filepath,vul_code,diff_target,patch_code
12052----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3e8b11ee7fe6fcfeb17e857340e23e4d4911142e_1.json----SSL_SESSION_free,"void SSL_SESSION_free(SSL_SESSION *ss) { int i; if(ss == NULL) return; i=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION); #ifdef REF_PRINT REF_PRINT(""SSL_SESSION"",ss); #endif if (i > 0) return; #ifdef REF_CHECK if (i < 0) { fprintf(stderr,""SSL_SESSION_free, bad reference count\n""); abort(); } #endif CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data); OPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg); OPENSSL_cleanse(ss->master_key,sizeof ss->master_key); OPENSSL_cleanse(ss->session_id,sizeof ss->session_id); if (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert); if (ss->peer != NULL) X509_free(ss->peer); if (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers); #ifndef OPENSSL_NO_TLSEXT if (ss->tlsext_hostname != NULL) OPENSSL_free(ss->tlsext_hostname); if (ss->tlsext_tick != NULL) OPENSSL_free(ss->tlsext_tick); #ifndef OPENSSL_NO_EC ss->tlsext_ecpointformatlist_length = 0; if (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist); ss->tlsext_ellipticcurvelist_length = 0; if (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist); #endif <S2SV_StartVul> if (ss->audit_proof != NULL) OPENSSL_free(ss->audit_proof); <S2SV_EndVul> <S2SV_StartVul> ss->audit_proof_length = 0; <S2SV_EndVul> #endif #ifndef OPENSSL_NO_PSK if (ss->psk_identity_hint != NULL) OPENSSL_free(ss->psk_identity_hint); if (ss->psk_identity != NULL) OPENSSL_free(ss->psk_identity); #endif #ifndef OPENSSL_NO_SRP if (ss->srp_username != NULL) OPENSSL_free(ss->srp_username); #endif OPENSSL_cleanse(ss,sizeof(*ss)); OPENSSL_free(ss); }","- if (ss->audit_proof != NULL) OPENSSL_free(ss->audit_proof);
- ss->audit_proof_length = 0;","void SSL_SESSION_free(SSL_SESSION *ss) { int i; if(ss == NULL) return; i=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION); #ifdef REF_PRINT REF_PRINT(""SSL_SESSION"",ss); #endif if (i > 0) return; #ifdef REF_CHECK if (i < 0) { fprintf(stderr,""SSL_SESSION_free, bad reference count\n""); abort(); } #endif CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data); OPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg); OPENSSL_cleanse(ss->master_key,sizeof ss->master_key); OPENSSL_cleanse(ss->session_id,sizeof ss->session_id); if (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert); if (ss->peer != NULL) X509_free(ss->peer); if (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers); #ifndef OPENSSL_NO_TLSEXT if (ss->tlsext_hostname != NULL) OPENSSL_free(ss->tlsext_hostname); if (ss->tlsext_tick != NULL) OPENSSL_free(ss->tlsext_tick); #ifndef OPENSSL_NO_EC ss->tlsext_ecpointformatlist_length = 0; if (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist); ss->tlsext_ellipticcurvelist_length = 0; if (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist); #endif #endif #ifndef OPENSSL_NO_PSK if (ss->psk_identity_hint != NULL) OPENSSL_free(ss->psk_identity_hint); if (ss->psk_identity != NULL) OPENSSL_free(ss->psk_identity); #endif #ifndef OPENSSL_NO_SRP if (ss->srp_username != NULL) OPENSSL_free(ss->srp_username); #endif OPENSSL_cleanse(ss,sizeof(*ss)); OPENSSL_free(ss); }"
652----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2352924e0fc310971e5383b08d56165af4aeec89_1.json----dxtory_decode_v1_420,"static int dxtory_decode_v1_420(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { int h, w; uint8_t *Y1, *Y2, *U, *V; int ret; <S2SV_StartVul> if (src_size < avctx->width * avctx->height * 3LL / 2) { <S2SV_EndVul> av_log(avctx, AV_LOG_ERROR, ""packet too small\n""); return AVERROR_INVALIDDATA; } avctx->pix_fmt = AV_PIX_FMT_YUV420P; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; Y1 = pic->data[0]; Y2 = pic->data[0] + pic->linesize[0]; U = pic->data[1]; V = pic->data[2]; for (h = 0; h < avctx->height; h += 2) { for (w = 0; w < avctx->width; w += 2) { AV_COPY16(Y1 + w, src); AV_COPY16(Y2 + w, src + 2); U[w >> 1] = src[4] + 0x80; V[w >> 1] = src[5] + 0x80; src += 6; } Y1 += pic->linesize[0] << 1; Y2 += pic->linesize[0] << 1; U += pic->linesize[1]; V += pic->linesize[2]; } return 0; }","- if (src_size < avctx->width * avctx->height * 3LL / 2) {
+ if (src_size < FFALIGN(avctx->width, 2) * FFALIGN(avctx->height, 2) * 3LL / 2) {","static int dxtory_decode_v1_420(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { int h, w; uint8_t *Y1, *Y2, *U, *V; int ret; if (src_size < FFALIGN(avctx->width, 2) * FFALIGN(avctx->height, 2) * 3LL / 2) { av_log(avctx, AV_LOG_ERROR, ""packet too small\n""); return AVERROR_INVALIDDATA; } avctx->pix_fmt = AV_PIX_FMT_YUV420P; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; Y1 = pic->data[0]; Y2 = pic->data[0] + pic->linesize[0]; U = pic->data[1]; V = pic->data[2]; for (h = 0; h < avctx->height; h += 2) { for (w = 0; w < avctx->width; w += 2) { AV_COPY16(Y1 + w, src); AV_COPY16(Y2 + w, src + 2); U[w >> 1] = src[4] + 0x80; V[w >> 1] = src[5] + 0x80; src += 6; } Y1 += pic->linesize[0] << 1; Y2 += pic->linesize[0] << 1; U += pic->linesize[1]; V += pic->linesize[2]; } return 0; }"
4663----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fb37c3e2bbabea7f396fdfca174c6922a1d7e3fb_1.json----new_audio_stream,"static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, int source_index) { int n; AVStream *st; OutputStream *ost; AVCodecContext *audio_enc; ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO, source_index); st = ost->st; audio_enc = st->codec; audio_enc->codec_type = AVMEDIA_TYPE_AUDIO; if (!ost->stream_copy) { <S2SV_StartVul> char *sample_fmt = NULL; <S2SV_EndVul> MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st); MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st); if (sample_fmt && (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) { av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt); exit_program(1); } MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st); <S2SV_StartVul> ost->rematrix_volume=1.0; <S2SV_EndVul> <S2SV_StartVul> MATCH_PER_STREAM_OPT(rematrix_volume, f, ost->rematrix_volume, oc, st); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> for (n = 0; n < o->nb_audio_channel_maps; n++) { <S2SV_EndVul> <S2SV_StartVul> AudioChannelMap *map = &o->audio_channel_maps[n]; <S2SV_EndVul> <S2SV_StartVul> InputStream *ist = input_streams[ost->source_index]; <S2SV_EndVul> <S2SV_StartVul> if ((map->channel_idx == -1 || (ist->file_index == map->file_idx && ist->st->index == map->stream_idx)) && <S2SV_EndVul> <S2SV_StartVul> (map->ofile_idx == -1 || ost->file_index == map->ofile_idx) && <S2SV_EndVul> <S2SV_StartVul> (map->ostream_idx == -1 || ost->st->index == map->ostream_idx)) { <S2SV_EndVul> <S2SV_StartVul> if (ost->audio_channels_mapped < FF_ARRAY_ELEMS(ost->audio_channels_map)) <S2SV_EndVul> <S2SV_StartVul> ost->audio_channels_map[ost->audio_channels_mapped++] = map->channel_idx; <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> av_log(NULL, AV_LOG_FATAL, ""Max channel mapping for output %d.%d reached\n"", <S2SV_EndVul> <S2SV_StartVul> ost->file_index, ost->st->index); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } return ost; }","- char *sample_fmt = NULL;
- ost->rematrix_volume=1.0;
- MATCH_PER_STREAM_OPT(rematrix_volume, f, ost->rematrix_volume, oc, st);
- }
- for (n = 0; n < o->nb_audio_channel_maps; n++) {
- AudioChannelMap *map = &o->audio_channel_maps[n];
- InputStream *ist = input_streams[ost->source_index];
- if ((map->channel_idx == -1 || (ist->file_index == map->file_idx && ist->st->index == map->stream_idx)) &&
- (map->ofile_idx == -1 || ost->file_index == map->ofile_idx) &&
- (map->ostream_idx == -1 || ost->st->index == map->ostream_idx)) {
- if (ost->audio_channels_mapped < FF_ARRAY_ELEMS(ost->audio_channels_map))
- ost->audio_channels_map[ost->audio_channels_mapped++] = map->channel_idx;
- else
- av_log(NULL, AV_LOG_FATAL, ""Max channel mapping for output %d.%d reached\n"",
- ost->file_index, ost->st->index);
- }
+ char *sample_fmt = NULL, *filters = NULL;;
+ MATCH_PER_STREAM_OPT(filters, str, filters, oc, st);
+ if (filters)
+ ost->avfilter = av_strdup(filters);","static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, int source_index) { int n; AVStream *st; OutputStream *ost; AVCodecContext *audio_enc; ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO, source_index); st = ost->st; audio_enc = st->codec; audio_enc->codec_type = AVMEDIA_TYPE_AUDIO; if (!ost->stream_copy) { char *sample_fmt = NULL, *filters = NULL;; MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st); MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st); if (sample_fmt && (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) { av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt); exit_program(1); } MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st); MATCH_PER_STREAM_OPT(filters, str, filters, oc, st); if (filters) ost->avfilter = av_strdup(filters); } return ost; }"
10369----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_03168f2f98f3735ab3ffdc01e8499d79e6b4f003_1.json----ctr_XOR,"<S2SV_StartVul> static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen) <S2SV_EndVul> { size_t i, n; if (in == NULL || inlen == 0) return; <S2SV_StartVul> n = inlen < cctx->keylen ? inlen : cctx->keylen; <S2SV_EndVul> for (i = 0; i < n; i++) <S2SV_StartVul> cctx->K[i] ^= in[i]; <S2SV_EndVul> <S2SV_StartVul> if (inlen <= cctx->keylen) <S2SV_EndVul> return; <S2SV_StartVul> n = inlen - cctx->keylen; <S2SV_EndVul> if (n > 16) { n = 16; } for (i = 0; i < n; i++) <S2SV_StartVul> cctx->V[i] ^= in[i + cctx->keylen]; <S2SV_EndVul> }","- static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen)
- n = inlen < cctx->keylen ? inlen : cctx->keylen;
- cctx->K[i] ^= in[i];
- if (inlen <= cctx->keylen)
- n = inlen - cctx->keylen;
- cctx->V[i] ^= in[i + cctx->keylen];
+ static void ctr_XOR(RAND_DRBG_CTR *ctr, const unsigned char *in, size_t inlen)
+ n = inlen < ctr->keylen ? inlen : ctr->keylen;
+ ctr->K[i] ^= in[i];
+ if (inlen <= ctr->keylen)
+ n = inlen - ctr->keylen;
+ ctr->V[i] ^= in[i + ctr->keylen];","static void ctr_XOR(RAND_DRBG_CTR *ctr, const unsigned char *in, size_t inlen) { size_t i, n; if (in == NULL || inlen == 0) return; n = inlen < ctr->keylen ? inlen : ctr->keylen; for (i = 0; i < n; i++) ctr->K[i] ^= in[i]; if (inlen <= ctr->keylen) return; n = inlen - ctr->keylen; if (n > 16) { n = 16; } for (i = 0; i < n; i++) ctr->V[i] ^= in[i + ctr->keylen]; }"
9015----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f216da225e8b66387d923e9e691e452d6338ab63_1.json----vorbis_parse_setup_hdr_mappings,"static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) { GetBitContext *gb = &vc->gb; <S2SV_StartVul> uint_fast8_t i, j; <S2SV_EndVul> vc->mapping_count = get_bits(gb, 6)+1; vc->mappings = av_mallocz(vc->mapping_count * sizeof(*vc->mappings)); AV_DEBUG("" There are %d mappings. \n"", vc->mapping_count); for (i = 0; i < vc->mapping_count; ++i) { vorbis_mapping *mapping_setup = &vc->mappings[i]; if (get_bits(gb, 16)) { av_log(vc->avccontext, AV_LOG_ERROR, ""Other mappings than type 0 are not compliant with the Vorbis I specification. \n""); return -1; } if (get_bits1(gb)) { mapping_setup->submaps = get_bits(gb, 4) + 1; } else { mapping_setup->submaps = 1; } if (get_bits1(gb)) { mapping_setup->coupling_steps = get_bits(gb, 8) + 1; mapping_setup->magnitude = av_mallocz(mapping_setup->coupling_steps * sizeof(*mapping_setup->magnitude)); mapping_setup->angle = av_mallocz(mapping_setup->coupling_steps * sizeof(*mapping_setup->angle)); for (j = 0; j < mapping_setup->coupling_steps; ++j) { GET_VALIDATED_INDEX(mapping_setup->magnitude[j], ilog(vc->audio_channels - 1), vc->audio_channels) GET_VALIDATED_INDEX(mapping_setup->angle[j], ilog(vc->audio_channels - 1), vc->audio_channels) } } else { mapping_setup->coupling_steps = 0; } <S2SV_StartVul> AV_DEBUG("" %d mapping coupling steps: %d \n"", i, mapping_setup->coupling_steps); <S2SV_EndVul> if (get_bits(gb, 2)) { <S2SV_StartVul> av_log(vc->avccontext, AV_LOG_ERROR, ""%d. mapping setup data invalid. \n"", i); <S2SV_EndVul> return -1; } if (mapping_setup->submaps>1) { mapping_setup->mux = av_mallocz(vc->audio_channels * sizeof(*mapping_setup->mux)); for (j = 0; j < vc->audio_channels; ++j) mapping_setup->mux[j] = get_bits(gb, 4); } for (j = 0; j < mapping_setup->submaps; ++j) { skip_bits(gb, 8); GET_VALIDATED_INDEX(mapping_setup->submap_floor[j], 8, vc->floor_count) GET_VALIDATED_INDEX(mapping_setup->submap_residue[j], 8, vc->residue_count) <S2SV_StartVul> AV_DEBUG("" %d mapping %d submap : floor %d, residue %d \n"", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]); <S2SV_EndVul> } } return 0; }","- uint_fast8_t i, j;
- AV_DEBUG("" %d mapping coupling steps: %d \n"", i, mapping_setup->coupling_steps);
- av_log(vc->avccontext, AV_LOG_ERROR, ""%d. mapping setup data invalid. \n"", i);
- AV_DEBUG("" %d mapping %d submap : floor %d, residue %d \n"", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);
+ unsigned i, j;
+ AV_DEBUG("" %u mapping coupling steps: %d\n"",
+ i, mapping_setup->coupling_steps);
+ av_log(vc->avccontext, AV_LOG_ERROR, ""%u. mapping setup data invalid.\n"", i);
+ AV_DEBUG("" %u mapping %u submap : floor %d, residue %d\n"",
+ i, j,
+ mapping_setup->submap_floor[j],
+ mapping_setup->submap_residue[j]);","static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) { GetBitContext *gb = &vc->gb; unsigned i, j; vc->mapping_count = get_bits(gb, 6)+1; vc->mappings = av_mallocz(vc->mapping_count * sizeof(*vc->mappings)); AV_DEBUG("" There are %d mappings. \n"", vc->mapping_count); for (i = 0; i < vc->mapping_count; ++i) { vorbis_mapping *mapping_setup = &vc->mappings[i]; if (get_bits(gb, 16)) { av_log(vc->avccontext, AV_LOG_ERROR, ""Other mappings than type 0 are not compliant with the Vorbis I specification. \n""); return -1; } if (get_bits1(gb)) { mapping_setup->submaps = get_bits(gb, 4) + 1; } else { mapping_setup->submaps = 1; } if (get_bits1(gb)) { mapping_setup->coupling_steps = get_bits(gb, 8) + 1; mapping_setup->magnitude = av_mallocz(mapping_setup->coupling_steps * sizeof(*mapping_setup->magnitude)); mapping_setup->angle = av_mallocz(mapping_setup->coupling_steps * sizeof(*mapping_setup->angle)); for (j = 0; j < mapping_setup->coupling_steps; ++j) { GET_VALIDATED_INDEX(mapping_setup->magnitude[j], ilog(vc->audio_channels - 1), vc->audio_channels) GET_VALIDATED_INDEX(mapping_setup->angle[j], ilog(vc->audio_channels - 1), vc->audio_channels) } } else { mapping_setup->coupling_steps = 0; } AV_DEBUG("" %u mapping coupling steps: %d\n"", i, mapping_setup->coupling_steps); if (get_bits(gb, 2)) { av_log(vc->avccontext, AV_LOG_ERROR, ""%u. mapping setup data invalid.\n"", i); return -1; } if (mapping_setup->submaps>1) { mapping_setup->mux = av_mallocz(vc->audio_channels * sizeof(*mapping_setup->mux)); for (j = 0; j < vc->audio_channels; ++j) mapping_setup->mux[j] = get_bits(gb, 4); } for (j = 0; j < mapping_setup->submaps; ++j) { skip_bits(gb, 8); GET_VALIDATED_INDEX(mapping_setup->submap_floor[j], 8, vc->floor_count) GET_VALIDATED_INDEX(mapping_setup->submap_residue[j], 8, vc->residue_count) AV_DEBUG("" %u mapping %u submap : floor %d, residue %d\n"", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]); } } return 0; }"
2772----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_98c3d061a8d08478686a0ef1520502161474da17_1.json----config_output,"static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; AVFilterLink *inlink = ctx->inputs[0]; ShowCQTContext *s = ctx->priv; int ret; common_uninit(s); outlink->w = s->width; outlink->h = s->height; s->format = outlink->format; outlink->sample_aspect_ratio = av_make_q(1, 1); outlink->frame_rate = s->rate; outlink->time_base = av_mul_q(av_inv_q(s->rate), av_make_q(1, PTS_STEP)); av_log(ctx, AV_LOG_INFO, ""video: %dx%d %s %d/%d fps, bar_h = %d, axis_h = %d, sono_h = %d.\n"", s->width, s->height, av_get_pix_fmt_name(s->format), s->rate.num, s->rate.den, s->bar_h, s->axis_h, s->sono_h); s->cqt_len = s->width * s->fcount; if (!(s->freq = create_freq_table(s->basefreq, s->endfreq, s->cqt_len))) return AVERROR(ENOMEM); if ((ret = init_volume(s)) < 0) return ret; s->fft_bits = FFMAX(ceil(log2(inlink->sample_rate * s->timeclamp)), 4); s->fft_len = 1 << s->fft_bits; av_log(ctx, AV_LOG_INFO, ""fft_len = %d, cqt_len = %d.\n"", s->fft_len, s->cqt_len); s->fft_ctx = av_fft_init(s->fft_bits, 0); s->fft_data = av_calloc(s->fft_len, sizeof(*s->fft_data)); s->fft_result = av_calloc(s->fft_len + 64, sizeof(*s->fft_result)); s->cqt_result = av_malloc_array(s->cqt_len, sizeof(*s->cqt_result)); if (!s->fft_ctx || !s->fft_data || !s->fft_result || !s->cqt_result) return AVERROR(ENOMEM); s->cqt_align = 1; s->cqt_calc = cqt_calc; s->permute_coeffs = NULL; s->draw_sono = draw_sono; if (s->format == AV_PIX_FMT_RGB24) { s->draw_bar = draw_bar_rgb; s->draw_axis = draw_axis_rgb; s->update_sono = update_sono_rgb; } else { s->draw_bar = draw_bar_yuv; s->draw_axis = draw_axis_yuv; s->update_sono = update_sono_yuv; } if (ARCH_X86) ff_showcqt_init_x86(s); if ((ret = init_cqt(s)) < 0) return ret; if (s->axis_h) { if (!s->axis) { if ((ret = init_axis_empty(s)) < 0) return ret; } else if (s->axisfile) { if (init_axis_from_file(s) < 0) { av_log(ctx, AV_LOG_WARNING, ""loading axis image failed, fallback to font rendering.\n""); if (init_axis_from_font(s) < 0) { av_log(ctx, AV_LOG_WARNING, ""loading axis font failed, disable text drawing.\n""); if ((ret = init_axis_empty(s)) < 0) return ret; } } } else { if (init_axis_from_font(s) < 0) { av_log(ctx, AV_LOG_WARNING, ""loading axis font failed, disable text drawing.\n""); if ((ret = init_axis_empty(s)) < 0) return ret; } } } if (s->sono_h) { s->sono_frame = alloc_frame_empty((outlink->format == AV_PIX_FMT_YUV420P) ? AV_PIX_FMT_YUV422P : outlink->format, s->width, s->sono_h); if (!s->sono_frame) return AVERROR(ENOMEM); } s->h_buf = av_malloc_array(s->cqt_len, sizeof (*s->h_buf)); s->rcp_h_buf = av_malloc_array(s->width, sizeof(*s->rcp_h_buf)); s->c_buf = av_malloc_array(s->width, sizeof(*s->c_buf)); if (!s->h_buf || !s->rcp_h_buf || !s->c_buf) return AVERROR(ENOMEM); s->sono_count = 0; s->next_pts = 0; s->sono_idx = 0; <S2SV_StartVul> s->remaining_fill = s->fft_len / 2; <S2SV_EndVul> s->remaining_frac = 0; s->step_frac = av_div_q(av_make_q(inlink->sample_rate, s->count) , s->rate); s->step = (int)(s->step_frac.num / s->step_frac.den); s->step_frac.num %= s->step_frac.den; if (s->step_frac.num) { av_log(ctx, AV_LOG_INFO, ""audio: %d Hz, step = %d + %d/%d.\n"", inlink->sample_rate, s->step, s->step_frac.num, s->step_frac.den); av_log(ctx, AV_LOG_WARNING, ""fractional step.\n""); } else { av_log(ctx, AV_LOG_INFO, ""audio: %d Hz, step = %d.\n"", inlink->sample_rate, s->step); } return 0; }","- s->remaining_fill = s->fft_len / 2;
+ s->remaining_fill_max = s->fft_len / 2;
+ if (s->attack > 0.0) {
+ int k;
+ s->remaining_fill_max = FFMIN(s->remaining_fill_max, ceil(inlink->sample_rate * s->attack));
+ s->attack_data = av_malloc_array(s->remaining_fill_max, sizeof(*s->attack_data));
+ if (!s->attack_data)
+ return AVERROR(ENOMEM);
+ for (k = 0; k < s->remaining_fill_max; k++) {
+ double y = M_PI * k / (inlink->sample_rate * s->attack);
+ s->attack_data[k] = 0.355768 + 0.487396 * cos(y) + 0.144232 * cos(2*y) + 0.012604 * cos(3*y);
+ }
+ }
+ s->remaining_fill = s->remaining_fill_max;","static int config_output(AVFilterLink *outlink) { AVFilterContext *ctx = outlink->src; AVFilterLink *inlink = ctx->inputs[0]; ShowCQTContext *s = ctx->priv; int ret; common_uninit(s); outlink->w = s->width; outlink->h = s->height; s->format = outlink->format; outlink->sample_aspect_ratio = av_make_q(1, 1); outlink->frame_rate = s->rate; outlink->time_base = av_mul_q(av_inv_q(s->rate), av_make_q(1, PTS_STEP)); av_log(ctx, AV_LOG_INFO, ""video: %dx%d %s %d/%d fps, bar_h = %d, axis_h = %d, sono_h = %d.\n"", s->width, s->height, av_get_pix_fmt_name(s->format), s->rate.num, s->rate.den, s->bar_h, s->axis_h, s->sono_h); s->cqt_len = s->width * s->fcount; if (!(s->freq = create_freq_table(s->basefreq, s->endfreq, s->cqt_len))) return AVERROR(ENOMEM); if ((ret = init_volume(s)) < 0) return ret; s->fft_bits = FFMAX(ceil(log2(inlink->sample_rate * s->timeclamp)), 4); s->fft_len = 1 << s->fft_bits; av_log(ctx, AV_LOG_INFO, ""fft_len = %d, cqt_len = %d.\n"", s->fft_len, s->cqt_len); s->fft_ctx = av_fft_init(s->fft_bits, 0); s->fft_data = av_calloc(s->fft_len, sizeof(*s->fft_data)); s->fft_result = av_calloc(s->fft_len + 64, sizeof(*s->fft_result)); s->cqt_result = av_malloc_array(s->cqt_len, sizeof(*s->cqt_result)); if (!s->fft_ctx || !s->fft_data || !s->fft_result || !s->cqt_result) return AVERROR(ENOMEM); s->remaining_fill_max = s->fft_len / 2; if (s->attack > 0.0) { int k; s->remaining_fill_max = FFMIN(s->remaining_fill_max, ceil(inlink->sample_rate * s->attack)); s->attack_data = av_malloc_array(s->remaining_fill_max, sizeof(*s->attack_data)); if (!s->attack_data) return AVERROR(ENOMEM); for (k = 0; k < s->remaining_fill_max; k++) { double y = M_PI * k / (inlink->sample_rate * s->attack); s->attack_data[k] = 0.355768 + 0.487396 * cos(y) + 0.144232 * cos(2*y) + 0.012604 * cos(3*y); } } s->cqt_align = 1; s->cqt_calc = cqt_calc; s->permute_coeffs = NULL; s->draw_sono = draw_sono; if (s->format == AV_PIX_FMT_RGB24) { s->draw_bar = draw_bar_rgb; s->draw_axis = draw_axis_rgb; s->update_sono = update_sono_rgb; } else { s->draw_bar = draw_bar_yuv; s->draw_axis = draw_axis_yuv; s->update_sono = update_sono_yuv; } if (ARCH_X86) ff_showcqt_init_x86(s); if ((ret = init_cqt(s)) < 0) return ret; if (s->axis_h) { if (!s->axis) { if ((ret = init_axis_empty(s)) < 0) return ret; } else if (s->axisfile) { if (init_axis_from_file(s) < 0) { av_log(ctx, AV_LOG_WARNING, ""loading axis image failed, fallback to font rendering.\n""); if (init_axis_from_font(s) < 0) { av_log(ctx, AV_LOG_WARNING, ""loading axis font failed, disable text drawing.\n""); if ((ret = init_axis_empty(s)) < 0) return ret; } } } else { if (init_axis_from_font(s) < 0) { av_log(ctx, AV_LOG_WARNING, ""loading axis font failed, disable text drawing.\n""); if ((ret = init_axis_empty(s)) < 0) return ret; } } } if (s->sono_h) { s->sono_frame = alloc_frame_empty((outlink->format == AV_PIX_FMT_YUV420P) ? AV_PIX_FMT_YUV422P : outlink->format, s->width, s->sono_h); if (!s->sono_frame) return AVERROR(ENOMEM); } s->h_buf = av_malloc_array(s->cqt_len, sizeof (*s->h_buf)); s->rcp_h_buf = av_malloc_array(s->width, sizeof(*s->rcp_h_buf)); s->c_buf = av_malloc_array(s->width, sizeof(*s->c_buf)); if (!s->h_buf || !s->rcp_h_buf || !s->c_buf) return AVERROR(ENOMEM); s->sono_count = 0; s->next_pts = 0; s->sono_idx = 0; s->remaining_fill = s->remaining_fill_max; s->remaining_frac = 0; s->step_frac = av_div_q(av_make_q(inlink->sample_rate, s->count) , s->rate); s->step = (int)(s->step_frac.num / s->step_frac.den); s->step_frac.num %= s->step_frac.den; if (s->step_frac.num) { av_log(ctx, AV_LOG_INFO, ""audio: %d Hz, step = %d + %d/%d.\n"", inlink->sample_rate, s->step, s->step_frac.num, s->step_frac.den); av_log(ctx, AV_LOG_WARNING, ""fractional step.\n""); } else { av_log(ctx, AV_LOG_INFO, ""audio: %d Hz, step = %d.\n"", inlink->sample_rate, s->step); } return 0; }"
7285----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8ac04d5aecb0a3919ae92fb965af007105db0ef2_1.json----ff_h263_decode_init,"int ff_h263_decode_init(AVCodecContext *avctx) { MpegEncContext *s = avctx->priv_data; int ret; s->avctx = avctx; s->out_format = FMT_H263; s->width = avctx->coded_width; s->height = avctx->coded_height; s->workaround_bugs = avctx->workaround_bugs; ff_MPV_decode_defaults(s); s->quant_precision = 5; s->decode_mb = ff_h263_decode_mb; s->low_delay = 1; if (avctx->codec->id == AV_CODEC_ID_MSS2) avctx->pix_fmt = AV_PIX_FMT_YUV420P; else avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts); s->unrestricted_mv = 1; switch (avctx->codec->id) { case AV_CODEC_ID_H263: s->unrestricted_mv = 0; avctx->chroma_sample_location = AVCHROMA_LOC_CENTER; break; case AV_CODEC_ID_MPEG4: break; case AV_CODEC_ID_MSMPEG4V1: s->h263_pred = 1; s->msmpeg4_version = 1; break; case AV_CODEC_ID_MSMPEG4V2: s->h263_pred = 1; s->msmpeg4_version = 2; break; case AV_CODEC_ID_MSMPEG4V3: s->h263_pred = 1; s->msmpeg4_version = 3; break; case AV_CODEC_ID_WMV1: s->h263_pred = 1; s->msmpeg4_version = 4; break; case AV_CODEC_ID_WMV2: s->h263_pred = 1; s->msmpeg4_version = 5; break; case AV_CODEC_ID_VC1: case AV_CODEC_ID_WMV3: case AV_CODEC_ID_VC1IMAGE: case AV_CODEC_ID_WMV3IMAGE: case AV_CODEC_ID_MSS2: s->h263_pred = 1; s->msmpeg4_version = 6; avctx->chroma_sample_location = AVCHROMA_LOC_LEFT; break; case AV_CODEC_ID_H263I: break; case AV_CODEC_ID_FLV1: s->h263_flv = 1; break; default: av_log(avctx, AV_LOG_ERROR, ""Unsupported codec %d\n"", avctx->codec->id); return AVERROR(ENOSYS); } s->codec_id = avctx->codec->id; if (avctx->codec->id != AV_CODEC_ID_H263 && <S2SV_StartVul> avctx->codec->id != AV_CODEC_ID_MPEG4) <S2SV_EndVul> if ((ret = ff_MPV_common_init(s)) < 0) return ret; ff_h263dsp_init(&s->h263dsp); ff_qpeldsp_init(&s->qdsp); ff_h263_decode_init_vlc(); return 0; }","- avctx->codec->id != AV_CODEC_ID_MPEG4)
+ avctx->codec->id != AV_CODEC_ID_MPEG4) {
+ ff_mpv_idct_init(s);
+ }","int ff_h263_decode_init(AVCodecContext *avctx) { MpegEncContext *s = avctx->priv_data; int ret; s->avctx = avctx; s->out_format = FMT_H263; s->width = avctx->coded_width; s->height = avctx->coded_height; s->workaround_bugs = avctx->workaround_bugs; ff_MPV_decode_defaults(s); s->quant_precision = 5; s->decode_mb = ff_h263_decode_mb; s->low_delay = 1; if (avctx->codec->id == AV_CODEC_ID_MSS2) avctx->pix_fmt = AV_PIX_FMT_YUV420P; else avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts); s->unrestricted_mv = 1; switch (avctx->codec->id) { case AV_CODEC_ID_H263: s->unrestricted_mv = 0; avctx->chroma_sample_location = AVCHROMA_LOC_CENTER; break; case AV_CODEC_ID_MPEG4: break; case AV_CODEC_ID_MSMPEG4V1: s->h263_pred = 1; s->msmpeg4_version = 1; break; case AV_CODEC_ID_MSMPEG4V2: s->h263_pred = 1; s->msmpeg4_version = 2; break; case AV_CODEC_ID_MSMPEG4V3: s->h263_pred = 1; s->msmpeg4_version = 3; break; case AV_CODEC_ID_WMV1: s->h263_pred = 1; s->msmpeg4_version = 4; break; case AV_CODEC_ID_WMV2: s->h263_pred = 1; s->msmpeg4_version = 5; break; case AV_CODEC_ID_VC1: case AV_CODEC_ID_WMV3: case AV_CODEC_ID_VC1IMAGE: case AV_CODEC_ID_WMV3IMAGE: case AV_CODEC_ID_MSS2: s->h263_pred = 1; s->msmpeg4_version = 6; avctx->chroma_sample_location = AVCHROMA_LOC_LEFT; break; case AV_CODEC_ID_H263I: break; case AV_CODEC_ID_FLV1: s->h263_flv = 1; break; default: av_log(avctx, AV_LOG_ERROR, ""Unsupported codec %d\n"", avctx->codec->id); return AVERROR(ENOSYS); } s->codec_id = avctx->codec->id; if (avctx->codec->id != AV_CODEC_ID_H263 && avctx->codec->id != AV_CODEC_ID_MPEG4) { ff_mpv_idct_init(s); if ((ret = ff_MPV_common_init(s)) < 0) return ret; } ff_h263dsp_init(&s->h263dsp); ff_qpeldsp_init(&s->qdsp); ff_h263_decode_init_vlc(); return 0; }"
10013----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_6c8f2f377d14d3e086874efbf2c8d1417e58d91f_1.json----ngx_http_map,"static char * ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf) { ngx_int_t rc, index; ngx_str_t *value, file, name; ngx_uint_t i, key; ngx_http_map_conf_ctx_t *ctx; ngx_http_variable_value_t *var, **vp; ctx = cf->ctx; value = cf->args->elts; if (cf->args->nelts == 1 && ngx_strcmp(value[0].data, ""hostnames"") == 0) { ctx->hostnames = 1; return NGX_CONF_OK; } else if (cf->args->nelts != 2) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid number of the map parameters""); return NGX_CONF_ERROR; } if (ngx_strcmp(value[0].data, ""include"") == 0) { file = value[1]; if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) { return NGX_CONF_ERROR; } ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data); return ngx_conf_parse(cf, &file); } if (value[1].data[0] == '$') { name = value[1]; name.len--; name.data++; index = ngx_http_get_variable_index(ctx->cf, &name); if (index == NGX_ERROR) { return NGX_CONF_ERROR; } var = ctx->var_values.elts; for (i = 0; i < ctx->var_values.nelts; i++) { if (index == (ngx_int_t) var[i].data) { goto found; } } <S2SV_StartVul> var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t)); <S2SV_EndVul> if (var == NULL) { return NGX_CONF_ERROR; } var->valid = 0; var->no_cacheable = 0; var->not_found = 0; var->len = 0; var->data = (u_char *) index; <S2SV_StartVul> vp = ngx_array_push(&ctx->var_values); <S2SV_EndVul> <S2SV_StartVul> if (vp == NULL) { <S2SV_EndVul> <S2SV_StartVul> return NGX_CONF_ERROR; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> *vp = var; <S2SV_EndVul> goto found; } key = 0; for (i = 0; i < value[1].len; i++) { key = ngx_hash(key, value[1].data[i]); } key %= ctx->keys.hsize; vp = ctx->values_hash[key].elts; if (vp) { for (i = 0; i < ctx->values_hash[key].nelts; i++) { if (value[1].len != (size_t) vp[i]->len) { continue; } if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) { var = vp[i]; goto found; } } } else { if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4, sizeof(ngx_http_variable_value_t *)) != NGX_OK) { return NGX_CONF_ERROR; } } var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t)); if (var == NULL) { return NGX_CONF_ERROR; } var->len = value[1].len; var->data = ngx_pstrdup(ctx->keys.pool, &value[1]); if (var->data == NULL) { return NGX_CONF_ERROR; } var->valid = 1; var->no_cacheable = 0; var->not_found = 0; vp = ngx_array_push(&ctx->values_hash[key]); if (vp == NULL) { return NGX_CONF_ERROR; } *vp = var; found: if (ngx_strcmp(value[0].data, ""default"") == 0) { if (ctx->default_value) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""duplicate default map parameter""); return NGX_CONF_ERROR; } ctx->default_value = var; return NGX_CONF_OK; } #if (NGX_PCRE) if (value[0].len && value[0].data[0] == '~') { ngx_regex_compile_t rc; ngx_http_map_regex_t *regex; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_array_push(&ctx->regexes); if (regex == NULL) { return NGX_CONF_ERROR; } value[0].len--; value[0].data++; ngx_memzero(&rc, sizeof(ngx_regex_compile_t)); if (value[0].data[0] == '*') { value[0].len--; value[0].data++; rc.options = NGX_REGEX_CASELESS; } rc.pattern = value[0]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; regex->regex = ngx_http_regex_compile(ctx->cf, &rc); if (regex->regex == NULL) { return NGX_CONF_ERROR; } regex->value = var; return NGX_CONF_OK; } #endif if (value[0].len && value[0].data[0] == '\\') { value[0].len--; value[0].data++; } rc = ngx_hash_add_key(&ctx->keys, &value[0], var, (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0); if (rc == NGX_OK) { return NGX_CONF_OK; } if (rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid hostname or wildcard \""%V\"""", &value[0]); } if (rc == NGX_BUSY) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""conflicting parameter \""%V\"""", &value[0]); } return NGX_CONF_ERROR; }","- var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t));
- vp = ngx_array_push(&ctx->var_values);
- if (vp == NULL) {
- return NGX_CONF_ERROR;
- }
+ var = &var[i];
+ var = ngx_array_push(&ctx->var_values);","static char * ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf) { ngx_int_t rc, index; ngx_str_t *value, file, name; ngx_uint_t i, key; ngx_http_map_conf_ctx_t *ctx; ngx_http_variable_value_t *var, **vp; ctx = cf->ctx; value = cf->args->elts; if (cf->args->nelts == 1 && ngx_strcmp(value[0].data, ""hostnames"") == 0) { ctx->hostnames = 1; return NGX_CONF_OK; } else if (cf->args->nelts != 2) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid number of the map parameters""); return NGX_CONF_ERROR; } if (ngx_strcmp(value[0].data, ""include"") == 0) { file = value[1]; if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) { return NGX_CONF_ERROR; } ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data); return ngx_conf_parse(cf, &file); } if (value[1].data[0] == '$') { name = value[1]; name.len--; name.data++; index = ngx_http_get_variable_index(ctx->cf, &name); if (index == NGX_ERROR) { return NGX_CONF_ERROR; } var = ctx->var_values.elts; for (i = 0; i < ctx->var_values.nelts; i++) { if (index == (ngx_int_t) var[i].data) { var = &var[i]; goto found; } } var = ngx_array_push(&ctx->var_values); if (var == NULL) { return NGX_CONF_ERROR; } var->valid = 0; var->no_cacheable = 0; var->not_found = 0; var->len = 0; var->data = (u_char *) index; goto found; } key = 0; for (i = 0; i < value[1].len; i++) { key = ngx_hash(key, value[1].data[i]); } key %= ctx->keys.hsize; vp = ctx->values_hash[key].elts; if (vp) { for (i = 0; i < ctx->values_hash[key].nelts; i++) { if (value[1].len != (size_t) vp[i]->len) { continue; } if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) { var = vp[i]; goto found; } } } else { if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4, sizeof(ngx_http_variable_value_t *)) != NGX_OK) { return NGX_CONF_ERROR; } } var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t)); if (var == NULL) { return NGX_CONF_ERROR; } var->len = value[1].len; var->data = ngx_pstrdup(ctx->keys.pool, &value[1]); if (var->data == NULL) { return NGX_CONF_ERROR; } var->valid = 1; var->no_cacheable = 0; var->not_found = 0; vp = ngx_array_push(&ctx->values_hash[key]); if (vp == NULL) { return NGX_CONF_ERROR; } *vp = var; found: if (ngx_strcmp(value[0].data, ""default"") == 0) { if (ctx->default_value) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""duplicate default map parameter""); return NGX_CONF_ERROR; } ctx->default_value = var; return NGX_CONF_OK; } #if (NGX_PCRE) if (value[0].len && value[0].data[0] == '~') { ngx_regex_compile_t rc; ngx_http_map_regex_t *regex; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_array_push(&ctx->regexes); if (regex == NULL) { return NGX_CONF_ERROR; } value[0].len--; value[0].data++; ngx_memzero(&rc, sizeof(ngx_regex_compile_t)); if (value[0].data[0] == '*') { value[0].len--; value[0].data++; rc.options = NGX_REGEX_CASELESS; } rc.pattern = value[0]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; regex->regex = ngx_http_regex_compile(ctx->cf, &rc); if (regex->regex == NULL) { return NGX_CONF_ERROR; } regex->value = var; return NGX_CONF_OK; } #endif if (value[0].len && value[0].data[0] == '\\') { value[0].len--; value[0].data++; } rc = ngx_hash_add_key(&ctx->keys, &value[0], var, (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0); if (rc == NGX_OK) { return NGX_CONF_OK; } if (rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid hostname or wildcard \""%V\"""", &value[0]); } if (rc == NGX_BUSY) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""conflicting parameter \""%V\"""", &value[0]); } return NGX_CONF_ERROR; }"
4855----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_862c138fb262c4729661ef8db4144b5411ac1321_1.json----ap_get_mime_headers_core,"AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb) { char *last_field = NULL; apr_size_t last_len = 0; apr_size_t alloc_len = 0; char *field; char *value; apr_size_t len; int fields_read = 0; char *tmp_field; core_server_config *conf = ap_get_core_module_config(r->server->module_config); while(1) { apr_status_t rv; field = NULL; rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2, &len, r, 0, bb); if (rv != APR_SUCCESS) { if (APR_STATUS_IS_TIMEUP(rv)) { r->status = HTTP_REQUEST_TIME_OUT; } else { r->status = HTTP_BAD_REQUEST; } if (rv == APR_ENOSPC) { const char *field_escaped; if (field && len) { field[len - 1] = '\0'; field_escaped = ap_escape_html(r->pool, field); } else { field_escaped = field = """"; } apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Size of a request header field "" ""exceeds server limit.<br />\n"" ""<pre>\n%.*s\n</pre>\n"", field_name_len(field_escaped), field_escaped)); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561) ""Request header exceeds LimitRequestFieldSize%s"" ""%.*s"", *field ? "": "" : """", field_name_len(field), field); } return; } <S2SV_StartVul> if ((*field == '\t') || *field == ' ') { <S2SV_EndVul> apr_size_t fold_len; if (last_field == NULL) { r->status = HTTP_BAD_REQUEST; ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03442) ""Line folding encounterd before first"" "" header line""); return; } fold_len = last_len + len + 1; if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) { const char *field_escaped; r->status = HTTP_BAD_REQUEST; field_escaped = ap_escape_html(r->pool, last_field); apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Size of a request header field "" ""after folding "" ""exceeds server limit.<br />\n"" ""<pre>\n%.*s\n</pre>\n"", field_name_len(field_escaped), field_escaped)); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562) ""Request header exceeds LimitRequestFieldSize "" ""after folding: %.*s"", field_name_len(last_field), last_field); return; } if (fold_len > alloc_len) { char *fold_buf; alloc_len += alloc_len; if (fold_len > alloc_len) { alloc_len = fold_len; } fold_buf = (char *)apr_palloc(r->pool, alloc_len); memcpy(fold_buf, last_field, last_len); last_field = fold_buf; } memcpy(last_field + last_len, field, len +1); if (conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT) { last_field[last_len] = ' '; } last_len += len; continue; } else if (last_field != NULL) { if (r->server->limit_req_fields && (++fields_read > r->server->limit_req_fields)) { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", ""The number of request header fields "" ""exceeds this server's limit.""); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563) ""Number of request headers exceeds "" ""LimitRequestFields""); return; } if (!(conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT)) { if (!(value = strchr(last_field, ':'))) { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Request header field is "" ""missing ':' separator.<br />\n"" ""<pre>\n%.*s</pre>\n"", (int)LOG_NAME_MAX_LEN, ap_escape_html(r->pool, last_field))); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564) ""Request header field is missing ':' "" ""separator: %.*s"", (int)LOG_NAME_MAX_LEN, last_field); return; } tmp_field = value - 1; *value++ = '\0'; while (*value == ' ' || *value == '\t') { ++value; } while (tmp_field > last_field && (*tmp_field == ' ' || *tmp_field == '\t')) { *tmp_field-- = '\0'; } <S2SV_StartVul> tmp_field = last_field + last_len - 1; <S2SV_EndVul> <S2SV_StartVul> while (tmp_field > value <S2SV_EndVul> <S2SV_StartVul> && (*tmp_field == ' ' || *tmp_field == '\t')) { <S2SV_EndVul> <S2SV_StartVul> *tmp_field-- = '\0'; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } else { value = (char *)ap_scan_http_token(last_field); if ((value == last_field) || *value != ':') { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Request header field name "" ""is malformed.<br />\n"" ""<pre>\n%.*s</pre>\n"", (int)LOG_NAME_MAX_LEN, ap_escape_html(r->pool, last_field))); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02426) ""Request header field name is malformed: "" ""%.*s"", (int)LOG_NAME_MAX_LEN, last_field); return; } *value++ = '\0'; while (*value == ' ' || *value == '\t') { ++value; } tmp_field = (char *)ap_scan_http_field_content(value); <S2SV_StartVul> if (*value && (*tmp_field == '\0')) { <S2SV_EndVul> <S2SV_StartVul> tmp_field--; <S2SV_EndVul> <S2SV_StartVul> while (*tmp_field == ' ' || *tmp_field == '\t') { <S2SV_EndVul> <S2SV_StartVul> *tmp_field-- = '\0'; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> ++tmp_field; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (*tmp_field != '\0') { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Request header value "" ""is malformed.<br />\n"" ""<pre>\n%.*s</pre>\n"", (int)LOG_NAME_MAX_LEN, ap_escape_html(r->pool, value))); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02427) ""Request header value is malformed: "" ""%.*s"", (int)LOG_NAME_MAX_LEN, value); return; } } apr_table_addn(r->headers_in, last_field, value); } if (len == 0) { break; } alloc_len = 0; last_field = field; last_len = len; } apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE); apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL); }","- if ((*field == '\t') || *field == ' ') {
- tmp_field = last_field + last_len - 1;
- while (tmp_field > value
- && (*tmp_field == ' ' || *tmp_field == '\t')) {
- }
- if (*value && (*tmp_field == '\0')) {
- tmp_field--;
- while (*tmp_field == ' ' || *tmp_field == '\t') {
- }
- ++tmp_field;
- }
+ while (len > 1 && (field[len-1] == '\t' || field[len-1] == ' ')) {
+ field[--len] = '\0';
+ }
+ if (*field == '\t' || *field == ' ') {","AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb) { char *last_field = NULL; apr_size_t last_len = 0; apr_size_t alloc_len = 0; char *field; char *value; apr_size_t len; int fields_read = 0; char *tmp_field; core_server_config *conf = ap_get_core_module_config(r->server->module_config); while(1) { apr_status_t rv; field = NULL; rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2, &len, r, 0, bb); if (rv != APR_SUCCESS) { if (APR_STATUS_IS_TIMEUP(rv)) { r->status = HTTP_REQUEST_TIME_OUT; } else { r->status = HTTP_BAD_REQUEST; } if (rv == APR_ENOSPC) { const char *field_escaped; if (field && len) { field[len - 1] = '\0'; field_escaped = ap_escape_html(r->pool, field); } else { field_escaped = field = """"; } apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Size of a request header field "" ""exceeds server limit.<br />\n"" ""<pre>\n%.*s\n</pre>\n"", field_name_len(field_escaped), field_escaped)); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561) ""Request header exceeds LimitRequestFieldSize%s"" ""%.*s"", *field ? "": "" : """", field_name_len(field), field); } return; } while (len > 1 && (field[len-1] == '\t' || field[len-1] == ' ')) { field[--len] = '\0'; } if (*field == '\t' || *field == ' ') { apr_size_t fold_len; if (last_field == NULL) { r->status = HTTP_BAD_REQUEST; ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03442) ""Line folding encounterd before first"" "" header line""); return; } fold_len = last_len + len + 1; if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) { const char *field_escaped; r->status = HTTP_BAD_REQUEST; field_escaped = ap_escape_html(r->pool, last_field); apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Size of a request header field "" ""after folding "" ""exceeds server limit.<br />\n"" ""<pre>\n%.*s\n</pre>\n"", field_name_len(field_escaped), field_escaped)); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562) ""Request header exceeds LimitRequestFieldSize "" ""after folding: %.*s"", field_name_len(last_field), last_field); return; } if (fold_len > alloc_len) { char *fold_buf; alloc_len += alloc_len; if (fold_len > alloc_len) { alloc_len = fold_len; } fold_buf = (char *)apr_palloc(r->pool, alloc_len); memcpy(fold_buf, last_field, last_len); last_field = fold_buf; } memcpy(last_field + last_len, field, len +1); if (conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT) { last_field[last_len] = ' '; } last_len += len; continue; } else if (last_field != NULL) { if (r->server->limit_req_fields && (++fields_read > r->server->limit_req_fields)) { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", ""The number of request header fields "" ""exceeds this server's limit.""); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563) ""Number of request headers exceeds "" ""LimitRequestFields""); return; } if (!(conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT)) { if (!(value = strchr(last_field, ':'))) { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Request header field is "" ""missing ':' separator.<br />\n"" ""<pre>\n%.*s</pre>\n"", (int)LOG_NAME_MAX_LEN, ap_escape_html(r->pool, last_field))); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564) ""Request header field is missing ':' "" ""separator: %.*s"", (int)LOG_NAME_MAX_LEN, last_field); return; } tmp_field = value - 1; *value++ = '\0'; while (*value == ' ' || *value == '\t') { ++value; } while (tmp_field > last_field && (*tmp_field == ' ' || *tmp_field == '\t')) { *tmp_field-- = '\0'; } } else { value = (char *)ap_scan_http_token(last_field); if ((value == last_field) || *value != ':') { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Request header field name "" ""is malformed.<br />\n"" ""<pre>\n%.*s</pre>\n"", (int)LOG_NAME_MAX_LEN, ap_escape_html(r->pool, last_field))); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02426) ""Request header field name is malformed: "" ""%.*s"", (int)LOG_NAME_MAX_LEN, last_field); return; } *value++ = '\0'; while (*value == ' ' || *value == '\t') { ++value; } tmp_field = (char *)ap_scan_http_field_content(value); if (*tmp_field != '\0') { r->status = HTTP_BAD_REQUEST; apr_table_setn(r->notes, ""error-notes"", apr_psprintf(r->pool, ""Request header value "" ""is malformed.<br />\n"" ""<pre>\n%.*s</pre>\n"", (int)LOG_NAME_MAX_LEN, ap_escape_html(r->pool, value))); ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02427) ""Request header value is malformed: "" ""%.*s"", (int)LOG_NAME_MAX_LEN, value); return; } } apr_table_addn(r->headers_in, last_field, value); } if (len == 0) { break; } alloc_len = 0; last_field = field; last_len = len; } apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE); apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL); }"
5266----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1233805ab017e35822814c4434650d3dd06a45de_1.json----select_input_picture,"static int select_input_picture(MpegEncContext *s) { int i, ret; for (i = 1; i < MAX_PICTURE_COUNT; i++) s->reordered_input_picture[i - 1] = s->reordered_input_picture[i]; s->reordered_input_picture[MAX_PICTURE_COUNT - 1] = NULL; if (!s->reordered_input_picture[0] && s->input_picture[0]) { if ( !s->next_picture_ptr || s->intra_only) { s->reordered_input_picture[0] = s->input_picture[0]; s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_I; s->reordered_input_picture[0]->f->coded_picture_number = s->coded_picture_number++; } else { int b_frames; if (s->avctx->frame_skip_threshold || s->avctx->frame_skip_factor) { if (s->picture_in_gop_number < s->gop_size && skip_check(s, s->input_picture[0], s->next_picture_ptr)) { av_frame_unref(s->input_picture[0]->f); emms_c(); ff_vbv_update(s, 0); goto no_output_pic; } } if (s->avctx->flags & CODEC_FLAG_PASS2) { for (i = 0; i < s->max_b_frames + 1; i++) { int pict_num = s->input_picture[0]->f->display_picture_number + i; if (pict_num >= s->rc_context.num_entries) break; if (!s->input_picture[i]) { s->rc_context.entry[pict_num - 1].new_pict_type = AV_PICTURE_TYPE_P; break; } s->input_picture[i]->f->pict_type = s->rc_context.entry[pict_num].new_pict_type; } } if (s->avctx->b_frame_strategy == 0) { b_frames = s->max_b_frames; while (b_frames && !s->input_picture[b_frames]) b_frames--; } else if (s->avctx->b_frame_strategy == 1) { for (i = 1; i < s->max_b_frames + 1; i++) { if (s->input_picture[i] && s->input_picture[i]->b_frame_score == 0) { s->input_picture[i]->b_frame_score = get_intra_count(s, s->input_picture[i ]->f->data[0], s->input_picture[i - 1]->f->data[0], s->linesize) + 1; } } for (i = 0; i < s->max_b_frames + 1; i++) { if (!s->input_picture[i] || s->input_picture[i]->b_frame_score - 1 > s->mb_num / s->avctx->b_sensitivity) break; } b_frames = FFMAX(0, i - 1); for (i = 0; i < b_frames + 1; i++) { s->input_picture[i]->b_frame_score = 0; } } else if (s->avctx->b_frame_strategy == 2) { b_frames = estimate_best_b_count(s); } else { av_log(s->avctx, AV_LOG_ERROR, ""illegal b frame strategy\n""); b_frames = 0; } emms_c(); for (i = b_frames - 1; i >= 0; i--) { int type = s->input_picture[i]->f->pict_type; if (type && type != AV_PICTURE_TYPE_B) b_frames = i; } if (s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_B && b_frames == s->max_b_frames) { av_log(s->avctx, AV_LOG_ERROR, ""warning, too many b frames in a row\n""); } if (s->picture_in_gop_number + b_frames >= s->gop_size) { if ((s->mpv_flags & FF_MPV_FLAG_STRICT_GOP) && s->gop_size > s->picture_in_gop_number) { b_frames = s->gop_size - s->picture_in_gop_number - 1; } else { if (s->avctx->flags & CODEC_FLAG_CLOSED_GOP) b_frames = 0; s->input_picture[b_frames]->f->pict_type = AV_PICTURE_TYPE_I; } } if ((s->avctx->flags & CODEC_FLAG_CLOSED_GOP) && b_frames && s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_I) b_frames--; s->reordered_input_picture[0] = s->input_picture[b_frames]; if (s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_I) s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_P; s->reordered_input_picture[0]->f->coded_picture_number = s->coded_picture_number++; for (i = 0; i < b_frames; i++) { s->reordered_input_picture[i + 1] = s->input_picture[i]; s->reordered_input_picture[i + 1]->f->pict_type = AV_PICTURE_TYPE_B; s->reordered_input_picture[i + 1]->f->coded_picture_number = s->coded_picture_number++; } } } no_output_pic: if (s->reordered_input_picture[0]) { s->reordered_input_picture[0]->reference = s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_B ? 3 : 0; <S2SV_StartVul> ff_mpeg_unref_picture(s, &s->new_picture); <S2SV_EndVul> if ((ret = ff_mpeg_ref_picture(s, &s->new_picture, s->reordered_input_picture[0]))) return ret; if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) { Picture *pic; int i = ff_find_unused_picture(s, 0); if (i < 0) return i; pic = &s->picture[i]; pic->reference = s->reordered_input_picture[0]->reference; if (ff_alloc_picture(s, pic, 0) < 0) { return -1; } ret = av_frame_copy_props(pic->f, s->reordered_input_picture[0]->f); if (ret < 0) return ret; av_frame_unref(s->reordered_input_picture[0]->f); s->reordered_input_picture[0]->shared = 0; s->current_picture_ptr = pic; } else { s->current_picture_ptr = s->reordered_input_picture[0]; for (i = 0; i < 4; i++) { s->new_picture.f->data[i] += INPLACE_OFFSET; } } <S2SV_StartVul> ff_mpeg_unref_picture(s, &s->current_picture); <S2SV_EndVul> if ((ret = ff_mpeg_ref_picture(s, &s->current_picture, s->current_picture_ptr)) < 0) return ret; s->picture_number = s->new_picture.f->display_picture_number; } else { <S2SV_StartVul> ff_mpeg_unref_picture(s, &s->new_picture); <S2SV_EndVul> } return 0; }","- ff_mpeg_unref_picture(s, &s->new_picture);
- ff_mpeg_unref_picture(s, &s->current_picture);
- ff_mpeg_unref_picture(s, &s->new_picture);
+ ff_mpeg_unref_picture(s->avctx, &s->new_picture);
+ ff_mpeg_unref_picture(s->avctx, &s->current_picture);
+ ff_mpeg_unref_picture(s->avctx, &s->new_picture);","static int select_input_picture(MpegEncContext *s) { int i, ret; for (i = 1; i < MAX_PICTURE_COUNT; i++) s->reordered_input_picture[i - 1] = s->reordered_input_picture[i]; s->reordered_input_picture[MAX_PICTURE_COUNT - 1] = NULL; if (!s->reordered_input_picture[0] && s->input_picture[0]) { if ( !s->next_picture_ptr || s->intra_only) { s->reordered_input_picture[0] = s->input_picture[0]; s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_I; s->reordered_input_picture[0]->f->coded_picture_number = s->coded_picture_number++; } else { int b_frames; if (s->avctx->frame_skip_threshold || s->avctx->frame_skip_factor) { if (s->picture_in_gop_number < s->gop_size && skip_check(s, s->input_picture[0], s->next_picture_ptr)) { av_frame_unref(s->input_picture[0]->f); emms_c(); ff_vbv_update(s, 0); goto no_output_pic; } } if (s->avctx->flags & CODEC_FLAG_PASS2) { for (i = 0; i < s->max_b_frames + 1; i++) { int pict_num = s->input_picture[0]->f->display_picture_number + i; if (pict_num >= s->rc_context.num_entries) break; if (!s->input_picture[i]) { s->rc_context.entry[pict_num - 1].new_pict_type = AV_PICTURE_TYPE_P; break; } s->input_picture[i]->f->pict_type = s->rc_context.entry[pict_num].new_pict_type; } } if (s->avctx->b_frame_strategy == 0) { b_frames = s->max_b_frames; while (b_frames && !s->input_picture[b_frames]) b_frames--; } else if (s->avctx->b_frame_strategy == 1) { for (i = 1; i < s->max_b_frames + 1; i++) { if (s->input_picture[i] && s->input_picture[i]->b_frame_score == 0) { s->input_picture[i]->b_frame_score = get_intra_count(s, s->input_picture[i ]->f->data[0], s->input_picture[i - 1]->f->data[0], s->linesize) + 1; } } for (i = 0; i < s->max_b_frames + 1; i++) { if (!s->input_picture[i] || s->input_picture[i]->b_frame_score - 1 > s->mb_num / s->avctx->b_sensitivity) break; } b_frames = FFMAX(0, i - 1); for (i = 0; i < b_frames + 1; i++) { s->input_picture[i]->b_frame_score = 0; } } else if (s->avctx->b_frame_strategy == 2) { b_frames = estimate_best_b_count(s); } else { av_log(s->avctx, AV_LOG_ERROR, ""illegal b frame strategy\n""); b_frames = 0; } emms_c(); for (i = b_frames - 1; i >= 0; i--) { int type = s->input_picture[i]->f->pict_type; if (type && type != AV_PICTURE_TYPE_B) b_frames = i; } if (s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_B && b_frames == s->max_b_frames) { av_log(s->avctx, AV_LOG_ERROR, ""warning, too many b frames in a row\n""); } if (s->picture_in_gop_number + b_frames >= s->gop_size) { if ((s->mpv_flags & FF_MPV_FLAG_STRICT_GOP) && s->gop_size > s->picture_in_gop_number) { b_frames = s->gop_size - s->picture_in_gop_number - 1; } else { if (s->avctx->flags & CODEC_FLAG_CLOSED_GOP) b_frames = 0; s->input_picture[b_frames]->f->pict_type = AV_PICTURE_TYPE_I; } } if ((s->avctx->flags & CODEC_FLAG_CLOSED_GOP) && b_frames && s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_I) b_frames--; s->reordered_input_picture[0] = s->input_picture[b_frames]; if (s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_I) s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_P; s->reordered_input_picture[0]->f->coded_picture_number = s->coded_picture_number++; for (i = 0; i < b_frames; i++) { s->reordered_input_picture[i + 1] = s->input_picture[i]; s->reordered_input_picture[i + 1]->f->pict_type = AV_PICTURE_TYPE_B; s->reordered_input_picture[i + 1]->f->coded_picture_number = s->coded_picture_number++; } } } no_output_pic: if (s->reordered_input_picture[0]) { s->reordered_input_picture[0]->reference = s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_B ? 3 : 0; ff_mpeg_unref_picture(s->avctx, &s->new_picture); if ((ret = ff_mpeg_ref_picture(s, &s->new_picture, s->reordered_input_picture[0]))) return ret; if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) { Picture *pic; int i = ff_find_unused_picture(s, 0); if (i < 0) return i; pic = &s->picture[i]; pic->reference = s->reordered_input_picture[0]->reference; if (ff_alloc_picture(s, pic, 0) < 0) { return -1; } ret = av_frame_copy_props(pic->f, s->reordered_input_picture[0]->f); if (ret < 0) return ret; av_frame_unref(s->reordered_input_picture[0]->f); s->reordered_input_picture[0]->shared = 0; s->current_picture_ptr = pic; } else { s->current_picture_ptr = s->reordered_input_picture[0]; for (i = 0; i < 4; i++) { s->new_picture.f->data[i] += INPLACE_OFFSET; } } ff_mpeg_unref_picture(s->avctx, &s->current_picture); if ((ret = ff_mpeg_ref_picture(s, &s->current_picture, s->current_picture_ptr)) < 0) return ret; s->picture_number = s->new_picture.f->display_picture_number; } else { ff_mpeg_unref_picture(s->avctx, &s->new_picture); } return 0; }"
12049----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3e70f359de36b613d89a7fc82ee78b0d29c2c72a_1.json----ssl_add_clienthello_tlsext,"unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit, int *al) { int extdatalen=0; unsigned char *ret = p; #ifndef OPENSSL_NO_EC int using_ecc = 0; if (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) { int i; unsigned long alg_k, alg_a; STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s); for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) { SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i); alg_k = c->algorithm_mkey; alg_a = c->algorithm_auth; if ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe) || (alg_a & SSL_aECDSA))) { using_ecc = 1; break; } } } #endif if (s->client_version == SSL3_VERSION && !s->s3->send_connection_binding) return p; ret+=2; if (ret>=limit) return NULL; if (s->tlsext_hostname != NULL) { unsigned long size_str; long lenmax; if ((lenmax = limit - ret - 9) < 0 || (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) return NULL; s2n(TLSEXT_TYPE_server_name,ret); s2n(size_str+5,ret); s2n(size_str+3,ret); *(ret++) = (unsigned char) TLSEXT_NAMETYPE_host_name; s2n(size_str,ret); memcpy(ret, s->tlsext_hostname, size_str); ret+=size_str; } if (s->renegotiate) { int el; if(!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } if((limit - p - 4 - el) < 0) return NULL; s2n(TLSEXT_TYPE_renegotiate,ret); s2n(el,ret); if(!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } ret += el; } #ifndef OPENSSL_NO_SRP if (s->srp_ctx.login != NULL) { int login_len = strlen(s->srp_ctx.login); if (login_len > 255 || login_len == 0) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } if ((limit - ret - 5 - login_len) < 0) return NULL; s2n(TLSEXT_TYPE_srp,ret); s2n(login_len+1,ret); (*ret++) = (unsigned char) login_len; memcpy(ret, s->srp_ctx.login, login_len); ret+=login_len; } #endif #ifndef OPENSSL_NO_EC if (using_ecc) { long lenmax; const unsigned char *plist; size_t plistlen; tls1_get_formatlist(s, &plist, &plistlen); if ((lenmax = limit - ret - 5) < 0) return NULL; if (plistlen > (size_t)lenmax) return NULL; if (plistlen > 255) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } s2n(TLSEXT_TYPE_ec_point_formats,ret); s2n(plistlen + 1,ret); *(ret++) = (unsigned char)plistlen ; memcpy(ret, plist, plistlen); ret+=plistlen; plist = s->tlsext_ellipticcurvelist; tls1_get_curvelist(s, 0, &plist, &plistlen); if ((lenmax = limit - ret - 6) < 0) return NULL; if (plistlen > (size_t)lenmax) return NULL; if (plistlen > 65532) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } s2n(TLSEXT_TYPE_elliptic_curves,ret); <S2SV_StartVul> s2n(plistlen + 2, ret); <S2SV_EndVul> s2n(plistlen, ret); <S2SV_StartVul> memcpy(ret, plist, plistlen); <S2SV_EndVul> ret+=plistlen; } #endif <S2SV_StartVul> if (!(SSL_get_options(s) & SSL_OP_NO_TICKET)) <S2SV_EndVul> { int ticklen; if (!s->new_session && s->session && s->session->tlsext_tick) ticklen = s->session->tlsext_ticklen; else if (s->session && s->tlsext_session_ticket && s->tlsext_session_ticket->data) { ticklen = s->tlsext_session_ticket->length; s->session->tlsext_tick = OPENSSL_malloc(ticklen); if (!s->session->tlsext_tick) return NULL; memcpy(s->session->tlsext_tick, s->tlsext_session_ticket->data, ticklen); s->session->tlsext_ticklen = ticklen; } else ticklen = 0; if (ticklen == 0 && s->tlsext_session_ticket && s->tlsext_session_ticket->data == NULL) goto skip_ext; if ((long)(limit - ret - 4 - ticklen) < 0) return NULL; s2n(TLSEXT_TYPE_session_ticket,ret); s2n(ticklen,ret); if (ticklen) { memcpy(ret, s->session->tlsext_tick, ticklen); ret += ticklen; } } skip_ext: if (SSL_USE_SIGALGS(s)) { size_t salglen; const unsigned char *salg; salglen = tls12_get_psigalgs(s, &salg); if ((size_t)(limit - ret) < salglen + 6) return NULL; s2n(TLSEXT_TYPE_signature_algorithms,ret); <S2SV_StartVul> s2n(salglen + 2, ret); <S2SV_EndVul> <S2SV_StartVul> s2n(salglen, ret); <S2SV_EndVul> <S2SV_StartVul> memcpy(ret, salg, salglen); <S2SV_EndVul> ret += salglen; } #ifdef TLSEXT_TYPE_opaque_prf_input if (s->s3->client_opaque_prf_input != NULL) { size_t col = s->s3->client_opaque_prf_input_len; if ((long)(limit - ret - 6 - col < 0)) return NULL; if (col > 0xFFFD) return NULL; s2n(TLSEXT_TYPE_opaque_prf_input, ret); s2n(col + 2, ret); s2n(col, ret); memcpy(ret, s->s3->client_opaque_prf_input, col); ret += col; } #endif if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) { int i; long extlen, idlen, itmp; OCSP_RESPID *id; idlen = 0; for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) { id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i); itmp = i2d_OCSP_RESPID(id, NULL); if (itmp <= 0) return NULL; idlen += itmp + 2; } if (s->tlsext_ocsp_exts) { extlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL); if (extlen < 0) return NULL; } else extlen = 0; if ((long)(limit - ret - 7 - extlen - idlen) < 0) return NULL; s2n(TLSEXT_TYPE_status_request, ret); if (extlen + idlen > 0xFFF0) return NULL; s2n(extlen + idlen + 5, ret); *(ret++) = TLSEXT_STATUSTYPE_ocsp; s2n(idlen, ret); for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) { unsigned char *q = ret; id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i); ret += 2; itmp = i2d_OCSP_RESPID(id, &ret); s2n(itmp, q); } s2n(extlen, ret); if (extlen > 0) i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret); } #ifndef OPENSSL_NO_HEARTBEATS s2n(TLSEXT_TYPE_heartbeat,ret); s2n(1,ret); if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS) *(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS; else *(ret++) = SSL_TLSEXT_HB_ENABLED; #endif #ifndef OPENSSL_NO_NEXTPROTONEG if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) { if (limit - ret - 4 < 0) return NULL; s2n(TLSEXT_TYPE_next_proto_neg,ret); s2n(0,ret); } #endif if (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len) { if ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len) return NULL; s2n(TLSEXT_TYPE_application_layer_protocol_negotiation,ret); s2n(2 + s->alpn_client_proto_list_len,ret); s2n(s->alpn_client_proto_list_len,ret); memcpy(ret, s->alpn_client_proto_list, s->alpn_client_proto_list_len); ret += s->alpn_client_proto_list_len; } if(SSL_get_srtp_profiles(s)) { int el; ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0); if((limit - p - 4 - el) < 0) return NULL; s2n(TLSEXT_TYPE_use_srtp,ret); s2n(el,ret); if(ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } ret += el; } if (s->ctx->custom_cli_ext_records_count) { size_t i; custom_cli_ext_record* record; for (i = 0; i < s->ctx->custom_cli_ext_records_count; i++) { const unsigned char* out = NULL; unsigned short outlen = 0; record = &s->ctx->custom_cli_ext_records[i]; if (record->fn1) { int cb_retval = 0; cb_retval = record->fn1(s, record->ext_type, &out, &outlen, al, record->arg); if (cb_retval == 0) return NULL; if (cb_retval == -1) continue; } if (limit < ret + 4 + outlen) return NULL; s2n(record->ext_type, ret); s2n(outlen, ret); memcpy(ret, out, outlen); ret += outlen; } } #ifdef TLSEXT_TYPE_encrypt_then_mac s2n(TLSEXT_TYPE_encrypt_then_mac,ret); s2n(0,ret); #endif #ifdef TLSEXT_TYPE_padding { int hlen = ret - (unsigned char *)s->init_buf->data; if (s->state == SSL23_ST_CW_CLNT_HELLO_A) hlen -= 5; if (hlen > 0xff && hlen < 0x200) { hlen = 0x200 - hlen; if (hlen >= 4) hlen -= 4; else hlen = 0; s2n(TLSEXT_TYPE_padding, ret); s2n(hlen, ret); memset(ret, 0, hlen); ret += hlen; } } #endif if ((extdatalen = ret-p-2) == 0) return p; s2n(extdatalen,p); return ret; }","- s2n(plistlen + 2, ret);
- memcpy(ret, plist, plistlen);
- if (!(SSL_get_options(s) & SSL_OP_NO_TICKET))
- s2n(salglen + 2, ret);
- s2n(salglen, ret);
- memcpy(ret, salg, salglen);
+ size_t i;
+ unsigned char *etmp;
+ etmp = ret + 4;
+ for (i = 0; i < plistlen; i += 2, plist += 2)
+ {
+ if (tls_curve_allowed(s, plist, SSL_SECOP_CURVE_SUPPORTED))
+ {
+ }
+ }
+ plistlen = etmp - ret - 4;
+ s2n(plistlen + 2, ret);
+ if (tls_use_ticket(s))
+ unsigned char *etmp;
+ etmp = ret;
+ ret += 4;
+ salglen = tls12_copy_sigalgs(s, etmp, salg, salglen);
+ s2n(salglen + 2, etmp);
+ s2n(salglen, etmp);","unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit, int *al) { int extdatalen=0; unsigned char *ret = p; #ifndef OPENSSL_NO_EC int using_ecc = 0; if (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) { int i; unsigned long alg_k, alg_a; STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s); for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) { SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i); alg_k = c->algorithm_mkey; alg_a = c->algorithm_auth; if ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe) || (alg_a & SSL_aECDSA))) { using_ecc = 1; break; } } } #endif if (s->client_version == SSL3_VERSION && !s->s3->send_connection_binding) return p; ret+=2; if (ret>=limit) return NULL; if (s->tlsext_hostname != NULL) { unsigned long size_str; long lenmax; if ((lenmax = limit - ret - 9) < 0 || (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) return NULL; s2n(TLSEXT_TYPE_server_name,ret); s2n(size_str+5,ret); s2n(size_str+3,ret); *(ret++) = (unsigned char) TLSEXT_NAMETYPE_host_name; s2n(size_str,ret); memcpy(ret, s->tlsext_hostname, size_str); ret+=size_str; } if (s->renegotiate) { int el; if(!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } if((limit - p - 4 - el) < 0) return NULL; s2n(TLSEXT_TYPE_renegotiate,ret); s2n(el,ret); if(!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } ret += el; } #ifndef OPENSSL_NO_SRP if (s->srp_ctx.login != NULL) { int login_len = strlen(s->srp_ctx.login); if (login_len > 255 || login_len == 0) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } if ((limit - ret - 5 - login_len) < 0) return NULL; s2n(TLSEXT_TYPE_srp,ret); s2n(login_len+1,ret); (*ret++) = (unsigned char) login_len; memcpy(ret, s->srp_ctx.login, login_len); ret+=login_len; } #endif #ifndef OPENSSL_NO_EC if (using_ecc) { long lenmax; const unsigned char *plist; size_t plistlen; size_t i; unsigned char *etmp; tls1_get_formatlist(s, &plist, &plistlen); if ((lenmax = limit - ret - 5) < 0) return NULL; if (plistlen > (size_t)lenmax) return NULL; if (plistlen > 255) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } s2n(TLSEXT_TYPE_ec_point_formats,ret); s2n(plistlen + 1,ret); *(ret++) = (unsigned char)plistlen ; memcpy(ret, plist, plistlen); ret+=plistlen; plist = s->tlsext_ellipticcurvelist; tls1_get_curvelist(s, 0, &plist, &plistlen); if ((lenmax = limit - ret - 6) < 0) return NULL; if (plistlen > (size_t)lenmax) return NULL; if (plistlen > 65532) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } s2n(TLSEXT_TYPE_elliptic_curves,ret); etmp = ret + 4; for (i = 0; i < plistlen; i += 2, plist += 2) { if (tls_curve_allowed(s, plist, SSL_SECOP_CURVE_SUPPORTED)) { *etmp++ = plist[0]; *etmp++ = plist[1]; } } plistlen = etmp - ret - 4; s2n(plistlen + 2, ret); s2n(plistlen, ret); ret+=plistlen; } #endif if (tls_use_ticket(s)) { int ticklen; if (!s->new_session && s->session && s->session->tlsext_tick) ticklen = s->session->tlsext_ticklen; else if (s->session && s->tlsext_session_ticket && s->tlsext_session_ticket->data) { ticklen = s->tlsext_session_ticket->length; s->session->tlsext_tick = OPENSSL_malloc(ticklen); if (!s->session->tlsext_tick) return NULL; memcpy(s->session->tlsext_tick, s->tlsext_session_ticket->data, ticklen); s->session->tlsext_ticklen = ticklen; } else ticklen = 0; if (ticklen == 0 && s->tlsext_session_ticket && s->tlsext_session_ticket->data == NULL) goto skip_ext; if ((long)(limit - ret - 4 - ticklen) < 0) return NULL; s2n(TLSEXT_TYPE_session_ticket,ret); s2n(ticklen,ret); if (ticklen) { memcpy(ret, s->session->tlsext_tick, ticklen); ret += ticklen; } } skip_ext: if (SSL_USE_SIGALGS(s)) { size_t salglen; const unsigned char *salg; unsigned char *etmp; salglen = tls12_get_psigalgs(s, &salg); if ((size_t)(limit - ret) < salglen + 6) return NULL; s2n(TLSEXT_TYPE_signature_algorithms,ret); etmp = ret; ret += 4; salglen = tls12_copy_sigalgs(s, etmp, salg, salglen); s2n(salglen + 2, etmp); s2n(salglen, etmp); ret += salglen; } #ifdef TLSEXT_TYPE_opaque_prf_input if (s->s3->client_opaque_prf_input != NULL) { size_t col = s->s3->client_opaque_prf_input_len; if ((long)(limit - ret - 6 - col < 0)) return NULL; if (col > 0xFFFD) return NULL; s2n(TLSEXT_TYPE_opaque_prf_input, ret); s2n(col + 2, ret); s2n(col, ret); memcpy(ret, s->s3->client_opaque_prf_input, col); ret += col; } #endif if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) { int i; long extlen, idlen, itmp; OCSP_RESPID *id; idlen = 0; for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) { id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i); itmp = i2d_OCSP_RESPID(id, NULL); if (itmp <= 0) return NULL; idlen += itmp + 2; } if (s->tlsext_ocsp_exts) { extlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL); if (extlen < 0) return NULL; } else extlen = 0; if ((long)(limit - ret - 7 - extlen - idlen) < 0) return NULL; s2n(TLSEXT_TYPE_status_request, ret); if (extlen + idlen > 0xFFF0) return NULL; s2n(extlen + idlen + 5, ret); *(ret++) = TLSEXT_STATUSTYPE_ocsp; s2n(idlen, ret); for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) { unsigned char *q = ret; id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i); ret += 2; itmp = i2d_OCSP_RESPID(id, &ret); s2n(itmp, q); } s2n(extlen, ret); if (extlen > 0) i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret); } #ifndef OPENSSL_NO_HEARTBEATS s2n(TLSEXT_TYPE_heartbeat,ret); s2n(1,ret); if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS) *(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS; else *(ret++) = SSL_TLSEXT_HB_ENABLED; #endif #ifndef OPENSSL_NO_NEXTPROTONEG if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) { if (limit - ret - 4 < 0) return NULL; s2n(TLSEXT_TYPE_next_proto_neg,ret); s2n(0,ret); } #endif if (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len) { if ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len) return NULL; s2n(TLSEXT_TYPE_application_layer_protocol_negotiation,ret); s2n(2 + s->alpn_client_proto_list_len,ret); s2n(s->alpn_client_proto_list_len,ret); memcpy(ret, s->alpn_client_proto_list, s->alpn_client_proto_list_len); ret += s->alpn_client_proto_list_len; } if(SSL_get_srtp_profiles(s)) { int el; ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0); if((limit - p - 4 - el) < 0) return NULL; s2n(TLSEXT_TYPE_use_srtp,ret); s2n(el,ret); if(ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) { SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return NULL; } ret += el; } if (s->ctx->custom_cli_ext_records_count) { size_t i; custom_cli_ext_record* record; for (i = 0; i < s->ctx->custom_cli_ext_records_count; i++) { const unsigned char* out = NULL; unsigned short outlen = 0; record = &s->ctx->custom_cli_ext_records[i]; if (record->fn1) { int cb_retval = 0; cb_retval = record->fn1(s, record->ext_type, &out, &outlen, al, record->arg); if (cb_retval == 0) return NULL; if (cb_retval == -1) continue; } if (limit < ret + 4 + outlen) return NULL; s2n(record->ext_type, ret); s2n(outlen, ret); memcpy(ret, out, outlen); ret += outlen; } } #ifdef TLSEXT_TYPE_encrypt_then_mac s2n(TLSEXT_TYPE_encrypt_then_mac,ret); s2n(0,ret); #endif #ifdef TLSEXT_TYPE_padding { int hlen = ret - (unsigned char *)s->init_buf->data; if (s->state == SSL23_ST_CW_CLNT_HELLO_A) hlen -= 5; if (hlen > 0xff && hlen < 0x200) { hlen = 0x200 - hlen; if (hlen >= 4) hlen -= 4; else hlen = 0; s2n(TLSEXT_TYPE_padding, ret); s2n(hlen, ret); memset(ret, 0, hlen); ret += hlen; } } #endif if ((extdatalen = ret-p-2) == 0) return p; s2n(extdatalen,p); return ret; }"
5611----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_1.json----decode_ics_info,"static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics, GetBitContext *gb) { if (get_bits1(gb)) { av_log(ac->avctx, AV_LOG_ERROR, ""Reserved bit set.\n""); return AVERROR_INVALIDDATA; } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = get_bits(gb, 2); ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = get_bits1(gb); ics->num_window_groups = 1; ics->group_len[0] = 1; if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { int i; ics->max_sfb = get_bits(gb, 4); for (i = 0; i < 7; i++) { if (get_bits1(gb)) { ics->group_len[ics->num_window_groups - 1]++; } else { ics->num_window_groups++; ics->group_len[ics->num_window_groups - 1] = 1; } } ics->num_windows = 8; <S2SV_StartVul> ics->swb_offset = ff_swb_offset_128[ac->m4ac.sampling_index]; <S2SV_EndVul> <S2SV_StartVul> ics->num_swb = ff_aac_num_swb_128[ac->m4ac.sampling_index]; <S2SV_EndVul> <S2SV_StartVul> ics->tns_max_bands = ff_tns_max_bands_128[ac->m4ac.sampling_index]; <S2SV_EndVul> ics->predictor_present = 0; } else { ics->max_sfb = get_bits(gb, 6); ics->num_windows = 1; <S2SV_StartVul> ics->swb_offset = ff_swb_offset_1024[ac->m4ac.sampling_index]; <S2SV_EndVul> <S2SV_StartVul> ics->num_swb = ff_aac_num_swb_1024[ac->m4ac.sampling_index]; <S2SV_EndVul> <S2SV_StartVul> ics->tns_max_bands = ff_tns_max_bands_1024[ac->m4ac.sampling_index]; <S2SV_EndVul> ics->predictor_present = get_bits1(gb); ics->predictor_reset_group = 0; if (ics->predictor_present) { <S2SV_StartVul> if (ac->m4ac.object_type == AOT_AAC_MAIN) { <S2SV_EndVul> if (decode_prediction(ac, ics, gb)) { return AVERROR_INVALIDDATA; } <S2SV_StartVul> } else if (ac->m4ac.object_type == AOT_AAC_LC) { <S2SV_EndVul> av_log(ac->avctx, AV_LOG_ERROR, ""Prediction is not allowed in AAC-LC.\n""); return AVERROR_INVALIDDATA; } else { if ((ics->ltp.present = get_bits(gb, 1))) decode_ltp(ac, &ics->ltp, gb, ics->max_sfb); } } } if (ics->max_sfb > ics->num_swb) { av_log(ac->avctx, AV_LOG_ERROR, ""Number of scalefactor bands in group (%d) exceeds limit (%d).\n"", ics->max_sfb, ics->num_swb); return AVERROR_INVALIDDATA; } return 0; }","- ics->swb_offset = ff_swb_offset_128[ac->m4ac.sampling_index];
- ics->num_swb = ff_aac_num_swb_128[ac->m4ac.sampling_index];
- ics->tns_max_bands = ff_tns_max_bands_128[ac->m4ac.sampling_index];
- ics->swb_offset = ff_swb_offset_1024[ac->m4ac.sampling_index];
- ics->num_swb = ff_aac_num_swb_1024[ac->m4ac.sampling_index];
- ics->tns_max_bands = ff_tns_max_bands_1024[ac->m4ac.sampling_index];
- if (ac->m4ac.object_type == AOT_AAC_MAIN) {
- } else if (ac->m4ac.object_type == AOT_AAC_LC) {
+ ics->swb_offset = ff_swb_offset_128[ac->oc[1].m4ac.sampling_index];
+ ics->num_swb = ff_aac_num_swb_128[ac->oc[1].m4ac.sampling_index];
+ ics->tns_max_bands = ff_tns_max_bands_128[ac->oc[1].m4ac.sampling_index];
+ ics->swb_offset = ff_swb_offset_1024[ac->oc[1].m4ac.sampling_index];
+ ics->num_swb = ff_aac_num_swb_1024[ac->oc[1].m4ac.sampling_index];
+ ics->tns_max_bands = ff_tns_max_bands_1024[ac->oc[1].m4ac.sampling_index];
+ if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN) {
+ } else if (ac->oc[1].m4ac.object_type == AOT_AAC_LC) {","static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics, GetBitContext *gb) { if (get_bits1(gb)) { av_log(ac->avctx, AV_LOG_ERROR, ""Reserved bit set.\n""); return AVERROR_INVALIDDATA; } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = get_bits(gb, 2); ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = get_bits1(gb); ics->num_window_groups = 1; ics->group_len[0] = 1; if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { int i; ics->max_sfb = get_bits(gb, 4); for (i = 0; i < 7; i++) { if (get_bits1(gb)) { ics->group_len[ics->num_window_groups - 1]++; } else { ics->num_window_groups++; ics->group_len[ics->num_window_groups - 1] = 1; } } ics->num_windows = 8; ics->swb_offset = ff_swb_offset_128[ac->oc[1].m4ac.sampling_index]; ics->num_swb = ff_aac_num_swb_128[ac->oc[1].m4ac.sampling_index]; ics->tns_max_bands = ff_tns_max_bands_128[ac->oc[1].m4ac.sampling_index]; ics->predictor_present = 0; } else { ics->max_sfb = get_bits(gb, 6); ics->num_windows = 1; ics->swb_offset = ff_swb_offset_1024[ac->oc[1].m4ac.sampling_index]; ics->num_swb = ff_aac_num_swb_1024[ac->oc[1].m4ac.sampling_index]; ics->tns_max_bands = ff_tns_max_bands_1024[ac->oc[1].m4ac.sampling_index]; ics->predictor_present = get_bits1(gb); ics->predictor_reset_group = 0; if (ics->predictor_present) { if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN) { if (decode_prediction(ac, ics, gb)) { return AVERROR_INVALIDDATA; } } else if (ac->oc[1].m4ac.object_type == AOT_AAC_LC) { av_log(ac->avctx, AV_LOG_ERROR, ""Prediction is not allowed in AAC-LC.\n""); return AVERROR_INVALIDDATA; } else { if ((ics->ltp.present = get_bits(gb, 1))) decode_ltp(ac, &ics->ltp, gb, ics->max_sfb); } } } if (ics->max_sfb > ics->num_swb) { av_log(ac->avctx, AV_LOG_ERROR, ""Number of scalefactor bands in group (%d) exceeds limit (%d).\n"", ics->max_sfb, ics->num_swb); return AVERROR_INVALIDDATA; } return 0; }"
1755----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6170c67504202ad4b0ef41b35b5fe3064925228a_1.json----save_subtitle_set,"static int save_subtitle_set(AVCodecContext *avctx, AVSubtitle *sub, int *got_output) { DVBSubContext *ctx = avctx->priv_data; DVBSubRegionDisplay *display; DVBSubDisplayDefinition *display_def = ctx->display_definition; DVBSubRegion *region; AVSubtitleRect *rect; DVBSubCLUT *clut; uint32_t *clut_table; int i; int offset_x=0, offset_y=0; int ret = 0; if (display_def) { offset_x = display_def->x; offset_y = display_def->y; } if(sub->num_rects) { avpriv_request_sample(ctx, ""Different Version of Segment asked Twice""); return AVERROR_PATCHWELCOME; } for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (region && region->dirty) sub->num_rects++; } if(ctx->compute_edt == 0) { sub->end_display_time = ctx->time_out * 1000; *got_output = 1; } else if (ctx->prev_start != AV_NOPTS_VALUE) { sub->end_display_time = av_rescale_q((sub->pts - ctx->prev_start ), AV_TIME_BASE_Q, (AVRational){ 1, 1000 }) - 1; *got_output = 1; } if (sub->num_rects > 0) { sub->rects = av_mallocz_array(sizeof(*sub->rects), sub->num_rects); if (!sub->rects) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < sub->num_rects; i++) { sub->rects[i] = av_mallocz(sizeof(*sub->rects[i])); if (!sub->rects[i]) { ret = AVERROR(ENOMEM); goto fail; } } i = 0; for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (!region) continue; if (!region->dirty) continue; rect = sub->rects[i]; rect->x = display->x_pos + offset_x; rect->y = display->y_pos + offset_y; rect->w = region->width; rect->h = region->height; rect->nb_colors = (1 << region->depth); rect->type = SUBTITLE_BITMAP; rect->linesize[0] = region->width; clut = get_clut(ctx, region->clut); if (!clut) clut = &default_clut; switch (region->depth) { case 2: clut_table = clut->clut4; break; case 8: clut_table = clut->clut256; break; case 4: default: clut_table = clut->clut16; break; } rect->data[1] = av_mallocz(AVPALETTE_SIZE); if (!rect->data[1]) { ret = AVERROR(ENOMEM); goto fail; } memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t)); rect->data[0] = av_malloc(region->buf_size); if (!rect->data[0]) { ret = AVERROR(ENOMEM); goto fail; } memcpy(rect->data[0], region->pbuf, region->buf_size); <S2SV_StartVul> if ((clut == &default_clut && ctx->compute_clut == -1) || ctx->compute_clut == 1) <S2SV_EndVul> <S2SV_StartVul> compute_default_clut(rect, rect->w, rect->h); <S2SV_EndVul> #if FF_API_AVPICTURE FF_DISABLE_DEPRECATION_WARNINGS { int j; for (j = 0; j < 4; j++) { rect->pict.data[j] = rect->data[j]; rect->pict.linesize[j] = rect->linesize[j]; } } FF_ENABLE_DEPRECATION_WARNINGS #endif i++; } } return 0; fail: if (sub->rects) { for(i=0; i<sub->num_rects; i++) { rect = sub->rects[i]; if (rect) { av_freep(&rect->data[0]); av_freep(&rect->data[1]); } av_freep(&sub->rects[i]); } av_freep(&sub->rects); } sub->num_rects = 0; return ret; }","- if ((clut == &default_clut && ctx->compute_clut == -1) || ctx->compute_clut == 1)
- compute_default_clut(rect, rect->w, rect->h);
+ if ((clut == &default_clut && ctx->compute_clut == -1) || ctx->compute_clut == 1) {
+ if (!region->has_computed_clut) {
+ compute_default_clut(region->computed_clut, rect, rect->w, rect->h);
+ region->has_computed_clut = 1;
+ }
+ memcpy(rect->data[1], region->computed_clut, sizeof(region->computed_clut));
+ }","static int save_subtitle_set(AVCodecContext *avctx, AVSubtitle *sub, int *got_output) { DVBSubContext *ctx = avctx->priv_data; DVBSubRegionDisplay *display; DVBSubDisplayDefinition *display_def = ctx->display_definition; DVBSubRegion *region; AVSubtitleRect *rect; DVBSubCLUT *clut; uint32_t *clut_table; int i; int offset_x=0, offset_y=0; int ret = 0; if (display_def) { offset_x = display_def->x; offset_y = display_def->y; } if(sub->num_rects) { avpriv_request_sample(ctx, ""Different Version of Segment asked Twice""); return AVERROR_PATCHWELCOME; } for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (region && region->dirty) sub->num_rects++; } if(ctx->compute_edt == 0) { sub->end_display_time = ctx->time_out * 1000; *got_output = 1; } else if (ctx->prev_start != AV_NOPTS_VALUE) { sub->end_display_time = av_rescale_q((sub->pts - ctx->prev_start ), AV_TIME_BASE_Q, (AVRational){ 1, 1000 }) - 1; *got_output = 1; } if (sub->num_rects > 0) { sub->rects = av_mallocz_array(sizeof(*sub->rects), sub->num_rects); if (!sub->rects) { ret = AVERROR(ENOMEM); goto fail; } for (i = 0; i < sub->num_rects; i++) { sub->rects[i] = av_mallocz(sizeof(*sub->rects[i])); if (!sub->rects[i]) { ret = AVERROR(ENOMEM); goto fail; } } i = 0; for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (!region) continue; if (!region->dirty) continue; rect = sub->rects[i]; rect->x = display->x_pos + offset_x; rect->y = display->y_pos + offset_y; rect->w = region->width; rect->h = region->height; rect->nb_colors = (1 << region->depth); rect->type = SUBTITLE_BITMAP; rect->linesize[0] = region->width; clut = get_clut(ctx, region->clut); if (!clut) clut = &default_clut; switch (region->depth) { case 2: clut_table = clut->clut4; break; case 8: clut_table = clut->clut256; break; case 4: default: clut_table = clut->clut16; break; } rect->data[1] = av_mallocz(AVPALETTE_SIZE); if (!rect->data[1]) { ret = AVERROR(ENOMEM); goto fail; } memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t)); rect->data[0] = av_malloc(region->buf_size); if (!rect->data[0]) { ret = AVERROR(ENOMEM); goto fail; } memcpy(rect->data[0], region->pbuf, region->buf_size); if ((clut == &default_clut && ctx->compute_clut == -1) || ctx->compute_clut == 1) { if (!region->has_computed_clut) { compute_default_clut(region->computed_clut, rect, rect->w, rect->h); region->has_computed_clut = 1; } memcpy(rect->data[1], region->computed_clut, sizeof(region->computed_clut)); } #if FF_API_AVPICTURE FF_DISABLE_DEPRECATION_WARNINGS { int j; for (j = 0; j < 4; j++) { rect->pict.data[j] = rect->data[j]; rect->pict.linesize[j] = rect->linesize[j]; } } FF_ENABLE_DEPRECATION_WARNINGS #endif i++; } } return 0; fail: if (sub->rects) { for(i=0; i<sub->num_rects; i++) { rect = sub->rects[i]; if (rect) { av_freep(&rect->data[0]); av_freep(&rect->data[1]); } av_freep(&sub->rects[i]); } av_freep(&sub->rects); } sub->num_rects = 0; return ret; }"
14429----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_9197c97670ebeac4caaf69a132edb9ff7dbaf7e6_1.json----add_DN_object,"static int add_DN_object(X509_NAME *n, char *text, char *def, char *value, int nid, int n_min, int n_max, unsigned long chtype, int mval) { int i,ret=0; MS_STATIC char buf[1024]; start: if (!batch) BIO_printf(bio_err,""%s [%s]:"",text,def); (void)BIO_flush(bio_err); if(value != NULL) { <S2SV_StartVul> OPENSSL_assert(strlen(value) < sizeof buf-2); <S2SV_EndVul> <S2SV_StartVul> strcpy(buf,value); <S2SV_EndVul> <S2SV_StartVul> strcat(buf,""\n""); <S2SV_EndVul> BIO_printf(bio_err,""%s\n"",value); } else { buf[0]='\0'; if (!batch) { fgets(buf,sizeof buf,stdin); } else { buf[0] = '\n'; buf[1] = '\0'; } } if (buf[0] == '\0') return(0); else if (buf[0] == '\n') { if ((def == NULL) || (def[0] == '\0')) return(1); <S2SV_StartVul> strcpy(buf,def); <S2SV_EndVul> <S2SV_StartVul> strcat(buf,""\n""); <S2SV_EndVul> } else if ((buf[0] == '.') && (buf[1] == '\n')) return(1); i=strlen(buf); if (buf[i-1] != '\n') { BIO_printf(bio_err,""weird input :-(\n""); return(0); } buf[--i]='\0'; #ifdef CHARSET_EBCDIC ebcdic2ascii(buf, buf, i); #endif if(!req_check_len(i, n_min, n_max)) goto start; if (!X509_NAME_add_entry_by_NID(n,nid, chtype, (unsigned char *) buf, -1,-1,mval)) goto err; ret=1; err: return(ret); }","- OPENSSL_assert(strlen(value) < sizeof buf-2);
- strcpy(buf,value);
- strcat(buf,""\n"");
- strcpy(buf,def);
- strcat(buf,""\n"");
+ BUF_strlcpy(buf,value,sizeof buf);
+ BUF_strlcat(buf,""\n"",sizeof buf);
+ BUF_strlcpy(buf,def,sizeof buf);
+ BUF_strlcat(buf,""\n"",sizeof buf);","static int add_DN_object(X509_NAME *n, char *text, char *def, char *value, int nid, int n_min, int n_max, unsigned long chtype, int mval) { int i,ret=0; MS_STATIC char buf[1024]; start: if (!batch) BIO_printf(bio_err,""%s [%s]:"",text,def); (void)BIO_flush(bio_err); if(value != NULL) { BUF_strlcpy(buf,value,sizeof buf); BUF_strlcat(buf,""\n"",sizeof buf); BIO_printf(bio_err,""%s\n"",value); } else { buf[0]='\0'; if (!batch) { fgets(buf,sizeof buf,stdin); } else { buf[0] = '\n'; buf[1] = '\0'; } } if (buf[0] == '\0') return(0); else if (buf[0] == '\n') { if ((def == NULL) || (def[0] == '\0')) return(1); BUF_strlcpy(buf,def,sizeof buf); BUF_strlcat(buf,""\n"",sizeof buf); } else if ((buf[0] == '.') && (buf[1] == '\n')) return(1); i=strlen(buf); if (buf[i-1] != '\n') { BIO_printf(bio_err,""weird input :-(\n""); return(0); } buf[--i]='\0'; #ifdef CHARSET_EBCDIC ebcdic2ascii(buf, buf, i); #endif if(!req_check_len(i, n_min, n_max)) goto start; if (!X509_NAME_add_entry_by_NID(n,nid, chtype, (unsigned char *) buf, -1,-1,mval)) goto err; ret=1; err: return(ret); }"
574----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_203932dd8d56e3c3ec243dec70a4fde845f05f6c_1.json----hwupload_query_formats,"static int hwupload_query_formats(AVFilterContext *avctx) { HWUploadContext *ctx = avctx->priv; AVHWFramesConstraints *constraints = NULL; const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts; AVFilterFormats *input_formats = NULL; int err, i; if (!avctx->hw_device_ctx) { av_log(ctx, AV_LOG_ERROR, ""A hardware device reference is required "" ""to upload frames to.\n""); return AVERROR(EINVAL); } ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx); if (!ctx->hwdevice_ref) return AVERROR(ENOMEM); ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data; constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL); if (!constraints) { err = AVERROR(EINVAL); goto fail; } input_pix_fmts = constraints->valid_sw_formats; output_pix_fmts = constraints->valid_hw_formats; input_formats = ff_make_format_list(output_pix_fmts); if (!input_formats) { err = AVERROR(ENOMEM); goto fail; } if (input_pix_fmts) { for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) { err = ff_add_format(&input_formats, input_pix_fmts[i]); <S2SV_StartVul> if (err < 0) { <S2SV_EndVul> <S2SV_StartVul> ff_formats_unref(&input_formats); <S2SV_EndVul> goto fail; <S2SV_StartVul> } <S2SV_EndVul> } } <S2SV_StartVul> ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats); <S2SV_EndVul> <S2SV_StartVul> ff_formats_ref(ff_make_format_list(output_pix_fmts), <S2SV_EndVul> <S2SV_StartVul> &avctx->outputs[0]->in_formats); <S2SV_EndVul> av_hwframe_constraints_free(&constraints); return 0; fail: av_buffer_unref(&ctx->hwdevice_ref); av_hwframe_constraints_free(&constraints); return err; }","- if (err < 0) {
- ff_formats_unref(&input_formats);
- }
- ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);
- ff_formats_ref(ff_make_format_list(output_pix_fmts),
- &avctx->outputs[0]->in_formats);
+ if (err < 0)
+ if ((err = ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats)) < 0 ||
+ (err = ff_formats_ref(ff_make_format_list(output_pix_fmts),
+ &avctx->outputs[0]->in_formats)) < 0)
+ goto fail;","static int hwupload_query_formats(AVFilterContext *avctx) { HWUploadContext *ctx = avctx->priv; AVHWFramesConstraints *constraints = NULL; const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts; AVFilterFormats *input_formats = NULL; int err, i; if (!avctx->hw_device_ctx) { av_log(ctx, AV_LOG_ERROR, ""A hardware device reference is required "" ""to upload frames to.\n""); return AVERROR(EINVAL); } ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx); if (!ctx->hwdevice_ref) return AVERROR(ENOMEM); ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data; constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL); if (!constraints) { err = AVERROR(EINVAL); goto fail; } input_pix_fmts = constraints->valid_sw_formats; output_pix_fmts = constraints->valid_hw_formats; input_formats = ff_make_format_list(output_pix_fmts); if (!input_formats) { err = AVERROR(ENOMEM); goto fail; } if (input_pix_fmts) { for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) { err = ff_add_format(&input_formats, input_pix_fmts[i]); if (err < 0) goto fail; } } if ((err = ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats)) < 0 || (err = ff_formats_ref(ff_make_format_list(output_pix_fmts), &avctx->outputs[0]->in_formats)) < 0) goto fail; av_hwframe_constraints_free(&constraints); return 0; fail: av_buffer_unref(&ctx->hwdevice_ref); av_hwframe_constraints_free(&constraints); return err; }"
13046----MEMORY_LEAK----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_61d82097e5b4e03e62f5b19530938285dbb68d19_1.json----BN_MONT_CTX_init,void BN_MONT_CTX_init(BN_MONT_CTX *ctx) { ctx->ri = 0; <S2SV_StartVul> bn_init(&(ctx->RR)); <S2SV_EndVul> <S2SV_StartVul> bn_init(&(ctx->N)); <S2SV_EndVul> <S2SV_StartVul> bn_init(&(ctx->Ni)); <S2SV_EndVul> ctx->n0[0] = ctx->n0[1] = 0; ctx->flags = 0; },"- bn_init(&(ctx->RR));
- bn_init(&(ctx->N));
- bn_init(&(ctx->Ni));
+ bn_init(&ctx->RR);
+ bn_init(&ctx->N);
+ bn_init(&ctx->Ni);",void BN_MONT_CTX_init(BN_MONT_CTX *ctx) { ctx->ri = 0; bn_init(&ctx->RR); bn_init(&ctx->N); bn_init(&ctx->Ni); ctx->n0[0] = ctx->n0[1] = 0; ctx->flags = 0; }
10546----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_09ff7e62219ee73350d6581a8843ff1c3b777288_1.json----nseq_main,"int nseq_main(int argc, char **argv) { BIO *in = NULL, *out = NULL; X509 *x509 = NULL; NETSCAPE_CERT_SEQUENCE *seq = NULL; OPTION_CHOICE o; int toseq = 0, ret = 1, i; char *infile = NULL, *outfile = NULL, *prog; prog = opt_init(argc, argv, nseq_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: ret = 0; opt_help(nseq_options); goto end; case OPT_TOSEQ: toseq = 1; break; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; } } argc = opt_num_rest(); argv = opt_rest(); if (!app_load_modules(NULL)) goto end; <S2SV_StartVul> in = bio_open_default(infile, ""r""); <S2SV_EndVul> if (in == NULL) goto end; <S2SV_StartVul> out = bio_open_default(outfile, ""w""); <S2SV_EndVul> if (out == NULL) goto end; if (toseq) { seq = NETSCAPE_CERT_SEQUENCE_new(); seq->certs = sk_X509_new_null(); if (!seq->certs) goto end; while ((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL))) sk_X509_push(seq->certs, x509); if (!sk_X509_num(seq->certs)) { BIO_printf(bio_err, ""%s: Error reading certs file %s\n"", prog, infile); ERR_print_errors(bio_err); goto end; } PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq); ret = 0; goto end; } seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL); if (seq == NULL) { BIO_printf(bio_err, ""%s: Error reading sequence file %s\n"", prog, infile); ERR_print_errors(bio_err); goto end; } for (i = 0; i < sk_X509_num(seq->certs); i++) { x509 = sk_X509_value(seq->certs, i); dump_cert_text(out, x509); PEM_write_bio_X509(out, x509); } ret = 0; end: BIO_free(in); BIO_free_all(out); NETSCAPE_CERT_SEQUENCE_free(seq); return (ret); }","- in = bio_open_default(infile, ""r"");
- out = bio_open_default(outfile, ""w"");
+ in = bio_open_default(infile, 'r', FORMAT_PEM);
+ out = bio_open_default(outfile, 'w', FORMAT_PEM);","int nseq_main(int argc, char **argv) { BIO *in = NULL, *out = NULL; X509 *x509 = NULL; NETSCAPE_CERT_SEQUENCE *seq = NULL; OPTION_CHOICE o; int toseq = 0, ret = 1, i; char *infile = NULL, *outfile = NULL, *prog; prog = opt_init(argc, argv, nseq_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: ret = 0; opt_help(nseq_options); goto end; case OPT_TOSEQ: toseq = 1; break; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; } } argc = opt_num_rest(); argv = opt_rest(); if (!app_load_modules(NULL)) goto end; in = bio_open_default(infile, 'r', FORMAT_PEM); if (in == NULL) goto end; out = bio_open_default(outfile, 'w', FORMAT_PEM); if (out == NULL) goto end; if (toseq) { seq = NETSCAPE_CERT_SEQUENCE_new(); seq->certs = sk_X509_new_null(); if (!seq->certs) goto end; while ((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL))) sk_X509_push(seq->certs, x509); if (!sk_X509_num(seq->certs)) { BIO_printf(bio_err, ""%s: Error reading certs file %s\n"", prog, infile); ERR_print_errors(bio_err); goto end; } PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq); ret = 0; goto end; } seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL); if (seq == NULL) { BIO_printf(bio_err, ""%s: Error reading sequence file %s\n"", prog, infile); ERR_print_errors(bio_err); goto end; } for (i = 0; i < sk_X509_num(seq->certs); i++) { x509 = sk_X509_value(seq->certs, i); dump_cert_text(out, x509); PEM_write_bio_X509(out, x509); } ret = 0; end: BIO_free(in); BIO_free_all(out); NETSCAPE_CERT_SEQUENCE_free(seq); return (ret); }"
13404----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6eaeed1fc25440b9076ab3d5c66bb193525d4391_1.json----BIO_get_accept_socket,"int BIO_get_accept_socket(char *host, int bind_mode) { int ret=0; struct sockaddr_in server,client; <S2SV_StartVul> int s= -1,cs; <S2SV_EndVul> unsigned char ip[4]; unsigned short port; <S2SV_StartVul> char *str,*e; <S2SV_EndVul> const char *h,*p; unsigned long l; int err_num; if (BIO_sock_init() != 1) return(INVALID_SOCKET); if ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET); h=p=NULL; h=str; for (e=str; *e; e++) { if (*e == ':') { p= &(e[1]); *e='\0'; } else if (*e == '/') { *e='\0'; break; } } if (p == NULL) { p=h; h=""*""; } <S2SV_StartVul> if (!BIO_get_port(p,&port)) return(INVALID_SOCKET); <S2SV_EndVul> memset((char *)&server,0,sizeof(server)); server.sin_family=AF_INET; server.sin_port=htons(port); if (strcmp(h,""*"") == 0) server.sin_addr.s_addr=INADDR_ANY; else { <S2SV_StartVul> if (!BIO_get_host_ip(h,&(ip[0]))) return(INVALID_SOCKET); <S2SV_EndVul> l=(unsigned long) ((unsigned long)ip[0]<<24L)| ((unsigned long)ip[1]<<16L)| ((unsigned long)ip[2]<< 8L)| ((unsigned long)ip[3]); server.sin_addr.s_addr=htonl(l); } again: s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL); if (s == INVALID_SOCKET) { SYSerr(SYS_F_SOCKET,get_last_socket_error()); ERR_add_error_data(3,""port='"",host,""'""); BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET); goto err; } #ifdef SO_REUSEADDR if (bind_mode == BIO_BIND_REUSEADDR) { int i=1; ret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i)); bind_mode=BIO_BIND_NORMAL; } #endif if (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1) { #ifdef SO_REUSEADDR err_num=get_last_socket_error(); if ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) && (err_num == EADDRINUSE)) { memcpy((char *)&client,(char *)&server,sizeof(server)); if (strcmp(h,""*"") == 0) client.sin_addr.s_addr=htonl(0x7F000001); cs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL); if (cs != INVALID_SOCKET) { int ii; ii=connect(cs,(struct sockaddr *)&client, sizeof(client)); closesocket(cs); if (ii == INVALID_SOCKET) { bind_mode=BIO_BIND_REUSEADDR; closesocket(s); goto again; } } } #endif SYSerr(SYS_F_BIND,err_num); ERR_add_error_data(3,""port='"",host,""'""); BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET); goto err; } if (listen(s,MAX_LISTEN) == -1) { SYSerr(SYS_F_BIND,get_last_socket_error()); ERR_add_error_data(3,""port='"",host,""'""); BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET); goto err; } ret=1; err: if (str != NULL) OPENSSL_free(str); if ((ret == 0) && (s != INVALID_SOCKET)) { closesocket(s); s= INVALID_SOCKET; } return(s); }","- int s= -1,cs;
- char *str,*e;
- if (!BIO_get_port(p,&port)) return(INVALID_SOCKET);
- if (!BIO_get_host_ip(h,&(ip[0]))) return(INVALID_SOCKET);
+ int s=INVALID_SOCKET,cs;
+ char *str=NULL,*e;
+ if (!BIO_get_port(p,&port)) goto err;
+ if (!BIO_get_host_ip(h,&(ip[0]))) goto err;","int BIO_get_accept_socket(char *host, int bind_mode) { int ret=0; struct sockaddr_in server,client; int s=INVALID_SOCKET,cs; unsigned char ip[4]; unsigned short port; char *str=NULL,*e; const char *h,*p; unsigned long l; int err_num; if (BIO_sock_init() != 1) return(INVALID_SOCKET); if ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET); h=p=NULL; h=str; for (e=str; *e; e++) { if (*e == ':') { p= &(e[1]); *e='\0'; } else if (*e == '/') { *e='\0'; break; } } if (p == NULL) { p=h; h=""*""; } if (!BIO_get_port(p,&port)) goto err; memset((char *)&server,0,sizeof(server)); server.sin_family=AF_INET; server.sin_port=htons(port); if (strcmp(h,""*"") == 0) server.sin_addr.s_addr=INADDR_ANY; else { if (!BIO_get_host_ip(h,&(ip[0]))) goto err; l=(unsigned long) ((unsigned long)ip[0]<<24L)| ((unsigned long)ip[1]<<16L)| ((unsigned long)ip[2]<< 8L)| ((unsigned long)ip[3]); server.sin_addr.s_addr=htonl(l); } again: s=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL); if (s == INVALID_SOCKET) { SYSerr(SYS_F_SOCKET,get_last_socket_error()); ERR_add_error_data(3,""port='"",host,""'""); BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET); goto err; } #ifdef SO_REUSEADDR if (bind_mode == BIO_BIND_REUSEADDR) { int i=1; ret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i)); bind_mode=BIO_BIND_NORMAL; } #endif if (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1) { #ifdef SO_REUSEADDR err_num=get_last_socket_error(); if ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) && (err_num == EADDRINUSE)) { memcpy((char *)&client,(char *)&server,sizeof(server)); if (strcmp(h,""*"") == 0) client.sin_addr.s_addr=htonl(0x7F000001); cs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL); if (cs != INVALID_SOCKET) { int ii; ii=connect(cs,(struct sockaddr *)&client, sizeof(client)); closesocket(cs); if (ii == INVALID_SOCKET) { bind_mode=BIO_BIND_REUSEADDR; closesocket(s); goto again; } } } #endif SYSerr(SYS_F_BIND,err_num); ERR_add_error_data(3,""port='"",host,""'""); BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET); goto err; } if (listen(s,MAX_LISTEN) == -1) { SYSerr(SYS_F_BIND,get_last_socket_error()); ERR_add_error_data(3,""port='"",host,""'""); BIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET); goto err; } ret=1; err: if (str != NULL) OPENSSL_free(str); if ((ret == 0) && (s != INVALID_SOCKET)) { closesocket(s); s= INVALID_SOCKET; } return(s); }"
3749----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_c9c38ef562721b38c036c4419a4a08588e9cb77b_1.json----configure_video_filters,"<S2SV_StartVul> static int configure_video_filters(FilterGraph *fg) <S2SV_EndVul> { InputStream *ist = fg->inputs[0]->ist; OutputStream *ost = fg->outputs[0]->ost; <S2SV_StartVul> AVFilterContext *in_filter, *out_filter, *filter; <S2SV_EndVul> AVCodecContext *codec = ost->st->codec; char *pix_fmts; AVRational sample_aspect_ratio; char args[255]; int ret; <S2SV_StartVul> avfilter_graph_free(&fg->graph); <S2SV_EndVul> <S2SV_StartVul> fg->graph = avfilter_graph_alloc(); <S2SV_EndVul> if (ist->st->sample_aspect_ratio.num) { sample_aspect_ratio = ist->st->sample_aspect_ratio; } else sample_aspect_ratio = ist->st->codec->sample_aspect_ratio; snprintf(args, 255, ""%d:%d:%d:%d:%d:%d:%d"", ist->st->codec->width, ist->st->codec->height, ist->st->codec->pix_fmt, 1, AV_TIME_BASE, sample_aspect_ratio.num, sample_aspect_ratio.den); ret = avfilter_graph_create_filter(&fg->inputs[0]->filter, avfilter_get_by_name(""buffer""), ""src"", args, NULL, fg->graph); if (ret < 0) return ret; ret = avfilter_graph_create_filter(&fg->outputs[0]->filter, avfilter_get_by_name(""buffersink""), ""out"", NULL, NULL, fg->graph); if (ret < 0) return ret; <S2SV_StartVul> in_filter = fg->inputs[0]->filter; <S2SV_EndVul> <S2SV_StartVul> out_filter = fg->outputs[0]->filter; <S2SV_EndVul> if (codec->width || codec->height) { snprintf(args, 255, ""%d:%d:flags=0x%X"", codec->width, codec->height, (unsigned)ost->sws_flags); if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name(""scale""), NULL, args, NULL, fg->graph)) < 0) return ret; <S2SV_StartVul> if ((ret = avfilter_link(in_filter, 0, filter, 0)) < 0) <S2SV_EndVul> return ret; <S2SV_StartVul> in_filter = filter; <S2SV_EndVul> } <S2SV_StartVul> if ((pix_fmts = choose_pixel_fmts(ost))) { <S2SV_EndVul> if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name(""format""), ""format"", pix_fmts, NULL, fg->graph)) < 0) return ret; <S2SV_StartVul> if ((ret = avfilter_link(filter, 0, out_filter, 0)) < 0) <S2SV_EndVul> return ret; <S2SV_StartVul> out_filter = filter; <S2SV_EndVul> av_freep(&pix_fmts); } snprintf(args, sizeof(args), ""flags=0x%X"", (unsigned)ost->sws_flags); fg->graph->scale_sws_opts = av_strdup(args); if (ost->avfilter) { AVFilterInOut *outputs = avfilter_inout_alloc(); AVFilterInOut *inputs = avfilter_inout_alloc(); outputs->name = av_strdup(""in""); outputs->filter_ctx = in_filter; outputs->pad_idx = 0; outputs->next = NULL; inputs->name = av_strdup(""out""); inputs->filter_ctx = out_filter; inputs->pad_idx = 0; inputs->next = NULL; if ((ret = avfilter_graph_parse(fg->graph, ost->avfilter, inputs, outputs, NULL)) < 0) return ret; } else { if ((ret = avfilter_link(in_filter, 0, out_filter, 0)) < 0) return ret; } if ((ret = avfilter_graph_config(fg->graph, NULL)) < 0) return ret; ost->filter = fg->outputs[0]; return 0; }","- static int configure_video_filters(FilterGraph *fg)
- AVFilterContext *in_filter, *out_filter, *filter;
- avfilter_graph_free(&fg->graph);
- fg->graph = avfilter_graph_alloc();
- in_filter = fg->inputs[0]->filter;
- out_filter = fg->outputs[0]->filter;
- if ((ret = avfilter_link(in_filter, 0, filter, 0)) < 0)
- in_filter = filter;
- if ((pix_fmts = choose_pixel_fmts(ost))) {
- if ((ret = avfilter_link(filter, 0, out_filter, 0)) < 0)
- out_filter = filter;
+ static int configure_video_filters(FilterGraph *fg, AVFilterContext **in_filter,
+ AVFilterContext **out_filter)
+ AVFilterContext *filter;
+ if ((ret = avfilter_link(*in_filter, 0, filter, 0)) < 0)
+ if ((pix_fmts = choose_pix_fmts(ost))) {
+ if ((ret = avfilter_link(filter, 0, *out_filter, 0)) < 0)
+ return 0;
+ }","static int configure_video_filters(FilterGraph *fg, AVFilterContext **in_filter, AVFilterContext **out_filter) { InputStream *ist = fg->inputs[0]->ist; OutputStream *ost = fg->outputs[0]->ost; AVFilterContext *filter; AVCodecContext *codec = ost->st->codec; char *pix_fmts; AVRational sample_aspect_ratio; char args[255]; int ret; if (ist->st->sample_aspect_ratio.num) { sample_aspect_ratio = ist->st->sample_aspect_ratio; } else sample_aspect_ratio = ist->st->codec->sample_aspect_ratio; snprintf(args, 255, ""%d:%d:%d:%d:%d:%d:%d"", ist->st->codec->width, ist->st->codec->height, ist->st->codec->pix_fmt, 1, AV_TIME_BASE, sample_aspect_ratio.num, sample_aspect_ratio.den); ret = avfilter_graph_create_filter(&fg->inputs[0]->filter, avfilter_get_by_name(""buffer""), ""src"", args, NULL, fg->graph); if (ret < 0) return ret; ret = avfilter_graph_create_filter(&fg->outputs[0]->filter, avfilter_get_by_name(""buffersink""), ""out"", NULL, NULL, fg->graph); if (ret < 0) return ret; *in_filter = fg->inputs[0]->filter; *out_filter = fg->outputs[0]->filter; if (codec->width || codec->height) { snprintf(args, 255, ""%d:%d:flags=0x%X"", codec->width, codec->height, (unsigned)ost->sws_flags); if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name(""scale""), NULL, args, NULL, fg->graph)) < 0) return ret; if ((ret = avfilter_link(*in_filter, 0, filter, 0)) < 0) return ret; *in_filter = filter; } if ((pix_fmts = choose_pix_fmts(ost))) { if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name(""format""), ""format"", pix_fmts, NULL, fg->graph)) < 0) return ret; if ((ret = avfilter_link(filter, 0, *out_filter, 0)) < 0) return ret; *out_filter = filter; av_freep(&pix_fmts); } snprintf(args, sizeof(args), ""flags=0x%X"", (unsigned)ost->sws_flags); fg->graph->scale_sws_opts = av_strdup(args); return 0; }"
1864----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_665d8476e842a9aa2e3e7125391ccab759863d1b_1.json----hls_read_header,"static int hls_read_header(AVFormatContext *s) { void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb; HLSContext *c = s->priv_data; int ret = 0, i; int highest_cur_seq_no = 0; c->ctx = s; c->interrupt_callback = &s->interrupt_callback; c->strict_std_compliance = s->strict_std_compliance; c->first_packet = 1; c->first_timestamp = AV_NOPTS_VALUE; c->cur_timestamp = AV_NOPTS_VALUE; if (u) { update_options(&c->user_agent, ""user-agent"", u); update_options(&c->cookies, ""cookies"", u); update_options(&c->headers, ""headers"", u); update_options(&c->http_proxy, ""http_proxy"", u); } if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0) goto fail; if ((ret = save_avio_options(s)) < 0) goto fail; av_dict_set(&c->avio_opts, ""seekable"", ""0"", 0); if (c->n_variants == 0) { av_log(NULL, AV_LOG_WARNING, ""Empty playlist\n""); ret = AVERROR_EOF; goto fail; } if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) { for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0) goto fail; } } if (c->variants[0]->playlists[0]->n_segments == 0) { av_log(NULL, AV_LOG_WARNING, ""Empty playlist\n""); ret = AVERROR_EOF; goto fail; } if (c->variants[0]->playlists[0]->finished) { int64_t duration = 0; for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++) duration += c->variants[0]->playlists[0]->segments[i]->duration; s->duration = duration; } for (i = 0; i < c->n_variants; i++) { struct variant *var = c->variants[i]; if (var->audio_group[0]) add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group); if (var->video_group[0]) add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group); if (var->subtitles_group[0]) add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group); } for (i = 0; i < c->n_variants; i++) { struct variant *v = c->variants[i]; AVProgram *program; program = av_new_program(s, i); if (!program) goto fail; av_dict_set_int(&program->metadata, ""variant_bitrate"", v->bandwidth, 0); } for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; if (pls->n_segments == 0) continue; pls->cur_seq_no = select_cur_seq_no(c, pls); highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no); } for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; AVInputFormat *in_fmt = NULL; if (!(pls->ctx = avformat_alloc_context())) { ret = AVERROR(ENOMEM); goto fail; } if (pls->n_segments == 0) continue; pls->index = i; pls->needed = 1; pls->parent = s; if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 && highest_cur_seq_no < pls->start_seq_no + pls->n_segments) { pls->cur_seq_no = highest_cur_seq_no; } pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE); if (!pls->read_buffer){ ret = AVERROR(ENOMEM); avformat_free_context(pls->ctx); pls->ctx = NULL; goto fail; } ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls, read_data, NULL, NULL); pls->pb.seekable = 0; ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url, NULL, 0, 0); if (ret < 0) { av_log(s, AV_LOG_ERROR, ""Error when loading first segment '%s'\n"", pls->segments[0]->url); avformat_free_context(pls->ctx); pls->ctx = NULL; goto fail; } pls->ctx->pb = &pls->pb; pls->ctx->io_open = nested_io_open; if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0) goto fail; ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL); if (ret < 0) goto fail; if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) { ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra); avformat_queue_attached_pictures(pls->ctx); ff_id3v2_free_extra_meta(&pls->id3_deferred_extra); pls->id3_deferred_extra = NULL; } if (pls->is_id3_timestamped == -1) av_log(s, AV_LOG_WARNING, ""No expected HTTP requests have been made\n""); if (pls->is_id3_timestamped) { ret = avformat_find_stream_info(pls->ctx, NULL); if (ret < 0) goto fail; } pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER); ret = update_streams_from_subdemuxer(s, pls); if (ret < 0) goto fail; add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO); add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO); add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE); } update_noheader_flag(s); return 0; fail: <S2SV_StartVul> free_playlist_list(c); <S2SV_EndVul> <S2SV_StartVul> free_variant_list(c); <S2SV_EndVul> <S2SV_StartVul> free_rendition_list(c); <S2SV_EndVul> return ret; }","- free_playlist_list(c);
- free_variant_list(c);
- free_rendition_list(c);
+ hls_close(s);","static int hls_read_header(AVFormatContext *s) { void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb; HLSContext *c = s->priv_data; int ret = 0, i; int highest_cur_seq_no = 0; c->ctx = s; c->interrupt_callback = &s->interrupt_callback; c->strict_std_compliance = s->strict_std_compliance; c->first_packet = 1; c->first_timestamp = AV_NOPTS_VALUE; c->cur_timestamp = AV_NOPTS_VALUE; if (u) { update_options(&c->user_agent, ""user-agent"", u); update_options(&c->cookies, ""cookies"", u); update_options(&c->headers, ""headers"", u); update_options(&c->http_proxy, ""http_proxy"", u); } if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0) goto fail; if ((ret = save_avio_options(s)) < 0) goto fail; av_dict_set(&c->avio_opts, ""seekable"", ""0"", 0); if (c->n_variants == 0) { av_log(NULL, AV_LOG_WARNING, ""Empty playlist\n""); ret = AVERROR_EOF; goto fail; } if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) { for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0) goto fail; } } if (c->variants[0]->playlists[0]->n_segments == 0) { av_log(NULL, AV_LOG_WARNING, ""Empty playlist\n""); ret = AVERROR_EOF; goto fail; } if (c->variants[0]->playlists[0]->finished) { int64_t duration = 0; for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++) duration += c->variants[0]->playlists[0]->segments[i]->duration; s->duration = duration; } for (i = 0; i < c->n_variants; i++) { struct variant *var = c->variants[i]; if (var->audio_group[0]) add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group); if (var->video_group[0]) add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group); if (var->subtitles_group[0]) add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group); } for (i = 0; i < c->n_variants; i++) { struct variant *v = c->variants[i]; AVProgram *program; program = av_new_program(s, i); if (!program) goto fail; av_dict_set_int(&program->metadata, ""variant_bitrate"", v->bandwidth, 0); } for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; if (pls->n_segments == 0) continue; pls->cur_seq_no = select_cur_seq_no(c, pls); highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no); } for (i = 0; i < c->n_playlists; i++) { struct playlist *pls = c->playlists[i]; AVInputFormat *in_fmt = NULL; if (!(pls->ctx = avformat_alloc_context())) { ret = AVERROR(ENOMEM); goto fail; } if (pls->n_segments == 0) continue; pls->index = i; pls->needed = 1; pls->parent = s; if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 && highest_cur_seq_no < pls->start_seq_no + pls->n_segments) { pls->cur_seq_no = highest_cur_seq_no; } pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE); if (!pls->read_buffer){ ret = AVERROR(ENOMEM); avformat_free_context(pls->ctx); pls->ctx = NULL; goto fail; } ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls, read_data, NULL, NULL); pls->pb.seekable = 0; ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url, NULL, 0, 0); if (ret < 0) { av_log(s, AV_LOG_ERROR, ""Error when loading first segment '%s'\n"", pls->segments[0]->url); avformat_free_context(pls->ctx); pls->ctx = NULL; goto fail; } pls->ctx->pb = &pls->pb; pls->ctx->io_open = nested_io_open; if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0) goto fail; ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL); if (ret < 0) goto fail; if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) { ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra); avformat_queue_attached_pictures(pls->ctx); ff_id3v2_free_extra_meta(&pls->id3_deferred_extra); pls->id3_deferred_extra = NULL; } if (pls->is_id3_timestamped == -1) av_log(s, AV_LOG_WARNING, ""No expected HTTP requests have been made\n""); if (pls->is_id3_timestamped) { ret = avformat_find_stream_info(pls->ctx, NULL); if (ret < 0) goto fail; } pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER); ret = update_streams_from_subdemuxer(s, pls); if (ret < 0) goto fail; add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO); add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO); add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE); } update_noheader_flag(s); return 0; fail: hls_close(s); return ret; }"
1984----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6c342ac045ec74a88111188f8b511527d2119c2f_1.json----decode_sgirle8,"static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize) { const uint8_t *src_end = src + src_size; int x = 0, y = 0; #define INC_XY(n) \ x += n; \ if (x >= width) { \ y++; \ if (y >= height) \ return 0; \ x = 0; \ } while (src_end - src >= 2) { uint8_t v = *src++; if (v > 0 && v < 0xC0) { do { int length = FFMIN(v, width - x); memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length); INC_XY(length); v -= length; } while (v > 0); src++; } else if (v >= 0xC1) { v -= 0xC0; do { int length = FFMIN3(v, width - x, src_end - src); <S2SV_StartVul> if (src_end - src < length) <S2SV_EndVul> break; memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length); INC_XY(length); src += length; v -= length; } while (v > 0); } else { avpriv_request_sample(avctx, ""opcode %d"", v); return AVERROR_PATCHWELCOME; } } return 0; }","- if (src_end - src < length)
+ if (length <= 0)
+ break;
+ if (src_end - src < length || length <= 0)","static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize) { const uint8_t *src_end = src + src_size; int x = 0, y = 0; #define INC_XY(n) \ x += n; \ if (x >= width) { \ y++; \ if (y >= height) \ return 0; \ x = 0; \ } while (src_end - src >= 2) { uint8_t v = *src++; if (v > 0 && v < 0xC0) { do { int length = FFMIN(v, width - x); if (length <= 0) break; memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length); INC_XY(length); v -= length; } while (v > 0); src++; } else if (v >= 0xC1) { v -= 0xC0; do { int length = FFMIN3(v, width - x, src_end - src); if (src_end - src < length || length <= 0) break; memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length); INC_XY(length); src += length; v -= length; } while (v > 0); } else { avpriv_request_sample(avctx, ""opcode %d"", v); return AVERROR_PATCHWELCOME; } } return 0; }"
10746----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_116ae88bd361daa0cfac158e4e092d396f93677c_1.json----PEM_dek_info,"void PEM_dek_info(char *buf, const char *type, int len, char *str) { static const unsigned char map[17] = ""0123456789ABCDEF""; long i; int j; <S2SV_StartVul> BUF_strlcat(buf, ""DEK-Info: "", PEM_BUFSIZE); <S2SV_EndVul> <S2SV_StartVul> BUF_strlcat(buf, type, PEM_BUFSIZE); <S2SV_EndVul> <S2SV_StartVul> BUF_strlcat(buf, "","", PEM_BUFSIZE); <S2SV_EndVul> j = strlen(buf); if (j + (len * 2) + 1 > PEM_BUFSIZE) return; for (i = 0; i < len; i++) { buf[j + i * 2] = map[(str[i] >> 4) & 0x0f]; buf[j + i * 2 + 1] = map[(str[i]) & 0x0f]; } buf[j + i * 2] = '\n'; buf[j + i * 2 + 1] = '\0'; }","- BUF_strlcat(buf, ""DEK-Info: "", PEM_BUFSIZE);
- BUF_strlcat(buf, type, PEM_BUFSIZE);
- BUF_strlcat(buf, "","", PEM_BUFSIZE);
+ OPENSSL_strlcat(buf, ""DEK-Info: "", PEM_BUFSIZE);
+ OPENSSL_strlcat(buf, type, PEM_BUFSIZE);
+ OPENSSL_strlcat(buf, "","", PEM_BUFSIZE);","void PEM_dek_info(char *buf, const char *type, int len, char *str) { static const unsigned char map[17] = ""0123456789ABCDEF""; long i; int j; OPENSSL_strlcat(buf, ""DEK-Info: "", PEM_BUFSIZE); OPENSSL_strlcat(buf, type, PEM_BUFSIZE); OPENSSL_strlcat(buf, "","", PEM_BUFSIZE); j = strlen(buf); if (j + (len * 2) + 1 > PEM_BUFSIZE) return; for (i = 0; i < len; i++) { buf[j + i * 2] = map[(str[i] >> 4) & 0x0f]; buf[j + i * 2 + 1] = map[(str[i]) & 0x0f]; } buf[j + i * 2] = '\n'; buf[j + i * 2 + 1] = '\0'; }"
7186----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_85313cf32b4fd059ece5ea69e8df39432cb2e2c9_1.json----vc1_parse_frame_header_adv,"int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb) { int pqindex, lowquant; int status; v->p_frame_skipped = 0; if(v->interlace){ v->fcm = decode012(gb); if(v->fcm){ if(!v->warn_interlaced++) av_log(v->s.avctx, AV_LOG_ERROR, ""Interlaced frames/fields support is not implemented\n""); return -1; } } switch(get_unary(gb, 0, 4)) { case 0: v->s.pict_type = AV_PICTURE_TYPE_P; break; case 1: v->s.pict_type = AV_PICTURE_TYPE_B; break; case 2: v->s.pict_type = AV_PICTURE_TYPE_I; break; case 3: v->s.pict_type = AV_PICTURE_TYPE_BI; break; case 4: v->s.pict_type = AV_PICTURE_TYPE_P; v->p_frame_skipped = 1; <S2SV_StartVul> return 0; <S2SV_EndVul> } if(v->tfcntrflag) skip_bits(gb, 8); if(v->broadcast) { if(!v->interlace || v->psf) { v->rptfrm = get_bits(gb, 2); } else { v->tff = get_bits1(gb); <S2SV_StartVul> v->rptfrm = get_bits1(gb); <S2SV_EndVul> } } if(v->panscanflag) { av_log_missing_feature(v->s.avctx, ""Pan-scan"", 0); } v->rnd = get_bits1(gb); if(v->interlace) v->uvsamp = get_bits1(gb); if(v->finterpflag) v->interpfrm = get_bits1(gb); if(v->s.pict_type == AV_PICTURE_TYPE_B) { v->bfraction_lut_index = get_vlc2(gb, ff_vc1_bfraction_vlc.table, VC1_BFRACTION_VLC_BITS, 1); v->bfraction = ff_vc1_bfraction_lut[v->bfraction_lut_index]; if(v->bfraction == 0) { v->s.pict_type = AV_PICTURE_TYPE_BI; } } pqindex = get_bits(gb, 5); if(!pqindex) return -1; v->pqindex = pqindex; if (v->quantizer_mode == QUANT_FRAME_IMPLICIT) v->pq = ff_vc1_pquant_table[0][pqindex]; else v->pq = ff_vc1_pquant_table[1][pqindex]; v->pquantizer = 1; if (v->quantizer_mode == QUANT_FRAME_IMPLICIT) v->pquantizer = pqindex < 9; if (v->quantizer_mode == QUANT_NON_UNIFORM) v->pquantizer = 0; v->pqindex = pqindex; if (pqindex < 9) v->halfpq = get_bits1(gb); else v->halfpq = 0; if (v->quantizer_mode == QUANT_FRAME_EXPLICIT) v->pquantizer = get_bits1(gb); if(v->postprocflag) v->postproc = get_bits(gb, 2); if(v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_P) v->use_ic = 0; if(v->parse_only) return 0; switch(v->s.pict_type) { case AV_PICTURE_TYPE_I: case AV_PICTURE_TYPE_BI: status = bitplane_decoding(v->acpred_plane, &v->acpred_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""ACPRED plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); v->condover = CONDOVER_NONE; if(v->overlap && v->pq <= 8) { v->condover = decode012(gb); if(v->condover == CONDOVER_SELECT) { status = bitplane_decoding(v->over_flags_plane, &v->overflg_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""CONDOVER plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); } } break; case AV_PICTURE_TYPE_P: if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3); else v->mvrange = 0; v->k_x = v->mvrange + 9 + (v->mvrange >> 1); v->k_y = v->mvrange + 8; v->range_x = 1 << (v->k_x - 1); v->range_y = 1 << (v->k_y - 1); if (v->pq < 5) v->tt_index = 0; else if(v->pq < 13) v->tt_index = 1; else v->tt_index = 2; lowquant = (v->pq > 12) ? 0 : 1; v->mv_mode = ff_vc1_mv_pmode_table[lowquant][get_unary(gb, 1, 4)]; if (v->mv_mode == MV_PMODE_INTENSITY_COMP) { int scale, shift, i; v->mv_mode2 = ff_vc1_mv_pmode_table2[lowquant][get_unary(gb, 1, 3)]; v->lumscale = get_bits(gb, 6); v->lumshift = get_bits(gb, 6); if(!v->lumscale) { scale = -64; shift = (255 - v->lumshift * 2) << 6; if(v->lumshift > 31) shift += 128 << 6; } else { scale = v->lumscale + 32; if(v->lumshift > 31) shift = (v->lumshift - 64) << 6; else shift = v->lumshift << 6; } for(i = 0; i < 256; i++) { v->luty[i] = av_clip_uint8((scale * i + shift + 32) >> 6); v->lutuv[i] = av_clip_uint8((scale * (i - 128) + 128*64 + 32) >> 6); } v->use_ic = 1; } if(v->mv_mode == MV_PMODE_1MV_HPEL || v->mv_mode == MV_PMODE_1MV_HPEL_BILIN) v->s.quarter_sample = 0; else if(v->mv_mode == MV_PMODE_INTENSITY_COMP) { if(v->mv_mode2 == MV_PMODE_1MV_HPEL || v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN) v->s.quarter_sample = 0; else v->s.quarter_sample = 1; } else v->s.quarter_sample = 1; v->s.mspel = !(v->mv_mode == MV_PMODE_1MV_HPEL_BILIN || (v->mv_mode == MV_PMODE_INTENSITY_COMP && v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN)); if ((v->mv_mode == MV_PMODE_INTENSITY_COMP && v->mv_mode2 == MV_PMODE_MIXED_MV) || v->mv_mode == MV_PMODE_MIXED_MV) { status = bitplane_decoding(v->mv_type_mb_plane, &v->mv_type_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); } else { v->mv_type_is_raw = 0; memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height); } status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Skip plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); v->s.mv_table_index = get_bits(gb, 2); v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)]; if (v->dquant) { av_log(v->s.avctx, AV_LOG_DEBUG, ""VOP DQuant info\n""); vop_dquant_decoding(v); } v->ttfrm = 0; if (v->vstransform) { v->ttmbf = get_bits1(gb); if (v->ttmbf) { v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)]; } } else { v->ttmbf = 1; v->ttfrm = TT_8X8; } break; case AV_PICTURE_TYPE_B: if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3); else v->mvrange = 0; v->k_x = v->mvrange + 9 + (v->mvrange >> 1); v->k_y = v->mvrange + 8; v->range_x = 1 << (v->k_x - 1); v->range_y = 1 << (v->k_y - 1); if (v->pq < 5) v->tt_index = 0; else if(v->pq < 13) v->tt_index = 1; else v->tt_index = 2; v->mv_mode = get_bits1(gb) ? MV_PMODE_1MV : MV_PMODE_1MV_HPEL_BILIN; v->s.quarter_sample = (v->mv_mode == MV_PMODE_1MV); v->s.mspel = v->s.quarter_sample; status = bitplane_decoding(v->direct_mb_plane, &v->dmb_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct Type plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Skip plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); v->s.mv_table_index = get_bits(gb, 2); v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)]; if (v->dquant) { av_log(v->s.avctx, AV_LOG_DEBUG, ""VOP DQuant info\n""); vop_dquant_decoding(v); } v->ttfrm = 0; if (v->vstransform) { v->ttmbf = get_bits1(gb); if (v->ttmbf) { v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)]; } } else { v->ttmbf = 1; v->ttfrm = TT_8X8; } break; } v->c_ac_table_index = decode012(gb); if (v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI) { v->y_ac_table_index = decode012(gb); } v->s.dc_table_index = get_bits1(gb); if ((v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI) && v->dquant) { av_log(v->s.avctx, AV_LOG_DEBUG, ""VOP DQuant info\n""); vop_dquant_decoding(v); } v->bi_type = 0; if(v->s.pict_type == AV_PICTURE_TYPE_BI) { v->s.pict_type = AV_PICTURE_TYPE_B; v->bi_type = 1; } return 0; }","- return 0;
- v->rptfrm = get_bits1(gb);
+ break;
+ v->rff = get_bits1(gb);
+ if(v->p_frame_skipped) {
+ return 0;
+ }","int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb) { int pqindex, lowquant; int status; v->p_frame_skipped = 0; if(v->interlace){ v->fcm = decode012(gb); if(v->fcm){ if(!v->warn_interlaced++) av_log(v->s.avctx, AV_LOG_ERROR, ""Interlaced frames/fields support is not implemented\n""); return -1; } } switch(get_unary(gb, 0, 4)) { case 0: v->s.pict_type = AV_PICTURE_TYPE_P; break; case 1: v->s.pict_type = AV_PICTURE_TYPE_B; break; case 2: v->s.pict_type = AV_PICTURE_TYPE_I; break; case 3: v->s.pict_type = AV_PICTURE_TYPE_BI; break; case 4: v->s.pict_type = AV_PICTURE_TYPE_P; v->p_frame_skipped = 1; break; } if(v->tfcntrflag) skip_bits(gb, 8); if(v->broadcast) { if(!v->interlace || v->psf) { v->rptfrm = get_bits(gb, 2); } else { v->tff = get_bits1(gb); v->rff = get_bits1(gb); } } if(v->panscanflag) { av_log_missing_feature(v->s.avctx, ""Pan-scan"", 0); } if(v->p_frame_skipped) { return 0; } v->rnd = get_bits1(gb); if(v->interlace) v->uvsamp = get_bits1(gb); if(v->finterpflag) v->interpfrm = get_bits1(gb); if(v->s.pict_type == AV_PICTURE_TYPE_B) { v->bfraction_lut_index = get_vlc2(gb, ff_vc1_bfraction_vlc.table, VC1_BFRACTION_VLC_BITS, 1); v->bfraction = ff_vc1_bfraction_lut[v->bfraction_lut_index]; if(v->bfraction == 0) { v->s.pict_type = AV_PICTURE_TYPE_BI; } } pqindex = get_bits(gb, 5); if(!pqindex) return -1; v->pqindex = pqindex; if (v->quantizer_mode == QUANT_FRAME_IMPLICIT) v->pq = ff_vc1_pquant_table[0][pqindex]; else v->pq = ff_vc1_pquant_table[1][pqindex]; v->pquantizer = 1; if (v->quantizer_mode == QUANT_FRAME_IMPLICIT) v->pquantizer = pqindex < 9; if (v->quantizer_mode == QUANT_NON_UNIFORM) v->pquantizer = 0; v->pqindex = pqindex; if (pqindex < 9) v->halfpq = get_bits1(gb); else v->halfpq = 0; if (v->quantizer_mode == QUANT_FRAME_EXPLICIT) v->pquantizer = get_bits1(gb); if(v->postprocflag) v->postproc = get_bits(gb, 2); if(v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_P) v->use_ic = 0; if(v->parse_only) return 0; switch(v->s.pict_type) { case AV_PICTURE_TYPE_I: case AV_PICTURE_TYPE_BI: status = bitplane_decoding(v->acpred_plane, &v->acpred_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""ACPRED plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); v->condover = CONDOVER_NONE; if(v->overlap && v->pq <= 8) { v->condover = decode012(gb); if(v->condover == CONDOVER_SELECT) { status = bitplane_decoding(v->over_flags_plane, &v->overflg_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""CONDOVER plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); } } break; case AV_PICTURE_TYPE_P: if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3); else v->mvrange = 0; v->k_x = v->mvrange + 9 + (v->mvrange >> 1); v->k_y = v->mvrange + 8; v->range_x = 1 << (v->k_x - 1); v->range_y = 1 << (v->k_y - 1); if (v->pq < 5) v->tt_index = 0; else if(v->pq < 13) v->tt_index = 1; else v->tt_index = 2; lowquant = (v->pq > 12) ? 0 : 1; v->mv_mode = ff_vc1_mv_pmode_table[lowquant][get_unary(gb, 1, 4)]; if (v->mv_mode == MV_PMODE_INTENSITY_COMP) { int scale, shift, i; v->mv_mode2 = ff_vc1_mv_pmode_table2[lowquant][get_unary(gb, 1, 3)]; v->lumscale = get_bits(gb, 6); v->lumshift = get_bits(gb, 6); if(!v->lumscale) { scale = -64; shift = (255 - v->lumshift * 2) << 6; if(v->lumshift > 31) shift += 128 << 6; } else { scale = v->lumscale + 32; if(v->lumshift > 31) shift = (v->lumshift - 64) << 6; else shift = v->lumshift << 6; } for(i = 0; i < 256; i++) { v->luty[i] = av_clip_uint8((scale * i + shift + 32) >> 6); v->lutuv[i] = av_clip_uint8((scale * (i - 128) + 128*64 + 32) >> 6); } v->use_ic = 1; } if(v->mv_mode == MV_PMODE_1MV_HPEL || v->mv_mode == MV_PMODE_1MV_HPEL_BILIN) v->s.quarter_sample = 0; else if(v->mv_mode == MV_PMODE_INTENSITY_COMP) { if(v->mv_mode2 == MV_PMODE_1MV_HPEL || v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN) v->s.quarter_sample = 0; else v->s.quarter_sample = 1; } else v->s.quarter_sample = 1; v->s.mspel = !(v->mv_mode == MV_PMODE_1MV_HPEL_BILIN || (v->mv_mode == MV_PMODE_INTENSITY_COMP && v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN)); if ((v->mv_mode == MV_PMODE_INTENSITY_COMP && v->mv_mode2 == MV_PMODE_MIXED_MV) || v->mv_mode == MV_PMODE_MIXED_MV) { status = bitplane_decoding(v->mv_type_mb_plane, &v->mv_type_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); } else { v->mv_type_is_raw = 0; memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height); } status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Skip plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); v->s.mv_table_index = get_bits(gb, 2); v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)]; if (v->dquant) { av_log(v->s.avctx, AV_LOG_DEBUG, ""VOP DQuant info\n""); vop_dquant_decoding(v); } v->ttfrm = 0; if (v->vstransform) { v->ttmbf = get_bits1(gb); if (v->ttmbf) { v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)]; } } else { v->ttmbf = 1; v->ttfrm = TT_8X8; } break; case AV_PICTURE_TYPE_B: if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3); else v->mvrange = 0; v->k_x = v->mvrange + 9 + (v->mvrange >> 1); v->k_y = v->mvrange + 8; v->range_x = 1 << (v->k_x - 1); v->range_y = 1 << (v->k_y - 1); if (v->pq < 5) v->tt_index = 0; else if(v->pq < 13) v->tt_index = 1; else v->tt_index = 2; v->mv_mode = get_bits1(gb) ? MV_PMODE_1MV : MV_PMODE_1MV_HPEL_BILIN; v->s.quarter_sample = (v->mv_mode == MV_PMODE_1MV); v->s.mspel = v->s.quarter_sample; status = bitplane_decoding(v->direct_mb_plane, &v->dmb_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct Type plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v); if (status < 0) return -1; av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Skip plane encoding: "" ""Imode: %i, Invert: %i\n"", status>>1, status&1); v->s.mv_table_index = get_bits(gb, 2); v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)]; if (v->dquant) { av_log(v->s.avctx, AV_LOG_DEBUG, ""VOP DQuant info\n""); vop_dquant_decoding(v); } v->ttfrm = 0; if (v->vstransform) { v->ttmbf = get_bits1(gb); if (v->ttmbf) { v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)]; } } else { v->ttmbf = 1; v->ttfrm = TT_8X8; } break; } v->c_ac_table_index = decode012(gb); if (v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI) { v->y_ac_table_index = decode012(gb); } v->s.dc_table_index = get_bits1(gb); if ((v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI) && v->dquant) { av_log(v->s.avctx, AV_LOG_DEBUG, ""VOP DQuant info\n""); vop_dquant_decoding(v); } v->bi_type = 0; if(v->s.pict_type == AV_PICTURE_TYPE_BI) { v->s.pict_type = AV_PICTURE_TYPE_B; v->bi_type = 1; } return 0; }"
9874----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_18fdcecbb7f758386bd512fb3518ac4097bbf3be_1.json----ngx_http_upstream_finalize_request,"static void ngx_http_upstream_finalize_request(ngx_http_request_t *r, ngx_http_upstream_t *u, ngx_int_t rc) { ngx_uint_t flush; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""finalize http upstream request: %i"", rc); if (u->cleanup == NULL) { ngx_http_finalize_request(r, NGX_DONE); return; } *u->cleanup = NULL; u->cleanup = NULL; if (u->resolved && u->resolved->ctx) { ngx_resolve_name_done(u->resolved->ctx); u->resolved->ctx = NULL; } if (u->state && u->state->response_time) { u->state->response_time = ngx_current_msec - u->state->response_time; if (u->pipe && u->pipe->read_length) { u->state->bytes_received += u->pipe->read_length - u->pipe->preread_size; u->state->response_length = u->pipe->read_length; } } u->finalize_request(r, rc); if (u->peer.free && u->peer.sockaddr) { u->peer.free(&u->peer, u->peer.data, 0); u->peer.sockaddr = NULL; } if (u->peer.connection) { #if (NGX_HTTP_SSL) if (u->peer.connection->ssl) { u->peer.connection->ssl->no_wait_shutdown = 1; (void) ngx_ssl_shutdown(u->peer.connection); } #endif ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""close http upstream connection: %d"", u->peer.connection->fd); if (u->peer.connection->pool) { ngx_destroy_pool(u->peer.connection->pool); } ngx_close_connection(u->peer.connection); } u->peer.connection = NULL; if (u->pipe && u->pipe->temp_file) { ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream temp fd: %d"", u->pipe->temp_file->file.fd); } if (u->store && u->pipe && u->pipe->temp_file && u->pipe->temp_file->file.fd != NGX_INVALID_FILE) { if (ngx_delete_file(u->pipe->temp_file->file.name.data) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, ngx_delete_file_n "" \""%s\"" failed"", u->pipe->temp_file->file.name.data); } } #if (NGX_HTTP_CACHE) if (r->cache) { if (u->cacheable) { if (rc == NGX_HTTP_BAD_GATEWAY || rc == NGX_HTTP_GATEWAY_TIME_OUT) { time_t valid; valid = ngx_http_file_cache_valid(u->conf->cache_valid, rc); if (valid) { r->cache->valid_sec = ngx_time() + valid; r->cache->error = rc; } } } ngx_http_file_cache_free(r->cache, u->pipe->temp_file); } #endif if (r->subrequest_in_memory && u->headers_in.status_n >= NGX_HTTP_SPECIAL_RESPONSE) { u->buffer.last = u->buffer.pos; } r->read_event_handler = ngx_http_block_reading; if (rc == NGX_DECLINED) { return; } r->connection->log->action = ""sending to client""; if (!u->header_sent || rc == NGX_HTTP_REQUEST_TIME_OUT <S2SV_StartVul> || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST <S2SV_EndVul> <S2SV_StartVul> || (u->pipe && u->pipe->downstream_error)) <S2SV_EndVul> { ngx_http_finalize_request(r, rc); return; } flush = 0; if (rc >= NGX_HTTP_SPECIAL_RESPONSE) { rc = NGX_ERROR; flush = 1; } <S2SV_StartVul> if (r->header_only) { <S2SV_EndVul> ngx_http_finalize_request(r, rc); return; } if (rc == 0) { rc = ngx_http_send_special(r, NGX_HTTP_LAST); } else if (flush) { r->keepalive = 0; rc = ngx_http_send_special(r, NGX_HTTP_FLUSH); } ngx_http_finalize_request(r, rc); }","- || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST
- || (u->pipe && u->pipe->downstream_error))
- if (r->header_only) {
+ || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST)
+ if (r->header_only
+ || (u->pipe && u->pipe->downstream_error))
+ {","static void ngx_http_upstream_finalize_request(ngx_http_request_t *r, ngx_http_upstream_t *u, ngx_int_t rc) { ngx_uint_t flush; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""finalize http upstream request: %i"", rc); if (u->cleanup == NULL) { ngx_http_finalize_request(r, NGX_DONE); return; } *u->cleanup = NULL; u->cleanup = NULL; if (u->resolved && u->resolved->ctx) { ngx_resolve_name_done(u->resolved->ctx); u->resolved->ctx = NULL; } if (u->state && u->state->response_time) { u->state->response_time = ngx_current_msec - u->state->response_time; if (u->pipe && u->pipe->read_length) { u->state->bytes_received += u->pipe->read_length - u->pipe->preread_size; u->state->response_length = u->pipe->read_length; } } u->finalize_request(r, rc); if (u->peer.free && u->peer.sockaddr) { u->peer.free(&u->peer, u->peer.data, 0); u->peer.sockaddr = NULL; } if (u->peer.connection) { #if (NGX_HTTP_SSL) if (u->peer.connection->ssl) { u->peer.connection->ssl->no_wait_shutdown = 1; (void) ngx_ssl_shutdown(u->peer.connection); } #endif ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""close http upstream connection: %d"", u->peer.connection->fd); if (u->peer.connection->pool) { ngx_destroy_pool(u->peer.connection->pool); } ngx_close_connection(u->peer.connection); } u->peer.connection = NULL; if (u->pipe && u->pipe->temp_file) { ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream temp fd: %d"", u->pipe->temp_file->file.fd); } if (u->store && u->pipe && u->pipe->temp_file && u->pipe->temp_file->file.fd != NGX_INVALID_FILE) { if (ngx_delete_file(u->pipe->temp_file->file.name.data) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, ngx_delete_file_n "" \""%s\"" failed"", u->pipe->temp_file->file.name.data); } } #if (NGX_HTTP_CACHE) if (r->cache) { if (u->cacheable) { if (rc == NGX_HTTP_BAD_GATEWAY || rc == NGX_HTTP_GATEWAY_TIME_OUT) { time_t valid; valid = ngx_http_file_cache_valid(u->conf->cache_valid, rc); if (valid) { r->cache->valid_sec = ngx_time() + valid; r->cache->error = rc; } } } ngx_http_file_cache_free(r->cache, u->pipe->temp_file); } #endif if (r->subrequest_in_memory && u->headers_in.status_n >= NGX_HTTP_SPECIAL_RESPONSE) { u->buffer.last = u->buffer.pos; } r->read_event_handler = ngx_http_block_reading; if (rc == NGX_DECLINED) { return; } r->connection->log->action = ""sending to client""; if (!u->header_sent || rc == NGX_HTTP_REQUEST_TIME_OUT || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST) { ngx_http_finalize_request(r, rc); return; } flush = 0; if (rc >= NGX_HTTP_SPECIAL_RESPONSE) { rc = NGX_ERROR; flush = 1; } if (r->header_only || (u->pipe && u->pipe->downstream_error)) { ngx_http_finalize_request(r, rc); return; } if (rc == 0) { rc = ngx_http_send_special(r, NGX_HTTP_LAST); } else if (flush) { r->keepalive = 0; rc = ngx_http_send_special(r, NGX_HTTP_FLUSH); } ngx_http_finalize_request(r, rc); }"
1362----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4aee4f7d228c05591e23cd9cc81e6eb9b6fc42cf_1.json----scene_sad16,"<S2SV_StartVul> static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, int height) <S2SV_EndVul> { int64_t sad; int x, y; <S2SV_StartVul> for (sad = y = 0; y < height; y += 8) { <S2SV_EndVul> <S2SV_StartVul> for (x = 0; x < p1_linesize; x += 8) { <S2SV_EndVul> sad += sad_8x8_16(p1 + y * p1_linesize + x, p1_linesize, p2 + y * p2_linesize + x, p2_linesize); } } return sad; }","- static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, int height)
- for (sad = y = 0; y < height; y += 8) {
- for (x = 0; x < p1_linesize; x += 8) {
+ static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, const int width, const int height)
+ for (sad = y = 0; y < height - 7; y += 8) {
+ for (x = 0; x < width - 7; x += 8) {","static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, const int width, const int height) { int64_t sad; int x, y; for (sad = y = 0; y < height - 7; y += 8) { for (x = 0; x < width - 7; x += 8) { sad += sad_8x8_16(p1 + y * p1_linesize + x, p1_linesize, p2 + y * p2_linesize + x, p2_linesize); } } return sad; }"
6078----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_1.json----check_output_constraints,"static int check_output_constraints(InputStream *ist, OutputStream *ost) { <S2SV_StartVul> OutputFile *of = &output_files[ost->file_index]; <S2SV_EndVul> <S2SV_StartVul> int ist_index = ist - input_streams; <S2SV_EndVul> if (ost->source_index != ist_index) return 0; if (of->start_time && ist->last_dts < of->start_time) return 0; return 1; }","- OutputFile *of = &output_files[ost->file_index];
- int ist_index = ist - input_streams;
+ OutputFile *of = output_files[ost->file_index];
+ int ist_index = input_files[ist->file_index]->ist_index + ist->st->index;","static int check_output_constraints(InputStream *ist, OutputStream *ost) { OutputFile *of = output_files[ost->file_index]; int ist_index = input_files[ist->file_index]->ist_index + ist->st->index; if (ost->source_index != ist_index) return 0; if (of->start_time && ist->last_dts < of->start_time) return 0; return 1; }"
251----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0ef01e07116080f9ea0b2c831c54515dce008181_1.json----av_image_get_linesize,"int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt); int max_step [4]; int max_step_comp[4]; <S2SV_StartVul> if ((unsigned)pix_fmt >= AV_PIX_FMT_NB || desc->flags & AV_PIX_FMT_FLAG_HWACCEL) <S2SV_EndVul> return AVERROR(EINVAL); av_image_fill_max_pixsteps(max_step, max_step_comp, desc); return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc); }","- if ((unsigned)pix_fmt >= AV_PIX_FMT_NB || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)
+ if (!desc || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)","int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt); int max_step [4]; int max_step_comp[4]; if (!desc || desc->flags & AV_PIX_FMT_FLAG_HWACCEL) return AVERROR(EINVAL); av_image_fill_max_pixsteps(max_step, max_step_comp, desc); return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc); }"
153----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_098ed9ede86eb1eb57b8bc2c35e265e315eb4a82_1.json----decode_chunks,"static int decode_chunks(AVCodecContext *avctx, AVFrame *picture, int *data_size, const uint8_t *buf, int buf_size) { Mpeg1Context *s = avctx->priv_data; MpegEncContext *s2 = &s->mpeg_enc_ctx; const uint8_t *buf_ptr = buf; const uint8_t *buf_end = buf + buf_size; int ret, input_size; int last_code= 0; for(;;) { uint32_t start_code = -1; buf_ptr = ff_find_start_code(buf_ptr,buf_end, &start_code); if (start_code > 0x1ff){ if(s2->pict_type != AV_PICTURE_TYPE_B || avctx->skip_frame <= AVDISCARD_DEFAULT){ <S2SV_StartVul> if(avctx->thread_count > 1){ <S2SV_EndVul> int i; avctx->execute(avctx, slice_decode_thread, &s2->thread_context[0], NULL, s->slice_count, sizeof(void*)); for(i=0; i<s->slice_count; i++) s2->error_count += s2->thread_context[i]->error_count; } if (CONFIG_MPEG_VDPAU_DECODER && avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_mpeg_picture_complete(s2, buf, buf_size, s->slice_count); if (slice_end(avctx, picture)) { if(s2->last_picture_ptr || s2->low_delay) *data_size = sizeof(AVPicture); } } s2->pict_type= 0; return FFMAX(0, buf_ptr - buf - s2->parse_context.last_index); } input_size = buf_end - buf_ptr; if(avctx->debug & FF_DEBUG_STARTCODE){ av_log(avctx, AV_LOG_DEBUG, ""%3X at %td left %d\n"", start_code, buf_ptr-buf, input_size); } switch(start_code) { case SEQ_START_CODE: if(last_code == 0){ mpeg1_decode_sequence(avctx, buf_ptr, input_size); s->sync=1; }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring SEQ_START_CODE after %X\n"", last_code); } break; case PICTURE_START_CODE: if (HAVE_THREADS && (avctx->active_thread_type&FF_THREAD_SLICE) && s->slice_count) { int i; avctx->execute(avctx, slice_decode_thread, s2->thread_context, NULL, s->slice_count, sizeof(void*)); for (i = 0; i < s->slice_count; i++) s2->error_count += s2->thread_context[i]->error_count; s->slice_count = 0; } if(last_code == 0 || last_code == SLICE_MIN_START_CODE){ if(mpeg_decode_postinit(avctx) < 0){ av_log(avctx, AV_LOG_ERROR, ""mpeg_decode_postinit() failure\n""); return -1; } if(mpeg1_decode_picture(avctx, buf_ptr, input_size) < 0) s2->pict_type=0; s2->first_slice = 1; last_code= PICTURE_START_CODE; }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring pic after %X\n"", last_code); } break; case EXT_START_CODE: init_get_bits(&s2->gb, buf_ptr, input_size*8); switch(get_bits(&s2->gb, 4)) { case 0x1: if(last_code == 0){ mpeg_decode_sequence_extension(s); }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring seq ext after %X\n"", last_code); } break; case 0x2: mpeg_decode_sequence_display_extension(s); break; case 0x3: mpeg_decode_quant_matrix_extension(s2); break; case 0x7: mpeg_decode_picture_display_extension(s); break; case 0x8: if(last_code == PICTURE_START_CODE){ mpeg_decode_picture_coding_extension(s); }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring pic cod ext after %X\n"", last_code); } break; } break; case USER_START_CODE: mpeg_decode_user_data(avctx, buf_ptr, input_size); break; case GOP_START_CODE: if(last_code == 0){ s2->first_field=0; mpeg_decode_gop(avctx, buf_ptr, input_size); s->sync=1; }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring GOP_START_CODE after %X\n"", last_code); } break; default: if (start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code!=0) { const int field_pic= s2->picture_structure != PICT_FRAME; int mb_y= (start_code - SLICE_MIN_START_CODE) << field_pic; last_code= SLICE_MIN_START_CODE; if(s2->picture_structure == PICT_BOTTOM_FIELD) mb_y++; if (mb_y >= s2->mb_height){ av_log(s2->avctx, AV_LOG_ERROR, ""slice below image (%d >= %d)\n"", mb_y, s2->mb_height); return -1; } if(s2->last_picture_ptr==NULL){ if(s2->pict_type==AV_PICTURE_TYPE_B){ if(!s2->closed_gop) break; } } if(s2->pict_type==AV_PICTURE_TYPE_I) s->sync=1; if(s2->next_picture_ptr==NULL){ if(s2->pict_type==AV_PICTURE_TYPE_P && !s->sync) break; } if( (avctx->skip_frame >= AVDISCARD_NONREF && s2->pict_type==AV_PICTURE_TYPE_B) ||(avctx->skip_frame >= AVDISCARD_NONKEY && s2->pict_type!=AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) break; if (!s->mpeg_enc_ctx_allocated) break; if(s2->codec_id == CODEC_ID_MPEG2VIDEO){ if(mb_y < avctx->skip_top || mb_y >= s2->mb_height - avctx->skip_bottom) break; } if(!s2->pict_type){ av_log(avctx, AV_LOG_ERROR, ""Missing picture start code\n""); break; } if(s2->first_slice){ s2->first_slice=0; if(mpeg_field_start(s2, buf, buf_size) < 0) return -1; } if(!s2->current_picture_ptr){ av_log(avctx, AV_LOG_ERROR, ""current_picture not initialized\n""); return -1; } if (avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) { s->slice_count++; break; } <S2SV_StartVul> if(avctx->thread_count > 1){ <S2SV_EndVul> int threshold= (s2->mb_height*s->slice_count + avctx->thread_count/2) / avctx->thread_count; if(threshold <= mb_y){ MpegEncContext *thread_context= s2->thread_context[s->slice_count]; thread_context->start_mb_y= mb_y; thread_context->end_mb_y = s2->mb_height; if(s->slice_count){ s2->thread_context[s->slice_count-1]->end_mb_y= mb_y; ff_update_duplicate_context(thread_context, s2); } init_get_bits(&thread_context->gb, buf_ptr, input_size*8); s->slice_count++; } buf_ptr += 2; }else{ ret = mpeg_decode_slice(s, mb_y, &buf_ptr, input_size); emms_c(); if(ret < 0){ if(s2->resync_mb_x>=0 && s2->resync_mb_y>=0) ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x, s2->mb_y, AC_ERROR|DC_ERROR|MV_ERROR); }else{ ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x-1, s2->mb_y, AC_END|DC_END|MV_END); } } } break; } } }","- if(avctx->thread_count > 1){
- if(avctx->thread_count > 1){
+ if((avctx->active_thread_type & FF_THREAD_SLICE) && avctx->thread_count > 1){
+ if((avctx->active_thread_type & FF_THREAD_SLICE) && avctx->thread_count > 1){","static int decode_chunks(AVCodecContext *avctx, AVFrame *picture, int *data_size, const uint8_t *buf, int buf_size) { Mpeg1Context *s = avctx->priv_data; MpegEncContext *s2 = &s->mpeg_enc_ctx; const uint8_t *buf_ptr = buf; const uint8_t *buf_end = buf + buf_size; int ret, input_size; int last_code= 0; for(;;) { uint32_t start_code = -1; buf_ptr = ff_find_start_code(buf_ptr,buf_end, &start_code); if (start_code > 0x1ff){ if(s2->pict_type != AV_PICTURE_TYPE_B || avctx->skip_frame <= AVDISCARD_DEFAULT){ if((avctx->active_thread_type & FF_THREAD_SLICE) && avctx->thread_count > 1){ int i; avctx->execute(avctx, slice_decode_thread, &s2->thread_context[0], NULL, s->slice_count, sizeof(void*)); for(i=0; i<s->slice_count; i++) s2->error_count += s2->thread_context[i]->error_count; } if (CONFIG_MPEG_VDPAU_DECODER && avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_mpeg_picture_complete(s2, buf, buf_size, s->slice_count); if (slice_end(avctx, picture)) { if(s2->last_picture_ptr || s2->low_delay) *data_size = sizeof(AVPicture); } } s2->pict_type= 0; return FFMAX(0, buf_ptr - buf - s2->parse_context.last_index); } input_size = buf_end - buf_ptr; if(avctx->debug & FF_DEBUG_STARTCODE){ av_log(avctx, AV_LOG_DEBUG, ""%3X at %td left %d\n"", start_code, buf_ptr-buf, input_size); } switch(start_code) { case SEQ_START_CODE: if(last_code == 0){ mpeg1_decode_sequence(avctx, buf_ptr, input_size); s->sync=1; }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring SEQ_START_CODE after %X\n"", last_code); } break; case PICTURE_START_CODE: if (HAVE_THREADS && (avctx->active_thread_type&FF_THREAD_SLICE) && s->slice_count) { int i; avctx->execute(avctx, slice_decode_thread, s2->thread_context, NULL, s->slice_count, sizeof(void*)); for (i = 0; i < s->slice_count; i++) s2->error_count += s2->thread_context[i]->error_count; s->slice_count = 0; } if(last_code == 0 || last_code == SLICE_MIN_START_CODE){ if(mpeg_decode_postinit(avctx) < 0){ av_log(avctx, AV_LOG_ERROR, ""mpeg_decode_postinit() failure\n""); return -1; } if(mpeg1_decode_picture(avctx, buf_ptr, input_size) < 0) s2->pict_type=0; s2->first_slice = 1; last_code= PICTURE_START_CODE; }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring pic after %X\n"", last_code); } break; case EXT_START_CODE: init_get_bits(&s2->gb, buf_ptr, input_size*8); switch(get_bits(&s2->gb, 4)) { case 0x1: if(last_code == 0){ mpeg_decode_sequence_extension(s); }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring seq ext after %X\n"", last_code); } break; case 0x2: mpeg_decode_sequence_display_extension(s); break; case 0x3: mpeg_decode_quant_matrix_extension(s2); break; case 0x7: mpeg_decode_picture_display_extension(s); break; case 0x8: if(last_code == PICTURE_START_CODE){ mpeg_decode_picture_coding_extension(s); }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring pic cod ext after %X\n"", last_code); } break; } break; case USER_START_CODE: mpeg_decode_user_data(avctx, buf_ptr, input_size); break; case GOP_START_CODE: if(last_code == 0){ s2->first_field=0; mpeg_decode_gop(avctx, buf_ptr, input_size); s->sync=1; }else{ av_log(avctx, AV_LOG_ERROR, ""ignoring GOP_START_CODE after %X\n"", last_code); } break; default: if (start_code >= SLICE_MIN_START_CODE && start_code <= SLICE_MAX_START_CODE && last_code!=0) { const int field_pic= s2->picture_structure != PICT_FRAME; int mb_y= (start_code - SLICE_MIN_START_CODE) << field_pic; last_code= SLICE_MIN_START_CODE; if(s2->picture_structure == PICT_BOTTOM_FIELD) mb_y++; if (mb_y >= s2->mb_height){ av_log(s2->avctx, AV_LOG_ERROR, ""slice below image (%d >= %d)\n"", mb_y, s2->mb_height); return -1; } if(s2->last_picture_ptr==NULL){ if(s2->pict_type==AV_PICTURE_TYPE_B){ if(!s2->closed_gop) break; } } if(s2->pict_type==AV_PICTURE_TYPE_I) s->sync=1; if(s2->next_picture_ptr==NULL){ if(s2->pict_type==AV_PICTURE_TYPE_P && !s->sync) break; } if( (avctx->skip_frame >= AVDISCARD_NONREF && s2->pict_type==AV_PICTURE_TYPE_B) ||(avctx->skip_frame >= AVDISCARD_NONKEY && s2->pict_type!=AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) break; if (!s->mpeg_enc_ctx_allocated) break; if(s2->codec_id == CODEC_ID_MPEG2VIDEO){ if(mb_y < avctx->skip_top || mb_y >= s2->mb_height - avctx->skip_bottom) break; } if(!s2->pict_type){ av_log(avctx, AV_LOG_ERROR, ""Missing picture start code\n""); break; } if(s2->first_slice){ s2->first_slice=0; if(mpeg_field_start(s2, buf, buf_size) < 0) return -1; } if(!s2->current_picture_ptr){ av_log(avctx, AV_LOG_ERROR, ""current_picture not initialized\n""); return -1; } if (avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) { s->slice_count++; break; } if((avctx->active_thread_type & FF_THREAD_SLICE) && avctx->thread_count > 1){ int threshold= (s2->mb_height*s->slice_count + avctx->thread_count/2) / avctx->thread_count; if(threshold <= mb_y){ MpegEncContext *thread_context= s2->thread_context[s->slice_count]; thread_context->start_mb_y= mb_y; thread_context->end_mb_y = s2->mb_height; if(s->slice_count){ s2->thread_context[s->slice_count-1]->end_mb_y= mb_y; ff_update_duplicate_context(thread_context, s2); } init_get_bits(&thread_context->gb, buf_ptr, input_size*8); s->slice_count++; } buf_ptr += 2; }else{ ret = mpeg_decode_slice(s, mb_y, &buf_ptr, input_size); emms_c(); if(ret < 0){ if(s2->resync_mb_x>=0 && s2->resync_mb_y>=0) ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x, s2->mb_y, AC_ERROR|DC_ERROR|MV_ERROR); }else{ ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x-1, s2->mb_y, AC_END|DC_END|MV_END); } } } break; } } }"
385----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_166a6aa90fbb9a2458a28b936f85c8952e9a2098_1.json----compute_images_mse,"static inline void compute_images_mse(PSNRContext *s, const uint8_t *main_data[4], const int main_linesizes[4], const uint8_t *ref_data[4], const int ref_linesizes[4], int w, int h, double mse[4]) { int i, c, j; for (c = 0; c < s->nb_components; c++) { const int outw = s->planewidth[c]; const int outh = s->planeheight[c]; const uint8_t *main_line = main_data[c]; const uint8_t *ref_line = ref_data[c]; const int ref_linesize = ref_linesizes[c]; const int main_linesize = main_linesizes[c]; <S2SV_StartVul> int m = 0; <S2SV_EndVul> for (i = 0; i < outh; i++) { for (j = 0; j < outw; j++) m += pow2(main_line[j] - ref_line[j]); ref_line += ref_linesize; main_line += main_linesize; } mse[c] = m / (double)(outw * outh); } }","- int m = 0;
+ uint64_t m = 0;","static inline void compute_images_mse(PSNRContext *s, const uint8_t *main_data[4], const int main_linesizes[4], const uint8_t *ref_data[4], const int ref_linesizes[4], int w, int h, double mse[4]) { int i, c, j; for (c = 0; c < s->nb_components; c++) { const int outw = s->planewidth[c]; const int outh = s->planeheight[c]; const uint8_t *main_line = main_data[c]; const uint8_t *ref_line = ref_data[c]; const int ref_linesize = ref_linesizes[c]; const int main_linesize = main_linesizes[c]; uint64_t m = 0; for (i = 0; i < outh; i++) { for (j = 0; j < outw; j++) m += pow2(main_line[j] - ref_line[j]); ref_line += ref_linesize; main_line += main_linesize; } mse[c] = m / (double)(outw * outh); } }"
3239----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b0bbc7403896f32ea28c3f0fc87e59a8a4287afa_1.json----truemotion1_decode_header,"static int truemotion1_decode_header(TrueMotion1Context *s) { int i; int width_shift = 0; int new_pix_fmt; struct frame_header header; uint8_t header_buffer[128]; const uint8_t *sel_vector_table; header.header_size = ((s->buf[0] >> 5) | (s->buf[0] << 3)) & 0x7f; if (s->buf[0] < 0x10) { av_log(s->avctx, AV_LOG_ERROR, ""invalid header size (%d)\n"", s->buf[0]); return -1; } memset(header_buffer, 0, 128); for (i = 1; i < header.header_size; i++) header_buffer[i - 1] = s->buf[i] ^ s->buf[i + 1]; header.compression = header_buffer[0]; header.deltaset = header_buffer[1]; header.vectable = header_buffer[2]; header.ysize = AV_RL16(&header_buffer[3]); header.xsize = AV_RL16(&header_buffer[5]); header.checksum = AV_RL16(&header_buffer[7]); header.version = header_buffer[9]; header.header_type = header_buffer[10]; header.flags = header_buffer[11]; header.control = header_buffer[12]; if (header.version >= 2) { if (header.header_type > 3) { av_log(s->avctx, AV_LOG_ERROR, ""invalid header type (%d)\n"", header.header_type); return -1; } else if ((header.header_type == 2) || (header.header_type == 3)) { s->flags = header.flags; if (!(s->flags & FLAG_INTERFRAME)) s->flags |= FLAG_KEYFRAME; } else s->flags = FLAG_KEYFRAME; } else s->flags = FLAG_KEYFRAME; if (s->flags & FLAG_SPRITE) { av_log(s->avctx, AV_LOG_INFO, ""SPRITE frame found, please report the sample to the developers\n""); #if 0 s->w = header.width; s->h = header.height; s->x = header.xoffset; s->y = header.yoffset; #else return -1; #endif } else { s->w = header.xsize; s->h = header.ysize; if (header.header_type < 2) { if ((s->w < 213) && (s->h >= 176)) { s->flags |= FLAG_INTERPOLATED; av_log(s->avctx, AV_LOG_INFO, ""INTERPOLATION selected, please report the sample to the developers\n""); } } } if (header.compression >= 17) { av_log(s->avctx, AV_LOG_ERROR, ""invalid compression type (%d)\n"", header.compression); return -1; } if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable)) select_delta_tables(s, header.deltaset); if ((header.compression & 1) && header.header_type) sel_vector_table = pc_tbl2; else { <S2SV_StartVul> if (header.vectable < 4) <S2SV_EndVul> sel_vector_table = tables[header.vectable - 1]; else { av_log(s->avctx, AV_LOG_ERROR, ""invalid vector table id (%d)\n"", header.vectable); return -1; } } if (compression_types[header.compression].algorithm == ALGO_RGB24H) { new_pix_fmt = PIX_FMT_RGB32; width_shift = 1; } else new_pix_fmt = PIX_FMT_RGB555; s->w >>= width_shift; if (av_image_check_size(s->w, s->h, 0, s->avctx) < 0) return -1; if (s->w != s->avctx->width || s->h != s->avctx->height || new_pix_fmt != s->avctx->pix_fmt) { if (s->frame.data[0]) s->avctx->release_buffer(s->avctx, &s->frame); s->avctx->sample_aspect_ratio = (AVRational){ 1 << width_shift, 1 }; s->avctx->pix_fmt = new_pix_fmt; avcodec_set_dimensions(s->avctx, s->w, s->h); av_fast_malloc(&s->vert_pred, &s->vert_pred_size, s->avctx->width * sizeof(unsigned int)); } s->mb_change_bits_row_size = ((s->avctx->width >> (2 - width_shift)) + 7) >> 3; if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable)) { if (compression_types[header.compression].algorithm == ALGO_RGB24H) gen_vector_table24(s, sel_vector_table); else if (s->avctx->pix_fmt == PIX_FMT_RGB555) gen_vector_table15(s, sel_vector_table); else gen_vector_table16(s, sel_vector_table); } s->mb_change_bits = s->buf + header.header_size; if (s->flags & FLAG_KEYFRAME) { s->index_stream = s->mb_change_bits; } else { s->index_stream = s->mb_change_bits + (s->mb_change_bits_row_size * (s->avctx->height >> 2)); } s->index_stream_size = s->size - (s->index_stream - s->buf); s->last_deltaset = header.deltaset; s->last_vectable = header.vectable; s->compression = header.compression; s->block_width = compression_types[header.compression].block_width; s->block_height = compression_types[header.compression].block_height; s->block_type = compression_types[header.compression].block_type; if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, ""tables: %d / %d c:%d %dx%d t:%d %s%s%s%s\n"", s->last_deltaset, s->last_vectable, s->compression, s->block_width, s->block_height, s->block_type, s->flags & FLAG_KEYFRAME ? "" KEY"" : """", s->flags & FLAG_INTERFRAME ? "" INTER"" : """", s->flags & FLAG_SPRITE ? "" SPRITE"" : """", s->flags & FLAG_INTERPOLATED ? "" INTERPOL"" : """"); return header.header_size; }","- if (header.vectable < 4)
+ if (header.vectable > 0 && header.vectable < 4)","static int truemotion1_decode_header(TrueMotion1Context *s) { int i; int width_shift = 0; int new_pix_fmt; struct frame_header header; uint8_t header_buffer[128]; const uint8_t *sel_vector_table; header.header_size = ((s->buf[0] >> 5) | (s->buf[0] << 3)) & 0x7f; if (s->buf[0] < 0x10) { av_log(s->avctx, AV_LOG_ERROR, ""invalid header size (%d)\n"", s->buf[0]); return -1; } memset(header_buffer, 0, 128); for (i = 1; i < header.header_size; i++) header_buffer[i - 1] = s->buf[i] ^ s->buf[i + 1]; header.compression = header_buffer[0]; header.deltaset = header_buffer[1]; header.vectable = header_buffer[2]; header.ysize = AV_RL16(&header_buffer[3]); header.xsize = AV_RL16(&header_buffer[5]); header.checksum = AV_RL16(&header_buffer[7]); header.version = header_buffer[9]; header.header_type = header_buffer[10]; header.flags = header_buffer[11]; header.control = header_buffer[12]; if (header.version >= 2) { if (header.header_type > 3) { av_log(s->avctx, AV_LOG_ERROR, ""invalid header type (%d)\n"", header.header_type); return -1; } else if ((header.header_type == 2) || (header.header_type == 3)) { s->flags = header.flags; if (!(s->flags & FLAG_INTERFRAME)) s->flags |= FLAG_KEYFRAME; } else s->flags = FLAG_KEYFRAME; } else s->flags = FLAG_KEYFRAME; if (s->flags & FLAG_SPRITE) { av_log(s->avctx, AV_LOG_INFO, ""SPRITE frame found, please report the sample to the developers\n""); #if 0 s->w = header.width; s->h = header.height; s->x = header.xoffset; s->y = header.yoffset; #else return -1; #endif } else { s->w = header.xsize; s->h = header.ysize; if (header.header_type < 2) { if ((s->w < 213) && (s->h >= 176)) { s->flags |= FLAG_INTERPOLATED; av_log(s->avctx, AV_LOG_INFO, ""INTERPOLATION selected, please report the sample to the developers\n""); } } } if (header.compression >= 17) { av_log(s->avctx, AV_LOG_ERROR, ""invalid compression type (%d)\n"", header.compression); return -1; } if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable)) select_delta_tables(s, header.deltaset); if ((header.compression & 1) && header.header_type) sel_vector_table = pc_tbl2; else { if (header.vectable > 0 && header.vectable < 4) sel_vector_table = tables[header.vectable - 1]; else { av_log(s->avctx, AV_LOG_ERROR, ""invalid vector table id (%d)\n"", header.vectable); return -1; } } if (compression_types[header.compression].algorithm == ALGO_RGB24H) { new_pix_fmt = PIX_FMT_RGB32; width_shift = 1; } else new_pix_fmt = PIX_FMT_RGB555; s->w >>= width_shift; if (av_image_check_size(s->w, s->h, 0, s->avctx) < 0) return -1; if (s->w != s->avctx->width || s->h != s->avctx->height || new_pix_fmt != s->avctx->pix_fmt) { if (s->frame.data[0]) s->avctx->release_buffer(s->avctx, &s->frame); s->avctx->sample_aspect_ratio = (AVRational){ 1 << width_shift, 1 }; s->avctx->pix_fmt = new_pix_fmt; avcodec_set_dimensions(s->avctx, s->w, s->h); av_fast_malloc(&s->vert_pred, &s->vert_pred_size, s->avctx->width * sizeof(unsigned int)); } s->mb_change_bits_row_size = ((s->avctx->width >> (2 - width_shift)) + 7) >> 3; if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable)) { if (compression_types[header.compression].algorithm == ALGO_RGB24H) gen_vector_table24(s, sel_vector_table); else if (s->avctx->pix_fmt == PIX_FMT_RGB555) gen_vector_table15(s, sel_vector_table); else gen_vector_table16(s, sel_vector_table); } s->mb_change_bits = s->buf + header.header_size; if (s->flags & FLAG_KEYFRAME) { s->index_stream = s->mb_change_bits; } else { s->index_stream = s->mb_change_bits + (s->mb_change_bits_row_size * (s->avctx->height >> 2)); } s->index_stream_size = s->size - (s->index_stream - s->buf); s->last_deltaset = header.deltaset; s->last_vectable = header.vectable; s->compression = header.compression; s->block_width = compression_types[header.compression].block_width; s->block_height = compression_types[header.compression].block_height; s->block_type = compression_types[header.compression].block_type; if (s->avctx->debug & FF_DEBUG_PICT_INFO) av_log(s->avctx, AV_LOG_INFO, ""tables: %d / %d c:%d %dx%d t:%d %s%s%s%s\n"", s->last_deltaset, s->last_vectable, s->compression, s->block_width, s->block_height, s->block_type, s->flags & FLAG_KEYFRAME ? "" KEY"" : """", s->flags & FLAG_INTERFRAME ? "" INTER"" : """", s->flags & FLAG_SPRITE ? "" SPRITE"" : """", s->flags & FLAG_INTERPOLATED ? "" INTERPOL"" : """"); return header.header_size; }"
6542----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5fe5efc51de215caf36bf667e30bc27cd48df490_1.json----udp_leave_multicast_group,"static int udp_leave_multicast_group(int sockfd, struct sockaddr *addr) { #ifdef IP_DROP_MEMBERSHIP if (addr->sa_family == AF_INET) { struct ip_mreq mreq; mreq.imr_multiaddr.s_addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr; mreq.imr_interface.s_addr= INADDR_ANY; if (setsockopt(sockfd, IPPROTO_IP, IP_DROP_MEMBERSHIP, (const void *)&mreq, sizeof(mreq)) < 0) { <S2SV_StartVul> av_log(NULL, AV_LOG_ERROR, ""setsockopt(IP_DROP_MEMBERSHIP): %s\n"", strerror(errno)); <S2SV_EndVul> return -1; } } #endif #if HAVE_STRUCT_IPV6_MREQ && defined(IPPROTO_IPV6) if (addr->sa_family == AF_INET6) { struct ipv6_mreq mreq6; memcpy(&mreq6.ipv6mr_multiaddr, &(((struct sockaddr_in6 *)addr)->sin6_addr), sizeof(struct in6_addr)); mreq6.ipv6mr_interface= 0; if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq6, sizeof(mreq6)) < 0) { <S2SV_StartVul> av_log(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_DROP_MEMBERSHIP): %s\n"", strerror(errno)); <S2SV_EndVul> return -1; } } #endif return 0; }","- av_log(NULL, AV_LOG_ERROR, ""setsockopt(IP_DROP_MEMBERSHIP): %s\n"", strerror(errno));
- av_log(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_DROP_MEMBERSHIP): %s\n"", strerror(errno));
+ log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IP_DROP_MEMBERSHIP)"");
+ log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_DROP_MEMBERSHIP)"");","static int udp_leave_multicast_group(int sockfd, struct sockaddr *addr) { #ifdef IP_DROP_MEMBERSHIP if (addr->sa_family == AF_INET) { struct ip_mreq mreq; mreq.imr_multiaddr.s_addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr; mreq.imr_interface.s_addr= INADDR_ANY; if (setsockopt(sockfd, IPPROTO_IP, IP_DROP_MEMBERSHIP, (const void *)&mreq, sizeof(mreq)) < 0) { log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IP_DROP_MEMBERSHIP)""); return -1; } } #endif #if HAVE_STRUCT_IPV6_MREQ && defined(IPPROTO_IPV6) if (addr->sa_family == AF_INET6) { struct ipv6_mreq mreq6; memcpy(&mreq6.ipv6mr_multiaddr, &(((struct sockaddr_in6 *)addr)->sin6_addr), sizeof(struct in6_addr)); mreq6.ipv6mr_interface= 0; if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq6, sizeof(mreq6)) < 0) { log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_DROP_MEMBERSHIP)""); return -1; } } #endif return 0; }"
5173----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0d15a1ee8f7b34c7e645d3097ac827a49b7d4ad9_1.json----adpcm_compress_trellis,"static void adpcm_compress_trellis(AVCodecContext *avctx, const short *samples, uint8_t *dst, ADPCMChannelStatus *c, int n) { ADPCMContext *s = avctx->priv_data; const int frontier = 1 << avctx->trellis; const int stride = avctx->channels; const int version = avctx->codec->id; TrellisPath *paths = s->paths, *p; TrellisNode *node_buf = s->node_buf; TrellisNode **nodep_buf = s->nodep_buf; TrellisNode **nodes = nodep_buf; TrellisNode **nodes_next = nodep_buf + frontier; <S2SV_StartVul> int pathn = 0, froze = -1, i, j, k; <S2SV_EndVul> memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf)); nodes[0] = node_buf + frontier; nodes[0]->ssd = 0; nodes[0]->path = 0; nodes[0]->step = c->step_index; nodes[0]->sample1 = c->sample1; nodes[0]->sample2 = c->sample2; if((version == CODEC_ID_ADPCM_IMA_WAV) || (version == CODEC_ID_ADPCM_IMA_QT) || (version == CODEC_ID_ADPCM_SWF)) nodes[0]->sample1 = c->prev_sample; if(version == CODEC_ID_ADPCM_MS) nodes[0]->step = c->idelta; if(version == CODEC_ID_ADPCM_YAMAHA) { if(c->step == 0) { nodes[0]->step = 127; nodes[0]->sample1 = 0; } else { nodes[0]->step = c->step; nodes[0]->sample1 = c->predictor; } } for(i=0; i<n; i++) { TrellisNode *t = node_buf + frontier*(i&1); TrellisNode **u; int sample = samples[i*stride]; int heap_pos = 0; memset(nodes_next, 0, frontier*sizeof(TrellisNode*)); for(j=0; j<frontier && nodes[j]; j++) { const int range = (j < frontier/2) ? 1 : 0; const int step = nodes[j]->step; int nidx; if(version == CODEC_ID_ADPCM_MS) { const int predictor = ((nodes[j]->sample1 * c->coeff1) + (nodes[j]->sample2 * c->coeff2)) / 64; const int div = (sample - predictor) / step; const int nmin = av_clip(div-range, -8, 6); const int nmax = av_clip(div+range, -7, 7); for(nidx=nmin; nidx<=nmax; nidx++) { const int nibble = nidx & 0xf; int dec_sample = predictor + nidx * step; #define STORE_NODE(NAME,STEP_INDEX) \ int d;\ uint32_t ssd;\ int pos;\ TrellisNode *u;\ dec_sample = av_clip_int16(dec_sample);\ d = sample - dec_sample;\ ssd = nodes[j]->ssd + d*d;\ \ <S2SV_EndVul> <S2SV_StartVul> for(k=0; k<frontier && nodes_next[k]; k++) {\ <S2SV_EndVul> <S2SV_StartVul> if(dec_sample == nodes_next[k]->sample1) {\ <S2SV_EndVul> <S2SV_StartVul> assert(ssd >= nodes_next[k]->ssd);\ <S2SV_EndVul> <S2SV_StartVul> goto next_##NAME;\ <S2SV_EndVul> <S2SV_StartVul> }\ <S2SV_EndVul> <S2SV_StartVul> }\ <S2SV_EndVul> if (heap_pos < frontier) {\ pos = heap_pos++;\ } else {\ \ pos = (frontier >> 1) + (heap_pos++ & ((frontier >> 1) - 1));\ if (ssd > nodes_next[pos]->ssd)\ goto next_##NAME;\ }\ u = nodes_next[pos];\ if(!u) {\ assert(pathn < FREEZE_INTERVAL<<avctx->trellis);\ u = t++;\ nodes_next[pos] = u;\ u->path = pathn++;\ }\ u->ssd = ssd;\ u->step = STEP_INDEX;\ u->sample2 = nodes[j]->sample1;\ u->sample1 = dec_sample;\ paths[u->path].nibble = nibble;\ paths[u->path].prev = nodes[j]->path;\ \ while (pos > 0) {\ int parent = (pos - 1) >> 1;\ if (nodes_next[parent]->ssd <= ssd)\ break;\ FFSWAP(TrellisNode*, nodes_next[parent], nodes_next[pos]);\ pos = parent;\ }\ next_##NAME:; STORE_NODE(ms, FFMAX(16, (AdaptationTable[nibble] * step) >> 8)); } } else if((version == CODEC_ID_ADPCM_IMA_WAV)|| (version == CODEC_ID_ADPCM_IMA_QT)|| (version == CODEC_ID_ADPCM_SWF)) { #define LOOP_NODES(NAME,STEP_TABLE,STEP_INDEX) \ const int predictor = nodes[j]->sample1;\ const int div = (sample - predictor) * 4 / STEP_TABLE;\ int nmin = av_clip(div-range, -7, 6);\ int nmax = av_clip(div+range, -6, 7);\ if(nmin<=0) nmin--; \ if(nmax<0) nmax--;\ for(nidx=nmin; nidx<=nmax; nidx++) {\ const int nibble = nidx<0 ? 7-nidx : nidx;\ int dec_sample = predictor + (STEP_TABLE * yamaha_difflookup[nibble]) / 8;\ STORE_NODE(NAME, STEP_INDEX);\ } LOOP_NODES(ima, step_table[step], av_clip(step + index_table[nibble], 0, 88)); } else { LOOP_NODES(yamaha, step, av_clip((step * yamaha_indexscale[nibble]) >> 8, 127, 24567)); #undef LOOP_NODES #undef STORE_NODE } } u = nodes; nodes = nodes_next; nodes_next = u; if(nodes[0]->ssd > (1<<28)) { for(j=1; j<frontier && nodes[j]; j++) nodes[j]->ssd -= nodes[0]->ssd; nodes[0]->ssd = 0; } if(i == froze + FREEZE_INTERVAL) { p = &paths[nodes[0]->path]; for(k=i; k>froze; k--) { dst[k] = p->nibble; p = &paths[p->prev]; } froze = i; pathn = 0; memset(nodes+1, 0, (frontier-1)*sizeof(TrellisNode*)); } } p = &paths[nodes[0]->path]; for(i=n-1; i>froze; i--) { dst[i] = p->nibble; p = &paths[p->prev]; } c->predictor = nodes[0]->sample1; c->sample1 = nodes[0]->sample1; c->sample2 = nodes[0]->sample2; c->step_index = nodes[0]->step; c->step = nodes[0]->step; c->idelta = nodes[0]->step; }","- int pathn = 0, froze = -1, i, j, k;
- for(k=0; k<frontier && nodes_next[k]; k++) {\
- if(dec_sample == nodes_next[k]->sample1) {\
- assert(ssd >= nodes_next[k]->ssd);\
- goto next_##NAME;\
- }\
- }\
+ int pathn = 0, froze = -1, i, j, k, generation = 0;
+ uint8_t *hash = s->trellis_hash;
+ memset(hash, 0xff, 65536 * sizeof(*hash));
+ uint8_t *h;\
+ h = &hash[(uint16_t) dec_sample];\
+ if (*h == generation)\
+ goto next_##NAME;\
+ generation++;
+ if (generation == 255) {
+ memset(hash, 0xff, 65536 * sizeof(*hash));
+ generation = 0;
+ }","static void adpcm_compress_trellis(AVCodecContext *avctx, const short *samples, uint8_t *dst, ADPCMChannelStatus *c, int n) { ADPCMContext *s = avctx->priv_data; const int frontier = 1 << avctx->trellis; const int stride = avctx->channels; const int version = avctx->codec->id; TrellisPath *paths = s->paths, *p; TrellisNode *node_buf = s->node_buf; TrellisNode **nodep_buf = s->nodep_buf; TrellisNode **nodes = nodep_buf; TrellisNode **nodes_next = nodep_buf + frontier; int pathn = 0, froze = -1, i, j, k, generation = 0; uint8_t *hash = s->trellis_hash; memset(hash, 0xff, 65536 * sizeof(*hash)); memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf)); nodes[0] = node_buf + frontier; nodes[0]->ssd = 0; nodes[0]->path = 0; nodes[0]->step = c->step_index; nodes[0]->sample1 = c->sample1; nodes[0]->sample2 = c->sample2; if((version == CODEC_ID_ADPCM_IMA_WAV) || (version == CODEC_ID_ADPCM_IMA_QT) || (version == CODEC_ID_ADPCM_SWF)) nodes[0]->sample1 = c->prev_sample; if(version == CODEC_ID_ADPCM_MS) nodes[0]->step = c->idelta; if(version == CODEC_ID_ADPCM_YAMAHA) { if(c->step == 0) { nodes[0]->step = 127; nodes[0]->sample1 = 0; } else { nodes[0]->step = c->step; nodes[0]->sample1 = c->predictor; } } for(i=0; i<n; i++) { TrellisNode *t = node_buf + frontier*(i&1); TrellisNode **u; int sample = samples[i*stride]; int heap_pos = 0; memset(nodes_next, 0, frontier*sizeof(TrellisNode*)); for(j=0; j<frontier && nodes[j]; j++) { const int range = (j < frontier/2) ? 1 : 0; const int step = nodes[j]->step; int nidx; if(version == CODEC_ID_ADPCM_MS) { const int predictor = ((nodes[j]->sample1 * c->coeff1) + (nodes[j]->sample2 * c->coeff2)) / 64; const int div = (sample - predictor) / step; const int nmin = av_clip(div-range, -8, 6); const int nmax = av_clip(div+range, -7, 7); for(nidx=nmin; nidx<=nmax; nidx++) { const int nibble = nidx & 0xf; int dec_sample = predictor + nidx * step; #define STORE_NODE(NAME,STEP_INDEX) \ int d;\ uint32_t ssd;\ int pos;\ TrellisNode *u;\ uint8_t *h;\ dec_sample = av_clip_int16(dec_sample);\ d = sample - dec_sample;\ ssd = nodes[j]->ssd + d*d;\ \ h = &hash[(uint16_t) dec_sample];\ if (*h == generation)\ goto next_##NAME;\ if (heap_pos < frontier) {\ pos = heap_pos++;\ } else {\ \ pos = (frontier >> 1) + (heap_pos++ & ((frontier >> 1) - 1));\ if (ssd > nodes_next[pos]->ssd)\ goto next_##NAME;\ }\ *h = generation;\ u = nodes_next[pos];\ if(!u) {\ assert(pathn < FREEZE_INTERVAL<<avctx->trellis);\ u = t++;\ nodes_next[pos] = u;\ u->path = pathn++;\ }\ u->ssd = ssd;\ u->step = STEP_INDEX;\ u->sample2 = nodes[j]->sample1;\ u->sample1 = dec_sample;\ paths[u->path].nibble = nibble;\ paths[u->path].prev = nodes[j]->path;\ \ while (pos > 0) {\ int parent = (pos - 1) >> 1;\ if (nodes_next[parent]->ssd <= ssd)\ break;\ FFSWAP(TrellisNode*, nodes_next[parent], nodes_next[pos]);\ pos = parent;\ }\ next_##NAME:; STORE_NODE(ms, FFMAX(16, (AdaptationTable[nibble] * step) >> 8)); } } else if((version == CODEC_ID_ADPCM_IMA_WAV)|| (version == CODEC_ID_ADPCM_IMA_QT)|| (version == CODEC_ID_ADPCM_SWF)) { #define LOOP_NODES(NAME,STEP_TABLE,STEP_INDEX) \ const int predictor = nodes[j]->sample1;\ const int div = (sample - predictor) * 4 / STEP_TABLE;\ int nmin = av_clip(div-range, -7, 6);\ int nmax = av_clip(div+range, -6, 7);\ if(nmin<=0) nmin--; \ if(nmax<0) nmax--;\ for(nidx=nmin; nidx<=nmax; nidx++) {\ const int nibble = nidx<0 ? 7-nidx : nidx;\ int dec_sample = predictor + (STEP_TABLE * yamaha_difflookup[nibble]) / 8;\ STORE_NODE(NAME, STEP_INDEX);\ } LOOP_NODES(ima, step_table[step], av_clip(step + index_table[nibble], 0, 88)); } else { LOOP_NODES(yamaha, step, av_clip((step * yamaha_indexscale[nibble]) >> 8, 127, 24567)); #undef LOOP_NODES #undef STORE_NODE } } u = nodes; nodes = nodes_next; nodes_next = u; generation++; if (generation == 255) { memset(hash, 0xff, 65536 * sizeof(*hash)); generation = 0; } if(nodes[0]->ssd > (1<<28)) { for(j=1; j<frontier && nodes[j]; j++) nodes[j]->ssd -= nodes[0]->ssd; nodes[0]->ssd = 0; } if(i == froze + FREEZE_INTERVAL) { p = &paths[nodes[0]->path]; for(k=i; k>froze; k--) { dst[k] = p->nibble; p = &paths[p->prev]; } froze = i; pathn = 0; memset(nodes+1, 0, (frontier-1)*sizeof(TrellisNode*)); } } p = &paths[nodes[0]->path]; for(i=n-1; i>froze; i--) { dst[i] = p->nibble; p = &paths[p->prev]; } c->predictor = nodes[0]->sample1; c->sample1 = nodes[0]->sample1; c->sample2 = nodes[0]->sample2; c->step_index = nodes[0]->step; c->step = nodes[0]->step; c->idelta = nodes[0]->step; }"
14976----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a5de9f7ff6d23a8b5f079da8c0b912119c9fb20d_1.json----tls_construct_new_session_ticket,"int tls_construct_new_session_ticket(SSL *s, WPACKET *pkt) { unsigned char *senc = NULL; EVP_CIPHER_CTX *ctx = NULL; HMAC_CTX *hctx = NULL; unsigned char *p, *encdata1, *encdata2, *macdata1, *macdata2; const unsigned char *const_p; int len, slen_full, slen, lenfinal; SSL_SESSION *sess; unsigned int hlen; SSL_CTX *tctx = s->session_ctx; unsigned char iv[EVP_MAX_IV_LENGTH]; unsigned char key_name[TLSEXT_KEYNAME_LENGTH]; int iv_len; size_t macoffset, macendoffset; union { unsigned char age_add_c[sizeof(uint32_t)]; uint32_t age_add; } age_add_u; if (SSL_IS_TLS13(s)) { void (*cb) (const SSL *ssl, int type, int val) = NULL; if (s->info_callback != NULL) cb = s->info_callback; else if (s->ctx->info_callback != NULL) cb = s->ctx->info_callback; if (cb != NULL) { if (s->sent_tickets != 0) { ossl_statem_set_in_init(s, 0); cb(s, SSL_CB_HANDSHAKE_DONE, 1); ossl_statem_set_in_init(s, 1); } cb(s, SSL_CB_HANDSHAKE_START, 1); } if (s->sent_tickets != 0) { SSL_SESSION *new_sess = ssl_session_dup(s->session, 0); if (new_sess == NULL) { goto err; } SSL_SESSION_free(s->session); s->session = new_sess; } if (!ssl_generate_session_id(s, s->session)) { goto err; } if (RAND_bytes(age_add_u.age_add_c, sizeof(age_add_u)) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } s->session->ext.tick_age_add = age_add_u.age_add; <S2SV_EndVul> OPENSSL_free(s->session->ext.tick_nonce); <S2SV_StartVul> s->session->ext.tick_nonce = OPENSSL_zalloc(sizeof(char)); <S2SV_EndVul> if (s->session->ext.tick_nonce == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } <S2SV_StartVul> s->session->ext.tick_nonce_len = 1; <S2SV_EndVul> s->session->time = (long)time(NULL); if (s->s3->alpn_selected != NULL) { OPENSSL_free(s->session->ext.alpn_selected); s->session->ext.alpn_selected = OPENSSL_memdup(s->s3->alpn_selected, s->s3->alpn_selected_len); if (s->session->ext.alpn_selected == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } s->session->ext.alpn_selected_len = s->s3->alpn_selected_len; } s->session->ext.max_early_data = s->max_early_data; } if (tctx->generate_ticket_cb != NULL && tctx->generate_ticket_cb(s, tctx->ticket_cb_data) == 0) goto err; slen_full = i2d_SSL_SESSION(s->session, NULL); if (slen_full == 0 || slen_full > 0xFF00) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } senc = OPENSSL_malloc(slen_full); if (senc == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } ctx = EVP_CIPHER_CTX_new(); hctx = HMAC_CTX_new(); if (ctx == NULL || hctx == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } p = senc; if (!i2d_SSL_SESSION(s->session, &p)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } const_p = senc; sess = d2i_SSL_SESSION(NULL, &const_p, slen_full); if (sess == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } slen = i2d_SSL_SESSION(sess, NULL); if (slen == 0 || slen > slen_full) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); SSL_SESSION_free(sess); goto err; } p = senc; if (!i2d_SSL_SESSION(sess, &p)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); SSL_SESSION_free(sess); goto err; } SSL_SESSION_free(sess); if (tctx->ext.ticket_key_cb) { int ret = tctx->ext.ticket_key_cb(s, key_name, iv, ctx, hctx, 1); if (ret == 0) { if (!WPACKET_put_bytes_u32(pkt, 0) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } OPENSSL_free(senc); EVP_CIPHER_CTX_free(ctx); HMAC_CTX_free(hctx); return 1; } if (ret < 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, SSL_R_CALLBACK_FAILED); goto err; } iv_len = EVP_CIPHER_CTX_iv_length(ctx); } else { const EVP_CIPHER *cipher = EVP_aes_256_cbc(); iv_len = EVP_CIPHER_iv_length(cipher); if (RAND_bytes(iv, iv_len) <= 0 || !EVP_EncryptInit_ex(ctx, cipher, NULL, tctx->ext.secure->tick_aes_key, iv) || !HMAC_Init_ex(hctx, tctx->ext.secure->tick_hmac_key, sizeof(tctx->ext.secure->tick_hmac_key), EVP_sha256(), NULL)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } memcpy(key_name, tctx->ext.tick_key_name, sizeof(tctx->ext.tick_key_name)); } if (!WPACKET_put_bytes_u32(pkt, (s->hit && !SSL_IS_TLS13(s)) ? 0 : s->session->timeout) || (SSL_IS_TLS13(s) && (!WPACKET_put_bytes_u32(pkt, age_add_u.age_add) || !WPACKET_sub_memcpy_u8(pkt, s->session->ext.tick_nonce, s->session->ext.tick_nonce_len))) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_get_total_written(pkt, &macoffset) || !WPACKET_memcpy(pkt, key_name, sizeof(key_name)) || !WPACKET_memcpy(pkt, iv, iv_len) || !WPACKET_reserve_bytes(pkt, slen + EVP_MAX_BLOCK_LENGTH, &encdata1) || !EVP_EncryptUpdate(ctx, encdata1, &len, senc, slen) || !WPACKET_allocate_bytes(pkt, len, &encdata2) || encdata1 != encdata2 || !EVP_EncryptFinal(ctx, encdata1 + len, &lenfinal) || !WPACKET_allocate_bytes(pkt, lenfinal, &encdata2) || encdata1 + len != encdata2 || len + lenfinal > slen + EVP_MAX_BLOCK_LENGTH || !WPACKET_get_total_written(pkt, &macendoffset) || !HMAC_Update(hctx, (unsigned char *)s->init_buf->data + macoffset, macendoffset - macoffset) || !WPACKET_reserve_bytes(pkt, EVP_MAX_MD_SIZE, &macdata1) || !HMAC_Final(hctx, macdata1, &hlen) || hlen > EVP_MAX_MD_SIZE || !WPACKET_allocate_bytes(pkt, hlen, &macdata2) || macdata1 != macdata2 || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } if (SSL_IS_TLS13(s)) { if (!tls_construct_extensions(s, pkt, SSL_EXT_TLS1_3_NEW_SESSION_TICKET, NULL, 0)) { goto err; } s->sent_tickets++; ssl_update_cache(s, SSL_SESS_CACHE_SERVER); } EVP_CIPHER_CTX_free(ctx); HMAC_CTX_free(hctx); OPENSSL_free(senc); return 1; err: OPENSSL_free(senc); EVP_CIPHER_CTX_free(ctx); HMAC_CTX_free(hctx); return 0; }","- s->session->ext.tick_nonce = OPENSSL_zalloc(sizeof(char));
- s->session->ext.tick_nonce_len = 1;
+ size_t i, hashlen;
+ uint64_t nonce;
+ const char nonce_label[] = ""resumption"";
+ const EVP_MD *md = ssl_handshake_md(s);
+ int hashleni = EVP_MD_size(md);
+ if (!ossl_assert(hashleni >= 0)) {
+ SSLfatal(s, SSL_AD_INTERNAL_ERROR,
+ SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,
+ ERR_R_INTERNAL_ERROR);
+ goto err;
+ }
+ hashlen = (size_t)hashleni;
+ s->session->ext.tick_nonce = OPENSSL_zalloc(TICKET_NONCE_SIZE);
+ nonce = s->next_ticket_nonce;
+ for (i = TICKET_NONCE_SIZE; nonce > 0 && i > 0; i--) {
+ s->session->ext.tick_nonce[i - 1] = nonce & 0xff;
+ nonce >>= 8;
+ }
+ s->session->ext.tick_nonce_len = TICKET_NONCE_SIZE;
+ if (!tls13_hkdf_expand(s, md, s->resumption_master_secret,
+ (const unsigned char *)nonce_label,
+ sizeof(nonce_label) - 1,
+ s->session->ext.tick_nonce,
+ s->session->ext.tick_nonce_len,
+ s->session->master_key,
+ hashlen)) {
+ goto err;
+ }
+ s->session->master_key_length = hashlen;
+ s->next_ticket_nonce++;","int tls_construct_new_session_ticket(SSL *s, WPACKET *pkt) { unsigned char *senc = NULL; EVP_CIPHER_CTX *ctx = NULL; HMAC_CTX *hctx = NULL; unsigned char *p, *encdata1, *encdata2, *macdata1, *macdata2; const unsigned char *const_p; int len, slen_full, slen, lenfinal; SSL_SESSION *sess; unsigned int hlen; SSL_CTX *tctx = s->session_ctx; unsigned char iv[EVP_MAX_IV_LENGTH]; unsigned char key_name[TLSEXT_KEYNAME_LENGTH]; int iv_len; size_t macoffset, macendoffset; union { unsigned char age_add_c[sizeof(uint32_t)]; uint32_t age_add; } age_add_u; if (SSL_IS_TLS13(s)) { size_t i, hashlen; uint64_t nonce; const char nonce_label[] = ""resumption""; const EVP_MD *md = ssl_handshake_md(s); void (*cb) (const SSL *ssl, int type, int val) = NULL; int hashleni = EVP_MD_size(md); if (!ossl_assert(hashleni >= 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } hashlen = (size_t)hashleni; if (s->info_callback != NULL) cb = s->info_callback; else if (s->ctx->info_callback != NULL) cb = s->ctx->info_callback; if (cb != NULL) { if (s->sent_tickets != 0) { ossl_statem_set_in_init(s, 0); cb(s, SSL_CB_HANDSHAKE_DONE, 1); ossl_statem_set_in_init(s, 1); } cb(s, SSL_CB_HANDSHAKE_START, 1); } if (s->sent_tickets != 0) { SSL_SESSION *new_sess = ssl_session_dup(s->session, 0); if (new_sess == NULL) { goto err; } SSL_SESSION_free(s->session); s->session = new_sess; } if (!ssl_generate_session_id(s, s->session)) { goto err; } if (RAND_bytes(age_add_u.age_add_c, sizeof(age_add_u)) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } s->session->ext.tick_age_add = age_add_u.age_add; OPENSSL_free(s->session->ext.tick_nonce); s->session->ext.tick_nonce = OPENSSL_zalloc(TICKET_NONCE_SIZE); if (s->session->ext.tick_nonce == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } nonce = s->next_ticket_nonce; for (i = TICKET_NONCE_SIZE; nonce > 0 && i > 0; i--) { s->session->ext.tick_nonce[i - 1] = nonce & 0xff; nonce >>= 8; } s->session->ext.tick_nonce_len = TICKET_NONCE_SIZE; if (!tls13_hkdf_expand(s, md, s->resumption_master_secret, (const unsigned char *)nonce_label, sizeof(nonce_label) - 1, s->session->ext.tick_nonce, s->session->ext.tick_nonce_len, s->session->master_key, hashlen)) { goto err; } s->session->master_key_length = hashlen; s->session->time = (long)time(NULL); if (s->s3->alpn_selected != NULL) { OPENSSL_free(s->session->ext.alpn_selected); s->session->ext.alpn_selected = OPENSSL_memdup(s->s3->alpn_selected, s->s3->alpn_selected_len); if (s->session->ext.alpn_selected == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } s->session->ext.alpn_selected_len = s->s3->alpn_selected_len; } s->session->ext.max_early_data = s->max_early_data; } if (tctx->generate_ticket_cb != NULL && tctx->generate_ticket_cb(s, tctx->ticket_cb_data) == 0) goto err; slen_full = i2d_SSL_SESSION(s->session, NULL); if (slen_full == 0 || slen_full > 0xFF00) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } senc = OPENSSL_malloc(slen_full); if (senc == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } ctx = EVP_CIPHER_CTX_new(); hctx = HMAC_CTX_new(); if (ctx == NULL || hctx == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE); goto err; } p = senc; if (!i2d_SSL_SESSION(s->session, &p)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } const_p = senc; sess = d2i_SSL_SESSION(NULL, &const_p, slen_full); if (sess == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } slen = i2d_SSL_SESSION(sess, NULL); if (slen == 0 || slen > slen_full) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); SSL_SESSION_free(sess); goto err; } p = senc; if (!i2d_SSL_SESSION(sess, &p)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); SSL_SESSION_free(sess); goto err; } SSL_SESSION_free(sess); if (tctx->ext.ticket_key_cb) { int ret = tctx->ext.ticket_key_cb(s, key_name, iv, ctx, hctx, 1); if (ret == 0) { if (!WPACKET_put_bytes_u32(pkt, 0) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } OPENSSL_free(senc); EVP_CIPHER_CTX_free(ctx); HMAC_CTX_free(hctx); return 1; } if (ret < 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, SSL_R_CALLBACK_FAILED); goto err; } iv_len = EVP_CIPHER_CTX_iv_length(ctx); } else { const EVP_CIPHER *cipher = EVP_aes_256_cbc(); iv_len = EVP_CIPHER_iv_length(cipher); if (RAND_bytes(iv, iv_len) <= 0 || !EVP_EncryptInit_ex(ctx, cipher, NULL, tctx->ext.secure->tick_aes_key, iv) || !HMAC_Init_ex(hctx, tctx->ext.secure->tick_hmac_key, sizeof(tctx->ext.secure->tick_hmac_key), EVP_sha256(), NULL)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } memcpy(key_name, tctx->ext.tick_key_name, sizeof(tctx->ext.tick_key_name)); } if (!WPACKET_put_bytes_u32(pkt, (s->hit && !SSL_IS_TLS13(s)) ? 0 : s->session->timeout) || (SSL_IS_TLS13(s) && (!WPACKET_put_bytes_u32(pkt, age_add_u.age_add) || !WPACKET_sub_memcpy_u8(pkt, s->session->ext.tick_nonce, s->session->ext.tick_nonce_len))) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_get_total_written(pkt, &macoffset) || !WPACKET_memcpy(pkt, key_name, sizeof(key_name)) || !WPACKET_memcpy(pkt, iv, iv_len) || !WPACKET_reserve_bytes(pkt, slen + EVP_MAX_BLOCK_LENGTH, &encdata1) || !EVP_EncryptUpdate(ctx, encdata1, &len, senc, slen) || !WPACKET_allocate_bytes(pkt, len, &encdata2) || encdata1 != encdata2 || !EVP_EncryptFinal(ctx, encdata1 + len, &lenfinal) || !WPACKET_allocate_bytes(pkt, lenfinal, &encdata2) || encdata1 + len != encdata2 || len + lenfinal > slen + EVP_MAX_BLOCK_LENGTH || !WPACKET_get_total_written(pkt, &macendoffset) || !HMAC_Update(hctx, (unsigned char *)s->init_buf->data + macoffset, macendoffset - macoffset) || !WPACKET_reserve_bytes(pkt, EVP_MAX_MD_SIZE, &macdata1) || !HMAC_Final(hctx, macdata1, &hlen) || hlen > EVP_MAX_MD_SIZE || !WPACKET_allocate_bytes(pkt, hlen, &macdata2) || macdata1 != macdata2 || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR); goto err; } if (SSL_IS_TLS13(s)) { if (!tls_construct_extensions(s, pkt, SSL_EXT_TLS1_3_NEW_SESSION_TICKET, NULL, 0)) { goto err; } s->sent_tickets++; s->next_ticket_nonce++; ssl_update_cache(s, SSL_SESS_CACHE_SERVER); } EVP_CIPHER_CTX_free(ctx); HMAC_CTX_free(hctx); OPENSSL_free(senc); return 1; err: OPENSSL_free(senc); EVP_CIPHER_CTX_free(ctx); HMAC_CTX_free(hctx); return 0; }"
1512----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_53fbcac5b44f1be44b9826c1c320df2b2950644f_1.json----g2m_decode_frame,"static int g2m_decode_frame(AVCodecContext *avctx, void *data, int *got_picture_ptr, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; G2MContext *c = avctx->priv_data; AVFrame *pic = data; GetByteContext bc, tbc; int magic; int got_header = 0; uint32_t chunk_size, cur_size; int chunk_type; int i; int ret; if (buf_size < 12) { av_log(avctx, AV_LOG_ERROR, ""Frame should have at least 12 bytes, got %d instead\n"", buf_size); return AVERROR_INVALIDDATA; } bytestream2_init(&bc, buf, buf_size); magic = bytestream2_get_be32(&bc); if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') || (magic & 0xF) < 2 || (magic & 0xF) > 4) { av_log(avctx, AV_LOG_ERROR, ""Wrong magic %08X\n"", magic); return AVERROR_INVALIDDATA; } if ((magic & 0xF) != 4) { av_log(avctx, AV_LOG_ERROR, ""G2M2 and G2M3 are not yet supported\n""); return AVERROR(ENOSYS); } while (bytestream2_get_bytes_left(&bc) > 5) { chunk_size = bytestream2_get_le32(&bc) - 1; chunk_type = bytestream2_get_byte(&bc); if (chunk_size > bytestream2_get_bytes_left(&bc)) { av_log(avctx, AV_LOG_ERROR, ""Invalid chunk size %d type %02X\n"", chunk_size, chunk_type); break; } switch (chunk_type) { case FRAME_INFO: c->got_header = 0; if (chunk_size < 21) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame info size %d\n"", chunk_size); break; } c->width = bytestream2_get_be32(&bc); c->height = bytestream2_get_be32(&bc); if (c->width < 16 || c->width > avctx->width || c->height < 16 || c->height > avctx->height) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame dimensions %dx%d\n"", c->width, c->height); c->width = c->height = 0; bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc)); } if (c->width != avctx->width || c->height != avctx->height) avcodec_set_dimensions(avctx, c->width, c->height); c->compression = bytestream2_get_be32(&bc); if (c->compression != 2 && c->compression != 3) { av_log(avctx, AV_LOG_ERROR, ""Unknown compression method %d\n"", c->compression); return AVERROR_PATCHWELCOME; } c->tile_width = bytestream2_get_be32(&bc); c->tile_height = bytestream2_get_be32(&bc); if (!c->tile_width || !c->tile_height) { av_log(avctx, AV_LOG_ERROR, ""Invalid tile dimensions %dx%d\n"", c->tile_width, c->tile_height); return AVERROR_INVALIDDATA; } c->tiles_x = (c->width + c->tile_width - 1) / c->tile_width; c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height; c->bpp = bytestream2_get_byte(&bc); chunk_size -= 21; bytestream2_skip(&bc, chunk_size); if (g2m_init_buffers(c)) return AVERROR(ENOMEM); got_header = 1; break; case TILE_DATA: if (!c->tiles_x || !c->tiles_y) { av_log(avctx, AV_LOG_WARNING, ""No frame header - skipping tile\n""); bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc)); break; } if (chunk_size < 2) { av_log(avctx, AV_LOG_ERROR, ""Invalid tile data size %d\n"", chunk_size); break; } c->tile_x = bytestream2_get_byte(&bc); c->tile_y = bytestream2_get_byte(&bc); if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) { av_log(avctx, AV_LOG_ERROR, ""Invalid tile pos %d,%d (in %dx%d grid)\n"", c->tile_x, c->tile_y, c->tiles_x, c->tiles_y); break; } chunk_size -= 2; ret = 0; switch (c->compression) { case COMPR_EPIC_J_B: av_log(avctx, AV_LOG_ERROR, ""ePIC j-b compression is not implemented yet\n""); return AVERROR(ENOSYS); case COMPR_KEMPF_J_B: ret = kempf_decode_tile(c, c->tile_x, c->tile_y, buf + bytestream2_tell(&bc), chunk_size); break; } if (ret && c->framebuf) av_log(avctx, AV_LOG_ERROR, ""Error decoding tile %d,%d\n"", c->tile_x, c->tile_y); bytestream2_skip(&bc, chunk_size); break; case CURSOR_POS: if (chunk_size < 5) { av_log(avctx, AV_LOG_ERROR, ""Invalid cursor pos size %d\n"", chunk_size); break; } c->cursor_x = bytestream2_get_be16(&bc); c->cursor_y = bytestream2_get_be16(&bc); bytestream2_skip(&bc, chunk_size - 4); break; case CURSOR_SHAPE: if (chunk_size < 8) { av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\n"", chunk_size); break; } bytestream2_init(&tbc, buf + bytestream2_tell(&bc), chunk_size - 4); cur_size = bytestream2_get_be32(&tbc); <S2SV_StartVul> c->cursor_w = bytestream2_get_byte(&tbc); <S2SV_EndVul> <S2SV_StartVul> c->cursor_h = bytestream2_get_byte(&tbc); <S2SV_EndVul> <S2SV_StartVul> c->cursor_hot_x = bytestream2_get_byte(&tbc); <S2SV_EndVul> <S2SV_StartVul> c->cursor_hot_y = bytestream2_get_byte(&tbc); <S2SV_EndVul> <S2SV_StartVul> c->cursor_fmt = bytestream2_get_byte(&tbc); <S2SV_EndVul> if (cur_size >= chunk_size || c->cursor_w * c->cursor_h / 4 > cur_size) { av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\n"", chunk_size); break; } g2m_load_cursor(c, &tbc); bytestream2_skip(&bc, chunk_size); break; case CHUNK_CC: case CHUNK_CD: bytestream2_skip(&bc, chunk_size); break; default: av_log(avctx, AV_LOG_WARNING, ""Skipping chunk type %02X\n"", chunk_type); bytestream2_skip(&bc, chunk_size); } } if (got_header) c->got_header = 1; if (c->width && c->height && c->framebuf) { if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return ret; } pic->key_frame = got_header; pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P; for (i = 0; i < avctx->height; i++) memcpy(pic->data[0] + i * pic->linesize[0], c->framebuf + i * c->framebuf_stride, c->width * 3); g2m_paint_cursor(c, pic->data[0], pic->linesize[0]); *got_picture_ptr = 1; } return buf_size; }","- c->cursor_w = bytestream2_get_byte(&tbc);
- c->cursor_h = bytestream2_get_byte(&tbc);
- c->cursor_hot_x = bytestream2_get_byte(&tbc);
- c->cursor_hot_y = bytestream2_get_byte(&tbc);
- c->cursor_fmt = bytestream2_get_byte(&tbc);
+ int cursor_w, cursor_h, cursor_hot_x, cursor_hot_y, cursor_fmt;
+ cursor_w = bytestream2_get_byte(&tbc);
+ cursor_h = bytestream2_get_byte(&tbc);
+ cursor_hot_x = bytestream2_get_byte(&tbc);
+ cursor_hot_y = bytestream2_get_byte(&tbc);
+ cursor_fmt = bytestream2_get_byte(&tbc);
+ c->cursor_w = cursor_w;
+ c->cursor_h = cursor_h;
+ c->cursor_hot_x = cursor_hot_x;
+ c->cursor_hot_y = cursor_hot_y;
+ c->cursor_fmt = cursor_fmt;","static int g2m_decode_frame(AVCodecContext *avctx, void *data, int *got_picture_ptr, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; G2MContext *c = avctx->priv_data; AVFrame *pic = data; GetByteContext bc, tbc; int magic; int got_header = 0; uint32_t chunk_size, cur_size; int chunk_type; int i; int ret; int cursor_w, cursor_h, cursor_hot_x, cursor_hot_y, cursor_fmt; if (buf_size < 12) { av_log(avctx, AV_LOG_ERROR, ""Frame should have at least 12 bytes, got %d instead\n"", buf_size); return AVERROR_INVALIDDATA; } bytestream2_init(&bc, buf, buf_size); magic = bytestream2_get_be32(&bc); if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') || (magic & 0xF) < 2 || (magic & 0xF) > 4) { av_log(avctx, AV_LOG_ERROR, ""Wrong magic %08X\n"", magic); return AVERROR_INVALIDDATA; } if ((magic & 0xF) != 4) { av_log(avctx, AV_LOG_ERROR, ""G2M2 and G2M3 are not yet supported\n""); return AVERROR(ENOSYS); } while (bytestream2_get_bytes_left(&bc) > 5) { chunk_size = bytestream2_get_le32(&bc) - 1; chunk_type = bytestream2_get_byte(&bc); if (chunk_size > bytestream2_get_bytes_left(&bc)) { av_log(avctx, AV_LOG_ERROR, ""Invalid chunk size %d type %02X\n"", chunk_size, chunk_type); break; } switch (chunk_type) { case FRAME_INFO: c->got_header = 0; if (chunk_size < 21) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame info size %d\n"", chunk_size); break; } c->width = bytestream2_get_be32(&bc); c->height = bytestream2_get_be32(&bc); if (c->width < 16 || c->width > avctx->width || c->height < 16 || c->height > avctx->height) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame dimensions %dx%d\n"", c->width, c->height); c->width = c->height = 0; bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc)); } if (c->width != avctx->width || c->height != avctx->height) avcodec_set_dimensions(avctx, c->width, c->height); c->compression = bytestream2_get_be32(&bc); if (c->compression != 2 && c->compression != 3) { av_log(avctx, AV_LOG_ERROR, ""Unknown compression method %d\n"", c->compression); return AVERROR_PATCHWELCOME; } c->tile_width = bytestream2_get_be32(&bc); c->tile_height = bytestream2_get_be32(&bc); if (!c->tile_width || !c->tile_height) { av_log(avctx, AV_LOG_ERROR, ""Invalid tile dimensions %dx%d\n"", c->tile_width, c->tile_height); return AVERROR_INVALIDDATA; } c->tiles_x = (c->width + c->tile_width - 1) / c->tile_width; c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height; c->bpp = bytestream2_get_byte(&bc); chunk_size -= 21; bytestream2_skip(&bc, chunk_size); if (g2m_init_buffers(c)) return AVERROR(ENOMEM); got_header = 1; break; case TILE_DATA: if (!c->tiles_x || !c->tiles_y) { av_log(avctx, AV_LOG_WARNING, ""No frame header - skipping tile\n""); bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc)); break; } if (chunk_size < 2) { av_log(avctx, AV_LOG_ERROR, ""Invalid tile data size %d\n"", chunk_size); break; } c->tile_x = bytestream2_get_byte(&bc); c->tile_y = bytestream2_get_byte(&bc); if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) { av_log(avctx, AV_LOG_ERROR, ""Invalid tile pos %d,%d (in %dx%d grid)\n"", c->tile_x, c->tile_y, c->tiles_x, c->tiles_y); break; } chunk_size -= 2; ret = 0; switch (c->compression) { case COMPR_EPIC_J_B: av_log(avctx, AV_LOG_ERROR, ""ePIC j-b compression is not implemented yet\n""); return AVERROR(ENOSYS); case COMPR_KEMPF_J_B: ret = kempf_decode_tile(c, c->tile_x, c->tile_y, buf + bytestream2_tell(&bc), chunk_size); break; } if (ret && c->framebuf) av_log(avctx, AV_LOG_ERROR, ""Error decoding tile %d,%d\n"", c->tile_x, c->tile_y); bytestream2_skip(&bc, chunk_size); break; case CURSOR_POS: if (chunk_size < 5) { av_log(avctx, AV_LOG_ERROR, ""Invalid cursor pos size %d\n"", chunk_size); break; } c->cursor_x = bytestream2_get_be16(&bc); c->cursor_y = bytestream2_get_be16(&bc); bytestream2_skip(&bc, chunk_size - 4); break; case CURSOR_SHAPE: if (chunk_size < 8) { av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\n"", chunk_size); break; } bytestream2_init(&tbc, buf + bytestream2_tell(&bc), chunk_size - 4); cur_size = bytestream2_get_be32(&tbc); cursor_w = bytestream2_get_byte(&tbc); cursor_h = bytestream2_get_byte(&tbc); cursor_hot_x = bytestream2_get_byte(&tbc); cursor_hot_y = bytestream2_get_byte(&tbc); cursor_fmt = bytestream2_get_byte(&tbc); if (cur_size >= chunk_size || c->cursor_w * c->cursor_h / 4 > cur_size) { av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\n"", chunk_size); break; } c->cursor_w = cursor_w; c->cursor_h = cursor_h; c->cursor_hot_x = cursor_hot_x; c->cursor_hot_y = cursor_hot_y; c->cursor_fmt = cursor_fmt; g2m_load_cursor(c, &tbc); bytestream2_skip(&bc, chunk_size); break; case CHUNK_CC: case CHUNK_CD: bytestream2_skip(&bc, chunk_size); break; default: av_log(avctx, AV_LOG_WARNING, ""Skipping chunk type %02X\n"", chunk_type); bytestream2_skip(&bc, chunk_size); } } if (got_header) c->got_header = 1; if (c->width && c->height && c->framebuf) { if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return ret; } pic->key_frame = got_header; pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P; for (i = 0; i < avctx->height; i++) memcpy(pic->data[0] + i * pic->linesize[0], c->framebuf + i * c->framebuf_stride, c->width * 3); g2m_paint_cursor(c, pic->data[0], pic->linesize[0]); *got_picture_ptr = 1; } return buf_size; }"
2888----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_9d0fbaee58ab21c4bc371b83accb5393fa3d76be_1.json----mxf_decrypt_triplet,"static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv) { static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b}; MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; int64_t end = avio_tell(pb) + klv->length; uint64_t size; uint64_t orig_size; uint64_t plaintext_size; uint8_t ivec[16]; uint8_t tmpbuf[16]; int index; if (!mxf->aesc && s->key && s->keylen == 16) { mxf->aesc = av_malloc(av_aes_size); if (!mxf->aesc) return -1; av_aes_init(mxf->aesc, s->key, 128, 1); } avio_skip(pb, klv_decode_ber_length(pb)); klv_decode_ber_length(pb); plaintext_size = avio_rb64(pb); klv_decode_ber_length(pb); avio_read(pb, klv->key, 16); if (!IS_KLV_KEY(klv, mxf_essence_element_key)) return -1; index = mxf_get_stream_index(s, klv); if (index < 0) return -1; klv_decode_ber_length(pb); orig_size = avio_rb64(pb); if (orig_size < plaintext_size) return -1; size = klv_decode_ber_length(pb); if (size < 32 || size - 32 < orig_size) return -1; avio_read(pb, ivec, 16); avio_read(pb, tmpbuf, 16); if (mxf->aesc) av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1); if (memcmp(tmpbuf, checkv, 16)) av_log(s, AV_LOG_ERROR, ""probably incorrect decryption key\n""); size -= 32; <S2SV_StartVul> av_get_packet(pb, pkt, size); <S2SV_EndVul> size -= plaintext_size; if (mxf->aesc) av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size], &pkt->data[plaintext_size], size >> 4, ivec, 1); <S2SV_StartVul> pkt->size = orig_size; <S2SV_EndVul> pkt->stream_index = index; avio_skip(pb, end - avio_tell(pb)); return 0; }","- av_get_packet(pb, pkt, size);
- pkt->size = orig_size;
+ size = av_get_packet(pb, pkt, size);
+ if (size < 0)
+ return size;
+ else if (size < plaintext_size)
+ return AVERROR_INVALIDDATA;
+ av_shrink_packet(pkt, orig_size);","static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv) { static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b}; MXFContext *mxf = s->priv_data; AVIOContext *pb = s->pb; int64_t end = avio_tell(pb) + klv->length; uint64_t size; uint64_t orig_size; uint64_t plaintext_size; uint8_t ivec[16]; uint8_t tmpbuf[16]; int index; if (!mxf->aesc && s->key && s->keylen == 16) { mxf->aesc = av_malloc(av_aes_size); if (!mxf->aesc) return -1; av_aes_init(mxf->aesc, s->key, 128, 1); } avio_skip(pb, klv_decode_ber_length(pb)); klv_decode_ber_length(pb); plaintext_size = avio_rb64(pb); klv_decode_ber_length(pb); avio_read(pb, klv->key, 16); if (!IS_KLV_KEY(klv, mxf_essence_element_key)) return -1; index = mxf_get_stream_index(s, klv); if (index < 0) return -1; klv_decode_ber_length(pb); orig_size = avio_rb64(pb); if (orig_size < plaintext_size) return -1; size = klv_decode_ber_length(pb); if (size < 32 || size - 32 < orig_size) return -1; avio_read(pb, ivec, 16); avio_read(pb, tmpbuf, 16); if (mxf->aesc) av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1); if (memcmp(tmpbuf, checkv, 16)) av_log(s, AV_LOG_ERROR, ""probably incorrect decryption key\n""); size -= 32; size = av_get_packet(pb, pkt, size); if (size < 0) return size; else if (size < plaintext_size) return AVERROR_INVALIDDATA; size -= plaintext_size; if (mxf->aesc) av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size], &pkt->data[plaintext_size], size >> 4, ivec, 1); av_shrink_packet(pkt, orig_size); pkt->stream_index = index; avio_skip(pb, end - avio_tell(pb)); return 0; }"
11905----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_39a7eef2677c635a5ea55709a085fa393817ecc7_1.json----def_load_bio,"static int def_load_bio(CONF *conf, BIO *in, long *line) { #define CONFBUFSIZE 512 int bufnum = 0, i, ii; BUF_MEM *buff = NULL; char *s, *p, *end; int again; long eline = 0; char btmp[DECIMAL_SIZE(eline) + 1]; CONF_VALUE *v = NULL, *tv; CONF_VALUE *sv = NULL; char *section = NULL, *buf; char *start, *psection, *pname; void *h = (void *)(conf->data); if ((buff = BUF_MEM_new()) == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB); goto err; } <S2SV_StartVul> section = BUF_strdup(""default""); <S2SV_EndVul> if (section == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } if (_CONF_new_data(conf) == 0) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } sv = _CONF_new_section(conf, section); if (sv == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } bufnum = 0; again = 0; for (;;) { if (!BUF_MEM_grow(buff, bufnum + CONFBUFSIZE)) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB); goto err; } p = &(buff->data[bufnum]); *p = '\0'; BIO_gets(in, p, CONFBUFSIZE - 1); p[CONFBUFSIZE - 1] = '\0'; ii = i = strlen(p); if (i == 0 && !again) break; again = 0; while (i > 0) { if ((p[i - 1] != '\r') && (p[i - 1] != '\n')) break; else i--; } if (ii && i == ii) again = 1; else { p[i] = '\0'; eline++; } bufnum += i; v = NULL; if (bufnum >= 1) { p = &(buff->data[bufnum - 1]); if (IS_ESC(conf, p[0]) && ((bufnum <= 1) || !IS_ESC(conf, p[-1]))) { bufnum--; again = 1; } } if (again) continue; bufnum = 0; buf = buff->data; clear_comments(conf, buf); s = eat_ws(conf, buf); if (IS_EOF(conf, *s)) continue; if (*s == '[') { char *ss; s++; start = eat_ws(conf, s); ss = start; again: end = eat_alpha_numeric(conf, ss); p = eat_ws(conf, end); if (*p != ']') { if (*p != '\0' && ss != p) { ss = p; goto again; } CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_CLOSE_SQUARE_BRACKET); goto err; } *end = '\0'; if (!str_copy(conf, NULL, &section, start)) goto err; if ((sv = _CONF_get_section(conf, section)) == NULL) sv = _CONF_new_section(conf, section); if (sv == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } continue; } else { pname = s; psection = NULL; end = eat_alpha_numeric(conf, s); if ((end[0] == ':') && (end[1] == ':')) { *end = '\0'; end += 2; psection = pname; pname = end; end = eat_alpha_numeric(conf, end); } p = eat_ws(conf, end); if (*p != '=') { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN); goto err; } *end = '\0'; p++; start = eat_ws(conf, p); while (!IS_EOF(conf, *p)) p++; p--; while ((p != start) && (IS_WS(conf, *p))) p--; p++; *p = '\0'; if ((v = OPENSSL_malloc(sizeof(*v))) == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } if (psection == NULL) psection = section; v->name = OPENSSL_malloc(strlen(pname) + 1); v->value = NULL; if (v->name == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } <S2SV_StartVul> BUF_strlcpy(v->name, pname, strlen(pname) + 1); <S2SV_EndVul> if (!str_copy(conf, psection, &(v->value), start)) goto err; if (strcmp(psection, section) != 0) { if ((tv = _CONF_get_section(conf, psection)) == NULL) tv = _CONF_new_section(conf, psection); if (tv == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } } else tv = sv; if (_CONF_add_string(conf, tv, v) == 0) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } v = NULL; } } BUF_MEM_free(buff); OPENSSL_free(section); return (1); err: BUF_MEM_free(buff); OPENSSL_free(section); if (line != NULL) *line = eline; BIO_snprintf(btmp, sizeof btmp, ""%ld"", eline); ERR_add_error_data(2, ""line "", btmp); if (h != conf->data) { CONF_free(conf->data); conf->data = NULL; } if (v != NULL) { OPENSSL_free(v->name); OPENSSL_free(v->value); OPENSSL_free(v); } return (0); }","- section = BUF_strdup(""default"");
- BUF_strlcpy(v->name, pname, strlen(pname) + 1);
+ section = OPENSSL_strdup(""default"");
+ OPENSSL_strlcpy(v->name, pname, strlen(pname) + 1);","static int def_load_bio(CONF *conf, BIO *in, long *line) { #define CONFBUFSIZE 512 int bufnum = 0, i, ii; BUF_MEM *buff = NULL; char *s, *p, *end; int again; long eline = 0; char btmp[DECIMAL_SIZE(eline) + 1]; CONF_VALUE *v = NULL, *tv; CONF_VALUE *sv = NULL; char *section = NULL, *buf; char *start, *psection, *pname; void *h = (void *)(conf->data); if ((buff = BUF_MEM_new()) == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB); goto err; } section = OPENSSL_strdup(""default""); if (section == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } if (_CONF_new_data(conf) == 0) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } sv = _CONF_new_section(conf, section); if (sv == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } bufnum = 0; again = 0; for (;;) { if (!BUF_MEM_grow(buff, bufnum + CONFBUFSIZE)) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB); goto err; } p = &(buff->data[bufnum]); *p = '\0'; BIO_gets(in, p, CONFBUFSIZE - 1); p[CONFBUFSIZE - 1] = '\0'; ii = i = strlen(p); if (i == 0 && !again) break; again = 0; while (i > 0) { if ((p[i - 1] != '\r') && (p[i - 1] != '\n')) break; else i--; } if (ii && i == ii) again = 1; else { p[i] = '\0'; eline++; } bufnum += i; v = NULL; if (bufnum >= 1) { p = &(buff->data[bufnum - 1]); if (IS_ESC(conf, p[0]) && ((bufnum <= 1) || !IS_ESC(conf, p[-1]))) { bufnum--; again = 1; } } if (again) continue; bufnum = 0; buf = buff->data; clear_comments(conf, buf); s = eat_ws(conf, buf); if (IS_EOF(conf, *s)) continue; if (*s == '[') { char *ss; s++; start = eat_ws(conf, s); ss = start; again: end = eat_alpha_numeric(conf, ss); p = eat_ws(conf, end); if (*p != ']') { if (*p != '\0' && ss != p) { ss = p; goto again; } CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_CLOSE_SQUARE_BRACKET); goto err; } *end = '\0'; if (!str_copy(conf, NULL, &section, start)) goto err; if ((sv = _CONF_get_section(conf, section)) == NULL) sv = _CONF_new_section(conf, section); if (sv == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } continue; } else { pname = s; psection = NULL; end = eat_alpha_numeric(conf, s); if ((end[0] == ':') && (end[1] == ':')) { *end = '\0'; end += 2; psection = pname; pname = end; end = eat_alpha_numeric(conf, end); } p = eat_ws(conf, end); if (*p != '=') { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN); goto err; } *end = '\0'; p++; start = eat_ws(conf, p); while (!IS_EOF(conf, *p)) p++; p--; while ((p != start) && (IS_WS(conf, *p))) p--; p++; *p = '\0'; if ((v = OPENSSL_malloc(sizeof(*v))) == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } if (psection == NULL) psection = section; v->name = OPENSSL_malloc(strlen(pname) + 1); v->value = NULL; if (v->name == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } OPENSSL_strlcpy(v->name, pname, strlen(pname) + 1); if (!str_copy(conf, psection, &(v->value), start)) goto err; if (strcmp(psection, section) != 0) { if ((tv = _CONF_get_section(conf, psection)) == NULL) tv = _CONF_new_section(conf, psection); if (tv == NULL) { CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } } else tv = sv; if (_CONF_add_string(conf, tv, v) == 0) { CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } v = NULL; } } BUF_MEM_free(buff); OPENSSL_free(section); return (1); err: BUF_MEM_free(buff); OPENSSL_free(section); if (line != NULL) *line = eline; BIO_snprintf(btmp, sizeof btmp, ""%ld"", eline); ERR_add_error_data(2, ""line "", btmp); if (h != conf->data) { CONF_free(conf->data); conf->data = NULL; } if (v != NULL) { OPENSSL_free(v->name); OPENSSL_free(v->value); OPENSSL_free(v); } return (0); }"
11597----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_303fa954d4d9f1a0dd903c4bc7841cd14843c39e_1.json----PKCS12_verify_mac,"int PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen) { unsigned char mac[EVP_MAX_MD_SIZE]; unsigned int maclen; const ASN1_OCTET_STRING *macoct; if (p12->mac == NULL) { PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_ABSENT); return 0; } <S2SV_StartVul> if (!PKCS12_gen_mac(p12, pass, passlen, mac, &maclen)) { <S2SV_EndVul> PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR); return 0; } X509_SIG_get0(p12->mac->dinfo, NULL, &macoct); <S2SV_StartVul> if ((maclen != (unsigned int)ASN1_STRING_length(macoct)) <S2SV_EndVul> <S2SV_StartVul> || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen)) <S2SV_EndVul> return 0; return 1; }","- if (!PKCS12_gen_mac(p12, pass, passlen, mac, &maclen)) {
- if ((maclen != (unsigned int)ASN1_STRING_length(macoct))
- || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen))
+ if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen,
+ PKCS12_key_gen_utf8)) {
+ if (maclen != (unsigned int)ASN1_STRING_length(macoct))
+ if (CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0) {
+ if (pass == NULL)
+ return 0;
+ if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen,
+ PKCS12_key_gen_asc)) {
+ PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR);
+ return 0;
+ }
+ if ((maclen != (unsigned int)ASN1_STRING_length(macoct))
+ || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0)
+ return 0;
+ else
+ PKCS12_key_gen = PKCS12_key_gen_asc;
+ }","int PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen) { unsigned char mac[EVP_MAX_MD_SIZE]; unsigned int maclen; const ASN1_OCTET_STRING *macoct; if (p12->mac == NULL) { PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_ABSENT); return 0; } if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen, PKCS12_key_gen_utf8)) { PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR); return 0; } X509_SIG_get0(p12->mac->dinfo, NULL, &macoct); if (maclen != (unsigned int)ASN1_STRING_length(macoct)) return 0; if (CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0) { if (pass == NULL) return 0; if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen, PKCS12_key_gen_asc)) { PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR); return 0; } if ((maclen != (unsigned int)ASN1_STRING_length(macoct)) || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0) return 0; else PKCS12_key_gen = PKCS12_key_gen_asc; } return 1; }"
7386----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_90e45ea37c9440343091334773297ce12fa8a7ac_1.json----ff_mpv_frame_size_alloc,"int ff_mpv_frame_size_alloc(MpegEncContext *s, int linesize) { int alloc_size = FFALIGN(FFABS(linesize) + 32, 32); <S2SV_StartVul> FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, alloc_size * 2 * 21, <S2SV_EndVul> fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->me.scratchpad, alloc_size * 2 * 16 * 2, fail) s->me.temp = s->me.scratchpad; s->rd_scratchpad = s->me.scratchpad; s->b_scratchpad = s->me.scratchpad; s->obmc_scratchpad = s->me.scratchpad + 16; return 0; fail: av_freep(&s->edge_emu_buffer); return AVERROR(ENOMEM); }","- FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, alloc_size * 2 * 21,
+ FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, alloc_size * 2 * 24,","int ff_mpv_frame_size_alloc(MpegEncContext *s, int linesize) { int alloc_size = FFALIGN(FFABS(linesize) + 32, 32); FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, alloc_size * 2 * 24, fail); FF_ALLOCZ_OR_GOTO(s->avctx, s->me.scratchpad, alloc_size * 2 * 16 * 2, fail) s->me.temp = s->me.scratchpad; s->rd_scratchpad = s->me.scratchpad; s->b_scratchpad = s->me.scratchpad; s->obmc_scratchpad = s->me.scratchpad + 16; return 0; fail: av_freep(&s->edge_emu_buffer); return AVERROR(ENOMEM); }"
10002----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_659add3bd258fb898ebbddce72426f1f66a4e8e0_1.json----ngx_http_upstream_process_upgraded,"static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r, <S2SV_StartVul> ngx_uint_t from_upstream) <S2SV_EndVul> { size_t size; ssize_t n; ngx_buf_t *b; <S2SV_StartVul> ngx_uint_t do_write; <S2SV_EndVul> ngx_connection_t *c, *downstream, *upstream, *dst, *src; ngx_http_upstream_t *u; ngx_http_core_loc_conf_t *clcf; c = r->connection; u = r->upstream; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http upstream process upgraded, fu:%ui"", from_upstream); downstream = c; upstream = u->peer.connection; if (downstream->write->timedout) { c->timedout = 1; ngx_connection_error(c, NGX_ETIMEDOUT, ""client timed out""); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT); return; } if (upstream->read->timedout || upstream->write->timedout) { ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed out""); ngx_http_upstream_finalize_request(r, u, 0); return; } if (from_upstream) { src = upstream; dst = downstream; b = &u->buffer; } else { src = downstream; dst = upstream; b = &u->from_client; if (r->header_in->last > r->header_in->pos) { b = r->header_in; b->end = b->last; do_write = 1; } if (b->start == NULL) { b->start = ngx_palloc(r->pool, u->conf->buffer_size); if (b->start == NULL) { ngx_http_upstream_finalize_request(r, u, 0); return; } b->pos = b->start; b->last = b->start; b->end = b->start + u->conf->buffer_size; b->temporary = 1; b->tag = u->output.tag; } } for ( ;; ) { if (do_write) { size = b->last - b->pos; if (size && dst->write->ready) { n = dst->send(dst, b->pos, size); if (n == NGX_ERROR) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (n > 0) { b->pos += n; if (b->pos == b->last) { b->pos = b->start; b->last = b->start; } } } } size = b->end - b->last; if (size && src->read->ready) { n = src->recv(src, b->last, size); if (n == NGX_AGAIN || n == 0) { break; } if (n > 0) { do_write = 1; b->last += n; continue; } if (n == NGX_ERROR) { src->read->eof = 1; } } break; } if ((upstream->read->eof && u->buffer.pos == u->buffer.last) || (downstream->read->eof && u->from_client.pos == u->from_client.last) || (downstream->read->eof && upstream->read->eof)) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http upstream upgraded done""); ngx_http_upstream_finalize_request(r, u, 0); return; } clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (ngx_handle_write_event(upstream->write, u->conf->send_lowat) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (upstream->write->active && !upstream->write->ready) { ngx_add_timer(upstream->write, u->conf->send_timeout); } else if (upstream->write->timer_set) { ngx_del_timer(upstream->write); } if (ngx_handle_read_event(upstream->read, 0) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (upstream->read->active && !upstream->read->ready) { ngx_add_timer(upstream->read, u->conf->read_timeout); } else if (upstream->read->timer_set) { ngx_del_timer(upstream->read); } if (ngx_handle_write_event(downstream->write, clcf->send_lowat) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (ngx_handle_read_event(downstream->read, 0) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (downstream->write->active && !downstream->write->ready) { ngx_add_timer(downstream->write, clcf->send_timeout); } else if (downstream->write->timer_set) { ngx_del_timer(downstream->write); } }","- ngx_uint_t from_upstream)
- ngx_uint_t do_write;
+ ngx_uint_t from_upstream, ngx_uint_t do_write)","static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r, ngx_uint_t from_upstream, ngx_uint_t do_write) { size_t size; ssize_t n; ngx_buf_t *b; ngx_connection_t *c, *downstream, *upstream, *dst, *src; ngx_http_upstream_t *u; ngx_http_core_loc_conf_t *clcf; c = r->connection; u = r->upstream; ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http upstream process upgraded, fu:%ui"", from_upstream); downstream = c; upstream = u->peer.connection; if (downstream->write->timedout) { c->timedout = 1; ngx_connection_error(c, NGX_ETIMEDOUT, ""client timed out""); ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT); return; } if (upstream->read->timedout || upstream->write->timedout) { ngx_connection_error(c, NGX_ETIMEDOUT, ""upstream timed out""); ngx_http_upstream_finalize_request(r, u, 0); return; } if (from_upstream) { src = upstream; dst = downstream; b = &u->buffer; } else { src = downstream; dst = upstream; b = &u->from_client; if (r->header_in->last > r->header_in->pos) { b = r->header_in; b->end = b->last; do_write = 1; } if (b->start == NULL) { b->start = ngx_palloc(r->pool, u->conf->buffer_size); if (b->start == NULL) { ngx_http_upstream_finalize_request(r, u, 0); return; } b->pos = b->start; b->last = b->start; b->end = b->start + u->conf->buffer_size; b->temporary = 1; b->tag = u->output.tag; } } for ( ;; ) { if (do_write) { size = b->last - b->pos; if (size && dst->write->ready) { n = dst->send(dst, b->pos, size); if (n == NGX_ERROR) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (n > 0) { b->pos += n; if (b->pos == b->last) { b->pos = b->start; b->last = b->start; } } } } size = b->end - b->last; if (size && src->read->ready) { n = src->recv(src, b->last, size); if (n == NGX_AGAIN || n == 0) { break; } if (n > 0) { do_write = 1; b->last += n; continue; } if (n == NGX_ERROR) { src->read->eof = 1; } } break; } if ((upstream->read->eof && u->buffer.pos == u->buffer.last) || (downstream->read->eof && u->from_client.pos == u->from_client.last) || (downstream->read->eof && upstream->read->eof)) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http upstream upgraded done""); ngx_http_upstream_finalize_request(r, u, 0); return; } clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (ngx_handle_write_event(upstream->write, u->conf->send_lowat) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (upstream->write->active && !upstream->write->ready) { ngx_add_timer(upstream->write, u->conf->send_timeout); } else if (upstream->write->timer_set) { ngx_del_timer(upstream->write); } if (ngx_handle_read_event(upstream->read, 0) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (upstream->read->active && !upstream->read->ready) { ngx_add_timer(upstream->read, u->conf->read_timeout); } else if (upstream->read->timer_set) { ngx_del_timer(upstream->read); } if (ngx_handle_write_event(downstream->write, clcf->send_lowat) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (ngx_handle_read_event(downstream->read, 0) != NGX_OK) { ngx_http_upstream_finalize_request(r, u, 0); return; } if (downstream->write->active && !downstream->write->ready) { ngx_add_timer(downstream->write, clcf->send_timeout); } else if (downstream->write->timer_set) { ngx_del_timer(downstream->write); } }"
4277----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e789a23d43a1d467d3abf85a8ac290f7ea22d9c1_1.json----bs_get_v,static inline int64_t bs_get_v(const uint8_t **bs) { <S2SV_StartVul> int64_t v = 0; <S2SV_EndVul> int br = 0; int c; do { c = **bs; (*bs)++; v <<= 7; v |= c & 0x7F; br++; if (br > 10) return -1; } while (c & 0x80); return v - br; },"- int64_t v = 0;
+ uint64_t v = 0;",static inline int64_t bs_get_v(const uint8_t **bs) { uint64_t v = 0; int br = 0; int c; do { c = **bs; (*bs)++; v <<= 7; v |= c & 0x7F; br++; if (br > 10) return -1; } while (c & 0x80); return v - br; }
12171----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_4343cd68794cc430eb16e5678113e29d6263c2a0_1.json----EVP_DecryptFinal_ex,"int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl) { int i,n; unsigned int b; *outl=0; b=ctx->cipher->block_size; if (ctx->flags & EVP_CIPH_NO_PADDING) { if(ctx->buf_len) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH); return 0; } *outl = 0; return 1; } if (b > 1) { if (ctx->buf_len || !ctx->final_used) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH); return(0); } OPENSSL_assert(b <= sizeof ctx->final); n=ctx->final[b-1]; <S2SV_StartVul> if (n > (int)b) <S2SV_EndVul> { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT); return(0); } for (i=0; i<n; i++) { if (ctx->final[--b] != n) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT); return(0); } } n=ctx->cipher->block_size-n; for (i=0; i<n; i++) out[i]=ctx->final[i]; *outl=n; } else *outl=0; return(1); }","- if (n > (int)b)
+ if (n == 0 || n > (int)b)","int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl) { int i,n; unsigned int b; *outl=0; b=ctx->cipher->block_size; if (ctx->flags & EVP_CIPH_NO_PADDING) { if(ctx->buf_len) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH); return 0; } *outl = 0; return 1; } if (b > 1) { if (ctx->buf_len || !ctx->final_used) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH); return(0); } OPENSSL_assert(b <= sizeof ctx->final); n=ctx->final[b-1]; if (n == 0 || n > (int)b) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT); return(0); } for (i=0; i<n; i++) { if (ctx->final[--b] != n) { EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT); return(0); } } n=ctx->cipher->block_size-n; for (i=0; i<n; i++) out[i]=ctx->final[i]; *outl=n; } else *outl=0; return(1); }"
5482----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1f943e31df31da7b831e17af6a068c837eb146c5_1.json----ff_intrax8_decode_picture,"int ff_intrax8_decode_picture(IntraX8Context * const w, int dquant, int quant_offset){ MpegEncContext * const s= w->s; int mb_xy; assert(s); w->use_quant_matrix = get_bits1(&s->gb); w->dquant = dquant; w->quant = dquant >> 1; w->qsum = quant_offset; w->divide_quant_dc_luma = ((1<<16) + (w->quant>>1)) / w->quant; if(w->quant < 5){ w->quant_dc_chroma = w->quant; w->divide_quant_dc_chroma = w->divide_quant_dc_luma; }else{ w->quant_dc_chroma = w->quant+((w->quant+3)>>3); w->divide_quant_dc_chroma = ((1<<16) + (w->quant_dc_chroma>>1)) / w->quant_dc_chroma; } x8_reset_vlc_tables(w); <S2SV_StartVul> s->resync_mb_x=0; <S2SV_EndVul> <S2SV_StartVul> s->resync_mb_y=0; <S2SV_EndVul> for(s->mb_y=0; s->mb_y < s->mb_height*2; s->mb_y++){ x8_init_block_index(s); mb_xy=(s->mb_y>>1)*s->mb_stride; for(s->mb_x=0; s->mb_x < s->mb_width*2; s->mb_x++){ x8_get_prediction(w); if(x8_setup_spatial_predictor(w,0)) goto error; if(x8_decode_intra_mb(w,0)) goto error; if( s->mb_x & s->mb_y & 1 ){ x8_get_prediction_chroma(w); x8_setup_spatial_predictor(w,1); if(x8_decode_intra_mb(w,1)) goto error; x8_setup_spatial_predictor(w,2); if(x8_decode_intra_mb(w,2)) goto error; s->dest[1]+= 8; s->dest[2]+= 8; s->mbskip_table [mb_xy]=0; s->mbintra_table[mb_xy]=1; s->current_picture.qscale_table[mb_xy] = w->quant; mb_xy++; } s->dest[0]+= 8; } if(s->mb_y&1){ ff_mpeg_draw_horiz_band(s, (s->mb_y-1)*8, 16); } } error: <S2SV_StartVul> ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, <S2SV_EndVul> <S2SV_StartVul> (s->mb_x>>1)-1, (s->mb_y>>1)-1, <S2SV_EndVul> <S2SV_StartVul> ER_MB_END ); <S2SV_EndVul> return 0; }","- s->resync_mb_x=0;
- s->resync_mb_y=0;
- ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,
- (s->mb_x>>1)-1, (s->mb_y>>1)-1,
- ER_MB_END );","int ff_intrax8_decode_picture(IntraX8Context * const w, int dquant, int quant_offset){ MpegEncContext * const s= w->s; int mb_xy; assert(s); w->use_quant_matrix = get_bits1(&s->gb); w->dquant = dquant; w->quant = dquant >> 1; w->qsum = quant_offset; w->divide_quant_dc_luma = ((1<<16) + (w->quant>>1)) / w->quant; if(w->quant < 5){ w->quant_dc_chroma = w->quant; w->divide_quant_dc_chroma = w->divide_quant_dc_luma; }else{ w->quant_dc_chroma = w->quant+((w->quant+3)>>3); w->divide_quant_dc_chroma = ((1<<16) + (w->quant_dc_chroma>>1)) / w->quant_dc_chroma; } x8_reset_vlc_tables(w); for(s->mb_y=0; s->mb_y < s->mb_height*2; s->mb_y++){ x8_init_block_index(s); mb_xy=(s->mb_y>>1)*s->mb_stride; for(s->mb_x=0; s->mb_x < s->mb_width*2; s->mb_x++){ x8_get_prediction(w); if(x8_setup_spatial_predictor(w,0)) goto error; if(x8_decode_intra_mb(w,0)) goto error; if( s->mb_x & s->mb_y & 1 ){ x8_get_prediction_chroma(w); x8_setup_spatial_predictor(w,1); if(x8_decode_intra_mb(w,1)) goto error; x8_setup_spatial_predictor(w,2); if(x8_decode_intra_mb(w,2)) goto error; s->dest[1]+= 8; s->dest[2]+= 8; s->mbskip_table [mb_xy]=0; s->mbintra_table[mb_xy]=1; s->current_picture.qscale_table[mb_xy] = w->quant; mb_xy++; } s->dest[0]+= 8; } if(s->mb_y&1){ ff_mpeg_draw_horiz_band(s, (s->mb_y-1)*8, 16); } } error: return 0; }"
263----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0ff2969da58abc84fef1ba005ad7555000d94456_1.json----get_qcx,"static int get_qcx(J2kDecoderContext *s, int n, J2kQuantStyle *q) { int i, x; if (s->buf_end - s->buf < 1) return AVERROR(EINVAL); x = bytestream_get_byte(&s->buf); q->nguardbits = x >> 5; q->quantsty = x & 0x1f; if (q->quantsty == J2K_QSTY_NONE){ n -= 3; <S2SV_StartVul> if (s->buf_end - s->buf < n) <S2SV_EndVul> return AVERROR(EINVAL); for (i = 0; i < n; i++) q->expn[i] = bytestream_get_byte(&s->buf) >> 3; } else if (q->quantsty == J2K_QSTY_SI){ if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); x = bytestream_get_be16(&s->buf); q->expn[0] = x >> 11; q->mant[0] = x & 0x7ff; for (i = 1; i < 32 * 3; i++){ int curexpn = FFMAX(0, q->expn[0] - (i-1)/3); q->expn[i] = curexpn; q->mant[i] = q->mant[0]; } } else{ n = (n - 3) >> 1; <S2SV_StartVul> if (s->buf_end - s->buf < n) <S2SV_EndVul> return AVERROR(EINVAL); for (i = 0; i < n; i++){ x = bytestream_get_be16(&s->buf); q->expn[i] = x >> 11; q->mant[i] = x & 0x7ff; } } return 0; }","- if (s->buf_end - s->buf < n)
- if (s->buf_end - s->buf < n)
+ if (s->buf_end - s->buf < n || 32*3 < n)
+ if (s->buf_end - s->buf < n || 32*3 < n)","static int get_qcx(J2kDecoderContext *s, int n, J2kQuantStyle *q) { int i, x; if (s->buf_end - s->buf < 1) return AVERROR(EINVAL); x = bytestream_get_byte(&s->buf); q->nguardbits = x >> 5; q->quantsty = x & 0x1f; if (q->quantsty == J2K_QSTY_NONE){ n -= 3; if (s->buf_end - s->buf < n || 32*3 < n) return AVERROR(EINVAL); for (i = 0; i < n; i++) q->expn[i] = bytestream_get_byte(&s->buf) >> 3; } else if (q->quantsty == J2K_QSTY_SI){ if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); x = bytestream_get_be16(&s->buf); q->expn[0] = x >> 11; q->mant[0] = x & 0x7ff; for (i = 1; i < 32 * 3; i++){ int curexpn = FFMAX(0, q->expn[0] - (i-1)/3); q->expn[i] = curexpn; q->mant[i] = q->mant[0]; } } else{ n = (n - 3) >> 1; if (s->buf_end - s->buf < n || 32*3 < n) return AVERROR(EINVAL); for (i = 0; i < n; i++){ x = bytestream_get_be16(&s->buf); q->expn[i] = x >> 11; q->mant[i] = x & 0x7ff; } } return 0; }"
4020----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d8a457b5d9749d9b0b92cd0f442e628c580ca887_1.json----copy_parameter_set,"<S2SV_StartVul> static void copy_parameter_set(void **to, void **from, int count, int size) <S2SV_EndVul> { int i; for (i = 0; i < count; i++) { <S2SV_StartVul> if (to[i] && !from[i]) <S2SV_EndVul> av_freep(&to[i]); <S2SV_StartVul> else if (from[i] && !to[i]) <S2SV_EndVul> to[i] = av_malloc(size); if (from[i]) memcpy(to[i], from[i], size); } }","- static void copy_parameter_set(void **to, void **from, int count, int size)
- if (to[i] && !from[i])
- else if (from[i] && !to[i])
+ static int copy_parameter_set(void **to, void **from, int count, int size)
+ if (to[i] && !from[i]) {
+ } else if (from[i] && !to[i]) {
+ if (!to[i])
+ return AVERROR(ENOMEM);
+ }
+ return 0;","static int copy_parameter_set(void **to, void **from, int count, int size) { int i; for (i = 0; i < count; i++) { if (to[i] && !from[i]) { av_freep(&to[i]); } else if (from[i] && !to[i]) { to[i] = av_malloc(size); if (!to[i]) return AVERROR(ENOMEM); } if (from[i]) memcpy(to[i], from[i], size); } return 0; }"
440----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_190244feea6af3a02a566aff9acb4e932bb7711f_1.json----mm_decode_inter,"static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size) { const int data_ptr = 2 + AV_RL16(&buf[0]); int d, r, y; d = data_ptr; r = 2; y = 0; while(r < data_ptr) { int i, j; int length = buf[r] & 0x7f; int x = buf[r+1] + ((buf[r] & 0x80) << 1); r += 2; if (length==0) { y += x; continue; } for(i=0; i<length; i++) { for(j=0; j<8; j++) { int replace = (buf[r+i] >> (7-j)) & 1; if (replace) { int color = buf[d]; s->frame.data[0][y*s->frame.linesize[0] + x] = color; if (half_horiz) s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color; if (half_vert) { s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color; if (half_horiz) s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color; } d++; } <S2SV_StartVul> x += half_horiz ? 2 : 1; <S2SV_EndVul> } } r += length; <S2SV_StartVul> y += half_vert ? 2 : 1; <S2SV_EndVul> } }","- x += half_horiz ? 2 : 1;
- y += half_vert ? 2 : 1;
+ x += 1 + half_horiz;
+ y += 1 + half_vert;","static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size) { const int data_ptr = 2 + AV_RL16(&buf[0]); int d, r, y; d = data_ptr; r = 2; y = 0; while(r < data_ptr) { int i, j; int length = buf[r] & 0x7f; int x = buf[r+1] + ((buf[r] & 0x80) << 1); r += 2; if (length==0) { y += x; continue; } for(i=0; i<length; i++) { for(j=0; j<8; j++) { int replace = (buf[r+i] >> (7-j)) & 1; if (replace) { int color = buf[d]; s->frame.data[0][y*s->frame.linesize[0] + x] = color; if (half_horiz) s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color; if (half_vert) { s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color; if (half_horiz) s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color; } d++; } x += 1 + half_horiz; } } r += length; y += 1 + half_vert; } }"
8871----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_e800f1c631dc56dfeb6e3f390e78698a1bdd646b_1.json----decode_bmv_frame,"static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off) { unsigned val, saved_val = 0; int tmplen = src_len; const uint8_t *src, *source_end = source + src_len; uint8_t *frame_end = frame + SCREEN_WIDE * SCREEN_HIGH; uint8_t *dst, *dst_end; int len, mask; int forward = (frame_off <= -SCREEN_WIDE) || (frame_off >= 0); int read_two_nibbles, flag; int advance_mode; int mode = 0; int i; if (src_len <= 0) return AVERROR_INVALIDDATA; if (forward) { src = source; dst = frame; dst_end = frame_end; } else { src = source + src_len - 1; dst = frame_end - 1; dst_end = frame - 1; } for (;;) { int shift = 0; flag = 0; if (!mode || (tmplen == 4)) { if (src < source || src >= source_end) return AVERROR_INVALIDDATA; val = *src; read_two_nibbles = 1; } else { val = saved_val; read_two_nibbles = 0; } if (!(val & 0xC)) { for (;;) { if (!read_two_nibbles) { if (src < source || src >= source_end) return AVERROR_INVALIDDATA; shift += 2; val |= *src << shift; if (*src & 0xC) break; } read_two_nibbles = 0; shift += 2; mask = (1 << shift) - 1; val = ((val >> 2) & ~mask) | (val & mask); NEXT_BYTE(src); if ((val & (0xC << shift))) { flag = 1; break; } } } else if (mode) { flag = tmplen != 4; } if (flag) { tmplen = 4; } else { saved_val = val >> (4 + shift); tmplen = 0; val &= (1 << (shift + 4)) - 1; NEXT_BYTE(src); } advance_mode = val & 1; len = (val >> 1) - 1; mode += 1 + advance_mode; if (mode >= 4) mode -= 3; <S2SV_StartVul> if (FFABS(dst_end - dst) < len) <S2SV_EndVul> return AVERROR_INVALIDDATA; switch (mode) { case 1: if (forward) { if (dst - frame + SCREEN_WIDE < frame_off || dst - frame + SCREEN_WIDE + frame_off < 0 || frame_end - dst < frame_off + len || frame_end - dst < len) return AVERROR_INVALIDDATA; for (i = 0; i < len; i++) dst[i] = dst[frame_off + i]; dst += len; } else { dst -= len; if (dst - frame + SCREEN_WIDE < frame_off || dst - frame + SCREEN_WIDE + frame_off < 0 || frame_end - dst < frame_off + len || frame_end - dst < len) return AVERROR_INVALIDDATA; for (i = len - 1; i >= 0; i--) dst[i] = dst[frame_off + i]; } break; case 2: if (forward) { if (source + src_len - src < len) return AVERROR_INVALIDDATA; memcpy(dst, src, len); dst += len; src += len; } else { if (src - source < len) return AVERROR_INVALIDDATA; dst -= len; src -= len; memcpy(dst, src, len); } break; case 3: val = forward ? dst[-1] : dst[1]; if (forward) { memset(dst, val, len); dst += len; } else { dst -= len; memset(dst, val, len); } break; default: break; } if (dst == dst_end) return 0; } return 0; }","- if (FFABS(dst_end - dst) < len)
+ if (len <= 0 || FFABS(dst_end - dst) < len)","static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off) { unsigned val, saved_val = 0; int tmplen = src_len; const uint8_t *src, *source_end = source + src_len; uint8_t *frame_end = frame + SCREEN_WIDE * SCREEN_HIGH; uint8_t *dst, *dst_end; int len, mask; int forward = (frame_off <= -SCREEN_WIDE) || (frame_off >= 0); int read_two_nibbles, flag; int advance_mode; int mode = 0; int i; if (src_len <= 0) return AVERROR_INVALIDDATA; if (forward) { src = source; dst = frame; dst_end = frame_end; } else { src = source + src_len - 1; dst = frame_end - 1; dst_end = frame - 1; } for (;;) { int shift = 0; flag = 0; if (!mode || (tmplen == 4)) { if (src < source || src >= source_end) return AVERROR_INVALIDDATA; val = *src; read_two_nibbles = 1; } else { val = saved_val; read_two_nibbles = 0; } if (!(val & 0xC)) { for (;;) { if (!read_two_nibbles) { if (src < source || src >= source_end) return AVERROR_INVALIDDATA; shift += 2; val |= *src << shift; if (*src & 0xC) break; } read_two_nibbles = 0; shift += 2; mask = (1 << shift) - 1; val = ((val >> 2) & ~mask) | (val & mask); NEXT_BYTE(src); if ((val & (0xC << shift))) { flag = 1; break; } } } else if (mode) { flag = tmplen != 4; } if (flag) { tmplen = 4; } else { saved_val = val >> (4 + shift); tmplen = 0; val &= (1 << (shift + 4)) - 1; NEXT_BYTE(src); } advance_mode = val & 1; len = (val >> 1) - 1; mode += 1 + advance_mode; if (mode >= 4) mode -= 3; if (len <= 0 || FFABS(dst_end - dst) < len) return AVERROR_INVALIDDATA; switch (mode) { case 1: if (forward) { if (dst - frame + SCREEN_WIDE < frame_off || dst - frame + SCREEN_WIDE + frame_off < 0 || frame_end - dst < frame_off + len || frame_end - dst < len) return AVERROR_INVALIDDATA; for (i = 0; i < len; i++) dst[i] = dst[frame_off + i]; dst += len; } else { dst -= len; if (dst - frame + SCREEN_WIDE < frame_off || dst - frame + SCREEN_WIDE + frame_off < 0 || frame_end - dst < frame_off + len || frame_end - dst < len) return AVERROR_INVALIDDATA; for (i = len - 1; i >= 0; i--) dst[i] = dst[frame_off + i]; } break; case 2: if (forward) { if (source + src_len - src < len) return AVERROR_INVALIDDATA; memcpy(dst, src, len); dst += len; src += len; } else { if (src - source < len) return AVERROR_INVALIDDATA; dst -= len; src -= len; memcpy(dst, src, len); } break; case 3: val = forward ? dst[-1] : dst[1]; if (forward) { memset(dst, val, len); dst += len; } else { dst -= len; memset(dst, val, len); } break; default: break; } if (dst == dst_end) return 0; } return 0; }"
2115----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_73af8dd5e5a989a76bbc4e1a3a3f004432576297_1.json----ff_new_chapter,"int ff_new_chapter(AVFormatContext *s, int id, int64_t start, int64_t end, const char *title) { AVChapter *chapter = NULL; int i; for(i=0; i<s->num_chapters; i++) if(s->chapters[i]->id == id) chapter = s->chapters[i]; if(!chapter){ chapter= av_mallocz(sizeof(AVChapter)); if(!chapter) return AVERROR(ENOMEM); dynarray_add(&s->chapters, &s->num_chapters, chapter); } if(chapter->title) av_free(chapter->title); <S2SV_StartVul> if (title) <S2SV_EndVul> chapter->title = av_strdup(title); chapter->id = id; chapter->start = start; chapter->end = end; return 0; }",- if (title),"int ff_new_chapter(AVFormatContext *s, int id, int64_t start, int64_t end, const char *title) { AVChapter *chapter = NULL; int i; for(i=0; i<s->num_chapters; i++) if(s->chapters[i]->id == id) chapter = s->chapters[i]; if(!chapter){ chapter= av_mallocz(sizeof(AVChapter)); if(!chapter) return AVERROR(ENOMEM); dynarray_add(&s->chapters, &s->num_chapters, chapter); } if(chapter->title) av_free(chapter->title); chapter->title = av_strdup(title); chapter->id = id; chapter->start = start; chapter->end = end; return 0; }"
12679----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_54f1c9e48ca89d3c6971480829afc2f76fdd1b76_1.json----ssl3_accept,"int ssl3_accept(SSL *s) { BUF_MEM *buf; unsigned long l,Time=time(NULL); void (*cb)()=NULL; long num1; int ret= -1; int new_state,state,skip=0; RAND_add(&Time,sizeof(Time),0); ERR_clear_error(); clear_sys_error(); if (s->info_callback != NULL) cb=s->info_callback; else if (s->ctx->info_callback != NULL) cb=s->ctx->info_callback; if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); s->in_handshake++; if (s->cert == NULL) { SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET); return(-1); } for (;;) { state=s->state; switch (s->state) { case SSL_ST_RENEGOTIATE: s->new_session=1; case SSL_ST_BEFORE: case SSL_ST_ACCEPT: case SSL_ST_BEFORE|SSL_ST_ACCEPT: case SSL_ST_OK|SSL_ST_ACCEPT: s->server=1; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1); if ((s->version>>8) != 3) { SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_INTERNAL_ERROR); return -1; } s->type=SSL_ST_ACCEPT; if (s->init_buf == NULL) { if ((buf=BUF_MEM_new()) == NULL) { ret= -1; goto end; } if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH)) { ret= -1; goto end; } s->init_buf=buf; } if (!ssl3_setup_buffers(s)) { ret= -1; goto end; } if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; } s->init_num=0; if (s->state != SSL_ST_RENEGOTIATE) { ssl3_init_finished_mac(s); s->state=SSL3_ST_SR_CLNT_HELLO_A; s->ctx->stats.sess_accept++; } else { s->ctx->stats.sess_accept_renegotiate++; s->state=SSL3_ST_SW_HELLO_REQ_A; } break; case SSL3_ST_SW_HELLO_REQ_A: case SSL3_ST_SW_HELLO_REQ_B: s->shutdown=0; ret=ssl3_send_hello_request(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; ssl3_init_finished_mac(s); break; case SSL3_ST_SW_HELLO_REQ_C: s->state=SSL_ST_OK; ret=1; goto end; case SSL3_ST_SR_CLNT_HELLO_A: case SSL3_ST_SR_CLNT_HELLO_B: case SSL3_ST_SR_CLNT_HELLO_C: s->shutdown=0; ret=ssl3_get_client_hello(s); if (ret <= 0) goto end; s->state=SSL3_ST_SW_SRVR_HELLO_A; s->init_num=0; break; case SSL3_ST_SW_SRVR_HELLO_A: case SSL3_ST_SW_SRVR_HELLO_B: ret=ssl3_send_server_hello(s); if (ret <= 0) goto end; if (s->hit) s->state=SSL3_ST_SW_CHANGE_A; else s->state=SSL3_ST_SW_CERT_A; s->init_num=0; break; case SSL3_ST_SW_CERT_A: case SSL3_ST_SW_CERT_B: if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL)) { ret=ssl3_send_server_certificate(s); if (ret <= 0) goto end; } else skip=1; s->state=SSL3_ST_SW_KEY_EXCH_A; s->init_num=0; break; case SSL3_ST_SW_KEY_EXCH_A: case SSL3_ST_SW_KEY_EXCH_B: l=s->s3->tmp.new_cipher->algorithms; <S2SV_StartVul> if (s->options & SSL_OP_EPHEMERAL_RSA) <S2SV_EndVul> s->s3->tmp.use_rsa_tmp=1; else s->s3->tmp.use_rsa_tmp=0; if (s->s3->tmp.use_rsa_tmp || (l & (SSL_DH|SSL_kFZA)) || ((l & SSL_kRSA) && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher) ) ) ) ) { ret=ssl3_send_server_key_exchange(s); if (ret <= 0) goto end; } else skip=1; s->state=SSL3_ST_SW_CERT_REQ_A; s->init_num=0; break; case SSL3_ST_SW_CERT_REQ_A: case SSL3_ST_SW_CERT_REQ_B: if ( !(s->verify_mode & SSL_VERIFY_PEER) || ((s->session->peer != NULL) && (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) || ((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) && !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) { skip=1; s->s3->tmp.cert_request=0; s->state=SSL3_ST_SW_SRVR_DONE_A; } else { s->s3->tmp.cert_request=1; ret=ssl3_send_certificate_request(s); if (ret <= 0) goto end; #ifndef NETSCAPE_HANG_BUG s->state=SSL3_ST_SW_SRVR_DONE_A; #else s->state=SSL3_ST_SW_FLUSH; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; #endif s->init_num=0; } break; case SSL3_ST_SW_SRVR_DONE_A: case SSL3_ST_SW_SRVR_DONE_B: ret=ssl3_send_server_done(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; break; case SSL3_ST_SW_FLUSH: num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL); if (num1 > 0) { s->rwstate=SSL_WRITING; num1=BIO_flush(s->wbio); if (num1 <= 0) { ret= -1; goto end; } s->rwstate=SSL_NOTHING; } s->state=s->s3->tmp.next_state; break; case SSL3_ST_SR_CERT_A: case SSL3_ST_SR_CERT_B: ret = ssl3_check_client_hello(s); if (ret <= 0) goto end; if (ret == 2) s->state = SSL3_ST_SR_CLNT_HELLO_C; else { ret=ssl3_get_client_certificate(s); if (ret <= 0) goto end; s->init_num=0; s->state=SSL3_ST_SR_KEY_EXCH_A; } break; case SSL3_ST_SR_KEY_EXCH_A: case SSL3_ST_SR_KEY_EXCH_B: ret=ssl3_get_client_key_exchange(s); if (ret <= 0) goto end; s->state=SSL3_ST_SR_CERT_VRFY_A; s->init_num=0; s->method->ssl3_enc->cert_verify_mac(s, &(s->s3->finish_dgst1), &(s->s3->tmp.cert_verify_md[0])); s->method->ssl3_enc->cert_verify_mac(s, &(s->s3->finish_dgst2), &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH])); break; case SSL3_ST_SR_CERT_VRFY_A: case SSL3_ST_SR_CERT_VRFY_B: ret=ssl3_get_cert_verify(s); if (ret <= 0) goto end; s->state=SSL3_ST_SR_FINISHED_A; s->init_num=0; break; case SSL3_ST_SR_FINISHED_A: case SSL3_ST_SR_FINISHED_B: ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A, SSL3_ST_SR_FINISHED_B); if (ret <= 0) goto end; if (s->hit) s->state=SSL_ST_OK; else s->state=SSL3_ST_SW_CHANGE_A; s->init_num=0; break; case SSL3_ST_SW_CHANGE_A: case SSL3_ST_SW_CHANGE_B: s->session->cipher=s->s3->tmp.new_cipher; if (!s->method->ssl3_enc->setup_key_block(s)) { ret= -1; goto end; } ret=ssl3_send_change_cipher_spec(s, SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FINISHED_A; s->init_num=0; if (!s->method->ssl3_enc->change_cipher_state(s, SSL3_CHANGE_CIPHER_SERVER_WRITE)) { ret= -1; goto end; } break; case SSL3_ST_SW_FINISHED_A: case SSL3_ST_SW_FINISHED_B: ret=ssl3_send_finished(s, SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B, s->method->ssl3_enc->server_finished_label, s->method->ssl3_enc->server_finished_label_len); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FLUSH; if (s->hit) s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A; else s->s3->tmp.next_state=SSL_ST_OK; s->init_num=0; break; case SSL_ST_OK: ssl3_cleanup_key_block(s); BUF_MEM_free(s->init_buf); s->init_buf=NULL; ssl_free_wbio_buffer(s); s->new_session=0; s->init_num=0; ssl_update_cache(s,SSL_SESS_CACHE_SERVER); s->ctx->stats.sess_accept_good++; s->handshake_func=ssl3_accept; ret=1; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1); goto end; default: SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE); ret= -1; goto end; } if (!s->s3->tmp.reuse_message && !skip) { if (s->debug) { if ((ret=BIO_flush(s->wbio)) <= 0) goto end; } if ((cb != NULL) && (s->state != state)) { new_state=s->state; s->state=state; cb(s,SSL_CB_ACCEPT_LOOP,1); s->state=new_state; } } skip=0; } end: if (cb != NULL) cb(s,SSL_CB_ACCEPT_EXIT,ret); s->in_handshake--; return(ret); }","- if (s->options & SSL_OP_EPHEMERAL_RSA)
+ if ((s->options & SSL_OP_EPHEMERAL_RSA)
+ #ifndef NO_KRB5
+ && !(l & SSL_KRB5)
+ )","int ssl3_accept(SSL *s) { BUF_MEM *buf; unsigned long l,Time=time(NULL); void (*cb)()=NULL; long num1; int ret= -1; int new_state,state,skip=0; RAND_add(&Time,sizeof(Time),0); ERR_clear_error(); clear_sys_error(); if (s->info_callback != NULL) cb=s->info_callback; else if (s->ctx->info_callback != NULL) cb=s->ctx->info_callback; if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); s->in_handshake++; if (s->cert == NULL) { SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET); return(-1); } for (;;) { state=s->state; switch (s->state) { case SSL_ST_RENEGOTIATE: s->new_session=1; case SSL_ST_BEFORE: case SSL_ST_ACCEPT: case SSL_ST_BEFORE|SSL_ST_ACCEPT: case SSL_ST_OK|SSL_ST_ACCEPT: s->server=1; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1); if ((s->version>>8) != 3) { SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_INTERNAL_ERROR); return -1; } s->type=SSL_ST_ACCEPT; if (s->init_buf == NULL) { if ((buf=BUF_MEM_new()) == NULL) { ret= -1; goto end; } if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH)) { ret= -1; goto end; } s->init_buf=buf; } if (!ssl3_setup_buffers(s)) { ret= -1; goto end; } if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; } s->init_num=0; if (s->state != SSL_ST_RENEGOTIATE) { ssl3_init_finished_mac(s); s->state=SSL3_ST_SR_CLNT_HELLO_A; s->ctx->stats.sess_accept++; } else { s->ctx->stats.sess_accept_renegotiate++; s->state=SSL3_ST_SW_HELLO_REQ_A; } break; case SSL3_ST_SW_HELLO_REQ_A: case SSL3_ST_SW_HELLO_REQ_B: s->shutdown=0; ret=ssl3_send_hello_request(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; ssl3_init_finished_mac(s); break; case SSL3_ST_SW_HELLO_REQ_C: s->state=SSL_ST_OK; ret=1; goto end; case SSL3_ST_SR_CLNT_HELLO_A: case SSL3_ST_SR_CLNT_HELLO_B: case SSL3_ST_SR_CLNT_HELLO_C: s->shutdown=0; ret=ssl3_get_client_hello(s); if (ret <= 0) goto end; s->state=SSL3_ST_SW_SRVR_HELLO_A; s->init_num=0; break; case SSL3_ST_SW_SRVR_HELLO_A: case SSL3_ST_SW_SRVR_HELLO_B: ret=ssl3_send_server_hello(s); if (ret <= 0) goto end; if (s->hit) s->state=SSL3_ST_SW_CHANGE_A; else s->state=SSL3_ST_SW_CERT_A; s->init_num=0; break; case SSL3_ST_SW_CERT_A: case SSL3_ST_SW_CERT_B: if (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL)) { ret=ssl3_send_server_certificate(s); if (ret <= 0) goto end; } else skip=1; s->state=SSL3_ST_SW_KEY_EXCH_A; s->init_num=0; break; case SSL3_ST_SW_KEY_EXCH_A: case SSL3_ST_SW_KEY_EXCH_B: l=s->s3->tmp.new_cipher->algorithms; if ((s->options & SSL_OP_EPHEMERAL_RSA) #ifndef NO_KRB5 && !(l & SSL_KRB5) #endif ) s->s3->tmp.use_rsa_tmp=1; else s->s3->tmp.use_rsa_tmp=0; if (s->s3->tmp.use_rsa_tmp || (l & (SSL_DH|SSL_kFZA)) || ((l & SSL_kRSA) && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher) ) ) ) ) { ret=ssl3_send_server_key_exchange(s); if (ret <= 0) goto end; } else skip=1; s->state=SSL3_ST_SW_CERT_REQ_A; s->init_num=0; break; case SSL3_ST_SW_CERT_REQ_A: case SSL3_ST_SW_CERT_REQ_B: if ( !(s->verify_mode & SSL_VERIFY_PEER) || ((s->session->peer != NULL) && (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) || ((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) && !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) { skip=1; s->s3->tmp.cert_request=0; s->state=SSL3_ST_SW_SRVR_DONE_A; } else { s->s3->tmp.cert_request=1; ret=ssl3_send_certificate_request(s); if (ret <= 0) goto end; #ifndef NETSCAPE_HANG_BUG s->state=SSL3_ST_SW_SRVR_DONE_A; #else s->state=SSL3_ST_SW_FLUSH; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; #endif s->init_num=0; } break; case SSL3_ST_SW_SRVR_DONE_A: case SSL3_ST_SW_SRVR_DONE_B: ret=ssl3_send_server_done(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; break; case SSL3_ST_SW_FLUSH: num1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL); if (num1 > 0) { s->rwstate=SSL_WRITING; num1=BIO_flush(s->wbio); if (num1 <= 0) { ret= -1; goto end; } s->rwstate=SSL_NOTHING; } s->state=s->s3->tmp.next_state; break; case SSL3_ST_SR_CERT_A: case SSL3_ST_SR_CERT_B: ret = ssl3_check_client_hello(s); if (ret <= 0) goto end; if (ret == 2) s->state = SSL3_ST_SR_CLNT_HELLO_C; else { ret=ssl3_get_client_certificate(s); if (ret <= 0) goto end; s->init_num=0; s->state=SSL3_ST_SR_KEY_EXCH_A; } break; case SSL3_ST_SR_KEY_EXCH_A: case SSL3_ST_SR_KEY_EXCH_B: ret=ssl3_get_client_key_exchange(s); if (ret <= 0) goto end; s->state=SSL3_ST_SR_CERT_VRFY_A; s->init_num=0; s->method->ssl3_enc->cert_verify_mac(s, &(s->s3->finish_dgst1), &(s->s3->tmp.cert_verify_md[0])); s->method->ssl3_enc->cert_verify_mac(s, &(s->s3->finish_dgst2), &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH])); break; case SSL3_ST_SR_CERT_VRFY_A: case SSL3_ST_SR_CERT_VRFY_B: ret=ssl3_get_cert_verify(s); if (ret <= 0) goto end; s->state=SSL3_ST_SR_FINISHED_A; s->init_num=0; break; case SSL3_ST_SR_FINISHED_A: case SSL3_ST_SR_FINISHED_B: ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A, SSL3_ST_SR_FINISHED_B); if (ret <= 0) goto end; if (s->hit) s->state=SSL_ST_OK; else s->state=SSL3_ST_SW_CHANGE_A; s->init_num=0; break; case SSL3_ST_SW_CHANGE_A: case SSL3_ST_SW_CHANGE_B: s->session->cipher=s->s3->tmp.new_cipher; if (!s->method->ssl3_enc->setup_key_block(s)) { ret= -1; goto end; } ret=ssl3_send_change_cipher_spec(s, SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FINISHED_A; s->init_num=0; if (!s->method->ssl3_enc->change_cipher_state(s, SSL3_CHANGE_CIPHER_SERVER_WRITE)) { ret= -1; goto end; } break; case SSL3_ST_SW_FINISHED_A: case SSL3_ST_SW_FINISHED_B: ret=ssl3_send_finished(s, SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B, s->method->ssl3_enc->server_finished_label, s->method->ssl3_enc->server_finished_label_len); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FLUSH; if (s->hit) s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A; else s->s3->tmp.next_state=SSL_ST_OK; s->init_num=0; break; case SSL_ST_OK: ssl3_cleanup_key_block(s); BUF_MEM_free(s->init_buf); s->init_buf=NULL; ssl_free_wbio_buffer(s); s->new_session=0; s->init_num=0; ssl_update_cache(s,SSL_SESS_CACHE_SERVER); s->ctx->stats.sess_accept_good++; s->handshake_func=ssl3_accept; ret=1; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1); goto end; default: SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE); ret= -1; goto end; } if (!s->s3->tmp.reuse_message && !skip) { if (s->debug) { if ((ret=BIO_flush(s->wbio)) <= 0) goto end; } if ((cb != NULL) && (s->state != state)) { new_state=s->state; s->state=state; cb(s,SSL_CB_ACCEPT_LOOP,1); s->state=new_state; } } skip=0; } end: if (cb != NULL) cb(s,SSL_CB_ACCEPT_EXIT,ret); s->in_handshake--; return(ret); }"
1149----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3ed90b1d3449c31a9c72c6f1758e47d18cd3f765_1.json----ffv1_init_slice_contexts,"int ffv1_init_slice_contexts(FFV1Context *f) { <S2SV_StartVul> int i; <S2SV_EndVul> f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n""); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { <S2SV_StartVul> FFV1Context *fs = av_mallocz(sizeof(*fs)); <S2SV_EndVul> int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int sxe = f->avctx->width * (sx + 1) / f->num_h_slices; int sys = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); fs->slice_width = sxe - sxs; fs->slice_height = sye - sys; fs->slice_x = sxs; fs->slice_y = sys; fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); <S2SV_StartVul> if (!fs->sample_buffer) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> } return 0; }","- int i;
- FFV1Context *fs = av_mallocz(sizeof(*fs));
- if (!fs->sample_buffer)
- return AVERROR(ENOMEM);
+ int i, j;
+ FFV1Context *fs = av_mallocz(sizeof(*fs));
+ if (!fs)
+ goto memfail;
+ if (!fs->sample_buffer) {
+ av_free(fs);
+ goto memfail;
+ }
+ memfail:
+ for (j = 0; j < i; j++) {
+ av_free(&f->slice_context[j]->sample_buffer);
+ av_free(&f->slice_context[j]);
+ }
+ return AVERROR(ENOMEM);","int ffv1_init_slice_contexts(FFV1Context *f) { int i, j; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n""); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int sxe = f->avctx->width * (sx + 1) / f->num_h_slices; int sys = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; FFV1Context *fs = av_mallocz(sizeof(*fs)); if (!fs) goto memfail; f->slice_context[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); fs->slice_width = sxe - sxs; fs->slice_height = sye - sys; fs->slice_x = sxs; fs->slice_y = sys; fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); if (!fs->sample_buffer) { av_free(fs); goto memfail; } } return 0; memfail: for (j = 0; j < i; j++) { av_free(&f->slice_context[j]->sample_buffer); av_free(&f->slice_context[j]); } return AVERROR(ENOMEM); }"
6243----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4d7ad59a43f9c77d269708749d9cffbf15147492_1.json----h264_filter_mb_fast_internal,"static av_always_inline void h264_filter_mb_fast_internal(H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize, int pixel_shift) { <S2SV_StartVul> MpegEncContext * const s = &h->s; <S2SV_EndVul> <S2SV_StartVul> int chroma = !(CONFIG_GRAY && (s->flags&CODEC_FLAG_GRAY)); <S2SV_EndVul> int chroma444 = CHROMA444; int chroma422 = CHROMA422; int mb_xy = h->mb_xy; int left_type= h->left_type[LTOP]; int top_type= h->top_type; int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8); int a = h->slice_alpha_c0_offset - qp_bd_offset; int b = h->slice_beta_offset - qp_bd_offset; <S2SV_StartVul> int mb_type = s->current_picture.f.mb_type[mb_xy]; <S2SV_EndVul> <S2SV_StartVul> int qp = s->current_picture.f.qscale_table[mb_xy]; <S2SV_EndVul> <S2SV_StartVul> int qp0 = s->current_picture.f.qscale_table[mb_xy - 1]; <S2SV_EndVul> <S2SV_StartVul> int qp1 = s->current_picture.f.qscale_table[h->top_mb_xy]; <S2SV_EndVul> int qpc = get_chroma_qp( h, 0, qp ); int qpc0 = get_chroma_qp( h, 0, qp0 ); int qpc1 = get_chroma_qp( h, 0, qp1 ); qp0 = (qp + qp0 + 1) >> 1; qp1 = (qp + qp1 + 1) >> 1; qpc0 = (qpc + qpc0 + 1) >> 1; qpc1 = (qpc + qpc1 + 1) >> 1; if( IS_INTRA(mb_type) ) { static const int16_t bS4[4] = {4,4,4,4}; static const int16_t bS3[4] = {3,3,3,3}; const int16_t *bSH = FIELD_PICTURE ? bS3 : bS4; if(left_type) filter_mb_edgev( &img_y[4*0<<pixel_shift], linesize, bS4, qp0, a, b, h, 1); if( IS_8x8DCT(mb_type) ) { filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1); } filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0); } else { filter_mb_edgev( &img_y[4*1<<pixel_shift], linesize, bS3, qp, a, b, h, 0); filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0); filter_mb_edgev( &img_y[4*3<<pixel_shift], linesize, bS3, qp, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1); } filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, a, b, h, 0); filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0); filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, a, b, h, 0); } if(chroma){ if(chroma444){ if(left_type){ filter_mb_edgev( &img_cb[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1); filter_mb_edgev( &img_cr[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1); } if( IS_8x8DCT(mb_type) ) { filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 ); filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 ); } filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); } else { filter_mb_edgev( &img_cb[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cb[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1); filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1); } filter_mb_edgeh( &img_cb[4*1*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*1*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cb[4*3*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*3*linesize], linesize, bS3, qpc, a, b, h, 0); } }else if(chroma422){ if(left_type){ filter_mb_edgecv(&img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); filter_mb_edgecv(&img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); } filter_mb_edgecv(&img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgecv(&img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgech(&img_cb[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); filter_mb_edgech(&img_cr[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); } filter_mb_edgech(&img_cb[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cr[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cb[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cr[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cb[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cr[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); }else{ if(left_type){ filter_mb_edgecv( &img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); filter_mb_edgecv( &img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); } filter_mb_edgecv( &img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgecv( &img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); } filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); } } return; } else { LOCAL_ALIGNED_8(int16_t, bS, [2], [4][4]); int edges; if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 && !chroma444 ) { edges = 4; AV_WN64A(bS[0][0], 0x0002000200020002ULL); AV_WN64A(bS[0][2], 0x0002000200020002ULL); AV_WN64A(bS[1][0], 0x0002000200020002ULL); AV_WN64A(bS[1][2], 0x0002000200020002ULL); } else { int mask_edge1 = (3*(((5*mb_type)>>5)&1)) | (mb_type>>4); int mask_edge0 = 3*((mask_edge1>>1) & ((5*left_type)>>5)&1); int step = 1+(mb_type>>24); edges = 4 - 3*((mb_type>>3) & !(h->cbp & 15)); h->h264dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache, h->list_count==2, edges, step, mask_edge0, mask_edge1, FIELD_PICTURE); } if( IS_INTRA(left_type) ) AV_WN64A(bS[0][0], 0x0004000400040004ULL); if( IS_INTRA(top_type) ) AV_WN64A(bS[1][0], FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL); #define FILTER(hv,dir,edge,intra) \ if(AV_RN64A(bS[dir][edge])) { \ filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qp : qp##dir, a, b, h, intra );\ if(chroma){\ if(chroma444){\ filter_mb_edge##hv( &img_cb[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ filter_mb_edge##hv( &img_cr[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ } else if(!(edge&1)) {\ filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ }\ }\ } if(left_type) FILTER(v,0,0,1); if( edges == 1 ) { if(top_type) FILTER(h,1,0,1); } else if( IS_8x8DCT(mb_type) ) { FILTER(v,0,2,0); if(top_type) FILTER(h,1,0,1); FILTER(h,1,2,0); } else { FILTER(v,0,1,0); FILTER(v,0,2,0); FILTER(v,0,3,0); if(top_type) FILTER(h,1,0,1); FILTER(h,1,1,0); FILTER(h,1,2,0); FILTER(h,1,3,0); } #undef FILTER } }","- MpegEncContext * const s = &h->s;
- int chroma = !(CONFIG_GRAY && (s->flags&CODEC_FLAG_GRAY));
- int mb_type = s->current_picture.f.mb_type[mb_xy];
- int qp = s->current_picture.f.qscale_table[mb_xy];
- int qp0 = s->current_picture.f.qscale_table[mb_xy - 1];
- int qp1 = s->current_picture.f.qscale_table[h->top_mb_xy];
+ int chroma = !(CONFIG_GRAY && (h->flags&CODEC_FLAG_GRAY));
+ int mb_type = h->cur_pic.f.mb_type[mb_xy];
+ int qp = h->cur_pic.f.qscale_table[mb_xy];
+ int qp0 = h->cur_pic.f.qscale_table[mb_xy - 1];
+ int qp1 = h->cur_pic.f.qscale_table[h->top_mb_xy];","static av_always_inline void h264_filter_mb_fast_internal(H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize, int pixel_shift) { int chroma = !(CONFIG_GRAY && (h->flags&CODEC_FLAG_GRAY)); int chroma444 = CHROMA444; int chroma422 = CHROMA422; int mb_xy = h->mb_xy; int left_type= h->left_type[LTOP]; int top_type= h->top_type; int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8); int a = h->slice_alpha_c0_offset - qp_bd_offset; int b = h->slice_beta_offset - qp_bd_offset; int mb_type = h->cur_pic.f.mb_type[mb_xy]; int qp = h->cur_pic.f.qscale_table[mb_xy]; int qp0 = h->cur_pic.f.qscale_table[mb_xy - 1]; int qp1 = h->cur_pic.f.qscale_table[h->top_mb_xy]; int qpc = get_chroma_qp( h, 0, qp ); int qpc0 = get_chroma_qp( h, 0, qp0 ); int qpc1 = get_chroma_qp( h, 0, qp1 ); qp0 = (qp + qp0 + 1) >> 1; qp1 = (qp + qp1 + 1) >> 1; qpc0 = (qpc + qpc0 + 1) >> 1; qpc1 = (qpc + qpc1 + 1) >> 1; if( IS_INTRA(mb_type) ) { static const int16_t bS4[4] = {4,4,4,4}; static const int16_t bS3[4] = {3,3,3,3}; const int16_t *bSH = FIELD_PICTURE ? bS3 : bS4; if(left_type) filter_mb_edgev( &img_y[4*0<<pixel_shift], linesize, bS4, qp0, a, b, h, 1); if( IS_8x8DCT(mb_type) ) { filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1); } filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0); } else { filter_mb_edgev( &img_y[4*1<<pixel_shift], linesize, bS3, qp, a, b, h, 0); filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0); filter_mb_edgev( &img_y[4*3<<pixel_shift], linesize, bS3, qp, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1); } filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, a, b, h, 0); filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0); filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, a, b, h, 0); } if(chroma){ if(chroma444){ if(left_type){ filter_mb_edgev( &img_cb[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1); filter_mb_edgev( &img_cr[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1); } if( IS_8x8DCT(mb_type) ) { filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 ); filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 ); } filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); } else { filter_mb_edgev( &img_cb[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cb[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgev( &img_cr[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1); filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1); } filter_mb_edgeh( &img_cb[4*1*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*1*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cb[4*3*linesize], linesize, bS3, qpc, a, b, h, 0); filter_mb_edgeh( &img_cr[4*3*linesize], linesize, bS3, qpc, a, b, h, 0); } }else if(chroma422){ if(left_type){ filter_mb_edgecv(&img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); filter_mb_edgecv(&img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); } filter_mb_edgecv(&img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgecv(&img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgech(&img_cb[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); filter_mb_edgech(&img_cr[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); } filter_mb_edgech(&img_cb[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cr[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cb[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cr[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cb[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech(&img_cr[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); }else{ if(left_type){ filter_mb_edgecv( &img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); filter_mb_edgecv( &img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1); } filter_mb_edgecv( &img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgecv( &img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0); if(top_type){ filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1); } filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0); } } return; } else { LOCAL_ALIGNED_8(int16_t, bS, [2], [4][4]); int edges; if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 && !chroma444 ) { edges = 4; AV_WN64A(bS[0][0], 0x0002000200020002ULL); AV_WN64A(bS[0][2], 0x0002000200020002ULL); AV_WN64A(bS[1][0], 0x0002000200020002ULL); AV_WN64A(bS[1][2], 0x0002000200020002ULL); } else { int mask_edge1 = (3*(((5*mb_type)>>5)&1)) | (mb_type>>4); int mask_edge0 = 3*((mask_edge1>>1) & ((5*left_type)>>5)&1); int step = 1+(mb_type>>24); edges = 4 - 3*((mb_type>>3) & !(h->cbp & 15)); h->h264dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache, h->list_count==2, edges, step, mask_edge0, mask_edge1, FIELD_PICTURE); } if( IS_INTRA(left_type) ) AV_WN64A(bS[0][0], 0x0004000400040004ULL); if( IS_INTRA(top_type) ) AV_WN64A(bS[1][0], FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL); #define FILTER(hv,dir,edge,intra) \ if(AV_RN64A(bS[dir][edge])) { \ filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qp : qp##dir, a, b, h, intra );\ if(chroma){\ if(chroma444){\ filter_mb_edge##hv( &img_cb[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ filter_mb_edge##hv( &img_cr[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ } else if(!(edge&1)) {\ filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\ }\ }\ } if(left_type) FILTER(v,0,0,1); if( edges == 1 ) { if(top_type) FILTER(h,1,0,1); } else if( IS_8x8DCT(mb_type) ) { FILTER(v,0,2,0); if(top_type) FILTER(h,1,0,1); FILTER(h,1,2,0); } else { FILTER(v,0,1,0); FILTER(v,0,2,0); FILTER(v,0,3,0); if(top_type) FILTER(h,1,0,1); FILTER(h,1,1,0); FILTER(h,1,2,0); FILTER(h,1,3,0); } #undef FILTER } }"
5000----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_037cbeda19bd56768caa2288d452b634d6b6a78e_1.json----av_buffer_realloc,"int av_buffer_realloc(AVBufferRef **pbuf, int size) { AVBufferRef *buf = *pbuf; uint8_t *tmp; if (!buf) { uint8_t *data = av_realloc(NULL, size); if (!data) return AVERROR(ENOMEM); buf = av_buffer_create(data, size, av_buffer_default_free, NULL, 0); if (!buf) { av_freep(&data); return AVERROR(ENOMEM); } buf->buffer->flags |= BUFFER_FLAG_REALLOCATABLE; *pbuf = buf; return 0; } else if (buf->size == size) return 0; if (!(buf->buffer->flags & BUFFER_FLAG_REALLOCATABLE) || <S2SV_StartVul> !av_buffer_is_writable(buf)) { <S2SV_EndVul> AVBufferRef *new = NULL; av_buffer_realloc(&new, size); if (!new) return AVERROR(ENOMEM); memcpy(new->data, buf->data, FFMIN(size, buf->size)); av_buffer_unref(pbuf); *pbuf = new; return 0; } tmp = av_realloc(buf->buffer->data, size); if (!tmp) return AVERROR(ENOMEM); buf->buffer->data = buf->data = tmp; buf->buffer->size = buf->size = size; return 0; }","- !av_buffer_is_writable(buf)) {
+ !av_buffer_is_writable(buf) || buf->data != buf->buffer->data) {","int av_buffer_realloc(AVBufferRef **pbuf, int size) { AVBufferRef *buf = *pbuf; uint8_t *tmp; if (!buf) { uint8_t *data = av_realloc(NULL, size); if (!data) return AVERROR(ENOMEM); buf = av_buffer_create(data, size, av_buffer_default_free, NULL, 0); if (!buf) { av_freep(&data); return AVERROR(ENOMEM); } buf->buffer->flags |= BUFFER_FLAG_REALLOCATABLE; *pbuf = buf; return 0; } else if (buf->size == size) return 0; if (!(buf->buffer->flags & BUFFER_FLAG_REALLOCATABLE) || !av_buffer_is_writable(buf) || buf->data != buf->buffer->data) { AVBufferRef *new = NULL; av_buffer_realloc(&new, size); if (!new) return AVERROR(ENOMEM); memcpy(new->data, buf->data, FFMIN(size, buf->size)); av_buffer_unref(pbuf); *pbuf = new; return 0; } tmp = av_realloc(buf->buffer->data, size); if (!tmp) return AVERROR(ENOMEM); buf->buffer->data = buf->data = tmp; buf->buffer->size = buf->size = size; return 0; }"
10842----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1494534c015c78a18b7eb1def3f3aa93968cf8b1_1.json----BN_MONT_CTX_set,"int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx) { <S2SV_StartVul> int ret = 0; <S2SV_EndVul> BIGNUM *Ri, *R; if (BN_is_zero(mod)) return 0; BN_CTX_start(ctx); if ((Ri = BN_CTX_get(ctx)) == NULL) goto err; R = &(mont->RR); if (!BN_copy(&(mont->N), mod)) goto err; if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0) BN_set_flags(&(mont->N), BN_FLG_CONSTTIME); mont->N.neg = 0; #ifdef MONT_WORD { BIGNUM tmod; BN_ULONG buf[2]; bn_init(&tmod); tmod.d = buf; tmod.dmax = 2; tmod.neg = 0; if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0) BN_set_flags(&tmod, BN_FLG_CONSTTIME); mont->ri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2; # if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32) BN_zero(R); if (!(BN_set_bit(R, 2 * BN_BITS2))) goto err; tmod.top = 0; if ((buf[0] = mod->d[0])) tmod.top = 1; if ((buf[1] = mod->top > 1 ? mod->d[1] : 0)) tmod.top = 2; if (BN_is_one(&tmod)) BN_zero(Ri); else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL) goto err; if (!BN_lshift(Ri, Ri, 2 * BN_BITS2)) goto err; if (!BN_is_zero(Ri)) { if (!BN_sub_word(Ri, 1)) goto err; } else { if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL) goto err; Ri->neg = 0; Ri->d[0] = BN_MASK2; Ri->d[1] = BN_MASK2; Ri->top = 2; } if (!BN_div(Ri, NULL, Ri, &tmod, ctx)) goto err; mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0; mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0; # else BN_zero(R); if (!(BN_set_bit(R, BN_BITS2))) goto err; buf[0] = mod->d[0]; buf[1] = 0; tmod.top = buf[0] != 0 ? 1 : 0; if (BN_is_one(&tmod)) BN_zero(Ri); else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL) goto err; if (!BN_lshift(Ri, Ri, BN_BITS2)) goto err; if (!BN_is_zero(Ri)) { if (!BN_sub_word(Ri, 1)) goto err; } else { if (!BN_set_word(Ri, BN_MASK2)) goto err; } if (!BN_div(Ri, NULL, Ri, &tmod, ctx)) goto err; mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0; mont->n0[1] = 0; # endif } #else { mont->ri = BN_num_bits(&mont->N); BN_zero(R); if (!BN_set_bit(R, mont->ri)) goto err; if ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL) goto err; if (!BN_lshift(Ri, Ri, mont->ri)) goto err; if (!BN_sub_word(Ri, 1)) goto err; if (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx)) goto err; } #endif BN_zero(&(mont->RR)); if (!BN_set_bit(&(mont->RR), mont->ri * 2)) goto err; if (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx)) goto err; ret = 1; err: BN_CTX_end(ctx); return ret; }","- int ret = 0;
+ int i, ret = 0;
+ for (i = mont->RR.top, ret = mont->N.top; i < ret; i++)
+ mont->RR.d[i] = 0;
+ mont->RR.top = ret;
+ mont->RR.flags |= BN_FLG_FIXED_TOP;","int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx) { int i, ret = 0; BIGNUM *Ri, *R; if (BN_is_zero(mod)) return 0; BN_CTX_start(ctx); if ((Ri = BN_CTX_get(ctx)) == NULL) goto err; R = &(mont->RR); if (!BN_copy(&(mont->N), mod)) goto err; if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0) BN_set_flags(&(mont->N), BN_FLG_CONSTTIME); mont->N.neg = 0; #ifdef MONT_WORD { BIGNUM tmod; BN_ULONG buf[2]; bn_init(&tmod); tmod.d = buf; tmod.dmax = 2; tmod.neg = 0; if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0) BN_set_flags(&tmod, BN_FLG_CONSTTIME); mont->ri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2; # if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32) BN_zero(R); if (!(BN_set_bit(R, 2 * BN_BITS2))) goto err; tmod.top = 0; if ((buf[0] = mod->d[0])) tmod.top = 1; if ((buf[1] = mod->top > 1 ? mod->d[1] : 0)) tmod.top = 2; if (BN_is_one(&tmod)) BN_zero(Ri); else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL) goto err; if (!BN_lshift(Ri, Ri, 2 * BN_BITS2)) goto err; if (!BN_is_zero(Ri)) { if (!BN_sub_word(Ri, 1)) goto err; } else { if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL) goto err; Ri->neg = 0; Ri->d[0] = BN_MASK2; Ri->d[1] = BN_MASK2; Ri->top = 2; } if (!BN_div(Ri, NULL, Ri, &tmod, ctx)) goto err; mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0; mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0; # else BN_zero(R); if (!(BN_set_bit(R, BN_BITS2))) goto err; buf[0] = mod->d[0]; buf[1] = 0; tmod.top = buf[0] != 0 ? 1 : 0; if (BN_is_one(&tmod)) BN_zero(Ri); else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL) goto err; if (!BN_lshift(Ri, Ri, BN_BITS2)) goto err; if (!BN_is_zero(Ri)) { if (!BN_sub_word(Ri, 1)) goto err; } else { if (!BN_set_word(Ri, BN_MASK2)) goto err; } if (!BN_div(Ri, NULL, Ri, &tmod, ctx)) goto err; mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0; mont->n0[1] = 0; # endif } #else { mont->ri = BN_num_bits(&mont->N); BN_zero(R); if (!BN_set_bit(R, mont->ri)) goto err; if ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL) goto err; if (!BN_lshift(Ri, Ri, mont->ri)) goto err; if (!BN_sub_word(Ri, 1)) goto err; if (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx)) goto err; } #endif BN_zero(&(mont->RR)); if (!BN_set_bit(&(mont->RR), mont->ri * 2)) goto err; if (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx)) goto err; for (i = mont->RR.top, ret = mont->N.top; i < ret; i++) mont->RR.d[i] = 0; mont->RR.top = ret; mont->RR.flags |= BN_FLG_FIXED_TOP; ret = 1; err: BN_CTX_end(ctx); return ret; }"
9967----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_525b151845c54c6365d530a931c8ceb3588cfc58_1.json----ngx_rbtree_insert_timer_value,"void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel) { ngx_rbtree_node_t **p; for ( ;; ) { <S2SV_StartVul> p = ((ngx_rbtree_key_int_t) node->key - (ngx_rbtree_key_int_t) temp->key <S2SV_EndVul> <S2SV_StartVul> < 0) <S2SV_EndVul> ? &temp->left : &temp->right; if (*p == sentinel) { break; } temp = *p; } *p = node; node->parent = temp; node->left = sentinel; node->right = sentinel; ngx_rbt_red(node); }","- p = ((ngx_rbtree_key_int_t) node->key - (ngx_rbtree_key_int_t) temp->key
- < 0)
+ p = ((ngx_rbtree_key_int_t) (node->key - temp->key) < 0)","void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel) { ngx_rbtree_node_t **p; for ( ;; ) { p = ((ngx_rbtree_key_int_t) (node->key - temp->key) < 0) ? &temp->left : &temp->right; if (*p == sentinel) { break; } temp = *p; } *p = node; node->parent = temp; node->left = sentinel; node->right = sentinel; ngx_rbt_red(node); }"
17365----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_f8c063c882c2172f6fa20d284b85143b06c861dd_1.json----sh_testbit,"static int sh_testbit(char *ptr, int list, unsigned char *table) { <S2SV_StartVul> int bit; <S2SV_EndVul> OPENSSL_assert(list >= 0 && list < sh.freelist_size); OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0); <S2SV_StartVul> bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list)); <S2SV_EndVul> OPENSSL_assert(bit > 0 && bit < sh.bittable_size); return TESTBIT(table, bit); }","- int bit;
- bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));
+ size_t bit;
+ bit = (ONE << list) + ((ptr - sh.arena) / (sh.arena_size >> list));","static int sh_testbit(char *ptr, int list, unsigned char *table) { size_t bit; OPENSSL_assert(list >= 0 && list < sh.freelist_size); OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0); bit = (ONE << list) + ((ptr - sh.arena) / (sh.arena_size >> list)); OPENSSL_assert(bit > 0 && bit < sh.bittable_size); return TESTBIT(table, bit); }"
1447----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4fb9ce3b4cc54cba14ce5ef3c1672bc3d73784f2_1.json----ff_psy_preprocess_init,"struct FFPsyPreprocessContext* ff_psy_preprocess_init(AVCodecContext *avctx) { FFPsyPreprocessContext *ctx; int i; float cutoff_coeff = 0; ctx = av_mallocz(sizeof(FFPsyPreprocessContext)); if (!ctx) return NULL; ctx->avctx = avctx; if (avctx->cutoff > 0) cutoff_coeff = 2.0 * avctx->cutoff / avctx->sample_rate; <S2SV_StartVul> if (!cutoff_coeff && avctx->codec_id == AV_CODEC_ID_AAC) <S2SV_EndVul> <S2SV_StartVul> cutoff_coeff = 2.0 * AAC_CUTOFF(avctx) / avctx->sample_rate; <S2SV_EndVul> if (cutoff_coeff && cutoff_coeff < 0.98) ctx->fcoeffs = ff_iir_filter_init_coeffs(avctx, FF_FILTER_TYPE_BUTTERWORTH, FF_FILTER_MODE_LOWPASS, FILT_ORDER, cutoff_coeff, 0.0, 0.0); if (ctx->fcoeffs) { <S2SV_StartVul> ctx->fstate = av_mallocz_array(sizeof(ctx->fstate[0]), avctx->channels); <S2SV_EndVul> <S2SV_StartVul> if (!ctx->fstate) { <S2SV_EndVul> <S2SV_StartVul> av_free(ctx); <S2SV_EndVul> <S2SV_StartVul> return NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> for (i = 0; i < avctx->channels; i++) ctx->fstate[i] = ff_iir_filter_init_state(FILT_ORDER); } ff_iir_filter_init(&ctx->fiir); return ctx; }","- if (!cutoff_coeff && avctx->codec_id == AV_CODEC_ID_AAC)
- cutoff_coeff = 2.0 * AAC_CUTOFF(avctx) / avctx->sample_rate;
- ctx->fstate = av_mallocz_array(sizeof(ctx->fstate[0]), avctx->channels);
- if (!ctx->fstate) {
- av_free(ctx);
- return NULL;
- }
+ if (avctx->codec_id != AV_CODEC_ID_AAC) {
+ ctx->fstate = av_mallocz(sizeof(ctx->fstate[0]) * avctx->channels);
+ }","struct FFPsyPreprocessContext* ff_psy_preprocess_init(AVCodecContext *avctx) { FFPsyPreprocessContext *ctx; int i; float cutoff_coeff = 0; ctx = av_mallocz(sizeof(FFPsyPreprocessContext)); if (!ctx) return NULL; ctx->avctx = avctx; if (avctx->codec_id != AV_CODEC_ID_AAC) { if (avctx->cutoff > 0) cutoff_coeff = 2.0 * avctx->cutoff / avctx->sample_rate; if (cutoff_coeff && cutoff_coeff < 0.98) ctx->fcoeffs = ff_iir_filter_init_coeffs(avctx, FF_FILTER_TYPE_BUTTERWORTH, FF_FILTER_MODE_LOWPASS, FILT_ORDER, cutoff_coeff, 0.0, 0.0); if (ctx->fcoeffs) { ctx->fstate = av_mallocz(sizeof(ctx->fstate[0]) * avctx->channels); for (i = 0; i < avctx->channels; i++) ctx->fstate[i] = ff_iir_filter_init_state(FILT_ORDER); } } ff_iir_filter_init(&ctx->fiir); return ctx; }"
13470----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_710a178cffb51f4975faffefeec58a3251163406_1.json----BN_CTX_init,"<S2SV_StartVul> void BN_CTX_init(BN_CTX *ctx) <S2SV_EndVul> #else <S2SV_StartVul> static void BN_CTX_init(BN_CTX *ctx) <S2SV_EndVul> #endif { <S2SV_StartVul> #if 0 <S2SV_EndVul> <S2SV_StartVul> int i; <S2SV_EndVul> <S2SV_StartVul> ctx->tos = 0; <S2SV_EndVul> <S2SV_StartVul> ctx->flags = 0; <S2SV_EndVul> <S2SV_StartVul> ctx->depth = 0; <S2SV_EndVul> ctx->too_many = 0; <S2SV_StartVul> for (i = 0; i < BN_CTX_NUM; i++) <S2SV_EndVul> <S2SV_StartVul> BN_init(&(ctx->bn[i])); <S2SV_EndVul> <S2SV_StartVul> #else <S2SV_EndVul> <S2SV_StartVul> memset(ctx, 0, sizeof *ctx); <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> }","- void BN_CTX_init(BN_CTX *ctx)
- static void BN_CTX_init(BN_CTX *ctx)
- int i;
- ctx->tos = 0;
- ctx->flags = 0;
- ctx->depth = 0;
- for (i = 0; i < BN_CTX_NUM; i++)
- BN_init(&(ctx->bn[i]));
- #else
- memset(ctx, 0, sizeof *ctx);
- #endif
+ void BN_CTX_init(BN_CTX *ctx)
+ BN_POOL_reset(&ctx->pool);
+ BN_STACK_reset(&ctx->stack);
+ ctx->used = 0;
+ ctx->err_stack = 0;",void BN_CTX_init(BN_CTX *ctx) { BN_POOL_reset(&ctx->pool); BN_STACK_reset(&ctx->stack); ctx->used = 0; ctx->err_stack = 0; ctx->too_many = 0; }
860----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2f21bbc819b0b66474110099f4df35edf950a584_1.json----read_frame,"static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt, uint8_t block_type, AVFormatContext *s) { uint8_t * vidbuf_start = NULL; int vidbuf_nbytes = 0; int code; int bytes_copied = 0; int position, duration, npixels; unsigned int vidbuf_capacity; int ret = 0; AVStream *st; if (vid->video_index < 0) { st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); vid->video_index = st->index; if (vid->audio_index < 0) { av_log_ask_for_sample(s, ""No audio packet before first video "" ""packet. Using default video time base.\n""); } avpriv_set_pts_info(st, 64, 185, vid->sample_rate); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_BETHSOFTVID; st->codec->width = vid->width; st->codec->height = vid->height; } st = s->streams[vid->video_index]; npixels = st->codec->width * st->codec->height; vidbuf_start = av_malloc(vidbuf_capacity = BUFFER_PADDING_SIZE); if(!vidbuf_start) return AVERROR(ENOMEM); position = avio_tell(pb) - 1; vidbuf_start[vidbuf_nbytes++] = block_type; duration = vid->bethsoft_global_delay + avio_rl16(pb); if(block_type == VIDEO_YOFF_P_FRAME){ if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) { ret = AVERROR(EIO); goto fail; } vidbuf_nbytes += 2; } do{ vidbuf_start = av_fast_realloc(vidbuf_start, &vidbuf_capacity, vidbuf_nbytes + BUFFER_PADDING_SIZE); if(!vidbuf_start) return AVERROR(ENOMEM); code = avio_r8(pb); vidbuf_start[vidbuf_nbytes++] = code; if(code >= 0x80){ if(block_type == VIDEO_I_FRAME) vidbuf_start[vidbuf_nbytes++] = avio_r8(pb); } else if(code){ if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) { ret = AVERROR(EIO); goto fail; } vidbuf_nbytes += code; } bytes_copied += code & 0x7F; if(bytes_copied == npixels){ if(avio_r8(pb)) avio_seek(pb, -1, SEEK_CUR); break; } if (bytes_copied > npixels) { ret = AVERROR_INVALIDDATA; goto fail; } } while(code); if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0) goto fail; memcpy(pkt->data, vidbuf_start, vidbuf_nbytes); av_free(vidbuf_start); pkt->pos = position; pkt->stream_index = vid->video_index; pkt->duration = duration; if (block_type == VIDEO_I_FRAME) pkt->flags |= AV_PKT_FLAG_KEY; if (vid->palette) { uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, BVID_PALETTE_SIZE); <S2SV_StartVul> memcpy(pdata, vid->palette, BVID_PALETTE_SIZE); <S2SV_EndVul> av_freep(&vid->palette); } vid->nframes--; return 0; fail: av_free(vidbuf_start); return ret; }","- memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);
+ if (pdata)
+ memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);","static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt, uint8_t block_type, AVFormatContext *s) { uint8_t * vidbuf_start = NULL; int vidbuf_nbytes = 0; int code; int bytes_copied = 0; int position, duration, npixels; unsigned int vidbuf_capacity; int ret = 0; AVStream *st; if (vid->video_index < 0) { st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); vid->video_index = st->index; if (vid->audio_index < 0) { av_log_ask_for_sample(s, ""No audio packet before first video "" ""packet. Using default video time base.\n""); } avpriv_set_pts_info(st, 64, 185, vid->sample_rate); st->codec->codec_type = AVMEDIA_TYPE_VIDEO; st->codec->codec_id = AV_CODEC_ID_BETHSOFTVID; st->codec->width = vid->width; st->codec->height = vid->height; } st = s->streams[vid->video_index]; npixels = st->codec->width * st->codec->height; vidbuf_start = av_malloc(vidbuf_capacity = BUFFER_PADDING_SIZE); if(!vidbuf_start) return AVERROR(ENOMEM); position = avio_tell(pb) - 1; vidbuf_start[vidbuf_nbytes++] = block_type; duration = vid->bethsoft_global_delay + avio_rl16(pb); if(block_type == VIDEO_YOFF_P_FRAME){ if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) { ret = AVERROR(EIO); goto fail; } vidbuf_nbytes += 2; } do{ vidbuf_start = av_fast_realloc(vidbuf_start, &vidbuf_capacity, vidbuf_nbytes + BUFFER_PADDING_SIZE); if(!vidbuf_start) return AVERROR(ENOMEM); code = avio_r8(pb); vidbuf_start[vidbuf_nbytes++] = code; if(code >= 0x80){ if(block_type == VIDEO_I_FRAME) vidbuf_start[vidbuf_nbytes++] = avio_r8(pb); } else if(code){ if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) { ret = AVERROR(EIO); goto fail; } vidbuf_nbytes += code; } bytes_copied += code & 0x7F; if(bytes_copied == npixels){ if(avio_r8(pb)) avio_seek(pb, -1, SEEK_CUR); break; } if (bytes_copied > npixels) { ret = AVERROR_INVALIDDATA; goto fail; } } while(code); if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0) goto fail; memcpy(pkt->data, vidbuf_start, vidbuf_nbytes); av_free(vidbuf_start); pkt->pos = position; pkt->stream_index = vid->video_index; pkt->duration = duration; if (block_type == VIDEO_I_FRAME) pkt->flags |= AV_PKT_FLAG_KEY; if (vid->palette) { uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, BVID_PALETTE_SIZE); if (pdata) memcpy(pdata, vid->palette, BVID_PALETTE_SIZE); av_freep(&vid->palette); } vid->nframes--; return 0; fail: av_free(vidbuf_start); return ret; }"
16646----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_de919e0935eded987093d8ea3897c7f688a390e2_1.json----crl2pkcs7_main,"int MAIN(int argc, char **argv) { int i,badops=0; BIO *in=NULL,*out=NULL; int informat,outformat; char *infile,*outfile,*prog,*certfile; PKCS7 *p7 = NULL; PKCS7_SIGNED *p7s = NULL; X509_CRL *crl=NULL; STACK *certflst=NULL; STACK_OF(X509_CRL) *crl_stack=NULL; STACK_OF(X509) *cert_stack=NULL; int ret=1,nocrl=0; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-nocrl"") == 0) { nocrl=1; } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-certfile"") == 0) { if (--argc < 1) goto bad; if(!certflst) certflst = sk_new_null(); sk_push(certflst,*(++argv)); } else { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - DER or PEM\n""); BIO_printf(bio_err,"" -outform arg output format - DER or PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -certfile arg certificates file of chain to a trusted CA\n""); BIO_printf(bio_err,"" (can be used more than once)\n""); BIO_printf(bio_err,"" -nocrl no crl to load, just certs from '-certfile'\n""); EXIT(1); } ERR_load_crypto_strings(); in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (!nocrl) { if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) { perror(infile); goto end; } } if (informat == FORMAT_ASN1) crl=d2i_X509_CRL_bio(in,NULL); else if (informat == FORMAT_PEM) crl=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL); else { BIO_printf(bio_err,""bad input format specified for input crl\n""); goto end; } if (crl == NULL) { BIO_printf(bio_err,""unable to load CRL\n""); ERR_print_errors(bio_err); goto end; } } if ((p7=PKCS7_new()) == NULL) goto end; if ((p7s=PKCS7_SIGNED_new()) == NULL) goto end; p7->type=OBJ_nid2obj(NID_pkcs7_signed); p7->d.sign=p7s; p7s->contents->type=OBJ_nid2obj(NID_pkcs7_data); if (!ASN1_INTEGER_set(p7s->version,1)) goto end; if ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end; p7s->crl=crl_stack; if (crl != NULL) { sk_X509_CRL_push(crl_stack,crl); crl=NULL; } if ((cert_stack=sk_X509_new_null()) == NULL) goto end; p7s->cert=cert_stack; if(certflst) for(i = 0; i < sk_num(certflst); i++) { certfile = sk_value(certflst, i); if (add_certs_from_file(cert_stack,certfile) < 0) { BIO_printf(bio_err, ""error loading certificates\n""); ERR_print_errors(bio_err); goto end; } } sk_free(certflst); if (outfile == NULL) BIO_set_fp(out,stdout,BIO_NOCLOSE); else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (outformat == FORMAT_ASN1) i=i2d_PKCS7_bio(out,p7); else if (outformat == FORMAT_PEM) i=PEM_write_bio_PKCS7(out,p7); else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } ret=0; end: if (in != NULL) BIO_free(in); <S2SV_StartVul> if (out != NULL) BIO_free(out); <S2SV_EndVul> if (p7 != NULL) PKCS7_free(p7); if (crl != NULL) X509_CRL_free(crl); EXIT(ret); }","- if (out != NULL) BIO_free(out);
+ {
+ #ifdef VMS
+ {
+ BIO *tmpbio = BIO_new(BIO_f_linebuffer());
+ out = BIO_push(tmpbio, out);
+ }
+ #endif
+ }
+ if (out != NULL) BIO_free_all(out);","int MAIN(int argc, char **argv) { int i,badops=0; BIO *in=NULL,*out=NULL; int informat,outformat; char *infile,*outfile,*prog,*certfile; PKCS7 *p7 = NULL; PKCS7_SIGNED *p7s = NULL; X509_CRL *crl=NULL; STACK *certflst=NULL; STACK_OF(X509_CRL) *crl_stack=NULL; STACK_OF(X509) *cert_stack=NULL; int ret=1,nocrl=0; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-nocrl"") == 0) { nocrl=1; } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-certfile"") == 0) { if (--argc < 1) goto bad; if(!certflst) certflst = sk_new_null(); sk_push(certflst,*(++argv)); } else { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - DER or PEM\n""); BIO_printf(bio_err,"" -outform arg output format - DER or PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -certfile arg certificates file of chain to a trusted CA\n""); BIO_printf(bio_err,"" (can be used more than once)\n""); BIO_printf(bio_err,"" -nocrl no crl to load, just certs from '-certfile'\n""); EXIT(1); } ERR_load_crypto_strings(); in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (!nocrl) { if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) { perror(infile); goto end; } } if (informat == FORMAT_ASN1) crl=d2i_X509_CRL_bio(in,NULL); else if (informat == FORMAT_PEM) crl=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL); else { BIO_printf(bio_err,""bad input format specified for input crl\n""); goto end; } if (crl == NULL) { BIO_printf(bio_err,""unable to load CRL\n""); ERR_print_errors(bio_err); goto end; } } if ((p7=PKCS7_new()) == NULL) goto end; if ((p7s=PKCS7_SIGNED_new()) == NULL) goto end; p7->type=OBJ_nid2obj(NID_pkcs7_signed); p7->d.sign=p7s; p7s->contents->type=OBJ_nid2obj(NID_pkcs7_data); if (!ASN1_INTEGER_set(p7s->version,1)) goto end; if ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end; p7s->crl=crl_stack; if (crl != NULL) { sk_X509_CRL_push(crl_stack,crl); crl=NULL; } if ((cert_stack=sk_X509_new_null()) == NULL) goto end; p7s->cert=cert_stack; if(certflst) for(i = 0; i < sk_num(certflst); i++) { certfile = sk_value(certflst, i); if (add_certs_from_file(cert_stack,certfile) < 0) { BIO_printf(bio_err, ""error loading certificates\n""); ERR_print_errors(bio_err); goto end; } } sk_free(certflst); if (outfile == NULL) { BIO_set_fp(out,stdout,BIO_NOCLOSE); #ifdef VMS { BIO *tmpbio = BIO_new(BIO_f_linebuffer()); out = BIO_push(tmpbio, out); } #endif } else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (outformat == FORMAT_ASN1) i=i2d_PKCS7_bio(out,p7); else if (outformat == FORMAT_PEM) i=PEM_write_bio_PKCS7(out,p7); else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } ret=0; end: if (in != NULL) BIO_free(in); if (out != NULL) BIO_free_all(out); if (p7 != NULL) PKCS7_free(p7); if (crl != NULL) X509_CRL_free(crl); EXIT(ret); }"
1492----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_52e106e92fdff9e1f67c694f074adcb4473e0c0f_1.json----cinaudio_decode_frame,"static int cinaudio_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; <S2SV_StartVul> int buf_size = avpkt->size; <S2SV_EndVul> CinAudioContext *cin = avctx->priv_data; <S2SV_StartVul> const uint8_t *src = buf; <S2SV_EndVul> int16_t *samples = data; <S2SV_StartVul> int delta; <S2SV_EndVul> <S2SV_StartVul> buf_size = FFMIN(buf_size, *data_size/2); <S2SV_EndVul> delta = cin->delta; if (cin->initial_decode_frame) { cin->initial_decode_frame = 0; <S2SV_StartVul> delta = (int16_t)AV_RL16(src); src += 2; <S2SV_EndVul> *samples++ = delta; <S2SV_StartVul> buf_size -= 2; <S2SV_EndVul> } <S2SV_StartVul> while (buf_size > 0) { <S2SV_EndVul> <S2SV_StartVul> delta += cinaudio_delta16_table[*src++]; <S2SV_EndVul> delta = av_clip_int16(delta); *samples++ = delta; <S2SV_StartVul> --buf_size; <S2SV_EndVul> } cin->delta = delta; <S2SV_StartVul> *data_size = (uint8_t *)samples - (uint8_t *)data; <S2SV_EndVul> <S2SV_StartVul> return src - buf; <S2SV_EndVul> }","- int buf_size = avpkt->size;
- const uint8_t *src = buf;
- int delta;
- buf_size = FFMIN(buf_size, *data_size/2);
- delta = (int16_t)AV_RL16(src); src += 2;
- buf_size -= 2;
- while (buf_size > 0) {
- delta += cinaudio_delta16_table[*src++];
- --buf_size;
- return src - buf;
+ const uint8_t *buf_end = buf + avpkt->size;
+ int delta, out_size;
+ out_size = (avpkt->size - cin->initial_decode_frame) *
+ av_get_bytes_per_sample(avctx->sample_fmt);
+ if (*data_size < out_size) {
+ av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
+ return AVERROR(EINVAL);
+ }
+ delta = (int16_t)AV_RL16(buf);
+ buf += 2;
+ while (buf < buf_end) {
+ delta += cinaudio_delta16_table[*buf++];
+ return avpkt->size;","static int cinaudio_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; CinAudioContext *cin = avctx->priv_data; const uint8_t *buf_end = buf + avpkt->size; int16_t *samples = data; int delta, out_size; out_size = (avpkt->size - cin->initial_decode_frame) * av_get_bytes_per_sample(avctx->sample_fmt); if (*data_size < out_size) { av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n""); return AVERROR(EINVAL); } delta = cin->delta; if (cin->initial_decode_frame) { cin->initial_decode_frame = 0; delta = (int16_t)AV_RL16(buf); buf += 2; *samples++ = delta; } while (buf < buf_end) { delta += cinaudio_delta16_table[*buf++]; delta = av_clip_int16(delta); *samples++ = delta; } cin->delta = delta; *data_size = out_size; return avpkt->size; }"
11222----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2228ac0bb84eaa9490fc2c2c6edcff9c629608c9_1.json----ssl3_cbc_digest_record,"void ssl3_cbc_digest_record( const EVP_MD_CTX *ctx, unsigned char* md_out, size_t* md_out_size, const unsigned char header[13], const unsigned char *data, size_t data_plus_mac_size, size_t data_plus_mac_plus_padding_size, const unsigned char *mac_secret, unsigned mac_secret_length, char is_sslv3) { <S2SV_StartVul> unsigned char md_state[sizeof(SHA512_CTX)]; <S2SV_EndVul> void (*md_final_raw)(void *ctx, unsigned char *md_out); void (*md_transform)(void *ctx, const unsigned char *block); unsigned md_size, md_block_size = 64; unsigned sslv3_pad_length = 40, header_length, variance_blocks, len, max_mac_bytes, num_blocks, num_starting_blocks, k, mac_end_offset, c, index_a, index_b; unsigned int bits; unsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; unsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; unsigned char first_block[MAX_HASH_BLOCK_SIZE]; unsigned char mac_out[EVP_MAX_MD_SIZE]; unsigned i, j, md_out_size_u; EVP_MD_CTX md_ctx; unsigned md_length_size = 8; OPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); switch (ctx->digest->type) { case NID_md5: <S2SV_StartVul> MD5_Init((MD5_CTX*)md_state); <S2SV_EndVul> md_final_raw = tls1_md5_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; md_size = 16; sslv3_pad_length = 48; break; case NID_sha1: <S2SV_StartVul> SHA1_Init((SHA_CTX*)md_state); <S2SV_EndVul> md_final_raw = tls1_sha1_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; md_size = 20; break; case NID_sha224: <S2SV_StartVul> SHA224_Init((SHA256_CTX*)md_state); <S2SV_EndVul> md_final_raw = tls1_sha256_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; md_size = 224/8; break; case NID_sha256: <S2SV_StartVul> SHA256_Init((SHA256_CTX*)md_state); <S2SV_EndVul> md_final_raw = tls1_sha256_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; md_size = 32; break; case NID_sha384: <S2SV_StartVul> SHA384_Init((SHA512_CTX*)md_state); <S2SV_EndVul> md_final_raw = tls1_sha512_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; md_size = 384/8; md_block_size = 128; md_length_size = 16; break; case NID_sha512: <S2SV_StartVul> SHA512_Init((SHA512_CTX*)md_state); <S2SV_EndVul> md_final_raw = tls1_sha512_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; md_size = 64; md_block_size = 128; md_length_size = 16; break; default: OPENSSL_assert(0); if (md_out_size) *md_out_size = -1; return; } OPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); OPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); header_length = 13; if (is_sslv3) { header_length = mac_secret_length + sslv3_pad_length + 8 + 1 + 2 ; } variance_blocks = is_sslv3 ? 2 : 6; len = data_plus_mac_plus_padding_size + header_length; max_mac_bytes = len - md_size - 1; num_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; num_starting_blocks = 0; k = 0; mac_end_offset = data_plus_mac_size + header_length - md_size; c = mac_end_offset % md_block_size; index_a = mac_end_offset / md_block_size; index_b = (mac_end_offset + md_length_size) / md_block_size; if (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) { num_starting_blocks = num_blocks - variance_blocks; k = md_block_size*num_starting_blocks; } bits = 8*mac_end_offset; if (!is_sslv3) { bits += 8*md_block_size; memset(hmac_pad, 0, md_block_size); OPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); memcpy(hmac_pad, mac_secret, mac_secret_length); for (i = 0; i < md_block_size; i++) hmac_pad[i] ^= 0x36; <S2SV_StartVul> md_transform(md_state, hmac_pad); <S2SV_EndVul> } memset(length_bytes,0,md_length_size-4); length_bytes[md_length_size-4] = (unsigned char)(bits>>24); length_bytes[md_length_size-3] = (unsigned char)(bits>>16); length_bytes[md_length_size-2] = (unsigned char)(bits>>8); length_bytes[md_length_size-1] = (unsigned char)bits; if (k > 0) { if (is_sslv3) { unsigned overhang = header_length-md_block_size; <S2SV_StartVul> md_transform(md_state, header); <S2SV_EndVul> memcpy(first_block, header + md_block_size, overhang); memcpy(first_block + overhang, data, md_block_size-overhang); <S2SV_StartVul> md_transform(md_state, first_block); <S2SV_EndVul> for (i = 1; i < k/md_block_size - 1; i++) <S2SV_StartVul> md_transform(md_state, data + md_block_size*i - overhang); <S2SV_EndVul> } else { memcpy(first_block, header, 13); memcpy(first_block+13, data, md_block_size-13); <S2SV_StartVul> md_transform(md_state, first_block); <S2SV_EndVul> for (i = 1; i < k/md_block_size; i++) <S2SV_StartVul> md_transform(md_state, data + md_block_size*i - 13); <S2SV_EndVul> } } memset(mac_out, 0, sizeof(mac_out)); for (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) { unsigned char block[MAX_HASH_BLOCK_SIZE]; unsigned char is_block_a = constant_time_eq_8(i, index_a); unsigned char is_block_b = constant_time_eq_8(i, index_b); for (j = 0; j < md_block_size; j++) { unsigned char b = 0, is_past_c, is_past_cp1; if (k < header_length) b = header[k]; else if (k < data_plus_mac_plus_padding_size + header_length) b = data[k-header_length]; k++; is_past_c = is_block_a & constant_time_ge(j, c); is_past_cp1 = is_block_a & constant_time_ge(j, c+1); b = (b&~is_past_c) | (0x80&is_past_c); b = b&~is_past_cp1; b &= ~is_block_b | is_block_a; if (j >= md_block_size - md_length_size) { b = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); } block[j] = b; } <S2SV_StartVul> md_transform(md_state, block); <S2SV_EndVul> <S2SV_StartVul> md_final_raw(md_state, block); <S2SV_EndVul> for (j = 0; j < md_size; j++) mac_out[j] |= block[j]&is_block_b; } EVP_MD_CTX_init(&md_ctx); EVP_DigestInit_ex(&md_ctx, ctx->digest, NULL ); if (is_sslv3) { memset(hmac_pad, 0x5c, sslv3_pad_length); EVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); EVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); EVP_DigestUpdate(&md_ctx, mac_out, md_size); } else { for (i = 0; i < md_block_size; i++) hmac_pad[i] ^= 0x6a; EVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); EVP_DigestUpdate(&md_ctx, mac_out, md_size); } EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); if (md_out_size) *md_out_size = md_out_size_u; EVP_MD_CTX_cleanup(&md_ctx); }","- unsigned char md_state[sizeof(SHA512_CTX)];
- MD5_Init((MD5_CTX*)md_state);
- SHA1_Init((SHA_CTX*)md_state);
- SHA224_Init((SHA256_CTX*)md_state);
- SHA256_Init((SHA256_CTX*)md_state);
- SHA384_Init((SHA512_CTX*)md_state);
- SHA512_Init((SHA512_CTX*)md_state);
- md_transform(md_state, hmac_pad);
- md_transform(md_state, header);
- md_transform(md_state, first_block);
- md_transform(md_state, data + md_block_size*i - overhang);
- md_transform(md_state, first_block);
- md_transform(md_state, data + md_block_size*i - 13);
- md_transform(md_state, block);
- md_final_raw(md_state, block);
+ union { double align;
+ unsigned char c[sizeof(SHA512_CTX)]; } md_state;
+ MD5_Init((MD5_CTX*)md_state.c);
+ SHA1_Init((SHA_CTX*)md_state.c);
+ SHA224_Init((SHA256_CTX*)md_state.c);
+ SHA256_Init((SHA256_CTX*)md_state.c);
+ SHA384_Init((SHA512_CTX*)md_state.c);
+ SHA512_Init((SHA512_CTX*)md_state.c);
+ md_transform(md_state.c, hmac_pad);
+ md_transform(md_state.c, header);
+ md_transform(md_state.c, first_block);
+ md_transform(md_state.c, data + md_block_size*i - overhang);
+ md_transform(md_state.c, first_block);
+ md_transform(md_state.c, data + md_block_size*i - 13);
+ md_transform(md_state.c, block);
+ md_final_raw(md_state.c, block);","void ssl3_cbc_digest_record( const EVP_MD_CTX *ctx, unsigned char* md_out, size_t* md_out_size, const unsigned char header[13], const unsigned char *data, size_t data_plus_mac_size, size_t data_plus_mac_plus_padding_size, const unsigned char *mac_secret, unsigned mac_secret_length, char is_sslv3) { union { double align; unsigned char c[sizeof(SHA512_CTX)]; } md_state; void (*md_final_raw)(void *ctx, unsigned char *md_out); void (*md_transform)(void *ctx, const unsigned char *block); unsigned md_size, md_block_size = 64; unsigned sslv3_pad_length = 40, header_length, variance_blocks, len, max_mac_bytes, num_blocks, num_starting_blocks, k, mac_end_offset, c, index_a, index_b; unsigned int bits; unsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; unsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; unsigned char first_block[MAX_HASH_BLOCK_SIZE]; unsigned char mac_out[EVP_MAX_MD_SIZE]; unsigned i, j, md_out_size_u; EVP_MD_CTX md_ctx; unsigned md_length_size = 8; OPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); switch (ctx->digest->type) { case NID_md5: MD5_Init((MD5_CTX*)md_state.c); md_final_raw = tls1_md5_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; md_size = 16; sslv3_pad_length = 48; break; case NID_sha1: SHA1_Init((SHA_CTX*)md_state.c); md_final_raw = tls1_sha1_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; md_size = 20; break; case NID_sha224: SHA224_Init((SHA256_CTX*)md_state.c); md_final_raw = tls1_sha256_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; md_size = 224/8; break; case NID_sha256: SHA256_Init((SHA256_CTX*)md_state.c); md_final_raw = tls1_sha256_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; md_size = 32; break; case NID_sha384: SHA384_Init((SHA512_CTX*)md_state.c); md_final_raw = tls1_sha512_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; md_size = 384/8; md_block_size = 128; md_length_size = 16; break; case NID_sha512: SHA512_Init((SHA512_CTX*)md_state.c); md_final_raw = tls1_sha512_final_raw; md_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; md_size = 64; md_block_size = 128; md_length_size = 16; break; default: OPENSSL_assert(0); if (md_out_size) *md_out_size = -1; return; } OPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); OPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); header_length = 13; if (is_sslv3) { header_length = mac_secret_length + sslv3_pad_length + 8 + 1 + 2 ; } variance_blocks = is_sslv3 ? 2 : 6; len = data_plus_mac_plus_padding_size + header_length; max_mac_bytes = len - md_size - 1; num_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; num_starting_blocks = 0; k = 0; mac_end_offset = data_plus_mac_size + header_length - md_size; c = mac_end_offset % md_block_size; index_a = mac_end_offset / md_block_size; index_b = (mac_end_offset + md_length_size) / md_block_size; if (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) { num_starting_blocks = num_blocks - variance_blocks; k = md_block_size*num_starting_blocks; } bits = 8*mac_end_offset; if (!is_sslv3) { bits += 8*md_block_size; memset(hmac_pad, 0, md_block_size); OPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); memcpy(hmac_pad, mac_secret, mac_secret_length); for (i = 0; i < md_block_size; i++) hmac_pad[i] ^= 0x36; md_transform(md_state.c, hmac_pad); } memset(length_bytes,0,md_length_size-4); length_bytes[md_length_size-4] = (unsigned char)(bits>>24); length_bytes[md_length_size-3] = (unsigned char)(bits>>16); length_bytes[md_length_size-2] = (unsigned char)(bits>>8); length_bytes[md_length_size-1] = (unsigned char)bits; if (k > 0) { if (is_sslv3) { unsigned overhang = header_length-md_block_size; md_transform(md_state.c, header); memcpy(first_block, header + md_block_size, overhang); memcpy(first_block + overhang, data, md_block_size-overhang); md_transform(md_state.c, first_block); for (i = 1; i < k/md_block_size - 1; i++) md_transform(md_state.c, data + md_block_size*i - overhang); } else { memcpy(first_block, header, 13); memcpy(first_block+13, data, md_block_size-13); md_transform(md_state.c, first_block); for (i = 1; i < k/md_block_size; i++) md_transform(md_state.c, data + md_block_size*i - 13); } } memset(mac_out, 0, sizeof(mac_out)); for (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) { unsigned char block[MAX_HASH_BLOCK_SIZE]; unsigned char is_block_a = constant_time_eq_8(i, index_a); unsigned char is_block_b = constant_time_eq_8(i, index_b); for (j = 0; j < md_block_size; j++) { unsigned char b = 0, is_past_c, is_past_cp1; if (k < header_length) b = header[k]; else if (k < data_plus_mac_plus_padding_size + header_length) b = data[k-header_length]; k++; is_past_c = is_block_a & constant_time_ge(j, c); is_past_cp1 = is_block_a & constant_time_ge(j, c+1); b = (b&~is_past_c) | (0x80&is_past_c); b = b&~is_past_cp1; b &= ~is_block_b | is_block_a; if (j >= md_block_size - md_length_size) { b = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); } block[j] = b; } md_transform(md_state.c, block); md_final_raw(md_state.c, block); for (j = 0; j < md_size; j++) mac_out[j] |= block[j]&is_block_b; } EVP_MD_CTX_init(&md_ctx); EVP_DigestInit_ex(&md_ctx, ctx->digest, NULL ); if (is_sslv3) { memset(hmac_pad, 0x5c, sslv3_pad_length); EVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); EVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); EVP_DigestUpdate(&md_ctx, mac_out, md_size); } else { for (i = 0; i < md_block_size; i++) hmac_pad[i] ^= 0x6a; EVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); EVP_DigestUpdate(&md_ctx, mac_out, md_size); } EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); if (md_out_size) *md_out_size = md_out_size_u; EVP_MD_CTX_cleanup(&md_ctx); }"
618----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2204fb69aca783fb5dd0d83979f1779450165d42_1.json----open_input_stream,"static int open_input_stream(HTTPContext *c, const char *info) { char buf[128]; char input_filename[1024]; AVFormatContext *s; int buf_size, i, ret; int64_t stream_pos; if (c->stream->feed) { strcpy(input_filename, c->stream->feed->feed_filename); buf_size = FFM_PACKET_SIZE; if (find_info_tag(buf, sizeof(buf), ""date"", info)) { stream_pos = parse_date(buf, 0); if (stream_pos == INT64_MIN) return -1; } else if (find_info_tag(buf, sizeof(buf), ""buffer"", info)) { int prebuffer = strtol(buf, 0, 10); stream_pos = av_gettime() - prebuffer * (int64_t)1000000; } else stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000; } else { strcpy(input_filename, c->stream->feed_filename); buf_size = 0; if (find_info_tag(buf, sizeof(buf), ""date"", info)) { stream_pos = parse_date(buf, 1); if (stream_pos == INT64_MIN) return -1; } else stream_pos = 0; } if (input_filename[0] == '\0') return -1; #if 0 { time_t when = stream_pos / 1000000; http_log(""Stream pos = %""PRId64"", time=%s"", stream_pos, ctime(&when)); } #endif if ((ret = av_open_input_file(&s, input_filename, c->stream->ifmt, buf_size, c->stream->ap_in)) < 0) { http_log(""could not open %s: %d\n"", input_filename, ret); return -1; } s->flags |= AVFMT_FLAG_GENPTS; c->fmt_in = s; <S2SV_StartVul> av_find_stream_info(c->fmt_in); <S2SV_EndVul> for(i=0;i<s->nb_streams;i++) open_parser(s, i); c->pts_stream_index = 0; for(i=0;i<c->stream->nb_streams;i++) { if (c->pts_stream_index == 0 && c->stream->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) { c->pts_stream_index = i; } } #if 1 if (c->fmt_in->iformat->read_seek) av_seek_frame(c->fmt_in, -1, stream_pos, 0); #endif c->start_time = cur_time; c->first_pts = AV_NOPTS_VALUE; return 0; }","- av_find_stream_info(c->fmt_in);
+ if (av_find_stream_info(c->fmt_in) < 0) {
+ http_log(""Could not find stream info '%s'\n"", input_filename);
+ av_close_input_file(s);
+ return -1;
+ }","static int open_input_stream(HTTPContext *c, const char *info) { char buf[128]; char input_filename[1024]; AVFormatContext *s; int buf_size, i, ret; int64_t stream_pos; if (c->stream->feed) { strcpy(input_filename, c->stream->feed->feed_filename); buf_size = FFM_PACKET_SIZE; if (find_info_tag(buf, sizeof(buf), ""date"", info)) { stream_pos = parse_date(buf, 0); if (stream_pos == INT64_MIN) return -1; } else if (find_info_tag(buf, sizeof(buf), ""buffer"", info)) { int prebuffer = strtol(buf, 0, 10); stream_pos = av_gettime() - prebuffer * (int64_t)1000000; } else stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000; } else { strcpy(input_filename, c->stream->feed_filename); buf_size = 0; if (find_info_tag(buf, sizeof(buf), ""date"", info)) { stream_pos = parse_date(buf, 1); if (stream_pos == INT64_MIN) return -1; } else stream_pos = 0; } if (input_filename[0] == '\0') return -1; #if 0 { time_t when = stream_pos / 1000000; http_log(""Stream pos = %""PRId64"", time=%s"", stream_pos, ctime(&when)); } #endif if ((ret = av_open_input_file(&s, input_filename, c->stream->ifmt, buf_size, c->stream->ap_in)) < 0) { http_log(""could not open %s: %d\n"", input_filename, ret); return -1; } s->flags |= AVFMT_FLAG_GENPTS; c->fmt_in = s; if (av_find_stream_info(c->fmt_in) < 0) { http_log(""Could not find stream info '%s'\n"", input_filename); av_close_input_file(s); return -1; } for(i=0;i<s->nb_streams;i++) open_parser(s, i); c->pts_stream_index = 0; for(i=0;i<c->stream->nb_streams;i++) { if (c->pts_stream_index == 0 && c->stream->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) { c->pts_stream_index = i; } } #if 1 if (c->fmt_in->iformat->read_seek) av_seek_frame(c->fmt_in, -1, stream_pos, 0); #endif c->start_time = cur_time; c->first_pts = AV_NOPTS_VALUE; return 0; }"
799----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2bdb329dc5ae63c78558cb1617c21fb0dcec65c4_1.json----avfilter_start_frame,"void avfilter_start_frame(AVFilterLink *link, AVFilterBufferRef *picref) { void (*start_frame)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = link->dstpad; FF_DPRINTF_START(NULL, start_frame); ff_dprintf_link(NULL, link, 0); dprintf(NULL, "" ""); ff_dprintf_ref(NULL, picref, 1); if (!(start_frame = dst->start_frame)) start_frame = avfilter_default_start_frame; <S2SV_StartVul> if ((dst->min_perms & picref->perms) != dst->min_perms || <S2SV_EndVul> <S2SV_StartVul> dst->rej_perms & picref->perms) { <S2SV_EndVul> av_log(link->dst, AV_LOG_DEBUG, ""frame copy needed (have perms %x, need %x, reject %x)\n"", picref->perms, link->dstpad->min_perms, link->dstpad->rej_perms); link->cur_buf = avfilter_get_video_buffer(link, dst->min_perms, link->w, link->h); link->src_buf = picref; avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf); } else link->cur_buf = picref; start_frame(link, link->cur_buf); }","- if ((dst->min_perms & picref->perms) != dst->min_perms ||
- dst->rej_perms & picref->perms) {
+ int perms = picref->perms;
+ if (picref->linesize[0] < 0)
+ perms |= AV_PERM_NEG_LINESIZES;
+ if ((dst->min_perms & perms) != dst->min_perms || dst->rej_perms & perms) {","void avfilter_start_frame(AVFilterLink *link, AVFilterBufferRef *picref) { void (*start_frame)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = link->dstpad; int perms = picref->perms; FF_DPRINTF_START(NULL, start_frame); ff_dprintf_link(NULL, link, 0); dprintf(NULL, "" ""); ff_dprintf_ref(NULL, picref, 1); if (!(start_frame = dst->start_frame)) start_frame = avfilter_default_start_frame; if (picref->linesize[0] < 0) perms |= AV_PERM_NEG_LINESIZES; if ((dst->min_perms & perms) != dst->min_perms || dst->rej_perms & perms) { av_log(link->dst, AV_LOG_DEBUG, ""frame copy needed (have perms %x, need %x, reject %x)\n"", picref->perms, link->dstpad->min_perms, link->dstpad->rej_perms); link->cur_buf = avfilter_get_video_buffer(link, dst->min_perms, link->w, link->h); link->src_buf = picref; avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf); } else link->cur_buf = picref; start_frame(link, link->cur_buf); }"
40----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0298aa6f29fec45f1adf1ed30ddda5eb4a5fc5f7_1.json----ass_decode_frame,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr, AVPacket *avpkt) { const char *ptr = avpkt->data; int len, size = avpkt->size; while (size > 0) { ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL); <S2SV_StartVul> int duration = dialog->end - dialog->start; <S2SV_EndVul> len = ff_ass_add_rect(data, ptr, 0, duration, 1); if (len < 0) return len; ptr += len; size -= len; } *got_sub_ptr = avpkt->size > 0; return avpkt->size; }","- int duration = dialog->end - dialog->start;
+ int duration;
+ if (!dialog)
+ return AVERROR_INVALIDDATA;
+ duration = dialog->end - dialog->start;","static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr, AVPacket *avpkt) { const char *ptr = avpkt->data; int len, size = avpkt->size; while (size > 0) { int duration; ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL); if (!dialog) return AVERROR_INVALIDDATA; duration = dialog->end - dialog->start; len = ff_ass_add_rect(data, ptr, 0, duration, 1); if (len < 0) return len; ptr += len; size -= len; } *got_sub_ptr = avpkt->size > 0; return avpkt->size; }"
540----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1df9158086d4899a3dbfc92117dcca59bbe5e95a_1.json----get_len,"static inline int get_len(LZOContext *c, int x, int mask) { int cnt = x & mask; if (!cnt) { <S2SV_StartVul> while (!(x = get_byte(c))) <S2SV_EndVul> cnt += 255; cnt += mask + x; } return cnt; }","- while (!(x = get_byte(c)))
+ while (!(x = get_byte(c))) {
+ if (cnt >= INT_MAX - 1000) {
+ c->error |= AV_LZO_ERROR;
+ break;
+ }
+ }","static inline int get_len(LZOContext *c, int x, int mask) { int cnt = x & mask; if (!cnt) { while (!(x = get_byte(c))) { if (cnt >= INT_MAX - 1000) { c->error |= AV_LZO_ERROR; break; } cnt += 255; } cnt += mask + x; } return cnt; }"
9032----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f2e3310a3143b3b5b495855e982c15f029278dfa_1.json----send_filter_eof,"static int send_filter_eof(InputStream *ist) { <S2SV_StartVul> int i, j, ret; <S2SV_EndVul> for (i = 0; i < ist->nb_filters; i++) { <S2SV_StartVul> if (ist->filters[i]->filter) { <S2SV_EndVul> <S2SV_StartVul> ret = av_buffersrc_add_frame(ist->filters[i]->filter, NULL); <S2SV_EndVul> <S2SV_StartVul> if (ret < 0) <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> FilterGraph *fg = ist->filters[i]->graph; <S2SV_EndVul> <S2SV_StartVul> for (j = 0; j < fg->nb_outputs; j++) <S2SV_EndVul> <S2SV_StartVul> finish_output_stream(fg->outputs[j]->ost); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } return 0; }","- int i, j, ret;
- if (ist->filters[i]->filter) {
- ret = av_buffersrc_add_frame(ist->filters[i]->filter, NULL);
- if (ret < 0)
- return ret;
- } else {
- FilterGraph *fg = ist->filters[i]->graph;
- for (j = 0; j < fg->nb_outputs; j++)
- finish_output_stream(fg->outputs[j]->ost);
- }
+ int i, ret;
+ ret = ifilter_send_eof(ist->filters[i]);
+ if (ret < 0)
+ return ret;","static int send_filter_eof(InputStream *ist) { int i, ret; for (i = 0; i < ist->nb_filters; i++) { ret = ifilter_send_eof(ist->filters[i]); if (ret < 0) return ret; } return 0; }"
4994----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0344226d61c1d2ab7d39d488ef2e930f06489821_1.json----aac_encode_frame,"static int aac_encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data) { AACEncContext *s = avctx->priv_data; int16_t *samples = s->samples, *samples2, *la; ChannelElement *cpe; <S2SV_StartVul> int i, ch, w, chans, tag, start_ch; <S2SV_EndVul> const uint8_t *chan_map = aac_chan_configs[avctx->channels-1]; int chan_el_counter[4]; FFPsyWindowInfo windows[AAC_MAX_CHANNELS]; if (s->last_frame) return 0; if (data) { if (!s->psypp) { memcpy(s->samples + 1024 * avctx->channels, data, 1024 * avctx->channels * sizeof(s->samples[0])); } else { start_ch = 0; samples2 = s->samples + 1024 * avctx->channels; for (i = 0; i < chan_map[0]; i++) { tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch, samples2 + start_ch, start_ch, chans); start_ch += chans; } } } if (!avctx->frame_number) { memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return 0; } start_ch = 0; for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; for (ch = 0; ch < chans; ch++) { IndividualChannelStream *ics = &cpe->ch[ch].ics; int cur_channel = start_ch + ch; samples2 = samples + cur_channel; la = samples2 + (448+64) * avctx->channels; if (!data) la = NULL; if (tag == TYPE_LFE) { wi[ch].window_type[0] = ONLY_LONG_SEQUENCE; wi[ch].window_shape = 0; wi[ch].num_windows = 1; wi[ch].grouping[0] = 1; } else { wi[ch] = s->psy.model->window(&s->psy, samples2, la, cur_channel, ics->window_sequence[0]); } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = wi[ch].window_type[0]; ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = wi[ch].window_shape; ics->num_windows = wi[ch].num_windows; ics->swb_sizes = s->psy.bands [ics->num_windows == 8]; ics->num_swb = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8]; for (w = 0; w < ics->num_windows; w++) ics->group_len[w] = wi[ch].grouping[w]; apply_window_and_mdct(avctx, s, &cpe->ch[ch], samples2); } start_ch += chans; } do { int frame_bits; init_put_bits(&s->pb, frame, buf_size*8); if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT)) put_bitstream_info(avctx, s, LIBAVCODEC_IDENT); start_ch = 0; memset(chan_el_counter, 0, sizeof(chan_el_counter)); for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; put_bits(&s->pb, 3, tag); put_bits(&s->pb, 4, chan_el_counter[tag]++); for (ch = 0; ch < chans; ch++) { s->cur_channel = start_ch + ch; s->psy.model->analyze(&s->psy, s->cur_channel, cpe->ch[ch].coeffs, &wi[ch]); s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda); } cpe->common_window = 0; if (chans > 1 && wi[0].window_type[0] == wi[1].window_type[0] && wi[0].window_shape == wi[1].window_shape) { cpe->common_window = 1; for (w = 0; w < wi[0].num_windows; w++) { if (wi[0].grouping[w] != wi[1].grouping[w]) { cpe->common_window = 0; break; } } } s->cur_channel = start_ch; <S2SV_StartVul> if (cpe->common_window && s->coder->search_for_ms) <S2SV_EndVul> <S2SV_StartVul> s->coder->search_for_ms(s, cpe, s->lambda); <S2SV_EndVul> adjust_frame_information(s, cpe, chans); if (chans == 2) { put_bits(&s->pb, 1, cpe->common_window); if (cpe->common_window) { put_ics_info(s, &cpe->ch[0].ics); encode_ms_info(&s->pb, cpe); } } for (ch = 0; ch < chans; ch++) { s->cur_channel = start_ch + ch; encode_individual_channel(avctx, s, &cpe->ch[ch], cpe->common_window); } start_ch += chans; } frame_bits = put_bits_count(&s->pb); if (frame_bits <= 6144 * avctx->channels - 3) { s->psy.bitres.bits = frame_bits / avctx->channels; break; } s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits; } while (1); put_bits(&s->pb, 3, TYPE_END); flush_put_bits(&s->pb); avctx->frame_bits = put_bits_count(&s->pb); if (!(avctx->flags & CODEC_FLAG_QSCALE)) { float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits; s->lambda *= ratio; s->lambda = FFMIN(s->lambda, 65536.f); } if (!data) s->last_frame = 1; memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return put_bits_count(&s->pb)>>3; }","- int i, ch, w, chans, tag, start_ch;
- if (cpe->common_window && s->coder->search_for_ms)
- s->coder->search_for_ms(s, cpe, s->lambda);
+ int i, ch, w, g, chans, tag, start_ch;
+ if (s->options.stereo_mode && cpe->common_window) {
+ if (s->options.stereo_mode > 0) {
+ IndividualChannelStream *ics = &cpe->ch[0].ics;
+ for (w = 0; w < ics->num_windows; w += ics->group_len[w])
+ for (g = 0; g < ics->num_swb; g++)
+ cpe->ms_mask[w*16+g] = 1;
+ } else if (s->coder->search_for_ms) {
+ s->coder->search_for_ms(s, cpe, s->lambda);
+ }
+ }","static int aac_encode_frame(AVCodecContext *avctx, uint8_t *frame, int buf_size, void *data) { AACEncContext *s = avctx->priv_data; int16_t *samples = s->samples, *samples2, *la; ChannelElement *cpe; int i, ch, w, g, chans, tag, start_ch; const uint8_t *chan_map = aac_chan_configs[avctx->channels-1]; int chan_el_counter[4]; FFPsyWindowInfo windows[AAC_MAX_CHANNELS]; if (s->last_frame) return 0; if (data) { if (!s->psypp) { memcpy(s->samples + 1024 * avctx->channels, data, 1024 * avctx->channels * sizeof(s->samples[0])); } else { start_ch = 0; samples2 = s->samples + 1024 * avctx->channels; for (i = 0; i < chan_map[0]; i++) { tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch, samples2 + start_ch, start_ch, chans); start_ch += chans; } } } if (!avctx->frame_number) { memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return 0; } start_ch = 0; for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; for (ch = 0; ch < chans; ch++) { IndividualChannelStream *ics = &cpe->ch[ch].ics; int cur_channel = start_ch + ch; samples2 = samples + cur_channel; la = samples2 + (448+64) * avctx->channels; if (!data) la = NULL; if (tag == TYPE_LFE) { wi[ch].window_type[0] = ONLY_LONG_SEQUENCE; wi[ch].window_shape = 0; wi[ch].num_windows = 1; wi[ch].grouping[0] = 1; } else { wi[ch] = s->psy.model->window(&s->psy, samples2, la, cur_channel, ics->window_sequence[0]); } ics->window_sequence[1] = ics->window_sequence[0]; ics->window_sequence[0] = wi[ch].window_type[0]; ics->use_kb_window[1] = ics->use_kb_window[0]; ics->use_kb_window[0] = wi[ch].window_shape; ics->num_windows = wi[ch].num_windows; ics->swb_sizes = s->psy.bands [ics->num_windows == 8]; ics->num_swb = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8]; for (w = 0; w < ics->num_windows; w++) ics->group_len[w] = wi[ch].grouping[w]; apply_window_and_mdct(avctx, s, &cpe->ch[ch], samples2); } start_ch += chans; } do { int frame_bits; init_put_bits(&s->pb, frame, buf_size*8); if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT)) put_bitstream_info(avctx, s, LIBAVCODEC_IDENT); start_ch = 0; memset(chan_el_counter, 0, sizeof(chan_el_counter)); for (i = 0; i < chan_map[0]; i++) { FFPsyWindowInfo* wi = windows + start_ch; tag = chan_map[i+1]; chans = tag == TYPE_CPE ? 2 : 1; cpe = &s->cpe[i]; put_bits(&s->pb, 3, tag); put_bits(&s->pb, 4, chan_el_counter[tag]++); for (ch = 0; ch < chans; ch++) { s->cur_channel = start_ch + ch; s->psy.model->analyze(&s->psy, s->cur_channel, cpe->ch[ch].coeffs, &wi[ch]); s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda); } cpe->common_window = 0; if (chans > 1 && wi[0].window_type[0] == wi[1].window_type[0] && wi[0].window_shape == wi[1].window_shape) { cpe->common_window = 1; for (w = 0; w < wi[0].num_windows; w++) { if (wi[0].grouping[w] != wi[1].grouping[w]) { cpe->common_window = 0; break; } } } s->cur_channel = start_ch; if (s->options.stereo_mode && cpe->common_window) { if (s->options.stereo_mode > 0) { IndividualChannelStream *ics = &cpe->ch[0].ics; for (w = 0; w < ics->num_windows; w += ics->group_len[w]) for (g = 0; g < ics->num_swb; g++) cpe->ms_mask[w*16+g] = 1; } else if (s->coder->search_for_ms) { s->coder->search_for_ms(s, cpe, s->lambda); } } adjust_frame_information(s, cpe, chans); if (chans == 2) { put_bits(&s->pb, 1, cpe->common_window); if (cpe->common_window) { put_ics_info(s, &cpe->ch[0].ics); encode_ms_info(&s->pb, cpe); } } for (ch = 0; ch < chans; ch++) { s->cur_channel = start_ch + ch; encode_individual_channel(avctx, s, &cpe->ch[ch], cpe->common_window); } start_ch += chans; } frame_bits = put_bits_count(&s->pb); if (frame_bits <= 6144 * avctx->channels - 3) { s->psy.bitres.bits = frame_bits / avctx->channels; break; } s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits; } while (1); put_bits(&s->pb, 3, TYPE_END); flush_put_bits(&s->pb); avctx->frame_bits = put_bits_count(&s->pb); if (!(avctx->flags & CODEC_FLAG_QSCALE)) { float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits; s->lambda *= ratio; s->lambda = FFMIN(s->lambda, 65536.f); } if (!data) s->last_frame = 1; memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return put_bits_count(&s->pb)>>3; }"
3499----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bd36d3673dbf920e8b3ddd1a1bf01242e23235d1_1.json----decode_coeffs_b_generic,"static av_always_inline int decode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs, int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3], unsigned (*eob)[6][2], uint8_t (*p)[6][11], int nnz, const int16_t *scan, const int16_t (*nb)[2], const int16_t *band_counts, const int16_t *qmul) { int i = 0, band = 0, band_left = band_counts[band]; uint8_t *tp = p[0][nnz]; uint8_t cache[1024]; do { int val, rc; val = vp56_rac_get_prob_branchy(c, tp[0]); eob[band][nnz][val]++; if (!val) break; skip_eob: if (!vp56_rac_get_prob_branchy(c, tp[1])) { cnt[band][nnz][0]++; if (!--band_left) band_left = band_counts[++band]; cache[scan[i]] = 0; nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1; tp = p[band][nnz]; if (++i == n_coeffs) break; goto skip_eob; } rc = scan[i]; if (!vp56_rac_get_prob_branchy(c, tp[2])) { cnt[band][nnz][1]++; val = 1; cache[rc] = 1; } else { if (!tp[3]) memcpy(&tp[3], ff_vp9_model_pareto8[tp[2]], 8); cnt[band][nnz][2]++; if (!vp56_rac_get_prob_branchy(c, tp[3])) { if (!vp56_rac_get_prob_branchy(c, tp[4])) { cache[rc] = val = 2; } else { val = 3 + vp56_rac_get_prob(c, tp[5]); cache[rc] = 3; } } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { cache[rc] = 4; if (!vp56_rac_get_prob_branchy(c, tp[7])) { val = vp56_rac_get_prob(c, 159) + 5; } else { val = (vp56_rac_get_prob(c, 165) << 1) + 7; val += vp56_rac_get_prob(c, 145); } } else { cache[rc] = 5; if (!vp56_rac_get_prob_branchy(c, tp[8])) { if (!vp56_rac_get_prob_branchy(c, tp[9])) { val = 11 + (vp56_rac_get_prob(c, 173) << 2); val += (vp56_rac_get_prob(c, 148) << 1); val += vp56_rac_get_prob(c, 140); } else { val = 19 + (vp56_rac_get_prob(c, 176) << 3); val += (vp56_rac_get_prob(c, 155) << 2); val += (vp56_rac_get_prob(c, 140) << 1); val += vp56_rac_get_prob(c, 135); } } else if (!vp56_rac_get_prob_branchy(c, tp[10])) { val = (vp56_rac_get_prob(c, 180) << 4) + 35; val += (vp56_rac_get_prob(c, 157) << 3); val += (vp56_rac_get_prob(c, 141) << 2); val += (vp56_rac_get_prob(c, 134) << 1); val += vp56_rac_get_prob(c, 130); } else { val = 67; if (!is8bitsperpixel) { if (bpp == 12) { val += vp56_rac_get_prob(c, 255) << 17; val += vp56_rac_get_prob(c, 255) << 16; } val += (vp56_rac_get_prob(c, 255) << 15); val += (vp56_rac_get_prob(c, 255) << 14); } val += (vp56_rac_get_prob(c, 254) << 13); val += (vp56_rac_get_prob(c, 254) << 12); val += (vp56_rac_get_prob(c, 254) << 11); val += (vp56_rac_get_prob(c, 252) << 10); val += (vp56_rac_get_prob(c, 249) << 9); val += (vp56_rac_get_prob(c, 243) << 8); val += (vp56_rac_get_prob(c, 230) << 7); val += (vp56_rac_get_prob(c, 196) << 6); val += (vp56_rac_get_prob(c, 177) << 5); val += (vp56_rac_get_prob(c, 153) << 4); val += (vp56_rac_get_prob(c, 140) << 3); val += (vp56_rac_get_prob(c, 133) << 2); val += (vp56_rac_get_prob(c, 130) << 1); val += vp56_rac_get_prob(c, 129); } } } #define STORE_COEF(c,i,v) do { \ if (is8bitsperpixel) { \ c[i] = v; \ } else { \ AV_WN32A(&c[i * 2], v); \ } \ } while (0) if (!--band_left) band_left = band_counts[++band]; if (is_tx32x32) <S2SV_StartVul> STORE_COEF(coef, rc, ((vp8_rac_get(c) ? -val : val) * qmul[!!i]) / 2); <S2SV_EndVul> else <S2SV_StartVul> STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * qmul[!!i]); <S2SV_EndVul> nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1; tp = p[band][nnz]; } while (++i < n_coeffs); return i; }","- STORE_COEF(coef, rc, ((vp8_rac_get(c) ? -val : val) * qmul[!!i]) / 2);
- STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * qmul[!!i]);
+ STORE_COEF(coef, rc, (int)((vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2);
+ STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]);","static av_always_inline int decode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs, int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3], unsigned (*eob)[6][2], uint8_t (*p)[6][11], int nnz, const int16_t *scan, const int16_t (*nb)[2], const int16_t *band_counts, const int16_t *qmul) { int i = 0, band = 0, band_left = band_counts[band]; uint8_t *tp = p[0][nnz]; uint8_t cache[1024]; do { int val, rc; val = vp56_rac_get_prob_branchy(c, tp[0]); eob[band][nnz][val]++; if (!val) break; skip_eob: if (!vp56_rac_get_prob_branchy(c, tp[1])) { cnt[band][nnz][0]++; if (!--band_left) band_left = band_counts[++band]; cache[scan[i]] = 0; nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1; tp = p[band][nnz]; if (++i == n_coeffs) break; goto skip_eob; } rc = scan[i]; if (!vp56_rac_get_prob_branchy(c, tp[2])) { cnt[band][nnz][1]++; val = 1; cache[rc] = 1; } else { if (!tp[3]) memcpy(&tp[3], ff_vp9_model_pareto8[tp[2]], 8); cnt[band][nnz][2]++; if (!vp56_rac_get_prob_branchy(c, tp[3])) { if (!vp56_rac_get_prob_branchy(c, tp[4])) { cache[rc] = val = 2; } else { val = 3 + vp56_rac_get_prob(c, tp[5]); cache[rc] = 3; } } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { cache[rc] = 4; if (!vp56_rac_get_prob_branchy(c, tp[7])) { val = vp56_rac_get_prob(c, 159) + 5; } else { val = (vp56_rac_get_prob(c, 165) << 1) + 7; val += vp56_rac_get_prob(c, 145); } } else { cache[rc] = 5; if (!vp56_rac_get_prob_branchy(c, tp[8])) { if (!vp56_rac_get_prob_branchy(c, tp[9])) { val = 11 + (vp56_rac_get_prob(c, 173) << 2); val += (vp56_rac_get_prob(c, 148) << 1); val += vp56_rac_get_prob(c, 140); } else { val = 19 + (vp56_rac_get_prob(c, 176) << 3); val += (vp56_rac_get_prob(c, 155) << 2); val += (vp56_rac_get_prob(c, 140) << 1); val += vp56_rac_get_prob(c, 135); } } else if (!vp56_rac_get_prob_branchy(c, tp[10])) { val = (vp56_rac_get_prob(c, 180) << 4) + 35; val += (vp56_rac_get_prob(c, 157) << 3); val += (vp56_rac_get_prob(c, 141) << 2); val += (vp56_rac_get_prob(c, 134) << 1); val += vp56_rac_get_prob(c, 130); } else { val = 67; if (!is8bitsperpixel) { if (bpp == 12) { val += vp56_rac_get_prob(c, 255) << 17; val += vp56_rac_get_prob(c, 255) << 16; } val += (vp56_rac_get_prob(c, 255) << 15); val += (vp56_rac_get_prob(c, 255) << 14); } val += (vp56_rac_get_prob(c, 254) << 13); val += (vp56_rac_get_prob(c, 254) << 12); val += (vp56_rac_get_prob(c, 254) << 11); val += (vp56_rac_get_prob(c, 252) << 10); val += (vp56_rac_get_prob(c, 249) << 9); val += (vp56_rac_get_prob(c, 243) << 8); val += (vp56_rac_get_prob(c, 230) << 7); val += (vp56_rac_get_prob(c, 196) << 6); val += (vp56_rac_get_prob(c, 177) << 5); val += (vp56_rac_get_prob(c, 153) << 4); val += (vp56_rac_get_prob(c, 140) << 3); val += (vp56_rac_get_prob(c, 133) << 2); val += (vp56_rac_get_prob(c, 130) << 1); val += vp56_rac_get_prob(c, 129); } } } #define STORE_COEF(c,i,v) do { \ if (is8bitsperpixel) { \ c[i] = v; \ } else { \ AV_WN32A(&c[i * 2], v); \ } \ } while (0) if (!--band_left) band_left = band_counts[++band]; if (is_tx32x32) STORE_COEF(coef, rc, (int)((vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2); else STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]); nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1; tp = p[band][nnz]; } while (++i < n_coeffs); return i; }"
1781----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_62c8ccbff449aa2b3819ada7ee421012b2e54f9b_1.json----gsm_mult,"static inline int gsm_mult(int a, int b) { <S2SV_StartVul> return (a * b + (1 << 14)) >> 15; <S2SV_EndVul> }","- return (a * b + (1 << 14)) >> 15;
+ return (int)(a * (SUINT)b + (1 << 14)) >> 15;","static inline int gsm_mult(int a, int b) { return (int)(a * (SUINT)b + (1 << 14)) >> 15; }"
1043----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38d25a19a3dacaf85848a3ef5e98cc62c1526d15_1.json----avpriv_adx_decode_header,"int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf, int bufsize, int *header_size, int *coeff) { int offset, cutoff; if (bufsize < 24) return AVERROR_INVALIDDATA; if (AV_RB16(buf) != 0x8000) return AVERROR_INVALIDDATA; offset = AV_RB16(buf + 2) + 4; if (bufsize >= offset && memcmp(buf + offset - 6, ""(c)CRI"", 6)) return AVERROR_INVALIDDATA; if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) { av_log_ask_for_sample(avctx, ""unsupported ADX format\n""); return AVERROR_PATCHWELCOME; } avctx->channels = buf[7]; <S2SV_StartVul> if (avctx->channels > 2) <S2SV_EndVul> return AVERROR_INVALIDDATA; avctx->sample_rate = AV_RB32(buf + 8); if (avctx->sample_rate < 1 || avctx->sample_rate > INT_MAX / (avctx->channels * BLOCK_SIZE * 8)) return AVERROR_INVALIDDATA; avctx->bit_rate = avctx->sample_rate * avctx->channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES; if (coeff) { cutoff = AV_RB16(buf + 16); ff_adx_calculate_coeffs(cutoff, avctx->sample_rate, COEFF_BITS, coeff); } *header_size = offset; return 0; }","- if (avctx->channels > 2)
+ if (avctx->channels <= 0 || avctx->channels > 2)","int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf, int bufsize, int *header_size, int *coeff) { int offset, cutoff; if (bufsize < 24) return AVERROR_INVALIDDATA; if (AV_RB16(buf) != 0x8000) return AVERROR_INVALIDDATA; offset = AV_RB16(buf + 2) + 4; if (bufsize >= offset && memcmp(buf + offset - 6, ""(c)CRI"", 6)) return AVERROR_INVALIDDATA; if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) { av_log_ask_for_sample(avctx, ""unsupported ADX format\n""); return AVERROR_PATCHWELCOME; } avctx->channels = buf[7]; if (avctx->channels <= 0 || avctx->channels > 2) return AVERROR_INVALIDDATA; avctx->sample_rate = AV_RB32(buf + 8); if (avctx->sample_rate < 1 || avctx->sample_rate > INT_MAX / (avctx->channels * BLOCK_SIZE * 8)) return AVERROR_INVALIDDATA; avctx->bit_rate = avctx->sample_rate * avctx->channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES; if (coeff) { cutoff = AV_RB16(buf + 16); ff_adx_calculate_coeffs(cutoff, avctx->sample_rate, COEFF_BITS, coeff); } *header_size = offset; return 0; }"
4650----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fa7b664b292143c2e4ddf6d6c606cf7e4d458b8a_1.json----add_shorts_metadata,"static int add_shorts_metadata(int count, const char *name, const char *sep, TiffContext *s) { char *ap; int i; int16_t *sp; if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t)) <S2SV_StartVul> return -1; <S2SV_EndVul> sp = av_malloc(count * sizeof(int16_t)); if (!sp) return AVERROR(ENOMEM); for (i = 0; i < count; i++) sp[i] = tget_short(&s->gb, s->le); ap = shorts2str(sp, count, sep); av_freep(&sp); if (!ap) return AVERROR(ENOMEM); av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL); return 0; }","- return -1;
+ if (count >= INT_MAX / sizeof(int16_t))
+ return AVERROR_INVALIDDATA;
+ return AVERROR_INVALIDDATA;","static int add_shorts_metadata(int count, const char *name, const char *sep, TiffContext *s) { char *ap; int i; int16_t *sp; if (count >= INT_MAX / sizeof(int16_t)) return AVERROR_INVALIDDATA; if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t)) return AVERROR_INVALIDDATA; sp = av_malloc(count * sizeof(int16_t)); if (!sp) return AVERROR(ENOMEM); for (i = 0; i < count; i++) sp[i] = tget_short(&s->gb, s->le); ap = shorts2str(sp, count, sep); av_freep(&sp); if (!ap) return AVERROR(ENOMEM); av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL); return 0; }"
2316----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7ed302c0c8e84065e5348dee4bb67cb534b45b40_1.json----get_ue_code,"static inline int get_ue_code(GetBitContext *gb, int order) { if (order) { <S2SV_StartVul> int ret = get_ue_golomb(gb) << order; <S2SV_EndVul> <S2SV_StartVul> return ret + get_bits(gb, order); <S2SV_EndVul> } <S2SV_StartVul> return get_ue_golomb(gb); <S2SV_EndVul> }","- int ret = get_ue_golomb(gb) << order;
- return ret + get_bits(gb, order);
- return get_ue_golomb(gb);
+ unsigned ret = get_ue_golomb(gb);
+ if (ret >= ((1U<<31)>>order)) {
+ av_log(NULL, AV_LOG_ERROR, ""get_ue_code: value too larger\n"");
+ return AVERROR_INVALIDDATA;
+ }
+ return (ret<<order) + get_bits(gb, order);
+ return ret;","static inline int get_ue_code(GetBitContext *gb, int order) { unsigned ret = get_ue_golomb(gb); if (ret >= ((1U<<31)>>order)) { av_log(NULL, AV_LOG_ERROR, ""get_ue_code: value too larger\n""); return AVERROR_INVALIDDATA; } if (order) { return (ret<<order) + get_bits(gb, order); } return ret; }"
675----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_24e87409b562f998244ee8cc6fb72e24de14fb73_1.json----avi_sync,"static int avi_sync(AVFormatContext *s, int exit_early) { AVIContext *avi = s->priv_data; AVIOContext *pb = s->pb; int n; unsigned int d[8]; unsigned int size; int64_t i, sync; start_sync: memset(d, -1, sizeof(d)); for (i = sync = avio_tell(pb); !avio_feof(pb); i++) { int j; for (j = 0; j < 7; j++) d[j] = d[j + 1]; d[7] = avio_r8(pb); size = d[4] + (d[5] << 8) + (d[6] << 16) + (d[7] << 24); n = get_stream_idx(d + 2); ff_tlog(s, ""%X %X %X %X %X %X %X %X %""PRId64"" %u %d\n"", d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n); if (i*(avi->io_fsize>0) + (uint64_t)size > avi->fsize || d[0] > 127) continue; if ((d[0] == 'i' && d[1] == 'x' && n < s->nb_streams) || (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K') || (d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1') || (d[0] == 'i' && d[1] == 'n' && d[2] == 'd' && d[3] == 'x')) { avio_skip(pb, size); goto start_sync; } if (d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T') { avio_skip(pb, 4); goto start_sync; } n = get_stream_idx(d); if (!((i - avi->last_pkt_pos) & 1) && get_stream_idx(d + 1) < s->nb_streams) continue; if (d[2] == 'i' && d[3] == 'x' && n < s->nb_streams) { avio_skip(pb, size); goto start_sync; } if (avi->dv_demux && n != 0) continue; if (n < s->nb_streams) { AVStream *st; AVIStream *ast; st = s->streams[n]; ast = st->priv_data; if (!ast) { av_log(s, AV_LOG_WARNING, ""Skipping foreign stream %d packet\n"", n); continue; } if (s->nb_streams >= 2) { AVStream *st1 = s->streams[1]; AVIStream *ast1 = st1->priv_data; if ( d[2] == 'w' && d[3] == 'b' && n == 0 && st ->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && st1->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && ast->prefix == 'd'*256+'c' && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count) ) { n = 1; st = st1; ast = ast1; av_log(s, AV_LOG_WARNING, ""Invalid stream + prefix combination, assuming audio.\n""); } } <S2SV_StartVul> if (!avi->dv_demux && <S2SV_EndVul> <S2SV_StartVul> ((st->discard >= AVDISCARD_DEFAULT && size == 0) <S2SV_EndVul> <S2SV_StartVul> || st->discard >= AVDISCARD_ALL)) { <S2SV_EndVul> <S2SV_StartVul> if (!exit_early) { <S2SV_EndVul> <S2SV_StartVul> ast->frame_offset += get_duration(ast, size); <S2SV_EndVul> <S2SV_StartVul> avio_skip(pb, size); <S2SV_EndVul> <S2SV_StartVul> goto start_sync; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (d[2] == 'p' && d[3] == 'c' && size <= 4 * 256 + 4) { int k = avio_r8(pb); int last = (k + avio_r8(pb) - 1) & 0xFF; avio_rl16(pb); for (; k <= last; k++) ast->pal[k] = 0xFFU<<24 | avio_rb32(pb)>>8; ast->has_pal = 1; goto start_sync; } else if (((ast->prefix_count < 5 || sync + 9 > i) && d[2] < 128 && d[3] < 128) || d[2] * 256 + d[3] == ast->prefix ) { if (exit_early) return 0; if (d[2] * 256 + d[3] == ast->prefix) ast->prefix_count++; else { ast->prefix = d[2] * 256 + d[3]; ast->prefix_count = 0; } avi->stream_index = n; ast->packet_size = size + 8; ast->remaining = size; if (size) { uint64_t pos = avio_tell(pb) - 8; if (!st->index_entries || !st->nb_index_entries || st->index_entries[st->nb_index_entries - 1].pos < pos) { av_add_index_entry(st, pos, ast->frame_offset, size, 0, AVINDEX_KEYFRAME); } } return 0; } } } if (pb->error) return pb->error; return AVERROR_EOF; }","- if (!avi->dv_demux &&
- ((st->discard >= AVDISCARD_DEFAULT && size == 0) /* ||
- (st->discard >= AVDISCARD_NONKEY &&
- || st->discard >= AVDISCARD_ALL)) {
- if (!exit_early) {
- ast->frame_offset += get_duration(ast, size);
- avio_skip(pb, size);
- goto start_sync;
- }
- }
+ if (!avi->dv_demux &&
+ ((st->discard >= AVDISCARD_DEFAULT && size == 0) /* ||
+ (st->discard >= AVDISCARD_NONKEY &&
+ || st->discard >= AVDISCARD_ALL)) {
+ ast->frame_offset += get_duration(ast, size);
+ avio_skip(pb, size);
+ goto start_sync;
+ }","static int avi_sync(AVFormatContext *s, int exit_early) { AVIContext *avi = s->priv_data; AVIOContext *pb = s->pb; int n; unsigned int d[8]; unsigned int size; int64_t i, sync; start_sync: memset(d, -1, sizeof(d)); for (i = sync = avio_tell(pb); !avio_feof(pb); i++) { int j; for (j = 0; j < 7; j++) d[j] = d[j + 1]; d[7] = avio_r8(pb); size = d[4] + (d[5] << 8) + (d[6] << 16) + (d[7] << 24); n = get_stream_idx(d + 2); ff_tlog(s, ""%X %X %X %X %X %X %X %X %""PRId64"" %u %d\n"", d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n); if (i*(avi->io_fsize>0) + (uint64_t)size > avi->fsize || d[0] > 127) continue; if ((d[0] == 'i' && d[1] == 'x' && n < s->nb_streams) || (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K') || (d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1') || (d[0] == 'i' && d[1] == 'n' && d[2] == 'd' && d[3] == 'x')) { avio_skip(pb, size); goto start_sync; } if (d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T') { avio_skip(pb, 4); goto start_sync; } n = get_stream_idx(d); if (!((i - avi->last_pkt_pos) & 1) && get_stream_idx(d + 1) < s->nb_streams) continue; if (d[2] == 'i' && d[3] == 'x' && n < s->nb_streams) { avio_skip(pb, size); goto start_sync; } if (avi->dv_demux && n != 0) continue; if (n < s->nb_streams) { AVStream *st; AVIStream *ast; st = s->streams[n]; ast = st->priv_data; if (!ast) { av_log(s, AV_LOG_WARNING, ""Skipping foreign stream %d packet\n"", n); continue; } if (s->nb_streams >= 2) { AVStream *st1 = s->streams[1]; AVIStream *ast1 = st1->priv_data; if ( d[2] == 'w' && d[3] == 'b' && n == 0 && st ->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && st1->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && ast->prefix == 'd'*256+'c' && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count) ) { n = 1; st = st1; ast = ast1; av_log(s, AV_LOG_WARNING, ""Invalid stream + prefix combination, assuming audio.\n""); } } if (d[2] == 'p' && d[3] == 'c' && size <= 4 * 256 + 4) { int k = avio_r8(pb); int last = (k + avio_r8(pb) - 1) & 0xFF; avio_rl16(pb); for (; k <= last; k++) ast->pal[k] = 0xFFU<<24 | avio_rb32(pb)>>8; ast->has_pal = 1; goto start_sync; } else if (((ast->prefix_count < 5 || sync + 9 > i) && d[2] < 128 && d[3] < 128) || d[2] * 256 + d[3] == ast->prefix ) { if (exit_early) return 0; if (d[2] * 256 + d[3] == ast->prefix) ast->prefix_count++; else { ast->prefix = d[2] * 256 + d[3]; ast->prefix_count = 0; } if (!avi->dv_demux && ((st->discard >= AVDISCARD_DEFAULT && size == 0) || st->discard >= AVDISCARD_ALL)) { ast->frame_offset += get_duration(ast, size); avio_skip(pb, size); goto start_sync; } avi->stream_index = n; ast->packet_size = size + 8; ast->remaining = size; if (size) { uint64_t pos = avio_tell(pb) - 8; if (!st->index_entries || !st->nb_index_entries || st->index_entries[st->nb_index_entries - 1].pos < pos) { av_add_index_entry(st, pos, ast->frame_offset, size, 0, AVINDEX_KEYFRAME); } } return 0; } } } if (pb->error) return pb->error; return AVERROR_EOF; }"
15014----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a72d642d3bc2835850d49f91520bff8647a3216c_1.json----UI_create_method,UI_METHOD *UI_create_method(char *name) { UI_METHOD *ui_method = OPENSSL_zalloc(sizeof(*ui_method)); if (ui_method != NULL) <S2SV_StartVul> ui_method->name = BUF_strdup(name); <S2SV_EndVul> return ui_method; },"- ui_method->name = BUF_strdup(name);
+ ui_method->name = OPENSSL_strdup(name);",UI_METHOD *UI_create_method(char *name) { UI_METHOD *ui_method = OPENSSL_zalloc(sizeof(*ui_method)); if (ui_method != NULL) ui_method->name = OPENSSL_strdup(name); return ui_method; }
996----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_364779faba5a2ebb298d614166ad15d4dea4c51d_1.json----add_metadata,"<S2SV_StartVul> static int add_metadata(const uint8_t **buf, int count, int type, <S2SV_EndVul> const char *name, const char *sep, TiffContext *s) { switch(type) { <S2SV_StartVul> case TIFF_DOUBLE: return add_doubles_metadata(buf, count, name, sep, s); <S2SV_EndVul> <S2SV_StartVul> case TIFF_SHORT : return add_shorts_metadata(buf, count, name, sep, s); <S2SV_EndVul> default : return AVERROR_INVALIDDATA; }; }","- static int add_metadata(const uint8_t **buf, int count, int type,
- case TIFF_DOUBLE: return add_doubles_metadata(buf, count, name, sep, s);
- case TIFF_SHORT : return add_shorts_metadata(buf, count, name, sep, s);
+ static int add_metadata(int count, int type,
+ case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s);
+ case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s);","static int add_metadata(int count, int type, const char *name, const char *sep, TiffContext *s) { switch(type) { case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s); case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s); default : return AVERROR_INVALIDDATA; }; }"
10364----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0313d3d7c2cda8e2e0bc2926e37a917979627536_1.json----test_exp_mod_zero,"static int test_exp_mod_zero() { <S2SV_StartVul> BIGNUM a, p, m; <S2SV_EndVul> <S2SV_StartVul> BIGNUM r; <S2SV_EndVul> BN_CTX *ctx = BN_CTX_new(); int ret = 1; <S2SV_StartVul> BN_init(&m); <S2SV_EndVul> <S2SV_StartVul> BN_one(&m); <S2SV_EndVul> <S2SV_StartVul> BN_init(&a); <S2SV_EndVul> <S2SV_StartVul> BN_one(&a); <S2SV_EndVul> <S2SV_StartVul> BN_init(&p); <S2SV_EndVul> <S2SV_StartVul> BN_zero(&p); <S2SV_EndVul> <S2SV_StartVul> BN_init(&r); <S2SV_EndVul> <S2SV_StartVul> BN_mod_exp(&r, &a, &p, &m, ctx); <S2SV_EndVul> BN_CTX_free(ctx); <S2SV_StartVul> if (BN_is_zero(&r)) <S2SV_EndVul> ret = 0; else { printf(""1**0 mod 1 = ""); <S2SV_StartVul> BN_print_fp(stdout, &r); <S2SV_EndVul> printf("", should be 0\n""); } <S2SV_StartVul> BN_free(&r); <S2SV_EndVul> <S2SV_StartVul> BN_free(&a); <S2SV_EndVul> <S2SV_StartVul> BN_free(&p); <S2SV_EndVul> <S2SV_StartVul> BN_free(&m); <S2SV_EndVul> return ret; }","- BIGNUM a, p, m;
- BIGNUM r;
- BN_init(&m);
- BN_one(&m);
- BN_init(&a);
- BN_one(&a);
- BN_init(&p);
- BN_zero(&p);
- BN_init(&r);
- BN_mod_exp(&r, &a, &p, &m, ctx);
- if (BN_is_zero(&r))
- BN_print_fp(stdout, &r);
- BN_free(&r);
- BN_free(&a);
- BN_free(&p);
- BN_free(&m);
+ BIGNUM *a = NULL, *p = NULL, *m = NULL;
+ BIGNUM *r = NULL;
+ m = BN_new();
+ if(!m) goto err;
+ BN_one(m);
+ a = BN_new();
+ if(!a) goto err;
+ BN_one(a);
+ p = BN_new();
+ if(!p) goto err;
+ BN_zero(p);
+ r = BN_new();
+ if(!r) goto err;
+ BN_mod_exp(r, a, p, m, ctx);
+ if (BN_is_zero(r))
+ BN_print_fp(stdout, r);
+ err:
+ BN_free(r);
+ BN_free(a);
+ BN_free(p);
+ BN_free(m);","static int test_exp_mod_zero() { BIGNUM *a = NULL, *p = NULL, *m = NULL; BIGNUM *r = NULL; BN_CTX *ctx = BN_CTX_new(); int ret = 1; m = BN_new(); if(!m) goto err; BN_one(m); a = BN_new(); if(!a) goto err; BN_one(a); p = BN_new(); if(!p) goto err; BN_zero(p); r = BN_new(); if(!r) goto err; BN_mod_exp(r, a, p, m, ctx); BN_CTX_free(ctx); if (BN_is_zero(r)) ret = 0; else { printf(""1**0 mod 1 = ""); BN_print_fp(stdout, r); printf("", should be 0\n""); } err: BN_free(r); BN_free(a); BN_free(p); BN_free(m); return ret; }"
888----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_30c429d9190e93f9c67160818d16aa2e62f7478c_1.json----decode_byterun,"static int decode_byterun(uint8_t *dst, int dst_size, const uint8_t *buf, const uint8_t *const buf_end) { const uint8_t *const buf_start = buf; unsigned x; for (x = 0; x < dst_size && buf < buf_end;) { unsigned length; const int8_t value = *buf++; if (value >= 0) { <S2SV_StartVul> length = value + 1; <S2SV_EndVul> <S2SV_StartVul> memcpy(dst + x, buf, FFMIN3(length, dst_size - x, buf_end - buf)); <S2SV_EndVul> buf += length; } else if (value > -128) { <S2SV_StartVul> length = -value + 1; <S2SV_EndVul> <S2SV_StartVul> memset(dst + x, *buf++, FFMIN(length, dst_size - x)); <S2SV_EndVul> } else { continue; } x += length; } if (x < dst_size) { av_log(NULL, AV_LOG_WARNING, ""decode_byterun ended before plane size\n""); memset(dst+x, 0, dst_size - x); } return buf - buf_start; }","- length = value + 1;
- memcpy(dst + x, buf, FFMIN3(length, dst_size - x, buf_end - buf));
- length = -value + 1;
- memset(dst + x, *buf++, FFMIN(length, dst_size - x));
+ length = FFMIN3(value + 1, dst_size - x, buf_end - buf);
+ memcpy(dst + x, buf, length);
+ length = FFMIN(-value + 1, dst_size - x);
+ memset(dst + x, *buf++, length);","static int decode_byterun(uint8_t *dst, int dst_size, const uint8_t *buf, const uint8_t *const buf_end) { const uint8_t *const buf_start = buf; unsigned x; for (x = 0; x < dst_size && buf < buf_end;) { unsigned length; const int8_t value = *buf++; if (value >= 0) { length = FFMIN3(value + 1, dst_size - x, buf_end - buf); memcpy(dst + x, buf, length); buf += length; } else if (value > -128) { length = FFMIN(-value + 1, dst_size - x); memset(dst + x, *buf++, length); } else { continue; } x += length; } if (x < dst_size) { av_log(NULL, AV_LOG_WARNING, ""decode_byterun ended before plane size\n""); memset(dst+x, 0, dst_size - x); } return buf - buf_start; }"
3090----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a847043f0b7137103225c1857046046d9ab80e6d_1.json----mov_read_chpl,"static int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom) { int64_t start; int i, nb_chapters, str_len, version; char str[256+1]; if ((atom.size -= 5) < 0) return 0; version = avio_r8(pb); avio_rb24(pb); if (version) avio_rb32(pb); nb_chapters = avio_r8(pb); for (i = 0; i < nb_chapters; i++) { if (atom.size < 9) return 0; start = avio_rb64(pb); str_len = avio_r8(pb); if ((atom.size -= 9+str_len) < 0) return 0; <S2SV_StartVul> avio_read(pb, str, str_len); <S2SV_EndVul> str[str_len] = 0; avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str); } return 0; }","- avio_read(pb, str, str_len);
+ int ret;
+ ret = ffio_read_size(pb, str, str_len);
+ if (ret < 0)
+ return ret;","static int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom) { int64_t start; int i, nb_chapters, str_len, version; char str[256+1]; int ret; if ((atom.size -= 5) < 0) return 0; version = avio_r8(pb); avio_rb24(pb); if (version) avio_rb32(pb); nb_chapters = avio_r8(pb); for (i = 0; i < nb_chapters; i++) { if (atom.size < 9) return 0; start = avio_rb64(pb); str_len = avio_r8(pb); if ((atom.size -= 9+str_len) < 0) return 0; ret = ffio_read_size(pb, str, str_len); if (ret < 0) return ret; str[str_len] = 0; avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str); } return 0; }"
1194----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4112a7048e03ff6df31df70d6ebe622d6fc9e1ea_1.json----mov_read_trun,"static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom) { MOVFragment *frag = &c->fragment; AVStream *st = NULL; MOVStreamContext *sc; MOVStts *ctts_data; uint64_t offset; int64_t dts; int data_offset = 0; unsigned entries, first_sample_flags = frag->flags; int flags, distance, i, found_keyframe = 0, err; for (i = 0; i < c->fc->nb_streams; i++) { if (c->fc->streams[i]->id == frag->track_id) { st = c->fc->streams[i]; break; } } if (!st) { av_log(c->fc, AV_LOG_ERROR, ""could not find corresponding track id %d\n"", frag->track_id); return AVERROR_INVALIDDATA; } sc = st->priv_data; if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1) return 0; avio_r8(pb); flags = avio_rb24(pb); entries = avio_rb32(pb); av_dlog(c->fc, ""flags 0x%x entries %d\n"", flags, entries); if (!sc->ctts_count && sc->sample_count) { ctts_data = av_realloc(NULL, sizeof(*sc->ctts_data)); if (!ctts_data) return AVERROR(ENOMEM); sc->ctts_data = ctts_data; sc->ctts_data[sc->ctts_count].count = sc->sample_count; sc->ctts_data[sc->ctts_count].duration = 0; sc->ctts_count++; } if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data)) return AVERROR_INVALIDDATA; if ((err = av_reallocp_array(&sc->ctts_data, entries + sc->ctts_count, sizeof(*sc->ctts_data))) < 0) { sc->ctts_count = 0; return err; } if (flags & MOV_TRUN_DATA_OFFSET) data_offset = avio_rb32(pb); if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb); dts = sc->track_end - sc->time_offset; offset = frag->base_data_offset + data_offset; distance = 0; av_dlog(c->fc, ""first sample flags 0x%x\n"", first_sample_flags); for (i = 0; i < entries && !pb->eof_reached; i++) { unsigned sample_size = frag->size; int sample_flags = i ? frag->flags : first_sample_flags; unsigned sample_duration = frag->duration; int keyframe = 0; int sample_cts = 0; int64_t cts; if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb); if (flags & MOV_TRUN_SAMPLE_SIZE) sample_size = avio_rb32(pb); if (flags & MOV_TRUN_SAMPLE_FLAGS) sample_flags = avio_rb32(pb); if (flags & MOV_TRUN_SAMPLE_CTS) sample_cts = avio_rb32(pb); sc->ctts_data[sc->ctts_count].count = 1; sc->ctts_data[sc->ctts_count].duration = sample_cts; mov_update_dts_shift(sc, sc->ctts_data[sc->ctts_count].duration); if (frag->time != AV_NOPTS_VALUE) { if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) { int64_t pts = frag->time; av_log(c->fc, AV_LOG_DEBUG, ""found frag time %""PRId64 "" sc->dts_shift %d ctts.duration %d"" "" sc->time_offset %""PRId64"" flags & MOV_TRUN_SAMPLE_CTS %d\n"", pts, sc->dts_shift, sc->ctts_data[sc->ctts_count].duration, sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS); dts = pts - sc->dts_shift; if (flags & MOV_TRUN_SAMPLE_CTS) { dts -= sc->ctts_data[sc->ctts_count].duration; } else { dts -= sc->time_offset; } av_log(c->fc, AV_LOG_DEBUG, ""calculated into dts %""PRId64""\n"", dts); } else { dts = frag->time; av_log(c->fc, AV_LOG_DEBUG, ""found frag time %""PRId64 "", using it for dts\n"", dts); } frag->time = AV_NOPTS_VALUE; } cts = dts + sample_cts; sc->ctts_count++; if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) keyframe = 1; else if (!found_keyframe) keyframe = found_keyframe = !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC | MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES)); if (keyframe) distance = 0; <S2SV_StartVul> err = av_add_index_entry(st, offset, INT64_MAX/2, sample_size, distance, <S2SV_EndVul> keyframe ? AVINDEX_KEYFRAME : 0); if (err < 0) { av_log(c->fc, AV_LOG_ERROR, ""Failed to add index entry\n""); <S2SV_StartVul> } else <S2SV_EndVul> <S2SV_StartVul> st->index_entries[st->nb_index_entries - 1].timestamp = cts; <S2SV_EndVul> av_dlog(c->fc, ""AVIndex stream %d, sample %d, offset %""PRIx64"", cts %""PRId64"", "" ""size %d, distance %d, keyframe %d\n"", st->index, sc->sample_count+i, offset, cts, sample_size, distance, keyframe); distance++; dts += sample_duration; offset += sample_size; sc->data_size += sample_size; sc->duration_for_fps += sample_duration; sc->nb_frames_for_fps ++; } if (pb->eof_reached) return AVERROR_EOF; frag->implicit_offset = offset; st->duration = sc->track_end = dts + sc->time_offset; return 0; }","- err = av_add_index_entry(st, offset, INT64_MAX/2, sample_size, distance,
- } else
- st->index_entries[st->nb_index_entries - 1].timestamp = cts;
+ err = av_add_index_entry(st, offset, cts, sample_size, distance,
+ }","static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom) { MOVFragment *frag = &c->fragment; AVStream *st = NULL; MOVStreamContext *sc; MOVStts *ctts_data; uint64_t offset; int64_t dts; int data_offset = 0; unsigned entries, first_sample_flags = frag->flags; int flags, distance, i, found_keyframe = 0, err; for (i = 0; i < c->fc->nb_streams; i++) { if (c->fc->streams[i]->id == frag->track_id) { st = c->fc->streams[i]; break; } } if (!st) { av_log(c->fc, AV_LOG_ERROR, ""could not find corresponding track id %d\n"", frag->track_id); return AVERROR_INVALIDDATA; } sc = st->priv_data; if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1) return 0; avio_r8(pb); flags = avio_rb24(pb); entries = avio_rb32(pb); av_dlog(c->fc, ""flags 0x%x entries %d\n"", flags, entries); if (!sc->ctts_count && sc->sample_count) { ctts_data = av_realloc(NULL, sizeof(*sc->ctts_data)); if (!ctts_data) return AVERROR(ENOMEM); sc->ctts_data = ctts_data; sc->ctts_data[sc->ctts_count].count = sc->sample_count; sc->ctts_data[sc->ctts_count].duration = 0; sc->ctts_count++; } if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data)) return AVERROR_INVALIDDATA; if ((err = av_reallocp_array(&sc->ctts_data, entries + sc->ctts_count, sizeof(*sc->ctts_data))) < 0) { sc->ctts_count = 0; return err; } if (flags & MOV_TRUN_DATA_OFFSET) data_offset = avio_rb32(pb); if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb); dts = sc->track_end - sc->time_offset; offset = frag->base_data_offset + data_offset; distance = 0; av_dlog(c->fc, ""first sample flags 0x%x\n"", first_sample_flags); for (i = 0; i < entries && !pb->eof_reached; i++) { unsigned sample_size = frag->size; int sample_flags = i ? frag->flags : first_sample_flags; unsigned sample_duration = frag->duration; int keyframe = 0; int sample_cts = 0; int64_t cts; if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb); if (flags & MOV_TRUN_SAMPLE_SIZE) sample_size = avio_rb32(pb); if (flags & MOV_TRUN_SAMPLE_FLAGS) sample_flags = avio_rb32(pb); if (flags & MOV_TRUN_SAMPLE_CTS) sample_cts = avio_rb32(pb); sc->ctts_data[sc->ctts_count].count = 1; sc->ctts_data[sc->ctts_count].duration = sample_cts; mov_update_dts_shift(sc, sc->ctts_data[sc->ctts_count].duration); if (frag->time != AV_NOPTS_VALUE) { if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) { int64_t pts = frag->time; av_log(c->fc, AV_LOG_DEBUG, ""found frag time %""PRId64 "" sc->dts_shift %d ctts.duration %d"" "" sc->time_offset %""PRId64"" flags & MOV_TRUN_SAMPLE_CTS %d\n"", pts, sc->dts_shift, sc->ctts_data[sc->ctts_count].duration, sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS); dts = pts - sc->dts_shift; if (flags & MOV_TRUN_SAMPLE_CTS) { dts -= sc->ctts_data[sc->ctts_count].duration; } else { dts -= sc->time_offset; } av_log(c->fc, AV_LOG_DEBUG, ""calculated into dts %""PRId64""\n"", dts); } else { dts = frag->time; av_log(c->fc, AV_LOG_DEBUG, ""found frag time %""PRId64 "", using it for dts\n"", dts); } frag->time = AV_NOPTS_VALUE; } cts = dts + sample_cts; sc->ctts_count++; if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) keyframe = 1; else if (!found_keyframe) keyframe = found_keyframe = !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC | MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES)); if (keyframe) distance = 0; err = av_add_index_entry(st, offset, cts, sample_size, distance, keyframe ? AVINDEX_KEYFRAME : 0); if (err < 0) { av_log(c->fc, AV_LOG_ERROR, ""Failed to add index entry\n""); } av_dlog(c->fc, ""AVIndex stream %d, sample %d, offset %""PRIx64"", cts %""PRId64"", "" ""size %d, distance %d, keyframe %d\n"", st->index, sc->sample_count+i, offset, cts, sample_size, distance, keyframe); distance++; dts += sample_duration; offset += sample_size; sc->data_size += sample_size; sc->duration_for_fps += sample_duration; sc->nb_frames_for_fps ++; } if (pb->eof_reached) return AVERROR_EOF; frag->implicit_offset = offset; st->duration = sc->track_end = dts + sc->time_offset; return 0; }"
1483----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_524e958707ee245a4e9167a2ed68ff8f43d5fe1d_1.json----amf_parse_object,"static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, int64_t max_pos, int depth) { AVCodecContext *acodec, *vcodec; FLVContext *flv = s->priv_data; AVIOContext *ioc; AMFDataType amf_type; char str_val[256]; double num_val; num_val = 0; ioc = s->pb; amf_type = avio_r8(ioc); switch (amf_type) { case AMF_DATA_TYPE_NUMBER: num_val = av_int2double(avio_rb64(ioc)); break; case AMF_DATA_TYPE_BOOL: num_val = avio_r8(ioc); break; case AMF_DATA_TYPE_STRING: if (amf_get_string(ioc, str_val, sizeof(str_val)) < 0) return -1; break; case AMF_DATA_TYPE_OBJECT: if ((vstream || astream) && key && ioc->seekable && !strcmp(KEYFRAMES_TAG, key) && depth == 1) if (parse_keyframes_index(s, ioc, vstream ? vstream : astream, max_pos) < 0) av_log(s, AV_LOG_ERROR, ""Keyframe index parsing failed\n""); while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) if (amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0) return -1; if (avio_r8(ioc) != AMF_END_OF_OBJECT) return -1; break; case AMF_DATA_TYPE_NULL: case AMF_DATA_TYPE_UNDEFINED: case AMF_DATA_TYPE_UNSUPPORTED: break; case AMF_DATA_TYPE_MIXEDARRAY: avio_skip(ioc, 4); while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) if (amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0) return -1; if (avio_r8(ioc) != AMF_END_OF_OBJECT) return -1; break; case AMF_DATA_TYPE_ARRAY: { unsigned int arraylen, i; arraylen = avio_rb32(ioc); for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++) if (amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0) return -1; } break; case AMF_DATA_TYPE_DATE: avio_skip(ioc, 8 + 2); break; default: return -1; } if (key) { if (depth == 1) { <S2SV_StartVul> acodec = astream ? astream->codec : NULL; <S2SV_EndVul> <S2SV_StartVul> vcodec = vstream ? vstream->codec : NULL; <S2SV_EndVul> if (amf_type == AMF_DATA_TYPE_NUMBER || amf_type == AMF_DATA_TYPE_BOOL) { if (!strcmp(key, ""duration"")) s->duration = num_val * AV_TIME_BASE; else if (!strcmp(key, ""videodatarate"") && vcodec && 0 <= (int)(num_val * 1024.0)) vcodec->bit_rate = num_val * 1024.0; else if (!strcmp(key, ""audiodatarate"") && acodec && 0 <= (int)(num_val * 1024.0)) acodec->bit_rate = num_val * 1024.0; else if (!strcmp(key, ""datastream"")) { AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA); if (!st) return AVERROR(ENOMEM); st->codec->codec_id = AV_CODEC_ID_TEXT; } else if (flv->trust_metadata) { if (!strcmp(key, ""videocodecid"") && vcodec) { flv_set_video_codec(s, vstream, num_val, 0); } else if (!strcmp(key, ""audiocodecid"") && acodec) { int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET; flv_set_audio_codec(s, astream, acodec, id); } else if (!strcmp(key, ""audiosamplerate"") && acodec) { acodec->sample_rate = num_val; } else if (!strcmp(key, ""audiosamplesize"") && acodec) { acodec->bits_per_coded_sample = num_val; } else if (!strcmp(key, ""stereo"") && acodec) { acodec->channels = num_val + 1; acodec->channel_layout = acodec->channels == 2 ? AV_CH_LAYOUT_STEREO : AV_CH_LAYOUT_MONO; } else if (!strcmp(key, ""width"") && vcodec) { vcodec->width = num_val; } else if (!strcmp(key, ""height"") && vcodec) { vcodec->height = num_val; } } } } if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 && ((!acodec && !strcmp(key, ""audiocodecid"")) || (!vcodec && !strcmp(key, ""videocodecid"")))) s->ctx_flags &= ~AVFMTCTX_NOHEADER; if (!strcmp(key, ""duration"") || !strcmp(key, ""filesize"") || !strcmp(key, ""width"") || !strcmp(key, ""height"") || !strcmp(key, ""videodatarate"") || !strcmp(key, ""framerate"") || !strcmp(key, ""videocodecid"") || !strcmp(key, ""audiodatarate"") || !strcmp(key, ""audiosamplerate"") || !strcmp(key, ""audiosamplesize"") || !strcmp(key, ""stereo"") || !strcmp(key, ""audiocodecid"") || !strcmp(key, ""datastream"")) return 0; s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED; if (amf_type == AMF_DATA_TYPE_BOOL) { av_strlcpy(str_val, num_val > 0 ? ""true"" : ""false"", sizeof(str_val)); av_dict_set(&s->metadata, key, str_val, 0); } else if (amf_type == AMF_DATA_TYPE_NUMBER) { snprintf(str_val, sizeof(str_val), ""%.f"", num_val); av_dict_set(&s->metadata, key, str_val, 0); } else if (amf_type == AMF_DATA_TYPE_STRING) av_dict_set(&s->metadata, key, str_val, 0); } return 0; }","- acodec = astream ? astream->codec : NULL;
- vcodec = vstream ? vstream->codec : NULL;
+ acodec = astream ? astream->codec : NULL;
+ vcodec = vstream ? vstream->codec : NULL;","static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, int64_t max_pos, int depth) { AVCodecContext *acodec, *vcodec; FLVContext *flv = s->priv_data; AVIOContext *ioc; AMFDataType amf_type; char str_val[256]; double num_val; num_val = 0; ioc = s->pb; amf_type = avio_r8(ioc); switch (amf_type) { case AMF_DATA_TYPE_NUMBER: num_val = av_int2double(avio_rb64(ioc)); break; case AMF_DATA_TYPE_BOOL: num_val = avio_r8(ioc); break; case AMF_DATA_TYPE_STRING: if (amf_get_string(ioc, str_val, sizeof(str_val)) < 0) return -1; break; case AMF_DATA_TYPE_OBJECT: if ((vstream || astream) && key && ioc->seekable && !strcmp(KEYFRAMES_TAG, key) && depth == 1) if (parse_keyframes_index(s, ioc, vstream ? vstream : astream, max_pos) < 0) av_log(s, AV_LOG_ERROR, ""Keyframe index parsing failed\n""); while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) if (amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0) return -1; if (avio_r8(ioc) != AMF_END_OF_OBJECT) return -1; break; case AMF_DATA_TYPE_NULL: case AMF_DATA_TYPE_UNDEFINED: case AMF_DATA_TYPE_UNSUPPORTED: break; case AMF_DATA_TYPE_MIXEDARRAY: avio_skip(ioc, 4); while (avio_tell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) if (amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0) return -1; if (avio_r8(ioc) != AMF_END_OF_OBJECT) return -1; break; case AMF_DATA_TYPE_ARRAY: { unsigned int arraylen, i; arraylen = avio_rb32(ioc); for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++) if (amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0) return -1; } break; case AMF_DATA_TYPE_DATE: avio_skip(ioc, 8 + 2); break; default: return -1; } if (key) { acodec = astream ? astream->codec : NULL; vcodec = vstream ? vstream->codec : NULL; if (depth == 1) { if (amf_type == AMF_DATA_TYPE_NUMBER || amf_type == AMF_DATA_TYPE_BOOL) { if (!strcmp(key, ""duration"")) s->duration = num_val * AV_TIME_BASE; else if (!strcmp(key, ""videodatarate"") && vcodec && 0 <= (int)(num_val * 1024.0)) vcodec->bit_rate = num_val * 1024.0; else if (!strcmp(key, ""audiodatarate"") && acodec && 0 <= (int)(num_val * 1024.0)) acodec->bit_rate = num_val * 1024.0; else if (!strcmp(key, ""datastream"")) { AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA); if (!st) return AVERROR(ENOMEM); st->codec->codec_id = AV_CODEC_ID_TEXT; } else if (flv->trust_metadata) { if (!strcmp(key, ""videocodecid"") && vcodec) { flv_set_video_codec(s, vstream, num_val, 0); } else if (!strcmp(key, ""audiocodecid"") && acodec) { int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET; flv_set_audio_codec(s, astream, acodec, id); } else if (!strcmp(key, ""audiosamplerate"") && acodec) { acodec->sample_rate = num_val; } else if (!strcmp(key, ""audiosamplesize"") && acodec) { acodec->bits_per_coded_sample = num_val; } else if (!strcmp(key, ""stereo"") && acodec) { acodec->channels = num_val + 1; acodec->channel_layout = acodec->channels == 2 ? AV_CH_LAYOUT_STEREO : AV_CH_LAYOUT_MONO; } else if (!strcmp(key, ""width"") && vcodec) { vcodec->width = num_val; } else if (!strcmp(key, ""height"") && vcodec) { vcodec->height = num_val; } } } } if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 && ((!acodec && !strcmp(key, ""audiocodecid"")) || (!vcodec && !strcmp(key, ""videocodecid"")))) s->ctx_flags &= ~AVFMTCTX_NOHEADER; if (!strcmp(key, ""duration"") || !strcmp(key, ""filesize"") || !strcmp(key, ""width"") || !strcmp(key, ""height"") || !strcmp(key, ""videodatarate"") || !strcmp(key, ""framerate"") || !strcmp(key, ""videocodecid"") || !strcmp(key, ""audiodatarate"") || !strcmp(key, ""audiosamplerate"") || !strcmp(key, ""audiosamplesize"") || !strcmp(key, ""stereo"") || !strcmp(key, ""audiocodecid"") || !strcmp(key, ""datastream"")) return 0; s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED; if (amf_type == AMF_DATA_TYPE_BOOL) { av_strlcpy(str_val, num_val > 0 ? ""true"" : ""false"", sizeof(str_val)); av_dict_set(&s->metadata, key, str_val, 0); } else if (amf_type == AMF_DATA_TYPE_NUMBER) { snprintf(str_val, sizeof(str_val), ""%.f"", num_val); av_dict_set(&s->metadata, key, str_val, 0); } else if (amf_type == AMF_DATA_TYPE_STRING) av_dict_set(&s->metadata, key, str_val, 0); } return 0; }"
6851----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_70b1b67bcf3a04d32d74a9b962868df949c7058a_1.json----decode_i2_frame,"<S2SV_StartVul> static int decode_i2_frame(FourXContext *f, AVFrame *frame, const uint8_t *buf, int length) <S2SV_EndVul> { int x, y, x2, y2; const int width = f->avctx->width; const int height = f->avctx->height; const int mbs = (FFALIGN(width, 16) >> 4) * (FFALIGN(height, 16) >> 4); <S2SV_StartVul> uint16_t *dst = (uint16_t*)frame->data[0]; <S2SV_EndVul> <S2SV_StartVul> const int stride = frame->linesize[0]>>1; <S2SV_EndVul> GetByteContext g3; if (length < mbs * 8) { av_log(f->avctx, AV_LOG_ERROR, ""packet size too small\n""); return AVERROR_INVALIDDATA; } bytestream2_init(&g3, buf, length); for (y = 0; y < height; y += 16) { for (x = 0; x < width; x += 16) { unsigned int color[4] = { 0 }, bits; color[0] = bytestream2_get_le16u(&g3); color[1] = bytestream2_get_le16u(&g3); if (color[0] & 0x8000) av_log(f->avctx, AV_LOG_ERROR, ""unk bit 1\n""); if (color[1] & 0x8000) av_log(f->avctx, AV_LOG_ERROR, ""unk bit 2\n""); color[2] = mix(color[0], color[1]); color[3] = mix(color[1], color[0]); bits = bytestream2_get_le32u(&g3); for (y2 = 0; y2 < 16; y2++) { for (x2 = 0; x2 < 16; x2++) { int index = 2 * (x2 >> 2) + 8 * (y2 >> 2); <S2SV_StartVul> dst[y2 * stride + x2] = color[(bits >> index) & 3]; <S2SV_EndVul> } } dst += 16; } <S2SV_StartVul> dst += 16 * stride - x; <S2SV_EndVul> } return 0; }","- static int decode_i2_frame(FourXContext *f, AVFrame *frame, const uint8_t *buf, int length)
- uint16_t *dst = (uint16_t*)frame->data[0];
- const int stride = frame->linesize[0]>>1;
- dst[y2 * stride + x2] = color[(bits >> index) & 3];
- dst += 16 * stride - x;
+ static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length)
+ uint16_t *dst = f->frame_buffer;
+ dst[y2 * width + x2] = color[(bits >> index) & 3];
+ dst += 16 * width - x;","static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length) { int x, y, x2, y2; const int width = f->avctx->width; const int height = f->avctx->height; const int mbs = (FFALIGN(width, 16) >> 4) * (FFALIGN(height, 16) >> 4); uint16_t *dst = f->frame_buffer; GetByteContext g3; if (length < mbs * 8) { av_log(f->avctx, AV_LOG_ERROR, ""packet size too small\n""); return AVERROR_INVALIDDATA; } bytestream2_init(&g3, buf, length); for (y = 0; y < height; y += 16) { for (x = 0; x < width; x += 16) { unsigned int color[4] = { 0 }, bits; color[0] = bytestream2_get_le16u(&g3); color[1] = bytestream2_get_le16u(&g3); if (color[0] & 0x8000) av_log(f->avctx, AV_LOG_ERROR, ""unk bit 1\n""); if (color[1] & 0x8000) av_log(f->avctx, AV_LOG_ERROR, ""unk bit 2\n""); color[2] = mix(color[0], color[1]); color[3] = mix(color[1], color[0]); bits = bytestream2_get_le32u(&g3); for (y2 = 0; y2 < 16; y2++) { for (x2 = 0; x2 < 16; x2++) { int index = 2 * (x2 >> 2) + 8 * (y2 >> 2); dst[y2 * width + x2] = color[(bits >> index) & 3]; } } dst += 16; } dst += 16 * width - x; } return 0; }"
490----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b864c9ef37160c1e99e592d63be8e91973300ea_1.json----ff_h264_filter_mb_fast,"void ff_h264_filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) { MpegEncContext * const s = &h->s; int mb_y_firstrow = s->picture_structure == PICT_BOTTOM_FIELD; int mb_xy, mb_type; int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh; mb_xy = h->mb_xy; if(mb_x==0 || mb_y==mb_y_firstrow || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff || (h->deblocking_filter == 2 && (h->slice_num != h->slice_table[h->top_mb_xy] || h->slice_num != h->slice_table[mb_xy - 1]))) { ff_h264_filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize); return; } assert(!FRAME_MBAFF); mb_type = s->current_picture.mb_type[mb_xy]; qp = s->current_picture.qscale_table[mb_xy]; qp0 = s->current_picture.qscale_table[mb_xy-1]; qp1 = s->current_picture.qscale_table[h->top_mb_xy]; qpc = get_chroma_qp( h, 0, qp ); qpc0 = get_chroma_qp( h, 0, qp0 ); qpc1 = get_chroma_qp( h, 0, qp1 ); qp0 = (qp + qp0 + 1) >> 1; qp1 = (qp + qp1 + 1) >> 1; qpc0 = (qpc + qpc0 + 1) >> 1; qpc1 = (qpc + qpc1 + 1) >> 1; <S2SV_StartVul> qp_thresh = 15 - h->slice_alpha_c0_offset; <S2SV_EndVul> if(qp <= qp_thresh && qp0 <= qp_thresh && qp1 <= qp_thresh && qpc <= qp_thresh && qpc0 <= qp_thresh && qpc1 <= qp_thresh) return; if( IS_INTRA(mb_type) ) { int16_t bS4[4] = {4,4,4,4}; int16_t bS3[4] = {3,3,3,3}; int16_t *bSH = FIELD_PICTURE ? bS3 : bS4; if( IS_8x8DCT(mb_type) ) { filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h); filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h); filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h); } else { filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h); filter_mb_edgev( &img_y[4*1], linesize, bS3, qp, h); filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h); filter_mb_edgev( &img_y[4*3], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h); filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, h); } filter_mb_edgecv( &img_cb[2*0], uvlinesize, bS4, qpc0, h); filter_mb_edgecv( &img_cb[2*2], uvlinesize, bS3, qpc, h); filter_mb_edgecv( &img_cr[2*0], uvlinesize, bS4, qpc0, h); filter_mb_edgecv( &img_cr[2*2], uvlinesize, bS3, qpc, h); filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, h); filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, h); filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, h); filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, h); return; } else { DECLARE_ALIGNED_8(int16_t, bS)[2][4][4]; uint64_t (*bSv)[4] = (uint64_t(*)[4])bS; int edges; if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 ) { edges = 4; bSv[0][0] = bSv[0][2] = bSv[1][0] = bSv[1][2] = 0x0002000200020002ULL; } else { int mask_edge1 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : (mb_type & MB_TYPE_16x8) ? 1 : 0; int mask_edge0 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) && (s->current_picture.mb_type[mb_xy-1] & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : 0; int step = IS_8x8DCT(mb_type) ? 2 : 1; edges = (mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4; s->dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache, (h->slice_type_nos == FF_B_TYPE), edges, step, mask_edge0, mask_edge1, FIELD_PICTURE); } if( IS_INTRA(s->current_picture.mb_type[mb_xy-1]) ) bSv[0][0] = 0x0004000400040004ULL; if( IS_INTRA(s->current_picture.mb_type[h->top_mb_xy]) ) bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL; #define FILTER(hv,dir,edge) \ if(bSv[dir][edge]) {\ filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1)], linesize, bS[dir][edge], edge ? qp : qp##dir, h );\ if(!(edge&1)) {\ filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\ filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\ }\ } if( edges == 1 ) { FILTER(v,0,0); FILTER(h,1,0); } else if( IS_8x8DCT(mb_type) ) { FILTER(v,0,0); FILTER(v,0,2); FILTER(h,1,0); FILTER(h,1,2); } else { FILTER(v,0,0); FILTER(v,0,1); FILTER(v,0,2); FILTER(v,0,3); FILTER(h,1,0); FILTER(h,1,1); FILTER(h,1,2); FILTER(h,1,3); } #undef FILTER } }","- qp_thresh = 15 - h->slice_alpha_c0_offset;
+ qp_thresh = 15+52 - h->slice_alpha_c0_offset;","void ff_h264_filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) { MpegEncContext * const s = &h->s; int mb_y_firstrow = s->picture_structure == PICT_BOTTOM_FIELD; int mb_xy, mb_type; int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh; mb_xy = h->mb_xy; if(mb_x==0 || mb_y==mb_y_firstrow || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff || (h->deblocking_filter == 2 && (h->slice_num != h->slice_table[h->top_mb_xy] || h->slice_num != h->slice_table[mb_xy - 1]))) { ff_h264_filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize); return; } assert(!FRAME_MBAFF); mb_type = s->current_picture.mb_type[mb_xy]; qp = s->current_picture.qscale_table[mb_xy]; qp0 = s->current_picture.qscale_table[mb_xy-1]; qp1 = s->current_picture.qscale_table[h->top_mb_xy]; qpc = get_chroma_qp( h, 0, qp ); qpc0 = get_chroma_qp( h, 0, qp0 ); qpc1 = get_chroma_qp( h, 0, qp1 ); qp0 = (qp + qp0 + 1) >> 1; qp1 = (qp + qp1 + 1) >> 1; qpc0 = (qpc + qpc0 + 1) >> 1; qpc1 = (qpc + qpc1 + 1) >> 1; qp_thresh = 15+52 - h->slice_alpha_c0_offset; if(qp <= qp_thresh && qp0 <= qp_thresh && qp1 <= qp_thresh && qpc <= qp_thresh && qpc0 <= qp_thresh && qpc1 <= qp_thresh) return; if( IS_INTRA(mb_type) ) { int16_t bS4[4] = {4,4,4,4}; int16_t bS3[4] = {3,3,3,3}; int16_t *bSH = FIELD_PICTURE ? bS3 : bS4; if( IS_8x8DCT(mb_type) ) { filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h); filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h); filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h); } else { filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h); filter_mb_edgev( &img_y[4*1], linesize, bS3, qp, h); filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h); filter_mb_edgev( &img_y[4*3], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h); filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h); filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, h); } filter_mb_edgecv( &img_cb[2*0], uvlinesize, bS4, qpc0, h); filter_mb_edgecv( &img_cb[2*2], uvlinesize, bS3, qpc, h); filter_mb_edgecv( &img_cr[2*0], uvlinesize, bS4, qpc0, h); filter_mb_edgecv( &img_cr[2*2], uvlinesize, bS3, qpc, h); filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, h); filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, h); filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, h); filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, h); return; } else { DECLARE_ALIGNED_8(int16_t, bS)[2][4][4]; uint64_t (*bSv)[4] = (uint64_t(*)[4])bS; int edges; if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 ) { edges = 4; bSv[0][0] = bSv[0][2] = bSv[1][0] = bSv[1][2] = 0x0002000200020002ULL; } else { int mask_edge1 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : (mb_type & MB_TYPE_16x8) ? 1 : 0; int mask_edge0 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) && (s->current_picture.mb_type[mb_xy-1] & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : 0; int step = IS_8x8DCT(mb_type) ? 2 : 1; edges = (mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4; s->dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache, (h->slice_type_nos == FF_B_TYPE), edges, step, mask_edge0, mask_edge1, FIELD_PICTURE); } if( IS_INTRA(s->current_picture.mb_type[mb_xy-1]) ) bSv[0][0] = 0x0004000400040004ULL; if( IS_INTRA(s->current_picture.mb_type[h->top_mb_xy]) ) bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL; #define FILTER(hv,dir,edge) \ if(bSv[dir][edge]) {\ filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1)], linesize, bS[dir][edge], edge ? qp : qp##dir, h );\ if(!(edge&1)) {\ filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\ filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\ }\ } if( edges == 1 ) { FILTER(v,0,0); FILTER(h,1,0); } else if( IS_8x8DCT(mb_type) ) { FILTER(v,0,0); FILTER(v,0,2); FILTER(h,1,0); FILTER(h,1,2); } else { FILTER(v,0,0); FILTER(v,0,1); FILTER(v,0,2); FILTER(v,0,3); FILTER(h,1,0); FILTER(h,1,1); FILTER(h,1,2); FILTER(h,1,3); } #undef FILTER } }"
13801----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7bf66e41311ce56f748a660a38084678963d1e7b_1.json----pack_sign_cp,"<S2SV_StartVul> int pack_sign_cp(DSA_SIG *s, int order, unsigned char *sig, size_t *siglen) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> *siglen = 2 * order; <S2SV_EndVul> <S2SV_StartVul> memset(sig, 0, *siglen); <S2SV_EndVul> <S2SV_StartVul> store_bignum(s->s, sig, order); <S2SV_EndVul> <S2SV_StartVul> store_bignum(s->r, sig + order, order); <S2SV_EndVul> <S2SV_StartVul> dump_signature(""serialized"", sig, *siglen); <S2SV_EndVul> <S2SV_StartVul> DSA_SIG_free(s); <S2SV_EndVul> <S2SV_StartVul> return 1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- int pack_sign_cp(DSA_SIG *s, int order, unsigned char *sig, size_t *siglen)
- {
- memset(sig, 0, *siglen);
- store_bignum(s->s, sig, order);
- store_bignum(s->r, sig + order, order);
- dump_signature(""serialized"", sig, *siglen);
- DSA_SIG_free(s);
- return 1;
- }","int pack_sign_cp(DSA_SIG *s, int order, unsigned char *sig, size_t *siglen) { *siglen = 2 * order; memset(sig, 0, *siglen); store_bignum(s->s, sig, order); store_bignum(s->r, sig + order, order); DSA_SIG_free(s); return 1; }"
7816----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a88038817c0e7f00b9c1447d22c6c8be305eafab_1.json----encode_slice,"static int encode_slice(AVCodecContext *avctx, const AVFrame *pic, PutBitContext *pb, int sizes[4], int x, int y, int quant, int mbs_per_slice) { ProresContext *ctx = avctx->priv_data; int i, xp, yp; int total_size = 0; const uint16_t *src; int slice_width_factor = av_log2(mbs_per_slice); <S2SV_StartVul> int num_cblocks, pwidth, linesize, line_add; <S2SV_EndVul> int plane_factor, is_chroma; uint16_t *qmat; if (ctx->pictures_per_frame == 1) line_add = 0; else line_add = ctx->cur_picture_idx ^ !pic->top_field_first; if (ctx->force_quant) { qmat = ctx->quants[0]; } else if (quant < MAX_STORED_Q) { qmat = ctx->quants[quant]; } else { qmat = ctx->custom_q; for (i = 0; i < 64; i++) qmat[i] = ctx->quant_mat[i] * quant; } for (i = 0; i < ctx->num_planes; i++) { is_chroma = (i == 1 || i == 2); plane_factor = slice_width_factor + 2; if (is_chroma) plane_factor += ctx->chroma_factor - 3; if (!is_chroma || ctx->chroma_factor == CFACTOR_Y444) { xp = x << 4; yp = y << 4; num_cblocks = 4; pwidth = avctx->width; } else { xp = x << 3; yp = y << 4; num_cblocks = 2; pwidth = avctx->width >> 1; } linesize = pic->linesize[i] * ctx->pictures_per_frame; src = (const uint16_t*)(pic->data[i] + yp * linesize + line_add * pic->linesize[i]) + xp; if (i < 3) { get_slice_data(ctx, src, linesize, xp, yp, pwidth, avctx->height / ctx->pictures_per_frame, ctx->blocks[0], ctx->emu_buf, mbs_per_slice, num_cblocks, is_chroma); sizes[i] = encode_slice_plane(ctx, pb, src, linesize, mbs_per_slice, ctx->blocks[0], num_cblocks, plane_factor, qmat); } else { get_alpha_data(ctx, src, linesize, xp, yp, pwidth, avctx->height / ctx->pictures_per_frame, ctx->blocks[0], mbs_per_slice, ctx->alpha_bits); sizes[i] = encode_alpha_plane(ctx, pb, mbs_per_slice, ctx->blocks[0], quant); } total_size += sizes[i]; if (put_bits_left(pb) < 0) { av_log(avctx, AV_LOG_ERROR, ""Underestimated required buffer size.\n""); return AVERROR_BUG; } } return total_size; }","- int num_cblocks, pwidth, linesize, line_add;
+ int num_cblocks, pwidth, line_add;
+ ptrdiff_t linesize;","static int encode_slice(AVCodecContext *avctx, const AVFrame *pic, PutBitContext *pb, int sizes[4], int x, int y, int quant, int mbs_per_slice) { ProresContext *ctx = avctx->priv_data; int i, xp, yp; int total_size = 0; const uint16_t *src; int slice_width_factor = av_log2(mbs_per_slice); int num_cblocks, pwidth, line_add; ptrdiff_t linesize; int plane_factor, is_chroma; uint16_t *qmat; if (ctx->pictures_per_frame == 1) line_add = 0; else line_add = ctx->cur_picture_idx ^ !pic->top_field_first; if (ctx->force_quant) { qmat = ctx->quants[0]; } else if (quant < MAX_STORED_Q) { qmat = ctx->quants[quant]; } else { qmat = ctx->custom_q; for (i = 0; i < 64; i++) qmat[i] = ctx->quant_mat[i] * quant; } for (i = 0; i < ctx->num_planes; i++) { is_chroma = (i == 1 || i == 2); plane_factor = slice_width_factor + 2; if (is_chroma) plane_factor += ctx->chroma_factor - 3; if (!is_chroma || ctx->chroma_factor == CFACTOR_Y444) { xp = x << 4; yp = y << 4; num_cblocks = 4; pwidth = avctx->width; } else { xp = x << 3; yp = y << 4; num_cblocks = 2; pwidth = avctx->width >> 1; } linesize = pic->linesize[i] * ctx->pictures_per_frame; src = (const uint16_t*)(pic->data[i] + yp * linesize + line_add * pic->linesize[i]) + xp; if (i < 3) { get_slice_data(ctx, src, linesize, xp, yp, pwidth, avctx->height / ctx->pictures_per_frame, ctx->blocks[0], ctx->emu_buf, mbs_per_slice, num_cblocks, is_chroma); sizes[i] = encode_slice_plane(ctx, pb, src, linesize, mbs_per_slice, ctx->blocks[0], num_cblocks, plane_factor, qmat); } else { get_alpha_data(ctx, src, linesize, xp, yp, pwidth, avctx->height / ctx->pictures_per_frame, ctx->blocks[0], mbs_per_slice, ctx->alpha_bits); sizes[i] = encode_alpha_plane(ctx, pb, mbs_per_slice, ctx->blocks[0], quant); } total_size += sizes[i]; if (put_bits_left(pb) < 0) { av_log(avctx, AV_LOG_ERROR, ""Underestimated required buffer size.\n""); return AVERROR_BUG; } } return total_size; }"
6483----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5c2b17f99277f0db83d38972b59e254dfa8834dd_1.json----rtp_send_ilbc,"static int rtp_send_ilbc(AVFormatContext *s1, const uint8_t *buf, int size) { RTPMuxContext *s = s1->priv_data; AVStream *st = s1->streams[0]; <S2SV_StartVul> int frame_duration = av_get_audio_frame_duration(st->codec, 0); <S2SV_EndVul> <S2SV_StartVul> int frame_size = st->codec->block_align; <S2SV_EndVul> int frames = size / frame_size; while (frames > 0) { if (s->num_frames > 0 && av_compare_ts(s->cur_timestamp - s->timestamp, st->time_base, s1->max_delay, AV_TIME_BASE_Q) >= 0) { ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1); s->num_frames = 0; } if (!s->num_frames) { s->buf_ptr = s->buf; s->timestamp = s->cur_timestamp; } memcpy(s->buf_ptr, buf, frame_size); frames--; s->num_frames++; s->buf_ptr += frame_size; buf += frame_size; s->cur_timestamp += frame_duration; if (s->num_frames == s->max_frames_per_packet) { ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1); s->num_frames = 0; } } return 0; }","- int frame_duration = av_get_audio_frame_duration(st->codec, 0);
- int frame_size = st->codec->block_align;
+ int frame_duration = av_get_audio_frame_duration2(st->codecpar, 0);
+ int frame_size = st->codecpar->block_align;","static int rtp_send_ilbc(AVFormatContext *s1, const uint8_t *buf, int size) { RTPMuxContext *s = s1->priv_data; AVStream *st = s1->streams[0]; int frame_duration = av_get_audio_frame_duration2(st->codecpar, 0); int frame_size = st->codecpar->block_align; int frames = size / frame_size; while (frames > 0) { if (s->num_frames > 0 && av_compare_ts(s->cur_timestamp - s->timestamp, st->time_base, s1->max_delay, AV_TIME_BASE_Q) >= 0) { ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1); s->num_frames = 0; } if (!s->num_frames) { s->buf_ptr = s->buf; s->timestamp = s->cur_timestamp; } memcpy(s->buf_ptr, buf, frame_size); frames--; s->num_frames++; s->buf_ptr += frame_size; buf += frame_size; s->cur_timestamp += frame_duration; if (s->num_frames == s->max_frames_per_packet) { ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1); s->num_frames = 0; } } return 0; }"
10296----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_01439aa472ab6dbab4f9b63e3627efb1687802ca_1.json----BN_mod_mul_montgomery,"int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_MONT_CTX *mont, BN_CTX *ctx) { BIGNUM *tmp,*tmp2; int ret=0; BN_CTX_start(ctx); tmp = BN_CTX_get(ctx); tmp2 = BN_CTX_get(ctx); if (tmp == NULL || tmp2 == NULL) goto err; bn_check_top(tmp); bn_check_top(tmp2); if (a == b) { <S2SV_StartVul> #if 1 <S2SV_EndVul> bn_wexpand(tmp,a->top*2); bn_wexpand(tmp2,a->top*4); bn_sqr_recursive(tmp->d,a->d,a->top,tmp2->d); tmp->top=a->top*2; if (tmp->top > 0 && tmp->d[tmp->top-1] == 0) tmp->top--; #else if (!BN_sqr(tmp,a,ctx)) goto err; #endif } else { if (!BN_mul(tmp,a,b,ctx)) goto err; } if (!BN_from_montgomery(r,tmp,mont,ctx)) goto err; ret=1; err: BN_CTX_end(ctx); return(ret); }","- #if 1
+ #if 0 /* buggy -- try squaring g in the following parameters
+ (but note that squaring 2 or 4 works):
+ Diffie-Hellman-Parameters: (1024 bit)
+ prime:
+ 00:ff:ff:ff:ff:ff:ff:ff:ff:c9:0f:da:a2:21:68:
+ c2:34:c4:c6:62:8b:80:dc:1c:d1:29:02:4e:08:8a:
+ 67:cc:74:02:0b:be:a6:3b:13:9b:22:51:4a:08:79:
+ 8e:34:04:dd:ef:95:19:b3:cd:3a:43:1b:30:2b:0a:
+ 6d:f2:5f:14:37:4f:e1:35:6d:6d:51:c2:45:e4:85:
+ b5:76:62:5e:7e:c6:f4:4c:42:e9:a6:37:ed:6b:0b:
+ ff:5c:b6:f4:06:b7:ed:ee:38:6b:fb:5a:89:9f:a5:
+ ae:9f:24:11:7c:4b:1f:e6:49:28:66:51:ec:e6:53:
+ 81:ff:ff:ff:ff:ff:ff:ff:ff
+ generator: 8 (0x8)
+ -----BEGIN DH PARAMETERS-----
+ MIGHAoGBAP//////////yQ/aoiFowjTExmKLgNwc0SkCTgiKZ8x0Agu+pjsTmyJR
+ Sgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHCReSFtXZiXn7G9ExC6aY37WsL
+ /1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7OZTgf//////////AgEI
+ -----END DH PARAMETERS-----","int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_MONT_CTX *mont, BN_CTX *ctx) { BIGNUM *tmp,*tmp2; int ret=0; BN_CTX_start(ctx); tmp = BN_CTX_get(ctx); tmp2 = BN_CTX_get(ctx); if (tmp == NULL || tmp2 == NULL) goto err; bn_check_top(tmp); bn_check_top(tmp2); if (a == b) { #if 0 bn_wexpand(tmp,a->top*2); bn_wexpand(tmp2,a->top*4); bn_sqr_recursive(tmp->d,a->d,a->top,tmp2->d); tmp->top=a->top*2; if (tmp->top > 0 && tmp->d[tmp->top-1] == 0) tmp->top--; #else if (!BN_sqr(tmp,a,ctx)) goto err; #endif } else { if (!BN_mul(tmp,a,b,ctx)) goto err; } if (!BN_from_montgomery(r,tmp,mont,ctx)) goto err; ret=1; err: BN_CTX_end(ctx); return(ret); }"
10832----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_145a8cda95cd7f614f15b278c10ef2a2f68af658_1.json----fmtint,"static void fmtint( <S2SV_StartVul> char *buffer, <S2SV_EndVul> size_t *currlen, <S2SV_StartVul> size_t maxlen, <S2SV_EndVul> LLONG value, int base, int min, int max, int flags) { int signvalue = 0; unsigned LLONG uvalue; char convert[20]; int place = 0; int spadlen = 0; int zpadlen = 0; int caps = 0; if (max < 0) max = 0; uvalue = value; if (!(flags & DP_F_UNSIGNED)) { if (value < 0) { signvalue = '-'; uvalue = -value; } else if (flags & DP_F_PLUS) signvalue = '+'; else if (flags & DP_F_SPACE) signvalue = ' '; } if (flags & DP_F_UP) caps = 1; do { convert[place++] = (caps ? ""0123456789ABCDEF"" : ""0123456789abcdef"") [uvalue % (unsigned) base]; uvalue = (uvalue / (unsigned) base); } while (uvalue && (place < 20)); if (place == 20) place--; convert[place] = 0; zpadlen = max - place; spadlen = min - MAX(max, place) - (signvalue ? 1 : 0); if (zpadlen < 0) zpadlen = 0; if (spadlen < 0) spadlen = 0; if (flags & DP_F_ZERO) { zpadlen = MAX(zpadlen, spadlen); spadlen = 0; } if (flags & DP_F_MINUS) spadlen = -spadlen; while (spadlen > 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, ' '); <S2SV_EndVul> --spadlen; } if (signvalue) <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, signvalue); <S2SV_EndVul> if (zpadlen > 0) { while (zpadlen > 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, '0'); <S2SV_EndVul> --zpadlen; } } while (place > 0) <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, convert[--place]); <S2SV_EndVul> while (spadlen < 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, ' '); <S2SV_EndVul> ++spadlen; } return; }","- char *buffer,
- size_t maxlen,
- dopr_outch(buffer, currlen, maxlen, ' ');
- dopr_outch(buffer, currlen, maxlen, signvalue);
- dopr_outch(buffer, currlen, maxlen, '0');
- dopr_outch(buffer, currlen, maxlen, convert[--place]);
- dopr_outch(buffer, currlen, maxlen, ' ');
+ void (*outch_fn)(char **, size_t *, size_t *, int),
+ char **buffer,
+ size_t *maxlen,
+ (*outch_fn)(buffer, currlen, maxlen, ' ');
+ (*outch_fn)(buffer, currlen, maxlen, signvalue);
+ (*outch_fn)(buffer, currlen, maxlen, '0');
+ (*outch_fn)(buffer, currlen, maxlen, convert[--place]);
+ (*outch_fn)(buffer, currlen, maxlen, ' ');","static void fmtint( void (*outch_fn)(char **, size_t *, size_t *, int), char **buffer, size_t *currlen, size_t *maxlen, LLONG value, int base, int min, int max, int flags) { int signvalue = 0; unsigned LLONG uvalue; char convert[20]; int place = 0; int spadlen = 0; int zpadlen = 0; int caps = 0; if (max < 0) max = 0; uvalue = value; if (!(flags & DP_F_UNSIGNED)) { if (value < 0) { signvalue = '-'; uvalue = -value; } else if (flags & DP_F_PLUS) signvalue = '+'; else if (flags & DP_F_SPACE) signvalue = ' '; } if (flags & DP_F_UP) caps = 1; do { convert[place++] = (caps ? ""0123456789ABCDEF"" : ""0123456789abcdef"") [uvalue % (unsigned) base]; uvalue = (uvalue / (unsigned) base); } while (uvalue && (place < 20)); if (place == 20) place--; convert[place] = 0; zpadlen = max - place; spadlen = min - MAX(max, place) - (signvalue ? 1 : 0); if (zpadlen < 0) zpadlen = 0; if (spadlen < 0) spadlen = 0; if (flags & DP_F_ZERO) { zpadlen = MAX(zpadlen, spadlen); spadlen = 0; } if (flags & DP_F_MINUS) spadlen = -spadlen; while (spadlen > 0) { (*outch_fn)(buffer, currlen, maxlen, ' '); --spadlen; } if (signvalue) (*outch_fn)(buffer, currlen, maxlen, signvalue); if (zpadlen > 0) { while (zpadlen > 0) { (*outch_fn)(buffer, currlen, maxlen, '0'); --zpadlen; } } while (place > 0) (*outch_fn)(buffer, currlen, maxlen, convert[--place]); while (spadlen < 0) { (*outch_fn)(buffer, currlen, maxlen, ' '); ++spadlen; } return; }"
6221----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c4c31edfd61c8b55ddf405d6003d936af88d5c8_1.json----vc1_decode_p_blocks,"static void vc1_decode_p_blocks(VC1Context *v) { MpegEncContext *s = &v->s; int apply_loop_filter; switch (v->c_ac_table_index) { case 0: v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA; break; case 1: v->codingset = CS_HIGH_MOT_INTRA; break; case 2: v->codingset = CS_MID_RATE_INTRA; break; } switch (v->c_ac_table_index) { case 0: v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER; break; case 1: v->codingset2 = CS_HIGH_MOT_INTER; break; case 2: v->codingset2 = CS_MID_RATE_INTER; break; } <S2SV_StartVul> apply_loop_filter = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY); <S2SV_EndVul> s->first_slice_line = 1; memset(v->cbp_base, 0, sizeof(v->cbp_base[0])*2*s->mb_stride); for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) { s->mb_x = 0; ff_init_block_index(s); for (; s->mb_x < s->mb_width; s->mb_x++) { ff_update_block_index(s); if (v->fcm == ILACE_FIELD) vc1_decode_p_mb_intfi(v); else if (v->fcm == ILACE_FRAME) vc1_decode_p_mb_intfr(v); else vc1_decode_p_mb(v); <S2SV_StartVul> if (s->mb_y != s->start_mb_y && apply_loop_filter && v->fcm == PROGRESSIVE) <S2SV_EndVul> vc1_apply_p_loop_filter(v); if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) { ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR); av_log(s->avctx, AV_LOG_ERROR, ""Bits overconsumption: %i > %i at %ix%i\n"", get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y); return; } } memmove(v->cbp_base, v->cbp, sizeof(v->cbp_base[0]) * s->mb_stride); memmove(v->ttblk_base, v->ttblk, sizeof(v->ttblk_base[0]) * s->mb_stride); memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride); memmove(v->luma_mv_base, v->luma_mv, sizeof(v->luma_mv_base[0]) * s->mb_stride); if (s->mb_y != s->start_mb_y) ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16); s->first_slice_line = 0; } if (apply_loop_filter) { s->mb_x = 0; ff_init_block_index(s); for (; s->mb_x < s->mb_width; s->mb_x++) { ff_update_block_index(s); vc1_apply_p_loop_filter(v); } } if (s->end_mb_y >= s->start_mb_y) ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16); ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1, (s->end_mb_y << v->field_mode) - 1, ER_MB_END); }","- apply_loop_filter = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY);
- if (s->mb_y != s->start_mb_y && apply_loop_filter && v->fcm == PROGRESSIVE)
+ apply_loop_filter = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY) &&
+ v->fcm == PROGRESSIVE;
+ if (s->mb_y != s->start_mb_y && apply_loop_filter)","static void vc1_decode_p_blocks(VC1Context *v) { MpegEncContext *s = &v->s; int apply_loop_filter; switch (v->c_ac_table_index) { case 0: v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA; break; case 1: v->codingset = CS_HIGH_MOT_INTRA; break; case 2: v->codingset = CS_MID_RATE_INTRA; break; } switch (v->c_ac_table_index) { case 0: v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER; break; case 1: v->codingset2 = CS_HIGH_MOT_INTER; break; case 2: v->codingset2 = CS_MID_RATE_INTER; break; } apply_loop_filter = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY) && v->fcm == PROGRESSIVE; s->first_slice_line = 1; memset(v->cbp_base, 0, sizeof(v->cbp_base[0])*2*s->mb_stride); for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) { s->mb_x = 0; ff_init_block_index(s); for (; s->mb_x < s->mb_width; s->mb_x++) { ff_update_block_index(s); if (v->fcm == ILACE_FIELD) vc1_decode_p_mb_intfi(v); else if (v->fcm == ILACE_FRAME) vc1_decode_p_mb_intfr(v); else vc1_decode_p_mb(v); if (s->mb_y != s->start_mb_y && apply_loop_filter) vc1_apply_p_loop_filter(v); if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) { ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR); av_log(s->avctx, AV_LOG_ERROR, ""Bits overconsumption: %i > %i at %ix%i\n"", get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y); return; } } memmove(v->cbp_base, v->cbp, sizeof(v->cbp_base[0]) * s->mb_stride); memmove(v->ttblk_base, v->ttblk, sizeof(v->ttblk_base[0]) * s->mb_stride); memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride); memmove(v->luma_mv_base, v->luma_mv, sizeof(v->luma_mv_base[0]) * s->mb_stride); if (s->mb_y != s->start_mb_y) ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16); s->first_slice_line = 0; } if (apply_loop_filter) { s->mb_x = 0; ff_init_block_index(s); for (; s->mb_x < s->mb_width; s->mb_x++) { ff_update_block_index(s); vc1_apply_p_loop_filter(v); } } if (s->end_mb_y >= s->start_mb_y) ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16); ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1, (s->end_mb_y << v->field_mode) - 1, ER_MB_END); }"
10079----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_90107b7ab50654464d20c090193e6513fc69bf93_1.json----ngx_conf_merge_path_value,"char * ngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path, ngx_path_t *prev, ngx_path_init_t *init) { if (*path) { return NGX_CONF_OK; } if (prev) { *path = prev; return NGX_CONF_OK; } *path = ngx_palloc(cf->pool, sizeof(ngx_path_t)); if (*path == NULL) { return NGX_CONF_ERROR; } (*path)->name = init->name; <S2SV_StartVul> if (ngx_get_full_name(cf->pool, &cf->cycle->prefix, &(*path)->name) <S2SV_EndVul> <S2SV_StartVul> != NGX_OK) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> return NGX_CONF_ERROR; } (*path)->level[0] = init->level[0]; (*path)->level[1] = init->level[1]; (*path)->level[2] = init->level[2]; (*path)->len = init->level[0] + (init->level[0] ? 1 : 0) + init->level[1] + (init->level[1] ? 1 : 0) + init->level[2] + (init->level[2] ? 1 : 0); (*path)->manager = NULL; (*path)->loader = NULL; (*path)->conf_file = NULL; if (ngx_add_path(cf, path) != NGX_OK) { return NGX_CONF_ERROR; } return NGX_CONF_OK; }","- if (ngx_get_full_name(cf->pool, &cf->cycle->prefix, &(*path)->name)
- != NGX_OK)
- {
+ if (ngx_conf_full_name(cf->cycle, &(*path)->name, 0) != NGX_OK) {","char * ngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path, ngx_path_t *prev, ngx_path_init_t *init) { if (*path) { return NGX_CONF_OK; } if (prev) { *path = prev; return NGX_CONF_OK; } *path = ngx_palloc(cf->pool, sizeof(ngx_path_t)); if (*path == NULL) { return NGX_CONF_ERROR; } (*path)->name = init->name; if (ngx_conf_full_name(cf->cycle, &(*path)->name, 0) != NGX_OK) { return NGX_CONF_ERROR; } (*path)->level[0] = init->level[0]; (*path)->level[1] = init->level[1]; (*path)->level[2] = init->level[2]; (*path)->len = init->level[0] + (init->level[0] ? 1 : 0) + init->level[1] + (init->level[1] ? 1 : 0) + init->level[2] + (init->level[2] ? 1 : 0); (*path)->manager = NULL; (*path)->loader = NULL; (*path)->conf_file = NULL; if (ngx_add_path(cf, path) != NGX_OK) { return NGX_CONF_ERROR; } return NGX_CONF_OK; }"
10481----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_07c8308198e2f0348564310010b799e235662d7c_1.json----OBJ_obj2txt,"int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name) { int i, n = 0, len, nid, first, use_bn; BIGNUM *bl; unsigned long l; const unsigned char *p; char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2]; if (buf && buf_len > 0) buf[0] = '\0'; if ((a == NULL) || (a->data == NULL)) return (0); if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) { const char *s; s = OBJ_nid2ln(nid); if (s == NULL) s = OBJ_nid2sn(nid); if (s) { if (buf) OPENSSL_strlcpy(buf, s, buf_len); n = strlen(s); return n; } } len = a->length; p = a->data; first = 1; bl = NULL; while (len > 0) { l = 0; use_bn = 0; for (;;) { unsigned char c = *p++; len--; if ((len == 0) && (c & 0x80)) goto err; if (use_bn) { if (!BN_add_word(bl, c & 0x7f)) goto err; } else l |= c & 0x7f; if (!(c & 0x80)) break; if (!use_bn && (l > (ULONG_MAX >> 7L))) { if (bl == NULL && (bl = BN_new()) == NULL) goto err; if (!BN_set_word(bl, l)) goto err; use_bn = 1; } if (use_bn) { if (!BN_lshift(bl, bl, 7)) goto err; } else l <<= 7L; } if (first) { first = 0; if (l >= 80) { i = 2; if (use_bn) { if (!BN_sub_word(bl, 80)) goto err; } else l -= 80; } else { i = (int)(l / 40); l -= (long)(i * 40); } if (buf && (buf_len > 1)) { *buf++ = i + '0'; *buf = '\0'; buf_len--; } n++; } if (use_bn) { char *bndec; bndec = BN_bn2dec(bl); if (!bndec) goto err; i = strlen(bndec); if (buf) { if (buf_len > 1) { *buf++ = '.'; *buf = '\0'; buf_len--; } OPENSSL_strlcpy(buf, bndec, buf_len); if (i > buf_len) { buf += buf_len; buf_len = 0; } else { buf += i; buf_len -= i; } } n++; n += i; OPENSSL_free(bndec); } else { <S2SV_StartVul> BIO_snprintf(tbuf, sizeof tbuf, "".%lu"", l); <S2SV_EndVul> i = strlen(tbuf); if (buf && (buf_len > 0)) { OPENSSL_strlcpy(buf, tbuf, buf_len); if (i > buf_len) { buf += buf_len; buf_len = 0; } else { buf += i; buf_len -= i; } } n += i; l = 0; } } BN_free(bl); return n; err: BN_free(bl); return -1; }","- BIO_snprintf(tbuf, sizeof tbuf, "".%lu"", l);
+ sprintf(tbuf, "".%lu"", l);","int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name) { int i, n = 0, len, nid, first, use_bn; BIGNUM *bl; unsigned long l; const unsigned char *p; char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2]; if (buf && buf_len > 0) buf[0] = '\0'; if ((a == NULL) || (a->data == NULL)) return (0); if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) { const char *s; s = OBJ_nid2ln(nid); if (s == NULL) s = OBJ_nid2sn(nid); if (s) { if (buf) OPENSSL_strlcpy(buf, s, buf_len); n = strlen(s); return n; } } len = a->length; p = a->data; first = 1; bl = NULL; while (len > 0) { l = 0; use_bn = 0; for (;;) { unsigned char c = *p++; len--; if ((len == 0) && (c & 0x80)) goto err; if (use_bn) { if (!BN_add_word(bl, c & 0x7f)) goto err; } else l |= c & 0x7f; if (!(c & 0x80)) break; if (!use_bn && (l > (ULONG_MAX >> 7L))) { if (bl == NULL && (bl = BN_new()) == NULL) goto err; if (!BN_set_word(bl, l)) goto err; use_bn = 1; } if (use_bn) { if (!BN_lshift(bl, bl, 7)) goto err; } else l <<= 7L; } if (first) { first = 0; if (l >= 80) { i = 2; if (use_bn) { if (!BN_sub_word(bl, 80)) goto err; } else l -= 80; } else { i = (int)(l / 40); l -= (long)(i * 40); } if (buf && (buf_len > 1)) { *buf++ = i + '0'; *buf = '\0'; buf_len--; } n++; } if (use_bn) { char *bndec; bndec = BN_bn2dec(bl); if (!bndec) goto err; i = strlen(bndec); if (buf) { if (buf_len > 1) { *buf++ = '.'; *buf = '\0'; buf_len--; } OPENSSL_strlcpy(buf, bndec, buf_len); if (i > buf_len) { buf += buf_len; buf_len = 0; } else { buf += i; buf_len -= i; } } n++; n += i; OPENSSL_free(bndec); } else { sprintf(tbuf, "".%lu"", l); i = strlen(tbuf); if (buf && (buf_len > 0)) { OPENSSL_strlcpy(buf, tbuf, buf_len); if (i > buf_len) { buf += buf_len; buf_len = 0; } else { buf += i; buf_len -= i; } } n += i; l = 0; } } BN_free(bl); return n; err: BN_free(bl); return -1; }"
10686----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0f6f37d924e594b0f04236bcd45504af502cdbab_1.json----internal_verify,"static int internal_verify(X509_STORE_CTX *ctx) { int i,ok=0,n; X509 *xs,*xi; EVP_PKEY *pkey=NULL; int (*cb)(); cb=ctx->verify_cb; if (cb == NULL) cb=null_callback; n=sk_X509_num(ctx->chain); ctx->error_depth=n-1; n--; xi=sk_X509_value(ctx->chain,n); <S2SV_StartVul> if (X509_NAME_cmp(X509_get_subject_name(xi), <S2SV_EndVul> <S2SV_StartVul> X509_get_issuer_name(xi)) == 0) <S2SV_EndVul> xs=xi; else { if (n <= 0) { ctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE; ctx->current_cert=xi; ok=cb(0,ctx); goto end; } else { n--; ctx->error_depth=n; xs=sk_X509_value(ctx->chain,n); } } while (n >= 0) { ctx->error_depth=n; if (!xs->valid) { if ((pkey=X509_get_pubkey(xi)) == NULL) { ctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY; ctx->current_cert=xi; ok=(*cb)(0,ctx); if (!ok) goto end; } if (X509_verify(xs,pkey) <= 0) { ctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) { EVP_PKEY_free(pkey); goto end; } } EVP_PKEY_free(pkey); pkey=NULL; <S2SV_StartVul> i=X509_cmp_current_time(X509_get_notBefore(xs)); <S2SV_EndVul> if (i == 0) { ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } if (i > 0) { ctx->error=X509_V_ERR_CERT_NOT_YET_VALID; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } xs->valid=1; } <S2SV_StartVul> i=X509_cmp_current_time(X509_get_notAfter(xs)); <S2SV_EndVul> if (i == 0) { ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } if (i < 0) { ctx->error=X509_V_ERR_CERT_HAS_EXPIRED; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } ctx->current_cert=xs; ok=(*cb)(1,ctx); if (!ok) goto end; n--; if (n >= 0) { xi=xs; xs=sk_X509_value(ctx->chain,n); } } ok=1; end: return(ok); }","- if (X509_NAME_cmp(X509_get_subject_name(xi),
- X509_get_issuer_name(xi)) == 0)
- i=X509_cmp_current_time(X509_get_notBefore(xs));
- i=X509_cmp_current_time(X509_get_notAfter(xs));
+ time_t *ptime;
+ if(ctx->flags & X509_V_FLAG_USE_CHECK_TIME) ptime = &ctx->check_time;
+ else ptime = NULL;
+ if (ctx->check_issued(ctx, xi, xi))
+ i=X509_cmp_time(X509_get_notBefore(xs), ptime);
+ i=X509_cmp_time(X509_get_notAfter(xs), ptime);","static int internal_verify(X509_STORE_CTX *ctx) { int i,ok=0,n; X509 *xs,*xi; EVP_PKEY *pkey=NULL; time_t *ptime; int (*cb)(); cb=ctx->verify_cb; if (cb == NULL) cb=null_callback; n=sk_X509_num(ctx->chain); ctx->error_depth=n-1; n--; xi=sk_X509_value(ctx->chain,n); if(ctx->flags & X509_V_FLAG_USE_CHECK_TIME) ptime = &ctx->check_time; else ptime = NULL; if (ctx->check_issued(ctx, xi, xi)) xs=xi; else { if (n <= 0) { ctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE; ctx->current_cert=xi; ok=cb(0,ctx); goto end; } else { n--; ctx->error_depth=n; xs=sk_X509_value(ctx->chain,n); } } while (n >= 0) { ctx->error_depth=n; if (!xs->valid) { if ((pkey=X509_get_pubkey(xi)) == NULL) { ctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY; ctx->current_cert=xi; ok=(*cb)(0,ctx); if (!ok) goto end; } if (X509_verify(xs,pkey) <= 0) { ctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) { EVP_PKEY_free(pkey); goto end; } } EVP_PKEY_free(pkey); pkey=NULL; i=X509_cmp_time(X509_get_notBefore(xs), ptime); if (i == 0) { ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } if (i > 0) { ctx->error=X509_V_ERR_CERT_NOT_YET_VALID; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } xs->valid=1; } i=X509_cmp_time(X509_get_notAfter(xs), ptime); if (i == 0) { ctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } if (i < 0) { ctx->error=X509_V_ERR_CERT_HAS_EXPIRED; ctx->current_cert=xs; ok=(*cb)(0,ctx); if (!ok) goto end; } ctx->current_cert=xs; ok=(*cb)(1,ctx); if (!ok) goto end; n--; if (n >= 0) { xi=xs; xs=sk_X509_value(ctx->chain,n); } } ok=1; end: return(ok); }"
185----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0af298c1026b2f183f159fc2297ea2668ec36211_1.json----sdp_parse_fmtp_config_h264,"static int sdp_parse_fmtp_config_h264(AVStream * stream, PayloadContext * h264_data, char *attr, char *value) { AVCodecContext *codec = stream->codec; assert(codec->codec_id == CODEC_ID_H264); assert(h264_data != NULL); if (!strcmp(attr, ""packetization-mode"")) { av_log(codec, AV_LOG_DEBUG, ""RTP Packetization Mode: %d\n"", atoi(value)); h264_data->packetization_mode = atoi(value); if (h264_data->packetization_mode > 1) av_log(codec, AV_LOG_ERROR, ""Interleaved RTP mode is not supported yet.""); } else if (!strcmp(attr, ""profile-level-id"")) { if (strlen(value) == 6) { char buffer[3]; uint8_t profile_idc; uint8_t profile_iop; uint8_t level_idc; buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\0'; profile_idc = strtol(buffer, NULL, 16); buffer[0] = value[2]; buffer[1] = value[3]; profile_iop = strtol(buffer, NULL, 16); buffer[0] = value[4]; buffer[1] = value[5]; level_idc = strtol(buffer, NULL, 16); av_log(codec, AV_LOG_DEBUG, ""RTP Profile IDC: %x Profile IOP: %x Level: %x\n"", profile_idc, profile_iop, level_idc); h264_data->profile_idc = profile_idc; h264_data->profile_iop = profile_iop; h264_data->level_idc = level_idc; } } else if (!strcmp(attr, ""sprop-parameter-sets"")) { uint8_t start_sequence[]= { 0, 0, 1 }; codec->extradata_size= 0; codec->extradata= NULL; while (*value) { char base64packet[1024]; uint8_t decoded_packet[1024]; <S2SV_StartVul> uint32_t packet_size; <S2SV_EndVul> char *dst = base64packet; while (*value && *value != ',' && (dst - base64packet) < sizeof(base64packet) - 1) { *dst++ = *value++; } *dst++ = '\0'; if (*value == ',') value++; packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet)); <S2SV_StartVul> if (packet_size) { <S2SV_EndVul> uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) + codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); if(dest) { if(codec->extradata_size) { memcpy(dest, codec->extradata, codec->extradata_size); av_free(codec->extradata); } memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence)); memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size); memset(dest+codec->extradata_size+sizeof(start_sequence)+ packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE); codec->extradata= dest; codec->extradata_size+= sizeof(start_sequence)+packet_size; } else { av_log(codec, AV_LOG_ERROR, ""Unable to allocate memory for extradata!""); return AVERROR(ENOMEM); } } } av_log(codec, AV_LOG_DEBUG, ""Extradata set to %p (size: %d)!"", codec->extradata, codec->extradata_size); } return 0; }","- uint32_t packet_size;
- if (packet_size) {
+ int packet_size;
+ if (packet_size > 0) {","static int sdp_parse_fmtp_config_h264(AVStream * stream, PayloadContext * h264_data, char *attr, char *value) { AVCodecContext *codec = stream->codec; assert(codec->codec_id == CODEC_ID_H264); assert(h264_data != NULL); if (!strcmp(attr, ""packetization-mode"")) { av_log(codec, AV_LOG_DEBUG, ""RTP Packetization Mode: %d\n"", atoi(value)); h264_data->packetization_mode = atoi(value); if (h264_data->packetization_mode > 1) av_log(codec, AV_LOG_ERROR, ""Interleaved RTP mode is not supported yet.""); } else if (!strcmp(attr, ""profile-level-id"")) { if (strlen(value) == 6) { char buffer[3]; uint8_t profile_idc; uint8_t profile_iop; uint8_t level_idc; buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\0'; profile_idc = strtol(buffer, NULL, 16); buffer[0] = value[2]; buffer[1] = value[3]; profile_iop = strtol(buffer, NULL, 16); buffer[0] = value[4]; buffer[1] = value[5]; level_idc = strtol(buffer, NULL, 16); av_log(codec, AV_LOG_DEBUG, ""RTP Profile IDC: %x Profile IOP: %x Level: %x\n"", profile_idc, profile_iop, level_idc); h264_data->profile_idc = profile_idc; h264_data->profile_iop = profile_iop; h264_data->level_idc = level_idc; } } else if (!strcmp(attr, ""sprop-parameter-sets"")) { uint8_t start_sequence[]= { 0, 0, 1 }; codec->extradata_size= 0; codec->extradata= NULL; while (*value) { char base64packet[1024]; uint8_t decoded_packet[1024]; int packet_size; char *dst = base64packet; while (*value && *value != ',' && (dst - base64packet) < sizeof(base64packet) - 1) { *dst++ = *value++; } *dst++ = '\0'; if (*value == ',') value++; packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet)); if (packet_size > 0) { uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) + codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); if(dest) { if(codec->extradata_size) { memcpy(dest, codec->extradata, codec->extradata_size); av_free(codec->extradata); } memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence)); memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size); memset(dest+codec->extradata_size+sizeof(start_sequence)+ packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE); codec->extradata= dest; codec->extradata_size+= sizeof(start_sequence)+packet_size; } else { av_log(codec, AV_LOG_ERROR, ""Unable to allocate memory for extradata!""); return AVERROR(ENOMEM); } } } av_log(codec, AV_LOG_DEBUG, ""Extradata set to %p (size: %d)!"", codec->extradata, codec->extradata_size); } return 0; }"
13850----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d5bf675f76d0bf7e732def341c71b2a86edcee6_1.json----ssl3_ctrl,"long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg) { int ret = 0; switch (cmd) { case SSL_CTRL_GET_SESSION_REUSED: ret = s->hit; break; case SSL_CTRL_GET_CLIENT_CERT_REQUEST: break; case SSL_CTRL_GET_NUM_RENEGOTIATIONS: ret = s->s3->num_renegotiations; break; case SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS: ret = s->s3->num_renegotiations; s->s3->num_renegotiations = 0; break; case SSL_CTRL_GET_TOTAL_RENEGOTIATIONS: ret = s->s3->total_renegotiations; break; case SSL_CTRL_GET_FLAGS: ret = (int)(s->s3->flags); break; #ifndef OPENSSL_NO_DH case SSL_CTRL_SET_TMP_DH: { DH *dh = (DH *)parg; if (dh == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER); return (ret); } if (!ssl_security(s, SSL_SECOP_TMP_DH, DH_security_bits(dh), 0, dh)) { SSLerr(SSL_F_SSL3_CTRL, SSL_R_DH_KEY_TOO_SMALL); return (ret); } if ((dh = DHparams_dup(dh)) == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB); return (ret); } <S2SV_StartVul> if (!(s->options & SSL_OP_SINGLE_DH_USE)) { <S2SV_EndVul> <S2SV_StartVul> if (!DH_generate_key(dh)) { <S2SV_EndVul> <S2SV_StartVul> DH_free(dh); <S2SV_EndVul> <S2SV_StartVul> SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB); <S2SV_EndVul> <S2SV_StartVul> return (ret); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> DH_free(s->cert->dh_tmp); s->cert->dh_tmp = dh; ret = 1; } break; case SSL_CTRL_SET_TMP_DH_CB: { SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return (ret); } case SSL_CTRL_SET_DH_AUTO: s->cert->dh_tmp_auto = larg; return 1; #endif #ifndef OPENSSL_NO_EC case SSL_CTRL_SET_TMP_ECDH: { const EC_GROUP *group = NULL; int nid; if (parg == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER); return 0; } group = EC_KEY_get0_group((const EC_KEY *)parg); if (group == NULL) { SSLerr(SSL_F_SSL3_CTRL, EC_R_MISSING_PARAMETERS); return 0; } nid = EC_GROUP_get_curve_name(group); if (nid == NID_undef) return 0; return tls1_set_curves(&s->tlsext_ellipticcurvelist, &s->tlsext_ellipticcurvelist_length, &nid, 1); } break; #endif case SSL_CTRL_SET_TLSEXT_HOSTNAME: if (larg == TLSEXT_NAMETYPE_host_name) { OPENSSL_free(s->tlsext_hostname); s->tlsext_hostname = NULL; ret = 1; if (parg == NULL) break; if (strlen((char *)parg) > TLSEXT_MAXLEN_host_name) { SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME); return 0; } if ((s->tlsext_hostname = OPENSSL_strdup((char *)parg)) == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR); return 0; } } else { SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE); return 0; } break; case SSL_CTRL_SET_TLSEXT_DEBUG_ARG: s->tlsext_debug_arg = parg; ret = 1; break; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE: s->tlsext_status_type = larg; ret = 1; break; case SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS: *(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts; ret = 1; break; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS: s->tlsext_ocsp_exts = parg; ret = 1; break; case SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS: *(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids; ret = 1; break; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS: s->tlsext_ocsp_ids = parg; ret = 1; break; case SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP: *(unsigned char **)parg = s->tlsext_ocsp_resp; return s->tlsext_ocsp_resplen; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP: OPENSSL_free(s->tlsext_ocsp_resp); s->tlsext_ocsp_resp = parg; s->tlsext_ocsp_resplen = larg; ret = 1; break; #ifndef OPENSSL_NO_HEARTBEATS case SSL_CTRL_TLS_EXT_SEND_HEARTBEAT: if (SSL_IS_DTLS(s)) ret = dtls1_heartbeat(s); else ret = tls1_heartbeat(s); break; case SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING: ret = s->tlsext_hb_pending; break; case SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS: if (larg) s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS; else s->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS; ret = 1; break; #endif case SSL_CTRL_CHAIN: if (larg) return ssl_cert_set1_chain(s, NULL, (STACK_OF(X509) *)parg); else return ssl_cert_set0_chain(s, NULL, (STACK_OF(X509) *)parg); case SSL_CTRL_CHAIN_CERT: if (larg) return ssl_cert_add1_chain_cert(s, NULL, (X509 *)parg); else return ssl_cert_add0_chain_cert(s, NULL, (X509 *)parg); case SSL_CTRL_GET_CHAIN_CERTS: *(STACK_OF(X509) **)parg = s->cert->key->chain; break; case SSL_CTRL_SELECT_CURRENT_CERT: return ssl_cert_select_current(s->cert, (X509 *)parg); case SSL_CTRL_SET_CURRENT_CERT: if (larg == SSL_CERT_SET_SERVER) { CERT_PKEY *cpk; const SSL_CIPHER *cipher; if (!s->server) return 0; cipher = s->s3->tmp.new_cipher; if (!cipher) return 0; if (cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP)) return 2; cpk = ssl_get_server_send_pkey(s); if (!cpk) return 0; s->cert->key = cpk; return 1; } return ssl_cert_set_current(s->cert, larg); #ifndef OPENSSL_NO_EC case SSL_CTRL_GET_CURVES: { unsigned char *clist; size_t clistlen; if (!s->session) return 0; clist = s->session->tlsext_ellipticcurvelist; clistlen = s->session->tlsext_ellipticcurvelist_length / 2; if (parg) { size_t i; int *cptr = parg; unsigned int cid, nid; for (i = 0; i < clistlen; i++) { n2s(clist, cid); nid = tls1_ec_curve_id2nid(cid); if (nid != 0) cptr[i] = nid; else cptr[i] = TLSEXT_nid_unknown | cid; } } return (int)clistlen; } case SSL_CTRL_SET_CURVES: return tls1_set_curves(&s->tlsext_ellipticcurvelist, &s->tlsext_ellipticcurvelist_length, parg, larg); case SSL_CTRL_SET_CURVES_LIST: return tls1_set_curves_list(&s->tlsext_ellipticcurvelist, &s->tlsext_ellipticcurvelist_length, parg); case SSL_CTRL_GET_SHARED_CURVE: return tls1_shared_curve(s, larg); #endif case SSL_CTRL_SET_SIGALGS: return tls1_set_sigalgs(s->cert, parg, larg, 0); case SSL_CTRL_SET_SIGALGS_LIST: return tls1_set_sigalgs_list(s->cert, parg, 0); case SSL_CTRL_SET_CLIENT_SIGALGS: return tls1_set_sigalgs(s->cert, parg, larg, 1); case SSL_CTRL_SET_CLIENT_SIGALGS_LIST: return tls1_set_sigalgs_list(s->cert, parg, 1); case SSL_CTRL_GET_CLIENT_CERT_TYPES: { const unsigned char **pctype = parg; if (s->server || !s->s3->tmp.cert_req) return 0; if (s->cert->ctypes) { if (pctype) *pctype = s->cert->ctypes; return (int)s->cert->ctype_num; } if (pctype) *pctype = (unsigned char *)s->s3->tmp.ctype; return s->s3->tmp.ctype_num; } case SSL_CTRL_SET_CLIENT_CERT_TYPES: if (!s->server) return 0; return ssl3_set_req_cert_type(s->cert, parg, larg); case SSL_CTRL_BUILD_CERT_CHAIN: return ssl_build_cert_chain(s, NULL, larg); case SSL_CTRL_SET_VERIFY_CERT_STORE: return ssl_cert_set_cert_store(s->cert, parg, 0, larg); case SSL_CTRL_SET_CHAIN_CERT_STORE: return ssl_cert_set_cert_store(s->cert, parg, 1, larg); case SSL_CTRL_GET_PEER_SIGNATURE_NID: if (SSL_USE_SIGALGS(s)) { if (s->session) { const EVP_MD *sig; sig = s->s3->tmp.peer_md; if (sig) { *(int *)parg = EVP_MD_type(sig); return 1; } } return 0; } else return 0; case SSL_CTRL_GET_SERVER_TMP_KEY: if (s->server || !s->session) return 0; else { EVP_PKEY *ptmp; int rv = 0; #if !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC) if (s->s3->peer_dh_tmp == NULL && s->s3->peer_tmp == NULL) return 0; #endif ptmp = EVP_PKEY_new(); if (ptmp == NULL) return 0; #ifndef OPENSSL_NO_DH else if (s->s3->peer_dh_tmp != NULL) rv = EVP_PKEY_set1_DH(ptmp, s->s3->peer_dh_tmp); #endif #ifndef OPENSSL_NO_EC else if (s->s3->peer_tmp != NULL) rv = EVP_PKEY_set1_EC_KEY(ptmp, EVP_PKEY_get0_EC_KEY(s->s3->peer_tmp)); #endif if (rv) { *(EVP_PKEY **)parg = ptmp; return 1; } EVP_PKEY_free(ptmp); return 0; } #ifndef OPENSSL_NO_EC case SSL_CTRL_GET_EC_POINT_FORMATS: { SSL_SESSION *sess = s->session; const unsigned char **pformat = parg; if (!sess || !sess->tlsext_ecpointformatlist) return 0; *pformat = sess->tlsext_ecpointformatlist; return (int)sess->tlsext_ecpointformatlist_length; } #endif case SSL_CTRL_CHECK_PROTO_VERSION: if (s->version == s->ctx->method->version) return 1; if (s->ctx->method->version == TLS_method()->version) { #if TLS_MAX_VERSION != TLS1_2_VERSION # error Code needs update for TLS_method() support beyond TLS1_2_VERSION. #endif if (!(s->options & SSL_OP_NO_TLSv1_2)) return s->version == TLS1_2_VERSION; if (!(s->options & SSL_OP_NO_TLSv1_1)) return s->version == TLS1_1_VERSION; if (!(s->options & SSL_OP_NO_TLSv1)) return s->version == TLS1_VERSION; if (!(s->options & SSL_OP_NO_SSLv3)) return s->version == SSL3_VERSION; } return 0; default: break; } return (ret); }","- if (!(s->options & SSL_OP_SINGLE_DH_USE)) {
- if (!DH_generate_key(dh)) {
- DH_free(dh);
- SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);
- return (ret);
- }
- }","long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg) { int ret = 0; switch (cmd) { case SSL_CTRL_GET_SESSION_REUSED: ret = s->hit; break; case SSL_CTRL_GET_CLIENT_CERT_REQUEST: break; case SSL_CTRL_GET_NUM_RENEGOTIATIONS: ret = s->s3->num_renegotiations; break; case SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS: ret = s->s3->num_renegotiations; s->s3->num_renegotiations = 0; break; case SSL_CTRL_GET_TOTAL_RENEGOTIATIONS: ret = s->s3->total_renegotiations; break; case SSL_CTRL_GET_FLAGS: ret = (int)(s->s3->flags); break; #ifndef OPENSSL_NO_DH case SSL_CTRL_SET_TMP_DH: { DH *dh = (DH *)parg; if (dh == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER); return (ret); } if (!ssl_security(s, SSL_SECOP_TMP_DH, DH_security_bits(dh), 0, dh)) { SSLerr(SSL_F_SSL3_CTRL, SSL_R_DH_KEY_TOO_SMALL); return (ret); } if ((dh = DHparams_dup(dh)) == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB); return (ret); } DH_free(s->cert->dh_tmp); s->cert->dh_tmp = dh; ret = 1; } break; case SSL_CTRL_SET_TMP_DH_CB: { SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return (ret); } case SSL_CTRL_SET_DH_AUTO: s->cert->dh_tmp_auto = larg; return 1; #endif #ifndef OPENSSL_NO_EC case SSL_CTRL_SET_TMP_ECDH: { const EC_GROUP *group = NULL; int nid; if (parg == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER); return 0; } group = EC_KEY_get0_group((const EC_KEY *)parg); if (group == NULL) { SSLerr(SSL_F_SSL3_CTRL, EC_R_MISSING_PARAMETERS); return 0; } nid = EC_GROUP_get_curve_name(group); if (nid == NID_undef) return 0; return tls1_set_curves(&s->tlsext_ellipticcurvelist, &s->tlsext_ellipticcurvelist_length, &nid, 1); } break; #endif case SSL_CTRL_SET_TLSEXT_HOSTNAME: if (larg == TLSEXT_NAMETYPE_host_name) { OPENSSL_free(s->tlsext_hostname); s->tlsext_hostname = NULL; ret = 1; if (parg == NULL) break; if (strlen((char *)parg) > TLSEXT_MAXLEN_host_name) { SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME); return 0; } if ((s->tlsext_hostname = OPENSSL_strdup((char *)parg)) == NULL) { SSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR); return 0; } } else { SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE); return 0; } break; case SSL_CTRL_SET_TLSEXT_DEBUG_ARG: s->tlsext_debug_arg = parg; ret = 1; break; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE: s->tlsext_status_type = larg; ret = 1; break; case SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS: *(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts; ret = 1; break; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS: s->tlsext_ocsp_exts = parg; ret = 1; break; case SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS: *(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids; ret = 1; break; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS: s->tlsext_ocsp_ids = parg; ret = 1; break; case SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP: *(unsigned char **)parg = s->tlsext_ocsp_resp; return s->tlsext_ocsp_resplen; case SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP: OPENSSL_free(s->tlsext_ocsp_resp); s->tlsext_ocsp_resp = parg; s->tlsext_ocsp_resplen = larg; ret = 1; break; #ifndef OPENSSL_NO_HEARTBEATS case SSL_CTRL_TLS_EXT_SEND_HEARTBEAT: if (SSL_IS_DTLS(s)) ret = dtls1_heartbeat(s); else ret = tls1_heartbeat(s); break; case SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING: ret = s->tlsext_hb_pending; break; case SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS: if (larg) s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS; else s->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS; ret = 1; break; #endif case SSL_CTRL_CHAIN: if (larg) return ssl_cert_set1_chain(s, NULL, (STACK_OF(X509) *)parg); else return ssl_cert_set0_chain(s, NULL, (STACK_OF(X509) *)parg); case SSL_CTRL_CHAIN_CERT: if (larg) return ssl_cert_add1_chain_cert(s, NULL, (X509 *)parg); else return ssl_cert_add0_chain_cert(s, NULL, (X509 *)parg); case SSL_CTRL_GET_CHAIN_CERTS: *(STACK_OF(X509) **)parg = s->cert->key->chain; break; case SSL_CTRL_SELECT_CURRENT_CERT: return ssl_cert_select_current(s->cert, (X509 *)parg); case SSL_CTRL_SET_CURRENT_CERT: if (larg == SSL_CERT_SET_SERVER) { CERT_PKEY *cpk; const SSL_CIPHER *cipher; if (!s->server) return 0; cipher = s->s3->tmp.new_cipher; if (!cipher) return 0; if (cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP)) return 2; cpk = ssl_get_server_send_pkey(s); if (!cpk) return 0; s->cert->key = cpk; return 1; } return ssl_cert_set_current(s->cert, larg); #ifndef OPENSSL_NO_EC case SSL_CTRL_GET_CURVES: { unsigned char *clist; size_t clistlen; if (!s->session) return 0; clist = s->session->tlsext_ellipticcurvelist; clistlen = s->session->tlsext_ellipticcurvelist_length / 2; if (parg) { size_t i; int *cptr = parg; unsigned int cid, nid; for (i = 0; i < clistlen; i++) { n2s(clist, cid); nid = tls1_ec_curve_id2nid(cid); if (nid != 0) cptr[i] = nid; else cptr[i] = TLSEXT_nid_unknown | cid; } } return (int)clistlen; } case SSL_CTRL_SET_CURVES: return tls1_set_curves(&s->tlsext_ellipticcurvelist, &s->tlsext_ellipticcurvelist_length, parg, larg); case SSL_CTRL_SET_CURVES_LIST: return tls1_set_curves_list(&s->tlsext_ellipticcurvelist, &s->tlsext_ellipticcurvelist_length, parg); case SSL_CTRL_GET_SHARED_CURVE: return tls1_shared_curve(s, larg); #endif case SSL_CTRL_SET_SIGALGS: return tls1_set_sigalgs(s->cert, parg, larg, 0); case SSL_CTRL_SET_SIGALGS_LIST: return tls1_set_sigalgs_list(s->cert, parg, 0); case SSL_CTRL_SET_CLIENT_SIGALGS: return tls1_set_sigalgs(s->cert, parg, larg, 1); case SSL_CTRL_SET_CLIENT_SIGALGS_LIST: return tls1_set_sigalgs_list(s->cert, parg, 1); case SSL_CTRL_GET_CLIENT_CERT_TYPES: { const unsigned char **pctype = parg; if (s->server || !s->s3->tmp.cert_req) return 0; if (s->cert->ctypes) { if (pctype) *pctype = s->cert->ctypes; return (int)s->cert->ctype_num; } if (pctype) *pctype = (unsigned char *)s->s3->tmp.ctype; return s->s3->tmp.ctype_num; } case SSL_CTRL_SET_CLIENT_CERT_TYPES: if (!s->server) return 0; return ssl3_set_req_cert_type(s->cert, parg, larg); case SSL_CTRL_BUILD_CERT_CHAIN: return ssl_build_cert_chain(s, NULL, larg); case SSL_CTRL_SET_VERIFY_CERT_STORE: return ssl_cert_set_cert_store(s->cert, parg, 0, larg); case SSL_CTRL_SET_CHAIN_CERT_STORE: return ssl_cert_set_cert_store(s->cert, parg, 1, larg); case SSL_CTRL_GET_PEER_SIGNATURE_NID: if (SSL_USE_SIGALGS(s)) { if (s->session) { const EVP_MD *sig; sig = s->s3->tmp.peer_md; if (sig) { *(int *)parg = EVP_MD_type(sig); return 1; } } return 0; } else return 0; case SSL_CTRL_GET_SERVER_TMP_KEY: if (s->server || !s->session) return 0; else { EVP_PKEY *ptmp; int rv = 0; #if !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC) if (s->s3->peer_dh_tmp == NULL && s->s3->peer_tmp == NULL) return 0; #endif ptmp = EVP_PKEY_new(); if (ptmp == NULL) return 0; #ifndef OPENSSL_NO_DH else if (s->s3->peer_dh_tmp != NULL) rv = EVP_PKEY_set1_DH(ptmp, s->s3->peer_dh_tmp); #endif #ifndef OPENSSL_NO_EC else if (s->s3->peer_tmp != NULL) rv = EVP_PKEY_set1_EC_KEY(ptmp, EVP_PKEY_get0_EC_KEY(s->s3->peer_tmp)); #endif if (rv) { *(EVP_PKEY **)parg = ptmp; return 1; } EVP_PKEY_free(ptmp); return 0; } #ifndef OPENSSL_NO_EC case SSL_CTRL_GET_EC_POINT_FORMATS: { SSL_SESSION *sess = s->session; const unsigned char **pformat = parg; if (!sess || !sess->tlsext_ecpointformatlist) return 0; *pformat = sess->tlsext_ecpointformatlist; return (int)sess->tlsext_ecpointformatlist_length; } #endif case SSL_CTRL_CHECK_PROTO_VERSION: if (s->version == s->ctx->method->version) return 1; if (s->ctx->method->version == TLS_method()->version) { #if TLS_MAX_VERSION != TLS1_2_VERSION # error Code needs update for TLS_method() support beyond TLS1_2_VERSION. #endif if (!(s->options & SSL_OP_NO_TLSv1_2)) return s->version == TLS1_2_VERSION; if (!(s->options & SSL_OP_NO_TLSv1_1)) return s->version == TLS1_1_VERSION; if (!(s->options & SSL_OP_NO_TLSv1)) return s->version == TLS1_VERSION; if (!(s->options & SSL_OP_NO_SSLv3)) return s->version == SSL3_VERSION; } return 0; default: break; } return (ret); }"
925----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_32a15841b75f9e0c9941c0741fed329559510d9d_1.json----configure_filtergraph,static int configure_filtergraph(FilterGraph *fg) { <S2SV_StartVul> return fg->graph_desc ? configure_complex_filter(fg) : configure_video_filters(fg); <S2SV_EndVul> },"- return fg->graph_desc ? configure_complex_filter(fg) : configure_video_filters(fg);
+ return fg->graph_desc ? configure_complex_filter(fg) :
+ configure_simple_filtergraph(fg);",static int configure_filtergraph(FilterGraph *fg) { return fg->graph_desc ? configure_complex_filter(fg) : configure_simple_filtergraph(fg); }
8017----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_b472f526088b7f473acfea91592c41e19b7ffb66_1.json----expand_rle_row,"static int expand_rle_row(SgiState *s, uint8_t *out_buf, <S2SV_StartVul> uint8_t *out_end, int pixelstride) <S2SV_EndVul> { unsigned char pixel, count; unsigned char *orig = out_buf; while (1) { if (bytestream2_get_bytes_left(&s->g) < 1) return AVERROR_INVALIDDATA; pixel = bytestream2_get_byteu(&s->g); if (!(count = (pixel & 0x7f))) { return (out_buf - orig) / pixelstride; } <S2SV_StartVul> if(out_buf + pixelstride * count >= out_end) return -1; <S2SV_EndVul> if (pixel & 0x80) { while (count--) { *out_buf = bytestream2_get_byte(&s->g); out_buf += pixelstride; } } else { pixel = bytestream2_get_byte(&s->g); while (count--) { *out_buf = pixel; out_buf += pixelstride; } } } }","- uint8_t *out_end, int pixelstride)
- if(out_buf + pixelstride * count >= out_end) return -1;
+ int len, int pixelstride)
+ if (pixelstride * (count - 1) >= len) {
+ av_log(s->avctx, AV_LOG_ERROR, ""Invalid pixel count.\n"");
+ return AVERROR_INVALIDDATA;
+ }","static int expand_rle_row(SgiState *s, uint8_t *out_buf, int len, int pixelstride) { unsigned char pixel, count; unsigned char *orig = out_buf; while (1) { if (bytestream2_get_bytes_left(&s->g) < 1) return AVERROR_INVALIDDATA; pixel = bytestream2_get_byteu(&s->g); if (!(count = (pixel & 0x7f))) { return (out_buf - orig) / pixelstride; } if (pixelstride * (count - 1) >= len) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid pixel count.\n""); return AVERROR_INVALIDDATA; } if (pixel & 0x80) { while (count--) { *out_buf = bytestream2_get_byte(&s->g); out_buf += pixelstride; } } else { pixel = bytestream2_get_byte(&s->g); while (count--) { *out_buf = pixel; out_buf += pixelstride; } } } }"
5700----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2b658d9bdc55ecf08ba4d84b8f02b1f5b663b0b2_1.json----gen_fcpublish_stream,"<S2SV_StartVul> static void gen_fcpublish_stream(URLContext *s, RTMPContext *rt) <S2SV_EndVul> { RTMPPacket pkt; uint8_t *p; <S2SV_StartVul> ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, <S2SV_EndVul> <S2SV_StartVul> 25 + strlen(rt->playpath)); <S2SV_EndVul> av_log(s, AV_LOG_DEBUG, ""FCPublish stream...\n""); p = pkt.data; ff_amf_write_string(&p, ""FCPublish""); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_amf_write_string(&p, rt->playpath); ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); }","- static void gen_fcpublish_stream(URLContext *s, RTMPContext *rt)
- ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0,
- 25 + strlen(rt->playpath));
+ static int gen_fcpublish_stream(URLContext *s, RTMPContext *rt)
+ int ret;
+ if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,
+ 0, 25 + strlen(rt->playpath))) < 0)
+ return ret;
+ return 0;","static int gen_fcpublish_stream(URLContext *s, RTMPContext *rt) { RTMPPacket pkt; uint8_t *p; int ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 25 + strlen(rt->playpath))) < 0) return ret; av_log(s, AV_LOG_DEBUG, ""FCPublish stream...\n""); p = pkt.data; ff_amf_write_string(&p, ""FCPublish""); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_amf_write_string(&p, rt->playpath); ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); return 0; }"
10444----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_05ef78b242f98429990cfd21e2820db71c6b964b_1.json----ssl3_get_cert_verify,"int ssl3_get_cert_verify(SSL *s) { EVP_PKEY *pkey=NULL; unsigned char *p; int al,ok,ret=0; long n; int type=0,i,j; X509 *peer; n=s->method->ssl_get_message(s, SSL3_ST_SR_CERT_VRFY_A, SSL3_ST_SR_CERT_VRFY_B, -1, 514, &ok); if (!ok) return((int)n); if (s->session->peer != NULL) { peer=s->session->peer; pkey=X509_get_pubkey(peer); type=X509_certificate_type(peer,pkey); } else { peer=NULL; pkey=NULL; } if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY) { s->s3->tmp.reuse_message=1; if ((peer != NULL) && (type | EVP_PKT_SIGN)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE); goto f_err; } ret=1; goto end; } if (peer == NULL) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } if (!(type & EVP_PKT_SIGN)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE); al=SSL_AD_ILLEGAL_PARAMETER; goto f_err; } if (s->s3->change_cipher_spec) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } p=(unsigned char *)s->init_msg; <S2SV_StartVul> n2s(p,i); <S2SV_EndVul> <S2SV_StartVul> n-=2; <S2SV_EndVul> <S2SV_StartVul> if (i > n) <S2SV_EndVul> { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH); <S2SV_EndVul> <S2SV_StartVul> al=SSL_AD_DECODE_ERROR; <S2SV_EndVul> <S2SV_StartVul> goto f_err; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> j=EVP_PKEY_size(pkey); if ((i > j) || (n > j) || (n <= 0)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE); al=SSL_AD_DECODE_ERROR; goto f_err; } #ifndef OPENSSL_NO_RSA if (pkey->type == EVP_PKEY_RSA) { i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, pkey->pkey.rsa); if (i < 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT); goto f_err; } if (i == 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_DSA if (pkey->type == EVP_PKEY_DSA) { j=DSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_ECDSA if (pkey->type == EVP_PKEY_EC) { j=ECDSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else #endif { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR); al=SSL_AD_UNSUPPORTED_CERTIFICATE; goto f_err; } ret=1; if (0) { f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); } end: EVP_PKEY_free(pkey); return(ret); }","- n2s(p,i);
- n-=2;
- if (i > n)
- SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
- al=SSL_AD_DECODE_ERROR;
- goto f_err;
- }
+ if (n==64 && (pkey->type==NID_id_GostR3410_94 ||
+ pkey->type == NID_id_GostR3410_2001) )
+ i=64;
+ }
+ else
+ {
+ n2s(p,i);
+ n-=2;
+ if (i > n)
+ {
+ SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);
+ al=SSL_AD_DECODE_ERROR;
+ goto f_err;
+ }
+ }
+ if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)
+ { unsigned char signature[64];
+ int idx;
+ EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);
+ EVP_PKEY_verify_init(pctx);
+ if (i!=64) {
+ fprintf(stderr,""GOST signature length is %d"",i);
+ }
+ for (idx=0;idx<64;idx++) {
+ signature[63-idx]=p[idx];
+ }
+ j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);
+ EVP_PKEY_CTX_free(pctx);
+ if (j<=0)
+ {
+ al=SSL_AD_DECRYPT_ERROR;
+ SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,
+ SSL_R_BAD_ECDSA_SIGNATURE);
+ goto f_err;
+ }
+ }
+ else","int ssl3_get_cert_verify(SSL *s) { EVP_PKEY *pkey=NULL; unsigned char *p; int al,ok,ret=0; long n; int type=0,i,j; X509 *peer; n=s->method->ssl_get_message(s, SSL3_ST_SR_CERT_VRFY_A, SSL3_ST_SR_CERT_VRFY_B, -1, 514, &ok); if (!ok) return((int)n); if (s->session->peer != NULL) { peer=s->session->peer; pkey=X509_get_pubkey(peer); type=X509_certificate_type(peer,pkey); } else { peer=NULL; pkey=NULL; } if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY) { s->s3->tmp.reuse_message=1; if ((peer != NULL) && (type | EVP_PKT_SIGN)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE); goto f_err; } ret=1; goto end; } if (peer == NULL) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } if (!(type & EVP_PKT_SIGN)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE); al=SSL_AD_ILLEGAL_PARAMETER; goto f_err; } if (s->s3->change_cipher_spec) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } p=(unsigned char *)s->init_msg; if (n==64 && (pkey->type==NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) ) { i=64; } else { n2s(p,i); n-=2; if (i > n) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH); al=SSL_AD_DECODE_ERROR; goto f_err; } } j=EVP_PKEY_size(pkey); if ((i > j) || (n > j) || (n <= 0)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE); al=SSL_AD_DECODE_ERROR; goto f_err; } #ifndef OPENSSL_NO_RSA if (pkey->type == EVP_PKEY_RSA) { i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, pkey->pkey.rsa); if (i < 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT); goto f_err; } if (i == 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_DSA if (pkey->type == EVP_PKEY_DSA) { j=DSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_ECDSA if (pkey->type == EVP_PKEY_EC) { j=ECDSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else #endif if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) { unsigned char signature[64]; int idx; EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL); EVP_PKEY_verify_init(pctx); if (i!=64) { fprintf(stderr,""GOST signature length is %d"",i); } for (idx=0;idx<64;idx++) { signature[63-idx]=p[idx]; } j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32); EVP_PKEY_CTX_free(pctx); if (j<=0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR); al=SSL_AD_UNSUPPORTED_CERTIFICATE; goto f_err; } ret=1; if (0) { f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); } end: EVP_PKEY_free(pkey); return(ret); }"
10147----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_b6cd647ff834d1ae91a81e2ed2f692ac9726d53f_1.json----ngx_resolve_name_done,"void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx) { <S2SV_StartVul> uint32_t hash; <S2SV_EndVul> ngx_resolver_t *r; ngx_resolver_ctx_t *w, **p; ngx_resolver_node_t *rn; r = ctx->resolver; ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0, ""resolve name done: %i"", ctx->state); if (ctx->quick) { return; } if (ctx->event && ctx->event->timer_set) { ngx_del_timer(ctx->event); } if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOLVE_TIMEDOUT) { <S2SV_StartVul> hash = ngx_crc32_short(ctx->name.data, ctx->name.len); <S2SV_EndVul> <S2SV_StartVul> rn = ngx_resolver_lookup_name(r, &ctx->name, hash); <S2SV_EndVul> if (rn) { p = &rn->waiting; w = rn->waiting; while (w) { if (w == ctx) { *p = w->next; goto done; } p = &w->next; w = w->next; } } ngx_log_error(NGX_LOG_ALERT, r->log, 0, ""could not cancel %V resolving"", &ctx->name); } done: ngx_resolver_expire(r, &r->name_rbtree, &r->name_expire_queue); if (ctx->event) { ngx_resolver_free_locked(r, ctx->event); } ngx_resolver_free_locked(r, ctx); if (r->event->timer_set && ngx_resolver_resend_empty(r)) { ngx_del_timer(r->event); } }","- uint32_t hash;
- hash = ngx_crc32_short(ctx->name.data, ctx->name.len);
- rn = ngx_resolver_lookup_name(r, &ctx->name, hash);
+ rn = ctx->node;","void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx) { ngx_resolver_t *r; ngx_resolver_ctx_t *w, **p; ngx_resolver_node_t *rn; r = ctx->resolver; ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0, ""resolve name done: %i"", ctx->state); if (ctx->quick) { return; } if (ctx->event && ctx->event->timer_set) { ngx_del_timer(ctx->event); } if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOLVE_TIMEDOUT) { rn = ctx->node; if (rn) { p = &rn->waiting; w = rn->waiting; while (w) { if (w == ctx) { *p = w->next; goto done; } p = &w->next; w = w->next; } } ngx_log_error(NGX_LOG_ALERT, r->log, 0, ""could not cancel %V resolving"", &ctx->name); } done: ngx_resolver_expire(r, &r->name_rbtree, &r->name_expire_queue); if (ctx->event) { ngx_resolver_free_locked(r, ctx->event); } ngx_resolver_free_locked(r, ctx); if (r->event->timer_set && ngx_resolver_resend_empty(r)) { ngx_del_timer(r->event); } }"
9299----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_17879c080cc0011b48d2e921ff7bc5a8b13c9919_1.json----TIFFScanlineSize,"tmsize_t TIFFScanlineSize(TIFF* tif) { static const char module[] = ""TIFFScanlineSize""; uint64 m; <S2SV_StartVul> tmsize_t n; <S2SV_EndVul> m=TIFFScanlineSize64(tif); <S2SV_StartVul> n=(tmsize_t)m; <S2SV_EndVul> <S2SV_StartVul> if ((uint64)n!=m) { <S2SV_EndVul> <S2SV_StartVul> TIFFErrorExt(tif->tif_clientdata,module,""Integer arithmetic overflow""); <S2SV_EndVul> <S2SV_StartVul> n=0; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return(n); <S2SV_EndVul> }","- tmsize_t n;
- n=(tmsize_t)m;
- if ((uint64)n!=m) {
- TIFFErrorExt(tif->tif_clientdata,module,""Integer arithmetic overflow"");
- n=0;
- }
- return(n);
+ return _TIFFCastUInt64ToSSize(tif, m, module);","tmsize_t TIFFScanlineSize(TIFF* tif) { static const char module[] = ""TIFFScanlineSize""; uint64 m; m=TIFFScanlineSize64(tif); return _TIFFCastUInt64ToSSize(tif, m, module); }"
660----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_23a70a5448dce09e7e2d832bdcb5a7ee403e922b_1.json----encode_quant_matrix,"static void encode_quant_matrix(VC2EncContext *s) { <S2SV_StartVul> int level, custom_quant_matrix = 0; <S2SV_EndVul> <S2SV_StartVul> if (s->wavelet_depth > 4 || s->quant_matrix != VC2_QM_DEF) <S2SV_EndVul> <S2SV_StartVul> custom_quant_matrix = 1; <S2SV_EndVul> <S2SV_StartVul> put_bits(&s->pb, 1, custom_quant_matrix); <S2SV_EndVul> <S2SV_StartVul> if (custom_quant_matrix) { <S2SV_EndVul> <S2SV_StartVul> init_custom_qm(s); <S2SV_EndVul> put_vc2_ue_uint(&s->pb, s->quant[0][0]); for (level = 0; level < s->wavelet_depth; level++) { put_vc2_ue_uint(&s->pb, s->quant[level][1]); put_vc2_ue_uint(&s->pb, s->quant[level][2]); put_vc2_ue_uint(&s->pb, s->quant[level][3]); } <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> for (level = 0; level < s->wavelet_depth; level++) { <S2SV_EndVul> <S2SV_StartVul> s->quant[level][0] = ff_dirac_default_qmat[s->wavelet_idx][level][0]; <S2SV_EndVul> <S2SV_StartVul> s->quant[level][1] = ff_dirac_default_qmat[s->wavelet_idx][level][1]; <S2SV_EndVul> <S2SV_StartVul> s->quant[level][2] = ff_dirac_default_qmat[s->wavelet_idx][level][2]; <S2SV_EndVul> <S2SV_StartVul> s->quant[level][3] = ff_dirac_default_qmat[s->wavelet_idx][level][3]; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } }","- int level, custom_quant_matrix = 0;
- if (s->wavelet_depth > 4 || s->quant_matrix != VC2_QM_DEF)
- custom_quant_matrix = 1;
- put_bits(&s->pb, 1, custom_quant_matrix);
- if (custom_quant_matrix) {
- init_custom_qm(s);
- } else {
- for (level = 0; level < s->wavelet_depth; level++) {
- s->quant[level][0] = ff_dirac_default_qmat[s->wavelet_idx][level][0];
- s->quant[level][1] = ff_dirac_default_qmat[s->wavelet_idx][level][1];
- s->quant[level][2] = ff_dirac_default_qmat[s->wavelet_idx][level][2];
- s->quant[level][3] = ff_dirac_default_qmat[s->wavelet_idx][level][3];
- }
+ int level;
+ put_bits(&s->pb, 1, s->custom_quant_matrix);
+ if (s->custom_quant_matrix) {","static void encode_quant_matrix(VC2EncContext *s) { int level; put_bits(&s->pb, 1, s->custom_quant_matrix); if (s->custom_quant_matrix) { put_vc2_ue_uint(&s->pb, s->quant[0][0]); for (level = 0; level < s->wavelet_depth; level++) { put_vc2_ue_uint(&s->pb, s->quant[level][1]); put_vc2_ue_uint(&s->pb, s->quant[level][2]); put_vc2_ue_uint(&s->pb, s->quant[level][3]); } } }"
10952----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_180c1b1bc6285945477e27e305f38e94f28fb22f_1.json----ssl3_get_message,"long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok) { unsigned char *p; unsigned long l; long n; int i,al; if (s->s3->tmp.reuse_message) { s->s3->tmp.reuse_message=0; if ((mt >= 0) && (s->s3->tmp.message_type != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } *ok=1; return((int)s->s3->tmp.message_size); } p=(unsigned char *)s->init_buf->data; <S2SV_StartVul> if (s->state == st1) <S2SV_EndVul> { <S2SV_StartVul> i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num], <S2SV_EndVul> <S2SV_StartVul> 4-s->init_num); <S2SV_EndVul> <S2SV_StartVul> if (i < (4-s->init_num)) <S2SV_EndVul> { <S2SV_StartVul> *ok=0; <S2SV_EndVul> <S2SV_StartVul> return(ssl3_part_read(s,i)); <S2SV_EndVul> } if ((mt >= 0) && (*p != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } if((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) && (st1 == SSL3_ST_SR_CERT_A) && (stn == SSL3_ST_SR_CERT_B)) { ssl3_init_finished_mac(s); ssl3_finish_mac(s, p + s->init_num, i); } s->s3->tmp.message_type= *(p++); n2l3(p,l); if (l > (unsigned long)max) { al=SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE); goto f_err; } if (l && !BUF_MEM_grow(s->init_buf,(int)l)) { SSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB); goto err; } s->s3->tmp.message_size=l; s->state=stn; s->init_num=0; } p=(unsigned char *)s->init_buf->data; n=s->s3->tmp.message_size; <S2SV_StartVul> if (n > 0) <S2SV_EndVul> { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n); <S2SV_StartVul> if (i != (int)n) <S2SV_EndVul> { <S2SV_StartVul> *ok=0; <S2SV_EndVul> <S2SV_StartVul> return(ssl3_part_read(s,i)); <S2SV_EndVul> } } *ok=1; <S2SV_StartVul> return(n); <S2SV_EndVul> f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); err: *ok=0; return(-1); }","- if (s->state == st1)
- i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],
- 4-s->init_num);
- if (i < (4-s->init_num))
- return(ssl3_part_read(s,i));
- if (n > 0)
- if (i != (int)n)
- return(ssl3_part_read(s,i));
- return(n);
+ while (s->init_num < 4)
+ i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],
+ 4-s->init_num);
+ if (i <= 0)
+ {
+ s->rwstate=SSL_READING;
+ return i;
+ }
+ s->init_num+=i;
+ while (n > 0)
+ if (i <= 0)
+ s->rwstate=SSL_READING;
+ return i;
+ s->init_num += i;
+ n -= i;
+ return s->init_num;","long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok) { unsigned char *p; unsigned long l; long n; int i,al; if (s->s3->tmp.reuse_message) { s->s3->tmp.reuse_message=0; if ((mt >= 0) && (s->s3->tmp.message_type != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } *ok=1; return((int)s->s3->tmp.message_size); } p=(unsigned char *)s->init_buf->data; if (s->state == st1) { while (s->init_num < 4) { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num], 4-s->init_num); if (i <= 0) { s->rwstate=SSL_READING; *ok = 0; return i; } s->init_num+=i; } if ((mt >= 0) && (*p != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } if((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) && (st1 == SSL3_ST_SR_CERT_A) && (stn == SSL3_ST_SR_CERT_B)) { ssl3_init_finished_mac(s); ssl3_finish_mac(s, p + s->init_num, i); } s->s3->tmp.message_type= *(p++); n2l3(p,l); if (l > (unsigned long)max) { al=SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE); goto f_err; } if (l && !BUF_MEM_grow(s->init_buf,(int)l)) { SSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB); goto err; } s->s3->tmp.message_size=l; s->state=stn; s->init_num=0; } p=(unsigned char *)s->init_buf->data; n=s->s3->tmp.message_size; while (n > 0) { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n); if (i <= 0) { s->rwstate=SSL_READING; *ok = 0; return i; } s->init_num += i; n -= i; } *ok=1; return s->init_num; f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); err: *ok=0; return(-1); }"
10337----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0299162b2ec5492f9506b87d8e7dcc3c94101797_1.json----SRP_create_verifier,"char *SRP_create_verifier(const char *user, const char *pass, char **salt, char **verifier, const char *N, const char *g) { int len; char *result = NULL, *vf = NULL; const BIGNUM *N_bn = NULL, *g_bn = NULL; BIGNUM *N_bn_alloc = NULL, *g_bn_alloc = NULL, *s = NULL, *v = NULL; unsigned char tmp[MAX_LEN]; unsigned char tmp2[MAX_LEN]; char *defgNid = NULL; int vfsize = 0; if ((user == NULL) || (pass == NULL) || (salt == NULL) || (verifier == NULL)) goto err; if (N) { <S2SV_StartVul> if ((len = t_fromb64(tmp, N)) == 0) <S2SV_EndVul> goto err; N_bn_alloc = BN_bin2bn(tmp, len, NULL); N_bn = N_bn_alloc; <S2SV_StartVul> if ((len = t_fromb64(tmp, g)) == 0) <S2SV_EndVul> goto err; g_bn_alloc = BN_bin2bn(tmp, len, NULL); g_bn = g_bn_alloc; defgNid = ""*""; } else { SRP_gN *gN = SRP_get_gN_by_id(g, NULL); if (gN == NULL) goto err; N_bn = gN->N; g_bn = gN->g; defgNid = gN->id; } if (*salt == NULL) { if (RAND_bytes(tmp2, SRP_RANDOM_SALT_LEN) <= 0) goto err; s = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL); } else { <S2SV_StartVul> if ((len = t_fromb64(tmp2, *salt)) == 0) <S2SV_EndVul> goto err; s = BN_bin2bn(tmp2, len, NULL); } if (!SRP_create_verifier_BN(user, pass, &s, &v, N_bn, g_bn)) goto err; BN_bn2bin(v, tmp); vfsize = BN_num_bytes(v) * 2; if (((vf = OPENSSL_malloc(vfsize)) == NULL)) goto err; t_tob64(vf, tmp, BN_num_bytes(v)); if (*salt == NULL) { char *tmp_salt; if ((tmp_salt = OPENSSL_malloc(SRP_RANDOM_SALT_LEN * 2)) == NULL) { goto err; } t_tob64(tmp_salt, tmp2, SRP_RANDOM_SALT_LEN); *salt = tmp_salt; } *verifier = vf; vf = NULL; result = defgNid; err: BN_free(N_bn_alloc); BN_free(g_bn_alloc); OPENSSL_clear_free(vf, vfsize); BN_clear_free(s); BN_clear_free(v); return result; }","- if ((len = t_fromb64(tmp, N)) == 0)
- if ((len = t_fromb64(tmp, g)) == 0)
- if ((len = t_fromb64(tmp2, *salt)) == 0)
+ if ((len = t_fromb64(tmp, sizeof(tmp), N)) <= 0)
+ if ((len = t_fromb64(tmp, sizeof(tmp) ,g)) <= 0)
+ if ((len = t_fromb64(tmp2, sizeof(tmp2), *salt)) <= 0)","char *SRP_create_verifier(const char *user, const char *pass, char **salt, char **verifier, const char *N, const char *g) { int len; char *result = NULL, *vf = NULL; const BIGNUM *N_bn = NULL, *g_bn = NULL; BIGNUM *N_bn_alloc = NULL, *g_bn_alloc = NULL, *s = NULL, *v = NULL; unsigned char tmp[MAX_LEN]; unsigned char tmp2[MAX_LEN]; char *defgNid = NULL; int vfsize = 0; if ((user == NULL) || (pass == NULL) || (salt == NULL) || (verifier == NULL)) goto err; if (N) { if ((len = t_fromb64(tmp, sizeof(tmp), N)) <= 0) goto err; N_bn_alloc = BN_bin2bn(tmp, len, NULL); N_bn = N_bn_alloc; if ((len = t_fromb64(tmp, sizeof(tmp) ,g)) <= 0) goto err; g_bn_alloc = BN_bin2bn(tmp, len, NULL); g_bn = g_bn_alloc; defgNid = ""*""; } else { SRP_gN *gN = SRP_get_gN_by_id(g, NULL); if (gN == NULL) goto err; N_bn = gN->N; g_bn = gN->g; defgNid = gN->id; } if (*salt == NULL) { if (RAND_bytes(tmp2, SRP_RANDOM_SALT_LEN) <= 0) goto err; s = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL); } else { if ((len = t_fromb64(tmp2, sizeof(tmp2), *salt)) <= 0) goto err; s = BN_bin2bn(tmp2, len, NULL); } if (!SRP_create_verifier_BN(user, pass, &s, &v, N_bn, g_bn)) goto err; BN_bn2bin(v, tmp); vfsize = BN_num_bytes(v) * 2; if (((vf = OPENSSL_malloc(vfsize)) == NULL)) goto err; t_tob64(vf, tmp, BN_num_bytes(v)); if (*salt == NULL) { char *tmp_salt; if ((tmp_salt = OPENSSL_malloc(SRP_RANDOM_SALT_LEN * 2)) == NULL) { goto err; } t_tob64(tmp_salt, tmp2, SRP_RANDOM_SALT_LEN); *salt = tmp_salt; } *verifier = vf; vf = NULL; result = defgNid; err: BN_free(N_bn_alloc); BN_free(g_bn_alloc); OPENSSL_clear_free(vf, vfsize); BN_clear_free(s); BN_clear_free(v); return result; }"
9011----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f191399a0e841d780e74bf5d1312ca5dad782b32_1.json----decode_cabac_field_decoding_flag,"static int decode_cabac_field_decoding_flag(H264Context *h) { <S2SV_StartVul> MpegEncContext * const s = &h->s; <S2SV_EndVul> <S2SV_StartVul> const long mbb_xy = h->mb_xy - 2L*s->mb_stride; <S2SV_EndVul> unsigned long ctx = 0; <S2SV_StartVul> ctx += h->mb_field_decoding_flag & !!s->mb_x; <S2SV_StartVul> ctx += (s->current_picture.f.mb_type[mbb_xy] >> 7) & (h->slice_table[mbb_xy] == h->slice_num); <S2SV_EndVul> return get_cabac_noinline( &h->cabac, &(h->cabac_state+70)[ctx] ); }","- MpegEncContext * const s = &h->s;
- const long mbb_xy = h->mb_xy - 2L*s->mb_stride;
- ctx += h->mb_field_decoding_flag & !!s->mb_x; //for FMO:(s->current_picture.f.mb_type[mba_xy] >> 7) & (h->slice_table[mba_xy] == h->slice_num);
- ctx += (s->current_picture.f.mb_type[mbb_xy] >> 7) & (h->slice_table[mbb_xy] == h->slice_num);
+ const long mbb_xy = h->mb_xy - 2L*h->mb_stride;
+ ctx += h->mb_field_decoding_flag & !!h->mb_x; //for FMO:(s->current_picture.f.mb_type[mba_xy] >> 7) & (h->slice_table[mba_xy] == h->slice_num);
+ ctx += (h->cur_pic.f.mb_type[mbb_xy] >> 7) & (h->slice_table[mbb_xy] == h->slice_num);","static int decode_cabac_field_decoding_flag(H264Context *h) { const long mbb_xy = h->mb_xy - 2L*h->mb_stride; unsigned long ctx = 0; ctx += h->mb_field_decoding_flag & !!h->mb_x; ctx += (h->cur_pic.f.mb_type[mbb_xy] >> 7) & (h->slice_table[mbb_xy] == h->slice_num); return get_cabac_noinline( &h->cabac, &(h->cabac_state+70)[ctx] ); }"
11086----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1cb542048f9d3e79ff9fed2bd43202f97e770b5c_1.json----RSA_new_method,"RSA *RSA_new_method(ENGINE *engine) { RSA *ret; ret = OPENSSL_zalloc(sizeof(*ret)); if (ret == NULL) { RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_MALLOC_FAILURE); return NULL; } ret->meth = RSA_get_default_method(); #ifndef OPENSSL_NO_ENGINE if (engine) { if (!ENGINE_init(engine)) { RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB); OPENSSL_free(ret); return NULL; } ret->engine = engine; } else ret->engine = ENGINE_get_default_RSA(); if (ret->engine) { ret->meth = ENGINE_get_RSA(ret->engine); <S2SV_StartVul> if (!ret->meth) { <S2SV_EndVul> RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB); ENGINE_finish(ret->engine); OPENSSL_free(ret); return NULL; } } #endif ret->references = 1; ret->flags = ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW; if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data)) { #ifndef OPENSSL_NO_ENGINE if (ret->engine) ENGINE_finish(ret->engine); #endif OPENSSL_free(ret); return (NULL); } if ((ret->meth->init != NULL) && !ret->meth->init(ret)) { #ifndef OPENSSL_NO_ENGINE if (ret->engine) ENGINE_finish(ret->engine); #endif CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data); OPENSSL_free(ret); ret = NULL; } return (ret); }","- if (!ret->meth) {
+ if (ret->meth == NULL) {","RSA *RSA_new_method(ENGINE *engine) { RSA *ret; ret = OPENSSL_zalloc(sizeof(*ret)); if (ret == NULL) { RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_MALLOC_FAILURE); return NULL; } ret->meth = RSA_get_default_method(); #ifndef OPENSSL_NO_ENGINE if (engine) { if (!ENGINE_init(engine)) { RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB); OPENSSL_free(ret); return NULL; } ret->engine = engine; } else ret->engine = ENGINE_get_default_RSA(); if (ret->engine) { ret->meth = ENGINE_get_RSA(ret->engine); if (ret->meth == NULL) { RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB); ENGINE_finish(ret->engine); OPENSSL_free(ret); return NULL; } } #endif ret->references = 1; ret->flags = ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW; if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data)) { #ifndef OPENSSL_NO_ENGINE if (ret->engine) ENGINE_finish(ret->engine); #endif OPENSSL_free(ret); return (NULL); } if ((ret->meth->init != NULL) && !ret->meth->init(ret)) { #ifndef OPENSSL_NO_ENGINE if (ret->engine) ENGINE_finish(ret->engine); #endif CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data); OPENSSL_free(ret); ret = NULL; } return (ret); }"
9906----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_2e32a0a724ab0b1a72dd2844cdfe2bc0d1917f9f_1.json----ngx_http_proxy_create_request,"static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r) { size_t len, uri_len, loc_len, body_len; uintptr_t escape; ngx_buf_t *b; ngx_str_t method; ngx_uint_t i, unparsed_uri; ngx_chain_t *cl, *body; ngx_list_part_t *part; ngx_table_elt_t *header; ngx_http_upstream_t *u; ngx_http_proxy_ctx_t *ctx; ngx_http_script_code_pt code; ngx_http_script_engine_t e, le; ngx_http_proxy_loc_conf_t *plcf; ngx_http_script_len_code_pt lcode; u = r->upstream; plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module); if (u->method.len) { method = u->method; method.len++; } else if (plcf->method.len) { method = plcf->method; } else { method = r->method_name; method.len++; } ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module); if (method.len == 5 && ngx_strncasecmp(method.data, (u_char *) ""HEAD "", 5) == 0) { ctx->head = 1; } len = method.len + sizeof(ngx_http_proxy_version) - 1 + sizeof(CRLF) - 1; escape = 0; loc_len = 0; unparsed_uri = 0; <S2SV_StartVul> if (plcf->proxy_lengths) { <S2SV_EndVul> uri_len = ctx->vars.uri.len; } else if (ctx->vars.uri.len == 0 && r->valid_unparsed_uri && r == r->main) { unparsed_uri = 1; uri_len = r->unparsed_uri.len; } else { loc_len = (r->valid_location && ctx->vars.uri.len) ? plcf->location.len : 0; if (r->quoted_uri || r->space_in_uri || r->internal) { escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len, r->uri.len - loc_len, NGX_ESCAPE_URI); } uri_len = ctx->vars.uri.len + r->uri.len - loc_len + escape + sizeof(""?"") - 1 + r->args.len; } if (uri_len == 0) { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""zero length URI to proxy""); return NGX_ERROR; } len += uri_len; ngx_http_script_flush_no_cacheable_variables(r, plcf->flushes); if (plcf->body_set_len) { le.ip = plcf->body_set_len->elts; le.request = r; le.flushed = 1; body_len = 0; while (*(uintptr_t *) le.ip) { lcode = *(ngx_http_script_len_code_pt *) le.ip; body_len += lcode(&le); } ctx->internal_body_length = body_len; len += body_len; } le.ip = plcf->headers_set_len->elts; le.request = r; le.flushed = 1; while (*(uintptr_t *) le.ip) { while (*(uintptr_t *) le.ip) { lcode = *(ngx_http_script_len_code_pt *) le.ip; len += lcode(&le); } le.ip += sizeof(uintptr_t); } if (plcf->upstream.pass_request_headers) { part = &r->headers_in.headers.part; header = part->elts; for (i = 0; ; i++) { if (i >= part->nelts) { if (part->next == NULL) { break; } part = part->next; header = part->elts; i = 0; } if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash, header[i].lowcase_key, header[i].key.len)) { continue; } len += header[i].key.len + sizeof("": "") - 1 + header[i].value.len + sizeof(CRLF) - 1; } } b = ngx_create_temp_buf(r->pool, len); if (b == NULL) { return NGX_ERROR; } cl = ngx_alloc_chain_link(r->pool); if (cl == NULL) { return NGX_ERROR; } cl->buf = b; b->last = ngx_copy(b->last, method.data, method.len); u->uri.data = b->last; <S2SV_StartVul> if (plcf->proxy_lengths) { <S2SV_EndVul> b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len); } else if (unparsed_uri) { b->last = ngx_copy(b->last, r->unparsed_uri.data, r->unparsed_uri.len); } else { if (r->valid_location) { b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len); } if (escape) { ngx_escape_uri(b->last, r->uri.data + loc_len, r->uri.len - loc_len, NGX_ESCAPE_URI); b->last += r->uri.len - loc_len + escape; } else { b->last = ngx_copy(b->last, r->uri.data + loc_len, r->uri.len - loc_len); } if (r->args.len > 0) { *b->last++ = '?'; b->last = ngx_copy(b->last, r->args.data, r->args.len); } } u->uri.len = b->last - u->uri.data; if (plcf->http_version == NGX_HTTP_VERSION_11) { b->last = ngx_cpymem(b->last, ngx_http_proxy_version_11, sizeof(ngx_http_proxy_version_11) - 1); } else { b->last = ngx_cpymem(b->last, ngx_http_proxy_version, sizeof(ngx_http_proxy_version) - 1); } ngx_memzero(&e, sizeof(ngx_http_script_engine_t)); e.ip = plcf->headers_set->elts; e.pos = b->last; e.request = r; e.flushed = 1; le.ip = plcf->headers_set_len->elts; while (*(uintptr_t *) le.ip) { lcode = *(ngx_http_script_len_code_pt *) le.ip; (void) lcode(&le); if (*(ngx_http_script_len_code_pt *) le.ip) { for (len = 0; *(uintptr_t *) le.ip; len += lcode(&le)) { lcode = *(ngx_http_script_len_code_pt *) le.ip; } e.skip = (len == sizeof(CRLF) - 1) ? 1 : 0; } else { e.skip = 0; } le.ip += sizeof(uintptr_t); while (*(uintptr_t *) e.ip) { code = *(ngx_http_script_code_pt *) e.ip; code((ngx_http_script_engine_t *) &e); } e.ip += sizeof(uintptr_t); } b->last = e.pos; if (plcf->upstream.pass_request_headers) { part = &r->headers_in.headers.part; header = part->elts; for (i = 0; ; i++) { if (i >= part->nelts) { if (part->next == NULL) { break; } part = part->next; header = part->elts; i = 0; } if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash, header[i].lowcase_key, header[i].key.len)) { continue; } b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len); *b->last++ = ':'; *b->last++ = ' '; b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len); *b->last++ = CR; *b->last++ = LF; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http proxy header: \""%V: %V\"""", &header[i].key, &header[i].value); } } *b->last++ = CR; *b->last++ = LF; if (plcf->body_set) { e.ip = plcf->body_set->elts; e.pos = b->last; while (*(uintptr_t *) e.ip) { code = *(ngx_http_script_code_pt *) e.ip; code((ngx_http_script_engine_t *) &e); } b->last = e.pos; } ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http proxy header:\n\""%*s\"""", (size_t) (b->last - b->pos), b->pos); if (plcf->body_set == NULL && plcf->upstream.pass_request_body) { body = u->request_bufs; u->request_bufs = cl; while (body) { b = ngx_alloc_buf(r->pool); if (b == NULL) { return NGX_ERROR; } ngx_memcpy(b, body->buf, sizeof(ngx_buf_t)); cl->next = ngx_alloc_chain_link(r->pool); if (cl->next == NULL) { return NGX_ERROR; } cl = cl->next; cl->buf = b; body = body->next; } } else { u->request_bufs = cl; } b->flush = 1; cl->next = NULL; return NGX_OK; }","- if (plcf->proxy_lengths) {
- if (plcf->proxy_lengths) {
+ if (plcf->proxy_lengths && ctx->vars.uri.len) {
+ if (plcf->proxy_lengths && ctx->vars.uri.len) {","static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r) { size_t len, uri_len, loc_len, body_len; uintptr_t escape; ngx_buf_t *b; ngx_str_t method; ngx_uint_t i, unparsed_uri; ngx_chain_t *cl, *body; ngx_list_part_t *part; ngx_table_elt_t *header; ngx_http_upstream_t *u; ngx_http_proxy_ctx_t *ctx; ngx_http_script_code_pt code; ngx_http_script_engine_t e, le; ngx_http_proxy_loc_conf_t *plcf; ngx_http_script_len_code_pt lcode; u = r->upstream; plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module); if (u->method.len) { method = u->method; method.len++; } else if (plcf->method.len) { method = plcf->method; } else { method = r->method_name; method.len++; } ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module); if (method.len == 5 && ngx_strncasecmp(method.data, (u_char *) ""HEAD "", 5) == 0) { ctx->head = 1; } len = method.len + sizeof(ngx_http_proxy_version) - 1 + sizeof(CRLF) - 1; escape = 0; loc_len = 0; unparsed_uri = 0; if (plcf->proxy_lengths && ctx->vars.uri.len) { uri_len = ctx->vars.uri.len; } else if (ctx->vars.uri.len == 0 && r->valid_unparsed_uri && r == r->main) { unparsed_uri = 1; uri_len = r->unparsed_uri.len; } else { loc_len = (r->valid_location && ctx->vars.uri.len) ? plcf->location.len : 0; if (r->quoted_uri || r->space_in_uri || r->internal) { escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len, r->uri.len - loc_len, NGX_ESCAPE_URI); } uri_len = ctx->vars.uri.len + r->uri.len - loc_len + escape + sizeof(""?"") - 1 + r->args.len; } if (uri_len == 0) { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""zero length URI to proxy""); return NGX_ERROR; } len += uri_len; ngx_http_script_flush_no_cacheable_variables(r, plcf->flushes); if (plcf->body_set_len) { le.ip = plcf->body_set_len->elts; le.request = r; le.flushed = 1; body_len = 0; while (*(uintptr_t *) le.ip) { lcode = *(ngx_http_script_len_code_pt *) le.ip; body_len += lcode(&le); } ctx->internal_body_length = body_len; len += body_len; } le.ip = plcf->headers_set_len->elts; le.request = r; le.flushed = 1; while (*(uintptr_t *) le.ip) { while (*(uintptr_t *) le.ip) { lcode = *(ngx_http_script_len_code_pt *) le.ip; len += lcode(&le); } le.ip += sizeof(uintptr_t); } if (plcf->upstream.pass_request_headers) { part = &r->headers_in.headers.part; header = part->elts; for (i = 0; ; i++) { if (i >= part->nelts) { if (part->next == NULL) { break; } part = part->next; header = part->elts; i = 0; } if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash, header[i].lowcase_key, header[i].key.len)) { continue; } len += header[i].key.len + sizeof("": "") - 1 + header[i].value.len + sizeof(CRLF) - 1; } } b = ngx_create_temp_buf(r->pool, len); if (b == NULL) { return NGX_ERROR; } cl = ngx_alloc_chain_link(r->pool); if (cl == NULL) { return NGX_ERROR; } cl->buf = b; b->last = ngx_copy(b->last, method.data, method.len); u->uri.data = b->last; if (plcf->proxy_lengths && ctx->vars.uri.len) { b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len); } else if (unparsed_uri) { b->last = ngx_copy(b->last, r->unparsed_uri.data, r->unparsed_uri.len); } else { if (r->valid_location) { b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len); } if (escape) { ngx_escape_uri(b->last, r->uri.data + loc_len, r->uri.len - loc_len, NGX_ESCAPE_URI); b->last += r->uri.len - loc_len + escape; } else { b->last = ngx_copy(b->last, r->uri.data + loc_len, r->uri.len - loc_len); } if (r->args.len > 0) { *b->last++ = '?'; b->last = ngx_copy(b->last, r->args.data, r->args.len); } } u->uri.len = b->last - u->uri.data; if (plcf->http_version == NGX_HTTP_VERSION_11) { b->last = ngx_cpymem(b->last, ngx_http_proxy_version_11, sizeof(ngx_http_proxy_version_11) - 1); } else { b->last = ngx_cpymem(b->last, ngx_http_proxy_version, sizeof(ngx_http_proxy_version) - 1); } ngx_memzero(&e, sizeof(ngx_http_script_engine_t)); e.ip = plcf->headers_set->elts; e.pos = b->last; e.request = r; e.flushed = 1; le.ip = plcf->headers_set_len->elts; while (*(uintptr_t *) le.ip) { lcode = *(ngx_http_script_len_code_pt *) le.ip; (void) lcode(&le); if (*(ngx_http_script_len_code_pt *) le.ip) { for (len = 0; *(uintptr_t *) le.ip; len += lcode(&le)) { lcode = *(ngx_http_script_len_code_pt *) le.ip; } e.skip = (len == sizeof(CRLF) - 1) ? 1 : 0; } else { e.skip = 0; } le.ip += sizeof(uintptr_t); while (*(uintptr_t *) e.ip) { code = *(ngx_http_script_code_pt *) e.ip; code((ngx_http_script_engine_t *) &e); } e.ip += sizeof(uintptr_t); } b->last = e.pos; if (plcf->upstream.pass_request_headers) { part = &r->headers_in.headers.part; header = part->elts; for (i = 0; ; i++) { if (i >= part->nelts) { if (part->next == NULL) { break; } part = part->next; header = part->elts; i = 0; } if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash, header[i].lowcase_key, header[i].key.len)) { continue; } b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len); *b->last++ = ':'; *b->last++ = ' '; b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len); *b->last++ = CR; *b->last++ = LF; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http proxy header: \""%V: %V\"""", &header[i].key, &header[i].value); } } *b->last++ = CR; *b->last++ = LF; if (plcf->body_set) { e.ip = plcf->body_set->elts; e.pos = b->last; while (*(uintptr_t *) e.ip) { code = *(ngx_http_script_code_pt *) e.ip; code((ngx_http_script_engine_t *) &e); } b->last = e.pos; } ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http proxy header:\n\""%*s\"""", (size_t) (b->last - b->pos), b->pos); if (plcf->body_set == NULL && plcf->upstream.pass_request_body) { body = u->request_bufs; u->request_bufs = cl; while (body) { b = ngx_alloc_buf(r->pool); if (b == NULL) { return NGX_ERROR; } ngx_memcpy(b, body->buf, sizeof(ngx_buf_t)); cl->next = ngx_alloc_chain_link(r->pool); if (cl->next == NULL) { return NGX_ERROR; } cl = cl->next; cl->buf = b; body = body->next; } } else { u->request_bufs = cl; } b->flush = 1; cl->next = NULL; return NGX_OK; }"
9936----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_41bc01be78854b521ed5a3ddab5cd6a9c156c114_1.json----ngx_http_add_referer,"static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf, ngx_hash_keys_arrays_t *keys, ngx_str_t *value, ngx_str_t *uri) { ngx_int_t rc; ngx_str_t *u; <S2SV_StartVul> if (uri->len == 0) { <S2SV_EndVul> u = NGX_HTTP_REFERER_NO_URI_PART; } else { u = ngx_palloc(cf->pool, sizeof(ngx_str_t)); if (u == NULL) { return NGX_ERROR; } *u = *uri; } rc = ngx_hash_add_key(keys, value, u, NGX_HASH_WILDCARD_KEY); if (rc == NGX_OK) { return NGX_OK; } if (rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid hostname or wildcard \""%V\"""", value); } if (rc == NGX_BUSY) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""conflicting parameter \""%V\"""", value); } return NGX_ERROR; }","- if (uri->len == 0) {
+ if (uri == NULL || uri->len == 0) {","static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf, ngx_hash_keys_arrays_t *keys, ngx_str_t *value, ngx_str_t *uri) { ngx_int_t rc; ngx_str_t *u; if (uri == NULL || uri->len == 0) { u = NGX_HTTP_REFERER_NO_URI_PART; } else { u = ngx_palloc(cf->pool, sizeof(ngx_str_t)); if (u == NULL) { return NGX_ERROR; } *u = *uri; } rc = ngx_hash_add_key(keys, value, u, NGX_HASH_WILDCARD_KEY); if (rc == NGX_OK) { return NGX_OK; } if (rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid hostname or wildcard \""%V\"""", value); } if (rc == NGX_BUSY) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""conflicting parameter \""%V\"""", value); } return NGX_ERROR; }"
11798----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_36841189f4598a55810a70cd26582f8fad1edd04_1.json----init,"<S2SV_StartVul> static int init(DRBG_CTX *dctx, DRBG_SELFTEST_DATA *td, TEST_CTX *t) <S2SV_EndVul> { <S2SV_StartVul> if (!TEST_true(RAND_DRBG_set(dctx, td->nid, td->flags)) <S2SV_EndVul> <S2SV_StartVul> || !TEST_true(RAND_DRBG_set_callbacks(dctx, kat_entropy, NULL, <S2SV_EndVul> kat_nonce, NULL))) return 0; <S2SV_StartVul> RAND_DRBG_set_ex_data(dctx, app_data_index, t); <S2SV_EndVul> t->ent = td->ent; t->entlen = td->entlen; t->nonce = td->nonce; t->noncelen = td->noncelen; t->entcnt = 0; t->noncecnt = 0; return 1; }","- static int init(DRBG_CTX *dctx, DRBG_SELFTEST_DATA *td, TEST_CTX *t)
- if (!TEST_true(RAND_DRBG_set(dctx, td->nid, td->flags))
- || !TEST_true(RAND_DRBG_set_callbacks(dctx, kat_entropy, NULL,
- RAND_DRBG_set_ex_data(dctx, app_data_index, t);
+ static int init(RAND_DRBG *drbg, DRBG_SELFTEST_DATA *td, TEST_CTX *t)
+ if (!TEST_true(RAND_DRBG_set(drbg, td->nid, td->flags))
+ || !TEST_true(RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,
+ RAND_DRBG_set_ex_data(drbg, app_data_index, t);","static int init(RAND_DRBG *drbg, DRBG_SELFTEST_DATA *td, TEST_CTX *t) { if (!TEST_true(RAND_DRBG_set(drbg, td->nid, td->flags)) || !TEST_true(RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL, kat_nonce, NULL))) return 0; RAND_DRBG_set_ex_data(drbg, app_data_index, t); t->ent = td->ent; t->entlen = td->entlen; t->nonce = td->nonce; t->noncelen = td->noncelen; t->entcnt = 0; t->noncecnt = 0; return 1; }"
10735----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1134f9f9eb9094e1f8b6bbf48f18dc96b349ce2e_1.json----ssl3_accept,"int ssl3_accept(SSL *s) { BUF_MEM *buf; unsigned long alg_k,Time=(unsigned long)time(NULL); void (*cb)(const SSL *ssl,int type,int val)=NULL; int ret= -1; int new_state,state,skip=0; RAND_add(&Time,sizeof(Time),0); ERR_clear_error(); clear_sys_error(); if (s->info_callback != NULL) cb=s->info_callback; else if (s->ctx->info_callback != NULL) cb=s->ctx->info_callback; s->in_handshake++; if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); if (s->cert == NULL) { SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET); return(-1); } #ifndef OPENSSL_NO_HEARTBEATS if (s->tlsext_hb_pending) { s->tlsext_hb_pending = 0; s->tlsext_hb_seq++; } #endif for (;;) { state=s->state; switch (s->state) { case SSL_ST_RENEGOTIATE: s->renegotiate=1; case SSL_ST_BEFORE: case SSL_ST_ACCEPT: case SSL_ST_BEFORE|SSL_ST_ACCEPT: case SSL_ST_OK|SSL_ST_ACCEPT: s->server=1; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1); if ((s->version>>8) != 3) { SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR); return -1; } s->type=SSL_ST_ACCEPT; if (s->init_buf == NULL) { if ((buf=BUF_MEM_new()) == NULL) { ret= -1; goto end; } if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH)) { ret= -1; goto end; } s->init_buf=buf; } if (!ssl3_setup_buffers(s)) { ret= -1; goto end; } s->init_num=0; s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE; s->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY; if (s->state != SSL_ST_RENEGOTIATE) { if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; } ssl3_init_finished_mac(s); s->state=SSL3_ST_SR_CLNT_HELLO_A; s->ctx->stats.sess_accept++; } else if (!s->s3->send_connection_binding && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE); ret = -1; goto end; } else { s->ctx->stats.sess_accept_renegotiate++; s->state=SSL3_ST_SW_HELLO_REQ_A; } break; case SSL3_ST_SW_HELLO_REQ_A: case SSL3_ST_SW_HELLO_REQ_B: s->shutdown=0; ret=ssl3_send_hello_request(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; ssl3_init_finished_mac(s); break; case SSL3_ST_SW_HELLO_REQ_C: s->state=SSL_ST_OK; break; case SSL3_ST_SR_CLNT_HELLO_A: case SSL3_ST_SR_CLNT_HELLO_B: case SSL3_ST_SR_CLNT_HELLO_C: if (s->rwstate != SSL_X509_LOOKUP) { ret=ssl3_get_client_hello(s); if (ret <= 0) goto end; } #ifndef OPENSSL_NO_SRP { int al; if ((ret = ssl_check_srp_ext_ClientHello(s,&al)) < 0) { s->rwstate=SSL_X509_LOOKUP; goto end; } if (ret != SSL_ERROR_NONE) { ssl3_send_alert(s,SSL3_AL_FATAL,al); if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT); ret = SSL_TLSEXT_ERR_ALERT_FATAL; ret= -1; goto end; } } #endif s->renegotiate = 2; s->state=SSL3_ST_SW_SRVR_HELLO_A; s->init_num=0; break; case SSL3_ST_SW_SRVR_HELLO_A: case SSL3_ST_SW_SRVR_HELLO_B: ret=ssl3_send_server_hello(s); if (ret <= 0) goto end; #ifndef OPENSSL_NO_TLSEXT if (s->hit) { if (s->tlsext_ticket_expected) s->state=SSL3_ST_SW_SESSION_TICKET_A; else s->state=SSL3_ST_SW_CHANGE_A; } #else if (s->hit) s->state=SSL3_ST_SW_CHANGE_A; #endif else #ifndef OPENSSL_NO_TLSEXT s->state = SSL3_ST_SW_SUPPLEMENTAL_DATA_A; #else s->state = SSL3_ST_SW_CERT_A; #endif s->init_num = 0; break; #ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SUPPLEMENTAL_DATA_A: case SSL3_ST_SW_SUPPLEMENTAL_DATA_B: <S2SV_StartVul> if (s->s3->tlsext_authz_promised_to_client) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> ret = tls1_send_server_supplemental_data(s); <S2SV_EndVul> <S2SV_StartVul> if (ret <= 0) goto end; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> skip = 1; <S2SV_EndVul> s->state = SSL3_ST_SW_CERT_A; s->init_num = 0; break; #endif case SSL3_ST_SW_CERT_A: case SSL3_ST_SW_CERT_B: if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) && !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK) && !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)) { ret=ssl3_send_server_certificate(s); if (ret <= 0) goto end; #ifndef OPENSSL_NO_TLSEXT if (s->tlsext_status_expected) s->state=SSL3_ST_SW_CERT_STATUS_A; else s->state=SSL3_ST_SW_KEY_EXCH_A; } else { skip = 1; s->state=SSL3_ST_SW_KEY_EXCH_A; } #else } else skip=1; s->state=SSL3_ST_SW_KEY_EXCH_A; #endif s->init_num=0; break; case SSL3_ST_SW_KEY_EXCH_A: case SSL3_ST_SW_KEY_EXCH_B: alg_k = s->s3->tmp.new_cipher->algorithm_mkey; if ((s->options & SSL_OP_EPHEMERAL_RSA) #ifndef OPENSSL_NO_KRB5 && !(alg_k & SSL_kKRB5) #endif ) s->s3->tmp.use_rsa_tmp=1; else s->s3->tmp.use_rsa_tmp=0; if (s->s3->tmp.use_rsa_tmp #ifndef OPENSSL_NO_PSK || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint) #endif #ifndef OPENSSL_NO_SRP || (alg_k & SSL_kSRP) #endif || (alg_k & SSL_kEDH) || (alg_k & SSL_kEECDH) || ((alg_k & SSL_kRSA) && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher) ) ) ) ) { ret=ssl3_send_server_key_exchange(s); if (ret <= 0) goto end; } else skip=1; s->state=SSL3_ST_SW_CERT_REQ_A; s->init_num=0; break; case SSL3_ST_SW_CERT_REQ_A: case SSL3_ST_SW_CERT_REQ_B: if ( !(s->verify_mode & SSL_VERIFY_PEER) || ((s->session->peer != NULL) && (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) || ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) && !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) || (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) || (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) { skip=1; s->s3->tmp.cert_request=0; s->state=SSL3_ST_SW_SRVR_DONE_A; if (s->s3->handshake_buffer) if (!ssl3_digest_cached_records(s)) return -1; } else { s->s3->tmp.cert_request=1; ret=ssl3_send_certificate_request(s); if (ret <= 0) goto end; #ifndef NETSCAPE_HANG_BUG s->state=SSL3_ST_SW_SRVR_DONE_A; #else s->state=SSL3_ST_SW_FLUSH; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; #endif s->init_num=0; } break; case SSL3_ST_SW_SRVR_DONE_A: case SSL3_ST_SW_SRVR_DONE_B: ret=ssl3_send_server_done(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; break; case SSL3_ST_SW_FLUSH: s->rwstate=SSL_WRITING; if (BIO_flush(s->wbio) <= 0) { ret= -1; goto end; } s->rwstate=SSL_NOTHING; s->state=s->s3->tmp.next_state; break; case SSL3_ST_SR_CERT_A: case SSL3_ST_SR_CERT_B: ret = ssl3_check_client_hello(s); if (ret <= 0) goto end; if (ret == 2) s->state = SSL3_ST_SR_CLNT_HELLO_C; else { if (s->s3->tmp.cert_request) { ret=ssl3_get_client_certificate(s); if (ret <= 0) goto end; } s->init_num=0; s->state=SSL3_ST_SR_KEY_EXCH_A; } break; case SSL3_ST_SR_KEY_EXCH_A: case SSL3_ST_SR_KEY_EXCH_B: ret=ssl3_get_client_key_exchange(s); if (ret <= 0) goto end; if (ret == 2) { #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG) s->state=SSL3_ST_SR_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->state=SSL3_ST_SR_NEXT_PROTO_A; else s->state=SSL3_ST_SR_FINISHED_A; #endif s->init_num = 0; } else if (SSL_USE_SIGALGS(s)) { s->state=SSL3_ST_SR_CERT_VRFY_A; s->init_num=0; if (!s->session->peer) break; if (!s->s3->handshake_buffer) { SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR); return -1; } s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE; if (!ssl3_digest_cached_records(s)) return -1; } else { int offset=0; int dgst_num; s->state=SSL3_ST_SR_CERT_VRFY_A; s->init_num=0; if (s->s3->handshake_buffer) if (!ssl3_digest_cached_records(s)) return -1; for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++) if (s->s3->handshake_dgst[dgst_num]) { int dgst_size; s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset])); dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]); if (dgst_size < 0) { ret = -1; goto end; } offset+=dgst_size; } } break; case SSL3_ST_SR_CERT_VRFY_A: case SSL3_ST_SR_CERT_VRFY_B: ret=ssl3_get_cert_verify(s); if (ret <= 0) goto end; #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG) s->state=SSL3_ST_SR_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->state=SSL3_ST_SR_NEXT_PROTO_A; else s->state=SSL3_ST_SR_FINISHED_A; #endif s->init_num=0; break; #if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG) case SSL3_ST_SR_NEXT_PROTO_A: case SSL3_ST_SR_NEXT_PROTO_B: ret=ssl3_get_next_proto(s); if (ret <= 0) goto end; s->init_num = 0; s->state=SSL3_ST_SR_FINISHED_A; break; #endif case SSL3_ST_SR_FINISHED_A: case SSL3_ST_SR_FINISHED_B: ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A, SSL3_ST_SR_FINISHED_B); if (ret <= 0) goto end; if (s->hit) s->state=SSL_ST_OK; #ifndef OPENSSL_NO_TLSEXT else if (s->tlsext_ticket_expected) s->state=SSL3_ST_SW_SESSION_TICKET_A; #endif else s->state=SSL3_ST_SW_CHANGE_A; s->init_num=0; break; #ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A: case SSL3_ST_SW_SESSION_TICKET_B: ret=ssl3_send_newsession_ticket(s); if (ret <= 0) goto end; s->state=SSL3_ST_SW_CHANGE_A; s->init_num=0; break; case SSL3_ST_SW_CERT_STATUS_A: case SSL3_ST_SW_CERT_STATUS_B: ret=ssl3_send_cert_status(s); if (ret <= 0) goto end; s->state=SSL3_ST_SW_KEY_EXCH_A; s->init_num=0; break; #endif case SSL3_ST_SW_CHANGE_A: case SSL3_ST_SW_CHANGE_B: s->session->cipher=s->s3->tmp.new_cipher; if (!s->method->ssl3_enc->setup_key_block(s)) { ret= -1; goto end; } ret=ssl3_send_change_cipher_spec(s, SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FINISHED_A; s->init_num=0; if (!s->method->ssl3_enc->change_cipher_state(s, SSL3_CHANGE_CIPHER_SERVER_WRITE)) { ret= -1; goto end; } break; case SSL3_ST_SW_FINISHED_A: case SSL3_ST_SW_FINISHED_B: ret=ssl3_send_finished(s, SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B, s->method->ssl3_enc->server_finished_label, s->method->ssl3_enc->server_finished_label_len); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FLUSH; if (s->hit) { #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG) s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A; else s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A; #endif } else s->s3->tmp.next_state=SSL_ST_OK; s->init_num=0; break; case SSL_ST_OK: ssl3_cleanup_key_block(s); BUF_MEM_free(s->init_buf); s->init_buf=NULL; ssl_free_wbio_buffer(s); s->init_num=0; if (s->renegotiate == 2) { s->renegotiate=0; s->new_session=0; ssl_update_cache(s,SSL_SESS_CACHE_SERVER); s->ctx->stats.sess_accept_good++; s->handshake_func=ssl3_accept; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1); } ret = 1; goto end; default: SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE); ret= -1; goto end; } if (!s->s3->tmp.reuse_message && !skip) { if (s->debug) { if ((ret=BIO_flush(s->wbio)) <= 0) goto end; } if ((cb != NULL) && (s->state != state)) { new_state=s->state; s->state=state; cb(s,SSL_CB_ACCEPT_LOOP,1); s->state=new_state; } } skip=0; } end: s->in_handshake--; if (cb != NULL) cb(s,SSL_CB_ACCEPT_EXIT,ret); return(ret); }","- if (s->s3->tlsext_authz_promised_to_client)
- {
- ret = tls1_send_server_supplemental_data(s);
- if (ret <= 0) goto end;
- }
- else
- skip = 1;
+ ret = tls1_send_server_supplemental_data(s, &skip);
+ if (ret <= 0) goto end;
+ #ifndef OPENSSL_NO_TLSEXT
+ case SSL3_ST_SR_SUPPLEMENTAL_DATA_A:
+ case SSL3_ST_SR_SUPPLEMENTAL_DATA_B:
+ ret=tls1_get_client_supplemental_data(s);
+ if (ret <= 0) goto end;
+ s->s3->tmp.next_state=SSL3_ST_SR_CERT_A;
+ s->state=SSL3_ST_SW_FLUSH;
+ s->init_num=0;
+ break;
+ #endif
+ #ifndef OPENSSL_NO_TLSEXT
+ else if (ret == 3)
+ s->state = SSL3_ST_SR_SUPPLEMENTAL_DATA_A;
+ #endif","int ssl3_accept(SSL *s) { BUF_MEM *buf; unsigned long alg_k,Time=(unsigned long)time(NULL); void (*cb)(const SSL *ssl,int type,int val)=NULL; int ret= -1; int new_state,state,skip=0; RAND_add(&Time,sizeof(Time),0); ERR_clear_error(); clear_sys_error(); if (s->info_callback != NULL) cb=s->info_callback; else if (s->ctx->info_callback != NULL) cb=s->ctx->info_callback; s->in_handshake++; if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s); if (s->cert == NULL) { SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET); return(-1); } #ifndef OPENSSL_NO_HEARTBEATS if (s->tlsext_hb_pending) { s->tlsext_hb_pending = 0; s->tlsext_hb_seq++; } #endif for (;;) { state=s->state; switch (s->state) { case SSL_ST_RENEGOTIATE: s->renegotiate=1; case SSL_ST_BEFORE: case SSL_ST_ACCEPT: case SSL_ST_BEFORE|SSL_ST_ACCEPT: case SSL_ST_OK|SSL_ST_ACCEPT: s->server=1; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1); if ((s->version>>8) != 3) { SSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR); return -1; } s->type=SSL_ST_ACCEPT; if (s->init_buf == NULL) { if ((buf=BUF_MEM_new()) == NULL) { ret= -1; goto end; } if (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH)) { ret= -1; goto end; } s->init_buf=buf; } if (!ssl3_setup_buffers(s)) { ret= -1; goto end; } s->init_num=0; s->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE; s->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY; if (s->state != SSL_ST_RENEGOTIATE) { if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; } ssl3_init_finished_mac(s); s->state=SSL3_ST_SR_CLNT_HELLO_A; s->ctx->stats.sess_accept++; } else if (!s->s3->send_connection_binding && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { SSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); ssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE); ret = -1; goto end; } else { s->ctx->stats.sess_accept_renegotiate++; s->state=SSL3_ST_SW_HELLO_REQ_A; } break; case SSL3_ST_SW_HELLO_REQ_A: case SSL3_ST_SW_HELLO_REQ_B: s->shutdown=0; ret=ssl3_send_hello_request(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; ssl3_init_finished_mac(s); break; case SSL3_ST_SW_HELLO_REQ_C: s->state=SSL_ST_OK; break; case SSL3_ST_SR_CLNT_HELLO_A: case SSL3_ST_SR_CLNT_HELLO_B: case SSL3_ST_SR_CLNT_HELLO_C: if (s->rwstate != SSL_X509_LOOKUP) { ret=ssl3_get_client_hello(s); if (ret <= 0) goto end; } #ifndef OPENSSL_NO_SRP { int al; if ((ret = ssl_check_srp_ext_ClientHello(s,&al)) < 0) { s->rwstate=SSL_X509_LOOKUP; goto end; } if (ret != SSL_ERROR_NONE) { ssl3_send_alert(s,SSL3_AL_FATAL,al); if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT); ret = SSL_TLSEXT_ERR_ALERT_FATAL; ret= -1; goto end; } } #endif s->renegotiate = 2; s->state=SSL3_ST_SW_SRVR_HELLO_A; s->init_num=0; break; case SSL3_ST_SW_SRVR_HELLO_A: case SSL3_ST_SW_SRVR_HELLO_B: ret=ssl3_send_server_hello(s); if (ret <= 0) goto end; #ifndef OPENSSL_NO_TLSEXT if (s->hit) { if (s->tlsext_ticket_expected) s->state=SSL3_ST_SW_SESSION_TICKET_A; else s->state=SSL3_ST_SW_CHANGE_A; } #else if (s->hit) s->state=SSL3_ST_SW_CHANGE_A; #endif else #ifndef OPENSSL_NO_TLSEXT s->state = SSL3_ST_SW_SUPPLEMENTAL_DATA_A; #else s->state = SSL3_ST_SW_CERT_A; #endif s->init_num = 0; break; #ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SUPPLEMENTAL_DATA_A: case SSL3_ST_SW_SUPPLEMENTAL_DATA_B: ret = tls1_send_server_supplemental_data(s, &skip); if (ret <= 0) goto end; s->state = SSL3_ST_SW_CERT_A; s->init_num = 0; break; #endif case SSL3_ST_SW_CERT_A: case SSL3_ST_SW_CERT_B: if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) && !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK) && !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)) { ret=ssl3_send_server_certificate(s); if (ret <= 0) goto end; #ifndef OPENSSL_NO_TLSEXT if (s->tlsext_status_expected) s->state=SSL3_ST_SW_CERT_STATUS_A; else s->state=SSL3_ST_SW_KEY_EXCH_A; } else { skip = 1; s->state=SSL3_ST_SW_KEY_EXCH_A; } #else } else skip=1; s->state=SSL3_ST_SW_KEY_EXCH_A; #endif s->init_num=0; break; case SSL3_ST_SW_KEY_EXCH_A: case SSL3_ST_SW_KEY_EXCH_B: alg_k = s->s3->tmp.new_cipher->algorithm_mkey; if ((s->options & SSL_OP_EPHEMERAL_RSA) #ifndef OPENSSL_NO_KRB5 && !(alg_k & SSL_kKRB5) #endif ) s->s3->tmp.use_rsa_tmp=1; else s->s3->tmp.use_rsa_tmp=0; if (s->s3->tmp.use_rsa_tmp #ifndef OPENSSL_NO_PSK || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint) #endif #ifndef OPENSSL_NO_SRP || (alg_k & SSL_kSRP) #endif || (alg_k & SSL_kEDH) || (alg_k & SSL_kEECDH) || ((alg_k & SSL_kRSA) && (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher) && EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher) ) ) ) ) { ret=ssl3_send_server_key_exchange(s); if (ret <= 0) goto end; } else skip=1; s->state=SSL3_ST_SW_CERT_REQ_A; s->init_num=0; break; case SSL3_ST_SW_CERT_REQ_A: case SSL3_ST_SW_CERT_REQ_B: if ( !(s->verify_mode & SSL_VERIFY_PEER) || ((s->session->peer != NULL) && (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) || ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) && !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) || (s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5) || (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)) { skip=1; s->s3->tmp.cert_request=0; s->state=SSL3_ST_SW_SRVR_DONE_A; if (s->s3->handshake_buffer) if (!ssl3_digest_cached_records(s)) return -1; } else { s->s3->tmp.cert_request=1; ret=ssl3_send_certificate_request(s); if (ret <= 0) goto end; #ifndef NETSCAPE_HANG_BUG s->state=SSL3_ST_SW_SRVR_DONE_A; #else s->state=SSL3_ST_SW_FLUSH; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; #endif s->init_num=0; } break; case SSL3_ST_SW_SRVR_DONE_A: case SSL3_ST_SW_SRVR_DONE_B: ret=ssl3_send_server_done(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; break; case SSL3_ST_SW_FLUSH: s->rwstate=SSL_WRITING; if (BIO_flush(s->wbio) <= 0) { ret= -1; goto end; } s->rwstate=SSL_NOTHING; s->state=s->s3->tmp.next_state; break; #ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SR_SUPPLEMENTAL_DATA_A: case SSL3_ST_SR_SUPPLEMENTAL_DATA_B: ret=tls1_get_client_supplemental_data(s); if (ret <= 0) goto end; s->s3->tmp.next_state=SSL3_ST_SR_CERT_A; s->state=SSL3_ST_SW_FLUSH; s->init_num=0; break; #endif case SSL3_ST_SR_CERT_A: case SSL3_ST_SR_CERT_B: ret = ssl3_check_client_hello(s); if (ret <= 0) goto end; if (ret == 2) s->state = SSL3_ST_SR_CLNT_HELLO_C; #ifndef OPENSSL_NO_TLSEXT else if (ret == 3) s->state = SSL3_ST_SR_SUPPLEMENTAL_DATA_A; #endif else { if (s->s3->tmp.cert_request) { ret=ssl3_get_client_certificate(s); if (ret <= 0) goto end; } s->init_num=0; s->state=SSL3_ST_SR_KEY_EXCH_A; } break; case SSL3_ST_SR_KEY_EXCH_A: case SSL3_ST_SR_KEY_EXCH_B: ret=ssl3_get_client_key_exchange(s); if (ret <= 0) goto end; if (ret == 2) { #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG) s->state=SSL3_ST_SR_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->state=SSL3_ST_SR_NEXT_PROTO_A; else s->state=SSL3_ST_SR_FINISHED_A; #endif s->init_num = 0; } else if (SSL_USE_SIGALGS(s)) { s->state=SSL3_ST_SR_CERT_VRFY_A; s->init_num=0; if (!s->session->peer) break; if (!s->s3->handshake_buffer) { SSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR); return -1; } s->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE; if (!ssl3_digest_cached_records(s)) return -1; } else { int offset=0; int dgst_num; s->state=SSL3_ST_SR_CERT_VRFY_A; s->init_num=0; if (s->s3->handshake_buffer) if (!ssl3_digest_cached_records(s)) return -1; for (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++) if (s->s3->handshake_dgst[dgst_num]) { int dgst_size; s->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset])); dgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]); if (dgst_size < 0) { ret = -1; goto end; } offset+=dgst_size; } } break; case SSL3_ST_SR_CERT_VRFY_A: case SSL3_ST_SR_CERT_VRFY_B: ret=ssl3_get_cert_verify(s); if (ret <= 0) goto end; #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG) s->state=SSL3_ST_SR_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->state=SSL3_ST_SR_NEXT_PROTO_A; else s->state=SSL3_ST_SR_FINISHED_A; #endif s->init_num=0; break; #if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG) case SSL3_ST_SR_NEXT_PROTO_A: case SSL3_ST_SR_NEXT_PROTO_B: ret=ssl3_get_next_proto(s); if (ret <= 0) goto end; s->init_num = 0; s->state=SSL3_ST_SR_FINISHED_A; break; #endif case SSL3_ST_SR_FINISHED_A: case SSL3_ST_SR_FINISHED_B: ret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A, SSL3_ST_SR_FINISHED_B); if (ret <= 0) goto end; if (s->hit) s->state=SSL_ST_OK; #ifndef OPENSSL_NO_TLSEXT else if (s->tlsext_ticket_expected) s->state=SSL3_ST_SW_SESSION_TICKET_A; #endif else s->state=SSL3_ST_SW_CHANGE_A; s->init_num=0; break; #ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A: case SSL3_ST_SW_SESSION_TICKET_B: ret=ssl3_send_newsession_ticket(s); if (ret <= 0) goto end; s->state=SSL3_ST_SW_CHANGE_A; s->init_num=0; break; case SSL3_ST_SW_CERT_STATUS_A: case SSL3_ST_SW_CERT_STATUS_B: ret=ssl3_send_cert_status(s); if (ret <= 0) goto end; s->state=SSL3_ST_SW_KEY_EXCH_A; s->init_num=0; break; #endif case SSL3_ST_SW_CHANGE_A: case SSL3_ST_SW_CHANGE_B: s->session->cipher=s->s3->tmp.new_cipher; if (!s->method->ssl3_enc->setup_key_block(s)) { ret= -1; goto end; } ret=ssl3_send_change_cipher_spec(s, SSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FINISHED_A; s->init_num=0; if (!s->method->ssl3_enc->change_cipher_state(s, SSL3_CHANGE_CIPHER_SERVER_WRITE)) { ret= -1; goto end; } break; case SSL3_ST_SW_FINISHED_A: case SSL3_ST_SW_FINISHED_B: ret=ssl3_send_finished(s, SSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B, s->method->ssl3_enc->server_finished_label, s->method->ssl3_enc->server_finished_label_len); if (ret <= 0) goto end; s->state=SSL3_ST_SW_FLUSH; if (s->hit) { #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG) s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A; else s->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A; #endif } else s->s3->tmp.next_state=SSL_ST_OK; s->init_num=0; break; case SSL_ST_OK: ssl3_cleanup_key_block(s); BUF_MEM_free(s->init_buf); s->init_buf=NULL; ssl_free_wbio_buffer(s); s->init_num=0; if (s->renegotiate == 2) { s->renegotiate=0; s->new_session=0; ssl_update_cache(s,SSL_SESS_CACHE_SERVER); s->ctx->stats.sess_accept_good++; s->handshake_func=ssl3_accept; if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1); } ret = 1; goto end; default: SSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE); ret= -1; goto end; } if (!s->s3->tmp.reuse_message && !skip) { if (s->debug) { if ((ret=BIO_flush(s->wbio)) <= 0) goto end; } if ((cb != NULL) && (s->state != state)) { new_state=s->state; s->state=state; cb(s,SSL_CB_ACCEPT_LOOP,1); s->state=new_state; } } skip=0; } end: s->in_handshake--; if (cb != NULL) cb(s,SSL_CB_ACCEPT_EXIT,ret); return(ret); }"
16412----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d6a890e4f5efcee92aa5f5857af1cfa2ff9ff9fc_1.json----ssl_get_prev_session,"int ssl_get_prev_session(SSL *s, CLIENTHELLO_MSG *hello) { SSL_SESSION *ret = NULL; int fatal = 0; int try_session_cache = 0; int r; if (SSL_IS_TLS13(s)) { int al; if (!tls_parse_extension(s, TLSEXT_IDX_psk, EXT_CLIENT_HELLO, hello->pre_proc_exts, NULL, 0, &al)) return -1; ret = s->session; } else { r = tls_get_ticket_from_client(s, hello, &ret); switch (r) { case -1: fatal = 1; goto err; case 0: case 1: try_session_cache = 1; break; case 2: case 3: break; default: abort(); } } if (try_session_cache && ret == NULL && !(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) { SSL_SESSION data; data.ssl_version = s->version; memset(data.session_id, 0, sizeof(data.session_id)); memcpy(data.session_id, hello->session_id, hello->session_id_len); data.session_id_length = hello->session_id_len; CRYPTO_THREAD_read_lock(s->session_ctx->lock); ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data); if (ret != NULL) { SSL_SESSION_up_ref(ret); } CRYPTO_THREAD_unlock(s->session_ctx->lock); if (ret == NULL) s->session_ctx->stats.sess_miss++; } if (try_session_cache && ret == NULL && s->session_ctx->get_session_cb != NULL) { int copy = 1; ret = s->session_ctx->get_session_cb(s, hello->session_id, hello->session_id_len, &copy); if (ret != NULL) { s->session_ctx->stats.sess_cb_hit++; if (copy) SSL_SESSION_up_ref(ret); if (! (s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE)) { if (SSL_CTX_add_session(s->session_ctx, ret)) goto err; } } } if (ret == NULL) goto err; if (ret->ssl_version != s->version) goto err; if (ret->sid_ctx_length != s->sid_ctx_length || memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) { goto err; } if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) { SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED); fatal = 1; goto err; } <S2SV_StartVul> if (ret->cipher == NULL) { <S2SV_EndVul> <S2SV_StartVul> unsigned char buf[5], *p; <S2SV_EndVul> <S2SV_StartVul> unsigned long l; <S2SV_EndVul> <S2SV_StartVul> p = buf; <S2SV_EndVul> <S2SV_StartVul> l = ret->cipher_id; <S2SV_EndVul> <S2SV_StartVul> l2n(l, p); <S2SV_EndVul> <S2SV_StartVul> if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR) <S2SV_EndVul> <S2SV_StartVul> ret->cipher = ssl_get_cipher_by_char(s, &(buf[2])); <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> ret->cipher = ssl_get_cipher_by_char(s, &(buf[1])); <S2SV_EndVul> <S2SV_StartVul> if (ret->cipher == NULL) <S2SV_EndVul> <S2SV_StartVul> goto err; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (ret->timeout < (long)(time(NULL) - ret->time)) { s->session_ctx->stats.sess_timeout++; if (try_session_cache) { SSL_CTX_remove_session(s->session_ctx, ret); } goto err; } if (ret->flags & SSL_SESS_FLAG_EXTMS) { if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS)) { SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_INCONSISTENT_EXTMS); ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); fatal = 1; goto err; } } else if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) { goto err; } if (!SSL_IS_TLS13(s)) { SSL_SESSION_free(s->session); s->session = ret; } s->session_ctx->stats.sess_hit++; s->verify_result = s->session->verify_result; return 1; err: if (ret != NULL) { SSL_SESSION_free(ret); if (SSL_IS_TLS13(s)) s->session = NULL; if (!try_session_cache) { s->ext.ticket_expected = 1; } } if (fatal) return -1; else return 0; }","- if (ret->cipher == NULL) {
- unsigned char buf[5], *p;
- unsigned long l;
- p = buf;
- l = ret->cipher_id;
- l2n(l, p);
- if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)
- ret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));
- else
- ret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));
- if (ret->cipher == NULL)
- goto err;
- }","int ssl_get_prev_session(SSL *s, CLIENTHELLO_MSG *hello) { SSL_SESSION *ret = NULL; int fatal = 0; int try_session_cache = 0; int r; if (SSL_IS_TLS13(s)) { int al; if (!tls_parse_extension(s, TLSEXT_IDX_psk, EXT_CLIENT_HELLO, hello->pre_proc_exts, NULL, 0, &al)) return -1; ret = s->session; } else { r = tls_get_ticket_from_client(s, hello, &ret); switch (r) { case -1: fatal = 1; goto err; case 0: case 1: try_session_cache = 1; break; case 2: case 3: break; default: abort(); } } if (try_session_cache && ret == NULL && !(s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) { SSL_SESSION data; data.ssl_version = s->version; memset(data.session_id, 0, sizeof(data.session_id)); memcpy(data.session_id, hello->session_id, hello->session_id_len); data.session_id_length = hello->session_id_len; CRYPTO_THREAD_read_lock(s->session_ctx->lock); ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data); if (ret != NULL) { SSL_SESSION_up_ref(ret); } CRYPTO_THREAD_unlock(s->session_ctx->lock); if (ret == NULL) s->session_ctx->stats.sess_miss++; } if (try_session_cache && ret == NULL && s->session_ctx->get_session_cb != NULL) { int copy = 1; ret = s->session_ctx->get_session_cb(s, hello->session_id, hello->session_id_len, &copy); if (ret != NULL) { s->session_ctx->stats.sess_cb_hit++; if (copy) SSL_SESSION_up_ref(ret); if (! (s->session_ctx->session_cache_mode & SSL_SESS_CACHE_NO_INTERNAL_STORE)) { if (SSL_CTX_add_session(s->session_ctx, ret)) goto err; } } } if (ret == NULL) goto err; if (ret->ssl_version != s->version) goto err; if (ret->sid_ctx_length != s->sid_ctx_length || memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) { goto err; } if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) { SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED); fatal = 1; goto err; } if (ret->timeout < (long)(time(NULL) - ret->time)) { s->session_ctx->stats.sess_timeout++; if (try_session_cache) { SSL_CTX_remove_session(s->session_ctx, ret); } goto err; } if (ret->flags & SSL_SESS_FLAG_EXTMS) { if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS)) { SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_INCONSISTENT_EXTMS); ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); fatal = 1; goto err; } } else if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) { goto err; } if (!SSL_IS_TLS13(s)) { SSL_SESSION_free(s->session); s->session = ret; } s->session_ctx->stats.sess_hit++; s->verify_result = s->session->verify_result; return 1; err: if (ret != NULL) { SSL_SESSION_free(ret); if (SSL_IS_TLS13(s)) s->session = NULL; if (!try_session_cache) { s->ext.ticket_expected = 1; } } if (fatal) return -1; else return 0; }"
10223----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_de1f9385cd2b3439f6967eb3b72c07ccf3903526_1.json----ngx_http_file_cache_lock,"static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r, ngx_http_cache_t *c) { ngx_msec_t now, timer; ngx_http_file_cache_t *cache; if (!c->lock) { return NGX_DECLINED; } cache = c->file_cache; ngx_shmtx_lock(&cache->shpool->mutex); <S2SV_StartVul> if (!c->node->updating) { <S2SV_EndVul> c->node->updating = 1; c->updating = 1; } ngx_shmtx_unlock(&cache->shpool->mutex); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http file cache lock u:%d wt:%M"", c->updating, c->wait_time); if (c->updating) { return NGX_DECLINED; } <S2SV_StartVul> c->waiting = 1; <S2SV_EndVul> <S2SV_StartVul> now = ngx_current_msec; <S2SV_EndVul> if (c->wait_time == 0) { c->wait_time = now + c->lock_timeout; c->wait_event.handler = ngx_http_file_cache_lock_wait_handler; c->wait_event.data = r; c->wait_event.log = r->connection->log; } timer = c->wait_time - now; ngx_add_timer(&c->wait_event, (timer > 500) ? 500 : timer); r->main->blocked++; return NGX_AGAIN; }","- if (!c->node->updating) {
- c->waiting = 1;
- now = ngx_current_msec;
+ now = ngx_current_msec;
+ timer = c->node->lock_time - now;
+ if (!c->node->updating || (ngx_msec_int_t) timer <= 0) {
+ c->node->lock_time = now + c->lock_age;
+ c->lock_time = c->node->lock_time;
+ if (c->lock_timeout == 0) {
+ return NGX_HTTP_CACHE_SCARCE;
+ }
+ c->waiting = 1;","static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r, ngx_http_cache_t *c) { ngx_msec_t now, timer; ngx_http_file_cache_t *cache; if (!c->lock) { return NGX_DECLINED; } now = ngx_current_msec; cache = c->file_cache; ngx_shmtx_lock(&cache->shpool->mutex); timer = c->node->lock_time - now; if (!c->node->updating || (ngx_msec_int_t) timer <= 0) { c->node->updating = 1; c->node->lock_time = now + c->lock_age; c->updating = 1; c->lock_time = c->node->lock_time; } ngx_shmtx_unlock(&cache->shpool->mutex); ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http file cache lock u:%d wt:%M"", c->updating, c->wait_time); if (c->updating) { return NGX_DECLINED; } if (c->lock_timeout == 0) { return NGX_HTTP_CACHE_SCARCE; } c->waiting = 1; if (c->wait_time == 0) { c->wait_time = now + c->lock_timeout; c->wait_event.handler = ngx_http_file_cache_lock_wait_handler; c->wait_event.data = r; c->wait_event.log = r->connection->log; } timer = c->wait_time - now; ngx_add_timer(&c->wait_event, (timer > 500) ? 500 : timer); r->main->blocked++; return NGX_AGAIN; }"
16975----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_eb70282aba0c70825e6968f9b34182cbf10c8b92_1.json----BLAKE2s_Final,"int BLAKE2s_Final(unsigned char *md, BLAKE2S_CTX *c) { int i; <S2SV_StartVul> blake2s_increment_counter(c, (uint32_t)c->buflen); <S2SV_EndVul> blake2s_set_lastblock(c); memset(c->buf + c->buflen, 0, sizeof(c->buf) - c->buflen); <S2SV_StartVul> blake2s_compress(c, c->buf); <S2SV_EndVul> <S2SV_StartVul> for(i = 0; i < 8; ++i) { <S2SV_EndVul> store32(md + sizeof(c->h[i]) * i, c->h[i]); } OPENSSL_cleanse(c, sizeof(BLAKE2S_CTX)); return 1; }","- blake2s_increment_counter(c, (uint32_t)c->buflen);
- blake2s_compress(c, c->buf);
- for(i = 0; i < 8; ++i) {
+ blake2s_compress(c, c->buf, c->buflen);
+ for (i = 0; i < 8; ++i) {","int BLAKE2s_Final(unsigned char *md, BLAKE2S_CTX *c) { int i; blake2s_set_lastblock(c); memset(c->buf + c->buflen, 0, sizeof(c->buf) - c->buflen); blake2s_compress(c, c->buf, c->buflen); for (i = 0; i < 8; ++i) { store32(md + sizeof(c->h[i]) * i, c->h[i]); } OPENSSL_cleanse(c, sizeof(BLAKE2S_CTX)); return 1; }"
11687----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3309fea9c831959929b9a3954c7addfad9b960e4_1.json----ASN1_UTCTIME_adj,"ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t, int offset_day, long offset_sec) { char *p; struct tm *ts; struct tm data; size_t len = 20; int free_s = 0; if (s == NULL) { s = ASN1_UTCTIME_new(); if (s == NULL) goto err; free_s = 1; } ts = OPENSSL_gmtime(&t, &data); if (ts == NULL) goto err; if (offset_day || offset_sec) { if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec)) goto err; } if ((ts->tm_year < 50) || (ts->tm_year >= 150)) goto err; p = (char *)s->data; if ((p == NULL) || ((size_t)s->length < len)) { p = OPENSSL_malloc(len); if (p == NULL) { ASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE); goto err; } OPENSSL_free(s->data); s->data = (unsigned char *)p; } <S2SV_StartVul> BIO_snprintf(p, len, ""%02d%02d%02d%02d%02d%02dZ"", ts->tm_year % 100, <S2SV_EndVul> <S2SV_StartVul> ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min, <S2SV_EndVul> <S2SV_StartVul> ts->tm_sec); <S2SV_EndVul> s->length = strlen(p); s->type = V_ASN1_UTCTIME; #ifdef CHARSET_EBCDIC_not ebcdic2ascii(s->data, s->data, s->length); #endif return (s); err: if (free_s) ASN1_UTCTIME_free(s); return NULL; }","- BIO_snprintf(p, len, ""%02d%02d%02d%02d%02d%02dZ"", ts->tm_year % 100,
- ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,
- ts->tm_sec);
+ sprintf(p, ""%02d%02d%02d%02d%02d%02dZ"", ts->tm_year % 100,
+ ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,
+ ts->tm_sec);","ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t, int offset_day, long offset_sec) { char *p; struct tm *ts; struct tm data; size_t len = 20; int free_s = 0; if (s == NULL) { s = ASN1_UTCTIME_new(); if (s == NULL) goto err; free_s = 1; } ts = OPENSSL_gmtime(&t, &data); if (ts == NULL) goto err; if (offset_day || offset_sec) { if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec)) goto err; } if ((ts->tm_year < 50) || (ts->tm_year >= 150)) goto err; p = (char *)s->data; if ((p == NULL) || ((size_t)s->length < len)) { p = OPENSSL_malloc(len); if (p == NULL) { ASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE); goto err; } OPENSSL_free(s->data); s->data = (unsigned char *)p; } sprintf(p, ""%02d%02d%02d%02d%02d%02dZ"", ts->tm_year % 100, ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min, ts->tm_sec); s->length = strlen(p); s->type = V_ASN1_UTCTIME; #ifdef CHARSET_EBCDIC_not ebcdic2ascii(s->data, s->data, s->length); #endif return (s); err: if (free_s) ASN1_UTCTIME_free(s); return NULL; }"
2994----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a3062896ad56cd4745cb26dec03e2fedc6cc1518_1.json----fill_buffer,"static void fill_buffer(AVIOContext *s) { int max_buffer_size = s->max_packet_size ? s->max_packet_size : IO_BUFFER_SIZE; uint8_t *dst = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ? s->buf_end : s->buffer; int len = s->buffer_size - (dst - s->buffer); if (!s->read_packet && s->buf_ptr >= s->buf_end) s->eof_reached = 1; if (s->eof_reached) return; if (s->update_checksum && dst == s->buffer) { if (s->buf_end > s->checksum_ptr) s->checksum = s->update_checksum(s->checksum, s->checksum_ptr, s->buf_end - s->checksum_ptr); s->checksum_ptr = s->buffer; } if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) { if (dst == s->buffer) { <S2SV_StartVul> ffio_set_buf_size(s, s->orig_buffer_size); <S2SV_EndVul> s->checksum_ptr = dst = s->buffer; } av_assert0(len >= s->orig_buffer_size); len = s->orig_buffer_size; } if (s->read_packet) len = s->read_packet(s->opaque, dst, len); else len = 0; if (len <= 0) { s->eof_reached = 1; if (len < 0) s->error = len; } else { s->pos += len; s->buf_ptr = dst; s->buf_end = dst + len; s->bytes_read += len; } }","- ffio_set_buf_size(s, s->orig_buffer_size);
+ int ret = ffio_set_buf_size(s, s->orig_buffer_size);
+ if (ret < 0)
+ av_log(s, AV_LOG_WARNING, ""Failed to decrease buffer size\n"");","static void fill_buffer(AVIOContext *s) { int max_buffer_size = s->max_packet_size ? s->max_packet_size : IO_BUFFER_SIZE; uint8_t *dst = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ? s->buf_end : s->buffer; int len = s->buffer_size - (dst - s->buffer); if (!s->read_packet && s->buf_ptr >= s->buf_end) s->eof_reached = 1; if (s->eof_reached) return; if (s->update_checksum && dst == s->buffer) { if (s->buf_end > s->checksum_ptr) s->checksum = s->update_checksum(s->checksum, s->checksum_ptr, s->buf_end - s->checksum_ptr); s->checksum_ptr = s->buffer; } if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) { if (dst == s->buffer) { int ret = ffio_set_buf_size(s, s->orig_buffer_size); if (ret < 0) av_log(s, AV_LOG_WARNING, ""Failed to decrease buffer size\n""); s->checksum_ptr = dst = s->buffer; } av_assert0(len >= s->orig_buffer_size); len = s->orig_buffer_size; } if (s->read_packet) len = s->read_packet(s->opaque, dst, len); else len = 0; if (len <= 0) { s->eof_reached = 1; if (len < 0) s->error = len; } else { s->pos += len; s->buf_ptr = dst; s->buf_end = dst + len; s->bytes_read += len; } }"
14584----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_976c84f9ac3987f322f7dba225e862836cfe0bb5_1.json----EVP_VerifyFinal,"int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf, unsigned int siglen, EVP_PKEY *pkey) { unsigned char m[EVP_MAX_MD_SIZE]; unsigned int m_len; <S2SV_StartVul> int i,ok=0,v; <S2SV_EndVul> MS_STATIC EVP_MD_CTX tmp_ctx; EVP_MD_CTX_init(&tmp_ctx); if (!EVP_MD_CTX_copy_ex(&tmp_ctx,ctx)) goto err; if (!EVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len)) goto err; EVP_MD_CTX_cleanup(&tmp_ctx); if (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE) { <S2SV_StartVul> EVP_PKEY_CTX *pkctx = NULL; <S2SV_EndVul> i = -1; pkctx = EVP_PKEY_CTX_new(pkey, NULL); if (!pkctx) goto err; if (EVP_PKEY_verify_init(pkctx) <= 0) goto err; if (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0) goto err; i = EVP_PKEY_verify(pkctx, sigbuf, siglen, m, m_len); err: EVP_PKEY_CTX_free(pkctx); return i; } for (i=0; i<4; i++) { v=ctx->digest->required_pkey_type[i]; if (v == 0) break; if (pkey->type == v) { ok=1; break; } } if (!ok) { EVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE); return(-1); } if (ctx->digest->verify == NULL) { EVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_NO_VERIFY_FUNCTION_CONFIGURED); return(0); } return(ctx->digest->verify(ctx->digest->type,m,m_len, sigbuf,siglen,pkey->pkey.ptr)); }","- int i,ok=0,v;
- EVP_PKEY_CTX *pkctx = NULL;
+ int i = 0,ok = 0,v;
+ EVP_PKEY_CTX *pkctx = NULL;","int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf, unsigned int siglen, EVP_PKEY *pkey) { unsigned char m[EVP_MAX_MD_SIZE]; unsigned int m_len; int i = 0,ok = 0,v; MS_STATIC EVP_MD_CTX tmp_ctx; EVP_PKEY_CTX *pkctx = NULL; EVP_MD_CTX_init(&tmp_ctx); if (!EVP_MD_CTX_copy_ex(&tmp_ctx,ctx)) goto err; if (!EVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len)) goto err; EVP_MD_CTX_cleanup(&tmp_ctx); if (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE) { i = -1; pkctx = EVP_PKEY_CTX_new(pkey, NULL); if (!pkctx) goto err; if (EVP_PKEY_verify_init(pkctx) <= 0) goto err; if (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0) goto err; i = EVP_PKEY_verify(pkctx, sigbuf, siglen, m, m_len); err: EVP_PKEY_CTX_free(pkctx); return i; } for (i=0; i<4; i++) { v=ctx->digest->required_pkey_type[i]; if (v == 0) break; if (pkey->type == v) { ok=1; break; } } if (!ok) { EVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE); return(-1); } if (ctx->digest->verify == NULL) { EVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_NO_VERIFY_FUNCTION_CONFIGURED); return(0); } return(ctx->digest->verify(ctx->digest->type,m,m_len, sigbuf,siglen,pkey->pkey.ptr)); }"
449----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_19835309342c6c05b23d3bfe9d38937aad3c2046_1.json----verify_md5,"static int verify_md5(HEVCContext *s, AVFrame *frame) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format); <S2SV_StartVul> int pixel_shift = desc->comp[0].depth_minus1 > 7; <S2SV_EndVul> int i, j; if (!desc) return AVERROR(EINVAL); av_log(s->avctx, AV_LOG_DEBUG, ""Verifying checksum for frame with POC %d: "", s->poc); #if HAVE_BIGENDIAN if (pixel_shift && !s->checksum_buf) { av_fast_malloc(&s->checksum_buf, &s->checksum_buf_size, FFMAX3(frame->linesize[0], frame->linesize[1], frame->linesize[2])); if (!s->checksum_buf) return AVERROR(ENOMEM); } #endif for (i = 0; frame->data[i]; i++) { int width = s->avctx->coded_width; int height = s->avctx->coded_height; int w = (i == 1 || i == 2) ? (width >> desc->log2_chroma_w) : width; int h = (i == 1 || i == 2) ? (height >> desc->log2_chroma_h) : height; uint8_t md5[16]; av_md5_init(s->md5_ctx); for (j = 0; j < h; j++) { const uint8_t *src = frame->data[i] + j * frame->linesize[i]; #if HAVE_BIGENDIAN if (pixel_shift) { s->dsp.bswap16_buf((uint16_t*)s->checksum_buf, (const uint16_t*)src, w); src = s->checksum_buf; } #endif av_md5_update(s->md5_ctx, src, w << pixel_shift); } av_md5_final(s->md5_ctx, md5); if (!memcmp(md5, s->md5[i], 16)) { av_log (s->avctx, AV_LOG_DEBUG, ""plane %d - correct "", i); print_md5(s->avctx, AV_LOG_DEBUG, md5); av_log (s->avctx, AV_LOG_DEBUG, ""; ""); } else { av_log (s->avctx, AV_LOG_ERROR, ""mismatching checksum of plane %d - "", i); print_md5(s->avctx, AV_LOG_ERROR, md5); av_log (s->avctx, AV_LOG_ERROR, "" != ""); print_md5(s->avctx, AV_LOG_ERROR, s->md5[i]); av_log (s->avctx, AV_LOG_ERROR, ""\n""); return AVERROR_INVALIDDATA; } } av_log(s->avctx, AV_LOG_DEBUG, ""\n""); return 0; }","- int pixel_shift = desc->comp[0].depth_minus1 > 7;
+ int pixel_shift;
+ pixel_shift = desc->comp[0].depth_minus1 > 7;","static int verify_md5(HEVCContext *s, AVFrame *frame) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format); int pixel_shift; int i, j; if (!desc) return AVERROR(EINVAL); pixel_shift = desc->comp[0].depth_minus1 > 7; av_log(s->avctx, AV_LOG_DEBUG, ""Verifying checksum for frame with POC %d: "", s->poc); #if HAVE_BIGENDIAN if (pixel_shift && !s->checksum_buf) { av_fast_malloc(&s->checksum_buf, &s->checksum_buf_size, FFMAX3(frame->linesize[0], frame->linesize[1], frame->linesize[2])); if (!s->checksum_buf) return AVERROR(ENOMEM); } #endif for (i = 0; frame->data[i]; i++) { int width = s->avctx->coded_width; int height = s->avctx->coded_height; int w = (i == 1 || i == 2) ? (width >> desc->log2_chroma_w) : width; int h = (i == 1 || i == 2) ? (height >> desc->log2_chroma_h) : height; uint8_t md5[16]; av_md5_init(s->md5_ctx); for (j = 0; j < h; j++) { const uint8_t *src = frame->data[i] + j * frame->linesize[i]; #if HAVE_BIGENDIAN if (pixel_shift) { s->dsp.bswap16_buf((uint16_t*)s->checksum_buf, (const uint16_t*)src, w); src = s->checksum_buf; } #endif av_md5_update(s->md5_ctx, src, w << pixel_shift); } av_md5_final(s->md5_ctx, md5); if (!memcmp(md5, s->md5[i], 16)) { av_log (s->avctx, AV_LOG_DEBUG, ""plane %d - correct "", i); print_md5(s->avctx, AV_LOG_DEBUG, md5); av_log (s->avctx, AV_LOG_DEBUG, ""; ""); } else { av_log (s->avctx, AV_LOG_ERROR, ""mismatching checksum of plane %d - "", i); print_md5(s->avctx, AV_LOG_ERROR, md5); av_log (s->avctx, AV_LOG_ERROR, "" != ""); print_md5(s->avctx, AV_LOG_ERROR, s->md5[i]); av_log (s->avctx, AV_LOG_ERROR, ""\n""); return AVERROR_INVALIDDATA; } } av_log(s->avctx, AV_LOG_DEBUG, ""\n""); return 0; }"
11372----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_28261c1d353174fdc94bb2ef525e1667fd5cb888_1.json----SSL_add_ssl_module,"void SSL_add_ssl_module(void) { <S2SV_StartVul> CONF_module_add(""ssl_conf"", ssl_module_init, ssl_module_free); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- CONF_module_add(""ssl_conf"", ssl_module_init, ssl_module_free);
- }",void SSL_add_ssl_module(void) { }
6627----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_64c49fb107735bb9c902260416125f7d028d59b4_1.json----udp_set_multicast_ttl,"static int udp_set_multicast_ttl(int sockfd, int mcastTTL, struct sockaddr *addr) { #ifdef IP_MULTICAST_TTL if (addr->sa_family == AF_INET) { if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &mcastTTL, sizeof(mcastTTL)) < 0) { <S2SV_StartVul> av_log(NULL, AV_LOG_ERROR, ""setsockopt(IP_MULTICAST_TTL): %s\n"", strerror(errno)); <S2SV_EndVul> return -1; } } #endif #if defined(IPPROTO_IPV6) && defined(IPV6_MULTICAST_HOPS) if (addr->sa_family == AF_INET6) { if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &mcastTTL, sizeof(mcastTTL)) < 0) { <S2SV_StartVul> av_log(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_MULTICAST_HOPS): %s\n"", strerror(errno)); <S2SV_EndVul> return -1; } } #endif return 0; }","- av_log(NULL, AV_LOG_ERROR, ""setsockopt(IP_MULTICAST_TTL): %s\n"", strerror(errno));
- av_log(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_MULTICAST_HOPS): %s\n"", strerror(errno));
+ log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IP_MULTICAST_TTL)"");
+ log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_MULTICAST_HOPS)"");","static int udp_set_multicast_ttl(int sockfd, int mcastTTL, struct sockaddr *addr) { #ifdef IP_MULTICAST_TTL if (addr->sa_family == AF_INET) { if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &mcastTTL, sizeof(mcastTTL)) < 0) { log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IP_MULTICAST_TTL)""); return -1; } } #endif #if defined(IPPROTO_IPV6) && defined(IPV6_MULTICAST_HOPS) if (addr->sa_family == AF_INET6) { if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &mcastTTL, sizeof(mcastTTL)) < 0) { log_net_error(NULL, AV_LOG_ERROR, ""setsockopt(IPV6_MULTICAST_HOPS)""); return -1; } } #endif return 0; }"
6209----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4b59e22c12bf32306df4182118b6c4ad571a241e_1.json----formant_postfilter,"static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf) { int16_t filter_coef[2][LPC_ORDER], *buf_ptr; int filter_signal[LPC_ORDER + FRAME_LEN], *signal_ptr; int i, j, k; memcpy(buf, p->fir_mem, LPC_ORDER * sizeof(*buf)); memcpy(filter_signal, p->iir_mem, LPC_ORDER * sizeof(*filter_signal)); for (i = LPC_ORDER, j = 0; j < SUBFRAMES; i += SUBFRAME_LEN, j++) { for (k = 0; k < LPC_ORDER; k++) { filter_coef[0][k] = (-lpc[k] * postfilter_tbl[0][k] + (1 << 14)) >> 15; filter_coef[1][k] = (-lpc[k] * postfilter_tbl[1][k] + (1 << 14)) >> 15; } iir_filter(filter_coef[0], filter_coef[1], buf + i, filter_signal + i); lpc += LPC_ORDER; } memcpy(p->fir_mem, buf + FRAME_LEN, LPC_ORDER * sizeof(*p->fir_mem)); memcpy(p->iir_mem, filter_signal + FRAME_LEN, LPC_ORDER * sizeof(*p->iir_mem)); buf_ptr = buf + LPC_ORDER; signal_ptr = filter_signal + LPC_ORDER; for (i = 0; i < SUBFRAMES; i++) { int16_t temp_vector[SUBFRAME_LEN]; <S2SV_StartVul> int16_t temp; <S2SV_EndVul> int auto_corr[2]; int scale, energy; memcpy(temp_vector, buf_ptr, SUBFRAME_LEN * sizeof(*temp_vector)); scale = scale_vector(temp_vector, SUBFRAME_LEN); auto_corr[0] = dot_product(temp_vector, temp_vector + 1, SUBFRAME_LEN - 1, 1); auto_corr[1] = dot_product(temp_vector, temp_vector, SUBFRAME_LEN, 1); temp = auto_corr[1] >> 16; if (temp) { temp = (auto_corr[0] >> 2) / temp; } p->reflection_coef = (3 * p->reflection_coef + temp + 2) >> 2; <S2SV_StartVul> temp = (p->reflection_coef * 0xffffc >> 3) & 0xfffc; <S2SV_EndVul> for (j = 0; j < SUBFRAME_LEN; j++) { buf_ptr[j] = av_clipl_int32(signal_ptr[j] + ((signal_ptr[j - 1] >> 16) * temp << 1)) >> 16; } temp = 2 * scale + 4; if (temp < 0) { energy = av_clipl_int32((int64_t)auto_corr[1] << -temp); } else energy = auto_corr[1] >> temp; gain_scale(p, buf_ptr, energy); buf_ptr += SUBFRAME_LEN; signal_ptr += SUBFRAME_LEN; } }","- int16_t temp;
- temp = (p->reflection_coef * 0xffffc >> 3) & 0xfffc;
+ int temp;
+ temp = -p->reflection_coef >> 1 & ~3;","static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf) { int16_t filter_coef[2][LPC_ORDER], *buf_ptr; int filter_signal[LPC_ORDER + FRAME_LEN], *signal_ptr; int i, j, k; memcpy(buf, p->fir_mem, LPC_ORDER * sizeof(*buf)); memcpy(filter_signal, p->iir_mem, LPC_ORDER * sizeof(*filter_signal)); for (i = LPC_ORDER, j = 0; j < SUBFRAMES; i += SUBFRAME_LEN, j++) { for (k = 0; k < LPC_ORDER; k++) { filter_coef[0][k] = (-lpc[k] * postfilter_tbl[0][k] + (1 << 14)) >> 15; filter_coef[1][k] = (-lpc[k] * postfilter_tbl[1][k] + (1 << 14)) >> 15; } iir_filter(filter_coef[0], filter_coef[1], buf + i, filter_signal + i); lpc += LPC_ORDER; } memcpy(p->fir_mem, buf + FRAME_LEN, LPC_ORDER * sizeof(*p->fir_mem)); memcpy(p->iir_mem, filter_signal + FRAME_LEN, LPC_ORDER * sizeof(*p->iir_mem)); buf_ptr = buf + LPC_ORDER; signal_ptr = filter_signal + LPC_ORDER; for (i = 0; i < SUBFRAMES; i++) { int16_t temp_vector[SUBFRAME_LEN]; int temp; int auto_corr[2]; int scale, energy; memcpy(temp_vector, buf_ptr, SUBFRAME_LEN * sizeof(*temp_vector)); scale = scale_vector(temp_vector, SUBFRAME_LEN); auto_corr[0] = dot_product(temp_vector, temp_vector + 1, SUBFRAME_LEN - 1, 1); auto_corr[1] = dot_product(temp_vector, temp_vector, SUBFRAME_LEN, 1); temp = auto_corr[1] >> 16; if (temp) { temp = (auto_corr[0] >> 2) / temp; } p->reflection_coef = (3 * p->reflection_coef + temp + 2) >> 2; temp = -p->reflection_coef >> 1 & ~3; for (j = 0; j < SUBFRAME_LEN; j++) { buf_ptr[j] = av_clipl_int32(signal_ptr[j] + ((signal_ptr[j - 1] >> 16) * temp << 1)) >> 16; } temp = 2 * scale + 4; if (temp < 0) { energy = av_clipl_int32((int64_t)auto_corr[1] << -temp); } else energy = auto_corr[1] >> temp; gain_scale(p, buf_ptr, energy); buf_ptr += SUBFRAME_LEN; signal_ptr += SUBFRAME_LEN; } }"
6076----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_1.json----output_packet,"static int output_packet(InputStream *ist, const AVPacket *pkt) { int i; int got_output; int64_t pkt_pts = AV_NOPTS_VALUE; AVPacket avpkt; if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->last_dts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); if (pkt->pts != AV_NOPTS_VALUE) pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q); while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int ret = 0; handle_eof: ist->last_dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, ""Multiple frames in a packet from stream %d\n"", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = transcode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = transcode_video (ist, &avpkt, &got_output, &pkt_pts); if (avpkt.duration) ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); else if (ist->st->r_frame_rate.num) ist->next_dts += av_rescale_q(1, (AVRational){ist->st->r_frame_rate.den, ist->st->r_frame_rate.num}, AV_TIME_BASE_Q); else if (ist->st->codec->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame; ist->next_dts += av_rescale_q(ticks, ist->st->codec->time_base, AV_TIME_BASE_Q); } break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; if (pkt) { avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { rate_emu_sleep(ist); ist->last_dts = ist->next_dts; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) / ist->st->codec->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->st->codec->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } break; } } for (i = 0; pkt && i < nb_output_streams; i++) { <S2SV_StartVul> OutputStream *ost = &output_streams[i]; <S2SV_EndVul> if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }","- OutputStream *ost = &output_streams[i];
+ OutputStream *ost = output_streams[i];","static int output_packet(InputStream *ist, const AVPacket *pkt) { int i; int got_output; int64_t pkt_pts = AV_NOPTS_VALUE; AVPacket avpkt; if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->last_dts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); if (pkt->pts != AV_NOPTS_VALUE) pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q); while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int ret = 0; handle_eof: ist->last_dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, ""Multiple frames in a packet from stream %d\n"", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = transcode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = transcode_video (ist, &avpkt, &got_output, &pkt_pts); if (avpkt.duration) ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); else if (ist->st->r_frame_rate.num) ist->next_dts += av_rescale_q(1, (AVRational){ist->st->r_frame_rate.den, ist->st->r_frame_rate.num}, AV_TIME_BASE_Q); else if (ist->st->codec->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame; ist->next_dts += av_rescale_q(ticks, ist->st->codec->time_base, AV_TIME_BASE_Q); } break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; if (pkt) { avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { rate_emu_sleep(ist); ist->last_dts = ist->next_dts; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) / ist->st->codec->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->st->codec->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->time_base.num * ticks) / ist->st->codec->time_base.den; } break; } } for (i = 0; pkt && i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }"
2091----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7257f40c6184faac2d93f87214b4b47ed73e0388_1.json----mcdc,"<S2SV_StartVul> static inline void mcdc(uint16_t *dst, uint16_t *src, int log2w, int h, int stride, int scale, int dc){ <S2SV_EndVul> int i; dc*= 0x10001; switch(log2w){ case 0: for(i=0; i<h; i++){ dst[0] = scale*src[0] + dc; if(scale) src += stride; dst += stride; } break; case 1: for(i=0; i<h; i++){ LE_CENTRIC_MUL(dst, src, scale, dc); if(scale) src += stride; dst += stride; } break; case 2: for(i=0; i<h; i++){ LE_CENTRIC_MUL(dst, src, scale, dc); LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc); if(scale) src += stride; dst += stride; } break; case 3: for(i=0; i<h; i++){ LE_CENTRIC_MUL(dst, src, scale, dc); LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc); LE_CENTRIC_MUL(dst + 4, src + 4, scale, dc); LE_CENTRIC_MUL(dst + 6, src + 6, scale, dc); if(scale) src += stride; dst += stride; } break; default: assert(0); } }","- static inline void mcdc(uint16_t *dst, uint16_t *src, int log2w, int h, int stride, int scale, int dc){
+ static inline void mcdc(uint16_t *dst, uint16_t *src, int log2w, int h, int stride, int scale, unsigned dc){","static inline void mcdc(uint16_t *dst, uint16_t *src, int log2w, int h, int stride, int scale, unsigned dc){ int i; dc*= 0x10001; switch(log2w){ case 0: for(i=0; i<h; i++){ dst[0] = scale*src[0] + dc; if(scale) src += stride; dst += stride; } break; case 1: for(i=0; i<h; i++){ LE_CENTRIC_MUL(dst, src, scale, dc); if(scale) src += stride; dst += stride; } break; case 2: for(i=0; i<h; i++){ LE_CENTRIC_MUL(dst, src, scale, dc); LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc); if(scale) src += stride; dst += stride; } break; case 3: for(i=0; i<h; i++){ LE_CENTRIC_MUL(dst, src, scale, dc); LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc); LE_CENTRIC_MUL(dst + 4, src + 4, scale, dc); LE_CENTRIC_MUL(dst + 6, src + 6, scale, dc); if(scale) src += stride; dst += stride; } break; default: assert(0); } }"
5665----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_291c1b07455b08bcabf8dd217db79a81abc6e67d_1.json----ogg_packet,"static int ogg_packet (AVFormatContext * s, int *str, int *dstart, int *dsize, int64_t *fpos) { struct ogg *ogg = s->priv_data; int idx, i; struct ogg_stream *os; int complete = 0; int segp = 0, psize = 0; #if 0 av_log (s, AV_LOG_DEBUG, ""ogg_packet: curidx=%i\n"", ogg->curidx); #endif do{ idx = ogg->curidx; while (idx < 0){ if (ogg_read_page (s, &idx) < 0) return -1; } os = ogg->streams + idx; #if 0 av_log (s, AV_LOG_DEBUG, ""ogg_packet: idx=%d pstart=%d psize=%d segp=%d nsegs=%d\n"", idx, os->pstart, os->psize, os->segp, os->nsegs); #endif if (!os->codec){ if (os->header < 0){ os->codec = ogg_find_codec (os->buf, os->bufpos); if (!os->codec){ os->header = 0; return 0; } }else{ return 0; } } segp = os->segp; psize = os->psize; while (os->segp < os->nsegs){ int ss = os->segments[os->segp++]; os->psize += ss; if (ss < 255){ complete = 1; break; } } if (!complete && os->segp == os->nsegs){ ogg->curidx = -1; os->incomplete = 1; } }while (!complete); #if 0 av_log (s, AV_LOG_DEBUG, ""ogg_packet: idx %i, frame size %i, start %i\n"", idx, os->psize, os->pstart); #endif ogg->curidx = idx; os->incomplete = 0; <S2SV_StartVul> if (!ogg->headers){ <S2SV_EndVul> <S2SV_StartVul> int hdr = os->codec->header (s, idx); <S2SV_EndVul> <S2SV_StartVul> os->header = os->seq; <S2SV_EndVul> <S2SV_StartVul> if (!hdr){ <S2SV_EndVul> os->segp = segp; os->psize = psize; ogg->headers = 1; <S2SV_StartVul> s->data_offset = os->sync_pos; <S2SV_EndVul> }else{ os->pstart += os->psize; os->psize = 0; } <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (os->header > -1 && os->seq > os->header){ <S2SV_EndVul> os->pflags = 0; os->pduration = 0; if (os->codec && os->codec->packet) os->codec->packet (s, idx); if (str) *str = idx; if (dstart) *dstart = os->pstart; if (dsize) *dsize = os->psize; if (fpos) *fpos = os->sync_pos; os->pstart += os->psize; os->psize = 0; os->sync_pos = os->page_pos; } os->page_end = 1; for (i = os->segp; i < os->nsegs; i++) if (os->segments[i] < 255) { os->page_end = 0; break; } <S2SV_StartVul> os->seq++; <S2SV_EndVul> if (os->segp == os->nsegs) ogg->curidx = -1; return 0; }","- if (!ogg->headers){
- int hdr = os->codec->header (s, idx);
- os->header = os->seq;
- if (!hdr){
- s->data_offset = os->sync_pos;
- }
- if (os->header > -1 && os->seq > os->header){
- os->seq++;
+ if (os->header) {
+ os->header = os->codec->header (s, idx);
+ if (!os->header){
+ if (!ogg->headers)
+ s->data_offset = os->sync_pos;
+ } else {","static int ogg_packet (AVFormatContext * s, int *str, int *dstart, int *dsize, int64_t *fpos) { struct ogg *ogg = s->priv_data; int idx, i; struct ogg_stream *os; int complete = 0; int segp = 0, psize = 0; #if 0 av_log (s, AV_LOG_DEBUG, ""ogg_packet: curidx=%i\n"", ogg->curidx); #endif do{ idx = ogg->curidx; while (idx < 0){ if (ogg_read_page (s, &idx) < 0) return -1; } os = ogg->streams + idx; #if 0 av_log (s, AV_LOG_DEBUG, ""ogg_packet: idx=%d pstart=%d psize=%d segp=%d nsegs=%d\n"", idx, os->pstart, os->psize, os->segp, os->nsegs); #endif if (!os->codec){ if (os->header < 0){ os->codec = ogg_find_codec (os->buf, os->bufpos); if (!os->codec){ os->header = 0; return 0; } }else{ return 0; } } segp = os->segp; psize = os->psize; while (os->segp < os->nsegs){ int ss = os->segments[os->segp++]; os->psize += ss; if (ss < 255){ complete = 1; break; } } if (!complete && os->segp == os->nsegs){ ogg->curidx = -1; os->incomplete = 1; } }while (!complete); #if 0 av_log (s, AV_LOG_DEBUG, ""ogg_packet: idx %i, frame size %i, start %i\n"", idx, os->psize, os->pstart); #endif ogg->curidx = idx; os->incomplete = 0; if (os->header) { os->header = os->codec->header (s, idx); if (!os->header){ os->segp = segp; os->psize = psize; if (!ogg->headers) s->data_offset = os->sync_pos; ogg->headers = 1; }else{ os->pstart += os->psize; os->psize = 0; } } else { os->pflags = 0; os->pduration = 0; if (os->codec && os->codec->packet) os->codec->packet (s, idx); if (str) *str = idx; if (dstart) *dstart = os->pstart; if (dsize) *dsize = os->psize; if (fpos) *fpos = os->sync_pos; os->pstart += os->psize; os->psize = 0; os->sync_pos = os->page_pos; } os->page_end = 1; for (i = os->segp; i < os->nsegs; i++) if (os->segments[i] < 255) { os->page_end = 0; break; } if (os->segp == os->nsegs) ogg->curidx = -1; return 0; }"
12652----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5402d3f8f74b9cda8d201e05cfbde1870254ff92_1.json----tls_construct_stoc_renegotiate,"EXT_RETURN tls_construct_stoc_renegotiate(SSL *s, WPACKET *pkt, unsigned int context, X509 *x, size_t chainidx) { <S2SV_StartVul> if (!s->s3->send_connection_binding) <S2SV_EndVul> return EXT_RETURN_NOT_SENT; if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_renegotiate) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_start_sub_packet_u8(pkt) <S2SV_StartVul> || !WPACKET_memcpy(pkt, s->s3->previous_client_finished, <S2SV_EndVul> <S2SV_StartVul> s->s3->previous_client_finished_len) <S2SV_EndVul> <S2SV_StartVul> || !WPACKET_memcpy(pkt, s->s3->previous_server_finished, <S2SV_EndVul> <S2SV_StartVul> s->s3->previous_server_finished_len) <S2SV_EndVul> || !WPACKET_close(pkt) || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE, ERR_R_INTERNAL_ERROR); return EXT_RETURN_FAIL; } return EXT_RETURN_SENT; }","- if (!s->s3->send_connection_binding)
- || !WPACKET_memcpy(pkt, s->s3->previous_client_finished,
- s->s3->previous_client_finished_len)
- || !WPACKET_memcpy(pkt, s->s3->previous_server_finished,
- s->s3->previous_server_finished_len)
+ if (!s->s3.send_connection_binding)
+ || !WPACKET_memcpy(pkt, s->s3.previous_client_finished,
+ s->s3.previous_client_finished_len)
+ || !WPACKET_memcpy(pkt, s->s3.previous_server_finished,
+ s->s3.previous_server_finished_len)","EXT_RETURN tls_construct_stoc_renegotiate(SSL *s, WPACKET *pkt, unsigned int context, X509 *x, size_t chainidx) { if (!s->s3.send_connection_binding) return EXT_RETURN_NOT_SENT; if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_renegotiate) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_start_sub_packet_u8(pkt) || !WPACKET_memcpy(pkt, s->s3.previous_client_finished, s->s3.previous_client_finished_len) || !WPACKET_memcpy(pkt, s->s3.previous_server_finished, s->s3.previous_server_finished_len) || !WPACKET_close(pkt) || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE, ERR_R_INTERNAL_ERROR); return EXT_RETURN_FAIL; } return EXT_RETURN_SENT; }"
10273----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_000abaeb6fb99358ce2c1efdc56b7b15bf5a0b2c_1.json----bn_expand2,"BIGNUM *bn_expand2(BIGNUM *b, int words) { <S2SV_StartVul> BN_ULONG *A; <S2SV_EndVul> <S2SV_StartVul> int i; <S2SV_EndVul> bn_check_top(b); if (words > b->dmax) { BN_ULONG *a = bn_expand_internal(b, words); if(!a) return NULL; if(b->d) OPENSSL_free(b->d); b->d=a; b->dmax=words; } if (b->top < b->dmax) { <S2SV_StartVul> A = &(b->d[b->top]); <S2SV_EndVul> for (i=(b->dmax - b->top)>>3; i>0; i--,A+=8) { A[0]=0; A[1]=0; A[2]=0; A[3]=0; A[4]=0; A[5]=0; A[6]=0; A[7]=0; } for (i=(b->dmax - b->top)&7; i>0; i--,A++) A[0]=0; assert(A == &(b->d[b->dmax])); } bn_check_top(b); return b; }","- BN_ULONG *A;
- int i;
- A = &(b->d[b->top]);
+ #if 0
+ int i;
+ BN_ULONG *A = &(b->d[b->top]);
+ #endif","BIGNUM *bn_expand2(BIGNUM *b, int words) { bn_check_top(b); if (words > b->dmax) { BN_ULONG *a = bn_expand_internal(b, words); if(!a) return NULL; if(b->d) OPENSSL_free(b->d); b->d=a; b->dmax=words; } #if 0 if (b->top < b->dmax) { int i; BN_ULONG *A = &(b->d[b->top]); for (i=(b->dmax - b->top)>>3; i>0; i--,A+=8) { A[0]=0; A[1]=0; A[2]=0; A[3]=0; A[4]=0; A[5]=0; A[6]=0; A[7]=0; } for (i=(b->dmax - b->top)&7; i>0; i--,A++) A[0]=0; assert(A == &(b->d[b->dmax])); } #endif bn_check_top(b); return b; }"
3502----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bd3f9eeb97a5d4772ceb58075189093cff823a4b_1.json----mxf_write_header_metadata_sets,"static int mxf_write_header_metadata_sets(AVFormatContext *s) { <S2SV_StartVul> AVStream *st; <S2SV_EndVul> <S2SV_StartVul> MXFStreamContext *sc = NULL; <S2SV_EndVul> <S2SV_StartVul> int i; <S2SV_EndVul> mxf_write_preface(s); mxf_write_identification(s); mxf_write_content_storage(s); <S2SV_StartVul> for (i = 0; i < s->nb_streams; i++) { <S2SV_EndVul> <S2SV_StartVul> st = s->streams[i]; <S2SV_EndVul> <S2SV_StartVul> sc = av_mallocz(sizeof(MXFStreamContext)); <S2SV_EndVul> <S2SV_StartVul> if (!sc) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> <S2SV_StartVul> st->priv_data = sc; <S2SV_EndVul> <S2SV_StartVul> if (st->codec->codec_type == CODEC_TYPE_VIDEO) <S2SV_EndVul> <S2SV_StartVul> av_set_pts_info(st, 64, 1, st->codec->time_base.den); <S2SV_EndVul> <S2SV_StartVul> else if (st->codec->codec_type == CODEC_TYPE_AUDIO) <S2SV_EndVul> <S2SV_StartVul> av_set_pts_info(st, 64, 1, st->codec->sample_rate); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> mxf_build_structural_metadata(s, MaterialPackage); mxf_build_structural_metadata(s, SourcePackage); return 0; }","- AVStream *st;
- MXFStreamContext *sc = NULL;
- int i;
- for (i = 0; i < s->nb_streams; i++) {
- st = s->streams[i];
- sc = av_mallocz(sizeof(MXFStreamContext));
- if (!sc)
- return AVERROR(ENOMEM);
- st->priv_data = sc;
- if (st->codec->codec_type == CODEC_TYPE_VIDEO)
- av_set_pts_info(st, 64, 1, st->codec->time_base.den);
- else if (st->codec->codec_type == CODEC_TYPE_AUDIO)
- av_set_pts_info(st, 64, 1, st->codec->sample_rate);
- }","static int mxf_write_header_metadata_sets(AVFormatContext *s) { mxf_write_preface(s); mxf_write_identification(s); mxf_write_content_storage(s); mxf_build_structural_metadata(s, MaterialPackage); mxf_build_structural_metadata(s, SourcePackage); return 0; }"
12590----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_51fa1750855ce49f16d4305ab622163ce120dfe1_1.json----append_buf,"static int append_buf(char **buf, const char *s, int *size, int step) { if (*buf == NULL) { *size = step; *buf = app_malloc(*size, ""engine buffer""); **buf = '\0'; } if (strlen(*buf) + strlen(s) >= (unsigned int)*size) { *size += step; *buf = OPENSSL_realloc(*buf, *size); } if (*buf == NULL) return 0; if (**buf != '\0') <S2SV_StartVul> BUF_strlcat(*buf, "", "", *size); <S2SV_EndVul> <S2SV_StartVul> BUF_strlcat(*buf, s, *size); <S2SV_EndVul> return 1; }","- BUF_strlcat(*buf, "", "", *size);
- BUF_strlcat(*buf, s, *size);
+ OPENSSL_strlcat(*buf, "", "", *size);
+ OPENSSL_strlcat(*buf, s, *size);","static int append_buf(char **buf, const char *s, int *size, int step) { if (*buf == NULL) { *size = step; *buf = app_malloc(*size, ""engine buffer""); **buf = '\0'; } if (strlen(*buf) + strlen(s) >= (unsigned int)*size) { *size += step; *buf = OPENSSL_realloc(*buf, *size); } if (*buf == NULL) return 0; if (**buf != '\0') OPENSSL_strlcat(*buf, "", "", *size); OPENSSL_strlcat(*buf, s, *size); return 1; }"
8370----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_cc1f713311284c17845bca5d5214980c5a404d20_1.json----av_get_image_linesize,"int av_get_image_linesize(enum PixelFormat pix_fmt, int width, int plane) { const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt]; int max_step [4]; int max_step_comp[4]; int s; if (desc->flags & PIX_FMT_BITSTREAM) return (width * (desc->comp[0].step_minus1+1) + 7) >> 3; <S2SV_StartVul> av_fill_image_max_pixstep(max_step, max_step_comp, desc); <S2SV_EndVul> s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0; return max_step[plane] * (((width + (1 << s) - 1)) >> s); }","- av_fill_image_max_pixstep(max_step, max_step_comp, desc);
+ av_fill_image_max_pixsteps(max_step, max_step_comp, desc);","int av_get_image_linesize(enum PixelFormat pix_fmt, int width, int plane) { const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt]; int max_step [4]; int max_step_comp[4]; int s; if (desc->flags & PIX_FMT_BITSTREAM) return (width * (desc->comp[0].step_minus1+1) + 7) >> 3; av_fill_image_max_pixsteps(max_step, max_step_comp, desc); s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0; return max_step[plane] * (((width + (1 << s) - 1)) >> s); }"
15588----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b9d912813e7f34c64d38422e12edb60094a19c64_1.json----OPENSSL_sk_new,OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc c) { OPENSSL_STACK *ret; if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) goto err; <S2SV_StartVul> if ((ret->data = OPENSSL_zalloc(sizeof(*ret->data) * MIN_NODES)) == NULL) <S2SV_EndVul> goto err; ret->comp = c; <S2SV_StartVul> ret->num_alloc = MIN_NODES; <S2SV_EndVul> return (ret); err: OPENSSL_free(ret); return (NULL); },"- if ((ret->data = OPENSSL_zalloc(sizeof(*ret->data) * MIN_NODES)) == NULL)
- ret->num_alloc = MIN_NODES;
+ if ((ret->data = OPENSSL_zalloc(sizeof(*ret->data) * min_nodes)) == NULL)
+ ret->num_alloc = min_nodes;",OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc c) { OPENSSL_STACK *ret; if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL) goto err; if ((ret->data = OPENSSL_zalloc(sizeof(*ret->data) * min_nodes)) == NULL) goto err; ret->comp = c; ret->num_alloc = min_nodes; return (ret); err: OPENSSL_free(ret); return (NULL); }
13900----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7f1863f41d1927e313fbf20dbee20d39cdac6d21_1.json----UI_create_method,"UI_METHOD *UI_create_method(char *name) { UI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD)); if (ui_method) memset(ui_method, 0, sizeof(*ui_method)); <S2SV_StartVul> ui_method->name = BUF_strdup(name); <S2SV_EndVul> return ui_method; }","- ui_method->name = BUF_strdup(name);
+ {
+ ui_method->name = BUF_strdup(name);
+ }","UI_METHOD *UI_create_method(char *name) { UI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD)); if (ui_method) { memset(ui_method, 0, sizeof(*ui_method)); ui_method->name = BUF_strdup(name); } return ui_method; }"
1635----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5bce7eb47e85106738dd3a0f4a3e16b90a59b4e0_1.json----new_video_stream,"static void new_video_stream(AVFormatContext *oc, int file_idx) { AVStream *st; AVOutputStream *ost; AVCodecContext *video_enc; <S2SV_StartVul> enum CodecID codec_id; <S2SV_EndVul> AVCodec *codec= NULL; st = av_new_stream(oc, oc->nb_streams < nb_streamid_map ? streamid_map[oc->nb_streams] : 0); if (!st) { fprintf(stderr, ""Could not alloc stream\n""); ffmpeg_exit(1); } ost = new_output_stream(oc, file_idx); output_codecs = grow_array(output_codecs, sizeof(*output_codecs), &nb_output_codecs, nb_output_codecs + 1); if(!video_stream_copy){ if (video_codec_name) { codec_id = find_codec_or_die(video_codec_name, AVMEDIA_TYPE_VIDEO, 1, avcodec_opts[AVMEDIA_TYPE_VIDEO]->strict_std_compliance); codec = avcodec_find_encoder_by_name(video_codec_name); output_codecs[nb_output_codecs-1] = codec; } else { codec_id = av_guess_codec(oc->oformat, NULL, oc->filename, NULL, AVMEDIA_TYPE_VIDEO); codec = avcodec_find_encoder(codec_id); } } avcodec_get_context_defaults3(st->codec, codec); ost->bitstream_filters = video_bitstream_filters; video_bitstream_filters= NULL; avcodec_thread_init(st->codec, thread_count); video_enc = st->codec; if(video_codec_tag) video_enc->codec_tag= video_codec_tag; if( (video_global_header&1) || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){ video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER; avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags|= CODEC_FLAG_GLOBAL_HEADER; } if(video_global_header&2){ video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER; avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags2|= CODEC_FLAG2_LOCAL_HEADER; } if (video_stream_copy) { st->stream_copy = 1; video_enc->codec_type = AVMEDIA_TYPE_VIDEO; video_enc->sample_aspect_ratio = st->sample_aspect_ratio = av_d2q(frame_aspect_ratio*frame_height/frame_width, 255); } else { const char *p; int i; AVRational fps= frame_rate.num ? frame_rate : (AVRational){25,1}; video_enc->codec_id = codec_id; set_context_opts(video_enc, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM, codec); if (codec && codec->supported_framerates && !force_fps) fps = codec->supported_framerates[av_find_nearest_q_idx(fps, codec->supported_framerates)]; video_enc->time_base.den = fps.num; video_enc->time_base.num = fps.den; video_enc->width = frame_width; video_enc->height = frame_height; video_enc->sample_aspect_ratio = av_d2q(frame_aspect_ratio*video_enc->height/video_enc->width, 255); video_enc->pix_fmt = frame_pix_fmt; st->sample_aspect_ratio = video_enc->sample_aspect_ratio; choose_pixel_fmt(st, codec); if (intra_only) video_enc->gop_size = 0; if (video_qscale || same_quality) { video_enc->flags |= CODEC_FLAG_QSCALE; video_enc->global_quality= st->quality = FF_QP2LAMBDA * video_qscale; } if(intra_matrix) video_enc->intra_matrix = intra_matrix; if(inter_matrix) video_enc->inter_matrix = inter_matrix; p= video_rc_override_string; for(i=0; p; i++){ int start, end, q; int e=sscanf(p, ""%d,%d,%d"", &start, &end, &q); if(e!=3){ fprintf(stderr, ""error parsing rc_override\n""); ffmpeg_exit(1); } video_enc->rc_override= av_realloc(video_enc->rc_override, sizeof(RcOverride)*(i+1)); video_enc->rc_override[i].start_frame= start; video_enc->rc_override[i].end_frame = end; if(q>0){ video_enc->rc_override[i].qscale= q; video_enc->rc_override[i].quality_factor= 1.0; } else{ video_enc->rc_override[i].qscale= 0; video_enc->rc_override[i].quality_factor= -q/100.0; } p= strchr(p, '/'); if(p) p++; } video_enc->rc_override_count=i; if (!video_enc->rc_initial_buffer_occupancy) video_enc->rc_initial_buffer_occupancy = video_enc->rc_buffer_size*3/4; video_enc->me_threshold= me_threshold; video_enc->intra_dc_precision= intra_dc_precision - 8; if (do_psnr) video_enc->flags|= CODEC_FLAG_PSNR; if (do_pass) { if (do_pass == 1) { video_enc->flags |= CODEC_FLAG_PASS1; } else { video_enc->flags |= CODEC_FLAG_PASS2; } } if (forced_key_frames) parse_forced_key_frames(forced_key_frames, ost, video_enc); } if (video_language) { av_metadata_set2(&st->metadata, ""language"", video_language, 0); av_freep(&video_language); } video_disable = 0; av_freep(&video_codec_name); av_freep(&forced_key_frames); video_stream_copy = 0; frame_pix_fmt = PIX_FMT_NONE; }","- enum CodecID codec_id;
+ enum CodecID codec_id = CODEC_ID_NONE;","static void new_video_stream(AVFormatContext *oc, int file_idx) { AVStream *st; AVOutputStream *ost; AVCodecContext *video_enc; enum CodecID codec_id = CODEC_ID_NONE; AVCodec *codec= NULL; st = av_new_stream(oc, oc->nb_streams < nb_streamid_map ? streamid_map[oc->nb_streams] : 0); if (!st) { fprintf(stderr, ""Could not alloc stream\n""); ffmpeg_exit(1); } ost = new_output_stream(oc, file_idx); output_codecs = grow_array(output_codecs, sizeof(*output_codecs), &nb_output_codecs, nb_output_codecs + 1); if(!video_stream_copy){ if (video_codec_name) { codec_id = find_codec_or_die(video_codec_name, AVMEDIA_TYPE_VIDEO, 1, avcodec_opts[AVMEDIA_TYPE_VIDEO]->strict_std_compliance); codec = avcodec_find_encoder_by_name(video_codec_name); output_codecs[nb_output_codecs-1] = codec; } else { codec_id = av_guess_codec(oc->oformat, NULL, oc->filename, NULL, AVMEDIA_TYPE_VIDEO); codec = avcodec_find_encoder(codec_id); } } avcodec_get_context_defaults3(st->codec, codec); ost->bitstream_filters = video_bitstream_filters; video_bitstream_filters= NULL; avcodec_thread_init(st->codec, thread_count); video_enc = st->codec; if(video_codec_tag) video_enc->codec_tag= video_codec_tag; if( (video_global_header&1) || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){ video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER; avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags|= CODEC_FLAG_GLOBAL_HEADER; } if(video_global_header&2){ video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER; avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags2|= CODEC_FLAG2_LOCAL_HEADER; } if (video_stream_copy) { st->stream_copy = 1; video_enc->codec_type = AVMEDIA_TYPE_VIDEO; video_enc->sample_aspect_ratio = st->sample_aspect_ratio = av_d2q(frame_aspect_ratio*frame_height/frame_width, 255); } else { const char *p; int i; AVRational fps= frame_rate.num ? frame_rate : (AVRational){25,1}; video_enc->codec_id = codec_id; set_context_opts(video_enc, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM, codec); if (codec && codec->supported_framerates && !force_fps) fps = codec->supported_framerates[av_find_nearest_q_idx(fps, codec->supported_framerates)]; video_enc->time_base.den = fps.num; video_enc->time_base.num = fps.den; video_enc->width = frame_width; video_enc->height = frame_height; video_enc->sample_aspect_ratio = av_d2q(frame_aspect_ratio*video_enc->height/video_enc->width, 255); video_enc->pix_fmt = frame_pix_fmt; st->sample_aspect_ratio = video_enc->sample_aspect_ratio; choose_pixel_fmt(st, codec); if (intra_only) video_enc->gop_size = 0; if (video_qscale || same_quality) { video_enc->flags |= CODEC_FLAG_QSCALE; video_enc->global_quality= st->quality = FF_QP2LAMBDA * video_qscale; } if(intra_matrix) video_enc->intra_matrix = intra_matrix; if(inter_matrix) video_enc->inter_matrix = inter_matrix; p= video_rc_override_string; for(i=0; p; i++){ int start, end, q; int e=sscanf(p, ""%d,%d,%d"", &start, &end, &q); if(e!=3){ fprintf(stderr, ""error parsing rc_override\n""); ffmpeg_exit(1); } video_enc->rc_override= av_realloc(video_enc->rc_override, sizeof(RcOverride)*(i+1)); video_enc->rc_override[i].start_frame= start; video_enc->rc_override[i].end_frame = end; if(q>0){ video_enc->rc_override[i].qscale= q; video_enc->rc_override[i].quality_factor= 1.0; } else{ video_enc->rc_override[i].qscale= 0; video_enc->rc_override[i].quality_factor= -q/100.0; } p= strchr(p, '/'); if(p) p++; } video_enc->rc_override_count=i; if (!video_enc->rc_initial_buffer_occupancy) video_enc->rc_initial_buffer_occupancy = video_enc->rc_buffer_size*3/4; video_enc->me_threshold= me_threshold; video_enc->intra_dc_precision= intra_dc_precision - 8; if (do_psnr) video_enc->flags|= CODEC_FLAG_PSNR; if (do_pass) { if (do_pass == 1) { video_enc->flags |= CODEC_FLAG_PASS1; } else { video_enc->flags |= CODEC_FLAG_PASS2; } } if (forced_key_frames) parse_forced_key_frames(forced_key_frames, ost, video_enc); } if (video_language) { av_metadata_set2(&st->metadata, ""language"", video_language, 0); av_freep(&video_language); } video_disable = 0; av_freep(&video_codec_name); av_freep(&forced_key_frames); video_stream_copy = 0; frame_pix_fmt = PIX_FMT_NONE; }"
669----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_24a241122ffd03eb3a9da75a76adfba43ceefe0b_1.json----mov_stsc_index_valid,"<S2SV_StartVul> static inline int mov_stsc_index_valid(int index, int count) <S2SV_EndVul> { <S2SV_StartVul> return index + 1 < count; <S2SV_EndVul> }","- static inline int mov_stsc_index_valid(int index, int count)
- return index + 1 < count;
+ static inline int mov_stsc_index_valid(unsigned int index, unsigned int count)
+ return index < count - 1;","static inline int mov_stsc_index_valid(unsigned int index, unsigned int count) { return index < count - 1; }"
3246----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b0d7e5309b34ffc0b5acb05763366e2336741928_1.json----wv_unpack_mono,"static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb, void *dst, const int type) { int i, j, count = 0; int last, t; int A, S, T; int pos = s->pos; uint32_t crc = s->sc.crc; uint32_t crc_extra_bits = s->extra_sc.crc; int16_t *dst16 = dst; int32_t *dst32 = dst; float *dstfl = dst; s->one = s->zero = s->zeroes = 0; do { T = wv_get_value(s, gb, 0, &last); S = 0; if (last) break; for (i = 0; i < s->terms; i++) { t = s->decorr[i].value; if (t > 8) { if (t & 1) A = 2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]; else A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1; s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0]; j = 0; } else { A = s->decorr[i].samplesA[pos]; j = (pos + t) & 7; } if (type != AV_SAMPLE_FMT_S16P) S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10); else <S2SV_StartVul> S = T + ((s->decorr[i].weightA * A + 512) >> 10); <S2SV_EndVul> if (A && T) s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta; s->decorr[i].samplesA[j] = T = S; } pos = (pos + 1) & 7; crc = crc * 3 + S; if (type == AV_SAMPLE_FMT_FLTP) { *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S); } else if (type == AV_SAMPLE_FMT_S32P) { *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S); } else { *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S); } count++; } while (!last && count < s->samples); wv_reset_saved_context(s); if (last && count < s->samples) { int size = av_get_bytes_per_sample(type); memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size); } if (s->avctx->err_recognition & AV_EF_CRCCHECK) { int ret = wv_check_crc(s, crc, crc_extra_bits); if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE) return ret; } return 0; }","- S = T + ((s->decorr[i].weightA * A + 512) >> 10);
+ S = T + ((int)(s->decorr[i].weightA * (unsigned)A + 512) >> 10);","static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb, void *dst, const int type) { int i, j, count = 0; int last, t; int A, S, T; int pos = s->pos; uint32_t crc = s->sc.crc; uint32_t crc_extra_bits = s->extra_sc.crc; int16_t *dst16 = dst; int32_t *dst32 = dst; float *dstfl = dst; s->one = s->zero = s->zeroes = 0; do { T = wv_get_value(s, gb, 0, &last); S = 0; if (last) break; for (i = 0; i < s->terms; i++) { t = s->decorr[i].value; if (t > 8) { if (t & 1) A = 2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]; else A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1; s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0]; j = 0; } else { A = s->decorr[i].samplesA[pos]; j = (pos + t) & 7; } if (type != AV_SAMPLE_FMT_S16P) S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10); else S = T + ((int)(s->decorr[i].weightA * (unsigned)A + 512) >> 10); if (A && T) s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta; s->decorr[i].samplesA[j] = T = S; } pos = (pos + 1) & 7; crc = crc * 3 + S; if (type == AV_SAMPLE_FMT_FLTP) { *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S); } else if (type == AV_SAMPLE_FMT_S32P) { *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S); } else { *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S); } count++; } while (!last && count < s->samples); wv_reset_saved_context(s); if (last && count < s->samples) { int size = av_get_bytes_per_sample(type); memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size); } if (s->avctx->err_recognition & AV_EF_CRCCHECK) { int ret = wv_check_crc(s, crc, crc_extra_bits); if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE) return ret; } return 0; }"
2381----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_830e60e1fa6467b5383f77ad0dfd7c69a29d5300_1.json----swr_convert_frame,"int swr_convert_frame(SwrContext *s, AVFrame *out, const AVFrame *in) { int ret, setup = 0; if (!swr_is_initialized(s)) { if ((ret = swr_config_frame(s, out, in)) < 0) return ret; if ((ret = swr_init(s)) < 0) return ret; setup = 1; } else { if ((ret = config_changed(s, out, in))) return ret; } if (out) { if (!out->linesize[0]) { <S2SV_StartVul> out->nb_samples = swr_get_delay(s, s->out_sample_rate) <S2SV_EndVul> <S2SV_StartVul> + in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate <S2SV_EndVul> <S2SV_StartVul> + 3; <S2SV_EndVul> if ((ret = av_frame_get_buffer(out, 0)) < 0) { if (setup) swr_close(s); return ret; } } else { if (!out->nb_samples) out->nb_samples = available_samples(out); } } return convert_frame(s, out, in); }","- out->nb_samples = swr_get_delay(s, s->out_sample_rate)
- + in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate
- + 3;
+ out->nb_samples = swr_get_delay(s, s->out_sample_rate) + 3;
+ if (in) {
+ out->nb_samples += in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate;
+ }","int swr_convert_frame(SwrContext *s, AVFrame *out, const AVFrame *in) { int ret, setup = 0; if (!swr_is_initialized(s)) { if ((ret = swr_config_frame(s, out, in)) < 0) return ret; if ((ret = swr_init(s)) < 0) return ret; setup = 1; } else { if ((ret = config_changed(s, out, in))) return ret; } if (out) { if (!out->linesize[0]) { out->nb_samples = swr_get_delay(s, s->out_sample_rate) + 3; if (in) { out->nb_samples += in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate; } if ((ret = av_frame_get_buffer(out, 0)) < 0) { if (setup) swr_close(s); return ret; } } else { if (!out->nb_samples) out->nb_samples = available_samples(out); } } return convert_frame(s, out, in); }"
13615----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7612027932b3e77c3e01c62979cc5a4177a9bfc0_1.json----OPENSSL_sk_pop,"void *OPENSSL_sk_pop(OPENSSL_STACK *st) { if (st == NULL) <S2SV_StartVul> return (NULL); <S2SV_EndVul> if (st->num <= 0) <S2SV_StartVul> return (NULL); <S2SV_EndVul> <S2SV_StartVul> return (OPENSSL_sk_delete(st, st->num - 1)); <S2SV_EndVul> }","- return (NULL);
- return (NULL);
- return (OPENSSL_sk_delete(st, st->num - 1));
+ return NULL;
+ return NULL;
+ return internal_delete(st, st->num - 1);","void *OPENSSL_sk_pop(OPENSSL_STACK *st) { if (st == NULL) return NULL; if (st->num <= 0) return NULL; return internal_delete(st, st->num - 1); }"
5982----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3d1d64a3e6dc24acb0f694925d064068fa3bbfca_1.json----mov_read_sv3d,"static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; int size, version, layout; int32_t yaw, pitch, roll; <S2SV_StartVul> size_t l = 0, t = 0, r = 0, b = 0; <S2SV_EndVul> <S2SV_StartVul> size_t padding = 0; <S2SV_EndVul> <S2SV_StartVul> uint32_t tag; <S2SV_EndVul> enum AVSphericalProjection projection; if (c->fc->nb_streams < 1) return 0; st = c->fc->streams[c->fc->nb_streams - 1]; sc = st->priv_data; if (atom.size < 8) { av_log(c->fc, AV_LOG_ERROR, ""Empty spherical video box\n""); return AVERROR_INVALIDDATA; } size = avio_rb32(pb); if (size <= 12 || size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); if (tag != MKTAG('s','v','h','d')) { av_log(c->fc, AV_LOG_ERROR, ""Missing spherical video header\n""); return 0; } version = avio_r8(pb); if (version != 0) { av_log(c->fc, AV_LOG_WARNING, ""Unknown spherical version %d\n"", version); return 0; } avio_skip(pb, 3); avio_skip(pb, size - 12); size = avio_rb32(pb); if (size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); if (tag != MKTAG('p','r','o','j')) { av_log(c->fc, AV_LOG_ERROR, ""Missing projection box\n""); return 0; } size = avio_rb32(pb); if (size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); if (tag != MKTAG('p','r','h','d')) { av_log(c->fc, AV_LOG_ERROR, ""Missing projection header box\n""); return 0; } version = avio_r8(pb); if (version != 0) { av_log(c->fc, AV_LOG_WARNING, ""Unknown spherical version %d\n"", version); return 0; } avio_skip(pb, 3); yaw = avio_rb32(pb); pitch = avio_rb32(pb); roll = avio_rb32(pb); size = avio_rb32(pb); if (size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); version = avio_r8(pb); if (version != 0) { av_log(c->fc, AV_LOG_WARNING, ""Unknown spherical version %d\n"", version); return 0; } avio_skip(pb, 3); switch (tag) { case MKTAG('c','b','m','p'): layout = avio_rb32(pb); if (layout) { av_log(c->fc, AV_LOG_WARNING, ""Unsupported cubemap layout %d\n"", layout); return 0; } projection = AV_SPHERICAL_CUBEMAP; padding = avio_rb32(pb); break; case MKTAG('e','q','u','i'): t = avio_rb32(pb); b = avio_rb32(pb); l = avio_rb32(pb); r = avio_rb32(pb); if (b >= UINT_MAX - t || r >= UINT_MAX - l) { av_log(c->fc, AV_LOG_ERROR, ""Invalid bounding rectangle coordinates "" <S2SV_StartVul> ""%zu,%zu,%zu,%zu\n"", l, t, r, b); <S2SV_EndVul> return AVERROR_INVALIDDATA; } if (l || t || r || b) projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE; else projection = AV_SPHERICAL_EQUIRECTANGULAR; break; default: av_log(c->fc, AV_LOG_ERROR, ""Unknown projection type\n""); return 0; } sc->spherical = av_spherical_alloc(&sc->spherical_size); if (!sc->spherical) return AVERROR(ENOMEM); sc->spherical->projection = projection; sc->spherical->yaw = yaw; sc->spherical->pitch = pitch; sc->spherical->roll = roll; sc->spherical->padding = padding; sc->spherical->bound_left = l; sc->spherical->bound_top = t; sc->spherical->bound_right = r; sc->spherical->bound_bottom = b; return 0; }","- size_t l = 0, t = 0, r = 0, b = 0;
- size_t padding = 0;
- uint32_t tag;
- ""%zu,%zu,%zu,%zu\n"", l, t, r, b);
+ uint32_t l = 0, t = 0, r = 0, b = 0;
+ uint32_t tag, padding = 0;
+ ""%""PRIu32"",%""PRIu32"",%""PRIu32"",%""PRIu32""\n"", l, t, r, b);","static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; int size, version, layout; int32_t yaw, pitch, roll; uint32_t l = 0, t = 0, r = 0, b = 0; uint32_t tag, padding = 0; enum AVSphericalProjection projection; if (c->fc->nb_streams < 1) return 0; st = c->fc->streams[c->fc->nb_streams - 1]; sc = st->priv_data; if (atom.size < 8) { av_log(c->fc, AV_LOG_ERROR, ""Empty spherical video box\n""); return AVERROR_INVALIDDATA; } size = avio_rb32(pb); if (size <= 12 || size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); if (tag != MKTAG('s','v','h','d')) { av_log(c->fc, AV_LOG_ERROR, ""Missing spherical video header\n""); return 0; } version = avio_r8(pb); if (version != 0) { av_log(c->fc, AV_LOG_WARNING, ""Unknown spherical version %d\n"", version); return 0; } avio_skip(pb, 3); avio_skip(pb, size - 12); size = avio_rb32(pb); if (size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); if (tag != MKTAG('p','r','o','j')) { av_log(c->fc, AV_LOG_ERROR, ""Missing projection box\n""); return 0; } size = avio_rb32(pb); if (size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); if (tag != MKTAG('p','r','h','d')) { av_log(c->fc, AV_LOG_ERROR, ""Missing projection header box\n""); return 0; } version = avio_r8(pb); if (version != 0) { av_log(c->fc, AV_LOG_WARNING, ""Unknown spherical version %d\n"", version); return 0; } avio_skip(pb, 3); yaw = avio_rb32(pb); pitch = avio_rb32(pb); roll = avio_rb32(pb); size = avio_rb32(pb); if (size > atom.size) return AVERROR_INVALIDDATA; tag = avio_rl32(pb); version = avio_r8(pb); if (version != 0) { av_log(c->fc, AV_LOG_WARNING, ""Unknown spherical version %d\n"", version); return 0; } avio_skip(pb, 3); switch (tag) { case MKTAG('c','b','m','p'): layout = avio_rb32(pb); if (layout) { av_log(c->fc, AV_LOG_WARNING, ""Unsupported cubemap layout %d\n"", layout); return 0; } projection = AV_SPHERICAL_CUBEMAP; padding = avio_rb32(pb); break; case MKTAG('e','q','u','i'): t = avio_rb32(pb); b = avio_rb32(pb); l = avio_rb32(pb); r = avio_rb32(pb); if (b >= UINT_MAX - t || r >= UINT_MAX - l) { av_log(c->fc, AV_LOG_ERROR, ""Invalid bounding rectangle coordinates "" ""%""PRIu32"",%""PRIu32"",%""PRIu32"",%""PRIu32""\n"", l, t, r, b); return AVERROR_INVALIDDATA; } if (l || t || r || b) projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE; else projection = AV_SPHERICAL_EQUIRECTANGULAR; break; default: av_log(c->fc, AV_LOG_ERROR, ""Unknown projection type\n""); return 0; } sc->spherical = av_spherical_alloc(&sc->spherical_size); if (!sc->spherical) return AVERROR(ENOMEM); sc->spherical->projection = projection; sc->spherical->yaw = yaw; sc->spherical->pitch = pitch; sc->spherical->roll = roll; sc->spherical->padding = padding; sc->spherical->bound_left = l; sc->spherical->bound_top = t; sc->spherical->bound_right = r; sc->spherical->bound_bottom = b; return 0; }"
8365----DEAD_STORE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_cbe0ae4aa54c7e31f4d9333314105b7e0ae4b2cc_1.json----encode_frame,"static int encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pic, int *got_packet) { ProresContext *ctx = avctx->priv_data; uint8_t *orig_buf, *buf, *slice_hdr, *slice_sizes, *tmp; uint8_t *picture_size_pos; PutBitContext pb; int x, y, i, mb, q = 0; int sizes[4] = { 0 }; int slice_hdr_size = 2 + 2 * (ctx->num_planes - 1); int frame_size, picture_size, slice_size; <S2SV_StartVul> int mbs_per_slice = ctx->mbs_per_slice; <S2SV_EndVul> int pkt_size, ret; *avctx->coded_frame = *pic; avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I; avctx->coded_frame->key_frame = 1; pkt_size = ctx->frame_size + FF_MIN_BUFFER_SIZE; if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) { av_log(avctx, AV_LOG_ERROR, ""Error getting output packet.\n""); return ret; } orig_buf = pkt->data; orig_buf += 4; bytestream_put_be32 (&orig_buf, FRAME_ID); buf = orig_buf; tmp = buf; buf += 2; bytestream_put_be16 (&buf, 0); bytestream_put_buffer(&buf, ctx->vendor, 4); bytestream_put_be16 (&buf, avctx->width); bytestream_put_be16 (&buf, avctx->height); bytestream_put_byte (&buf, ctx->chroma_factor << 6); bytestream_put_byte (&buf, 0); bytestream_put_byte (&buf, avctx->color_primaries); bytestream_put_byte (&buf, avctx->color_trc); bytestream_put_byte (&buf, avctx->colorspace); bytestream_put_byte (&buf, 0x40); bytestream_put_byte (&buf, 0); if (ctx->quant_sel != QUANT_MAT_DEFAULT) { bytestream_put_byte (&buf, 0x03); for (i = 0; i < 64; i++) bytestream_put_byte(&buf, ctx->quant_mat[i]); for (i = 0; i < 64; i++) bytestream_put_byte(&buf, ctx->quant_mat[i]); } else { bytestream_put_byte (&buf, 0x00); } bytestream_put_be16 (&tmp, buf - orig_buf); picture_size_pos = buf + 1; bytestream_put_byte (&buf, 0x40); buf += 4; bytestream_put_be16 (&buf, ctx->num_slices); bytestream_put_byte (&buf, av_log2(ctx->mbs_per_slice) << 4); slice_sizes = buf; buf += ctx->num_slices * 2; if (!ctx->force_quant) { ret = avctx->execute2(avctx, find_quant_thread, NULL, NULL, ctx->mb_height); if (ret) return ret; } for (y = 0; y < ctx->mb_height; y++) { <S2SV_StartVul> mbs_per_slice = ctx->mbs_per_slice; <S2SV_EndVul> for (x = mb = 0; x < ctx->mb_width; x += mbs_per_slice, mb++) { q = ctx->force_quant ? ctx->force_quant : ctx->slice_q[mb + y * ctx->slices_width]; while (ctx->mb_width - x < mbs_per_slice) mbs_per_slice >>= 1; bytestream_put_byte(&buf, slice_hdr_size << 3); slice_hdr = buf; buf += slice_hdr_size - 1; init_put_bits(&pb, buf, (pkt_size - (buf - orig_buf)) * 8); encode_slice(avctx, pic, &pb, sizes, x, y, q, mbs_per_slice); bytestream_put_byte(&slice_hdr, q); slice_size = slice_hdr_size + sizes[ctx->num_planes - 1]; for (i = 0; i < ctx->num_planes - 1; i++) { bytestream_put_be16(&slice_hdr, sizes[i]); slice_size += sizes[i]; } bytestream_put_be16(&slice_sizes, slice_size); buf += slice_size - slice_hdr_size; } } orig_buf -= 8; frame_size = buf - orig_buf; picture_size = buf - picture_size_pos - 6; bytestream_put_be32(&orig_buf, frame_size); bytestream_put_be32(&picture_size_pos, picture_size); pkt->size = frame_size; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; }","- int mbs_per_slice = ctx->mbs_per_slice;
- mbs_per_slice = ctx->mbs_per_slice;
+ int mbs_per_slice = ctx->mbs_per_slice;","static int encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pic, int *got_packet) { ProresContext *ctx = avctx->priv_data; uint8_t *orig_buf, *buf, *slice_hdr, *slice_sizes, *tmp; uint8_t *picture_size_pos; PutBitContext pb; int x, y, i, mb, q = 0; int sizes[4] = { 0 }; int slice_hdr_size = 2 + 2 * (ctx->num_planes - 1); int frame_size, picture_size, slice_size; int pkt_size, ret; *avctx->coded_frame = *pic; avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I; avctx->coded_frame->key_frame = 1; pkt_size = ctx->frame_size + FF_MIN_BUFFER_SIZE; if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) { av_log(avctx, AV_LOG_ERROR, ""Error getting output packet.\n""); return ret; } orig_buf = pkt->data; orig_buf += 4; bytestream_put_be32 (&orig_buf, FRAME_ID); buf = orig_buf; tmp = buf; buf += 2; bytestream_put_be16 (&buf, 0); bytestream_put_buffer(&buf, ctx->vendor, 4); bytestream_put_be16 (&buf, avctx->width); bytestream_put_be16 (&buf, avctx->height); bytestream_put_byte (&buf, ctx->chroma_factor << 6); bytestream_put_byte (&buf, 0); bytestream_put_byte (&buf, avctx->color_primaries); bytestream_put_byte (&buf, avctx->color_trc); bytestream_put_byte (&buf, avctx->colorspace); bytestream_put_byte (&buf, 0x40); bytestream_put_byte (&buf, 0); if (ctx->quant_sel != QUANT_MAT_DEFAULT) { bytestream_put_byte (&buf, 0x03); for (i = 0; i < 64; i++) bytestream_put_byte(&buf, ctx->quant_mat[i]); for (i = 0; i < 64; i++) bytestream_put_byte(&buf, ctx->quant_mat[i]); } else { bytestream_put_byte (&buf, 0x00); } bytestream_put_be16 (&tmp, buf - orig_buf); picture_size_pos = buf + 1; bytestream_put_byte (&buf, 0x40); buf += 4; bytestream_put_be16 (&buf, ctx->num_slices); bytestream_put_byte (&buf, av_log2(ctx->mbs_per_slice) << 4); slice_sizes = buf; buf += ctx->num_slices * 2; if (!ctx->force_quant) { ret = avctx->execute2(avctx, find_quant_thread, NULL, NULL, ctx->mb_height); if (ret) return ret; } for (y = 0; y < ctx->mb_height; y++) { int mbs_per_slice = ctx->mbs_per_slice; for (x = mb = 0; x < ctx->mb_width; x += mbs_per_slice, mb++) { q = ctx->force_quant ? ctx->force_quant : ctx->slice_q[mb + y * ctx->slices_width]; while (ctx->mb_width - x < mbs_per_slice) mbs_per_slice >>= 1; bytestream_put_byte(&buf, slice_hdr_size << 3); slice_hdr = buf; buf += slice_hdr_size - 1; init_put_bits(&pb, buf, (pkt_size - (buf - orig_buf)) * 8); encode_slice(avctx, pic, &pb, sizes, x, y, q, mbs_per_slice); bytestream_put_byte(&slice_hdr, q); slice_size = slice_hdr_size + sizes[ctx->num_planes - 1]; for (i = 0; i < ctx->num_planes - 1; i++) { bytestream_put_be16(&slice_hdr, sizes[i]); slice_size += sizes[i]; } bytestream_put_be16(&slice_sizes, slice_size); buf += slice_size - slice_hdr_size; } } orig_buf -= 8; frame_size = buf - orig_buf; picture_size = buf - picture_size_pos - 6; bytestream_put_be32(&orig_buf, frame_size); bytestream_put_be32(&picture_size_pos, picture_size); pkt->size = frame_size; pkt->flags |= AV_PKT_FLAG_KEY; *got_packet = 1; return 0; }"
12581----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_51af23894508fbef3f8de651a6b811edfa1b18d6_1.json----EVP_PBE_CipherInit,"int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de) { const EVP_CIPHER *cipher; const EVP_MD *md; int cipher_nid, md_nid; EVP_PBE_KEYGEN *keygen; if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj), &cipher_nid, &md_nid, &keygen)) { char obj_tmp[80]; EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM); if (!pbe_obj) <S2SV_StartVul> BUF_strlcpy(obj_tmp, ""NULL"", sizeof obj_tmp); <S2SV_EndVul> else i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj); ERR_add_error_data(2, ""TYPE="", obj_tmp); return 0; } if (!pass) passlen = 0; else if (passlen == -1) passlen = strlen(pass); if (cipher_nid == -1) cipher = NULL; else { cipher = EVP_get_cipherbynid(cipher_nid); if (!cipher) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER); return 0; } } if (md_nid == -1) md = NULL; else { md = EVP_get_digestbynid(md_nid); if (!md) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST); return 0; } } if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE); return 0; } return 1; }","- BUF_strlcpy(obj_tmp, ""NULL"", sizeof obj_tmp);
+ OPENSSL_strlcpy(obj_tmp, ""NULL"", sizeof obj_tmp);","int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de) { const EVP_CIPHER *cipher; const EVP_MD *md; int cipher_nid, md_nid; EVP_PBE_KEYGEN *keygen; if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj), &cipher_nid, &md_nid, &keygen)) { char obj_tmp[80]; EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM); if (!pbe_obj) OPENSSL_strlcpy(obj_tmp, ""NULL"", sizeof obj_tmp); else i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj); ERR_add_error_data(2, ""TYPE="", obj_tmp); return 0; } if (!pass) passlen = 0; else if (passlen == -1) passlen = strlen(pass); if (cipher_nid == -1) cipher = NULL; else { cipher = EVP_get_cipherbynid(cipher_nid); if (!cipher) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER); return 0; } } if (md_nid == -1) md = NULL; else { md = EVP_get_digestbynid(md_nid); if (!md) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST); return 0; } } if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE); return 0; } return 1; }"
9917----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_36f20e5aa9532fe881dd9d602caaeb7b331ea552_1.json----ngx_http_file_cache_add,"static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache, ngx_http_cache_t *c) { ngx_http_file_cache_node_t *fcn; ngx_shmtx_lock(&cache->shpool->mutex); fcn = ngx_http_file_cache_lookup(cache, c->key); if (fcn == NULL) { <S2SV_StartVul> fcn = ngx_slab_alloc_locked(cache->shpool, <S2SV_EndVul> <S2SV_StartVul> sizeof(ngx_http_file_cache_node_t)); <S2SV_EndVul> if (fcn == NULL) { ngx_shmtx_unlock(&cache->shpool->mutex); return NGX_ERROR; } ngx_memcpy((u_char *) &fcn->node.key, c->key, sizeof(ngx_rbtree_key_t)); ngx_memcpy(fcn->key, &c->key[sizeof(ngx_rbtree_key_t)], NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t)); ngx_rbtree_insert(&cache->sh->rbtree, &fcn->node); fcn->uses = 1; <S2SV_StartVul> fcn->count = 0; <S2SV_EndVul> <S2SV_StartVul> fcn->valid_msec = 0; <S2SV_EndVul> <S2SV_StartVul> fcn->error = 0; <S2SV_EndVul> fcn->exists = 1; <S2SV_StartVul> fcn->updating = 0; <S2SV_EndVul> <S2SV_StartVul> fcn->deleting = 0; <S2SV_EndVul> <S2SV_StartVul> fcn->uniq = 0; <S2SV_EndVul> <S2SV_StartVul> fcn->valid_sec = 0; <S2SV_EndVul> <S2SV_StartVul> fcn->body_start = 0; <S2SV_EndVul> fcn->fs_size = c->fs_size; cache->sh->size += c->fs_size; } else { ngx_queue_remove(&fcn->queue); } fcn->expire = ngx_time() + cache->inactive; ngx_queue_insert_head(&cache->sh->queue, &fcn->queue); ngx_shmtx_unlock(&cache->shpool->mutex); return NGX_OK; }","- fcn = ngx_slab_alloc_locked(cache->shpool,
- sizeof(ngx_http_file_cache_node_t));
- fcn->count = 0;
- fcn->valid_msec = 0;
- fcn->error = 0;
- fcn->updating = 0;
- fcn->deleting = 0;
- fcn->uniq = 0;
- fcn->valid_sec = 0;
- fcn->body_start = 0;
+ fcn = ngx_slab_calloc_locked(cache->shpool,
+ sizeof(ngx_http_file_cache_node_t));","static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache, ngx_http_cache_t *c) { ngx_http_file_cache_node_t *fcn; ngx_shmtx_lock(&cache->shpool->mutex); fcn = ngx_http_file_cache_lookup(cache, c->key); if (fcn == NULL) { fcn = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t)); if (fcn == NULL) { ngx_shmtx_unlock(&cache->shpool->mutex); return NGX_ERROR; } ngx_memcpy((u_char *) &fcn->node.key, c->key, sizeof(ngx_rbtree_key_t)); ngx_memcpy(fcn->key, &c->key[sizeof(ngx_rbtree_key_t)], NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t)); ngx_rbtree_insert(&cache->sh->rbtree, &fcn->node); fcn->uses = 1; fcn->exists = 1; fcn->fs_size = c->fs_size; cache->sh->size += c->fs_size; } else { ngx_queue_remove(&fcn->queue); } fcn->expire = ngx_time() + cache->inactive; ngx_queue_insert_head(&cache->sh->queue, &fcn->queue); ngx_shmtx_unlock(&cache->shpool->mutex); return NGX_OK; }"
7179----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_84baf70d72a069c01cbb6ae861ce460642e60d5a_1.json----planarCopyWrapper,"static int planarCopyWrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dst[], int dstStride[]) { int plane, i, j; for (plane=0; plane<4; plane++) { int length= (plane==0 || plane==3) ? c->srcW : -((-c->srcW )>>c->chrDstHSubSample); int y= (plane==0 || plane==3) ? srcSliceY: -((-srcSliceY)>>c->chrDstVSubSample); int height= (plane==0 || plane==3) ? srcSliceH: -((-srcSliceH)>>c->chrDstVSubSample); const uint8_t *srcPtr= src[plane]; uint8_t *dstPtr= dst[plane] + dstStride[plane]*y; if (!dst[plane]) continue; if (plane == 1 && !dst[2]) continue; if (!src[plane] || (plane == 1 && !src[2])) { if(is16BPS(c->dstFormat)) length*=2; fillPlane(dst[plane], dstStride[plane], length, height, y, (plane==3) ? 255 : 128); } else { if(is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) { if (!isBE(c->srcFormat)) srcPtr++; for (i=0; i<height; i++) { for (j=0; j<length; j++) dstPtr[j] = srcPtr[j<<1]; srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } else if(!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) { for (i=0; i<height; i++) { for (j=0; j<length; j++) { dstPtr[ j<<1 ] = srcPtr[j]; dstPtr[(j<<1)+1] = srcPtr[j]; } srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } else if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat) && isBE(c->srcFormat) != isBE(c->dstFormat)) { for (i=0; i<height; i++) { for (j=0; j<length; j++) ((uint16_t*)dstPtr)[j] = av_bswap16(((const uint16_t*)srcPtr)[j]); srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } <S2SV_StartVul> } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0) <S2SV_EndVul> <S2SV_StartVul> memcpy(dst[plane] + dstStride[plane]*y, src[plane], height*dstStride[plane]); <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_EndVul> if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) length*=2; for (i=0; i<height; i++) { memcpy(dstPtr, srcPtr, length); srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } } } return srcSliceH; }","- } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0)
- memcpy(dst[plane] + dstStride[plane]*y, src[plane], height*dstStride[plane]);
- else {
+ } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0) {
+ if (height > 0)
+ memcpy(dst[plane] + dstStride[plane]*y, src[plane],
+ (height - 1)*dstStride[plane] + length);
+ } else {","static int planarCopyWrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8_t* dst[], int dstStride[]) { int plane, i, j; for (plane=0; plane<4; plane++) { int length= (plane==0 || plane==3) ? c->srcW : -((-c->srcW )>>c->chrDstHSubSample); int y= (plane==0 || plane==3) ? srcSliceY: -((-srcSliceY)>>c->chrDstVSubSample); int height= (plane==0 || plane==3) ? srcSliceH: -((-srcSliceH)>>c->chrDstVSubSample); const uint8_t *srcPtr= src[plane]; uint8_t *dstPtr= dst[plane] + dstStride[plane]*y; if (!dst[plane]) continue; if (plane == 1 && !dst[2]) continue; if (!src[plane] || (plane == 1 && !src[2])) { if(is16BPS(c->dstFormat)) length*=2; fillPlane(dst[plane], dstStride[plane], length, height, y, (plane==3) ? 255 : 128); } else { if(is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) { if (!isBE(c->srcFormat)) srcPtr++; for (i=0; i<height; i++) { for (j=0; j<length; j++) dstPtr[j] = srcPtr[j<<1]; srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } else if(!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) { for (i=0; i<height; i++) { for (j=0; j<length; j++) { dstPtr[ j<<1 ] = srcPtr[j]; dstPtr[(j<<1)+1] = srcPtr[j]; } srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } else if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat) && isBE(c->srcFormat) != isBE(c->dstFormat)) { for (i=0; i<height; i++) { for (j=0; j<length; j++) ((uint16_t*)dstPtr)[j] = av_bswap16(((const uint16_t*)srcPtr)[j]); srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0) { if (height > 0) memcpy(dst[plane] + dstStride[plane]*y, src[plane], (height - 1)*dstStride[plane] + length); } else { if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) length*=2; for (i=0; i<height; i++) { memcpy(dstPtr, srcPtr, length); srcPtr+= srcStride[plane]; dstPtr+= dstStride[plane]; } } } } return srcSliceH; }"
1226----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_426b81c52b59bf79f63473f1037049a77f706154_1.json----dequantize_slice_buffered,"static void dequantize_slice_buffered(SnowContext *s, slice_buffer * sb, SubBand *b, IDWTELEM *src, int stride, int start_y, int end_y){ const int w= b->width; const int qlog= av_clip(s->qlog + b->qlog, 0, QROOT*16); const int qmul= ff_qexp[qlog&(QROOT-1)]<<(qlog>>QSHIFT); const int qadd= (s->qbias*qmul)>>QBIAS_SHIFT; int x,y; if(s->qlog == LOSSLESS_QLOG) return; for(y=start_y; y<end_y; y++){ IDWTELEM * line = slice_buffer_get_line(sb, (y * b->stride_line) + b->buf_y_offset) + b->buf_x_offset; for(x=0; x<w; x++){ int i= line[x]; if(i<0){ <S2SV_StartVul> line[x]= -((-i*qmul + qadd)>>(QEXPSHIFT)); }else if(i>0){ <S2SV_StartVul> line[x]= (( i*qmul + qadd)>>(QEXPSHIFT)); <S2SV_EndVul> } } } }","- line[x]= -((-i*qmul + qadd)>>(QEXPSHIFT)); //FIXME try different bias
- line[x]= (( i*qmul + qadd)>>(QEXPSHIFT));
+ line[x]= -((-i*(unsigned)qmul + qadd)>>(QEXPSHIFT)); //FIXME try different bias
+ line[x]= (( i*(unsigned)qmul + qadd)>>(QEXPSHIFT));","static void dequantize_slice_buffered(SnowContext *s, slice_buffer * sb, SubBand *b, IDWTELEM *src, int stride, int start_y, int end_y){ const int w= b->width; const int qlog= av_clip(s->qlog + b->qlog, 0, QROOT*16); const int qmul= ff_qexp[qlog&(QROOT-1)]<<(qlog>>QSHIFT); const int qadd= (s->qbias*qmul)>>QBIAS_SHIFT; int x,y; if(s->qlog == LOSSLESS_QLOG) return; for(y=start_y; y<end_y; y++){ IDWTELEM * line = slice_buffer_get_line(sb, (y * b->stride_line) + b->buf_y_offset) + b->buf_x_offset; for(x=0; x<w; x++){ int i= line[x]; if(i<0){ line[x]= -((-i*(unsigned)qmul + qadd)>>(QEXPSHIFT)); }else if(i>0){ line[x]= (( i*(unsigned)qmul + qadd)>>(QEXPSHIFT)); } } } }"
5560----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2426c2a46601c19460da0a1fab3b7012ed9deff1_1.json----decode_frame,"static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; const uint8_t *buf_end = buf + avpkt->size; KgvContext * const c = avctx->priv_data; <S2SV_StartVul> int offsets[7]; <S2SV_EndVul> uint16_t *out, *prev; int outcnt = 0, maxcnt; int w, h, i; if (avpkt->size < 2) return -1; w = (buf[0] + 1) * 8; h = (buf[1] + 1) * 8; buf += 2; if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); maxcnt = w * h; out = av_realloc(c->cur, w * h * 2); if (!out) return -1; c->cur = out; prev = av_realloc(c->prev, w * h * 2); if (!prev) return -1; c->prev = prev; <S2SV_StartVul> for (i = 0; i < 7; i++) <S2SV_EndVul> offsets[i] = -1; while (outcnt < maxcnt && buf_end - 2 > buf) { int code = AV_RL16(buf); buf += 2; if (!(code & 0x8000)) { out[outcnt++] = code; } else { int count; uint16_t *inp; if ((code & 0x6000) == 0x6000) { int oidx = (code >> 10) & 7; int start; count = (code & 0x3FF) + 3; if (offsets[oidx] < 0) { if (buf_end - 3 < buf) break; offsets[oidx] = AV_RL24(buf); buf += 3; } start = (outcnt + offsets[oidx]) % maxcnt; if (maxcnt - start < count) break; inp = prev + start; } else { int offset = (code & 0x1FFF) + 1; if (!(code & 0x6000)) { count = 2; } else if ((code & 0x6000) == 0x2000) { count = 3; } else { if (buf_end - 1 < buf) break; count = 4 + *buf++; } if (outcnt < offset) break; inp = out + outcnt - offset; } if (maxcnt - outcnt < count) break; for (i = 0; i < count; i++) out[outcnt++] = inp[i]; } } if (outcnt - maxcnt) av_log(avctx, AV_LOG_DEBUG, ""frame finished with %d diff\n"", outcnt - maxcnt); c->pic.data[0] = (uint8_t *)c->cur; c->pic.linesize[0] = w * 2; *data_size = sizeof(AVFrame); *(AVFrame*)data = c->pic; FFSWAP(uint16_t *, c->cur, c->prev); return avpkt->size; }","- int offsets[7];
- for (i = 0; i < 7; i++)
+ int offsets[8];
+ for (i = 0; i < 8; i++)","static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; const uint8_t *buf_end = buf + avpkt->size; KgvContext * const c = avctx->priv_data; int offsets[8]; uint16_t *out, *prev; int outcnt = 0, maxcnt; int w, h, i; if (avpkt->size < 2) return -1; w = (buf[0] + 1) * 8; h = (buf[1] + 1) * 8; buf += 2; if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); maxcnt = w * h; out = av_realloc(c->cur, w * h * 2); if (!out) return -1; c->cur = out; prev = av_realloc(c->prev, w * h * 2); if (!prev) return -1; c->prev = prev; for (i = 0; i < 8; i++) offsets[i] = -1; while (outcnt < maxcnt && buf_end - 2 > buf) { int code = AV_RL16(buf); buf += 2; if (!(code & 0x8000)) { out[outcnt++] = code; } else { int count; uint16_t *inp; if ((code & 0x6000) == 0x6000) { int oidx = (code >> 10) & 7; int start; count = (code & 0x3FF) + 3; if (offsets[oidx] < 0) { if (buf_end - 3 < buf) break; offsets[oidx] = AV_RL24(buf); buf += 3; } start = (outcnt + offsets[oidx]) % maxcnt; if (maxcnt - start < count) break; inp = prev + start; } else { int offset = (code & 0x1FFF) + 1; if (!(code & 0x6000)) { count = 2; } else if ((code & 0x6000) == 0x2000) { count = 3; } else { if (buf_end - 1 < buf) break; count = 4 + *buf++; } if (outcnt < offset) break; inp = out + outcnt - offset; } if (maxcnt - outcnt < count) break; for (i = 0; i < count; i++) out[outcnt++] = inp[i]; } } if (outcnt - maxcnt) av_log(avctx, AV_LOG_DEBUG, ""frame finished with %d diff\n"", outcnt - maxcnt); c->pic.data[0] = (uint8_t *)c->cur; c->pic.linesize[0] = w * 2; *data_size = sizeof(AVFrame); *(AVFrame*)data = c->pic; FFSWAP(uint16_t *, c->cur, c->prev); return avpkt->size; }"
10307----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_1.json----ubsec_rsa_mod_exp,"static int ubsec_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa) { BN_CTX *ctx; int to_return = 0; if((ctx = BN_CTX_new()) == NULL) goto err; if(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp) { UBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP, UBSEC_R_MISSING_KEY_COMPONENTS); goto err; } <S2SV_EndVul> <S2SV_StartVul> if ((BN_num_bits(rsa->p)+BN_num_bits(rsa->q)) > 1024) { <S2SV_EndVul> <S2SV_StartVul> const RSA_METHOD *meth = RSA_PKCS1_SSLeay(); <S2SV_EndVul> <S2SV_StartVul> to_return = (*meth->rsa_mod_exp)(r0, I, rsa); <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> to_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1, <S2SV_EndVul> <S2SV_StartVul> rsa->dmq1, rsa->iqmp, ctx); <S2SV_EndVul> } err: if(ctx) BN_CTX_free(ctx); return to_return; }","- if ((BN_num_bits(rsa->p)+BN_num_bits(rsa->q)) > 1024) {
- const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
- to_return = (*meth->rsa_mod_exp)(r0, I, rsa);
- } else {
- to_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,
- rsa->dmq1, rsa->iqmp, ctx);
+ to_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,
+ rsa->dmq1, rsa->iqmp, ctx);
+ if (to_return == FAIL_TO_SOFTWARE)
+ {
+ const RSA_METHOD *meth = RSA_PKCS1_SSLeay();
+ to_return = (*meth->rsa_mod_exp)(r0, I, rsa);","static int ubsec_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa) { BN_CTX *ctx; int to_return = 0; if((ctx = BN_CTX_new()) == NULL) goto err; if(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp) { UBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP, UBSEC_R_MISSING_KEY_COMPONENTS); goto err; } to_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1, rsa->dmq1, rsa->iqmp, ctx); if (to_return == FAIL_TO_SOFTWARE) { const RSA_METHOD *meth = RSA_PKCS1_SSLeay(); to_return = (*meth->rsa_mod_exp)(r0, I, rsa); } err: if(ctx) BN_CTX_free(ctx); return to_return; }"
5255----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_12090119c14a576beafb6052ae8f35a0f12b803a_1.json----pred8x8l_vertical_add_8_c,"<S2SV_StartVul> static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const DCTELEM *_block, int stride){ <S2SV_EndVul> int i; pixel *pix = (pixel*)_pix; const dctcoef *block = (const dctcoef*)_block; stride /= sizeof(pixel); pix -= stride; for(i=0; i<8; i++){ pixel v = pix[0]; pix[1*stride]= v += block[0]; pix[2*stride]= v += block[8]; pix[3*stride]= v += block[16]; pix[4*stride]= v += block[24]; pix[5*stride]= v += block[32]; pix[6*stride]= v += block[40]; pix[7*stride]= v += block[48]; pix[8*stride]= v + block[56]; pix++; block++; } }","- static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const DCTELEM *_block, int stride){
+ static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const DCTELEM *_block,
+ ptrdiff_t stride)
+ {","static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const DCTELEM *_block, ptrdiff_t stride) { int i; pixel *pix = (pixel*)_pix; const dctcoef *block = (const dctcoef*)_block; stride /= sizeof(pixel); pix -= stride; for(i=0; i<8; i++){ pixel v = pix[0]; pix[1*stride]= v += block[0]; pix[2*stride]= v += block[8]; pix[3*stride]= v += block[16]; pix[4*stride]= v += block[24]; pix[5*stride]= v += block[32]; pix[6*stride]= v += block[40]; pix[7*stride]= v += block[48]; pix[8*stride]= v + block[56]; pix++; block++; } }"
9370----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_32b1dded7ee035829932aa62ad880d1103081c7d_1.json----TIFFWriteDirectorySec,"static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = ""TIFFWriteDirectorySec""; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif ); if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, ""Error post-encoding before directory write""); return (0); } } (*tif->tif_close)(tif); if (tif->tif_rawcc > 0 && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, ""Error flushing data before directory write""); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { <S2SV_StartVul> if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) <S2SV_EndVul> goto bad; } else { <S2SV_StartVul> if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount)) <S2SV_EndVul> goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) { <S2SV_StartVul> if (tif->tif_dir.td_stripoffset != NULL && <S2SV_EndVul> <S2SV_StartVul> !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) <S2SV_EndVul> goto bad; } else { <S2SV_StartVul> if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset)) <S2SV_EndVul> goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: TIFFErrorExt(tif->tif_clientdata,module, ""Cannot write tag %d (%s)"", TIFFFieldTag(o), o->field_name ? o->field_name : ""unknown""); goto bad; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: assert(0); break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,""Out of memory""); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,""Maximum TIFF file size exceeded""); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { if( na == ndir ) { TIFFErrorExt(tif->tif_clientdata,module, ""Cannot find SubIFD tag""); goto bad; } if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,""Out of memory""); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4; _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,""IO error writing directory""); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,""IO error writing directory""); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif); TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }","- if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))
- if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))
- if (tif->tif_dir.td_stripoffset != NULL &&
- !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))
- if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))
+ if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount_p))
+ if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount_p))
+ if (tif->tif_dir.td_stripoffset_p != NULL &&
+ !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset_p))
+ if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset_p))","static int TIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff) { static const char module[] = ""TIFFWriteDirectorySec""; uint32 ndir; TIFFDirEntry* dir; uint32 dirsize; void* dirmem; uint32 m; if (tif->tif_mode == O_RDONLY) return (1); _TIFFFillStriles( tif ); if (imagedone) { if (tif->tif_flags & TIFF_POSTENCODE) { tif->tif_flags &= ~TIFF_POSTENCODE; if (!(*tif->tif_postencode)(tif)) { TIFFErrorExt(tif->tif_clientdata,module, ""Error post-encoding before directory write""); return (0); } } (*tif->tif_close)(tif); if (tif->tif_rawcc > 0 && (tif->tif_flags & TIFF_BEENWRITING) != 0 ) { if( !TIFFFlushData1(tif) ) { TIFFErrorExt(tif->tif_clientdata, module, ""Error flushing data before directory write""); return (0); } } if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawcc = 0; tif->tif_rawdatasize = 0; tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = 0; } tif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP); } dir=NULL; dirmem=NULL; dirsize=0; while (1) { ndir=0; if (isimage) { if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth)) goto bad; if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution)) goto bad; } if (TIFFFieldSet(tif,FIELD_POSITION)) { if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition)) goto bad; if (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype)) goto bad; } if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample)) goto bad; } if (TIFFFieldSet(tif,FIELD_COMPRESSION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression)) goto bad; } if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric)) goto bad; } if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding)) goto bad; } if (TIFFFieldSet(tif,FIELD_FILLORDER)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder)) goto bad; } if (TIFFFieldSet(tif,FIELD_ORIENTATION)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation)) goto bad; } if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel)) goto bad; } if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP)) { if (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip)) goto bad; } if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig)) goto bad; } if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit)) goto bad; } if (TIFFFieldSet(tif,FIELD_PAGENUMBER)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS)) { if (!isTiled(tif)) { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount_p)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount_p)) goto bad; } } if (TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) { if (!isTiled(tif)) { if (tif->tif_dir.td_stripoffset_p != NULL && !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset_p)) goto bad; } else { if (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset_p)) goto bad; } } if (TIFFFieldSet(tif,FIELD_COLORMAP)) { if (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_EXTRASAMPLES)) { if (tif->tif_dir.td_extrasamples) { uint16 na; uint16* nb; TIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb); if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb)) goto bad; } } if (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT)) { if (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE)) { if (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue)) goto bad; } if (TIFFFieldSet(tif,FIELD_IMAGEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_TILEDEPTH)) { if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth)) goto bad; } if (TIFFFieldSet(tif,FIELD_HALFTONEHINTS)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING)) { if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0])) goto bad; } if (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING)) { if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning)) goto bad; } if (TIFFFieldSet(tif,FIELD_REFBLACKWHITE)) { if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite)) goto bad; } if (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION)) { if (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir)) goto bad; } if (TIFFFieldSet(tif,FIELD_INKNAMES)) { if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames)) goto bad; } if (TIFFFieldSet(tif,FIELD_SUBIFD)) { if (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir)) goto bad; } { uint32 n; for (n=0; n<tif->tif_nfields; n++) { const TIFFField* o; o = tif->tif_fields[n]; if ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit))) { switch (o->get_field_type) { case TIFF_SETGET_ASCII: { uint32 pa; char* pb; assert(o->field_type==TIFF_ASCII); assert(o->field_readcount==TIFF_VARIABLE); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&pb); pa=(uint32)(strlen(pb)); if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; case TIFF_SETGET_UINT16: { uint16 p; assert(o->field_type==TIFF_SHORT); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_UINT32: { uint32 p; assert(o->field_type==TIFF_LONG); assert(o->field_readcount==1); assert(o->field_passcount==0); TIFFGetField(tif,o->field_tag,&p); if (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p)) goto bad; } break; case TIFF_SETGET_C32_UINT8: { uint32 pa; void* pb; assert(o->field_type==TIFF_UNDEFINED); assert(o->field_readcount==TIFF_VARIABLE2); assert(o->field_passcount==1); TIFFGetField(tif,o->field_tag,&pa,&pb); if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb)) goto bad; } break; default: TIFFErrorExt(tif->tif_clientdata,module, ""Cannot write tag %d (%s)"", TIFFFieldTag(o), o->field_name ? o->field_name : ""unknown""); goto bad; } } } } } for (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++) { uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag; uint32 count = tif->tif_dir.td_customValues[m].count; switch (tif->tif_dir.td_customValues[m].info->field_type) { case TIFF_ASCII: if (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_UNDEFINED: if (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_BYTE: if (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SBYTE: if (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SHORT: if (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SSHORT: if (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG: if (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG: if (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_LONG8: if (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SLONG8: if (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_RATIONAL: if (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_SRATIONAL: if (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_FLOAT: if (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_DOUBLE: if (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD: if (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; case TIFF_IFD8: if (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value)) goto bad; break; default: assert(0); break; } } if (dir!=NULL) break; dir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry)); if (dir==NULL) { TIFFErrorExt(tif->tif_clientdata,module,""Out of memory""); goto bad; } if (isimage) { if ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif))) goto bad; } else tif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1)); if (pdiroff!=NULL) *pdiroff=tif->tif_diroff; if (!(tif->tif_flags&TIFF_BIGTIFF)) dirsize=2+ndir*12+4; else dirsize=8+ndir*20+8; tif->tif_dataoff=tif->tif_diroff+dirsize; if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_dataoff=(uint32)tif->tif_dataoff; if ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,""Maximum TIFF file size exceeded""); goto bad; } if (tif->tif_dataoff&1) tif->tif_dataoff++; if (isimage) tif->tif_curdir++; } if (isimage) { if (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0)) { uint32 na; TIFFDirEntry* nb; for (na=0, nb=dir; ; na++, nb++) { if( na == ndir ) { TIFFErrorExt(tif->tif_clientdata,module, ""Cannot find SubIFD tag""); goto bad; } if (nb->tdir_tag==TIFFTAG_SUBIFD) break; } if (!(tif->tif_flags&TIFF_BIGTIFF)) tif->tif_subifdoff=tif->tif_diroff+2+na*12+8; else tif->tif_subifdoff=tif->tif_diroff+8+na*20+12; } } dirmem=_TIFFmalloc(dirsize); if (dirmem==NULL) { TIFFErrorExt(tif->tif_clientdata,module,""Out of memory""); goto bad; } if (!(tif->tif_flags&TIFF_BIGTIFF)) { uint8* n; uint32 nTmp; TIFFDirEntry* o; n=dirmem; *(uint16*)n=(uint16)ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; nTmp = (uint32)o->tdir_count; _TIFFmemcpy(n,&nTmp,4); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong((uint32*)n); n+=4; _TIFFmemcpy(n,&o->tdir_offset,4); n+=4; o++; } nTmp = (uint32)tif->tif_nextdiroff; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong(&nTmp); _TIFFmemcpy(n,&nTmp,4); } else { uint8* n; TIFFDirEntry* o; n=dirmem; *(uint64*)n=ndir; if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; o=dir; for (m=0; m<ndir; m++) { *(uint16*)n=o->tdir_tag; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; *(uint16*)n=o->tdir_type; if (tif->tif_flags&TIFF_SWAB) TIFFSwabShort((uint16*)n); n+=2; _TIFFmemcpy(n,&o->tdir_count,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); n+=8; _TIFFmemcpy(n,&o->tdir_offset,8); n+=8; o++; } _TIFFmemcpy(n,&tif->tif_nextdiroff,8); if (tif->tif_flags&TIFF_SWAB) TIFFSwabLong8((uint64*)n); } _TIFFfree(dir); dir=NULL; if (!SeekOK(tif,tif->tif_diroff)) { TIFFErrorExt(tif->tif_clientdata,module,""IO error writing directory""); goto bad; } if (!WriteOK(tif,dirmem,(tmsize_t)dirsize)) { TIFFErrorExt(tif->tif_clientdata,module,""IO error writing directory""); goto bad; } _TIFFfree(dirmem); if (imagedone) { TIFFFreeDirectory(tif); tif->tif_flags &= ~TIFF_DIRTYDIRECT; tif->tif_flags &= ~TIFF_DIRTYSTRIP; (*tif->tif_cleanup)(tif); TIFFCreateDirectory(tif); } return(1); bad: if (dir!=NULL) _TIFFfree(dir); if (dirmem!=NULL) _TIFFfree(dirmem); return(0); }"
11575----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_1.json----DH_free,"void DH_free(DH *r) { int i; if(r == NULL) return; i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH); #ifdef REF_PRINT REF_PRINT(""DH"",r); #endif if (i > 0) return; #ifdef REF_CHECK if (i < 0) { fprintf(stderr,""DH_free, bad reference count\n""); abort(); } #endif CRYPTO_free_ex_data(dh_meth, r, &r->ex_data); <S2SV_StartVul> if(r->meth->finish) r->meth->finish(r); <S2SV_EndVul> if (r->p != NULL) BN_clear_free(r->p); if (r->g != NULL) BN_clear_free(r->g); if (r->q != NULL) BN_clear_free(r->q); if (r->j != NULL) BN_clear_free(r->j); if (r->seed) OPENSSL_free(r->seed); if (r->counter != NULL) BN_clear_free(r->counter); if (r->pub_key != NULL) BN_clear_free(r->pub_key); if (r->priv_key != NULL) BN_clear_free(r->priv_key); OPENSSL_free(r); }","- if(r->meth->finish) r->meth->finish(r);
+ DH_METHOD *meth;
+ meth = ENGINE_get_DH(r->engine);
+ if(meth->finish) meth->finish(r);
+ ENGINE_finish(r->engine);","void DH_free(DH *r) { DH_METHOD *meth; int i; if(r == NULL) return; i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH); #ifdef REF_PRINT REF_PRINT(""DH"",r); #endif if (i > 0) return; #ifdef REF_CHECK if (i < 0) { fprintf(stderr,""DH_free, bad reference count\n""); abort(); } #endif CRYPTO_free_ex_data(dh_meth, r, &r->ex_data); meth = ENGINE_get_DH(r->engine); if(meth->finish) meth->finish(r); ENGINE_finish(r->engine); if (r->p != NULL) BN_clear_free(r->p); if (r->g != NULL) BN_clear_free(r->g); if (r->q != NULL) BN_clear_free(r->q); if (r->j != NULL) BN_clear_free(r->j); if (r->seed) OPENSSL_free(r->seed); if (r->counter != NULL) BN_clear_free(r->counter); if (r->pub_key != NULL) BN_clear_free(r->pub_key); if (r->priv_key != NULL) BN_clear_free(r->priv_key); OPENSSL_free(r); }"
13845----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d2f101548a24682053862e2b839357fa6a8b520_1.json----dtls1_buffer_record,"<S2SV_StartVul> int <S2SV_EndVul> <S2SV_StartVul> dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority) <S2SV_EndVul> { DTLS1_RECORD_DATA *rdata; pitem *item; if (pqueue_size(queue->q) >= 100) return 0; rdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA)); item = pitem_new(priority, rdata); if (rdata == NULL || item == NULL) { if (rdata != NULL) OPENSSL_free(rdata); if (item != NULL) pitem_free(item); SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR); return -1; } rdata->packet = s->rlayer.packet; rdata->packet_length = s->rlayer.packet_length; memcpy(&(rdata->rbuf), &s->rlayer.rbuf, sizeof(SSL3_BUFFER)); memcpy(&(rdata->rrec), &s->rlayer.rrec, sizeof(SSL3_RECORD)); item->data = rdata; #ifndef OPENSSL_NO_SCTP if (BIO_dgram_is_sctp(SSL_get_rbio(s)) && (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) { BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo); } #endif s->rlayer.packet = NULL; s->rlayer.packet_length = 0; memset(&s->rlayer.rbuf, 0, sizeof(SSL3_BUFFER)); memset(&s->rlayer.rrec, 0, sizeof(SSL3_RECORD)); if (!ssl3_setup_buffers(s)) { SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR); if (rdata->rbuf.buf != NULL) OPENSSL_free(rdata->rbuf.buf); OPENSSL_free(rdata); pitem_free(item); return (-1); } if (pqueue_insert(queue->q, item) == NULL) { SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR); if (rdata->rbuf.buf != NULL) OPENSSL_free(rdata->rbuf.buf); OPENSSL_free(rdata); pitem_free(item); return (-1); } return (1); }","- int
- dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)
+ int dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)","int dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority) { DTLS1_RECORD_DATA *rdata; pitem *item; if (pqueue_size(queue->q) >= 100) return 0; rdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA)); item = pitem_new(priority, rdata); if (rdata == NULL || item == NULL) { if (rdata != NULL) OPENSSL_free(rdata); if (item != NULL) pitem_free(item); SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR); return -1; } rdata->packet = s->rlayer.packet; rdata->packet_length = s->rlayer.packet_length; memcpy(&(rdata->rbuf), &s->rlayer.rbuf, sizeof(SSL3_BUFFER)); memcpy(&(rdata->rrec), &s->rlayer.rrec, sizeof(SSL3_RECORD)); item->data = rdata; #ifndef OPENSSL_NO_SCTP if (BIO_dgram_is_sctp(SSL_get_rbio(s)) && (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) { BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo); } #endif s->rlayer.packet = NULL; s->rlayer.packet_length = 0; memset(&s->rlayer.rbuf, 0, sizeof(SSL3_BUFFER)); memset(&s->rlayer.rrec, 0, sizeof(SSL3_RECORD)); if (!ssl3_setup_buffers(s)) { SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR); if (rdata->rbuf.buf != NULL) OPENSSL_free(rdata->rbuf.buf); OPENSSL_free(rdata); pitem_free(item); return (-1); } if (pqueue_insert(queue->q, item) == NULL) { SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR); if (rdata->rbuf.buf != NULL) OPENSSL_free(rdata->rbuf.buf); OPENSSL_free(rdata); pitem_free(item); return (-1); } return (1); }"
14439----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_91d061b16a4fa0b2daed124f201c844134860ced_1.json----ssl_add_serverhello_tlsext,"int ssl_add_serverhello_tlsext(SSL *s, WPACKET *pkt, int *al) { #ifndef OPENSSL_NO_NEXTPROTONEG int next_proto_neg_seen; #endif #ifndef OPENSSL_NO_EC unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey; unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth; int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA); using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL); #endif if (!WPACKET_start_sub_packet_u16(pkt) || !WPACKET_set_flags(pkt, WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (s->s3->send_connection_binding && !ssl_add_serverhello_renegotiate_ext(s, pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (s->version == SSL3_VERSION) goto done; if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #ifndef OPENSSL_NO_EC if (using_ecc) { const unsigned char *plist; size_t plistlen; tls1_get_formatlist(s, &plist, &plistlen); if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_ec_point_formats) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_sub_memcpy_u8(pkt, plist, plistlen) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #endif if (s->tlsext_ticket_expected && tls_use_ticket(s)) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_session_ticket) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } else { s->tlsext_ticket_expected = 0; } if (s->tlsext_status_expected) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #ifndef OPENSSL_NO_SRTP if (SSL_IS_DTLS(s) && s->srtp_profile) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_use_srtp) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_put_bytes_u16(pkt, 2) || !WPACKET_put_bytes_u16(pkt, s->srtp_profile->id) || !WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #endif if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81) && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) { const unsigned char cryptopro_ext[36] = { 0xfd, 0xe8, 0x00, 0x20, 0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17 }; if (!WPACKET_memcpy(pkt, cryptopro_ext, sizeof(cryptopro_ext))) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #ifndef OPENSSL_NO_NEXTPROTONEG next_proto_neg_seen = s->s3->next_proto_neg_seen; s->s3->next_proto_neg_seen = 0; if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) { const unsigned char *npa; unsigned int npalen; int r; r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen, s-> ctx->next_protos_advertised_cb_arg); if (r == SSL_TLSEXT_ERR_OK) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_next_proto_neg) || !WPACKET_sub_memcpy_u16(pkt, npa, npalen)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } s->s3->next_proto_neg_seen = 1; } } #endif if (s->version == TLS1_3_VERSION) { unsigned char *encodedPoint; size_t encoded_pt_len = 0; EVP_PKEY *ckey = NULL, *skey = NULL; ckey = s->s3->peer_tmp; if (ckey == NULL) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_put_bytes_u16(pkt, s->s3->group_id)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } skey = ssl_generate_pkey(ckey); encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(skey, &encodedPoint); if (encoded_pt_len == 0) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_EC_LIB); EVP_PKEY_free(skey); return 0; } if (!WPACKET_sub_memcpy_u16(pkt, encodedPoint, encoded_pt_len) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); EVP_PKEY_free(skey); OPENSSL_free(encodedPoint); return 0; } s->s3->tmp.pkey = skey; <S2SV_StartVul> OPENSSL_free(encodedPoint); <S2SV_EndVul> } if (!custom_ext_add(s, 1, pkt, al)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) { if (s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4 || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12) s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC; else { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_encrypt_then_mac) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } } if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_extended_master_secret) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } if (s->s3->alpn_selected != NULL) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_application_layer_protocol_negotiation) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_sub_memcpy_u8(pkt, s->s3->alpn_selected, s->s3->alpn_selected_len) || !WPACKET_close(pkt) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } done: if (!WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } return 1; }","- OPENSSL_free(encodedPoint);
+ OPENSSL_free(encodedPoint);
+ if (ssl_derive(s, skey, ckey, 1) == 0) {
+ SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
+ return 0;
+ }","int ssl_add_serverhello_tlsext(SSL *s, WPACKET *pkt, int *al) { #ifndef OPENSSL_NO_NEXTPROTONEG int next_proto_neg_seen; #endif #ifndef OPENSSL_NO_EC unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey; unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth; int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA); using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL); #endif if (!WPACKET_start_sub_packet_u16(pkt) || !WPACKET_set_flags(pkt, WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (s->s3->send_connection_binding && !ssl_add_serverhello_renegotiate_ext(s, pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (s->version == SSL3_VERSION) goto done; if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #ifndef OPENSSL_NO_EC if (using_ecc) { const unsigned char *plist; size_t plistlen; tls1_get_formatlist(s, &plist, &plistlen); if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_ec_point_formats) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_sub_memcpy_u8(pkt, plist, plistlen) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #endif if (s->tlsext_ticket_expected && tls_use_ticket(s)) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_session_ticket) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } else { s->tlsext_ticket_expected = 0; } if (s->tlsext_status_expected) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #ifndef OPENSSL_NO_SRTP if (SSL_IS_DTLS(s) && s->srtp_profile) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_use_srtp) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_put_bytes_u16(pkt, 2) || !WPACKET_put_bytes_u16(pkt, s->srtp_profile->id) || !WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #endif if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80 || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81) && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) { const unsigned char cryptopro_ext[36] = { 0xfd, 0xe8, 0x00, 0x20, 0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17 }; if (!WPACKET_memcpy(pkt, cryptopro_ext, sizeof(cryptopro_ext))) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } #ifndef OPENSSL_NO_NEXTPROTONEG next_proto_neg_seen = s->s3->next_proto_neg_seen; s->s3->next_proto_neg_seen = 0; if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) { const unsigned char *npa; unsigned int npalen; int r; r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen, s-> ctx->next_protos_advertised_cb_arg); if (r == SSL_TLSEXT_ERR_OK) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_next_proto_neg) || !WPACKET_sub_memcpy_u16(pkt, npa, npalen)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } s->s3->next_proto_neg_seen = 1; } } #endif if (s->version == TLS1_3_VERSION) { unsigned char *encodedPoint; size_t encoded_pt_len = 0; EVP_PKEY *ckey = NULL, *skey = NULL; ckey = s->s3->peer_tmp; if (ckey == NULL) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_put_bytes_u16(pkt, s->s3->group_id)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } skey = ssl_generate_pkey(ckey); encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(skey, &encodedPoint); if (encoded_pt_len == 0) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_EC_LIB); EVP_PKEY_free(skey); return 0; } if (!WPACKET_sub_memcpy_u16(pkt, encodedPoint, encoded_pt_len) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); EVP_PKEY_free(skey); OPENSSL_free(encodedPoint); return 0; } OPENSSL_free(encodedPoint); s->s3->tmp.pkey = skey; if (ssl_derive(s, skey, ckey, 1) == 0) { *al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } if (!custom_ext_add(s, 1, pkt, al)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) { if (s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4 || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12) s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC; else { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_encrypt_then_mac) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } } if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_extended_master_secret) || !WPACKET_put_bytes_u16(pkt, 0)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } if (s->s3->alpn_selected != NULL) { if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_application_layer_protocol_negotiation) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_start_sub_packet_u16(pkt) || !WPACKET_sub_memcpy_u8(pkt, s->s3->alpn_selected, s->s3->alpn_selected_len) || !WPACKET_close(pkt) || !WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } } done: if (!WPACKET_close(pkt)) { SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR); return 0; } return 1; }"
1614----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5a7328fc29c8630147b4b2f19d350e1af8828f5e_1.json----ff_h263_decode_picture_header,"int ff_h263_decode_picture_header(MpegEncContext *s) { int format, width, height, i; uint32_t startcode; align_get_bits(&s->gb); if (show_bits(&s->gb, 2) == 2 && s->avctx->frame_number == 0) { av_log(s->avctx, AV_LOG_WARNING, ""Header looks like RTP instead of H.263\n""); } startcode= get_bits(&s->gb, 22-8); for(i= get_bits_left(&s->gb); i>24; i-=8) { startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF; if(startcode == 0x20) break; } if (startcode != 0x20) { av_log(s->avctx, AV_LOG_ERROR, ""Bad picture start code\n""); return -1; } i = get_bits(&s->gb, 8); if( (s->picture_number&~0xFF)+i < s->picture_number) i+= 256; s->picture_number= (s->picture_number&~0xFF) + i; <S2SV_StartVul> if (get_bits1(&s->gb) != 1) { <S2SV_EndVul> <S2SV_StartVul> av_log(s->avctx, AV_LOG_ERROR, ""Bad marker\n""); <S2SV_EndVul> return -1; } if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Bad H263 id\n""); return -1; } skip_bits1(&s->gb); skip_bits1(&s->gb); skip_bits1(&s->gb); format = get_bits(&s->gb, 3); if (format != 7 && format != 6) { s->h263_plus = 0; width = ff_h263_format[format][0]; height = ff_h263_format[format][1]; if (!width) return -1; s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb); s->h263_long_vectors = get_bits1(&s->gb); if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""H263 SAC not supported\n""); return -1; } s->obmc= get_bits1(&s->gb); s->unrestricted_mv = s->h263_long_vectors || s->obmc; s->pb_frame = get_bits1(&s->gb); s->chroma_qscale= s->qscale = get_bits(&s->gb, 5); skip_bits1(&s->gb); s->width = width; s->height = height; s->avctx->sample_aspect_ratio= (AVRational){12,11}; s->avctx->framerate = (AVRational){ 30000, 1001 }; } else { int ufep; s->h263_plus = 1; ufep = get_bits(&s->gb, 3); if (ufep == 1) { format = get_bits(&s->gb, 3); av_dlog(s->avctx, ""ufep=1, format: %d\n"", format); s->custom_pcf= get_bits1(&s->gb); s->umvplus = get_bits1(&s->gb); if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Syntax-based Arithmetic Coding (SAC) not supported\n""); } s->obmc= get_bits1(&s->gb); s->h263_aic = get_bits1(&s->gb); s->loop_filter= get_bits1(&s->gb); s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter; if(s->avctx->lowres) s->loop_filter = 0; s->h263_slice_structured= get_bits1(&s->gb); if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Reference Picture Selection not supported\n""); } if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Independent Segment Decoding not supported\n""); } s->alt_inter_vlc= get_bits1(&s->gb); s->modified_quant= get_bits1(&s->gb); if(s->modified_quant) s->chroma_qscale_table= ff_h263_chroma_qscale_table; skip_bits(&s->gb, 1); skip_bits(&s->gb, 3); } else if (ufep != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Bad UFEP type (%d)\n"", ufep); return -1; } s->pict_type = get_bits(&s->gb, 3); switch(s->pict_type){ case 0: s->pict_type= AV_PICTURE_TYPE_I;break; case 1: s->pict_type= AV_PICTURE_TYPE_P;break; case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break; case 3: s->pict_type= AV_PICTURE_TYPE_B;break; case 7: s->pict_type= AV_PICTURE_TYPE_I;break; default: return -1; } skip_bits(&s->gb, 2); s->no_rounding = get_bits1(&s->gb); skip_bits(&s->gb, 4); if (ufep) { if (format == 6) { s->aspect_ratio_info = get_bits(&s->gb, 4); av_dlog(s->avctx, ""aspect: %d\n"", s->aspect_ratio_info); width = (get_bits(&s->gb, 9) + 1) * 4; <S2SV_StartVul> skip_bits1(&s->gb); <S2SV_EndVul> height = get_bits(&s->gb, 9) * 4; av_dlog(s->avctx, ""\nH.263+ Custom picture: %dx%d\n"",width,height); if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) { s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8); s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8); }else{ s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info]; } } else { width = ff_h263_format[format][0]; height = ff_h263_format[format][1]; s->avctx->sample_aspect_ratio= (AVRational){12,11}; } s->avctx->sample_aspect_ratio.den <<= s->ehc_mode; if ((width == 0) || (height == 0)) return -1; s->width = width; s->height = height; if(s->custom_pcf){ int gcd; s->avctx->framerate.num = 1800000; s->avctx->framerate.den = 1000 + get_bits1(&s->gb); s->avctx->framerate.den *= get_bits(&s->gb, 7); if(s->avctx->framerate.den == 0){ av_log(s, AV_LOG_ERROR, ""zero framerate\n""); return -1; } gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num); s->avctx->framerate.den /= gcd; s->avctx->framerate.num /= gcd; }else{ s->avctx->framerate = (AVRational){ 30000, 1001 }; } } if(s->custom_pcf){ skip_bits(&s->gb, 2); } if (ufep) { if (s->umvplus) { if(get_bits1(&s->gb)==0) skip_bits1(&s->gb); } if(s->h263_slice_structured){ if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""rectangular slices not supported\n""); } if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""unordered slices not supported\n""); } } } s->qscale = get_bits(&s->gb, 5); } if (s->width == 0 || s->height == 0) { av_log(s->avctx, AV_LOG_ERROR, ""dimensions 0\n""); return -1; } s->mb_width = (s->width + 15) / 16; s->mb_height = (s->height + 15) / 16; s->mb_num = s->mb_width * s->mb_height; if (s->pb_frame) { skip_bits(&s->gb, 3); if (s->custom_pcf) skip_bits(&s->gb, 2); skip_bits(&s->gb, 2); } if (s->pict_type!=AV_PICTURE_TYPE_B) { s->time = s->picture_number; s->pp_time = s->time - s->last_non_b_time; s->last_non_b_time = s->time; }else{ s->time = s->picture_number; s->pb_time = s->pp_time - (s->last_non_b_time - s->time); if (s->pp_time <=s->pb_time || s->pp_time <= s->pp_time - s->pb_time || s->pp_time <= 0){ s->pp_time = 2; s->pb_time = 1; } ff_mpeg4_init_direct_mv(s); } if (skip_1stop_8data_bits(&s->gb) < 0) return AVERROR_INVALIDDATA; if(s->h263_slice_structured){ <S2SV_StartVul> if (get_bits1(&s->gb) != 1) { <S2SV_EndVul> <S2SV_StartVul> av_log(s->avctx, AV_LOG_ERROR, ""SEPB1 marker missing\n""); <S2SV_EndVul> return -1; } ff_h263_decode_mba(s); <S2SV_StartVul> if (get_bits1(&s->gb) != 1) { <S2SV_EndVul> <S2SV_StartVul> av_log(s->avctx, AV_LOG_ERROR, ""SEPB2 marker missing\n""); <S2SV_EndVul> return -1; } } s->f_code = 1; if(s->h263_aic){ s->y_dc_scale_table= s->c_dc_scale_table= ff_aic_dc_scale_table; }else{ s->y_dc_scale_table= s->c_dc_scale_table= ff_mpeg1_dc_scale_table; } ff_h263_show_pict_info(s); if (s->pict_type == AV_PICTURE_TYPE_I && s->codec_tag == AV_RL32(""ZYGO"") && get_bits_left(&s->gb) >= 85 + 13*3*16 + 50){ int i,j; for(i=0; i<85; i++) av_log(s->avctx, AV_LOG_DEBUG, ""%d"", get_bits1(&s->gb)); av_log(s->avctx, AV_LOG_DEBUG, ""\n""); for(i=0; i<13; i++){ for(j=0; j<3; j++){ int v= get_bits(&s->gb, 8); v |= get_sbits(&s->gb, 8)<<8; av_log(s->avctx, AV_LOG_DEBUG, "" %5d"", v); } av_log(s->avctx, AV_LOG_DEBUG, ""\n""); } for(i=0; i<50; i++) av_log(s->avctx, AV_LOG_DEBUG, ""%d"", get_bits1(&s->gb)); } return 0; }","- if (get_bits1(&s->gb) != 1) {
- av_log(s->avctx, AV_LOG_ERROR, ""Bad marker\n"");
- skip_bits1(&s->gb);
- if (get_bits1(&s->gb) != 1) {
- av_log(s->avctx, AV_LOG_ERROR, ""SEPB1 marker missing\n"");
- if (get_bits1(&s->gb) != 1) {
- av_log(s->avctx, AV_LOG_ERROR, ""SEPB2 marker missing\n"");
+ if (check_marker(&s->gb, ""in PTYPE"") != 1) {
+ check_marker(&s->gb, ""in dimensions"");
+ if (check_marker(&s->gb, ""SEPB1"") != 1) {
+ if (check_marker(&s->gb, ""SEPB2"") != 1) {","int ff_h263_decode_picture_header(MpegEncContext *s) { int format, width, height, i; uint32_t startcode; align_get_bits(&s->gb); if (show_bits(&s->gb, 2) == 2 && s->avctx->frame_number == 0) { av_log(s->avctx, AV_LOG_WARNING, ""Header looks like RTP instead of H.263\n""); } startcode= get_bits(&s->gb, 22-8); for(i= get_bits_left(&s->gb); i>24; i-=8) { startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF; if(startcode == 0x20) break; } if (startcode != 0x20) { av_log(s->avctx, AV_LOG_ERROR, ""Bad picture start code\n""); return -1; } i = get_bits(&s->gb, 8); if( (s->picture_number&~0xFF)+i < s->picture_number) i+= 256; s->picture_number= (s->picture_number&~0xFF) + i; if (check_marker(&s->gb, ""in PTYPE"") != 1) { return -1; } if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Bad H263 id\n""); return -1; } skip_bits1(&s->gb); skip_bits1(&s->gb); skip_bits1(&s->gb); format = get_bits(&s->gb, 3); if (format != 7 && format != 6) { s->h263_plus = 0; width = ff_h263_format[format][0]; height = ff_h263_format[format][1]; if (!width) return -1; s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb); s->h263_long_vectors = get_bits1(&s->gb); if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""H263 SAC not supported\n""); return -1; } s->obmc= get_bits1(&s->gb); s->unrestricted_mv = s->h263_long_vectors || s->obmc; s->pb_frame = get_bits1(&s->gb); s->chroma_qscale= s->qscale = get_bits(&s->gb, 5); skip_bits1(&s->gb); s->width = width; s->height = height; s->avctx->sample_aspect_ratio= (AVRational){12,11}; s->avctx->framerate = (AVRational){ 30000, 1001 }; } else { int ufep; s->h263_plus = 1; ufep = get_bits(&s->gb, 3); if (ufep == 1) { format = get_bits(&s->gb, 3); av_dlog(s->avctx, ""ufep=1, format: %d\n"", format); s->custom_pcf= get_bits1(&s->gb); s->umvplus = get_bits1(&s->gb); if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Syntax-based Arithmetic Coding (SAC) not supported\n""); } s->obmc= get_bits1(&s->gb); s->h263_aic = get_bits1(&s->gb); s->loop_filter= get_bits1(&s->gb); s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter; if(s->avctx->lowres) s->loop_filter = 0; s->h263_slice_structured= get_bits1(&s->gb); if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Reference Picture Selection not supported\n""); } if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Independent Segment Decoding not supported\n""); } s->alt_inter_vlc= get_bits1(&s->gb); s->modified_quant= get_bits1(&s->gb); if(s->modified_quant) s->chroma_qscale_table= ff_h263_chroma_qscale_table; skip_bits(&s->gb, 1); skip_bits(&s->gb, 3); } else if (ufep != 0) { av_log(s->avctx, AV_LOG_ERROR, ""Bad UFEP type (%d)\n"", ufep); return -1; } s->pict_type = get_bits(&s->gb, 3); switch(s->pict_type){ case 0: s->pict_type= AV_PICTURE_TYPE_I;break; case 1: s->pict_type= AV_PICTURE_TYPE_P;break; case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break; case 3: s->pict_type= AV_PICTURE_TYPE_B;break; case 7: s->pict_type= AV_PICTURE_TYPE_I;break; default: return -1; } skip_bits(&s->gb, 2); s->no_rounding = get_bits1(&s->gb); skip_bits(&s->gb, 4); if (ufep) { if (format == 6) { s->aspect_ratio_info = get_bits(&s->gb, 4); av_dlog(s->avctx, ""aspect: %d\n"", s->aspect_ratio_info); width = (get_bits(&s->gb, 9) + 1) * 4; check_marker(&s->gb, ""in dimensions""); height = get_bits(&s->gb, 9) * 4; av_dlog(s->avctx, ""\nH.263+ Custom picture: %dx%d\n"",width,height); if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) { s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8); s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8); }else{ s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info]; } } else { width = ff_h263_format[format][0]; height = ff_h263_format[format][1]; s->avctx->sample_aspect_ratio= (AVRational){12,11}; } s->avctx->sample_aspect_ratio.den <<= s->ehc_mode; if ((width == 0) || (height == 0)) return -1; s->width = width; s->height = height; if(s->custom_pcf){ int gcd; s->avctx->framerate.num = 1800000; s->avctx->framerate.den = 1000 + get_bits1(&s->gb); s->avctx->framerate.den *= get_bits(&s->gb, 7); if(s->avctx->framerate.den == 0){ av_log(s, AV_LOG_ERROR, ""zero framerate\n""); return -1; } gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num); s->avctx->framerate.den /= gcd; s->avctx->framerate.num /= gcd; }else{ s->avctx->framerate = (AVRational){ 30000, 1001 }; } } if(s->custom_pcf){ skip_bits(&s->gb, 2); } if (ufep) { if (s->umvplus) { if(get_bits1(&s->gb)==0) skip_bits1(&s->gb); } if(s->h263_slice_structured){ if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""rectangular slices not supported\n""); } if (get_bits1(&s->gb) != 0) { av_log(s->avctx, AV_LOG_ERROR, ""unordered slices not supported\n""); } } } s->qscale = get_bits(&s->gb, 5); } if (s->width == 0 || s->height == 0) { av_log(s->avctx, AV_LOG_ERROR, ""dimensions 0\n""); return -1; } s->mb_width = (s->width + 15) / 16; s->mb_height = (s->height + 15) / 16; s->mb_num = s->mb_width * s->mb_height; if (s->pb_frame) { skip_bits(&s->gb, 3); if (s->custom_pcf) skip_bits(&s->gb, 2); skip_bits(&s->gb, 2); } if (s->pict_type!=AV_PICTURE_TYPE_B) { s->time = s->picture_number; s->pp_time = s->time - s->last_non_b_time; s->last_non_b_time = s->time; }else{ s->time = s->picture_number; s->pb_time = s->pp_time - (s->last_non_b_time - s->time); if (s->pp_time <=s->pb_time || s->pp_time <= s->pp_time - s->pb_time || s->pp_time <= 0){ s->pp_time = 2; s->pb_time = 1; } ff_mpeg4_init_direct_mv(s); } if (skip_1stop_8data_bits(&s->gb) < 0) return AVERROR_INVALIDDATA; if(s->h263_slice_structured){ if (check_marker(&s->gb, ""SEPB1"") != 1) { return -1; } ff_h263_decode_mba(s); if (check_marker(&s->gb, ""SEPB2"") != 1) { return -1; } } s->f_code = 1; if(s->h263_aic){ s->y_dc_scale_table= s->c_dc_scale_table= ff_aic_dc_scale_table; }else{ s->y_dc_scale_table= s->c_dc_scale_table= ff_mpeg1_dc_scale_table; } ff_h263_show_pict_info(s); if (s->pict_type == AV_PICTURE_TYPE_I && s->codec_tag == AV_RL32(""ZYGO"") && get_bits_left(&s->gb) >= 85 + 13*3*16 + 50){ int i,j; for(i=0; i<85; i++) av_log(s->avctx, AV_LOG_DEBUG, ""%d"", get_bits1(&s->gb)); av_log(s->avctx, AV_LOG_DEBUG, ""\n""); for(i=0; i<13; i++){ for(j=0; j<3; j++){ int v= get_bits(&s->gb, 8); v |= get_sbits(&s->gb, 8)<<8; av_log(s->avctx, AV_LOG_DEBUG, "" %5d"", v); } av_log(s->avctx, AV_LOG_DEBUG, ""\n""); } for(i=0; i<50; i++) av_log(s->avctx, AV_LOG_DEBUG, ""%d"", get_bits1(&s->gb)); } return 0; }"
15881----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c5361bff5cd0b71d3697896780499760d2a190a8_1.json----test_div,"int test_div(BIO *bp, BN_CTX *ctx) { BIGNUM a,b,c,d,e; int i; int j; BN_init(&a); BN_init(&b); BN_init(&c); BN_init(&d); BN_init(&e); for (i=0; i<num0+num1; i++) { if (i < num1) { <S2SV_StartVul> BN_rand(&a,400,0,0); <S2SV_EndVul> BN_copy(&b,&a); BN_lshift(&a,&a,i); BN_add_word(&a,i); } else <S2SV_StartVul> BN_rand(&b,50+3*(i-num1),0,0); <S2SV_EndVul> a.neg=rand_neg(); b.neg=rand_neg(); if (bp == NULL) for (j=0; j<100; j++) BN_div(&d,&c,&a,&b,ctx); BN_div(&d,&c,&a,&b,ctx); if (bp != NULL) { if (!results) { BN_print(bp,&a); BIO_puts(bp,"" / ""); BN_print(bp,&b); BIO_puts(bp,"" - ""); } BN_print(bp,&d); BIO_puts(bp,""\n""); if (!results) { BN_print(bp,&a); BIO_puts(bp,"" % ""); BN_print(bp,&b); BIO_puts(bp,"" - ""); } BN_print(bp,&c); BIO_puts(bp,""\n""); } BN_mul(&e,&d,&b,ctx); BN_add(&d,&e,&c); BN_sub(&d,&d,&a); if(!BN_is_zero(&d)) { fprintf(stderr,""Division test failed!\n""); return 0; } } BN_free(&a); BN_free(&b); BN_free(&c); BN_free(&d); BN_free(&e); return(1); }","- BN_rand(&a,400,0,0);
- BN_rand(&b,50+3*(i-num1),0,0);
+ BN_bntest_rand(&a,400,0,0);
+ BN_bntest_rand(&b,50+3*(i-num1),0,0);","int test_div(BIO *bp, BN_CTX *ctx) { BIGNUM a,b,c,d,e; int i; int j; BN_init(&a); BN_init(&b); BN_init(&c); BN_init(&d); BN_init(&e); for (i=0; i<num0+num1; i++) { if (i < num1) { BN_bntest_rand(&a,400,0,0); BN_copy(&b,&a); BN_lshift(&a,&a,i); BN_add_word(&a,i); } else BN_bntest_rand(&b,50+3*(i-num1),0,0); a.neg=rand_neg(); b.neg=rand_neg(); if (bp == NULL) for (j=0; j<100; j++) BN_div(&d,&c,&a,&b,ctx); BN_div(&d,&c,&a,&b,ctx); if (bp != NULL) { if (!results) { BN_print(bp,&a); BIO_puts(bp,"" / ""); BN_print(bp,&b); BIO_puts(bp,"" - ""); } BN_print(bp,&d); BIO_puts(bp,""\n""); if (!results) { BN_print(bp,&a); BIO_puts(bp,"" % ""); BN_print(bp,&b); BIO_puts(bp,"" - ""); } BN_print(bp,&c); BIO_puts(bp,""\n""); } BN_mul(&e,&d,&b,ctx); BN_add(&d,&e,&c); BN_sub(&d,&d,&a); if(!BN_is_zero(&d)) { fprintf(stderr,""Division test failed!\n""); return 0; } } BN_free(&a); BN_free(&b); BN_free(&c); BN_free(&d); BN_free(&e); return(1); }"
5376----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_19a4adaa3985d39b724942b7121dd7beab666c5b_1.json----dash_write_packet,"static int dash_write_packet(AVFormatContext *s, AVPacket *pkt) { DASHContext *c = s->priv_data; AVStream *st = s->streams[pkt->stream_index]; OutputStream *os = &c->streams[pkt->stream_index]; int64_t seg_end_duration = (os->segment_index) * (int64_t) c->min_seg_duration; int ret; <S2SV_StartVul> if (os->first_dts == AV_NOPTS_VALUE && <S2SV_EndVul> s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) { pkt->pts -= pkt->dts; pkt->dts = 0; } <S2SV_StartVul> if (os->first_dts == AV_NOPTS_VALUE) <S2SV_EndVul> <S2SV_StartVul> os->first_dts = pkt->dts; <S2SV_EndVul> if ((!c->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) && pkt->flags & AV_PKT_FLAG_KEY && os->packets_written && <S2SV_StartVul> av_compare_ts(pkt->dts - os->first_dts, st->time_base, <S2SV_EndVul> seg_end_duration, AV_TIME_BASE_Q) >= 0) { int64_t prev_duration = c->last_duration; <S2SV_StartVul> c->last_duration = av_rescale_q(pkt->dts - os->start_dts, <S2SV_EndVul> st->time_base, AV_TIME_BASE_Q); <S2SV_StartVul> c->total_duration = av_rescale_q(pkt->dts - os->first_dts, <S2SV_EndVul> st->time_base, AV_TIME_BASE_Q); if ((!c->use_timeline || !c->use_template) && prev_duration) { if (c->last_duration < prev_duration*9/10 || c->last_duration > prev_duration*11/10) { av_log(s, AV_LOG_WARNING, ""Segment durations differ too much, enable use_timeline "" ""and use_template, or keep a stricter keyframe interval\n""); } } if ((ret = dash_flush(s, 0, pkt->stream_index)) < 0) return ret; } if (!os->packets_written) { <S2SV_StartVul> if (os->end_dts != AV_NOPTS_VALUE) <S2SV_EndVul> <S2SV_StartVul> os->start_dts = os->end_dts; <S2SV_EndVul> else <S2SV_StartVul> os->start_dts = pkt->dts; <S2SV_EndVul> } <S2SV_StartVul> os->end_dts = pkt->dts + pkt->duration; <S2SV_EndVul> os->packets_written++; return ff_write_chained(os->ctx, 0, pkt, s); }","- if (os->first_dts == AV_NOPTS_VALUE &&
- if (os->first_dts == AV_NOPTS_VALUE)
- os->first_dts = pkt->dts;
- av_compare_ts(pkt->dts - os->first_dts, st->time_base,
- c->last_duration = av_rescale_q(pkt->dts - os->start_dts,
- c->total_duration = av_rescale_q(pkt->dts - os->first_dts,
- if (os->end_dts != AV_NOPTS_VALUE)
- os->start_dts = os->end_dts;
- os->start_dts = pkt->dts;
- os->end_dts = pkt->dts + pkt->duration;
+ if (os->first_pts == AV_NOPTS_VALUE &&
+ if (os->first_pts == AV_NOPTS_VALUE)
+ os->first_pts = pkt->pts;
+ av_compare_ts(pkt->pts - os->first_pts, st->time_base,
+ c->last_duration = av_rescale_q(pkt->pts - os->start_pts,
+ c->total_duration = av_rescale_q(pkt->pts - os->first_pts,
+ if (os->max_pts != AV_NOPTS_VALUE)
+ os->start_pts = os->max_pts;
+ os->start_pts = pkt->pts;
+ if (os->max_pts == AV_NOPTS_VALUE)
+ os->max_pts = pkt->pts + pkt->duration;
+ else
+ os->max_pts = FFMAX(os->max_pts, pkt->pts + pkt->duration);","static int dash_write_packet(AVFormatContext *s, AVPacket *pkt) { DASHContext *c = s->priv_data; AVStream *st = s->streams[pkt->stream_index]; OutputStream *os = &c->streams[pkt->stream_index]; int64_t seg_end_duration = (os->segment_index) * (int64_t) c->min_seg_duration; int ret; if (os->first_pts == AV_NOPTS_VALUE && s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) { pkt->pts -= pkt->dts; pkt->dts = 0; } if (os->first_pts == AV_NOPTS_VALUE) os->first_pts = pkt->pts; if ((!c->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) && pkt->flags & AV_PKT_FLAG_KEY && os->packets_written && av_compare_ts(pkt->pts - os->first_pts, st->time_base, seg_end_duration, AV_TIME_BASE_Q) >= 0) { int64_t prev_duration = c->last_duration; c->last_duration = av_rescale_q(pkt->pts - os->start_pts, st->time_base, AV_TIME_BASE_Q); c->total_duration = av_rescale_q(pkt->pts - os->first_pts, st->time_base, AV_TIME_BASE_Q); if ((!c->use_timeline || !c->use_template) && prev_duration) { if (c->last_duration < prev_duration*9/10 || c->last_duration > prev_duration*11/10) { av_log(s, AV_LOG_WARNING, ""Segment durations differ too much, enable use_timeline "" ""and use_template, or keep a stricter keyframe interval\n""); } } if ((ret = dash_flush(s, 0, pkt->stream_index)) < 0) return ret; } if (!os->packets_written) { if (os->max_pts != AV_NOPTS_VALUE) os->start_pts = os->max_pts; else os->start_pts = pkt->pts; } if (os->max_pts == AV_NOPTS_VALUE) os->max_pts = pkt->pts + pkt->duration; else os->max_pts = FFMAX(os->max_pts, pkt->pts + pkt->duration); os->packets_written++; return ff_write_chained(os->ctx, 0, pkt, s); }"
3776----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cb0d6c58602cc9ed3e5b5133cae21dd6a42defcb_1.json----dnxhd_decode_header,"static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame, const uint8_t *buf, int buf_size, int first_field) { static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 }; static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 }; static const uint8_t header_prefixhr1[] = { 0x00, 0x00, 0x02, 0x80, 0x03 }; static const uint8_t header_prefixhr2[] = { 0x00, 0x00, 0x03, 0x8C, 0x03 }; int i, cid, ret; int old_bit_depth = ctx->bit_depth, bitdepth; <S2SV_StartVul> int old_mb_height = ctx->mb_height; <S2SV_EndVul> if (buf_size < 0x280) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < 640).\n"", buf_size); return AVERROR_INVALIDDATA; } if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) && memcmp(buf, header_prefixhr1, 5) && memcmp(buf, header_prefixhr2, 5)) { av_log(ctx->avctx, AV_LOG_ERROR, ""unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"", buf[0], buf[1], buf[2], buf[3], buf[4]); return AVERROR_INVALIDDATA; } if (buf[5] & 2) { ctx->cur_field = buf[5] & 1; frame->interlaced_frame = 1; frame->top_field_first = first_field ^ ctx->cur_field; av_log(ctx->avctx, AV_LOG_DEBUG, ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field); } else { ctx->cur_field = 0; } ctx->mbaff = (buf[0x6] >> 5) & 1; ctx->height = AV_RB16(buf + 0x18); ctx->width = AV_RB16(buf + 0x1a); switch(buf[0x21] >> 5) { case 1: bitdepth = 8; break; case 2: bitdepth = 10; break; case 3: bitdepth = 12; break; default: av_log(ctx->avctx, AV_LOG_ERROR, ""Unknown bitdepth indicator (%d)\n"", buf[0x21] >> 5); return AVERROR_INVALIDDATA; } cid = AV_RB32(buf + 0x28); if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0) return ret; if (ctx->mbaff && ctx->cid_table->cid != 1260) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive MB interlace flag in an unsupported profile.\n""); ctx->act = buf[0x2C] & 7; if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive color transform in an unsupported profile.\n""); ctx->is_444 = (buf[0x2C] >> 6) & 1; if (ctx->is_444) { if (bitdepth == 8) { avpriv_request_sample(ctx->avctx, ""4:4:4 8 bits\n""); return AVERROR_INVALIDDATA; } else if (bitdepth == 10) { ctx->decode_dct_block = dnxhd_decode_dct_block_10_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_12_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12; } } else if (bitdepth == 12) { ctx->decode_dct_block = dnxhd_decode_dct_block_12; ctx->pix_fmt = AV_PIX_FMT_YUV422P12; } else if (bitdepth == 10) { ctx->decode_dct_block = dnxhd_decode_dct_block_10; ctx->pix_fmt = AV_PIX_FMT_YUV422P10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_8; ctx->pix_fmt = AV_PIX_FMT_YUV422P; } ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth; if (ctx->bit_depth != old_bit_depth) { ff_blockdsp_init(&ctx->bdsp, ctx->avctx); ff_idctdsp_init(&ctx->idsp, ctx->avctx); ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, ff_zigzag_direct); } if (ctx->width != ctx->cid_table->width && ctx->cid_table->width != DNXHD_VARIABLE) { av_reduce(&ctx->avctx->sample_aspect_ratio.num, &ctx->avctx->sample_aspect_ratio.den, ctx->width, ctx->cid_table->width, 255); ctx->width = ctx->cid_table->width; } if (buf_size < ctx->cid_table->coding_unit_size) { av_log(ctx->avctx, AV_LOG_ERROR, ""incorrect frame size (%d < %d).\n"", buf_size, ctx->cid_table->coding_unit_size); return AVERROR_INVALIDDATA; } ctx->mb_width = (ctx->width + 15)>> 4; ctx->mb_height = buf[0x16d]; if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame) ctx->height <<= 1; av_log(ctx->avctx, AV_LOG_VERBOSE, ""%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"", ctx->width, ctx->height, ctx->is_444 ? ""4:4"" : ""2:2"", ctx->bit_depth, ctx->mbaff, ctx->act); if (!memcmp(buf, header_prefixhr2, 5)) { ctx->data_offset = 0x170 + (ctx->mb_height << 2); } else { if (ctx->mb_height > 68 || (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) { av_log(ctx->avctx, AV_LOG_ERROR, ""mb height too big: %d\n"", ctx->mb_height); return AVERROR_INVALIDDATA; } ctx->data_offset = 0x280; } if (buf_size < ctx->data_offset) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < %d).\n"", buf_size, ctx->data_offset); return AVERROR_INVALIDDATA; } <S2SV_StartVul> if (ctx->mb_height != old_mb_height) { <S2SV_EndVul> <S2SV_StartVul> av_freep(&ctx->mb_scan_index); <S2SV_EndVul> <S2SV_StartVul> ctx->mb_scan_index = av_mallocz_array(ctx->mb_height, sizeof(uint32_t)); <S2SV_EndVul> <S2SV_StartVul> if (!ctx->mb_scan_index) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> for (i = 0; i < ctx->mb_height; i++) { ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2)); ff_dlog(ctx->avctx, ""mb scan index %d, pos %d: %u\n"", i, 0x170 + (i << 2), ctx->mb_scan_index[i]); if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) { av_log(ctx->avctx, AV_LOG_ERROR, ""invalid mb scan index (%u vs %u).\n"", ctx->mb_scan_index[i], buf_size - ctx->data_offset); return AVERROR_INVALIDDATA; } } return 0; }","- int old_mb_height = ctx->mb_height;
- if (ctx->mb_height != old_mb_height) {
- av_freep(&ctx->mb_scan_index);
- ctx->mb_scan_index = av_mallocz_array(ctx->mb_height, sizeof(uint32_t));
- if (!ctx->mb_scan_index)
- return AVERROR(ENOMEM);
- }
+ av_assert0((unsigned)ctx->mb_height <= FF_ARRAY_ELEMS(ctx->mb_scan_index));","static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame, const uint8_t *buf, int buf_size, int first_field) { static const uint8_t header_prefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 }; static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 }; static const uint8_t header_prefixhr1[] = { 0x00, 0x00, 0x02, 0x80, 0x03 }; static const uint8_t header_prefixhr2[] = { 0x00, 0x00, 0x03, 0x8C, 0x03 }; int i, cid, ret; int old_bit_depth = ctx->bit_depth, bitdepth; if (buf_size < 0x280) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < 640).\n"", buf_size); return AVERROR_INVALIDDATA; } if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) && memcmp(buf, header_prefixhr1, 5) && memcmp(buf, header_prefixhr2, 5)) { av_log(ctx->avctx, AV_LOG_ERROR, ""unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"", buf[0], buf[1], buf[2], buf[3], buf[4]); return AVERROR_INVALIDDATA; } if (buf[5] & 2) { ctx->cur_field = buf[5] & 1; frame->interlaced_frame = 1; frame->top_field_first = first_field ^ ctx->cur_field; av_log(ctx->avctx, AV_LOG_DEBUG, ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field); } else { ctx->cur_field = 0; } ctx->mbaff = (buf[0x6] >> 5) & 1; ctx->height = AV_RB16(buf + 0x18); ctx->width = AV_RB16(buf + 0x1a); switch(buf[0x21] >> 5) { case 1: bitdepth = 8; break; case 2: bitdepth = 10; break; case 3: bitdepth = 12; break; default: av_log(ctx->avctx, AV_LOG_ERROR, ""Unknown bitdepth indicator (%d)\n"", buf[0x21] >> 5); return AVERROR_INVALIDDATA; } cid = AV_RB32(buf + 0x28); if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0) return ret; if (ctx->mbaff && ctx->cid_table->cid != 1260) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive MB interlace flag in an unsupported profile.\n""); ctx->act = buf[0x2C] & 7; if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive color transform in an unsupported profile.\n""); ctx->is_444 = (buf[0x2C] >> 6) & 1; if (ctx->is_444) { if (bitdepth == 8) { avpriv_request_sample(ctx->avctx, ""4:4:4 8 bits\n""); return AVERROR_INVALIDDATA; } else if (bitdepth == 10) { ctx->decode_dct_block = dnxhd_decode_dct_block_10_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_12_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12; } } else if (bitdepth == 12) { ctx->decode_dct_block = dnxhd_decode_dct_block_12; ctx->pix_fmt = AV_PIX_FMT_YUV422P12; } else if (bitdepth == 10) { ctx->decode_dct_block = dnxhd_decode_dct_block_10; ctx->pix_fmt = AV_PIX_FMT_YUV422P10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_8; ctx->pix_fmt = AV_PIX_FMT_YUV422P; } ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth; if (ctx->bit_depth != old_bit_depth) { ff_blockdsp_init(&ctx->bdsp, ctx->avctx); ff_idctdsp_init(&ctx->idsp, ctx->avctx); ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, ff_zigzag_direct); } if (ctx->width != ctx->cid_table->width && ctx->cid_table->width != DNXHD_VARIABLE) { av_reduce(&ctx->avctx->sample_aspect_ratio.num, &ctx->avctx->sample_aspect_ratio.den, ctx->width, ctx->cid_table->width, 255); ctx->width = ctx->cid_table->width; } if (buf_size < ctx->cid_table->coding_unit_size) { av_log(ctx->avctx, AV_LOG_ERROR, ""incorrect frame size (%d < %d).\n"", buf_size, ctx->cid_table->coding_unit_size); return AVERROR_INVALIDDATA; } ctx->mb_width = (ctx->width + 15)>> 4; ctx->mb_height = buf[0x16d]; if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame) ctx->height <<= 1; av_log(ctx->avctx, AV_LOG_VERBOSE, ""%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"", ctx->width, ctx->height, ctx->is_444 ? ""4:4"" : ""2:2"", ctx->bit_depth, ctx->mbaff, ctx->act); if (!memcmp(buf, header_prefixhr2, 5)) { ctx->data_offset = 0x170 + (ctx->mb_height << 2); } else { if (ctx->mb_height > 68 || (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) { av_log(ctx->avctx, AV_LOG_ERROR, ""mb height too big: %d\n"", ctx->mb_height); return AVERROR_INVALIDDATA; } ctx->data_offset = 0x280; } if (buf_size < ctx->data_offset) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < %d).\n"", buf_size, ctx->data_offset); return AVERROR_INVALIDDATA; } av_assert0((unsigned)ctx->mb_height <= FF_ARRAY_ELEMS(ctx->mb_scan_index)); for (i = 0; i < ctx->mb_height; i++) { ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2)); ff_dlog(ctx->avctx, ""mb scan index %d, pos %d: %u\n"", i, 0x170 + (i << 2), ctx->mb_scan_index[i]); if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) { av_log(ctx->avctx, AV_LOG_ERROR, ""invalid mb scan index (%u vs %u).\n"", ctx->mb_scan_index[i], buf_size - ctx->data_offset); return AVERROR_INVALIDDATA; } } return 0; }"
4564----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f6853f0cc22f3c6129d729ca46630f7caf0f37f1_1.json----sap_fetch_packet,"static int sap_fetch_packet(AVFormatContext *s, AVPacket *pkt) { struct SAPState *sap = s->priv_data; int fd = url_get_file_handle(sap->ann_fd); int n, ret; <S2SV_StartVul> fd_set rfds; <S2SV_EndVul> <S2SV_StartVul> struct timeval tv; <S2SV_EndVul> uint8_t recvbuf[1500]; if (sap->eof) return AVERROR_EOF; while (1) { <S2SV_StartVul> FD_ZERO(&rfds); <S2SV_EndVul> <S2SV_StartVul> FD_SET(fd, &rfds); <S2SV_EndVul> <S2SV_StartVul> tv.tv_sec = tv.tv_usec = 0; <S2SV_EndVul> <S2SV_StartVul> n = select(fd + 1, &rfds, NULL, NULL, &tv); <S2SV_EndVul> <S2SV_StartVul> if (n <= 0 || !FD_ISSET(fd, &rfds)) <S2SV_EndVul> break; ret = url_read(sap->ann_fd, recvbuf, sizeof(recvbuf)); if (ret >= 8) { uint16_t hash = AV_RB16(&recvbuf[2]); if (recvbuf[0] & 0x04 && hash == sap->hash) { sap->eof = 1; return AVERROR_EOF; } } } ret = av_read_frame(sap->sdp_ctx, pkt); if (ret < 0) return ret; if (s->ctx_flags & AVFMTCTX_NOHEADER) { while (sap->sdp_ctx->nb_streams > s->nb_streams) { int i = s->nb_streams; AVStream *st = av_new_stream(s, i); if (!st) { av_free_packet(pkt); return AVERROR(ENOMEM); } avcodec_copy_context(st->codec, sap->sdp_ctx->streams[i]->codec); st->time_base = sap->sdp_ctx->streams[i]->time_base; } } return ret; }","- fd_set rfds;
- struct timeval tv;
- FD_ZERO(&rfds);
- FD_SET(fd, &rfds);
- tv.tv_sec = tv.tv_usec = 0;
- n = select(fd + 1, &rfds, NULL, NULL, &tv);
- if (n <= 0 || !FD_ISSET(fd, &rfds))
+ struct pollfd p = {fd, POLLIN, 0};
+ n = poll(&p, 1, 0);
+ if (n <= 0 || !(p.revents & POLLIN))","static int sap_fetch_packet(AVFormatContext *s, AVPacket *pkt) { struct SAPState *sap = s->priv_data; int fd = url_get_file_handle(sap->ann_fd); int n, ret; struct pollfd p = {fd, POLLIN, 0}; uint8_t recvbuf[1500]; if (sap->eof) return AVERROR_EOF; while (1) { n = poll(&p, 1, 0); if (n <= 0 || !(p.revents & POLLIN)) break; ret = url_read(sap->ann_fd, recvbuf, sizeof(recvbuf)); if (ret >= 8) { uint16_t hash = AV_RB16(&recvbuf[2]); if (recvbuf[0] & 0x04 && hash == sap->hash) { sap->eof = 1; return AVERROR_EOF; } } } ret = av_read_frame(sap->sdp_ctx, pkt); if (ret < 0) return ret; if (s->ctx_flags & AVFMTCTX_NOHEADER) { while (sap->sdp_ctx->nb_streams > s->nb_streams) { int i = s->nb_streams; AVStream *st = av_new_stream(s, i); if (!st) { av_free_packet(pkt); return AVERROR(ENOMEM); } avcodec_copy_context(st->codec, sap->sdp_ctx->streams[i]->codec); st->time_base = sap->sdp_ctx->streams[i]->time_base; } } return ret; }"
10344----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_02aef6aad09723981e862f1c3de40d8bd8db4860_1.json----tls_psk_do_binder,"int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart, size_t binderoffset, const unsigned char *binderin, unsigned char *binderout, SSL_SESSION *sess, int sign, int external) { EVP_PKEY *mackey = NULL; EVP_MD_CTX *mctx = NULL; unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE]; unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE]; unsigned char *early_secret; static const unsigned char resumption_label[] = ""res binder""; static const unsigned char external_label[] = ""ext binder""; const unsigned char *label; size_t bindersize, labelsize, hashsize; int hashsizei = EVP_MD_size(md); int ret = -1; int usepskfored = 0; if (!ossl_assert(hashsizei >= 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } hashsize = (size_t)hashsizei; if (external && s->early_data_state == SSL_EARLY_DATA_CONNECTING && s->session->ext.max_early_data == 0 && sess->ext.max_early_data > 0) usepskfored = 1; if (external) { label = external_label; labelsize = sizeof(external_label) - 1; } else { label = resumption_label; labelsize = sizeof(resumption_label) - 1; } if (s->server || !external || usepskfored) early_secret = (unsigned char *)s->early_secret; else early_secret = (unsigned char *)sess->early_secret; if (!tls13_generate_secret(s, md, NULL, sess->master_key, sess->master_key_length, early_secret)) { goto err; } mctx = EVP_MD_CTX_new(); if (mctx == NULL || EVP_DigestInit_ex(mctx, md, NULL) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash, <S2SV_StartVul> hashsize, binderkey, hashsize)) { <S2SV_EndVul> goto err; } if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) { goto err; } if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (s->hello_retry_request == SSL_HRR_PENDING) { size_t hdatalen; long hdatalen_l; void *hdata; hdatalen = hdatalen_l = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen_l <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, SSL_R_BAD_HANDSHAKE_LENGTH); goto err; } if (s->server) { PACKET hashprefix, msg; if (!PACKET_buf_init(&hashprefix, hdata, hdatalen) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } hdatalen -= PACKET_remaining(&hashprefix); } if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } } if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } mackey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, finishedkey, hashsize); if (mackey == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!sign) binderout = tmpbinder; bindersize = hashsize; if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0 || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0 || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0 || bindersize != hashsize) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (sign) { ret = 1; } else { ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0); if (!ret) SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PSK_DO_BINDER, SSL_R_BINDER_DOES_NOT_VERIFY); } err: OPENSSL_cleanse(binderkey, sizeof(binderkey)); OPENSSL_cleanse(finishedkey, sizeof(finishedkey)); EVP_PKEY_free(mackey); EVP_MD_CTX_free(mctx); return ret; }","- hashsize, binderkey, hashsize)) {
+ hashsize, binderkey, hashsize, 1)) {","int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart, size_t binderoffset, const unsigned char *binderin, unsigned char *binderout, SSL_SESSION *sess, int sign, int external) { EVP_PKEY *mackey = NULL; EVP_MD_CTX *mctx = NULL; unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE]; unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE]; unsigned char *early_secret; static const unsigned char resumption_label[] = ""res binder""; static const unsigned char external_label[] = ""ext binder""; const unsigned char *label; size_t bindersize, labelsize, hashsize; int hashsizei = EVP_MD_size(md); int ret = -1; int usepskfored = 0; if (!ossl_assert(hashsizei >= 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } hashsize = (size_t)hashsizei; if (external && s->early_data_state == SSL_EARLY_DATA_CONNECTING && s->session->ext.max_early_data == 0 && sess->ext.max_early_data > 0) usepskfored = 1; if (external) { label = external_label; labelsize = sizeof(external_label) - 1; } else { label = resumption_label; labelsize = sizeof(resumption_label) - 1; } if (s->server || !external || usepskfored) early_secret = (unsigned char *)s->early_secret; else early_secret = (unsigned char *)sess->early_secret; if (!tls13_generate_secret(s, md, NULL, sess->master_key, sess->master_key_length, early_secret)) { goto err; } mctx = EVP_MD_CTX_new(); if (mctx == NULL || EVP_DigestInit_ex(mctx, md, NULL) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash, hashsize, binderkey, hashsize, 1)) { goto err; } if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) { goto err; } if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (s->hello_retry_request == SSL_HRR_PENDING) { size_t hdatalen; long hdatalen_l; void *hdata; hdatalen = hdatalen_l = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen_l <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, SSL_R_BAD_HANDSHAKE_LENGTH); goto err; } if (s->server) { PACKET hashprefix, msg; if (!PACKET_buf_init(&hashprefix, hdata, hdatalen) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } hdatalen -= PACKET_remaining(&hashprefix); } if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } } if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } mackey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, finishedkey, hashsize); if (mackey == NULL) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!sign) binderout = tmpbinder; bindersize = hashsize; if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0 || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0 || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0 || bindersize != hashsize) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (sign) { ret = 1; } else { ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0); if (!ret) SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PSK_DO_BINDER, SSL_R_BINDER_DOES_NOT_VERIFY); } err: OPENSSL_cleanse(binderkey, sizeof(binderkey)); OPENSSL_cleanse(finishedkey, sizeof(finishedkey)); EVP_PKEY_free(mackey); EVP_MD_CTX_free(mctx); return ret; }"
14286----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_8c9e8f9ee7fa46060aeb241db1af24ee7ecffb68_1.json----help_main,"int help_main(int argc, char **argv) { FUNCTION *fp; int i, nl; FUNC_TYPE tp; char *prog; HELPLIST_CHOICE o; prog = opt_init(argc, argv, help_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { default: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); return 1; case OPT_HELP: opt_help(help_options); return 0; } } argc = opt_num_rest(); <S2SV_StartVul> argv = opt_rest(); <S2SV_EndVul> if (argc != 0) { BIO_printf(bio_err, ""Usage: %s\n"", prog); return 1; } BIO_printf(bio_err, ""\nStandard commands""); i = 0; tp = FT_none; for (fp = functions; fp->name != NULL; fp++) { nl = 0; if (((i++) % COLUMNS) == 0) { BIO_printf(bio_err, ""\n""); nl = 1; } if (fp->type != tp) { tp = fp->type; if (!nl) BIO_printf(bio_err, ""\n""); if (tp == FT_md) { i = 1; BIO_printf(bio_err, ""\nMessage Digest commands (see the `dgst' command for more details)\n""); } else if (tp == FT_cipher) { i = 1; BIO_printf(bio_err, ""\nCipher commands (see the `enc' command for more details)\n""); } } BIO_printf(bio_err, FORMAT, fp->name); } BIO_printf(bio_err, ""\n\n""); return 0; }",- argv = opt_rest();,"int help_main(int argc, char **argv) { FUNCTION *fp; int i, nl; FUNC_TYPE tp; char *prog; HELPLIST_CHOICE o; prog = opt_init(argc, argv, help_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { default: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); return 1; case OPT_HELP: opt_help(help_options); return 0; } } argc = opt_num_rest(); if (argc != 0) { BIO_printf(bio_err, ""Usage: %s\n"", prog); return 1; } BIO_printf(bio_err, ""\nStandard commands""); i = 0; tp = FT_none; for (fp = functions; fp->name != NULL; fp++) { nl = 0; if (((i++) % COLUMNS) == 0) { BIO_printf(bio_err, ""\n""); nl = 1; } if (fp->type != tp) { tp = fp->type; if (!nl) BIO_printf(bio_err, ""\n""); if (tp == FT_md) { i = 1; BIO_printf(bio_err, ""\nMessage Digest commands (see the `dgst' command for more details)\n""); } else if (tp == FT_cipher) { i = 1; BIO_printf(bio_err, ""\nCipher commands (see the `enc' command for more details)\n""); } } BIO_printf(bio_err, FORMAT, fp->name); } BIO_printf(bio_err, ""\n\n""); return 0; }"
11744----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_34b990c39f2127305bc6002f460e7984882ad409_1.json----fmtfp,"static void fmtfp( <S2SV_StartVul> char *buffer, <S2SV_EndVul> size_t *currlen, <S2SV_StartVul> size_t maxlen, <S2SV_EndVul> LDOUBLE fvalue, int min, int max, int flags) { int signvalue = 0; LDOUBLE ufvalue; char iconvert[20]; char fconvert[20]; int iplace = 0; int fplace = 0; int padlen = 0; int zpadlen = 0; int caps = 0; long intpart; long fracpart; if (max < 0) max = 6; ufvalue = abs_val(fvalue); if (fvalue < 0) signvalue = '-'; else if (flags & DP_F_PLUS) signvalue = '+'; else if (flags & DP_F_SPACE) signvalue = ' '; intpart = (long)ufvalue; if (max > 9) max = 9; fracpart = round((pow10(max)) * (ufvalue - intpart)); if (fracpart >= pow10(max)) { intpart++; fracpart -= (long)pow10(max); } do { iconvert[iplace++] = (caps ? ""0123456789ABCDEF"" : ""0123456789abcdef"")[intpart % 10]; intpart = (intpart / 10); } while (intpart && (iplace < 20)); if (iplace == 20) iplace--; iconvert[iplace] = 0; do { fconvert[fplace++] = (caps ? ""0123456789ABCDEF"" : ""0123456789abcdef"")[fracpart % 10]; fracpart = (fracpart / 10); } while (fracpart && (fplace < 20)); if (fplace == 20) fplace--; fconvert[fplace] = 0; padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); zpadlen = max - fplace; if (zpadlen < 0) zpadlen = 0; if (padlen < 0) padlen = 0; if (flags & DP_F_MINUS) padlen = -padlen; if ((flags & DP_F_ZERO) && (padlen > 0)) { if (signvalue) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, signvalue); <S2SV_EndVul> --padlen; signvalue = 0; } while (padlen > 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, '0'); <S2SV_EndVul> --padlen; } } while (padlen > 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, ' '); <S2SV_EndVul> --padlen; } if (signvalue) <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, signvalue); <S2SV_EndVul> while (iplace > 0) <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, iconvert[--iplace]); <S2SV_EndVul> if (max > 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, '.'); <S2SV_EndVul> while (fplace > 0) <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, fconvert[--fplace]); <S2SV_EndVul> } while (zpadlen > 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, '0'); <S2SV_EndVul> --zpadlen; } while (padlen < 0) { <S2SV_StartVul> dopr_outch(buffer, currlen, maxlen, ' '); <S2SV_EndVul> ++padlen; } }","- char *buffer,
- size_t maxlen,
- dopr_outch(buffer, currlen, maxlen, signvalue);
- dopr_outch(buffer, currlen, maxlen, '0');
- dopr_outch(buffer, currlen, maxlen, ' ');
- dopr_outch(buffer, currlen, maxlen, signvalue);
- dopr_outch(buffer, currlen, maxlen, iconvert[--iplace]);
- dopr_outch(buffer, currlen, maxlen, '.');
- dopr_outch(buffer, currlen, maxlen, fconvert[--fplace]);
- dopr_outch(buffer, currlen, maxlen, '0');
- dopr_outch(buffer, currlen, maxlen, ' ');
+ void (*outch_fn)(char **, size_t *, size_t *, int),
+ char **buffer,
+ size_t *maxlen,
+ (*outch_fn)(buffer, currlen, maxlen, signvalue);
+ (*outch_fn)(buffer, currlen, maxlen, '0');
+ (*outch_fn)(buffer, currlen, maxlen, ' ');
+ (*outch_fn)(buffer, currlen, maxlen, signvalue);
+ (*outch_fn)(buffer, currlen, maxlen, iconvert[--iplace]);
+ (*outch_fn)(buffer, currlen, maxlen, '.');
+ (*outch_fn)(buffer, currlen, maxlen, fconvert[--fplace]);
+ (*outch_fn)(buffer, currlen, maxlen, '0');
+ (*outch_fn)(buffer, currlen, maxlen, ' ');","static void fmtfp( void (*outch_fn)(char **, size_t *, size_t *, int), char **buffer, size_t *currlen, size_t *maxlen, LDOUBLE fvalue, int min, int max, int flags) { int signvalue = 0; LDOUBLE ufvalue; char iconvert[20]; char fconvert[20]; int iplace = 0; int fplace = 0; int padlen = 0; int zpadlen = 0; int caps = 0; long intpart; long fracpart; if (max < 0) max = 6; ufvalue = abs_val(fvalue); if (fvalue < 0) signvalue = '-'; else if (flags & DP_F_PLUS) signvalue = '+'; else if (flags & DP_F_SPACE) signvalue = ' '; intpart = (long)ufvalue; if (max > 9) max = 9; fracpart = round((pow10(max)) * (ufvalue - intpart)); if (fracpart >= pow10(max)) { intpart++; fracpart -= (long)pow10(max); } do { iconvert[iplace++] = (caps ? ""0123456789ABCDEF"" : ""0123456789abcdef"")[intpart % 10]; intpart = (intpart / 10); } while (intpart && (iplace < 20)); if (iplace == 20) iplace--; iconvert[iplace] = 0; do { fconvert[fplace++] = (caps ? ""0123456789ABCDEF"" : ""0123456789abcdef"")[fracpart % 10]; fracpart = (fracpart / 10); } while (fracpart && (fplace < 20)); if (fplace == 20) fplace--; fconvert[fplace] = 0; padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); zpadlen = max - fplace; if (zpadlen < 0) zpadlen = 0; if (padlen < 0) padlen = 0; if (flags & DP_F_MINUS) padlen = -padlen; if ((flags & DP_F_ZERO) && (padlen > 0)) { if (signvalue) { (*outch_fn)(buffer, currlen, maxlen, signvalue); --padlen; signvalue = 0; } while (padlen > 0) { (*outch_fn)(buffer, currlen, maxlen, '0'); --padlen; } } while (padlen > 0) { (*outch_fn)(buffer, currlen, maxlen, ' '); --padlen; } if (signvalue) (*outch_fn)(buffer, currlen, maxlen, signvalue); while (iplace > 0) (*outch_fn)(buffer, currlen, maxlen, iconvert[--iplace]); if (max > 0) { (*outch_fn)(buffer, currlen, maxlen, '.'); while (fplace > 0) (*outch_fn)(buffer, currlen, maxlen, fconvert[--fplace]); } while (zpadlen > 0) { (*outch_fn)(buffer, currlen, maxlen, '0'); --zpadlen; } while (padlen < 0) { (*outch_fn)(buffer, currlen, maxlen, ' '); ++padlen; } }"
4228----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e4755f22e728c6b8770b4645fe850991046a30d0_1.json----set_palette,"<S2SV_StartVul> static int set_palette(AVFrame * frame, const uint8_t * palette_buffer, int buf_size) <S2SV_EndVul> { <S2SV_StartVul> uint32_t * palette = (uint32_t *)frame->data[1]; <S2SV_EndVul> int a; <S2SV_StartVul> if (buf_size < 256*3) <S2SV_EndVul> return AVERROR_INVALIDDATA; for(a = 0; a < 256; a++){ <S2SV_StartVul> palette[a] = AV_RB24(&palette_buffer[a * 3]) * 4; <S2SV_EndVul> } <S2SV_StartVul> frame->palette_has_changed = 1; <S2SV_EndVul> return 256*3; }","- static int set_palette(AVFrame * frame, const uint8_t * palette_buffer, int buf_size)
- uint32_t * palette = (uint32_t *)frame->data[1];
- if (buf_size < 256*3)
- palette[a] = AV_RB24(&palette_buffer[a * 3]) * 4;
- frame->palette_has_changed = 1;
+ static int set_palette(BethsoftvidContext *ctx)
+ uint32_t *palette = (uint32_t *)ctx->frame.data[1];
+ if (bytestream2_get_bytes_left(&ctx->g) < 256*3)
+ palette[a] = bytestream2_get_be24u(&ctx->g) * 4;
+ ctx->frame.palette_has_changed = 1;",static int set_palette(BethsoftvidContext *ctx) { uint32_t *palette = (uint32_t *)ctx->frame.data[1]; int a; if (bytestream2_get_bytes_left(&ctx->g) < 256*3) return AVERROR_INVALIDDATA; for(a = 0; a < 256; a++){ palette[a] = bytestream2_get_be24u(&ctx->g) * 4; } ctx->frame.palette_has_changed = 1; return 256*3; }
9----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_00d5bcf19ac61544540101d65a0659a5f2d49170_1.json----ff_fast_malloc,"static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc) { void *val; if (min_size < *size) return 0; <S2SV_StartVul> min_size = FFMAX(17 * min_size / 16 + 32, min_size); <S2SV_EndVul> av_freep(ptr); val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size); memcpy(ptr, &val, sizeof(val)); if (!val) min_size = 0; *size = min_size; return 1; }","- min_size = FFMAX(17 * min_size / 16 + 32, min_size);
+ min_size = FFMAX(min_size + min_size / 16 + 32, min_size);","static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc) { void *val; if (min_size < *size) return 0; min_size = FFMAX(min_size + min_size / 16 + 32, min_size); av_freep(ptr); val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size); memcpy(ptr, &val, sizeof(val)); if (!val) min_size = 0; *size = min_size; return 1; }"
4990----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_02d945294ff3b6fe4156603181976a5f86d6d733_1.json----ff_id3v2_parse,"<S2SV_StartVul> static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags) <S2SV_EndVul> { int isv34, tlen, unsync; char tag[5]; int64_t next, end = avio_tell(s->pb) + len; int taghdrlen; const char *reason = NULL; AVIOContext pb; unsigned char *buffer = NULL; int buffer_size = 0; switch (version) { case 2: if (flags & 0x40) { reason = ""compression""; goto error; } isv34 = 0; taghdrlen = 6; break; case 3: case 4: isv34 = 1; taghdrlen = 10; break; default: reason = ""version""; goto error; } unsync = flags & 0x80; if (isv34 && flags & 0x40) avio_skip(s->pb, get_size(s->pb, 4)); while (len >= taghdrlen) { unsigned int tflags = 0; int tunsync = 0; if (isv34) { avio_read(s->pb, tag, 4); tag[4] = 0; if(version==3){ tlen = avio_rb32(s->pb); }else tlen = get_size(s->pb, 4); tflags = avio_rb16(s->pb); tunsync = tflags & ID3v2_FLAG_UNSYNCH; } else { avio_read(s->pb, tag, 3); tag[3] = 0; tlen = avio_rb24(s->pb); } if (tlen <= 0 || tlen > len - taghdrlen) { av_log(s, AV_LOG_WARNING, ""Invalid size in frame %s, skipping the rest of tag.\n"", tag); break; } len -= taghdrlen + tlen; next = avio_tell(s->pb) + tlen; if (tflags & ID3v2_FLAG_DATALEN) { avio_rb32(s->pb); tlen -= 4; } if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) { av_log(s, AV_LOG_WARNING, ""Skipping encrypted/compressed ID3v2 frame %s.\n"", tag); avio_skip(s->pb, tlen); <S2SV_StartVul> } else if (tag[0] == 'T') { <S2SV_EndVul> if (unsync || tunsync) { int i, j; av_fast_malloc(&buffer, &buffer_size, tlen); if (!buffer) { av_log(s, AV_LOG_ERROR, ""Failed to alloc %d bytes\n"", tlen); goto seek; } for (i = 0, j = 0; i < tlen; i++, j++) { buffer[j] = avio_r8(s->pb); if (j > 0 && !buffer[j] && buffer[j - 1] == 0xff) { j--; } } ffio_init_context(&pb, buffer, j, 0, NULL, NULL, NULL, NULL); <S2SV_StartVul> read_ttag(s, &pb, j, tag); <S2SV_EndVul> } else { <S2SV_StartVul> read_ttag(s, s->pb, tlen, tag); <S2SV_EndVul> } } else if (!tag[0]) { if (tag[1]) av_log(s, AV_LOG_WARNING, ""invalid frame id, assuming padding""); avio_skip(s->pb, tlen); break; } seek: avio_seek(s->pb, next, SEEK_SET); } if (version == 4 && flags & 0x10) end += 10; error: if (reason) av_log(s, AV_LOG_INFO, ""ID3v2.%d tag skipped, cannot handle %s\n"", version, reason); avio_seek(s->pb, end, SEEK_SET); av_free(buffer); return; }","- static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags)
- } else if (tag[0] == 'T') {
- read_ttag(s, &pb, j, tag);
- read_ttag(s, s->pb, tlen, tag);
+ static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags, ID3v2ExtraMeta **extra_meta)
+ AVIOContext *pbx;
+ void (*extra_func)(AVFormatContext*, AVIOContext*, int, char*, ID3v2ExtraMeta**) = NULL;
+ } else if (tag[0] == 'T' || (extra_meta && (extra_func = get_extra_meta_func(tag, isv34)->read))) {
+ tlen = j;
+ pbx = &pb; // read from sync buffer
+ pbx = s->pb; // read straight from input
+ if (tag[0] == 'T')
+ read_ttag(s, pbx, tlen, tag);
+ else
+ extra_func(s, pbx, tlen, tag, extra_meta);","static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags, ID3v2ExtraMeta **extra_meta) { int isv34, tlen, unsync; char tag[5]; int64_t next, end = avio_tell(s->pb) + len; int taghdrlen; const char *reason = NULL; AVIOContext pb; AVIOContext *pbx; unsigned char *buffer = NULL; int buffer_size = 0; void (*extra_func)(AVFormatContext*, AVIOContext*, int, char*, ID3v2ExtraMeta**) = NULL; switch (version) { case 2: if (flags & 0x40) { reason = ""compression""; goto error; } isv34 = 0; taghdrlen = 6; break; case 3: case 4: isv34 = 1; taghdrlen = 10; break; default: reason = ""version""; goto error; } unsync = flags & 0x80; if (isv34 && flags & 0x40) avio_skip(s->pb, get_size(s->pb, 4)); while (len >= taghdrlen) { unsigned int tflags = 0; int tunsync = 0; if (isv34) { avio_read(s->pb, tag, 4); tag[4] = 0; if(version==3){ tlen = avio_rb32(s->pb); }else tlen = get_size(s->pb, 4); tflags = avio_rb16(s->pb); tunsync = tflags & ID3v2_FLAG_UNSYNCH; } else { avio_read(s->pb, tag, 3); tag[3] = 0; tlen = avio_rb24(s->pb); } if (tlen <= 0 || tlen > len - taghdrlen) { av_log(s, AV_LOG_WARNING, ""Invalid size in frame %s, skipping the rest of tag.\n"", tag); break; } len -= taghdrlen + tlen; next = avio_tell(s->pb) + tlen; if (tflags & ID3v2_FLAG_DATALEN) { avio_rb32(s->pb); tlen -= 4; } if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) { av_log(s, AV_LOG_WARNING, ""Skipping encrypted/compressed ID3v2 frame %s.\n"", tag); avio_skip(s->pb, tlen); } else if (tag[0] == 'T' || (extra_meta && (extra_func = get_extra_meta_func(tag, isv34)->read))) { if (unsync || tunsync) { int i, j; av_fast_malloc(&buffer, &buffer_size, tlen); if (!buffer) { av_log(s, AV_LOG_ERROR, ""Failed to alloc %d bytes\n"", tlen); goto seek; } for (i = 0, j = 0; i < tlen; i++, j++) { buffer[j] = avio_r8(s->pb); if (j > 0 && !buffer[j] && buffer[j - 1] == 0xff) { j--; } } ffio_init_context(&pb, buffer, j, 0, NULL, NULL, NULL, NULL); tlen = j; pbx = &pb; } else { pbx = s->pb; } if (tag[0] == 'T') read_ttag(s, pbx, tlen, tag); else extra_func(s, pbx, tlen, tag, extra_meta); } else if (!tag[0]) { if (tag[1]) av_log(s, AV_LOG_WARNING, ""invalid frame id, assuming padding""); avio_skip(s->pb, tlen); break; } seek: avio_seek(s->pb, next, SEEK_SET); } if (version == 4 && flags & 0x10) end += 10; error: if (reason) av_log(s, AV_LOG_INFO, ""ID3v2.%d tag skipped, cannot handle %s\n"", version, reason); avio_seek(s->pb, end, SEEK_SET); av_free(buffer); return; }"
9520----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_760b8c63c78de86e272f3bdbc080d5520b7debd6_1.json----TryChopUpUncompressedBigTiff,"static void TryChopUpUncompressedBigTiff( TIFF* tif ) { TIFFDirectory *td = &tif->tif_dir; uint32 rowblock; uint64 rowblockbytes; uint32 i; uint64 stripsize; uint32 rowblocksperstrip; uint32 rowsperstrip; uint64 stripbytes; uint32 nstrips; stripsize = TIFFStripSize64(tif); assert( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG ); assert( tif->tif_dir.td_compression == COMPRESSION_NONE ); assert( (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP ); assert( stripsize > 0x7FFFFFFFUL ); <S2SV_StartVul> if( td->td_stripbytecount[0] == 0 && tif->tif_mode != O_RDONLY ) <S2SV_EndVul> return; if ((td->td_photometric == PHOTOMETRIC_YCBCR)&& (!isUpSampled(tif))) rowblock = td->td_ycbcrsubsampling[1]; else rowblock = 1; rowblockbytes = TIFFVStripSize64(tif, rowblock); if( rowblockbytes == 0 || rowblockbytes > 0x7FFFFFFFUL ) { return; } for( i = 0; i < td->td_nstrips; i++ ) { if( i == td->td_nstrips - 1 ) { <S2SV_StartVul> if( td->td_stripbytecount[i] < TIFFVStripSize64( <S2SV_EndVul> tif, td->td_imagelength - i * td->td_rowsperstrip ) ) { return; } } else { <S2SV_StartVul> if( td->td_stripbytecount[i] != stripsize ) <S2SV_EndVul> { return; } <S2SV_StartVul> if( i > 0 && td->td_stripoffset[i] != <S2SV_EndVul> <S2SV_StartVul> td->td_stripoffset[i-1] + td->td_stripbytecount[i - 1] ) <S2SV_EndVul> { return; } } } rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes); if( rowblocksperstrip == 0 ) rowblocksperstrip = 1; rowsperstrip = rowblocksperstrip * rowblock; stripbytes = rowblocksperstrip * rowblockbytes; assert( stripbytes <= 0x7FFFFFFFUL ); nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip); if( nstrips == 0 ) return; if( tif->tif_mode == O_RDONLY && nstrips > 1000000 && <S2SV_StartVul> (td->td_stripoffset[td->td_nstrips-1] > TIFFGetFileSize(tif) || <S2SV_EndVul> <S2SV_StartVul> td->td_stripoffset[td->td_nstrips-1] + <S2SV_EndVul> <S2SV_StartVul> td->td_stripbytecount[td->td_nstrips-1] > TIFFGetFileSize(tif)) ) <S2SV_EndVul> { return; } allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip); }","- if( td->td_stripbytecount[0] == 0 && tif->tif_mode != O_RDONLY )
- if( td->td_stripbytecount[i] < TIFFVStripSize64(
- if( td->td_stripbytecount[i] != stripsize )
- if( i > 0 && td->td_stripoffset[i] !=
- td->td_stripoffset[i-1] + td->td_stripbytecount[i - 1] )
- (td->td_stripoffset[td->td_nstrips-1] > TIFFGetFileSize(tif) ||
- td->td_stripoffset[td->td_nstrips-1] +
- td->td_stripbytecount[td->td_nstrips-1] > TIFFGetFileSize(tif)) )
+ if( TIFFGetStrileByteCount(tif, 0) == 0 && tif->tif_mode != O_RDONLY )
+ if( TIFFGetStrileByteCount(tif, i) < TIFFVStripSize64(
+ if( TIFFGetStrileByteCount(tif, i) != stripsize )
+ if( i > 0 && TIFFGetStrileOffset(tif, i) !=
+ TIFFGetStrileOffset(tif, i-1) + TIFFGetStrileByteCount(tif, i-1) )
+ (TIFFGetStrileOffset(tif, td->td_nstrips-1) > TIFFGetFileSize(tif) ||
+ TIFFGetStrileOffset(tif, td->td_nstrips-1) +
+ TIFFGetStrileByteCount(tif, td->td_nstrips-1) > TIFFGetFileSize(tif)) )","static void TryChopUpUncompressedBigTiff( TIFF* tif ) { TIFFDirectory *td = &tif->tif_dir; uint32 rowblock; uint64 rowblockbytes; uint32 i; uint64 stripsize; uint32 rowblocksperstrip; uint32 rowsperstrip; uint64 stripbytes; uint32 nstrips; stripsize = TIFFStripSize64(tif); assert( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG ); assert( tif->tif_dir.td_compression == COMPRESSION_NONE ); assert( (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP ); assert( stripsize > 0x7FFFFFFFUL ); if( TIFFGetStrileByteCount(tif, 0) == 0 && tif->tif_mode != O_RDONLY ) return; if ((td->td_photometric == PHOTOMETRIC_YCBCR)&& (!isUpSampled(tif))) rowblock = td->td_ycbcrsubsampling[1]; else rowblock = 1; rowblockbytes = TIFFVStripSize64(tif, rowblock); if( rowblockbytes == 0 || rowblockbytes > 0x7FFFFFFFUL ) { return; } for( i = 0; i < td->td_nstrips; i++ ) { if( i == td->td_nstrips - 1 ) { if( TIFFGetStrileByteCount(tif, i) < TIFFVStripSize64( tif, td->td_imagelength - i * td->td_rowsperstrip ) ) { return; } } else { if( TIFFGetStrileByteCount(tif, i) != stripsize ) { return; } if( i > 0 && TIFFGetStrileOffset(tif, i) != TIFFGetStrileOffset(tif, i-1) + TIFFGetStrileByteCount(tif, i-1) ) { return; } } } rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes); if( rowblocksperstrip == 0 ) rowblocksperstrip = 1; rowsperstrip = rowblocksperstrip * rowblock; stripbytes = rowblocksperstrip * rowblockbytes; assert( stripbytes <= 0x7FFFFFFFUL ); nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip); if( nstrips == 0 ) return; if( tif->tif_mode == O_RDONLY && nstrips > 1000000 && (TIFFGetStrileOffset(tif, td->td_nstrips-1) > TIFFGetFileSize(tif) || TIFFGetStrileOffset(tif, td->td_nstrips-1) + TIFFGetStrileByteCount(tif, td->td_nstrips-1) > TIFFGetFileSize(tif)) ) { return; } allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip); }"
10656----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0de840379dbfb8592694c462f4f1aad9dc3e221f_1.json----ec_scalar_mul_ladder,"<S2SV_StartVul> static <S2SV_EndVul> int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar, const EC_POINT *point, BN_CTX *ctx) { int i, cardinality_bits, group_top, kbit, pbit, Z_is_one; EC_POINT *p = NULL; EC_POINT *s = NULL; BIGNUM *k = NULL; BIGNUM *lambda = NULL; BIGNUM *cardinality = NULL; <S2SV_StartVul> BN_CTX *new_ctx = NULL; <S2SV_EndVul> int ret = 0; if (point != NULL && EC_POINT_is_at_infinity(group, point)) return EC_POINT_set_to_infinity(group, r); <S2SV_StartVul> if (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL) <S2SV_EndVul> return 0; BN_CTX_start(ctx); if (((p = EC_POINT_new(group)) == NULL) || ((s = EC_POINT_new(group)) == NULL)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE); goto err; } if (point == NULL) { if (!EC_POINT_copy(p, group->generator)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB); goto err; } } else { if (!EC_POINT_copy(p, point)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB); goto err; } } EC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME); EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME); EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME); cardinality = BN_CTX_get(ctx); lambda = BN_CTX_get(ctx); k = BN_CTX_get(ctx); if (k == NULL) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE); goto err; } if (!BN_mul(cardinality, group->order, group->cofactor, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } cardinality_bits = BN_num_bits(cardinality); group_top = bn_get_top(cardinality); if ((bn_wexpand(k, group_top + 1) == NULL) || (bn_wexpand(lambda, group_top + 1) == NULL)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } if (!BN_copy(k, scalar)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } BN_set_flags(k, BN_FLG_CONSTTIME); if ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) { if (!BN_nnmod(k, k, cardinality, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } } if (!BN_add(lambda, k, cardinality)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } BN_set_flags(lambda, BN_FLG_CONSTTIME); if (!BN_add(k, lambda, cardinality)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } kbit = BN_is_bit_set(lambda, cardinality_bits); BN_consttime_swap(kbit, k, lambda, group_top + 1); group_top = bn_get_top(group->field); if ((bn_wexpand(s->X, group_top) == NULL) || (bn_wexpand(s->Y, group_top) == NULL) || (bn_wexpand(s->Z, group_top) == NULL) || (bn_wexpand(r->X, group_top) == NULL) || (bn_wexpand(r->Y, group_top) == NULL) || (bn_wexpand(r->Z, group_top) == NULL) || (bn_wexpand(p->X, group_top) == NULL) || (bn_wexpand(p->Y, group_top) == NULL) || (bn_wexpand(p->Z, group_top) == NULL)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } if (!ec_point_blind_coordinates(group, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_POINT_COORDINATES_BLIND_FAILURE); goto err; } if (!ec_point_ladder_pre(group, r, s, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE); goto err; } pbit = 1; #define EC_POINT_CSWAP(c,a,b,w,t) do { \ BN_consttime_swap(c, (a)->X, (b)->X, w); \ BN_consttime_swap(c, (a)->Y, (b)->Y, w); \ BN_consttime_swap(c, (a)->Z, (b)->Z, w); \ t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \ (a)->Z_is_one ^= (t); \ (b)->Z_is_one ^= (t); \ } while(0) for (i = cardinality_bits - 1; i >= 0; i--) { kbit = BN_is_bit_set(k, i) ^ pbit; EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one); if (!ec_point_ladder_step(group, r, s, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE); goto err; } pbit ^= kbit; } EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one); #undef EC_POINT_CSWAP if (!ec_point_ladder_post(group, r, s, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE); goto err; } ret = 1; err: EC_POINT_free(p); EC_POINT_free(s); BN_CTX_end(ctx); <S2SV_StartVul> BN_CTX_free(new_ctx); <S2SV_EndVul> return ret; }","- static
- BN_CTX *new_ctx = NULL;
- if (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL)
- BN_CTX_free(new_ctx);
+ if (BN_is_zero(group->order)) {
+ ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER);
+ }
+ if (BN_is_zero(group->cofactor)) {
+ ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR);
+ return 0;
+ }","int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r, const BIGNUM *scalar, const EC_POINT *point, BN_CTX *ctx) { int i, cardinality_bits, group_top, kbit, pbit, Z_is_one; EC_POINT *p = NULL; EC_POINT *s = NULL; BIGNUM *k = NULL; BIGNUM *lambda = NULL; BIGNUM *cardinality = NULL; int ret = 0; if (point != NULL && EC_POINT_is_at_infinity(group, point)) return EC_POINT_set_to_infinity(group, r); if (BN_is_zero(group->order)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER); return 0; } if (BN_is_zero(group->cofactor)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR); return 0; } BN_CTX_start(ctx); if (((p = EC_POINT_new(group)) == NULL) || ((s = EC_POINT_new(group)) == NULL)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE); goto err; } if (point == NULL) { if (!EC_POINT_copy(p, group->generator)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB); goto err; } } else { if (!EC_POINT_copy(p, point)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB); goto err; } } EC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME); EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME); EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME); cardinality = BN_CTX_get(ctx); lambda = BN_CTX_get(ctx); k = BN_CTX_get(ctx); if (k == NULL) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE); goto err; } if (!BN_mul(cardinality, group->order, group->cofactor, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } cardinality_bits = BN_num_bits(cardinality); group_top = bn_get_top(cardinality); if ((bn_wexpand(k, group_top + 1) == NULL) || (bn_wexpand(lambda, group_top + 1) == NULL)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } if (!BN_copy(k, scalar)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } BN_set_flags(k, BN_FLG_CONSTTIME); if ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) { if (!BN_nnmod(k, k, cardinality, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } } if (!BN_add(lambda, k, cardinality)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } BN_set_flags(lambda, BN_FLG_CONSTTIME); if (!BN_add(k, lambda, cardinality)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } kbit = BN_is_bit_set(lambda, cardinality_bits); BN_consttime_swap(kbit, k, lambda, group_top + 1); group_top = bn_get_top(group->field); if ((bn_wexpand(s->X, group_top) == NULL) || (bn_wexpand(s->Y, group_top) == NULL) || (bn_wexpand(s->Z, group_top) == NULL) || (bn_wexpand(r->X, group_top) == NULL) || (bn_wexpand(r->Y, group_top) == NULL) || (bn_wexpand(r->Z, group_top) == NULL) || (bn_wexpand(p->X, group_top) == NULL) || (bn_wexpand(p->Y, group_top) == NULL) || (bn_wexpand(p->Z, group_top) == NULL)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB); goto err; } if (!ec_point_blind_coordinates(group, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_POINT_COORDINATES_BLIND_FAILURE); goto err; } if (!ec_point_ladder_pre(group, r, s, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE); goto err; } pbit = 1; #define EC_POINT_CSWAP(c,a,b,w,t) do { \ BN_consttime_swap(c, (a)->X, (b)->X, w); \ BN_consttime_swap(c, (a)->Y, (b)->Y, w); \ BN_consttime_swap(c, (a)->Z, (b)->Z, w); \ t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \ (a)->Z_is_one ^= (t); \ (b)->Z_is_one ^= (t); \ } while(0) for (i = cardinality_bits - 1; i >= 0; i--) { kbit = BN_is_bit_set(k, i) ^ pbit; EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one); if (!ec_point_ladder_step(group, r, s, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE); goto err; } pbit ^= kbit; } EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one); #undef EC_POINT_CSWAP if (!ec_point_ladder_post(group, r, s, p, ctx)) { ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE); goto err; } ret = 1; err: EC_POINT_free(p); EC_POINT_free(s); BN_CTX_end(ctx); return ret; }"
5326----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1612cfa9a598d8f3bd2a3e29f7e6d0bad32752c4_1.json----svq3_decode_end,static int svq3_decode_end(AVCodecContext *avctx) { <S2SV_StartVul> SVQ3Context *svq3 = avctx->priv_data; <S2SV_EndVul> <S2SV_StartVul> H264Context *h = &svq3->h; <S2SV_EndVul> <S2SV_StartVul> MpegEncContext *s = &h->s; <S2SV_EndVul> <S2SV_StartVul> ff_h264_free_context(h); <S2SV_EndVul> <S2SV_StartVul> ff_MPV_common_end(s); <S2SV_EndVul> return 0; },"- SVQ3Context *svq3 = avctx->priv_data;
- H264Context *h = &svq3->h;
- MpegEncContext *s = &h->s;
- ff_h264_free_context(h);
- ff_MPV_common_end(s);
+ SVQ3Context *s = avctx->priv_data;
+ H264Context *h = &s->h;
+ free_picture(avctx, s->cur_pic);
+ free_picture(avctx, s->next_pic);
+ free_picture(avctx, s->last_pic);
+ ff_h264_free_context(h);","static int svq3_decode_end(AVCodecContext *avctx) { SVQ3Context *s = avctx->priv_data; H264Context *h = &s->h; free_picture(avctx, s->cur_pic); free_picture(avctx, s->next_pic); free_picture(avctx, s->last_pic); ff_h264_free_context(h); return 0; }"
4467----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f1ffdda6fe17c266c75a1b433d27874745eb9463_1.json----filter_frame,"static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *buf) { AVFilterContext *ctx = inlink->dst; AlphaMergeContext *merge = ctx->priv; int is_alpha = (inlink == ctx->inputs[1]); struct FFBufQueue *queue = (is_alpha ? &merge->queue_alpha : &merge->queue_main); ff_bufqueue_add(ctx, queue, buf); while (1) { AVFilterBufferRef *main_buf, *alpha_buf; if (!ff_bufqueue_peek(&merge->queue_main, 0) || !ff_bufqueue_peek(&merge->queue_alpha, 0)) break; main_buf = ff_bufqueue_get(&merge->queue_main); alpha_buf = ff_bufqueue_get(&merge->queue_alpha); merge->frame_requested = 0; draw_frame(ctx, main_buf, alpha_buf); <S2SV_StartVul> ff_filter_frame(ctx->outputs[0], avfilter_ref_buffer(main_buf, ~0)); <S2SV_EndVul> avfilter_unref_buffer(alpha_buf); } return 0; }","- ff_filter_frame(ctx->outputs[0], avfilter_ref_buffer(main_buf, ~0));
+ ff_filter_frame(ctx->outputs[0], main_buf);","static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *buf) { AVFilterContext *ctx = inlink->dst; AlphaMergeContext *merge = ctx->priv; int is_alpha = (inlink == ctx->inputs[1]); struct FFBufQueue *queue = (is_alpha ? &merge->queue_alpha : &merge->queue_main); ff_bufqueue_add(ctx, queue, buf); while (1) { AVFilterBufferRef *main_buf, *alpha_buf; if (!ff_bufqueue_peek(&merge->queue_main, 0) || !ff_bufqueue_peek(&merge->queue_alpha, 0)) break; main_buf = ff_bufqueue_get(&merge->queue_main); alpha_buf = ff_bufqueue_get(&merge->queue_alpha); merge->frame_requested = 0; draw_frame(ctx, main_buf, alpha_buf); ff_filter_frame(ctx->outputs[0], main_buf); avfilter_unref_buffer(alpha_buf); } return 0; }"
3928----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d34aa4d25452c55751ac9affd6f6add3b74d0654_1.json----ff_riff_write_info_tag,"void ff_riff_write_info_tag(AVIOContext *pb, const char *tag, const char *str) { <S2SV_StartVul> int len = strlen(str); <S2SV_EndVul> <S2SV_StartVul> if (len > 0) { <S2SV_EndVul> len++; ffio_wfourcc(pb, tag); avio_wl32(pb, len); avio_put_str(pb, str); if (len & 1) avio_w8(pb, 0); } }","- int len = strlen(str);
- if (len > 0) {
+ size_t len = strlen(str);
+ if (len > 0 && len < UINT32_MAX) {","void ff_riff_write_info_tag(AVIOContext *pb, const char *tag, const char *str) { size_t len = strlen(str); if (len > 0 && len < UINT32_MAX) { len++; ffio_wfourcc(pb, tag); avio_wl32(pb, len); avio_put_str(pb, str); if (len & 1) avio_w8(pb, 0); } }"
6477----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5bdac01f9e24b0d4f53250a3f9baba6813be2f1e_1.json----vorbis_parse_setup_hdr_floors,"static int vorbis_parse_setup_hdr_floors(vorbis_context *vc) { GetBitContext *gb = &vc->gb; int i,j,k; vc->floor_count = get_bits(gb, 6) + 1; vc->floors = av_mallocz(vc->floor_count * sizeof(*vc->floors)); for (i = 0; i < vc->floor_count; ++i) { vorbis_floor *floor_setup = &vc->floors[i]; floor_setup->floor_type = get_bits(gb, 16); AV_DEBUG("" %d. floor type %d \n"", i, floor_setup->floor_type); if (floor_setup->floor_type == 1) { int maximum_class = -1; <S2SV_StartVul> uint_fast8_t rangebits; <S2SV_EndVul> <S2SV_StartVul> uint_fast32_t rangemax; <S2SV_EndVul> <S2SV_StartVul> uint_fast16_t floor1_values = 2; <S2SV_EndVul> floor_setup->decode = vorbis_floor1_decode; floor_setup->data.t1.partitions = get_bits(gb, 5); AV_DEBUG("" %d.floor: %d partitions \n"", i, floor_setup->data.t1.partitions); for (j = 0; j < floor_setup->data.t1.partitions; ++j) { floor_setup->data.t1.partition_class[j] = get_bits(gb, 4); if (floor_setup->data.t1.partition_class[j] > maximum_class) maximum_class = floor_setup->data.t1.partition_class[j]; AV_DEBUG("" %d. floor %d partition class %d \n"", i, j, floor_setup->data.t1.partition_class[j]); } AV_DEBUG("" maximum class %d \n"", maximum_class); for (j = 0; j <= maximum_class; ++j) { floor_setup->data.t1.class_dimensions[j] = get_bits(gb, 3) + 1; floor_setup->data.t1.class_subclasses[j] = get_bits(gb, 2); AV_DEBUG("" %d floor %d class dim: %d subclasses %d \n"", i, j, floor_setup->data.t1.class_dimensions[j], floor_setup->data.t1.class_subclasses[j]); if (floor_setup->data.t1.class_subclasses[j]) { GET_VALIDATED_INDEX(floor_setup->data.t1.class_masterbook[j], 8, vc->codebook_count) AV_DEBUG("" masterbook: %d \n"", floor_setup->data.t1.class_masterbook[j]); } for (k = 0; k < (1 << floor_setup->data.t1.class_subclasses[j]); ++k) { int16_t bits = get_bits(gb, 8) - 1; if (bits != -1) VALIDATE_INDEX(bits, vc->codebook_count) floor_setup->data.t1.subclass_books[j][k] = bits; AV_DEBUG("" book %d. : %d \n"", k, floor_setup->data.t1.subclass_books[j][k]); } } floor_setup->data.t1.multiplier = get_bits(gb, 2) + 1; floor_setup->data.t1.x_list_dim = 2; for (j = 0; j < floor_setup->data.t1.partitions; ++j) floor_setup->data.t1.x_list_dim+=floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; floor_setup->data.t1.list = av_mallocz(floor_setup->data.t1.x_list_dim * sizeof(*floor_setup->data.t1.list)); rangebits = get_bits(gb, 4); rangemax = (1 << rangebits); if (rangemax > vc->blocksize[1] / 2) { av_log(vc->avccontext, AV_LOG_ERROR, <S2SV_StartVul> ""Floor value is too large for blocksize: %""PRIuFAST32"" (%""PRIuFAST32"")\n"", <S2SV_EndVul> rangemax, vc->blocksize[1] / 2); return -1; } floor_setup->data.t1.list[0].x = 0; floor_setup->data.t1.list[1].x = rangemax; for (j = 0; j < floor_setup->data.t1.partitions; ++j) { for (k = 0; k < floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; ++k, ++floor1_values) { floor_setup->data.t1.list[floor1_values].x = get_bits(gb, rangebits); <S2SV_StartVul> AV_DEBUG("" %d. floor1 Y coord. %d \n"", floor1_values, floor_setup->data.t1.list[floor1_values].x); <S2SV_EndVul> } } ff_vorbis_ready_floor1_list(floor_setup->data.t1.list, floor_setup->data.t1.x_list_dim); } else if (floor_setup->floor_type == 0) { <S2SV_StartVul> uint_fast8_t max_codebook_dim = 0; <S2SV_EndVul> floor_setup->decode = vorbis_floor0_decode; floor_setup->data.t0.order = get_bits(gb, 8); floor_setup->data.t0.rate = get_bits(gb, 16); floor_setup->data.t0.bark_map_size = get_bits(gb, 16); floor_setup->data.t0.amplitude_bits = get_bits(gb, 6); if (floor_setup->data.t0.amplitude_bits == 0) { av_log(vc->avccontext, AV_LOG_ERROR, ""Floor 0 amplitude bits is 0.\n""); return -1; } floor_setup->data.t0.amplitude_offset = get_bits(gb, 8); floor_setup->data.t0.num_books = get_bits(gb, 4) + 1; floor_setup->data.t0.book_list = av_malloc(floor_setup->data.t0.num_books); if (!floor_setup->data.t0.book_list) return -1; { int idx; <S2SV_StartVul> uint_fast8_t book_idx; <S2SV_EndVul> for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) { GET_VALIDATED_INDEX(book_idx, 8, vc->codebook_count) floor_setup->data.t0.book_list[idx] = book_idx; if (vc->codebooks[book_idx].dimensions > max_codebook_dim) max_codebook_dim = vc->codebooks[book_idx].dimensions; } } create_map(vc, i); floor_setup->data.t0.lsp = av_malloc((floor_setup->data.t0.order + 1 + max_codebook_dim) * sizeof(*floor_setup->data.t0.lsp)); if (!floor_setup->data.t0.lsp) return -1; #ifdef V_DEBUG AV_DEBUG(""floor0 order: %u\n"", floor_setup->data.t0.order); AV_DEBUG(""floor0 rate: %u\n"", floor_setup->data.t0.rate); AV_DEBUG(""floor0 bark map size: %u\n"", floor_setup->data.t0.bark_map_size); AV_DEBUG(""floor0 amplitude bits: %u\n"", floor_setup->data.t0.amplitude_bits); AV_DEBUG(""floor0 amplitude offset: %u\n"", floor_setup->data.t0.amplitude_offset); AV_DEBUG(""floor0 number of books: %u\n"", floor_setup->data.t0.num_books); AV_DEBUG(""floor0 book list pointer: %p\n"", floor_setup->data.t0.book_list); { int idx; for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) { AV_DEBUG("" Book %d: %u\n"", idx+1, floor_setup->data.t0.book_list[idx]); } } #endif } else { av_log(vc->avccontext, AV_LOG_ERROR, ""Invalid floor type!\n""); return -1; } } return 0; }","- uint_fast8_t rangebits;
- uint_fast32_t rangemax;
- uint_fast16_t floor1_values = 2;
- ""Floor value is too large for blocksize: %""PRIuFAST32"" (%""PRIuFAST32"")\n"",
- AV_DEBUG("" %d. floor1 Y coord. %d \n"", floor1_values, floor_setup->data.t1.list[floor1_values].x);
- uint_fast8_t max_codebook_dim = 0;
- uint_fast8_t book_idx;
+ unsigned rangebits, rangemax, floor1_values = 2;
+ ""Floor value is too large for blocksize: %u (%""PRIuFAST32"")\n"",
+ AV_DEBUG("" %u. floor1 Y coord. %d\n"", floor1_values,
+ floor_setup->data.t1.list[floor1_values].x);
+ unsigned max_codebook_dim = 0;
+ unsigned book_idx;","static int vorbis_parse_setup_hdr_floors(vorbis_context *vc) { GetBitContext *gb = &vc->gb; int i,j,k; vc->floor_count = get_bits(gb, 6) + 1; vc->floors = av_mallocz(vc->floor_count * sizeof(*vc->floors)); for (i = 0; i < vc->floor_count; ++i) { vorbis_floor *floor_setup = &vc->floors[i]; floor_setup->floor_type = get_bits(gb, 16); AV_DEBUG("" %d. floor type %d \n"", i, floor_setup->floor_type); if (floor_setup->floor_type == 1) { int maximum_class = -1; unsigned rangebits, rangemax, floor1_values = 2; floor_setup->decode = vorbis_floor1_decode; floor_setup->data.t1.partitions = get_bits(gb, 5); AV_DEBUG("" %d.floor: %d partitions \n"", i, floor_setup->data.t1.partitions); for (j = 0; j < floor_setup->data.t1.partitions; ++j) { floor_setup->data.t1.partition_class[j] = get_bits(gb, 4); if (floor_setup->data.t1.partition_class[j] > maximum_class) maximum_class = floor_setup->data.t1.partition_class[j]; AV_DEBUG("" %d. floor %d partition class %d \n"", i, j, floor_setup->data.t1.partition_class[j]); } AV_DEBUG("" maximum class %d \n"", maximum_class); for (j = 0; j <= maximum_class; ++j) { floor_setup->data.t1.class_dimensions[j] = get_bits(gb, 3) + 1; floor_setup->data.t1.class_subclasses[j] = get_bits(gb, 2); AV_DEBUG("" %d floor %d class dim: %d subclasses %d \n"", i, j, floor_setup->data.t1.class_dimensions[j], floor_setup->data.t1.class_subclasses[j]); if (floor_setup->data.t1.class_subclasses[j]) { GET_VALIDATED_INDEX(floor_setup->data.t1.class_masterbook[j], 8, vc->codebook_count) AV_DEBUG("" masterbook: %d \n"", floor_setup->data.t1.class_masterbook[j]); } for (k = 0; k < (1 << floor_setup->data.t1.class_subclasses[j]); ++k) { int16_t bits = get_bits(gb, 8) - 1; if (bits != -1) VALIDATE_INDEX(bits, vc->codebook_count) floor_setup->data.t1.subclass_books[j][k] = bits; AV_DEBUG("" book %d. : %d \n"", k, floor_setup->data.t1.subclass_books[j][k]); } } floor_setup->data.t1.multiplier = get_bits(gb, 2) + 1; floor_setup->data.t1.x_list_dim = 2; for (j = 0; j < floor_setup->data.t1.partitions; ++j) floor_setup->data.t1.x_list_dim+=floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; floor_setup->data.t1.list = av_mallocz(floor_setup->data.t1.x_list_dim * sizeof(*floor_setup->data.t1.list)); rangebits = get_bits(gb, 4); rangemax = (1 << rangebits); if (rangemax > vc->blocksize[1] / 2) { av_log(vc->avccontext, AV_LOG_ERROR, ""Floor value is too large for blocksize: %u (%""PRIuFAST32"")\n"", rangemax, vc->blocksize[1] / 2); return -1; } floor_setup->data.t1.list[0].x = 0; floor_setup->data.t1.list[1].x = rangemax; for (j = 0; j < floor_setup->data.t1.partitions; ++j) { for (k = 0; k < floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; ++k, ++floor1_values) { floor_setup->data.t1.list[floor1_values].x = get_bits(gb, rangebits); AV_DEBUG("" %u. floor1 Y coord. %d\n"", floor1_values, floor_setup->data.t1.list[floor1_values].x); } } ff_vorbis_ready_floor1_list(floor_setup->data.t1.list, floor_setup->data.t1.x_list_dim); } else if (floor_setup->floor_type == 0) { unsigned max_codebook_dim = 0; floor_setup->decode = vorbis_floor0_decode; floor_setup->data.t0.order = get_bits(gb, 8); floor_setup->data.t0.rate = get_bits(gb, 16); floor_setup->data.t0.bark_map_size = get_bits(gb, 16); floor_setup->data.t0.amplitude_bits = get_bits(gb, 6); if (floor_setup->data.t0.amplitude_bits == 0) { av_log(vc->avccontext, AV_LOG_ERROR, ""Floor 0 amplitude bits is 0.\n""); return -1; } floor_setup->data.t0.amplitude_offset = get_bits(gb, 8); floor_setup->data.t0.num_books = get_bits(gb, 4) + 1; floor_setup->data.t0.book_list = av_malloc(floor_setup->data.t0.num_books); if (!floor_setup->data.t0.book_list) return -1; { int idx; unsigned book_idx; for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) { GET_VALIDATED_INDEX(book_idx, 8, vc->codebook_count) floor_setup->data.t0.book_list[idx] = book_idx; if (vc->codebooks[book_idx].dimensions > max_codebook_dim) max_codebook_dim = vc->codebooks[book_idx].dimensions; } } create_map(vc, i); floor_setup->data.t0.lsp = av_malloc((floor_setup->data.t0.order + 1 + max_codebook_dim) * sizeof(*floor_setup->data.t0.lsp)); if (!floor_setup->data.t0.lsp) return -1; #ifdef V_DEBUG AV_DEBUG(""floor0 order: %u\n"", floor_setup->data.t0.order); AV_DEBUG(""floor0 rate: %u\n"", floor_setup->data.t0.rate); AV_DEBUG(""floor0 bark map size: %u\n"", floor_setup->data.t0.bark_map_size); AV_DEBUG(""floor0 amplitude bits: %u\n"", floor_setup->data.t0.amplitude_bits); AV_DEBUG(""floor0 amplitude offset: %u\n"", floor_setup->data.t0.amplitude_offset); AV_DEBUG(""floor0 number of books: %u\n"", floor_setup->data.t0.num_books); AV_DEBUG(""floor0 book list pointer: %p\n"", floor_setup->data.t0.book_list); { int idx; for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) { AV_DEBUG("" Book %d: %u\n"", idx+1, floor_setup->data.t0.book_list[idx]); } } #endif } else { av_log(vc->avccontext, AV_LOG_ERROR, ""Invalid floor type!\n""); return -1; } } return 0; }"
13897----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7f1040cbd920621e77ef0f4a95e9e266171741fa_1.json----test_PACKET_get_net_3,"<S2SV_StartVul> static int test_PACKET_get_net_3(unsigned char buf[BUF_LEN]) <S2SV_EndVul> { unsigned long i; PACKET pkt; <S2SV_StartVul> if ( !PACKET_buf_init(&pkt, buf, BUF_LEN) <S2SV_EndVul> <S2SV_StartVul> || !PACKET_get_net_3(&pkt, &i) <S2SV_EndVul> <S2SV_StartVul> || i != 0x020406UL <S2SV_EndVul> <S2SV_StartVul> || !PACKET_forward(&pkt, BUF_LEN - 6) <S2SV_EndVul> <S2SV_StartVul> || !PACKET_get_net_3(&pkt, &i) <S2SV_EndVul> <S2SV_StartVul> || i != 0xfafcfeUL <S2SV_EndVul> <S2SV_StartVul> || PACKET_get_net_3(&pkt, &i)) { <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""test_PACKET_get_net_3() failed\n""); <S2SV_EndVul> return 0; <S2SV_StartVul> } <S2SV_EndVul> return 1; }","- static int test_PACKET_get_net_3(unsigned char buf[BUF_LEN])
- if ( !PACKET_buf_init(&pkt, buf, BUF_LEN)
- || !PACKET_get_net_3(&pkt, &i)
- || i != 0x020406UL
- || !PACKET_forward(&pkt, BUF_LEN - 6)
- || !PACKET_get_net_3(&pkt, &i)
- || i != 0xfafcfeUL
- || PACKET_get_net_3(&pkt, &i)) {
- fprintf(stderr, ""test_PACKET_get_net_3() failed\n"");
- }
+ static int test_PACKET_get_net_3()
+ if (!TEST_true(PACKET_buf_init(&pkt, smbuf, BUF_LEN))
+ || !TEST_true(PACKET_get_net_3(&pkt, &i))
+ || !TEST_ulong_eq(i, 0x020406UL)
+ || !TEST_true(PACKET_forward(&pkt, BUF_LEN - 6))
+ || !TEST_true(PACKET_get_net_3(&pkt, &i))
+ || !TEST_ulong_eq(i, 0xfafcfeUL)
+ || !TEST_false(PACKET_get_net_3(&pkt, &i)))","static int test_PACKET_get_net_3() { unsigned long i; PACKET pkt; if (!TEST_true(PACKET_buf_init(&pkt, smbuf, BUF_LEN)) || !TEST_true(PACKET_get_net_3(&pkt, &i)) || !TEST_ulong_eq(i, 0x020406UL) || !TEST_true(PACKET_forward(&pkt, BUF_LEN - 6)) || !TEST_true(PACKET_get_net_3(&pkt, &i)) || !TEST_ulong_eq(i, 0xfafcfeUL) || !TEST_false(PACKET_get_net_3(&pkt, &i))) return 0; return 1; }"
10298----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_014eec82366e16b0cc2a769590ca53ad868b986b_1.json----X509_STORE_new,"X509_STORE *X509_STORE_new(void) { X509_STORE *ret; if ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL) return(NULL); <S2SV_StartVul> ret->certs=lh_new(x509_object_hash,x509_object_cmp); <S2SV_EndVul> ret->cache=1; ret->get_cert_methods=sk_X509_LOOKUP_new_null(); ret->verify=NULL; ret->verify_cb=NULL; memset(&ret->ex_data,0,sizeof(CRYPTO_EX_DATA)); ret->references=1; ret->depth=0; return(ret); }","- ret->certs=lh_new(x509_object_hash,x509_object_cmp);
+ ret->objs = sk_X509_OBJECT_new(x509_object_cmp);","X509_STORE *X509_STORE_new(void) { X509_STORE *ret; if ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL) return(NULL); ret->objs = sk_X509_OBJECT_new(x509_object_cmp); ret->cache=1; ret->get_cert_methods=sk_X509_LOOKUP_new_null(); ret->verify=NULL; ret->verify_cb=NULL; memset(&ret->ex_data,0,sizeof(CRYPTO_EX_DATA)); ret->references=1; ret->depth=0; return(ret); }"
1722----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5fc0de8b138e8601671930a55393be2887cfccaa_1.json----vp8_mc_luma,"static av_always_inline void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst, ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off, int block_w, int block_h, <S2SV_StartVul> int width, int height, int linesize, <S2SV_EndVul> vp8_mc_func mc_func[3][3]) { uint8_t *src = ref->f->data[0]; if (AV_RN32A(mv)) { int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx]; int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my]; x_off += mv->x >> 2; y_off += mv->y >> 2; ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0); src += y_off * linesize + x_off; if (x_off < mx_idx || x_off >= width - block_w - subpel_idx[2][mx] || y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) { s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize, block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my], x_off - mx_idx, y_off - my_idx, width, height); src = td->edge_emu_buffer + mx_idx + linesize * my_idx; } mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my); } else { ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0); mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0); } }","- int width, int height, int linesize,
+ int width, int height, ptrdiff_t linesize,","static av_always_inline void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst, ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off, int block_w, int block_h, int width, int height, ptrdiff_t linesize, vp8_mc_func mc_func[3][3]) { uint8_t *src = ref->f->data[0]; if (AV_RN32A(mv)) { int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx]; int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my]; x_off += mv->x >> 2; y_off += mv->y >> 2; ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0); src += y_off * linesize + x_off; if (x_off < mx_idx || x_off >= width - block_w - subpel_idx[2][mx] || y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) { s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize, block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my], x_off - mx_idx, y_off - my_idx, width, height); src = td->edge_emu_buffer + mx_idx + linesize * my_idx; } mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my); } else { ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0); mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0); } }"
11331----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_270585c9ba35b54bd54ef547bd400f5d0e69805e_1.json----rand_pool_new,"<S2SV_StartVul> RAND_POOL *rand_pool_new(int entropy, size_t min_len, size_t max_len) <S2SV_EndVul> { RAND_POOL *pool = OPENSSL_zalloc(sizeof(*pool)); if (pool == NULL) { RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE); <S2SV_StartVul> goto err; <S2SV_EndVul> } pool->min_len = min_len; <S2SV_StartVul> pool->max_len = max_len; <S2SV_EndVul> pool->buffer = OPENSSL_secure_zalloc(pool->max_len); if (pool->buffer == NULL) { RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE); goto err; } <S2SV_StartVul> pool->requested_entropy = entropy; <S2SV_EndVul> return pool; err: OPENSSL_free(pool); return NULL; }","- RAND_POOL *rand_pool_new(int entropy, size_t min_len, size_t max_len)
- goto err;
- pool->max_len = max_len;
- pool->requested_entropy = entropy;
+ RAND_POOL *rand_pool_new(int entropy_requested, size_t min_len, size_t max_len)
+ return NULL;
+ pool->max_len = (max_len > RAND_POOL_MAX_LENGTH) ?
+ RAND_POOL_MAX_LENGTH : max_len;
+ pool->entropy_requested = entropy_requested;","RAND_POOL *rand_pool_new(int entropy_requested, size_t min_len, size_t max_len) { RAND_POOL *pool = OPENSSL_zalloc(sizeof(*pool)); if (pool == NULL) { RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE); return NULL; } pool->min_len = min_len; pool->max_len = (max_len > RAND_POOL_MAX_LENGTH) ? RAND_POOL_MAX_LENGTH : max_len; pool->buffer = OPENSSL_secure_zalloc(pool->max_len); if (pool->buffer == NULL) { RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE); goto err; } pool->entropy_requested = entropy_requested; return pool; err: OPENSSL_free(pool); return NULL; }"
483----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b58d326672e7923df49a060697cf5ed471dcb0c_1.json----av_get_packet,"int av_get_packet(AVIOContext *s, AVPacket *pkt, int size) { <S2SV_StartVul> int ret= av_new_packet(pkt, size); <S2SV_EndVul> if(ret<0) return ret; pkt->pos= avio_tell(s); ret= avio_read(s, pkt->data, size); if(ret<=0) av_free_packet(pkt); else av_shrink_packet(pkt, ret); return ret; }","- int ret= av_new_packet(pkt, size);
+ int ret;
+ if(s->maxsize>0){
+ int64_t remaining= s->maxsize - avio_tell(s);
+ if(remaining>=0)
+ size= FFMIN(size, remaining);
+ }
+ ret= av_new_packet(pkt, size);","int av_get_packet(AVIOContext *s, AVPacket *pkt, int size) { int ret; if(s->maxsize>0){ int64_t remaining= s->maxsize - avio_tell(s); if(remaining>=0) size= FFMIN(size, remaining); } ret= av_new_packet(pkt, size); if(ret<0) return ret; pkt->pos= avio_tell(s); ret= avio_read(s, pkt->data, size); if(ret<=0) av_free_packet(pkt); else av_shrink_packet(pkt, ret); return ret; }"
131----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_081bf85e2aa98cf6d20cd64b16e8b853c2da63ef_1.json----hl_decode_mb_internal,"static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){ MpegEncContext * const s = &h->s; const int mb_x= s->mb_x; const int mb_y= s->mb_y; const int mb_xy= h->mb_xy; const int mb_type= s->current_picture.mb_type[mb_xy]; uint8_t *dest_y, *dest_cb, *dest_cr; int linesize, uvlinesize ; int i; int *block_offset = &h->block_offset[0]; const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass); const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264; void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride); void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride); dest_y = s->current_picture.data[0] + (mb_x + mb_y * s->linesize ) * 16; dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8; dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8; s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4); s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2); if (!simple && MB_FIELD) { linesize = h->mb_linesize = s->linesize * 2; uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2; block_offset = &h->block_offset[24]; if(mb_y&1){ dest_y -= s->linesize*15; dest_cb-= s->uvlinesize*7; dest_cr-= s->uvlinesize*7; } if(FRAME_MBAFF) { int list; for(list=0; list<h->list_count; list++){ if(!USES_LIST(mb_type, list)) continue; if(IS_16X16(mb_type)){ int8_t *ref = &h->ref_cache[list][scan8[0]]; fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1); }else{ for(i=0; i<16; i+=4){ int ref = h->ref_cache[list][scan8[i]]; if(ref >= 0) fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1); } } } } } else { linesize = h->mb_linesize = s->linesize; uvlinesize = h->mb_uvlinesize = s->uvlinesize; } if (!simple && IS_INTRA_PCM(mb_type)) { for (i=0; i<16; i++) { memcpy(dest_y + i* linesize, h->mb + i*8, 16); } for (i=0; i<8; i++) { memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4, 8); memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4, 8); } } else { if(IS_INTRA(mb_type)){ if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple); if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize); h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize); } if(IS_INTRA4x4(mb_type)){ if(simple || !s->encoding){ if(IS_8x8DCT(mb_type)){ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels8; }else{ idct_dc_add = s->dsp.h264_idct8_dc_add; idct_add = s->dsp.h264_idct8_add; } for(i=0; i<16; i+=4){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize); }else{ const int nnz = h->non_zero_count_cache[ scan8[i] ]; h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000, (h->topright_samples_available<<i)&0x4000, linesize); if(nnz){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); } } } }else{ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels4; }else{ idct_dc_add = s->dsp.h264_idct_dc_add; idct_add = s->dsp.h264_idct_add; } for(i=0; i<16; i++){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize); }else{ uint8_t *topright; int nnz, tr; if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){ const int topright_avail= (h->topright_samples_available<<i)&0x8000; assert(mb_y || linesize <= block_offset[i]); if(!topright_avail){ tr= ptr[3 - linesize]*0x01010101; topright= (uint8_t*) &tr; }else topright= ptr + 4 - linesize; }else topright= NULL; h->hpc.pred4x4[ dir ](ptr, topright, linesize); nnz = h->non_zero_count_cache[ scan8[i] ]; if(nnz){ if(is_h264){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); }else svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0); } } } } } }else{ h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize); if(is_h264){ if(!transform_bypass) h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]); }else svq3_luma_dc_dequant_idct_c(h->mb, s->qscale); } if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple); }else if(is_h264){ hl_motion(h, dest_y, dest_cb, dest_cr, s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab, s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab, s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab); } if(!IS_INTRA4x4(mb_type)){ if(is_h264){ if(IS_INTRA16x16(mb_type)){ if(transform_bypass){ if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){ h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize); }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } }else if(h->cbp&15){ if(transform_bypass){ const int di = IS_8x8DCT(mb_type) ? 4 : 1; idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4; for(i=0; i<16; i+=di){ if(h->non_zero_count_cache[ scan8[i] ]){ idct_add(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ if(IS_8x8DCT(mb_type)){ s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); }else{ s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } } } }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest_y + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0); } } } } if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){ uint8_t *dest[2] = {dest_cb, dest_cr}; if(transform_bypass){ if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){ h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize); h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize); }else{ idct_add = s->dsp.add_pixels4; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } } }else{ chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]); chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]); if(is_h264){ idct_add = s->dsp.h264_idct_add; idct_dc_add = s->dsp.h264_idct_dc_add; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); else if(h->mb[i*16]) idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } }else{ for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, ff_h264_chroma_qp[s->qscale + 12] - 12, 2); } } } } } } if(h->cbp || IS_INTRA(mb_type)) s->dsp.clear_blocks(h->mb); <S2SV_StartVul> if(h->deblocking_filter) { <S2SV_EndVul> backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple); fill_caches(h, mb_type, 1); h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]); h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]); if (!simple && FRAME_MBAFF) { ff_h264_filter_mb (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); } else { ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); } } }","- if(h->deblocking_filter) {
+ h->list_counts[mb_xy]= h->list_count;
+ if(h->deblocking_filter && 0) {","static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){ MpegEncContext * const s = &h->s; const int mb_x= s->mb_x; const int mb_y= s->mb_y; const int mb_xy= h->mb_xy; const int mb_type= s->current_picture.mb_type[mb_xy]; uint8_t *dest_y, *dest_cb, *dest_cr; int linesize, uvlinesize ; int i; int *block_offset = &h->block_offset[0]; const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass); const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264; void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride); void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride); dest_y = s->current_picture.data[0] + (mb_x + mb_y * s->linesize ) * 16; dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8; dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8; s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4); s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2); h->list_counts[mb_xy]= h->list_count; if (!simple && MB_FIELD) { linesize = h->mb_linesize = s->linesize * 2; uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2; block_offset = &h->block_offset[24]; if(mb_y&1){ dest_y -= s->linesize*15; dest_cb-= s->uvlinesize*7; dest_cr-= s->uvlinesize*7; } if(FRAME_MBAFF) { int list; for(list=0; list<h->list_count; list++){ if(!USES_LIST(mb_type, list)) continue; if(IS_16X16(mb_type)){ int8_t *ref = &h->ref_cache[list][scan8[0]]; fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1); }else{ for(i=0; i<16; i+=4){ int ref = h->ref_cache[list][scan8[i]]; if(ref >= 0) fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1); } } } } } else { linesize = h->mb_linesize = s->linesize; uvlinesize = h->mb_uvlinesize = s->uvlinesize; } if (!simple && IS_INTRA_PCM(mb_type)) { for (i=0; i<16; i++) { memcpy(dest_y + i* linesize, h->mb + i*8, 16); } for (i=0; i<8; i++) { memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4, 8); memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4, 8); } } else { if(IS_INTRA(mb_type)){ if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple); if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize); h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize); } if(IS_INTRA4x4(mb_type)){ if(simple || !s->encoding){ if(IS_8x8DCT(mb_type)){ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels8; }else{ idct_dc_add = s->dsp.h264_idct8_dc_add; idct_add = s->dsp.h264_idct8_add; } for(i=0; i<16; i+=4){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize); }else{ const int nnz = h->non_zero_count_cache[ scan8[i] ]; h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000, (h->topright_samples_available<<i)&0x4000, linesize); if(nnz){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); } } } }else{ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels4; }else{ idct_dc_add = s->dsp.h264_idct_dc_add; idct_add = s->dsp.h264_idct_add; } for(i=0; i<16; i++){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize); }else{ uint8_t *topright; int nnz, tr; if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){ const int topright_avail= (h->topright_samples_available<<i)&0x8000; assert(mb_y || linesize <= block_offset[i]); if(!topright_avail){ tr= ptr[3 - linesize]*0x01010101; topright= (uint8_t*) &tr; }else topright= ptr + 4 - linesize; }else topright= NULL; h->hpc.pred4x4[ dir ](ptr, topright, linesize); nnz = h->non_zero_count_cache[ scan8[i] ]; if(nnz){ if(is_h264){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); }else svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0); } } } } } }else{ h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize); if(is_h264){ if(!transform_bypass) h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]); }else svq3_luma_dc_dequant_idct_c(h->mb, s->qscale); } if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple); }else if(is_h264){ hl_motion(h, dest_y, dest_cb, dest_cr, s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab, s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab, s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab); } if(!IS_INTRA4x4(mb_type)){ if(is_h264){ if(IS_INTRA16x16(mb_type)){ if(transform_bypass){ if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){ h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize); }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } }else if(h->cbp&15){ if(transform_bypass){ const int di = IS_8x8DCT(mb_type) ? 4 : 1; idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4; for(i=0; i<16; i+=di){ if(h->non_zero_count_cache[ scan8[i] ]){ idct_add(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ if(IS_8x8DCT(mb_type)){ s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); }else{ s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } } } }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest_y + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0); } } } } if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){ uint8_t *dest[2] = {dest_cb, dest_cr}; if(transform_bypass){ if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){ h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize); h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize); }else{ idct_add = s->dsp.add_pixels4; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } } }else{ chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]); chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]); if(is_h264){ idct_add = s->dsp.h264_idct_add; idct_dc_add = s->dsp.h264_idct_dc_add; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); else if(h->mb[i*16]) idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } }else{ for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, ff_h264_chroma_qp[s->qscale + 12] - 12, 2); } } } } } } if(h->cbp || IS_INTRA(mb_type)) s->dsp.clear_blocks(h->mb); if(h->deblocking_filter && 0) { backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple); fill_caches(h, mb_type, 1); h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]); h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]); if (!simple && FRAME_MBAFF) { ff_h264_filter_mb (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); } else { ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); } } }"
8952----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_ed6fa367c058f7bd46244e47fefdcb74e85070bf_1.json----decode,"static void decode(RA288Context *ractx, float gain, int cb_coef) { int x, y; double sumsum; float sum, buffer[5]; memmove(ractx->sb + 5, ractx->sb, 36 * sizeof(*ractx->sb)); for (x=4; x >= 0; x--) ractx->sb[x] = -scalar_product_float(ractx->sb + x + 1, ractx->sp_lpc, 36); sum = 32. - scalar_product_float(ractx->gain_lpc, ractx->lhist, 10); sum = av_clipf(sum, 0, 60); sumsum = exp(sum * 0.1151292546497) * gain; for (x=0; x < 5; x++) buffer[x] = codetable[cb_coef][x] * sumsum; sum = scalar_product_float(buffer, buffer, 5) / 5; sum = FFMAX(sum, 1); memmove(ractx->lhist, ractx->lhist - 1, 10 * sizeof(*ractx->lhist)); *ractx->lhist = 10 * log10(sum) - 32; for (x=1; x < 5; x++) for (y=x-1; y >= 0; y--) buffer[x] -= ractx->sp_lpc[x-y-1] * buffer[y]; for (x=0; x < 5; x++) { <S2SV_StartVul> ractx->output[ractx->phase*5+x] = ractx->sb[4-x] = <S2SV_EndVul> av_clipf(ractx->sb[4-x] + buffer[x], -4095, 4095); } }","- ractx->output[ractx->phase*5+x] = ractx->sb[4-x] =
+ ractx->sb[4-x] =","static void decode(RA288Context *ractx, float gain, int cb_coef) { int x, y; double sumsum; float sum, buffer[5]; memmove(ractx->sb + 5, ractx->sb, 36 * sizeof(*ractx->sb)); for (x=4; x >= 0; x--) ractx->sb[x] = -scalar_product_float(ractx->sb + x + 1, ractx->sp_lpc, 36); sum = 32. - scalar_product_float(ractx->gain_lpc, ractx->lhist, 10); sum = av_clipf(sum, 0, 60); sumsum = exp(sum * 0.1151292546497) * gain; for (x=0; x < 5; x++) buffer[x] = codetable[cb_coef][x] * sumsum; sum = scalar_product_float(buffer, buffer, 5) / 5; sum = FFMAX(sum, 1); memmove(ractx->lhist, ractx->lhist - 1, 10 * sizeof(*ractx->lhist)); *ractx->lhist = 10 * log10(sum) - 32; for (x=1; x < 5; x++) for (y=x-1; y >= 0; y--) buffer[x] -= ractx->sp_lpc[x-y-1] * buffer[y]; for (x=0; x < 5; x++) { ractx->sb[4-x] = av_clipf(ractx->sb[4-x] + buffer[x], -4095, 4095); } }"
1020----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_37488348161af749c086b1b05caebb99b2e88ccd_1.json----ff_convert_matrix,"void ff_convert_matrix(DSPContext *dsp, int (*qmat)[64], uint16_t (*qmat16)[2][64], const uint16_t *quant_matrix, int bias, int qmin, int qmax, int intra) { int qscale; int shift = 0; for (qscale = qmin; qscale <= qmax; qscale++) { int i; if (dsp->fdct == ff_jpeg_fdct_islow_8 || dsp->fdct == ff_jpeg_fdct_islow_10 || dsp->fdct == ff_faandct) { for (i = 0; i < 64; i++) { const int j = dsp->idct_permutation[i]; qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) / (qscale * quant_matrix[j])); } } else if (dsp->fdct == ff_fdct_ifast) { for (i = 0; i < 64; i++) { const int j = dsp->idct_permutation[i]; qmat[qscale][i] = (int)((UINT64_C(1) << (QMAT_SHIFT + 14)) / <S2SV_StartVul> (ff_aanscales[i] * qscale * quant_matrix[j])); <S2SV_EndVul> } } else { for (i = 0; i < 64; i++) { const int j = dsp->idct_permutation[i]; qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) / (qscale * quant_matrix[j])); qmat16[qscale][0][i] = (1 << QMAT_SHIFT_MMX) / (qscale * quant_matrix[j]); if (qmat16[qscale][0][i] == 0 || qmat16[qscale][0][i] == 128 * 256) qmat16[qscale][0][i] = 128 * 256 - 1; qmat16[qscale][1][i] = ROUNDED_DIV(bias << (16 - QUANT_BIAS_SHIFT), qmat16[qscale][0][i]); } } for (i = intra; i < 64; i++) { int64_t max = 8191; if (dsp->fdct == ff_fdct_ifast) { max = (8191LL * ff_aanscales[i]) >> 14; } while (((max * qmat[qscale][i]) >> shift) > INT_MAX) { shift++; } } } if (shift) { av_log(NULL, AV_LOG_INFO, ""Warning, QMAT_SHIFT is larger than %d, overflows possible\n"", QMAT_SHIFT - shift); } }","- (ff_aanscales[i] * qscale * quant_matrix[j]));
+ (ff_aanscales[i] * (int64_t)qscale * quant_matrix[j]));","void ff_convert_matrix(DSPContext *dsp, int (*qmat)[64], uint16_t (*qmat16)[2][64], const uint16_t *quant_matrix, int bias, int qmin, int qmax, int intra) { int qscale; int shift = 0; for (qscale = qmin; qscale <= qmax; qscale++) { int i; if (dsp->fdct == ff_jpeg_fdct_islow_8 || dsp->fdct == ff_jpeg_fdct_islow_10 || dsp->fdct == ff_faandct) { for (i = 0; i < 64; i++) { const int j = dsp->idct_permutation[i]; qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) / (qscale * quant_matrix[j])); } } else if (dsp->fdct == ff_fdct_ifast) { for (i = 0; i < 64; i++) { const int j = dsp->idct_permutation[i]; qmat[qscale][i] = (int)((UINT64_C(1) << (QMAT_SHIFT + 14)) / (ff_aanscales[i] * (int64_t)qscale * quant_matrix[j])); } } else { for (i = 0; i < 64; i++) { const int j = dsp->idct_permutation[i]; qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) / (qscale * quant_matrix[j])); qmat16[qscale][0][i] = (1 << QMAT_SHIFT_MMX) / (qscale * quant_matrix[j]); if (qmat16[qscale][0][i] == 0 || qmat16[qscale][0][i] == 128 * 256) qmat16[qscale][0][i] = 128 * 256 - 1; qmat16[qscale][1][i] = ROUNDED_DIV(bias << (16 - QUANT_BIAS_SHIFT), qmat16[qscale][0][i]); } } for (i = intra; i < 64; i++) { int64_t max = 8191; if (dsp->fdct == ff_fdct_ifast) { max = (8191LL * ff_aanscales[i]) >> 14; } while (((max * qmat[qscale][i]) >> shift) > INT_MAX) { shift++; } } } if (shift) { av_log(NULL, AV_LOG_INFO, ""Warning, QMAT_SHIFT is larger than %d, overflows possible\n"", QMAT_SHIFT - shift); } }"
10738----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1136cfd78480a327211653fb5a7c7c0c35d6af8d_1.json----add_entry,"static int add_entry(enum Type type, unsigned int hash, const char *filename, const unsigned char *digest, int need_symlink, unsigned short old_id) { static BUCKET nilbucket; static HENTRY nilhentry; BUCKET *bp; HENTRY *ep, *found = NULL; unsigned int ndx = (type + hash) % OSSL_NELEM(hash_table); for (bp = hash_table[ndx]; bp; bp = bp->next) if (bp->type == type && bp->hash == hash) break; if (bp == NULL) { bp = app_malloc(sizeof(*bp), ""hash bucket""); *bp = nilbucket; bp->next = hash_table[ndx]; bp->type = type; bp->hash = hash; hash_table[ndx] = bp; } for (ep = bp->first_entry; ep; ep = ep->next) { if (digest && memcmp(digest, ep->digest, evpmdsize) == 0) { BIO_printf(bio_err, ""%s: skipping duplicate certificate in %s\n"", opt_getprog(), filename); return 1; } if (strcmp(filename, ep->filename) == 0) { found = ep; if (digest == NULL) break; } } ep = found; if (ep == NULL) { if (bp->num_needed >= MAX_COLLISIONS) { BIO_printf(bio_err, ""%s: hash table overflow for %s\n"", opt_getprog(), filename); return 1; } ep = app_malloc(sizeof(*ep), ""collision bucket""); *ep = nilhentry; ep->old_id = ~0; <S2SV_StartVul> ep->filename = BUF_strdup(filename); <S2SV_EndVul> if (bp->last_entry) bp->last_entry->next = ep; if (bp->first_entry == NULL) bp->first_entry = ep; bp->last_entry = ep; } if (old_id < ep->old_id) ep->old_id = old_id; if (need_symlink && !ep->need_symlink) { ep->need_symlink = 1; bp->num_needed++; memcpy(ep->digest, digest, evpmdsize); } return 0; }","- ep->filename = BUF_strdup(filename);
+ ep->filename = OPENSSL_strdup(filename);","static int add_entry(enum Type type, unsigned int hash, const char *filename, const unsigned char *digest, int need_symlink, unsigned short old_id) { static BUCKET nilbucket; static HENTRY nilhentry; BUCKET *bp; HENTRY *ep, *found = NULL; unsigned int ndx = (type + hash) % OSSL_NELEM(hash_table); for (bp = hash_table[ndx]; bp; bp = bp->next) if (bp->type == type && bp->hash == hash) break; if (bp == NULL) { bp = app_malloc(sizeof(*bp), ""hash bucket""); *bp = nilbucket; bp->next = hash_table[ndx]; bp->type = type; bp->hash = hash; hash_table[ndx] = bp; } for (ep = bp->first_entry; ep; ep = ep->next) { if (digest && memcmp(digest, ep->digest, evpmdsize) == 0) { BIO_printf(bio_err, ""%s: skipping duplicate certificate in %s\n"", opt_getprog(), filename); return 1; } if (strcmp(filename, ep->filename) == 0) { found = ep; if (digest == NULL) break; } } ep = found; if (ep == NULL) { if (bp->num_needed >= MAX_COLLISIONS) { BIO_printf(bio_err, ""%s: hash table overflow for %s\n"", opt_getprog(), filename); return 1; } ep = app_malloc(sizeof(*ep), ""collision bucket""); *ep = nilhentry; ep->old_id = ~0; ep->filename = OPENSSL_strdup(filename); if (bp->last_entry) bp->last_entry->next = ep; if (bp->first_entry == NULL) bp->first_entry = ep; bp->last_entry = ep; } if (old_id < ep->old_id) ep->old_id = old_id; if (need_symlink && !ep->need_symlink) { ep->need_symlink = 1; bp->num_needed++; memcpy(ep->digest, digest, evpmdsize); } return 0; }"
4967----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_00fa8842d2ec3728ce09a84f18d5465d8b424853_1.json----av_reallocp,"int av_reallocp(void *ptr, size_t size) { <S2SV_StartVul> void **ptrptr = ptr; <S2SV_EndVul> <S2SV_StartVul> void *ret; <S2SV_EndVul> if (!size) { av_freep(ptr); return 0; } <S2SV_StartVul> ret = av_realloc(*ptrptr, size); <S2SV_EndVul> <S2SV_StartVul> if (!ret) { <S2SV_EndVul> av_freep(ptr); return AVERROR(ENOMEM); } <S2SV_StartVul> *ptrptr = ret; <S2SV_EndVul> return 0; }","- void **ptrptr = ptr;
- void *ret;
- ret = av_realloc(*ptrptr, size);
- if (!ret) {
+ void *val;
+ memcpy(&val, ptr, sizeof(val));
+ val = av_realloc(val, size);
+ if (!val) {
+ memcpy(ptr, &val, sizeof(val));","int av_reallocp(void *ptr, size_t size) { void *val; if (!size) { av_freep(ptr); return 0; } memcpy(&val, ptr, sizeof(val)); val = av_realloc(val, size); if (!val) { av_freep(ptr); return AVERROR(ENOMEM); } memcpy(ptr, &val, sizeof(val)); return 0; }"
10885----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_15eb8dda52298b0c86aa61aefebb1523ec61194c_1.json----BN_exp,"int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) { int i, bits, ret = 0; BIGNUM *v, *rr; if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) { BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return -1; } BN_CTX_start(ctx); if ((r == a) || (r == p)) rr = BN_CTX_get(ctx); else rr = r; v = BN_CTX_get(ctx); if (rr == NULL || v == NULL) goto err; if (BN_copy(v, a) == NULL) goto err; bits = BN_num_bits(p); if (BN_is_odd(p)) { if (BN_copy(rr, a) == NULL) goto err; } else { if (!BN_one(rr)) goto err; } for (i = 1; i < bits; i++) { if (!BN_sqr(v, v, ctx)) goto err; if (BN_is_bit_set(p, i)) { if (!BN_mul(rr, rr, v, ctx)) goto err; } } <S2SV_StartVul> ret = 1; <S2SV_EndVul> <S2SV_StartVul> err: <S2SV_EndVul> if (r != rr) BN_copy(r, rr); BN_CTX_end(ctx); bn_check_top(r); return (ret); }","- ret = 1;
- err:
+ ret = 1;
+ err:","int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) { int i, bits, ret = 0; BIGNUM *v, *rr; if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) { BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return -1; } BN_CTX_start(ctx); if ((r == a) || (r == p)) rr = BN_CTX_get(ctx); else rr = r; v = BN_CTX_get(ctx); if (rr == NULL || v == NULL) goto err; if (BN_copy(v, a) == NULL) goto err; bits = BN_num_bits(p); if (BN_is_odd(p)) { if (BN_copy(rr, a) == NULL) goto err; } else { if (!BN_one(rr)) goto err; } for (i = 1; i < bits; i++) { if (!BN_sqr(v, v, ctx)) goto err; if (BN_is_bit_set(p, i)) { if (!BN_mul(rr, rr, v, ctx)) goto err; } } if (r != rr) BN_copy(r, rr); ret = 1; err: BN_CTX_end(ctx); bn_check_top(r); return (ret); }"
11354----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_27ba45e03d7e244dc09dba2d4c7727579b51388b_1.json----BIO_dump_indent,"int BIO_dump_indent(BIO *bio, const char *s, int len, int indent) { int ret=0; char buf[288+1],tmp[20],str[128+1]; int i,j,rows,trc; unsigned char ch; int dump_width; trc=0; #ifdef TRUNCATE for(; (len > 0) && ((s[len-1] == ' ') || (s[len-1] == '\0')); len--) trc++; #endif if (indent < 0) indent = 0; if (indent) { if (indent > 128) indent=128; memset(str,' ',indent); } str[indent]='\0'; dump_width=DUMP_WIDTH_LESS_INDENT(indent); rows=(len/dump_width); if ((rows*dump_width)<len) rows++; for(i=0;i<rows;i++) { buf[0]='\0'; <S2SV_StartVul> strcpy(buf,str); <S2SV_EndVul> <S2SV_StartVul> sprintf(tmp,""%04x - "",i*dump_width); <S2SV_EndVul> <S2SV_StartVul> strcat(buf,tmp); <S2SV_EndVul> for(j=0;j<dump_width;j++) { if (((i*dump_width)+j)>=len) { <S2SV_StartVul> strcat(buf,"" ""); <S2SV_EndVul> } else { ch=((unsigned char)*(s+i*dump_width+j)) & 0xff; <S2SV_StartVul> sprintf(tmp,""%02x%c"",ch,j==7?'-':' '); <S2SV_EndVul> <S2SV_StartVul> strcat(buf,tmp); <S2SV_EndVul> } } <S2SV_StartVul> strcat(buf,"" ""); <S2SV_EndVul> for(j=0;j<dump_width;j++) { if (((i*dump_width)+j)>=len) break; ch=((unsigned char)*(s+i*dump_width+j)) & 0xff; #ifndef CHARSET_EBCDIC <S2SV_StartVul> sprintf(tmp,""%c"",((ch>=' ')&&(ch<='~'))?ch:'.'); <S2SV_EndVul> #else <S2SV_StartVul> sprintf(tmp,""%c"",((ch>=os_toascii[' '])&&(ch<=os_toascii['~'])) <S2SV_EndVul> <S2SV_StartVul> ? os_toebcdic[ch] <S2SV_EndVul> <S2SV_StartVul> : '.'); <S2SV_EndVul> #endif <S2SV_StartVul> strcat(buf,tmp); <S2SV_EndVul> } <S2SV_StartVul> strcat(buf,""\n""); <S2SV_EndVul> ret+=BIO_write(bio,(char *)buf,strlen(buf)); } #ifdef TRUNCATE if (trc > 0) { <S2SV_StartVul> sprintf(buf,""%s%04x - <SPACES/NULS>\n"",str,len+trc); <S2SV_EndVul> ret+=BIO_write(bio,(char *)buf,strlen(buf)); } #endif return(ret); }","- strcpy(buf,str);
- sprintf(tmp,""%04x - "",i*dump_width);
- strcat(buf,tmp);
- strcat(buf,"" "");
- sprintf(tmp,""%02x%c"",ch,j==7?'-':' ');
- strcat(buf,tmp);
- strcat(buf,"" "");
- sprintf(tmp,""%c"",((ch>=' ')&&(ch<='~'))?ch:'.');
- sprintf(tmp,""%c"",((ch>=os_toascii[' '])&&(ch<=os_toascii['~']))
- ? os_toebcdic[ch]
- : '.');
- strcat(buf,tmp);
- strcat(buf,""\n"");
- sprintf(buf,""%s%04x - <SPACES/NULS>\n"",str,len+trc);
+ BUF_strlcpy(buf,str,sizeof buf);
+ BIO_snprintf(tmp,sizeof tmp,""%04x - "",i*dump_width);
+ BUF_strlcat(buf,tmp,sizeof buf);
+ BUF_strlcat(buf,"" "",sizeof buf);
+ BIO_snprintf(tmp,sizeof tmp,""%02x%c"",ch,
+ j==7?'-':' ');
+ BUF_strlcat(buf,tmp,sizeof buf);
+ BUF_strlcat(buf,"" "",sizeof buf);
+ BIO_snprintf(tmp,sizeof tmp,""%c"",
+ ((ch>=' ')&&(ch<='~'))?ch:'.');
+ BIO_snprintf(tmp,sizeof tmp,""%c"",
+ ((ch>=os_toascii[' '])&&(ch<=os_toascii['~']))
+ ? os_toebcdic[ch]
+ : '.');
+ BUF_strlcat(buf,tmp,sizeof buf);
+ BUF_strlcat(buf,""\n"",sizeof buf);
+ BIO_snprintf(buf,sizeof buf,""%s%04x - <SPACES/NULS>\n"",str,
+ len+trc);","int BIO_dump_indent(BIO *bio, const char *s, int len, int indent) { int ret=0; char buf[288+1],tmp[20],str[128+1]; int i,j,rows,trc; unsigned char ch; int dump_width; trc=0; #ifdef TRUNCATE for(; (len > 0) && ((s[len-1] == ' ') || (s[len-1] == '\0')); len--) trc++; #endif if (indent < 0) indent = 0; if (indent) { if (indent > 128) indent=128; memset(str,' ',indent); } str[indent]='\0'; dump_width=DUMP_WIDTH_LESS_INDENT(indent); rows=(len/dump_width); if ((rows*dump_width)<len) rows++; for(i=0;i<rows;i++) { buf[0]='\0'; BUF_strlcpy(buf,str,sizeof buf); BIO_snprintf(tmp,sizeof tmp,""%04x - "",i*dump_width); BUF_strlcat(buf,tmp,sizeof buf); for(j=0;j<dump_width;j++) { if (((i*dump_width)+j)>=len) { BUF_strlcat(buf,"" "",sizeof buf); } else { ch=((unsigned char)*(s+i*dump_width+j)) & 0xff; BIO_snprintf(tmp,sizeof tmp,""%02x%c"",ch, j==7?'-':' '); BUF_strlcat(buf,tmp,sizeof buf); } } BUF_strlcat(buf,"" "",sizeof buf); for(j=0;j<dump_width;j++) { if (((i*dump_width)+j)>=len) break; ch=((unsigned char)*(s+i*dump_width+j)) & 0xff; #ifndef CHARSET_EBCDIC BIO_snprintf(tmp,sizeof tmp,""%c"", ((ch>=' ')&&(ch<='~'))?ch:'.'); #else BIO_snprintf(tmp,sizeof tmp,""%c"", ((ch>=os_toascii[' '])&&(ch<=os_toascii['~'])) ? os_toebcdic[ch] : '.'); #endif BUF_strlcat(buf,tmp,sizeof buf); } BUF_strlcat(buf,""\n"",sizeof buf); ret+=BIO_write(bio,(char *)buf,strlen(buf)); } #ifdef TRUNCATE if (trc > 0) { BIO_snprintf(buf,sizeof buf,""%s%04x - <SPACES/NULS>\n"",str, len+trc); ret+=BIO_write(bio,(char *)buf,strlen(buf)); } #endif return(ret); }"
10971----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_18b413c8e735f80c2638f2b6f51c0a8b4eaa5dd3_1.json----ASN1_TIME_to_generalizedtime,"ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out) { ASN1_GENERALIZEDTIME *ret; char *str; int newlen; if (!ASN1_TIME_check(t)) return NULL; if (out == NULL || *out == NULL) { if ((ret = ASN1_GENERALIZEDTIME_new()) == NULL) return NULL; if (out) *out = ret; } else ret = *out; if (t->type == V_ASN1_GENERALIZEDTIME) { if (!ASN1_STRING_set(ret, t->data, t->length)) return NULL; return ret; } if (!ASN1_STRING_set(ret, NULL, t->length + 2)) return NULL; newlen = t->length + 2 + 1; str = (char *)ret->data; if (t->data[0] >= '5') <S2SV_StartVul> BUF_strlcpy(str, ""19"", newlen); <S2SV_EndVul> else <S2SV_StartVul> BUF_strlcpy(str, ""20"", newlen); <S2SV_EndVul> <S2SV_StartVul> BUF_strlcat(str, (char *)t->data, newlen); <S2SV_EndVul> return ret; }","- BUF_strlcpy(str, ""19"", newlen);
- BUF_strlcpy(str, ""20"", newlen);
- BUF_strlcat(str, (char *)t->data, newlen);
+ OPENSSL_strlcpy(str, ""19"", newlen);
+ OPENSSL_strlcpy(str, ""20"", newlen);
+ OPENSSL_strlcat(str, (char *)t->data, newlen);","ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t, ASN1_GENERALIZEDTIME **out) { ASN1_GENERALIZEDTIME *ret; char *str; int newlen; if (!ASN1_TIME_check(t)) return NULL; if (out == NULL || *out == NULL) { if ((ret = ASN1_GENERALIZEDTIME_new()) == NULL) return NULL; if (out) *out = ret; } else ret = *out; if (t->type == V_ASN1_GENERALIZEDTIME) { if (!ASN1_STRING_set(ret, t->data, t->length)) return NULL; return ret; } if (!ASN1_STRING_set(ret, NULL, t->length + 2)) return NULL; newlen = t->length + 2 + 1; str = (char *)ret->data; if (t->data[0] >= '5') OPENSSL_strlcpy(str, ""19"", newlen); else OPENSSL_strlcpy(str, ""20"", newlen); OPENSSL_strlcat(str, (char *)t->data, newlen); return ret; }"
1053----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_39ccaaadd29fd263e8d757fd1ab6e0ecb173c263_1.json----ff_rv34_decode_frame,"int ff_rv34_decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size) { RV34DecContext *r = avctx->priv_data; MpegEncContext *s = &r->s; AVFrame *pict = data; SliceInfo si; int i; int slice_count; const uint8_t *slices_hdr = NULL; int last = 0; if (buf_size == 0) { if (s->low_delay==0 && s->next_picture_ptr) { *pict= *(AVFrame*)s->next_picture_ptr; s->next_picture_ptr= NULL; *data_size = sizeof(AVFrame); } return 0; } if(!avctx->slice_count){ slice_count = (*buf++) + 1; slices_hdr = buf + 4; buf += 8 * slice_count; }else slice_count = avctx->slice_count; for(i=0; i<slice_count; i++){ int offset= get_slice_offset(avctx, slices_hdr, i); int size; if(i+1 == slice_count) size= buf_size - offset; else size= get_slice_offset(avctx, slices_hdr, i+1) - offset; if(offset > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is greater than frame size\n""); break; } r->si.end = s->mb_width * s->mb_height; if(i+1 < slice_count){ init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8); if(r->parse_slice_header(r, &r->s.gb, &si) < 0){ if(i+2 < slice_count) size = get_slice_offset(avctx, slices_hdr, i+2) - offset; else size = buf_size - offset; }else r->si.end = si.start; } <S2SV_StartVul> if(!i && si.type == FF_B_TYPE && (!s->last_picture_ptr || !s->last_picture_ptr->data[0])) <S2SV_EndVul> <S2SV_StartVul> return -1; <S2SV_EndVul> last = rv34_decode_slice(r, r->si.end, buf + offset, size); s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start; if(last) break; } if(last){ if(r->loop_filter) r->loop_filter(r, s->mb_height - 1); ff_er_frame_end(s); MPV_frame_end(s); if (s->pict_type == FF_B_TYPE || s->low_delay) { *pict= *(AVFrame*)s->current_picture_ptr; } else if (s->last_picture_ptr != NULL) { *pict= *(AVFrame*)s->last_picture_ptr; } if(s->last_picture_ptr || s->low_delay){ *data_size = sizeof(AVFrame); ff_print_debug_info(s, pict); } s->current_picture_ptr= NULL; } return buf_size; }","- if(!i && si.type == FF_B_TYPE && (!s->last_picture_ptr || !s->last_picture_ptr->data[0]))
- return -1;
+ if(get_slice_offset(avctx, slices_hdr, 0) > buf_size){
+ av_log(avctx, AV_LOG_ERROR, ""Slice offset is greater than frame size\n"");
+ return -1;
+ }
+ init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), buf_size-get_slice_offset(avctx, slices_hdr, 0));
+ if(r->parse_slice_header(r, &r->s.gb, &si) < 0){
+ av_log(avctx, AV_LOG_ERROR, ""First slice header is incorrect\n"");
+ return -1;
+ }
+ if((!s->last_picture_ptr || !s->last_picture_ptr->data[0]) && si.type == FF_B_TYPE)
+ return -1;","int ff_rv34_decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size) { RV34DecContext *r = avctx->priv_data; MpegEncContext *s = &r->s; AVFrame *pict = data; SliceInfo si; int i; int slice_count; const uint8_t *slices_hdr = NULL; int last = 0; if (buf_size == 0) { if (s->low_delay==0 && s->next_picture_ptr) { *pict= *(AVFrame*)s->next_picture_ptr; s->next_picture_ptr= NULL; *data_size = sizeof(AVFrame); } return 0; } if(!avctx->slice_count){ slice_count = (*buf++) + 1; slices_hdr = buf + 4; buf += 8 * slice_count; }else slice_count = avctx->slice_count; if(get_slice_offset(avctx, slices_hdr, 0) > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is greater than frame size\n""); return -1; } init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), buf_size-get_slice_offset(avctx, slices_hdr, 0)); if(r->parse_slice_header(r, &r->s.gb, &si) < 0){ av_log(avctx, AV_LOG_ERROR, ""First slice header is incorrect\n""); return -1; } if((!s->last_picture_ptr || !s->last_picture_ptr->data[0]) && si.type == FF_B_TYPE) return -1; for(i=0; i<slice_count; i++){ int offset= get_slice_offset(avctx, slices_hdr, i); int size; if(i+1 == slice_count) size= buf_size - offset; else size= get_slice_offset(avctx, slices_hdr, i+1) - offset; if(offset > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is greater than frame size\n""); break; } r->si.end = s->mb_width * s->mb_height; if(i+1 < slice_count){ init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8); if(r->parse_slice_header(r, &r->s.gb, &si) < 0){ if(i+2 < slice_count) size = get_slice_offset(avctx, slices_hdr, i+2) - offset; else size = buf_size - offset; }else r->si.end = si.start; } last = rv34_decode_slice(r, r->si.end, buf + offset, size); s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start; if(last) break; } if(last){ if(r->loop_filter) r->loop_filter(r, s->mb_height - 1); ff_er_frame_end(s); MPV_frame_end(s); if (s->pict_type == FF_B_TYPE || s->low_delay) { *pict= *(AVFrame*)s->current_picture_ptr; } else if (s->last_picture_ptr != NULL) { *pict= *(AVFrame*)s->last_picture_ptr; } if(s->last_picture_ptr || s->low_delay){ *data_size = sizeof(AVFrame); ff_print_debug_info(s, pict); } s->current_picture_ptr= NULL; } return buf_size; }"
10514----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_08e790e7428bb0bf6a59bf40c78cbfa0b7236dbb_1.json----t_fromb64,"static int t_fromb64(unsigned char *a, size_t alen, const char *src) { char *loc; int i, j; int size; while (*src && (*src == ' ' || *src == '\t' || *src == '\n')) ++src; size = strlen(src); <S2SV_StartVul> if (alen > INT_MAX || size > (int)alen) <S2SV_EndVul> return -1; i = 0; while (i < size) { loc = strchr(b64table, src[i]); if (loc == (char *)0) break; else a[i] = loc - b64table; ++i; } if (i == 0) return 0; size = i; i = size - 1; j = size; while (1) { a[j] = a[i]; if (--i < 0) break; a[j] |= (a[i] & 3) << 6; --j; a[j] = (unsigned char)((a[i] & 0x3c) >> 2); if (--i < 0) break; a[j] |= (a[i] & 0xf) << 4; --j; a[j] = (unsigned char)((a[i] & 0x30) >> 4); if (--i < 0) break; a[j] |= (a[i] << 2); a[--j] = 0; if (--i < 0) break; } <S2SV_StartVul> while (a[j] == 0 && j <= size) <S2SV_EndVul> ++j; i = 0; while (j <= size) a[i++] = a[j++]; return i; }","- if (alen > INT_MAX || size > (int)alen)
- while (a[j] == 0 && j <= size)
+ if (alen == 0 || alen > INT_MAX)
+ return -1;
+ if (size < 0 || size >= (int)alen)
+ while (j <= size && a[j] == 0)","static int t_fromb64(unsigned char *a, size_t alen, const char *src) { char *loc; int i, j; int size; if (alen == 0 || alen > INT_MAX) return -1; while (*src && (*src == ' ' || *src == '\t' || *src == '\n')) ++src; size = strlen(src); if (size < 0 || size >= (int)alen) return -1; i = 0; while (i < size) { loc = strchr(b64table, src[i]); if (loc == (char *)0) break; else a[i] = loc - b64table; ++i; } if (i == 0) return 0; size = i; i = size - 1; j = size; while (1) { a[j] = a[i]; if (--i < 0) break; a[j] |= (a[i] & 3) << 6; --j; a[j] = (unsigned char)((a[i] & 0x3c) >> 2); if (--i < 0) break; a[j] |= (a[i] & 0xf) << 4; --j; a[j] = (unsigned char)((a[i] & 0x30) >> 4); if (--i < 0) break; a[j] |= (a[i] << 2); a[--j] = 0; if (--i < 0) break; } while (j <= size && a[j] == 0) ++j; i = 0; while (j <= size) a[i++] = a[j++]; return i; }"
12811----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5981f8c59b86c8704bac714a9301d5f1194a0493_1.json----x509_load_serial,"static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile, int create) { char *buf = NULL, *p; ASN1_INTEGER *bs = NULL; BIGNUM *serial = NULL; size_t len; len = ((serialfile == NULL) ? (strlen(CAfile) + strlen(POSTFIX) + 1) : (strlen(serialfile))) + 1; buf = app_malloc(len, ""serial# buffer""); if (serialfile == NULL) { <S2SV_StartVul> BUF_strlcpy(buf, CAfile, len); <S2SV_EndVul> for (p = buf; *p; p++) if (*p == '.') { *p = '\0'; break; } <S2SV_StartVul> BUF_strlcat(buf, POSTFIX, len); <S2SV_EndVul> } else <S2SV_StartVul> BUF_strlcpy(buf, serialfile, len); <S2SV_EndVul> serial = load_serial(buf, create, NULL); if (serial == NULL) goto end; if (!BN_add_word(serial, 1)) { BIO_printf(bio_err, ""add_word failure\n""); goto end; } if (!save_serial(buf, NULL, serial, &bs)) goto end; end: OPENSSL_free(buf); BN_free(serial); return bs; }","- BUF_strlcpy(buf, CAfile, len);
- BUF_strlcat(buf, POSTFIX, len);
- BUF_strlcpy(buf, serialfile, len);
+ OPENSSL_strlcpy(buf, CAfile, len);
+ OPENSSL_strlcat(buf, POSTFIX, len);
+ OPENSSL_strlcpy(buf, serialfile, len);","static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile, int create) { char *buf = NULL, *p; ASN1_INTEGER *bs = NULL; BIGNUM *serial = NULL; size_t len; len = ((serialfile == NULL) ? (strlen(CAfile) + strlen(POSTFIX) + 1) : (strlen(serialfile))) + 1; buf = app_malloc(len, ""serial# buffer""); if (serialfile == NULL) { OPENSSL_strlcpy(buf, CAfile, len); for (p = buf; *p; p++) if (*p == '.') { *p = '\0'; break; } OPENSSL_strlcat(buf, POSTFIX, len); } else OPENSSL_strlcpy(buf, serialfile, len); serial = load_serial(buf, create, NULL); if (serial == NULL) goto end; if (!BN_add_word(serial, 1)) { BIO_printf(bio_err, ""add_word failure\n""); goto end; } if (!save_serial(buf, NULL, serial, &bs)) goto end; end: OPENSSL_free(buf); BN_free(serial); return bs; }"
14618----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_98e72fb76c18fabf7c7da1d8312b2d76e36ff5e0_1.json----asn1_cb,"static int asn1_cb(const char *elem, int len, void *bitstr) { tag_exp_arg *arg = bitstr; int i; int utype; <S2SV_StartVul> int vlen; <S2SV_EndVul> const char *p, *vstart = NULL; int tmp_tag, tmp_class; for(i = 0, p = elem; i < len; p++, i++) { if (*p == ':') { vstart = p + 1; vlen = len - (vstart - elem); len = p - elem; break; } } utype = asn1_str2tag(elem, len); if (utype == -1) { ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG); ERR_add_error_data(2, ""tag="", elem); return -1; } if (!(utype & ASN1_GEN_FLAG)) { arg->utype = utype; arg->str = vstart; if (!vstart && elem[len]) { ASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE); return -1; } return 0; } switch(utype) { case ASN1_GEN_FLAG_IMP: if (arg->imp_tag != -1) { ASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING); return -1; } if (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class)) return -1; break; case ASN1_GEN_FLAG_EXP: if (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class)) return -1; if (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0)) return -1; break; case ASN1_GEN_FLAG_SEQWRAP: if (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1)) return -1; break; case ASN1_GEN_FLAG_BITWRAP: if (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1)) return -1; break; case ASN1_GEN_FLAG_OCTWRAP: if (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1)) return -1; break; case ASN1_GEN_FLAG_FORMAT: if (!strncmp(vstart, ""ASCII"", 5)) arg->format = ASN1_GEN_FORMAT_ASCII; else if (!strncmp(vstart, ""UTF8"", 4)) arg->format = ASN1_GEN_FORMAT_UTF8; else if (!strncmp(vstart, ""HEX"", 3)) arg->format = ASN1_GEN_FORMAT_HEX; else if (!strncmp(vstart, ""BITLIST"", 3)) arg->format = ASN1_GEN_FORMAT_BITLIST; else { ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT); return -1; } break; } return 1; }","- int vlen;
+ int vlen = 0;","static int asn1_cb(const char *elem, int len, void *bitstr) { tag_exp_arg *arg = bitstr; int i; int utype; int vlen = 0; const char *p, *vstart = NULL; int tmp_tag, tmp_class; for(i = 0, p = elem; i < len; p++, i++) { if (*p == ':') { vstart = p + 1; vlen = len - (vstart - elem); len = p - elem; break; } } utype = asn1_str2tag(elem, len); if (utype == -1) { ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG); ERR_add_error_data(2, ""tag="", elem); return -1; } if (!(utype & ASN1_GEN_FLAG)) { arg->utype = utype; arg->str = vstart; if (!vstart && elem[len]) { ASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE); return -1; } return 0; } switch(utype) { case ASN1_GEN_FLAG_IMP: if (arg->imp_tag != -1) { ASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING); return -1; } if (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class)) return -1; break; case ASN1_GEN_FLAG_EXP: if (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class)) return -1; if (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0)) return -1; break; case ASN1_GEN_FLAG_SEQWRAP: if (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1)) return -1; break; case ASN1_GEN_FLAG_BITWRAP: if (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1)) return -1; break; case ASN1_GEN_FLAG_OCTWRAP: if (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1)) return -1; break; case ASN1_GEN_FLAG_FORMAT: if (!strncmp(vstart, ""ASCII"", 5)) arg->format = ASN1_GEN_FORMAT_ASCII; else if (!strncmp(vstart, ""UTF8"", 4)) arg->format = ASN1_GEN_FORMAT_UTF8; else if (!strncmp(vstart, ""HEX"", 3)) arg->format = ASN1_GEN_FORMAT_HEX; else if (!strncmp(vstart, ""BITLIST"", 3)) arg->format = ASN1_GEN_FORMAT_BITLIST; else { ASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT); return -1; } break; } return 1; }"
1647----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5bffbc64f3203f3ba04f4e0fc87eb3c2d1fa398f_1.json----avfilter_default_get_audio_buffer,"AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms, int nb_samples) { AVFilterBufferRef *samplesref = NULL; <S2SV_StartVul> int linesize[8]; <S2SV_EndVul> <S2SV_StartVul> uint8_t *data[8]; <S2SV_EndVul> <S2SV_StartVul> int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout); <S2SV_EndVul> if (av_samples_alloc(data, linesize, <S2SV_StartVul> nb_channels, nb_samples, link->format, <S2SV_EndVul> 16) < 0) return NULL; samplesref = avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms, nb_samples, link->format, link->channel_layout, link->planar); if (!samplesref) { av_free(data[0]); return NULL; } return samplesref; }","- int linesize[8];
- uint8_t *data[8];
- int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);
- nb_channels, nb_samples, link->format,
+ int linesize[8] = {0};
+ uint8_t *data[8] = {0};
+ int ch, nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);
+ av_assert0(nb_channels <= 8);
+ nb_channels, nb_samples,
+ av_get_alt_sample_fmt(link->format, link->planar),
+ for (ch = 1; link->planar && ch < nb_channels; ch++)
+ linesize[ch] = linesize[0];","AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms, int nb_samples) { AVFilterBufferRef *samplesref = NULL; int linesize[8] = {0}; uint8_t *data[8] = {0}; int ch, nb_channels = av_get_channel_layout_nb_channels(link->channel_layout); av_assert0(nb_channels <= 8); if (av_samples_alloc(data, linesize, nb_channels, nb_samples, av_get_alt_sample_fmt(link->format, link->planar), 16) < 0) return NULL; for (ch = 1; link->planar && ch < nb_channels; ch++) linesize[ch] = linesize[0]; samplesref = avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms, nb_samples, link->format, link->channel_layout, link->planar); if (!samplesref) { av_free(data[0]); return NULL; } return samplesref; }"
12778----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5883279e43d89c1000a3fe556b256c6bc2eb29be_1.json----EVP_PBE_CipherInit,"int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de) { const EVP_CIPHER *cipher; const EVP_MD *md; int cipher_nid, md_nid; EVP_PBE_KEYGEN *keygen; if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj), &cipher_nid, &md_nid, &keygen)) { char obj_tmp[80]; EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM); if (!pbe_obj) <S2SV_StartVul> OPENSSL_strlcpy(obj_tmp, ""NULL"", sizeof obj_tmp); <S2SV_EndVul> else i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj); ERR_add_error_data(2, ""TYPE="", obj_tmp); return 0; } if (!pass) passlen = 0; else if (passlen == -1) passlen = strlen(pass); if (cipher_nid == -1) cipher = NULL; else { cipher = EVP_get_cipherbynid(cipher_nid); if (!cipher) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER); return 0; } } if (md_nid == -1) md = NULL; else { md = EVP_get_digestbynid(md_nid); if (!md) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST); return 0; } } if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE); return 0; } return 1; }","- OPENSSL_strlcpy(obj_tmp, ""NULL"", sizeof obj_tmp);
+ strcpy(obj_tmp, ""NULL"");","int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen, ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de) { const EVP_CIPHER *cipher; const EVP_MD *md; int cipher_nid, md_nid; EVP_PBE_KEYGEN *keygen; if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj), &cipher_nid, &md_nid, &keygen)) { char obj_tmp[80]; EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM); if (!pbe_obj) strcpy(obj_tmp, ""NULL""); else i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj); ERR_add_error_data(2, ""TYPE="", obj_tmp); return 0; } if (!pass) passlen = 0; else if (passlen == -1) passlen = strlen(pass); if (cipher_nid == -1) cipher = NULL; else { cipher = EVP_get_cipherbynid(cipher_nid); if (!cipher) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER); return 0; } } if (md_nid == -1) md = NULL; else { md = EVP_get_digestbynid(md_nid); if (!md) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST); return 0; } } if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) { EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE); return 0; } return 1; }"
746----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_28831a56da3d3a71460805e8c60b3be56f2cc7fb_1.json----sbr_hf_calc_npatches,"static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr) { int i, k, sb = 0; int msb = sbr->k[0]; int usb = sbr->kx[1]; int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate; sbr->num_patches = 0; if (goal_sb < sbr->kx[1] + sbr->m[1]) { for (k = 0; sbr->f_master[k] < goal_sb; k++) ; } else k = sbr->n_master; do { int odd = 0; for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) { sb = sbr->f_master[i]; odd = (sb + sbr->k[0]) & 1; } sbr->patch_num_subbands[sbr->num_patches] = FFMAX(sb - usb, 0); sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches]; if (sbr->patch_num_subbands[sbr->num_patches] > 0) { usb = sb; msb = sb; sbr->num_patches++; } else msb = sbr->kx[1]; if (sbr->f_master[k] - sb < 3) k = sbr->n_master; } while (sb != sbr->kx[1] + sbr->m[1]); if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1) sbr->num_patches--; <S2SV_StartVul> if (sbr->num_patches > 6) { <S2SV_EndVul> <S2SV_StartVul> av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches); <S2SV_EndVul> <S2SV_StartVul> return -1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> return 0; }","- if (sbr->num_patches > 6) {
- av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches);
- return -1;
- }
+ if (sbr->num_patches > 5) {
+ av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches);
+ return -1;
+ }","static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr) { int i, k, sb = 0; int msb = sbr->k[0]; int usb = sbr->kx[1]; int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate; sbr->num_patches = 0; if (goal_sb < sbr->kx[1] + sbr->m[1]) { for (k = 0; sbr->f_master[k] < goal_sb; k++) ; } else k = sbr->n_master; do { int odd = 0; for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) { sb = sbr->f_master[i]; odd = (sb + sbr->k[0]) & 1; } if (sbr->num_patches > 5) { av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches); return -1; } sbr->patch_num_subbands[sbr->num_patches] = FFMAX(sb - usb, 0); sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches]; if (sbr->patch_num_subbands[sbr->num_patches] > 0) { usb = sb; msb = sb; sbr->num_patches++; } else msb = sbr->kx[1]; if (sbr->f_master[k] - sb < 3) k = sbr->n_master; } while (sb != sbr->kx[1] + sbr->m[1]); if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1) sbr->num_patches--; return 0; }"
14040----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_84642f9d0b6dbc42dcc13de5afb3685be960f244_1.json----rsa_blinding_convert,"<S2SV_StartVul> static int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f, <S2SV_EndVul> <S2SV_StartVul> BIGNUM *r, BN_CTX *ctx) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> if (local) <S2SV_EndVul> return BN_BLINDING_convert_ex(f, NULL, b, ctx); else { <S2SV_StartVul> int ret; <S2SV_EndVul> <S2SV_StartVul> CRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING); <S2SV_EndVul> <S2SV_StartVul> ret = BN_BLINDING_convert_ex(f, r, b, ctx); <S2SV_EndVul> <S2SV_StartVul> CRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING); <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- static int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f,
- BIGNUM *r, BN_CTX *ctx)
- {
- if (local)
- int ret;
- CRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING);
- ret = BN_BLINDING_convert_ex(f, r, b, ctx);
- CRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING);
- return ret;
- }
- }
+ static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
+ BN_CTX *ctx)
+ {
+ if (unblind == NULL)
+ ret = BN_BLINDING_convert_ex(f, unblind, b, ctx);
+ }","static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind, BN_CTX *ctx) { if (unblind == NULL) return BN_BLINDING_convert_ex(f, NULL, b, ctx); else { int ret; CRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING); ret = BN_BLINDING_convert_ex(f, unblind, b, ctx); CRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING); return ret; } }"
10436----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0594897dae408f54b75fba7d498527512172141d_1.json----ssl3_connect,"int ssl3_connect(SSL *s) { BUF_MEM *buf = NULL; unsigned long Time = (unsigned long)time(NULL); void (*cb) (const SSL *ssl, int type, int val) = NULL; int ret = -1; int new_state, state, skip = 0; RAND_add(&Time, sizeof(Time), 0); ERR_clear_error(); clear_sys_error(); if (s->info_callback != NULL) cb = s->info_callback; else if (s->ctx->info_callback != NULL) cb = s->ctx->info_callback; s->in_handshake++; if (!SSL_in_init(s) || SSL_in_before(s)) { if (!SSL_clear(s)) return -1; } #ifndef OPENSSL_NO_HEARTBEATS if (s->tlsext_hb_pending) { s->tlsext_hb_pending = 0; s->tlsext_hb_seq++; } #endif for (;;) { state = s->state; switch (s->state) { case SSL_ST_RENEGOTIATE: s->renegotiate = 1; s->state = SSL_ST_CONNECT; s->ctx->stats.sess_connect_renegotiate++; case SSL_ST_BEFORE: case SSL_ST_CONNECT: case SSL_ST_BEFORE | SSL_ST_CONNECT: case SSL_ST_OK | SSL_ST_CONNECT: s->server = 0; if (cb != NULL) cb(s, SSL_CB_HANDSHAKE_START, 1); if ((s->version >> 8) != SSL3_VERSION_MAJOR && s->version != TLS_ANY_VERSION) { SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR); s->state = SSL_ST_ERR; ret = -1; goto end; } if (s->version != TLS_ANY_VERSION && !ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) { SSLerr(SSL_F_SSL3_CONNECT, SSL_R_VERSION_TOO_LOW); return -1; } s->type = SSL_ST_CONNECT; if (s->init_buf == NULL) { if ((buf = BUF_MEM_new()) == NULL) { ret = -1; s->state = SSL_ST_ERR; goto end; } if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) { ret = -1; s->state = SSL_ST_ERR; goto end; } s->init_buf = buf; buf = NULL; } if (!ssl3_setup_buffers(s)) { ret = -1; goto end; } if (!ssl_init_wbio_buffer(s, 0)) { ret = -1; s->state = SSL_ST_ERR; goto end; } ssl3_init_finished_mac(s); s->state = SSL3_ST_CW_CLNT_HELLO_A; s->ctx->stats.sess_connect++; s->init_num = 0; s->s3->change_cipher_spec = 0; break; case SSL3_ST_CW_CLNT_HELLO_A: case SSL3_ST_CW_CLNT_HELLO_B: s->shutdown = 0; ret = ssl3_client_hello(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_SRVR_HELLO_A; s->init_num = 0; if (s->bbio != s->wbio) s->wbio = BIO_push(s->bbio, s->wbio); break; case SSL3_ST_CR_SRVR_HELLO_A: case SSL3_ST_CR_SRVR_HELLO_B: ret = ssl3_get_server_hello(s); if (ret <= 0) goto end; if (s->hit) { s->state = SSL3_ST_CR_CHANGE_A; if (s->tlsext_ticket_expected) { s->state = SSL3_ST_CR_SESSION_TICKET_A; } } else { s->state = SSL3_ST_CR_CERT_A; } s->init_num = 0; break; case SSL3_ST_CR_CERT_A: case SSL3_ST_CR_CERT_B: ret = ssl3_check_change(s); if (ret < 0) goto end; if (ret == 1) { s->hit = 1; s->state = SSL3_ST_CR_CHANGE_A; s->init_num = 0; break; } if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) { ret = ssl3_get_server_certificate(s); if (ret <= 0) goto end; if (s->tlsext_status_expected) s->state = SSL3_ST_CR_CERT_STATUS_A; else s->state = SSL3_ST_CR_KEY_EXCH_A; } else { skip = 1; s->state = SSL3_ST_CR_KEY_EXCH_A; } s->init_num = 0; break; case SSL3_ST_CR_KEY_EXCH_A: case SSL3_ST_CR_KEY_EXCH_B: ret = ssl3_get_key_exchange(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_CERT_REQ_A; s->init_num = 0; if (!ssl3_check_cert_and_algorithm(s)) { ret = -1; s->state = SSL_ST_ERR; goto end; } break; case SSL3_ST_CR_CERT_REQ_A: case SSL3_ST_CR_CERT_REQ_B: ret = ssl3_get_certificate_request(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_SRVR_DONE_A; s->init_num = 0; break; case SSL3_ST_CR_SRVR_DONE_A: case SSL3_ST_CR_SRVR_DONE_B: ret = ssl3_get_server_done(s); if (ret <= 0) goto end; <S2SV_StartVul> #ifndef OPENSSL_NO_SRP <S2SV_EndVul> <S2SV_StartVul> if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) { <S2SV_EndVul> <S2SV_StartVul> if ((ret = SRP_Calc_A_param(s)) <= 0) { <S2SV_EndVul> <S2SV_StartVul> SSLerr(SSL_F_SSL3_CONNECT, SSL_R_SRP_A_CALC); <S2SV_EndVul> <S2SV_StartVul> ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR); <S2SV_EndVul> <S2SV_StartVul> s->state = SSL_ST_ERR; <S2SV_EndVul> <S2SV_StartVul> goto end; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> if (s->s3->tmp.cert_req) s->state = SSL3_ST_CW_CERT_A; else s->state = SSL3_ST_CW_KEY_EXCH_A; s->init_num = 0; break; case SSL3_ST_CW_CERT_A: case SSL3_ST_CW_CERT_B: case SSL3_ST_CW_CERT_C: case SSL3_ST_CW_CERT_D: ret = ssl3_send_client_certificate(s); if (ret <= 0) goto end; s->state = SSL3_ST_CW_KEY_EXCH_A; s->init_num = 0; break; case SSL3_ST_CW_KEY_EXCH_A: case SSL3_ST_CW_KEY_EXCH_B: ret = ssl3_send_client_key_exchange(s); if (ret <= 0) goto end; if (s->s3->tmp.cert_req == 1) { s->state = SSL3_ST_CW_CERT_VRFY_A; } else { s->state = SSL3_ST_CW_CHANGE_A; } if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) { s->state = SSL3_ST_CW_CHANGE_A; } s->init_num = 0; break; case SSL3_ST_CW_CERT_VRFY_A: case SSL3_ST_CW_CERT_VRFY_B: ret = ssl3_send_client_verify(s); if (ret <= 0) goto end; s->state = SSL3_ST_CW_CHANGE_A; s->init_num = 0; break; case SSL3_ST_CW_CHANGE_A: case SSL3_ST_CW_CHANGE_B: ret = ssl3_send_change_cipher_spec(s, SSL3_ST_CW_CHANGE_A, SSL3_ST_CW_CHANGE_B); if (ret <= 0) goto end; #if defined(OPENSSL_NO_NEXTPROTONEG) s->state = SSL3_ST_CW_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->state = SSL3_ST_CW_NEXT_PROTO_A; else s->state = SSL3_ST_CW_FINISHED_A; #endif s->init_num = 0; s->session->cipher = s->s3->tmp.new_cipher; #ifdef OPENSSL_NO_COMP s->session->compress_meth = 0; #else if (s->s3->tmp.new_compression == NULL) s->session->compress_meth = 0; else s->session->compress_meth = s->s3->tmp.new_compression->id; #endif if (!s->method->ssl3_enc->setup_key_block(s)) { ret = -1; s->state = SSL_ST_ERR; goto end; } if (!s->method->ssl3_enc->change_cipher_state(s, SSL3_CHANGE_CIPHER_CLIENT_WRITE)) { ret = -1; s->state = SSL_ST_ERR; goto end; } break; #if !defined(OPENSSL_NO_NEXTPROTONEG) case SSL3_ST_CW_NEXT_PROTO_A: case SSL3_ST_CW_NEXT_PROTO_B: ret = ssl3_send_next_proto(s); if (ret <= 0) goto end; s->state = SSL3_ST_CW_FINISHED_A; break; #endif case SSL3_ST_CW_FINISHED_A: case SSL3_ST_CW_FINISHED_B: ret = ssl3_send_finished(s, SSL3_ST_CW_FINISHED_A, SSL3_ST_CW_FINISHED_B, s->method-> ssl3_enc->client_finished_label, s->method-> ssl3_enc->client_finished_label_len); if (ret <= 0) goto end; s->state = SSL3_ST_CW_FLUSH; if (s->hit) { s->s3->tmp.next_state = SSL_ST_OK; } else { if (s->tlsext_ticket_expected) s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A; else s->s3->tmp.next_state = SSL3_ST_CR_CHANGE_A; } s->init_num = 0; break; case SSL3_ST_CR_SESSION_TICKET_A: case SSL3_ST_CR_SESSION_TICKET_B: ret = ssl3_get_new_session_ticket(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_CHANGE_A; s->init_num = 0; break; case SSL3_ST_CR_CERT_STATUS_A: case SSL3_ST_CR_CERT_STATUS_B: ret = ssl3_get_cert_status(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_KEY_EXCH_A; s->init_num = 0; break; case SSL3_ST_CR_CHANGE_A: case SSL3_ST_CR_CHANGE_B: ret = ssl3_get_change_cipher_spec(s, SSL3_ST_CR_CHANGE_A, SSL3_ST_CR_CHANGE_B); if (ret <= 0) goto end; s->state = SSL3_ST_CR_FINISHED_A; s->init_num = 0; break; case SSL3_ST_CR_FINISHED_A: case SSL3_ST_CR_FINISHED_B: ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A, SSL3_ST_CR_FINISHED_B); if (ret <= 0) goto end; if (s->hit) s->state = SSL3_ST_CW_CHANGE_A; else s->state = SSL_ST_OK; s->init_num = 0; break; case SSL3_ST_CW_FLUSH: s->rwstate = SSL_WRITING; if (BIO_flush(s->wbio) <= 0) { ret = -1; goto end; } s->rwstate = SSL_NOTHING; s->state = s->s3->tmp.next_state; break; case SSL_ST_OK: ssl3_cleanup_key_block(s); BUF_MEM_free(s->init_buf); s->init_buf = NULL; ssl_free_wbio_buffer(s); s->init_num = 0; s->renegotiate = 0; s->new_session = 0; ssl_update_cache(s, SSL_SESS_CACHE_CLIENT); if (s->hit) s->ctx->stats.sess_hit++; ret = 1; s->handshake_func = ssl3_connect; s->ctx->stats.sess_connect_good++; if (cb != NULL) cb(s, SSL_CB_HANDSHAKE_DONE, 1); goto end; case SSL_ST_ERR: default: SSLerr(SSL_F_SSL3_CONNECT, SSL_R_UNKNOWN_STATE); ret = -1; goto end; } if (!s->s3->tmp.reuse_message && !skip) { if (s->debug) { if ((ret = BIO_flush(s->wbio)) <= 0) goto end; } if ((cb != NULL) && (s->state != state)) { new_state = s->state; s->state = state; cb(s, SSL_CB_CONNECT_LOOP, 1); s->state = new_state; } } skip = 0; } end: s->in_handshake--; BUF_MEM_free(buf); if (cb != NULL) cb(s, SSL_CB_CONNECT_EXIT, ret); return (ret); }","- #ifndef OPENSSL_NO_SRP
- if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {
- if ((ret = SRP_Calc_A_param(s)) <= 0) {
- SSLerr(SSL_F_SSL3_CONNECT, SSL_R_SRP_A_CALC);
- ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
- s->state = SSL_ST_ERR;
- goto end;
- }
- }
- #endif","int ssl3_connect(SSL *s) { BUF_MEM *buf = NULL; unsigned long Time = (unsigned long)time(NULL); void (*cb) (const SSL *ssl, int type, int val) = NULL; int ret = -1; int new_state, state, skip = 0; RAND_add(&Time, sizeof(Time), 0); ERR_clear_error(); clear_sys_error(); if (s->info_callback != NULL) cb = s->info_callback; else if (s->ctx->info_callback != NULL) cb = s->ctx->info_callback; s->in_handshake++; if (!SSL_in_init(s) || SSL_in_before(s)) { if (!SSL_clear(s)) return -1; } #ifndef OPENSSL_NO_HEARTBEATS if (s->tlsext_hb_pending) { s->tlsext_hb_pending = 0; s->tlsext_hb_seq++; } #endif for (;;) { state = s->state; switch (s->state) { case SSL_ST_RENEGOTIATE: s->renegotiate = 1; s->state = SSL_ST_CONNECT; s->ctx->stats.sess_connect_renegotiate++; case SSL_ST_BEFORE: case SSL_ST_CONNECT: case SSL_ST_BEFORE | SSL_ST_CONNECT: case SSL_ST_OK | SSL_ST_CONNECT: s->server = 0; if (cb != NULL) cb(s, SSL_CB_HANDSHAKE_START, 1); if ((s->version >> 8) != SSL3_VERSION_MAJOR && s->version != TLS_ANY_VERSION) { SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR); s->state = SSL_ST_ERR; ret = -1; goto end; } if (s->version != TLS_ANY_VERSION && !ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) { SSLerr(SSL_F_SSL3_CONNECT, SSL_R_VERSION_TOO_LOW); return -1; } s->type = SSL_ST_CONNECT; if (s->init_buf == NULL) { if ((buf = BUF_MEM_new()) == NULL) { ret = -1; s->state = SSL_ST_ERR; goto end; } if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) { ret = -1; s->state = SSL_ST_ERR; goto end; } s->init_buf = buf; buf = NULL; } if (!ssl3_setup_buffers(s)) { ret = -1; goto end; } if (!ssl_init_wbio_buffer(s, 0)) { ret = -1; s->state = SSL_ST_ERR; goto end; } ssl3_init_finished_mac(s); s->state = SSL3_ST_CW_CLNT_HELLO_A; s->ctx->stats.sess_connect++; s->init_num = 0; s->s3->change_cipher_spec = 0; break; case SSL3_ST_CW_CLNT_HELLO_A: case SSL3_ST_CW_CLNT_HELLO_B: s->shutdown = 0; ret = ssl3_client_hello(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_SRVR_HELLO_A; s->init_num = 0; if (s->bbio != s->wbio) s->wbio = BIO_push(s->bbio, s->wbio); break; case SSL3_ST_CR_SRVR_HELLO_A: case SSL3_ST_CR_SRVR_HELLO_B: ret = ssl3_get_server_hello(s); if (ret <= 0) goto end; if (s->hit) { s->state = SSL3_ST_CR_CHANGE_A; if (s->tlsext_ticket_expected) { s->state = SSL3_ST_CR_SESSION_TICKET_A; } } else { s->state = SSL3_ST_CR_CERT_A; } s->init_num = 0; break; case SSL3_ST_CR_CERT_A: case SSL3_ST_CR_CERT_B: ret = ssl3_check_change(s); if (ret < 0) goto end; if (ret == 1) { s->hit = 1; s->state = SSL3_ST_CR_CHANGE_A; s->init_num = 0; break; } if (!(s->s3->tmp.new_cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) { ret = ssl3_get_server_certificate(s); if (ret <= 0) goto end; if (s->tlsext_status_expected) s->state = SSL3_ST_CR_CERT_STATUS_A; else s->state = SSL3_ST_CR_KEY_EXCH_A; } else { skip = 1; s->state = SSL3_ST_CR_KEY_EXCH_A; } s->init_num = 0; break; case SSL3_ST_CR_KEY_EXCH_A: case SSL3_ST_CR_KEY_EXCH_B: ret = ssl3_get_key_exchange(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_CERT_REQ_A; s->init_num = 0; if (!ssl3_check_cert_and_algorithm(s)) { ret = -1; s->state = SSL_ST_ERR; goto end; } break; case SSL3_ST_CR_CERT_REQ_A: case SSL3_ST_CR_CERT_REQ_B: ret = ssl3_get_certificate_request(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_SRVR_DONE_A; s->init_num = 0; break; case SSL3_ST_CR_SRVR_DONE_A: case SSL3_ST_CR_SRVR_DONE_B: ret = ssl3_get_server_done(s); if (ret <= 0) goto end; if (s->s3->tmp.cert_req) s->state = SSL3_ST_CW_CERT_A; else s->state = SSL3_ST_CW_KEY_EXCH_A; s->init_num = 0; break; case SSL3_ST_CW_CERT_A: case SSL3_ST_CW_CERT_B: case SSL3_ST_CW_CERT_C: case SSL3_ST_CW_CERT_D: ret = ssl3_send_client_certificate(s); if (ret <= 0) goto end; s->state = SSL3_ST_CW_KEY_EXCH_A; s->init_num = 0; break; case SSL3_ST_CW_KEY_EXCH_A: case SSL3_ST_CW_KEY_EXCH_B: ret = ssl3_send_client_key_exchange(s); if (ret <= 0) goto end; if (s->s3->tmp.cert_req == 1) { s->state = SSL3_ST_CW_CERT_VRFY_A; } else { s->state = SSL3_ST_CW_CHANGE_A; } if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) { s->state = SSL3_ST_CW_CHANGE_A; } s->init_num = 0; break; case SSL3_ST_CW_CERT_VRFY_A: case SSL3_ST_CW_CERT_VRFY_B: ret = ssl3_send_client_verify(s); if (ret <= 0) goto end; s->state = SSL3_ST_CW_CHANGE_A; s->init_num = 0; break; case SSL3_ST_CW_CHANGE_A: case SSL3_ST_CW_CHANGE_B: ret = ssl3_send_change_cipher_spec(s, SSL3_ST_CW_CHANGE_A, SSL3_ST_CW_CHANGE_B); if (ret <= 0) goto end; #if defined(OPENSSL_NO_NEXTPROTONEG) s->state = SSL3_ST_CW_FINISHED_A; #else if (s->s3->next_proto_neg_seen) s->state = SSL3_ST_CW_NEXT_PROTO_A; else s->state = SSL3_ST_CW_FINISHED_A; #endif s->init_num = 0; s->session->cipher = s->s3->tmp.new_cipher; #ifdef OPENSSL_NO_COMP s->session->compress_meth = 0; #else if (s->s3->tmp.new_compression == NULL) s->session->compress_meth = 0; else s->session->compress_meth = s->s3->tmp.new_compression->id; #endif if (!s->method->ssl3_enc->setup_key_block(s)) { ret = -1; s->state = SSL_ST_ERR; goto end; } if (!s->method->ssl3_enc->change_cipher_state(s, SSL3_CHANGE_CIPHER_CLIENT_WRITE)) { ret = -1; s->state = SSL_ST_ERR; goto end; } break; #if !defined(OPENSSL_NO_NEXTPROTONEG) case SSL3_ST_CW_NEXT_PROTO_A: case SSL3_ST_CW_NEXT_PROTO_B: ret = ssl3_send_next_proto(s); if (ret <= 0) goto end; s->state = SSL3_ST_CW_FINISHED_A; break; #endif case SSL3_ST_CW_FINISHED_A: case SSL3_ST_CW_FINISHED_B: ret = ssl3_send_finished(s, SSL3_ST_CW_FINISHED_A, SSL3_ST_CW_FINISHED_B, s->method-> ssl3_enc->client_finished_label, s->method-> ssl3_enc->client_finished_label_len); if (ret <= 0) goto end; s->state = SSL3_ST_CW_FLUSH; if (s->hit) { s->s3->tmp.next_state = SSL_ST_OK; } else { if (s->tlsext_ticket_expected) s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A; else s->s3->tmp.next_state = SSL3_ST_CR_CHANGE_A; } s->init_num = 0; break; case SSL3_ST_CR_SESSION_TICKET_A: case SSL3_ST_CR_SESSION_TICKET_B: ret = ssl3_get_new_session_ticket(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_CHANGE_A; s->init_num = 0; break; case SSL3_ST_CR_CERT_STATUS_A: case SSL3_ST_CR_CERT_STATUS_B: ret = ssl3_get_cert_status(s); if (ret <= 0) goto end; s->state = SSL3_ST_CR_KEY_EXCH_A; s->init_num = 0; break; case SSL3_ST_CR_CHANGE_A: case SSL3_ST_CR_CHANGE_B: ret = ssl3_get_change_cipher_spec(s, SSL3_ST_CR_CHANGE_A, SSL3_ST_CR_CHANGE_B); if (ret <= 0) goto end; s->state = SSL3_ST_CR_FINISHED_A; s->init_num = 0; break; case SSL3_ST_CR_FINISHED_A: case SSL3_ST_CR_FINISHED_B: ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A, SSL3_ST_CR_FINISHED_B); if (ret <= 0) goto end; if (s->hit) s->state = SSL3_ST_CW_CHANGE_A; else s->state = SSL_ST_OK; s->init_num = 0; break; case SSL3_ST_CW_FLUSH: s->rwstate = SSL_WRITING; if (BIO_flush(s->wbio) <= 0) { ret = -1; goto end; } s->rwstate = SSL_NOTHING; s->state = s->s3->tmp.next_state; break; case SSL_ST_OK: ssl3_cleanup_key_block(s); BUF_MEM_free(s->init_buf); s->init_buf = NULL; ssl_free_wbio_buffer(s); s->init_num = 0; s->renegotiate = 0; s->new_session = 0; ssl_update_cache(s, SSL_SESS_CACHE_CLIENT); if (s->hit) s->ctx->stats.sess_hit++; ret = 1; s->handshake_func = ssl3_connect; s->ctx->stats.sess_connect_good++; if (cb != NULL) cb(s, SSL_CB_HANDSHAKE_DONE, 1); goto end; case SSL_ST_ERR: default: SSLerr(SSL_F_SSL3_CONNECT, SSL_R_UNKNOWN_STATE); ret = -1; goto end; } if (!s->s3->tmp.reuse_message && !skip) { if (s->debug) { if ((ret = BIO_flush(s->wbio)) <= 0) goto end; } if ((cb != NULL) && (s->state != state)) { new_state = s->state; s->state = state; cb(s, SSL_CB_CONNECT_LOOP, 1); s->state = new_state; } } skip = 0; } end: s->in_handshake--; BUF_MEM_free(buf); if (cb != NULL) cb(s, SSL_CB_CONNECT_EXIT, ret); return (ret); }"
9838----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_01e4c51254c7bbda573a0868f5e9050437a8c7f1_1.json----ngx_http_upstream_process_request,"static void ngx_http_upstream_process_request(ngx_http_request_t *r) { <S2SV_StartVul> ngx_uint_t del; <S2SV_EndVul> ngx_temp_file_t *tf; ngx_event_pipe_t *p; ngx_http_upstream_t *u; u = r->upstream; p = u->pipe; if (u->peer.connection) { if (u->store) { <S2SV_StartVul> del = p->upstream_error; <S2SV_EndVul> <S2SV_StartVul> tf = u->pipe->temp_file; <S2SV_EndVul> if (p->upstream_eof || p->upstream_done) { if (u->headers_in.status_n == NGX_HTTP_OK && (u->headers_in.content_length_n == -1 || (u->headers_in.content_length_n == tf->offset))) { ngx_http_upstream_store(r, u); <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> del = 1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (del && tf->file.fd != NGX_INVALID_FILE) { <S2SV_EndVul> <S2SV_StartVul> if (ngx_delete_file(tf->file.name.data) == NGX_FILE_ERROR) { <S2SV_EndVul> <S2SV_StartVul> ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, <S2SV_EndVul> <S2SV_StartVul> ngx_delete_file_n "" \""%s\"" failed"", <S2SV_EndVul> <S2SV_StartVul> u->pipe->temp_file->file.name.data); <S2SV_EndVul> } } } #if (NGX_HTTP_CACHE) if (u->cacheable) { if (p->upstream_done) { ngx_http_file_cache_update(r, u->pipe->temp_file); } else if (p->upstream_eof) { tf = u->pipe->temp_file; if (u->headers_in.content_length_n == -1 || u->headers_in.content_length_n == tf->offset - (off_t) r->cache->body_start) { ngx_http_file_cache_update(r, tf); } else { ngx_http_file_cache_free(r->cache, tf); } } else if (p->upstream_error) { ngx_http_file_cache_free(r->cache, u->pipe->temp_file); } } #endif if (p->upstream_done || p->upstream_eof || p->upstream_error) { ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream exit: %p"", p->out); #if 0 ngx_http_busy_unlock(u->conf->busy_lock, &u->busy_lock); #endif ngx_http_upstream_finalize_request(r, u, 0); return; } } if (p->downstream_error) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream downstream error""); if (!u->cacheable && !u->store && u->peer.connection) { ngx_http_upstream_finalize_request(r, u, 0); } } }","- ngx_uint_t del;
- del = p->upstream_error;
- tf = u->pipe->temp_file;
- } else {
- del = 1;
- }
- }
- if (del && tf->file.fd != NGX_INVALID_FILE) {
- if (ngx_delete_file(tf->file.name.data) == NGX_FILE_ERROR) {
- ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,
- ngx_delete_file_n "" \""%s\"" failed"",
- u->pipe->temp_file->file.name.data);
+ tf = u->pipe->temp_file;
+ u->store = 0;","static void ngx_http_upstream_process_request(ngx_http_request_t *r) { ngx_temp_file_t *tf; ngx_event_pipe_t *p; ngx_http_upstream_t *u; u = r->upstream; p = u->pipe; if (u->peer.connection) { if (u->store) { if (p->upstream_eof || p->upstream_done) { tf = u->pipe->temp_file; if (u->headers_in.status_n == NGX_HTTP_OK && (u->headers_in.content_length_n == -1 || (u->headers_in.content_length_n == tf->offset))) { ngx_http_upstream_store(r, u); u->store = 0; } } } #if (NGX_HTTP_CACHE) if (u->cacheable) { if (p->upstream_done) { ngx_http_file_cache_update(r, u->pipe->temp_file); } else if (p->upstream_eof) { tf = u->pipe->temp_file; if (u->headers_in.content_length_n == -1 || u->headers_in.content_length_n == tf->offset - (off_t) r->cache->body_start) { ngx_http_file_cache_update(r, tf); } else { ngx_http_file_cache_free(r->cache, tf); } } else if (p->upstream_error) { ngx_http_file_cache_free(r->cache, u->pipe->temp_file); } } #endif if (p->upstream_done || p->upstream_eof || p->upstream_error) { ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream exit: %p"", p->out); #if 0 ngx_http_busy_unlock(u->conf->busy_lock, &u->busy_lock); #endif ngx_http_upstream_finalize_request(r, u, 0); return; } } if (p->downstream_error) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream downstream error""); if (!u->cacheable && !u->store && u->peer.connection) { ngx_http_upstream_finalize_request(r, u, 0); } } }"
1126----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3df2b2de10ce93fea4b9653852e250154d91ac0c_1.json----tee_write_trailer,"static int tee_write_trailer(AVFormatContext *avf) { TeeContext *tee = avf->priv_data; <S2SV_StartVul> AVFormatContext *avf2; <S2SV_EndVul> int ret_all = 0, ret; unsigned i; for (i = 0; i < tee->nb_slaves; i++) { <S2SV_StartVul> avf2 = tee->slaves[i].avf; <S2SV_EndVul> <S2SV_StartVul> if ((ret = av_write_trailer(avf2)) < 0) <S2SV_EndVul> if (!ret_all) ret_all = ret; <S2SV_StartVul> if (!(avf2->oformat->flags & AVFMT_NOFILE)) <S2SV_EndVul> <S2SV_StartVul> ff_format_io_close(avf2, &avf2->pb); <S2SV_EndVul> } <S2SV_StartVul> close_slaves(avf); <S2SV_EndVul> return ret_all; }","- AVFormatContext *avf2;
- avf2 = tee->slaves[i].avf;
- if ((ret = av_write_trailer(avf2)) < 0)
- if (!(avf2->oformat->flags & AVFMT_NOFILE))
- ff_format_io_close(avf2, &avf2->pb);
- close_slaves(avf);
+ if ((ret = close_slave(&tee->slaves[i])) < 0)","static int tee_write_trailer(AVFormatContext *avf) { TeeContext *tee = avf->priv_data; int ret_all = 0, ret; unsigned i; for (i = 0; i < tee->nb_slaves; i++) { if ((ret = close_slave(&tee->slaves[i])) < 0) if (!ret_all) ret_all = ret; } return ret_all; }"
2627----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_8fdbf9229c9c41870deb575966de3e6367de0c19_1.json----ftp_abort,"static int ftp_abort(URLContext *h) { static const char *command = ""ABOR\r\n""; int err; static const int abor_codes[] = {225, 226, 0}; FTPContext *s = h->priv_data; if (ftp_send_command(s, command, NULL, NULL) < 0) { ftp_close_both_connections(s); if ((err = ftp_connect_control_connection(h)) < 0) { av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n""); return err; } } else { ftp_close_data_connection(s); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (ftp_status(s, NULL, abor_codes) < 225) { <S2SV_EndVul> <S2SV_StartVul> ffurl_closep(&s->conn_control); <S2SV_EndVul> <S2SV_StartVul> if ((err = ftp_connect_control_connection(h)) < 0) { <S2SV_EndVul> <S2SV_StartVul> av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n""); <S2SV_EndVul> <S2SV_StartVul> return err; <S2SV_EndVul> } } return 0; }","- }
- if (ftp_status(s, NULL, abor_codes) < 225) {
- ffurl_closep(&s->conn_control);
- if ((err = ftp_connect_control_connection(h)) < 0) {
- av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n"");
- return err;
+ if (ftp_status(s, NULL, abor_codes) < 225) {
+ ffurl_closep(&s->conn_control);
+ if ((err = ftp_connect_control_connection(h)) < 0) {
+ av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n"");
+ return err;
+ }","static int ftp_abort(URLContext *h) { static const char *command = ""ABOR\r\n""; int err; static const int abor_codes[] = {225, 226, 0}; FTPContext *s = h->priv_data; if (ftp_send_command(s, command, NULL, NULL) < 0) { ftp_close_both_connections(s); if ((err = ftp_connect_control_connection(h)) < 0) { av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n""); return err; } } else { ftp_close_data_connection(s); if (ftp_status(s, NULL, abor_codes) < 225) { ffurl_closep(&s->conn_control); if ((err = ftp_connect_control_connection(h)) < 0) { av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n""); return err; } } } return 0; }"
713----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_26fb1b43b41aa953643242b75bfff1ca03e802d4_1.json----shorten_decode_frame,"static int shorten_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; ShortenContext *s = avctx->priv_data; int i, input_buf_size = 0; int16_t *samples = data; if(s->max_framesize == 0){ s->max_framesize= 1024; <S2SV_StartVul> s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize); <S2SV_EndVul> } if(1 && s->max_framesize){ buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size); input_buf_size= buf_size; if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){ memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size); s->bitstream_index=0; } memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size); buf= &s->bitstream[s->bitstream_index]; buf_size += s->bitstream_size; s->bitstream_size= buf_size; if(buf_size < s->max_framesize){ *data_size = 0; return input_buf_size; } } init_get_bits(&s->gb, buf, buf_size*8); skip_bits(&s->gb, s->bitindex); if (!s->blocksize) { int ret; if ((ret = read_header(s)) < 0) return ret; *data_size = 0; } else { int cmd; int len; cmd = get_ur_golomb_shorten(&s->gb, FNSIZE); if (cmd > FN_VERBATIM) { av_log(avctx, AV_LOG_ERROR, ""unknown shorten function %d\n"", cmd); if (s->bitstream_size > 0) { s->bitstream_index++; s->bitstream_size--; } return -1; } if (!is_audio_command[cmd]) { switch (cmd) { case FN_VERBATIM: len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE); while (len--) { get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE); } break; case FN_BITSHIFT: s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE); break; case FN_BLOCKSIZE: { int blocksize = get_uint(s, av_log2(s->blocksize)); if (blocksize > s->blocksize) { av_log(avctx, AV_LOG_ERROR, ""Increasing block size is not supported\n""); return AVERROR_PATCHWELCOME; } s->blocksize = blocksize; break; } case FN_QUIT: break; } *data_size = 0; } else { int ret; int residual_size = 0; int channel = s->cur_chan; int32_t coffset; if (cmd != FN_ZERO) { residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE); if (s->version == 0) residual_size--; } if (s->nmean == 0) coffset = s->offset[channel][0]; else { int32_t sum = (s->version < 2) ? 0 : s->nmean / 2; for (i=0; i<s->nmean; i++) sum += s->offset[channel][i]; coffset = sum / s->nmean; if (s->version >= 2) coffset >>= FFMIN(1, s->bitshift); } switch (cmd) { case FN_ZERO: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = 0; break; case FN_DIFF0: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + coffset; break; case FN_DIFF1: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + s->decoded[channel][i - 1]; break; case FN_DIFF2: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 2*s->decoded[channel][i-1] - s->decoded[channel][i-2]; break; case FN_DIFF3: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 3*s->decoded[channel][i-1] - 3*s->decoded[channel][i-2] + s->decoded[channel][i-3]; break; case FN_QLPC: if ((ret = decode_subframe_lpc(s, channel, residual_size, coffset)) < 0) return ret; break; } if (s->nmean > 0) { int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2; for (i=0; i<s->blocksize; i++) sum += s->decoded[channel][i]; for (i=1; i<s->nmean; i++) s->offset[channel][i-1] = s->offset[channel][i]; if (s->version < 2) s->offset[channel][s->nmean - 1] = sum / s->blocksize; else s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift; } for (i=-s->nwrap; i<0; i++) s->decoded[channel][i] = s->decoded[channel][i + s->blocksize]; fix_bitshift(s, s->decoded[channel]); s->cur_chan++; if (s->cur_chan == s->channels) { samples = interleave_buffer(samples, s->channels, s->blocksize, s->decoded); s->cur_chan = 0; *data_size = (int8_t *)samples - (int8_t *)data; } else { *data_size = 0; } } } s->bitindex = get_bits_count(&s->gb) - 8*((get_bits_count(&s->gb))/8); i= (get_bits_count(&s->gb))/8; if (i > buf_size) { av_log(s->avctx, AV_LOG_ERROR, ""overread: %d\n"", i - buf_size); s->bitstream_size=0; s->bitstream_index=0; return -1; } if (s->bitstream_size) { s->bitstream_index += i; s->bitstream_size -= i; return input_buf_size; } else return i; }","- s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);
+ void *tmp_ptr;
+ tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,
+ s->max_framesize);
+ if (!tmp_ptr) {
+ av_log(avctx, AV_LOG_ERROR, ""error allocating bitstream buffer\n"");
+ return AVERROR(ENOMEM);
+ }
+ s->bitstream = tmp_ptr;","static int shorten_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; ShortenContext *s = avctx->priv_data; int i, input_buf_size = 0; int16_t *samples = data; if(s->max_framesize == 0){ void *tmp_ptr; s->max_framesize= 1024; tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize); if (!tmp_ptr) { av_log(avctx, AV_LOG_ERROR, ""error allocating bitstream buffer\n""); return AVERROR(ENOMEM); } s->bitstream = tmp_ptr; } if(1 && s->max_framesize){ buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size); input_buf_size= buf_size; if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){ memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size); s->bitstream_index=0; } memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size); buf= &s->bitstream[s->bitstream_index]; buf_size += s->bitstream_size; s->bitstream_size= buf_size; if(buf_size < s->max_framesize){ *data_size = 0; return input_buf_size; } } init_get_bits(&s->gb, buf, buf_size*8); skip_bits(&s->gb, s->bitindex); if (!s->blocksize) { int ret; if ((ret = read_header(s)) < 0) return ret; *data_size = 0; } else { int cmd; int len; cmd = get_ur_golomb_shorten(&s->gb, FNSIZE); if (cmd > FN_VERBATIM) { av_log(avctx, AV_LOG_ERROR, ""unknown shorten function %d\n"", cmd); if (s->bitstream_size > 0) { s->bitstream_index++; s->bitstream_size--; } return -1; } if (!is_audio_command[cmd]) { switch (cmd) { case FN_VERBATIM: len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE); while (len--) { get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE); } break; case FN_BITSHIFT: s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE); break; case FN_BLOCKSIZE: { int blocksize = get_uint(s, av_log2(s->blocksize)); if (blocksize > s->blocksize) { av_log(avctx, AV_LOG_ERROR, ""Increasing block size is not supported\n""); return AVERROR_PATCHWELCOME; } s->blocksize = blocksize; break; } case FN_QUIT: break; } *data_size = 0; } else { int ret; int residual_size = 0; int channel = s->cur_chan; int32_t coffset; if (cmd != FN_ZERO) { residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE); if (s->version == 0) residual_size--; } if (s->nmean == 0) coffset = s->offset[channel][0]; else { int32_t sum = (s->version < 2) ? 0 : s->nmean / 2; for (i=0; i<s->nmean; i++) sum += s->offset[channel][i]; coffset = sum / s->nmean; if (s->version >= 2) coffset >>= FFMIN(1, s->bitshift); } switch (cmd) { case FN_ZERO: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = 0; break; case FN_DIFF0: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + coffset; break; case FN_DIFF1: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + s->decoded[channel][i - 1]; break; case FN_DIFF2: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 2*s->decoded[channel][i-1] - s->decoded[channel][i-2]; break; case FN_DIFF3: for (i=0; i<s->blocksize; i++) s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 3*s->decoded[channel][i-1] - 3*s->decoded[channel][i-2] + s->decoded[channel][i-3]; break; case FN_QLPC: if ((ret = decode_subframe_lpc(s, channel, residual_size, coffset)) < 0) return ret; break; } if (s->nmean > 0) { int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2; for (i=0; i<s->blocksize; i++) sum += s->decoded[channel][i]; for (i=1; i<s->nmean; i++) s->offset[channel][i-1] = s->offset[channel][i]; if (s->version < 2) s->offset[channel][s->nmean - 1] = sum / s->blocksize; else s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift; } for (i=-s->nwrap; i<0; i++) s->decoded[channel][i] = s->decoded[channel][i + s->blocksize]; fix_bitshift(s, s->decoded[channel]); s->cur_chan++; if (s->cur_chan == s->channels) { samples = interleave_buffer(samples, s->channels, s->blocksize, s->decoded); s->cur_chan = 0; *data_size = (int8_t *)samples - (int8_t *)data; } else { *data_size = 0; } } } s->bitindex = get_bits_count(&s->gb) - 8*((get_bits_count(&s->gb))/8); i= (get_bits_count(&s->gb))/8; if (i > buf_size) { av_log(s->avctx, AV_LOG_ERROR, ""overread: %d\n"", i - buf_size); s->bitstream_size=0; s->bitstream_index=0; return -1; } if (s->bitstream_size) { s->bitstream_index += i; s->bitstream_size -= i; return input_buf_size; } else return i; }"
4478----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f29c31e72d03faeb12180d3ab697035441214e66_1.json----ff_rv34_decode_frame,"int ff_rv34_decode_frame(AVCodecContext *avctx, void *data, int *got_picture_ptr, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; RV34DecContext *r = avctx->priv_data; MpegEncContext *s = &r->s; AVFrame *pict = data; SliceInfo si; int i, ret; int slice_count; const uint8_t *slices_hdr = NULL; int last = 0; if (buf_size == 0) { if (s->low_delay==0 && s->next_picture_ptr) { <S2SV_StartVul> if ((ret = av_frame_ref(pict, &s->next_picture_ptr->f)) < 0) <S2SV_EndVul> return ret; s->next_picture_ptr = NULL; *got_picture_ptr = 1; } return 0; } if(!avctx->slice_count){ slice_count = (*buf++) + 1; slices_hdr = buf + 4; buf += 8 * slice_count; buf_size -= 1 + 8 * slice_count; }else slice_count = avctx->slice_count; if(get_slice_offset(avctx, slices_hdr, 0) < 0 || get_slice_offset(avctx, slices_hdr, 0) > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is invalid\n""); return AVERROR_INVALIDDATA; } init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8); if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){ av_log(avctx, AV_LOG_ERROR, ""First slice header is incorrect\n""); return AVERROR_INVALIDDATA; } <S2SV_StartVul> if ((!s->last_picture_ptr || !s->last_picture_ptr->f.data[0]) && <S2SV_EndVul> si.type == AV_PICTURE_TYPE_B) { av_log(avctx, AV_LOG_ERROR, ""Invalid decoder state: B-frame without "" ""reference data.\n""); return AVERROR_INVALIDDATA; } if( (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B) || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) return avpkt->size; if (si.start == 0) { if (s->mb_num_left > 0) { av_log(avctx, AV_LOG_ERROR, ""New frame but still %d MB left."", s->mb_num_left); ff_er_frame_end(&s->er); ff_MPV_frame_end(s); } if (s->width != si.width || s->height != si.height) { int err; av_log(s->avctx, AV_LOG_WARNING, ""Changing dimensions to %dx%d\n"", si.width, si.height); s->width = si.width; s->height = si.height; err = ff_set_dimensions(s->avctx, s->width, s->height); if (err < 0) return err; if ((err = ff_MPV_common_frame_size_change(s)) < 0) return err; if ((err = rv34_decoder_realloc(r)) < 0) return err; } s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I; if (ff_MPV_frame_start(s, s->avctx) < 0) return -1; ff_mpeg_er_frame_start(s); if (!r->tmp_b_block_base) { int i; r->tmp_b_block_base = av_malloc(s->linesize * 48); for (i = 0; i < 2; i++) r->tmp_b_block_y[i] = r->tmp_b_block_base + i * 16 * s->linesize; for (i = 0; i < 4; i++) r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize + (i >> 1) * 8 * s->uvlinesize + (i & 1) * 16; } r->cur_pts = si.pts; if (s->pict_type != AV_PICTURE_TYPE_B) { r->last_pts = r->next_pts; r->next_pts = r->cur_pts; } else { int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts); int dist0 = GET_PTS_DIFF(r->cur_pts, r->last_pts); int dist1 = GET_PTS_DIFF(r->next_pts, r->cur_pts); if(!refdist){ r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192; r->scaled_weight = 0; }else{ r->mv_weight1 = (dist0 << 14) / refdist; r->mv_weight2 = (dist1 << 14) / refdist; if((r->mv_weight1|r->mv_weight2) & 511){ r->weight1 = r->mv_weight1; r->weight2 = r->mv_weight2; r->scaled_weight = 0; }else{ r->weight1 = r->mv_weight1 >> 9; r->weight2 = r->mv_weight2 >> 9; r->scaled_weight = 1; } } } s->mb_x = s->mb_y = 0; ff_thread_finish_setup(s->avctx); } else if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) { av_log(s->avctx, AV_LOG_ERROR, ""Decoder needs full frames in frame "" ""multithreading mode (start MB is %d).\n"", si.start); return AVERROR_INVALIDDATA; } for(i = 0; i < slice_count; i++){ int offset = get_slice_offset(avctx, slices_hdr, i); int size; if(i+1 == slice_count) size = buf_size - offset; else size = get_slice_offset(avctx, slices_hdr, i+1) - offset; if(offset < 0 || offset > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is invalid\n""); break; } r->si.end = s->mb_width * s->mb_height; s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start; if(i+1 < slice_count){ if (get_slice_offset(avctx, slices_hdr, i+1) < 0 || get_slice_offset(avctx, slices_hdr, i+1) > buf_size) { av_log(avctx, AV_LOG_ERROR, ""Slice offset is invalid\n""); break; } init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8); if(r->parse_slice_header(r, &r->s.gb, &si) < 0){ if(i+2 < slice_count) size = get_slice_offset(avctx, slices_hdr, i+2) - offset; else size = buf_size - offset; }else r->si.end = si.start; } if (size < 0 || size > buf_size - offset) { av_log(avctx, AV_LOG_ERROR, ""Slice size is invalid\n""); break; } last = rv34_decode_slice(r, r->si.end, buf + offset, size); if(last) break; } if (s->current_picture_ptr) { if (last) { if(r->loop_filter) r->loop_filter(r, s->mb_height - 1); ret = finish_frame(avctx, pict); if (ret < 0) return ret; *got_picture_ptr = ret; } else if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) { av_log(avctx, AV_LOG_INFO, ""marking unfished frame as finished\n""); ff_er_frame_end(&s->er); ff_MPV_frame_end(s); s->mb_num_left = 0; ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0); return AVERROR_INVALIDDATA; } } return avpkt->size; }","- if ((ret = av_frame_ref(pict, &s->next_picture_ptr->f)) < 0)
- if ((!s->last_picture_ptr || !s->last_picture_ptr->f.data[0]) &&
+ if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)
+ if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&","int ff_rv34_decode_frame(AVCodecContext *avctx, void *data, int *got_picture_ptr, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; RV34DecContext *r = avctx->priv_data; MpegEncContext *s = &r->s; AVFrame *pict = data; SliceInfo si; int i, ret; int slice_count; const uint8_t *slices_hdr = NULL; int last = 0; if (buf_size == 0) { if (s->low_delay==0 && s->next_picture_ptr) { if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0) return ret; s->next_picture_ptr = NULL; *got_picture_ptr = 1; } return 0; } if(!avctx->slice_count){ slice_count = (*buf++) + 1; slices_hdr = buf + 4; buf += 8 * slice_count; buf_size -= 1 + 8 * slice_count; }else slice_count = avctx->slice_count; if(get_slice_offset(avctx, slices_hdr, 0) < 0 || get_slice_offset(avctx, slices_hdr, 0) > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is invalid\n""); return AVERROR_INVALIDDATA; } init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8); if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){ av_log(avctx, AV_LOG_ERROR, ""First slice header is incorrect\n""); return AVERROR_INVALIDDATA; } if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) && si.type == AV_PICTURE_TYPE_B) { av_log(avctx, AV_LOG_ERROR, ""Invalid decoder state: B-frame without "" ""reference data.\n""); return AVERROR_INVALIDDATA; } if( (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B) || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) return avpkt->size; if (si.start == 0) { if (s->mb_num_left > 0) { av_log(avctx, AV_LOG_ERROR, ""New frame but still %d MB left."", s->mb_num_left); ff_er_frame_end(&s->er); ff_MPV_frame_end(s); } if (s->width != si.width || s->height != si.height) { int err; av_log(s->avctx, AV_LOG_WARNING, ""Changing dimensions to %dx%d\n"", si.width, si.height); s->width = si.width; s->height = si.height; err = ff_set_dimensions(s->avctx, s->width, s->height); if (err < 0) return err; if ((err = ff_MPV_common_frame_size_change(s)) < 0) return err; if ((err = rv34_decoder_realloc(r)) < 0) return err; } s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I; if (ff_MPV_frame_start(s, s->avctx) < 0) return -1; ff_mpeg_er_frame_start(s); if (!r->tmp_b_block_base) { int i; r->tmp_b_block_base = av_malloc(s->linesize * 48); for (i = 0; i < 2; i++) r->tmp_b_block_y[i] = r->tmp_b_block_base + i * 16 * s->linesize; for (i = 0; i < 4; i++) r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize + (i >> 1) * 8 * s->uvlinesize + (i & 1) * 16; } r->cur_pts = si.pts; if (s->pict_type != AV_PICTURE_TYPE_B) { r->last_pts = r->next_pts; r->next_pts = r->cur_pts; } else { int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts); int dist0 = GET_PTS_DIFF(r->cur_pts, r->last_pts); int dist1 = GET_PTS_DIFF(r->next_pts, r->cur_pts); if(!refdist){ r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192; r->scaled_weight = 0; }else{ r->mv_weight1 = (dist0 << 14) / refdist; r->mv_weight2 = (dist1 << 14) / refdist; if((r->mv_weight1|r->mv_weight2) & 511){ r->weight1 = r->mv_weight1; r->weight2 = r->mv_weight2; r->scaled_weight = 0; }else{ r->weight1 = r->mv_weight1 >> 9; r->weight2 = r->mv_weight2 >> 9; r->scaled_weight = 1; } } } s->mb_x = s->mb_y = 0; ff_thread_finish_setup(s->avctx); } else if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) { av_log(s->avctx, AV_LOG_ERROR, ""Decoder needs full frames in frame "" ""multithreading mode (start MB is %d).\n"", si.start); return AVERROR_INVALIDDATA; } for(i = 0; i < slice_count; i++){ int offset = get_slice_offset(avctx, slices_hdr, i); int size; if(i+1 == slice_count) size = buf_size - offset; else size = get_slice_offset(avctx, slices_hdr, i+1) - offset; if(offset < 0 || offset > buf_size){ av_log(avctx, AV_LOG_ERROR, ""Slice offset is invalid\n""); break; } r->si.end = s->mb_width * s->mb_height; s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start; if(i+1 < slice_count){ if (get_slice_offset(avctx, slices_hdr, i+1) < 0 || get_slice_offset(avctx, slices_hdr, i+1) > buf_size) { av_log(avctx, AV_LOG_ERROR, ""Slice offset is invalid\n""); break; } init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8); if(r->parse_slice_header(r, &r->s.gb, &si) < 0){ if(i+2 < slice_count) size = get_slice_offset(avctx, slices_hdr, i+2) - offset; else size = buf_size - offset; }else r->si.end = si.start; } if (size < 0 || size > buf_size - offset) { av_log(avctx, AV_LOG_ERROR, ""Slice size is invalid\n""); break; } last = rv34_decode_slice(r, r->si.end, buf + offset, size); if(last) break; } if (s->current_picture_ptr) { if (last) { if(r->loop_filter) r->loop_filter(r, s->mb_height - 1); ret = finish_frame(avctx, pict); if (ret < 0) return ret; *got_picture_ptr = ret; } else if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) { av_log(avctx, AV_LOG_INFO, ""marking unfished frame as finished\n""); ff_er_frame_end(&s->er); ff_MPV_frame_end(s); s->mb_num_left = 0; ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0); return AVERROR_INVALIDDATA; } } return avpkt->size; }"
7734----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a43e5676c129f81e287895eaea78a449c724a34b_1.json----parse_command_line,"static inline int parse_command_line(AVFormatContext *s, const char *line, int linelen, char *uri, int urisize, char *method, int methodsize, enum RTSPMethod *methodcode) { RTSPState *rt = s->priv_data; const char *linept, *searchlinept; linept = strchr(line, ' '); if (linept - line > methodsize - 1) { av_log(s, AV_LOG_ERROR, ""Method string too long\n""); return AVERROR(EIO); } memcpy(method, line, linept - line); method[linept - line] = '\0'; linept++; if (!strcmp(method, ""ANNOUNCE"")) *methodcode = ANNOUNCE; else if (!strcmp(method, ""OPTIONS"")) *methodcode = OPTIONS; else if (!strcmp(method, ""RECORD"")) *methodcode = RECORD; else if (!strcmp(method, ""SETUP"")) *methodcode = SETUP; else if (!strcmp(method, ""PAUSE"")) *methodcode = PAUSE; else if (!strcmp(method, ""TEARDOWN"")) *methodcode = TEARDOWN; else *methodcode = UNKNOWN; if (rt->state == RTSP_STATE_IDLE) { if ((*methodcode != ANNOUNCE) && (*methodcode != OPTIONS)) { av_log(s, AV_LOG_ERROR, ""Unexpected command in Idle State %s\n"", line); return AVERROR_PROTOCOL_NOT_FOUND; } } else if (rt->state == RTSP_STATE_PAUSED) { if ((*methodcode != OPTIONS) && (*methodcode != RECORD) && (*methodcode != SETUP)) { av_log(s, AV_LOG_ERROR, ""Unexpected command in Paused State %s\n"", line); return AVERROR_PROTOCOL_NOT_FOUND; } } else if (rt->state == RTSP_STATE_STREAMING) { if ((*methodcode != PAUSE) && (*methodcode != OPTIONS) && (*methodcode != TEARDOWN)) { av_log(s, AV_LOG_ERROR, ""Unexpected command in Streaming State"" "" %s\n"", line); return AVERROR_PROTOCOL_NOT_FOUND; } } else { av_log(s, AV_LOG_ERROR, ""Unexpected State [%d]\n"", rt->state); return AVERROR_BUG; } searchlinept = strchr(linept, ' '); if (searchlinept == NULL) { av_log(s, AV_LOG_ERROR, ""Error parsing message URI\n""); return AVERROR_INVALIDDATA; } if (searchlinept - linept > urisize - 1) { av_log(s, AV_LOG_ERROR, ""uri string length exceeded buffer size\n""); return AVERROR(EIO); } memcpy(uri, linept, searchlinept - linept); uri[searchlinept - linept] = '\0'; if (strcmp(rt->control_uri, uri)) { char host[128], path[512], auth[128]; int port; char ctl_host[128], ctl_path[512], ctl_auth[128]; int ctl_port; av_url_split(NULL, 0, auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), uri); av_url_split(NULL, 0, ctl_auth, sizeof(ctl_auth), ctl_host, sizeof(ctl_host), &ctl_port, ctl_path, sizeof(ctl_path), rt->control_uri); if (strcmp(host, ctl_host)) av_log(s, AV_LOG_INFO, ""Host %s differs from expected %s\n"", host, ctl_host); if (strcmp(path, ctl_path) && *methodcode != SETUP) av_log(s, AV_LOG_WARNING, ""WARNING: Path %s differs from expected"" "" %s\n"", path, ctl_path); if (*methodcode == ANNOUNCE) { av_log(s, AV_LOG_INFO, ""Updating control URI to %s\n"", uri); <S2SV_StartVul> strcpy(rt->control_uri, uri); <S2SV_EndVul> } } linept = searchlinept + 1; if (!av_strstart(linept, ""RTSP/1.0"", NULL)) { av_log(s, AV_LOG_ERROR, ""Error parsing protocol or version\n""); return AVERROR_PROTOCOL_NOT_FOUND; } return 0; }","- strcpy(rt->control_uri, uri);
+ av_strlcpy(rt->control_uri, uri, sizeof(rt->control_uri));","static inline int parse_command_line(AVFormatContext *s, const char *line, int linelen, char *uri, int urisize, char *method, int methodsize, enum RTSPMethod *methodcode) { RTSPState *rt = s->priv_data; const char *linept, *searchlinept; linept = strchr(line, ' '); if (linept - line > methodsize - 1) { av_log(s, AV_LOG_ERROR, ""Method string too long\n""); return AVERROR(EIO); } memcpy(method, line, linept - line); method[linept - line] = '\0'; linept++; if (!strcmp(method, ""ANNOUNCE"")) *methodcode = ANNOUNCE; else if (!strcmp(method, ""OPTIONS"")) *methodcode = OPTIONS; else if (!strcmp(method, ""RECORD"")) *methodcode = RECORD; else if (!strcmp(method, ""SETUP"")) *methodcode = SETUP; else if (!strcmp(method, ""PAUSE"")) *methodcode = PAUSE; else if (!strcmp(method, ""TEARDOWN"")) *methodcode = TEARDOWN; else *methodcode = UNKNOWN; if (rt->state == RTSP_STATE_IDLE) { if ((*methodcode != ANNOUNCE) && (*methodcode != OPTIONS)) { av_log(s, AV_LOG_ERROR, ""Unexpected command in Idle State %s\n"", line); return AVERROR_PROTOCOL_NOT_FOUND; } } else if (rt->state == RTSP_STATE_PAUSED) { if ((*methodcode != OPTIONS) && (*methodcode != RECORD) && (*methodcode != SETUP)) { av_log(s, AV_LOG_ERROR, ""Unexpected command in Paused State %s\n"", line); return AVERROR_PROTOCOL_NOT_FOUND; } } else if (rt->state == RTSP_STATE_STREAMING) { if ((*methodcode != PAUSE) && (*methodcode != OPTIONS) && (*methodcode != TEARDOWN)) { av_log(s, AV_LOG_ERROR, ""Unexpected command in Streaming State"" "" %s\n"", line); return AVERROR_PROTOCOL_NOT_FOUND; } } else { av_log(s, AV_LOG_ERROR, ""Unexpected State [%d]\n"", rt->state); return AVERROR_BUG; } searchlinept = strchr(linept, ' '); if (searchlinept == NULL) { av_log(s, AV_LOG_ERROR, ""Error parsing message URI\n""); return AVERROR_INVALIDDATA; } if (searchlinept - linept > urisize - 1) { av_log(s, AV_LOG_ERROR, ""uri string length exceeded buffer size\n""); return AVERROR(EIO); } memcpy(uri, linept, searchlinept - linept); uri[searchlinept - linept] = '\0'; if (strcmp(rt->control_uri, uri)) { char host[128], path[512], auth[128]; int port; char ctl_host[128], ctl_path[512], ctl_auth[128]; int ctl_port; av_url_split(NULL, 0, auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), uri); av_url_split(NULL, 0, ctl_auth, sizeof(ctl_auth), ctl_host, sizeof(ctl_host), &ctl_port, ctl_path, sizeof(ctl_path), rt->control_uri); if (strcmp(host, ctl_host)) av_log(s, AV_LOG_INFO, ""Host %s differs from expected %s\n"", host, ctl_host); if (strcmp(path, ctl_path) && *methodcode != SETUP) av_log(s, AV_LOG_WARNING, ""WARNING: Path %s differs from expected"" "" %s\n"", path, ctl_path); if (*methodcode == ANNOUNCE) { av_log(s, AV_LOG_INFO, ""Updating control URI to %s\n"", uri); av_strlcpy(rt->control_uri, uri, sizeof(rt->control_uri)); } } linept = searchlinept + 1; if (!av_strstart(linept, ""RTSP/1.0"", NULL)) { av_log(s, AV_LOG_ERROR, ""Error parsing protocol or version\n""); return AVERROR_PROTOCOL_NOT_FOUND; } return 0; }"
5581----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_258d6511c89bd5ab657507bf839affdac60cdbde_1.json----vorbisfloat2float,"<S2SV_StartVul> static float vorbisfloat2float(uint_fast32_t val) <S2SV_EndVul> { double mant = val & 0x1fffff; long exp = (val & 0x7fe00000L) >> 21; if (val & 0x80000000) mant = -mant; return ldexp(mant, exp - 20 - 768); }","- static float vorbisfloat2float(uint_fast32_t val)
+ static float vorbisfloat2float(unsigned val)","static float vorbisfloat2float(unsigned val) { double mant = val & 0x1fffff; long exp = (val & 0x7fe00000L) >> 21; if (val & 0x80000000) mant = -mant; return ldexp(mant, exp - 20 - 768); }"
11336----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_271bcea44854c3066d4ea29de803dace50b5782a_1.json----pkeyparam_main,"int pkeyparam_main(int argc, char **argv) { ENGINE *e = NULL; BIO *in = NULL, *out = NULL; EVP_PKEY *pkey = NULL; <S2SV_StartVul> int text = 0, noout = 0, ret = 1; <S2SV_EndVul> OPTION_CHOICE o; char *infile = NULL, *outfile = NULL, *prog; prog = opt_init(argc, argv, pkeyparam_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: opt_help(pkeyparam_options); ret = 0; goto end; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; case OPT_ENGINE: e = setup_engine(opt_arg(), 0); break; case OPT_TEXT: text = 1; break; case OPT_NOOUT: noout = 1; break; } } argc = opt_num_rest(); if (argc != 0) goto opthelp; in = bio_open_default(infile, 'r', FORMAT_PEM); if (in == NULL) goto end; out = bio_open_default(outfile, 'w', FORMAT_PEM); if (out == NULL) goto end; pkey = PEM_read_bio_Parameters(in, NULL); if (pkey == NULL) { BIO_printf(bio_err, ""Error reading parameters\n""); ERR_print_errors(bio_err); goto end; } if (!noout) PEM_write_bio_Parameters(out, pkey); if (text) EVP_PKEY_print_params(out, pkey, 0, NULL); ret = 0; end: EVP_PKEY_free(pkey); release_engine(e); BIO_free_all(out); BIO_free(in); return ret; }","- int text = 0, noout = 0, ret = 1;
+ int text = 0, noout = 0, ret = 1, check = 0;
+ case OPT_CHECK:
+ check = 1;
+ break;
+ if (check) {
+ int r;
+ EVP_PKEY_CTX *ctx;
+ ctx = EVP_PKEY_CTX_new(pkey, e);
+ if (ctx == NULL) {
+ ERR_print_errors(bio_err);
+ goto end;
+ }
+ r = EVP_PKEY_param_check(ctx);
+ if (r == 1) {
+ BIO_printf(out, ""Parameters are valid\n"");
+ } else {
+ unsigned long err;
+ BIO_printf(out, ""Parameters are invalid\n"");
+ while ((err = ERR_peek_error()) != 0) {
+ BIO_printf(out, ""Detailed error: %s\n"",
+ ERR_reason_error_string(err));
+ }
+ }
+ EVP_PKEY_CTX_free(ctx);
+ }","int pkeyparam_main(int argc, char **argv) { ENGINE *e = NULL; BIO *in = NULL, *out = NULL; EVP_PKEY *pkey = NULL; int text = 0, noout = 0, ret = 1, check = 0; OPTION_CHOICE o; char *infile = NULL, *outfile = NULL, *prog; prog = opt_init(argc, argv, pkeyparam_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: opt_help(pkeyparam_options); ret = 0; goto end; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; case OPT_ENGINE: e = setup_engine(opt_arg(), 0); break; case OPT_TEXT: text = 1; break; case OPT_NOOUT: noout = 1; break; case OPT_CHECK: check = 1; break; } } argc = opt_num_rest(); if (argc != 0) goto opthelp; in = bio_open_default(infile, 'r', FORMAT_PEM); if (in == NULL) goto end; out = bio_open_default(outfile, 'w', FORMAT_PEM); if (out == NULL) goto end; pkey = PEM_read_bio_Parameters(in, NULL); if (pkey == NULL) { BIO_printf(bio_err, ""Error reading parameters\n""); ERR_print_errors(bio_err); goto end; } if (check) { int r; EVP_PKEY_CTX *ctx; ctx = EVP_PKEY_CTX_new(pkey, e); if (ctx == NULL) { ERR_print_errors(bio_err); goto end; } r = EVP_PKEY_param_check(ctx); if (r == 1) { BIO_printf(out, ""Parameters are valid\n""); } else { unsigned long err; BIO_printf(out, ""Parameters are invalid\n""); while ((err = ERR_peek_error()) != 0) { BIO_printf(out, ""Detailed error: %s\n"", ERR_reason_error_string(err)); ERR_get_error(); } } EVP_PKEY_CTX_free(ctx); } if (!noout) PEM_write_bio_Parameters(out, pkey); if (text) EVP_PKEY_print_params(out, pkey, 0, NULL); ret = 0; end: EVP_PKEY_free(pkey); release_engine(e); BIO_free_all(out); BIO_free(in); return ret; }"
305----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_128f727236544c25a169d4a5c3e91b55ec4da604_1.json----show_packets,"static void show_packets(AVFormatContext *fmt_ctx) { AVPacket pkt; av_init_packet(&pkt); probe_array_header(""packets"", 0); <S2SV_StartVul> while (!av_read_frame(fmt_ctx, &pkt)) <S2SV_EndVul> show_packet(fmt_ctx, &pkt); probe_array_footer(""packets"", 0); }","- while (!av_read_frame(fmt_ctx, &pkt))
+ while (!av_read_frame(fmt_ctx, &pkt)) {
+ av_packet_unref(&pkt);
+ }","static void show_packets(AVFormatContext *fmt_ctx) { AVPacket pkt; av_init_packet(&pkt); probe_array_header(""packets"", 0); while (!av_read_frame(fmt_ctx, &pkt)) { show_packet(fmt_ctx, &pkt); av_packet_unref(&pkt); } probe_array_footer(""packets"", 0); }"
10565----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0a81f8588f8e9a9d96402855b39e89f9797a34fe_1.json----BN_sub_word,"int BN_sub_word(BIGNUM *a, BN_ULONG w) { int i; w &= BN_MASK2; <S2SV_StartVul> if (!w) <S2SV_EndVul> <S2SV_StartVul> return 1; <S2SV_EndVul> <S2SV_StartVul> if (BN_is_zero(a) || a->neg) <S2SV_EndVul> { a->neg=0; i=BN_add_word(a,w); a->neg=1; return(i); } if ((a->top == 1) && (a->d[0] < w)) { a->d[0]=w-a->d[0]; a->neg=1; return(1); } i=0; for (;;) { if (a->d[i] >= w) { a->d[i]-=w; break; } else { a->d[i]=(a->d[i]-w)&BN_MASK2; i++; w=1; } } if ((a->d[i] == 0) && (i == (a->top-1))) a->top--; bn_check_top(a); return(1); }","- if (!w)
- return 1;
- if (BN_is_zero(a) || a->neg)
+ bn_check_top(a);
+ if (!w) return 1;
+ if(BN_is_zero(a)) return BN_set_word(a,w);
+ if (a->neg)","int BN_sub_word(BIGNUM *a, BN_ULONG w) { int i; bn_check_top(a); w &= BN_MASK2; if (!w) return 1; if(BN_is_zero(a)) return BN_set_word(a,w); if (a->neg) { a->neg=0; i=BN_add_word(a,w); a->neg=1; return(i); } if ((a->top == 1) && (a->d[0] < w)) { a->d[0]=w-a->d[0]; a->neg=1; return(1); } i=0; for (;;) { if (a->d[i] >= w) { a->d[i]-=w; break; } else { a->d[i]=(a->d[i]-w)&BN_MASK2; i++; w=1; } } if ((a->d[i] == 0) && (i == (a->top-1))) a->top--; bn_check_top(a); return(1); }"
846----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2e65dbd2bdab6c98dfe334e2e89e2877c3e0f98d_1.json----hls_prediction_unit,"static void hls_prediction_unit(HEVCContext *s, int x0, int y0, int nPbW, int nPbH, int log2_cb_size, int partIdx) { #define POS(c_idx,x,y) \ &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \ (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)] HEVCLocalContext *lc = &s->HEVClc; int merge_idx = 0; struct MvField current_mv = {{{ 0 }}}; int min_pu_width = s->sps->min_pu_width; MvField *tab_mvf = s->ref->tab_mvf; RefPicList *refPicList = s->ref->refPicList; HEVCFrame *ref0, *ref1; int tmpstride = MAX_PB_SIZE; uint8_t *dst0 = POS(0, x0, y0); uint8_t *dst1 = POS(1, x0, y0); uint8_t *dst2 = POS(2, x0, y0); int log2_min_cb_size = s->sps->log2_min_cb_size; int min_cb_width = s->sps->min_cb_width; int x_cb = x0 >> log2_min_cb_size; int y_cb = y0 >> log2_min_cb_size; int x_pu, y_pu; int i, j; int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb); if (!skip_flag) lc->pu.merge_flag = ff_hevc_merge_flag_decode(s); if (skip_flag || lc->pu.merge_flag) { if (s->sh.max_num_merge_cand > 1) merge_idx = ff_hevc_merge_idx_decode(s); else merge_idx = 0; ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv); } else { enum InterPredIdc inter_pred_idc = PRED_L0; int mvp_flag; ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH); if (s->sh.slice_type == B_SLICE) inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH); if (inter_pred_idc != PRED_L1) { if (s->sh.nb_refs[L0]) { current_mv.ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]); } current_mv.pred_flag[0] = 1; hls_mvd_coding(s, x0, y0, 0); mvp_flag = ff_hevc_mvp_lx_flag_decode(s); ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv, mvp_flag, 0); current_mv.mv[0].x += lc->pu.mvd.x; current_mv.mv[0].y += lc->pu.mvd.y; } if (inter_pred_idc != PRED_L0) { if (s->sh.nb_refs[L1]) { current_mv.ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]); } if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) { AV_ZERO32(&lc->pu.mvd); } else { hls_mvd_coding(s, x0, y0, 1); } current_mv.pred_flag[1] = 1; mvp_flag = ff_hevc_mvp_lx_flag_decode(s); ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv, mvp_flag, 1); current_mv.mv[1].x += lc->pu.mvd.x; current_mv.mv[1].y += lc->pu.mvd.y; } } x_pu = x0 >> s->sps->log2_min_pu_size; y_pu = y0 >> s->sps->log2_min_pu_size; for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++) for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++) tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv; if (current_mv.pred_flag[0]) { ref0 = refPicList[0].ref[current_mv.ref_idx[0]]; if (!ref0) return; hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH); } if (current_mv.pred_flag[1]) { ref1 = refPicList[1].ref[current_mv.ref_idx[1]]; if (!ref1) return; hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH); } if (current_mv.pred_flag[0] && !current_mv.pred_flag[1]) { DECLARE_ALIGNED(16, int16_t, tmp[MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]); luma_mc(s, tmp, tmpstride, ref0->frame, &current_mv.mv[0], x0, y0, nPbW, nPbH); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom, s->sh.luma_weight_l0[current_mv.ref_idx[0]], s->sh.luma_offset_l0[current_mv.ref_idx[0]], dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } else { s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame, &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0], dst1, s->frame->linesize[1], tmp, tmpstride, nPbW / 2, nPbH / 2); s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1], dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW / 2, nPbH / 2); } else { s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2); } } else if (!current_mv.pred_flag[0] && current_mv.pred_flag[1]) { DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]); <S2SV_StartVul> if (!ref1) <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> luma_mc(s, tmp, tmpstride, ref1->frame, &current_mv.mv[1], x0, y0, nPbW, nPbH); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom, s->sh.luma_weight_l1[current_mv.ref_idx[1]], s->sh.luma_offset_l1[current_mv.ref_idx[1]], dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } else { s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } chroma_mc(s, tmp, tmp2, tmpstride, ref1->frame, &current_mv.mv[1], x0/2, y0/2, nPbW/2, nPbH/2); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0], dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1], dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2); } else { s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2); } } else if (current_mv.pred_flag[0] && current_mv.pred_flag[1]) { DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp3[MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp4[MAX_PB_SIZE * MAX_PB_SIZE]); <S2SV_StartVul> HEVCFrame *ref0 = refPicList[0].ref[current_mv.ref_idx[0]]; <S2SV_EndVul> <S2SV_StartVul> HEVCFrame *ref1 = refPicList[1].ref[current_mv.ref_idx[1]]; <S2SV_EndVul> <S2SV_StartVul> if (!ref0 || !ref1) <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> luma_mc(s, tmp, tmpstride, ref0->frame, &current_mv.mv[0], x0, y0, nPbW, nPbH); luma_mc(s, tmp2, tmpstride, ref1->frame, &current_mv.mv[1], x0, y0, nPbW, nPbH); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred_avg(s->sh.luma_log2_weight_denom, s->sh.luma_weight_l0[current_mv.ref_idx[0]], s->sh.luma_weight_l1[current_mv.ref_idx[1]], s->sh.luma_offset_l0[current_mv.ref_idx[0]], s->sh.luma_offset_l1[current_mv.ref_idx[1]], dst0, s->frame->linesize[0], tmp, tmp2, tmpstride, nPbW, nPbH); } else { s->hevcdsp.put_weighted_pred_avg(dst0, s->frame->linesize[0], tmp, tmp2, tmpstride, nPbW, nPbH); } chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame, &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2); chroma_mc(s, tmp3, tmp4, tmpstride, ref1->frame, &current_mv.mv[1], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0], dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW / 2, nPbH / 2); s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1], dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW / 2, nPbH / 2); } else { s->hevcdsp.put_weighted_pred_avg(dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.put_weighted_pred_avg(dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW/2, nPbH/2); } } }","- if (!ref1)
- return;
- HEVCFrame *ref0 = refPicList[0].ref[current_mv.ref_idx[0]];
- HEVCFrame *ref1 = refPicList[1].ref[current_mv.ref_idx[1]];
- if (!ref0 || !ref1)
- return;","static void hls_prediction_unit(HEVCContext *s, int x0, int y0, int nPbW, int nPbH, int log2_cb_size, int partIdx) { #define POS(c_idx,x,y) \ &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \ (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)] HEVCLocalContext *lc = &s->HEVClc; int merge_idx = 0; struct MvField current_mv = {{{ 0 }}}; int min_pu_width = s->sps->min_pu_width; MvField *tab_mvf = s->ref->tab_mvf; RefPicList *refPicList = s->ref->refPicList; HEVCFrame *ref0, *ref1; int tmpstride = MAX_PB_SIZE; uint8_t *dst0 = POS(0, x0, y0); uint8_t *dst1 = POS(1, x0, y0); uint8_t *dst2 = POS(2, x0, y0); int log2_min_cb_size = s->sps->log2_min_cb_size; int min_cb_width = s->sps->min_cb_width; int x_cb = x0 >> log2_min_cb_size; int y_cb = y0 >> log2_min_cb_size; int x_pu, y_pu; int i, j; int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb); if (!skip_flag) lc->pu.merge_flag = ff_hevc_merge_flag_decode(s); if (skip_flag || lc->pu.merge_flag) { if (s->sh.max_num_merge_cand > 1) merge_idx = ff_hevc_merge_idx_decode(s); else merge_idx = 0; ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv); } else { enum InterPredIdc inter_pred_idc = PRED_L0; int mvp_flag; ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH); if (s->sh.slice_type == B_SLICE) inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH); if (inter_pred_idc != PRED_L1) { if (s->sh.nb_refs[L0]) { current_mv.ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]); } current_mv.pred_flag[0] = 1; hls_mvd_coding(s, x0, y0, 0); mvp_flag = ff_hevc_mvp_lx_flag_decode(s); ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv, mvp_flag, 0); current_mv.mv[0].x += lc->pu.mvd.x; current_mv.mv[0].y += lc->pu.mvd.y; } if (inter_pred_idc != PRED_L0) { if (s->sh.nb_refs[L1]) { current_mv.ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]); } if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) { AV_ZERO32(&lc->pu.mvd); } else { hls_mvd_coding(s, x0, y0, 1); } current_mv.pred_flag[1] = 1; mvp_flag = ff_hevc_mvp_lx_flag_decode(s); ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size, partIdx, merge_idx, &current_mv, mvp_flag, 1); current_mv.mv[1].x += lc->pu.mvd.x; current_mv.mv[1].y += lc->pu.mvd.y; } } x_pu = x0 >> s->sps->log2_min_pu_size; y_pu = y0 >> s->sps->log2_min_pu_size; for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++) for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++) tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv; if (current_mv.pred_flag[0]) { ref0 = refPicList[0].ref[current_mv.ref_idx[0]]; if (!ref0) return; hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH); } if (current_mv.pred_flag[1]) { ref1 = refPicList[1].ref[current_mv.ref_idx[1]]; if (!ref1) return; hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH); } if (current_mv.pred_flag[0] && !current_mv.pred_flag[1]) { DECLARE_ALIGNED(16, int16_t, tmp[MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]); luma_mc(s, tmp, tmpstride, ref0->frame, &current_mv.mv[0], x0, y0, nPbW, nPbH); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom, s->sh.luma_weight_l0[current_mv.ref_idx[0]], s->sh.luma_offset_l0[current_mv.ref_idx[0]], dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } else { s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame, &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0], dst1, s->frame->linesize[1], tmp, tmpstride, nPbW / 2, nPbH / 2); s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1], dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW / 2, nPbH / 2); } else { s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2); } } else if (!current_mv.pred_flag[0] && current_mv.pred_flag[1]) { DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]); luma_mc(s, tmp, tmpstride, ref1->frame, &current_mv.mv[1], x0, y0, nPbW, nPbH); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom, s->sh.luma_weight_l1[current_mv.ref_idx[1]], s->sh.luma_offset_l1[current_mv.ref_idx[1]], dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } else { s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH); } chroma_mc(s, tmp, tmp2, tmpstride, ref1->frame, &current_mv.mv[1], x0/2, y0/2, nPbW/2, nPbH/2); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0], dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1], dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2); } else { s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2); } } else if (current_mv.pred_flag[0] && current_mv.pred_flag[1]) { DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp3[MAX_PB_SIZE * MAX_PB_SIZE]); DECLARE_ALIGNED(16, int16_t, tmp4[MAX_PB_SIZE * MAX_PB_SIZE]); luma_mc(s, tmp, tmpstride, ref0->frame, &current_mv.mv[0], x0, y0, nPbW, nPbH); luma_mc(s, tmp2, tmpstride, ref1->frame, &current_mv.mv[1], x0, y0, nPbW, nPbH); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred_avg(s->sh.luma_log2_weight_denom, s->sh.luma_weight_l0[current_mv.ref_idx[0]], s->sh.luma_weight_l1[current_mv.ref_idx[1]], s->sh.luma_offset_l0[current_mv.ref_idx[0]], s->sh.luma_offset_l1[current_mv.ref_idx[1]], dst0, s->frame->linesize[0], tmp, tmp2, tmpstride, nPbW, nPbH); } else { s->hevcdsp.put_weighted_pred_avg(dst0, s->frame->linesize[0], tmp, tmp2, tmpstride, nPbW, nPbH); } chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame, &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2); chroma_mc(s, tmp3, tmp4, tmpstride, ref1->frame, &current_mv.mv[1], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2); if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) || (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) { s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0], dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW / 2, nPbH / 2); s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom, s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1], dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW / 2, nPbH / 2); } else { s->hevcdsp.put_weighted_pred_avg(dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW/2, nPbH/2); s->hevcdsp.put_weighted_pred_avg(dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW/2, nPbH/2); } } }"
6322----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_52d8fffb6087291873f3beed41d40905d3bbed6c_1.json----render_line_unrolled,"<S2SV_StartVul> static inline void render_line_unrolled(intptr_t x, intptr_t y, int x1, <S2SV_EndVul> intptr_t sy, int ady, int adx, float *buf) { int err = -adx; x -= x1 - 1; buf += x1 - 1; while (++x < 0) { err += ady; if (err >= 0) { err += ady - adx; y += sy; buf[x++] = ff_vorbis_floor1_inverse_db_table[y]; } buf[x] = ff_vorbis_floor1_inverse_db_table[y]; } if (x <= 0) { if (err + ady >= 0) y += sy; buf[x] = ff_vorbis_floor1_inverse_db_table[y]; } }","- static inline void render_line_unrolled(intptr_t x, intptr_t y, int x1,
+ static inline void render_line_unrolled(intptr_t x, uint8_t y, int x1,","static inline void render_line_unrolled(intptr_t x, uint8_t y, int x1, intptr_t sy, int ady, int adx, float *buf) { int err = -adx; x -= x1 - 1; buf += x1 - 1; while (++x < 0) { err += ady; if (err >= 0) { err += ady - adx; y += sy; buf[x++] = ff_vorbis_floor1_inverse_db_table[y]; } buf[x] = ff_vorbis_floor1_inverse_db_table[y]; } if (x <= 0) { if (err + ady >= 0) y += sy; buf[x] = ff_vorbis_floor1_inverse_db_table[y]; } }"
4001----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d7efa41399c2c30a7c70486183a0d41e83641985_1.json----get_scene_score,"static double get_scene_score(AVFilterContext *ctx, AVFilterBufferRef *picref) { double ret = 0; SelectContext *select = ctx->priv; AVFilterBufferRef *prev_picref = select->prev_picref; if (prev_picref && picref->video->h == prev_picref->video->h && picref->video->w == prev_picref->video->w && picref->linesize[0] == prev_picref->linesize[0]) { <S2SV_StartVul> int x, y; <S2SV_EndVul> int64_t sad = 0; double mafd, diff; uint8_t *p1 = picref->data[0]; uint8_t *p2 = prev_picref->data[0]; const int linesize = picref->linesize[0]; <S2SV_StartVul> for (y = 0; y < picref->video->h; y += 8) <S2SV_EndVul> <S2SV_StartVul> for (x = 0; x < linesize; x += 8) <S2SV_EndVul> sad += select->c.sad[1](select, p1 + y * linesize + x, p2 + y * linesize + x, linesize, 8); emms_c(); <S2SV_StartVul> mafd = sad / (picref->video->h * picref->video->w * 3); <S2SV_EndVul> diff = fabs(mafd - select->prev_mafd); ret = av_clipf(FFMIN(mafd, diff) / 100., 0, 1); select->prev_mafd = mafd; avfilter_unref_buffer(prev_picref); } select->prev_picref = avfilter_ref_buffer(picref, ~0); return ret; }","- int x, y;
- for (y = 0; y < picref->video->h; y += 8)
- for (x = 0; x < linesize; x += 8)
- mafd = sad / (picref->video->h * picref->video->w * 3);
+ int x, y, nb_sad = 0;
+ for (y = 0; y < picref->video->h - 8; y += 8) {
+ for (x = 0; x < picref->video->w*3 - 8; x += 8) {
+ nb_sad += 8 * 8;
+ }
+ }
+ mafd = nb_sad ? sad / nb_sad : 0;","static double get_scene_score(AVFilterContext *ctx, AVFilterBufferRef *picref) { double ret = 0; SelectContext *select = ctx->priv; AVFilterBufferRef *prev_picref = select->prev_picref; if (prev_picref && picref->video->h == prev_picref->video->h && picref->video->w == prev_picref->video->w && picref->linesize[0] == prev_picref->linesize[0]) { int x, y, nb_sad = 0; int64_t sad = 0; double mafd, diff; uint8_t *p1 = picref->data[0]; uint8_t *p2 = prev_picref->data[0]; const int linesize = picref->linesize[0]; for (y = 0; y < picref->video->h - 8; y += 8) { for (x = 0; x < picref->video->w*3 - 8; x += 8) { sad += select->c.sad[1](select, p1 + y * linesize + x, p2 + y * linesize + x, linesize, 8); nb_sad += 8 * 8; } } emms_c(); mafd = nb_sad ? sad / nb_sad : 0; diff = fabs(mafd - select->prev_mafd); ret = av_clipf(FFMIN(mafd, diff) / 100., 0, 1); select->prev_mafd = mafd; avfilter_unref_buffer(prev_picref); } select->prev_picref = avfilter_ref_buffer(picref, ~0); return ret; }"
11027----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1aaa787e6112b9be148b889811681bb92cc5f4e1_1.json----BN_from_montgomery,"int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx) { int retn = 0; #ifdef MONT_WORD BIGNUM *t; BN_CTX_start(ctx); <S2SV_StartVul> if ((t = BN_CTX_get(ctx)) && BN_copy(t, a)) <S2SV_EndVul> <S2SV_StartVul> retn = BN_from_montgomery_word(ret, t, mont); <S2SV_EndVul> BN_CTX_end(ctx); #else BIGNUM *t1, *t2; BN_CTX_start(ctx); t1 = BN_CTX_get(ctx); t2 = BN_CTX_get(ctx); if (t2 == NULL) goto err; if (!BN_copy(t1, a)) goto err; BN_mask_bits(t1, mont->ri); if (!BN_mul(t2, t1, &mont->Ni, ctx)) goto err; BN_mask_bits(t2, mont->ri); if (!BN_mul(t1, t2, &mont->N, ctx)) goto err; if (!BN_add(t2, a, t1)) goto err; if (!BN_rshift(ret, t2, mont->ri)) goto err; if (BN_ucmp(ret, &(mont->N)) >= 0) { if (!BN_usub(ret, ret, &(mont->N))) goto err; } retn = 1; bn_check_top(ret); err: BN_CTX_end(ctx); #endif return retn; }","- if ((t = BN_CTX_get(ctx)) && BN_copy(t, a))
- retn = BN_from_montgomery_word(ret, t, mont);
+ if ((t = BN_CTX_get(ctx)) && BN_copy(t, a)) {
+ retn = bn_from_montgomery_word(ret, t, mont);
+ bn_correct_top(ret);
+ bn_check_top(ret);
+ }","int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont, BN_CTX *ctx) { int retn = 0; #ifdef MONT_WORD BIGNUM *t; BN_CTX_start(ctx); if ((t = BN_CTX_get(ctx)) && BN_copy(t, a)) { retn = bn_from_montgomery_word(ret, t, mont); bn_correct_top(ret); bn_check_top(ret); } BN_CTX_end(ctx); #else BIGNUM *t1, *t2; BN_CTX_start(ctx); t1 = BN_CTX_get(ctx); t2 = BN_CTX_get(ctx); if (t2 == NULL) goto err; if (!BN_copy(t1, a)) goto err; BN_mask_bits(t1, mont->ri); if (!BN_mul(t2, t1, &mont->Ni, ctx)) goto err; BN_mask_bits(t2, mont->ri); if (!BN_mul(t1, t2, &mont->N, ctx)) goto err; if (!BN_add(t2, a, t1)) goto err; if (!BN_rshift(ret, t2, mont->ri)) goto err; if (BN_ucmp(ret, &(mont->N)) >= 0) { if (!BN_usub(ret, ret, &(mont->N))) goto err; } retn = 1; bn_check_top(ret); err: BN_CTX_end(ctx); #endif return retn; }"
1317----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_481f317ebdad07473d5f94ac05bc9c986685159c_1.json----ff_iir_filter_init_coeffs,"<S2SV_StartVul> struct FFIIRFilterCoeffs* ff_iir_filter_init_coeffs(enum IIRFilterType filt_type, <S2SV_EndVul> enum IIRFilterMode filt_mode, int order, float cutoff_ratio, float stopband, float ripple) { int i, j; FFIIRFilterCoeffs *c; double wa; double p[MAXORDER + 1][2]; if(filt_type != FF_FILTER_TYPE_BUTTERWORTH || filt_mode != FF_FILTER_MODE_LOWPASS) return NULL; if(order <= 1 || (order & 1) || order > MAXORDER || cutoff_ratio >= 1.0) return NULL; <S2SV_StartVul> c = av_malloc(sizeof(FFIIRFilterCoeffs)); <S2SV_EndVul> <S2SV_StartVul> c->cx = av_malloc(sizeof(c->cx[0]) * ((order >> 1) + 1)); <S2SV_EndVul> <S2SV_StartVul> c->cy = av_malloc(sizeof(c->cy[0]) * order); <S2SV_EndVul> c->order = order; wa = 2 * tan(M_PI * 0.5 * cutoff_ratio); c->cx[0] = 1; for(i = 1; i < (order >> 1) + 1; i++) c->cx[i] = c->cx[i - 1] * (order - i + 1LL) / i; p[0][0] = 1.0; p[0][1] = 0.0; for(i = 1; i <= order; i++) p[i][0] = p[i][1] = 0.0; for(i = 0; i < order; i++){ double zp[2]; double th = (i + (order >> 1) + 0.5) * M_PI / order; double a_re, a_im, c_re, c_im; zp[0] = cos(th) * wa; zp[1] = sin(th) * wa; a_re = zp[0] + 2.0; c_re = zp[0] - 2.0; a_im = c_im = zp[1]; zp[0] = (a_re * c_re + a_im * c_im) / (c_re * c_re + c_im * c_im); zp[1] = (a_im * c_re - a_re * c_im) / (c_re * c_re + c_im * c_im); for(j = order; j >= 1; j--) { a_re = p[j][0]; a_im = p[j][1]; p[j][0] = a_re*zp[0] - a_im*zp[1] + p[j-1][0]; p[j][1] = a_re*zp[1] + a_im*zp[0] + p[j-1][1]; } a_re = p[0][0]*zp[0] - p[0][1]*zp[1]; p[0][1] = p[0][0]*zp[1] + p[0][1]*zp[0]; p[0][0] = a_re; } c->gain = p[order][0]; for(i = 0; i < order; i++){ c->gain += p[i][0]; c->cy[i] = (-p[i][0] * p[order][0] + -p[i][1] * p[order][1]) / (p[order][0] * p[order][0] + p[order][1] * p[order][1]); } c->gain /= 1 << order; return c; }","- struct FFIIRFilterCoeffs* ff_iir_filter_init_coeffs(enum IIRFilterType filt_type,
- c = av_malloc(sizeof(FFIIRFilterCoeffs));
- c->cx = av_malloc(sizeof(c->cx[0]) * ((order >> 1) + 1));
- c->cy = av_malloc(sizeof(c->cy[0]) * order);
+ struct FFIIRFilterCoeffs* ff_iir_filter_init_coeffs(void *avc,
+ enum IIRFilterType filt_type,
+ FF_ALLOCZ_OR_GOTO(avc, c, sizeof(FFIIRFilterCoeffs),
+ init_fail);
+ FF_ALLOC_OR_GOTO (avc, c->cx, sizeof(c->cx[0]) * ((order >> 1) + 1),
+ init_fail);
+ FF_ALLOC_OR_GOTO (avc, c->cy, sizeof(c->cy[0]) * order,
+ init_fail);
+ init_fail:
+ ff_iir_filter_free_coeffs(c);
+ return NULL;","struct FFIIRFilterCoeffs* ff_iir_filter_init_coeffs(void *avc, enum IIRFilterType filt_type, enum IIRFilterMode filt_mode, int order, float cutoff_ratio, float stopband, float ripple) { int i, j; FFIIRFilterCoeffs *c; double wa; double p[MAXORDER + 1][2]; if(filt_type != FF_FILTER_TYPE_BUTTERWORTH || filt_mode != FF_FILTER_MODE_LOWPASS) return NULL; if(order <= 1 || (order & 1) || order > MAXORDER || cutoff_ratio >= 1.0) return NULL; FF_ALLOCZ_OR_GOTO(avc, c, sizeof(FFIIRFilterCoeffs), init_fail); FF_ALLOC_OR_GOTO (avc, c->cx, sizeof(c->cx[0]) * ((order >> 1) + 1), init_fail); FF_ALLOC_OR_GOTO (avc, c->cy, sizeof(c->cy[0]) * order, init_fail); c->order = order; wa = 2 * tan(M_PI * 0.5 * cutoff_ratio); c->cx[0] = 1; for(i = 1; i < (order >> 1) + 1; i++) c->cx[i] = c->cx[i - 1] * (order - i + 1LL) / i; p[0][0] = 1.0; p[0][1] = 0.0; for(i = 1; i <= order; i++) p[i][0] = p[i][1] = 0.0; for(i = 0; i < order; i++){ double zp[2]; double th = (i + (order >> 1) + 0.5) * M_PI / order; double a_re, a_im, c_re, c_im; zp[0] = cos(th) * wa; zp[1] = sin(th) * wa; a_re = zp[0] + 2.0; c_re = zp[0] - 2.0; a_im = c_im = zp[1]; zp[0] = (a_re * c_re + a_im * c_im) / (c_re * c_re + c_im * c_im); zp[1] = (a_im * c_re - a_re * c_im) / (c_re * c_re + c_im * c_im); for(j = order; j >= 1; j--) { a_re = p[j][0]; a_im = p[j][1]; p[j][0] = a_re*zp[0] - a_im*zp[1] + p[j-1][0]; p[j][1] = a_re*zp[1] + a_im*zp[0] + p[j-1][1]; } a_re = p[0][0]*zp[0] - p[0][1]*zp[1]; p[0][1] = p[0][0]*zp[1] + p[0][1]*zp[0]; p[0][0] = a_re; } c->gain = p[order][0]; for(i = 0; i < order; i++){ c->gain += p[i][0]; c->cy[i] = (-p[i][0] * p[order][0] + -p[i][1] * p[order][1]) / (p[order][0] * p[order][0] + p[order][1] * p[order][1]); } c->gain /= 1 << order; return c; init_fail: ff_iir_filter_free_coeffs(c); return NULL; }"
2026----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6ecdedb75308c5ffaa9a1ee5a2676ed8a4e063e5_1.json----probe_file,"static int probe_file(WriterContext *wctx, const char *filename) { AVFormatContext *fmt_ctx; int ret, i; int section_id; do_read_frames = do_show_frames || do_count_frames; do_read_packets = do_show_packets || do_count_packets; ret = open_input_file(&fmt_ctx, filename); if (ret < 0) return ret; #define CHECK_END if (ret < 0) goto end <S2SV_StartVul> nb_streams_frames = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames)); <S2SV_EndVul> <S2SV_StartVul> nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets)); <S2SV_EndVul> <S2SV_StartVul> selected_streams = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams)); <S2SV_EndVul> for (i = 0; i < fmt_ctx->nb_streams; i++) { if (stream_specifier) { ret = avformat_match_stream_specifier(fmt_ctx, fmt_ctx->streams[i], stream_specifier); CHECK_END; else selected_streams[i] = ret; ret = 0; } else { selected_streams[i] = 1; } } if (do_read_frames || do_read_packets) { if (do_show_frames && do_show_packets && wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER) section_id = SECTION_ID_PACKETS_AND_FRAMES; else if (do_show_packets && !do_show_frames) section_id = SECTION_ID_PACKETS; else section_id = SECTION_ID_FRAMES; if (do_show_frames || do_show_packets) writer_print_section_header(wctx, section_id); ret = read_packets(wctx, fmt_ctx); if (do_show_frames || do_show_packets) writer_print_section_footer(wctx); CHECK_END; } if (do_show_programs) { ret = show_programs(wctx, fmt_ctx); CHECK_END; } if (do_show_streams) { ret = show_streams(wctx, fmt_ctx); CHECK_END; } if (do_show_chapters) { ret = show_chapters(wctx, fmt_ctx); CHECK_END; } if (do_show_format) { ret = show_format(wctx, fmt_ctx); CHECK_END; } end: close_input_file(&fmt_ctx); av_freep(&nb_streams_frames); av_freep(&nb_streams_packets); av_freep(&selected_streams); return ret; }","- nb_streams_frames = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));
- nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));
- selected_streams = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));
+ nb_streams = fmt_ctx->nb_streams;
+ REALLOCZ_ARRAY_STREAM(nb_streams_frames,0,fmt_ctx->nb_streams);
+ REALLOCZ_ARRAY_STREAM(nb_streams_packets,0,fmt_ctx->nb_streams);
+ REALLOCZ_ARRAY_STREAM(selected_streams,0,fmt_ctx->nb_streams);","static int probe_file(WriterContext *wctx, const char *filename) { AVFormatContext *fmt_ctx; int ret, i; int section_id; do_read_frames = do_show_frames || do_count_frames; do_read_packets = do_show_packets || do_count_packets; ret = open_input_file(&fmt_ctx, filename); if (ret < 0) return ret; #define CHECK_END if (ret < 0) goto end nb_streams = fmt_ctx->nb_streams; REALLOCZ_ARRAY_STREAM(nb_streams_frames,0,fmt_ctx->nb_streams); REALLOCZ_ARRAY_STREAM(nb_streams_packets,0,fmt_ctx->nb_streams); REALLOCZ_ARRAY_STREAM(selected_streams,0,fmt_ctx->nb_streams); for (i = 0; i < fmt_ctx->nb_streams; i++) { if (stream_specifier) { ret = avformat_match_stream_specifier(fmt_ctx, fmt_ctx->streams[i], stream_specifier); CHECK_END; else selected_streams[i] = ret; ret = 0; } else { selected_streams[i] = 1; } } if (do_read_frames || do_read_packets) { if (do_show_frames && do_show_packets && wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER) section_id = SECTION_ID_PACKETS_AND_FRAMES; else if (do_show_packets && !do_show_frames) section_id = SECTION_ID_PACKETS; else section_id = SECTION_ID_FRAMES; if (do_show_frames || do_show_packets) writer_print_section_header(wctx, section_id); ret = read_packets(wctx, fmt_ctx); if (do_show_frames || do_show_packets) writer_print_section_footer(wctx); CHECK_END; } if (do_show_programs) { ret = show_programs(wctx, fmt_ctx); CHECK_END; } if (do_show_streams) { ret = show_streams(wctx, fmt_ctx); CHECK_END; } if (do_show_chapters) { ret = show_chapters(wctx, fmt_ctx); CHECK_END; } if (do_show_format) { ret = show_format(wctx, fmt_ctx); CHECK_END; } end: close_input_file(&fmt_ctx); av_freep(&nb_streams_frames); av_freep(&nb_streams_packets); av_freep(&selected_streams); return ret; }"
10308----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_1.json----ubsec_mod_exp_crt,"static int ubsec_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *q, const BIGNUM *dp, const BIGNUM *dq, const BIGNUM *qinv, BN_CTX *ctx) { int y_len, m_len, fd; m_len = BN_num_bytes(p) + BN_num_bytes(q) + 1; y_len = BN_num_bits(p) + BN_num_bits(q); <S2SV_StartVul> if (y_len > 1024) { <S2SV_EndVul> UBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL); <S2SV_StartVul> return 0; <S2SV_EndVul> } if (!bn_wexpand(r, p->top + q->top + 1)) { UBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP_CRT, UBSEC_R_BN_EXPAND_FAIL); return 0; } if ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) { fd = 0; UBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_UNIT_FAILURE); <S2SV_StartVul> return 0; <S2SV_EndVul> } if (p_UBSEC_rsa_mod_exp_crt_ioctl(fd, (unsigned char *)a->d, BN_num_bits(a), (unsigned char *)qinv->d, BN_num_bits(qinv), (unsigned char *)dp->d, BN_num_bits(dp), (unsigned char *)p->d, BN_num_bits(p), (unsigned char *)dq->d, BN_num_bits(dq), (unsigned char *)q->d, BN_num_bits(q), (unsigned char *)r->d, &y_len) != 0) { UBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_REQUEST_FAILED); <S2SV_StartVul> return 0; <S2SV_EndVul> } p_UBSEC_ubsec_close(fd); r->top = (BN_num_bits(p) + BN_num_bits(q) + BN_BITS2 - 1)/BN_BITS2; return 1; }","- if (y_len > 1024) {
- return 0;
- return 0;
- return 0;
+ if (y_len > max_key_len) {
+ return FAIL_TO_SOFTWARE;
+ return FAIL_TO_SOFTWARE;
+ p_UBSEC_ubsec_close(fd);
+ return FAIL_TO_SOFTWARE;","static int ubsec_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, const BIGNUM *q, const BIGNUM *dp, const BIGNUM *dq, const BIGNUM *qinv, BN_CTX *ctx) { int y_len, m_len, fd; m_len = BN_num_bytes(p) + BN_num_bytes(q) + 1; y_len = BN_num_bits(p) + BN_num_bits(q); if (y_len > max_key_len) { UBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL); return FAIL_TO_SOFTWARE; } if (!bn_wexpand(r, p->top + q->top + 1)) { UBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP_CRT, UBSEC_R_BN_EXPAND_FAIL); return 0; } if ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) { fd = 0; UBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_UNIT_FAILURE); return FAIL_TO_SOFTWARE; } if (p_UBSEC_rsa_mod_exp_crt_ioctl(fd, (unsigned char *)a->d, BN_num_bits(a), (unsigned char *)qinv->d, BN_num_bits(qinv), (unsigned char *)dp->d, BN_num_bits(dp), (unsigned char *)p->d, BN_num_bits(p), (unsigned char *)dq->d, BN_num_bits(dq), (unsigned char *)q->d, BN_num_bits(q), (unsigned char *)r->d, &y_len) != 0) { UBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_REQUEST_FAILED); p_UBSEC_ubsec_close(fd); return FAIL_TO_SOFTWARE; } p_UBSEC_ubsec_close(fd); r->top = (BN_num_bits(p) + BN_num_bits(q) + BN_BITS2 - 1)/BN_BITS2; return 1; }"
4948----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_f2c99cd60672ee9be2773e0767b028a2ccac7dba_1.json----proxy_connect_handler,"static int proxy_connect_handler(request_rec *r, proxy_worker *worker, proxy_server_conf *conf, char *url, const char *proxyname, apr_port_t proxyport) { connect_conf *c_conf = ap_get_module_config(r->server->module_config, &proxy_connect_module); apr_pool_t *p = r->pool; apr_socket_t *sock; conn_rec *c = r->connection; conn_rec *backconn; apr_status_t rv; apr_size_t nbytes; char buffer[HUGE_STRING_LEN]; apr_bucket_brigade *bb; proxy_tunnel_rec *tunnel; int failed, rc; apr_uri_t uri; const char *connectname; apr_port_t connectport = 0; apr_sockaddr_t *nexthop; if (r->method_number != M_CONNECT) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""declining URL %s"", url); return DECLINED; } ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""serving URL %s"", url); if (APR_SUCCESS != apr_uri_parse_hostinfo(p, url, &uri)) { return ap_proxyerror(r, HTTP_BAD_REQUEST, apr_pstrcat(p, ""URI cannot be parsed: "", url, NULL)); } ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01019) ""connecting %s to %s:%d"", url, uri.hostname, uri.port); connectname = proxyname ? proxyname : uri.hostname; connectport = proxyname ? proxyport : uri.port; rv = apr_sockaddr_info_get(&nexthop, connectname, APR_UNSPEC, connectport, 0, p); if (rv != APR_SUCCESS) { ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02327) ""failed to resolve hostname '%s'"", connectname); return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(p, ""DNS lookup failure for: "", connectname, NULL)); } if (ap_proxy_checkproxyblock(r, conf, uri.hostname, proxyname ? NULL : nexthop) != OK) { return ap_proxyerror(r, HTTP_FORBIDDEN, ""Connect to remote machine blocked""); } ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""connecting to remote proxy %s on port %d"", connectname, connectport); if (!allowed_port(c_conf, uri.port)) { return ap_proxyerror(r, HTTP_FORBIDDEN, ""Connect to remote machine blocked""); } failed = ap_proxy_connect_to_backend(&sock, ""CONNECT"", nexthop, connectname, conf, r); if (failed) { if (proxyname) { return DECLINED; } else { return HTTP_SERVICE_UNAVAILABLE; } } backconn = ap_run_create_connection(c->pool, r->server, sock, c->id, c->sbh, c->bucket_alloc); if (!backconn) { ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01021) ""an error occurred creating a new connection "" ""to %pI (%s)"", nexthop, connectname); apr_socket_close(sock); return HTTP_INTERNAL_SERVER_ERROR; } ap_proxy_ssl_engine(backconn, r->per_dir_config, 0); rc = ap_run_pre_connection(backconn, sock); if (rc != OK && rc != DONE) { backconn->aborted = 1; ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01022) ""pre_connection setup failed (%d)"", rc); apr_socket_close(sock); return HTTP_INTERNAL_SERVER_ERROR; } ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r, ""connection complete to %pI (%s)"", nexthop, connectname); apr_table_setn(r->notes, ""proxy-source-port"", apr_psprintf(r->pool, ""%hu"", backconn->local_addr->port)); bb = apr_brigade_create(p, c->bucket_alloc); if (proxyport) { ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""sending the CONNECT request to the remote proxy""); ap_fprintf(backconn->output_filters, bb, ""CONNECT %s HTTP/1.0"" CRLF, r->uri); ap_fprintf(backconn->output_filters, bb, ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner()); ap_fflush(backconn->output_filters, bb); } else { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""Returning 200 OK""); nbytes = apr_snprintf(buffer, sizeof(buffer), ""HTTP/1.0 200 Connection Established"" CRLF); ap_xlate_proto_to_ascii(buffer, nbytes); ap_fwrite(c->output_filters, bb, buffer, nbytes); nbytes = apr_snprintf(buffer, sizeof(buffer), ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner()); ap_xlate_proto_to_ascii(buffer, nbytes); ap_fwrite(c->output_filters, bb, buffer, nbytes); ap_fflush(c->output_filters, bb); #if 0 r->status = HTTP_OK; r->header_only = 1; apr_table_set(r->headers_out, ""Proxy-agent: %s"", ap_get_server_banner()); ap_rflush(r); #endif } apr_brigade_cleanup(bb); <S2SV_StartVul> rv = ap_proxy_tunnel_create(&tunnel, r, backconn); <S2SV_EndVul> if (rv != APR_SUCCESS) { ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10208) ""can't create tunnel for %pI (%s)"", nexthop, connectname); return HTTP_INTERNAL_SERVER_ERROR; } rc = ap_proxy_tunnel_run(tunnel); if (ap_is_HTTP_ERROR(rc)) { if (proxyport && !tunnel->replied) { return rc; } r->status = rc; } if (backconn->aborted) apr_socket_close(sock); else ap_lingering_close(backconn); return OK; }","- rv = ap_proxy_tunnel_create(&tunnel, r, backconn);
+ rv = ap_proxy_tunnel_create(&tunnel, r, backconn, ""CONNECT"");
+ if (rc == HTTP_GATEWAY_TIME_OUT) {
+ ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10224)
+ ""tunnel timed out"");
+ }","static int proxy_connect_handler(request_rec *r, proxy_worker *worker, proxy_server_conf *conf, char *url, const char *proxyname, apr_port_t proxyport) { connect_conf *c_conf = ap_get_module_config(r->server->module_config, &proxy_connect_module); apr_pool_t *p = r->pool; apr_socket_t *sock; conn_rec *c = r->connection; conn_rec *backconn; apr_status_t rv; apr_size_t nbytes; char buffer[HUGE_STRING_LEN]; apr_bucket_brigade *bb; proxy_tunnel_rec *tunnel; int failed, rc; apr_uri_t uri; const char *connectname; apr_port_t connectport = 0; apr_sockaddr_t *nexthop; if (r->method_number != M_CONNECT) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""declining URL %s"", url); return DECLINED; } ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""serving URL %s"", url); if (APR_SUCCESS != apr_uri_parse_hostinfo(p, url, &uri)) { return ap_proxyerror(r, HTTP_BAD_REQUEST, apr_pstrcat(p, ""URI cannot be parsed: "", url, NULL)); } ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01019) ""connecting %s to %s:%d"", url, uri.hostname, uri.port); connectname = proxyname ? proxyname : uri.hostname; connectport = proxyname ? proxyport : uri.port; rv = apr_sockaddr_info_get(&nexthop, connectname, APR_UNSPEC, connectport, 0, p); if (rv != APR_SUCCESS) { ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02327) ""failed to resolve hostname '%s'"", connectname); return ap_proxyerror(r, HTTP_BAD_GATEWAY, apr_pstrcat(p, ""DNS lookup failure for: "", connectname, NULL)); } if (ap_proxy_checkproxyblock(r, conf, uri.hostname, proxyname ? NULL : nexthop) != OK) { return ap_proxyerror(r, HTTP_FORBIDDEN, ""Connect to remote machine blocked""); } ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""connecting to remote proxy %s on port %d"", connectname, connectport); if (!allowed_port(c_conf, uri.port)) { return ap_proxyerror(r, HTTP_FORBIDDEN, ""Connect to remote machine blocked""); } failed = ap_proxy_connect_to_backend(&sock, ""CONNECT"", nexthop, connectname, conf, r); if (failed) { if (proxyname) { return DECLINED; } else { return HTTP_SERVICE_UNAVAILABLE; } } backconn = ap_run_create_connection(c->pool, r->server, sock, c->id, c->sbh, c->bucket_alloc); if (!backconn) { ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01021) ""an error occurred creating a new connection "" ""to %pI (%s)"", nexthop, connectname); apr_socket_close(sock); return HTTP_INTERNAL_SERVER_ERROR; } ap_proxy_ssl_engine(backconn, r->per_dir_config, 0); rc = ap_run_pre_connection(backconn, sock); if (rc != OK && rc != DONE) { backconn->aborted = 1; ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01022) ""pre_connection setup failed (%d)"", rc); apr_socket_close(sock); return HTTP_INTERNAL_SERVER_ERROR; } ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r, ""connection complete to %pI (%s)"", nexthop, connectname); apr_table_setn(r->notes, ""proxy-source-port"", apr_psprintf(r->pool, ""%hu"", backconn->local_addr->port)); bb = apr_brigade_create(p, c->bucket_alloc); if (proxyport) { ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""sending the CONNECT request to the remote proxy""); ap_fprintf(backconn->output_filters, bb, ""CONNECT %s HTTP/1.0"" CRLF, r->uri); ap_fprintf(backconn->output_filters, bb, ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner()); ap_fflush(backconn->output_filters, bb); } else { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""Returning 200 OK""); nbytes = apr_snprintf(buffer, sizeof(buffer), ""HTTP/1.0 200 Connection Established"" CRLF); ap_xlate_proto_to_ascii(buffer, nbytes); ap_fwrite(c->output_filters, bb, buffer, nbytes); nbytes = apr_snprintf(buffer, sizeof(buffer), ""Proxy-agent: %s"" CRLF CRLF, ap_get_server_banner()); ap_xlate_proto_to_ascii(buffer, nbytes); ap_fwrite(c->output_filters, bb, buffer, nbytes); ap_fflush(c->output_filters, bb); #if 0 r->status = HTTP_OK; r->header_only = 1; apr_table_set(r->headers_out, ""Proxy-agent: %s"", ap_get_server_banner()); ap_rflush(r); #endif } apr_brigade_cleanup(bb); rv = ap_proxy_tunnel_create(&tunnel, r, backconn, ""CONNECT""); if (rv != APR_SUCCESS) { ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10208) ""can't create tunnel for %pI (%s)"", nexthop, connectname); return HTTP_INTERNAL_SERVER_ERROR; } rc = ap_proxy_tunnel_run(tunnel); if (ap_is_HTTP_ERROR(rc)) { if (rc == HTTP_GATEWAY_TIME_OUT) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10224) ""tunnel timed out""); } if (proxyport && !tunnel->replied) { return rc; } r->status = rc; } if (backconn->aborted) apr_socket_close(sock); else ap_lingering_close(backconn); return OK; }"
3260----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b16469e6e157af1fbbc4e6e6fefb856898969227_1.json----jpeg2000_read_main_headers,"static int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s) { Jpeg2000CodingStyle *codsty = s->codsty; Jpeg2000QuantStyle *qntsty = s->qntsty; uint8_t *properties = s->properties; for (;;) { int len, ret = 0; uint16_t marker; <S2SV_StartVul> const uint8_t *oldbuf; <S2SV_EndVul> <S2SV_StartVul> if (s->buf_end - s->buf < 2) { <S2SV_EndVul> av_log(s->avctx, AV_LOG_ERROR, ""Missing EOC\n""); break; } <S2SV_StartVul> marker = bytestream_get_be16(&s->buf); <S2SV_EndVul> <S2SV_StartVul> oldbuf = s->buf; <S2SV_EndVul> if (marker == JPEG2000_EOC) break; <S2SV_StartVul> if (s->buf_end - s->buf < 2) <S2SV_EndVul> return AVERROR(EINVAL); <S2SV_StartVul> len = bytestream_get_be16(&s->buf); <S2SV_EndVul> switch (marker) { case JPEG2000_SIZ: ret = get_siz(s); break; case JPEG2000_COC: ret = get_coc(s, codsty, properties); break; case JPEG2000_COD: ret = get_cod(s, codsty, properties); break; case JPEG2000_QCC: ret = get_qcc(s, len, qntsty, properties); break; case JPEG2000_QCD: ret = get_qcd(s, len, qntsty, properties); break; case JPEG2000_SOT: ret = get_sot(s, len); break; case JPEG2000_COM: <S2SV_StartVul> s->buf += len - 2; <S2SV_EndVul> break; case JPEG2000_TLM: ret = get_tlm(s, len); break; default: av_log(s->avctx, AV_LOG_ERROR, ""unsupported marker 0x%.4X at pos 0x%tX\n"", <S2SV_StartVul> marker, s->buf - s->buf_start - 4); <S2SV_EndVul> <S2SV_StartVul> s->buf += len - 2; <S2SV_EndVul> break; } <S2SV_StartVul> if (((s->buf - oldbuf != len) && (marker != JPEG2000_SOT)) || ret) { <S2SV_EndVul> av_log(s->avctx, AV_LOG_ERROR, ""error during processing marker segment %.4x\n"", marker); return ret ? ret : -1; } } return 0; }","- const uint8_t *oldbuf;
- if (s->buf_end - s->buf < 2) {
- marker = bytestream_get_be16(&s->buf);
- oldbuf = s->buf;
- if (s->buf_end - s->buf < 2)
- len = bytestream_get_be16(&s->buf);
- s->buf += len - 2;
- marker, s->buf - s->buf_start - 4);
- s->buf += len - 2;
- if (((s->buf - oldbuf != len) && (marker != JPEG2000_SOT)) || ret) {
+ int oldpos;
+ if (bytestream2_get_bytes_left(&s->g) < 2) {
+ marker = bytestream2_get_be16u(&s->g);
+ oldpos = bytestream2_tell(&s->g);
+ if (bytestream2_get_bytes_left(&s->g) < 2)
+ len = bytestream2_get_be16u(&s->g);
+ bytestream2_skip(&s->g, len - 2);
+ marker, bytestream2_tell(&s->g) - 4);
+ bytestream2_skip(&s->g, len - 2);
+ if (((bytestream2_tell(&s->g) - oldpos != len) && (marker != JPEG2000_SOT)) || ret) {","static int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s) { Jpeg2000CodingStyle *codsty = s->codsty; Jpeg2000QuantStyle *qntsty = s->qntsty; uint8_t *properties = s->properties; for (;;) { int len, ret = 0; uint16_t marker; int oldpos; if (bytestream2_get_bytes_left(&s->g) < 2) { av_log(s->avctx, AV_LOG_ERROR, ""Missing EOC\n""); break; } marker = bytestream2_get_be16u(&s->g); oldpos = bytestream2_tell(&s->g); if (marker == JPEG2000_EOC) break; if (bytestream2_get_bytes_left(&s->g) < 2) return AVERROR(EINVAL); len = bytestream2_get_be16u(&s->g); switch (marker) { case JPEG2000_SIZ: ret = get_siz(s); break; case JPEG2000_COC: ret = get_coc(s, codsty, properties); break; case JPEG2000_COD: ret = get_cod(s, codsty, properties); break; case JPEG2000_QCC: ret = get_qcc(s, len, qntsty, properties); break; case JPEG2000_QCD: ret = get_qcd(s, len, qntsty, properties); break; case JPEG2000_SOT: ret = get_sot(s, len); break; case JPEG2000_COM: bytestream2_skip(&s->g, len - 2); break; case JPEG2000_TLM: ret = get_tlm(s, len); break; default: av_log(s->avctx, AV_LOG_ERROR, ""unsupported marker 0x%.4X at pos 0x%tX\n"", marker, bytestream2_tell(&s->g) - 4); bytestream2_skip(&s->g, len - 2); break; } if (((bytestream2_tell(&s->g) - oldpos != len) && (marker != JPEG2000_SOT)) || ret) { av_log(s->avctx, AV_LOG_ERROR, ""error during processing marker segment %.4x\n"", marker); return ret ? ret : -1; } } return 0; }"
8146----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_bd055b74c019049025bcfe911a2e10b6e1a8910d_1.json----flv_read_packet,"static int flv_read_packet(AVFormatContext *s, AVPacket *pkt) { FLVContext *flv = s->priv_data; int ret, i, size, flags, is_audio; enum FlvTagType type; int64_t next, pos; int64_t dts, pts = AV_NOPTS_VALUE; int sample_rate = 0, channels = 0; AVStream *st = NULL; for (;; avio_skip(s->pb, 4)) { pos = avio_tell(s->pb); type = avio_r8(s->pb); size = avio_rb24(s->pb); dts = avio_rb24(s->pb); dts |= avio_r8(s->pb) << 24; av_log(s, AV_LOG_TRACE, ""type:%d, size:%d, dts:%""PRId64""\n"", type, size, dts); if (s->pb->eof_reached) return AVERROR_EOF; avio_skip(s->pb, 3); flags = 0; if (flv->validate_next < flv->validate_count) { int64_t validate_pos = flv->validate_index[flv->validate_next].pos; if (pos == validate_pos) { if (FFABS(dts - flv->validate_index[flv->validate_next].dts) <= VALIDATE_INDEX_TS_THRESH) { flv->validate_next++; } else { clear_index_entries(s, validate_pos); flv->validate_count = 0; } } else if (pos > validate_pos) { clear_index_entries(s, validate_pos); flv->validate_count = 0; } } if (size == 0) continue; next = size + avio_tell(s->pb); if (type == FLV_TAG_TYPE_AUDIO) { is_audio = 1; flags = avio_r8(s->pb); size--; } else if (type == FLV_TAG_TYPE_VIDEO) { is_audio = 0; flags = avio_r8(s->pb); size--; if ((flags & 0xf0) == 0x50) goto skip; } else { if (type == FLV_TAG_TYPE_META && size > 13 + 1 + 4) if (flv_read_metabody(s, next) > 0) { return flv_data_packet(s, pkt, dts, next); } else av_log(s, AV_LOG_DEBUG, ""Skipping flv packet: type %d, size %d, flags %d.\n"", type, size, flags); skip: avio_seek(s->pb, next, SEEK_SET); continue; } if (!size) continue; for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; if (is_audio && st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (flv_same_audio_codec(st->codec, flags)) break; } else if (!is_audio && st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (flv_same_video_codec(st->codec, flags)) break; } } if (i == s->nb_streams) { st = create_stream(s, is_audio ? AVMEDIA_TYPE_AUDIO : AVMEDIA_TYPE_VIDEO); if (!st) return AVERROR(ENOMEM); } av_log(s, AV_LOG_TRACE, ""%d %X %d \n"", is_audio, flags, st->discard); if ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || is_audio) av_add_index_entry(st, pos, dts, size, 0, AVINDEX_KEYFRAME); if ((st->discard >= AVDISCARD_NONKEY && !((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || is_audio)) || (st->discard >= AVDISCARD_BIDIR && ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_DISP_INTER && !is_audio)) || st->discard >= AVDISCARD_ALL) { avio_seek(s->pb, next, SEEK_SET); continue; } break; } if (s->pb->seekable && (!s->duration || s->duration == AV_NOPTS_VALUE) && !flv->searched_for_end) { int size; const int64_t pos = avio_tell(s->pb); const int64_t fsize = avio_size(s->pb); avio_seek(s->pb, fsize - 4, SEEK_SET); size = avio_rb32(s->pb); <S2SV_StartVul> avio_seek(s->pb, fsize - 3 - size, SEEK_SET); <S2SV_EndVul> <S2SV_StartVul> if (size == avio_rb24(s->pb) + 11) { <S2SV_EndVul> <S2SV_StartVul> uint32_t ts = avio_rb24(s->pb); <S2SV_EndVul> <S2SV_StartVul> ts |= avio_r8(s->pb) << 24; <S2SV_EndVul> <S2SV_StartVul> s->duration = ts * (int64_t)AV_TIME_BASE / 1000; <S2SV_EndVul> } avio_seek(s->pb, pos, SEEK_SET); flv->searched_for_end = 1; } if (is_audio) { int bits_per_coded_sample; channels = (flags & FLV_AUDIO_CHANNEL_MASK) == FLV_STEREO ? 2 : 1; sample_rate = 44100 << ((flags & FLV_AUDIO_SAMPLERATE_MASK) >> FLV_AUDIO_SAMPLERATE_OFFSET) >> 3; bits_per_coded_sample = (flags & FLV_AUDIO_SAMPLESIZE_MASK) ? 16 : 8; if (!st->codec->channels || !st->codec->sample_rate || !st->codec->bits_per_coded_sample) { st->codec->channels = channels; st->codec->channel_layout = channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO; st->codec->sample_rate = sample_rate; st->codec->bits_per_coded_sample = bits_per_coded_sample; } if (!st->codec->codec_id) { flv_set_audio_codec(s, st, st->codec, flags & FLV_AUDIO_CODECID_MASK); flv->last_sample_rate = sample_rate = st->codec->sample_rate; flv->last_channels = channels = st->codec->channels; } else { AVCodecContext ctx; ctx.sample_rate = sample_rate; ctx.bits_per_coded_sample = bits_per_coded_sample; flv_set_audio_codec(s, st, &ctx, flags & FLV_AUDIO_CODECID_MASK); sample_rate = ctx.sample_rate; } } else { size -= flv_set_video_codec(s, st, flags & FLV_VIDEO_CODECID_MASK, 1); } if (st->codec->codec_id == AV_CODEC_ID_AAC || st->codec->codec_id == AV_CODEC_ID_H264) { int type = avio_r8(s->pb); size--; if (st->codec->codec_id == AV_CODEC_ID_H264) { int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000; pts = dts + cts; if (cts < 0 && !flv->wrong_dts) { flv->wrong_dts = 1; av_log(s, AV_LOG_WARNING, ""Negative cts, previous timestamps might be wrong.\n""); } } if (type == 0) { if (st->codec->extradata) { if ((ret = flv_queue_extradata(flv, s->pb, is_audio, size)) < 0) return ret; ret = AVERROR(EAGAIN); goto leave; } if ((ret = flv_get_extradata(s, st, size)) < 0) return ret; if (st->codec->codec_id == AV_CODEC_ID_AAC) { MPEG4AudioConfig cfg; AVDictionaryEntry *t = av_dict_get(s->metadata, ""Encoder"", NULL, 0); if (t && !strcmp(t->value, ""Omnia A/XE"")) st->codec->extradata_size = 2; avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata, st->codec->extradata_size * 8, 1); st->codec->channels = cfg.channels; st->codec->channel_layout = 0; if (cfg.ext_sample_rate) st->codec->sample_rate = cfg.ext_sample_rate; else st->codec->sample_rate = cfg.sample_rate; av_log(s, AV_LOG_TRACE, ""mp4a config channels %d sample rate %d\n"", st->codec->channels, st->codec->sample_rate); } ret = AVERROR(EAGAIN); goto leave; } } if (!size) { ret = AVERROR(EAGAIN); goto leave; } ret = av_get_packet(s->pb, pkt, size); if (ret < 0) return AVERROR(EIO); pkt->size = ret; pkt->dts = dts; pkt->pts = pts == AV_NOPTS_VALUE ? dts : pts; pkt->stream_index = st->index; if (flv->new_extradata[is_audio]) { uint8_t *side = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, flv->new_extradata_size[is_audio]); if (side) { memcpy(side, flv->new_extradata[is_audio], flv->new_extradata_size[is_audio]); av_freep(&flv->new_extradata[is_audio]); flv->new_extradata_size[is_audio] = 0; } } if (is_audio && (sample_rate != flv->last_sample_rate || channels != flv->last_channels)) { flv->last_sample_rate = sample_rate; flv->last_channels = channels; ff_add_param_change(pkt, channels, 0, sample_rate, 0, 0); } if (is_audio || ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY)) pkt->flags |= AV_PKT_FLAG_KEY; leave: avio_skip(s->pb, 4); return ret; }","- avio_seek(s->pb, fsize - 3 - size, SEEK_SET);
- if (size == avio_rb24(s->pb) + 11) {
- uint32_t ts = avio_rb24(s->pb);
- ts |= avio_r8(s->pb) << 24;
- s->duration = ts * (int64_t)AV_TIME_BASE / 1000;
+ if (size > 0 && size < fsize) {
+ avio_seek(s->pb, fsize - 3 - size, SEEK_SET);
+ if (size == avio_rb24(s->pb) + 11) {
+ uint32_t ts = avio_rb24(s->pb);
+ ts |= avio_r8(s->pb) << 24;
+ s->duration = ts * (int64_t)AV_TIME_BASE / 1000;
+ }","static int flv_read_packet(AVFormatContext *s, AVPacket *pkt) { FLVContext *flv = s->priv_data; int ret, i, size, flags, is_audio; enum FlvTagType type; int64_t next, pos; int64_t dts, pts = AV_NOPTS_VALUE; int sample_rate = 0, channels = 0; AVStream *st = NULL; for (;; avio_skip(s->pb, 4)) { pos = avio_tell(s->pb); type = avio_r8(s->pb); size = avio_rb24(s->pb); dts = avio_rb24(s->pb); dts |= avio_r8(s->pb) << 24; av_log(s, AV_LOG_TRACE, ""type:%d, size:%d, dts:%""PRId64""\n"", type, size, dts); if (s->pb->eof_reached) return AVERROR_EOF; avio_skip(s->pb, 3); flags = 0; if (flv->validate_next < flv->validate_count) { int64_t validate_pos = flv->validate_index[flv->validate_next].pos; if (pos == validate_pos) { if (FFABS(dts - flv->validate_index[flv->validate_next].dts) <= VALIDATE_INDEX_TS_THRESH) { flv->validate_next++; } else { clear_index_entries(s, validate_pos); flv->validate_count = 0; } } else if (pos > validate_pos) { clear_index_entries(s, validate_pos); flv->validate_count = 0; } } if (size == 0) continue; next = size + avio_tell(s->pb); if (type == FLV_TAG_TYPE_AUDIO) { is_audio = 1; flags = avio_r8(s->pb); size--; } else if (type == FLV_TAG_TYPE_VIDEO) { is_audio = 0; flags = avio_r8(s->pb); size--; if ((flags & 0xf0) == 0x50) goto skip; } else { if (type == FLV_TAG_TYPE_META && size > 13 + 1 + 4) if (flv_read_metabody(s, next) > 0) { return flv_data_packet(s, pkt, dts, next); } else av_log(s, AV_LOG_DEBUG, ""Skipping flv packet: type %d, size %d, flags %d.\n"", type, size, flags); skip: avio_seek(s->pb, next, SEEK_SET); continue; } if (!size) continue; for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; if (is_audio && st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if (flv_same_audio_codec(st->codec, flags)) break; } else if (!is_audio && st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if (flv_same_video_codec(st->codec, flags)) break; } } if (i == s->nb_streams) { st = create_stream(s, is_audio ? AVMEDIA_TYPE_AUDIO : AVMEDIA_TYPE_VIDEO); if (!st) return AVERROR(ENOMEM); } av_log(s, AV_LOG_TRACE, ""%d %X %d \n"", is_audio, flags, st->discard); if ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || is_audio) av_add_index_entry(st, pos, dts, size, 0, AVINDEX_KEYFRAME); if ((st->discard >= AVDISCARD_NONKEY && !((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || is_audio)) || (st->discard >= AVDISCARD_BIDIR && ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_DISP_INTER && !is_audio)) || st->discard >= AVDISCARD_ALL) { avio_seek(s->pb, next, SEEK_SET); continue; } break; } if (s->pb->seekable && (!s->duration || s->duration == AV_NOPTS_VALUE) && !flv->searched_for_end) { int size; const int64_t pos = avio_tell(s->pb); const int64_t fsize = avio_size(s->pb); avio_seek(s->pb, fsize - 4, SEEK_SET); size = avio_rb32(s->pb); if (size > 0 && size < fsize) { avio_seek(s->pb, fsize - 3 - size, SEEK_SET); if (size == avio_rb24(s->pb) + 11) { uint32_t ts = avio_rb24(s->pb); ts |= avio_r8(s->pb) << 24; s->duration = ts * (int64_t)AV_TIME_BASE / 1000; } } avio_seek(s->pb, pos, SEEK_SET); flv->searched_for_end = 1; } if (is_audio) { int bits_per_coded_sample; channels = (flags & FLV_AUDIO_CHANNEL_MASK) == FLV_STEREO ? 2 : 1; sample_rate = 44100 << ((flags & FLV_AUDIO_SAMPLERATE_MASK) >> FLV_AUDIO_SAMPLERATE_OFFSET) >> 3; bits_per_coded_sample = (flags & FLV_AUDIO_SAMPLESIZE_MASK) ? 16 : 8; if (!st->codec->channels || !st->codec->sample_rate || !st->codec->bits_per_coded_sample) { st->codec->channels = channels; st->codec->channel_layout = channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO; st->codec->sample_rate = sample_rate; st->codec->bits_per_coded_sample = bits_per_coded_sample; } if (!st->codec->codec_id) { flv_set_audio_codec(s, st, st->codec, flags & FLV_AUDIO_CODECID_MASK); flv->last_sample_rate = sample_rate = st->codec->sample_rate; flv->last_channels = channels = st->codec->channels; } else { AVCodecContext ctx; ctx.sample_rate = sample_rate; ctx.bits_per_coded_sample = bits_per_coded_sample; flv_set_audio_codec(s, st, &ctx, flags & FLV_AUDIO_CODECID_MASK); sample_rate = ctx.sample_rate; } } else { size -= flv_set_video_codec(s, st, flags & FLV_VIDEO_CODECID_MASK, 1); } if (st->codec->codec_id == AV_CODEC_ID_AAC || st->codec->codec_id == AV_CODEC_ID_H264) { int type = avio_r8(s->pb); size--; if (st->codec->codec_id == AV_CODEC_ID_H264) { int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000; pts = dts + cts; if (cts < 0 && !flv->wrong_dts) { flv->wrong_dts = 1; av_log(s, AV_LOG_WARNING, ""Negative cts, previous timestamps might be wrong.\n""); } } if (type == 0) { if (st->codec->extradata) { if ((ret = flv_queue_extradata(flv, s->pb, is_audio, size)) < 0) return ret; ret = AVERROR(EAGAIN); goto leave; } if ((ret = flv_get_extradata(s, st, size)) < 0) return ret; if (st->codec->codec_id == AV_CODEC_ID_AAC) { MPEG4AudioConfig cfg; AVDictionaryEntry *t = av_dict_get(s->metadata, ""Encoder"", NULL, 0); if (t && !strcmp(t->value, ""Omnia A/XE"")) st->codec->extradata_size = 2; avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata, st->codec->extradata_size * 8, 1); st->codec->channels = cfg.channels; st->codec->channel_layout = 0; if (cfg.ext_sample_rate) st->codec->sample_rate = cfg.ext_sample_rate; else st->codec->sample_rate = cfg.sample_rate; av_log(s, AV_LOG_TRACE, ""mp4a config channels %d sample rate %d\n"", st->codec->channels, st->codec->sample_rate); } ret = AVERROR(EAGAIN); goto leave; } } if (!size) { ret = AVERROR(EAGAIN); goto leave; } ret = av_get_packet(s->pb, pkt, size); if (ret < 0) return AVERROR(EIO); pkt->size = ret; pkt->dts = dts; pkt->pts = pts == AV_NOPTS_VALUE ? dts : pts; pkt->stream_index = st->index; if (flv->new_extradata[is_audio]) { uint8_t *side = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, flv->new_extradata_size[is_audio]); if (side) { memcpy(side, flv->new_extradata[is_audio], flv->new_extradata_size[is_audio]); av_freep(&flv->new_extradata[is_audio]); flv->new_extradata_size[is_audio] = 0; } } if (is_audio && (sample_rate != flv->last_sample_rate || channels != flv->last_channels)) { flv->last_sample_rate = sample_rate; flv->last_channels = channels; ff_add_param_change(pkt, channels, 0, sample_rate, 0, 0); } if (is_audio || ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY)) pkt->flags |= AV_PKT_FLAG_KEY; leave: avio_skip(s->pb, 4); return ret; }"
3778----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cb19c6b56b75a29dbb27a18e7101b58840683d35_1.json----mkv_write_header,"static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header, segment_info; AVDictionaryEntry *tag; int ret, i, version = 2; if (!strcmp(s->oformat->name, ""webm"")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (s->avoid_negative_ts < 0) { s->avoid_negative_ts = 1; s->internal->avoid_negative_ts_use_pts = 1; } if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->metadata, ""alpha_mode"", NULL, 0)) version = 4; for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codec->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codec->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codec->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codec->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codec->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codec->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, ""The Matroska muxer does not yet support muxing %s\n"", avcodec_get_name(s->streams[i]->codec->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codec->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->streams[i]->metadata, ""alpha_mode"", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); <S2SV_StartVul> if (!mkv->tracks) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); <S2SV_StartVul> if (!mkv->main_seekhead) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); <S2SV_StartVul> if (ret < 0) return ret; <S2SV_EndVul> segment_info = start_ebml_master(pb, MATROSKA_ID_INFO, 0); put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if ((tag = av_dict_get(s->metadata, ""title"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { uint32_t segment_uid[4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) segment_uid[i] = av_lfg_get(&lfg); put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if ((tag = av_dict_get(s->metadata, ""encoding_tool"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16); } else { const char *ident = ""Lavf""; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (tag = av_dict_get(s->metadata, ""creation_time"", NULL, 0)) { int64_t date_utc = (ff_iso8601_to_unix_time(tag->value) - 978307200) * 1000000000; uint8_t date_utc_buf[8]; AV_WB64(date_utc_buf, date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { put_ebml_void(pb, 11); } end_ebml_master(pb, segment_info); mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); ret = mkv_write_tracks(s); if (ret < 0) <S2SV_StartVul> return ret; <S2SV_EndVul> for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); if (mkv->mode != MODE_WEBM) { ret = mkv_write_chapters(s); if (ret < 0) <S2SV_StartVul> return ret; <S2SV_EndVul> ret = mkv_write_tags(s); if (ret < 0) <S2SV_StartVul> return ret; <S2SV_EndVul> ret = mkv_write_attachments(s); if (ret < 0) <S2SV_StartVul> return ret; <S2SV_EndVul> } if (!s->pb->seekable && !mkv->is_live) <S2SV_StartVul> mkv_write_seekhead(pb, mkv->main_seekhead); <S2SV_EndVul> mkv->cues = mkv_start_cues(mkv->segment_offset); <S2SV_StartVul> if (!mkv->cues) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> if (pb->seekable && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; }","- if (!mkv->tracks)
- return AVERROR(ENOMEM);
- if (!mkv->main_seekhead)
- return AVERROR(ENOMEM);
- if (ret < 0) return ret;
- return ret;
- return ret;
- return ret;
- return ret;
- mkv_write_seekhead(pb, mkv->main_seekhead);
- if (!mkv->cues)
- return AVERROR(ENOMEM);
+ if (!mkv->tracks) {
+ ret = AVERROR(ENOMEM);
+ goto fail;
+ }
+ if (!mkv->main_seekhead) {
+ ret = AVERROR(ENOMEM);
+ goto fail;
+ }
+ if (ret < 0) goto fail;
+ goto fail;
+ goto fail;
+ goto fail;
+ goto fail;
+ mkv_write_seekhead(pb, mkv);
+ if (!mkv->cues) {
+ ret = AVERROR(ENOMEM);
+ goto fail;
+ }
+ fail:
+ mkv_free(mkv);
+ return ret;","static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header, segment_info; AVDictionaryEntry *tag; int ret, i, version = 2; if (!strcmp(s->oformat->name, ""webm"")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (s->avoid_negative_ts < 0) { s->avoid_negative_ts = 1; s->internal->avoid_negative_ts_use_pts = 1; } if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->metadata, ""alpha_mode"", NULL, 0)) version = 4; for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codec->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codec->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codec->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codec->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codec->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codec->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, ""The Matroska muxer does not yet support muxing %s\n"", avcodec_get_name(s->streams[i]->codec->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codec->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->streams[i]->metadata, ""alpha_mode"", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { ret = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { ret = AVERROR(ENOMEM); goto fail; } ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if (ret < 0) goto fail; segment_info = start_ebml_master(pb, MATROSKA_ID_INFO, 0); put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if ((tag = av_dict_get(s->metadata, ""title"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { uint32_t segment_uid[4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) segment_uid[i] = av_lfg_get(&lfg); put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if ((tag = av_dict_get(s->metadata, ""encoding_tool"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16); } else { const char *ident = ""Lavf""; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (tag = av_dict_get(s->metadata, ""creation_time"", NULL, 0)) { int64_t date_utc = (ff_iso8601_to_unix_time(tag->value) - 978307200) * 1000000000; uint8_t date_utc_buf[8]; AV_WB64(date_utc_buf, date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { put_ebml_void(pb, 11); } end_ebml_master(pb, segment_info); mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); ret = mkv_write_tracks(s); if (ret < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); if (mkv->mode != MODE_WEBM) { ret = mkv_write_chapters(s); if (ret < 0) goto fail; ret = mkv_write_tags(s); if (ret < 0) goto fail; ret = mkv_write_attachments(s); if (ret < 0) goto fail; } if (!s->pb->seekable && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { ret = AVERROR(ENOMEM); goto fail; } if (pb->seekable && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return ret; }"
4973----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_019fe0c439f0703d9374b6decee7173190057fa5_1.json----gen_check_bw,"<S2SV_StartVul> static void gen_check_bw(URLContext *s, RTMPContext *rt) <S2SV_EndVul> { RTMPPacket pkt; uint8_t *p; <S2SV_StartVul> ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 21); <S2SV_EndVul> p = pkt.data; ff_amf_write_string(&p, ""_checkbw""); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); }","- static void gen_check_bw(URLContext *s, RTMPContext *rt)
- ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 21);
+ static int gen_check_bw(URLContext *s, RTMPContext *rt)
+ int ret;
+ if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,
+ 0, 21)) < 0)
+ return ret;
+ return ret;","static int gen_check_bw(URLContext *s, RTMPContext *rt) { RTMPPacket pkt; uint8_t *p; int ret; if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 21)) < 0) return ret; p = pkt.data; ff_amf_write_string(&p, ""_checkbw""); ff_amf_write_number(&p, ++rt->nb_invokes); ff_amf_write_null(&p); ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]); ff_rtmp_packet_destroy(&pkt); return ret; }"
15815----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c2d8a680d948497296b7d56c232ab4337aef6a62_1.json----DSO_convert_filename,"char *DSO_convert_filename(DSO *dso, const char *filename) { char *result = NULL; if(dso == NULL) { DSOerr(DSO_F_DSO_CONVERT_FILENAME,ERR_R_PASSED_NULL_PARAMETER); return(NULL); } if(filename == NULL) filename = dso->filename; if(filename == NULL) { DSOerr(DSO_F_DSO_CONVERT_FILENAME,DSO_R_NO_FILENAME); return(NULL); } if((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0) { if(dso->name_converter != NULL) result = dso->name_converter(dso, filename); else if(dso->meth->dso_name_converter != NULL) result = dso->meth->dso_name_converter(dso, filename); } if(result == NULL) { result = OPENSSL_malloc(strlen(filename) + 1); if(result == NULL) { DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE); return(NULL); } <S2SV_StartVul> strcpy(result, filename); <S2SV_EndVul> } return(result); }","- strcpy(result, filename);
+ BUF_strlcpy(result, filename, strlen(filename) + 1);","char *DSO_convert_filename(DSO *dso, const char *filename) { char *result = NULL; if(dso == NULL) { DSOerr(DSO_F_DSO_CONVERT_FILENAME,ERR_R_PASSED_NULL_PARAMETER); return(NULL); } if(filename == NULL) filename = dso->filename; if(filename == NULL) { DSOerr(DSO_F_DSO_CONVERT_FILENAME,DSO_R_NO_FILENAME); return(NULL); } if((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0) { if(dso->name_converter != NULL) result = dso->name_converter(dso, filename); else if(dso->meth->dso_name_converter != NULL) result = dso->meth->dso_name_converter(dso, filename); } if(result == NULL) { result = OPENSSL_malloc(strlen(filename) + 1); if(result == NULL) { DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE); return(NULL); } BUF_strlcpy(result, filename, strlen(filename) + 1); } return(result); }"
1890----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_67b81f7026fd23a0f963edaaca8e6be6ddecf2e0_1.json----ff_jpegls_init_state,"void ff_jpegls_init_state(JLSState *state){ int i; state->twonear = state->near * 2 + 1; state->range = ((state->maxval + state->twonear - 1) / state->twonear) + 1; for(state->qbpp = 0; (1 << state->qbpp) < state->range; state->qbpp++); <S2SV_StartVul> if(state->bpp < 8) <S2SV_EndVul> <S2SV_StartVul> state->limit = 16 + 2 * state->bpp - state->qbpp; <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> state->limit = (4 * state->bpp) - state->qbpp; <S2SV_EndVul> for(i = 0; i < 367; i++) { state->A[i] = FFMAX((state->range + 32) >> 6, 2); state->N[i] = 1; } }","- if(state->bpp < 8)
- state->limit = 16 + 2 * state->bpp - state->qbpp;
- else
- state->limit = (4 * state->bpp) - state->qbpp;
+ state->bpp = FFMAX(av_log2(state->maxval)+1, 2);
+ state->limit = 2*(state->bpp + FFMAX(state->bpp, 8)) - state->qbpp;","void ff_jpegls_init_state(JLSState *state){ int i; state->twonear = state->near * 2 + 1; state->range = ((state->maxval + state->twonear - 1) / state->twonear) + 1; for(state->qbpp = 0; (1 << state->qbpp) < state->range; state->qbpp++); state->bpp = FFMAX(av_log2(state->maxval)+1, 2); state->limit = 2*(state->bpp + FFMAX(state->bpp, 8)) - state->qbpp; for(i = 0; i < 367; i++) { state->A[i] = FFMAX((state->range + 32) >> 6, 2); state->N[i] = 1; } }"
9933----INTEGER_OVERFLOW_L1----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_404030dd7da72e271b205e52f6c292f43348345d_1.json----ngx_http_file_cache_cleanup,"static void ngx_http_file_cache_cleanup(void *data) { ngx_http_cache_t *c = data; <S2SV_StartVul> ngx_http_file_cache_t *cache; <S2SV_EndVul> if (c->updated) { return; } <S2SV_StartVul> c->updated = 1; <S2SV_EndVul> ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0, ""http file cache cleanup""); <S2SV_StartVul> if (c->error) { <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> } <S2SV_StartVul> cache = c->file_cache; <S2SV_EndVul> <S2SV_StartVul> ngx_shmtx_lock(&cache->shpool->mutex); <S2SV_EndVul> <S2SV_StartVul> c->node->count--; <S2SV_EndVul> <S2SV_StartVul> ngx_shmtx_unlock(&cache->shpool->mutex); <S2SV_EndVul> }","- ngx_http_file_cache_t *cache;
- c->updated = 1;
- if (c->error) {
- return;
- cache = c->file_cache;
- ngx_shmtx_lock(&cache->shpool->mutex);
- c->node->count--;
- ngx_shmtx_unlock(&cache->shpool->mutex);
+ if (c->updating) {
+ ngx_log_error(NGX_LOG_ALERT, c->file.log, 0,
+ ""stalled cache updating, error:%ui"", c->error);
+ ngx_http_file_cache_free(c, NULL);","static void ngx_http_file_cache_cleanup(void *data) { ngx_http_cache_t *c = data; if (c->updated) { return; } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0, ""http file cache cleanup""); if (c->updating) { ngx_log_error(NGX_LOG_ALERT, c->file.log, 0, ""stalled cache updating, error:%ui"", c->error); } ngx_http_file_cache_free(c, NULL); }"
5796----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_30c75cc2ced6ae9753c3bd8522f68123b1439a3d_1.json----twin_decode_init,"static av_cold int twin_decode_init(AVCodecContext *avctx) { int ret; TwinContext *tctx = avctx->priv_data; int isampf, ibps; tctx->avctx = avctx; avctx->sample_fmt = AV_SAMPLE_FMT_FLTP; if (!avctx->extradata || avctx->extradata_size < 12) { av_log(avctx, AV_LOG_ERROR, ""Missing or incomplete extradata\n""); return AVERROR_INVALIDDATA; } avctx->channels = AV_RB32(avctx->extradata ) + 1; avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000; isampf = AV_RB32(avctx->extradata + 8); switch (isampf) { case 44: avctx->sample_rate = 44100; break; case 22: avctx->sample_rate = 22050; break; case 11: avctx->sample_rate = 11025; break; default: avctx->sample_rate = isampf * 1000; break; } <S2SV_StartVul> if (avctx->channels > CHANNELS_MAX) { <S2SV_EndVul> av_log(avctx, AV_LOG_ERROR, ""Unsupported number of channels: %i\n"", avctx->channels); return -1; } ibps = avctx->bit_rate / (1000 * avctx->channels); switch ((isampf << 8) + ibps) { case (8 <<8) + 8: tctx->mtab = &mode_08_08; break; case (11<<8) + 8: tctx->mtab = &mode_11_08; break; case (11<<8) + 10: tctx->mtab = &mode_11_10; break; case (16<<8) + 16: tctx->mtab = &mode_16_16; break; case (22<<8) + 20: tctx->mtab = &mode_22_20; break; case (22<<8) + 24: tctx->mtab = &mode_22_24; break; case (22<<8) + 32: tctx->mtab = &mode_22_32; break; case (44<<8) + 40: tctx->mtab = &mode_44_40; break; case (44<<8) + 48: tctx->mtab = &mode_44_48; break; default: av_log(avctx, AV_LOG_ERROR, ""This version does not support %d kHz - %d kbit/s/ch mode.\n"", isampf, isampf); return -1; } ff_dsputil_init(&tctx->dsp, avctx); avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT); if ((ret = init_mdct_win(tctx))) { av_log(avctx, AV_LOG_ERROR, ""Error initializing MDCT\n""); twin_decode_close(avctx); return ret; } init_bitstream_params(tctx); memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist)); avcodec_get_frame_defaults(&tctx->frame); avctx->coded_frame = &tctx->frame; return 0; }","- if (avctx->channels > CHANNELS_MAX) {
+ if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {","static av_cold int twin_decode_init(AVCodecContext *avctx) { int ret; TwinContext *tctx = avctx->priv_data; int isampf, ibps; tctx->avctx = avctx; avctx->sample_fmt = AV_SAMPLE_FMT_FLTP; if (!avctx->extradata || avctx->extradata_size < 12) { av_log(avctx, AV_LOG_ERROR, ""Missing or incomplete extradata\n""); return AVERROR_INVALIDDATA; } avctx->channels = AV_RB32(avctx->extradata ) + 1; avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000; isampf = AV_RB32(avctx->extradata + 8); switch (isampf) { case 44: avctx->sample_rate = 44100; break; case 22: avctx->sample_rate = 22050; break; case 11: avctx->sample_rate = 11025; break; default: avctx->sample_rate = isampf * 1000; break; } if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) { av_log(avctx, AV_LOG_ERROR, ""Unsupported number of channels: %i\n"", avctx->channels); return -1; } ibps = avctx->bit_rate / (1000 * avctx->channels); switch ((isampf << 8) + ibps) { case (8 <<8) + 8: tctx->mtab = &mode_08_08; break; case (11<<8) + 8: tctx->mtab = &mode_11_08; break; case (11<<8) + 10: tctx->mtab = &mode_11_10; break; case (16<<8) + 16: tctx->mtab = &mode_16_16; break; case (22<<8) + 20: tctx->mtab = &mode_22_20; break; case (22<<8) + 24: tctx->mtab = &mode_22_24; break; case (22<<8) + 32: tctx->mtab = &mode_22_32; break; case (44<<8) + 40: tctx->mtab = &mode_44_40; break; case (44<<8) + 48: tctx->mtab = &mode_44_48; break; default: av_log(avctx, AV_LOG_ERROR, ""This version does not support %d kHz - %d kbit/s/ch mode.\n"", isampf, isampf); return -1; } ff_dsputil_init(&tctx->dsp, avctx); avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT); if ((ret = init_mdct_win(tctx))) { av_log(avctx, AV_LOG_ERROR, ""Error initializing MDCT\n""); twin_decode_close(avctx); return ret; } init_bitstream_params(tctx); memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist)); avcodec_get_frame_defaults(&tctx->frame); avctx->coded_frame = &tctx->frame; return 0; }"
13145----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_65a87db48fea380df4c7c46a2b8acd20c8e8d6a0_1.json----OPENSSL_fork_child,void OPENSSL_fork_child(void) { <S2SV_StartVul> rand_fork(); <S2SV_EndVul> },- rand_fork();,void OPENSSL_fork_child(void) { }
9380----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_35bc12ddd07f23865765f6ceed4f382a81a14708_1.json----_TIFFVGetField,"static int _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory* td = &tif->tif_dir; int ret_val = 1; uint32 standard_tag = tag; const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY); if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32*) = td->td_subfiletype; break; case TIFFTAG_IMAGEWIDTH: *va_arg(ap, uint32*) = td->td_imagewidth; break; case TIFFTAG_IMAGELENGTH: *va_arg(ap, uint32*) = td->td_imagelength; break; case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16*) = td->td_bitspersample; break; case TIFFTAG_COMPRESSION: *va_arg(ap, uint16*) = td->td_compression; break; case TIFFTAG_PHOTOMETRIC: *va_arg(ap, uint16*) = td->td_photometric; break; case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16*) = td->td_threshholding; break; case TIFFTAG_FILLORDER: *va_arg(ap, uint16*) = td->td_fillorder; break; case TIFFTAG_ORIENTATION: *va_arg(ap, uint16*) = td->td_orientation; break; case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16*) = td->td_samplesperpixel; break; case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32*) = td->td_rowsperstrip; break; case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_minsamplevalue; break; case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_maxsamplevalue; break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_sminsamplevalue; else { uint16 i; double v = td->td_sminsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_sminsamplevalue[i] < v ) v = td->td_sminsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_smaxsamplevalue; else { uint16 i; double v = td->td_smaxsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_smaxsamplevalue[i] > v ) v = td->td_smaxsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_XRESOLUTION: *va_arg(ap, float*) = td->td_xresolution; break; case TIFFTAG_YRESOLUTION: *va_arg(ap, float*) = td->td_yresolution; break; case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16*) = td->td_planarconfig; break; case TIFFTAG_XPOSITION: *va_arg(ap, float*) = td->td_xposition; break; case TIFFTAG_YPOSITION: *va_arg(ap, float*) = td->td_yposition; break; case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16*) = td->td_resolutionunit; break; case TIFFTAG_PAGENUMBER: *va_arg(ap, uint16*) = td->td_pagenumber[0]; *va_arg(ap, uint16*) = td->td_pagenumber[1]; break; case TIFFTAG_HALFTONEHINTS: *va_arg(ap, uint16*) = td->td_halftonehints[0]; *va_arg(ap, uint16*) = td->td_halftonehints[1]; break; case TIFFTAG_COLORMAP: *va_arg(ap, uint16**) = td->td_colormap[0]; *va_arg(ap, uint16**) = td->td_colormap[1]; *va_arg(ap, uint16**) = td->td_colormap[2]; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripoffset; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripbytecount; break; case TIFFTAG_MATTEING: *va_arg(ap, uint16*) = (td->td_extrasamples == 1 && td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); break; case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16*) = td->td_extrasamples; *va_arg(ap, uint16**) = td->td_sampleinfo; break; case TIFFTAG_TILEWIDTH: *va_arg(ap, uint32*) = td->td_tilewidth; break; case TIFFTAG_TILELENGTH: *va_arg(ap, uint32*) = td->td_tilelength; break; case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32*) = td->td_tiledepth; break; case TIFFTAG_DATATYPE: switch (td->td_sampleformat) { case SAMPLEFORMAT_UINT: *va_arg(ap, uint16*) = DATATYPE_UINT; break; case SAMPLEFORMAT_INT: *va_arg(ap, uint16*) = DATATYPE_INT; break; case SAMPLEFORMAT_IEEEFP: *va_arg(ap, uint16*) = DATATYPE_IEEEFP; break; case SAMPLEFORMAT_VOID: *va_arg(ap, uint16*) = DATATYPE_VOID; break; } break; case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16*) = td->td_sampleformat; break; case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32*) = td->td_imagedepth; break; case TIFFTAG_SUBIFD: *va_arg(ap, uint16*) = td->td_nsubifd; *va_arg(ap, uint64**) = td->td_subifd; break; case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16*) = td->td_ycbcrpositioning; break; case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1]; break; case TIFFTAG_TRANSFERFUNCTION: *va_arg(ap, uint16**) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16**) = td->td_transferfunction[1]; *va_arg(ap, uint16**) = td->td_transferfunction[2]; } break; case TIFFTAG_REFERENCEBLACKWHITE: *va_arg(ap, float**) = td->td_refblackwhite; break; case TIFFTAG_INKNAMES: *va_arg(ap, char**) = td->td_inknames; break; default: { int i; <S2SV_StartVul> if( fip == NULL || fip->field_bit != FIELD_CUSTOM ) <S2SV_EndVul> { TIFFErrorExt(tif->tif_clientdata, ""_TIFFVGetField"", ""%s: Invalid %stag \""%s\"" "" ""(not supported by codec)"", tif->tif_name, isPseudoTag(tag) ? ""pseudo-"" : """", <S2SV_StartVul> fip ? fip->field_name : ""Unknown""); <S2SV_EndVul> ret_val = 0; break; } ret_val = 0; for (i = 0; i < td->td_customValueCount; i++) { TIFFTagValue *tv = td->td_customValues + i; if (tv->info->field_tag != tag) continue; if (fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2) *va_arg(ap, uint32*) = (uint32)tv->count; else *va_arg(ap, uint16*) = (uint16)tv->count; *va_arg(ap, void **) = tv->value; ret_val = 1; } else if (fip->field_tag == TIFFTAG_DOTRANGE && strcmp(fip->field_name,""DotRange"") == 0) { *va_arg(ap, uint16*) = ((uint16 *)tv->value)[0]; *va_arg(ap, uint16*) = ((uint16 *)tv->value)[1]; ret_val = 1; } else { if (fip->field_type == TIFF_ASCII || fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2 || fip->field_readcount == TIFF_SPP || tv->count > 1) { *va_arg(ap, void **) = tv->value; ret_val = 1; } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: *va_arg(ap, uint8*) = *(uint8 *)val; ret_val = 1; break; case TIFF_SBYTE: *va_arg(ap, int8*) = *(int8 *)val; ret_val = 1; break; case TIFF_SHORT: *va_arg(ap, uint16*) = *(uint16 *)val; ret_val = 1; break; case TIFF_SSHORT: *va_arg(ap, int16*) = *(int16 *)val; ret_val = 1; break; case TIFF_LONG: case TIFF_IFD: *va_arg(ap, uint32*) = *(uint32 *)val; ret_val = 1; break; case TIFF_SLONG: *va_arg(ap, int32*) = *(int32 *)val; ret_val = 1; break; case TIFF_LONG8: case TIFF_IFD8: *va_arg(ap, uint64*) = *(uint64 *)val; ret_val = 1; break; case TIFF_SLONG8: *va_arg(ap, int64*) = *(int64 *)val; ret_val = 1; break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: *va_arg(ap, float*) = *(float *)val; ret_val = 1; break; case TIFF_DOUBLE: *va_arg(ap, double*) = *(double *)val; ret_val = 1; break; default: ret_val = 0; break; } } } break; } } } return(ret_val); }","- if( fip == NULL || fip->field_bit != FIELD_CUSTOM )
- fip ? fip->field_name : ""Unknown"");
+ return 0;
+ if( fip->field_bit != FIELD_CUSTOM )
+ fip->field_name);","static int _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) { TIFFDirectory* td = &tif->tif_dir; int ret_val = 1; uint32 standard_tag = tag; const TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY); if( fip == NULL ) return 0; if (fip->field_bit == FIELD_CUSTOM) { standard_tag = 0; } switch (standard_tag) { case TIFFTAG_SUBFILETYPE: *va_arg(ap, uint32*) = td->td_subfiletype; break; case TIFFTAG_IMAGEWIDTH: *va_arg(ap, uint32*) = td->td_imagewidth; break; case TIFFTAG_IMAGELENGTH: *va_arg(ap, uint32*) = td->td_imagelength; break; case TIFFTAG_BITSPERSAMPLE: *va_arg(ap, uint16*) = td->td_bitspersample; break; case TIFFTAG_COMPRESSION: *va_arg(ap, uint16*) = td->td_compression; break; case TIFFTAG_PHOTOMETRIC: *va_arg(ap, uint16*) = td->td_photometric; break; case TIFFTAG_THRESHHOLDING: *va_arg(ap, uint16*) = td->td_threshholding; break; case TIFFTAG_FILLORDER: *va_arg(ap, uint16*) = td->td_fillorder; break; case TIFFTAG_ORIENTATION: *va_arg(ap, uint16*) = td->td_orientation; break; case TIFFTAG_SAMPLESPERPIXEL: *va_arg(ap, uint16*) = td->td_samplesperpixel; break; case TIFFTAG_ROWSPERSTRIP: *va_arg(ap, uint32*) = td->td_rowsperstrip; break; case TIFFTAG_MINSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_minsamplevalue; break; case TIFFTAG_MAXSAMPLEVALUE: *va_arg(ap, uint16*) = td->td_maxsamplevalue; break; case TIFFTAG_SMINSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_sminsamplevalue; else { uint16 i; double v = td->td_sminsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_sminsamplevalue[i] < v ) v = td->td_sminsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_SMAXSAMPLEVALUE: if (tif->tif_flags & TIFF_PERSAMPLE) *va_arg(ap, double**) = td->td_smaxsamplevalue; else { uint16 i; double v = td->td_smaxsamplevalue[0]; for (i=1; i < td->td_samplesperpixel; ++i) if( td->td_smaxsamplevalue[i] > v ) v = td->td_smaxsamplevalue[i]; *va_arg(ap, double*) = v; } break; case TIFFTAG_XRESOLUTION: *va_arg(ap, float*) = td->td_xresolution; break; case TIFFTAG_YRESOLUTION: *va_arg(ap, float*) = td->td_yresolution; break; case TIFFTAG_PLANARCONFIG: *va_arg(ap, uint16*) = td->td_planarconfig; break; case TIFFTAG_XPOSITION: *va_arg(ap, float*) = td->td_xposition; break; case TIFFTAG_YPOSITION: *va_arg(ap, float*) = td->td_yposition; break; case TIFFTAG_RESOLUTIONUNIT: *va_arg(ap, uint16*) = td->td_resolutionunit; break; case TIFFTAG_PAGENUMBER: *va_arg(ap, uint16*) = td->td_pagenumber[0]; *va_arg(ap, uint16*) = td->td_pagenumber[1]; break; case TIFFTAG_HALFTONEHINTS: *va_arg(ap, uint16*) = td->td_halftonehints[0]; *va_arg(ap, uint16*) = td->td_halftonehints[1]; break; case TIFFTAG_COLORMAP: *va_arg(ap, uint16**) = td->td_colormap[0]; *va_arg(ap, uint16**) = td->td_colormap[1]; *va_arg(ap, uint16**) = td->td_colormap[2]; break; case TIFFTAG_STRIPOFFSETS: case TIFFTAG_TILEOFFSETS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripoffset; break; case TIFFTAG_STRIPBYTECOUNTS: case TIFFTAG_TILEBYTECOUNTS: _TIFFFillStriles( tif ); *va_arg(ap, uint64**) = td->td_stripbytecount; break; case TIFFTAG_MATTEING: *va_arg(ap, uint16*) = (td->td_extrasamples == 1 && td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA); break; case TIFFTAG_EXTRASAMPLES: *va_arg(ap, uint16*) = td->td_extrasamples; *va_arg(ap, uint16**) = td->td_sampleinfo; break; case TIFFTAG_TILEWIDTH: *va_arg(ap, uint32*) = td->td_tilewidth; break; case TIFFTAG_TILELENGTH: *va_arg(ap, uint32*) = td->td_tilelength; break; case TIFFTAG_TILEDEPTH: *va_arg(ap, uint32*) = td->td_tiledepth; break; case TIFFTAG_DATATYPE: switch (td->td_sampleformat) { case SAMPLEFORMAT_UINT: *va_arg(ap, uint16*) = DATATYPE_UINT; break; case SAMPLEFORMAT_INT: *va_arg(ap, uint16*) = DATATYPE_INT; break; case SAMPLEFORMAT_IEEEFP: *va_arg(ap, uint16*) = DATATYPE_IEEEFP; break; case SAMPLEFORMAT_VOID: *va_arg(ap, uint16*) = DATATYPE_VOID; break; } break; case TIFFTAG_SAMPLEFORMAT: *va_arg(ap, uint16*) = td->td_sampleformat; break; case TIFFTAG_IMAGEDEPTH: *va_arg(ap, uint32*) = td->td_imagedepth; break; case TIFFTAG_SUBIFD: *va_arg(ap, uint16*) = td->td_nsubifd; *va_arg(ap, uint64**) = td->td_subifd; break; case TIFFTAG_YCBCRPOSITIONING: *va_arg(ap, uint16*) = td->td_ycbcrpositioning; break; case TIFFTAG_YCBCRSUBSAMPLING: *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0]; *va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1]; break; case TIFFTAG_TRANSFERFUNCTION: *va_arg(ap, uint16**) = td->td_transferfunction[0]; if (td->td_samplesperpixel - td->td_extrasamples > 1) { *va_arg(ap, uint16**) = td->td_transferfunction[1]; *va_arg(ap, uint16**) = td->td_transferfunction[2]; } break; case TIFFTAG_REFERENCEBLACKWHITE: *va_arg(ap, float**) = td->td_refblackwhite; break; case TIFFTAG_INKNAMES: *va_arg(ap, char**) = td->td_inknames; break; default: { int i; if( fip->field_bit != FIELD_CUSTOM ) { TIFFErrorExt(tif->tif_clientdata, ""_TIFFVGetField"", ""%s: Invalid %stag \""%s\"" "" ""(not supported by codec)"", tif->tif_name, isPseudoTag(tag) ? ""pseudo-"" : """", fip->field_name); ret_val = 0; break; } ret_val = 0; for (i = 0; i < td->td_customValueCount; i++) { TIFFTagValue *tv = td->td_customValues + i; if (tv->info->field_tag != tag) continue; if (fip->field_passcount) { if (fip->field_readcount == TIFF_VARIABLE2) *va_arg(ap, uint32*) = (uint32)tv->count; else *va_arg(ap, uint16*) = (uint16)tv->count; *va_arg(ap, void **) = tv->value; ret_val = 1; } else if (fip->field_tag == TIFFTAG_DOTRANGE && strcmp(fip->field_name,""DotRange"") == 0) { *va_arg(ap, uint16*) = ((uint16 *)tv->value)[0]; *va_arg(ap, uint16*) = ((uint16 *)tv->value)[1]; ret_val = 1; } else { if (fip->field_type == TIFF_ASCII || fip->field_readcount == TIFF_VARIABLE || fip->field_readcount == TIFF_VARIABLE2 || fip->field_readcount == TIFF_SPP || tv->count > 1) { *va_arg(ap, void **) = tv->value; ret_val = 1; } else { char *val = (char *)tv->value; assert( tv->count == 1 ); switch (fip->field_type) { case TIFF_BYTE: case TIFF_UNDEFINED: *va_arg(ap, uint8*) = *(uint8 *)val; ret_val = 1; break; case TIFF_SBYTE: *va_arg(ap, int8*) = *(int8 *)val; ret_val = 1; break; case TIFF_SHORT: *va_arg(ap, uint16*) = *(uint16 *)val; ret_val = 1; break; case TIFF_SSHORT: *va_arg(ap, int16*) = *(int16 *)val; ret_val = 1; break; case TIFF_LONG: case TIFF_IFD: *va_arg(ap, uint32*) = *(uint32 *)val; ret_val = 1; break; case TIFF_SLONG: *va_arg(ap, int32*) = *(int32 *)val; ret_val = 1; break; case TIFF_LONG8: case TIFF_IFD8: *va_arg(ap, uint64*) = *(uint64 *)val; ret_val = 1; break; case TIFF_SLONG8: *va_arg(ap, int64*) = *(int64 *)val; ret_val = 1; break; case TIFF_RATIONAL: case TIFF_SRATIONAL: case TIFF_FLOAT: *va_arg(ap, float*) = *(float *)val; ret_val = 1; break; case TIFF_DOUBLE: *va_arg(ap, double*) = *(double *)val; ret_val = 1; break; default: ret_val = 0; break; } } } break; } } } return(ret_val); }"
16794----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_e4b96056af7e00e9ff2f8aef4b82b89eee329a2f_1.json----EVP_EncryptUpdate,"int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { int i,j,bl; OPENSSL_assert(inl > 0); if(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0) { if(ctx->cipher->do_cipher(ctx,out,in,inl)) { *outl=inl; return 1; } else { *outl=0; return 0; } } i=ctx->buf_len; bl=ctx->cipher->block_size; <S2SV_StartVul> OPENSSL_assert(bl <= sizeof ctx->buf); <S2SV_EndVul> if (i != 0) { if (i+inl < bl) { memcpy(&(ctx->buf[i]),in,inl); ctx->buf_len+=inl; *outl=0; return 1; } else { j=bl-i; memcpy(&(ctx->buf[i]),in,j); if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0; inl-=j; in+=j; out+=bl; *outl=bl; } } else *outl = 0; i=inl&(bl-1); inl-=i; if (inl > 0) { if(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0; *outl+=inl; } if (i != 0) memcpy(ctx->buf,&(in[inl]),i); ctx->buf_len=i; return 1; }","- OPENSSL_assert(bl <= sizeof ctx->buf);
+ OPENSSL_assert(bl <= (int)sizeof(ctx->buf));","int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { int i,j,bl; OPENSSL_assert(inl > 0); if(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0) { if(ctx->cipher->do_cipher(ctx,out,in,inl)) { *outl=inl; return 1; } else { *outl=0; return 0; } } i=ctx->buf_len; bl=ctx->cipher->block_size; OPENSSL_assert(bl <= (int)sizeof(ctx->buf)); if (i != 0) { if (i+inl < bl) { memcpy(&(ctx->buf[i]),in,inl); ctx->buf_len+=inl; *outl=0; return 1; } else { j=bl-i; memcpy(&(ctx->buf[i]),in,j); if(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0; inl-=j; in+=j; out+=bl; *outl=bl; } } else *outl = 0; i=inl&(bl-1); inl-=i; if (inl > 0) { if(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0; *outl+=inl; } if (i != 0) memcpy(ctx->buf,&(in[inl]),i); ctx->buf_len=i; return 1; }"
11659----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_320c206e31576cd13132a52b874a347ed3032c78_1.json----ssl3_get_server_hello,"int ssl3_get_server_hello(SSL *s) { <S2SV_StartVul> STACK_OF(SSL_CIPHER) *sk; <S2SV_EndVul> <S2SV_StartVul> const SSL_CIPHER *c; <S2SV_EndVul> <S2SV_StartVul> PACKET pkt, session_id; <S2SV_EndVul> <S2SV_StartVul> size_t session_id_len; <S2SV_EndVul> <S2SV_StartVul> unsigned char *cipherchars; <S2SV_EndVul> <S2SV_StartVul> int i, al = SSL_AD_INTERNAL_ERROR, ok; <S2SV_EndVul> <S2SV_StartVul> unsigned int compression; <S2SV_EndVul> long n; <S2SV_StartVul> #ifndef OPENSSL_NO_COMP <S2SV_EndVul> <S2SV_StartVul> SSL_COMP *comp; <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> s->first_packet = 1; n = s->method->ssl_get_message(s, SSL3_ST_CR_SRVR_HELLO_A, SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok); if (!ok) return ((int)n); s->first_packet = 0; if (SSL_IS_DTLS(s)) { if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) { if (s->d1->send_cookie == 0) { s->s3->tmp.reuse_message = 1; return 1; } else { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE); goto f_err; } } } if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE); goto f_err; } if (!PACKET_buf_init(&pkt, s->init_msg, n)) { al = SSL_AD_INTERNAL_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR); <S2SV_EndVul> goto f_err; } if (s->method->version == TLS_ANY_VERSION) { unsigned int sversion; if (!PACKET_get_net_2(&pkt, &sversion)) { al = SSL_AD_DECODE_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); <S2SV_EndVul> goto f_err; } #if TLS_MAX_VERSION != TLS1_2_VERSION #error Code needs updating for new TLS version #endif #ifndef OPENSSL_NO_SSL3 if ((sversion == SSL3_VERSION) && !(s->options & SSL_OP_NO_SSLv3)) { if (FIPS_mode()) { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE); al = SSL_AD_PROTOCOL_VERSION; goto f_err; } s->method = SSLv3_client_method(); } else #endif if ((sversion == TLS1_VERSION) && !(s->options & SSL_OP_NO_TLSv1)) { s->method = TLSv1_client_method(); } else if ((sversion == TLS1_1_VERSION) && !(s->options & SSL_OP_NO_TLSv1_1)) { s->method = TLSv1_1_client_method(); } else if ((sversion == TLS1_2_VERSION) && !(s->options & SSL_OP_NO_TLSv1_2)) { s->method = TLSv1_2_client_method(); } else { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL); <S2SV_EndVul> al = SSL_AD_PROTOCOL_VERSION; goto f_err; } s->session->ssl_version = s->version = s->method->version; if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_VERSION_TOO_LOW); <S2SV_EndVul> al = SSL_AD_PROTOCOL_VERSION; goto f_err; } } else if (s->method->version == DTLS_ANY_VERSION) { unsigned int hversion; int options; if (!PACKET_get_net_2(&pkt, &hversion)) { al = SSL_AD_DECODE_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); <S2SV_EndVul> goto f_err; } options = s->options; if (hversion == DTLS1_2_VERSION && !(options & SSL_OP_NO_DTLSv1_2)) s->method = DTLSv1_2_client_method(); else if (tls1_suiteb(s)) { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE); s->version = hversion; al = SSL_AD_PROTOCOL_VERSION; goto f_err; } else if (hversion == DTLS1_VERSION && !(options & SSL_OP_NO_DTLSv1)) s->method = DTLSv1_client_method(); else { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION); <S2SV_EndVul> s->version = hversion; al = SSL_AD_PROTOCOL_VERSION; goto f_err; } s->session->ssl_version = s->version = s->method->version; } else { unsigned char *vers; if (!PACKET_get_bytes(&pkt, &vers, 2)) { al = SSL_AD_DECODE_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); <S2SV_EndVul> goto f_err; } if ((vers[0] != (s->version >> 8)) || (vers[1] != (s->version & 0xff))) { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION); <S2SV_EndVul> s->version = (s->version & 0xff00) | vers[1]; al = SSL_AD_PROTOCOL_VERSION; goto f_err; } } if (!PACKET_copy_bytes(&pkt, s->s3->server_random, SSL3_RANDOM_SIZE)) { al = SSL_AD_DECODE_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); <S2SV_EndVul> goto f_err; } s->hit = 0; if (!PACKET_get_length_prefixed_1(&pkt, &session_id)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); goto f_err; } session_id_len = PACKET_remaining(&session_id); if (session_id_len > sizeof s->session->session_id || session_id_len > SSL3_SESSION_ID_SIZE) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG); <S2SV_EndVul> goto f_err; } if (!PACKET_get_bytes(&pkt, &cipherchars, TLS_CIPHER_LEN)) { SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); al = SSL_AD_DECODE_ERROR; goto f_err; } if (s->version >= TLS1_VERSION && s->tls_session_secret_cb && s->session->tlsext_tick) { SSL_CIPHER *pref_cipher = NULL; s->session->master_key_length = sizeof(s->session->master_key); if (s->tls_session_secret_cb(s, s->session->master_key, &s->session->master_key_length, NULL, &pref_cipher, s->tls_session_secret_cb_arg)) { s->session->cipher = pref_cipher ? pref_cipher : ssl_get_cipher_by_char(s, cipherchars); } else { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR); <S2SV_EndVul> al = SSL_AD_INTERNAL_ERROR; goto f_err; } } if (session_id_len != 0 && session_id_len == s->session->session_id_length && memcmp(PACKET_data(&session_id), s->session->session_id, session_id_len) == 0) { if (s->sid_ctx_length != s->session->sid_ctx_length || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT); goto f_err; } s->hit = 1; } else { if (s->session->session_id_length > 0) { if (!ssl_get_new_session(s, 0)) { goto f_err; } } s->session->session_id_length = session_id_len; memcpy(s->session->session_id, PACKET_data(&session_id), session_id_len); } c = ssl_get_cipher_by_char(s, cipherchars); if (c == NULL) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED); <S2SV_EndVul> goto f_err; } if (!SSL_USE_TLS1_2_CIPHERS(s)) s->s3->tmp.mask_ssl = SSL_TLSV1_2; else s->s3->tmp.mask_ssl = 0; if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK)) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED); <S2SV_EndVul> goto f_err; } sk = ssl_get_ciphers_by_id(s); i = sk_SSL_CIPHER_find(sk, c); if (i < 0) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED); <S2SV_EndVul> goto f_err; } if (s->session->cipher) s->session->cipher_id = s->session->cipher->id; if (s->hit && (s->session->cipher_id != c->id)) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED); goto f_err; } s->s3->tmp.new_cipher = c; if (!SSL_USE_SIGALGS(s) && !ssl3_digest_cached_records(s, 0)) goto f_err; if (!PACKET_get_1(&pkt, &compression)) { SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH); al = SSL_AD_DECODE_ERROR; goto f_err; } #ifdef OPENSSL_NO_COMP if (compression != 0) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM); goto f_err; } if (s->session->compress_meth != 0) { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION); <S2SV_EndVul> goto f_err; } #else if (s->hit && compression != s->session->compress_meth) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED); goto f_err; } if (compression == 0) comp = NULL; else if (!ssl_allow_compression(s)) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED); <S2SV_EndVul> goto f_err; } else { comp = ssl3_comp_find(s->ctx->comp_methods, compression); } if (compression != 0 && comp == NULL) { al = SSL_AD_ILLEGAL_PARAMETER; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, <S2SV_EndVul> SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM); goto f_err; } else { s->s3->tmp.new_compression = comp; } #endif if (!ssl_parse_serverhello_tlsext(s, &pkt)) { <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT); <S2SV_EndVul> goto err; } if (PACKET_remaining(&pkt) != 0) { al = SSL_AD_DECODE_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH); <S2SV_EndVul> goto f_err; } <S2SV_StartVul> return (1); <S2SV_EndVul> f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); err: <S2SV_StartVul> s->state = SSL_ST_ERR; <S2SV_EndVul> <S2SV_StartVul> return (-1); <S2SV_EndVul> }","- STACK_OF(SSL_CIPHER) *sk;
- const SSL_CIPHER *c;
- PACKET pkt, session_id;
- size_t session_id_len;
- unsigned char *cipherchars;
- int i, al = SSL_AD_INTERNAL_ERROR, ok;
- unsigned int compression;
- #ifndef OPENSSL_NO_COMP
- SSL_COMP *comp;
- #endif
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_VERSION_TOO_LOW);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT);
- SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);
- return (1);
- s->state = SSL_ST_ERR;
- return (-1);
+ int ok, al;
+ return tls_process_server_hello(s, (unsigned long)n);
+ f_err:
+ ssl3_send_alert(s, SSL3_AL_FATAL, al);
+ s->state = SSL_ST_ERR;
+ return (-1);
+ }","int ssl3_get_server_hello(SSL *s) { int ok, al; long n; s->first_packet = 1; n = s->method->ssl_get_message(s, SSL3_ST_CR_SRVR_HELLO_A, SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok); if (!ok) return ((int)n); s->first_packet = 0; if (SSL_IS_DTLS(s)) { if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) { if (s->d1->send_cookie == 0) { s->s3->tmp.reuse_message = 1; return 1; } else { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE); goto f_err; } } } if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE); goto f_err; } return tls_process_server_hello(s, (unsigned long)n); f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); s->state = SSL_ST_ERR; return (-1); }"
7936----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_af34a64f7e7dd87c061d5177159816894859bfc9_1.json----ff_rate_estimate_qscale,"float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run) { float q; int qmin, qmax; float br_compensation; double diff; double short_term_q; double fps; int picture_number = s->picture_number; int64_t wanted_bits; RateControlContext *rcc = &s->rc_context; AVCodecContext *a = s->avctx; RateControlEntry local_rce, *rce; double bits; double rate_factor; int var; const int pict_type = s->pict_type; Picture * const pic = &s->current_picture; emms_c(); #if CONFIG_LIBXVID if ((s->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) return ff_xvid_rate_estimate_qscale(s, dry_run); #endif get_qminmax(&qmin, &qmax, s, pict_type); fps = 1 / av_q2d(s->avctx->time_base); if (picture_number > 2 && !dry_run) { const int last_var = s->last_pict_type == AV_PICTURE_TYPE_I ? rcc->last_mb_var_sum : rcc->last_mc_mb_var_sum; update_predictor(&rcc->pred[s->last_pict_type], rcc->last_qscale, sqrt(last_var), s->frame_bits); } if (s->flags & CODEC_FLAG_PASS2) { assert(picture_number >= 0); assert(picture_number < rcc->num_entries); rce = &rcc->entry[picture_number]; wanted_bits = rce->expected_bits; } else { Picture *dts_pic; rce = &local_rce; if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) dts_pic = s->current_picture_ptr; else dts_pic = s->last_picture_ptr; <S2SV_StartVul> if (!dts_pic || dts_pic->f.pts == AV_NOPTS_VALUE) <S2SV_EndVul> wanted_bits = (uint64_t)(s->bit_rate * (double)picture_number / fps); else <S2SV_StartVul> wanted_bits = (uint64_t)(s->bit_rate * (double)dts_pic->f.pts / fps); <S2SV_EndVul> } diff = s->total_bits - wanted_bits; br_compensation = (a->bit_rate_tolerance - diff) / a->bit_rate_tolerance; if (br_compensation <= 0.0) br_compensation = 0.001; var = pict_type == AV_PICTURE_TYPE_I ? pic->mb_var_sum : pic->mc_mb_var_sum; short_term_q = 0; if (s->flags & CODEC_FLAG_PASS2) { if (pict_type != AV_PICTURE_TYPE_I) assert(pict_type == rce->new_pict_type); q = rce->new_qscale / br_compensation; av_dlog(s, ""%f %f %f last:%d var:%d type:%d//\n"", q, rce->new_qscale, br_compensation, s->frame_bits, var, pict_type); } else { rce->pict_type = rce->new_pict_type = pict_type; rce->mc_mb_var_sum = pic->mc_mb_var_sum; rce->mb_var_sum = pic->mb_var_sum; rce->qscale = FF_QP2LAMBDA * 2; rce->f_code = s->f_code; rce->b_code = s->b_code; rce->misc_bits = 1; bits = predict_size(&rcc->pred[pict_type], rce->qscale, sqrt(var)); if (pict_type == AV_PICTURE_TYPE_I) { rce->i_count = s->mb_num; rce->i_tex_bits = bits; rce->p_tex_bits = 0; rce->mv_bits = 0; } else { rce->i_count = 0; rce->i_tex_bits = 0; rce->p_tex_bits = bits * 0.9; rce->mv_bits = bits * 0.1; } rcc->i_cplx_sum[pict_type] += rce->i_tex_bits * rce->qscale; rcc->p_cplx_sum[pict_type] += rce->p_tex_bits * rce->qscale; rcc->mv_bits_sum[pict_type] += rce->mv_bits; rcc->frame_count[pict_type]++; bits = rce->i_tex_bits + rce->p_tex_bits; rate_factor = rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum * br_compensation; q = get_qscale(s, rce, rate_factor, picture_number); if (q < 0) return -1; assert(q > 0.0); q = get_diff_limited_q(s, rce, q); assert(q > 0.0); if (pict_type == AV_PICTURE_TYPE_P || s->intra_only) { rcc->short_term_qsum *= a->qblur; rcc->short_term_qcount *= a->qblur; rcc->short_term_qsum += q; rcc->short_term_qcount++; q = short_term_q = rcc->short_term_qsum / rcc->short_term_qcount; } assert(q > 0.0); q = modify_qscale(s, rce, q, picture_number); rcc->pass1_wanted_bits += s->bit_rate / fps; assert(q > 0.0); } if (s->avctx->debug & FF_DEBUG_RC) { av_log(s->avctx, AV_LOG_DEBUG, ""%c qp:%d<%2.1f<%d %d want:%d total:%d comp:%f st_q:%2.2f "" ""size:%d var:%d/%d br:%d fps:%d\n"", av_get_picture_type_char(pict_type), qmin, q, qmax, picture_number, (int)wanted_bits / 1000, (int)s->total_bits / 1000, br_compensation, short_term_q, s->frame_bits, pic->mb_var_sum, pic->mc_mb_var_sum, s->bit_rate / 1000, (int)fps); } if (q < qmin) q = qmin; else if (q > qmax) q = qmax; if (s->adaptive_quant) adaptive_quantization(s, q); else q = (int)(q + 0.5); if (!dry_run) { rcc->last_qscale = q; rcc->last_mc_mb_var_sum = pic->mc_mb_var_sum; rcc->last_mb_var_sum = pic->mb_var_sum; } return q; }","- if (!dts_pic || dts_pic->f.pts == AV_NOPTS_VALUE)
- wanted_bits = (uint64_t)(s->bit_rate * (double)dts_pic->f.pts / fps);
+ if (!dts_pic || dts_pic->f->pts == AV_NOPTS_VALUE)
+ wanted_bits = (uint64_t)(s->bit_rate * (double)dts_pic->f->pts / fps);","float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run) { float q; int qmin, qmax; float br_compensation; double diff; double short_term_q; double fps; int picture_number = s->picture_number; int64_t wanted_bits; RateControlContext *rcc = &s->rc_context; AVCodecContext *a = s->avctx; RateControlEntry local_rce, *rce; double bits; double rate_factor; int var; const int pict_type = s->pict_type; Picture * const pic = &s->current_picture; emms_c(); #if CONFIG_LIBXVID if ((s->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) return ff_xvid_rate_estimate_qscale(s, dry_run); #endif get_qminmax(&qmin, &qmax, s, pict_type); fps = 1 / av_q2d(s->avctx->time_base); if (picture_number > 2 && !dry_run) { const int last_var = s->last_pict_type == AV_PICTURE_TYPE_I ? rcc->last_mb_var_sum : rcc->last_mc_mb_var_sum; update_predictor(&rcc->pred[s->last_pict_type], rcc->last_qscale, sqrt(last_var), s->frame_bits); } if (s->flags & CODEC_FLAG_PASS2) { assert(picture_number >= 0); assert(picture_number < rcc->num_entries); rce = &rcc->entry[picture_number]; wanted_bits = rce->expected_bits; } else { Picture *dts_pic; rce = &local_rce; if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) dts_pic = s->current_picture_ptr; else dts_pic = s->last_picture_ptr; if (!dts_pic || dts_pic->f->pts == AV_NOPTS_VALUE) wanted_bits = (uint64_t)(s->bit_rate * (double)picture_number / fps); else wanted_bits = (uint64_t)(s->bit_rate * (double)dts_pic->f->pts / fps); } diff = s->total_bits - wanted_bits; br_compensation = (a->bit_rate_tolerance - diff) / a->bit_rate_tolerance; if (br_compensation <= 0.0) br_compensation = 0.001; var = pict_type == AV_PICTURE_TYPE_I ? pic->mb_var_sum : pic->mc_mb_var_sum; short_term_q = 0; if (s->flags & CODEC_FLAG_PASS2) { if (pict_type != AV_PICTURE_TYPE_I) assert(pict_type == rce->new_pict_type); q = rce->new_qscale / br_compensation; av_dlog(s, ""%f %f %f last:%d var:%d type:%d//\n"", q, rce->new_qscale, br_compensation, s->frame_bits, var, pict_type); } else { rce->pict_type = rce->new_pict_type = pict_type; rce->mc_mb_var_sum = pic->mc_mb_var_sum; rce->mb_var_sum = pic->mb_var_sum; rce->qscale = FF_QP2LAMBDA * 2; rce->f_code = s->f_code; rce->b_code = s->b_code; rce->misc_bits = 1; bits = predict_size(&rcc->pred[pict_type], rce->qscale, sqrt(var)); if (pict_type == AV_PICTURE_TYPE_I) { rce->i_count = s->mb_num; rce->i_tex_bits = bits; rce->p_tex_bits = 0; rce->mv_bits = 0; } else { rce->i_count = 0; rce->i_tex_bits = 0; rce->p_tex_bits = bits * 0.9; rce->mv_bits = bits * 0.1; } rcc->i_cplx_sum[pict_type] += rce->i_tex_bits * rce->qscale; rcc->p_cplx_sum[pict_type] += rce->p_tex_bits * rce->qscale; rcc->mv_bits_sum[pict_type] += rce->mv_bits; rcc->frame_count[pict_type]++; bits = rce->i_tex_bits + rce->p_tex_bits; rate_factor = rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum * br_compensation; q = get_qscale(s, rce, rate_factor, picture_number); if (q < 0) return -1; assert(q > 0.0); q = get_diff_limited_q(s, rce, q); assert(q > 0.0); if (pict_type == AV_PICTURE_TYPE_P || s->intra_only) { rcc->short_term_qsum *= a->qblur; rcc->short_term_qcount *= a->qblur; rcc->short_term_qsum += q; rcc->short_term_qcount++; q = short_term_q = rcc->short_term_qsum / rcc->short_term_qcount; } assert(q > 0.0); q = modify_qscale(s, rce, q, picture_number); rcc->pass1_wanted_bits += s->bit_rate / fps; assert(q > 0.0); } if (s->avctx->debug & FF_DEBUG_RC) { av_log(s->avctx, AV_LOG_DEBUG, ""%c qp:%d<%2.1f<%d %d want:%d total:%d comp:%f st_q:%2.2f "" ""size:%d var:%d/%d br:%d fps:%d\n"", av_get_picture_type_char(pict_type), qmin, q, qmax, picture_number, (int)wanted_bits / 1000, (int)s->total_bits / 1000, br_compensation, short_term_q, s->frame_bits, pic->mb_var_sum, pic->mc_mb_var_sum, s->bit_rate / 1000, (int)fps); } if (q < qmin) q = qmin; else if (q > qmax) q = qmax; if (s->adaptive_quant) adaptive_quantization(s, q); else q = (int)(q + 0.5); if (!dry_run) { rcc->last_qscale = q; rcc->last_mc_mb_var_sum = pic->mc_mb_var_sum; rcc->last_mb_var_sum = pic->mb_var_sum; } return q; }"
885----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_30936f0c18b712564dd84bc406c6ac8810d0825f_1.json----ff_subblock_synthesis,"void ff_subblock_synthesis(RA144Context *ractx, const int16_t *lpc_coefs, int cba_idx, int cb1_idx, int cb2_idx, int gval, int gain) { <S2SV_StartVul> int16_t buffer_a[BLOCKSIZE]; <S2SV_EndVul> int16_t *block; int m[3]; if (cba_idx) { cba_idx += BLOCKSIZE/2 - 1; <S2SV_StartVul> ff_copy_and_dup(buffer_a, ractx->adapt_cb, cba_idx); <S2SV_EndVul> <S2SV_StartVul> m[0] = (ff_irms(buffer_a) * gval) >> 12; <S2SV_EndVul> } else { m[0] = 0; } m[1] = (ff_cb1_base[cb1_idx] * gval) >> 8; m[2] = (ff_cb2_base[cb2_idx] * gval) >> 8; memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE, (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb)); block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE; <S2SV_StartVul> add_wav(block, gain, cba_idx, m, cba_idx? buffer_a: NULL, <S2SV_EndVul> ff_cb1_vects[cb1_idx], ff_cb2_vects[cb2_idx]); memcpy(ractx->curr_sblock, ractx->curr_sblock + BLOCKSIZE, LPC_ORDER*sizeof(*ractx->curr_sblock)); if (ff_celp_lp_synthesis_filter(ractx->curr_sblock + LPC_ORDER, lpc_coefs, block, BLOCKSIZE, LPC_ORDER, 1, 0, 0xfff)) memset(ractx->curr_sblock, 0, (LPC_ORDER+BLOCKSIZE)*sizeof(*ractx->curr_sblock)); }","- int16_t buffer_a[BLOCKSIZE];
- ff_copy_and_dup(buffer_a, ractx->adapt_cb, cba_idx);
- m[0] = (ff_irms(buffer_a) * gval) >> 12;
- add_wav(block, gain, cba_idx, m, cba_idx? buffer_a: NULL,
+ ff_copy_and_dup(ractx->buffer_a, ractx->adapt_cb, cba_idx);
+ m[0] = (ff_irms(&ractx->dsp, ractx->buffer_a) * gval) >> 12;
+ add_wav(block, gain, cba_idx, m, cba_idx? ractx->buffer_a: NULL,","void ff_subblock_synthesis(RA144Context *ractx, const int16_t *lpc_coefs, int cba_idx, int cb1_idx, int cb2_idx, int gval, int gain) { int16_t *block; int m[3]; if (cba_idx) { cba_idx += BLOCKSIZE/2 - 1; ff_copy_and_dup(ractx->buffer_a, ractx->adapt_cb, cba_idx); m[0] = (ff_irms(&ractx->dsp, ractx->buffer_a) * gval) >> 12; } else { m[0] = 0; } m[1] = (ff_cb1_base[cb1_idx] * gval) >> 8; m[2] = (ff_cb2_base[cb2_idx] * gval) >> 8; memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE, (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb)); block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE; add_wav(block, gain, cba_idx, m, cba_idx? ractx->buffer_a: NULL, ff_cb1_vects[cb1_idx], ff_cb2_vects[cb2_idx]); memcpy(ractx->curr_sblock, ractx->curr_sblock + BLOCKSIZE, LPC_ORDER*sizeof(*ractx->curr_sblock)); if (ff_celp_lp_synthesis_filter(ractx->curr_sblock + LPC_ORDER, lpc_coefs, block, BLOCKSIZE, LPC_ORDER, 1, 0, 0xfff)) memset(ractx->curr_sblock, 0, (LPC_ORDER+BLOCKSIZE)*sizeof(*ractx->curr_sblock)); }"
41----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_029c887679414a6a62442e60648b455161af6980_1.json----hl_decode_mb_internal,"static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){ MpegEncContext * const s = &h->s; const int mb_x= s->mb_x; const int mb_y= s->mb_y; const int mb_xy= h->mb_xy; const int mb_type= s->current_picture.mb_type[mb_xy]; uint8_t *dest_y, *dest_cb, *dest_cr; int linesize, uvlinesize ; int i; int *block_offset = &h->block_offset[0]; const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass); const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264; void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride); void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride); dest_y = s->current_picture.data[0] + (mb_x + mb_y * s->linesize ) * 16; dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8; dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8; s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4); s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2); if (!simple && MB_FIELD) { linesize = h->mb_linesize = s->linesize * 2; uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2; block_offset = &h->block_offset[24]; if(mb_y&1){ dest_y -= s->linesize*15; dest_cb-= s->uvlinesize*7; dest_cr-= s->uvlinesize*7; } if(FRAME_MBAFF) { int list; for(list=0; list<h->list_count; list++){ if(!USES_LIST(mb_type, list)) continue; if(IS_16X16(mb_type)){ int8_t *ref = &h->ref_cache[list][scan8[0]]; fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1); }else{ for(i=0; i<16; i+=4){ int ref = h->ref_cache[list][scan8[i]]; if(ref >= 0) fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1); } } } } } else { linesize = h->mb_linesize = s->linesize; uvlinesize = h->mb_uvlinesize = s->uvlinesize; } if (!simple && IS_INTRA_PCM(mb_type)) { for (i=0; i<16; i++) { memcpy(dest_y + i* linesize, h->mb + i*8, 16); } for (i=0; i<8; i++) { memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4, 8); memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4, 8); } } else { if(IS_INTRA(mb_type)){ if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple); if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize); h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize); } if(IS_INTRA4x4(mb_type)){ if(simple || !s->encoding){ if(IS_8x8DCT(mb_type)){ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels8; }else{ idct_dc_add = s->dsp.h264_idct8_dc_add; idct_add = s->dsp.h264_idct8_add; } for(i=0; i<16; i+=4){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize); }else{ const int nnz = h->non_zero_count_cache[ scan8[i] ]; h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000, (h->topright_samples_available<<i)&0x4000, linesize); if(nnz){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); } } } }else{ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels4; }else{ idct_dc_add = s->dsp.h264_idct_dc_add; idct_add = s->dsp.h264_idct_add; } for(i=0; i<16; i++){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize); }else{ uint8_t *topright; int nnz, tr; if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){ const int topright_avail= (h->topright_samples_available<<i)&0x8000; assert(mb_y || linesize <= block_offset[i]); if(!topright_avail){ tr= ptr[3 - linesize]*0x01010101; topright= (uint8_t*) &tr; }else topright= ptr + 4 - linesize; }else topright= NULL; h->hpc.pred4x4[ dir ](ptr, topright, linesize); nnz = h->non_zero_count_cache[ scan8[i] ]; if(nnz){ if(is_h264){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); }else svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0); } } } } } }else{ h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize); if(is_h264){ if(!transform_bypass) h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]); }else svq3_luma_dc_dequant_idct_c(h->mb, s->qscale); } if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple); }else if(is_h264){ hl_motion(h, dest_y, dest_cb, dest_cr, s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab, s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab, s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab); } if(!IS_INTRA4x4(mb_type)){ if(is_h264){ if(IS_INTRA16x16(mb_type)){ if(transform_bypass){ if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){ h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize); }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } }else if(h->cbp&15){ if(transform_bypass){ const int di = IS_8x8DCT(mb_type) ? 4 : 1; idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4; for(i=0; i<16; i+=di){ if(h->non_zero_count_cache[ scan8[i] ]){ idct_add(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ if(IS_8x8DCT(mb_type)){ s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); }else{ s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } } } }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest_y + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0); } } } } if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){ uint8_t *dest[2] = {dest_cb, dest_cr}; if(transform_bypass){ if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){ h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize); h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize); }else{ idct_add = s->dsp.add_pixels4; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } } }else{ chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]); chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]); if(is_h264){ idct_add = s->dsp.h264_idct_add; idct_dc_add = s->dsp.h264_idct_dc_add; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); else if(h->mb[i*16]) idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } }else{ for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, chroma_qp[s->qscale + 12] - 12, 2); } } } } } } if(h->cbp || IS_INTRA(mb_type)) s->dsp.clear_blocks(h->mb); if(h->deblocking_filter) { backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple); fill_caches(h, mb_type, 1); h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]); h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]); if (!simple && FRAME_MBAFF) { <S2SV_StartVul> filter_mb (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); <S2SV_EndVul> } else { <S2SV_StartVul> filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); <S2SV_EndVul> } } }","- filter_mb (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);
- filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);
+ ff_h264_filter_mb (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);
+ ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);","static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){ MpegEncContext * const s = &h->s; const int mb_x= s->mb_x; const int mb_y= s->mb_y; const int mb_xy= h->mb_xy; const int mb_type= s->current_picture.mb_type[mb_xy]; uint8_t *dest_y, *dest_cb, *dest_cr; int linesize, uvlinesize ; int i; int *block_offset = &h->block_offset[0]; const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass); const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264; void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride); void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride); dest_y = s->current_picture.data[0] + (mb_x + mb_y * s->linesize ) * 16; dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8; dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8; s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4); s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2); if (!simple && MB_FIELD) { linesize = h->mb_linesize = s->linesize * 2; uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2; block_offset = &h->block_offset[24]; if(mb_y&1){ dest_y -= s->linesize*15; dest_cb-= s->uvlinesize*7; dest_cr-= s->uvlinesize*7; } if(FRAME_MBAFF) { int list; for(list=0; list<h->list_count; list++){ if(!USES_LIST(mb_type, list)) continue; if(IS_16X16(mb_type)){ int8_t *ref = &h->ref_cache[list][scan8[0]]; fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1); }else{ for(i=0; i<16; i+=4){ int ref = h->ref_cache[list][scan8[i]]; if(ref >= 0) fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1); } } } } } else { linesize = h->mb_linesize = s->linesize; uvlinesize = h->mb_uvlinesize = s->uvlinesize; } if (!simple && IS_INTRA_PCM(mb_type)) { for (i=0; i<16; i++) { memcpy(dest_y + i* linesize, h->mb + i*8, 16); } for (i=0; i<8; i++) { memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4, 8); memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4, 8); } } else { if(IS_INTRA(mb_type)){ if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple); if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize); h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize); } if(IS_INTRA4x4(mb_type)){ if(simple || !s->encoding){ if(IS_8x8DCT(mb_type)){ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels8; }else{ idct_dc_add = s->dsp.h264_idct8_dc_add; idct_add = s->dsp.h264_idct8_add; } for(i=0; i<16; i+=4){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize); }else{ const int nnz = h->non_zero_count_cache[ scan8[i] ]; h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000, (h->topright_samples_available<<i)&0x4000, linesize); if(nnz){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); } } } }else{ if(transform_bypass){ idct_dc_add = idct_add = s->dsp.add_pixels4; }else{ idct_dc_add = s->dsp.h264_idct_dc_add; idct_add = s->dsp.h264_idct_add; } for(i=0; i<16; i++){ uint8_t * const ptr= dest_y + block_offset[i]; const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ]; if(transform_bypass && h->sps.profile_idc==244 && dir<=1){ h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize); }else{ uint8_t *topright; int nnz, tr; if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){ const int topright_avail= (h->topright_samples_available<<i)&0x8000; assert(mb_y || linesize <= block_offset[i]); if(!topright_avail){ tr= ptr[3 - linesize]*0x01010101; topright= (uint8_t*) &tr; }else topright= ptr + 4 - linesize; }else topright= NULL; h->hpc.pred4x4[ dir ](ptr, topright, linesize); nnz = h->non_zero_count_cache[ scan8[i] ]; if(nnz){ if(is_h264){ if(nnz == 1 && h->mb[i*16]) idct_dc_add(ptr, h->mb + i*16, linesize); else idct_add (ptr, h->mb + i*16, linesize); }else svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0); } } } } } }else{ h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize); if(is_h264){ if(!transform_bypass) h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]); }else svq3_luma_dc_dequant_idct_c(h->mb, s->qscale); } if(h->deblocking_filter) xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple); }else if(is_h264){ hl_motion(h, dest_y, dest_cb, dest_cr, s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab, s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab, s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab); } if(!IS_INTRA4x4(mb_type)){ if(is_h264){ if(IS_INTRA16x16(mb_type)){ if(transform_bypass){ if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){ h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize); }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } }else if(h->cbp&15){ if(transform_bypass){ const int di = IS_8x8DCT(mb_type) ? 4 : 1; idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4; for(i=0; i<16; i+=di){ if(h->non_zero_count_cache[ scan8[i] ]){ idct_add(dest_y + block_offset[i], h->mb + i*16, linesize); } } }else{ if(IS_8x8DCT(mb_type)){ s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); }else{ s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache); } } } }else{ for(i=0; i<16; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest_y + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0); } } } } if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){ uint8_t *dest[2] = {dest_cb, dest_cr}; if(transform_bypass){ if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){ h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize); h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize); }else{ idct_add = s->dsp.add_pixels4; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } } }else{ chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]); chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]); if(is_h264){ idct_add = s->dsp.h264_idct_add; idct_dc_add = s->dsp.h264_idct_dc_add; for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ]) idct_add (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); else if(h->mb[i*16]) idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize); } }else{ for(i=16; i<16+8; i++){ if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i]; svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, chroma_qp[s->qscale + 12] - 12, 2); } } } } } } if(h->cbp || IS_INTRA(mb_type)) s->dsp.clear_blocks(h->mb); if(h->deblocking_filter) { backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple); fill_caches(h, mb_type, 1); h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]); h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]); if (!simple && FRAME_MBAFF) { ff_h264_filter_mb (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); } else { ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize); } } }"
7443----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_93cb98eec0022d2bc12e002052541804e54ef59e_1.json----tcp_open,"static int tcp_open(URLContext *h, const char *uri, int flags) { struct addrinfo hints = { 0 }, *ai, *cur_ai; int port, fd = -1; TCPContext *s = h->priv_data; int listen_socket = 0; const char *p; char buf[256]; int ret; int timeout = 100, listen_timeout = -1; char hostname[1024],proto[1024],path[1024]; char portstr[10]; av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); if (strcmp(proto, ""tcp"")) return AVERROR(EINVAL); if (port <= 0 || port >= 65536) { av_log(h, AV_LOG_ERROR, ""Port missing in uri\n""); return AVERROR(EINVAL); } p = strchr(uri, '?'); if (p) { if (av_find_info_tag(buf, sizeof(buf), ""listen"", p)) listen_socket = 1; if (av_find_info_tag(buf, sizeof(buf), ""timeout"", p)) { timeout = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), ""listen_timeout"", p)) { listen_timeout = strtol(buf, NULL, 10); } } hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; snprintf(portstr, sizeof(portstr), ""%d"", port); if (listen_socket) hints.ai_flags |= AI_PASSIVE; if (!hostname[0]) ret = getaddrinfo(NULL, portstr, &hints, &ai); else ret = getaddrinfo(hostname, portstr, &hints, &ai); if (ret) { av_log(h, AV_LOG_ERROR, ""Failed to resolve hostname %s: %s\n"", hostname, gai_strerror(ret)); return AVERROR(EIO); } cur_ai = ai; restart: fd = socket(cur_ai->ai_family, cur_ai->ai_socktype, cur_ai->ai_protocol); if (fd < 0) { ret = ff_neterrno(); goto fail; } if (listen_socket) { if ((fd = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen, <S2SV_StartVul> listen_timeout)) < 0) { <S2SV_EndVul> ret = fd; goto fail1; } } else { if ((ret = ff_listen_connect(fd, cur_ai->ai_addr, cur_ai->ai_addrlen, <S2SV_StartVul> timeout, h)) < 0) { <S2SV_EndVul> if (ret == AVERROR_EXIT) goto fail1; else goto fail; } } h->is_streamed = 1; s->fd = fd; freeaddrinfo(ai); return 0; fail: if (cur_ai->ai_next) { cur_ai = cur_ai->ai_next; if (fd >= 0) closesocket(fd); ret = 0; goto restart; } fail1: if (fd >= 0) closesocket(fd); freeaddrinfo(ai); return ret; }","- listen_timeout)) < 0) {
- timeout, h)) < 0) {
+ listen_timeout, h)) < 0) {
+ timeout * 100, h)) < 0) {","static int tcp_open(URLContext *h, const char *uri, int flags) { struct addrinfo hints = { 0 }, *ai, *cur_ai; int port, fd = -1; TCPContext *s = h->priv_data; int listen_socket = 0; const char *p; char buf[256]; int ret; int timeout = 100, listen_timeout = -1; char hostname[1024],proto[1024],path[1024]; char portstr[10]; av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); if (strcmp(proto, ""tcp"")) return AVERROR(EINVAL); if (port <= 0 || port >= 65536) { av_log(h, AV_LOG_ERROR, ""Port missing in uri\n""); return AVERROR(EINVAL); } p = strchr(uri, '?'); if (p) { if (av_find_info_tag(buf, sizeof(buf), ""listen"", p)) listen_socket = 1; if (av_find_info_tag(buf, sizeof(buf), ""timeout"", p)) { timeout = strtol(buf, NULL, 10); } if (av_find_info_tag(buf, sizeof(buf), ""listen_timeout"", p)) { listen_timeout = strtol(buf, NULL, 10); } } hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; snprintf(portstr, sizeof(portstr), ""%d"", port); if (listen_socket) hints.ai_flags |= AI_PASSIVE; if (!hostname[0]) ret = getaddrinfo(NULL, portstr, &hints, &ai); else ret = getaddrinfo(hostname, portstr, &hints, &ai); if (ret) { av_log(h, AV_LOG_ERROR, ""Failed to resolve hostname %s: %s\n"", hostname, gai_strerror(ret)); return AVERROR(EIO); } cur_ai = ai; restart: fd = socket(cur_ai->ai_family, cur_ai->ai_socktype, cur_ai->ai_protocol); if (fd < 0) { ret = ff_neterrno(); goto fail; } if (listen_socket) { if ((fd = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen, listen_timeout, h)) < 0) { ret = fd; goto fail1; } } else { if ((ret = ff_listen_connect(fd, cur_ai->ai_addr, cur_ai->ai_addrlen, timeout * 100, h)) < 0) { if (ret == AVERROR_EXIT) goto fail1; else goto fail; } } h->is_streamed = 1; s->fd = fd; freeaddrinfo(ai); return 0; fail: if (cur_ai->ai_next) { cur_ai = cur_ai->ai_next; if (fd >= 0) closesocket(fd); ret = 0; goto restart; } fail1: if (fd >= 0) closesocket(fd); freeaddrinfo(ai); return ret; }"
5043----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_05ee2642682a2b1a2624ee29223824a2a588fa74_1.json----get_bits,"static int get_bits(Jpeg2000DecoderContext *s, int n) { int res = 0; <S2SV_StartVul> if (s->buf_end - s->buf < ((n - s->bit_index) >> 8)) <S2SV_EndVul> <S2SV_StartVul> return AVERROR_INVALIDDATA; <S2SV_EndVul> while (--n >= 0) { res <<= 1; if (s->bit_index == 0) { <S2SV_StartVul> s->bit_index = 7 + (*s->buf != 0xff); <S2SV_EndVul> <S2SV_StartVul> s->buf++; <S2SV_EndVul> } s->bit_index--; <S2SV_StartVul> res |= (*s->buf >> s->bit_index) & 1; <S2SV_EndVul> } return res; }","- if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
- return AVERROR_INVALIDDATA;
- s->bit_index = 7 + (*s->buf != 0xff);
- s->buf++;
- res |= (*s->buf >> s->bit_index) & 1;
+ s->bit_index = 7 + (bytestream2_get_byte(&s->g) != 0xFFu);
+ res |= (bytestream2_peek_byte(&s->g) >> s->bit_index) & 1;","static int get_bits(Jpeg2000DecoderContext *s, int n) { int res = 0; while (--n >= 0) { res <<= 1; if (s->bit_index == 0) { s->bit_index = 7 + (bytestream2_get_byte(&s->g) != 0xFFu); } s->bit_index--; res |= (bytestream2_peek_byte(&s->g) >> s->bit_index) & 1; } return res; }"
10687----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0f7bbc491948a94a44b45e94e06ed14defa95b9d_1.json----by_file_ctrl,"static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl, char **ret) { <S2SV_StartVul> int ok=0,ok2=0; <S2SV_EndVul> char *file; switch (cmd) { case X509_L_FILE_LOAD: if (argl == X509_FILETYPE_DEFAULT) { <S2SV_StartVul> ok=X509_load_cert_file(ctx,X509_get_default_cert_file(), <S2SV_EndVul> X509_FILETYPE_PEM); <S2SV_StartVul> ok2=X509_load_crl_file(ctx,X509_get_default_cert_file(), <S2SV_EndVul> <S2SV_StartVul> X509_FILETYPE_PEM); <S2SV_EndVul> <S2SV_StartVul> if (!ok || !ok2) <S2SV_EndVul> { X509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS); } else { file=(char *)Getenv(X509_get_default_cert_file_env()); <S2SV_StartVul> ok=X509_load_cert_file(ctx,file, <S2SV_EndVul> <S2SV_StartVul> X509_FILETYPE_PEM); <S2SV_EndVul> <S2SV_StartVul> ok2=X509_load_crl_file(ctx,file, <S2SV_EndVul> X509_FILETYPE_PEM); } } else { <S2SV_StartVul> ok=X509_load_cert_file(ctx,argp,(int)argl); <S2SV_EndVul> <S2SV_StartVul> ok2=X509_load_crl_file(ctx,argp,(int)argl); <S2SV_EndVul> } break; } <S2SV_StartVul> return((ok && ok2)?ok:0); <S2SV_EndVul> }","- int ok=0,ok2=0;
- ok=X509_load_cert_file(ctx,X509_get_default_cert_file(),
- ok2=X509_load_crl_file(ctx,X509_get_default_cert_file(),
- X509_FILETYPE_PEM);
- if (!ok || !ok2)
- ok=X509_load_cert_file(ctx,file,
- X509_FILETYPE_PEM);
- ok2=X509_load_crl_file(ctx,file,
- ok=X509_load_cert_file(ctx,argp,(int)argl);
- ok2=X509_load_crl_file(ctx,argp,(int)argl);
- return((ok && ok2)?ok:0);
+ int ok=0;
+ ok=X509_load_cert_crl_file(ctx,X509_get_default_cert_file(),
+ if (!ok)
+ ok=X509_load_cert_crl_file(ctx,file,
+ if(argl == X509_FILETYPE_PEM)
+ ok=X509_load_cert_crl_file(ctx,argp,
+ X509_FILETYPE_PEM);
+ else ok=X509_load_cert_file(ctx,argp,(int)argl);
+ return(ok);","static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl, char **ret) { int ok=0; char *file; switch (cmd) { case X509_L_FILE_LOAD: if (argl == X509_FILETYPE_DEFAULT) { ok=X509_load_cert_crl_file(ctx,X509_get_default_cert_file(), X509_FILETYPE_PEM); if (!ok) { X509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS); } else { file=(char *)Getenv(X509_get_default_cert_file_env()); ok=X509_load_cert_crl_file(ctx,file, X509_FILETYPE_PEM); } } else { if(argl == X509_FILETYPE_PEM) ok=X509_load_cert_crl_file(ctx,argp, X509_FILETYPE_PEM); else ok=X509_load_cert_file(ctx,argp,(int)argl); } break; } return(ok); }"
49----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03337126d300793f1d2684ee7705327b30237d40_1.json----old_codec47,"static int old_codec47(SANMVideoContext *ctx, int top, int left, int width, int height) { int i, j, seq, compr, new_rot, tbl_pos, skip; int stride = ctx->pitch; uint8_t *dst = ((uint8_t*)ctx->frm0) + left + top * stride; uint8_t *prev1 = (uint8_t*)ctx->frm1; uint8_t *prev2 = (uint8_t*)ctx->frm2; uint32_t decoded_size; tbl_pos = bytestream2_tell(&ctx->gb); seq = bytestream2_get_le16(&ctx->gb); compr = bytestream2_get_byte(&ctx->gb); new_rot = bytestream2_get_byte(&ctx->gb); skip = bytestream2_get_byte(&ctx->gb); bytestream2_skip(&ctx->gb, 9); decoded_size = bytestream2_get_le32(&ctx->gb); bytestream2_skip(&ctx->gb, 8); <S2SV_StartVul> if (decoded_size > height * stride - left - top * stride) { <S2SV_EndVul> <S2SV_StartVul> decoded_size = height * stride - left - top * stride; <S2SV_EndVul> av_log(ctx->avctx, AV_LOG_WARNING, ""decoded size is too large\n""); } if (skip & 1) bytestream2_skip(&ctx->gb, 0x8080); if (!seq) { ctx->prev_seq = -1; memset(prev1, 0, ctx->height * stride); memset(prev2, 0, ctx->height * stride); } av_dlog(ctx->avctx, ""compression %d\n"", compr); switch (compr) { case 0: if (bytestream2_get_bytes_left(&ctx->gb) < width * height) return AVERROR_INVALIDDATA; for (j = 0; j < height; j++) { bytestream2_get_bufferu(&ctx->gb, dst, width); dst += stride; } break; case 1: if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1)) return AVERROR_INVALIDDATA; for (j = 0; j < height; j += 2) { for (i = 0; i < width; i += 2) { dst[i] = dst[i + 1] = dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb); } dst += stride * 2; } break; case 2: if (seq == ctx->prev_seq + 1) { for (j = 0; j < height; j += 8) { for (i = 0; i < width; i += 8) { if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride, tbl_pos + 8, 8)) return AVERROR_INVALIDDATA; } dst += stride * 8; prev1 += stride * 8; prev2 += stride * 8; } } break; case 3: memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height); break; case 4: memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height); break; case 5: if (rle_decode(ctx, dst, decoded_size)) return AVERROR_INVALIDDATA; break; default: av_log(ctx->avctx, AV_LOG_ERROR, ""subcodec 47 compression %d not implemented\n"", compr); return AVERROR_PATCHWELCOME; } if (seq == ctx->prev_seq + 1) ctx->rotate_code = new_rot; else ctx->rotate_code = 0; ctx->prev_seq = seq; return 0; }","- if (decoded_size > height * stride - left - top * stride) {
- decoded_size = height * stride - left - top * stride;
+ if (decoded_size > ctx->height * stride - left - top * stride) {
+ decoded_size = ctx->height * stride - left - top * stride;","static int old_codec47(SANMVideoContext *ctx, int top, int left, int width, int height) { int i, j, seq, compr, new_rot, tbl_pos, skip; int stride = ctx->pitch; uint8_t *dst = ((uint8_t*)ctx->frm0) + left + top * stride; uint8_t *prev1 = (uint8_t*)ctx->frm1; uint8_t *prev2 = (uint8_t*)ctx->frm2; uint32_t decoded_size; tbl_pos = bytestream2_tell(&ctx->gb); seq = bytestream2_get_le16(&ctx->gb); compr = bytestream2_get_byte(&ctx->gb); new_rot = bytestream2_get_byte(&ctx->gb); skip = bytestream2_get_byte(&ctx->gb); bytestream2_skip(&ctx->gb, 9); decoded_size = bytestream2_get_le32(&ctx->gb); bytestream2_skip(&ctx->gb, 8); if (decoded_size > ctx->height * stride - left - top * stride) { decoded_size = ctx->height * stride - left - top * stride; av_log(ctx->avctx, AV_LOG_WARNING, ""decoded size is too large\n""); } if (skip & 1) bytestream2_skip(&ctx->gb, 0x8080); if (!seq) { ctx->prev_seq = -1; memset(prev1, 0, ctx->height * stride); memset(prev2, 0, ctx->height * stride); } av_dlog(ctx->avctx, ""compression %d\n"", compr); switch (compr) { case 0: if (bytestream2_get_bytes_left(&ctx->gb) < width * height) return AVERROR_INVALIDDATA; for (j = 0; j < height; j++) { bytestream2_get_bufferu(&ctx->gb, dst, width); dst += stride; } break; case 1: if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1)) return AVERROR_INVALIDDATA; for (j = 0; j < height; j += 2) { for (i = 0; i < width; i += 2) { dst[i] = dst[i + 1] = dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb); } dst += stride * 2; } break; case 2: if (seq == ctx->prev_seq + 1) { for (j = 0; j < height; j += 8) { for (i = 0; i < width; i += 8) { if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride, tbl_pos + 8, 8)) return AVERROR_INVALIDDATA; } dst += stride * 8; prev1 += stride * 8; prev2 += stride * 8; } } break; case 3: memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height); break; case 4: memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height); break; case 5: if (rle_decode(ctx, dst, decoded_size)) return AVERROR_INVALIDDATA; break; default: av_log(ctx->avctx, AV_LOG_ERROR, ""subcodec 47 compression %d not implemented\n"", compr); return AVERROR_PATCHWELCOME; } if (seq == ctx->prev_seq + 1) ctx->rotate_code = new_rot; else ctx->rotate_code = 0; ctx->prev_seq = seq; return 0; }"
10990----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_1.json----EVP_PKEY_free_it,static void EVP_PKEY_free_it(EVP_PKEY *x) { if (x->ameth && x->ameth->pkey_free) { x->ameth->pkey_free(x); x->pkey.ptr = NULL; } #ifndef OPENSSL_NO_ENGINE <S2SV_StartVul> if (x->engine) { <S2SV_EndVul> <S2SV_StartVul> ENGINE_finish(x->engine); <S2SV_EndVul> <S2SV_StartVul> x->engine = NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> #endif },"- if (x->engine) {
- ENGINE_finish(x->engine);
- x->engine = NULL;
- }
+ ENGINE_finish(x->engine);
+ x->engine = NULL;",static void EVP_PKEY_free_it(EVP_PKEY *x) { if (x->ameth && x->ameth->pkey_free) { x->ameth->pkey_free(x); x->pkey.ptr = NULL; } #ifndef OPENSSL_NO_ENGINE ENGINE_finish(x->engine); x->engine = NULL; #endif }
16620----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_ddbfa79b85c60119be90fa16a23aa03c45c72e9c_1.json----RAND_DRBG_free,"<S2SV_StartVul> void RAND_DRBG_free(DRBG_CTX *dctx) <S2SV_EndVul> { <S2SV_StartVul> if (dctx == NULL) <S2SV_EndVul> return; <S2SV_StartVul> ctr_uninstantiate(dctx); <S2SV_EndVul> <S2SV_StartVul> CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, dctx, &dctx->ex_data); <S2SV_EndVul> <S2SV_StartVul> if (dctx == RAND_DRBG_get_default()) { <S2SV_EndVul> <S2SV_StartVul> memset(dctx, 0, sizeof(DRBG_CTX)); <S2SV_EndVul> <S2SV_StartVul> dctx->nid = 0; <S2SV_EndVul> <S2SV_StartVul> dctx->status = DRBG_STATUS_UNINITIALISED; <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> OPENSSL_cleanse(&dctx->ctr, sizeof(dctx->ctr)); <S2SV_EndVul> <S2SV_StartVul> OPENSSL_free(dctx); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> }","- void RAND_DRBG_free(DRBG_CTX *dctx)
- if (dctx == NULL)
- ctr_uninstantiate(dctx);
- CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, dctx, &dctx->ex_data);
- if (dctx == RAND_DRBG_get_default()) {
- memset(dctx, 0, sizeof(DRBG_CTX));
- dctx->nid = 0;
- dctx->status = DRBG_STATUS_UNINITIALISED;
- } else {
- OPENSSL_cleanse(&dctx->ctr, sizeof(dctx->ctr));
- OPENSSL_free(dctx);
- }
+ void RAND_DRBG_free(RAND_DRBG *drbg)
+ if (drbg == NULL || drbg == &rand_drbg)
+ ctr_uninstantiate(drbg);
+ OPENSSL_cleanse(drbg->randomness, drbg->size);
+ OPENSSL_free(drbg->randomness);
+ CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, drbg, &drbg->ex_data);
+ OPENSSL_clear_free(drbg, sizeof(*drbg));","void RAND_DRBG_free(RAND_DRBG *drbg) { if (drbg == NULL || drbg == &rand_drbg) return; ctr_uninstantiate(drbg); OPENSSL_cleanse(drbg->randomness, drbg->size); OPENSSL_free(drbg->randomness); CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, drbg, &drbg->ex_data); OPENSSL_clear_free(drbg, sizeof(*drbg)); }"
1582----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_585255eed3ce6685ba43022e63aa9ffe744a0871_1.json----matroska_parse_block,"static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size, int64_t pos, uint64_t cluster_time, uint64_t duration, int is_keyframe, int is_bframe) { int res = 0; int track; AVStream *st; AVPacket *pkt; uint8_t *origdata = data; int16_t block_time; uint32_t *lace_size = NULL; int n, flags, laces = 0; uint64_t num; int stream_index; if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) { av_log(matroska->ctx, AV_LOG_ERROR, ""EBML block data error\n""); av_free(origdata); return res; } data += n; size -= n; track = matroska_find_track_by_num(matroska, num); if (size <= 3 || track < 0 || track >= matroska->num_tracks) { av_log(matroska->ctx, AV_LOG_INFO, ""Invalid stream %d or size %u\n"", track, size); av_free(origdata); return res; } stream_index = matroska->tracks[track]->stream_index; <S2SV_StartVul> if (stream_index < 0) { <S2SV_EndVul> av_free(origdata); return res; } st = matroska->ctx->streams[stream_index]; if (st->discard >= AVDISCARD_ALL) { av_free(origdata); return res; } if (duration == AV_NOPTS_VALUE) duration = matroska->tracks[track]->default_duration / matroska->time_scale; block_time = AV_RB16(data); data += 2; flags = *data++; size -= 3; if (is_keyframe == -1) is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0; if (matroska->skip_to_keyframe) { if (!is_keyframe || st != matroska->skip_to_stream) { av_free(origdata); return res; } matroska->skip_to_keyframe = 0; } switch ((flags & 0x06) >> 1) { case 0x0: laces = 1; lace_size = av_mallocz(sizeof(int)); lace_size[0] = size; break; case 0x1: case 0x2: case 0x3: if (size == 0) { res = -1; break; } laces = (*data) + 1; data += 1; size -= 1; lace_size = av_mallocz(laces * sizeof(int)); switch ((flags & 0x06) >> 1) { case 0x1: { uint8_t temp; uint32_t total = 0; for (n = 0; res == 0 && n < laces - 1; n++) { while (1) { if (size == 0) { res = -1; break; } temp = *data; lace_size[n] += temp; data += 1; size -= 1; if (temp != 0xff) break; } total += lace_size[n]; } lace_size[n] = size - total; break; } case 0x2: for (n = 0; n < laces; n++) lace_size[n] = size / laces; break; case 0x3: { uint32_t total; n = matroska_ebmlnum_uint(data, size, &num); if (n < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); break; } data += n; size -= n; total = lace_size[0] = num; for (n = 1; res == 0 && n < laces - 1; n++) { int64_t snum; int r; r = matroska_ebmlnum_sint (data, size, &snum); if (r < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); break; } data += r; size -= r; lace_size[n] = lace_size[n - 1] + snum; total += lace_size[n]; } lace_size[n] = size - total; break; } } break; } if (res == 0) { uint64_t timecode = AV_NOPTS_VALUE; if (cluster_time != (uint64_t)-1 && (block_time >= 0 || cluster_time >= -block_time)) timecode = cluster_time + block_time; for (n = 0; n < laces; n++) { if (st->codec->codec_id == CODEC_ID_RA_288 || st->codec->codec_id == CODEC_ID_COOK || st->codec->codec_id == CODEC_ID_ATRAC3) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track]; int a = st->codec->block_align; int sps = audiotrack->sub_packet_size; int cfs = audiotrack->coded_framesize; int h = audiotrack->sub_packet_h; int y = audiotrack->sub_packet_cnt; int w = audiotrack->frame_size; int x; if (!audiotrack->pkt_cnt) { if (st->codec->codec_id == CODEC_ID_RA_288) for (x=0; x<h/2; x++) memcpy(audiotrack->buf+x*2*w+y*cfs, data+x*cfs, cfs); else for (x=0; x<w/sps; x++) memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps); if (++audiotrack->sub_packet_cnt >= h) { audiotrack->sub_packet_cnt = 0; audiotrack->pkt_cnt = h*w / a; } } while (audiotrack->pkt_cnt) { pkt = av_mallocz(sizeof(AVPacket)); av_new_packet(pkt, a); memcpy(pkt->data, audiotrack->buf + a * (h*w / a - audiotrack->pkt_cnt--), a); pkt->pos = pos; pkt->stream_index = stream_index; matroska_queue_packet(matroska, pkt); } } else { int offset = 0; pkt = av_mallocz(sizeof(AVPacket)); if (av_new_packet(pkt, lace_size[n]-offset) < 0) { res = AVERROR(ENOMEM); n = laces-1; break; } memcpy (pkt->data, data+offset, lace_size[n]-offset); if (n == 0) pkt->flags = is_keyframe; pkt->stream_index = stream_index; pkt->pts = timecode; pkt->pos = pos; pkt->duration = duration; matroska_queue_packet(matroska, pkt); } if (timecode != AV_NOPTS_VALUE) timecode = duration ? timecode + duration : AV_NOPTS_VALUE; data += lace_size[n]; } } av_free(lace_size); av_free(origdata); return res; }","- if (stream_index < 0) {
+ if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {","static int matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size, int64_t pos, uint64_t cluster_time, uint64_t duration, int is_keyframe, int is_bframe) { int res = 0; int track; AVStream *st; AVPacket *pkt; uint8_t *origdata = data; int16_t block_time; uint32_t *lace_size = NULL; int n, flags, laces = 0; uint64_t num; int stream_index; if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) { av_log(matroska->ctx, AV_LOG_ERROR, ""EBML block data error\n""); av_free(origdata); return res; } data += n; size -= n; track = matroska_find_track_by_num(matroska, num); if (size <= 3 || track < 0 || track >= matroska->num_tracks) { av_log(matroska->ctx, AV_LOG_INFO, ""Invalid stream %d or size %u\n"", track, size); av_free(origdata); return res; } stream_index = matroska->tracks[track]->stream_index; if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) { av_free(origdata); return res; } st = matroska->ctx->streams[stream_index]; if (st->discard >= AVDISCARD_ALL) { av_free(origdata); return res; } if (duration == AV_NOPTS_VALUE) duration = matroska->tracks[track]->default_duration / matroska->time_scale; block_time = AV_RB16(data); data += 2; flags = *data++; size -= 3; if (is_keyframe == -1) is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0; if (matroska->skip_to_keyframe) { if (!is_keyframe || st != matroska->skip_to_stream) { av_free(origdata); return res; } matroska->skip_to_keyframe = 0; } switch ((flags & 0x06) >> 1) { case 0x0: laces = 1; lace_size = av_mallocz(sizeof(int)); lace_size[0] = size; break; case 0x1: case 0x2: case 0x3: if (size == 0) { res = -1; break; } laces = (*data) + 1; data += 1; size -= 1; lace_size = av_mallocz(laces * sizeof(int)); switch ((flags & 0x06) >> 1) { case 0x1: { uint8_t temp; uint32_t total = 0; for (n = 0; res == 0 && n < laces - 1; n++) { while (1) { if (size == 0) { res = -1; break; } temp = *data; lace_size[n] += temp; data += 1; size -= 1; if (temp != 0xff) break; } total += lace_size[n]; } lace_size[n] = size - total; break; } case 0x2: for (n = 0; n < laces; n++) lace_size[n] = size / laces; break; case 0x3: { uint32_t total; n = matroska_ebmlnum_uint(data, size, &num); if (n < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); break; } data += n; size -= n; total = lace_size[0] = num; for (n = 1; res == 0 && n < laces - 1; n++) { int64_t snum; int r; r = matroska_ebmlnum_sint (data, size, &snum); if (r < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); break; } data += r; size -= r; lace_size[n] = lace_size[n - 1] + snum; total += lace_size[n]; } lace_size[n] = size - total; break; } } break; } if (res == 0) { uint64_t timecode = AV_NOPTS_VALUE; if (cluster_time != (uint64_t)-1 && (block_time >= 0 || cluster_time >= -block_time)) timecode = cluster_time + block_time; for (n = 0; n < laces; n++) { if (st->codec->codec_id == CODEC_ID_RA_288 || st->codec->codec_id == CODEC_ID_COOK || st->codec->codec_id == CODEC_ID_ATRAC3) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track]; int a = st->codec->block_align; int sps = audiotrack->sub_packet_size; int cfs = audiotrack->coded_framesize; int h = audiotrack->sub_packet_h; int y = audiotrack->sub_packet_cnt; int w = audiotrack->frame_size; int x; if (!audiotrack->pkt_cnt) { if (st->codec->codec_id == CODEC_ID_RA_288) for (x=0; x<h/2; x++) memcpy(audiotrack->buf+x*2*w+y*cfs, data+x*cfs, cfs); else for (x=0; x<w/sps; x++) memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps); if (++audiotrack->sub_packet_cnt >= h) { audiotrack->sub_packet_cnt = 0; audiotrack->pkt_cnt = h*w / a; } } while (audiotrack->pkt_cnt) { pkt = av_mallocz(sizeof(AVPacket)); av_new_packet(pkt, a); memcpy(pkt->data, audiotrack->buf + a * (h*w / a - audiotrack->pkt_cnt--), a); pkt->pos = pos; pkt->stream_index = stream_index; matroska_queue_packet(matroska, pkt); } } else { int offset = 0; pkt = av_mallocz(sizeof(AVPacket)); if (av_new_packet(pkt, lace_size[n]-offset) < 0) { res = AVERROR(ENOMEM); n = laces-1; break; } memcpy (pkt->data, data+offset, lace_size[n]-offset); if (n == 0) pkt->flags = is_keyframe; pkt->stream_index = stream_index; pkt->pts = timecode; pkt->pos = pos; pkt->duration = duration; matroska_queue_packet(matroska, pkt); } if (timecode != AV_NOPTS_VALUE) timecode = duration ? timecode + duration : AV_NOPTS_VALUE; data += lace_size[n]; } } av_free(lace_size); av_free(origdata); return res; }"
10733----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_113012cef007976c3aae66c276b7e2095e9090a0_1.json----tls13_change_cipher_state,"int tls13_change_cipher_state(SSL *s, int which) { static const unsigned char client_early_traffic[] = ""c e traffic""; static const unsigned char client_handshake_traffic[] = ""c hs traffic""; static const unsigned char client_application_traffic[] = ""c ap traffic""; static const unsigned char server_handshake_traffic[] = ""s hs traffic""; static const unsigned char server_application_traffic[] = ""s ap traffic""; static const unsigned char exporter_master_secret[] = ""exp master""; static const unsigned char resumption_master_secret[] = ""res master""; unsigned char *iv; unsigned char secret[EVP_MAX_MD_SIZE]; unsigned char hashval[EVP_MAX_MD_SIZE]; unsigned char *hash = hashval; unsigned char *insecret; unsigned char *finsecret = NULL; const char *log_label = NULL; EVP_CIPHER_CTX *ciph_ctx; size_t finsecretlen = 0; const unsigned char *label; size_t labellen, hashlen = 0; int ret = 0; const EVP_MD *md = NULL; const EVP_CIPHER *cipher = NULL; if (which & SSL3_CC_READ) { if (s->enc_read_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_read_ctx); } else { s->enc_read_ctx = EVP_CIPHER_CTX_new(); if (s->enc_read_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_read_ctx; iv = s->read_iv; RECORD_LAYER_reset_read_sequence(&s->rlayer); } else { if (s->enc_write_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_write_ctx); } else { s->enc_write_ctx = EVP_CIPHER_CTX_new(); if (s->enc_write_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_write_ctx; iv = s->write_iv; RECORD_LAYER_reset_write_sequence(&s->rlayer); } if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE)) || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) { if (which & SSL3_CC_EARLY) { EVP_MD_CTX *mdctx = NULL; long handlen; void *hdata; unsigned int hashlenui; const SSL_CIPHER *sslcipher = SSL_SESSION_get0_cipher(s->session); insecret = s->early_secret; label = client_early_traffic; labellen = sizeof(client_early_traffic) - 1; log_label = CLIENT_EARLY_LABEL; handlen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (handlen <= 0) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, SSL_R_BAD_HANDSHAKE_LENGTH); goto err; } if (sslcipher == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } mdctx = EVP_MD_CTX_new(); if (mdctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } cipher = EVP_get_cipherbynid(SSL_CIPHER_get_cipher_nid(sslcipher)); md = ssl_md(sslcipher->algorithm2); if (md == NULL || !EVP_DigestInit_ex(mdctx, md, NULL) || !EVP_DigestUpdate(mdctx, hdata, handlen) || !EVP_DigestFinal_ex(mdctx, hashval, &hashlenui)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); EVP_MD_CTX_free(mdctx); goto err; } hashlen = hashlenui; EVP_MD_CTX_free(mdctx); } else if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->client_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = client_handshake_traffic; labellen = sizeof(client_handshake_traffic) - 1; log_label = CLIENT_HANDSHAKE_LABEL; hash = s->handshake_traffic_hash; } else { insecret = s->master_secret; label = client_application_traffic; labellen = sizeof(client_application_traffic) - 1; log_label = CLIENT_APPLICATION_LABEL; hash = s->server_finished_hash; } } else { if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->server_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = server_handshake_traffic; labellen = sizeof(server_handshake_traffic) - 1; log_label = SERVER_HANDSHAKE_LABEL; } else { insecret = s->master_secret; label = server_application_traffic; labellen = sizeof(server_application_traffic) - 1; log_label = SERVER_APPLICATION_LABEL; } } if (!(which & SSL3_CC_EARLY)) { md = ssl_handshake_md(s); cipher = s->s3->tmp.new_sym_enc; if (!ssl3_digest_cached_records(s, 1) || !ssl_handshake_hash(s, hashval, sizeof(hashval), &hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } } if (label == server_application_traffic) memcpy(s->server_finished_hash, hashval, hashlen); if (label == server_handshake_traffic) memcpy(s->handshake_traffic_hash, hashval, hashlen); if (label == client_application_traffic) { if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret, resumption_master_secret, sizeof(resumption_master_secret) - 1, <S2SV_StartVul> hashval, s->session->master_key, hashlen)) { <S2SV_EndVul> SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } s->session->master_key_length = hashlen; if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret, exporter_master_secret, sizeof(exporter_master_secret) - 1, <S2SV_StartVul> hash, s->exporter_master_secret, hashlen)) { <S2SV_EndVul> SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } } if (!derive_secret_key_and_iv(s, which & SSL3_CC_WRITE, md, cipher, insecret, hash, label, labellen, secret, iv, ciph_ctx)) { goto err; } if (label == server_application_traffic) memcpy(s->server_app_traffic_secret, secret, hashlen); else if (label == client_application_traffic) memcpy(s->client_app_traffic_secret, secret, hashlen); if (!ssl_log_secret(s, log_label, secret, hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } if (finsecret != NULL && !tls13_derive_finishedkey(s, ssl_handshake_md(s), secret, finsecret, finsecretlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } ret = 1; err: OPENSSL_cleanse(secret, sizeof(secret)); return ret; }","- hashval, s->session->master_key, hashlen)) {
- hash, s->exporter_master_secret, hashlen)) {
+ hashval, hashlen, s->session->master_key,
+ hashlen)) {
+ hash, hashlen, s->exporter_master_secret,
+ hashlen)) {","int tls13_change_cipher_state(SSL *s, int which) { static const unsigned char client_early_traffic[] = ""c e traffic""; static const unsigned char client_handshake_traffic[] = ""c hs traffic""; static const unsigned char client_application_traffic[] = ""c ap traffic""; static const unsigned char server_handshake_traffic[] = ""s hs traffic""; static const unsigned char server_application_traffic[] = ""s ap traffic""; static const unsigned char exporter_master_secret[] = ""exp master""; static const unsigned char resumption_master_secret[] = ""res master""; unsigned char *iv; unsigned char secret[EVP_MAX_MD_SIZE]; unsigned char hashval[EVP_MAX_MD_SIZE]; unsigned char *hash = hashval; unsigned char *insecret; unsigned char *finsecret = NULL; const char *log_label = NULL; EVP_CIPHER_CTX *ciph_ctx; size_t finsecretlen = 0; const unsigned char *label; size_t labellen, hashlen = 0; int ret = 0; const EVP_MD *md = NULL; const EVP_CIPHER *cipher = NULL; if (which & SSL3_CC_READ) { if (s->enc_read_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_read_ctx); } else { s->enc_read_ctx = EVP_CIPHER_CTX_new(); if (s->enc_read_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_read_ctx; iv = s->read_iv; RECORD_LAYER_reset_read_sequence(&s->rlayer); } else { if (s->enc_write_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_write_ctx); } else { s->enc_write_ctx = EVP_CIPHER_CTX_new(); if (s->enc_write_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_write_ctx; iv = s->write_iv; RECORD_LAYER_reset_write_sequence(&s->rlayer); } if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE)) || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) { if (which & SSL3_CC_EARLY) { EVP_MD_CTX *mdctx = NULL; long handlen; void *hdata; unsigned int hashlenui; const SSL_CIPHER *sslcipher = SSL_SESSION_get0_cipher(s->session); insecret = s->early_secret; label = client_early_traffic; labellen = sizeof(client_early_traffic) - 1; log_label = CLIENT_EARLY_LABEL; handlen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (handlen <= 0) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, SSL_R_BAD_HANDSHAKE_LENGTH); goto err; } if (sslcipher == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } mdctx = EVP_MD_CTX_new(); if (mdctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } cipher = EVP_get_cipherbynid(SSL_CIPHER_get_cipher_nid(sslcipher)); md = ssl_md(sslcipher->algorithm2); if (md == NULL || !EVP_DigestInit_ex(mdctx, md, NULL) || !EVP_DigestUpdate(mdctx, hdata, handlen) || !EVP_DigestFinal_ex(mdctx, hashval, &hashlenui)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); EVP_MD_CTX_free(mdctx); goto err; } hashlen = hashlenui; EVP_MD_CTX_free(mdctx); } else if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->client_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = client_handshake_traffic; labellen = sizeof(client_handshake_traffic) - 1; log_label = CLIENT_HANDSHAKE_LABEL; hash = s->handshake_traffic_hash; } else { insecret = s->master_secret; label = client_application_traffic; labellen = sizeof(client_application_traffic) - 1; log_label = CLIENT_APPLICATION_LABEL; hash = s->server_finished_hash; } } else { if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->server_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = server_handshake_traffic; labellen = sizeof(server_handshake_traffic) - 1; log_label = SERVER_HANDSHAKE_LABEL; } else { insecret = s->master_secret; label = server_application_traffic; labellen = sizeof(server_application_traffic) - 1; log_label = SERVER_APPLICATION_LABEL; } } if (!(which & SSL3_CC_EARLY)) { md = ssl_handshake_md(s); cipher = s->s3->tmp.new_sym_enc; if (!ssl3_digest_cached_records(s, 1) || !ssl_handshake_hash(s, hashval, sizeof(hashval), &hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } } if (label == server_application_traffic) memcpy(s->server_finished_hash, hashval, hashlen); if (label == server_handshake_traffic) memcpy(s->handshake_traffic_hash, hashval, hashlen); if (label == client_application_traffic) { if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret, resumption_master_secret, sizeof(resumption_master_secret) - 1, hashval, hashlen, s->session->master_key, hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } s->session->master_key_length = hashlen; if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret, exporter_master_secret, sizeof(exporter_master_secret) - 1, hash, hashlen, s->exporter_master_secret, hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } } if (!derive_secret_key_and_iv(s, which & SSL3_CC_WRITE, md, cipher, insecret, hash, label, labellen, secret, iv, ciph_ctx)) { goto err; } if (label == server_application_traffic) memcpy(s->server_app_traffic_secret, secret, hashlen); else if (label == client_application_traffic) memcpy(s->client_app_traffic_secret, secret, hashlen); if (!ssl_log_secret(s, log_label, secret, hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } if (finsecret != NULL && !tls13_derive_finishedkey(s, ssl_handshake_md(s), secret, finsecret, finsecretlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } ret = 1; err: OPENSSL_cleanse(secret, sizeof(secret)); return ret; }"
16105----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_cc924d47001675f60463a5c028dc92d06bc9b639_1.json----RECORD_LAYER_clear,"void RECORD_LAYER_clear(RECORD_LAYER *rl) { <S2SV_StartVul> unsigned int pipes; <S2SV_EndVul> rl->rstate = SSL_ST_READ_HEADER; rl->packet = NULL; rl->packet_length = 0; rl->wnum = 0; memset(rl->alert_fragment, 0, sizeof(rl->alert_fragment)); rl->alert_fragment_len = 0; memset(rl->handshake_fragment, 0, sizeof(rl->handshake_fragment)); rl->handshake_fragment_len = 0; rl->wpend_tot = 0; rl->wpend_type = 0; rl->wpend_ret = 0; rl->wpend_buf = NULL; SSL3_BUFFER_clear(&rl->rbuf); <S2SV_StartVul> for (pipes = 0; pipes < rl->numwpipes; pipes++) <S2SV_EndVul> <S2SV_StartVul> SSL3_BUFFER_clear(&rl->wbuf[pipes]); <S2SV_EndVul> <S2SV_StartVul> rl->numwpipes = 0; <S2SV_EndVul> rl->numrpipes = 0; SSL3_RECORD_clear(rl->rrec, SSL_MAX_PIPELINES); RECORD_LAYER_reset_read_sequence(rl); RECORD_LAYER_reset_write_sequence(rl); if (rl->d) DTLS_RECORD_LAYER_clear(rl); }","- unsigned int pipes;
- for (pipes = 0; pipes < rl->numwpipes; pipes++)
- SSL3_BUFFER_clear(&rl->wbuf[pipes]);
- rl->numwpipes = 0;
+ ssl3_release_write_buffer(rl->s);","void RECORD_LAYER_clear(RECORD_LAYER *rl) { rl->rstate = SSL_ST_READ_HEADER; rl->packet = NULL; rl->packet_length = 0; rl->wnum = 0; memset(rl->alert_fragment, 0, sizeof(rl->alert_fragment)); rl->alert_fragment_len = 0; memset(rl->handshake_fragment, 0, sizeof(rl->handshake_fragment)); rl->handshake_fragment_len = 0; rl->wpend_tot = 0; rl->wpend_type = 0; rl->wpend_ret = 0; rl->wpend_buf = NULL; SSL3_BUFFER_clear(&rl->rbuf); ssl3_release_write_buffer(rl->s); rl->numrpipes = 0; SSL3_RECORD_clear(rl->rrec, SSL_MAX_PIPELINES); RECORD_LAYER_reset_read_sequence(rl); RECORD_LAYER_reset_write_sequence(rl); if (rl->d) DTLS_RECORD_LAYER_clear(rl); }"
11574----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_1.json----dh_main,"int MAIN(int argc, char **argv) { DH *dh=NULL; int i,badops=0,text=0; BIO *in=NULL,*out=NULL; int informat,outformat,check=0,noout=0,C=0,ret=1; <S2SV_StartVul> char *infile,*outfile,*prog; <S2SV_EndVul> apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-check"") == 0) check=1; else if (strcmp(*argv,""-text"") == 0) text=1; else if (strcmp(*argv,""-C"") == 0) C=1; else if (strcmp(*argv,""-noout"") == 0) noout=1; else { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - one of DER PEM\n""); BIO_printf(bio_err,"" -outform arg output format - one of DER PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -check check the DH parameters\n""); BIO_printf(bio_err,"" -text print a text form of the DH parameters\n""); BIO_printf(bio_err,"" -C Output C code\n""); BIO_printf(bio_err,"" -noout no output\n""); goto end; } ERR_load_crypto_strings(); in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) { perror(infile); goto end; } } if (outfile == NULL) { BIO_set_fp(out,stdout,BIO_NOCLOSE); #ifdef VMS { BIO *tmpbio = BIO_new(BIO_f_linebuffer()); out = BIO_push(tmpbio, out); } #endif } else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (informat == FORMAT_ASN1) dh=d2i_DHparams_bio(in,NULL); else if (informat == FORMAT_PEM) dh=PEM_read_bio_DHparams(in,NULL,NULL,NULL); else { BIO_printf(bio_err,""bad input format specified\n""); goto end; } if (dh == NULL) { BIO_printf(bio_err,""unable to load DH parameters\n""); ERR_print_errors(bio_err); goto end; } if (text) { DHparams_print(out,dh); #ifdef undef printf(""p=""); BN_print(stdout,dh->p); printf(""\ng=""); BN_print(stdout,dh->g); printf(""\n""); if (dh->length != 0) printf(""recommended private length=%ld\n"",dh->length); #endif } if (check) { if (!DH_check(dh,&i)) { ERR_print_errors(bio_err); goto end; } if (i & DH_CHECK_P_NOT_PRIME) printf(""p value is not prime\n""); if (i & DH_CHECK_P_NOT_SAFE_PRIME) printf(""p value is not a safe prime\n""); if (i & DH_UNABLE_TO_CHECK_GENERATOR) printf(""unable to check the generator value\n""); if (i & DH_NOT_SUITABLE_GENERATOR) printf(""the g value is not a generator\n""); if (i == 0) printf(""DH parameters appear to be ok.\n""); } if (C) { unsigned char *data; int len,l,bits; len=BN_num_bytes(dh->p); bits=BN_num_bits(dh->p); data=(unsigned char *)OPENSSL_malloc(len); if (data == NULL) { perror(""OPENSSL_malloc""); goto end; } l=BN_bn2bin(dh->p,data); printf(""static unsigned char dh%d_p[]={"",bits); for (i=0; i<l; i++) { if ((i%12) == 0) printf(""\n\t""); printf(""0x%02X,"",data[i]); } printf(""\n\t};\n""); l=BN_bn2bin(dh->g,data); printf(""static unsigned char dh%d_g[]={"",bits); for (i=0; i<l; i++) { if ((i%12) == 0) printf(""\n\t""); printf(""0x%02X,"",data[i]); } printf(""\n\t};\n\n""); printf(""DH *get_dh%d()\n\t{\n"",bits); printf(""\tDH *dh;\n\n""); printf(""\tif ((dh=DH_new()) == NULL) return(NULL);\n""); printf(""\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\n"", bits,bits); printf(""\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\n"", bits,bits); printf(""\tif ((dh->p == NULL) || (dh->g == NULL))\n""); printf(""\t\treturn(NULL);\n""); printf(""\treturn(dh);\n\t}\n""); OPENSSL_free(data); } if (!noout) { if (outformat == FORMAT_ASN1) i=i2d_DHparams_bio(out,dh); else if (outformat == FORMAT_PEM) i=PEM_write_bio_DHparams(out,dh); else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write DH parameters\n""); ERR_print_errors(bio_err); goto end; } } ret=0; end: if (in != NULL) BIO_free(in); if (out != NULL) BIO_free_all(out); if (dh != NULL) DH_free(dh); EXIT(ret); }","- char *infile,*outfile,*prog;
+ ENGINE *e = NULL;
+ char *infile,*outfile,*prog,*engine;
+ engine=NULL;
+ else if (strcmp(*argv,""-engine"") == 0)
+ {
+ if (--argc < 1) goto bad;
+ engine= *(++argv);
+ }
+ BIO_printf(bio_err,"" -engine e use engine e, possibly a hardware device.\n"");
+ if (engine != NULL)
+ {
+ if((e = ENGINE_by_id(engine)) == NULL)
+ {
+ BIO_printf(bio_err,""invalid engine \""%s\""\n"",
+ engine);
+ goto end;
+ }
+ if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
+ {
+ BIO_printf(bio_err,""can't use that engine\n"");
+ goto end;
+ }
+ BIO_printf(bio_err,""engine \""%s\"" set.\n"", engine);
+ ENGINE_free(e);
+ }","int MAIN(int argc, char **argv) { ENGINE *e = NULL; DH *dh=NULL; int i,badops=0,text=0; BIO *in=NULL,*out=NULL; int informat,outformat,check=0,noout=0,C=0,ret=1; char *infile,*outfile,*prog,*engine; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); engine=NULL; infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-engine"") == 0) { if (--argc < 1) goto bad; engine= *(++argv); } else if (strcmp(*argv,""-check"") == 0) check=1; else if (strcmp(*argv,""-text"") == 0) text=1; else if (strcmp(*argv,""-C"") == 0) C=1; else if (strcmp(*argv,""-noout"") == 0) noout=1; else { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - one of DER PEM\n""); BIO_printf(bio_err,"" -outform arg output format - one of DER PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -check check the DH parameters\n""); BIO_printf(bio_err,"" -text print a text form of the DH parameters\n""); BIO_printf(bio_err,"" -C Output C code\n""); BIO_printf(bio_err,"" -noout no output\n""); BIO_printf(bio_err,"" -engine e use engine e, possibly a hardware device.\n""); goto end; } ERR_load_crypto_strings(); if (engine != NULL) { if((e = ENGINE_by_id(engine)) == NULL) { BIO_printf(bio_err,""invalid engine \""%s\""\n"", engine); goto end; } if(!ENGINE_set_default(e, ENGINE_METHOD_ALL)) { BIO_printf(bio_err,""can't use that engine\n""); goto end; } BIO_printf(bio_err,""engine \""%s\"" set.\n"", engine); ENGINE_free(e); } in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) { perror(infile); goto end; } } if (outfile == NULL) { BIO_set_fp(out,stdout,BIO_NOCLOSE); #ifdef VMS { BIO *tmpbio = BIO_new(BIO_f_linebuffer()); out = BIO_push(tmpbio, out); } #endif } else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (informat == FORMAT_ASN1) dh=d2i_DHparams_bio(in,NULL); else if (informat == FORMAT_PEM) dh=PEM_read_bio_DHparams(in,NULL,NULL,NULL); else { BIO_printf(bio_err,""bad input format specified\n""); goto end; } if (dh == NULL) { BIO_printf(bio_err,""unable to load DH parameters\n""); ERR_print_errors(bio_err); goto end; } if (text) { DHparams_print(out,dh); #ifdef undef printf(""p=""); BN_print(stdout,dh->p); printf(""\ng=""); BN_print(stdout,dh->g); printf(""\n""); if (dh->length != 0) printf(""recommended private length=%ld\n"",dh->length); #endif } if (check) { if (!DH_check(dh,&i)) { ERR_print_errors(bio_err); goto end; } if (i & DH_CHECK_P_NOT_PRIME) printf(""p value is not prime\n""); if (i & DH_CHECK_P_NOT_SAFE_PRIME) printf(""p value is not a safe prime\n""); if (i & DH_UNABLE_TO_CHECK_GENERATOR) printf(""unable to check the generator value\n""); if (i & DH_NOT_SUITABLE_GENERATOR) printf(""the g value is not a generator\n""); if (i == 0) printf(""DH parameters appear to be ok.\n""); } if (C) { unsigned char *data; int len,l,bits; len=BN_num_bytes(dh->p); bits=BN_num_bits(dh->p); data=(unsigned char *)OPENSSL_malloc(len); if (data == NULL) { perror(""OPENSSL_malloc""); goto end; } l=BN_bn2bin(dh->p,data); printf(""static unsigned char dh%d_p[]={"",bits); for (i=0; i<l; i++) { if ((i%12) == 0) printf(""\n\t""); printf(""0x%02X,"",data[i]); } printf(""\n\t};\n""); l=BN_bn2bin(dh->g,data); printf(""static unsigned char dh%d_g[]={"",bits); for (i=0; i<l; i++) { if ((i%12) == 0) printf(""\n\t""); printf(""0x%02X,"",data[i]); } printf(""\n\t};\n\n""); printf(""DH *get_dh%d()\n\t{\n"",bits); printf(""\tDH *dh;\n\n""); printf(""\tif ((dh=DH_new()) == NULL) return(NULL);\n""); printf(""\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\n"", bits,bits); printf(""\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\n"", bits,bits); printf(""\tif ((dh->p == NULL) || (dh->g == NULL))\n""); printf(""\t\treturn(NULL);\n""); printf(""\treturn(dh);\n\t}\n""); OPENSSL_free(data); } if (!noout) { if (outformat == FORMAT_ASN1) i=i2d_DHparams_bio(out,dh); else if (outformat == FORMAT_PEM) i=PEM_write_bio_DHparams(out,dh); else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write DH parameters\n""); ERR_print_errors(bio_err); goto end; } } ret=0; end: if (in != NULL) BIO_free(in); if (out != NULL) BIO_free_all(out); if (dh != NULL) DH_free(dh); EXIT(ret); }"
6373----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5554557039ad9bee0d2960b94281a2380cf2c734_1.json----read_sbr_extension,"static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr, GetBitContext *gb, int bs_extension_id, int *num_bits_left) { switch (bs_extension_id) { case EXTENSION_ID_PS: <S2SV_StartVul> if (!ac->m4ac.ps) { <S2SV_EndVul> av_log(ac->avctx, AV_LOG_ERROR, ""Parametric Stereo signaled to be not-present but was found in the bitstream.\n""); skip_bits_long(gb, *num_bits_left); *num_bits_left = 0; } else { #if 1 *num_bits_left -= ff_ps_read_data(ac->avctx, gb, &sbr->ps, *num_bits_left); #else av_log_missing_feature(ac->avctx, ""Parametric Stereo is"", 0); skip_bits_long(gb, *num_bits_left); *num_bits_left = 0; #endif } break; default: av_log_missing_feature(ac->avctx, ""Reserved SBR extensions are"", 1); skip_bits_long(gb, *num_bits_left); *num_bits_left = 0; break; } }","- if (!ac->m4ac.ps) {
+ if (!ac->oc[1].m4ac.ps) {","static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr, GetBitContext *gb, int bs_extension_id, int *num_bits_left) { switch (bs_extension_id) { case EXTENSION_ID_PS: if (!ac->oc[1].m4ac.ps) { av_log(ac->avctx, AV_LOG_ERROR, ""Parametric Stereo signaled to be not-present but was found in the bitstream.\n""); skip_bits_long(gb, *num_bits_left); *num_bits_left = 0; } else { #if 1 *num_bits_left -= ff_ps_read_data(ac->avctx, gb, &sbr->ps, *num_bits_left); #else av_log_missing_feature(ac->avctx, ""Parametric Stereo is"", 0); skip_bits_long(gb, *num_bits_left); *num_bits_left = 0; #endif } break; default: av_log_missing_feature(ac->avctx, ""Reserved SBR extensions are"", 1); skip_bits_long(gb, *num_bits_left); *num_bits_left = 0; break; } }"
16597----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_dd0f4c6cf3a74118c9bf29ca5aa25d3381de2ca4_1.json----v2i_IPAddrBlocks,"static void *v2i_IPAddrBlocks(const struct v3_ext_method *method, struct v3_ext_ctx *ctx, STACK_OF(CONF_VALUE) *values) { static const char v4addr_chars[] = ""0123456789.""; static const char v6addr_chars[] = ""0123456789.:abcdefABCDEF""; IPAddrBlocks *addr = NULL; char *s = NULL, *t; int i; if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); return NULL; } for (i = 0; i < sk_CONF_VALUE_num(values); i++) { CONF_VALUE *val = sk_CONF_VALUE_value(values, i); unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN]; unsigned afi, *safi = NULL, safi_; const char *addr_chars = NULL; int prefixlen, i1, i2, delim, length; if (!name_cmp(val->name, ""IPv4"")) { afi = IANA_AFI_IPV4; } else if (!name_cmp(val->name, ""IPv6"")) { afi = IANA_AFI_IPV6; } else if (!name_cmp(val->name, ""IPv4-SAFI"")) { afi = IANA_AFI_IPV4; safi = &safi_; } else if (!name_cmp(val->name, ""IPv6-SAFI"")) { afi = IANA_AFI_IPV6; safi = &safi_; } else { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_NAME_ERROR); X509V3_conf_err(val); goto err; } switch (afi) { case IANA_AFI_IPV4: addr_chars = v4addr_chars; break; case IANA_AFI_IPV6: addr_chars = v6addr_chars; break; } length = length_from_afi(afi); if (safi != NULL) { *safi = strtoul(val->value, &t, 0); t += strspn(t, "" \t""); if (*safi > 0xFF || *t++ != ':') { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI); X509V3_conf_err(val); goto err; } t += strspn(t, "" \t""); <S2SV_StartVul> s = BUF_strdup(t); <S2SV_EndVul> } else { <S2SV_StartVul> s = BUF_strdup(val->value); <S2SV_EndVul> } if (s == NULL) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } if (strcmp(s, ""inherit"") == 0) { if (!v3_addr_add_inherit(addr, afi, safi)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_INHERITANCE); X509V3_conf_err(val); goto err; } OPENSSL_free(s); s = NULL; continue; } i1 = strspn(s, addr_chars); i2 = i1 + strspn(s + i1, "" \t""); delim = s[i2++]; s[i1] = '\0'; if (a2i_ipadd(min, s) != length) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS); X509V3_conf_err(val); goto err; } switch (delim) { case '/': prefixlen = (int)strtoul(s + i2, &t, 10); if (t == s + i2 || *t != '\0') { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } if (!v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } break; case '-': i1 = i2 + strspn(s + i2, "" \t""); i2 = i1 + strspn(s + i1, addr_chars); if (i1 == i2 || s[i2] != '\0') { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } if (a2i_ipadd(max, s + i1) != length) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS); X509V3_conf_err(val); goto err; } if (memcmp(min, max, length_from_afi(afi)) > 0) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } if (!v3_addr_add_range(addr, afi, safi, min, max)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } break; case '\0': if (!v3_addr_add_prefix(addr, afi, safi, min, length * 8)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } break; default: X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } OPENSSL_free(s); s = NULL; } if (!v3_addr_canonize(addr)) goto err; return addr; err: OPENSSL_free(s); sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free); return NULL; }","- s = BUF_strdup(t);
- s = BUF_strdup(val->value);
+ s = OPENSSL_strdup(t);
+ s = OPENSSL_strdup(val->value);","static void *v2i_IPAddrBlocks(const struct v3_ext_method *method, struct v3_ext_ctx *ctx, STACK_OF(CONF_VALUE) *values) { static const char v4addr_chars[] = ""0123456789.""; static const char v6addr_chars[] = ""0123456789.:abcdefABCDEF""; IPAddrBlocks *addr = NULL; char *s = NULL, *t; int i; if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); return NULL; } for (i = 0; i < sk_CONF_VALUE_num(values); i++) { CONF_VALUE *val = sk_CONF_VALUE_value(values, i); unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN]; unsigned afi, *safi = NULL, safi_; const char *addr_chars = NULL; int prefixlen, i1, i2, delim, length; if (!name_cmp(val->name, ""IPv4"")) { afi = IANA_AFI_IPV4; } else if (!name_cmp(val->name, ""IPv6"")) { afi = IANA_AFI_IPV6; } else if (!name_cmp(val->name, ""IPv4-SAFI"")) { afi = IANA_AFI_IPV4; safi = &safi_; } else if (!name_cmp(val->name, ""IPv6-SAFI"")) { afi = IANA_AFI_IPV6; safi = &safi_; } else { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_NAME_ERROR); X509V3_conf_err(val); goto err; } switch (afi) { case IANA_AFI_IPV4: addr_chars = v4addr_chars; break; case IANA_AFI_IPV6: addr_chars = v6addr_chars; break; } length = length_from_afi(afi); if (safi != NULL) { *safi = strtoul(val->value, &t, 0); t += strspn(t, "" \t""); if (*safi > 0xFF || *t++ != ':') { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI); X509V3_conf_err(val); goto err; } t += strspn(t, "" \t""); s = OPENSSL_strdup(t); } else { s = OPENSSL_strdup(val->value); } if (s == NULL) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } if (strcmp(s, ""inherit"") == 0) { if (!v3_addr_add_inherit(addr, afi, safi)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_INHERITANCE); X509V3_conf_err(val); goto err; } OPENSSL_free(s); s = NULL; continue; } i1 = strspn(s, addr_chars); i2 = i1 + strspn(s + i1, "" \t""); delim = s[i2++]; s[i1] = '\0'; if (a2i_ipadd(min, s) != length) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS); X509V3_conf_err(val); goto err; } switch (delim) { case '/': prefixlen = (int)strtoul(s + i2, &t, 10); if (t == s + i2 || *t != '\0') { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } if (!v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } break; case '-': i1 = i2 + strspn(s + i2, "" \t""); i2 = i1 + strspn(s + i1, addr_chars); if (i1 == i2 || s[i2] != '\0') { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } if (a2i_ipadd(max, s + i1) != length) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS); X509V3_conf_err(val); goto err; } if (memcmp(min, max, length_from_afi(afi)) > 0) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } if (!v3_addr_add_range(addr, afi, safi, min, max)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } break; case '\0': if (!v3_addr_add_prefix(addr, afi, safi, min, length * 8)) { X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE); goto err; } break; default: X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_EXTENSION_VALUE_ERROR); X509V3_conf_err(val); goto err; } OPENSSL_free(s); s = NULL; } if (!v3_addr_canonize(addr)) goto err; return addr; err: OPENSSL_free(s); sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free); return NULL; }"
5299----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_13d8eb80257c7c69c45016a685163b48b587b9ed_1.json----mov_write_mdia_tag,"<S2SV_StartVul> static int mov_write_mdia_tag(AVIOContext *pb, MOVMuxContext *mov, <S2SV_EndVul> <S2SV_StartVul> MOVTrack *track) <S2SV_EndVul> { int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, ""mdia""); mov_write_mdhd_tag(pb, mov, track); <S2SV_StartVul> mov_write_hdlr_tag(pb, track); <S2SV_EndVul> <S2SV_StartVul> mov_write_minf_tag(pb, track); <S2SV_EndVul> return update_size(pb, pos); }","- static int mov_write_mdia_tag(AVIOContext *pb, MOVMuxContext *mov,
- MOVTrack *track)
- mov_write_hdlr_tag(pb, track);
- mov_write_minf_tag(pb, track);
+ static int mov_write_mdia_tag(AVFormatContext *s, AVIOContext *pb,
+ MOVMuxContext *mov, MOVTrack *track)
+ mov_write_hdlr_tag(s, pb, track);
+ mov_write_minf_tag(s, pb, track);","static int mov_write_mdia_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track) { int64_t pos = avio_tell(pb); avio_wb32(pb, 0); ffio_wfourcc(pb, ""mdia""); mov_write_mdhd_tag(pb, mov, track); mov_write_hdlr_tag(s, pb, track); mov_write_minf_tag(s, pb, track); return update_size(pb, pos); }"
5552----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_23faa44b6df1acfa5b3e8b04b5ac725cd86798d9_1.json----encode_residual_ch,"static int encode_residual_ch(FlacEncodeContext *s, int ch) { int i, n; int min_order, max_order, opt_order, omethod; FlacFrame *frame; FlacSubframe *sub; int32_t coefs[MAX_LPC_ORDER][MAX_LPC_ORDER]; int shift[MAX_LPC_ORDER]; int32_t *res, *smp; frame = &s->frame; sub = &frame->subframes[ch]; res = sub->residual; smp = sub->samples; n = frame->blocksize; for (i = 1; i < n; i++) if(smp[i] != smp[0]) break; if (i == n) { sub->type = sub->type_code = FLAC_SUBFRAME_CONSTANT; res[0] = smp[0]; return subframe_count_exact(s, sub, 0); } if (frame->verbatim_only || n < 5) { sub->type = sub->type_code = FLAC_SUBFRAME_VERBATIM; memcpy(res, smp, n * sizeof(int32_t)); return subframe_count_exact(s, sub, 0); } min_order = s->options.min_prediction_order; max_order = s->options.max_prediction_order; omethod = s->options.prediction_order_method; sub->type = FLAC_SUBFRAME_FIXED; if (s->options.lpc_type == FF_LPC_TYPE_NONE || s->options.lpc_type == FF_LPC_TYPE_FIXED || n <= max_order) { <S2SV_StartVul> uint32_t bits[MAX_FIXED_ORDER+1]; <S2SV_EndVul> if (max_order > MAX_FIXED_ORDER) max_order = MAX_FIXED_ORDER; opt_order = 0; bits[0] = UINT32_MAX; for (i = min_order; i <= max_order; i++) { encode_residual_fixed(res, smp, n, i); bits[i] = find_subframe_rice_params(s, sub, i); if (bits[i] < bits[opt_order]) opt_order = i; } sub->order = opt_order; sub->type_code = sub->type | sub->order; if (sub->order != max_order) { encode_residual_fixed(res, smp, n, sub->order); find_subframe_rice_params(s, sub, sub->order); } return subframe_count_exact(s, sub, sub->order); } sub->type = FLAC_SUBFRAME_LPC; opt_order = ff_lpc_calc_coefs(&s->lpc_ctx, smp, n, min_order, max_order, s->options.lpc_coeff_precision, coefs, shift, s->options.lpc_type, s->options.lpc_passes, omethod, MAX_LPC_SHIFT, 0); if (omethod == ORDER_METHOD_2LEVEL || omethod == ORDER_METHOD_4LEVEL || omethod == ORDER_METHOD_8LEVEL) { int levels = 1 << omethod; <S2SV_StartVul> uint32_t bits[1 << ORDER_METHOD_8LEVEL]; <S2SV_EndVul> int order; int opt_index = levels-1; opt_order = max_order-1; bits[opt_index] = UINT32_MAX; for (i = levels-1; i >= 0; i--) { order = min_order + (((max_order-min_order+1) * (i+1)) / levels)-1; if (order < 0) order = 0; encode_residual_lpc(res, smp, n, order+1, coefs[order], shift[order]); bits[i] = find_subframe_rice_params(s, sub, order+1); if (bits[i] < bits[opt_index]) { opt_index = i; opt_order = order; } } opt_order++; } else if (omethod == ORDER_METHOD_SEARCH) { <S2SV_StartVul> uint32_t bits[MAX_LPC_ORDER]; <S2SV_EndVul> opt_order = 0; bits[0] = UINT32_MAX; for (i = min_order-1; i < max_order; i++) { encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]); bits[i] = find_subframe_rice_params(s, sub, i+1); if (bits[i] < bits[opt_order]) opt_order = i; } opt_order++; } else if (omethod == ORDER_METHOD_LOG) { <S2SV_StartVul> uint32_t bits[MAX_LPC_ORDER]; <S2SV_EndVul> int step; opt_order = min_order - 1 + (max_order-min_order)/3; memset(bits, -1, sizeof(bits)); for (step = 16; step; step >>= 1) { int last = opt_order; for (i = last-step; i <= last+step; i += step) { if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX) continue; encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]); bits[i] = find_subframe_rice_params(s, sub, i+1); if (bits[i] < bits[opt_order]) opt_order = i; } } opt_order++; } sub->order = opt_order; sub->type_code = sub->type | (sub->order-1); sub->shift = shift[sub->order-1]; for (i = 0; i < sub->order; i++) sub->coefs[i] = coefs[sub->order-1][i]; encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift); find_subframe_rice_params(s, sub, sub->order); return subframe_count_exact(s, sub, sub->order); }","- uint32_t bits[MAX_FIXED_ORDER+1];
- uint32_t bits[1 << ORDER_METHOD_8LEVEL];
- uint32_t bits[MAX_LPC_ORDER];
- uint32_t bits[MAX_LPC_ORDER];
+ uint64_t bits[MAX_FIXED_ORDER+1];
+ uint64_t bits[1 << ORDER_METHOD_8LEVEL];
+ uint64_t bits[MAX_LPC_ORDER];
+ uint64_t bits[MAX_LPC_ORDER];","static int encode_residual_ch(FlacEncodeContext *s, int ch) { int i, n; int min_order, max_order, opt_order, omethod; FlacFrame *frame; FlacSubframe *sub; int32_t coefs[MAX_LPC_ORDER][MAX_LPC_ORDER]; int shift[MAX_LPC_ORDER]; int32_t *res, *smp; frame = &s->frame; sub = &frame->subframes[ch]; res = sub->residual; smp = sub->samples; n = frame->blocksize; for (i = 1; i < n; i++) if(smp[i] != smp[0]) break; if (i == n) { sub->type = sub->type_code = FLAC_SUBFRAME_CONSTANT; res[0] = smp[0]; return subframe_count_exact(s, sub, 0); } if (frame->verbatim_only || n < 5) { sub->type = sub->type_code = FLAC_SUBFRAME_VERBATIM; memcpy(res, smp, n * sizeof(int32_t)); return subframe_count_exact(s, sub, 0); } min_order = s->options.min_prediction_order; max_order = s->options.max_prediction_order; omethod = s->options.prediction_order_method; sub->type = FLAC_SUBFRAME_FIXED; if (s->options.lpc_type == FF_LPC_TYPE_NONE || s->options.lpc_type == FF_LPC_TYPE_FIXED || n <= max_order) { uint64_t bits[MAX_FIXED_ORDER+1]; if (max_order > MAX_FIXED_ORDER) max_order = MAX_FIXED_ORDER; opt_order = 0; bits[0] = UINT32_MAX; for (i = min_order; i <= max_order; i++) { encode_residual_fixed(res, smp, n, i); bits[i] = find_subframe_rice_params(s, sub, i); if (bits[i] < bits[opt_order]) opt_order = i; } sub->order = opt_order; sub->type_code = sub->type | sub->order; if (sub->order != max_order) { encode_residual_fixed(res, smp, n, sub->order); find_subframe_rice_params(s, sub, sub->order); } return subframe_count_exact(s, sub, sub->order); } sub->type = FLAC_SUBFRAME_LPC; opt_order = ff_lpc_calc_coefs(&s->lpc_ctx, smp, n, min_order, max_order, s->options.lpc_coeff_precision, coefs, shift, s->options.lpc_type, s->options.lpc_passes, omethod, MAX_LPC_SHIFT, 0); if (omethod == ORDER_METHOD_2LEVEL || omethod == ORDER_METHOD_4LEVEL || omethod == ORDER_METHOD_8LEVEL) { int levels = 1 << omethod; uint64_t bits[1 << ORDER_METHOD_8LEVEL]; int order; int opt_index = levels-1; opt_order = max_order-1; bits[opt_index] = UINT32_MAX; for (i = levels-1; i >= 0; i--) { order = min_order + (((max_order-min_order+1) * (i+1)) / levels)-1; if (order < 0) order = 0; encode_residual_lpc(res, smp, n, order+1, coefs[order], shift[order]); bits[i] = find_subframe_rice_params(s, sub, order+1); if (bits[i] < bits[opt_index]) { opt_index = i; opt_order = order; } } opt_order++; } else if (omethod == ORDER_METHOD_SEARCH) { uint64_t bits[MAX_LPC_ORDER]; opt_order = 0; bits[0] = UINT32_MAX; for (i = min_order-1; i < max_order; i++) { encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]); bits[i] = find_subframe_rice_params(s, sub, i+1); if (bits[i] < bits[opt_order]) opt_order = i; } opt_order++; } else if (omethod == ORDER_METHOD_LOG) { uint64_t bits[MAX_LPC_ORDER]; int step; opt_order = min_order - 1 + (max_order-min_order)/3; memset(bits, -1, sizeof(bits)); for (step = 16; step; step >>= 1) { int last = opt_order; for (i = last-step; i <= last+step; i += step) { if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX) continue; encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]); bits[i] = find_subframe_rice_params(s, sub, i+1); if (bits[i] < bits[opt_order]) opt_order = i; } } opt_order++; } sub->order = opt_order; sub->type_code = sub->type | (sub->order-1); sub->shift = shift[sub->order-1]; for (i = 0; i < sub->order; i++) sub->coefs[i] = coefs[sub->order-1][i]; encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift); find_subframe_rice_params(s, sub, sub->order); return subframe_count_exact(s, sub, sub->order); }"
8896----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_e993725add07887bcc0c8776f1db953994f95f2f_1.json----alac_set_info,"static int alac_set_info(ALACContext *alac) { const unsigned char *ptr = alac->avctx->extradata; ptr += 4; ptr += 4; ptr += 4; if(AV_RB32(ptr) >= UINT_MAX/4){ av_log(alac->avctx, AV_LOG_ERROR, ""setinfo_max_samples_per_frame too large\n""); return -1; } alac->setinfo_max_samples_per_frame = bytestream_get_be32(&ptr); ptr++; alac->setinfo_sample_size = *ptr++; alac->setinfo_rice_historymult = *ptr++; alac->setinfo_rice_initialhistory = *ptr++; alac->setinfo_rice_kmodifier = *ptr++; alac->numchannels = *ptr++; bytestream_get_be16(&ptr); bytestream_get_be32(&ptr); bytestream_get_be32(&ptr); bytestream_get_be32(&ptr); <S2SV_StartVul> allocate_buffers(alac); <S2SV_EndVul> return 0; }",- allocate_buffers(alac);,"static int alac_set_info(ALACContext *alac) { const unsigned char *ptr = alac->avctx->extradata; ptr += 4; ptr += 4; ptr += 4; if(AV_RB32(ptr) >= UINT_MAX/4){ av_log(alac->avctx, AV_LOG_ERROR, ""setinfo_max_samples_per_frame too large\n""); return -1; } alac->setinfo_max_samples_per_frame = bytestream_get_be32(&ptr); ptr++; alac->setinfo_sample_size = *ptr++; alac->setinfo_rice_historymult = *ptr++; alac->setinfo_rice_initialhistory = *ptr++; alac->setinfo_rice_kmodifier = *ptr++; alac->numchannels = *ptr++; bytestream_get_be16(&ptr); bytestream_get_be32(&ptr); bytestream_get_be32(&ptr); bytestream_get_be32(&ptr); return 0; }"
10992----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_198601e23f65e508d4e94718d9f05a8a731ef541_1.json----X509_STORE_CTX_cleanup,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx) { if (ctx->cleanup) ctx->cleanup(ctx); <S2SV_StartVul> X509_VERIFY_PARAM_free(ctx->param); <S2SV_EndVul> <S2SV_StartVul> if (ctx->tree) <S2SV_EndVul> X509_policy_tree_free(ctx->tree); if (ctx->chain != NULL) { sk_X509_pop_free(ctx->chain,X509_free); ctx->chain=NULL; } CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data)); memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA)); }","- X509_VERIFY_PARAM_free(ctx->param);
- if (ctx->tree)
+ if (ctx->param != NULL)
+ {
+ X509_VERIFY_PARAM_free(ctx->param);
+ ctx->param=NULL;
+ }
+ if (ctx->tree != NULL)
+ {
+ ctx->tree=NULL;
+ }","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx) { if (ctx->cleanup) ctx->cleanup(ctx); if (ctx->param != NULL) { X509_VERIFY_PARAM_free(ctx->param); ctx->param=NULL; } if (ctx->tree != NULL) { X509_policy_tree_free(ctx->tree); ctx->tree=NULL; } if (ctx->chain != NULL) { sk_X509_pop_free(ctx->chain,X509_free); ctx->chain=NULL; } CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data)); memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA)); }"
13948----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_80cd832b0c93aaf2b42b73ee4833fd1eadacdc26_1.json----test_secret,"static int test_secret(SSL *s, unsigned char *prk, const unsigned char *label, size_t labellen, const unsigned char *ref_secret, const unsigned char *ref_key, const unsigned char *ref_iv) { size_t hashsize; unsigned char gensecret[EVP_MAX_MD_SIZE]; unsigned char hash[EVP_MAX_MD_SIZE]; unsigned char key[KEYLEN]; unsigned char iv[IVLEN]; const EVP_MD *md = ssl_handshake_md(s); if (!ssl_handshake_hash(s, hash, sizeof(hash), &hashsize)) { TEST_error(""Failed to get hash""); return 0; } if (!tls13_hkdf_expand(s, md, prk, label, labellen, hash, hashsize, <S2SV_StartVul> gensecret, hashsize)) { <S2SV_EndVul> TEST_error(""Secret generation failed""); return 0; } if (!TEST_mem_eq(gensecret, hashsize, ref_secret, hashsize)) return 0; if (!tls13_derive_key(s, md, gensecret, key, KEYLEN)) { TEST_error(""Key generation failed""); return 0; } if (!TEST_mem_eq(key, KEYLEN, ref_key, KEYLEN)) return 0; if (!tls13_derive_iv(s, md, gensecret, iv, IVLEN)) { TEST_error(""IV generation failed""); return 0; } if (!TEST_mem_eq(iv, IVLEN, ref_iv, IVLEN)) return 0; return 1; }","- gensecret, hashsize)) {
+ gensecret, hashsize, 1)) {","static int test_secret(SSL *s, unsigned char *prk, const unsigned char *label, size_t labellen, const unsigned char *ref_secret, const unsigned char *ref_key, const unsigned char *ref_iv) { size_t hashsize; unsigned char gensecret[EVP_MAX_MD_SIZE]; unsigned char hash[EVP_MAX_MD_SIZE]; unsigned char key[KEYLEN]; unsigned char iv[IVLEN]; const EVP_MD *md = ssl_handshake_md(s); if (!ssl_handshake_hash(s, hash, sizeof(hash), &hashsize)) { TEST_error(""Failed to get hash""); return 0; } if (!tls13_hkdf_expand(s, md, prk, label, labellen, hash, hashsize, gensecret, hashsize, 1)) { TEST_error(""Secret generation failed""); return 0; } if (!TEST_mem_eq(gensecret, hashsize, ref_secret, hashsize)) return 0; if (!tls13_derive_key(s, md, gensecret, key, KEYLEN)) { TEST_error(""Key generation failed""); return 0; } if (!TEST_mem_eq(key, KEYLEN, ref_key, KEYLEN)) return 0; if (!tls13_derive_iv(s, md, gensecret, iv, IVLEN)) { TEST_error(""IV generation failed""); return 0; } if (!TEST_mem_eq(iv, IVLEN, ref_iv, IVLEN)) return 0; return 1; }"
15064----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a8c186d247ba40e2875c3751f1af259f05d66909_1.json----derive_secret_key_and_iv,"static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md, const EVP_CIPHER *ciph, const unsigned char *insecret, const unsigned char *hash, const unsigned char *label, size_t labellen, unsigned char *secret, unsigned char *iv, EVP_CIPHER_CTX *ciph_ctx) { unsigned char key[EVP_MAX_KEY_LENGTH]; size_t ivlen, keylen, taglen; int hashleni = EVP_MD_size(md); size_t hashlen; if (!ossl_assert(hashleni >= 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV, ERR_R_EVP_LIB); goto err; } hashlen = (size_t)hashleni; if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen, <S2SV_StartVul> secret, hashlen)) { <S2SV_EndVul> goto err; } keylen = EVP_CIPHER_key_length(ciph); if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) { uint32_t algenc; ivlen = EVP_CCM_TLS_IV_LEN; if (s->s3->tmp.new_cipher == NULL) { algenc = s->session->cipher->algorithm_enc; } else { algenc = s->s3->tmp.new_cipher->algorithm_enc; } if (algenc & (SSL_AES128CCM8 | SSL_AES256CCM8)) taglen = EVP_CCM8_TLS_TAG_LEN; else taglen = EVP_CCM_TLS_TAG_LEN; } else { ivlen = EVP_CIPHER_iv_length(ciph); taglen = 0; } if (!tls13_derive_key(s, md, secret, key, keylen) || !tls13_derive_iv(s, md, secret, iv, ivlen)) { goto err; } if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, NULL, NULL, sending) <= 0 || !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL) || (taglen != 0 && !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG, taglen, NULL)) || EVP_CipherInit_ex(ciph_ctx, NULL, NULL, key, NULL, -1) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV, ERR_R_EVP_LIB); goto err; } return 1; err: OPENSSL_cleanse(key, sizeof(key)); return 0; }","- secret, hashlen)) {
+ secret, hashlen, 1)) {","static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md, const EVP_CIPHER *ciph, const unsigned char *insecret, const unsigned char *hash, const unsigned char *label, size_t labellen, unsigned char *secret, unsigned char *iv, EVP_CIPHER_CTX *ciph_ctx) { unsigned char key[EVP_MAX_KEY_LENGTH]; size_t ivlen, keylen, taglen; int hashleni = EVP_MD_size(md); size_t hashlen; if (!ossl_assert(hashleni >= 0)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV, ERR_R_EVP_LIB); goto err; } hashlen = (size_t)hashleni; if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen, secret, hashlen, 1)) { goto err; } keylen = EVP_CIPHER_key_length(ciph); if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) { uint32_t algenc; ivlen = EVP_CCM_TLS_IV_LEN; if (s->s3->tmp.new_cipher == NULL) { algenc = s->session->cipher->algorithm_enc; } else { algenc = s->s3->tmp.new_cipher->algorithm_enc; } if (algenc & (SSL_AES128CCM8 | SSL_AES256CCM8)) taglen = EVP_CCM8_TLS_TAG_LEN; else taglen = EVP_CCM_TLS_TAG_LEN; } else { ivlen = EVP_CIPHER_iv_length(ciph); taglen = 0; } if (!tls13_derive_key(s, md, secret, key, keylen) || !tls13_derive_iv(s, md, secret, iv, ivlen)) { goto err; } if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, NULL, NULL, sending) <= 0 || !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL) || (taglen != 0 && !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG, taglen, NULL)) || EVP_CipherInit_ex(ciph_ctx, NULL, NULL, key, NULL, -1) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV, ERR_R_EVP_LIB); goto err; } return 1; err: OPENSSL_cleanse(key, sizeof(key)); return 0; }"
3230----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b04cb870fff926a2f94930338900734da5efd546_1.json----ff_id3v2_free_extra_meta,"void ff_id3v2_free_extra_meta(ID3v2ExtraMeta **extra_meta) { ID3v2ExtraMeta *current = *extra_meta, *next; <S2SV_StartVul> void (*free_func)(ID3v2ExtraMeta*); <S2SV_EndVul> while (current) { <S2SV_StartVul> if ((free_func = get_extra_meta_func(current->tag, 1)->free)) <S2SV_EndVul> <S2SV_StartVul> free_func(current->data); <S2SV_EndVul> next = current->next; av_freep(&current); current = next; } }","- void (*free_func)(ID3v2ExtraMeta*);
- if ((free_func = get_extra_meta_func(current->tag, 1)->free))
- free_func(current->data);
+ const ID3v2EMFunc *extra_func;
+ if ((extra_func = get_extra_meta_func(current->tag, 1)))
+ extra_func->free(current->data);","void ff_id3v2_free_extra_meta(ID3v2ExtraMeta **extra_meta) { ID3v2ExtraMeta *current = *extra_meta, *next; const ID3v2EMFunc *extra_func; while (current) { if ((extra_func = get_extra_meta_func(current->tag, 1))) extra_func->free(current->data); next = current->next; av_freep(&current); current = next; } }"
4794----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_3a21065b68f4a4dbb3f45c35d3bd287381a03357_1.json----start_threads,"static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void *dummy) { thread_starter *ts = dummy; apr_thread_t **threads = ts->threads; apr_threadattr_t *thread_attr = ts->threadattr; int child_num_arg = ts->child_num_arg; int my_child_num = child_num_arg; proc_info *my_info; apr_status_t rv; int i; int threads_created = 0; int listener_started = 0; int loops; int prev_threads_created; int max_recycled_pools = -1; worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue)); rv = ap_queue_init(worker_queue, threads_per_child, pchild); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, ""ap_queue_init() failed""); clean_child_exit(APEXIT_CHILDFATAL); } if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) { max_recycled_pools = threads_per_child * 3 / 4 ; } rv = ap_queue_info_create(&worker_queue_info, pchild, threads_per_child, max_recycled_pools); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, ""ap_queue_info_create() failed""); clean_child_exit(APEXIT_CHILDFATAL); } rv = apr_pollset_create(&event_pollset, threads_per_child, <S2SV_StartVul> pchild, APR_POLLSET_WAKEABLE|APR_POLLSET_NOCOPY); <S2SV_EndVul> if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, <S2SV_StartVul> ""apr_pollset_create failed; check system or user limits""); <S2SV_EndVul> clean_child_exit(APEXIT_CHILDFATAL); } worker_sockets = apr_pcalloc(pchild, threads_per_child * sizeof(apr_socket_t *)); <S2SV_StartVul> worker_equeues = apr_palloc(pchild, threads_per_child * sizeof(ap_equeue_t*)); <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < threads_per_child; i++) { <S2SV_EndVul> <S2SV_StartVul> ap_equeue_t* eq = NULL; <S2SV_EndVul> <S2SV_StartVul> ap_equeue_create(pchild, 16, sizeof(pollset_op_t), &eq); <S2SV_EndVul> <S2SV_StartVul> worker_equeues[i] = eq; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> loops = prev_threads_created = 0; while (1) { for (i = 0; i < threads_per_child; i++) { int status = ap_scoreboard_image->servers[child_num_arg][i].status; if (status != SERVER_GRACEFUL && status != SERVER_DEAD) { continue; } my_info = (proc_info *) ap_malloc(sizeof(proc_info)); my_info->pid = my_child_num; my_info->tid = i; my_info->sd = 0; ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING, NULL); rv = apr_thread_create(&threads[i], thread_attr, worker_thread, my_info, pchild); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, ""apr_thread_create: unable to create worker thread""); clean_child_exit(APEXIT_CHILDSICK); } threads_created++; } if (!listener_started && threads_created) { create_listener_thread(ts); listener_started = 1; } if (start_thread_may_exit || threads_created == threads_per_child) { break; } apr_sleep(apr_time_from_sec(1)); ++loops; if (loops % 120 == 0) { if (prev_threads_created == threads_created) { ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, ""child %"" APR_PID_T_FMT "" isn't taking over "" ""slots very quickly (%d of %d)"", ap_my_pid, threads_created, threads_per_child); } prev_threads_created = threads_created; } } apr_thread_exit(thd, APR_SUCCESS); return NULL; }","- pchild, APR_POLLSET_WAKEABLE|APR_POLLSET_NOCOPY);
- ""apr_pollset_create failed; check system or user limits"");
- worker_equeues = apr_palloc(pchild, threads_per_child * sizeof(ap_equeue_t*));
- for (i = 0; i < threads_per_child; i++) {
- ap_equeue_t* eq = NULL;
- ap_equeue_create(pchild, 16, sizeof(pollset_op_t), &eq);
- worker_equeues[i] = eq;
- }
+ rv = apr_thread_mutex_create(&timeout_mutex, APR_THREAD_MUTEX_DEFAULT,
+ pchild);
+ if (rv != APR_SUCCESS) {
+ ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,
+ ""creation of the timeout mutex failed."");
+ clean_child_exit(APEXIT_CHILDFATAL);
+ }
+ pchild, APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY);
+ ""apr_pollset_create with Thread Safety failed."");","static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void *dummy) { thread_starter *ts = dummy; apr_thread_t **threads = ts->threads; apr_threadattr_t *thread_attr = ts->threadattr; int child_num_arg = ts->child_num_arg; int my_child_num = child_num_arg; proc_info *my_info; apr_status_t rv; int i; int threads_created = 0; int listener_started = 0; int loops; int prev_threads_created; int max_recycled_pools = -1; worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue)); rv = ap_queue_init(worker_queue, threads_per_child, pchild); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, ""ap_queue_init() failed""); clean_child_exit(APEXIT_CHILDFATAL); } if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) { max_recycled_pools = threads_per_child * 3 / 4 ; } rv = ap_queue_info_create(&worker_queue_info, pchild, threads_per_child, max_recycled_pools); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, ""ap_queue_info_create() failed""); clean_child_exit(APEXIT_CHILDFATAL); } rv = apr_thread_mutex_create(&timeout_mutex, APR_THREAD_MUTEX_DEFAULT, pchild); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, ""creation of the timeout mutex failed.""); clean_child_exit(APEXIT_CHILDFATAL); } rv = apr_pollset_create(&event_pollset, threads_per_child, pchild, APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf, ""apr_pollset_create with Thread Safety failed.""); clean_child_exit(APEXIT_CHILDFATAL); } worker_sockets = apr_pcalloc(pchild, threads_per_child * sizeof(apr_socket_t *)); loops = prev_threads_created = 0; while (1) { for (i = 0; i < threads_per_child; i++) { int status = ap_scoreboard_image->servers[child_num_arg][i].status; if (status != SERVER_GRACEFUL && status != SERVER_DEAD) { continue; } my_info = (proc_info *) ap_malloc(sizeof(proc_info)); my_info->pid = my_child_num; my_info->tid = i; my_info->sd = 0; ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING, NULL); rv = apr_thread_create(&threads[i], thread_attr, worker_thread, my_info, pchild); if (rv != APR_SUCCESS) { ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf, ""apr_thread_create: unable to create worker thread""); clean_child_exit(APEXIT_CHILDSICK); } threads_created++; } if (!listener_started && threads_created) { create_listener_thread(ts); listener_started = 1; } if (start_thread_may_exit || threads_created == threads_per_child) { break; } apr_sleep(apr_time_from_sec(1)); ++loops; if (loops % 120 == 0) { if (prev_threads_created == threads_created) { ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, ""child %"" APR_PID_T_FMT "" isn't taking over "" ""slots very quickly (%d of %d)"", ap_my_pid, threads_created, threads_per_child); } prev_threads_created = threads_created; } } apr_thread_exit(thd, APR_SUCCESS); return NULL; }"
2209----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_79a1fd16656161591ad6a84d66f81bd8d285d365_1.json----matroska_parse_laces,"static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf, <S2SV_StartVul> int size, int type, <S2SV_EndVul> uint32_t **lace_buf, int *laces) { <S2SV_StartVul> int res = 0, n; <S2SV_EndVul> uint8_t *data = *buf; uint32_t *lace_size; if (!type) { *laces = 1; *lace_buf = av_mallocz(sizeof(int)); if (!*lace_buf) return AVERROR(ENOMEM); *lace_buf[0] = size; return 0; } av_assert0(size > 0); *laces = *data + 1; data += 1; size -= 1; lace_size = av_mallocz(*laces * sizeof(int)); if (!lace_size) return AVERROR(ENOMEM); switch (type) { case 0x1: { uint8_t temp; uint32_t total = 0; for (n = 0; res == 0 && n < *laces - 1; n++) { while (1) { if (size == 0) { res = AVERROR_EOF; break; } temp = *data; lace_size[n] += temp; data += 1; size -= 1; if (temp != 0xff) break; } total += lace_size[n]; } if (size <= total) { res = AVERROR_INVALIDDATA; break; } lace_size[n] = size - total; break; } case 0x2: if (size % (*laces)) { res = AVERROR_INVALIDDATA; break; } for (n = 0; n < *laces; n++) lace_size[n] = size / *laces; break; case 0x3: { uint64_t num; uint32_t total; n = matroska_ebmlnum_uint(matroska, data, size, &num); if (n < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); res = n; break; } data += n; size -= n; total = lace_size[0] = num; for (n = 1; res == 0 && n < *laces - 1; n++) { int64_t snum; int r; r = matroska_ebmlnum_sint(matroska, data, size, &snum); if (r < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); res = r; break; } data += r; size -= r; lace_size[n] = lace_size[n - 1] + snum; total += lace_size[n]; } if (size <= total) { res = AVERROR_INVALIDDATA; break; } lace_size[*laces - 1] = size - total; break; } } *buf = data; *lace_buf = lace_size; return res; }","- int size, int type,
- int res = 0, n;
+ int* buf_size, int type,
+ int res = 0, n, size = *buf_size;","static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf, int* buf_size, int type, uint32_t **lace_buf, int *laces) { int res = 0, n, size = *buf_size; uint8_t *data = *buf; uint32_t *lace_size; if (!type) { *laces = 1; *lace_buf = av_mallocz(sizeof(int)); if (!*lace_buf) return AVERROR(ENOMEM); *lace_buf[0] = size; return 0; } av_assert0(size > 0); *laces = *data + 1; data += 1; size -= 1; lace_size = av_mallocz(*laces * sizeof(int)); if (!lace_size) return AVERROR(ENOMEM); switch (type) { case 0x1: { uint8_t temp; uint32_t total = 0; for (n = 0; res == 0 && n < *laces - 1; n++) { while (1) { if (size == 0) { res = AVERROR_EOF; break; } temp = *data; lace_size[n] += temp; data += 1; size -= 1; if (temp != 0xff) break; } total += lace_size[n]; } if (size <= total) { res = AVERROR_INVALIDDATA; break; } lace_size[n] = size - total; break; } case 0x2: if (size % (*laces)) { res = AVERROR_INVALIDDATA; break; } for (n = 0; n < *laces; n++) lace_size[n] = size / *laces; break; case 0x3: { uint64_t num; uint32_t total; n = matroska_ebmlnum_uint(matroska, data, size, &num); if (n < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); res = n; break; } data += n; size -= n; total = lace_size[0] = num; for (n = 1; res == 0 && n < *laces - 1; n++) { int64_t snum; int r; r = matroska_ebmlnum_sint(matroska, data, size, &snum); if (r < 0) { av_log(matroska->ctx, AV_LOG_INFO, ""EBML block data error\n""); res = r; break; } data += r; size -= r; lace_size[n] = lace_size[n - 1] + snum; total += lace_size[n]; } if (size <= total) { res = AVERROR_INVALIDDATA; break; } lace_size[*laces - 1] = size - total; break; } } *buf = data; *lace_buf = lace_size; *buf_size = size; return res; }"
445----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1935e3f78e4ec0fddadbfb257bf41428e90282fa_1.json----allocate_buffers,"static int allocate_buffers(ALACContext *alac) { int ch; <S2SV_StartVul> int buf_size = alac->max_samples_per_frame * sizeof(int32_t); <S2SV_EndVul> for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) { FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch], buf_size, buf_alloc_fail); alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt); if (!alac->direct_output) { FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch], buf_size, buf_alloc_fail); } FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch], buf_size, buf_alloc_fail); } return 0; buf_alloc_fail: alac_decode_close(alac->avctx); return AVERROR(ENOMEM); }","- int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
+ int buf_size;
+ if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t))
+ goto buf_alloc_fail;
+ buf_size = alac->max_samples_per_frame * sizeof(int32_t);","static int allocate_buffers(ALACContext *alac) { int ch; int buf_size; if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t)) goto buf_alloc_fail; buf_size = alac->max_samples_per_frame * sizeof(int32_t); for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) { FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch], buf_size, buf_alloc_fail); alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt); if (!alac->direct_output) { FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch], buf_size, buf_alloc_fail); } FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch], buf_size, buf_alloc_fail); } return 0; buf_alloc_fail: alac_decode_close(alac->avctx); return AVERROR(ENOMEM); }"
6807----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_6d63b782229e4ad0efee7750ed9028a64c482f3e_1.json----mpegts_push_data,"static int mpegts_push_data(MpegTSFilter *filter, const uint8_t *buf, int buf_size, int is_start, int64_t pos) { PESContext *pes = filter->u.pes_filter.opaque; MpegTSContext *ts = pes->ts; const uint8_t *p; int len, code; if(!ts->pkt) return 0; if (is_start) { if (pes->state == MPEGTS_PAYLOAD && pes->data_index > 0) { new_pes_packet(pes, ts->pkt); ts->stop_parse = 1; } pes->state = MPEGTS_HEADER; pes->data_index = 0; pes->ts_packet_pos = pos; } p = buf; while (buf_size > 0) { switch(pes->state) { case MPEGTS_HEADER: len = PES_START_SIZE - pes->data_index; if (len > buf_size) len = buf_size; memcpy(pes->header + pes->data_index, p, len); pes->data_index += len; p += len; buf_size -= len; if (pes->data_index == PES_START_SIZE) { if (pes->header[0] == 0x00 && pes->header[1] == 0x00 && pes->header[2] == 0x01) { code = pes->header[3] | 0x100; av_dlog(pes->stream, ""pid=%x pes_code=%#x\n"", pes->pid, code); if ((pes->st && pes->st->discard == AVDISCARD_ALL) || code == 0x1be) goto skip; if (!pes->st) { pes->st = av_new_stream(ts->stream, pes->pid); if (!pes->st) return AVERROR(ENOMEM); mpegts_set_stream_info(pes->st, pes, 0, 0); } pes->total_size = AV_RB16(pes->header + 4); if (!pes->total_size) pes->total_size = MAX_PES_PAYLOAD; pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE); if (!pes->buffer) return AVERROR(ENOMEM); if (code != 0x1bc && code != 0x1bf && code != 0x1f0 && code != 0x1f1 && code != 0x1ff && code != 0x1f2 && code != 0x1f8) { pes->state = MPEGTS_PESHEADER; if (pes->st->codec->codec_id == CODEC_ID_NONE) { av_dlog(pes->stream, ""pid=%x stream_type=%x probing\n"", pes->pid, pes->stream_type); pes->st->codec->codec_id = CODEC_ID_PROBE; } } else { pes->state = MPEGTS_PAYLOAD; pes->data_index = 0; } } else { skip: pes->state = MPEGTS_SKIP; continue; } } break; case MPEGTS_PESHEADER: len = PES_HEADER_SIZE - pes->data_index; if (len < 0) return -1; if (len > buf_size) len = buf_size; memcpy(pes->header + pes->data_index, p, len); pes->data_index += len; p += len; buf_size -= len; if (pes->data_index == PES_HEADER_SIZE) { pes->pes_header_size = pes->header[8] + 9; pes->state = MPEGTS_PESHEADER_FILL; } break; case MPEGTS_PESHEADER_FILL: len = pes->pes_header_size - pes->data_index; if (len < 0) return -1; if (len > buf_size) len = buf_size; memcpy(pes->header + pes->data_index, p, len); pes->data_index += len; p += len; buf_size -= len; if (pes->data_index == pes->pes_header_size) { const uint8_t *r; unsigned int flags, pes_ext, skip; flags = pes->header[7]; r = pes->header + 9; pes->pts = AV_NOPTS_VALUE; pes->dts = AV_NOPTS_VALUE; if ((flags & 0xc0) == 0x80) { pes->dts = pes->pts = ff_parse_pes_pts(r); r += 5; } else if ((flags & 0xc0) == 0xc0) { pes->pts = ff_parse_pes_pts(r); r += 5; pes->dts = ff_parse_pes_pts(r); r += 5; } pes->extended_stream_id = -1; if (flags & 0x01) { pes_ext = *r++; skip = (pes_ext >> 4) & 0xb; skip += skip & 0x9; r += skip; if ((pes_ext & 0x41) == 0x01 && (r + 2) <= (pes->header + pes->pes_header_size)) { if ((r[0] & 0x7f) > 0 && (r[1] & 0x80) == 0) pes->extended_stream_id = r[1]; } } pes->state = MPEGTS_PAYLOAD; pes->data_index = 0; } break; case MPEGTS_PAYLOAD: if (buf_size > 0 && pes->buffer) { if (pes->data_index > 0 && pes->data_index+buf_size > pes->total_size) { new_pes_packet(pes, ts->pkt); pes->total_size = MAX_PES_PAYLOAD; pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE); if (!pes->buffer) return AVERROR(ENOMEM); ts->stop_parse = 1; } else if (pes->data_index == 0 && buf_size > pes->total_size) { buf_size = pes->total_size; } memcpy(pes->buffer+pes->data_index, p, buf_size); pes->data_index += buf_size; } buf_size = 0; <S2SV_StartVul> if (pes->total_size < MAX_PES_PAYLOAD && <S2SV_EndVul> pes->pes_header_size + pes->data_index == pes->total_size + 6) { ts->stop_parse = 1; new_pes_packet(pes, ts->pkt); } break; case MPEGTS_SKIP: buf_size = 0; break; } } return 0; }","- if (pes->total_size < MAX_PES_PAYLOAD &&
+ if (!ts->stop_parse && pes->total_size < MAX_PES_PAYLOAD &&","static int mpegts_push_data(MpegTSFilter *filter, const uint8_t *buf, int buf_size, int is_start, int64_t pos) { PESContext *pes = filter->u.pes_filter.opaque; MpegTSContext *ts = pes->ts; const uint8_t *p; int len, code; if(!ts->pkt) return 0; if (is_start) { if (pes->state == MPEGTS_PAYLOAD && pes->data_index > 0) { new_pes_packet(pes, ts->pkt); ts->stop_parse = 1; } pes->state = MPEGTS_HEADER; pes->data_index = 0; pes->ts_packet_pos = pos; } p = buf; while (buf_size > 0) { switch(pes->state) { case MPEGTS_HEADER: len = PES_START_SIZE - pes->data_index; if (len > buf_size) len = buf_size; memcpy(pes->header + pes->data_index, p, len); pes->data_index += len; p += len; buf_size -= len; if (pes->data_index == PES_START_SIZE) { if (pes->header[0] == 0x00 && pes->header[1] == 0x00 && pes->header[2] == 0x01) { code = pes->header[3] | 0x100; av_dlog(pes->stream, ""pid=%x pes_code=%#x\n"", pes->pid, code); if ((pes->st && pes->st->discard == AVDISCARD_ALL) || code == 0x1be) goto skip; if (!pes->st) { pes->st = av_new_stream(ts->stream, pes->pid); if (!pes->st) return AVERROR(ENOMEM); mpegts_set_stream_info(pes->st, pes, 0, 0); } pes->total_size = AV_RB16(pes->header + 4); if (!pes->total_size) pes->total_size = MAX_PES_PAYLOAD; pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE); if (!pes->buffer) return AVERROR(ENOMEM); if (code != 0x1bc && code != 0x1bf && code != 0x1f0 && code != 0x1f1 && code != 0x1ff && code != 0x1f2 && code != 0x1f8) { pes->state = MPEGTS_PESHEADER; if (pes->st->codec->codec_id == CODEC_ID_NONE) { av_dlog(pes->stream, ""pid=%x stream_type=%x probing\n"", pes->pid, pes->stream_type); pes->st->codec->codec_id = CODEC_ID_PROBE; } } else { pes->state = MPEGTS_PAYLOAD; pes->data_index = 0; } } else { skip: pes->state = MPEGTS_SKIP; continue; } } break; case MPEGTS_PESHEADER: len = PES_HEADER_SIZE - pes->data_index; if (len < 0) return -1; if (len > buf_size) len = buf_size; memcpy(pes->header + pes->data_index, p, len); pes->data_index += len; p += len; buf_size -= len; if (pes->data_index == PES_HEADER_SIZE) { pes->pes_header_size = pes->header[8] + 9; pes->state = MPEGTS_PESHEADER_FILL; } break; case MPEGTS_PESHEADER_FILL: len = pes->pes_header_size - pes->data_index; if (len < 0) return -1; if (len > buf_size) len = buf_size; memcpy(pes->header + pes->data_index, p, len); pes->data_index += len; p += len; buf_size -= len; if (pes->data_index == pes->pes_header_size) { const uint8_t *r; unsigned int flags, pes_ext, skip; flags = pes->header[7]; r = pes->header + 9; pes->pts = AV_NOPTS_VALUE; pes->dts = AV_NOPTS_VALUE; if ((flags & 0xc0) == 0x80) { pes->dts = pes->pts = ff_parse_pes_pts(r); r += 5; } else if ((flags & 0xc0) == 0xc0) { pes->pts = ff_parse_pes_pts(r); r += 5; pes->dts = ff_parse_pes_pts(r); r += 5; } pes->extended_stream_id = -1; if (flags & 0x01) { pes_ext = *r++; skip = (pes_ext >> 4) & 0xb; skip += skip & 0x9; r += skip; if ((pes_ext & 0x41) == 0x01 && (r + 2) <= (pes->header + pes->pes_header_size)) { if ((r[0] & 0x7f) > 0 && (r[1] & 0x80) == 0) pes->extended_stream_id = r[1]; } } pes->state = MPEGTS_PAYLOAD; pes->data_index = 0; } break; case MPEGTS_PAYLOAD: if (buf_size > 0 && pes->buffer) { if (pes->data_index > 0 && pes->data_index+buf_size > pes->total_size) { new_pes_packet(pes, ts->pkt); pes->total_size = MAX_PES_PAYLOAD; pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE); if (!pes->buffer) return AVERROR(ENOMEM); ts->stop_parse = 1; } else if (pes->data_index == 0 && buf_size > pes->total_size) { buf_size = pes->total_size; } memcpy(pes->buffer+pes->data_index, p, buf_size); pes->data_index += buf_size; } buf_size = 0; if (!ts->stop_parse && pes->total_size < MAX_PES_PAYLOAD && pes->pes_header_size + pes->data_index == pes->total_size + 6) { ts->stop_parse = 1; new_pes_packet(pes, ts->pkt); } break; case MPEGTS_SKIP: buf_size = 0; break; } } return 0; }"
3457----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bab4e5a73df6e769936c7652bbc519f5fba56a36_1.json----avfilter_filter_samples,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = link->dstpad; int i; FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1); if (!(filter_samples = dst->filter_samples)) filter_samples = avfilter_default_filter_samples; if ((dst->min_perms & samplesref->perms) != dst->min_perms || dst->rej_perms & samplesref->perms) { av_log(link->dst, AV_LOG_DEBUG, ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"", samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms); link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms, samplesref->audio->nb_samples); link->cur_buf->pts = samplesref->pts; link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate; <S2SV_StartVul> for (i = 0; samplesref->data[i]; i++) <S2SV_EndVul> memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]); avfilter_unref_buffer(samplesref); } else link->cur_buf = samplesref; filter_samples(link, link->cur_buf); }","- for (i = 0; samplesref->data[i]; i++)
+ for (i = 0; samplesref->data[i] && i < 8; i++)","void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = link->dstpad; int i; FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1); if (!(filter_samples = dst->filter_samples)) filter_samples = avfilter_default_filter_samples; if ((dst->min_perms & samplesref->perms) != dst->min_perms || dst->rej_perms & samplesref->perms) { av_log(link->dst, AV_LOG_DEBUG, ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"", samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms); link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms, samplesref->audio->nb_samples); link->cur_buf->pts = samplesref->pts; link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate; for (i = 0; samplesref->data[i] && i < 8; i++) memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]); avfilter_unref_buffer(samplesref); } else link->cur_buf = samplesref; filter_samples(link, link->cur_buf); }"
10574----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0aba974665c8408e990a9fecb3347b3cc9fb563d_1.json----pkcs7_main,"int pkcs7_main(int argc, char **argv) { PKCS7 *p7 = NULL; BIO *in = NULL, *out = NULL; int informat = FORMAT_PEM, outformat = FORMAT_PEM; char *infile = NULL, *outfile = NULL, *prog; int i, print_certs = 0, text = 0, noout = 0, p7_print = 0, ret = 1; OPTION_CHOICE o; prog = opt_init(argc, argv, pkcs7_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: opt_help(pkcs7_options); ret = 0; goto end; case OPT_INFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat)) goto opthelp; break; case OPT_OUTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat)) goto opthelp; break; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; case OPT_NOOUT: noout = 1; break; case OPT_TEXT: text = 1; break; case OPT_PRINT: p7_print = 1; break; case OPT_PRINT_CERTS: print_certs = 1; break; case OPT_ENGINE: (void)setup_engine(opt_arg(), 0); break; } } argc = opt_num_rest(); argv = opt_rest(); if (!app_load_modules(NULL)) goto end; <S2SV_StartVul> in = bio_open_default(infile, RB(informat)); <S2SV_EndVul> if (in == NULL) goto end; if (informat == FORMAT_ASN1) p7 = d2i_PKCS7_bio(in, NULL); else p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL); if (p7 == NULL) { BIO_printf(bio_err, ""unable to load PKCS7 object\n""); ERR_print_errors(bio_err); goto end; } <S2SV_StartVul> out = bio_open_default(outfile, WB(outformat)); <S2SV_EndVul> if (out == NULL) goto end; if (p7_print) PKCS7_print_ctx(out, p7, 0, NULL); if (print_certs) { STACK_OF(X509) *certs = NULL; STACK_OF(X509_CRL) *crls = NULL; i = OBJ_obj2nid(p7->type); switch (i) { case NID_pkcs7_signed: certs = p7->d.sign->cert; crls = p7->d.sign->crl; break; case NID_pkcs7_signedAndEnveloped: certs = p7->d.signed_and_enveloped->cert; crls = p7->d.signed_and_enveloped->crl; break; default: break; } if (certs != NULL) { X509 *x; for (i = 0; i < sk_X509_num(certs); i++) { x = sk_X509_value(certs, i); if (text) X509_print(out, x); else dump_cert_text(out, x); if (!noout) PEM_write_bio_X509(out, x); BIO_puts(out, ""\n""); } } if (crls != NULL) { X509_CRL *crl; for (i = 0; i < sk_X509_CRL_num(crls); i++) { crl = sk_X509_CRL_value(crls, i); X509_CRL_print(out, crl); if (!noout) PEM_write_bio_X509_CRL(out, crl); BIO_puts(out, ""\n""); } } ret = 0; goto end; } if (!noout) { if (outformat == FORMAT_ASN1) i = i2d_PKCS7_bio(out, p7); else i = PEM_write_bio_PKCS7(out, p7); if (!i) { BIO_printf(bio_err, ""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } } ret = 0; end: PKCS7_free(p7); BIO_free(in); BIO_free_all(out); return (ret); }","- in = bio_open_default(infile, RB(informat));
- out = bio_open_default(outfile, WB(outformat));
+ in = bio_open_default(infile, 'r', informat);
+ out = bio_open_default(outfile, 'w', outformat);","int pkcs7_main(int argc, char **argv) { PKCS7 *p7 = NULL; BIO *in = NULL, *out = NULL; int informat = FORMAT_PEM, outformat = FORMAT_PEM; char *infile = NULL, *outfile = NULL, *prog; int i, print_certs = 0, text = 0, noout = 0, p7_print = 0, ret = 1; OPTION_CHOICE o; prog = opt_init(argc, argv, pkcs7_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: opt_help(pkcs7_options); ret = 0; goto end; case OPT_INFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat)) goto opthelp; break; case OPT_OUTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat)) goto opthelp; break; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; case OPT_NOOUT: noout = 1; break; case OPT_TEXT: text = 1; break; case OPT_PRINT: p7_print = 1; break; case OPT_PRINT_CERTS: print_certs = 1; break; case OPT_ENGINE: (void)setup_engine(opt_arg(), 0); break; } } argc = opt_num_rest(); argv = opt_rest(); if (!app_load_modules(NULL)) goto end; in = bio_open_default(infile, 'r', informat); if (in == NULL) goto end; if (informat == FORMAT_ASN1) p7 = d2i_PKCS7_bio(in, NULL); else p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL); if (p7 == NULL) { BIO_printf(bio_err, ""unable to load PKCS7 object\n""); ERR_print_errors(bio_err); goto end; } out = bio_open_default(outfile, 'w', outformat); if (out == NULL) goto end; if (p7_print) PKCS7_print_ctx(out, p7, 0, NULL); if (print_certs) { STACK_OF(X509) *certs = NULL; STACK_OF(X509_CRL) *crls = NULL; i = OBJ_obj2nid(p7->type); switch (i) { case NID_pkcs7_signed: certs = p7->d.sign->cert; crls = p7->d.sign->crl; break; case NID_pkcs7_signedAndEnveloped: certs = p7->d.signed_and_enveloped->cert; crls = p7->d.signed_and_enveloped->crl; break; default: break; } if (certs != NULL) { X509 *x; for (i = 0; i < sk_X509_num(certs); i++) { x = sk_X509_value(certs, i); if (text) X509_print(out, x); else dump_cert_text(out, x); if (!noout) PEM_write_bio_X509(out, x); BIO_puts(out, ""\n""); } } if (crls != NULL) { X509_CRL *crl; for (i = 0; i < sk_X509_CRL_num(crls); i++) { crl = sk_X509_CRL_value(crls, i); X509_CRL_print(out, crl); if (!noout) PEM_write_bio_X509_CRL(out, crl); BIO_puts(out, ""\n""); } } ret = 0; goto end; } if (!noout) { if (outformat == FORMAT_ASN1) i = i2d_PKCS7_bio(out, p7); else i = PEM_write_bio_PKCS7(out, p7); if (!i) { BIO_printf(bio_err, ""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } } ret = 0; end: PKCS7_free(p7); BIO_free(in); BIO_free_all(out); return (ret); }"
5584----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25b274a85d250156fa649dc424cb0305f35fd9ed_1.json----decode_frame,"static int decode_frame(WmallDecodeCtx *s) { GetBitContext* gb = &s->gb; int more_frames = 0, len = 0, i, ret; <S2SV_StartVul> s->frame.nb_samples = s->samples_per_frame; <S2SV_EndVul> <S2SV_StartVul> if ((ret = ff_get_buffer(s->avctx, &s->frame, 0)) < 0) { <S2SV_EndVul> av_log(s->avctx, AV_LOG_ERROR, ""not enough space for the output samples\n""); s->packet_loss = 1; return ret; } for (i = 0; i < s->num_channels; i++) { <S2SV_StartVul> s->samples_16[i] = (int16_t *)s->frame.extended_data[i]; <S2SV_EndVul> <S2SV_StartVul> s->samples_32[i] = (int32_t *)s->frame.extended_data[i]; <S2SV_EndVul> } if (s->len_prefix) len = get_bits(gb, s->log2_frame_size); if (decode_tilehdr(s)) { s->packet_loss = 1; return 0; } if (s->dynamic_range_compression) s->drc_gain = get_bits(gb, 8); if (get_bits1(gb)) { int av_unused skip; if (get_bits1(gb)) { skip = get_bits(gb, av_log2(s->samples_per_frame * 2)); av_dlog(s->avctx, ""start skip: %i\n"", skip); } if (get_bits1(gb)) { skip = get_bits(gb, av_log2(s->samples_per_frame * 2)); av_dlog(s->avctx, ""end skip: %i\n"", skip); } } s->parsed_all_subframes = 0; for (i = 0; i < s->num_channels; i++) { s->channel[i].decoded_samples = 0; s->channel[i].cur_subframe = 0; } while (!s->parsed_all_subframes) { if (decode_subframe(s) < 0) { s->packet_loss = 1; return 0; } } av_dlog(s->avctx, ""Frame done\n""); if (s->skip_frame) s->skip_frame = 0; if (s->len_prefix) { if (len != (get_bits_count(gb) - s->frame_offset) + 2) { av_log(s->avctx, AV_LOG_ERROR, ""frame[%i] would have to skip %i bits\n"", s->frame_num, len - (get_bits_count(gb) - s->frame_offset) - 1); s->packet_loss = 1; return 0; } skip_bits_long(gb, len - (get_bits_count(gb) - s->frame_offset) - 1); } more_frames = get_bits1(gb); ++s->frame_num; return more_frames; }","- s->frame.nb_samples = s->samples_per_frame;
- if ((ret = ff_get_buffer(s->avctx, &s->frame, 0)) < 0) {
- s->samples_16[i] = (int16_t *)s->frame.extended_data[i];
- s->samples_32[i] = (int32_t *)s->frame.extended_data[i];
+ s->frame->nb_samples = s->samples_per_frame;
+ if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {
+ s->samples_16[i] = (int16_t *)s->frame->extended_data[i];
+ s->samples_32[i] = (int32_t *)s->frame->extended_data[i];","static int decode_frame(WmallDecodeCtx *s) { GetBitContext* gb = &s->gb; int more_frames = 0, len = 0, i, ret; s->frame->nb_samples = s->samples_per_frame; if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) { av_log(s->avctx, AV_LOG_ERROR, ""not enough space for the output samples\n""); s->packet_loss = 1; return ret; } for (i = 0; i < s->num_channels; i++) { s->samples_16[i] = (int16_t *)s->frame->extended_data[i]; s->samples_32[i] = (int32_t *)s->frame->extended_data[i]; } if (s->len_prefix) len = get_bits(gb, s->log2_frame_size); if (decode_tilehdr(s)) { s->packet_loss = 1; return 0; } if (s->dynamic_range_compression) s->drc_gain = get_bits(gb, 8); if (get_bits1(gb)) { int av_unused skip; if (get_bits1(gb)) { skip = get_bits(gb, av_log2(s->samples_per_frame * 2)); av_dlog(s->avctx, ""start skip: %i\n"", skip); } if (get_bits1(gb)) { skip = get_bits(gb, av_log2(s->samples_per_frame * 2)); av_dlog(s->avctx, ""end skip: %i\n"", skip); } } s->parsed_all_subframes = 0; for (i = 0; i < s->num_channels; i++) { s->channel[i].decoded_samples = 0; s->channel[i].cur_subframe = 0; } while (!s->parsed_all_subframes) { if (decode_subframe(s) < 0) { s->packet_loss = 1; return 0; } } av_dlog(s->avctx, ""Frame done\n""); if (s->skip_frame) s->skip_frame = 0; if (s->len_prefix) { if (len != (get_bits_count(gb) - s->frame_offset) + 2) { av_log(s->avctx, AV_LOG_ERROR, ""frame[%i] would have to skip %i bits\n"", s->frame_num, len - (get_bits_count(gb) - s->frame_offset) - 1); s->packet_loss = 1; return 0; } skip_bits_long(gb, len - (get_bits_count(gb) - s->frame_offset) - 1); } more_frames = get_bits1(gb); ++s->frame_num; return more_frames; }"
290----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_11f75d1b5e115cf7a6cdb8848d6ff529cec81f3b_1.json----av_reallocp_array,"int av_reallocp_array(void *ptr, size_t nmemb, size_t size) { void **ptrptr = ptr; *ptrptr = av_realloc_f(*ptrptr, nmemb, size); <S2SV_StartVul> if (!*ptrptr && !(nmemb && size)) <S2SV_EndVul> return AVERROR(ENOMEM); return 0; }","- if (!*ptrptr && !(nmemb && size))
+ if (!*ptrptr && nmemb && size)","int av_reallocp_array(void *ptr, size_t nmemb, size_t size) { void **ptrptr = ptr; *ptrptr = av_realloc_f(*ptrptr, nmemb, size); if (!*ptrptr && nmemb && size) return AVERROR(ENOMEM); return 0; }"
10384----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_03a9f2df90e1da644719327cf6c1dd33754730ff_1.json----BN_mod_exp_mont,"int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont) { int i, j, bits, ret = 0, wstart, wend, window, wvalue; int start = 1; BIGNUM *d, *r; const BIGNUM *aa; BIGNUM *val[TABLE_SIZE]; BN_MONT_CTX *mont = NULL; if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) { return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont); } bn_check_top(a); bn_check_top(p); bn_check_top(m); if (!BN_is_odd(m)) { BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS); return 0; } bits = BN_num_bits(p); if (bits == 0) { if (BN_abs_is_word(m, 1)) { ret = 1; BN_zero(rr); } else { ret = BN_one(rr); } return ret; } BN_CTX_start(ctx); d = BN_CTX_get(ctx); r = BN_CTX_get(ctx); val[0] = BN_CTX_get(ctx); if (val[0] == NULL) goto err; if (in_mont != NULL) mont = in_mont; else { if ((mont = BN_MONT_CTX_new()) == NULL) goto err; if (!BN_MONT_CTX_set(mont, m, ctx)) goto err; } if (a->neg || BN_ucmp(a, m) >= 0) { if (!BN_nnmod(val[0], a, m, ctx)) goto err; aa = val[0]; } else aa = a; if (BN_is_zero(aa)) { BN_zero(rr); ret = 1; goto err; } <S2SV_StartVul> if (!BN_to_montgomery(val[0], aa, mont, ctx)) <S2SV_EndVul> goto err; window = BN_window_bits_for_exponent_size(bits); if (window > 1) { <S2SV_StartVul> if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx)) <S2SV_EndVul> goto err; j = 1 << (window - 1); for (i = 1; i < j; i++) { if (((val[i] = BN_CTX_get(ctx)) == NULL) || <S2SV_StartVul> !BN_mod_mul_montgomery(val[i], val[i - 1], d, mont, ctx)) <S2SV_EndVul> goto err; } } start = 1; wvalue = 0; wstart = bits - 1; wend = 0; #if 1 j = m->top; if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) { if (bn_wexpand(r, j) == NULL) goto err; r->d[0] = (0 - m->d[0]) & BN_MASK2; for (i = 1; i < j; i++) r->d[i] = (~m->d[i]) & BN_MASK2; r->top = j; <S2SV_EndVul> <S2SV_StartVul> bn_correct_top(r); <S2SV_EndVul> } else #endif <S2SV_StartVul> if (!BN_to_montgomery(r, BN_value_one(), mont, ctx)) <S2SV_EndVul> goto err; for (;;) { if (BN_is_bit_set(p, wstart) == 0) { if (!start) { <S2SV_StartVul> if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) <S2SV_EndVul> goto err; } if (wstart == 0) break; wstart--; continue; } j = wstart; wvalue = 1; wend = 0; for (i = 1; i < window; i++) { if (wstart - i < 0) break; if (BN_is_bit_set(p, wstart - i)) { wvalue <<= (i - wend); wvalue |= 1; wend = i; } } j = wend + 1; if (!start) for (i = 0; i < j; i++) { <S2SV_StartVul> if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) <S2SV_EndVul> goto err; } <S2SV_StartVul> if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx)) <S2SV_EndVul> goto err; wstart -= wend + 1; wvalue = 0; start = 0; if (wstart < 0) break; } #if defined(SPARC_T4_MONT) if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) { j = mont->N.top; val[0]->d[0] = 1; for (i = 1; i < j; i++) val[0]->d[i] = 0; val[0]->top = j; if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx)) goto err; } else #endif if (!BN_from_montgomery(rr, r, mont, ctx)) goto err; ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); BN_CTX_end(ctx); bn_check_top(rr); return ret; }","- if (!BN_to_montgomery(val[0], aa, mont, ctx))
- if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))
- !BN_mod_mul_montgomery(val[i], val[i - 1], d, mont, ctx))
- bn_correct_top(r);
- if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))
- if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
- if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))
- if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))
+ if (!bn_to_mont_fixed_top(val[0], aa, mont, ctx))
+ if (!bn_mul_mont_fixed_top(d, val[0], val[0], mont, ctx))
+ !bn_mul_mont_fixed_top(val[i], val[i - 1], d, mont, ctx))
+ r->flags |= BN_FLG_FIXED_TOP;
+ if (!bn_to_mont_fixed_top(r, BN_value_one(), mont, ctx))
+ if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx))
+ if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx))
+ if (!bn_mul_mont_fixed_top(r, r, val[wvalue >> 1], mont, ctx))","int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont) { int i, j, bits, ret = 0, wstart, wend, window, wvalue; int start = 1; BIGNUM *d, *r; const BIGNUM *aa; BIGNUM *val[TABLE_SIZE]; BN_MONT_CTX *mont = NULL; if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0 || BN_get_flags(a, BN_FLG_CONSTTIME) != 0 || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) { return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont); } bn_check_top(a); bn_check_top(p); bn_check_top(m); if (!BN_is_odd(m)) { BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS); return 0; } bits = BN_num_bits(p); if (bits == 0) { if (BN_abs_is_word(m, 1)) { ret = 1; BN_zero(rr); } else { ret = BN_one(rr); } return ret; } BN_CTX_start(ctx); d = BN_CTX_get(ctx); r = BN_CTX_get(ctx); val[0] = BN_CTX_get(ctx); if (val[0] == NULL) goto err; if (in_mont != NULL) mont = in_mont; else { if ((mont = BN_MONT_CTX_new()) == NULL) goto err; if (!BN_MONT_CTX_set(mont, m, ctx)) goto err; } if (a->neg || BN_ucmp(a, m) >= 0) { if (!BN_nnmod(val[0], a, m, ctx)) goto err; aa = val[0]; } else aa = a; if (BN_is_zero(aa)) { BN_zero(rr); ret = 1; goto err; } if (!bn_to_mont_fixed_top(val[0], aa, mont, ctx)) goto err; window = BN_window_bits_for_exponent_size(bits); if (window > 1) { if (!bn_mul_mont_fixed_top(d, val[0], val[0], mont, ctx)) goto err; j = 1 << (window - 1); for (i = 1; i < j; i++) { if (((val[i] = BN_CTX_get(ctx)) == NULL) || !bn_mul_mont_fixed_top(val[i], val[i - 1], d, mont, ctx)) goto err; } } start = 1; wvalue = 0; wstart = bits - 1; wend = 0; #if 1 j = m->top; if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) { if (bn_wexpand(r, j) == NULL) goto err; r->d[0] = (0 - m->d[0]) & BN_MASK2; for (i = 1; i < j; i++) r->d[i] = (~m->d[i]) & BN_MASK2; r->top = j; r->flags |= BN_FLG_FIXED_TOP; } else #endif if (!bn_to_mont_fixed_top(r, BN_value_one(), mont, ctx)) goto err; for (;;) { if (BN_is_bit_set(p, wstart) == 0) { if (!start) { if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx)) goto err; } if (wstart == 0) break; wstart--; continue; } j = wstart; wvalue = 1; wend = 0; for (i = 1; i < window; i++) { if (wstart - i < 0) break; if (BN_is_bit_set(p, wstart - i)) { wvalue <<= (i - wend); wvalue |= 1; wend = i; } } j = wend + 1; if (!start) for (i = 0; i < j; i++) { if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx)) goto err; } if (!bn_mul_mont_fixed_top(r, r, val[wvalue >> 1], mont, ctx)) goto err; wstart -= wend + 1; wvalue = 0; start = 0; if (wstart < 0) break; } #if defined(SPARC_T4_MONT) if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) { j = mont->N.top; val[0]->d[0] = 1; for (i = 1; i < j; i++) val[0]->d[i] = 0; val[0]->top = j; if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx)) goto err; } else #endif if (!BN_from_montgomery(rr, r, mont, ctx)) goto err; ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); BN_CTX_end(ctx); bn_check_top(rr); return ret; }"
6886----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_72e7f0a84efc09519b51f5b5cdec49d2f43856d4_1.json----vmdaudio_decode_frame,"static int vmdaudio_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; VmdAudioContext *s = avctx->priv_data; unsigned char *output_samples = (unsigned char *)data; const unsigned char *p = buf + 16; if (buf_size < 16) return buf_size; if (buf[6] == 1) { *data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16); } else if (buf[6] == 2) { uint32_t flags = AV_RB32(p); int raw_block_size = s->block_align * (av_get_bits_per_sample_fmt(avctx->sample_fmt) / 8); <S2SV_StartVul> int silent_chunks; <S2SV_EndVul> <S2SV_StartVul> if(flags == 0xFFFFFFFF) <S2SV_EndVul> <S2SV_StartVul> silent_chunks = 32; <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> silent_chunks = av_log2(flags + 1); <S2SV_EndVul> if(*data_size < (s->block_align*silent_chunks + buf_size - 20) * 2) return -1; *data_size = 0; memset(output_samples, 0, raw_block_size * silent_chunks); output_samples += raw_block_size * silent_chunks; *data_size = raw_block_size * silent_chunks; *data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20); } else if (buf[6] == 3) { *data_size = vmdaudio_loadsound(s, output_samples, p, 1, s->block_align); } return buf_size; }","- int silent_chunks;
- if(flags == 0xFFFFFFFF)
- silent_chunks = 32;
- else
- silent_chunks = av_log2(flags + 1);
+ int silent_chunks = av_popcount(flags);","static int vmdaudio_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; VmdAudioContext *s = avctx->priv_data; unsigned char *output_samples = (unsigned char *)data; const unsigned char *p = buf + 16; if (buf_size < 16) return buf_size; if (buf[6] == 1) { *data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16); } else if (buf[6] == 2) { uint32_t flags = AV_RB32(p); int raw_block_size = s->block_align * (av_get_bits_per_sample_fmt(avctx->sample_fmt) / 8); int silent_chunks = av_popcount(flags); if(*data_size < (s->block_align*silent_chunks + buf_size - 20) * 2) return -1; *data_size = 0; memset(output_samples, 0, raw_block_size * silent_chunks); output_samples += raw_block_size * silent_chunks; *data_size = raw_block_size * silent_chunks; *data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20); } else if (buf[6] == 3) { *data_size = vmdaudio_loadsound(s, output_samples, p, 1, s->block_align); } return buf_size; }"
4118----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_de14db683bc62be7975ac12142a5c44ceda6e293_1.json----av_image_fill_arrays,"int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align) { int ret, i; if ((ret = av_image_check_size(width, height, 0, NULL)) < 0) return ret; if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) < 0) return ret; for (i = 0; i < 4; i++) dst_linesize[i] = FFALIGN(dst_linesize[i], align); <S2SV_StartVul> if ((ret = av_image_fill_pointers(dst_data, pix_fmt, width, NULL, dst_linesize)) < 0) <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize); }","- if ((ret = av_image_fill_pointers(dst_data, pix_fmt, width, NULL, dst_linesize)) < 0)
- return ret;","int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align) { int ret, i; if ((ret = av_image_check_size(width, height, 0, NULL)) < 0) return ret; if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) < 0) return ret; for (i = 0; i < 4; i++) dst_linesize[i] = FFALIGN(dst_linesize[i], align); return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize); }"
5901----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_367e944e9dc15b0891a9f580acab147d13719f82_1.json----vc1_decode_blocks,"<S2SV_StartVul> static void vc1_decode_blocks(VC1Context *v) <S2SV_EndVul> { v->s.esc3_level_length = 0; if(v->x8_type){ ff_intrax8_decode_picture(&v->x8, 2*v->pq+v->halfpq, v->pq*(!v->pquantizer) ); }else{ switch(v->s.pict_type) { case FF_I_TYPE: if(v->profile == PROFILE_ADVANCED) <S2SV_StartVul> vc1_decode_i_blocks_adv(v); <S2SV_EndVul> else vc1_decode_i_blocks(v); break; case FF_P_TYPE: if(v->p_frame_skipped) vc1_decode_skip_blocks(v); else <S2SV_StartVul> vc1_decode_p_blocks(v); <S2SV_EndVul> break; case FF_B_TYPE: if(v->bi_type){ if(v->profile == PROFILE_ADVANCED) <S2SV_StartVul> vc1_decode_i_blocks_adv(v); <S2SV_EndVul> else vc1_decode_i_blocks(v); }else <S2SV_StartVul> vc1_decode_b_blocks(v); <S2SV_EndVul> break; } } }","- static void vc1_decode_blocks(VC1Context *v)
- vc1_decode_i_blocks_adv(v);
- vc1_decode_p_blocks(v);
- vc1_decode_i_blocks_adv(v);
- vc1_decode_b_blocks(v);
+ static void vc1_decode_blocks(VC1Context *v, int mby_start, int mby_end)
+ vc1_decode_i_blocks_adv(v, mby_start, mby_end);
+ vc1_decode_p_blocks(v, mby_start, mby_end);
+ vc1_decode_i_blocks_adv(v, mby_start, mby_end);
+ vc1_decode_b_blocks(v, mby_start, mby_end);","static void vc1_decode_blocks(VC1Context *v, int mby_start, int mby_end) { v->s.esc3_level_length = 0; if(v->x8_type){ ff_intrax8_decode_picture(&v->x8, 2*v->pq+v->halfpq, v->pq*(!v->pquantizer) ); }else{ switch(v->s.pict_type) { case FF_I_TYPE: if(v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v, mby_start, mby_end); else vc1_decode_i_blocks(v); break; case FF_P_TYPE: if(v->p_frame_skipped) vc1_decode_skip_blocks(v); else vc1_decode_p_blocks(v, mby_start, mby_end); break; case FF_B_TYPE: if(v->bi_type){ if(v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v, mby_start, mby_end); else vc1_decode_i_blocks(v); }else vc1_decode_b_blocks(v, mby_start, mby_end); break; } } }"
2237----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7b5b33895239e2c60fc450b5dea8b3833d9ade44_1.json----ff_rdft_init,"int ff_rdft_init(RDFTContext *s, int nbits, enum RDFTransformType trans) { int n = 1 << nbits; int ret; s->nbits = nbits; s->inverse = trans == IDFT_C2R || trans == DFT_C2R; s->sign_convention = trans == IDFT_R2C || trans == DFT_C2R ? 1 : -1; if (nbits < 4 || nbits > 16) return AVERROR(EINVAL); if ((ret = ff_fft_init(&s->fft, nbits-1, trans == IDFT_C2R || trans == IDFT_R2C)) < 0) return ret; ff_init_ff_cos_tabs(nbits); s->tcos = ff_cos_tabs[nbits]; <S2SV_StartVul> s->tsin = ff_sin_tabs[nbits]+(trans == DFT_R2C || trans == DFT_C2R)*(n>>2); <S2SV_EndVul> <S2SV_StartVul> #if !CONFIG_HARDCODED_TABLES <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> int i; <S2SV_EndVul> <S2SV_StartVul> const double theta = (trans == DFT_R2C || trans == DFT_C2R ? -1 : 1) * 2 * M_PI / n; <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < (n >> 2); i++) <S2SV_EndVul> <S2SV_StartVul> s->tsin[i] = sin(i * theta); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> s->rdft_calc = rdft_calc_c; if (ARCH_ARM) ff_rdft_init_arm(s); return 0; }","- s->tsin = ff_sin_tabs[nbits]+(trans == DFT_R2C || trans == DFT_C2R)*(n>>2);
- #if !CONFIG_HARDCODED_TABLES
- {
- int i;
- const double theta = (trans == DFT_R2C || trans == DFT_C2R ? -1 : 1) * 2 * M_PI / n;
- for (i = 0; i < (n >> 2); i++)
- s->tsin[i] = sin(i * theta);
- }
- #endif
+ s->negative_sin = trans == DFT_C2R || trans == DFT_R2C;
+ s->tsin = ff_cos_tabs[nbits] + (n >> 2);","int ff_rdft_init(RDFTContext *s, int nbits, enum RDFTransformType trans) { int n = 1 << nbits; int ret; s->nbits = nbits; s->inverse = trans == IDFT_C2R || trans == DFT_C2R; s->sign_convention = trans == IDFT_R2C || trans == DFT_C2R ? 1 : -1; s->negative_sin = trans == DFT_C2R || trans == DFT_R2C; if (nbits < 4 || nbits > 16) return AVERROR(EINVAL); if ((ret = ff_fft_init(&s->fft, nbits-1, trans == IDFT_C2R || trans == IDFT_R2C)) < 0) return ret; ff_init_ff_cos_tabs(nbits); s->tcos = ff_cos_tabs[nbits]; s->tsin = ff_cos_tabs[nbits] + (n >> 2); s->rdft_calc = rdft_calc_c; if (ARCH_ARM) ff_rdft_init_arm(s); return 0; }"
603----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2166d21a0ac18fb4d0e5e0e9d0c645d31e425e26_1.json----ff_rate_control_init,"int ff_rate_control_init(MpegEncContext *s) { RateControlContext *rcc = &s->rc_context; int i, res; static const char * const const_names[] = { ""PI"", ""E"", ""iTex"", ""pTex"", ""tex"", ""mv"", ""fCode"", ""iCount"", ""mcVar"", ""var"", ""isI"", ""isP"", ""isB"", ""avgQP"", ""qComp"", #if 0 ""lastIQP"", ""lastPQP"", ""lastBQP"", ""nextNonBQP"", #endif ""avgIITex"", ""avgPITex"", ""avgPPTex"", ""avgBPTex"", ""avgTex"", NULL }; static double (* const func1[])(void *, double) = { (void *)bits2qp, (void *)qp2bits, NULL }; static const char * const func1_names[] = { ""bits2qp"", ""qp2bits"", NULL }; emms_c(); if (!s->avctx->rc_max_available_vbv_use && s->avctx->rc_buffer_size) { if (s->avctx->rc_max_rate) { s->avctx->rc_max_available_vbv_use = av_clipf(s->avctx->rc_max_rate/(s->avctx->rc_buffer_size*get_fps(s->avctx)), 1.0/3, 1.0); } else s->avctx->rc_max_available_vbv_use = 1.0; } res = av_expr_parse(&rcc->rc_eq_eval, s->avctx->rc_eq ? s->avctx->rc_eq : ""tex^qComp"", const_names, func1_names, func1, NULL, NULL, 0, s->avctx); if (res < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Error parsing rc_eq \""%s\""\n"", s->avctx->rc_eq); return res; } for (i = 0; i < 5; i++) { rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0; rcc->pred[i].count = 1.0; rcc->pred[i].decay = 0.4; rcc->i_cplx_sum [i] = rcc->p_cplx_sum [i] = rcc->mv_bits_sum[i] = rcc->qscale_sum [i] = rcc->frame_count[i] = 1; rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5; } rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy; if (!rcc->buffer_index) rcc->buffer_index = s->avctx->rc_buffer_size * 3 / 4; if (s->flags & CODEC_FLAG_PASS2) { int i; char *p; p = s->avctx->stats_in; for (i = -1; p; i++) p = strchr(p + 1, ';'); i += s->max_b_frames; if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry)) return -1; rcc->entry = av_mallocz(i * sizeof(RateControlEntry)); rcc->num_entries = i; for (i = 0; i < rcc->num_entries; i++) { RateControlEntry *rce = &rcc->entry[i]; rce->pict_type = rce->new_pict_type = AV_PICTURE_TYPE_P; rce->qscale = rce->new_qscale = FF_QP2LAMBDA * 2; rce->misc_bits = s->mb_num + 10; rce->mb_var_sum = s->mb_num * 100; } p = s->avctx->stats_in; for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) { RateControlEntry *rce; int picture_number; int e; char *next; next = strchr(p, ';'); if (next) { (*next) = 0; next++; } e = sscanf(p, "" in:%d "", &picture_number); assert(picture_number >= 0); assert(picture_number < rcc->num_entries); rce = &rcc->entry[picture_number]; <S2SV_StartVul> e += sscanf(p, "" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d"", <S2SV_EndVul> &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits, &rce->mv_bits, &rce->misc_bits, &rce->f_code, &rce->b_code, &rce->mc_mb_var_sum, &rce->mb_var_sum, &rce->i_count, &rce->skip_count, &rce->header_bits); if (e != 14) { av_log(s->avctx, AV_LOG_ERROR, ""statistics are damaged at line %d, parser out=%d\n"", i, e); return -1; } p = next; } if (init_pass2(s) < 0) return -1; if ((s->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) { #if CONFIG_LIBXVID return ff_xvid_rate_control_init(s); #else av_log(s->avctx, AV_LOG_ERROR, ""Xvid ratecontrol requires libavcodec compiled with Xvid support.\n""); return -1; #endif } } if (!(s->flags & CODEC_FLAG_PASS2)) { rcc->short_term_qsum = 0.001; rcc->short_term_qcount = 0.001; rcc->pass1_rc_eq_output_sum = 0.001; rcc->pass1_wanted_bits = 0.001; if (s->avctx->qblur > 1.0) { av_log(s->avctx, AV_LOG_ERROR, ""qblur too large\n""); return -1; } if (s->avctx->rc_initial_cplx) { for (i = 0; i < 60 * 30; i++) { double bits = s->avctx->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num; RateControlEntry rce; if (i % ((s->gop_size + 3) / 4) == 0) rce.pict_type = AV_PICTURE_TYPE_I; else if (i % (s->max_b_frames + 1)) rce.pict_type = AV_PICTURE_TYPE_B; else rce.pict_type = AV_PICTURE_TYPE_P; rce.new_pict_type = rce.pict_type; rce.mc_mb_var_sum = bits * s->mb_num / 100000; rce.mb_var_sum = s->mb_num; rce.qscale = FF_QP2LAMBDA * 2; rce.f_code = 2; rce.b_code = 1; rce.misc_bits = 1; if (s->pict_type == AV_PICTURE_TYPE_I) { rce.i_count = s->mb_num; rce.i_tex_bits = bits; rce.p_tex_bits = 0; rce.mv_bits = 0; } else { rce.i_count = 0; rce.i_tex_bits = 0; rce.p_tex_bits = bits * 0.9; rce.mv_bits = bits * 0.1; } rcc->i_cplx_sum[rce.pict_type] += rce.i_tex_bits * rce.qscale; rcc->p_cplx_sum[rce.pict_type] += rce.p_tex_bits * rce.qscale; rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits; rcc->frame_count[rce.pict_type]++; get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i); rcc->pass1_wanted_bits += s->bit_rate / get_fps(s->avctx); } } } return 0; }","- e += sscanf(p, "" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d"",
+ e += sscanf(p, "" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%""SCNd64"" var:%""SCNd64"" icount:%d skipcount:%d hbits:%d"",","int ff_rate_control_init(MpegEncContext *s) { RateControlContext *rcc = &s->rc_context; int i, res; static const char * const const_names[] = { ""PI"", ""E"", ""iTex"", ""pTex"", ""tex"", ""mv"", ""fCode"", ""iCount"", ""mcVar"", ""var"", ""isI"", ""isP"", ""isB"", ""avgQP"", ""qComp"", #if 0 ""lastIQP"", ""lastPQP"", ""lastBQP"", ""nextNonBQP"", #endif ""avgIITex"", ""avgPITex"", ""avgPPTex"", ""avgBPTex"", ""avgTex"", NULL }; static double (* const func1[])(void *, double) = { (void *)bits2qp, (void *)qp2bits, NULL }; static const char * const func1_names[] = { ""bits2qp"", ""qp2bits"", NULL }; emms_c(); if (!s->avctx->rc_max_available_vbv_use && s->avctx->rc_buffer_size) { if (s->avctx->rc_max_rate) { s->avctx->rc_max_available_vbv_use = av_clipf(s->avctx->rc_max_rate/(s->avctx->rc_buffer_size*get_fps(s->avctx)), 1.0/3, 1.0); } else s->avctx->rc_max_available_vbv_use = 1.0; } res = av_expr_parse(&rcc->rc_eq_eval, s->avctx->rc_eq ? s->avctx->rc_eq : ""tex^qComp"", const_names, func1_names, func1, NULL, NULL, 0, s->avctx); if (res < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Error parsing rc_eq \""%s\""\n"", s->avctx->rc_eq); return res; } for (i = 0; i < 5; i++) { rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0; rcc->pred[i].count = 1.0; rcc->pred[i].decay = 0.4; rcc->i_cplx_sum [i] = rcc->p_cplx_sum [i] = rcc->mv_bits_sum[i] = rcc->qscale_sum [i] = rcc->frame_count[i] = 1; rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5; } rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy; if (!rcc->buffer_index) rcc->buffer_index = s->avctx->rc_buffer_size * 3 / 4; if (s->flags & CODEC_FLAG_PASS2) { int i; char *p; p = s->avctx->stats_in; for (i = -1; p; i++) p = strchr(p + 1, ';'); i += s->max_b_frames; if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry)) return -1; rcc->entry = av_mallocz(i * sizeof(RateControlEntry)); rcc->num_entries = i; for (i = 0; i < rcc->num_entries; i++) { RateControlEntry *rce = &rcc->entry[i]; rce->pict_type = rce->new_pict_type = AV_PICTURE_TYPE_P; rce->qscale = rce->new_qscale = FF_QP2LAMBDA * 2; rce->misc_bits = s->mb_num + 10; rce->mb_var_sum = s->mb_num * 100; } p = s->avctx->stats_in; for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) { RateControlEntry *rce; int picture_number; int e; char *next; next = strchr(p, ';'); if (next) { (*next) = 0; next++; } e = sscanf(p, "" in:%d "", &picture_number); assert(picture_number >= 0); assert(picture_number < rcc->num_entries); rce = &rcc->entry[picture_number]; e += sscanf(p, "" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%""SCNd64"" var:%""SCNd64"" icount:%d skipcount:%d hbits:%d"", &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits, &rce->mv_bits, &rce->misc_bits, &rce->f_code, &rce->b_code, &rce->mc_mb_var_sum, &rce->mb_var_sum, &rce->i_count, &rce->skip_count, &rce->header_bits); if (e != 14) { av_log(s->avctx, AV_LOG_ERROR, ""statistics are damaged at line %d, parser out=%d\n"", i, e); return -1; } p = next; } if (init_pass2(s) < 0) return -1; if ((s->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) { #if CONFIG_LIBXVID return ff_xvid_rate_control_init(s); #else av_log(s->avctx, AV_LOG_ERROR, ""Xvid ratecontrol requires libavcodec compiled with Xvid support.\n""); return -1; #endif } } if (!(s->flags & CODEC_FLAG_PASS2)) { rcc->short_term_qsum = 0.001; rcc->short_term_qcount = 0.001; rcc->pass1_rc_eq_output_sum = 0.001; rcc->pass1_wanted_bits = 0.001; if (s->avctx->qblur > 1.0) { av_log(s->avctx, AV_LOG_ERROR, ""qblur too large\n""); return -1; } if (s->avctx->rc_initial_cplx) { for (i = 0; i < 60 * 30; i++) { double bits = s->avctx->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num; RateControlEntry rce; if (i % ((s->gop_size + 3) / 4) == 0) rce.pict_type = AV_PICTURE_TYPE_I; else if (i % (s->max_b_frames + 1)) rce.pict_type = AV_PICTURE_TYPE_B; else rce.pict_type = AV_PICTURE_TYPE_P; rce.new_pict_type = rce.pict_type; rce.mc_mb_var_sum = bits * s->mb_num / 100000; rce.mb_var_sum = s->mb_num; rce.qscale = FF_QP2LAMBDA * 2; rce.f_code = 2; rce.b_code = 1; rce.misc_bits = 1; if (s->pict_type == AV_PICTURE_TYPE_I) { rce.i_count = s->mb_num; rce.i_tex_bits = bits; rce.p_tex_bits = 0; rce.mv_bits = 0; } else { rce.i_count = 0; rce.i_tex_bits = 0; rce.p_tex_bits = bits * 0.9; rce.mv_bits = bits * 0.1; } rcc->i_cplx_sum[rce.pict_type] += rce.i_tex_bits * rce.qscale; rcc->p_cplx_sum[rce.pict_type] += rce.p_tex_bits * rce.qscale; rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits; rcc->frame_count[rce.pict_type]++; get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i); rcc->pass1_wanted_bits += s->bit_rate / get_fps(s->avctx); } } } return 0; }"
13181----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_66ad9310ee77f7d6434e8a1896edd109d571c116_1.json----OPENSSL_sk_delete,"void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc) { <S2SV_StartVul> const char *ret; <S2SV_EndVul> if (st == NULL || loc < 0 || loc >= st->num) return NULL; ret = st->data[loc]; if (loc != st->num - 1) memmove(&st->data[loc], &st->data[loc + 1], sizeof(st->data[0]) * (st->num - loc - 1)); st->num--; return (void *)ret; }","- const char *ret;
+ const void *ret;","void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc) { const void *ret; if (st == NULL || loc < 0 || loc >= st->num) return NULL; ret = st->data[loc]; if (loc != st->num - 1) memmove(&st->data[loc], &st->data[loc + 1], sizeof(st->data[0]) * (st->num - loc - 1)); st->num--; return (void *)ret; }"
3724----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_c8509f2b90f9aa8861a18c05e97f2bab35d68024_1.json----calculate_bitrate,"static int calculate_bitrate(AVFormatContext *s) { AVIContext *avi = s->priv_data; int i, j; int64_t lensum = 0; int64_t maxpos = 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; if (!st->nb_index_entries) continue; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; maxpos = FFMAX(maxpos, st->index_entries[j-1].pos); lensum += len; } if (maxpos < avi->io_fsize*9/10) return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) return 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; int64_t duration; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; if (st->nb_index_entries < 2 || st->codec->bit_rate > 0) continue; duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp; <S2SV_StartVul> st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num); <S2SV_EndVul> } return 1; }","- st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);
+ int64_t bitrate;
+ bitrate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);
+ if (bitrate <= INT_MAX && bitrate > 0) {
+ st->codec->bit_rate = bitrate;
+ }","static int calculate_bitrate(AVFormatContext *s) { AVIContext *avi = s->priv_data; int i, j; int64_t lensum = 0; int64_t maxpos = 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; if (!st->nb_index_entries) continue; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; maxpos = FFMAX(maxpos, st->index_entries[j-1].pos); lensum += len; } if (maxpos < avi->io_fsize*9/10) return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) return 0; for (i = 0; i<s->nb_streams; i++) { int64_t len = 0; AVStream *st = s->streams[i]; int64_t duration; int64_t bitrate; for (j = 0; j < st->nb_index_entries; j++) len += st->index_entries[j].size; if (st->nb_index_entries < 2 || st->codec->bit_rate > 0) continue; duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp; bitrate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num); if (bitrate <= INT_MAX && bitrate > 0) { st->codec->bit_rate = bitrate; } } return 1; }"
1154----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3eeaeb56edfdc114edb0514a66b59925360071bf_1.json----hevc_loop_filter_luma_8,"static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix, ptrdiff_t _xstride, ptrdiff_t _ystride, <S2SV_StartVul> int *_beta, int *_tc, <S2SV_EndVul> uint8_t *_no_p, uint8_t *_no_q) { int d, j; pixel *pix = (pixel *)_pix; ptrdiff_t xstride = _xstride / sizeof(pixel); ptrdiff_t ystride = _ystride / sizeof(pixel); for (j = 0; j < 2; j++) { const int dp0 = abs(P2 - 2 * P1 + P0); const int dq0 = abs(Q2 - 2 * Q1 + Q0); const int dp3 = abs(TP2 - 2 * TP1 + TP0); const int dq3 = abs(TQ2 - 2 * TQ1 + TQ0); const int d0 = dp0 + dq0; const int d3 = dp3 + dq3; <S2SV_StartVul> const int beta = _beta[j] << (BIT_DEPTH - 8); <S2SV_EndVul> const int tc = _tc[j] << (BIT_DEPTH - 8); const int no_p = _no_p[j]; const int no_q = _no_q[j]; if (d0 + d3 >= beta) { pix += 4 * ystride; continue; } else { const int beta_3 = beta >> 3; const int beta_2 = beta >> 2; const int tc25 = ((tc * 5 + 1) >> 1); if (abs(P3 - P0) + abs(Q3 - Q0) < beta_3 && abs(P0 - Q0) < tc25 && abs(TP3 - TP0) + abs(TQ3 - TQ0) < beta_3 && abs(TP0 - TQ0) < tc25 && (d0 << 1) < beta_2 && (d3 << 1) < beta_2) { const int tc2 = tc << 1; for (d = 0; d < 4; d++) { const int p3 = P3; const int p2 = P2; const int p1 = P1; const int p0 = P0; const int q0 = Q0; const int q1 = Q1; const int q2 = Q2; const int q3 = Q3; if (!no_p) { P0 = p0 + av_clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3) - p0, -tc2, tc2); P1 = p1 + av_clip(((p2 + p1 + p0 + q0 + 2) >> 2) - p1, -tc2, tc2); P2 = p2 + av_clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3) - p2, -tc2, tc2); } if (!no_q) { Q0 = q0 + av_clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3) - q0, -tc2, tc2); Q1 = q1 + av_clip(((p0 + q0 + q1 + q2 + 2) >> 2) - q1, -tc2, tc2); Q2 = q2 + av_clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3) - q2, -tc2, tc2); } pix += ystride; } } else { int nd_p = 1; int nd_q = 1; const int tc_2 = tc >> 1; if (dp0 + dp3 < ((beta + (beta >> 1)) >> 3)) nd_p = 2; if (dq0 + dq3 < ((beta + (beta >> 1)) >> 3)) nd_q = 2; for (d = 0; d < 4; d++) { const int p2 = P2; const int p1 = P1; const int p0 = P0; const int q0 = Q0; const int q1 = Q1; const int q2 = Q2; int delta0 = (9 * (q0 - p0) - 3 * (q1 - p1) + 8) >> 4; if (abs(delta0) < 10 * tc) { delta0 = av_clip(delta0, -tc, tc); if (!no_p) P0 = av_clip_pixel(p0 + delta0); if (!no_q) Q0 = av_clip_pixel(q0 - delta0); if (!no_p && nd_p > 1) { const int deltap1 = av_clip((((p2 + p0 + 1) >> 1) - p1 + delta0) >> 1, -tc_2, tc_2); P1 = av_clip_pixel(p1 + deltap1); } if (!no_q && nd_q > 1) { const int deltaq1 = av_clip((((q2 + q0 + 1) >> 1) - q1 - delta0) >> 1, -tc_2, tc_2); Q1 = av_clip_pixel(q1 + deltaq1); } } pix += ystride; } } } } }","- int *_beta, int *_tc,
- const int beta = _beta[j] << (BIT_DEPTH - 8);
+ int beta, int *_tc,
+ beta <<= BIT_DEPTH - 8;","static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix, ptrdiff_t _xstride, ptrdiff_t _ystride, int beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q) { int d, j; pixel *pix = (pixel *)_pix; ptrdiff_t xstride = _xstride / sizeof(pixel); ptrdiff_t ystride = _ystride / sizeof(pixel); beta <<= BIT_DEPTH - 8; for (j = 0; j < 2; j++) { const int dp0 = abs(P2 - 2 * P1 + P0); const int dq0 = abs(Q2 - 2 * Q1 + Q0); const int dp3 = abs(TP2 - 2 * TP1 + TP0); const int dq3 = abs(TQ2 - 2 * TQ1 + TQ0); const int d0 = dp0 + dq0; const int d3 = dp3 + dq3; const int tc = _tc[j] << (BIT_DEPTH - 8); const int no_p = _no_p[j]; const int no_q = _no_q[j]; if (d0 + d3 >= beta) { pix += 4 * ystride; continue; } else { const int beta_3 = beta >> 3; const int beta_2 = beta >> 2; const int tc25 = ((tc * 5 + 1) >> 1); if (abs(P3 - P0) + abs(Q3 - Q0) < beta_3 && abs(P0 - Q0) < tc25 && abs(TP3 - TP0) + abs(TQ3 - TQ0) < beta_3 && abs(TP0 - TQ0) < tc25 && (d0 << 1) < beta_2 && (d3 << 1) < beta_2) { const int tc2 = tc << 1; for (d = 0; d < 4; d++) { const int p3 = P3; const int p2 = P2; const int p1 = P1; const int p0 = P0; const int q0 = Q0; const int q1 = Q1; const int q2 = Q2; const int q3 = Q3; if (!no_p) { P0 = p0 + av_clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3) - p0, -tc2, tc2); P1 = p1 + av_clip(((p2 + p1 + p0 + q0 + 2) >> 2) - p1, -tc2, tc2); P2 = p2 + av_clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3) - p2, -tc2, tc2); } if (!no_q) { Q0 = q0 + av_clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3) - q0, -tc2, tc2); Q1 = q1 + av_clip(((p0 + q0 + q1 + q2 + 2) >> 2) - q1, -tc2, tc2); Q2 = q2 + av_clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3) - q2, -tc2, tc2); } pix += ystride; } } else { int nd_p = 1; int nd_q = 1; const int tc_2 = tc >> 1; if (dp0 + dp3 < ((beta + (beta >> 1)) >> 3)) nd_p = 2; if (dq0 + dq3 < ((beta + (beta >> 1)) >> 3)) nd_q = 2; for (d = 0; d < 4; d++) { const int p2 = P2; const int p1 = P1; const int p0 = P0; const int q0 = Q0; const int q1 = Q1; const int q2 = Q2; int delta0 = (9 * (q0 - p0) - 3 * (q1 - p1) + 8) >> 4; if (abs(delta0) < 10 * tc) { delta0 = av_clip(delta0, -tc, tc); if (!no_p) P0 = av_clip_pixel(p0 + delta0); if (!no_q) Q0 = av_clip_pixel(q0 - delta0); if (!no_p && nd_p > 1) { const int deltap1 = av_clip((((p2 + p0 + 1) >> 1) - p1 + delta0) >> 1, -tc_2, tc_2); P1 = av_clip_pixel(p1 + deltap1); } if (!no_q && nd_q > 1) { const int deltaq1 = av_clip((((q2 + q0 + 1) >> 1) - q1 - delta0) >> 1, -tc_2, tc_2); Q1 = av_clip_pixel(q1 + deltaq1); } } pix += ystride; } } } } }"
2736----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_95fdf3b8e74ed7632fc16e543e0041b3b7a719d9_1.json----RENAME,"static int RENAME(resample_common)(ResampleContext *c, <S2SV_StartVul> DELEM *dst, const DELEM *src, <S2SV_EndVul> int n, int update_ctx) { int dst_index; int index= c->index; int frac= c->frac; int sample_index = index >> c->phase_shift; index &= c->phase_mask; for (dst_index = 0; dst_index < n; dst_index++) { FELEM *filter = ((FELEM *) c->filter_bank) + c->filter_alloc * index; FELEM2 val=0; int i; for (i = 0; i < c->filter_length; i++) { val += src[sample_index + i] * (FELEM2)filter[i]; } OUT(dst[dst_index], val); frac += c->dst_incr_mod; index += c->dst_incr_div; if (frac >= c->src_incr) { frac -= c->src_incr; index++; } sample_index += index >> c->phase_shift; index &= c->phase_mask; } if(update_ctx){ c->frac= frac; c->index= index; } return sample_index; }","- DELEM *dst, const DELEM *src,
+ void *dest, const void *source,
+ DELEM *dst = dest;
+ const DELEM *src = source;","static int RENAME(resample_common)(ResampleContext *c, void *dest, const void *source, int n, int update_ctx) { DELEM *dst = dest; const DELEM *src = source; int dst_index; int index= c->index; int frac= c->frac; int sample_index = index >> c->phase_shift; index &= c->phase_mask; for (dst_index = 0; dst_index < n; dst_index++) { FELEM *filter = ((FELEM *) c->filter_bank) + c->filter_alloc * index; FELEM2 val=0; int i; for (i = 0; i < c->filter_length; i++) { val += src[sample_index + i] * (FELEM2)filter[i]; } OUT(dst[dst_index], val); frac += c->dst_incr_mod; index += c->dst_incr_div; if (frac >= c->src_incr) { frac -= c->src_incr; index++; } sample_index += index >> c->phase_shift; index &= c->phase_mask; } if(update_ctx){ c->frac= frac; c->index= index; } return sample_index; }"
434----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_18cb71162f5a52881ba3481f8f20296b9587049e_1.json----ff_interleave_add_packet,"<S2SV_StartVul> void ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt, <S2SV_EndVul> <S2SV_StartVul> int (*compare)(AVFormatContext *, AVPacket *, AVPacket *)) <S2SV_EndVul> { AVPacketList **next_point, *this_pktl; this_pktl = av_mallocz(sizeof(AVPacketList)); this_pktl->pkt = *pkt; #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS pkt->destruct = NULL; FF_ENABLE_DEPRECATION_WARNINGS #endif pkt->buf = NULL; <S2SV_StartVul> av_dup_packet(&this_pktl->pkt); if (s->streams[pkt->stream_index]->last_in_packet_buffer) { next_point = &(s->streams[pkt->stream_index]->last_in_packet_buffer->next); } else next_point = &s->packet_buffer; if (*next_point) { if (compare(s, &s->packet_buffer_end->pkt, pkt)) { while (!compare(s, &(*next_point)->pkt, pkt)) next_point = &(*next_point)->next; goto next_non_null; } else { next_point = &(s->packet_buffer_end->next); } } assert(!*next_point); s->packet_buffer_end = this_pktl; next_non_null: this_pktl->next = *next_point; s->streams[pkt->stream_index]->last_in_packet_buffer = *next_point = this_pktl; }","- void ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,
- int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))
- av_dup_packet(&this_pktl->pkt); // duplicate the packet if it uses non-alloced memory
+ int ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,
+ int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))
+ int ret;
+ if (!this_pktl)
+ return AVERROR(ENOMEM);
+ if ((ret = av_dup_packet(&this_pktl->pkt)) < 0) {
+ av_free(this_pktl);
+ return ret;
+ }
+ return 0;","int ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt, int (*compare)(AVFormatContext *, AVPacket *, AVPacket *)) { int ret; AVPacketList **next_point, *this_pktl; this_pktl = av_mallocz(sizeof(AVPacketList)); if (!this_pktl) return AVERROR(ENOMEM); this_pktl->pkt = *pkt; #if FF_API_DESTRUCT_PACKET FF_DISABLE_DEPRECATION_WARNINGS pkt->destruct = NULL; FF_ENABLE_DEPRECATION_WARNINGS #endif pkt->buf = NULL; if ((ret = av_dup_packet(&this_pktl->pkt)) < 0) { av_free(this_pktl); return ret; } if (s->streams[pkt->stream_index]->last_in_packet_buffer) { next_point = &(s->streams[pkt->stream_index]->last_in_packet_buffer->next); } else next_point = &s->packet_buffer; if (*next_point) { if (compare(s, &s->packet_buffer_end->pkt, pkt)) { while (!compare(s, &(*next_point)->pkt, pkt)) next_point = &(*next_point)->next; goto next_non_null; } else { next_point = &(s->packet_buffer_end->next); } } assert(!*next_point); s->packet_buffer_end = this_pktl; next_non_null: this_pktl->next = *next_point; s->streams[pkt->stream_index]->last_in_packet_buffer = *next_point = this_pktl; return 0; }"
4356----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ebd388d38fb8ade2e3444ee6c5a66b9a190f2475_1.json----oma_read_packet,"static int oma_read_packet(AVFormatContext *s, AVPacket *pkt) { OMAContext *oc = s->priv_data; AVStream *st = s->streams[0]; int packet_size = st->codec->block_align; int byte_rate = st->codec->bit_rate >> 3; int64_t pos = avio_tell(s->pb); int ret = av_get_packet(s->pb, pkt, packet_size); if (ret < packet_size) pkt->flags |= AV_PKT_FLAG_CORRUPT; if (ret < 0) return ret; if (!ret) return AVERROR_EOF; pkt->stream_index = 0; <S2SV_StartVul> if (pos > 0) { <S2SV_EndVul> pkt->pts = pkt->dts = av_rescale(pos, st->time_base.den, byte_rate * (int64_t)st->time_base.num); } if (oc->encrypted) { if (ret == packet_size) av_des_crypt(&oc->av_des, pkt->data, pkt->data, (packet_size >> 3), oc->iv, 1); else memset(oc->iv, 0, 8); } return ret; }","- if (pos > 0) {
+ if (pos > 0 && byte_rate > 0) {","static int oma_read_packet(AVFormatContext *s, AVPacket *pkt) { OMAContext *oc = s->priv_data; AVStream *st = s->streams[0]; int packet_size = st->codec->block_align; int byte_rate = st->codec->bit_rate >> 3; int64_t pos = avio_tell(s->pb); int ret = av_get_packet(s->pb, pkt, packet_size); if (ret < packet_size) pkt->flags |= AV_PKT_FLAG_CORRUPT; if (ret < 0) return ret; if (!ret) return AVERROR_EOF; pkt->stream_index = 0; if (pos > 0 && byte_rate > 0) { pkt->pts = pkt->dts = av_rescale(pos, st->time_base.den, byte_rate * (int64_t)st->time_base.num); } if (oc->encrypted) { if (ret == packet_size) av_des_crypt(&oc->av_des, pkt->data, pkt->data, (packet_size >> 3), oc->iv, 1); else memset(oc->iv, 0, 8); } return ret; }"
13061----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6258fdeffa51308853b3eb5ab70f5bedc8ad6304_1.json----tls1_cbc_remove_padding,"int tls1_cbc_remove_padding(const SSL* s, SSL3_RECORD *rec, unsigned block_size, unsigned mac_size) { unsigned padding_length, good, to_check, i; const char has_explicit_iv = s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION; const unsigned overhead = 1 + mac_size + (has_explicit_iv ? block_size : 0); if (overhead > rec->length) return 0; padding_length = rec->data[rec->length-1]; if ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand) { if ((memcmp(s->s3->read_sequence, ""\0\0\0\0\0\0\0\0"",8) == 0) && !(padding_length & 1)) { s->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG; } if ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) && padding_length > 0) { padding_length--; } } good = constant_time_ge(rec->length, overhead+padding_length); to_check = 255; if (to_check > rec->length-1) to_check = rec->length-1; for (i = 0; i < to_check; i++) { unsigned char mask = constant_time_ge(padding_length, i); unsigned char b = rec->data[rec->length-1-i]; good &= ~(mask&(padding_length ^ b)); } good &= good >> 4; good &= good >> 2; good &= good >> 1; good <<= sizeof(good)*8-1; good = DUPLICATE_MSB_TO_ALL(good); padding_length = good & (padding_length+1); rec->length -= padding_length; rec->type |= padding_length<<8; <S2SV_EndVul> <S2SV_StartVul> if (has_explicit_iv) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> rec->data += block_size; <S2SV_EndVul> <S2SV_StartVul> rec->input += block_size; <S2SV_EndVul> <S2SV_StartVul> rec->length -= block_size; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> return (int)((good & 1) | (~good & -1)); }","- if (has_explicit_iv)
- {
- rec->data += block_size;
- rec->input += block_size;
- rec->length -= block_size;
- }
+ if (has_explicit_iv)
+ {
+ rec->data += block_size;
+ rec->input += block_size;
+ rec->length -= block_size;
+ }
+ if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)
+ {
+ rec->length -= padding_length;
+ return 1;
+ }","int tls1_cbc_remove_padding(const SSL* s, SSL3_RECORD *rec, unsigned block_size, unsigned mac_size) { unsigned padding_length, good, to_check, i; const char has_explicit_iv = s->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION; const unsigned overhead = 1 + mac_size + (has_explicit_iv ? block_size : 0); if (overhead > rec->length) return 0; if (has_explicit_iv) { rec->data += block_size; rec->input += block_size; rec->length -= block_size; } padding_length = rec->data[rec->length-1]; if ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand) { if ((memcmp(s->s3->read_sequence, ""\0\0\0\0\0\0\0\0"",8) == 0) && !(padding_length & 1)) { s->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG; } if ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) && padding_length > 0) { padding_length--; } } if (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER) { rec->length -= padding_length; return 1; } good = constant_time_ge(rec->length, overhead+padding_length); to_check = 255; if (to_check > rec->length-1) to_check = rec->length-1; for (i = 0; i < to_check; i++) { unsigned char mask = constant_time_ge(padding_length, i); unsigned char b = rec->data[rec->length-1-i]; good &= ~(mask&(padding_length ^ b)); } good &= good >> 4; good &= good >> 2; good &= good >> 1; good <<= sizeof(good)*8-1; good = DUPLICATE_MSB_TO_ALL(good); padding_length = good & (padding_length+1); rec->length -= padding_length; rec->type |= padding_length<<8; return (int)((good & 1) | (~good & -1)); }"
11539----DANGLING_POINTER_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2dc577bc6beabe3d277ce39990048594fd2ee115_1.json----EVP_MAC_name,const char *EVP_MAC_name(const EVP_MAC *mac) { <S2SV_StartVul> return mac->name; <S2SV_EndVul> },"- return mac->name;
+ return evp_first_name(mac->prov, mac->name_id);","const char *EVP_MAC_name(const EVP_MAC *mac) { return evp_first_name(mac->prov, mac->name_id); }"
7547----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_994e6e5cace56cfdeda5b9ce1a4a5d9df5f28150_1.json----av_get_channel_layout_nb_channels,<S2SV_StartVul> int av_get_channel_layout_nb_channels(int64_t channel_layout) <S2SV_EndVul> { int count; uint64_t x = channel_layout; for (count = 0; x; count++) x &= x-1; return count; },"- int av_get_channel_layout_nb_channels(int64_t channel_layout)
+ int av_get_channel_layout_nb_channels(uint64_t channel_layout)",int av_get_channel_layout_nb_channels(uint64_t channel_layout) { int count; uint64_t x = channel_layout; for (count = 0; x; count++) x &= x-1; return count; }
2805----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_99ac503dd75ed857c3b37ee47ae0990dc0bd396b_1.json----find_best_filter,"static int64_t find_best_filter(const DCAADPCMEncContext *s, const int32_t *in, int len) { const premultiplied_coeffs *precalc_data = s->private_data; int i, j, k = 0; <S2SV_StartVul> int vq; <S2SV_EndVul> int64_t err; int64_t min_err = 1ll << 62; int64_t corr[15]; for (i = 0; i <= DCA_ADPCM_COEFFS; i++) for (j = i; j <= DCA_ADPCM_COEFFS; j++) corr[k++] = calc_corr(in+4, len, i, j); for (i = 0; i < DCA_ADPCM_VQCODEBOOK_SZ; i++) { err = apply_filter(ff_dca_adpcm_vb[i], corr, *precalc_data); if (err < min_err) { min_err = err; vq = i; } precalc_data++; } return vq; }","- int vq;
+ int vq = -1;","static int64_t find_best_filter(const DCAADPCMEncContext *s, const int32_t *in, int len) { const premultiplied_coeffs *precalc_data = s->private_data; int i, j, k = 0; int vq = -1; int64_t err; int64_t min_err = 1ll << 62; int64_t corr[15]; for (i = 0; i <= DCA_ADPCM_COEFFS; i++) for (j = i; j <= DCA_ADPCM_COEFFS; j++) corr[k++] = calc_corr(in+4, len, i, j); for (i = 0; i < DCA_ADPCM_VQCODEBOOK_SZ; i++) { err = apply_filter(ff_dca_adpcm_vb[i], corr, *precalc_data); if (err < min_err) { min_err = err; vq = i; } precalc_data++; } return vq; }"
2730----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_95c01c5ffa82ba2594534b0753d9db773b594f63_1.json----dnxhd_decode_frame,"static int dnxhd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; DNXHDContext *ctx = avctx->priv_data; ThreadFrame frame = { .f = data }; AVFrame *picture = data; int first_field = 1; int ret, i; ff_dlog(avctx, ""frame size %d\n"", buf_size); decode_coding_unit: if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0) return ret; if ((avctx->width || avctx->height) && (ctx->width != avctx->width || ctx->height != avctx->height)) { av_log(avctx, AV_LOG_WARNING, ""frame size changed: %dx%d -> %dx%d\n"", avctx->width, avctx->height, ctx->width, ctx->height); first_field = 1; } if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) { av_log(avctx, AV_LOG_WARNING, ""pix_fmt changed: %s -> %s\n"", av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt)); first_field = 1; } avctx->pix_fmt = ctx->pix_fmt; ret = ff_set_dimensions(avctx, ctx->width, ctx->height); if (ret < 0) return ret; if (first_field) { if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; picture->pict_type = AV_PICTURE_TYPE_I; picture->key_frame = 1; } <S2SV_StartVul> ctx->buf_size = buf_size - 0x280; <S2SV_EndVul> <S2SV_StartVul> ctx->buf = buf + 0x280; <S2SV_EndVul> avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height); if (first_field && picture->interlaced_frame) { buf += ctx->cid_table->coding_unit_size; buf_size -= ctx->cid_table->coding_unit_size; first_field = 0; goto decode_coding_unit; } ret = 0; for (i = 0; i < avctx->thread_count; i++) { ret += ctx->rows[i].errors; ctx->rows[i].errors = 0; } if (ret) { av_log(ctx->avctx, AV_LOG_ERROR, ""%d lines with errors\n"", ret); return AVERROR_INVALIDDATA; } *got_frame = 1; return avpkt->size; }","- ctx->buf_size = buf_size - 0x280;
- ctx->buf = buf + 0x280;
+ ctx->buf_size = buf_size - ctx->data_offset;
+ ctx->buf = buf + ctx->data_offset;","static int dnxhd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; DNXHDContext *ctx = avctx->priv_data; ThreadFrame frame = { .f = data }; AVFrame *picture = data; int first_field = 1; int ret, i; ff_dlog(avctx, ""frame size %d\n"", buf_size); decode_coding_unit: if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0) return ret; if ((avctx->width || avctx->height) && (ctx->width != avctx->width || ctx->height != avctx->height)) { av_log(avctx, AV_LOG_WARNING, ""frame size changed: %dx%d -> %dx%d\n"", avctx->width, avctx->height, ctx->width, ctx->height); first_field = 1; } if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) { av_log(avctx, AV_LOG_WARNING, ""pix_fmt changed: %s -> %s\n"", av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt)); first_field = 1; } avctx->pix_fmt = ctx->pix_fmt; ret = ff_set_dimensions(avctx, ctx->width, ctx->height); if (ret < 0) return ret; if (first_field) { if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; picture->pict_type = AV_PICTURE_TYPE_I; picture->key_frame = 1; } ctx->buf_size = buf_size - ctx->data_offset; ctx->buf = buf + ctx->data_offset; avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height); if (first_field && picture->interlaced_frame) { buf += ctx->cid_table->coding_unit_size; buf_size -= ctx->cid_table->coding_unit_size; first_field = 0; goto decode_coding_unit; } ret = 0; for (i = 0; i < avctx->thread_count; i++) { ret += ctx->rows[i].errors; ctx->rows[i].errors = 0; } if (ret) { av_log(ctx->avctx, AV_LOG_ERROR, ""%d lines with errors\n"", ret); return AVERROR_INVALIDDATA; } *got_frame = 1; return avpkt->size; }"
4996----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_034702df8e1951f18d998cc657c2330c1a86ed98_1.json----has_decode_delay_been_guessed,static int has_decode_delay_been_guessed(AVStream *st) { return st->codec->codec_id != CODEC_ID_H264 || <S2SV_StartVul> st->codec_info_nb_frames >= 6 + st->codec->has_b_frames; <S2SV_EndVul> },"- st->codec_info_nb_frames >= 6 + st->codec->has_b_frames;
+ st->info->nb_decoded_frames >= 6;",static int has_decode_delay_been_guessed(AVStream *st) { return st->codec->codec_id != CODEC_ID_H264 || st->info->nb_decoded_frames >= 6; }
562----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1f6e23ee894701106c59e794b0e36d9f3fd44aba_1.json----parse_nal_units,"static inline int parse_nal_units(AVCodecParserContext *s, const uint8_t *buf, int buf_size, AVCodecContext *avctx) { HEVCParserContext *ctx = s->priv_data; HEVCContext *h = &ctx->h; GetBitContext *gb; SliceHeader *sh = &h->sh; HEVCParamSets *ps = &h->ps; HEVCPacket *pkt = &ctx->pkt; const uint8_t *buf_end = buf + buf_size; int state = -1, i; HEVCNAL *nal; int is_global = buf == avctx->extradata; if (!h->HEVClc) h->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (!h->HEVClc) return AVERROR(ENOMEM); gb = &h->HEVClc->gb; s->pict_type = AV_PICTURE_TYPE_I; s->key_frame = 0; s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN; h->avctx = avctx; if (!buf_size) return 0; if (pkt->nals_allocated < 1) { HEVCNAL *tmp = av_realloc_array(pkt->nals, 1, sizeof(*tmp)); if (!tmp) return AVERROR(ENOMEM); pkt->nals = tmp; memset(pkt->nals, 0, sizeof(*tmp)); pkt->nals_allocated = 1; } nal = &pkt->nals[0]; for (;;) { int src_length, consumed; int ret; buf = avpriv_find_start_code(buf, buf_end, &state); if (--buf + 2 >= buf_end) break; src_length = buf_end - buf; h->nal_unit_type = (*buf >> 1) & 0x3f; h->temporal_id = (*(buf + 1) & 0x07) - 1; if (h->nal_unit_type <= NAL_CRA_NUT) { if (src_length > 20) src_length = 20; } <S2SV_StartVul> consumed = ff_hevc_extract_rbsp(NULL, buf, src_length, nal); <S2SV_EndVul> if (consumed < 0) return consumed; ret = init_get_bits8(gb, nal->data + 2, nal->size); if (ret < 0) return ret; switch (h->nal_unit_type) { case NAL_VPS: ff_hevc_decode_nal_vps(gb, avctx, ps); break; case NAL_SPS: ff_hevc_decode_nal_sps(gb, avctx, ps, 1); break; case NAL_PPS: ff_hevc_decode_nal_pps(gb, avctx, ps); break; case NAL_SEI_PREFIX: case NAL_SEI_SUFFIX: ff_hevc_decode_nal_sei(h); break; case NAL_TRAIL_N: case NAL_TRAIL_R: case NAL_TSA_N: case NAL_TSA_R: case NAL_STSA_N: case NAL_STSA_R: case NAL_RADL_N: case NAL_RADL_R: case NAL_RASL_N: case NAL_RASL_R: case NAL_BLA_W_LP: case NAL_BLA_W_RADL: case NAL_BLA_N_LP: case NAL_IDR_W_RADL: case NAL_IDR_N_LP: case NAL_CRA_NUT: if (is_global) { av_log(avctx, AV_LOG_ERROR, ""Invalid NAL unit: %d\n"", h->nal_unit_type); return AVERROR_INVALIDDATA; } sh->first_slice_in_pic_flag = get_bits1(gb); s->picture_structure = h->picture_struct; s->field_order = h->picture_struct; if (IS_IRAP(h)) { s->key_frame = 1; sh->no_output_of_prior_pics_flag = get_bits1(gb); } sh->pps_id = get_ue_golomb(gb); if (sh->pps_id >= MAX_PPS_COUNT || !ps->pps_list[sh->pps_id]) { av_log(avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id); return AVERROR_INVALIDDATA; } ps->pps = (HEVCPPS*)ps->pps_list[sh->pps_id]->data; if (ps->pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[ps->pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, ""SPS id out of range: %d\n"", ps->pps->sps_id); return AVERROR_INVALIDDATA; } if (ps->sps != (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data) { ps->sps = (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data; ps->vps = (HEVCVPS*)ps->vps_list[ps->sps->vps_id]->data; } if (!sh->first_slice_in_pic_flag) { int slice_address_length; if (ps->pps->dependent_slice_segments_enabled_flag) sh->dependent_slice_segment_flag = get_bits1(gb); else sh->dependent_slice_segment_flag = 0; slice_address_length = av_ceil_log2_c(ps->sps->ctb_width * ps->sps->ctb_height); sh->slice_segment_addr = get_bitsz(gb, slice_address_length); if (sh->slice_segment_addr >= ps->sps->ctb_width * ps->sps->ctb_height) { av_log(avctx, AV_LOG_ERROR, ""Invalid slice segment address: %u.\n"", sh->slice_segment_addr); return AVERROR_INVALIDDATA; } } else sh->dependent_slice_segment_flag = 0; if (sh->dependent_slice_segment_flag) break; for (i = 0; i < ps->pps->num_extra_slice_header_bits; i++) skip_bits(gb, 1); sh->slice_type = get_ue_golomb(gb); if (!(sh->slice_type == I_SLICE || sh->slice_type == P_SLICE || sh->slice_type == B_SLICE)) { av_log(avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"", sh->slice_type); return AVERROR_INVALIDDATA; } s->pict_type = sh->slice_type == B_SLICE ? AV_PICTURE_TYPE_B : sh->slice_type == P_SLICE ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I; if (ps->pps->output_flag_present_flag) sh->pic_output_flag = get_bits1(gb); if (ps->sps->separate_colour_plane_flag) sh->colour_plane_id = get_bits(gb, 2); if (!IS_IDR(h)) { sh->pic_order_cnt_lsb = get_bits(gb, ps->sps->log2_max_poc_lsb); s->output_picture_number = h->poc = ff_hevc_compute_poc(h, sh->pic_order_cnt_lsb); } else s->output_picture_number = h->poc = 0; if (h->temporal_id == 0 && h->nal_unit_type != NAL_TRAIL_N && h->nal_unit_type != NAL_TSA_N && h->nal_unit_type != NAL_STSA_N && h->nal_unit_type != NAL_RADL_N && h->nal_unit_type != NAL_RASL_N && h->nal_unit_type != NAL_RADL_R && h->nal_unit_type != NAL_RASL_R) h->pocTid0 = h->poc; return 0; } buf += consumed; } if (!is_global) av_log(h->avctx, AV_LOG_ERROR, ""missing picture in access unit\n""); return -1; }","- consumed = ff_hevc_extract_rbsp(NULL, buf, src_length, nal);
+ consumed = ff_hevc_extract_rbsp(buf, src_length, nal);","static inline int parse_nal_units(AVCodecParserContext *s, const uint8_t *buf, int buf_size, AVCodecContext *avctx) { HEVCParserContext *ctx = s->priv_data; HEVCContext *h = &ctx->h; GetBitContext *gb; SliceHeader *sh = &h->sh; HEVCParamSets *ps = &h->ps; HEVCPacket *pkt = &ctx->pkt; const uint8_t *buf_end = buf + buf_size; int state = -1, i; HEVCNAL *nal; int is_global = buf == avctx->extradata; if (!h->HEVClc) h->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (!h->HEVClc) return AVERROR(ENOMEM); gb = &h->HEVClc->gb; s->pict_type = AV_PICTURE_TYPE_I; s->key_frame = 0; s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN; h->avctx = avctx; if (!buf_size) return 0; if (pkt->nals_allocated < 1) { HEVCNAL *tmp = av_realloc_array(pkt->nals, 1, sizeof(*tmp)); if (!tmp) return AVERROR(ENOMEM); pkt->nals = tmp; memset(pkt->nals, 0, sizeof(*tmp)); pkt->nals_allocated = 1; } nal = &pkt->nals[0]; for (;;) { int src_length, consumed; int ret; buf = avpriv_find_start_code(buf, buf_end, &state); if (--buf + 2 >= buf_end) break; src_length = buf_end - buf; h->nal_unit_type = (*buf >> 1) & 0x3f; h->temporal_id = (*(buf + 1) & 0x07) - 1; if (h->nal_unit_type <= NAL_CRA_NUT) { if (src_length > 20) src_length = 20; } consumed = ff_hevc_extract_rbsp(buf, src_length, nal); if (consumed < 0) return consumed; ret = init_get_bits8(gb, nal->data + 2, nal->size); if (ret < 0) return ret; switch (h->nal_unit_type) { case NAL_VPS: ff_hevc_decode_nal_vps(gb, avctx, ps); break; case NAL_SPS: ff_hevc_decode_nal_sps(gb, avctx, ps, 1); break; case NAL_PPS: ff_hevc_decode_nal_pps(gb, avctx, ps); break; case NAL_SEI_PREFIX: case NAL_SEI_SUFFIX: ff_hevc_decode_nal_sei(h); break; case NAL_TRAIL_N: case NAL_TRAIL_R: case NAL_TSA_N: case NAL_TSA_R: case NAL_STSA_N: case NAL_STSA_R: case NAL_RADL_N: case NAL_RADL_R: case NAL_RASL_N: case NAL_RASL_R: case NAL_BLA_W_LP: case NAL_BLA_W_RADL: case NAL_BLA_N_LP: case NAL_IDR_W_RADL: case NAL_IDR_N_LP: case NAL_CRA_NUT: if (is_global) { av_log(avctx, AV_LOG_ERROR, ""Invalid NAL unit: %d\n"", h->nal_unit_type); return AVERROR_INVALIDDATA; } sh->first_slice_in_pic_flag = get_bits1(gb); s->picture_structure = h->picture_struct; s->field_order = h->picture_struct; if (IS_IRAP(h)) { s->key_frame = 1; sh->no_output_of_prior_pics_flag = get_bits1(gb); } sh->pps_id = get_ue_golomb(gb); if (sh->pps_id >= MAX_PPS_COUNT || !ps->pps_list[sh->pps_id]) { av_log(avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id); return AVERROR_INVALIDDATA; } ps->pps = (HEVCPPS*)ps->pps_list[sh->pps_id]->data; if (ps->pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[ps->pps->sps_id]) { av_log(avctx, AV_LOG_ERROR, ""SPS id out of range: %d\n"", ps->pps->sps_id); return AVERROR_INVALIDDATA; } if (ps->sps != (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data) { ps->sps = (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data; ps->vps = (HEVCVPS*)ps->vps_list[ps->sps->vps_id]->data; } if (!sh->first_slice_in_pic_flag) { int slice_address_length; if (ps->pps->dependent_slice_segments_enabled_flag) sh->dependent_slice_segment_flag = get_bits1(gb); else sh->dependent_slice_segment_flag = 0; slice_address_length = av_ceil_log2_c(ps->sps->ctb_width * ps->sps->ctb_height); sh->slice_segment_addr = get_bitsz(gb, slice_address_length); if (sh->slice_segment_addr >= ps->sps->ctb_width * ps->sps->ctb_height) { av_log(avctx, AV_LOG_ERROR, ""Invalid slice segment address: %u.\n"", sh->slice_segment_addr); return AVERROR_INVALIDDATA; } } else sh->dependent_slice_segment_flag = 0; if (sh->dependent_slice_segment_flag) break; for (i = 0; i < ps->pps->num_extra_slice_header_bits; i++) skip_bits(gb, 1); sh->slice_type = get_ue_golomb(gb); if (!(sh->slice_type == I_SLICE || sh->slice_type == P_SLICE || sh->slice_type == B_SLICE)) { av_log(avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"", sh->slice_type); return AVERROR_INVALIDDATA; } s->pict_type = sh->slice_type == B_SLICE ? AV_PICTURE_TYPE_B : sh->slice_type == P_SLICE ? AV_PICTURE_TYPE_P : AV_PICTURE_TYPE_I; if (ps->pps->output_flag_present_flag) sh->pic_output_flag = get_bits1(gb); if (ps->sps->separate_colour_plane_flag) sh->colour_plane_id = get_bits(gb, 2); if (!IS_IDR(h)) { sh->pic_order_cnt_lsb = get_bits(gb, ps->sps->log2_max_poc_lsb); s->output_picture_number = h->poc = ff_hevc_compute_poc(h, sh->pic_order_cnt_lsb); } else s->output_picture_number = h->poc = 0; if (h->temporal_id == 0 && h->nal_unit_type != NAL_TRAIL_N && h->nal_unit_type != NAL_TSA_N && h->nal_unit_type != NAL_STSA_N && h->nal_unit_type != NAL_RADL_N && h->nal_unit_type != NAL_RASL_N && h->nal_unit_type != NAL_RADL_R && h->nal_unit_type != NAL_RASL_R) h->pocTid0 = h->poc; return 0; } buf += consumed; } if (!is_global) av_log(h->avctx, AV_LOG_ERROR, ""missing picture in access unit\n""); return -1; }"
6048----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4041de4d6003f73a707bcdbb498cbbce705d4a40_1.json----ff_snappy_uncompress,"<S2SV_StartVul> int ff_snappy_uncompress(GetByteContext *gb, uint8_t **buf, int64_t *size) <S2SV_EndVul> { int64_t len = decode_len(gb); int ret = 0; uint8_t *p; if (len < 0) return len; <S2SV_StartVul> if ((ret = av_reallocp(buf, len)) < 0) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> *size = len; <S2SV_StartVul> p = *buf; <S2SV_EndVul> while (bytestream2_get_bytes_left(gb) > 0) { uint8_t s = bytestream2_get_byte(gb); int val = s >> 2; switch (s & 0x03) { case SNAPPY_LITERAL: ret = snappy_literal(gb, p, len, val); break; case SNAPPY_COPY_1: <S2SV_StartVul> ret = snappy_copy1(gb, *buf, p, len, val); <S2SV_EndVul> break; case SNAPPY_COPY_2: <S2SV_StartVul> ret = snappy_copy2(gb, *buf, p, len, val); <S2SV_EndVul> break; case SNAPPY_COPY_4: <S2SV_StartVul> ret = snappy_copy4(gb, *buf, p, len, val); <S2SV_EndVul> break; } if (ret < 0) return ret; p += ret; len -= ret; } return 0; }","- int ff_snappy_uncompress(GetByteContext *gb, uint8_t **buf, int64_t *size)
- if ((ret = av_reallocp(buf, len)) < 0)
- return AVERROR(ENOMEM);
- p = *buf;
- ret = snappy_copy1(gb, *buf, p, len, val);
- ret = snappy_copy2(gb, *buf, p, len, val);
- ret = snappy_copy4(gb, *buf, p, len, val);
+ int ff_snappy_uncompress(GetByteContext *gb, uint8_t *buf, int64_t *size)
+ if (len > *size)
+ return AVERROR_BUG;
+ p = buf;
+ ret = snappy_copy1(gb, buf, p, len, val);
+ ret = snappy_copy2(gb, buf, p, len, val);
+ ret = snappy_copy4(gb, buf, p, len, val);","int ff_snappy_uncompress(GetByteContext *gb, uint8_t *buf, int64_t *size) { int64_t len = decode_len(gb); int ret = 0; uint8_t *p; if (len < 0) return len; if (len > *size) return AVERROR_BUG; *size = len; p = buf; while (bytestream2_get_bytes_left(gb) > 0) { uint8_t s = bytestream2_get_byte(gb); int val = s >> 2; switch (s & 0x03) { case SNAPPY_LITERAL: ret = snappy_literal(gb, p, len, val); break; case SNAPPY_COPY_1: ret = snappy_copy1(gb, buf, p, len, val); break; case SNAPPY_COPY_2: ret = snappy_copy2(gb, buf, p, len, val); break; case SNAPPY_COPY_4: ret = snappy_copy4(gb, buf, p, len, val); break; } if (ret < 0) return ret; p += ret; len -= ret; } return 0; }"
286----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_11ac454ba0552583439dd3011dbdb23528528a7a_1.json----alloc_sequence_buffers,"static int alloc_sequence_buffers(DiracContext *s) { int sbwidth = DIVRNDUP(s->source.width, 4); int sbheight = DIVRNDUP(s->source.height, 4); int i, w, h, top_padding; for (i = 0; i < 3; i++) { int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0); int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0); w = s->source.width >> (i ? s->chroma_x_shift : 0); h = s->source.height >> (i ? s->chroma_y_shift : 0); top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2); w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2; s->plane[i].idwt_buf_base = av_mallocz_array((w+max_xblen), h * sizeof(IDWTELEM)); s->plane[i].idwt_tmp = av_malloc_array((w+16), sizeof(IDWTELEM)); s->plane[i].idwt_buf = s->plane[i].idwt_buf_base + top_padding*w; if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp) return AVERROR(ENOMEM); } <S2SV_StartVul> w = s->source.width; <S2SV_EndVul> <S2SV_StartVul> h = s->source.height; <S2SV_EndVul> s->sbsplit = av_malloc_array(sbwidth, sbheight); s->blmotion = av_malloc_array(sbwidth, sbheight * 16 * sizeof(*s->blmotion)); <S2SV_StartVul> s->edge_emu_buffer_base = av_malloc_array((w+64), MAX_BLOCKSIZE); <S2SV_EndVul> <S2SV_StartVul> s->mctmp = av_malloc_array((w+64+MAX_BLOCKSIZE), (h+MAX_BLOCKSIZE) * sizeof(*s->mctmp)); <S2SV_EndVul> <S2SV_StartVul> s->mcscratch = av_malloc_array((w+64), MAX_BLOCKSIZE); <S2SV_EndVul> <S2SV_StartVul> if (!s->sbsplit || !s->blmotion || !s->mctmp || !s->mcscratch) <S2SV_EndVul> return AVERROR(ENOMEM); return 0; }","- w = s->source.width;
- h = s->source.height;
- s->edge_emu_buffer_base = av_malloc_array((w+64), MAX_BLOCKSIZE);
- s->mctmp = av_malloc_array((w+64+MAX_BLOCKSIZE), (h+MAX_BLOCKSIZE) * sizeof(*s->mctmp));
- s->mcscratch = av_malloc_array((w+64), MAX_BLOCKSIZE);
- if (!s->sbsplit || !s->blmotion || !s->mctmp || !s->mcscratch)
+ if (!s->sbsplit || !s->blmotion)
+ return AVERROR(ENOMEM);
+ return 0;
+ }","static int alloc_sequence_buffers(DiracContext *s) { int sbwidth = DIVRNDUP(s->source.width, 4); int sbheight = DIVRNDUP(s->source.height, 4); int i, w, h, top_padding; for (i = 0; i < 3; i++) { int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0); int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0); w = s->source.width >> (i ? s->chroma_x_shift : 0); h = s->source.height >> (i ? s->chroma_y_shift : 0); top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2); w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2; s->plane[i].idwt_buf_base = av_mallocz_array((w+max_xblen), h * sizeof(IDWTELEM)); s->plane[i].idwt_tmp = av_malloc_array((w+16), sizeof(IDWTELEM)); s->plane[i].idwt_buf = s->plane[i].idwt_buf_base + top_padding*w; if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp) return AVERROR(ENOMEM); } s->sbsplit = av_malloc_array(sbwidth, sbheight); s->blmotion = av_malloc_array(sbwidth, sbheight * 16 * sizeof(*s->blmotion)); if (!s->sbsplit || !s->blmotion) return AVERROR(ENOMEM); return 0; }"
11529----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2d43700043cba2db2eba34a285b24f67fab2f978_1.json----ec_key_simple_priv2oct,"size_t ec_key_simple_priv2oct(const EC_KEY *eckey, unsigned char *buf, size_t len) { size_t buf_len; <S2SV_StartVul> buf_len = (EC_GROUP_get_degree(eckey->group) + 7) / 8; <S2SV_EndVul> if (eckey->priv_key == NULL) return 0; if (buf == NULL) return buf_len; else if (len < buf_len) return 0; if (BN_bn2binpad(eckey->priv_key, buf, buf_len) == -1) { ECerr(EC_F_EC_KEY_SIMPLE_PRIV2OCT, EC_R_BUFFER_TOO_SMALL); return 0; } return buf_len; }","- buf_len = (EC_GROUP_get_degree(eckey->group) + 7) / 8;
+ buf_len = (EC_GROUP_order_bits(eckey->group) + 7) / 8;","size_t ec_key_simple_priv2oct(const EC_KEY *eckey, unsigned char *buf, size_t len) { size_t buf_len; buf_len = (EC_GROUP_order_bits(eckey->group) + 7) / 8; if (eckey->priv_key == NULL) return 0; if (buf == NULL) return buf_len; else if (len < buf_len) return 0; if (BN_bn2binpad(eckey->priv_key, buf, buf_len) == -1) { ECerr(EC_F_EC_KEY_SIMPLE_PRIV2OCT, EC_R_BUFFER_TOO_SMALL); return 0; } return buf_len; }"
4937----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_e9b090a200a4523a0ce93365741a7d5f68f49b30_1.json----proxy_wstunnel_pump,"static int proxy_wstunnel_pump(ws_baton_t *baton, apr_time_t timeout, int try_async) { request_rec *r = baton->r; conn_rec *c = r->connection; proxy_conn_rec *conn = baton->proxy_connrec; apr_socket_t *sock = conn->sock; conn_rec *backconn = conn->connection; const apr_pollfd_t *signalled; apr_int32_t pollcnt, pi; apr_int16_t pollevent; apr_pollset_t *pollset = baton->pollset; apr_socket_t *client_socket = baton->client_soc; apr_status_t rv; apr_bucket_brigade *bb = baton->bb; while(1) { <S2SV_StartVul> ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""poll timeout is %""APR_TIME_T_FMT""ms %s"", apr_time_as_msec(timeout), try_async ? ""async"" : ""sync""); <S2SV_EndVul> if ((rv = apr_pollset_poll(pollset, timeout, &pollcnt, &signalled)) != APR_SUCCESS) { if (APR_STATUS_IS_EINTR(rv)) { continue; } else if (APR_STATUS_IS_TIMEUP(rv)) { if (try_async) { <S2SV_StartVul> ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02542) ""Attempting to go async""); <S2SV_EndVul> return SUSPENDED; } else { return HTTP_REQUEST_TIME_OUT; } } else { ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) ""error apr_poll()""); return HTTP_INTERNAL_SERVER_ERROR; } } ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02445) ""woke from poll(), i=%d"", pollcnt); for (pi = 0; pi < pollcnt; pi++) { const apr_pollfd_t *cur = &signalled[pi]; if (cur->desc.s == sock) { pollevent = cur->rtnevents; if (pollevent & (APR_POLLIN | APR_POLLHUP)) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02446) ""sock was readable""); rv = proxy_wstunnel_transfer(r, backconn, c, bb, ""sock""); } else if (pollevent & APR_POLLERR) { rv = APR_EPIPE; ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447) ""error on backconn""); } else { rv = APR_EGENERAL; ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02605) ""unknown event on backconn %d"", pollevent); } } else if (cur->desc.s == client_socket) { pollevent = cur->rtnevents; if (pollevent & (APR_POLLIN | APR_POLLHUP)) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02448) ""client was readable""); rv = proxy_wstunnel_transfer(r, c, backconn, bb, ""client""); } else if (pollevent & APR_POLLERR) { rv = APR_EPIPE; c->aborted = 1; ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02607) ""error on client conn""); } else { rv = APR_EGENERAL; ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02606) ""unknown event on client conn %d"", pollevent); } } else { rv = APR_EBADF; ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449) ""unknown socket in pollset""); } } if (rv != APR_SUCCESS) { break; } } ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""finished with poll() - cleaning up""); return OK; }","- ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""poll timeout is %""APR_TIME_T_FMT""ms %s"", apr_time_as_msec(timeout), try_async ? ""async"" : ""sync"");
- ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02542) ""Attempting to go async"");
+ ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02542) ""Attempting to go async"");","static int proxy_wstunnel_pump(ws_baton_t *baton, apr_time_t timeout, int try_async) { request_rec *r = baton->r; conn_rec *c = r->connection; proxy_conn_rec *conn = baton->proxy_connrec; apr_socket_t *sock = conn->sock; conn_rec *backconn = conn->connection; const apr_pollfd_t *signalled; apr_int32_t pollcnt, pi; apr_int16_t pollevent; apr_pollset_t *pollset = baton->pollset; apr_socket_t *client_socket = baton->client_soc; apr_status_t rv; apr_bucket_brigade *bb = baton->bb; while(1) { if ((rv = apr_pollset_poll(pollset, timeout, &pollcnt, &signalled)) != APR_SUCCESS) { if (APR_STATUS_IS_EINTR(rv)) { continue; } else if (APR_STATUS_IS_TIMEUP(rv)) { if (try_async) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02542) ""Attempting to go async""); return SUSPENDED; } else { return HTTP_REQUEST_TIME_OUT; } } else { ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) ""error apr_poll()""); return HTTP_INTERNAL_SERVER_ERROR; } } ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02445) ""woke from poll(), i=%d"", pollcnt); for (pi = 0; pi < pollcnt; pi++) { const apr_pollfd_t *cur = &signalled[pi]; if (cur->desc.s == sock) { pollevent = cur->rtnevents; if (pollevent & (APR_POLLIN | APR_POLLHUP)) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02446) ""sock was readable""); rv = proxy_wstunnel_transfer(r, backconn, c, bb, ""sock""); } else if (pollevent & APR_POLLERR) { rv = APR_EPIPE; ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447) ""error on backconn""); } else { rv = APR_EGENERAL; ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02605) ""unknown event on backconn %d"", pollevent); } } else if (cur->desc.s == client_socket) { pollevent = cur->rtnevents; if (pollevent & (APR_POLLIN | APR_POLLHUP)) { ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02448) ""client was readable""); rv = proxy_wstunnel_transfer(r, c, backconn, bb, ""client""); } else if (pollevent & APR_POLLERR) { rv = APR_EPIPE; c->aborted = 1; ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02607) ""error on client conn""); } else { rv = APR_EGENERAL; ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02606) ""unknown event on client conn %d"", pollevent); } } else { rv = APR_EBADF; ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449) ""unknown socket in pollset""); } } if (rv != APR_SUCCESS) { break; } } ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, ""finished with poll() - cleaning up""); return OK; }"
10907----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_168047b916a9c1a1fc58369ef355a8b6546f980a_1.json----BN_mod_exp_mont_word,"int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont) { BN_MONT_CTX *mont = NULL; int b, bits, ret = 0; int r_is_one; BN_ULONG w, next_w; BIGNUM *d, *r, *t; BIGNUM *swap_tmp; #define BN_MOD_MUL_WORD(r,w,m) \ (BN_mul_word(r, (w)) && \ ( \ (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1)))) #define BN_TO_MONTGOMERY_WORD(r,w,mont) \ (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx)) if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) { BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return -1; } bn_check_top(p); bn_check_top(m); if (!BN_is_odd(m)) { BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS); return (0); } if (m->top == 1) a %= m->d[0]; bits = BN_num_bits(p); if (bits == 0) { if (BN_is_one(m)) { ret = 1; BN_zero(rr); <S2SV_StartVul> } else <S2SV_EndVul> ret = BN_one(rr); return ret; } if (a == 0) { BN_zero(rr); ret = 1; return ret; } BN_CTX_start(ctx); d = BN_CTX_get(ctx); r = BN_CTX_get(ctx); t = BN_CTX_get(ctx); if (d == NULL || r == NULL || t == NULL) goto err; if (in_mont != NULL) mont = in_mont; else { if ((mont = BN_MONT_CTX_new()) == NULL) goto err; if (!BN_MONT_CTX_set(mont, m, ctx)) goto err; } r_is_one = 1; w = a; for (b = bits - 2; b >= 0; b--) { next_w = w * w; if ((next_w / w) != w) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } next_w = 1; } w = next_w; if (!r_is_one) { if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err; } if (BN_is_bit_set(p, b)) { next_w = w * a; if ((next_w / a) != w) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } next_w = a; } w = next_w; } } if (w != 1) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } } if (r_is_one) { if (!BN_one(rr)) goto err; } else { if (!BN_from_montgomery(rr, r, mont, ctx)) goto err; } ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); BN_CTX_end(ctx); bn_check_top(rr); return (ret); }","- } else
+ } else {
+ }","int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p, const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont) { BN_MONT_CTX *mont = NULL; int b, bits, ret = 0; int r_is_one; BN_ULONG w, next_w; BIGNUM *d, *r, *t; BIGNUM *swap_tmp; #define BN_MOD_MUL_WORD(r,w,m) \ (BN_mul_word(r, (w)) && \ ( \ (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1)))) #define BN_TO_MONTGOMERY_WORD(r,w,mont) \ (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx)) if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) { BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return -1; } bn_check_top(p); bn_check_top(m); if (!BN_is_odd(m)) { BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS); return (0); } if (m->top == 1) a %= m->d[0]; bits = BN_num_bits(p); if (bits == 0) { if (BN_is_one(m)) { ret = 1; BN_zero(rr); } else { ret = BN_one(rr); } return ret; } if (a == 0) { BN_zero(rr); ret = 1; return ret; } BN_CTX_start(ctx); d = BN_CTX_get(ctx); r = BN_CTX_get(ctx); t = BN_CTX_get(ctx); if (d == NULL || r == NULL || t == NULL) goto err; if (in_mont != NULL) mont = in_mont; else { if ((mont = BN_MONT_CTX_new()) == NULL) goto err; if (!BN_MONT_CTX_set(mont, m, ctx)) goto err; } r_is_one = 1; w = a; for (b = bits - 2; b >= 0; b--) { next_w = w * w; if ((next_w / w) != w) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } next_w = 1; } w = next_w; if (!r_is_one) { if (!BN_mod_mul_montgomery(r, r, r, mont, ctx)) goto err; } if (BN_is_bit_set(p, b)) { next_w = w * a; if ((next_w / a) != w) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } next_w = a; } w = next_w; } } if (w != 1) { if (r_is_one) { if (!BN_TO_MONTGOMERY_WORD(r, w, mont)) goto err; r_is_one = 0; } else { if (!BN_MOD_MUL_WORD(r, w, m)) goto err; } } if (r_is_one) { if (!BN_one(rr)) goto err; } else { if (!BN_from_montgomery(rr, r, mont, ctx)) goto err; } ret = 1; err: if (in_mont == NULL) BN_MONT_CTX_free(mont); BN_CTX_end(ctx); bn_check_top(rr); return (ret); }"
12856----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5b678e708b9cf733587dcfed60a861a02befad75_1.json----NAME_CONSTRAINTS_check_CN,"int NAME_CONSTRAINTS_check_CN(X509 *x, NAME_CONSTRAINTS *nc) { int r, i; <S2SV_StartVul> GENERAL_NAMES *gens = NULL; <S2SV_EndVul> <S2SV_StartVul> X509_NAME *nm; <S2SV_EndVul> ASN1_STRING stmp; GENERAL_NAME gntmp; stmp.flags = 0; stmp.type = V_ASN1_IA5STRING; gntmp.type = GEN_DNS; gntmp.d.dNSName = &stmp; <S2SV_StartVul> gens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL); <S2SV_EndVul> <S2SV_StartVul> if (gens != NULL) { <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) { <S2SV_EndVul> <S2SV_StartVul> GENERAL_NAME *gen = sk_GENERAL_NAME_value(gens, i); <S2SV_EndVul> <S2SV_StartVul> if (gen->type == GEN_DNS) { <S2SV_EndVul> <S2SV_StartVul> GENERAL_NAMES_free(gens); <S2SV_EndVul> <S2SV_StartVul> return X509_V_OK; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> GENERAL_NAMES_free(gens); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> nm = X509_get_subject_name(x); <S2SV_EndVul> for (i = -1;;) { X509_NAME_ENTRY *ne; ASN1_STRING *cn; unsigned char *idval; size_t idlen; i = X509_NAME_get_index_by_NID(nm, NID_commonName, i); if (i == -1) break; ne = X509_NAME_get_entry(nm, i); cn = X509_NAME_ENTRY_get_data(ne); if ((r = cn2dnsid(cn, &idval, &idlen)) != X509_V_OK) return r; if (idlen == 0) continue; stmp.length = idlen; stmp.data = idval; r = nc_match(&gntmp, nc); OPENSSL_free(idval); if (r != X509_V_OK) return r; } return X509_V_OK; }","- GENERAL_NAMES *gens = NULL;
- X509_NAME *nm;
- gens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);
- if (gens != NULL) {
- for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
- GENERAL_NAME *gen = sk_GENERAL_NAME_value(gens, i);
- if (gen->type == GEN_DNS) {
- GENERAL_NAMES_free(gens);
- return X509_V_OK;
- }
- }
- GENERAL_NAMES_free(gens);
- }
- nm = X509_get_subject_name(x);
+ X509_NAME *nm = X509_get_subject_name(x);","int NAME_CONSTRAINTS_check_CN(X509 *x, NAME_CONSTRAINTS *nc) { int r, i; X509_NAME *nm = X509_get_subject_name(x); ASN1_STRING stmp; GENERAL_NAME gntmp; stmp.flags = 0; stmp.type = V_ASN1_IA5STRING; gntmp.type = GEN_DNS; gntmp.d.dNSName = &stmp; for (i = -1;;) { X509_NAME_ENTRY *ne; ASN1_STRING *cn; unsigned char *idval; size_t idlen; i = X509_NAME_get_index_by_NID(nm, NID_commonName, i); if (i == -1) break; ne = X509_NAME_get_entry(nm, i); cn = X509_NAME_ENTRY_get_data(ne); if ((r = cn2dnsid(cn, &idval, &idlen)) != X509_V_OK) return r; if (idlen == 0) continue; stmp.length = idlen; stmp.data = idval; r = nc_match(&gntmp, nc); OPENSSL_free(idval); if (r != X509_V_OK) return r; } return X509_V_OK; }"
573----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2028b814431e9fc430ecf8bafc132fd42e8e12e9_1.json----decode_cblk,"static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, int width, int height, int bandpos) { int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y; int pass_cnt = 0; int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC; int term_cnt = 0; int coder_type; <S2SV_StartVul> av_assert0(width <= JPEG2000_MAX_CBLKW); <S2SV_EndVul> <S2SV_StartVul> av_assert0(height <= JPEG2000_MAX_CBLKH); <S2SV_EndVul> <S2SV_StartVul> for (y = 0; y < height; y++) <S2SV_EndVul> <S2SV_StartVul> memset(t1->data[y], 0, width * sizeof(**t1->data)); <S2SV_EndVul> if (!cblk->length) return 0; <S2SV_StartVul> for (y = 0; y < height + 2; y++) <S2SV_EndVul> <S2SV_StartVul> memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags)); <S2SV_EndVul> cblk->data[cblk->length] = 0xff; cblk->data[cblk->length+1] = 0xff; ff_mqc_initdec(&t1->mqc, cblk->data, 0, 1); while (passno--) { switch(pass_t) { case 0: decode_sigpass(t1, width, height, bpno + 1, bandpos, vert_causal_ctx_csty_symbol); break; case 1: decode_refpass(t1, width, height, bpno + 1, vert_causal_ctx_csty_symbol); break; case 2: av_assert2(!t1->mqc.raw); decode_clnpass(s, t1, width, height, bpno + 1, bandpos, codsty->cblk_style & JPEG2000_CBLK_SEGSYM, vert_causal_ctx_csty_symbol); break; } if (codsty->cblk_style & JPEG2000_CBLK_RESET) ff_mqc_init_contexts(&t1->mqc); if (passno && (coder_type = needs_termination(codsty->cblk_style, pass_cnt))) { if (term_cnt >= cblk->nb_terminations) { av_log(s->avctx, AV_LOG_ERROR, ""Missing needed termination \n""); return AVERROR_INVALIDDATA; } ff_mqc_initdec(&t1->mqc, cblk->data + cblk->data_start[++term_cnt], coder_type == 2, 0); } pass_t++; if (pass_t == 3) { bpno--; pass_t = 0; } pass_cnt ++; } if (cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) != t1->mqc.bp) { av_log(s->avctx, AV_LOG_WARNING, ""End mismatch %""PTRDIFF_SPECIFIER""\n"", cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) - t1->mqc.bp); } return 0; }","- av_assert0(width <= JPEG2000_MAX_CBLKW);
- av_assert0(height <= JPEG2000_MAX_CBLKH);
- for (y = 0; y < height; y++)
- memset(t1->data[y], 0, width * sizeof(**t1->data));
- for (y = 0; y < height + 2; y++)
- memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));
+ av_assert0(width <= 1024U && height <= 1024U);
+ av_assert0(width*height <= 4096);
+ memset(t1->data, 0, t1->stride * height * sizeof(*t1->data));
+ memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags));","static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty, Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk, int width, int height, int bandpos) { int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y; int pass_cnt = 0; int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC; int term_cnt = 0; int coder_type; av_assert0(width <= 1024U && height <= 1024U); av_assert0(width*height <= 4096); memset(t1->data, 0, t1->stride * height * sizeof(*t1->data)); if (!cblk->length) return 0; memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags)); cblk->data[cblk->length] = 0xff; cblk->data[cblk->length+1] = 0xff; ff_mqc_initdec(&t1->mqc, cblk->data, 0, 1); while (passno--) { switch(pass_t) { case 0: decode_sigpass(t1, width, height, bpno + 1, bandpos, vert_causal_ctx_csty_symbol); break; case 1: decode_refpass(t1, width, height, bpno + 1, vert_causal_ctx_csty_symbol); break; case 2: av_assert2(!t1->mqc.raw); decode_clnpass(s, t1, width, height, bpno + 1, bandpos, codsty->cblk_style & JPEG2000_CBLK_SEGSYM, vert_causal_ctx_csty_symbol); break; } if (codsty->cblk_style & JPEG2000_CBLK_RESET) ff_mqc_init_contexts(&t1->mqc); if (passno && (coder_type = needs_termination(codsty->cblk_style, pass_cnt))) { if (term_cnt >= cblk->nb_terminations) { av_log(s->avctx, AV_LOG_ERROR, ""Missing needed termination \n""); return AVERROR_INVALIDDATA; } ff_mqc_initdec(&t1->mqc, cblk->data + cblk->data_start[++term_cnt], coder_type == 2, 0); } pass_t++; if (pass_t == 3) { bpno--; pass_t = 0; } pass_cnt ++; } if (cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) != t1->mqc.bp) { av_log(s->avctx, AV_LOG_WARNING, ""End mismatch %""PTRDIFF_SPECIFIER""\n"", cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) - t1->mqc.bp); } return 0; }"
2221----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7a8d6eb09749cba01ac6dfc7afe8062d7eb83186_1.json----ff_vorbis_floor1_render_list,"void ff_vorbis_floor1_render_list(vorbis_floor1_entry * list, int values, uint16_t *y_list, int *flag, int multiplier, float *out, int samples) { <S2SV_StartVul> int lx, i; <S2SV_EndVul> <S2SV_StartVul> uint8_t ly; <S2SV_EndVul> lx = 0; ly = y_list[0] * multiplier; for (i = 1; i < values; i++) { int pos = list[i].sort; if (flag[pos]) { int x1 = list[pos].x; int y1 = y_list[pos] * multiplier; if (lx < samples) render_line(lx, ly, FFMIN(x1,samples), y1, out); lx = x1; ly = y1; } if (lx >= samples) break; } if (lx < samples) render_line(lx, ly, samples, ly, out); }","- int lx, i;
- uint8_t ly;
+ int lx, ly, i;","void ff_vorbis_floor1_render_list(vorbis_floor1_entry * list, int values, uint16_t *y_list, int *flag, int multiplier, float *out, int samples) { int lx, ly, i; lx = 0; ly = y_list[0] * multiplier; for (i = 1; i < values; i++) { int pos = list[i].sort; if (flag[pos]) { int x1 = list[pos].x; int y1 = y_list[pos] * multiplier; if (lx < samples) render_line(lx, ly, FFMIN(x1,samples), y1, out); lx = x1; ly = y1; } if (lx >= samples) break; } if (lx < samples) render_line(lx, ly, samples, ly, out); }"
2737----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_96277c84464fbadad29cd8f534c3f4aa3b8682d3_1.json----srt_to_ass,"static void srt_to_ass(AVCodecContext *avctx, AVBPrint *dst, const char *in, int x1, int y1, int x2, int y2) { if (x1 >= 0 && y1 >= 0) { if (x2 >= 0 && y2 >= 0 && (x2 != x1 || y2 != y1) && x2 >= x1 && y2 >= y1) { const int cx = x1 + (x2 - x1)/2; const int cy = y1 + (y2 - y1)/2; <S2SV_StartVul> const int scaled_x = cx * ASS_DEFAULT_PLAYRESX / 720; <S2SV_EndVul> <S2SV_StartVul> const int scaled_y = cy * ASS_DEFAULT_PLAYRESY / 480; <S2SV_EndVul> av_bprintf(dst, ""{\\an5}{\\pos(%d,%d)}"", scaled_x, scaled_y); } else { <S2SV_StartVul> const int scaled_x = x1 * ASS_DEFAULT_PLAYRESX / 720; <S2SV_EndVul> <S2SV_StartVul> const int scaled_y = y1 * ASS_DEFAULT_PLAYRESY / 480; <S2SV_EndVul> av_bprintf(dst, ""{\\an1}{\\pos(%d,%d)}"", scaled_x, scaled_y); } } ff_htmlmarkup_to_ass(avctx, dst, in); }","- const int scaled_x = cx * ASS_DEFAULT_PLAYRESX / 720;
- const int scaled_y = cy * ASS_DEFAULT_PLAYRESY / 480;
- const int scaled_x = x1 * ASS_DEFAULT_PLAYRESX / 720;
- const int scaled_y = y1 * ASS_DEFAULT_PLAYRESY / 480;
+ const int scaled_x = cx * (int64_t)ASS_DEFAULT_PLAYRESX / 720;
+ const int scaled_y = cy * (int64_t)ASS_DEFAULT_PLAYRESY / 480;
+ const int scaled_x = x1 * (int64_t)ASS_DEFAULT_PLAYRESX / 720;
+ const int scaled_y = y1 * (int64_t)ASS_DEFAULT_PLAYRESY / 480;","static void srt_to_ass(AVCodecContext *avctx, AVBPrint *dst, const char *in, int x1, int y1, int x2, int y2) { if (x1 >= 0 && y1 >= 0) { if (x2 >= 0 && y2 >= 0 && (x2 != x1 || y2 != y1) && x2 >= x1 && y2 >= y1) { const int cx = x1 + (x2 - x1)/2; const int cy = y1 + (y2 - y1)/2; const int scaled_x = cx * (int64_t)ASS_DEFAULT_PLAYRESX / 720; const int scaled_y = cy * (int64_t)ASS_DEFAULT_PLAYRESY / 480; av_bprintf(dst, ""{\\an5}{\\pos(%d,%d)}"", scaled_x, scaled_y); } else { const int scaled_x = x1 * (int64_t)ASS_DEFAULT_PLAYRESX / 720; const int scaled_y = y1 * (int64_t)ASS_DEFAULT_PLAYRESY / 480; av_bprintf(dst, ""{\\an1}{\\pos(%d,%d)}"", scaled_x, scaled_y); } } ff_htmlmarkup_to_ass(avctx, dst, in); }"
10954----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1813e93f682216ce4f4aba0bcddabd5a65dfa286_1.json----bn_mul_part_recursive,"void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn, int n, BN_ULONG *t) { int i,j,n2=n*2; <S2SV_StartVul> unsigned int c1; <S2SV_EndVul> BN_ULONG ln,lo,*p; # ifdef BN_COUNT printf("" bn_mul_part_recursive %d * %d\n"",tn+n,tn+n); # endif if (n < 8) { i=tn+n; bn_mul_normal(r,a,i,b,i); return; } <S2SV_StartVul> bn_sub_words(t, a, &(a[n]),n); <S2SV_EndVul> <S2SV_StartVul> bn_sub_words(&(t[n]),b, &(b[n]),n); <S2SV_EndVul> # if 0 if (n == 4) { bn_mul_comba4(&(t[n2]),t,&(t[n])); bn_mul_comba4(r,a,b); bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn); memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2)); } else # endif if (n == 8) { bn_mul_comba8(&(t[n2]),t,&(t[n])); bn_mul_comba8(r,a,b); bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn); memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2)); } else { p= &(t[n2*2]); bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p); bn_mul_recursive(r,a,b,n,p); i=n/2; j=tn-i; if (j == 0) { bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p); memset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2)); } else if (j > 0) { bn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]), j,i,p); memset(&(r[n2+tn*2]),0, sizeof(BN_ULONG)*(n2-tn*2)); } else { memset(&(r[n2]),0,sizeof(BN_ULONG)*n2); if (tn < BN_MUL_RECURSIVE_SIZE_NORMAL) { bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn); } else { for (;;) { i/=2; if (i < tn) { bn_mul_part_recursive(&(r[n2]), &(a[n]),&(b[n]), tn-i,i,p); break; } else if (i == tn) { bn_mul_recursive(&(r[n2]), &(a[n]),&(b[n]), i,p); break; } } } } } c1=(int)(bn_add_words(t,r,&(r[n2]),n2)); <S2SV_StartVul> c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2)); <S2SV_EndVul> c1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2)); if (c1) { p= &(r[n+n2]); lo= *p; ln=(lo+c1)&BN_MASK2; *p=ln; if (ln < c1) { do { p++; lo= *p; ln=(lo+1)&BN_MASK2; *p=ln; } while (ln == 0); } } }","- unsigned int c1;
- c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
+ unsigned int c1,c2,neg,zero;
+ c1=bn_cmp_words(a,&(a[n]),n);
+ c2=bn_cmp_words(&(b[n]),b,n);
+ zero=neg=0;
+ switch (c1*3+c2)
+ {
+ case -4:
+ break;
+ case -3:
+ zero=1;
+ case -2:
+ neg=1;
+ break;
+ case -1:
+ case 0:
+ case 1:
+ zero=1;
+ case 2:
+ neg=1;
+ break;
+ case 3:
+ zero=1;
+ case 4:
+ bn_sub_words(t, a, &(a[n]),n);
+ bn_sub_words(&(t[n]),&(b[n]),b, n);
+ break;
+ }
+ {
+ c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));
+ }
+ else
+ {
+ c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));
+ }","void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn, int n, BN_ULONG *t) { int i,j,n2=n*2; unsigned int c1,c2,neg,zero; BN_ULONG ln,lo,*p; # ifdef BN_COUNT printf("" bn_mul_part_recursive %d * %d\n"",tn+n,tn+n); # endif if (n < 8) { i=tn+n; bn_mul_normal(r,a,i,b,i); return; } c1=bn_cmp_words(a,&(a[n]),n); c2=bn_cmp_words(&(b[n]),b,n); zero=neg=0; switch (c1*3+c2) { case -4: bn_sub_words(t, &(a[n]),a, n); bn_sub_words(&(t[n]),b, &(b[n]),n); break; case -3: zero=1; case -2: bn_sub_words(t, &(a[n]),a, n); bn_sub_words(&(t[n]),&(b[n]),b, n); neg=1; break; case -1: case 0: case 1: zero=1; case 2: bn_sub_words(t, a, &(a[n]),n); bn_sub_words(&(t[n]),b, &(b[n]),n); neg=1; break; case 3: zero=1; case 4: bn_sub_words(t, a, &(a[n]),n); bn_sub_words(&(t[n]),&(b[n]),b, n); break; } # if 0 if (n == 4) { bn_mul_comba4(&(t[n2]),t,&(t[n])); bn_mul_comba4(r,a,b); bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn); memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2)); } else # endif if (n == 8) { bn_mul_comba8(&(t[n2]),t,&(t[n])); bn_mul_comba8(r,a,b); bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn); memset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2)); } else { p= &(t[n2*2]); bn_mul_recursive(&(t[n2]),t,&(t[n]),n,p); bn_mul_recursive(r,a,b,n,p); i=n/2; j=tn-i; if (j == 0) { bn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p); memset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2)); } else if (j > 0) { bn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]), j,i,p); memset(&(r[n2+tn*2]),0, sizeof(BN_ULONG)*(n2-tn*2)); } else { memset(&(r[n2]),0,sizeof(BN_ULONG)*n2); if (tn < BN_MUL_RECURSIVE_SIZE_NORMAL) { bn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn); } else { for (;;) { i/=2; if (i < tn) { bn_mul_part_recursive(&(r[n2]), &(a[n]),&(b[n]), tn-i,i,p); break; } else if (i == tn) { bn_mul_recursive(&(r[n2]), &(a[n]),&(b[n]), i,p); break; } } } } } c1=(int)(bn_add_words(t,r,&(r[n2]),n2)); if (neg) { c1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2)); } else { c1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2)); } c1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2)); if (c1) { p= &(r[n+n2]); lo= *p; ln=(lo+c1)&BN_MASK2; *p=ln; if (ln < c1) { do { p++; lo= *p; ln=(lo+1)&BN_MASK2; *p=ln; } while (ln == 0); } } }"
12800----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_591c377bc6fac27ab8ad423bad190e41ce9271ec_1.json----i2v_AUTHORITY_INFO_ACCESS,"static STACK_OF(CONF_VALUE) *i2v_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *method, AUTHORITY_INFO_ACCESS *ainfo, STACK_OF(CONF_VALUE) *ret) { ACCESS_DESCRIPTION *desc; <S2SV_StartVul> int i; <S2SV_EndVul> char objtmp[80], *ntmp; CONF_VALUE *vtmp; for(i = 0; i < sk_ACCESS_DESCRIPTION_num(ainfo); i++) { desc = sk_ACCESS_DESCRIPTION_value(ainfo, i); ret = i2v_GENERAL_NAME(method, desc->location, ret); if(!ret) break; vtmp = sk_CONF_VALUE_value(ret, i); i2t_ASN1_OBJECT(objtmp, sizeof objtmp, desc->method); <S2SV_StartVul> ntmp = OPENSSL_malloc(strlen(objtmp) + strlen(vtmp->name) + 5); <S2SV_EndVul> if(!ntmp) { X509V3err(X509V3_F_I2V_AUTHORITY_INFO_ACCESS, ERR_R_MALLOC_FAILURE); return NULL; } <S2SV_StartVul> strcpy(ntmp, objtmp); <S2SV_EndVul> <S2SV_StartVul> strcat(ntmp, "" - ""); <S2SV_EndVul> <S2SV_StartVul> strcat(ntmp, vtmp->name); <S2SV_EndVul> OPENSSL_free(vtmp->name); vtmp->name = ntmp; } if(!ret) return sk_CONF_VALUE_new_null(); return ret; }","- int i;
- ntmp = OPENSSL_malloc(strlen(objtmp) + strlen(vtmp->name) + 5);
- strcpy(ntmp, objtmp);
- strcat(ntmp, "" - "");
- strcat(ntmp, vtmp->name);
+ int i,nlen;
+ nlen = strlen(objtmp) + strlen(vtmp->name) + 5;
+ ntmp = OPENSSL_malloc(nlen);
+ BUF_strlcpy(ntmp, objtmp, nlen);
+ BUF_strlcat(ntmp, "" - "", nlen);
+ BUF_strlcat(ntmp, vtmp->name, nlen);","static STACK_OF(CONF_VALUE) *i2v_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *method, AUTHORITY_INFO_ACCESS *ainfo, STACK_OF(CONF_VALUE) *ret) { ACCESS_DESCRIPTION *desc; int i,nlen; char objtmp[80], *ntmp; CONF_VALUE *vtmp; for(i = 0; i < sk_ACCESS_DESCRIPTION_num(ainfo); i++) { desc = sk_ACCESS_DESCRIPTION_value(ainfo, i); ret = i2v_GENERAL_NAME(method, desc->location, ret); if(!ret) break; vtmp = sk_CONF_VALUE_value(ret, i); i2t_ASN1_OBJECT(objtmp, sizeof objtmp, desc->method); nlen = strlen(objtmp) + strlen(vtmp->name) + 5; ntmp = OPENSSL_malloc(nlen); if(!ntmp) { X509V3err(X509V3_F_I2V_AUTHORITY_INFO_ACCESS, ERR_R_MALLOC_FAILURE); return NULL; } BUF_strlcpy(ntmp, objtmp, nlen); BUF_strlcat(ntmp, "" - "", nlen); BUF_strlcat(ntmp, vtmp->name, nlen); OPENSSL_free(vtmp->name); vtmp->name = ntmp; } if(!ret) return sk_CONF_VALUE_new_null(); return ret; }"
6219----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c0cdd7f37dd9dd4dc0e0b5e0ad2d16f7052cd85_1.json----ff_mjpeg_decode_frame,"int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; MJpegDecodeContext *s = avctx->priv_data; const uint8_t *buf_end, *buf_ptr; const uint8_t *unescaped_buf_ptr; int unescaped_buf_size; int start_code; int ret = 0; s->got_picture = 0; buf_ptr = buf; buf_end = buf + buf_size; while (buf_ptr < buf_end) { start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end, &unescaped_buf_ptr, &unescaped_buf_size); if (start_code < 0) { goto the_end; <S2SV_StartVul> } else if (unescaped_buf_size > (1U<<29)) { <S2SV_EndVul> <S2SV_StartVul> av_log(avctx, AV_LOG_ERROR, ""MJPEG packet 0x%x too big (0x%x/0x%x), corrupt data?\n"", <S2SV_EndVul> start_code, unescaped_buf_size, buf_size); return AVERROR_INVALIDDATA; } av_log(avctx, AV_LOG_DEBUG, ""marker=%x avail_size_in_buf=%td\n"", start_code, buf_end - buf_ptr); <S2SV_StartVul> init_get_bits(&s->gb, unescaped_buf_ptr, unescaped_buf_size * 8); <S2SV_EndVul> s->start_code = start_code; if (s->avctx->debug & FF_DEBUG_STARTCODE) av_log(avctx, AV_LOG_DEBUG, ""startcode: %X\n"", start_code); if (start_code >= 0xd0 && start_code <= 0xd7) av_log(avctx, AV_LOG_DEBUG, ""restart marker: %d\n"", start_code & 0x0f); else if (start_code >= APP0 && start_code <= APP15) mjpeg_decode_app(s); else if (start_code == COM) mjpeg_decode_com(s); if (!CONFIG_JPEGLS_DECODER && (start_code == SOF48 || start_code == LSE)) { av_log(avctx, AV_LOG_ERROR, ""JPEG-LS support not enabled.\n""); return AVERROR(ENOSYS); } switch (start_code) { case SOI: s->restart_interval = 0; s->restart_count = 0; break; case DQT: ff_mjpeg_decode_dqt(s); break; case DHT: if ((ret = ff_mjpeg_decode_dht(s)) < 0) { av_log(avctx, AV_LOG_ERROR, ""huffman table decode error\n""); return ret; } break; case SOF0: case SOF1: s->lossless = 0; s->ls = 0; s->progressive = 0; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case SOF2: s->lossless = 0; s->ls = 0; s->progressive = 1; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case SOF3: s->lossless = 1; s->ls = 0; s->progressive = 0; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case SOF48: s->lossless = 1; s->ls = 1; s->progressive = 0; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case LSE: if (!CONFIG_JPEGLS_DECODER || (ret = ff_jpegls_decode_lse(s)) < 0) return ret; break; case EOI: s->cur_scan = 0; if ((s->buggy_avid && !s->interlaced) || s->restart_interval) break; eoi_parser: if (!s->got_picture) { av_log(avctx, AV_LOG_WARNING, ""Found EOI before any SOF, ignoring\n""); break; } if (s->interlaced) { s->bottom_field ^= 1; if (s->bottom_field == !s->interlace_polarity) goto not_the_end; } if ((ret = av_frame_ref(data, s->picture_ptr)) < 0) return ret; *got_frame = 1; if (!s->lossless && avctx->debug & FF_DEBUG_QP) { av_log(avctx, AV_LOG_DEBUG, ""QP: %d\n"", FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2])); } goto the_end; case SOS: if (!s->got_picture) { av_log(avctx, AV_LOG_WARNING, ""Can not process SOS before SOF, skipping\n""); break; } if ((ret = ff_mjpeg_decode_sos(s, NULL, NULL)) < 0 && (avctx->err_recognition & AV_EF_EXPLODE)) return ret; if ((s->buggy_avid && !s->interlaced) || s->restart_interval) goto eoi_parser; break; case DRI: mjpeg_decode_dri(s); break; case SOF5: case SOF6: case SOF7: case SOF9: case SOF10: case SOF11: case SOF13: case SOF14: case SOF15: case JPG: av_log(avctx, AV_LOG_ERROR, ""mjpeg: unsupported coding type (%x)\n"", start_code); break; } not_the_end: buf_ptr += (get_bits_count(&s->gb) + 7) / 8; av_log(avctx, AV_LOG_DEBUG, ""marker parser used %d bytes (%d bits)\n"", (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb)); } if (s->got_picture) { av_log(avctx, AV_LOG_WARNING, ""EOI missing, emulating\n""); goto eoi_parser; } av_log(avctx, AV_LOG_FATAL, ""No JPEG data found in image\n""); return AVERROR_INVALIDDATA; the_end: av_log(avctx, AV_LOG_DEBUG, ""mjpeg decode frame unused %td bytes\n"", buf_end - buf_ptr); return buf_ptr - buf; }","- } else if (unescaped_buf_size > (1U<<29)) {
- av_log(avctx, AV_LOG_ERROR, ""MJPEG packet 0x%x too big (0x%x/0x%x), corrupt data?\n"",
- init_get_bits(&s->gb, unescaped_buf_ptr, unescaped_buf_size * 8);
+ } else if (unescaped_buf_size > INT_MAX / 8) {
+ av_log(avctx, AV_LOG_ERROR,
+ ""MJPEG packet 0x%x too big (%d/%d), corrupt data?\n"",
+ ret = init_get_bits(&s->gb, unescaped_buf_ptr,
+ unescaped_buf_size * 8);
+ if (ret < 0)
+ return ret;","int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; MJpegDecodeContext *s = avctx->priv_data; const uint8_t *buf_end, *buf_ptr; const uint8_t *unescaped_buf_ptr; int unescaped_buf_size; int start_code; int ret = 0; s->got_picture = 0; buf_ptr = buf; buf_end = buf + buf_size; while (buf_ptr < buf_end) { start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end, &unescaped_buf_ptr, &unescaped_buf_size); if (start_code < 0) { goto the_end; } else if (unescaped_buf_size > INT_MAX / 8) { av_log(avctx, AV_LOG_ERROR, ""MJPEG packet 0x%x too big (%d/%d), corrupt data?\n"", start_code, unescaped_buf_size, buf_size); return AVERROR_INVALIDDATA; } av_log(avctx, AV_LOG_DEBUG, ""marker=%x avail_size_in_buf=%td\n"", start_code, buf_end - buf_ptr); ret = init_get_bits(&s->gb, unescaped_buf_ptr, unescaped_buf_size * 8); if (ret < 0) return ret; s->start_code = start_code; if (s->avctx->debug & FF_DEBUG_STARTCODE) av_log(avctx, AV_LOG_DEBUG, ""startcode: %X\n"", start_code); if (start_code >= 0xd0 && start_code <= 0xd7) av_log(avctx, AV_LOG_DEBUG, ""restart marker: %d\n"", start_code & 0x0f); else if (start_code >= APP0 && start_code <= APP15) mjpeg_decode_app(s); else if (start_code == COM) mjpeg_decode_com(s); if (!CONFIG_JPEGLS_DECODER && (start_code == SOF48 || start_code == LSE)) { av_log(avctx, AV_LOG_ERROR, ""JPEG-LS support not enabled.\n""); return AVERROR(ENOSYS); } switch (start_code) { case SOI: s->restart_interval = 0; s->restart_count = 0; break; case DQT: ff_mjpeg_decode_dqt(s); break; case DHT: if ((ret = ff_mjpeg_decode_dht(s)) < 0) { av_log(avctx, AV_LOG_ERROR, ""huffman table decode error\n""); return ret; } break; case SOF0: case SOF1: s->lossless = 0; s->ls = 0; s->progressive = 0; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case SOF2: s->lossless = 0; s->ls = 0; s->progressive = 1; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case SOF3: s->lossless = 1; s->ls = 0; s->progressive = 0; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case SOF48: s->lossless = 1; s->ls = 1; s->progressive = 0; if ((ret = ff_mjpeg_decode_sof(s)) < 0) return ret; break; case LSE: if (!CONFIG_JPEGLS_DECODER || (ret = ff_jpegls_decode_lse(s)) < 0) return ret; break; case EOI: s->cur_scan = 0; if ((s->buggy_avid && !s->interlaced) || s->restart_interval) break; eoi_parser: if (!s->got_picture) { av_log(avctx, AV_LOG_WARNING, ""Found EOI before any SOF, ignoring\n""); break; } if (s->interlaced) { s->bottom_field ^= 1; if (s->bottom_field == !s->interlace_polarity) goto not_the_end; } if ((ret = av_frame_ref(data, s->picture_ptr)) < 0) return ret; *got_frame = 1; if (!s->lossless && avctx->debug & FF_DEBUG_QP) { av_log(avctx, AV_LOG_DEBUG, ""QP: %d\n"", FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2])); } goto the_end; case SOS: if (!s->got_picture) { av_log(avctx, AV_LOG_WARNING, ""Can not process SOS before SOF, skipping\n""); break; } if ((ret = ff_mjpeg_decode_sos(s, NULL, NULL)) < 0 && (avctx->err_recognition & AV_EF_EXPLODE)) return ret; if ((s->buggy_avid && !s->interlaced) || s->restart_interval) goto eoi_parser; break; case DRI: mjpeg_decode_dri(s); break; case SOF5: case SOF6: case SOF7: case SOF9: case SOF10: case SOF11: case SOF13: case SOF14: case SOF15: case JPG: av_log(avctx, AV_LOG_ERROR, ""mjpeg: unsupported coding type (%x)\n"", start_code); break; } not_the_end: buf_ptr += (get_bits_count(&s->gb) + 7) / 8; av_log(avctx, AV_LOG_DEBUG, ""marker parser used %d bytes (%d bits)\n"", (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb)); } if (s->got_picture) { av_log(avctx, AV_LOG_WARNING, ""EOI missing, emulating\n""); goto eoi_parser; } av_log(avctx, AV_LOG_FATAL, ""No JPEG data found in image\n""); return AVERROR_INVALIDDATA; the_end: av_log(avctx, AV_LOG_DEBUG, ""mjpeg decode frame unused %td bytes\n"", buf_end - buf_ptr); return buf_ptr - buf; }"
5587----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_1.json----update_dimensions,"static int update_dimensions(VP8Context *s, int width, int height) { if (width != s->avctx->width || height != s->avctx->height) { if (av_image_check_size(width, height, 0, s->avctx)) return AVERROR_INVALIDDATA; <S2SV_StartVul> vp8_decode_flush(s->avctx); <S2SV_EndVul> avcodec_set_dimensions(s->avctx, width, height); } s->mb_width = (s->avctx->coded_width +15) / 16; s->mb_height = (s->avctx->coded_height+15) / 16; s->macroblocks_base = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks)); s->filter_strength = av_mallocz(s->mb_width*sizeof(*s->filter_strength)); s->intra4x4_pred_mode_top = av_mallocz(s->mb_width*4); s->top_nnz = av_mallocz(s->mb_width*sizeof(*s->top_nnz)); s->top_border = av_mallocz((s->mb_width+1)*sizeof(*s->top_border)); <S2SV_StartVul> s->segmentation_map = av_mallocz(s->mb_width*s->mb_height); <S2SV_EndVul> if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top || <S2SV_StartVul> !s->top_nnz || !s->top_border || !s->segmentation_map) <S2SV_EndVul> return AVERROR(ENOMEM); s->macroblocks = s->macroblocks_base + 1; return 0; }","- vp8_decode_flush(s->avctx);
- s->segmentation_map = av_mallocz(s->mb_width*s->mb_height);
- !s->top_nnz || !s->top_border || !s->segmentation_map)
+ vp8_decode_flush_impl(s->avctx, 1, 0);
+ !s->top_nnz || !s->top_border)","static int update_dimensions(VP8Context *s, int width, int height) { if (width != s->avctx->width || height != s->avctx->height) { if (av_image_check_size(width, height, 0, s->avctx)) return AVERROR_INVALIDDATA; vp8_decode_flush_impl(s->avctx, 1, 0); avcodec_set_dimensions(s->avctx, width, height); } s->mb_width = (s->avctx->coded_width +15) / 16; s->mb_height = (s->avctx->coded_height+15) / 16; s->macroblocks_base = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks)); s->filter_strength = av_mallocz(s->mb_width*sizeof(*s->filter_strength)); s->intra4x4_pred_mode_top = av_mallocz(s->mb_width*4); s->top_nnz = av_mallocz(s->mb_width*sizeof(*s->top_nnz)); s->top_border = av_mallocz((s->mb_width+1)*sizeof(*s->top_border)); if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top || !s->top_nnz || !s->top_border) return AVERROR(ENOMEM); s->macroblocks = s->macroblocks_base + 1; return 0; }"
10721----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_10d52df25ef829fb43473cfb6e878bfb1341fd0d_1.json----check_bn,"static int check_bn(const char *name, const BIGNUM *bn, const char *hexbn) { BIGNUM *tmp = NULL; if (!TEST_true(BN_hex2bn(&tmp, hexbn))) return 0; <S2SV_StartVul> if (!TEST_int_eq(BN_cmp(bn, tmp), 0)) { <S2SV_EndVul> <S2SV_StartVul> TEST_info(""Unexpected %s value"", name); <S2SV_EndVul> <S2SV_StartVul> showbn(""expecting"", tmp); <S2SV_EndVul> <S2SV_StartVul> showbn(""received"", bn); <S2SV_EndVul> <S2SV_StartVul> BN_free(tmp); <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> BN_free(tmp); <S2SV_StartVul> return 1; <S2SV_EndVul> }","- if (!TEST_int_eq(BN_cmp(bn, tmp), 0)) {
- TEST_info(""Unexpected %s value"", name);
- showbn(""expecting"", tmp);
- showbn(""received"", bn);
- BN_free(tmp);
- return 0;
- }
- return 1;
+ int r;
+ if (BN_cmp(bn, tmp) != 0)
+ TEST_error(""unexpected %s value"", name);
+ r = TEST_BN_eq(bn, tmp);
+ return r;","static int check_bn(const char *name, const BIGNUM *bn, const char *hexbn) { BIGNUM *tmp = NULL; int r; if (!TEST_true(BN_hex2bn(&tmp, hexbn))) return 0; if (BN_cmp(bn, tmp) != 0) TEST_error(""unexpected %s value"", name); r = TEST_BN_eq(bn, tmp); BN_free(tmp); return r; }"
97----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_05dce424ef3e9ac8cd853d25c7b38c8840ab6ed6_1.json----mpeg_motion_internal,"static av_always_inline void mpeg_motion_internal(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h, int is_mpeg12, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos; ptrdiff_t uvlinesize, linesize; #if 0 if (s->quarter_sample) { motion_x >>= 1; motion_y >>= 1; } #endif v_edge_pos = s->v_edge_pos >> field_based; <S2SV_StartVul> linesize = s->current_picture.f.linesize[0] << field_based; <S2SV_EndVul> <S2SV_StartVul> uvlinesize = s->current_picture.f.linesize[1] << field_based; <S2SV_EndVul> dxy = ((motion_y & 1) << 1) | (motion_x & 1); src_x = s->mb_x * 16 + (motion_x >> 1); src_y = (mb_y << (4 - field_based)) + (motion_y >> 1); if (!is_mpeg12 && s->out_format == FMT_H263) { if ((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based) { mx = (motion_x >> 1) | (motion_x & 1); my = motion_y >> 1; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x * 8 + (mx >> 1); uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1); } else { uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1); uvsrc_x = src_x >> 1; uvsrc_y = src_y >> 1; } } else if (!is_mpeg12 && s->out_format == FMT_H261) { mx = motion_x / 4; my = motion_y / 4; uvdxy = 0; uvsrc_x = s->mb_x * 8 + mx; uvsrc_y = mb_y * 8 + my; } else { if (s->chroma_y_shift) { mx = motion_x / 2; my = motion_y / 2; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x * 8 + (mx >> 1); uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1); } else { if (s->chroma_x_shift) { mx = motion_x / 2; uvdxy = ((motion_y & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x * 8 + (mx >> 1); uvsrc_y = src_y; } else { uvdxy = dxy; uvsrc_x = src_x; uvsrc_y = src_y; } } } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 16, 0) || (unsigned)src_y > FFMAX(v_edge_pos - (motion_y & 1) - h, 0)) { if (is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || s->codec_id == AV_CODEC_ID_MPEG1VIDEO) { av_log(s->avctx, AV_LOG_DEBUG, ""MPEG motion vector out of boundary (%d %d)\n"", src_x, src_y); return; } s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize, s->linesize, 17, 17 + field_based, src_x, src_y << field_based, s->h_edge_pos, s->v_edge_pos); ptr_y = s->edge_emu_buffer; if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize; s->vdsp.emulated_edge_mc(uvbuf, ptr_cb, s->uvlinesize, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, s->h_edge_pos >> 1, s->v_edge_pos >> 1); s->vdsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, s->h_edge_pos >> 1, s->v_edge_pos >> 1); ptr_cb = uvbuf; ptr_cr = uvbuf + 16; } } if (bottom_field) { dest_y += s->linesize; dest_cb += s->uvlinesize; dest_cr += s->uvlinesize; } if (field_select) { ptr_y += s->linesize; ptr_cb += s->uvlinesize; ptr_cr += s->uvlinesize; } pix_op[0][dxy](dest_y, ptr_y, linesize, h); if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { pix_op[s->chroma_x_shift][uvdxy] (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift); pix_op[s->chroma_x_shift][uvdxy] (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift); } if (!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) && s->out_format == FMT_H261) { ff_h261_loop_filter(s); } }","- linesize = s->current_picture.f.linesize[0] << field_based;
- uvlinesize = s->current_picture.f.linesize[1] << field_based;
+ linesize = s->current_picture.f->linesize[0] << field_based;
+ uvlinesize = s->current_picture.f->linesize[1] << field_based;","static av_always_inline void mpeg_motion_internal(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h, int is_mpeg12, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos; ptrdiff_t uvlinesize, linesize; #if 0 if (s->quarter_sample) { motion_x >>= 1; motion_y >>= 1; } #endif v_edge_pos = s->v_edge_pos >> field_based; linesize = s->current_picture.f->linesize[0] << field_based; uvlinesize = s->current_picture.f->linesize[1] << field_based; dxy = ((motion_y & 1) << 1) | (motion_x & 1); src_x = s->mb_x * 16 + (motion_x >> 1); src_y = (mb_y << (4 - field_based)) + (motion_y >> 1); if (!is_mpeg12 && s->out_format == FMT_H263) { if ((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based) { mx = (motion_x >> 1) | (motion_x & 1); my = motion_y >> 1; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x * 8 + (mx >> 1); uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1); } else { uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1); uvsrc_x = src_x >> 1; uvsrc_y = src_y >> 1; } } else if (!is_mpeg12 && s->out_format == FMT_H261) { mx = motion_x / 4; my = motion_y / 4; uvdxy = 0; uvsrc_x = s->mb_x * 8 + mx; uvsrc_y = mb_y * 8 + my; } else { if (s->chroma_y_shift) { mx = motion_x / 2; my = motion_y / 2; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x * 8 + (mx >> 1); uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1); } else { if (s->chroma_x_shift) { mx = motion_x / 2; uvdxy = ((motion_y & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x * 8 + (mx >> 1); uvsrc_y = src_y; } else { uvdxy = dxy; uvsrc_x = src_x; uvsrc_y = src_y; } } } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 16, 0) || (unsigned)src_y > FFMAX(v_edge_pos - (motion_y & 1) - h, 0)) { if (is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || s->codec_id == AV_CODEC_ID_MPEG1VIDEO) { av_log(s->avctx, AV_LOG_DEBUG, ""MPEG motion vector out of boundary (%d %d)\n"", src_x, src_y); return; } s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize, s->linesize, 17, 17 + field_based, src_x, src_y << field_based, s->h_edge_pos, s->v_edge_pos); ptr_y = s->edge_emu_buffer; if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize; s->vdsp.emulated_edge_mc(uvbuf, ptr_cb, s->uvlinesize, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, s->h_edge_pos >> 1, s->v_edge_pos >> 1); s->vdsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, s->uvlinesize, 9, 9 + field_based, uvsrc_x, uvsrc_y << field_based, s->h_edge_pos >> 1, s->v_edge_pos >> 1); ptr_cb = uvbuf; ptr_cr = uvbuf + 16; } } if (bottom_field) { dest_y += s->linesize; dest_cb += s->uvlinesize; dest_cr += s->uvlinesize; } if (field_select) { ptr_y += s->linesize; ptr_cb += s->uvlinesize; ptr_cr += s->uvlinesize; } pix_op[0][dxy](dest_y, ptr_y, linesize, h); if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) { pix_op[s->chroma_x_shift][uvdxy] (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift); pix_op[s->chroma_x_shift][uvdxy] (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift); } if (!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) && s->out_format == FMT_H261) { ff_h261_loop_filter(s); } }"
1038----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38a40d1cab1051c3b0d8be4eef69f34c4ef1b867_1.json----adx_encode,"static void adx_encode(unsigned char *adx,const short *wav, ADXChannelState *prev) { int scale; int i; int s0,s1,s2,d; int max=0; int min=0; int data[32]; s1 = prev->s1; s2 = prev->s2; for(i=0;i<32;i++) { s0 = wav[i]; <S2SV_StartVul> d = ((s0<<14) - SCALE1*s1 + SCALE2*s2)/BASEVOL; <S2SV_EndVul> data[i]=d; if (max<d) max=d; if (min>d) min=d; s2 = s1; s1 = s0; } prev->s1 = s1; prev->s2 = s2; if (max==0 && min==0) { memset(adx,0,18); return; } if (max/7>-min/8) scale = max/7; else scale = -min/8; if (scale==0) scale=1; AV_WB16(adx, scale); for(i=0;i<16;i++) { adx[i+2] = ((data[i*2]/scale)<<4) | ((data[i*2+1]/scale)&0xf); } }","- d = ((s0<<14) - SCALE1*s1 + SCALE2*s2)/BASEVOL;
+ d = ((s0 << COEFF_BITS) - COEFF1 * s1 + COEFF2 * s2) >> COEFF_BITS;","static void adx_encode(unsigned char *adx,const short *wav, ADXChannelState *prev) { int scale; int i; int s0,s1,s2,d; int max=0; int min=0; int data[32]; s1 = prev->s1; s2 = prev->s2; for(i=0;i<32;i++) { s0 = wav[i]; d = ((s0 << COEFF_BITS) - COEFF1 * s1 + COEFF2 * s2) >> COEFF_BITS; data[i]=d; if (max<d) max=d; if (min>d) min=d; s2 = s1; s1 = s0; } prev->s1 = s1; prev->s2 = s2; if (max==0 && min==0) { memset(adx,0,18); return; } if (max/7>-min/8) scale = max/7; else scale = -min/8; if (scale==0) scale=1; AV_WB16(adx, scale); for(i=0;i<16;i++) { adx[i+2] = ((data[i*2]/scale)<<4) | ((data[i*2+1]/scale)&0xf); } }"
699----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_267f6ad7426977eee133ce432c2958786fdc0138_1.json----decode_video,"static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output) { AVFrame *decoded_frame, *f; int i, ret = 0, err = 0, resample_changed; int64_t best_effort_timestamp; AVRational *frame_sample_aspect; if (!ist->decoded_frame && !(ist->decoded_frame = av_frame_alloc())) return AVERROR(ENOMEM); if (!ist->filter_frame && !(ist->filter_frame = av_frame_alloc())) return AVERROR(ENOMEM); decoded_frame = ist->decoded_frame; pkt->dts = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ist->st->time_base); update_benchmark(NULL); ret = avcodec_decode_video2(ist->dec_ctx, decoded_frame, got_output, pkt); update_benchmark(""decode_video %d.%d"", ist->file_index, ist->st->index); if (ist->st->codec->has_b_frames < ist->dec_ctx->has_b_frames) { if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) { ist->st->codec->has_b_frames = ist->dec_ctx->has_b_frames; } else av_log(ist->dec_ctx, AV_LOG_WARNING, ""has_b_frames is larger in decoder than demuxer %d > %d.\n"" ""If you want to help, upload a sample "" ""of this file to ftp://upload.ffmpeg.org/incoming/ "" ""and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)"", ist->dec_ctx->has_b_frames, ist->st->codec->has_b_frames); } <S2SV_StartVul> if (*got_output || ret<0) <S2SV_EndVul> <S2SV_StartVul> decode_error_stat[ret<0] ++; <S2SV_EndVul> <S2SV_StartVul> if (ret < 0 && exit_on_error) <S2SV_EndVul> <S2SV_StartVul> exit_program(1); <S2SV_EndVul> if (*got_output && ret >= 0) { if (ist->dec_ctx->width != decoded_frame->width || ist->dec_ctx->height != decoded_frame->height || ist->dec_ctx->pix_fmt != decoded_frame->format) { av_log(NULL, AV_LOG_DEBUG, ""Frame parameters mismatch context %d,%d,%d != %d,%d,%d\n"", decoded_frame->width, decoded_frame->height, decoded_frame->format, ist->dec_ctx->width, ist->dec_ctx->height, ist->dec_ctx->pix_fmt); } } if (!*got_output || ret < 0) return ret; if(ist->top_field_first>=0) decoded_frame->top_field_first = ist->top_field_first; ist->frames_decoded++; if (ist->hwaccel_retrieve_data && decoded_frame->format == ist->hwaccel_pix_fmt) { err = ist->hwaccel_retrieve_data(ist->dec_ctx, decoded_frame); if (err < 0) goto fail; } ist->hwaccel_retrieved_pix_fmt = decoded_frame->format; best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame); if(best_effort_timestamp != AV_NOPTS_VALUE) ist->next_pts = ist->pts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q); if (debug_ts) { av_log(NULL, AV_LOG_INFO, ""decoder -> ist_index:%d type:video "" ""frame_pts:%s frame_pts_time:%s best_effort_ts:%""PRId64"" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\n"", ist->st->index, av_ts2str(decoded_frame->pts), av_ts2timestr(decoded_frame->pts, &ist->st->time_base), best_effort_timestamp, av_ts2timestr(best_effort_timestamp, &ist->st->time_base), decoded_frame->key_frame, decoded_frame->pict_type, ist->st->time_base.num, ist->st->time_base.den); } pkt->size = 0; if (ist->st->sample_aspect_ratio.num) decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio; resample_changed = ist->resample_width != decoded_frame->width || ist->resample_height != decoded_frame->height || ist->resample_pix_fmt != decoded_frame->format; if (resample_changed) { av_log(NULL, AV_LOG_INFO, ""Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n"", ist->file_index, ist->st->index, ist->resample_width, ist->resample_height, av_get_pix_fmt_name(ist->resample_pix_fmt), decoded_frame->width, decoded_frame->height, av_get_pix_fmt_name(decoded_frame->format)); ist->resample_width = decoded_frame->width; ist->resample_height = decoded_frame->height; ist->resample_pix_fmt = decoded_frame->format; for (i = 0; i < nb_filtergraphs; i++) { if (ist_in_filtergraph(filtergraphs[i], ist) && ist->reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) { av_log(NULL, AV_LOG_FATAL, ""Error reinitializing filters!\n""); exit_program(1); } } } frame_sample_aspect= av_opt_ptr(avcodec_get_frame_class(), decoded_frame, ""sample_aspect_ratio""); for (i = 0; i < ist->nb_filters; i++) { if (!frame_sample_aspect->num) *frame_sample_aspect = ist->st->sample_aspect_ratio; if (i < ist->nb_filters - 1) { f = ist->filter_frame; err = av_frame_ref(f, decoded_frame); if (err < 0) break; } else f = decoded_frame; ret = av_buffersrc_add_frame_flags(ist->filters[i]->filter, f, AV_BUFFERSRC_FLAG_PUSH); if (ret == AVERROR_EOF) { ret = 0; } else if (ret < 0) { av_log(NULL, AV_LOG_FATAL, ""Failed to inject frame into filter network: %s\n"", av_err2str(ret)); exit_program(1); } } fail: av_frame_unref(ist->filter_frame); av_frame_unref(decoded_frame); return err < 0 ? err : ret; }","- if (*got_output || ret<0)
- decode_error_stat[ret<0] ++;
- if (ret < 0 && exit_on_error)
- exit_program(1);
+ check_decode_result(got_output, ret);","static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output) { AVFrame *decoded_frame, *f; int i, ret = 0, err = 0, resample_changed; int64_t best_effort_timestamp; AVRational *frame_sample_aspect; if (!ist->decoded_frame && !(ist->decoded_frame = av_frame_alloc())) return AVERROR(ENOMEM); if (!ist->filter_frame && !(ist->filter_frame = av_frame_alloc())) return AVERROR(ENOMEM); decoded_frame = ist->decoded_frame; pkt->dts = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ist->st->time_base); update_benchmark(NULL); ret = avcodec_decode_video2(ist->dec_ctx, decoded_frame, got_output, pkt); update_benchmark(""decode_video %d.%d"", ist->file_index, ist->st->index); if (ist->st->codec->has_b_frames < ist->dec_ctx->has_b_frames) { if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) { ist->st->codec->has_b_frames = ist->dec_ctx->has_b_frames; } else av_log(ist->dec_ctx, AV_LOG_WARNING, ""has_b_frames is larger in decoder than demuxer %d > %d.\n"" ""If you want to help, upload a sample "" ""of this file to ftp://upload.ffmpeg.org/incoming/ "" ""and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)"", ist->dec_ctx->has_b_frames, ist->st->codec->has_b_frames); } check_decode_result(got_output, ret); if (*got_output && ret >= 0) { if (ist->dec_ctx->width != decoded_frame->width || ist->dec_ctx->height != decoded_frame->height || ist->dec_ctx->pix_fmt != decoded_frame->format) { av_log(NULL, AV_LOG_DEBUG, ""Frame parameters mismatch context %d,%d,%d != %d,%d,%d\n"", decoded_frame->width, decoded_frame->height, decoded_frame->format, ist->dec_ctx->width, ist->dec_ctx->height, ist->dec_ctx->pix_fmt); } } if (!*got_output || ret < 0) return ret; if(ist->top_field_first>=0) decoded_frame->top_field_first = ist->top_field_first; ist->frames_decoded++; if (ist->hwaccel_retrieve_data && decoded_frame->format == ist->hwaccel_pix_fmt) { err = ist->hwaccel_retrieve_data(ist->dec_ctx, decoded_frame); if (err < 0) goto fail; } ist->hwaccel_retrieved_pix_fmt = decoded_frame->format; best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame); if(best_effort_timestamp != AV_NOPTS_VALUE) ist->next_pts = ist->pts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q); if (debug_ts) { av_log(NULL, AV_LOG_INFO, ""decoder -> ist_index:%d type:video "" ""frame_pts:%s frame_pts_time:%s best_effort_ts:%""PRId64"" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\n"", ist->st->index, av_ts2str(decoded_frame->pts), av_ts2timestr(decoded_frame->pts, &ist->st->time_base), best_effort_timestamp, av_ts2timestr(best_effort_timestamp, &ist->st->time_base), decoded_frame->key_frame, decoded_frame->pict_type, ist->st->time_base.num, ist->st->time_base.den); } pkt->size = 0; if (ist->st->sample_aspect_ratio.num) decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio; resample_changed = ist->resample_width != decoded_frame->width || ist->resample_height != decoded_frame->height || ist->resample_pix_fmt != decoded_frame->format; if (resample_changed) { av_log(NULL, AV_LOG_INFO, ""Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n"", ist->file_index, ist->st->index, ist->resample_width, ist->resample_height, av_get_pix_fmt_name(ist->resample_pix_fmt), decoded_frame->width, decoded_frame->height, av_get_pix_fmt_name(decoded_frame->format)); ist->resample_width = decoded_frame->width; ist->resample_height = decoded_frame->height; ist->resample_pix_fmt = decoded_frame->format; for (i = 0; i < nb_filtergraphs; i++) { if (ist_in_filtergraph(filtergraphs[i], ist) && ist->reinit_filters && configure_filtergraph(filtergraphs[i]) < 0) { av_log(NULL, AV_LOG_FATAL, ""Error reinitializing filters!\n""); exit_program(1); } } } frame_sample_aspect= av_opt_ptr(avcodec_get_frame_class(), decoded_frame, ""sample_aspect_ratio""); for (i = 0; i < ist->nb_filters; i++) { if (!frame_sample_aspect->num) *frame_sample_aspect = ist->st->sample_aspect_ratio; if (i < ist->nb_filters - 1) { f = ist->filter_frame; err = av_frame_ref(f, decoded_frame); if (err < 0) break; } else f = decoded_frame; ret = av_buffersrc_add_frame_flags(ist->filters[i]->filter, f, AV_BUFFERSRC_FLAG_PUSH); if (ret == AVERROR_EOF) { ret = 0; } else if (ret < 0) { av_log(NULL, AV_LOG_FATAL, ""Failed to inject frame into filter network: %s\n"", av_err2str(ret)); exit_program(1); } } fail: av_frame_unref(ist->filter_frame); av_frame_unref(decoded_frame); return err < 0 ? err : ret; }"
4168----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e1848949c861cbd23542c4fc91678057ccfa89a6_1.json----request_frame,static int request_frame(AVFilterLink *outlink) { ShowWavesContext *showwaves = outlink->src->priv; AVFilterLink *inlink = outlink->src->inputs[0]; int ret; <S2SV_StartVul> showwaves->req_fullfilled = 0; <S2SV_EndVul> <S2SV_StartVul> do { <S2SV_EndVul> <S2SV_StartVul> ret = ff_request_frame(inlink); <S2SV_EndVul> <S2SV_StartVul> } while (!showwaves->req_fullfilled && ret >= 0); <S2SV_EndVul> if (ret == AVERROR_EOF && showwaves->outpicref) { if (showwaves->single_pic) push_single_pic(outlink); else push_frame(outlink); } return ret; },"- showwaves->req_fullfilled = 0;
- do {
- ret = ff_request_frame(inlink);
- } while (!showwaves->req_fullfilled && ret >= 0);
+ ret = ff_request_frame(inlink);",static int request_frame(AVFilterLink *outlink) { ShowWavesContext *showwaves = outlink->src->priv; AVFilterLink *inlink = outlink->src->inputs[0]; int ret; ret = ff_request_frame(inlink); if (ret == AVERROR_EOF && showwaves->outpicref) { if (showwaves->single_pic) push_single_pic(outlink); else push_frame(outlink); } return ret; }
1435----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4f4d84eb2e09649978d7a9bbe792dabb5dfa55ce_1.json----rm_read_audio_stream_info,"static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb, AVStream *st, int read_all) { RMDemuxContext *rm = s->priv_data; char buf[256]; uint32_t version; <S2SV_StartVul> int i; <S2SV_EndVul> version = get_be32(pb); if (((version >> 16) & 0xff) == 3) { int64_t startpos = url_ftell(pb); <S2SV_StartVul> for(i = 0; i < 14; i++) <S2SV_EndVul> <S2SV_StartVul> get_byte(pb); <S2SV_EndVul> get_str8(pb, s->title, sizeof(s->title)); get_str8(pb, s->author, sizeof(s->author)); get_str8(pb, s->copyright, sizeof(s->copyright)); get_str8(pb, s->comment, sizeof(s->comment)); if ((startpos + (version & 0xffff)) >= url_ftell(pb) + 2) { get_byte(pb); get_str8(pb, buf, sizeof(buf)); } if ((startpos + (version & 0xffff)) > url_ftell(pb)) url_fskip(pb, (version & 0xffff) + startpos - url_ftell(pb)); st->codec->sample_rate = 8000; st->codec->channels = 1; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_RA_144; } else { int flavor, sub_packet_h, coded_framesize, sub_packet_size; get_be32(pb); get_be32(pb); get_be16(pb); get_be32(pb); flavor= get_be16(pb); rm->coded_framesize = coded_framesize = get_be32(pb); get_be32(pb); get_be32(pb); get_be32(pb); rm->sub_packet_h = sub_packet_h = get_be16(pb); st->codec->block_align= get_be16(pb); rm->sub_packet_size = sub_packet_size = get_be16(pb); get_be16(pb); if (((version >> 16) & 0xff) == 5) { get_be16(pb); get_be16(pb); get_be16(pb); } st->codec->sample_rate = get_be16(pb); get_be32(pb); st->codec->channels = get_be16(pb); if (((version >> 16) & 0xff) == 5) { get_be32(pb); <S2SV_StartVul> buf[0] = get_byte(pb); <S2SV_EndVul> <S2SV_StartVul> buf[1] = get_byte(pb); <S2SV_EndVul> <S2SV_StartVul> buf[2] = get_byte(pb); <S2SV_EndVul> <S2SV_StartVul> buf[3] = get_byte(pb); <S2SV_EndVul> buf[4] = 0; } else { get_str8(pb, buf, sizeof(buf)); get_str8(pb, buf, sizeof(buf)); } st->codec->codec_type = CODEC_TYPE_AUDIO; if (!strcmp(buf, ""dnet"")) { st->codec->codec_id = CODEC_ID_AC3; st->need_parsing = AVSTREAM_PARSE_FULL; } else if (!strcmp(buf, ""28_8"")) { st->codec->codec_id = CODEC_ID_RA_288; st->codec->extradata_size= 0; rm->audio_framesize = st->codec->block_align; st->codec->block_align = coded_framesize; if(rm->audio_framesize >= UINT_MAX / sub_packet_h){ av_log(s, AV_LOG_ERROR, ""rm->audio_framesize * sub_packet_h too large\n""); return -1; } rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h); } else if ((!strcmp(buf, ""cook"")) || (!strcmp(buf, ""atrc"")) || (!strcmp(buf, ""sipr""))) { <S2SV_StartVul> int codecdata_length, i; <S2SV_EndVul> get_be16(pb); get_byte(pb); if (((version >> 16) & 0xff) == 5) get_byte(pb); codecdata_length = get_be32(pb); if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){ av_log(s, AV_LOG_ERROR, ""codecdata_length too large\n""); return -1; } if(sub_packet_size <= 0){ av_log(s, AV_LOG_ERROR, ""sub_packet_size is invalid\n""); return -1; } if (!strcmp(buf, ""cook"")) st->codec->codec_id = CODEC_ID_COOK; else if (!strcmp(buf, ""sipr"")) st->codec->codec_id = CODEC_ID_SIPR; else st->codec->codec_id = CODEC_ID_ATRAC3; st->codec->extradata_size= codecdata_length; st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); <S2SV_StartVul> for(i = 0; i < codecdata_length; i++) <S2SV_EndVul> <S2SV_StartVul> ((uint8_t*)st->codec->extradata)[i] = get_byte(pb); <S2SV_EndVul> rm->audio_framesize = st->codec->block_align; st->codec->block_align = rm->sub_packet_size; if(rm->audio_framesize >= UINT_MAX / sub_packet_h){ av_log(s, AV_LOG_ERROR, ""rm->audio_framesize * sub_packet_h too large\n""); return -1; } rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h); } else if (!strcmp(buf, ""raac"") || !strcmp(buf, ""racp"")) { <S2SV_StartVul> int codecdata_length, i; <S2SV_EndVul> get_be16(pb); get_byte(pb); if (((version >> 16) & 0xff) == 5) get_byte(pb); st->codec->codec_id = CODEC_ID_AAC; codecdata_length = get_be32(pb); if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){ av_log(s, AV_LOG_ERROR, ""codecdata_length too large\n""); return -1; } if (codecdata_length >= 1) { st->codec->extradata_size = codecdata_length - 1; st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); get_byte(pb); <S2SV_StartVul> for(i = 0; i < st->codec->extradata_size; i++) <S2SV_EndVul> <S2SV_StartVul> ((uint8_t*)st->codec->extradata)[i] = get_byte(pb); <S2SV_EndVul> } } else { st->codec->codec_id = CODEC_ID_NONE; av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name)); } if (read_all) { get_byte(pb); get_byte(pb); get_byte(pb); get_str8(pb, s->title, sizeof(s->title)); get_str8(pb, s->author, sizeof(s->author)); get_str8(pb, s->copyright, sizeof(s->copyright)); get_str8(pb, s->comment, sizeof(s->comment)); } } return 0; }","- int i;
- for(i = 0; i < 14; i++)
- get_byte(pb);
- buf[0] = get_byte(pb);
- buf[1] = get_byte(pb);
- buf[2] = get_byte(pb);
- buf[3] = get_byte(pb);
- int codecdata_length, i;
- for(i = 0; i < codecdata_length; i++)
- ((uint8_t*)st->codec->extradata)[i] = get_byte(pb);
- int codecdata_length, i;
- for(i = 0; i < st->codec->extradata_size; i++)
- ((uint8_t*)st->codec->extradata)[i] = get_byte(pb);
+ url_fskip(pb, 14);
+ get_buffer(pb, buf, 4);
+ int codecdata_length;
+ get_buffer(pb, st->codec->extradata, st->codec->extradata_size);
+ int codecdata_length;
+ get_buffer(pb, st->codec->extradata, st->codec->extradata_size);","static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb, AVStream *st, int read_all) { RMDemuxContext *rm = s->priv_data; char buf[256]; uint32_t version; version = get_be32(pb); if (((version >> 16) & 0xff) == 3) { int64_t startpos = url_ftell(pb); url_fskip(pb, 14); get_str8(pb, s->title, sizeof(s->title)); get_str8(pb, s->author, sizeof(s->author)); get_str8(pb, s->copyright, sizeof(s->copyright)); get_str8(pb, s->comment, sizeof(s->comment)); if ((startpos + (version & 0xffff)) >= url_ftell(pb) + 2) { get_byte(pb); get_str8(pb, buf, sizeof(buf)); } if ((startpos + (version & 0xffff)) > url_ftell(pb)) url_fskip(pb, (version & 0xffff) + startpos - url_ftell(pb)); st->codec->sample_rate = 8000; st->codec->channels = 1; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->codec_id = CODEC_ID_RA_144; } else { int flavor, sub_packet_h, coded_framesize, sub_packet_size; get_be32(pb); get_be32(pb); get_be16(pb); get_be32(pb); flavor= get_be16(pb); rm->coded_framesize = coded_framesize = get_be32(pb); get_be32(pb); get_be32(pb); get_be32(pb); rm->sub_packet_h = sub_packet_h = get_be16(pb); st->codec->block_align= get_be16(pb); rm->sub_packet_size = sub_packet_size = get_be16(pb); get_be16(pb); if (((version >> 16) & 0xff) == 5) { get_be16(pb); get_be16(pb); get_be16(pb); } st->codec->sample_rate = get_be16(pb); get_be32(pb); st->codec->channels = get_be16(pb); if (((version >> 16) & 0xff) == 5) { get_be32(pb); get_buffer(pb, buf, 4); buf[4] = 0; } else { get_str8(pb, buf, sizeof(buf)); get_str8(pb, buf, sizeof(buf)); } st->codec->codec_type = CODEC_TYPE_AUDIO; if (!strcmp(buf, ""dnet"")) { st->codec->codec_id = CODEC_ID_AC3; st->need_parsing = AVSTREAM_PARSE_FULL; } else if (!strcmp(buf, ""28_8"")) { st->codec->codec_id = CODEC_ID_RA_288; st->codec->extradata_size= 0; rm->audio_framesize = st->codec->block_align; st->codec->block_align = coded_framesize; if(rm->audio_framesize >= UINT_MAX / sub_packet_h){ av_log(s, AV_LOG_ERROR, ""rm->audio_framesize * sub_packet_h too large\n""); return -1; } rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h); } else if ((!strcmp(buf, ""cook"")) || (!strcmp(buf, ""atrc"")) || (!strcmp(buf, ""sipr""))) { int codecdata_length; get_be16(pb); get_byte(pb); if (((version >> 16) & 0xff) == 5) get_byte(pb); codecdata_length = get_be32(pb); if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){ av_log(s, AV_LOG_ERROR, ""codecdata_length too large\n""); return -1; } if(sub_packet_size <= 0){ av_log(s, AV_LOG_ERROR, ""sub_packet_size is invalid\n""); return -1; } if (!strcmp(buf, ""cook"")) st->codec->codec_id = CODEC_ID_COOK; else if (!strcmp(buf, ""sipr"")) st->codec->codec_id = CODEC_ID_SIPR; else st->codec->codec_id = CODEC_ID_ATRAC3; st->codec->extradata_size= codecdata_length; st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); get_buffer(pb, st->codec->extradata, st->codec->extradata_size); rm->audio_framesize = st->codec->block_align; st->codec->block_align = rm->sub_packet_size; if(rm->audio_framesize >= UINT_MAX / sub_packet_h){ av_log(s, AV_LOG_ERROR, ""rm->audio_framesize * sub_packet_h too large\n""); return -1; } rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h); } else if (!strcmp(buf, ""raac"") || !strcmp(buf, ""racp"")) { int codecdata_length; get_be16(pb); get_byte(pb); if (((version >> 16) & 0xff) == 5) get_byte(pb); st->codec->codec_id = CODEC_ID_AAC; codecdata_length = get_be32(pb); if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){ av_log(s, AV_LOG_ERROR, ""codecdata_length too large\n""); return -1; } if (codecdata_length >= 1) { st->codec->extradata_size = codecdata_length - 1; st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE); get_byte(pb); get_buffer(pb, st->codec->extradata, st->codec->extradata_size); } } else { st->codec->codec_id = CODEC_ID_NONE; av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name)); } if (read_all) { get_byte(pb); get_byte(pb); get_byte(pb); get_str8(pb, s->title, sizeof(s->title)); get_str8(pb, s->author, sizeof(s->author)); get_str8(pb, s->copyright, sizeof(s->copyright)); get_str8(pb, s->comment, sizeof(s->comment)); } } return 0; }"
15541----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b8acf421ad15375c949e9d703b42048bdc81b90a_1.json----ssl23_get_client_hello,"int ssl23_get_client_hello(SSL *s) { <S2SV_StartVul> char buf_space[8]; <S2SV_EndVul> char *buf= &(buf_space[0]); unsigned char *p,*d,*dd; unsigned int i; unsigned int csl,sil,cl; int n=0,j,tls1=0; int type=0,use_sslv2_strong=0; int v[2]; if (s->state == SSL23_ST_SR_CLNT_HELLO_A) { v[0]=v[1]=0; if (!ssl3_setup_buffers(s)) goto err; <S2SV_StartVul> n=ssl23_read_bytes(s,7); <S2SV_EndVul> <S2SV_StartVul> if (n != 7) return(n); <S2SV_EndVul> p=s->packet; memcpy(buf,p,n); if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) { if ((p[3] == 0x00) && (p[4] == 0x02)) { v[0]=p[3]; v[1]=p[4]; if (!(s->options & SSL_OP_NO_SSLv2)) type=1; } else if (p[3] == SSL3_VERSION_MAJOR) { v[0]=p[3]; v[1]=p[4]; if (p[4] >= TLS1_VERSION_MINOR) { if (!(s->options & SSL_OP_NO_TLSv1)) { tls1=1; s->state=SSL23_ST_SR_CLNT_HELLO_B; } else if (!(s->options & SSL_OP_NO_SSLv3)) { s->state=SSL23_ST_SR_CLNT_HELLO_B; } else if (!(s->options & SSL_OP_NO_SSLv2)) { type=1; } } else if (!(s->options & SSL_OP_NO_SSLv3)) s->state=SSL23_ST_SR_CLNT_HELLO_B; else if (!(s->options & SSL_OP_NO_SSLv2)) type=1; if (s->options & SSL_OP_NON_EXPORT_FIRST) { STACK_OF(SSL_CIPHER) *sk; SSL_CIPHER *c; int ne2,ne3; j=((p[0]&0x7f)<<8)|p[1]; if (j > (1024*4)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE); goto err; } n=ssl23_read_bytes(s,j+2); if (n <= 0) return(n); p=s->packet; if ((buf=Malloc(n)) == NULL) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE); goto err; } memcpy(buf,p,n); p+=5; n2s(p,csl); p+=4; sk=ssl_bytes_to_cipher_list( s,p,csl,NULL); if (sk != NULL) { ne2=ne3=0; for (j=0; j<sk_SSL_CIPHER_num(sk); j++) { c=sk_SSL_CIPHER_value(sk,j); if (!SSL_C_IS_EXPORT(c)) { if ((c->id>>24L) == 2L) ne2=1; else ne3=1; } } if (ne2 && !ne3) { type=1; use_sslv2_strong=1; goto next_bit; } } } } } else if ((p[0] == SSL3_RT_HANDSHAKE) && (p[1] == SSL3_VERSION_MAJOR) && <S2SV_StartVul> (p[5] == SSL3_MT_CLIENT_HELLO)) <S2SV_EndVul> { <S2SV_StartVul> v[0]=p[1]; v[1]=p[2]; <S2SV_EndVul> if (p[2] >= TLS1_VERSION_MINOR) { if (!(s->options & SSL_OP_NO_TLSv1)) { type=3; tls1=1; } else if (!(s->options & SSL_OP_NO_SSLv3)) type=3; } else if (!(s->options & SSL_OP_NO_SSLv3)) type=3; } else if ((strncmp(""GET "", (char *)p,4) == 0) || (strncmp(""POST "",(char *)p,5) == 0) || (strncmp(""HEAD "",(char *)p,5) == 0) || (strncmp(""PUT "", (char *)p,4) == 0)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST); goto err; } else if (strncmp(""CONNECT"",(char *)p,7) == 0) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST); goto err; } } next_bit: if (s->state == SSL23_ST_SR_CLNT_HELLO_B) { type=2; p=s->packet; v[0] = p[3]; v[1] = p[4]; n=((p[0]&0x7f)<<8)|p[1]; if (n > (1024*4)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE); goto err; } j=ssl23_read_bytes(s,n+2); if (j <= 0) return(j); ssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2); p=s->packet; p+=5; n2s(p,csl); n2s(p,sil); n2s(p,cl); d=(unsigned char *)s->init_buf->data; if ((csl+sil+cl+11) != s->packet_length) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH); goto err; } *(d++)=SSL3_VERSION_MAJOR; if (tls1) *(d++)=TLS1_VERSION_MINOR; else *(d++)=SSL3_VERSION_MINOR; i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl; memset(d,0,SSL3_RANDOM_SIZE); memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i); d+=SSL3_RANDOM_SIZE; *(d++)=0; j=0; dd=d; d+=2; for (i=0; i<csl; i+=3) { if (p[i] != 0) continue; *(d++)=p[i+1]; *(d++)=p[i+2]; j+=2; } s2n(j,dd); *(d++)=1; *(d++)=0; i=(d-(unsigned char *)s->init_buf->data); s->s3->tmp.reuse_message=1; s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO; s->s3->tmp.message_size=i; } if (type == 1) { if (s->s2 == NULL) { if (!ssl2_new(s)) goto err; } else ssl2_clear(s); if (s->s3 != NULL) ssl3_free(s); if (!BUF_MEM_grow(s->init_buf, SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)) { goto err; } s->state=SSL2_ST_GET_CLIENT_HELLO_A; if ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) || use_sslv2_strong) s->s2->ssl2_rollback=0; else s->s2->ssl2_rollback=1; s->rstate=SSL_ST_READ_HEADER; s->packet_length=n; s->packet= &(s->s2->rbuf[0]); memcpy(s->packet,buf,n); s->s2->rbuf_left=n; s->s2->rbuf_offs=0; s->method=SSLv2_server_method(); s->handshake_func=s->method->ssl_accept; } if ((type == 2) || (type == 3)) { if (!ssl_init_wbio_buffer(s,1)) goto err; s->state=SSL3_ST_SR_CLNT_HELLO_A; if (type == 3) { s->rstate=SSL_ST_READ_HEADER; s->packet_length=n; s->packet= &(s->s3->rbuf.buf[0]); memcpy(s->packet,buf,n); s->s3->rbuf.left=n; s->s3->rbuf.offset=0; } else { s->packet_length=0; s->s3->rbuf.left=0; s->s3->rbuf.offset=0; } if (tls1) { s->version=TLS1_VERSION; s->method=TLSv1_server_method(); } else { s->version=SSL3_VERSION; s->method=SSLv3_server_method(); } s->client_version=(v[0]<<8)|v[1]; s->handshake_func=s->method->ssl_accept; } if ((type < 1) || (type > 3)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL); goto err; } s->init_num=0; if (buf != buf_space) Free(buf); s->first_packet=1; return(SSL_accept(s)); err: if (buf != buf_space) Free(buf); return(-1); }","- char buf_space[8];
- n=ssl23_read_bytes(s,7);
- (p[5] == SSL3_MT_CLIENT_HELLO))
- v[0]=p[1]; v[1]=p[2];
+ char buf_space[10];
+ n=ssl23_read_bytes(s,10);
+ {
+ }
+ (p[5] == SSL3_MT_CLIENT_HELLO) &&
+ (p[9] == p[1]))
+ n=ssl23_read_bytes(s,11);
+ if (n != 11)
+ v[0]=p[9]; v[1]=p[10];
+ #endif","int ssl23_get_client_hello(SSL *s) { char buf_space[10]; char *buf= &(buf_space[0]); unsigned char *p,*d,*dd; unsigned int i; unsigned int csl,sil,cl; int n=0,j,tls1=0; int type=0,use_sslv2_strong=0; int v[2]; if (s->state == SSL23_ST_SR_CLNT_HELLO_A) { v[0]=v[1]=0; if (!ssl3_setup_buffers(s)) goto err; n=ssl23_read_bytes(s,10); if (n != 10) return(n); p=s->packet; memcpy(buf,p,n); if ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO)) { if ((p[3] == 0x00) && (p[4] == 0x02)) { v[0]=p[3]; v[1]=p[4]; if (!(s->options & SSL_OP_NO_SSLv2)) type=1; } else if (p[3] == SSL3_VERSION_MAJOR) { v[0]=p[3]; v[1]=p[4]; if (p[4] >= TLS1_VERSION_MINOR) { if (!(s->options & SSL_OP_NO_TLSv1)) { tls1=1; s->state=SSL23_ST_SR_CLNT_HELLO_B; } else if (!(s->options & SSL_OP_NO_SSLv3)) { s->state=SSL23_ST_SR_CLNT_HELLO_B; } else if (!(s->options & SSL_OP_NO_SSLv2)) { type=1; } } else if (!(s->options & SSL_OP_NO_SSLv3)) { s->state=SSL23_ST_SR_CLNT_HELLO_B; } else if (!(s->options & SSL_OP_NO_SSLv2)) type=1; if (s->options & SSL_OP_NON_EXPORT_FIRST) { STACK_OF(SSL_CIPHER) *sk; SSL_CIPHER *c; int ne2,ne3; j=((p[0]&0x7f)<<8)|p[1]; if (j > (1024*4)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE); goto err; } n=ssl23_read_bytes(s,j+2); if (n <= 0) return(n); p=s->packet; if ((buf=Malloc(n)) == NULL) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE); goto err; } memcpy(buf,p,n); p+=5; n2s(p,csl); p+=4; sk=ssl_bytes_to_cipher_list( s,p,csl,NULL); if (sk != NULL) { ne2=ne3=0; for (j=0; j<sk_SSL_CIPHER_num(sk); j++) { c=sk_SSL_CIPHER_value(sk,j); if (!SSL_C_IS_EXPORT(c)) { if ((c->id>>24L) == 2L) ne2=1; else ne3=1; } } if (ne2 && !ne3) { type=1; use_sslv2_strong=1; goto next_bit; } } } } } else if ((p[0] == SSL3_RT_HANDSHAKE) && (p[1] == SSL3_VERSION_MAJOR) && (p[5] == SSL3_MT_CLIENT_HELLO) && (p[9] == p[1])) { n=ssl23_read_bytes(s,11); if (n != 11) return(n); v[0]=p[9]; v[1]=p[10]; if (p[2] >= TLS1_VERSION_MINOR) { if (!(s->options & SSL_OP_NO_TLSv1)) { type=3; tls1=1; } else if (!(s->options & SSL_OP_NO_SSLv3)) type=3; } else if (!(s->options & SSL_OP_NO_SSLv3)) type=3; } else if ((strncmp(""GET "", (char *)p,4) == 0) || (strncmp(""POST "",(char *)p,5) == 0) || (strncmp(""HEAD "",(char *)p,5) == 0) || (strncmp(""PUT "", (char *)p,4) == 0)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST); goto err; } else if (strncmp(""CONNECT"",(char *)p,7) == 0) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST); goto err; } } next_bit: if (s->state == SSL23_ST_SR_CLNT_HELLO_B) { type=2; p=s->packet; v[0] = p[3]; v[1] = p[4]; n=((p[0]&0x7f)<<8)|p[1]; if (n > (1024*4)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE); goto err; } j=ssl23_read_bytes(s,n+2); if (j <= 0) return(j); ssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2); p=s->packet; p+=5; n2s(p,csl); n2s(p,sil); n2s(p,cl); d=(unsigned char *)s->init_buf->data; if ((csl+sil+cl+11) != s->packet_length) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH); goto err; } *(d++)=SSL3_VERSION_MAJOR; if (tls1) *(d++)=TLS1_VERSION_MINOR; else *(d++)=SSL3_VERSION_MINOR; i=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl; memset(d,0,SSL3_RANDOM_SIZE); memcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i); d+=SSL3_RANDOM_SIZE; *(d++)=0; j=0; dd=d; d+=2; for (i=0; i<csl; i+=3) { if (p[i] != 0) continue; *(d++)=p[i+1]; *(d++)=p[i+2]; j+=2; } s2n(j,dd); *(d++)=1; *(d++)=0; i=(d-(unsigned char *)s->init_buf->data); s->s3->tmp.reuse_message=1; s->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO; s->s3->tmp.message_size=i; } if (type == 1) { if (s->s2 == NULL) { if (!ssl2_new(s)) goto err; } else ssl2_clear(s); if (s->s3 != NULL) ssl3_free(s); if (!BUF_MEM_grow(s->init_buf, SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)) { goto err; } s->state=SSL2_ST_GET_CLIENT_HELLO_A; if ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) || use_sslv2_strong) s->s2->ssl2_rollback=0; else s->s2->ssl2_rollback=1; s->rstate=SSL_ST_READ_HEADER; s->packet_length=n; s->packet= &(s->s2->rbuf[0]); memcpy(s->packet,buf,n); s->s2->rbuf_left=n; s->s2->rbuf_offs=0; s->method=SSLv2_server_method(); s->handshake_func=s->method->ssl_accept; } if ((type == 2) || (type == 3)) { if (!ssl_init_wbio_buffer(s,1)) goto err; s->state=SSL3_ST_SR_CLNT_HELLO_A; if (type == 3) { s->rstate=SSL_ST_READ_HEADER; s->packet_length=n; s->packet= &(s->s3->rbuf.buf[0]); memcpy(s->packet,buf,n); s->s3->rbuf.left=n; s->s3->rbuf.offset=0; } else { s->packet_length=0; s->s3->rbuf.left=0; s->s3->rbuf.offset=0; } if (tls1) { s->version=TLS1_VERSION; s->method=TLSv1_server_method(); } else { s->version=SSL3_VERSION; s->method=SSLv3_server_method(); } #if 0 s->client_version=(v[0]<<8)|v[1]; #endif s->handshake_func=s->method->ssl_accept; } if ((type < 1) || (type > 3)) { SSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL); goto err; } s->init_num=0; if (buf != buf_space) Free(buf); s->first_packet=1; return(SSL_accept(s)); err: if (buf != buf_space) Free(buf); return(-1); }"
1348----DIVIDE_BY_ZERO----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_49a64f20437fd80ef3330e65973402f92eee83e5_1.json----av_get_int,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out) { int64_t intnum=1; double num=1; int den=1; <S2SV_StartVul> av_get_number(obj, name, o_out, &num, &den, &intnum); <S2SV_EndVul> return num*intnum/den; }","- av_get_number(obj, name, o_out, &num, &den, &intnum);
+ if (av_get_number(obj, name, o_out, &num, &den, &intnum) < 0)
+ return -1;","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out) { int64_t intnum=1; double num=1; int den=1; if (av_get_number(obj, name, o_out, &num, &den, &intnum) < 0) return -1; return num*intnum/den; }"
28----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_01f051b7b0f6bed96361bd551add29db577d0170_1.json----blend_frames_c,"static void blend_frames_c(BLEND_FUNC_PARAMS) { int line, pixel; for (line = 0; line < height; line++) { <S2SV_StartVul> for (pixel = 0; pixel < width; pixel++) { <S2SV_EndVul> <S2SV_StartVul> dst[pixel] = ((src1[pixel] * factor1) + (src2[pixel] * factor2) + 128) >> 8; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> src1 += src1_linesize; src2 += src2_linesize; dst += dst_linesize; } }","- for (pixel = 0; pixel < width; pixel++) {
- dst[pixel] = ((src1[pixel] * factor1) + (src2[pixel] * factor2) + 128) >> 8;
- }
+ for (pixel = 0; pixel < width; pixel++)
+ dst[pixel] = ((src1[pixel] * factor1) + (src2[pixel] * factor2) + half) >> BLEND_FACTOR_DEPTH8;","static void blend_frames_c(BLEND_FUNC_PARAMS) { int line, pixel; for (line = 0; line < height; line++) { for (pixel = 0; pixel < width; pixel++) dst[pixel] = ((src1[pixel] * factor1) + (src2[pixel] * factor2) + half) >> BLEND_FACTOR_DEPTH8; src1 += src1_linesize; src2 += src2_linesize; dst += dst_linesize; } }"
5442----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1cd63c8a590158e29beb847acc3ea6f907f48efa_1.json----decode_cabac_residual_internal,"static av_always_inline void decode_cabac_residual_internal(H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff, int is_dc, int chroma422) { static const int significant_coeff_flag_offset[2][14] = { { 105+0, 105+15, 105+29, 105+44, 105+47, 402, 484+0, 484+15, 484+29, 660, 528+0, 528+15, 528+29, 718 }, { 277+0, 277+15, 277+29, 277+44, 277+47, 436, 776+0, 776+15, 776+29, 675, 820+0, 820+15, 820+29, 733 } }; static const int last_coeff_flag_offset[2][14] = { { 166+0, 166+15, 166+29, 166+44, 166+47, 417, 572+0, 572+15, 572+29, 690, 616+0, 616+15, 616+29, 748 }, { 338+0, 338+15, 338+29, 338+44, 338+47, 451, 864+0, 864+15, 864+29, 699, 908+0, 908+15, 908+29, 757 } }; static const int coeff_abs_level_m1_offset[14] = { 227+0, 227+10, 227+20, 227+30, 227+39, 426, 952+0, 952+10, 952+20, 708, 982+0, 982+10, 982+20, 766 }; static const uint8_t significant_coeff_flag_offset_8x8[2][63] = { { 0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5, 4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7, 7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11, 12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12 }, { 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5, 6, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9, 9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 } }; static const uint8_t sig_coeff_offset_dc[7] = { 0, 0, 1, 1, 2, 2, 2 }; static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 }; static const uint8_t coeff_abs_levelgt1_ctx[2][8] = { { 5, 5, 5, 5, 6, 7, 8, 9 }, { 5, 5, 5, 5, 6, 7, 8, 8 }, }; static const uint8_t coeff_abs_level_transition[2][8] = { { 1, 2, 3, 3, 4, 5, 6, 7 }, { 4, 4, 4, 4, 5, 6, 7, 7 } }; int index[64]; int av_unused last; int coeff_count = 0; int node_ctx = 0; uint8_t *significant_coeff_ctx_base; uint8_t *last_coeff_ctx_base; uint8_t *abs_level_m1_ctx_base; #if !ARCH_X86 #define CABAC_ON_STACK #endif #ifdef CABAC_ON_STACK #define CC &cc CABACContext cc; cc.range = h->cabac.range; cc.low = h->cabac.low; cc.bytestream= h->cabac.bytestream; cc.bytestream_end = h->cabac.bytestream_end; #else #define CC &h->cabac #endif significant_coeff_ctx_base = h->cabac_state + significant_coeff_flag_offset[MB_FIELD][cat]; last_coeff_ctx_base = h->cabac_state + last_coeff_flag_offset[MB_FIELD][cat]; abs_level_m1_ctx_base = h->cabac_state + coeff_abs_level_m1_offset[cat]; if( !is_dc && max_coeff == 64 ) { #define DECODE_SIGNIFICANCE(coefs,sig_off,last_off) \ for(last= 0; last < coefs; last++) { \ uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \ if( get_cabac( CC, sig_ctx )) { \ uint8_t *last_ctx = last_coeff_ctx_base + last_off; \ index[coeff_count++] = last; \ if( get_cabac( CC, last_ctx ) ) { \ last= max_coeff; \ break; \ } \ } \ }\ if( last == max_coeff -1 ) {\ index[coeff_count++] = last;\ } const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD]; #if ARCH_X86 && HAVE_7REGS && !defined(BROKEN_RELOCATIONS) coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, last_coeff_ctx_base, sig_off); } else { if (is_dc && chroma422) { DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]); } else { coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index, last_coeff_ctx_base-significant_coeff_ctx_base); } #else <S2SV_StartVul> DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] ); <S2SV_EndVul> } else { if (is_dc && chroma422) { DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]); } else { DECODE_SIGNIFICANCE(max_coeff - 1, last, last); } #endif } assert(coeff_count > 0); if( is_dc ) { if( cat == 3 ) h->cbp_table[h->mb_xy] |= 0x40 << (n - CHROMA_DC_BLOCK_INDEX); else h->cbp_table[h->mb_xy] |= 0x100 << (n - LUMA_DC_BLOCK_INDEX); h->non_zero_count_cache[scan8[n]] = coeff_count; } else { if( max_coeff == 64 ) fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1); else { assert( cat == 1 || cat == 2 || cat == 4 || cat == 7 || cat == 8 || cat == 11 || cat == 12 ); h->non_zero_count_cache[scan8[n]] = coeff_count; } } #define STORE_BLOCK(type) \ do { \ uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base; \ \ int j= scantable[index[--coeff_count]]; \ \ if( get_cabac( CC, ctx ) == 0 ) { \ node_ctx = coeff_abs_level_transition[0][node_ctx]; \ if( is_dc ) { \ ((type*)block)[j] = get_cabac_bypass_sign( CC, -1); \ }else{ \ ((type*)block)[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6; \ } \ } else { \ int coeff_abs = 2; \ ctx = coeff_abs_levelgt1_ctx[is_dc && chroma422][node_ctx] + abs_level_m1_ctx_base; \ node_ctx = coeff_abs_level_transition[1][node_ctx]; \ \ while( coeff_abs < 15 && get_cabac( CC, ctx ) ) { \ coeff_abs++; \ } \ \ if( coeff_abs >= 15 ) { \ int j = 0; \ while( get_cabac_bypass( CC ) ) { \ j++; \ } \ \ coeff_abs=1; \ while( j-- ) { \ coeff_abs += coeff_abs + get_cabac_bypass( CC ); \ } \ coeff_abs+= 14; \ } \ \ if( is_dc ) { \ ((type*)block)[j] = get_cabac_bypass_sign( CC, -coeff_abs ); \ }else{ \ ((type*)block)[j] = ((int)(get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32)) >> 6; \ } \ } \ } while ( coeff_count ); if (h->pixel_shift) { STORE_BLOCK(int32_t) } else { STORE_BLOCK(int16_t) } #ifdef CABAC_ON_STACK h->cabac.range = cc.range ; h->cabac.low = cc.low ; h->cabac.bytestream= cc.bytestream; #endif }","- DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );
+ DECODE_SIGNIFICANCE( 63, sig_off[last], ff_h264_last_coeff_flag_offset_8x8[last] );","static av_always_inline void decode_cabac_residual_internal(H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff, int is_dc, int chroma422) { static const int significant_coeff_flag_offset[2][14] = { { 105+0, 105+15, 105+29, 105+44, 105+47, 402, 484+0, 484+15, 484+29, 660, 528+0, 528+15, 528+29, 718 }, { 277+0, 277+15, 277+29, 277+44, 277+47, 436, 776+0, 776+15, 776+29, 675, 820+0, 820+15, 820+29, 733 } }; static const int last_coeff_flag_offset[2][14] = { { 166+0, 166+15, 166+29, 166+44, 166+47, 417, 572+0, 572+15, 572+29, 690, 616+0, 616+15, 616+29, 748 }, { 338+0, 338+15, 338+29, 338+44, 338+47, 451, 864+0, 864+15, 864+29, 699, 908+0, 908+15, 908+29, 757 } }; static const int coeff_abs_level_m1_offset[14] = { 227+0, 227+10, 227+20, 227+30, 227+39, 426, 952+0, 952+10, 952+20, 708, 982+0, 982+10, 982+20, 766 }; static const uint8_t significant_coeff_flag_offset_8x8[2][63] = { { 0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5, 4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7, 7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11, 12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12 }, { 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5, 6, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9, 9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 } }; static const uint8_t sig_coeff_offset_dc[7] = { 0, 0, 1, 1, 2, 2, 2 }; static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 }; static const uint8_t coeff_abs_levelgt1_ctx[2][8] = { { 5, 5, 5, 5, 6, 7, 8, 9 }, { 5, 5, 5, 5, 6, 7, 8, 8 }, }; static const uint8_t coeff_abs_level_transition[2][8] = { { 1, 2, 3, 3, 4, 5, 6, 7 }, { 4, 4, 4, 4, 5, 6, 7, 7 } }; int index[64]; int av_unused last; int coeff_count = 0; int node_ctx = 0; uint8_t *significant_coeff_ctx_base; uint8_t *last_coeff_ctx_base; uint8_t *abs_level_m1_ctx_base; #if !ARCH_X86 #define CABAC_ON_STACK #endif #ifdef CABAC_ON_STACK #define CC &cc CABACContext cc; cc.range = h->cabac.range; cc.low = h->cabac.low; cc.bytestream= h->cabac.bytestream; cc.bytestream_end = h->cabac.bytestream_end; #else #define CC &h->cabac #endif significant_coeff_ctx_base = h->cabac_state + significant_coeff_flag_offset[MB_FIELD][cat]; last_coeff_ctx_base = h->cabac_state + last_coeff_flag_offset[MB_FIELD][cat]; abs_level_m1_ctx_base = h->cabac_state + coeff_abs_level_m1_offset[cat]; if( !is_dc && max_coeff == 64 ) { #define DECODE_SIGNIFICANCE(coefs,sig_off,last_off) \ for(last= 0; last < coefs; last++) { \ uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \ if( get_cabac( CC, sig_ctx )) { \ uint8_t *last_ctx = last_coeff_ctx_base + last_off; \ index[coeff_count++] = last; \ if( get_cabac( CC, last_ctx ) ) { \ last= max_coeff; \ break; \ } \ } \ }\ if( last == max_coeff -1 ) {\ index[coeff_count++] = last;\ } const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD]; #if ARCH_X86 && HAVE_7REGS && !defined(BROKEN_RELOCATIONS) coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, last_coeff_ctx_base, sig_off); } else { if (is_dc && chroma422) { DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]); } else { coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index, last_coeff_ctx_base-significant_coeff_ctx_base); } #else DECODE_SIGNIFICANCE( 63, sig_off[last], ff_h264_last_coeff_flag_offset_8x8[last] ); } else { if (is_dc && chroma422) { DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]); } else { DECODE_SIGNIFICANCE(max_coeff - 1, last, last); } #endif } assert(coeff_count > 0); if( is_dc ) { if( cat == 3 ) h->cbp_table[h->mb_xy] |= 0x40 << (n - CHROMA_DC_BLOCK_INDEX); else h->cbp_table[h->mb_xy] |= 0x100 << (n - LUMA_DC_BLOCK_INDEX); h->non_zero_count_cache[scan8[n]] = coeff_count; } else { if( max_coeff == 64 ) fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1); else { assert( cat == 1 || cat == 2 || cat == 4 || cat == 7 || cat == 8 || cat == 11 || cat == 12 ); h->non_zero_count_cache[scan8[n]] = coeff_count; } } #define STORE_BLOCK(type) \ do { \ uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base; \ \ int j= scantable[index[--coeff_count]]; \ \ if( get_cabac( CC, ctx ) == 0 ) { \ node_ctx = coeff_abs_level_transition[0][node_ctx]; \ if( is_dc ) { \ ((type*)block)[j] = get_cabac_bypass_sign( CC, -1); \ }else{ \ ((type*)block)[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6; \ } \ } else { \ int coeff_abs = 2; \ ctx = coeff_abs_levelgt1_ctx[is_dc && chroma422][node_ctx] + abs_level_m1_ctx_base; \ node_ctx = coeff_abs_level_transition[1][node_ctx]; \ \ while( coeff_abs < 15 && get_cabac( CC, ctx ) ) { \ coeff_abs++; \ } \ \ if( coeff_abs >= 15 ) { \ int j = 0; \ while( get_cabac_bypass( CC ) ) { \ j++; \ } \ \ coeff_abs=1; \ while( j-- ) { \ coeff_abs += coeff_abs + get_cabac_bypass( CC ); \ } \ coeff_abs+= 14; \ } \ \ if( is_dc ) { \ ((type*)block)[j] = get_cabac_bypass_sign( CC, -coeff_abs ); \ }else{ \ ((type*)block)[j] = ((int)(get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32)) >> 6; \ } \ } \ } while ( coeff_count ); if (h->pixel_shift) { STORE_BLOCK(int32_t) } else { STORE_BLOCK(int16_t) } #ifdef CABAC_ON_STACK h->cabac.range = cc.range ; h->cabac.low = cc.low ; h->cabac.bytestream= cc.bytestream; #endif }"
594----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_21345d971ad82f01390813a2312822322913ced7_1.json----tta_decode_frame,"static int tta_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TTAContext *s = avctx->priv_data; int i; init_get_bits(&s->gb, buf, buf_size*8); { int32_t predictors[s->channels]; TTAFilter filters[s->channels]; TTARice rices[s->channels]; int cur_chan = 0, framelen = s->frame_length; int32_t *p; s->total_frames--; if (!s->total_frames && s->last_frame_length) framelen = s->last_frame_length; for (i = 0; i < s->channels; i++) { predictors[i] = 0; ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]); rice_init(&(rices[i]), 10, 10); } for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { int32_t *predictor = &(predictors[cur_chan]); TTAFilter *filter = &(filters[cur_chan]); TTARice *rice = &(rices[cur_chan]); uint32_t unary, depth, k; int32_t value; unary = tta_get_unary(&s->gb); if (unary == 0) { depth = 0; k = rice->k0; } else { depth = 1; k = rice->k1; unary--; } <S2SV_StartVul> if (k) <S2SV_EndVul> value = (unary << k) + get_bits(&s->gb, k); <S2SV_StartVul> else <S2SV_EndVul> value = unary; switch (depth) { case 1: rice->sum1 += value - (rice->sum1 >> 4); if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1]) rice->k1--; else if(rice->sum1 > shift_16[rice->k1 + 1]) rice->k1++; value += shift_1[rice->k0]; default: rice->sum0 += value - (rice->sum0 >> 4); if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0]) rice->k0--; else if(rice->sum0 > shift_16[rice->k0 + 1]) rice->k0++; } #define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1)) *p = UNFOLD(value); ttafilter_process(filter, p, 0); #define PRED(x,k) (int32_t)((((uint64_t)x << k) - x) >> k) switch (s->bps) { case 1: *p += PRED(*predictor, 4); break; case 2: case 3: *p += PRED(*predictor, 5); break; case 4: *p += *predictor; break; } *predictor = *p; #if 0 if (s->is_float && ((p - data) & 1)) { uint32_t neg = *p & 0x80000000; uint32_t hi = *(p - 1); uint32_t lo = abs(*p) - 1; hi += (hi || lo) ? 0x3f80 : 0; *(p - 1) = (hi << 16) | SWAP16(lo) | neg; } #endif if (cur_chan < (s->channels-1)) cur_chan++; else { if (!s->is_float && (s->channels > 1)) { int32_t *r = p - 1; for (*p += *r / 2; r > p - s->channels; r--) *r = *(r + 1) - *r; } cur_chan = 0; } } skip_bits(&s->gb, 32); switch(s->bps) { case 2: { uint16_t *samples = data; for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { *samples++ = *p; } *data_size = (uint8_t *)samples - (uint8_t *)data; break; } default: av_log(s->avctx, AV_LOG_ERROR, ""Error, only 16bit samples supported!\n""); } } return buf_size; }","- if (k)
- else
+ if (get_bits_left(&s->gb) < k)
+ return -1;
+ if (k) {
+ if (k > MIN_CACHE_BITS)
+ return -1;
+ } else
+ if (get_bits_left(&s->gb) < 32)
+ return -1;","static int tta_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TTAContext *s = avctx->priv_data; int i; init_get_bits(&s->gb, buf, buf_size*8); { int32_t predictors[s->channels]; TTAFilter filters[s->channels]; TTARice rices[s->channels]; int cur_chan = 0, framelen = s->frame_length; int32_t *p; s->total_frames--; if (!s->total_frames && s->last_frame_length) framelen = s->last_frame_length; for (i = 0; i < s->channels; i++) { predictors[i] = 0; ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]); rice_init(&(rices[i]), 10, 10); } for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { int32_t *predictor = &(predictors[cur_chan]); TTAFilter *filter = &(filters[cur_chan]); TTARice *rice = &(rices[cur_chan]); uint32_t unary, depth, k; int32_t value; unary = tta_get_unary(&s->gb); if (unary == 0) { depth = 0; k = rice->k0; } else { depth = 1; k = rice->k1; unary--; } if (get_bits_left(&s->gb) < k) return -1; if (k) { if (k > MIN_CACHE_BITS) return -1; value = (unary << k) + get_bits(&s->gb, k); } else value = unary; switch (depth) { case 1: rice->sum1 += value - (rice->sum1 >> 4); if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1]) rice->k1--; else if(rice->sum1 > shift_16[rice->k1 + 1]) rice->k1++; value += shift_1[rice->k0]; default: rice->sum0 += value - (rice->sum0 >> 4); if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0]) rice->k0--; else if(rice->sum0 > shift_16[rice->k0 + 1]) rice->k0++; } #define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1)) *p = UNFOLD(value); ttafilter_process(filter, p, 0); #define PRED(x,k) (int32_t)((((uint64_t)x << k) - x) >> k) switch (s->bps) { case 1: *p += PRED(*predictor, 4); break; case 2: case 3: *p += PRED(*predictor, 5); break; case 4: *p += *predictor; break; } *predictor = *p; #if 0 if (s->is_float && ((p - data) & 1)) { uint32_t neg = *p & 0x80000000; uint32_t hi = *(p - 1); uint32_t lo = abs(*p) - 1; hi += (hi || lo) ? 0x3f80 : 0; *(p - 1) = (hi << 16) | SWAP16(lo) | neg; } #endif if (cur_chan < (s->channels-1)) cur_chan++; else { if (!s->is_float && (s->channels > 1)) { int32_t *r = p - 1; for (*p += *r / 2; r > p - s->channels; r--) *r = *(r + 1) - *r; } cur_chan = 0; } } if (get_bits_left(&s->gb) < 32) return -1; skip_bits(&s->gb, 32); switch(s->bps) { case 2: { uint16_t *samples = data; for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { *samples++ = *p; } *data_size = (uint8_t *)samples - (uint8_t *)data; break; } default: av_log(s->avctx, AV_LOG_ERROR, ""Error, only 16bit samples supported!\n""); } } return buf_size; }"
6617----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_645f5b2750930839b111371c80149132c9757ded_1.json----parse_h264_sdp_line,"static int parse_h264_sdp_line(AVFormatContext *s, int st_index, PayloadContext *h264_data, const char *line) { AVStream *stream = s->streams[st_index]; AVCodecContext *codec = stream->codec; const char *p = line; assert(h264_data->cookie == MAGIC_COOKIE); if (av_strstart(p, ""framesize:"", &p)) { char buf1[50]; char *dst = buf1; while (*p && *p == ' ') p++; while (*p && *p != ' ') p++; while (*p && *p == ' ') p++; <S2SV_StartVul> while (*p && *p != '-' && (buf1 - dst) < sizeof(buf1) - 1) { <S2SV_EndVul> *dst++ = *p++; } *dst = '\0'; codec->width = atoi(buf1); codec->height = atoi(p + 1); codec->pix_fmt = PIX_FMT_YUV420P; } else if (av_strstart(p, ""fmtp:"", &p)) { char attr[256]; char value[4096]; while (*p && *p == ' ') p++; while (*p && *p != ' ') p++; while (*p && *p == ' ') p++; while (rtsp_next_attr_and_value (&p, attr, sizeof(attr), value, sizeof(value))) { sdp_parse_fmtp_config_h264(stream, h264_data, attr, value); } } else if (av_strstart(p, ""cliprect:"", &p)) { } av_set_pts_info(stream, 33, 1, 90000); return 0; }","- while (*p && *p != '-' && (buf1 - dst) < sizeof(buf1) - 1) {
+ while (*p && *p != '-' && (dst - buf1) < sizeof(buf1) - 1) {","static int parse_h264_sdp_line(AVFormatContext *s, int st_index, PayloadContext *h264_data, const char *line) { AVStream *stream = s->streams[st_index]; AVCodecContext *codec = stream->codec; const char *p = line; assert(h264_data->cookie == MAGIC_COOKIE); if (av_strstart(p, ""framesize:"", &p)) { char buf1[50]; char *dst = buf1; while (*p && *p == ' ') p++; while (*p && *p != ' ') p++; while (*p && *p == ' ') p++; while (*p && *p != '-' && (dst - buf1) < sizeof(buf1) - 1) { *dst++ = *p++; } *dst = '\0'; codec->width = atoi(buf1); codec->height = atoi(p + 1); codec->pix_fmt = PIX_FMT_YUV420P; } else if (av_strstart(p, ""fmtp:"", &p)) { char attr[256]; char value[4096]; while (*p && *p == ' ') p++; while (*p && *p != ' ') p++; while (*p && *p == ' ') p++; while (rtsp_next_attr_and_value (&p, attr, sizeof(attr), value, sizeof(value))) { sdp_parse_fmtp_config_h264(stream, h264_data, attr, value); } } else if (av_strstart(p, ""cliprect:"", &p)) { } av_set_pts_info(stream, 33, 1, 90000); return 0; }"
2409----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_84997102a67e8c1aa24c8ba3ee798a490b330d2f_1.json----xan_decode_chroma,"static int xan_decode_chroma(AVCodecContext *avctx, unsigned chroma_off) { XanContext *s = avctx->priv_data; uint8_t *U, *V; int val, uval, vval; int i, j; const uint8_t *src, *src_end; const uint8_t *table; <S2SV_StartVul> int mode, offset, dec_size; <S2SV_EndVul> if (!chroma_off) return 0; if (chroma_off + 4 >= bytestream2_get_bytes_left(&s->gb)) { av_log(avctx, AV_LOG_ERROR, ""Invalid chroma block position\n""); return -1; } bytestream2_seek(&s->gb, chroma_off + 4, SEEK_SET); <S2SV_StartVul> mode = bytestream2_get_le16(&s->gb); <S2SV_EndVul> <S2SV_StartVul> table = s->gb.buffer; <S2SV_EndVul> <S2SV_StartVul> offset = bytestream2_get_le16(&s->gb) * 2; <S2SV_EndVul> if (offset >= bytestream2_get_bytes_left(&s->gb)) { av_log(avctx, AV_LOG_ERROR, ""Invalid chroma block offset\n""); return -1; } bytestream2_skip(&s->gb, offset); memset(s->scratch_buffer, 0, s->buffer_size); dec_size = xan_unpack(s, s->scratch_buffer, s->buffer_size); if (dec_size < 0) { av_log(avctx, AV_LOG_ERROR, ""Chroma unpacking failed\n""); return -1; } U = s->pic.data[1]; V = s->pic.data[2]; src = s->scratch_buffer; src_end = src + dec_size; if (mode) { for (j = 0; j < avctx->height >> 1; j++) { for (i = 0; i < avctx->width >> 1; i++) { val = *src++; <S2SV_StartVul> if (val) { <S2SV_EndVul> val = AV_RL16(table + (val << 1)); uval = (val >> 3) & 0xF8; vval = (val >> 8) & 0xF8; U[i] = uval | (uval >> 5); V[i] = vval | (vval >> 5); } if (src == src_end) return 0; } U += s->pic.linesize[1]; V += s->pic.linesize[2]; } } else { uint8_t *U2 = U + s->pic.linesize[1]; uint8_t *V2 = V + s->pic.linesize[2]; for (j = 0; j < avctx->height >> 2; j++) { for (i = 0; i < avctx->width >> 1; i += 2) { val = *src++; <S2SV_StartVul> if (val) { <S2SV_EndVul> val = AV_RL16(table + (val << 1)); uval = (val >> 3) & 0xF8; vval = (val >> 8) & 0xF8; U[i] = U[i+1] = U2[i] = U2[i+1] = uval | (uval >> 5); V[i] = V[i+1] = V2[i] = V2[i+1] = vval | (vval >> 5); } } U += s->pic.linesize[1] * 2; V += s->pic.linesize[2] * 2; U2 += s->pic.linesize[1] * 2; V2 += s->pic.linesize[2] * 2; } } return 0; }","- int mode, offset, dec_size;
- mode = bytestream2_get_le16(&s->gb);
- table = s->gb.buffer;
- offset = bytestream2_get_le16(&s->gb) * 2;
- if (val) {
- if (val) {
+ int mode, offset, dec_size, table_size;
+ mode = bytestream2_get_le16(&s->gb);
+ table = s->gb.buffer;
+ table_size = bytestream2_get_le16(&s->gb);
+ offset = table_size * 2;
+ table_size += 1;
+ if (val && val < table_size) {
+ if (val && val < table_size) {","static int xan_decode_chroma(AVCodecContext *avctx, unsigned chroma_off) { XanContext *s = avctx->priv_data; uint8_t *U, *V; int val, uval, vval; int i, j; const uint8_t *src, *src_end; const uint8_t *table; int mode, offset, dec_size, table_size; if (!chroma_off) return 0; if (chroma_off + 4 >= bytestream2_get_bytes_left(&s->gb)) { av_log(avctx, AV_LOG_ERROR, ""Invalid chroma block position\n""); return -1; } bytestream2_seek(&s->gb, chroma_off + 4, SEEK_SET); mode = bytestream2_get_le16(&s->gb); table = s->gb.buffer; table_size = bytestream2_get_le16(&s->gb); offset = table_size * 2; table_size += 1; if (offset >= bytestream2_get_bytes_left(&s->gb)) { av_log(avctx, AV_LOG_ERROR, ""Invalid chroma block offset\n""); return -1; } bytestream2_skip(&s->gb, offset); memset(s->scratch_buffer, 0, s->buffer_size); dec_size = xan_unpack(s, s->scratch_buffer, s->buffer_size); if (dec_size < 0) { av_log(avctx, AV_LOG_ERROR, ""Chroma unpacking failed\n""); return -1; } U = s->pic.data[1]; V = s->pic.data[2]; src = s->scratch_buffer; src_end = src + dec_size; if (mode) { for (j = 0; j < avctx->height >> 1; j++) { for (i = 0; i < avctx->width >> 1; i++) { val = *src++; if (val && val < table_size) { val = AV_RL16(table + (val << 1)); uval = (val >> 3) & 0xF8; vval = (val >> 8) & 0xF8; U[i] = uval | (uval >> 5); V[i] = vval | (vval >> 5); } if (src == src_end) return 0; } U += s->pic.linesize[1]; V += s->pic.linesize[2]; } } else { uint8_t *U2 = U + s->pic.linesize[1]; uint8_t *V2 = V + s->pic.linesize[2]; for (j = 0; j < avctx->height >> 2; j++) { for (i = 0; i < avctx->width >> 1; i += 2) { val = *src++; if (val && val < table_size) { val = AV_RL16(table + (val << 1)); uval = (val >> 3) & 0xF8; vval = (val >> 8) & 0xF8; U[i] = U[i+1] = U2[i] = U2[i+1] = uval | (uval >> 5); V[i] = V[i+1] = V2[i] = V2[i+1] = vval | (vval >> 5); } } U += s->pic.linesize[1] * 2; V += s->pic.linesize[2] * 2; U2 += s->pic.linesize[1] * 2; V2 += s->pic.linesize[2] * 2; } } return 0; }"
8614----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d98d9281674a5441d8b3cd0ba666ec1ef87124f6_1.json----flv_write_packet,"static int flv_write_packet(AVFormatContext *s, AVPacket *pkt) { AVIOContext *pb = s->pb; AVCodecContext *enc = s->streams[pkt->stream_index]->codec; FLVContext *flv = s->priv_data; FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data; unsigned ts; int size = pkt->size; uint8_t *data = NULL; <S2SV_StartVul> int flags, flags_size; <S2SV_EndVul> if (enc->codec_id == AV_CODEC_ID_VP6 || enc->codec_id == AV_CODEC_ID_VP6F || enc->codec_id == AV_CODEC_ID_AAC) flags_size = 2; else if (enc->codec_id == AV_CODEC_ID_H264) flags_size = 5; else flags_size = 1; switch (enc->codec_type) { case AVMEDIA_TYPE_VIDEO: avio_w8(pb, FLV_TAG_TYPE_VIDEO); flags = enc->codec_tag; if (flags == 0) { av_log(s, AV_LOG_ERROR, ""video codec %X not compatible with flv\n"", enc->codec_id); return -1; } flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER; break; case AVMEDIA_TYPE_AUDIO: flags = get_audio_flags(s, enc); assert(size); avio_w8(pb, FLV_TAG_TYPE_AUDIO); break; case AVMEDIA_TYPE_DATA: avio_w8(pb, FLV_TAG_TYPE_META); break; default: return AVERROR(EINVAL); } if (enc->codec_id == AV_CODEC_ID_H264) if (enc->extradata_size > 0 && *(uint8_t*)enc->extradata != 1) if (ff_avc_parse_nal_units_buf(pkt->data, &data, &size) < 0) return -1; if (flv->delay == AV_NOPTS_VALUE) flv->delay = -pkt->dts; if (pkt->dts < -flv->delay) { av_log(s, AV_LOG_WARNING, ""Packets are not in the proper order with respect to DTS\n""); return AVERROR(EINVAL); } ts = pkt->dts + flv->delay; if (enc->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160) av_log(s, AV_LOG_WARNING, ""Warning: Speex stream has more than "" ""8 frames per packet. Adobe Flash "" ""Player cannot handle this!\n""); if (sc->last_ts < ts) sc->last_ts = ts; avio_wb24(pb, size + flags_size); avio_wb24(pb, ts); avio_w8(pb, (ts >> 24) & 0x7F); avio_wb24(pb, flv->reserved); if (enc->codec_type == AVMEDIA_TYPE_DATA) { int data_size; int metadata_size_pos = avio_tell(pb); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, ""onTextData""); avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY); avio_wb32(pb, 2); put_amf_string(pb, ""type""); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, ""Text""); put_amf_string(pb, ""text""); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, pkt->data); put_amf_string(pb, """"); avio_w8(pb, AMF_END_OF_OBJECT); data_size = avio_tell(pb) - metadata_size_pos; avio_seek(pb, metadata_size_pos - 10, SEEK_SET); avio_wb24(pb, data_size); avio_seek(pb, data_size + 10 - 3, SEEK_CUR); avio_wb32(pb, data_size + 11); } else { avio_w8(pb,flags); if (enc->codec_id == AV_CODEC_ID_VP6) avio_w8(pb, 0); if (enc->codec_id == AV_CODEC_ID_VP6F) avio_w8(pb, enc->extradata_size ? enc->extradata[0] : 0); else if (enc->codec_id == AV_CODEC_ID_AAC) avio_w8(pb, 1); else if (enc->codec_id == AV_CODEC_ID_H264) { avio_w8(pb, 1); avio_wb24(pb, pkt->pts - pkt->dts); } avio_write(pb, data ? data : pkt->data, size); avio_wb32(pb, size + flags_size + 11); flv->duration = FFMAX(flv->duration, pkt->pts + flv->delay + pkt->duration); } avio_flush(pb); av_free(data); return pb->error; }","- int flags, flags_size;
+ int flags = 0, flags_size;","static int flv_write_packet(AVFormatContext *s, AVPacket *pkt) { AVIOContext *pb = s->pb; AVCodecContext *enc = s->streams[pkt->stream_index]->codec; FLVContext *flv = s->priv_data; FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data; unsigned ts; int size = pkt->size; uint8_t *data = NULL; int flags = 0, flags_size; if (enc->codec_id == AV_CODEC_ID_VP6 || enc->codec_id == AV_CODEC_ID_VP6F || enc->codec_id == AV_CODEC_ID_AAC) flags_size = 2; else if (enc->codec_id == AV_CODEC_ID_H264) flags_size = 5; else flags_size = 1; switch (enc->codec_type) { case AVMEDIA_TYPE_VIDEO: avio_w8(pb, FLV_TAG_TYPE_VIDEO); flags = enc->codec_tag; if (flags == 0) { av_log(s, AV_LOG_ERROR, ""video codec %X not compatible with flv\n"", enc->codec_id); return -1; } flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER; break; case AVMEDIA_TYPE_AUDIO: flags = get_audio_flags(s, enc); assert(size); avio_w8(pb, FLV_TAG_TYPE_AUDIO); break; case AVMEDIA_TYPE_DATA: avio_w8(pb, FLV_TAG_TYPE_META); break; default: return AVERROR(EINVAL); } if (enc->codec_id == AV_CODEC_ID_H264) if (enc->extradata_size > 0 && *(uint8_t*)enc->extradata != 1) if (ff_avc_parse_nal_units_buf(pkt->data, &data, &size) < 0) return -1; if (flv->delay == AV_NOPTS_VALUE) flv->delay = -pkt->dts; if (pkt->dts < -flv->delay) { av_log(s, AV_LOG_WARNING, ""Packets are not in the proper order with respect to DTS\n""); return AVERROR(EINVAL); } ts = pkt->dts + flv->delay; if (enc->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160) av_log(s, AV_LOG_WARNING, ""Warning: Speex stream has more than "" ""8 frames per packet. Adobe Flash "" ""Player cannot handle this!\n""); if (sc->last_ts < ts) sc->last_ts = ts; avio_wb24(pb, size + flags_size); avio_wb24(pb, ts); avio_w8(pb, (ts >> 24) & 0x7F); avio_wb24(pb, flv->reserved); if (enc->codec_type == AVMEDIA_TYPE_DATA) { int data_size; int metadata_size_pos = avio_tell(pb); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, ""onTextData""); avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY); avio_wb32(pb, 2); put_amf_string(pb, ""type""); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, ""Text""); put_amf_string(pb, ""text""); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, pkt->data); put_amf_string(pb, """"); avio_w8(pb, AMF_END_OF_OBJECT); data_size = avio_tell(pb) - metadata_size_pos; avio_seek(pb, metadata_size_pos - 10, SEEK_SET); avio_wb24(pb, data_size); avio_seek(pb, data_size + 10 - 3, SEEK_CUR); avio_wb32(pb, data_size + 11); } else { avio_w8(pb,flags); if (enc->codec_id == AV_CODEC_ID_VP6) avio_w8(pb, 0); if (enc->codec_id == AV_CODEC_ID_VP6F) avio_w8(pb, enc->extradata_size ? enc->extradata[0] : 0); else if (enc->codec_id == AV_CODEC_ID_AAC) avio_w8(pb, 1); else if (enc->codec_id == AV_CODEC_ID_H264) { avio_w8(pb, 1); avio_wb24(pb, pkt->pts - pkt->dts); } avio_write(pb, data ? data : pkt->data, size); avio_wb32(pb, size + flags_size + 11); flv->duration = FFMAX(flv->duration, pkt->pts + flv->delay + pkt->duration); } avio_flush(pb); av_free(data); return pb->error; }"
16375----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d59bb0574da62e8e39dfdb15422c99dc13583538_1.json----ssl3_get_message,"long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok) { unsigned char *p; unsigned long l; long n; int i,al; if (s->s3->tmp.reuse_message) { s->s3->tmp.reuse_message=0; if ((mt >= 0) && (s->s3->tmp.message_type != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } *ok=1; return((int)s->s3->tmp.message_size); } p=(unsigned char *)s->init_buf->data; if (s->state == st1) { int skip_message; do { while (s->init_num < 4) { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num], <S2SV_StartVul> 4-s->init_num); <S2SV_EndVul> if (i <= 0) { s->rwstate=SSL_READING; *ok = 0; return i; } s->init_num+=i; } skip_message = 0; if (!s->server) if (p[0] == SSL3_MT_HELLO_REQUEST) <S2SV_EndVul> if (p[1] == 0 && p[2] == 0 &&p[3] == 0) skip_message = 1; } while (skip_message); if ((mt >= 0) && (*p != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } if((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) && (st1 == SSL3_ST_SR_CERT_A) && (stn == SSL3_ST_SR_CERT_B)) { ssl3_init_finished_mac(s); <S2SV_StartVul> ssl3_finish_mac(s, p + s->init_num, i); <S2SV_EndVul> } s->s3->tmp.message_type= *(p++); n2l3(p,l); if (l > (unsigned long)max) { al=SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE); goto f_err; } if (l && !BUF_MEM_grow(s->init_buf,(int)l)) { SSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB); goto err; } s->s3->tmp.message_size=l; s->state=stn; s->init_num=0; } p=(unsigned char *)s->init_buf->data; n=s->s3->tmp.message_size; while (n > 0) { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n); if (i <= 0) { s->rwstate=SSL_READING; *ok = 0; return i; } s->init_num += i; n -= i; } *ok=1; return s->init_num; f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); err: *ok=0; return(-1); }","- 4-s->init_num);
- ssl3_finish_mac(s, p + s->init_num, i);
+ 4 - s->init_num);
+ ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, 4);
+ ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num);","long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok) { unsigned char *p; unsigned long l; long n; int i,al; if (s->s3->tmp.reuse_message) { s->s3->tmp.reuse_message=0; if ((mt >= 0) && (s->s3->tmp.message_type != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } *ok=1; return((int)s->s3->tmp.message_size); } p=(unsigned char *)s->init_buf->data; if (s->state == st1) { int skip_message; do { while (s->init_num < 4) { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num], 4 - s->init_num); if (i <= 0) { s->rwstate=SSL_READING; *ok = 0; return i; } s->init_num+=i; } skip_message = 0; if (!s->server) if (p[0] == SSL3_MT_HELLO_REQUEST) if (p[1] == 0 && p[2] == 0 &&p[3] == 0) skip_message = 1; } while (skip_message); if ((mt >= 0) && (*p != mt)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE); goto f_err; } if((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) && (st1 == SSL3_ST_SR_CERT_A) && (stn == SSL3_ST_SR_CERT_B)) { ssl3_init_finished_mac(s); } ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, 4); s->s3->tmp.message_type= *(p++); n2l3(p,l); if (l > (unsigned long)max) { al=SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE); goto f_err; } if (l && !BUF_MEM_grow(s->init_buf,(int)l)) { SSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB); goto err; } s->s3->tmp.message_size=l; s->state=stn; s->init_num=0; } p=(unsigned char *)s->init_buf->data; n=s->s3->tmp.message_size; while (n > 0) { i=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n); if (i <= 0) { s->rwstate=SSL_READING; *ok = 0; return i; } s->init_num += i; n -= i; } ssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num); *ok=1; return s->init_num; f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); err: *ok=0; return(-1); }"
4644----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fa3fa6951f7fc4271429b9486f86c192b01c3118_1.json----decode_audio_specific_config,"static int decode_audio_specific_config(AACContext *ac, AVCodecContext *avctx, MPEG4AudioConfig *m4ac, <S2SV_StartVul> const uint8_t *data, int bit_size, <S2SV_EndVul> int sync_extension) { GetBitContext gb; int i, ret; <S2SV_StartVul> ff_dlog(avctx, ""audio specific config size %d\n"", bit_size >> 3); <S2SV_EndVul> for (i = 0; i < bit_size >> 3; i++) ff_dlog(avctx, ""%02x "", data[i]); ff_dlog(avctx, ""\n""); if ((ret = init_get_bits(&gb, data, bit_size)) < 0) return ret; if ((i = avpriv_mpeg4audio_get_config(m4ac, data, bit_size, sync_extension)) < 0) return AVERROR_INVALIDDATA; if (m4ac->sampling_index > 12) { av_log(avctx, AV_LOG_ERROR, ""invalid sampling rate index %d\n"", m4ac->sampling_index); return AVERROR_INVALIDDATA; } if (m4ac->object_type == AOT_ER_AAC_LD && (m4ac->sampling_index < 3 || m4ac->sampling_index > 7)) { av_log(avctx, AV_LOG_ERROR, ""invalid low delay sampling rate index %d\n"", m4ac->sampling_index); return AVERROR_INVALIDDATA; } skip_bits_long(&gb, i); switch (m4ac->object_type) { case AOT_AAC_MAIN: case AOT_AAC_LC: case AOT_AAC_LTP: case AOT_ER_AAC_LC: case AOT_ER_AAC_LD: if ((ret = decode_ga_specific_config(ac, avctx, &gb, m4ac, m4ac->chan_config)) < 0) return ret; break; case AOT_ER_AAC_ELD: if ((ret = decode_eld_specific_config(ac, avctx, &gb, m4ac, m4ac->chan_config)) < 0) return ret; break; default: avpriv_report_missing_feature(avctx, ""Audio object type %s%d"", m4ac->sbr == 1 ? ""SBR+"" : """", m4ac->object_type); return AVERROR(ENOSYS); } ff_dlog(avctx, ""AOT %d chan config %d sampling index %d (%d) SBR %d PS %d\n"", m4ac->object_type, m4ac->chan_config, m4ac->sampling_index, m4ac->sample_rate, m4ac->sbr, m4ac->ps); return get_bits_count(&gb); }","- const uint8_t *data, int bit_size,
- ff_dlog(avctx, ""audio specific config size %d\n"", bit_size >> 3);
+ const uint8_t *data, int64_t bit_size,
+ if (bit_size < 0 || bit_size > INT_MAX) {
+ av_log(avctx, AV_LOG_ERROR, ""Audio specific config size is invalid\n"");
+ return AVERROR_INVALIDDATA;
+ }
+ ff_dlog(avctx, ""audio specific config size %d\n"", (int)bit_size >> 3);","static int decode_audio_specific_config(AACContext *ac, AVCodecContext *avctx, MPEG4AudioConfig *m4ac, const uint8_t *data, int64_t bit_size, int sync_extension) { GetBitContext gb; int i, ret; if (bit_size < 0 || bit_size > INT_MAX) { av_log(avctx, AV_LOG_ERROR, ""Audio specific config size is invalid\n""); return AVERROR_INVALIDDATA; } ff_dlog(avctx, ""audio specific config size %d\n"", (int)bit_size >> 3); for (i = 0; i < bit_size >> 3; i++) ff_dlog(avctx, ""%02x "", data[i]); ff_dlog(avctx, ""\n""); if ((ret = init_get_bits(&gb, data, bit_size)) < 0) return ret; if ((i = avpriv_mpeg4audio_get_config(m4ac, data, bit_size, sync_extension)) < 0) return AVERROR_INVALIDDATA; if (m4ac->sampling_index > 12) { av_log(avctx, AV_LOG_ERROR, ""invalid sampling rate index %d\n"", m4ac->sampling_index); return AVERROR_INVALIDDATA; } if (m4ac->object_type == AOT_ER_AAC_LD && (m4ac->sampling_index < 3 || m4ac->sampling_index > 7)) { av_log(avctx, AV_LOG_ERROR, ""invalid low delay sampling rate index %d\n"", m4ac->sampling_index); return AVERROR_INVALIDDATA; } skip_bits_long(&gb, i); switch (m4ac->object_type) { case AOT_AAC_MAIN: case AOT_AAC_LC: case AOT_AAC_LTP: case AOT_ER_AAC_LC: case AOT_ER_AAC_LD: if ((ret = decode_ga_specific_config(ac, avctx, &gb, m4ac, m4ac->chan_config)) < 0) return ret; break; case AOT_ER_AAC_ELD: if ((ret = decode_eld_specific_config(ac, avctx, &gb, m4ac, m4ac->chan_config)) < 0) return ret; break; default: avpriv_report_missing_feature(avctx, ""Audio object type %s%d"", m4ac->sbr == 1 ? ""SBR+"" : """", m4ac->object_type); return AVERROR(ENOSYS); } ff_dlog(avctx, ""AOT %d chan config %d sampling index %d (%d) SBR %d PS %d\n"", m4ac->object_type, m4ac->chan_config, m4ac->sampling_index, m4ac->sample_rate, m4ac->sbr, m4ac->ps); return get_bits_count(&gb); }"
208----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0c522e6248daf0957b8bf6b2a0b14c035cff32f4_1.json----dxtory_decode_v2_rgb,"static int dxtory_decode_v2_rgb(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { GetByteContext gb; GetBitContext gb2; int nslices, slice, slice_height; uint32_t off, slice_size; uint8_t *dst; int ret; bytestream2_init(&gb, src, src_size); nslices = bytestream2_get_le16(&gb); off = FFALIGN(nslices * 4 + 2, 16); if (src_size < off) { av_log(avctx, AV_LOG_ERROR, ""no slice data\n""); return AVERROR_INVALIDDATA; } if (!nslices || avctx->height % nslices) { avpriv_request_sample(avctx, ""%d slices for %dx%d"", nslices, avctx->width, avctx->height); return AVERROR_PATCHWELCOME; } slice_height = avctx->height / nslices; avctx->pix_fmt = AV_PIX_FMT_BGR24; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; dst = pic->data[0]; for (slice = 0; slice < nslices; slice++) { slice_size = bytestream2_get_le32(&gb); <S2SV_StartVul> if (slice_size > src_size - off) { <S2SV_EndVul> <S2SV_StartVul> av_log(avctx, AV_LOG_ERROR, <S2SV_EndVul> <S2SV_StartVul> ""invalid slice size %""PRIu32"" (only %""PRIu32"" bytes left)\n"", <S2SV_EndVul> <S2SV_StartVul> slice_size, src_size - off); <S2SV_EndVul> <S2SV_StartVul> return AVERROR_INVALIDDATA; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (slice_size <= 16) { <S2SV_EndVul> <S2SV_StartVul> av_log(avctx, AV_LOG_ERROR, ""invalid slice size %""PRIu32""\n"", <S2SV_EndVul> <S2SV_StartVul> slice_size); <S2SV_EndVul> <S2SV_StartVul> return AVERROR_INVALIDDATA; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (AV_RL32(src + off) != slice_size - 16) { <S2SV_EndVul> <S2SV_StartVul> av_log(avctx, AV_LOG_ERROR, <S2SV_EndVul> <S2SV_StartVul> ""Slice sizes mismatch: got %""PRIu32"" instead of %""PRIu32""\n"", <S2SV_EndVul> <S2SV_StartVul> AV_RL32(src + off), slice_size - 16); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8); dx2_decode_slice_rgb(&gb2, avctx->width, slice_height, dst, pic->linesize[0]); dst += pic->linesize[0] * slice_height; off += slice_size; } return 0; }","- if (slice_size > src_size - off) {
- av_log(avctx, AV_LOG_ERROR,
- ""invalid slice size %""PRIu32"" (only %""PRIu32"" bytes left)\n"",
- slice_size, src_size - off);
- return AVERROR_INVALIDDATA;
- }
- if (slice_size <= 16) {
- av_log(avctx, AV_LOG_ERROR, ""invalid slice size %""PRIu32""\n"",
- slice_size);
- return AVERROR_INVALIDDATA;
- }
- if (AV_RL32(src + off) != slice_size - 16) {
- av_log(avctx, AV_LOG_ERROR,
- ""Slice sizes mismatch: got %""PRIu32"" instead of %""PRIu32""\n"",
- AV_RL32(src + off), slice_size - 16);
- }
+ ret = check_slice_size(avctx, src, src_size, slice_size, off);
+ if (ret < 0)
+ return ret;","static int dxtory_decode_v2_rgb(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { GetByteContext gb; GetBitContext gb2; int nslices, slice, slice_height; uint32_t off, slice_size; uint8_t *dst; int ret; bytestream2_init(&gb, src, src_size); nslices = bytestream2_get_le16(&gb); off = FFALIGN(nslices * 4 + 2, 16); if (src_size < off) { av_log(avctx, AV_LOG_ERROR, ""no slice data\n""); return AVERROR_INVALIDDATA; } if (!nslices || avctx->height % nslices) { avpriv_request_sample(avctx, ""%d slices for %dx%d"", nslices, avctx->width, avctx->height); return AVERROR_PATCHWELCOME; } slice_height = avctx->height / nslices; avctx->pix_fmt = AV_PIX_FMT_BGR24; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; dst = pic->data[0]; for (slice = 0; slice < nslices; slice++) { slice_size = bytestream2_get_le32(&gb); ret = check_slice_size(avctx, src, src_size, slice_size, off); if (ret < 0) return ret; init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8); dx2_decode_slice_rgb(&gb2, avctx->width, slice_height, dst, pic->linesize[0]); dst += pic->linesize[0] * slice_height; off += slice_size; } return 0; }"
3931----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d3ad1ae0dc6d144e0308e3bf6754ff5c79e034ae_1.json----ff_rm_parse_packet,"int ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *pkt, int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if ((ast->deint_id == DEINT_ID_GENR) || (ast->deint_id == DEINT_ID_INT4) || (ast->deint_id == DEINT_ID_SIPR)) { int x; int sps = ast->sub_packet_size; int cfs = ast->coded_framesize; int h = ast->sub_packet_h; int y = ast->sub_packet_cnt; int w = ast->audio_framesize; if (flags & 2) y = ast->sub_packet_cnt = 0; if (!y) ast->audiotimestamp = timestamp; switch (ast->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) <S2SV_StartVul> avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs); <S2SV_EndVul> break; case DEINT_ID_GENR: for (x = 0; x < w/sps; x++) <S2SV_StartVul> avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps); <S2SV_EndVul> break; case DEINT_ID_SIPR: <S2SV_StartVul> avio_read(pb, ast->pkt.data + y * w, w); <S2SV_EndVul> break; } if (++(ast->sub_packet_cnt) < h) return -1; if (ast->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data(ast->pkt.data, h, w); ast->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * w / st->codec->block_align; } else if ((ast->deint_id == DEINT_ID_VBRF) || (ast->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if (ast->sub_packet_cnt) { for (x = 0; x < ast->sub_packet_cnt; x++) ast->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = ast->sub_packet_cnt; ast->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, pkt, len); rm_ac3_swap_bytes(st, pkt); } } else av_get_packet(pb, pkt, len); pkt->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1); av_log(s, AV_LOG_DEBUG, ""%d %""PRId64"" %d\n"", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp > 0x2000) seq -= 0x4000; if(seq - timestamp < -0x2000) seq += 0x4000; } } #endif pkt->pts = timestamp; if (flags & 2) pkt->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }","- avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);
- avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);
- avio_read(pb, ast->pkt.data + y * w, w);
+ readfull(s, pb, ast->pkt.data+x*2*w+y*cfs, cfs);
+ readfull(s, pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);
+ readfull(s, pb, ast->pkt.data + y * w, w);","int ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *pkt, int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if ((ast->deint_id == DEINT_ID_GENR) || (ast->deint_id == DEINT_ID_INT4) || (ast->deint_id == DEINT_ID_SIPR)) { int x; int sps = ast->sub_packet_size; int cfs = ast->coded_framesize; int h = ast->sub_packet_h; int y = ast->sub_packet_cnt; int w = ast->audio_framesize; if (flags & 2) y = ast->sub_packet_cnt = 0; if (!y) ast->audiotimestamp = timestamp; switch (ast->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) readfull(s, pb, ast->pkt.data+x*2*w+y*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x < w/sps; x++) readfull(s, pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps); break; case DEINT_ID_SIPR: readfull(s, pb, ast->pkt.data + y * w, w); break; } if (++(ast->sub_packet_cnt) < h) return -1; if (ast->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data(ast->pkt.data, h, w); ast->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * w / st->codec->block_align; } else if ((ast->deint_id == DEINT_ID_VBRF) || (ast->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if (ast->sub_packet_cnt) { for (x = 0; x < ast->sub_packet_cnt; x++) ast->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = ast->sub_packet_cnt; ast->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, pkt, len); rm_ac3_swap_bytes(st, pkt); } } else av_get_packet(pb, pkt, len); pkt->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1); av_log(s, AV_LOG_DEBUG, ""%d %""PRId64"" %d\n"", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp > 0x2000) seq -= 0x4000; if(seq - timestamp < -0x2000) seq += 0x4000; } } #endif pkt->pts = timestamp; if (flags & 2) pkt->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }"
13842----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d1c0f003c7872d7f0de32897ecfe933c827b693_1.json----encode_test_init,"static int encode_test_init(struct evp_test *t, const char *encoding) { struct encode_data *edata = OPENSSL_zalloc(sizeof(*edata)); if (strcmp(encoding, ""canonical"") == 0) { edata->encoding = BASE64_CANONICAL_ENCODING; } else if (strcmp(encoding, ""valid"") == 0) { edata->encoding = BASE64_VALID_ENCODING; } else if (strcmp(encoding, ""invalid"") == 0) { edata->encoding = BASE64_INVALID_ENCODING; <S2SV_StartVul> t->expected_err = BUF_strdup(""DECODE_ERROR""); <S2SV_EndVul> if (t->expected_err == NULL) return 0; } else { fprintf(stderr, ""Bad encoding: %s. Should be one of "" ""{canonical, valid, invalid}\n"", encoding); return 0; } t->data = edata; return 1; }","- t->expected_err = BUF_strdup(""DECODE_ERROR"");
+ t->expected_err = OPENSSL_strdup(""DECODE_ERROR"");","static int encode_test_init(struct evp_test *t, const char *encoding) { struct encode_data *edata = OPENSSL_zalloc(sizeof(*edata)); if (strcmp(encoding, ""canonical"") == 0) { edata->encoding = BASE64_CANONICAL_ENCODING; } else if (strcmp(encoding, ""valid"") == 0) { edata->encoding = BASE64_VALID_ENCODING; } else if (strcmp(encoding, ""invalid"") == 0) { edata->encoding = BASE64_INVALID_ENCODING; t->expected_err = OPENSSL_strdup(""DECODE_ERROR""); if (t->expected_err == NULL) return 0; } else { fprintf(stderr, ""Bad encoding: %s. Should be one of "" ""{canonical, valid, invalid}\n"", encoding); return 0; } t->data = edata; return 1; }"
2774----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_98dc7b0cbdc2e78e710ed020511efd78d0fc4fea_1.json----common_init,"static av_cold int common_init(AVCodecContext *avctx){ FFV1Context *s = avctx->priv_data; s->avctx= avctx; s->flags= avctx->flags; avcodec_get_frame_defaults(&s->picture); ff_dsputil_init(&s->dsp, avctx); s->width = avctx->width; s->height= avctx->height; <S2SV_StartVul> assert(s->width && s->height); <S2SV_EndVul> s->num_h_slices=1; s->num_v_slices=1; return 0; }","- assert(s->width && s->height);
+ if(!avctx->width || !avctx->height)
+ return AVERROR_INVALIDDATA;","static av_cold int common_init(AVCodecContext *avctx){ FFV1Context *s = avctx->priv_data; if(!avctx->width || !avctx->height) return AVERROR_INVALIDDATA; s->avctx= avctx; s->flags= avctx->flags; avcodec_get_frame_defaults(&s->picture); ff_dsputil_init(&s->dsp, avctx); s->width = avctx->width; s->height= avctx->height; s->num_h_slices=1; s->num_v_slices=1; return 0; }"
7440----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_93944838599ce510398112e19e3eb3f81b25fd92_1.json----fill_filter_caches,"static int fill_filter_caches(H264Context *h, int mb_type){ MpegEncContext * const s = &h->s; const int mb_xy= h->mb_xy; int top_xy, left_xy[2]; int top_type, left_type[2]; top_xy = mb_xy - (s->mb_stride << MB_FIELD); left_xy[1] = left_xy[0] = mb_xy-1; if(FRAME_MBAFF){ const int left_mb_field_flag = IS_INTERLACED(s->current_picture.mb_type[mb_xy-1]); const int curr_mb_field_flag = IS_INTERLACED(mb_type); if(s->mb_y&1){ if (left_mb_field_flag != curr_mb_field_flag) { left_xy[0] -= s->mb_stride; } }else{ if(curr_mb_field_flag){ top_xy += s->mb_stride & (((s->current_picture.mb_type[top_xy ]>>7)&1)-1); } if (left_mb_field_flag != curr_mb_field_flag) { left_xy[1] += s->mb_stride; } } } h->top_mb_xy = top_xy; h->left_mb_xy[0] = left_xy[0]; h->left_mb_xy[1] = left_xy[1]; { int qp_thresh = h->qp_thresh; int qp = s->current_picture.qscale_table[mb_xy]; if(qp <= qp_thresh && (left_xy[0]<0 || ((qp + s->current_picture.qscale_table[left_xy[0]] + 1)>>1) <= qp_thresh) && (top_xy < 0 || ((qp + s->current_picture.qscale_table[top_xy ] + 1)>>1) <= qp_thresh)){ if(!FRAME_MBAFF) return 1; if( (left_xy[0]< 0 || ((qp + s->current_picture.qscale_table[left_xy[1] ] + 1)>>1) <= qp_thresh) && (top_xy < s->mb_stride || ((qp + s->current_picture.qscale_table[top_xy -s->mb_stride] + 1)>>1) <= qp_thresh)) return 1; } } if(h->deblocking_filter == 2){ h->top_type = top_type = h->slice_table[top_xy ] == h->slice_num ? s->current_picture.mb_type[top_xy] : 0; h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] == h->slice_num ? s->current_picture.mb_type[left_xy[0]] : 0; h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] == h->slice_num ? s->current_picture.mb_type[left_xy[1]] : 0; }else{ h->top_type = top_type = h->slice_table[top_xy ] < 0xFFFF ? s->current_picture.mb_type[top_xy] : 0; h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[0]] : 0; h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[1]] : 0; } if(IS_INTRA(mb_type)) return 0; AV_COPY64(&h->non_zero_count_cache[0+8*1], &h->non_zero_count[mb_xy][ 0]); AV_COPY64(&h->non_zero_count_cache[0+8*2], &h->non_zero_count[mb_xy][ 8]); *((uint32_t*)&h->non_zero_count_cache[0+8*5])= *((uint32_t*)&h->non_zero_count[mb_xy][16]); *((uint32_t*)&h->non_zero_count_cache[4+8*3])= *((uint32_t*)&h->non_zero_count[mb_xy][20]); AV_COPY64(&h->non_zero_count_cache[0+8*4], &h->non_zero_count[mb_xy][24]); h->cbp= h->cbp_table[mb_xy]; { int list; for(list=0; list<h->list_count; list++){ int8_t *ref; int y, b_stride; int16_t (*mv_dst)[2]; int16_t (*mv_src)[2]; if(!USES_LIST(mb_type, list)){ fill_rectangle( h->mv_cache[list][scan8[0]], 4, 4, 8, pack16to32(0,0), 4); *(uint32_t*)&h->ref_cache[list][scan8[ 0]] = *(uint32_t*)&h->ref_cache[list][scan8[ 2]] = *(uint32_t*)&h->ref_cache[list][scan8[ 8]] = *(uint32_t*)&h->ref_cache[list][scan8[10]] = ((LIST_NOT_USED)&0xFF)*0x01010101U; continue; } ref = &s->current_picture.ref_index[list][h->mb2b8_xy[mb_xy]]; { <S2SV_StartVul> int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2); <S2SV_EndVul> *(uint32_t*)&h->ref_cache[list][scan8[ 0]] = *(uint32_t*)&h->ref_cache[list][scan8[ 2]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101; ref += h->b8_stride; *(uint32_t*)&h->ref_cache[list][scan8[ 8]] = *(uint32_t*)&h->ref_cache[list][scan8[10]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101; } b_stride = h->b_stride; mv_dst = &h->mv_cache[list][scan8[0]]; mv_src = &s->current_picture.motion_val[list][4*s->mb_x + 4*s->mb_y*b_stride]; for(y=0; y<4; y++){ AV_COPY128(mv_dst + 8*y, mv_src + y*b_stride); } } } if(top_type){ *(uint32_t*)&h->non_zero_count_cache[4+8*0]= *(uint32_t*)&h->non_zero_count[top_xy][4+3*8]; } if(left_type[0]){ h->non_zero_count_cache[3+8*1]= h->non_zero_count[left_xy[0]][7+0*8]; h->non_zero_count_cache[3+8*2]= h->non_zero_count[left_xy[0]][7+1*8]; h->non_zero_count_cache[3+8*3]= h->non_zero_count[left_xy[0]][7+2*8]; h->non_zero_count_cache[3+8*4]= h->non_zero_count[left_xy[0]][7+3*8]; } if(!CABAC && h->pps.transform_8x8_mode){ if(IS_8x8DCT(top_type)){ h->non_zero_count_cache[4+8*0]= h->non_zero_count_cache[5+8*0]= h->cbp_table[top_xy] & 4; h->non_zero_count_cache[6+8*0]= h->non_zero_count_cache[7+8*0]= h->cbp_table[top_xy] & 8; } if(IS_8x8DCT(left_type[0])){ h->non_zero_count_cache[3+8*1]= h->non_zero_count_cache[3+8*2]= h->cbp_table[left_xy[0]]&2; } if(IS_8x8DCT(left_type[1])){ h->non_zero_count_cache[3+8*3]= h->non_zero_count_cache[3+8*4]= h->cbp_table[left_xy[1]]&8; } if(IS_8x8DCT(mb_type)){ h->non_zero_count_cache[scan8[0 ]]= h->non_zero_count_cache[scan8[1 ]]= h->non_zero_count_cache[scan8[2 ]]= h->non_zero_count_cache[scan8[3 ]]= h->cbp & 1; h->non_zero_count_cache[scan8[0+ 4]]= h->non_zero_count_cache[scan8[1+ 4]]= h->non_zero_count_cache[scan8[2+ 4]]= h->non_zero_count_cache[scan8[3+ 4]]= h->cbp & 2; h->non_zero_count_cache[scan8[0+ 8]]= h->non_zero_count_cache[scan8[1+ 8]]= h->non_zero_count_cache[scan8[2+ 8]]= h->non_zero_count_cache[scan8[3+ 8]]= h->cbp & 4; h->non_zero_count_cache[scan8[0+12]]= h->non_zero_count_cache[scan8[1+12]]= h->non_zero_count_cache[scan8[2+12]]= h->non_zero_count_cache[scan8[3+12]]= h->cbp & 8; } } if(IS_INTER(mb_type) || IS_DIRECT(mb_type)){ int list; for(list=0; list<h->list_count; list++){ if(USES_LIST(top_type, list)){ const int b_xy= h->mb2b_xy[top_xy] + 3*h->b_stride; const int b8_xy= h->mb2b8_xy[top_xy] + h->b8_stride; <S2SV_StartVul> int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2); <S2SV_EndVul> AV_COPY128(h->mv_cache[list][scan8[0] + 0 - 1*8], s->current_picture.motion_val[list][b_xy + 0]); h->ref_cache[list][scan8[0] + 0 - 1*8]= h->ref_cache[list][scan8[0] + 1 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 0]]; h->ref_cache[list][scan8[0] + 2 - 1*8]= h->ref_cache[list][scan8[0] + 3 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 1]]; }else{ AV_ZERO128(h->mv_cache[list][scan8[0] + 0 - 1*8]); *(uint32_t*)&h->ref_cache[list][scan8[0] + 0 - 1*8]= ((LIST_NOT_USED)&0xFF)*0x01010101U; } if(!IS_INTERLACED(mb_type^left_type[0])){ if(USES_LIST(left_type[0], list)){ const int b_xy= h->mb2b_xy[left_xy[0]] + 3; const int b8_xy= h->mb2b8_xy[left_xy[0]] + 1; <S2SV_StartVul> int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2); <S2SV_EndVul> *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 0 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*0]; *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 8 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*1]; *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +16 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*2]; *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +24 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*3]; h->ref_cache[list][scan8[0] - 1 + 0 ]= h->ref_cache[list][scan8[0] - 1 + 8 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*0]]; h->ref_cache[list][scan8[0] - 1 +16 ]= h->ref_cache[list][scan8[0] - 1 +24 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*1]]; }else{ *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 0 ]= *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 8 ]= *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +16 ]= *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +24 ]= 0; h->ref_cache[list][scan8[0] - 1 + 0 ]= h->ref_cache[list][scan8[0] - 1 + 8 ]= h->ref_cache[list][scan8[0] - 1 + 16 ]= h->ref_cache[list][scan8[0] - 1 + 24 ]= LIST_NOT_USED; } } } } return 0; }","- int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2);
- int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2);
- int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2);
+ int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);
+ int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);
+ int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);","static int fill_filter_caches(H264Context *h, int mb_type){ MpegEncContext * const s = &h->s; const int mb_xy= h->mb_xy; int top_xy, left_xy[2]; int top_type, left_type[2]; top_xy = mb_xy - (s->mb_stride << MB_FIELD); left_xy[1] = left_xy[0] = mb_xy-1; if(FRAME_MBAFF){ const int left_mb_field_flag = IS_INTERLACED(s->current_picture.mb_type[mb_xy-1]); const int curr_mb_field_flag = IS_INTERLACED(mb_type); if(s->mb_y&1){ if (left_mb_field_flag != curr_mb_field_flag) { left_xy[0] -= s->mb_stride; } }else{ if(curr_mb_field_flag){ top_xy += s->mb_stride & (((s->current_picture.mb_type[top_xy ]>>7)&1)-1); } if (left_mb_field_flag != curr_mb_field_flag) { left_xy[1] += s->mb_stride; } } } h->top_mb_xy = top_xy; h->left_mb_xy[0] = left_xy[0]; h->left_mb_xy[1] = left_xy[1]; { int qp_thresh = h->qp_thresh; int qp = s->current_picture.qscale_table[mb_xy]; if(qp <= qp_thresh && (left_xy[0]<0 || ((qp + s->current_picture.qscale_table[left_xy[0]] + 1)>>1) <= qp_thresh) && (top_xy < 0 || ((qp + s->current_picture.qscale_table[top_xy ] + 1)>>1) <= qp_thresh)){ if(!FRAME_MBAFF) return 1; if( (left_xy[0]< 0 || ((qp + s->current_picture.qscale_table[left_xy[1] ] + 1)>>1) <= qp_thresh) && (top_xy < s->mb_stride || ((qp + s->current_picture.qscale_table[top_xy -s->mb_stride] + 1)>>1) <= qp_thresh)) return 1; } } if(h->deblocking_filter == 2){ h->top_type = top_type = h->slice_table[top_xy ] == h->slice_num ? s->current_picture.mb_type[top_xy] : 0; h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] == h->slice_num ? s->current_picture.mb_type[left_xy[0]] : 0; h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] == h->slice_num ? s->current_picture.mb_type[left_xy[1]] : 0; }else{ h->top_type = top_type = h->slice_table[top_xy ] < 0xFFFF ? s->current_picture.mb_type[top_xy] : 0; h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[0]] : 0; h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[1]] : 0; } if(IS_INTRA(mb_type)) return 0; AV_COPY64(&h->non_zero_count_cache[0+8*1], &h->non_zero_count[mb_xy][ 0]); AV_COPY64(&h->non_zero_count_cache[0+8*2], &h->non_zero_count[mb_xy][ 8]); *((uint32_t*)&h->non_zero_count_cache[0+8*5])= *((uint32_t*)&h->non_zero_count[mb_xy][16]); *((uint32_t*)&h->non_zero_count_cache[4+8*3])= *((uint32_t*)&h->non_zero_count[mb_xy][20]); AV_COPY64(&h->non_zero_count_cache[0+8*4], &h->non_zero_count[mb_xy][24]); h->cbp= h->cbp_table[mb_xy]; { int list; for(list=0; list<h->list_count; list++){ int8_t *ref; int y, b_stride; int16_t (*mv_dst)[2]; int16_t (*mv_src)[2]; if(!USES_LIST(mb_type, list)){ fill_rectangle( h->mv_cache[list][scan8[0]], 4, 4, 8, pack16to32(0,0), 4); *(uint32_t*)&h->ref_cache[list][scan8[ 0]] = *(uint32_t*)&h->ref_cache[list][scan8[ 2]] = *(uint32_t*)&h->ref_cache[list][scan8[ 8]] = *(uint32_t*)&h->ref_cache[list][scan8[10]] = ((LIST_NOT_USED)&0xFF)*0x01010101U; continue; } ref = &s->current_picture.ref_index[list][h->mb2b8_xy[mb_xy]]; { int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2); *(uint32_t*)&h->ref_cache[list][scan8[ 0]] = *(uint32_t*)&h->ref_cache[list][scan8[ 2]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101; ref += h->b8_stride; *(uint32_t*)&h->ref_cache[list][scan8[ 8]] = *(uint32_t*)&h->ref_cache[list][scan8[10]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101; } b_stride = h->b_stride; mv_dst = &h->mv_cache[list][scan8[0]]; mv_src = &s->current_picture.motion_val[list][4*s->mb_x + 4*s->mb_y*b_stride]; for(y=0; y<4; y++){ AV_COPY128(mv_dst + 8*y, mv_src + y*b_stride); } } } if(top_type){ *(uint32_t*)&h->non_zero_count_cache[4+8*0]= *(uint32_t*)&h->non_zero_count[top_xy][4+3*8]; } if(left_type[0]){ h->non_zero_count_cache[3+8*1]= h->non_zero_count[left_xy[0]][7+0*8]; h->non_zero_count_cache[3+8*2]= h->non_zero_count[left_xy[0]][7+1*8]; h->non_zero_count_cache[3+8*3]= h->non_zero_count[left_xy[0]][7+2*8]; h->non_zero_count_cache[3+8*4]= h->non_zero_count[left_xy[0]][7+3*8]; } if(!CABAC && h->pps.transform_8x8_mode){ if(IS_8x8DCT(top_type)){ h->non_zero_count_cache[4+8*0]= h->non_zero_count_cache[5+8*0]= h->cbp_table[top_xy] & 4; h->non_zero_count_cache[6+8*0]= h->non_zero_count_cache[7+8*0]= h->cbp_table[top_xy] & 8; } if(IS_8x8DCT(left_type[0])){ h->non_zero_count_cache[3+8*1]= h->non_zero_count_cache[3+8*2]= h->cbp_table[left_xy[0]]&2; } if(IS_8x8DCT(left_type[1])){ h->non_zero_count_cache[3+8*3]= h->non_zero_count_cache[3+8*4]= h->cbp_table[left_xy[1]]&8; } if(IS_8x8DCT(mb_type)){ h->non_zero_count_cache[scan8[0 ]]= h->non_zero_count_cache[scan8[1 ]]= h->non_zero_count_cache[scan8[2 ]]= h->non_zero_count_cache[scan8[3 ]]= h->cbp & 1; h->non_zero_count_cache[scan8[0+ 4]]= h->non_zero_count_cache[scan8[1+ 4]]= h->non_zero_count_cache[scan8[2+ 4]]= h->non_zero_count_cache[scan8[3+ 4]]= h->cbp & 2; h->non_zero_count_cache[scan8[0+ 8]]= h->non_zero_count_cache[scan8[1+ 8]]= h->non_zero_count_cache[scan8[2+ 8]]= h->non_zero_count_cache[scan8[3+ 8]]= h->cbp & 4; h->non_zero_count_cache[scan8[0+12]]= h->non_zero_count_cache[scan8[1+12]]= h->non_zero_count_cache[scan8[2+12]]= h->non_zero_count_cache[scan8[3+12]]= h->cbp & 8; } } if(IS_INTER(mb_type) || IS_DIRECT(mb_type)){ int list; for(list=0; list<h->list_count; list++){ if(USES_LIST(top_type, list)){ const int b_xy= h->mb2b_xy[top_xy] + 3*h->b_stride; const int b8_xy= h->mb2b8_xy[top_xy] + h->b8_stride; int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2); AV_COPY128(h->mv_cache[list][scan8[0] + 0 - 1*8], s->current_picture.motion_val[list][b_xy + 0]); h->ref_cache[list][scan8[0] + 0 - 1*8]= h->ref_cache[list][scan8[0] + 1 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 0]]; h->ref_cache[list][scan8[0] + 2 - 1*8]= h->ref_cache[list][scan8[0] + 3 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 1]]; }else{ AV_ZERO128(h->mv_cache[list][scan8[0] + 0 - 1*8]); *(uint32_t*)&h->ref_cache[list][scan8[0] + 0 - 1*8]= ((LIST_NOT_USED)&0xFF)*0x01010101U; } if(!IS_INTERLACED(mb_type^left_type[0])){ if(USES_LIST(left_type[0], list)){ const int b_xy= h->mb2b_xy[left_xy[0]] + 3; const int b8_xy= h->mb2b8_xy[left_xy[0]] + 1; int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2); *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 0 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*0]; *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 8 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*1]; *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +16 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*2]; *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +24 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*3]; h->ref_cache[list][scan8[0] - 1 + 0 ]= h->ref_cache[list][scan8[0] - 1 + 8 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*0]]; h->ref_cache[list][scan8[0] - 1 +16 ]= h->ref_cache[list][scan8[0] - 1 +24 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*1]]; }else{ *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 0 ]= *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 8 ]= *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +16 ]= *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +24 ]= 0; h->ref_cache[list][scan8[0] - 1 + 0 ]= h->ref_cache[list][scan8[0] - 1 + 8 ]= h->ref_cache[list][scan8[0] - 1 + 16 ]= h->ref_cache[list][scan8[0] - 1 + 24 ]= LIST_NOT_USED; } } } } return 0; }"
4750----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_11057f2e6181938df1381676fddec3806d28be7e_1.json----mkhash,"int mkhash(struct passwd_ctx *ctx) { char *pw; <S2SV_StartVul> char pwin[MAX_STRING_LEN]; <S2SV_EndVul> char salt[16]; apr_status_t rv; int ret = 0; #if CRYPT_ALGO_SUPPORTED char *cbuf; #endif if (ctx->cost != 0 && ctx->alg != ALG_BCRYPT) { apr_file_printf(errfile, ""Warning: Ignoring -C argument for this algorithm."" NL); } <S2SV_StartVul> if (ctx->passwd != NULL) { <S2SV_EndVul> <S2SV_StartVul> pw = ctx->passwd; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_EndVul> if ((ret = get_password(ctx)) != 0) return ret; <S2SV_StartVul> pw = pwin; <S2SV_EndVul> } switch (ctx->alg) { case ALG_APSHA: apr_sha1_base64(pw, strlen(pw), ctx->out); break; case ALG_APMD5: ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool); if (ret != 0) break; rv = apr_md5_encode(pw, salt, ctx->out, ctx->out_len); if (rv != APR_SUCCESS) { ctx->errstr = apr_psprintf(ctx->pool, ""could not encode password: %pm"", &rv); ret = ERR_GENERAL; } break; case ALG_PLAIN: apr_cpystrn(ctx->out, pw, ctx->out_len); break; #if CRYPT_ALGO_SUPPORTED case ALG_CRYPT: ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool); if (ret != 0) break; cbuf = crypt(pw, salt); if (cbuf == NULL) { rv = APR_FROM_OS_ERROR(errno); ctx->errstr = apr_psprintf(ctx->pool, ""crypt() failed: %pm"", &rv); ret = ERR_PWMISMATCH; break; } apr_cpystrn(ctx->out, cbuf, ctx->out_len - 1); if (strlen(pw) > 8) { <S2SV_StartVul> char *truncpw = strdup(pw); <S2SV_EndVul> <S2SV_StartVul> if (truncpw == NULL) <S2SV_EndVul> <S2SV_StartVul> abort_on_oom(0); <S2SV_EndVul> truncpw[8] = '\0'; if (!strcmp(ctx->out, crypt(truncpw, salt))) { apr_file_printf(errfile, ""Warning: Password truncated to 8 "" ""characters by CRYPT algorithm."" NL); } memset(truncpw, '\0', strlen(pw)); free(truncpw); } break; #endif #if BCRYPT_ALGO_SUPPORTED case ALG_BCRYPT: rv = apr_generate_random_bytes((unsigned char*)salt, 16); if (rv != APR_SUCCESS) { ctx->errstr = apr_psprintf(ctx->pool, ""Unable to generate random "" ""bytes: %pm"", &rv); ret = ERR_RANDOM; break; } if (ctx->cost == 0) ctx->cost = BCRYPT_DEFAULT_COST; rv = apr_bcrypt_encode(pw, ctx->cost, (unsigned char*)salt, 16, ctx->out, ctx->out_len); if (rv != APR_SUCCESS) { ctx->errstr = apr_psprintf(ctx->pool, ""Unable to encode with "" ""bcrypt: %pm"", &rv); ret = ERR_PWMISMATCH; break; } break; #endif default: apr_file_printf(errfile, ""mkhash(): BUG: invalid algorithm %d"", ctx->alg); abort(); } memset(pw, '\0', strlen(pw)); return ret; }","- char pwin[MAX_STRING_LEN];
- if (ctx->passwd != NULL) {
- pw = ctx->passwd;
- }
- else {
- pw = pwin;
- char *truncpw = strdup(pw);
- if (truncpw == NULL)
- abort_on_oom(0);
+ if (ctx->passwd == NULL) {
+ pw = ctx->passwd;
+ char *truncpw = apr_pstrdup(ctx->pool, pw);","int mkhash(struct passwd_ctx *ctx) { char *pw; char salt[16]; apr_status_t rv; int ret = 0; #if CRYPT_ALGO_SUPPORTED char *cbuf; #endif if (ctx->cost != 0 && ctx->alg != ALG_BCRYPT) { apr_file_printf(errfile, ""Warning: Ignoring -C argument for this algorithm."" NL); } if (ctx->passwd == NULL) { if ((ret = get_password(ctx)) != 0) return ret; } pw = ctx->passwd; switch (ctx->alg) { case ALG_APSHA: apr_sha1_base64(pw, strlen(pw), ctx->out); break; case ALG_APMD5: ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool); if (ret != 0) break; rv = apr_md5_encode(pw, salt, ctx->out, ctx->out_len); if (rv != APR_SUCCESS) { ctx->errstr = apr_psprintf(ctx->pool, ""could not encode password: %pm"", &rv); ret = ERR_GENERAL; } break; case ALG_PLAIN: apr_cpystrn(ctx->out, pw, ctx->out_len); break; #if CRYPT_ALGO_SUPPORTED case ALG_CRYPT: ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool); if (ret != 0) break; cbuf = crypt(pw, salt); if (cbuf == NULL) { rv = APR_FROM_OS_ERROR(errno); ctx->errstr = apr_psprintf(ctx->pool, ""crypt() failed: %pm"", &rv); ret = ERR_PWMISMATCH; break; } apr_cpystrn(ctx->out, cbuf, ctx->out_len - 1); if (strlen(pw) > 8) { char *truncpw = apr_pstrdup(ctx->pool, pw); truncpw[8] = '\0'; if (!strcmp(ctx->out, crypt(truncpw, salt))) { apr_file_printf(errfile, ""Warning: Password truncated to 8 "" ""characters by CRYPT algorithm."" NL); } memset(truncpw, '\0', strlen(pw)); free(truncpw); } break; #endif #if BCRYPT_ALGO_SUPPORTED case ALG_BCRYPT: rv = apr_generate_random_bytes((unsigned char*)salt, 16); if (rv != APR_SUCCESS) { ctx->errstr = apr_psprintf(ctx->pool, ""Unable to generate random "" ""bytes: %pm"", &rv); ret = ERR_RANDOM; break; } if (ctx->cost == 0) ctx->cost = BCRYPT_DEFAULT_COST; rv = apr_bcrypt_encode(pw, ctx->cost, (unsigned char*)salt, 16, ctx->out, ctx->out_len); if (rv != APR_SUCCESS) { ctx->errstr = apr_psprintf(ctx->pool, ""Unable to encode with "" ""bcrypt: %pm"", &rv); ret = ERR_PWMISMATCH; break; } break; #endif default: apr_file_printf(errfile, ""mkhash(): BUG: invalid algorithm %d"", ctx->alg); abort(); } memset(pw, '\0', strlen(pw)); return ret; }"
5646----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2830ca2e8801de1751491b14a282fa0e72b879dc_1.json----write_back_motion,"static av_always_inline void write_back_motion(H264Context *h, int mb_type) { <S2SV_StartVul> MpegEncContext *const s = &h->s; <S2SV_EndVul> const int b_stride = h->b_stride; <S2SV_StartVul> const int b_xy = 4 * s->mb_x + 4 * s->mb_y * h->b_stride; const int b8_xy = 4 * h->mb_xy; if (USES_LIST(mb_type, 0)) { <S2SV_StartVul> write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 0); <S2SV_EndVul> } else { <S2SV_StartVul> fill_rectangle(&s->current_picture.f.ref_index[0][b8_xy], <S2SV_EndVul> 2, 2, 2, (uint8_t)LIST_NOT_USED, 1); } if (USES_LIST(mb_type, 1)) <S2SV_StartVul> write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 1); <S2SV_EndVul> if (h->slice_type_nos == AV_PICTURE_TYPE_B && CABAC) { if (IS_8X8(mb_type)) { uint8_t *direct_table = &h->direct_table[4 * h->mb_xy]; direct_table[1] = h->sub_mb_type[1] >> 1; direct_table[2] = h->sub_mb_type[2] >> 1; direct_table[3] = h->sub_mb_type[3] >> 1; } } }","- MpegEncContext *const s = &h->s;
- const int b_xy = 4 * s->mb_x + 4 * s->mb_y * h->b_stride; // try mb2b(8)_xy
- write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 0);
- fill_rectangle(&s->current_picture.f.ref_index[0][b8_xy],
- write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 1);
+ const int b_xy = 4 * h->mb_x + 4 * h->mb_y * h->b_stride; // try mb2b(8)_xy
+ write_back_motion_list(h, b_stride, b_xy, b8_xy, mb_type, 0);
+ fill_rectangle(&h->cur_pic.f.ref_index[0][b8_xy],
+ write_back_motion_list(h, b_stride, b_xy, b8_xy, mb_type, 1);","static av_always_inline void write_back_motion(H264Context *h, int mb_type) { const int b_stride = h->b_stride; const int b_xy = 4 * h->mb_x + 4 * h->mb_y * h->b_stride; const int b8_xy = 4 * h->mb_xy; if (USES_LIST(mb_type, 0)) { write_back_motion_list(h, b_stride, b_xy, b8_xy, mb_type, 0); } else { fill_rectangle(&h->cur_pic.f.ref_index[0][b8_xy], 2, 2, 2, (uint8_t)LIST_NOT_USED, 1); } if (USES_LIST(mb_type, 1)) write_back_motion_list(h, b_stride, b_xy, b8_xy, mb_type, 1); if (h->slice_type_nos == AV_PICTURE_TYPE_B && CABAC) { if (IS_8X8(mb_type)) { uint8_t *direct_table = &h->direct_table[4 * h->mb_xy]; direct_table[1] = h->sub_mb_type[1] >> 1; direct_table[2] = h->sub_mb_type[2] >> 1; direct_table[3] = h->sub_mb_type[3] >> 1; } } }"
235----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0de14753e6799762dbe3995570e3772b1822d075_1.json----tscc2_decode_frame,"static int tscc2_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TSCC2Context *c = avctx->priv_data; GetByteContext gb; uint32_t frame_type, size; int i, val, len, pos = 0; int num_mb = c->mb_width * c->mb_height; int ret; bytestream2_init(&gb, buf, buf_size); frame_type = bytestream2_get_byte(&gb); if (frame_type > 1) { av_log(avctx, AV_LOG_ERROR, ""Incorrect frame type %""PRIu32""\n"", frame_type); return AVERROR_INVALIDDATA; } <S2SV_StartVul> if ((ret = ff_reget_buffer(avctx, c->pic)) < 0) { <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (frame_type == 0) { <S2SV_StartVul> *got_frame = 1; <S2SV_EndVul> <S2SV_StartVul> if ((ret = av_frame_ref(data, c->pic)) < 0) <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> return buf_size; } if (bytestream2_get_bytes_left(&gb) < 4) { av_log(avctx, AV_LOG_ERROR, ""Frame is too short\n""); return AVERROR_INVALIDDATA; } c->quant[0] = bytestream2_get_byte(&gb); c->quant[1] = bytestream2_get_byte(&gb); if (c->quant[0] < 2 || c->quant[0] > NUM_VLC_SETS + 1 || c->quant[1] < 2 || c->quant[1] > NUM_VLC_SETS + 1) { av_log(avctx, AV_LOG_ERROR, ""Invalid quantisers %d / %d\n"", c->quant[0], c->quant[1]); return AVERROR_INVALIDDATA; } for (i = 0; i < 3; i++) { c->q[0][i] = tscc2_quants[c->quant[0] - 2][i]; c->q[1][i] = tscc2_quants[c->quant[1] - 2][i]; } bytestream2_skip(&gb, 1); size = bytestream2_get_le32(&gb); if (size > bytestream2_get_bytes_left(&gb)) { av_log(avctx, AV_LOG_ERROR, ""Slice properties chunk is too large\n""); return AVERROR_INVALIDDATA; } for (i = 0; i < size; i++) { val = bytestream2_get_byte(&gb); len = val & 0x3F; val >>= 6; if (pos + len > num_mb) { av_log(avctx, AV_LOG_ERROR, ""Too many slice properties\n""); return AVERROR_INVALIDDATA; } memset(c->slice_quants + pos, val, len); pos += len; } if (pos < num_mb) { av_log(avctx, AV_LOG_ERROR, ""Too few slice properties (%d / %d)\n"", pos, num_mb); return AVERROR_INVALIDDATA; } for (i = 0; i < c->mb_height; i++) { size = bytestream2_peek_byte(&gb); if (size & 1) { size = bytestream2_get_byte(&gb) - 1; } else { size = bytestream2_get_le32(&gb) >> 1; } if (!size) { int skip_row = 1, j, off = i * c->mb_width; for (j = 0; j < c->mb_width; j++) { if (c->slice_quants[off + j] == 1 || c->slice_quants[off + j] == 2) { skip_row = 0; break; } } if (!skip_row) { av_log(avctx, AV_LOG_ERROR, ""Non-skip row with zero size\n""); return AVERROR_INVALIDDATA; } } if (bytestream2_get_bytes_left(&gb) < size) { av_log(avctx, AV_LOG_ERROR, ""Invalid slice size (%""PRIu32""/%u)\n"", size, bytestream2_get_bytes_left(&gb)); return AVERROR_INVALIDDATA; } ret = tscc2_decode_slice(c, i, buf + bytestream2_tell(&gb), size); if (ret) { av_log(avctx, AV_LOG_ERROR, ""Error decoding slice %d\n"", i); return ret; } bytestream2_skip(&gb, size); } *got_frame = 1; if ((ret = av_frame_ref(data, c->pic)) < 0) return ret; return buf_size; }","- if ((ret = ff_reget_buffer(avctx, c->pic)) < 0) {
- return ret;
- }
- if ((ret = av_frame_ref(data, c->pic)) < 0)
- return ret;
+ if ((ret = ff_reget_buffer(avctx, c->pic)) < 0) {
+ return ret;
+ }","static int tscc2_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TSCC2Context *c = avctx->priv_data; GetByteContext gb; uint32_t frame_type, size; int i, val, len, pos = 0; int num_mb = c->mb_width * c->mb_height; int ret; bytestream2_init(&gb, buf, buf_size); frame_type = bytestream2_get_byte(&gb); if (frame_type > 1) { av_log(avctx, AV_LOG_ERROR, ""Incorrect frame type %""PRIu32""\n"", frame_type); return AVERROR_INVALIDDATA; } if (frame_type == 0) { return buf_size; } if ((ret = ff_reget_buffer(avctx, c->pic)) < 0) { return ret; } if (bytestream2_get_bytes_left(&gb) < 4) { av_log(avctx, AV_LOG_ERROR, ""Frame is too short\n""); return AVERROR_INVALIDDATA; } c->quant[0] = bytestream2_get_byte(&gb); c->quant[1] = bytestream2_get_byte(&gb); if (c->quant[0] < 2 || c->quant[0] > NUM_VLC_SETS + 1 || c->quant[1] < 2 || c->quant[1] > NUM_VLC_SETS + 1) { av_log(avctx, AV_LOG_ERROR, ""Invalid quantisers %d / %d\n"", c->quant[0], c->quant[1]); return AVERROR_INVALIDDATA; } for (i = 0; i < 3; i++) { c->q[0][i] = tscc2_quants[c->quant[0] - 2][i]; c->q[1][i] = tscc2_quants[c->quant[1] - 2][i]; } bytestream2_skip(&gb, 1); size = bytestream2_get_le32(&gb); if (size > bytestream2_get_bytes_left(&gb)) { av_log(avctx, AV_LOG_ERROR, ""Slice properties chunk is too large\n""); return AVERROR_INVALIDDATA; } for (i = 0; i < size; i++) { val = bytestream2_get_byte(&gb); len = val & 0x3F; val >>= 6; if (pos + len > num_mb) { av_log(avctx, AV_LOG_ERROR, ""Too many slice properties\n""); return AVERROR_INVALIDDATA; } memset(c->slice_quants + pos, val, len); pos += len; } if (pos < num_mb) { av_log(avctx, AV_LOG_ERROR, ""Too few slice properties (%d / %d)\n"", pos, num_mb); return AVERROR_INVALIDDATA; } for (i = 0; i < c->mb_height; i++) { size = bytestream2_peek_byte(&gb); if (size & 1) { size = bytestream2_get_byte(&gb) - 1; } else { size = bytestream2_get_le32(&gb) >> 1; } if (!size) { int skip_row = 1, j, off = i * c->mb_width; for (j = 0; j < c->mb_width; j++) { if (c->slice_quants[off + j] == 1 || c->slice_quants[off + j] == 2) { skip_row = 0; break; } } if (!skip_row) { av_log(avctx, AV_LOG_ERROR, ""Non-skip row with zero size\n""); return AVERROR_INVALIDDATA; } } if (bytestream2_get_bytes_left(&gb) < size) { av_log(avctx, AV_LOG_ERROR, ""Invalid slice size (%""PRIu32""/%u)\n"", size, bytestream2_get_bytes_left(&gb)); return AVERROR_INVALIDDATA; } ret = tscc2_decode_slice(c, i, buf + bytestream2_tell(&gb), size); if (ret) { av_log(avctx, AV_LOG_ERROR, ""Error decoding slice %d\n"", i); return ret; } bytestream2_skip(&gb, size); } *got_frame = 1; if ((ret = av_frame_ref(data, c->pic)) < 0) return ret; return buf_size; }"
5213----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1042d8f583d04cb2c1ec54f2d31e184574c165eb_1.json----MPV_encode_picture,"int MPV_encode_picture(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data) { MpegEncContext *s = avctx->priv_data; AVFrame *pic_arg = data; <S2SV_StartVul> int i, stuffing_count, context_count = avctx->thread_count; <S2SV_EndVul> for (i = 0; i < context_count; i++) { int start_y = s->thread_context[i]->start_mb_y; int end_y = s->thread_context[i]-> end_mb_y; int h = s->mb_height; uint8_t *start = buf + (size_t)(((int64_t) buf_size) * start_y / h); uint8_t *end = buf + (size_t)(((int64_t) buf_size) * end_y / h); init_put_bits(&s->thread_context[i]->pb, start, end - start); } s->picture_in_gop_number++; if (load_input_picture(s, pic_arg) < 0) return -1; if (select_input_picture(s) < 0) { return -1; } if (s->new_picture.f.data[0]) { s->pict_type = s->new_picture.f.pict_type; MPV_frame_start(s, avctx); vbv_retry: if (encode_picture(s, s->picture_number) < 0) return -1; avctx->header_bits = s->header_bits; avctx->mv_bits = s->mv_bits; avctx->misc_bits = s->misc_bits; avctx->i_tex_bits = s->i_tex_bits; avctx->p_tex_bits = s->p_tex_bits; avctx->i_count = s->i_count; avctx->p_count = s->mb_num - s->i_count - s->skip_count; avctx->skip_count = s->skip_count; MPV_frame_end(s); if (CONFIG_MJPEG_ENCODER && s->out_format == FMT_MJPEG) ff_mjpeg_encode_picture_trailer(s); if (avctx->rc_buffer_size) { RateControlContext *rcc = &s->rc_context; int max_size = rcc->buffer_index * avctx->rc_max_available_vbv_use; if (put_bits_count(&s->pb) > max_size && s->lambda < s->avctx->lmax) { s->next_lambda = FFMAX(s->lambda + 1, s->lambda * (s->qscale + 1) / s->qscale); if (s->adaptive_quant) { int i; for (i = 0; i < s->mb_height * s->mb_stride; i++) s->lambda_table[i] = FFMAX(s->lambda_table[i] + 1, s->lambda_table[i] * (s->qscale + 1) / s->qscale); } s->mb_skipped = 0; if (s->pict_type == AV_PICTURE_TYPE_P) { if (s->flipflop_rounding || s->codec_id == CODEC_ID_H263P || s->codec_id == CODEC_ID_MPEG4) s->no_rounding ^= 1; } if (s->pict_type != AV_PICTURE_TYPE_B) { s->time_base = s->last_time_base; s->last_non_b_time = s->time - s->pp_time; } for (i = 0; i < context_count; i++) { PutBitContext *pb = &s->thread_context[i]->pb; init_put_bits(pb, pb->buf, pb->buf_end - pb->buf); } goto vbv_retry; } assert(s->avctx->rc_max_rate); } if (s->flags & CODEC_FLAG_PASS1) ff_write_pass1_stats(s); for (i = 0; i < 4; i++) { s->current_picture_ptr->f.error[i] = s->current_picture.f.error[i]; avctx->error[i] += s->current_picture_ptr->f.error[i]; } if (s->flags & CODEC_FLAG_PASS1) assert(avctx->header_bits + avctx->mv_bits + avctx->misc_bits + avctx->i_tex_bits + avctx->p_tex_bits == put_bits_count(&s->pb)); flush_put_bits(&s->pb); s->frame_bits = put_bits_count(&s->pb); stuffing_count = ff_vbv_update(s, s->frame_bits); if (stuffing_count) { if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < stuffing_count + 50) { av_log(s->avctx, AV_LOG_ERROR, ""stuffing too large\n""); return -1; } switch (s->codec_id) { case CODEC_ID_MPEG1VIDEO: case CODEC_ID_MPEG2VIDEO: while (stuffing_count--) { put_bits(&s->pb, 8, 0); } break; case CODEC_ID_MPEG4: put_bits(&s->pb, 16, 0); put_bits(&s->pb, 16, 0x1C3); stuffing_count -= 4; while (stuffing_count--) { put_bits(&s->pb, 8, 0xFF); } break; default: av_log(s->avctx, AV_LOG_ERROR, ""vbv buffer overflow\n""); } flush_put_bits(&s->pb); s->frame_bits = put_bits_count(&s->pb); } if (s->avctx->rc_max_rate && s->avctx->rc_min_rate == s->avctx->rc_max_rate && s->out_format == FMT_MPEG1 && 90000LL * (avctx->rc_buffer_size - 1) <= s->avctx->rc_max_rate * 0xFFFFLL) { int vbv_delay, min_delay; double inbits = s->avctx->rc_max_rate * av_q2d(s->avctx->time_base); int minbits = s->frame_bits - 8 * (s->vbv_delay_ptr - s->pb.buf - 1); double bits = s->rc_context.buffer_index + minbits - inbits; if (bits < 0) av_log(s->avctx, AV_LOG_ERROR, ""Internal error, negative bits\n""); assert(s->repeat_first_field == 0); vbv_delay = bits * 90000 / s->avctx->rc_max_rate; min_delay = (minbits * 90000LL + s->avctx->rc_max_rate - 1) / s->avctx->rc_max_rate; vbv_delay = FFMAX(vbv_delay, min_delay); assert(vbv_delay < 0xFFFF); s->vbv_delay_ptr[0] &= 0xF8; s->vbv_delay_ptr[0] |= vbv_delay >> 13; s->vbv_delay_ptr[1] = vbv_delay >> 5; s->vbv_delay_ptr[2] &= 0x07; s->vbv_delay_ptr[2] |= vbv_delay << 3; avctx->vbv_delay = vbv_delay * 300; } s->total_bits += s->frame_bits; avctx->frame_bits = s->frame_bits; } else { assert((put_bits_ptr(&s->pb) == s->pb.buf)); s->frame_bits = 0; } assert((s->frame_bits & 7) == 0); return s->frame_bits / 8; }","- int i, stuffing_count, context_count = avctx->thread_count;
+ int i, stuffing_count;
+ int context_count = s->slice_context_count;","int MPV_encode_picture(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data) { MpegEncContext *s = avctx->priv_data; AVFrame *pic_arg = data; int i, stuffing_count; int context_count = s->slice_context_count; for (i = 0; i < context_count; i++) { int start_y = s->thread_context[i]->start_mb_y; int end_y = s->thread_context[i]-> end_mb_y; int h = s->mb_height; uint8_t *start = buf + (size_t)(((int64_t) buf_size) * start_y / h); uint8_t *end = buf + (size_t)(((int64_t) buf_size) * end_y / h); init_put_bits(&s->thread_context[i]->pb, start, end - start); } s->picture_in_gop_number++; if (load_input_picture(s, pic_arg) < 0) return -1; if (select_input_picture(s) < 0) { return -1; } if (s->new_picture.f.data[0]) { s->pict_type = s->new_picture.f.pict_type; MPV_frame_start(s, avctx); vbv_retry: if (encode_picture(s, s->picture_number) < 0) return -1; avctx->header_bits = s->header_bits; avctx->mv_bits = s->mv_bits; avctx->misc_bits = s->misc_bits; avctx->i_tex_bits = s->i_tex_bits; avctx->p_tex_bits = s->p_tex_bits; avctx->i_count = s->i_count; avctx->p_count = s->mb_num - s->i_count - s->skip_count; avctx->skip_count = s->skip_count; MPV_frame_end(s); if (CONFIG_MJPEG_ENCODER && s->out_format == FMT_MJPEG) ff_mjpeg_encode_picture_trailer(s); if (avctx->rc_buffer_size) { RateControlContext *rcc = &s->rc_context; int max_size = rcc->buffer_index * avctx->rc_max_available_vbv_use; if (put_bits_count(&s->pb) > max_size && s->lambda < s->avctx->lmax) { s->next_lambda = FFMAX(s->lambda + 1, s->lambda * (s->qscale + 1) / s->qscale); if (s->adaptive_quant) { int i; for (i = 0; i < s->mb_height * s->mb_stride; i++) s->lambda_table[i] = FFMAX(s->lambda_table[i] + 1, s->lambda_table[i] * (s->qscale + 1) / s->qscale); } s->mb_skipped = 0; if (s->pict_type == AV_PICTURE_TYPE_P) { if (s->flipflop_rounding || s->codec_id == CODEC_ID_H263P || s->codec_id == CODEC_ID_MPEG4) s->no_rounding ^= 1; } if (s->pict_type != AV_PICTURE_TYPE_B) { s->time_base = s->last_time_base; s->last_non_b_time = s->time - s->pp_time; } for (i = 0; i < context_count; i++) { PutBitContext *pb = &s->thread_context[i]->pb; init_put_bits(pb, pb->buf, pb->buf_end - pb->buf); } goto vbv_retry; } assert(s->avctx->rc_max_rate); } if (s->flags & CODEC_FLAG_PASS1) ff_write_pass1_stats(s); for (i = 0; i < 4; i++) { s->current_picture_ptr->f.error[i] = s->current_picture.f.error[i]; avctx->error[i] += s->current_picture_ptr->f.error[i]; } if (s->flags & CODEC_FLAG_PASS1) assert(avctx->header_bits + avctx->mv_bits + avctx->misc_bits + avctx->i_tex_bits + avctx->p_tex_bits == put_bits_count(&s->pb)); flush_put_bits(&s->pb); s->frame_bits = put_bits_count(&s->pb); stuffing_count = ff_vbv_update(s, s->frame_bits); if (stuffing_count) { if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) < stuffing_count + 50) { av_log(s->avctx, AV_LOG_ERROR, ""stuffing too large\n""); return -1; } switch (s->codec_id) { case CODEC_ID_MPEG1VIDEO: case CODEC_ID_MPEG2VIDEO: while (stuffing_count--) { put_bits(&s->pb, 8, 0); } break; case CODEC_ID_MPEG4: put_bits(&s->pb, 16, 0); put_bits(&s->pb, 16, 0x1C3); stuffing_count -= 4; while (stuffing_count--) { put_bits(&s->pb, 8, 0xFF); } break; default: av_log(s->avctx, AV_LOG_ERROR, ""vbv buffer overflow\n""); } flush_put_bits(&s->pb); s->frame_bits = put_bits_count(&s->pb); } if (s->avctx->rc_max_rate && s->avctx->rc_min_rate == s->avctx->rc_max_rate && s->out_format == FMT_MPEG1 && 90000LL * (avctx->rc_buffer_size - 1) <= s->avctx->rc_max_rate * 0xFFFFLL) { int vbv_delay, min_delay; double inbits = s->avctx->rc_max_rate * av_q2d(s->avctx->time_base); int minbits = s->frame_bits - 8 * (s->vbv_delay_ptr - s->pb.buf - 1); double bits = s->rc_context.buffer_index + minbits - inbits; if (bits < 0) av_log(s->avctx, AV_LOG_ERROR, ""Internal error, negative bits\n""); assert(s->repeat_first_field == 0); vbv_delay = bits * 90000 / s->avctx->rc_max_rate; min_delay = (minbits * 90000LL + s->avctx->rc_max_rate - 1) / s->avctx->rc_max_rate; vbv_delay = FFMAX(vbv_delay, min_delay); assert(vbv_delay < 0xFFFF); s->vbv_delay_ptr[0] &= 0xF8; s->vbv_delay_ptr[0] |= vbv_delay >> 13; s->vbv_delay_ptr[1] = vbv_delay >> 5; s->vbv_delay_ptr[2] &= 0x07; s->vbv_delay_ptr[2] |= vbv_delay << 3; avctx->vbv_delay = vbv_delay * 300; } s->total_bits += s->frame_bits; avctx->frame_bits = s->frame_bits; } else { assert((put_bits_ptr(&s->pb) == s->pb.buf)); s->frame_bits = 0; } assert((s->frame_bits & 7) == 0); return s->frame_bits / 8; }"
949----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3391f57802554ead0f9b02060f0f54dee86f7fda_1.json----av_image_get_linesize,"int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane) { const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt]; int max_step [4]; int max_step_comp[4]; <S2SV_StartVul> int s, linesize; <S2SV_EndVul> if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL) return AVERROR(EINVAL); av_image_fill_max_pixsteps(max_step, max_step_comp, desc); <S2SV_StartVul> s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0; <S2SV_EndVul> <S2SV_StartVul> linesize = max_step[plane] * (((width + (1 << s) - 1)) >> s); <S2SV_EndVul> <S2SV_StartVul> if (desc->flags & PIX_FMT_BITSTREAM) <S2SV_EndVul> <S2SV_StartVul> linesize = (linesize + 7) >> 3; <S2SV_EndVul> <S2SV_StartVul> return linesize; <S2SV_EndVul> }","- int s, linesize;
- s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0;
- linesize = max_step[plane] * (((width + (1 << s) - 1)) >> s);
- if (desc->flags & PIX_FMT_BITSTREAM)
- linesize = (linesize + 7) >> 3;
- return linesize;
+ return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc);","int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane) { const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt]; int max_step [4]; int max_step_comp[4]; if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL) return AVERROR(EINVAL); av_image_fill_max_pixsteps(max_step, max_step_comp, desc); return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc); }"
3824----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cd6ff752e16dce268ef8ce9a7eaeb9f7248b6fe6_1.json----huf_uncompress,"static int huf_uncompress(GetByteContext *gb, uint16_t *dst, int dst_size) { int32_t src_size, im, iM; uint32_t nBits; uint64_t *freq; HufDec *hdec; int ret, i; src_size = bytestream2_get_le32(gb); im = bytestream2_get_le32(gb); iM = bytestream2_get_le32(gb); bytestream2_skip(gb, 4); nBits = bytestream2_get_le32(gb); if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE || src_size < 0) return AVERROR_INVALIDDATA; bytestream2_skip(gb, 4); freq = av_calloc(HUF_ENCSIZE, sizeof(*freq)); hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec)); if (!freq || !hdec) { ret = AVERROR(ENOMEM); goto fail; } if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0) goto fail; if (nBits > 8 * bytestream2_get_bytes_left(gb)) { ret = AVERROR_INVALIDDATA; goto fail; } if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0) goto fail; ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst); fail: for (i = 0; i < HUF_DECSIZE; i++) { <S2SV_StartVul> if (hdec[i].p) <S2SV_EndVul> av_freep(&hdec[i].p); } av_free(freq); av_free(hdec); return ret; }","- if (hdec[i].p)
+ if (hdec)","static int huf_uncompress(GetByteContext *gb, uint16_t *dst, int dst_size) { int32_t src_size, im, iM; uint32_t nBits; uint64_t *freq; HufDec *hdec; int ret, i; src_size = bytestream2_get_le32(gb); im = bytestream2_get_le32(gb); iM = bytestream2_get_le32(gb); bytestream2_skip(gb, 4); nBits = bytestream2_get_le32(gb); if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE || src_size < 0) return AVERROR_INVALIDDATA; bytestream2_skip(gb, 4); freq = av_calloc(HUF_ENCSIZE, sizeof(*freq)); hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec)); if (!freq || !hdec) { ret = AVERROR(ENOMEM); goto fail; } if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0) goto fail; if (nBits > 8 * bytestream2_get_bytes_left(gb)) { ret = AVERROR_INVALIDDATA; goto fail; } if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0) goto fail; ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst); fail: for (i = 0; i < HUF_DECSIZE; i++) { if (hdec) av_freep(&hdec[i].p); } av_free(freq); av_free(hdec); return ret; }"
825----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2d50633d5f9b530971c3eef37c77a1f38ce6d50d_1.json----ea_read_header,"static int ea_read_header(AVFormatContext *s) { EaDemuxContext *ea = s->priv_data; AVStream *st; if (process_ea_header(s)<=0) return AVERROR(EIO); if (init_video_stream(s, &ea->video) || init_video_stream(s, &ea->alpha)) return AVERROR(ENOMEM); if (ea->audio_codec) { if (ea->num_channels <= 0 || ea->num_channels > 2) { av_log(s, AV_LOG_WARNING, ""Unsupported number of channels: %d\n"", ea->num_channels); ea->audio_codec = 0; return 1; } if (ea->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, ""Unsupported sample rate: %d\n"", ea->sample_rate); ea->audio_codec = 0; return 1; } if (ea->bytes <= 0) { av_log(s, AV_LOG_ERROR, ""Invalid number of bytes per sample: %d\n"", ea->bytes); ea->audio_codec = AV_CODEC_ID_NONE; return 1; } st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 33, 1, ea->sample_rate); st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; st->codecpar->codec_id = ea->audio_codec; st->codecpar->codec_tag = 0; st->codecpar->channels = ea->num_channels; st->codecpar->sample_rate = ea->sample_rate; st->codecpar->bits_per_coded_sample = ea->bytes * 8; <S2SV_StartVul> st->codecpar->bit_rate = st->codecpar->channels * <S2SV_EndVul> st->codecpar->sample_rate * st->codecpar->bits_per_coded_sample / 4; st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample; ea->audio_stream_index = st->index; st->start_time = 0; } return 1; }","- st->codecpar->bit_rate = st->codecpar->channels *
+ st->codecpar->bit_rate = (int64_t)st->codecpar->channels *","static int ea_read_header(AVFormatContext *s) { EaDemuxContext *ea = s->priv_data; AVStream *st; if (process_ea_header(s)<=0) return AVERROR(EIO); if (init_video_stream(s, &ea->video) || init_video_stream(s, &ea->alpha)) return AVERROR(ENOMEM); if (ea->audio_codec) { if (ea->num_channels <= 0 || ea->num_channels > 2) { av_log(s, AV_LOG_WARNING, ""Unsupported number of channels: %d\n"", ea->num_channels); ea->audio_codec = 0; return 1; } if (ea->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, ""Unsupported sample rate: %d\n"", ea->sample_rate); ea->audio_codec = 0; return 1; } if (ea->bytes <= 0) { av_log(s, AV_LOG_ERROR, ""Invalid number of bytes per sample: %d\n"", ea->bytes); ea->audio_codec = AV_CODEC_ID_NONE; return 1; } st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); avpriv_set_pts_info(st, 33, 1, ea->sample_rate); st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; st->codecpar->codec_id = ea->audio_codec; st->codecpar->codec_tag = 0; st->codecpar->channels = ea->num_channels; st->codecpar->sample_rate = ea->sample_rate; st->codecpar->bits_per_coded_sample = ea->bytes * 8; st->codecpar->bit_rate = (int64_t)st->codecpar->channels * st->codecpar->sample_rate * st->codecpar->bits_per_coded_sample / 4; st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample; ea->audio_stream_index = st->index; st->start_time = 0; } return 1; }"
1190----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_40f1dadac0826affb49726324ec4d3709b48a6ec_1.json----format_name,"static int format_name(char *buf, int buf_len, int index) { const char *proto, *dir; <S2SV_StartVul> char *orig_buf_dup = NULL, *mod_buf_dup = NULL; <S2SV_EndVul> int ret = 0; if (!av_stristr(buf, ""%v"")) return ret; orig_buf_dup = av_strdup(buf); if (!orig_buf_dup) { ret = AVERROR(ENOMEM); goto fail; } <S2SV_StartVul> if (replace_int_data_in_filename(buf, buf_len, orig_buf_dup, 'v', index) < 1) { <S2SV_EndVul> ret = AVERROR(EINVAL); goto fail; } proto = avio_find_protocol_name(orig_buf_dup); dir = av_dirname(orig_buf_dup); if (av_stristr(dir, ""%v"") && proto && !strcmp(proto, ""file"")) { mod_buf_dup = av_strdup(buf); if (!mod_buf_dup) { ret = AVERROR(ENOMEM); goto fail; } dir = av_dirname(mod_buf_dup); if (mkdir_p(dir) == -1 && errno != EEXIST) { ret = AVERROR(errno); goto fail; } } fail: av_freep(&orig_buf_dup); av_freep(&mod_buf_dup); return ret; }","- char *orig_buf_dup = NULL, *mod_buf_dup = NULL;
- if (replace_int_data_in_filename(buf, buf_len, orig_buf_dup, 'v', index) < 1) {
+ char *orig_buf_dup = NULL, *mod_buf = NULL, *mod_buf_dup = NULL;
+ if (replace_int_data_in_filename(&mod_buf, orig_buf_dup, 'v', index) < 1) {
+ av_strlcpy(buf, mod_buf, buf_len);
+ av_freep(&mod_buf);","static int format_name(char *buf, int buf_len, int index) { const char *proto, *dir; char *orig_buf_dup = NULL, *mod_buf = NULL, *mod_buf_dup = NULL; int ret = 0; if (!av_stristr(buf, ""%v"")) return ret; orig_buf_dup = av_strdup(buf); if (!orig_buf_dup) { ret = AVERROR(ENOMEM); goto fail; } if (replace_int_data_in_filename(&mod_buf, orig_buf_dup, 'v', index) < 1) { ret = AVERROR(EINVAL); goto fail; } av_strlcpy(buf, mod_buf, buf_len); proto = avio_find_protocol_name(orig_buf_dup); dir = av_dirname(orig_buf_dup); if (av_stristr(dir, ""%v"") && proto && !strcmp(proto, ""file"")) { mod_buf_dup = av_strdup(buf); if (!mod_buf_dup) { ret = AVERROR(ENOMEM); goto fail; } dir = av_dirname(mod_buf_dup); if (mkdir_p(dir) == -1 && errno != EEXIST) { ret = AVERROR(errno); goto fail; } } fail: av_freep(&orig_buf_dup); av_freep(&mod_buf_dup); av_freep(&mod_buf); return ret; }"
15307----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b10aa44ddfeb8b95f69326bf598d46cfdfc763fe_1.json----tls_psk_do_binder,"int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart, size_t binderoffset, const unsigned char *binderin, unsigned char *binderout, SSL_SESSION *sess, int sign, int external) { EVP_PKEY *mackey = NULL; EVP_MD_CTX *mctx = NULL; unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE]; unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE]; unsigned char *early_secret; const char resumption_label[] = ""res binder""; const char external_label[] = ""ext binder""; const char *label; size_t bindersize, labelsize, hashsize = EVP_MD_size(md); int ret = -1; if (external) { label = external_label; labelsize = sizeof(external_label) - 1; } else { label = resumption_label; labelsize = sizeof(resumption_label) - 1; } if (s->server || !external) early_secret = (unsigned char *)s->early_secret; else early_secret = (unsigned char *)sess->early_secret; if (!tls13_generate_secret(s, md, NULL, sess->master_key, sess->master_key_length, early_secret)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } mctx = EVP_MD_CTX_new(); if (mctx == NULL || EVP_DigestInit_ex(mctx, md, NULL) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!tls13_hkdf_expand(s, md, early_secret, (unsigned char *)label, <S2SV_StartVul> labelsize, hash, binderkey, hashsize)) { <S2SV_EndVul> SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (s->hello_retry_request) { size_t hdatalen; void *hdata; hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, SSL_R_BAD_HANDSHAKE_LENGTH); goto err; } if (s->server) { PACKET hashprefix, msg; if (!PACKET_buf_init(&hashprefix, hdata, hdatalen) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } hdatalen -= PACKET_remaining(&hashprefix); } if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } } if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } mackey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, finishedkey, hashsize); if (mackey == NULL) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!sign) binderout = tmpbinder; bindersize = hashsize; if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0 || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0 || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0 || bindersize != hashsize) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (sign) { ret = 1; } else { ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0); } err: OPENSSL_cleanse(binderkey, sizeof(binderkey)); OPENSSL_cleanse(finishedkey, sizeof(finishedkey)); EVP_PKEY_free(mackey); EVP_MD_CTX_free(mctx); return ret; }","- labelsize, hash, binderkey, hashsize)) {
+ labelsize, hash, hashsize, binderkey, hashsize)) {","int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart, size_t binderoffset, const unsigned char *binderin, unsigned char *binderout, SSL_SESSION *sess, int sign, int external) { EVP_PKEY *mackey = NULL; EVP_MD_CTX *mctx = NULL; unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE]; unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE]; unsigned char *early_secret; const char resumption_label[] = ""res binder""; const char external_label[] = ""ext binder""; const char *label; size_t bindersize, labelsize, hashsize = EVP_MD_size(md); int ret = -1; if (external) { label = external_label; labelsize = sizeof(external_label) - 1; } else { label = resumption_label; labelsize = sizeof(resumption_label) - 1; } if (s->server || !external) early_secret = (unsigned char *)s->early_secret; else early_secret = (unsigned char *)sess->early_secret; if (!tls13_generate_secret(s, md, NULL, sess->master_key, sess->master_key_length, early_secret)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } mctx = EVP_MD_CTX_new(); if (mctx == NULL || EVP_DigestInit_ex(mctx, md, NULL) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!tls13_hkdf_expand(s, md, early_secret, (unsigned char *)label, labelsize, hash, hashsize, binderkey, hashsize)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (s->hello_retry_request) { size_t hdatalen; void *hdata; hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, SSL_R_BAD_HANDSHAKE_LENGTH); goto err; } if (s->server) { PACKET hashprefix, msg; if (!PACKET_buf_init(&hashprefix, hdata, hdatalen) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg) || !PACKET_forward(&hashprefix, 1) || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } hdatalen -= PACKET_remaining(&hashprefix); } if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } } if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0 || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } mackey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, finishedkey, hashsize); if (mackey == NULL) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (!sign) binderout = tmpbinder; bindersize = hashsize; if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0 || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0 || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0 || bindersize != hashsize) { SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR); goto err; } if (sign) { ret = 1; } else { ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0); } err: OPENSSL_cleanse(binderkey, sizeof(binderkey)); OPENSSL_cleanse(finishedkey, sizeof(finishedkey)); EVP_PKEY_free(mackey); EVP_MD_CTX_free(mctx); return ret; }"
15872----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c4ce0c3f067175c913e097e5d518e131be06fd80_1.json----x9_62_tests,"<S2SV_StartVul> int x9_62_tests(BIO *out) <S2SV_EndVul> { int ret = 0; <S2SV_StartVul> BIO_printf(out, ""some tests from X9.62:\n""); <S2SV_EndVul> if (!change_rand()) goto x962_err; <S2SV_StartVul> if (!x9_62_test_internal(out, NID_X9_62_prime192v1, <S2SV_EndVul> <S2SV_StartVul> ""3342403536405981729393488334694600415596881826869351677613"", <S2SV_EndVul> <S2SV_StartVul> ""5735822328888155254683894997897571951568553642892029982342"")) <S2SV_EndVul> goto x962_err; <S2SV_StartVul> if (!x9_62_test_internal(out, NID_X9_62_prime239v1, <S2SV_EndVul> <S2SV_StartVul> ""3086361431751678114926225473006680188549593787585317781474"" <S2SV_EndVul> ""62058306432176"", <S2SV_StartVul> ""3238135532097973577080787768312505059318910517550078427819"" <S2SV_EndVul> <S2SV_StartVul> ""78505179448783"")) <S2SV_EndVul> goto x962_err; # ifndef OPENSSL_NO_EC2M <S2SV_StartVul> if (!x9_62_test_internal(out, NID_X9_62_c2tnb191v1, <S2SV_EndVul> <S2SV_StartVul> ""87194383164871543355722284926904419997237591535066528048"", <S2SV_EndVul> <S2SV_StartVul> ""308992691965804947361541664549085895292153777025772063598"")) <S2SV_EndVul> goto x962_err; <S2SV_StartVul> if (!x9_62_test_internal(out, NID_X9_62_c2tnb239v1, <S2SV_EndVul> <S2SV_StartVul> ""2159633321041961198501834003903461262881815148684178964245"" <S2SV_EndVul> ""5876922391552"", <S2SV_StartVul> ""1970303740007316867383349976549972270528498040721988191026"" <S2SV_EndVul> <S2SV_StartVul> ""49413465737174"")) <S2SV_EndVul> goto x962_err; # endif ret = 1; x962_err: <S2SV_StartVul> if (!restore_rand()) <S2SV_EndVul> ret = 0; return ret; }","- int x9_62_tests(BIO *out)
- BIO_printf(out, ""some tests from X9.62:\n"");
- if (!x9_62_test_internal(out, NID_X9_62_prime192v1,
- ""3342403536405981729393488334694600415596881826869351677613"",
- ""5735822328888155254683894997897571951568553642892029982342""))
- if (!x9_62_test_internal(out, NID_X9_62_prime239v1,
- ""3086361431751678114926225473006680188549593787585317781474""
- ""3238135532097973577080787768312505059318910517550078427819""
- ""78505179448783""))
- if (!x9_62_test_internal(out, NID_X9_62_c2tnb191v1,
- ""87194383164871543355722284926904419997237591535066528048"",
- ""308992691965804947361541664549085895292153777025772063598""))
- if (!x9_62_test_internal(out, NID_X9_62_c2tnb239v1,
- ""2159633321041961198501834003903461262881815148684178964245""
- ""1970303740007316867383349976549972270528498040721988191026""
- ""49413465737174""))
- if (!restore_rand())
+ static int x9_62_tests()
+ if (!TEST_true(x9_62_test_internal(NID_X9_62_prime192v1,
+ ""3342403536405981729393488334694600415596881826869351677613"",
+ ""5735822328888155254683894997897571951568553642892029982342"")))
+ if (!TEST_true(x9_62_test_internal(NID_X9_62_prime239v1,
+ ""3086361431751678114926225473006680188549593787585317781474""
+ ""3238135532097973577080787768312505059318910517550078427819""
+ ""78505179448783"")))
+ if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb191v1,
+ ""87194383164871543355722284926904419997237591535066528048"",
+ ""308992691965804947361541664549085895292153777025772063598"")))
+ if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb239v1,
+ ""2159633321041961198501834003903461262881815148684178964245""
+ ""1970303740007316867383349976549972270528498040721988191026""
+ ""49413465737174"")))
+ if (!TEST_true(restore_rand()))","static int x9_62_tests() { int ret = 0; if (!change_rand()) goto x962_err; if (!TEST_true(x9_62_test_internal(NID_X9_62_prime192v1, ""3342403536405981729393488334694600415596881826869351677613"", ""5735822328888155254683894997897571951568553642892029982342""))) goto x962_err; if (!TEST_true(x9_62_test_internal(NID_X9_62_prime239v1, ""3086361431751678114926225473006680188549593787585317781474"" ""62058306432176"", ""3238135532097973577080787768312505059318910517550078427819"" ""78505179448783""))) goto x962_err; # ifndef OPENSSL_NO_EC2M if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb191v1, ""87194383164871543355722284926904419997237591535066528048"", ""308992691965804947361541664549085895292153777025772063598""))) goto x962_err; if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb239v1, ""2159633321041961198501834003903461262881815148684178964245"" ""5876922391552"", ""1970303740007316867383349976549972270528498040721988191026"" ""49413465737174""))) goto x962_err; # endif ret = 1; x962_err: if (!TEST_true(restore_rand())) ret = 0; return ret; }"
5677----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_29d7d6dfec445d962ee7f5280cee20554a726785_1.json----vp8_mc_luma,"static av_always_inline <S2SV_StartVul> void vp8_mc_luma(VP8Context *s, uint8_t *dst, AVFrame *ref, const VP56mv *mv, <S2SV_EndVul> int x_off, int y_off, int block_w, int block_h, int width, int height, int linesize, vp8_mc_func mc_func[3][3]) { uint8_t *src = ref->data[0]; if (AV_RN32A(mv)) { int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx]; int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my]; x_off += mv->x >> 2; y_off += mv->y >> 2; ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0); src += y_off * linesize + x_off; if (x_off < mx_idx || x_off >= width - block_w - subpel_idx[2][mx] || y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) { <S2SV_StartVul> s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize, <S2SV_EndVul> block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my], x_off - mx_idx, y_off - my_idx, width, height); <S2SV_StartVul> src = s->edge_emu_buffer + mx_idx + linesize * my_idx; <S2SV_EndVul> } mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my); } else { ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0); mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0); } }","- void vp8_mc_luma(VP8Context *s, uint8_t *dst, AVFrame *ref, const VP56mv *mv,
- s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,
- src = s->edge_emu_buffer + mx_idx + linesize * my_idx;
+ void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,
+ AVFrame *ref, const VP56mv *mv,
+ s->dsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,
+ src = td->edge_emu_buffer + mx_idx + linesize * my_idx;","static av_always_inline void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst, AVFrame *ref, const VP56mv *mv, int x_off, int y_off, int block_w, int block_h, int width, int height, int linesize, vp8_mc_func mc_func[3][3]) { uint8_t *src = ref->data[0]; if (AV_RN32A(mv)) { int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx]; int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my]; x_off += mv->x >> 2; y_off += mv->y >> 2; ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0); src += y_off * linesize + x_off; if (x_off < mx_idx || x_off >= width - block_w - subpel_idx[2][mx] || y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) { s->dsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize, block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my], x_off - mx_idx, y_off - my_idx, width, height); src = td->edge_emu_buffer + mx_idx + linesize * my_idx; } mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my); } else { ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0); mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0); } }"
7805----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a8338af27a0f47920be36307107618cb60fb51fa_1.json----allocate_buffers,"static void allocate_buffers(FLACContext *s) { int i; assert(s->max_blocksize); for (i = 0; i < s->channels; i++) { <S2SV_StartVul> s->decoded[i] = av_realloc(s->decoded[i], <S2SV_EndVul> <S2SV_StartVul> sizeof(int32_t)*s->max_blocksize); <S2SV_EndVul> } }","- s->decoded[i] = av_realloc(s->decoded[i],
- sizeof(int32_t)*s->max_blocksize);
+ s->decoded[i] = av_malloc(sizeof(int32_t)*s->max_blocksize);",static void allocate_buffers(FLACContext *s) { int i; assert(s->max_blocksize); for (i = 0; i < s->channels; i++) { s->decoded[i] = av_malloc(sizeof(int32_t)*s->max_blocksize); } }
13448----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_700f87ea7cbec40d4209c9e8703505cb625e5970_1.json----check_purpose,"static int check_purpose(X509_STORE_CTX *ctx, X509 *x, int purpose, int depth, int must_be_ca) { <S2SV_StartVul> int pu_ok = X509_check_purpose(x, purpose, must_be_ca > 0); <S2SV_EndVul> int tr_ok = X509_TRUST_UNTRUSTED; if (depth >= ctx->num_untrusted && purpose == ctx->param->purpose) tr_ok = X509_check_trust(x, ctx->param->trust, X509_TRUST_NO_SS_COMPAT); <S2SV_StartVul> if (tr_ok != X509_TRUST_REJECTED && <S2SV_EndVul> <S2SV_StartVul> (pu_ok == 1 || <S2SV_EndVul> <S2SV_StartVul> (pu_ok != 0 && (ctx->param->flags & X509_V_FLAG_X509_STRICT) == 0))) <S2SV_EndVul> return 1; ctx->error = X509_V_ERR_INVALID_PURPOSE; ctx->error_depth = depth; ctx->current_cert = x; return ctx->verify_cb(0, ctx); }","- int pu_ok = X509_check_purpose(x, purpose, must_be_ca > 0);
- if (tr_ok != X509_TRUST_REJECTED &&
- (pu_ok == 1 ||
- (pu_ok != 0 && (ctx->param->flags & X509_V_FLAG_X509_STRICT) == 0)))
+ switch (tr_ok) {
+ case X509_TRUST_TRUSTED:
+ case X509_TRUST_REJECTED:
+ break;
+ default:
+ switch (X509_check_purpose(x, purpose, must_be_ca > 0)) {
+ case 1:
+ return 1;
+ case 0:
+ break;
+ default:
+ if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) == 0)
+ return 1;
+ }
+ break;
+ }","static int check_purpose(X509_STORE_CTX *ctx, X509 *x, int purpose, int depth, int must_be_ca) { int tr_ok = X509_TRUST_UNTRUSTED; if (depth >= ctx->num_untrusted && purpose == ctx->param->purpose) tr_ok = X509_check_trust(x, ctx->param->trust, X509_TRUST_NO_SS_COMPAT); switch (tr_ok) { case X509_TRUST_TRUSTED: return 1; case X509_TRUST_REJECTED: break; default: switch (X509_check_purpose(x, purpose, must_be_ca > 0)) { case 1: return 1; case 0: break; default: if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) == 0) return 1; } break; } ctx->error = X509_V_ERR_INVALID_PURPOSE; ctx->error_depth = depth; ctx->current_cert = x; return ctx->verify_cb(0, ctx); }"
1248----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_437bdd486a45c19a4edef898d70419aebd227188_1.json----cookie_string,"static int cookie_string(AVDictionary *dict, char **cookies) { AVDictionaryEntry *e = NULL; int len = 1; while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX)) len += strlen(e->key) + strlen(e->value) + 1; e = NULL; if (*cookies) av_free(*cookies); *cookies = av_malloc(len); <S2SV_StartVul> if (!cookies) return AVERROR(ENOMEM); <S2SV_EndVul> *cookies[0] = '\0'; while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX)) av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value); return 0; }","- if (!cookies) return AVERROR(ENOMEM);
+ if (!*cookies) return AVERROR(ENOMEM);","static int cookie_string(AVDictionary *dict, char **cookies) { AVDictionaryEntry *e = NULL; int len = 1; while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX)) len += strlen(e->key) + strlen(e->value) + 1; e = NULL; if (*cookies) av_free(*cookies); *cookies = av_malloc(len); if (!*cookies) return AVERROR(ENOMEM); *cookies[0] = '\0'; while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX)) av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value); return 0; }"
2651----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_90fb6bb9c69c9102306aa06d8e43b3cc669b241e_1.json----dirac_unpack_block_motion_data,"<S2SV_StartVul> static void dirac_unpack_block_motion_data(DiracContext *s) <S2SV_EndVul> { GetBitContext *gb = &s->gb; uint8_t *sbsplit = s->sbsplit; int i, x, y, q, p; DiracArith arith[8]; align_get_bits(gb); s->sbwidth = DIVRNDUP(s->source.width, 4*s->plane[0].xbsep); s->sbheight = DIVRNDUP(s->source.height, 4*s->plane[0].ybsep); s->blwidth = 4 * s->sbwidth; s->blheight = 4 * s->sbheight; ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb)); for (y = 0; y < s->sbheight; y++) { for (x = 0; x < s->sbwidth; x++) { <S2SV_StartVul> int split = dirac_get_arith_uint(arith, CTX_SB_F1, CTX_SB_DATA); <S2SV_EndVul> sbsplit[x] = (split + pred_sbsplit(sbsplit+x, s->sbwidth, x, y)) % 3; } sbsplit += s->sbwidth; } ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb)); for (i = 0; i < s->num_refs; i++) { ff_dirac_init_arith_decoder(arith + 4 + 2 * i, gb, svq3_get_ue_golomb(gb)); ff_dirac_init_arith_decoder(arith + 5 + 2 * i, gb, svq3_get_ue_golomb(gb)); } for (i = 0; i < 3; i++) ff_dirac_init_arith_decoder(arith+1+i, gb, svq3_get_ue_golomb(gb)); for (y = 0; y < s->sbheight; y++) for (x = 0; x < s->sbwidth; x++) { int blkcnt = 1 << s->sbsplit[y * s->sbwidth + x]; int step = 4 >> s->sbsplit[y * s->sbwidth + x]; for (q = 0; q < blkcnt; q++) for (p = 0; p < blkcnt; p++) { int bx = 4 * x + p*step; int by = 4 * y + q*step; DiracBlock *block = &s->blmotion[by*s->blwidth + bx]; decode_block_params(s, arith, block, s->blwidth, bx, by); propagate_block_data(block, s->blwidth, step); } } }","- static void dirac_unpack_block_motion_data(DiracContext *s)
- int split = dirac_get_arith_uint(arith, CTX_SB_F1, CTX_SB_DATA);
+ static int dirac_unpack_block_motion_data(DiracContext *s)
+ unsigned int split = dirac_get_arith_uint(arith, CTX_SB_F1, CTX_SB_DATA);
+ if (split > 2)
+ return -1;
+ return 0;","static int dirac_unpack_block_motion_data(DiracContext *s) { GetBitContext *gb = &s->gb; uint8_t *sbsplit = s->sbsplit; int i, x, y, q, p; DiracArith arith[8]; align_get_bits(gb); s->sbwidth = DIVRNDUP(s->source.width, 4*s->plane[0].xbsep); s->sbheight = DIVRNDUP(s->source.height, 4*s->plane[0].ybsep); s->blwidth = 4 * s->sbwidth; s->blheight = 4 * s->sbheight; ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb)); for (y = 0; y < s->sbheight; y++) { for (x = 0; x < s->sbwidth; x++) { unsigned int split = dirac_get_arith_uint(arith, CTX_SB_F1, CTX_SB_DATA); if (split > 2) return -1; sbsplit[x] = (split + pred_sbsplit(sbsplit+x, s->sbwidth, x, y)) % 3; } sbsplit += s->sbwidth; } ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb)); for (i = 0; i < s->num_refs; i++) { ff_dirac_init_arith_decoder(arith + 4 + 2 * i, gb, svq3_get_ue_golomb(gb)); ff_dirac_init_arith_decoder(arith + 5 + 2 * i, gb, svq3_get_ue_golomb(gb)); } for (i = 0; i < 3; i++) ff_dirac_init_arith_decoder(arith+1+i, gb, svq3_get_ue_golomb(gb)); for (y = 0; y < s->sbheight; y++) for (x = 0; x < s->sbwidth; x++) { int blkcnt = 1 << s->sbsplit[y * s->sbwidth + x]; int step = 4 >> s->sbsplit[y * s->sbwidth + x]; for (q = 0; q < blkcnt; q++) for (p = 0; p < blkcnt; p++) { int bx = 4 * x + p*step; int by = 4 * y + q*step; DiracBlock *block = &s->blmotion[by*s->blwidth + bx]; decode_block_params(s, arith, block, s->blwidth, bx, by); propagate_block_data(block, s->blwidth, step); } } return 0; }"
7761----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a5a095bf58869d2ba60cadc45e6cdeaa88a12185_1.json----decode_frame,"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; int ret; h->flags = avctx->flags; out: if (buf_size == 0) { Picture *out; int i, out_idx; h->cur_pic_ptr = NULL; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { <S2SV_StartVul> if ((ret = av_frame_ref(pict, &out->f)) < 0) <S2SV_EndVul> return ret; *got_frame = 1; } return buf_index; } buf_index = decode_nal_units(h, buf, buf_size, 0); if (buf_index < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF) return 0; av_log(avctx, AV_LOG_ERROR, ""no frame!\n""); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); if (!h->next_output_pic) { *got_frame = 0; } else { <S2SV_StartVul> if ((ret = av_frame_ref(pict, &h->next_output_pic->f)) < 0) <S2SV_EndVul> return ret; *got_frame = 1; } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }","- if ((ret = av_frame_ref(pict, &out->f)) < 0)
- if ((ret = av_frame_ref(pict, &h->next_output_pic->f)) < 0)
+ ret = output_frame(h, pict, &out->f);
+ if (ret < 0)
+ ret = output_frame(h, pict, &h->next_output_pic->f);
+ if (ret < 0)","static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; int ret; h->flags = avctx->flags; out: if (buf_size == 0) { Picture *out; int i, out_idx; h->cur_pic_ptr = NULL; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { ret = output_frame(h, pict, &out->f); if (ret < 0) return ret; *got_frame = 1; } return buf_index; } buf_index = decode_nal_units(h, buf, buf_size, 0); if (buf_index < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF) return 0; av_log(avctx, AV_LOG_ERROR, ""no frame!\n""); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); if (!h->next_output_pic) { *got_frame = 0; } else { ret = output_frame(h, pict, &h->next_output_pic->f); if (ret < 0) return ret; *got_frame = 1; } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }"
10895----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_160d7256cdbd1ef5bd40b4524626dd2db2d282ab_1.json----X509_VERIFY_PARAM_inherit,"int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest, const X509_VERIFY_PARAM *src) { unsigned long inh_flags; int to_default, to_overwrite; if (!src) return 1; inh_flags = dest->inh_flags | src->inh_flags; if (inh_flags & X509_VP_FLAG_ONCE) dest->inh_flags = 0; if (inh_flags & X509_VP_FLAG_LOCKED) return 1; if (inh_flags & X509_VP_FLAG_DEFAULT) to_default = 1; else to_default = 0; if (inh_flags & X509_VP_FLAG_OVERWRITE) to_overwrite = 1; else to_overwrite = 0; x509_verify_param_copy(purpose, 0); x509_verify_param_copy(trust, 0); x509_verify_param_copy(depth, -1); if (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME)) { dest->check_time = src->check_time; dest->flags &= ~X509_V_FLAG_USE_CHECK_TIME; } if (inh_flags & X509_VP_FLAG_RESET_FLAGS) dest->flags = 0; dest->flags |= src->flags; if (test_x509_verify_param_copy(policies, NULL)) { if (!X509_VERIFY_PARAM_set1_policies(dest, src->policies)) return 0; } <S2SV_StartVul> if (test_x509_verify_param_copy(host, NULL)) <S2SV_EndVul> { <S2SV_StartVul> if (!X509_VERIFY_PARAM_set1_host(dest, src->host, src->hostlen)) <S2SV_EndVul> return 0; } <S2SV_StartVul> if (test_x509_verify_param_copy(email, NULL)) <S2SV_EndVul> { <S2SV_StartVul> if (!X509_VERIFY_PARAM_set1_email(dest, src->email, src->emaillen)) <S2SV_EndVul> return 0; } <S2SV_StartVul> if (test_x509_verify_param_copy(ip, NULL)) <S2SV_EndVul> { <S2SV_StartVul> if (!X509_VERIFY_PARAM_set1_ip(dest, src->ip, src->iplen)) <S2SV_EndVul> return 0; } return 1; }","- if (test_x509_verify_param_copy(host, NULL))
- if (!X509_VERIFY_PARAM_set1_host(dest, src->host, src->hostlen))
- if (test_x509_verify_param_copy(email, NULL))
- if (!X509_VERIFY_PARAM_set1_email(dest, src->email, src->emaillen))
- if (test_x509_verify_param_copy(ip, NULL))
- if (!X509_VERIFY_PARAM_set1_ip(dest, src->ip, src->iplen))
+ X509_VERIFY_PARAM_ID *id;
+ id = src->id;
+ if (test_x509_verify_param_copy_id(host, NULL))
+ if (!X509_VERIFY_PARAM_set1_host(dest, id->host, id->hostlen))
+ if (test_x509_verify_param_copy_id(email, NULL))
+ if (!X509_VERIFY_PARAM_set1_email(dest, id->email, id->emaillen))
+ if (test_x509_verify_param_copy_id(ip, NULL))
+ if (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))","int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest, const X509_VERIFY_PARAM *src) { unsigned long inh_flags; int to_default, to_overwrite; X509_VERIFY_PARAM_ID *id; if (!src) return 1; id = src->id; inh_flags = dest->inh_flags | src->inh_flags; if (inh_flags & X509_VP_FLAG_ONCE) dest->inh_flags = 0; if (inh_flags & X509_VP_FLAG_LOCKED) return 1; if (inh_flags & X509_VP_FLAG_DEFAULT) to_default = 1; else to_default = 0; if (inh_flags & X509_VP_FLAG_OVERWRITE) to_overwrite = 1; else to_overwrite = 0; x509_verify_param_copy(purpose, 0); x509_verify_param_copy(trust, 0); x509_verify_param_copy(depth, -1); if (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME)) { dest->check_time = src->check_time; dest->flags &= ~X509_V_FLAG_USE_CHECK_TIME; } if (inh_flags & X509_VP_FLAG_RESET_FLAGS) dest->flags = 0; dest->flags |= src->flags; if (test_x509_verify_param_copy(policies, NULL)) { if (!X509_VERIFY_PARAM_set1_policies(dest, src->policies)) return 0; } if (test_x509_verify_param_copy_id(host, NULL)) { if (!X509_VERIFY_PARAM_set1_host(dest, id->host, id->hostlen)) return 0; } if (test_x509_verify_param_copy_id(email, NULL)) { if (!X509_VERIFY_PARAM_set1_email(dest, id->email, id->emaillen)) return 0; } if (test_x509_verify_param_copy_id(ip, NULL)) { if (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen)) return 0; } return 1; }"
5586----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_1.json----vp8_decode_frame,"static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { VP8Context *s = avctx->priv_data; int ret, mb_x, mb_y, i, y, referenced; enum AVDiscard skip_thresh; AVFrame *av_uninit(curframe), *prev_frame = s->framep[VP56_FRAME_CURRENT]; if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0) return ret; referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT || s->update_altref == VP56_FRAME_CURRENT; skip_thresh = !referenced ? AVDISCARD_NONREF : !s->keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL; if (avctx->skip_frame >= skip_thresh) { s->invisible = 1; goto skip_decode; } s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh; for (i = 0; i < 5; i++) if (s->frames[i].data[0] && &s->frames[i] != prev_frame && &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) <S2SV_StartVul> ff_thread_release_buffer(avctx, &s->frames[i]); <S2SV_EndVul> for (i = 0; i < 5; i++) if (&s->frames[i] != prev_frame && &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) { curframe = s->framep[VP56_FRAME_CURRENT] = &s->frames[i]; break; } if (i == 5) { av_log(avctx, AV_LOG_FATAL, ""Ran out of free frames!\n""); abort(); } if (curframe->data[0]) ff_thread_release_buffer(avctx, curframe); curframe->key_frame = s->keyframe; curframe->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P; curframe->reference = referenced ? 3 : 0; <S2SV_StartVul> curframe->ref_index[0] = s->segmentation_map; <S2SV_EndVul> <S2SV_StartVul> if ((ret = ff_thread_get_buffer(avctx, curframe))) { <S2SV_EndVul> av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed!\n""); return ret; } if (s->update_altref != VP56_FRAME_NONE) { s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref]; } else { s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2]; } if (s->update_golden != VP56_FRAME_NONE) { s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden]; } else { s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN]; } if (s->update_last) { s->next_framep[VP56_FRAME_PREVIOUS] = curframe; } else { s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS]; } s->next_framep[VP56_FRAME_CURRENT] = curframe; ff_thread_finish_setup(avctx); if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] || !s->framep[VP56_FRAME_GOLDEN] || !s->framep[VP56_FRAME_GOLDEN2])) { av_log(avctx, AV_LOG_WARNING, ""Discarding interframe without a prior keyframe!\n""); return AVERROR_INVALIDDATA; } s->linesize = curframe->linesize[0]; s->uvlinesize = curframe->linesize[1]; if (!s->edge_emu_buffer) s->edge_emu_buffer = av_malloc(21*s->linesize); memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz)); memset(s->macroblocks + s->mb_height*2 - 1, 0, (s->mb_width+1)*sizeof(*s->macroblocks)); if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) { s->top_border[0][15] = s->top_border[0][23] = 127; memset(s->top_border[1]-1, 127, s->mb_width*sizeof(*s->top_border)+1); } memset(s->ref_count, 0, sizeof(s->ref_count)); if (s->keyframe) memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width*4); #define MARGIN (16 << 2) s->mv_min.y = -MARGIN; s->mv_max.y = ((s->mb_height - 1) << 6) + MARGIN; for (mb_y = 0; mb_y < s->mb_height; mb_y++) { VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions-1)]; VP8Macroblock *mb = s->macroblocks + (s->mb_height - mb_y - 1)*2; int mb_xy = mb_y*s->mb_width; uint8_t *dst[3] = { curframe->data[0] + 16*mb_y*s->linesize, curframe->data[1] + 8*mb_y*s->uvlinesize, curframe->data[2] + 8*mb_y*s->uvlinesize }; memset(mb - 1, 0, sizeof(*mb)); memset(s->left_nnz, 0, sizeof(s->left_nnz)); AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED*0x01010101); if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) { for (i = 0; i < 3; i++) for (y = 0; y < 16>>!!i; y++) dst[i][y*curframe->linesize[i]-1] = 129; if (mb_y == 1) s->top_border[0][15] = s->top_border[0][23] = s->top_border[0][31] = 129; } s->mv_min.x = -MARGIN; s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN; if (prev_frame && s->segmentation.enabled && !s->segmentation.update_map) ff_thread_await_progress(prev_frame, mb_y, 0); for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) { s->dsp.prefetch(dst[0] + (mb_x&3)*4*s->linesize + 64, s->linesize, 4); s->dsp.prefetch(dst[1] + (mb_x&7)*s->uvlinesize + 64, dst[2] - dst[1], 2); <S2SV_StartVul> decode_mb_mode(s, mb, mb_x, mb_y, s->segmentation_map + mb_xy, <S2SV_EndVul> <S2SV_StartVul> prev_frame ? prev_frame->ref_index[0] + mb_xy : NULL); <S2SV_EndVul> prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS); if (!mb->skip) decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz); if (mb->mode <= MODE_I4x4) intra_predict(s, dst, mb, mb_x, mb_y); else inter_predict(s, dst, mb, mb_x, mb_y); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN); if (!mb->skip) { idct_mb(s, dst, mb); } else { AV_ZERO64(s->left_nnz); AV_WN64(s->top_nnz[mb_x], 0); if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) { s->left_nnz[8] = 0; s->top_nnz[mb_x][8] = 0; } } if (s->deblock_filter) filter_level_for_mb(s, mb, &s->filter_strength[mb_x]); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2); dst[0] += 16; dst[1] += 8; dst[2] += 8; s->mv_min.x -= 64; s->mv_max.x -= 64; } if (s->deblock_filter) { if (s->filter.simple) filter_mb_row_simple(s, curframe, mb_y); else filter_mb_row(s, curframe, mb_y); } s->mv_min.y -= 64; s->mv_max.y -= 64; ff_thread_report_progress(curframe, mb_y, 0); } ff_thread_report_progress(curframe, INT_MAX, 0); skip_decode: if (!s->update_probabilities) s->prob[0] = s->prob[1]; memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4); if (!s->invisible) { *(AVFrame*)data = *curframe; *data_size = sizeof(AVFrame); } return avpkt->size; }","- ff_thread_release_buffer(avctx, &s->frames[i]);
- curframe->ref_index[0] = s->segmentation_map;
- if ((ret = ff_thread_get_buffer(avctx, curframe))) {
- decode_mb_mode(s, mb, mb_x, mb_y, s->segmentation_map + mb_xy,
- prev_frame ? prev_frame->ref_index[0] + mb_xy : NULL);
+ release_queued_segmaps(s, 0);
+ vp8_release_frame(s, &s->frames[i], 0);
+ if ((ret = vp8_alloc_frame(s, curframe))) {
+ decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,
+ prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL);","static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { VP8Context *s = avctx->priv_data; int ret, mb_x, mb_y, i, y, referenced; enum AVDiscard skip_thresh; AVFrame *av_uninit(curframe), *prev_frame = s->framep[VP56_FRAME_CURRENT]; release_queued_segmaps(s, 0); if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0) return ret; referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT || s->update_altref == VP56_FRAME_CURRENT; skip_thresh = !referenced ? AVDISCARD_NONREF : !s->keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL; if (avctx->skip_frame >= skip_thresh) { s->invisible = 1; goto skip_decode; } s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh; for (i = 0; i < 5; i++) if (s->frames[i].data[0] && &s->frames[i] != prev_frame && &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) vp8_release_frame(s, &s->frames[i], 0); for (i = 0; i < 5; i++) if (&s->frames[i] != prev_frame && &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] && &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) { curframe = s->framep[VP56_FRAME_CURRENT] = &s->frames[i]; break; } if (i == 5) { av_log(avctx, AV_LOG_FATAL, ""Ran out of free frames!\n""); abort(); } if (curframe->data[0]) ff_thread_release_buffer(avctx, curframe); curframe->key_frame = s->keyframe; curframe->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P; curframe->reference = referenced ? 3 : 0; if ((ret = vp8_alloc_frame(s, curframe))) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed!\n""); return ret; } if (s->update_altref != VP56_FRAME_NONE) { s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref]; } else { s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2]; } if (s->update_golden != VP56_FRAME_NONE) { s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden]; } else { s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN]; } if (s->update_last) { s->next_framep[VP56_FRAME_PREVIOUS] = curframe; } else { s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS]; } s->next_framep[VP56_FRAME_CURRENT] = curframe; ff_thread_finish_setup(avctx); if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] || !s->framep[VP56_FRAME_GOLDEN] || !s->framep[VP56_FRAME_GOLDEN2])) { av_log(avctx, AV_LOG_WARNING, ""Discarding interframe without a prior keyframe!\n""); return AVERROR_INVALIDDATA; } s->linesize = curframe->linesize[0]; s->uvlinesize = curframe->linesize[1]; if (!s->edge_emu_buffer) s->edge_emu_buffer = av_malloc(21*s->linesize); memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz)); memset(s->macroblocks + s->mb_height*2 - 1, 0, (s->mb_width+1)*sizeof(*s->macroblocks)); if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) { s->top_border[0][15] = s->top_border[0][23] = 127; memset(s->top_border[1]-1, 127, s->mb_width*sizeof(*s->top_border)+1); } memset(s->ref_count, 0, sizeof(s->ref_count)); if (s->keyframe) memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width*4); #define MARGIN (16 << 2) s->mv_min.y = -MARGIN; s->mv_max.y = ((s->mb_height - 1) << 6) + MARGIN; for (mb_y = 0; mb_y < s->mb_height; mb_y++) { VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions-1)]; VP8Macroblock *mb = s->macroblocks + (s->mb_height - mb_y - 1)*2; int mb_xy = mb_y*s->mb_width; uint8_t *dst[3] = { curframe->data[0] + 16*mb_y*s->linesize, curframe->data[1] + 8*mb_y*s->uvlinesize, curframe->data[2] + 8*mb_y*s->uvlinesize }; memset(mb - 1, 0, sizeof(*mb)); memset(s->left_nnz, 0, sizeof(s->left_nnz)); AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED*0x01010101); if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) { for (i = 0; i < 3; i++) for (y = 0; y < 16>>!!i; y++) dst[i][y*curframe->linesize[i]-1] = 129; if (mb_y == 1) s->top_border[0][15] = s->top_border[0][23] = s->top_border[0][31] = 129; } s->mv_min.x = -MARGIN; s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN; if (prev_frame && s->segmentation.enabled && !s->segmentation.update_map) ff_thread_await_progress(prev_frame, mb_y, 0); for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) { s->dsp.prefetch(dst[0] + (mb_x&3)*4*s->linesize + 64, s->linesize, 4); s->dsp.prefetch(dst[1] + (mb_x&7)*s->uvlinesize + 64, dst[2] - dst[1], 2); decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy, prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS); if (!mb->skip) decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz); if (mb->mode <= MODE_I4x4) intra_predict(s, dst, mb, mb_x, mb_y); else inter_predict(s, dst, mb, mb_x, mb_y); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN); if (!mb->skip) { idct_mb(s, dst, mb); } else { AV_ZERO64(s->left_nnz); AV_WN64(s->top_nnz[mb_x], 0); if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) { s->left_nnz[8] = 0; s->top_nnz[mb_x][8] = 0; } } if (s->deblock_filter) filter_level_for_mb(s, mb, &s->filter_strength[mb_x]); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2); dst[0] += 16; dst[1] += 8; dst[2] += 8; s->mv_min.x -= 64; s->mv_max.x -= 64; } if (s->deblock_filter) { if (s->filter.simple) filter_mb_row_simple(s, curframe, mb_y); else filter_mb_row(s, curframe, mb_y); } s->mv_min.y -= 64; s->mv_max.y -= 64; ff_thread_report_progress(curframe, mb_y, 0); } ff_thread_report_progress(curframe, INT_MAX, 0); skip_decode: if (!s->update_probabilities) s->prob[0] = s->prob[1]; memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4); if (!s->invisible) { *(AVFrame*)data = *curframe; *data_size = sizeof(AVFrame); } return avpkt->size; }"
13072----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_62cb3e6a1fa1ed3876644aa2671ff0e218de1060_1.json----do_handshake_internal,"static HANDSHAKE_RESULT *do_handshake_internal( SSL_CTX *server_ctx, SSL_CTX *server2_ctx, SSL_CTX *client_ctx, <S2SV_StartVul> const SSL_TEST_CTX *test_ctx, SSL_SESSION *session_in, <S2SV_EndVul> SSL_SESSION **session_out) { SSL *server, *client; BIO *client_to_server, *server_to_client; HANDSHAKE_EX_DATA server_ex_data, client_ex_data; CTX_DATA client_ctx_data, server_ctx_data, server2_ctx_data; HANDSHAKE_RESULT *ret = HANDSHAKE_RESULT_new(); int client_turn = 1, shutdown = 0; peer_status_t client_status = PEER_RETRY, server_status = PEER_RETRY; handshake_status_t status = HANDSHAKE_RETRY; unsigned char* tick = NULL; size_t tick_len = 0; SSL_SESSION* sess = NULL; #ifndef OPENSSL_NO_NEXTPROTONEG const unsigned char *proto = NULL; unsigned int proto_len = 0; #endif memset(&server_ctx_data, 0, sizeof(server_ctx_data)); memset(&server2_ctx_data, 0, sizeof(server2_ctx_data)); memset(&client_ctx_data, 0, sizeof(client_ctx_data)); <S2SV_StartVul> configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, test_ctx, <S2SV_EndVul> &server_ctx_data, &server2_ctx_data, &client_ctx_data); server = SSL_new(server_ctx); client = SSL_new(client_ctx); OPENSSL_assert(server != NULL && client != NULL); <S2SV_StartVul> configure_handshake_ssl(server, client, test_ctx); <S2SV_EndVul> if (session_in != NULL) { OPENSSL_assert(SSL_CTX_add_session(server_ctx, session_in)); OPENSSL_assert(SSL_set_session(client, session_in)); } memset(&server_ex_data, 0, sizeof(server_ex_data)); memset(&client_ex_data, 0, sizeof(client_ex_data)); ret->result = SSL_TEST_INTERNAL_ERROR; client_to_server = BIO_new(BIO_s_mem()); server_to_client = BIO_new(BIO_s_mem()); OPENSSL_assert(client_to_server != NULL && server_to_client != NULL); BIO_set_nbio(client_to_server, 1); BIO_set_nbio(server_to_client, 1); SSL_set_connect_state(client); SSL_set_accept_state(server); SSL_set_bio(client, server_to_client, client_to_server); OPENSSL_assert(BIO_up_ref(server_to_client) > 0); OPENSSL_assert(BIO_up_ref(client_to_server) > 0); SSL_set_bio(server, client_to_server, server_to_client); ex_data_idx = SSL_get_ex_new_index(0, ""ex data"", NULL, NULL, NULL); OPENSSL_assert(ex_data_idx >= 0); OPENSSL_assert(SSL_set_ex_data(server, ex_data_idx, &server_ex_data) == 1); OPENSSL_assert(SSL_set_ex_data(client, ex_data_idx, &client_ex_data) == 1); SSL_set_info_callback(server, &info_cb); SSL_set_info_callback(client, &info_cb); for(;;) { if (client_turn) { client_status = do_handshake_step(client, shutdown); status = handshake_status(client_status, server_status, 1 ); } else { server_status = do_handshake_step(server, shutdown); status = handshake_status(server_status, client_status, 0 ); } switch (status) { case HANDSHAKE_SUCCESS: if (shutdown) { ret->result = SSL_TEST_SUCCESS; goto err; } else { client_status = server_status = PEER_RETRY; shutdown = 1; client_turn = 1; break; } case CLIENT_ERROR: ret->result = SSL_TEST_CLIENT_FAIL; goto err; case SERVER_ERROR: ret->result = SSL_TEST_SERVER_FAIL; goto err; case INTERNAL_ERROR: ret->result = SSL_TEST_INTERNAL_ERROR; goto err; case HANDSHAKE_RETRY: client_turn ^= 1; break; } } err: ret->server_alert_sent = server_ex_data.alert_sent; ret->server_alert_received = client_ex_data.alert_received; ret->client_alert_sent = client_ex_data.alert_sent; ret->client_alert_received = server_ex_data.alert_received; ret->server_protocol = SSL_version(server); ret->client_protocol = SSL_version(client); ret->servername = server_ex_data.servername; if ((sess = SSL_get0_session(client)) != NULL) SSL_SESSION_get0_ticket(sess, &tick, &tick_len); if (tick == NULL || tick_len == 0) ret->session_ticket = SSL_TEST_SESSION_TICKET_NO; else ret->session_ticket = SSL_TEST_SESSION_TICKET_YES; ret->session_ticket_do_not_call = server_ex_data.session_ticket_do_not_call; #ifndef OPENSSL_NO_NEXTPROTONEG SSL_get0_next_proto_negotiated(client, &proto, &proto_len); ret->client_npn_negotiated = dup_str(proto, proto_len); SSL_get0_next_proto_negotiated(server, &proto, &proto_len); ret->server_npn_negotiated = dup_str(proto, proto_len); SSL_get0_alpn_selected(client, &proto, &proto_len); ret->client_alpn_negotiated = dup_str(proto, proto_len); SSL_get0_alpn_selected(server, &proto, &proto_len); ret->server_alpn_negotiated = dup_str(proto, proto_len); #endif ret->client_resumed = SSL_session_reused(client); ret->server_resumed = SSL_session_reused(server); if (session_out != NULL) *session_out = SSL_get1_session(client); ctx_data_free_data(&server_ctx_data); ctx_data_free_data(&server2_ctx_data); ctx_data_free_data(&client_ctx_data); SSL_free(server); SSL_free(client); return ret; }","- const SSL_TEST_CTX *test_ctx, SSL_SESSION *session_in,
- configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, test_ctx,
- configure_handshake_ssl(server, client, test_ctx);
+ const SSL_TEST_EXTRA_CONF *extra, SSL_SESSION *session_in,
+ configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, extra,
+ configure_handshake_ssl(server, client, extra);","static HANDSHAKE_RESULT *do_handshake_internal( SSL_CTX *server_ctx, SSL_CTX *server2_ctx, SSL_CTX *client_ctx, const SSL_TEST_EXTRA_CONF *extra, SSL_SESSION *session_in, SSL_SESSION **session_out) { SSL *server, *client; BIO *client_to_server, *server_to_client; HANDSHAKE_EX_DATA server_ex_data, client_ex_data; CTX_DATA client_ctx_data, server_ctx_data, server2_ctx_data; HANDSHAKE_RESULT *ret = HANDSHAKE_RESULT_new(); int client_turn = 1, shutdown = 0; peer_status_t client_status = PEER_RETRY, server_status = PEER_RETRY; handshake_status_t status = HANDSHAKE_RETRY; unsigned char* tick = NULL; size_t tick_len = 0; SSL_SESSION* sess = NULL; #ifndef OPENSSL_NO_NEXTPROTONEG const unsigned char *proto = NULL; unsigned int proto_len = 0; #endif memset(&server_ctx_data, 0, sizeof(server_ctx_data)); memset(&server2_ctx_data, 0, sizeof(server2_ctx_data)); memset(&client_ctx_data, 0, sizeof(client_ctx_data)); configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, extra, &server_ctx_data, &server2_ctx_data, &client_ctx_data); server = SSL_new(server_ctx); client = SSL_new(client_ctx); OPENSSL_assert(server != NULL && client != NULL); configure_handshake_ssl(server, client, extra); if (session_in != NULL) { OPENSSL_assert(SSL_CTX_add_session(server_ctx, session_in)); OPENSSL_assert(SSL_set_session(client, session_in)); } memset(&server_ex_data, 0, sizeof(server_ex_data)); memset(&client_ex_data, 0, sizeof(client_ex_data)); ret->result = SSL_TEST_INTERNAL_ERROR; client_to_server = BIO_new(BIO_s_mem()); server_to_client = BIO_new(BIO_s_mem()); OPENSSL_assert(client_to_server != NULL && server_to_client != NULL); BIO_set_nbio(client_to_server, 1); BIO_set_nbio(server_to_client, 1); SSL_set_connect_state(client); SSL_set_accept_state(server); SSL_set_bio(client, server_to_client, client_to_server); OPENSSL_assert(BIO_up_ref(server_to_client) > 0); OPENSSL_assert(BIO_up_ref(client_to_server) > 0); SSL_set_bio(server, client_to_server, server_to_client); ex_data_idx = SSL_get_ex_new_index(0, ""ex data"", NULL, NULL, NULL); OPENSSL_assert(ex_data_idx >= 0); OPENSSL_assert(SSL_set_ex_data(server, ex_data_idx, &server_ex_data) == 1); OPENSSL_assert(SSL_set_ex_data(client, ex_data_idx, &client_ex_data) == 1); SSL_set_info_callback(server, &info_cb); SSL_set_info_callback(client, &info_cb); for(;;) { if (client_turn) { client_status = do_handshake_step(client, shutdown); status = handshake_status(client_status, server_status, 1 ); } else { server_status = do_handshake_step(server, shutdown); status = handshake_status(server_status, client_status, 0 ); } switch (status) { case HANDSHAKE_SUCCESS: if (shutdown) { ret->result = SSL_TEST_SUCCESS; goto err; } else { client_status = server_status = PEER_RETRY; shutdown = 1; client_turn = 1; break; } case CLIENT_ERROR: ret->result = SSL_TEST_CLIENT_FAIL; goto err; case SERVER_ERROR: ret->result = SSL_TEST_SERVER_FAIL; goto err; case INTERNAL_ERROR: ret->result = SSL_TEST_INTERNAL_ERROR; goto err; case HANDSHAKE_RETRY: client_turn ^= 1; break; } } err: ret->server_alert_sent = server_ex_data.alert_sent; ret->server_alert_received = client_ex_data.alert_received; ret->client_alert_sent = client_ex_data.alert_sent; ret->client_alert_received = server_ex_data.alert_received; ret->server_protocol = SSL_version(server); ret->client_protocol = SSL_version(client); ret->servername = server_ex_data.servername; if ((sess = SSL_get0_session(client)) != NULL) SSL_SESSION_get0_ticket(sess, &tick, &tick_len); if (tick == NULL || tick_len == 0) ret->session_ticket = SSL_TEST_SESSION_TICKET_NO; else ret->session_ticket = SSL_TEST_SESSION_TICKET_YES; ret->session_ticket_do_not_call = server_ex_data.session_ticket_do_not_call; #ifndef OPENSSL_NO_NEXTPROTONEG SSL_get0_next_proto_negotiated(client, &proto, &proto_len); ret->client_npn_negotiated = dup_str(proto, proto_len); SSL_get0_next_proto_negotiated(server, &proto, &proto_len); ret->server_npn_negotiated = dup_str(proto, proto_len); SSL_get0_alpn_selected(client, &proto, &proto_len); ret->client_alpn_negotiated = dup_str(proto, proto_len); SSL_get0_alpn_selected(server, &proto, &proto_len); ret->server_alpn_negotiated = dup_str(proto, proto_len); #endif ret->client_resumed = SSL_session_reused(client); ret->server_resumed = SSL_session_reused(server); if (session_out != NULL) *session_out = SSL_get1_session(client); ctx_data_free_data(&server_ctx_data); ctx_data_free_data(&server2_ctx_data); ctx_data_free_data(&client_ctx_data); SSL_free(server); SSL_free(client); return ret; }"
7724----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a34bfb395d003e6f9c0b777824d5f14940550a5b_1.json----mov_read_stsd,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom) { <S2SV_StartVul> int entries; <S2SV_EndVul> avio_r8(pb); avio_rb24(pb); <S2SV_StartVul> entries = avio_rb32(pb); <S2SV_EndVul> <S2SV_StartVul> return ff_mov_read_stsd_entries(c, pb, entries); <S2SV_EndVul> }","- int entries;
- entries = avio_rb32(pb);
- return ff_mov_read_stsd_entries(c, pb, entries);
+ AVStream *st;
+ MOVStreamContext *sc;
+ int ret;
+ if (c->fc->nb_streams < 1)
+ return 0;
+ st = c->fc->streams[c->fc->nb_streams - 1];
+ sc = st->priv_data;
+ sc->extradata = av_mallocz_array(sc->stsd_count, sizeof(*sc->extradata));
+ if (!sc->extradata)
+ return AVERROR(ENOMEM);
+ sc->extradata_size = av_mallocz_array(sc->stsd_count, sizeof(sc->extradata_size));
+ if (!sc->extradata_size)
+ return AVERROR(ENOMEM);
+ ret = ff_mov_read_stsd_entries(c, pb, sc->stsd_count);
+ if (ret < 0)
+ return ret;
+ av_free(st->codecpar->extradata);
+ st->codecpar->extradata_size = sc->extradata_size[0];
+ st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);
+ if (!st->codecpar->extradata)
+ return AVERROR(ENOMEM);
+ memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);
+ return 0;","static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; int ret; if (c->fc->nb_streams < 1) return 0; st = c->fc->streams[c->fc->nb_streams - 1]; sc = st->priv_data; avio_r8(pb); avio_rb24(pb); sc->stsd_count = avio_rb32(pb); sc->extradata = av_mallocz_array(sc->stsd_count, sizeof(*sc->extradata)); if (!sc->extradata) return AVERROR(ENOMEM); sc->extradata_size = av_mallocz_array(sc->stsd_count, sizeof(sc->extradata_size)); if (!sc->extradata_size) return AVERROR(ENOMEM); ret = ff_mov_read_stsd_entries(c, pb, sc->stsd_count); if (ret < 0) return ret; av_free(st->codecpar->extradata); st->codecpar->extradata_size = sc->extradata_size[0]; st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE); if (!st->codecpar->extradata) return AVERROR(ENOMEM); memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]); return 0; }"
7299----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8c0fd76fb09b63b0528483c85df534f4c18cf8ca_1.json----rv34_decode_block,"<S2SV_StartVul> static inline void rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc) <S2SV_EndVul> { int code, pattern; code = get_vlc2(gb, rvlc->first_pattern[fc].table, 9, 2); pattern = code & 0x7; code >>= 3; <S2SV_StartVul> decode_subblock(dst, code, 0, gb, &rvlc->coefficient); <S2SV_EndVul> if(pattern & 4){ code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2); <S2SV_StartVul> decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient); <S2SV_EndVul> } if(pattern & 2){ code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2); <S2SV_StartVul> decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient); <S2SV_EndVul> } if(pattern & 1){ code = get_vlc2(gb, rvlc->third_pattern[sc].table, 9, 2); <S2SV_StartVul> decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient); <S2SV_EndVul> } }","- static inline void rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc)
- decode_subblock(dst, code, 0, gb, &rvlc->coefficient);
- decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient);
- decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient);
- decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient);
+ static inline void rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc, int q_dc, int q_ac1, int q_ac2)
+ decode_subblock3(dst, code, 0, gb, &rvlc->coefficient, q_dc, q_ac1, q_ac2);
+ decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient, q_ac2);
+ decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient, q_ac2);
+ decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient, q_ac2);","static inline void rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc, int q_dc, int q_ac1, int q_ac2) { int code, pattern; code = get_vlc2(gb, rvlc->first_pattern[fc].table, 9, 2); pattern = code & 0x7; code >>= 3; decode_subblock3(dst, code, 0, gb, &rvlc->coefficient, q_dc, q_ac1, q_ac2); if(pattern & 4){ code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2); decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient, q_ac2); } if(pattern & 2){ code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2); decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient, q_ac2); } if(pattern & 1){ code = get_vlc2(gb, rvlc->third_pattern[sc].table, 9, 2); decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient, q_ac2); } }"
14239----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_8b2e20c3177254a35200689b718a15a70dd18ff6_1.json----tls1_check_curve,"int tls1_check_curve(SSL *s, const unsigned char *p, size_t len) { const unsigned char *curves; <S2SV_StartVul> size_t curveslen, i; <S2SV_EndVul> unsigned int suiteb_flags = tls1_suiteb(s); if (len != 3 || p[0] != NAMED_CURVE_TYPE) return 0; if (suiteb_flags) { unsigned long cid = s->s3->tmp.new_cipher->id; if (p[1]) return 0; if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256) { if (p[2] != TLSEXT_curve_P_256) return 0; } else if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384) { if (p[2] != TLSEXT_curve_P_384) return 0; } else return 0; } <S2SV_StartVul> tls1_get_curvelist(s, 0, &curves, &curveslen); <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < curveslen; i += 2, curves += 2) <S2SV_EndVul> { if (p[1] == curves[0] && p[2] == curves[1]) return tls_curve_allowed(s, p + 1, SSL_SECOP_CURVE_CHECK); } return 0; }","- size_t curveslen, i;
- tls1_get_curvelist(s, 0, &curves, &curveslen);
- for (i = 0; i < curveslen; i += 2, curves += 2)
+ size_t num_curves, i;
+ if (!tls1_get_curvelist(s, 0, &curves, &num_curves))
+ return 0;
+ for (i = 0; i < num_curves; i++, curves += 2)","int tls1_check_curve(SSL *s, const unsigned char *p, size_t len) { const unsigned char *curves; size_t num_curves, i; unsigned int suiteb_flags = tls1_suiteb(s); if (len != 3 || p[0] != NAMED_CURVE_TYPE) return 0; if (suiteb_flags) { unsigned long cid = s->s3->tmp.new_cipher->id; if (p[1]) return 0; if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256) { if (p[2] != TLSEXT_curve_P_256) return 0; } else if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384) { if (p[2] != TLSEXT_curve_P_384) return 0; } else return 0; } if (!tls1_get_curvelist(s, 0, &curves, &num_curves)) return 0; for (i = 0; i < num_curves; i++, curves += 2) { if (p[1] == curves[0] && p[2] == curves[1]) return tls_curve_allowed(s, p + 1, SSL_SECOP_CURVE_CHECK); } return 0; }"
800----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2be7fa1eed74d33b22a60b9093c9e8f17f9d1ff4_1.json----compute_pkt_fields,"static void compute_pkt_fields(AVFormatContext *s, AVStream *st, AVCodecParserContext *pc, AVPacket *pkt, int64_t next_dts, int64_t next_pts) { int num, den, presentation_delayed, delay, i; int64_t offset; AVRational duration; int onein_oneout = st->codec->codec_id != AV_CODEC_ID_H264 && st->codec->codec_id != AV_CODEC_ID_HEVC; if (s->flags & AVFMT_FLAG_NOFILLIN) return; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pkt->dts != AV_NOPTS_VALUE) { if (pkt->dts == pkt->pts && st->last_dts_for_order_check != AV_NOPTS_VALUE) { if (st->last_dts_for_order_check <= pkt->dts) { st->dts_ordered++; } else { av_log(s, st->dts_misordered ? AV_LOG_DEBUG : AV_LOG_WARNING, ""DTS %""PRIi64"" < %""PRIi64"" out of order\n"", pkt->dts, st->last_dts_for_order_check); st->dts_misordered++; } if (st->dts_ordered + st->dts_misordered > 250) { st->dts_ordered >>= 1; st->dts_misordered >>= 1; } } st->last_dts_for_order_check = pkt->dts; if (st->dts_ordered < 8*st->dts_misordered && pkt->dts == pkt->pts) pkt->dts = AV_NOPTS_VALUE; } if ((s->flags & AVFMT_FLAG_IGNDTS) && pkt->pts != AV_NOPTS_VALUE) pkt->dts = AV_NOPTS_VALUE; if (pc && pc->pict_type == AV_PICTURE_TYPE_B && !st->codec->has_b_frames) st->codec->has_b_frames = 1; delay = st->codec->has_b_frames; presentation_delayed = 0; if (delay && pc && pc->pict_type != AV_PICTURE_TYPE_B) presentation_delayed = 1; if (pkt->pts != AV_NOPTS_VALUE && pkt->dts != AV_NOPTS_VALUE && st->pts_wrap_bits < 63 && pkt->dts - (1LL << (st->pts_wrap_bits - 1)) > pkt->pts) { if (is_relative(st->cur_dts) || pkt->dts - (1LL<<(st->pts_wrap_bits - 1)) > st->cur_dts) { pkt->dts -= 1LL << st->pts_wrap_bits; } else pkt->pts += 1LL << st->pts_wrap_bits; } if (delay == 1 && pkt->dts == pkt->pts && pkt->dts != AV_NOPTS_VALUE && presentation_delayed) { av_log(s, AV_LOG_DEBUG, ""invalid dts/pts combination %""PRIi64""\n"", pkt->dts); if ( strcmp(s->iformat->name, ""mov,mp4,m4a,3gp,3g2,mj2"") && strcmp(s->iformat->name, ""flv"")) pkt->dts = AV_NOPTS_VALUE; } duration = av_mul_q((AVRational) {pkt->duration, 1}, st->time_base); if (pkt->duration == 0) { ff_compute_frame_duration(s, &num, &den, st, pc, pkt); if (den && num) { duration = (AVRational) {num, den}; pkt->duration = av_rescale_rnd(1, num * (int64_t) st->time_base.den, den * (int64_t) st->time_base.num, AV_ROUND_DOWN); } } if (pkt->duration != 0 && (s->packet_buffer || s->parse_queue)) update_initial_durations(s, st, pkt->stream_index, pkt->duration); if (pc && st->need_parsing == AVSTREAM_PARSE_TIMESTAMPS && pkt->size) { offset = av_rescale(pc->offset, pkt->duration, pkt->size); if (pkt->pts != AV_NOPTS_VALUE) pkt->pts += offset; if (pkt->dts != AV_NOPTS_VALUE) pkt->dts += offset; } if (pkt->dts != AV_NOPTS_VALUE && pkt->pts != AV_NOPTS_VALUE && pkt->pts > pkt->dts) presentation_delayed = 1; av_dlog(NULL, ""IN delayed:%d pts:%s, dts:%s cur_dts:%s st:%d pc:%p duration:%d delay:%d onein_oneout:%d\n"", presentation_delayed, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts), pkt->stream_index, pc, pkt->duration, delay, onein_oneout); if ((delay == 0 || (delay == 1 && pc)) && onein_oneout) { if (presentation_delayed) { if (pkt->dts == AV_NOPTS_VALUE) pkt->dts = st->last_IP_pts; update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt); if (pkt->dts == AV_NOPTS_VALUE) pkt->dts = st->cur_dts; if (st->last_IP_duration == 0) st->last_IP_duration = pkt->duration; if (pkt->dts != AV_NOPTS_VALUE) st->cur_dts = pkt->dts + st->last_IP_duration; if (pkt->dts != AV_NOPTS_VALUE && pkt->pts == AV_NOPTS_VALUE && st->last_IP_duration > 0 && <S2SV_StartVul> (st->cur_dts - next_dts) <= 1 && <S2SV_EndVul> next_dts != next_pts && next_pts != AV_NOPTS_VALUE) pkt->pts = next_dts; st->last_IP_duration = pkt->duration; st->last_IP_pts = pkt->pts; } else if (pkt->pts != AV_NOPTS_VALUE || pkt->dts != AV_NOPTS_VALUE || pkt->duration ) { if (pkt->pts == AV_NOPTS_VALUE) pkt->pts = pkt->dts; update_initial_timestamps(s, pkt->stream_index, pkt->pts, pkt->pts, pkt); if (pkt->pts == AV_NOPTS_VALUE) pkt->pts = st->cur_dts; pkt->dts = pkt->pts; if (pkt->pts != AV_NOPTS_VALUE) st->cur_dts = av_add_stable(st->time_base, pkt->pts, duration, 1); } } if (pkt->pts != AV_NOPTS_VALUE && delay <= MAX_REORDER_DELAY && has_decode_delay_been_guessed(st)) { st->pts_buffer[0] = pkt->pts; for (i = 0; i<delay && st->pts_buffer[i] > st->pts_buffer[i + 1]; i++) FFSWAP(int64_t, st->pts_buffer[i], st->pts_buffer[i + 1]); pkt->dts = select_from_pts_buffer(st, st->pts_buffer, pkt->dts); } if (!onein_oneout) update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt); if (pkt->dts > st->cur_dts) st->cur_dts = pkt->dts; av_dlog(NULL, ""OUTdelayed:%d/%d pts:%s, dts:%s cur_dts:%s\n"", presentation_delayed, delay, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts)); if (is_intra_only(st->codec)) pkt->flags |= AV_PKT_FLAG_KEY; if (pc) pkt->convergence_duration = pc->convergence_duration; }","- (st->cur_dts - next_dts) <= 1 &&
+ ((uint64_t)st->cur_dts - (uint64_t)next_dts + 1) <= 2 &&","static void compute_pkt_fields(AVFormatContext *s, AVStream *st, AVCodecParserContext *pc, AVPacket *pkt, int64_t next_dts, int64_t next_pts) { int num, den, presentation_delayed, delay, i; int64_t offset; AVRational duration; int onein_oneout = st->codec->codec_id != AV_CODEC_ID_H264 && st->codec->codec_id != AV_CODEC_ID_HEVC; if (s->flags & AVFMT_FLAG_NOFILLIN) return; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pkt->dts != AV_NOPTS_VALUE) { if (pkt->dts == pkt->pts && st->last_dts_for_order_check != AV_NOPTS_VALUE) { if (st->last_dts_for_order_check <= pkt->dts) { st->dts_ordered++; } else { av_log(s, st->dts_misordered ? AV_LOG_DEBUG : AV_LOG_WARNING, ""DTS %""PRIi64"" < %""PRIi64"" out of order\n"", pkt->dts, st->last_dts_for_order_check); st->dts_misordered++; } if (st->dts_ordered + st->dts_misordered > 250) { st->dts_ordered >>= 1; st->dts_misordered >>= 1; } } st->last_dts_for_order_check = pkt->dts; if (st->dts_ordered < 8*st->dts_misordered && pkt->dts == pkt->pts) pkt->dts = AV_NOPTS_VALUE; } if ((s->flags & AVFMT_FLAG_IGNDTS) && pkt->pts != AV_NOPTS_VALUE) pkt->dts = AV_NOPTS_VALUE; if (pc && pc->pict_type == AV_PICTURE_TYPE_B && !st->codec->has_b_frames) st->codec->has_b_frames = 1; delay = st->codec->has_b_frames; presentation_delayed = 0; if (delay && pc && pc->pict_type != AV_PICTURE_TYPE_B) presentation_delayed = 1; if (pkt->pts != AV_NOPTS_VALUE && pkt->dts != AV_NOPTS_VALUE && st->pts_wrap_bits < 63 && pkt->dts - (1LL << (st->pts_wrap_bits - 1)) > pkt->pts) { if (is_relative(st->cur_dts) || pkt->dts - (1LL<<(st->pts_wrap_bits - 1)) > st->cur_dts) { pkt->dts -= 1LL << st->pts_wrap_bits; } else pkt->pts += 1LL << st->pts_wrap_bits; } if (delay == 1 && pkt->dts == pkt->pts && pkt->dts != AV_NOPTS_VALUE && presentation_delayed) { av_log(s, AV_LOG_DEBUG, ""invalid dts/pts combination %""PRIi64""\n"", pkt->dts); if ( strcmp(s->iformat->name, ""mov,mp4,m4a,3gp,3g2,mj2"") && strcmp(s->iformat->name, ""flv"")) pkt->dts = AV_NOPTS_VALUE; } duration = av_mul_q((AVRational) {pkt->duration, 1}, st->time_base); if (pkt->duration == 0) { ff_compute_frame_duration(s, &num, &den, st, pc, pkt); if (den && num) { duration = (AVRational) {num, den}; pkt->duration = av_rescale_rnd(1, num * (int64_t) st->time_base.den, den * (int64_t) st->time_base.num, AV_ROUND_DOWN); } } if (pkt->duration != 0 && (s->packet_buffer || s->parse_queue)) update_initial_durations(s, st, pkt->stream_index, pkt->duration); if (pc && st->need_parsing == AVSTREAM_PARSE_TIMESTAMPS && pkt->size) { offset = av_rescale(pc->offset, pkt->duration, pkt->size); if (pkt->pts != AV_NOPTS_VALUE) pkt->pts += offset; if (pkt->dts != AV_NOPTS_VALUE) pkt->dts += offset; } if (pkt->dts != AV_NOPTS_VALUE && pkt->pts != AV_NOPTS_VALUE && pkt->pts > pkt->dts) presentation_delayed = 1; av_dlog(NULL, ""IN delayed:%d pts:%s, dts:%s cur_dts:%s st:%d pc:%p duration:%d delay:%d onein_oneout:%d\n"", presentation_delayed, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts), pkt->stream_index, pc, pkt->duration, delay, onein_oneout); if ((delay == 0 || (delay == 1 && pc)) && onein_oneout) { if (presentation_delayed) { if (pkt->dts == AV_NOPTS_VALUE) pkt->dts = st->last_IP_pts; update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt); if (pkt->dts == AV_NOPTS_VALUE) pkt->dts = st->cur_dts; if (st->last_IP_duration == 0) st->last_IP_duration = pkt->duration; if (pkt->dts != AV_NOPTS_VALUE) st->cur_dts = pkt->dts + st->last_IP_duration; if (pkt->dts != AV_NOPTS_VALUE && pkt->pts == AV_NOPTS_VALUE && st->last_IP_duration > 0 && ((uint64_t)st->cur_dts - (uint64_t)next_dts + 1) <= 2 && next_dts != next_pts && next_pts != AV_NOPTS_VALUE) pkt->pts = next_dts; st->last_IP_duration = pkt->duration; st->last_IP_pts = pkt->pts; } else if (pkt->pts != AV_NOPTS_VALUE || pkt->dts != AV_NOPTS_VALUE || pkt->duration ) { if (pkt->pts == AV_NOPTS_VALUE) pkt->pts = pkt->dts; update_initial_timestamps(s, pkt->stream_index, pkt->pts, pkt->pts, pkt); if (pkt->pts == AV_NOPTS_VALUE) pkt->pts = st->cur_dts; pkt->dts = pkt->pts; if (pkt->pts != AV_NOPTS_VALUE) st->cur_dts = av_add_stable(st->time_base, pkt->pts, duration, 1); } } if (pkt->pts != AV_NOPTS_VALUE && delay <= MAX_REORDER_DELAY && has_decode_delay_been_guessed(st)) { st->pts_buffer[0] = pkt->pts; for (i = 0; i<delay && st->pts_buffer[i] > st->pts_buffer[i + 1]; i++) FFSWAP(int64_t, st->pts_buffer[i], st->pts_buffer[i + 1]); pkt->dts = select_from_pts_buffer(st, st->pts_buffer, pkt->dts); } if (!onein_oneout) update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt); if (pkt->dts > st->cur_dts) st->cur_dts = pkt->dts; av_dlog(NULL, ""OUTdelayed:%d/%d pts:%s, dts:%s cur_dts:%s\n"", presentation_delayed, delay, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts)); if (is_intra_only(st->codec)) pkt->flags |= AV_PKT_FLAG_KEY; if (pc) pkt->convergence_duration = pc->convergence_duration; }"
15912----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c619469b6024836dcdf3f3f4783ad5ef5c29b815_1.json----verify_main,"int MAIN(int argc, char **argv) { int i,ret=1; char *CApath=NULL,*CAfile=NULL; X509_STORE *cert_ctx=NULL; X509_LOOKUP *lookup=NULL; cert_ctx=X509_STORE_new(); if (cert_ctx == NULL) goto end; X509_STORE_set_verify_cb_func(cert_ctx,cb); ERR_load_crypto_strings(); apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); argc--; argv++; for (;;) { if (argc >= 1) { if (strcmp(*argv,""-CApath"") == 0) { if (argc-- < 1) goto end; CApath= *(++argv); } else if (strcmp(*argv,""-CAfile"") == 0) { if (argc-- < 1) goto end; CAfile= *(++argv); } else if (strcmp(*argv,""-help"") == 0) goto end; else if (strcmp(*argv,""-verbose"") == 0) v_verbose=1; else if (argv[0][0] == '-') goto end; else break; argc--; argv++; } else break; } lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file()); if (lookup == NULL) abort(); <S2SV_StartVul> if (!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM)) <S2SV_EndVul> <S2SV_StartVul> X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT); <S2SV_EndVul> lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir()); if (lookup == NULL) abort(); <S2SV_StartVul> if (!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM)) <S2SV_EndVul> <S2SV_StartVul> X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT); <S2SV_EndVul> ERR_clear_error(); if (argc < 1) check(cert_ctx,NULL); else for (i=0; i<argc; i++) check(cert_ctx,argv[i]); ret=0; end: if (ret == 1) BIO_printf(bio_err,""usage: verify [-verbose] [-CApath path] [-CAfile file] cert1 cert2 ...\n""); if (cert_ctx != NULL) X509_STORE_free(cert_ctx); EXIT(ret); }","- if (!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM))
- X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);
- if (!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM))
- X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);
+ if (CAfile) {
+ i=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM);
+ if(!i) {
+ BIO_printf(bio_err, ""Error loading file %s\n"", CAfile);
+ ERR_print_errors(bio_err);
+ goto end;
+ }
+ } else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);
+ if (CApath) {
+ i=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM);
+ if(!i) {
+ BIO_printf(bio_err, ""Error loading directory %s\n"", CApath);
+ ERR_print_errors(bio_err);
+ goto end;
+ }
+ } else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);","int MAIN(int argc, char **argv) { int i,ret=1; char *CApath=NULL,*CAfile=NULL; X509_STORE *cert_ctx=NULL; X509_LOOKUP *lookup=NULL; cert_ctx=X509_STORE_new(); if (cert_ctx == NULL) goto end; X509_STORE_set_verify_cb_func(cert_ctx,cb); ERR_load_crypto_strings(); apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); argc--; argv++; for (;;) { if (argc >= 1) { if (strcmp(*argv,""-CApath"") == 0) { if (argc-- < 1) goto end; CApath= *(++argv); } else if (strcmp(*argv,""-CAfile"") == 0) { if (argc-- < 1) goto end; CAfile= *(++argv); } else if (strcmp(*argv,""-help"") == 0) goto end; else if (strcmp(*argv,""-verbose"") == 0) v_verbose=1; else if (argv[0][0] == '-') goto end; else break; argc--; argv++; } else break; } lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file()); if (lookup == NULL) abort(); if (CAfile) { i=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM); if(!i) { BIO_printf(bio_err, ""Error loading file %s\n"", CAfile); ERR_print_errors(bio_err); goto end; } } else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT); lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir()); if (lookup == NULL) abort(); if (CApath) { i=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM); if(!i) { BIO_printf(bio_err, ""Error loading directory %s\n"", CApath); ERR_print_errors(bio_err); goto end; } } else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT); ERR_clear_error(); if (argc < 1) check(cert_ctx,NULL); else for (i=0; i<argc; i++) check(cert_ctx,argv[i]); ret=0; end: if (ret == 1) BIO_printf(bio_err,""usage: verify [-verbose] [-CApath path] [-CAfile file] cert1 cert2 ...\n""); if (cert_ctx != NULL) X509_STORE_free(cert_ctx); EXIT(ret); }"
3120----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a9d2072a8144aadee65f9e5ca567309b36cf037e_1.json----find_and_decode_index,"static int find_and_decode_index(NUTContext *nut){ AVFormatContext *s= nut->avf; ByteIOContext *bc = s->pb; uint64_t tmp, end; int i, j, syncpoint_count; int64_t filesize= url_fsize(bc); int64_t *syncpoints; int8_t *has_keyframe; url_fseek(bc, filesize-12, SEEK_SET); url_fseek(bc, filesize-get_be64(bc), SEEK_SET); if(get_be64(bc) != INDEX_STARTCODE){ av_log(s, AV_LOG_ERROR, ""no index at the end\n""); return -1; } end= get_packetheader(nut, bc, 1, INDEX_STARTCODE); end += url_ftell(bc); ff_get_v(bc); GET_V(syncpoint_count, tmp < INT_MAX/8 && tmp > 0) syncpoints= av_malloc(sizeof(int64_t)*syncpoint_count); has_keyframe= av_malloc(sizeof(int8_t)*(syncpoint_count+1)); for(i=0; i<syncpoint_count; i++){ GET_V(syncpoints[i], tmp>0) if(i) syncpoints[i] += syncpoints[i-1]; } for(i=0; i<s->nb_streams; i++){ int64_t last_pts= -1; for(j=0; j<syncpoint_count;){ uint64_t x= ff_get_v(bc); int type= x&1; int n= j; x>>=1; if(type){ int flag= x&1; x>>=1; if(n+x >= syncpoint_count + 1){ av_log(s, AV_LOG_ERROR, ""index overflow A\n""); return -1; } while(x--) has_keyframe[n++]= flag; has_keyframe[n++]= !flag; }else{ while(x != 1){ if(n>=syncpoint_count + 1){ av_log(s, AV_LOG_ERROR, ""index overflow B\n""); return -1; } has_keyframe[n++]= x&1; x>>=1; } } if(has_keyframe[0]){ av_log(s, AV_LOG_ERROR, ""keyframe before first syncpoint in index\n""); return -1; } assert(n<=syncpoint_count+1); <S2SV_StartVul> for(; j<n; j++){ <S2SV_EndVul> if(has_keyframe[j]){ uint64_t B, A= ff_get_v(bc); if(!A){ A= ff_get_v(bc); B= ff_get_v(bc); }else B= 0; av_add_index_entry( s->streams[i], 16*syncpoints[j-1], last_pts + A, 0, 0, AVINDEX_KEYFRAME); last_pts += A + B; } } } } if(skip_reserved(bc, end) || get_checksum(bc)){ av_log(s, AV_LOG_ERROR, ""index checksum mismatch\n""); return -1; } return 0; }","- for(; j<n; j++){
+ for(; j<n && j<syncpoint_count; j++){","static int find_and_decode_index(NUTContext *nut){ AVFormatContext *s= nut->avf; ByteIOContext *bc = s->pb; uint64_t tmp, end; int i, j, syncpoint_count; int64_t filesize= url_fsize(bc); int64_t *syncpoints; int8_t *has_keyframe; url_fseek(bc, filesize-12, SEEK_SET); url_fseek(bc, filesize-get_be64(bc), SEEK_SET); if(get_be64(bc) != INDEX_STARTCODE){ av_log(s, AV_LOG_ERROR, ""no index at the end\n""); return -1; } end= get_packetheader(nut, bc, 1, INDEX_STARTCODE); end += url_ftell(bc); ff_get_v(bc); GET_V(syncpoint_count, tmp < INT_MAX/8 && tmp > 0) syncpoints= av_malloc(sizeof(int64_t)*syncpoint_count); has_keyframe= av_malloc(sizeof(int8_t)*(syncpoint_count+1)); for(i=0; i<syncpoint_count; i++){ GET_V(syncpoints[i], tmp>0) if(i) syncpoints[i] += syncpoints[i-1]; } for(i=0; i<s->nb_streams; i++){ int64_t last_pts= -1; for(j=0; j<syncpoint_count;){ uint64_t x= ff_get_v(bc); int type= x&1; int n= j; x>>=1; if(type){ int flag= x&1; x>>=1; if(n+x >= syncpoint_count + 1){ av_log(s, AV_LOG_ERROR, ""index overflow A\n""); return -1; } while(x--) has_keyframe[n++]= flag; has_keyframe[n++]= !flag; }else{ while(x != 1){ if(n>=syncpoint_count + 1){ av_log(s, AV_LOG_ERROR, ""index overflow B\n""); return -1; } has_keyframe[n++]= x&1; x>>=1; } } if(has_keyframe[0]){ av_log(s, AV_LOG_ERROR, ""keyframe before first syncpoint in index\n""); return -1; } assert(n<=syncpoint_count+1); for(; j<n && j<syncpoint_count; j++){ if(has_keyframe[j]){ uint64_t B, A= ff_get_v(bc); if(!A){ A= ff_get_v(bc); B= ff_get_v(bc); }else B= 0; av_add_index_entry( s->streams[i], 16*syncpoints[j-1], last_pts + A, 0, 0, AVINDEX_KEYFRAME); last_pts += A + B; } } } } if(skip_reserved(bc, end) || get_checksum(bc)){ av_log(s, AV_LOG_ERROR, ""index checksum mismatch\n""); return -1; } return 0; }"
59----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03ae18bd120f731321855813a9b52acc20058859_1.json----decode_nal_units,"static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size) { AVCodecContext *const avctx = h->avctx; unsigned context_count = 0; int nals_needed = 0; int i, ret = 0; h->max_contexts = h->slice_context_count; if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) { h->current_slice = 0; if (!h->first_field) h->cur_pic_ptr = NULL; ff_h264_sei_uninit(&h->sei); } ret = ff_h2645_packet_split(&h->pkt, buf, buf_size, avctx, h->is_avc, h->nal_length_size, avctx->codec_id); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, ""Error splitting the input into NAL units.\n""); return ret; } if (avctx->active_thread_type & FF_THREAD_FRAME) nals_needed = get_last_needed_nal(h); for (i = 0; i < h->pkt.nb_nals; i++) { H2645NAL *nal = &h->pkt.nals[i]; H264SliceContext *sl = &h->slice_ctx[context_count]; int err; if (avctx->skip_frame >= AVDISCARD_NONREF && nal->ref_idc == 0 && nal->type != NAL_SEI) continue; <S2SV_StartVul> again: <S2SV_EndVul> h->nal_ref_idc = nal->ref_idc; h->nal_unit_type = nal->type; err = 0; switch (nal->type) { case NAL_IDR_SLICE: if (nal->type != NAL_IDR_SLICE) { av_log(h->avctx, AV_LOG_ERROR, ""Invalid mix of idr and non-idr slices\n""); ret = -1; goto end; } idr(h); case NAL_SLICE: sl->gb = nal->gb; if ((err = ff_h264_decode_slice_header(h, sl))) break; if (h->sei.recovery_point.recovery_frame_cnt >= 0 && h->recovery_frame < 0) { h->recovery_frame = (h->poc.frame_num + h->sei.recovery_point.recovery_frame_cnt) & ((1 << h->ps.sps->log2_max_frame_num) - 1); } h->cur_pic_ptr->f->key_frame |= (nal->type == NAL_IDR_SLICE) || (h->sei.recovery_point.recovery_frame_cnt >= 0); if (nal->type == NAL_IDR_SLICE || h->recovery_frame == h->poc.frame_num) { h->recovery_frame = -1; h->cur_pic_ptr->recovered = 1; } if (nal->type == NAL_IDR_SLICE) h->frame_recovered |= FRAME_RECOVERED_IDR; h->cur_pic_ptr->recovered |= !!(h->frame_recovered & FRAME_RECOVERED_IDR); if (h->current_slice == 1) { if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) decode_postinit(h, i >= nals_needed); if (h->avctx->hwaccel && (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0) return ret; } if (sl->redundant_pic_count == 0 && (avctx->skip_frame < AVDISCARD_NONREF || nal->ref_idc) && (avctx->skip_frame < AVDISCARD_BIDIR || sl->slice_type_nos != AV_PICTURE_TYPE_B) && (avctx->skip_frame < AVDISCARD_NONKEY || h->cur_pic_ptr->f->key_frame) && avctx->skip_frame < AVDISCARD_ALL) { if (avctx->hwaccel) { ret = avctx->hwaccel->decode_slice(avctx, nal->raw_data, nal->raw_size); if (ret < 0) return ret; } else context_count++; } break; case NAL_DPA: case NAL_DPB: case NAL_DPC: avpriv_request_sample(avctx, ""data partitioning""); ret = AVERROR(ENOSYS); goto end; break; case NAL_SEI: ret = ff_h264_sei_decode(&h->sei, &nal->gb, &h->ps, avctx); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; break; case NAL_SPS: ret = ff_h264_decode_seq_parameter_set(&nal->gb, avctx, &h->ps); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; break; case NAL_PPS: ret = ff_h264_decode_picture_parameter_set(&nal->gb, avctx, &h->ps, nal->size_bits); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; break; case NAL_AUD: case NAL_END_SEQUENCE: case NAL_END_STREAM: case NAL_FILLER_DATA: case NAL_SPS_EXT: case NAL_AUXILIARY_SLICE: break; case NAL_FF_IGNORE: break; default: av_log(avctx, AV_LOG_DEBUG, ""Unknown NAL code: %d (%d bits)\n"", nal->type, nal->size_bits); } if (context_count == h->max_contexts) { ret = ff_h264_execute_decode_slices(h, context_count); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; context_count = 0; } if (err < 0) { av_log(h->avctx, AV_LOG_ERROR, ""decode_slice_header error\n""); sl->ref_count[0] = sl->ref_count[1] = sl->list_count = 0; <S2SV_StartVul> } else if (err == 1) { <S2SV_EndVul> <S2SV_StartVul> sl = &h->slice_ctx[0]; <S2SV_EndVul> <S2SV_StartVul> goto again; <S2SV_EndVul> } } if (context_count) { ret = ff_h264_execute_decode_slices(h, context_count); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; } ret = 0; end: if (h->cur_pic_ptr && !h->droppable) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, h->picture_structure == PICT_BOTTOM_FIELD); } return (ret < 0) ? ret : buf_size; }","- again:
- } else if (err == 1) {
- sl = &h->slice_ctx[0];
- goto again;","static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size) { AVCodecContext *const avctx = h->avctx; unsigned context_count = 0; int nals_needed = 0; int i, ret = 0; h->max_contexts = h->slice_context_count; if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) { h->current_slice = 0; if (!h->first_field) h->cur_pic_ptr = NULL; ff_h264_sei_uninit(&h->sei); } ret = ff_h2645_packet_split(&h->pkt, buf, buf_size, avctx, h->is_avc, h->nal_length_size, avctx->codec_id); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, ""Error splitting the input into NAL units.\n""); return ret; } if (avctx->active_thread_type & FF_THREAD_FRAME) nals_needed = get_last_needed_nal(h); for (i = 0; i < h->pkt.nb_nals; i++) { H2645NAL *nal = &h->pkt.nals[i]; H264SliceContext *sl = &h->slice_ctx[context_count]; int err; if (avctx->skip_frame >= AVDISCARD_NONREF && nal->ref_idc == 0 && nal->type != NAL_SEI) continue; h->nal_ref_idc = nal->ref_idc; h->nal_unit_type = nal->type; err = 0; switch (nal->type) { case NAL_IDR_SLICE: if (nal->type != NAL_IDR_SLICE) { av_log(h->avctx, AV_LOG_ERROR, ""Invalid mix of idr and non-idr slices\n""); ret = -1; goto end; } idr(h); case NAL_SLICE: sl->gb = nal->gb; if ((err = ff_h264_decode_slice_header(h, sl))) break; if (h->sei.recovery_point.recovery_frame_cnt >= 0 && h->recovery_frame < 0) { h->recovery_frame = (h->poc.frame_num + h->sei.recovery_point.recovery_frame_cnt) & ((1 << h->ps.sps->log2_max_frame_num) - 1); } h->cur_pic_ptr->f->key_frame |= (nal->type == NAL_IDR_SLICE) || (h->sei.recovery_point.recovery_frame_cnt >= 0); if (nal->type == NAL_IDR_SLICE || h->recovery_frame == h->poc.frame_num) { h->recovery_frame = -1; h->cur_pic_ptr->recovered = 1; } if (nal->type == NAL_IDR_SLICE) h->frame_recovered |= FRAME_RECOVERED_IDR; h->cur_pic_ptr->recovered |= !!(h->frame_recovered & FRAME_RECOVERED_IDR); if (h->current_slice == 1) { if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) decode_postinit(h, i >= nals_needed); if (h->avctx->hwaccel && (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0) return ret; } if (sl->redundant_pic_count == 0 && (avctx->skip_frame < AVDISCARD_NONREF || nal->ref_idc) && (avctx->skip_frame < AVDISCARD_BIDIR || sl->slice_type_nos != AV_PICTURE_TYPE_B) && (avctx->skip_frame < AVDISCARD_NONKEY || h->cur_pic_ptr->f->key_frame) && avctx->skip_frame < AVDISCARD_ALL) { if (avctx->hwaccel) { ret = avctx->hwaccel->decode_slice(avctx, nal->raw_data, nal->raw_size); if (ret < 0) return ret; } else context_count++; } break; case NAL_DPA: case NAL_DPB: case NAL_DPC: avpriv_request_sample(avctx, ""data partitioning""); ret = AVERROR(ENOSYS); goto end; break; case NAL_SEI: ret = ff_h264_sei_decode(&h->sei, &nal->gb, &h->ps, avctx); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; break; case NAL_SPS: ret = ff_h264_decode_seq_parameter_set(&nal->gb, avctx, &h->ps); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; break; case NAL_PPS: ret = ff_h264_decode_picture_parameter_set(&nal->gb, avctx, &h->ps, nal->size_bits); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; break; case NAL_AUD: case NAL_END_SEQUENCE: case NAL_END_STREAM: case NAL_FILLER_DATA: case NAL_SPS_EXT: case NAL_AUXILIARY_SLICE: break; case NAL_FF_IGNORE: break; default: av_log(avctx, AV_LOG_DEBUG, ""Unknown NAL code: %d (%d bits)\n"", nal->type, nal->size_bits); } if (context_count == h->max_contexts) { ret = ff_h264_execute_decode_slices(h, context_count); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; context_count = 0; } if (err < 0) { av_log(h->avctx, AV_LOG_ERROR, ""decode_slice_header error\n""); sl->ref_count[0] = sl->ref_count[1] = sl->list_count = 0; } } if (context_count) { ret = ff_h264_execute_decode_slices(h, context_count); if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE)) goto end; } ret = 0; end: if (h->cur_pic_ptr && !h->droppable) { ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, h->picture_structure == PICT_BOTTOM_FIELD); } return (ret < 0) ? ret : buf_size; }"
13314----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6b5d27987e5c93dfb1a52691dc1dd3df77a3d49f_1.json----TXT_DB_read,"TXT_DB *TXT_DB_read(BIO *in, int num) { TXT_DB *ret=NULL; int er=1; int esc=0; long ln=0; int i,add,n; int size=BUFSIZE; int offset=0; char *p,**pp,*f; BUF_MEM *buf=NULL; if ((buf=BUF_MEM_new()) == NULL) goto err; if (!BUF_MEM_grow(buf,size)) goto err; if ((ret=(TXT_DB *)OPENSSL_malloc(sizeof(TXT_DB))) == NULL) goto err; ret->num_fields=num; ret->index=NULL; ret->qual=NULL; if ((ret->data=sk_new_null()) == NULL) goto err; if ((ret->index=(LHASH **)OPENSSL_malloc(sizeof(LHASH *)*num)) == NULL) goto err; if ((ret->qual=(int (**)(char **))OPENSSL_malloc(sizeof(int (**)(char **))*num)) == NULL) goto err; for (i=0; i<num; i++) { ret->index[i]=NULL; ret->qual[i]=NULL; } add=(num+1)*sizeof(char *); buf->data[size-1]='\0'; offset=0; for (;;) { if (offset != 0) { size+=BUFSIZE; if (!BUF_MEM_grow_clean(buf,size)) goto err; } buf->data[offset]='\0'; BIO_gets(in,&(buf->data[offset]),size-offset); ln++; if (buf->data[offset] == '\0') break; if ((offset == 0) && (buf->data[0] == '#')) continue; i=strlen(&(buf->data[offset])); offset+=i; if (buf->data[offset-1] != '\n') continue; else { buf->data[offset-1]='\0'; if (!(p=(char *)OPENSSL_malloc(add+offset))) goto err; offset=0; } pp=(char **)p; p+=add; n=0; pp[n++]=p; i=0; f=buf->data; esc=0; for (;;) { if (*f == '\0') break; if (*f == '\t') { if (esc) p--; else { *(p++)='\0'; f++; if (n >= num) break; pp[n++]=p; continue; } } esc=(*f == '\\'); *(p++)= *(f++); } *(p++)='\0'; if ((n != num) || (*f != '\0')) { #if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16) fprintf(stderr,""wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\n"",ln,num,n,f); #endif er=2; goto err; } pp[n]=p; if (!sk_push(ret->data,(char *)pp)) { #if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16) fprintf(stderr,""failure in sk_push\n""); #endif er=2; goto err; } } er=0; err: BUF_MEM_free(buf); if (er) { #if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16) if (er == 1) fprintf(stderr,""OPENSSL_malloc failure\n""); #endif <S2SV_StartVul> if (ret->data != NULL) sk_free(ret->data); <S2SV_EndVul> <S2SV_StartVul> if (ret->index != NULL) OPENSSL_free(ret->index); <S2SV_EndVul> <S2SV_StartVul> if (ret->qual != NULL) OPENSSL_free(ret->qual); <S2SV_EndVul> <S2SV_StartVul> if (ret != NULL) OPENSSL_free(ret); <S2SV_EndVul> return(NULL); } else return(ret); }","- if (ret->data != NULL) sk_free(ret->data);
- if (ret->index != NULL) OPENSSL_free(ret->index);
- if (ret->qual != NULL) OPENSSL_free(ret->qual);
- if (ret != NULL) OPENSSL_free(ret);
+ if (ret != NULL)
+ {
+ if (ret->data != NULL) sk_free(ret->data);
+ if (ret->index != NULL) OPENSSL_free(ret->index);
+ if (ret->qual != NULL) OPENSSL_free(ret->qual);
+ if (ret != NULL) OPENSSL_free(ret);
+ }","TXT_DB *TXT_DB_read(BIO *in, int num) { TXT_DB *ret=NULL; int er=1; int esc=0; long ln=0; int i,add,n; int size=BUFSIZE; int offset=0; char *p,**pp,*f; BUF_MEM *buf=NULL; if ((buf=BUF_MEM_new()) == NULL) goto err; if (!BUF_MEM_grow(buf,size)) goto err; if ((ret=(TXT_DB *)OPENSSL_malloc(sizeof(TXT_DB))) == NULL) goto err; ret->num_fields=num; ret->index=NULL; ret->qual=NULL; if ((ret->data=sk_new_null()) == NULL) goto err; if ((ret->index=(LHASH **)OPENSSL_malloc(sizeof(LHASH *)*num)) == NULL) goto err; if ((ret->qual=(int (**)(char **))OPENSSL_malloc(sizeof(int (**)(char **))*num)) == NULL) goto err; for (i=0; i<num; i++) { ret->index[i]=NULL; ret->qual[i]=NULL; } add=(num+1)*sizeof(char *); buf->data[size-1]='\0'; offset=0; for (;;) { if (offset != 0) { size+=BUFSIZE; if (!BUF_MEM_grow_clean(buf,size)) goto err; } buf->data[offset]='\0'; BIO_gets(in,&(buf->data[offset]),size-offset); ln++; if (buf->data[offset] == '\0') break; if ((offset == 0) && (buf->data[0] == '#')) continue; i=strlen(&(buf->data[offset])); offset+=i; if (buf->data[offset-1] != '\n') continue; else { buf->data[offset-1]='\0'; if (!(p=(char *)OPENSSL_malloc(add+offset))) goto err; offset=0; } pp=(char **)p; p+=add; n=0; pp[n++]=p; i=0; f=buf->data; esc=0; for (;;) { if (*f == '\0') break; if (*f == '\t') { if (esc) p--; else { *(p++)='\0'; f++; if (n >= num) break; pp[n++]=p; continue; } } esc=(*f == '\\'); *(p++)= *(f++); } *(p++)='\0'; if ((n != num) || (*f != '\0')) { #if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16) fprintf(stderr,""wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\n"",ln,num,n,f); #endif er=2; goto err; } pp[n]=p; if (!sk_push(ret->data,(char *)pp)) { #if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16) fprintf(stderr,""failure in sk_push\n""); #endif er=2; goto err; } } er=0; err: BUF_MEM_free(buf); if (er) { #if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16) if (er == 1) fprintf(stderr,""OPENSSL_malloc failure\n""); #endif if (ret != NULL) { if (ret->data != NULL) sk_free(ret->data); if (ret->index != NULL) OPENSSL_free(ret->index); if (ret->qual != NULL) OPENSSL_free(ret->qual); if (ret != NULL) OPENSSL_free(ret); } return(NULL); } else return(ret); }"
9180----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fc712d8d23389edfebbaabdd108d173157eb1489_1.json----jpeg2000_decode_packets,"static int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile) { <S2SV_StartVul> int layno, reslevelno, compno, precno, ok_reslevel, ret; <S2SV_EndVul> <S2SV_StartVul> uint8_t prog_order = tile->codsty[0].prog_order; <S2SV_EndVul> <S2SV_StartVul> uint16_t x; <S2SV_EndVul> <S2SV_StartVul> uint16_t y; <S2SV_EndVul> s->bit_index = 8; <S2SV_StartVul> switch (prog_order) { <S2SV_EndVul> case JPEG2000_PGOD_LRCP: for (layno = 0; layno < tile->codsty[0].nlayers; layno++) { ok_reslevel = 1; for (reslevelno = 0; ok_reslevel; reslevelno++) { ok_reslevel = 0; for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000CodingStyle *codsty = tile->codsty + compno; Jpeg2000QuantStyle *qntsty = tile->qntsty + compno; if (reslevelno < codsty->nreslevels) { Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno; ok_reslevel = 1; for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++) if ((ret = jpeg2000_decode_packet(s, codsty, rlevel, precno, layno, qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0), qntsty->nguardbits)) < 0) return ret; } } } } break; case JPEG2000_PGOD_CPRL: for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000CodingStyle *codsty = tile->codsty + compno; Jpeg2000QuantStyle *qntsty = tile->qntsty + compno; s->g = tile->tile_part[compno].tpg; for (y = 0; y < s->height; y += 256) { for (x = 0; x < s->width; x += 256) { for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) { uint16_t prcx, prcy; uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno; if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) || (y == 0))) continue; if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) || (x == 0))) continue; prcx = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width; prcy = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height; precno = prcx + rlevel->num_precincts_x * prcy; for (layno = 0; layno < tile->codsty[0].nlayers; layno++) { if ((ret = jpeg2000_decode_packet(s, codsty, rlevel, precno, layno, qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0), qntsty->nguardbits)) < 0) return ret; } } } } } break; default: break; } bytestream2_skip(&s->g, 2); <S2SV_StartVul> return 0; <S2SV_EndVul> }","- int layno, reslevelno, compno, precno, ok_reslevel, ret;
- uint8_t prog_order = tile->codsty[0].prog_order;
- uint16_t x;
- uint16_t y;
- switch (prog_order) {
- return 0;
+ int ret = 0;
+ int layno, reslevelno, compno, precno, ok_reslevel;
+ int x, y;
+ switch (tile->codsty[0].prog_order) {
+ case JPEG2000_PGOD_RLCP:
+ avpriv_request_sample(s->avctx, ""Progression order RLCP"");
+ ret = AVERROR_PATCHWELCOME;
+ break;
+ case JPEG2000_PGOD_RPCL:
+ avpriv_request_sample(s->avctx, ""Progression order RPCL"");
+ ret = AVERROR_PATCHWELCOME;
+ break;
+ case JPEG2000_PGOD_PCRL:
+ avpriv_request_sample(s->avctx, ""Progression order PCRL"");
+ ret = AVERROR_PATCHWELCOME;
+ break;
+ return ret;","static int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile) { int ret = 0; int layno, reslevelno, compno, precno, ok_reslevel; int x, y; s->bit_index = 8; switch (tile->codsty[0].prog_order) { case JPEG2000_PGOD_LRCP: for (layno = 0; layno < tile->codsty[0].nlayers; layno++) { ok_reslevel = 1; for (reslevelno = 0; ok_reslevel; reslevelno++) { ok_reslevel = 0; for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000CodingStyle *codsty = tile->codsty + compno; Jpeg2000QuantStyle *qntsty = tile->qntsty + compno; if (reslevelno < codsty->nreslevels) { Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno; ok_reslevel = 1; for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++) if ((ret = jpeg2000_decode_packet(s, codsty, rlevel, precno, layno, qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0), qntsty->nguardbits)) < 0) return ret; } } } } break; case JPEG2000_PGOD_CPRL: for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000CodingStyle *codsty = tile->codsty + compno; Jpeg2000QuantStyle *qntsty = tile->qntsty + compno; s->g = tile->tile_part[compno].tpg; for (y = 0; y < s->height; y += 256) { for (x = 0; x < s->width; x += 256) { for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) { uint16_t prcx, prcy; uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno; if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) || (y == 0))) continue; if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) || (x == 0))) continue; prcx = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width; prcy = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height; precno = prcx + rlevel->num_precincts_x * prcy; for (layno = 0; layno < tile->codsty[0].nlayers; layno++) { if ((ret = jpeg2000_decode_packet(s, codsty, rlevel, precno, layno, qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0), qntsty->nguardbits)) < 0) return ret; } } } } } break; case JPEG2000_PGOD_RLCP: avpriv_request_sample(s->avctx, ""Progression order RLCP""); ret = AVERROR_PATCHWELCOME; break; case JPEG2000_PGOD_RPCL: avpriv_request_sample(s->avctx, ""Progression order RPCL""); ret = AVERROR_PATCHWELCOME; break; case JPEG2000_PGOD_PCRL: avpriv_request_sample(s->avctx, ""Progression order PCRL""); ret = AVERROR_PATCHWELCOME; break; default: break; } bytestream2_skip(&s->g, 2); return ret; }"
2643----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_908810897ccfd9cd8c0616e10c40adba93da019d_1.json----pred_weight_table,"<S2SV_StartVul> static void pred_weight_table(HEVCContext *s, GetBitContext *gb) <S2SV_EndVul> { int i = 0; int j = 0; uint8_t luma_weight_l0_flag[16]; uint8_t chroma_weight_l0_flag[16]; uint8_t luma_weight_l1_flag[16]; uint8_t chroma_weight_l1_flag[16]; int luma_log2_weight_denom; luma_log2_weight_denom = get_ue_golomb_long(gb); if (luma_log2_weight_denom < 0 || luma_log2_weight_denom > 7) av_log(s->avctx, AV_LOG_ERROR, ""luma_log2_weight_denom %d is invalid\n"", luma_log2_weight_denom); s->sh.luma_log2_weight_denom = av_clip_uintp2(luma_log2_weight_denom, 3); if (s->ps.sps->chroma_format_idc != 0) { int delta = get_se_golomb(gb); s->sh.chroma_log2_weight_denom = av_clip_uintp2(s->sh.luma_log2_weight_denom + delta, 3); } for (i = 0; i < s->sh.nb_refs[L0]; i++) { luma_weight_l0_flag[i] = get_bits1(gb); if (!luma_weight_l0_flag[i]) { s->sh.luma_weight_l0[i] = 1 << s->sh.luma_log2_weight_denom; s->sh.luma_offset_l0[i] = 0; } } if (s->ps.sps->chroma_format_idc != 0) { for (i = 0; i < s->sh.nb_refs[L0]; i++) chroma_weight_l0_flag[i] = get_bits1(gb); } else { for (i = 0; i < s->sh.nb_refs[L0]; i++) chroma_weight_l0_flag[i] = 0; } for (i = 0; i < s->sh.nb_refs[L0]; i++) { if (luma_weight_l0_flag[i]) { int delta_luma_weight_l0 = get_se_golomb(gb); s->sh.luma_weight_l0[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l0; s->sh.luma_offset_l0[i] = get_se_golomb(gb); } if (chroma_weight_l0_flag[i]) { for (j = 0; j < 2; j++) { int delta_chroma_weight_l0 = get_se_golomb(gb); int delta_chroma_offset_l0 = get_se_golomb(gb); s->sh.chroma_weight_l0[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l0; s->sh.chroma_offset_l0[i][j] = av_clip((delta_chroma_offset_l0 - ((128 * s->sh.chroma_weight_l0[i][j]) >> s->sh.chroma_log2_weight_denom) + 128), -128, 127); } } else { s->sh.chroma_weight_l0[i][0] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l0[i][0] = 0; s->sh.chroma_weight_l0[i][1] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l0[i][1] = 0; } } if (s->sh.slice_type == HEVC_SLICE_B) { for (i = 0; i < s->sh.nb_refs[L1]; i++) { luma_weight_l1_flag[i] = get_bits1(gb); if (!luma_weight_l1_flag[i]) { s->sh.luma_weight_l1[i] = 1 << s->sh.luma_log2_weight_denom; s->sh.luma_offset_l1[i] = 0; } } if (s->ps.sps->chroma_format_idc != 0) { for (i = 0; i < s->sh.nb_refs[L1]; i++) chroma_weight_l1_flag[i] = get_bits1(gb); } else { for (i = 0; i < s->sh.nb_refs[L1]; i++) chroma_weight_l1_flag[i] = 0; } for (i = 0; i < s->sh.nb_refs[L1]; i++) { if (luma_weight_l1_flag[i]) { int delta_luma_weight_l1 = get_se_golomb(gb); s->sh.luma_weight_l1[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l1; s->sh.luma_offset_l1[i] = get_se_golomb(gb); } if (chroma_weight_l1_flag[i]) { for (j = 0; j < 2; j++) { int delta_chroma_weight_l1 = get_se_golomb(gb); int delta_chroma_offset_l1 = get_se_golomb(gb); s->sh.chroma_weight_l1[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l1; s->sh.chroma_offset_l1[i][j] = av_clip((delta_chroma_offset_l1 - ((128 * s->sh.chroma_weight_l1[i][j]) >> s->sh.chroma_log2_weight_denom) + 128), -128, 127); } } else { s->sh.chroma_weight_l1[i][0] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l1[i][0] = 0; s->sh.chroma_weight_l1[i][1] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l1[i][1] = 0; } } } }","- static void pred_weight_table(HEVCContext *s, GetBitContext *gb)
+ static int pred_weight_table(HEVCContext *s, GetBitContext *gb)
+ if ( (int8_t)delta_chroma_weight_l0 != delta_chroma_weight_l0
+ || delta_chroma_offset_l0 < -(1<<17) || delta_chroma_offset_l0 > (1<<17)) {
+ return AVERROR_INVALIDDATA;
+ }
+ if ( (int8_t)delta_chroma_weight_l1 != delta_chroma_weight_l1
+ || delta_chroma_offset_l1 < -(1<<17) || delta_chroma_offset_l1 > (1<<17)) {
+ return AVERROR_INVALIDDATA;
+ }
+ return 0;","static int pred_weight_table(HEVCContext *s, GetBitContext *gb) { int i = 0; int j = 0; uint8_t luma_weight_l0_flag[16]; uint8_t chroma_weight_l0_flag[16]; uint8_t luma_weight_l1_flag[16]; uint8_t chroma_weight_l1_flag[16]; int luma_log2_weight_denom; luma_log2_weight_denom = get_ue_golomb_long(gb); if (luma_log2_weight_denom < 0 || luma_log2_weight_denom > 7) av_log(s->avctx, AV_LOG_ERROR, ""luma_log2_weight_denom %d is invalid\n"", luma_log2_weight_denom); s->sh.luma_log2_weight_denom = av_clip_uintp2(luma_log2_weight_denom, 3); if (s->ps.sps->chroma_format_idc != 0) { int delta = get_se_golomb(gb); s->sh.chroma_log2_weight_denom = av_clip_uintp2(s->sh.luma_log2_weight_denom + delta, 3); } for (i = 0; i < s->sh.nb_refs[L0]; i++) { luma_weight_l0_flag[i] = get_bits1(gb); if (!luma_weight_l0_flag[i]) { s->sh.luma_weight_l0[i] = 1 << s->sh.luma_log2_weight_denom; s->sh.luma_offset_l0[i] = 0; } } if (s->ps.sps->chroma_format_idc != 0) { for (i = 0; i < s->sh.nb_refs[L0]; i++) chroma_weight_l0_flag[i] = get_bits1(gb); } else { for (i = 0; i < s->sh.nb_refs[L0]; i++) chroma_weight_l0_flag[i] = 0; } for (i = 0; i < s->sh.nb_refs[L0]; i++) { if (luma_weight_l0_flag[i]) { int delta_luma_weight_l0 = get_se_golomb(gb); s->sh.luma_weight_l0[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l0; s->sh.luma_offset_l0[i] = get_se_golomb(gb); } if (chroma_weight_l0_flag[i]) { for (j = 0; j < 2; j++) { int delta_chroma_weight_l0 = get_se_golomb(gb); int delta_chroma_offset_l0 = get_se_golomb(gb); if ( (int8_t)delta_chroma_weight_l0 != delta_chroma_weight_l0 || delta_chroma_offset_l0 < -(1<<17) || delta_chroma_offset_l0 > (1<<17)) { return AVERROR_INVALIDDATA; } s->sh.chroma_weight_l0[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l0; s->sh.chroma_offset_l0[i][j] = av_clip((delta_chroma_offset_l0 - ((128 * s->sh.chroma_weight_l0[i][j]) >> s->sh.chroma_log2_weight_denom) + 128), -128, 127); } } else { s->sh.chroma_weight_l0[i][0] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l0[i][0] = 0; s->sh.chroma_weight_l0[i][1] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l0[i][1] = 0; } } if (s->sh.slice_type == HEVC_SLICE_B) { for (i = 0; i < s->sh.nb_refs[L1]; i++) { luma_weight_l1_flag[i] = get_bits1(gb); if (!luma_weight_l1_flag[i]) { s->sh.luma_weight_l1[i] = 1 << s->sh.luma_log2_weight_denom; s->sh.luma_offset_l1[i] = 0; } } if (s->ps.sps->chroma_format_idc != 0) { for (i = 0; i < s->sh.nb_refs[L1]; i++) chroma_weight_l1_flag[i] = get_bits1(gb); } else { for (i = 0; i < s->sh.nb_refs[L1]; i++) chroma_weight_l1_flag[i] = 0; } for (i = 0; i < s->sh.nb_refs[L1]; i++) { if (luma_weight_l1_flag[i]) { int delta_luma_weight_l1 = get_se_golomb(gb); s->sh.luma_weight_l1[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l1; s->sh.luma_offset_l1[i] = get_se_golomb(gb); } if (chroma_weight_l1_flag[i]) { for (j = 0; j < 2; j++) { int delta_chroma_weight_l1 = get_se_golomb(gb); int delta_chroma_offset_l1 = get_se_golomb(gb); if ( (int8_t)delta_chroma_weight_l1 != delta_chroma_weight_l1 || delta_chroma_offset_l1 < -(1<<17) || delta_chroma_offset_l1 > (1<<17)) { return AVERROR_INVALIDDATA; } s->sh.chroma_weight_l1[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l1; s->sh.chroma_offset_l1[i][j] = av_clip((delta_chroma_offset_l1 - ((128 * s->sh.chroma_weight_l1[i][j]) >> s->sh.chroma_log2_weight_denom) + 128), -128, 127); } } else { s->sh.chroma_weight_l1[i][0] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l1[i][0] = 0; s->sh.chroma_weight_l1[i][1] = 1 << s->sh.chroma_log2_weight_denom; s->sh.chroma_offset_l1[i][1] = 0; } } } return 0; }"
1680----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5d7e3f375adf06f5a67aa71a44a635bdb13feb8e_1.json----av_grow_packet,"int av_grow_packet(AVPacket *pkt, int grow_by) { int new_size; av_assert0((unsigned)pkt->size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE); if ((unsigned)grow_by > INT_MAX - (pkt->size + AV_INPUT_BUFFER_PADDING_SIZE)) return -1; new_size = pkt->size + grow_by + AV_INPUT_BUFFER_PADDING_SIZE; if (pkt->buf) { size_t data_offset; uint8_t *old_data = pkt->data; if (pkt->data == NULL) { data_offset = 0; pkt->data = pkt->buf->data; } else { data_offset = pkt->data - pkt->buf->data; if (data_offset > INT_MAX - new_size) return -1; } if (new_size + data_offset > pkt->buf->size) { int ret = av_buffer_realloc(&pkt->buf, new_size + data_offset); if (ret < 0) { pkt->data = old_data; return ret; } pkt->data = pkt->buf->data + data_offset; } } else { pkt->buf = av_buffer_alloc(new_size); if (!pkt->buf) return AVERROR(ENOMEM); <S2SV_StartVul> memcpy(pkt->buf->data, pkt->data, pkt->size); <S2SV_EndVul> pkt->data = pkt->buf->data; } pkt->size += grow_by; memset(pkt->data + pkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE); return 0; }","- memcpy(pkt->buf->data, pkt->data, pkt->size);
+ if (pkt->size > 0)
+ memcpy(pkt->buf->data, pkt->data, pkt->size);","int av_grow_packet(AVPacket *pkt, int grow_by) { int new_size; av_assert0((unsigned)pkt->size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE); if ((unsigned)grow_by > INT_MAX - (pkt->size + AV_INPUT_BUFFER_PADDING_SIZE)) return -1; new_size = pkt->size + grow_by + AV_INPUT_BUFFER_PADDING_SIZE; if (pkt->buf) { size_t data_offset; uint8_t *old_data = pkt->data; if (pkt->data == NULL) { data_offset = 0; pkt->data = pkt->buf->data; } else { data_offset = pkt->data - pkt->buf->data; if (data_offset > INT_MAX - new_size) return -1; } if (new_size + data_offset > pkt->buf->size) { int ret = av_buffer_realloc(&pkt->buf, new_size + data_offset); if (ret < 0) { pkt->data = old_data; return ret; } pkt->data = pkt->buf->data + data_offset; } } else { pkt->buf = av_buffer_alloc(new_size); if (!pkt->buf) return AVERROR(ENOMEM); if (pkt->size > 0) memcpy(pkt->buf->data, pkt->data, pkt->size); pkt->data = pkt->buf->data; } pkt->size += grow_by; memset(pkt->data + pkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE); return 0; }"
1035----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38694e57192cb61911f1307a9398363c03f5aa33_1.json----set_expr,"static int set_expr(AVExpr **pexpr, const char *expr, void *log_ctx) { int ret; if (*pexpr) <S2SV_StartVul> av_expr_free(*pexpr); <S2SV_EndVul> <S2SV_StartVul> *pexpr = NULL; <S2SV_EndVul> ret = av_expr_parse(pexpr, expr, var_names, NULL, NULL, NULL, NULL, 0, log_ctx); <S2SV_StartVul> if (ret < 0) <S2SV_EndVul> av_log(log_ctx, AV_LOG_ERROR, ""Error when evaluating the expression '%s'\n"", expr); <S2SV_StartVul> return ret; <S2SV_EndVul> }","- av_expr_free(*pexpr);
- if (ret < 0)
- return ret;
+ AVExpr *old = NULL;
+ old = *pexpr;
+ if (ret < 0) {
+ return ret;
+ }
+ av_expr_free(old);
+ return 0;","static int set_expr(AVExpr **pexpr, const char *expr, void *log_ctx) { int ret; AVExpr *old = NULL; if (*pexpr) old = *pexpr; ret = av_expr_parse(pexpr, expr, var_names, NULL, NULL, NULL, NULL, 0, log_ctx); if (ret < 0) { av_log(log_ctx, AV_LOG_ERROR, ""Error when evaluating the expression '%s'\n"", expr); *pexpr = old; return ret; } av_expr_free(old); return 0; }"
5939----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_391fa935185daac5a15109b1ce2c5f308a837ca7_1.json----smka_decode_frame,"static int smka_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; GetBitContext gb; HuffContext h[4] = { { 0 } }; VLC vlc[4] = { { 0 } }; int16_t *samples; uint8_t *samples8; int val; int i, res, ret; int unp_size; int bits, stereo; int pred[2] = {0, 0}; if (buf_size <= 4) { av_log(avctx, AV_LOG_ERROR, ""packet is too small\n""); return AVERROR(EINVAL); } unp_size = AV_RL32(buf); init_get_bits(&gb, buf + 4, (buf_size - 4) * 8); if(!get_bits1(&gb)){ av_log(avctx, AV_LOG_INFO, ""Sound: no data\n""); *got_frame_ptr = 0; return 1; } stereo = get_bits1(&gb); bits = get_bits1(&gb); if (stereo ^ (avctx->channels != 1)) { av_log(avctx, AV_LOG_ERROR, ""channels mismatch\n""); return AVERROR(EINVAL); } if (bits && avctx->sample_fmt == AV_SAMPLE_FMT_U8) { av_log(avctx, AV_LOG_ERROR, ""sample format mismatch\n""); return AVERROR(EINVAL); } frame->nb_samples = unp_size / (avctx->channels * (bits + 1)); if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return ret; } samples = (int16_t *)frame->data[0]; samples8 = frame->data[0]; for(i = 0; i < (1 << (bits + stereo)); i++) { h[i].length = 256; h[i].maxlength = 0; h[i].current = 0; h[i].bits = av_mallocz(256 * 4); h[i].lengths = av_mallocz(256 * sizeof(int)); h[i].values = av_mallocz(256 * sizeof(int)); skip_bits1(&gb); if (smacker_decode_tree(&gb, &h[i], 0, 0) < 0) { <S2SV_StartVul> for (; i >= 0; i--) { <S2SV_EndVul> <S2SV_StartVul> if (vlc[i].table) <S2SV_EndVul> <S2SV_StartVul> ff_free_vlc(&vlc[i]); <S2SV_EndVul> <S2SV_StartVul> av_free(h[i].bits); <S2SV_EndVul> <S2SV_StartVul> av_free(h[i].lengths); <S2SV_EndVul> <S2SV_StartVul> av_free(h[i].values); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return AVERROR_INVALIDDATA; <S2SV_EndVul> } skip_bits1(&gb); if(h[i].current > 1) { res = init_vlc(&vlc[i], SMKTREE_BITS, h[i].length, h[i].lengths, sizeof(int), sizeof(int), h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE); if(res < 0) { av_log(avctx, AV_LOG_ERROR, ""Cannot build VLC table\n""); <S2SV_StartVul> return -1; <S2SV_EndVul> } } } if(bits) { for(i = stereo; i >= 0; i--) pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16); for(i = 0; i <= stereo; i++) *samples++ = pred[i]; for(; i < unp_size / 2; i++) { if(i & stereo) { if(vlc[2].table) res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3); else res = 0; val = h[2].values[res]; if(vlc[3].table) res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3); else res = 0; val |= h[3].values[res] << 8; pred[1] += sign_extend(val, 16); *samples++ = pred[1]; } else { if(vlc[0].table) res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3); else res = 0; val = h[0].values[res]; if(vlc[1].table) res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3); else res = 0; val |= h[1].values[res] << 8; pred[0] += sign_extend(val, 16); *samples++ = pred[0]; } } } else { for(i = stereo; i >= 0; i--) pred[i] = get_bits(&gb, 8); for(i = 0; i <= stereo; i++) *samples8++ = pred[i]; for(; i < unp_size; i++) { if(i & stereo){ if(vlc[1].table) res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3); else res = 0; pred[1] += sign_extend(h[1].values[res], 8); *samples8++ = pred[1]; } else { if(vlc[0].table) res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3); else res = 0; pred[0] += sign_extend(h[0].values[res], 8); *samples8++ = pred[0]; } } } for(i = 0; i < 4; i++) { if(vlc[i].table) ff_free_vlc(&vlc[i]); av_free(h[i].bits); av_free(h[i].lengths); av_free(h[i].values); } <S2SV_StartVul> *got_frame_ptr = 1; <S2SV_EndVul> <S2SV_StartVul> return buf_size; <S2SV_EndVul> }","- for (; i >= 0; i--) {
- if (vlc[i].table)
- ff_free_vlc(&vlc[i]);
- av_free(h[i].bits);
- av_free(h[i].lengths);
- av_free(h[i].values);
- }
- return AVERROR_INVALIDDATA;
- return -1;
- return buf_size;
+ if (!h[i].bits || !h[i].lengths || !h[i].values) {
+ ret = AVERROR(ENOMEM);
+ goto error;
+ }
+ ret = AVERROR_INVALIDDATA;
+ goto error;
+ ret = AVERROR_INVALIDDATA;
+ goto error;
+ ret = buf_size;
+ error:
+ return ret;","static int smka_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; GetBitContext gb; HuffContext h[4] = { { 0 } }; VLC vlc[4] = { { 0 } }; int16_t *samples; uint8_t *samples8; int val; int i, res, ret; int unp_size; int bits, stereo; int pred[2] = {0, 0}; if (buf_size <= 4) { av_log(avctx, AV_LOG_ERROR, ""packet is too small\n""); return AVERROR(EINVAL); } unp_size = AV_RL32(buf); init_get_bits(&gb, buf + 4, (buf_size - 4) * 8); if(!get_bits1(&gb)){ av_log(avctx, AV_LOG_INFO, ""Sound: no data\n""); *got_frame_ptr = 0; return 1; } stereo = get_bits1(&gb); bits = get_bits1(&gb); if (stereo ^ (avctx->channels != 1)) { av_log(avctx, AV_LOG_ERROR, ""channels mismatch\n""); return AVERROR(EINVAL); } if (bits && avctx->sample_fmt == AV_SAMPLE_FMT_U8) { av_log(avctx, AV_LOG_ERROR, ""sample format mismatch\n""); return AVERROR(EINVAL); } frame->nb_samples = unp_size / (avctx->channels * (bits + 1)); if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return ret; } samples = (int16_t *)frame->data[0]; samples8 = frame->data[0]; for(i = 0; i < (1 << (bits + stereo)); i++) { h[i].length = 256; h[i].maxlength = 0; h[i].current = 0; h[i].bits = av_mallocz(256 * 4); h[i].lengths = av_mallocz(256 * sizeof(int)); h[i].values = av_mallocz(256 * sizeof(int)); if (!h[i].bits || !h[i].lengths || !h[i].values) { ret = AVERROR(ENOMEM); goto error; } skip_bits1(&gb); if (smacker_decode_tree(&gb, &h[i], 0, 0) < 0) { ret = AVERROR_INVALIDDATA; goto error; } skip_bits1(&gb); if(h[i].current > 1) { res = init_vlc(&vlc[i], SMKTREE_BITS, h[i].length, h[i].lengths, sizeof(int), sizeof(int), h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE); if(res < 0) { av_log(avctx, AV_LOG_ERROR, ""Cannot build VLC table\n""); ret = AVERROR_INVALIDDATA; goto error; } } } if(bits) { for(i = stereo; i >= 0; i--) pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16); for(i = 0; i <= stereo; i++) *samples++ = pred[i]; for(; i < unp_size / 2; i++) { if(i & stereo) { if(vlc[2].table) res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3); else res = 0; val = h[2].values[res]; if(vlc[3].table) res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3); else res = 0; val |= h[3].values[res] << 8; pred[1] += sign_extend(val, 16); *samples++ = pred[1]; } else { if(vlc[0].table) res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3); else res = 0; val = h[0].values[res]; if(vlc[1].table) res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3); else res = 0; val |= h[1].values[res] << 8; pred[0] += sign_extend(val, 16); *samples++ = pred[0]; } } } else { for(i = stereo; i >= 0; i--) pred[i] = get_bits(&gb, 8); for(i = 0; i <= stereo; i++) *samples8++ = pred[i]; for(; i < unp_size; i++) { if(i & stereo){ if(vlc[1].table) res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3); else res = 0; pred[1] += sign_extend(h[1].values[res], 8); *samples8++ = pred[1]; } else { if(vlc[0].table) res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3); else res = 0; pred[0] += sign_extend(h[0].values[res], 8); *samples8++ = pred[0]; } } } *got_frame_ptr = 1; ret = buf_size; error: for(i = 0; i < 4; i++) { if(vlc[i].table) ff_free_vlc(&vlc[i]); av_free(h[i].bits); av_free(h[i].lengths); av_free(h[i].values); } return ret; }"
134----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_08371baf079e42b07ec2ade795b67121eafe05e8_1.json----raw_decode,"static int raw_decode(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int linesize_align = 4; RawVideoContext *context = avctx->priv_data; AVFrame * frame = (AVFrame *) data; AVPicture * picture = (AVPicture *) data; frame->pict_type = avctx->coded_frame->pict_type; frame->interlaced_frame = avctx->coded_frame->interlaced_frame; frame->top_field_first = avctx->coded_frame->top_field_first; frame->reordered_opaque = avctx->reordered_opaque; frame->pkt_pts = avctx->pkt->pts; frame->pkt_pos = avctx->pkt->pos; if(context->tff>=0){ frame->interlaced_frame = 1; frame->top_field_first = context->tff; } if (context->buffer) { int i; uint8_t *dst = context->buffer; buf_size = context->length - 256*4; if (avctx->bits_per_coded_sample == 4){ <S2SV_StartVul> for(i=0; 2*i+1 < buf_size; i++){ <S2SV_EndVul> dst[2*i+0]= buf[i]>>4; dst[2*i+1]= buf[i]&15; } linesize_align = 8; } else { <S2SV_StartVul> for(i=0; 4*i+3 < buf_size; i++){ <S2SV_EndVul> dst[4*i+0]= buf[i]>>6; dst[4*i+1]= buf[i]>>4&3; dst[4*i+2]= buf[i]>>2&3; dst[4*i+3]= buf[i] &3; } linesize_align = 16; } buf= dst; } if(avctx->codec_tag == MKTAG('A', 'V', '1', 'x') || avctx->codec_tag == MKTAG('A', 'V', 'u', 'p')) buf += buf_size - context->length; if(buf_size < context->length - (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0)) return -1; avpicture_fill(picture, buf, avctx->pix_fmt, avctx->width, avctx->height); if((avctx->pix_fmt==PIX_FMT_PAL8 && buf_size < context->length) || (av_pix_fmt_descriptors[avctx->pix_fmt].flags & PIX_FMT_PSEUDOPAL)) { frame->data[1]= context->palette; } if (avctx->pix_fmt == PIX_FMT_PAL8) { const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL); if (pal) { memcpy(frame->data[1], pal, AVPALETTE_SIZE); frame->palette_has_changed = 1; } } if((avctx->pix_fmt==PIX_FMT_BGR24 || avctx->pix_fmt==PIX_FMT_GRAY8 || avctx->pix_fmt==PIX_FMT_RGB555LE || avctx->pix_fmt==PIX_FMT_RGB555BE || avctx->pix_fmt==PIX_FMT_RGB565LE || avctx->pix_fmt==PIX_FMT_MONOWHITE || avctx->pix_fmt==PIX_FMT_PAL8) && FFALIGN(frame->linesize[0], linesize_align)*avctx->height <= buf_size) frame->linesize[0] = FFALIGN(frame->linesize[0], linesize_align); if(context->flip) flip(avctx, picture); if ( avctx->codec_tag == MKTAG('Y', 'V', '1', '2') || avctx->codec_tag == MKTAG('Y', 'V', '1', '6') || avctx->codec_tag == MKTAG('Y', 'V', '2', '4') || avctx->codec_tag == MKTAG('Y', 'V', 'U', '9')) FFSWAP(uint8_t *, picture->data[1], picture->data[2]); if(avctx->codec_tag == AV_RL32(""yuv2"") && avctx->pix_fmt == PIX_FMT_YUYV422) { int x, y; uint8_t *line = picture->data[0]; for(y = 0; y < avctx->height; y++) { for(x = 0; x < avctx->width; x++) line[2*x + 1] ^= 0x80; line += picture->linesize[0]; } } *data_size = sizeof(AVPicture); return buf_size; }","- for(i=0; 2*i+1 < buf_size; i++){
- for(i=0; 4*i+3 < buf_size; i++){
+ for(i=0; 2*i+1 < buf_size && i<avpkt->size; i++){
+ for(i=0; 4*i+3 < buf_size && i<avpkt->size; i++){","static int raw_decode(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; int linesize_align = 4; RawVideoContext *context = avctx->priv_data; AVFrame * frame = (AVFrame *) data; AVPicture * picture = (AVPicture *) data; frame->pict_type = avctx->coded_frame->pict_type; frame->interlaced_frame = avctx->coded_frame->interlaced_frame; frame->top_field_first = avctx->coded_frame->top_field_first; frame->reordered_opaque = avctx->reordered_opaque; frame->pkt_pts = avctx->pkt->pts; frame->pkt_pos = avctx->pkt->pos; if(context->tff>=0){ frame->interlaced_frame = 1; frame->top_field_first = context->tff; } if (context->buffer) { int i; uint8_t *dst = context->buffer; buf_size = context->length - 256*4; if (avctx->bits_per_coded_sample == 4){ for(i=0; 2*i+1 < buf_size && i<avpkt->size; i++){ dst[2*i+0]= buf[i]>>4; dst[2*i+1]= buf[i]&15; } linesize_align = 8; } else { for(i=0; 4*i+3 < buf_size && i<avpkt->size; i++){ dst[4*i+0]= buf[i]>>6; dst[4*i+1]= buf[i]>>4&3; dst[4*i+2]= buf[i]>>2&3; dst[4*i+3]= buf[i] &3; } linesize_align = 16; } buf= dst; } if(avctx->codec_tag == MKTAG('A', 'V', '1', 'x') || avctx->codec_tag == MKTAG('A', 'V', 'u', 'p')) buf += buf_size - context->length; if(buf_size < context->length - (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0)) return -1; avpicture_fill(picture, buf, avctx->pix_fmt, avctx->width, avctx->height); if((avctx->pix_fmt==PIX_FMT_PAL8 && buf_size < context->length) || (av_pix_fmt_descriptors[avctx->pix_fmt].flags & PIX_FMT_PSEUDOPAL)) { frame->data[1]= context->palette; } if (avctx->pix_fmt == PIX_FMT_PAL8) { const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL); if (pal) { memcpy(frame->data[1], pal, AVPALETTE_SIZE); frame->palette_has_changed = 1; } } if((avctx->pix_fmt==PIX_FMT_BGR24 || avctx->pix_fmt==PIX_FMT_GRAY8 || avctx->pix_fmt==PIX_FMT_RGB555LE || avctx->pix_fmt==PIX_FMT_RGB555BE || avctx->pix_fmt==PIX_FMT_RGB565LE || avctx->pix_fmt==PIX_FMT_MONOWHITE || avctx->pix_fmt==PIX_FMT_PAL8) && FFALIGN(frame->linesize[0], linesize_align)*avctx->height <= buf_size) frame->linesize[0] = FFALIGN(frame->linesize[0], linesize_align); if(context->flip) flip(avctx, picture); if ( avctx->codec_tag == MKTAG('Y', 'V', '1', '2') || avctx->codec_tag == MKTAG('Y', 'V', '1', '6') || avctx->codec_tag == MKTAG('Y', 'V', '2', '4') || avctx->codec_tag == MKTAG('Y', 'V', 'U', '9')) FFSWAP(uint8_t *, picture->data[1], picture->data[2]); if(avctx->codec_tag == AV_RL32(""yuv2"") && avctx->pix_fmt == PIX_FMT_YUYV422) { int x, y; uint8_t *line = picture->data[0]; for(y = 0; y < avctx->height; y++) { for(x = 0; x < avctx->width; x++) line[2*x + 1] ^= 0x80; line += picture->linesize[0]; } } *data_size = sizeof(AVPicture); return buf_size; }"
382----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_16560b07277aec13fc540d047e21145823f71429_1.json----compand_delay,"static int compand_delay(AVFilterContext *ctx, AVFrame *frame) { CompandContext *s = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; const int channels = inlink->channels; const int nb_samples = frame->nb_samples; int chan, i, av_uninit(dindex), oindex, av_uninit(count); AVFrame *out_frame = NULL; if (s->pts == AV_NOPTS_VALUE) { s->pts = (frame->pts == AV_NOPTS_VALUE) ? 0 : frame->pts; } av_assert1(channels > 0); for (chan = 0; chan < channels; chan++) { AVFrame *delay_frame = s->delay_frame; const double *src = (double *)frame->extended_data[chan]; double *dbuf = (double *)delay_frame->extended_data[chan]; ChanParam *cp = &s->channels[chan]; double *dst; count = s->delay_count; dindex = s->delay_index; for (i = 0, oindex = 0; i < nb_samples; i++) { const double in = src[i]; update_volume(cp, fabs(in)); if (count >= s->delay_samples) { if (!out_frame) { out_frame = ff_get_audio_buffer(inlink, nb_samples - i); if (!out_frame) { av_frame_free(&frame); return AVERROR(ENOMEM); } <S2SV_StartVul> av_frame_copy_props(out_frame, frame); <S2SV_EndVul> out_frame->pts = s->pts; s->pts += av_rescale_q(nb_samples - i, (AVRational){ 1, inlink->sample_rate }, inlink->time_base); } dst = (double *)out_frame->extended_data[chan]; dst[oindex++] = av_clipd(dbuf[dindex] * get_volume(s, cp->volume), -1, 1); } else { count++; } dbuf[dindex] = in; dindex = MOD(dindex + 1, s->delay_samples); } } s->delay_count = count; s->delay_index = dindex; av_frame_free(&frame); return out_frame ? ff_filter_frame(ctx->outputs[0], out_frame) : 0; }","- av_frame_copy_props(out_frame, frame);
+ int err;
+ err = av_frame_copy_props(out_frame, frame);
+ if (err < 0) {
+ av_frame_free(&out_frame);
+ av_frame_free(&frame);
+ return err;
+ }","static int compand_delay(AVFilterContext *ctx, AVFrame *frame) { CompandContext *s = ctx->priv; AVFilterLink *inlink = ctx->inputs[0]; const int channels = inlink->channels; const int nb_samples = frame->nb_samples; int chan, i, av_uninit(dindex), oindex, av_uninit(count); AVFrame *out_frame = NULL; int err; if (s->pts == AV_NOPTS_VALUE) { s->pts = (frame->pts == AV_NOPTS_VALUE) ? 0 : frame->pts; } av_assert1(channels > 0); for (chan = 0; chan < channels; chan++) { AVFrame *delay_frame = s->delay_frame; const double *src = (double *)frame->extended_data[chan]; double *dbuf = (double *)delay_frame->extended_data[chan]; ChanParam *cp = &s->channels[chan]; double *dst; count = s->delay_count; dindex = s->delay_index; for (i = 0, oindex = 0; i < nb_samples; i++) { const double in = src[i]; update_volume(cp, fabs(in)); if (count >= s->delay_samples) { if (!out_frame) { out_frame = ff_get_audio_buffer(inlink, nb_samples - i); if (!out_frame) { av_frame_free(&frame); return AVERROR(ENOMEM); } err = av_frame_copy_props(out_frame, frame); if (err < 0) { av_frame_free(&out_frame); av_frame_free(&frame); return err; } out_frame->pts = s->pts; s->pts += av_rescale_q(nb_samples - i, (AVRational){ 1, inlink->sample_rate }, inlink->time_base); } dst = (double *)out_frame->extended_data[chan]; dst[oindex++] = av_clipd(dbuf[dindex] * get_volume(s, cp->volume), -1, 1); } else { count++; } dbuf[dindex] = in; dindex = MOD(dindex + 1, s->delay_samples); } } s->delay_count = count; s->delay_index = dindex; av_frame_free(&frame); return out_frame ? ff_filter_frame(ctx->outputs[0], out_frame) : 0; }"
11414----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_29472847d5b156c07bd99fa13266a9a08e80c3e7_1.json----bn_probable_prime_dh_coprime,"int bn_probable_prime_dh_coprime(BIGNUM *rnd, int bits, BN_CTX *ctx) { int i; BIGNUM *offset_index; BIGNUM *offset_count; int ret = 0; BN_CTX_start(ctx); if ((offset_index = BN_CTX_get(ctx)) == NULL) goto err; if ((offset_count = BN_CTX_get(ctx)) == NULL) goto err; BN_add_word(offset_count, prime_offset_count); loop: <S2SV_StartVul> if (!BN_rand(rnd, bits, 0, 1)) goto err; <S2SV_EndVul> if (!BN_rand_range(offset_index, offset_count)) goto err; BN_mul_word(rnd, prime_multiplier); BN_add_word(rnd, prime_offsets[BN_get_word(offset_index)]); for (i = first_prime_index; i < NUMPRIMES; i++) { if (BN_mod_word(rnd, (BN_ULONG)primes[i]) <= 1) { goto loop; } } ret = 1; err: BN_CTX_end(ctx); bn_check_top(rnd); return ret; }","- if (!BN_rand(rnd, bits, 0, 1)) goto err;
+ OPENSSL_assert(bits > prime_multiplier_bits);
+ if (!BN_rand(rnd, bits - prime_multiplier_bits, 0, 1)) goto err;","int bn_probable_prime_dh_coprime(BIGNUM *rnd, int bits, BN_CTX *ctx) { int i; BIGNUM *offset_index; BIGNUM *offset_count; int ret = 0; OPENSSL_assert(bits > prime_multiplier_bits); BN_CTX_start(ctx); if ((offset_index = BN_CTX_get(ctx)) == NULL) goto err; if ((offset_count = BN_CTX_get(ctx)) == NULL) goto err; BN_add_word(offset_count, prime_offset_count); loop: if (!BN_rand(rnd, bits - prime_multiplier_bits, 0, 1)) goto err; if (!BN_rand_range(offset_index, offset_count)) goto err; BN_mul_word(rnd, prime_multiplier); BN_add_word(rnd, prime_offsets[BN_get_word(offset_index)]); for (i = first_prime_index; i < NUMPRIMES; i++) { if (BN_mod_word(rnd, (BN_ULONG)primes[i]) <= 1) { goto loop; } } ret = 1; err: BN_CTX_end(ctx); bn_check_top(rnd); return ret; }"
1505----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_539c43b2acfee98dd535e0a32ded95d9dd0590c5_1.json----get_format,"static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps) { #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL) enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts; switch (sps->pix_fmt) { case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUVJ420P: #if CONFIG_HEVC_DXVA2_HWACCEL *fmt++ = AV_PIX_FMT_DXVA2_VLD; #endif #if CONFIG_HEVC_D3D11VA_HWACCEL *fmt++ = AV_PIX_FMT_D3D11VA_VLD; #endif #if CONFIG_HEVC_VAAPI_HWACCEL *fmt++ = AV_PIX_FMT_VAAPI; #endif #if CONFIG_HEVC_VDPAU_HWACCEL *fmt++ = AV_PIX_FMT_VDPAU; #endif break; case AV_PIX_FMT_YUV420P10: #if CONFIG_HEVC_DXVA2_HWACCEL *fmt++ = AV_PIX_FMT_DXVA2_VLD; #endif #if CONFIG_HEVC_D3D11VA_HWACCEL *fmt++ = AV_PIX_FMT_D3D11VA_VLD; #endif #if CONFIG_HEVC_VAAPI_HWACCEL *fmt++ = AV_PIX_FMT_VAAPI; #endif break; } *fmt++ = sps->pix_fmt; *fmt = AV_PIX_FMT_NONE; <S2SV_StartVul> return ff_get_format(s->avctx, pix_fmts); <S2SV_EndVul> }","- return ff_get_format(s->avctx, pix_fmts);
+ return ff_thread_get_format(s->avctx, pix_fmts);","static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps) { #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL) enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts; switch (sps->pix_fmt) { case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUVJ420P: #if CONFIG_HEVC_DXVA2_HWACCEL *fmt++ = AV_PIX_FMT_DXVA2_VLD; #endif #if CONFIG_HEVC_D3D11VA_HWACCEL *fmt++ = AV_PIX_FMT_D3D11VA_VLD; #endif #if CONFIG_HEVC_VAAPI_HWACCEL *fmt++ = AV_PIX_FMT_VAAPI; #endif #if CONFIG_HEVC_VDPAU_HWACCEL *fmt++ = AV_PIX_FMT_VDPAU; #endif break; case AV_PIX_FMT_YUV420P10: #if CONFIG_HEVC_DXVA2_HWACCEL *fmt++ = AV_PIX_FMT_DXVA2_VLD; #endif #if CONFIG_HEVC_D3D11VA_HWACCEL *fmt++ = AV_PIX_FMT_D3D11VA_VLD; #endif #if CONFIG_HEVC_VAAPI_HWACCEL *fmt++ = AV_PIX_FMT_VAAPI; #endif break; } *fmt++ = sps->pix_fmt; *fmt = AV_PIX_FMT_NONE; return ff_thread_get_format(s->avctx, pix_fmts); }"
11233----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_22bb689ddbf96de75637c2607d7430c2059db46a_1.json----tls13_change_cipher_state,"int tls13_change_cipher_state(SSL *s, int which) { static const unsigned char client_handshake_traffic[] = ""client handshake traffic secret""; static const unsigned char client_application_traffic[] = ""client application traffic secret""; static const unsigned char server_handshake_traffic[] = ""server handshake traffic secret""; static const unsigned char server_application_traffic[] = ""server application traffic secret""; unsigned char key[EVP_MAX_KEY_LENGTH]; unsigned char *iv; unsigned char secret[EVP_MAX_MD_SIZE]; unsigned char *insecret; unsigned char *finsecret = NULL; EVP_CIPHER_CTX *ciph_ctx; const EVP_CIPHER *ciph = s->s3->tmp.new_sym_enc; size_t ivlen, keylen, finsecretlen = 0; const unsigned char *label; <S2SV_StartVul> size_t labellen; <S2SV_EndVul> int ret = 0; if (which & SSL3_CC_READ) { if (s->enc_read_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_read_ctx); } else { s->enc_read_ctx = EVP_CIPHER_CTX_new(); if (s->enc_read_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_read_ctx; iv = s->read_iv; RECORD_LAYER_reset_read_sequence(&s->rlayer); } else { if (s->enc_write_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_write_ctx); } else { s->enc_write_ctx = EVP_CIPHER_CTX_new(); if (s->enc_write_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_write_ctx; iv = s->write_iv; RECORD_LAYER_reset_write_sequence(&s->rlayer); } if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE)) || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) { if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->client_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = client_handshake_traffic; labellen = sizeof(client_handshake_traffic) - 1; } else { insecret = s->session->master_key; label = client_application_traffic; labellen = sizeof(client_application_traffic) - 1; } } else { if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->server_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = server_handshake_traffic; labellen = sizeof(server_handshake_traffic) - 1; } else { insecret = s->session->master_key; label = server_application_traffic; labellen = sizeof(server_application_traffic) - 1; } } <S2SV_StartVul> if (!tls13_derive_secret(s, insecret, label, labellen, secret)) { <S2SV_EndVul> SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } keylen = EVP_CIPHER_key_length(ciph); ivlen = EVP_CIPHER_iv_length(ciph); if (!tls13_derive_key(s, secret, key, keylen) || !tls13_derive_iv(s, secret, iv, ivlen) || (finsecret != NULL && !tls13_derive_finishedkey(s, secret, finsecret, finsecretlen))) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, key, NULL, (which & SSL3_CC_WRITE)) <= 0) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_EVP_LIB); goto err; } #ifdef OPENSSL_SSL_TRACE_CRYPTO if (s->msg_callback) { int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0; if (ciph->key_len) s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY, key, ciph->key_len, s, s->msg_callback_arg); wh |= TLS1_RT_CRYPTO_IV; s->msg_callback(2, s->version, wh, iv, ivlen, s, s->msg_callback_arg); } #endif ret = 1; err: OPENSSL_cleanse(secret, sizeof(secret)); OPENSSL_cleanse(key, sizeof(key)); return ret; }","- size_t labellen;
- if (!tls13_derive_secret(s, insecret, label, labellen, secret)) {
+ unsigned char hashval[EVP_MAX_MD_SIZE];
+ unsigned char *hash = hashval;
+ size_t labellen, hashlen = 0;
+ int hashleni;
+ hash = s->server_finished_hash;
+ hashleni = EVP_MD_CTX_size(s->s3->handshake_dgst);
+ if (hashleni < 0) {
+ SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);
+ goto err;
+ }
+ hashlen = (size_t)hashleni;
+ if (label != client_application_traffic) {
+ if (!ssl3_digest_cached_records(s, 1)
+ || !ssl_handshake_hash(s, hash, sizeof(hashval), &hashlen)) {
+ SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);
+ goto err;
+ }
+ if (label == server_application_traffic)
+ memcpy(s->server_finished_hash, hash, hashlen);
+ }
+ if (!tls13_hkdf_expand(s, insecret, label, labellen, hash, secret,
+ hashlen)) {","int tls13_change_cipher_state(SSL *s, int which) { static const unsigned char client_handshake_traffic[] = ""client handshake traffic secret""; static const unsigned char client_application_traffic[] = ""client application traffic secret""; static const unsigned char server_handshake_traffic[] = ""server handshake traffic secret""; static const unsigned char server_application_traffic[] = ""server application traffic secret""; unsigned char key[EVP_MAX_KEY_LENGTH]; unsigned char *iv; unsigned char secret[EVP_MAX_MD_SIZE]; unsigned char hashval[EVP_MAX_MD_SIZE]; unsigned char *hash = hashval; unsigned char *insecret; unsigned char *finsecret = NULL; EVP_CIPHER_CTX *ciph_ctx; const EVP_CIPHER *ciph = s->s3->tmp.new_sym_enc; size_t ivlen, keylen, finsecretlen = 0; const unsigned char *label; size_t labellen, hashlen = 0; int ret = 0; if (which & SSL3_CC_READ) { if (s->enc_read_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_read_ctx); } else { s->enc_read_ctx = EVP_CIPHER_CTX_new(); if (s->enc_read_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_read_ctx; iv = s->read_iv; RECORD_LAYER_reset_read_sequence(&s->rlayer); } else { if (s->enc_write_ctx != NULL) { EVP_CIPHER_CTX_reset(s->enc_write_ctx); } else { s->enc_write_ctx = EVP_CIPHER_CTX_new(); if (s->enc_write_ctx == NULL) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE); goto err; } } ciph_ctx = s->enc_write_ctx; iv = s->write_iv; RECORD_LAYER_reset_write_sequence(&s->rlayer); } if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE)) || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) { if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->client_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = client_handshake_traffic; labellen = sizeof(client_handshake_traffic) - 1; } else { int hashleni; insecret = s->session->master_key; label = client_application_traffic; labellen = sizeof(client_application_traffic) - 1; hash = s->server_finished_hash; hashleni = EVP_MD_CTX_size(s->s3->handshake_dgst); if (hashleni < 0) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } hashlen = (size_t)hashleni; } } else { if (which & SSL3_CC_HANDSHAKE) { insecret = s->handshake_secret; finsecret = s->server_finished_secret; finsecretlen = EVP_MD_size(ssl_handshake_md(s)); label = server_handshake_traffic; labellen = sizeof(server_handshake_traffic) - 1; } else { insecret = s->session->master_key; label = server_application_traffic; labellen = sizeof(server_application_traffic) - 1; } } if (label != client_application_traffic) { if (!ssl3_digest_cached_records(s, 1) || !ssl_handshake_hash(s, hash, sizeof(hashval), &hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } if (label == server_application_traffic) memcpy(s->server_finished_hash, hash, hashlen); } if (!tls13_hkdf_expand(s, insecret, label, labellen, hash, secret, hashlen)) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } keylen = EVP_CIPHER_key_length(ciph); ivlen = EVP_CIPHER_iv_length(ciph); if (!tls13_derive_key(s, secret, key, keylen) || !tls13_derive_iv(s, secret, iv, ivlen) || (finsecret != NULL && !tls13_derive_finishedkey(s, secret, finsecret, finsecretlen))) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR); goto err; } if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, key, NULL, (which & SSL3_CC_WRITE)) <= 0) { SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_EVP_LIB); goto err; } #ifdef OPENSSL_SSL_TRACE_CRYPTO if (s->msg_callback) { int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0; if (ciph->key_len) s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY, key, ciph->key_len, s, s->msg_callback_arg); wh |= TLS1_RT_CRYPTO_IV; s->msg_callback(2, s->version, wh, iv, ivlen, s, s->msg_callback_arg); } #endif ret = 1; err: OPENSSL_cleanse(secret, sizeof(secret)); OPENSSL_cleanse(key, sizeof(key)); return ret; }"
4810----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_4ab9ec895c0e9fc23db97c4ee05c5a90aea7d53c_1.json----close_connection,"static void close_connection(struct connection * c) { if (c->read == 0 && c->keepalive) { if (good) good--; } else { if (good == 1) { doclen = c->bread; } else if (c->bread != doclen) { bad++; err_length++; } if (done < requests) { <S2SV_StartVul> struct data s; <S2SV_EndVul> <S2SV_StartVul> if ((done) && heartbeatres && !(done % heartbeatres)) { <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""Completed %ld requests\n"", done); <S2SV_EndVul> fflush(stderr); } <S2SV_StartVul> c->done = apr_time_now(); <S2SV_EndVul> <S2SV_StartVul> s.read = c->read; <S2SV_EndVul> <S2SV_StartVul> s.starttime = c->start; <S2SV_EndVul> <S2SV_StartVul> s.ctime = ap_max(0, (c->connect - c->start) / 1000); <S2SV_EndVul> <S2SV_StartVul> s.time = ap_max(0, (c->done - c->start) / 1000); <S2SV_EndVul> <S2SV_StartVul> s.waittime = ap_max(0, (c->beginread - c->endwrite) / 1000); <S2SV_EndVul> <S2SV_StartVul> stats[done++] = s; <S2SV_EndVul> } } { apr_pollfd_t remove_pollfd; remove_pollfd.desc_type = APR_POLL_SOCKET; remove_pollfd.desc.s = c->aprsock; apr_pollset_remove(readbits, &remove_pollfd); #ifdef USE_SSL if (c->ssl) { SSL_shutdown(c->ssl); SSL_free(c->ssl); c->ssl = NULL; } #endif apr_socket_close(c->aprsock); } c->state = STATE_UNCONNECTED; start_connect(c); return; }","- struct data s;
- if ((done) && heartbeatres && !(done % heartbeatres)) {
- fprintf(stderr, ""Completed %ld requests\n"", done);
- c->done = apr_time_now();
- s.read = c->read;
- s.starttime = c->start;
- s.ctime = ap_max(0, (c->connect - c->start) / 1000);
- s.time = ap_max(0, (c->done - c->start) / 1000);
- s.waittime = ap_max(0, (c->beginread - c->endwrite) / 1000);
- stats[done++] = s;
+ struct data *s = &stats[done++];
+ c->done = lasttime = apr_time_now();
+ s->starttime = c->start;
+ s->ctime = ap_max(0, c->connect - c->start);
+ s->time = ap_max(0, c->done - c->start);
+ s->waittime = ap_max(0, c->beginread - c->endwrite);
+ if (heartbeatres && !(done % heartbeatres)) {
+ fprintf(stderr, ""Completed %d requests\n"", done);","static void close_connection(struct connection * c) { if (c->read == 0 && c->keepalive) { if (good) good--; } else { if (good == 1) { doclen = c->bread; } else if (c->bread != doclen) { bad++; err_length++; } if (done < requests) { struct data *s = &stats[done++]; c->done = lasttime = apr_time_now(); s->starttime = c->start; s->ctime = ap_max(0, c->connect - c->start); s->time = ap_max(0, c->done - c->start); s->waittime = ap_max(0, c->beginread - c->endwrite); if (heartbeatres && !(done % heartbeatres)) { fprintf(stderr, ""Completed %d requests\n"", done); fflush(stderr); } } } { apr_pollfd_t remove_pollfd; remove_pollfd.desc_type = APR_POLL_SOCKET; remove_pollfd.desc.s = c->aprsock; apr_pollset_remove(readbits, &remove_pollfd); #ifdef USE_SSL if (c->ssl) { SSL_shutdown(c->ssl); SSL_free(c->ssl); c->ssl = NULL; } #endif apr_socket_close(c->aprsock); } c->state = STATE_UNCONNECTED; start_connect(c); return; }"
1535----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_554330e3fa92f3008f5301a523363dbdf3a0f070_1.json----decode_nal_sei_prefix,"static int decode_nal_sei_prefix(GetBitContext *gb, HEVCSEIContext *s, const HEVCParamSets *ps, int type, int size, void *logctx) { switch (type) { case 256: return decode_nal_sei_decoded_picture_hash(&s->picture_hash, gb); case HEVC_SEI_TYPE_FRAME_PACKING: return decode_nal_sei_frame_packing_arrangement(&s->frame_packing, gb); case HEVC_SEI_TYPE_DISPLAY_ORIENTATION: return decode_nal_sei_display_orientation(&s->display_orientation, gb); case HEVC_SEI_TYPE_PICTURE_TIMING: <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> int ret = decode_pic_timing(s, gb, ps, logctx); <S2SV_EndVul> <S2SV_StartVul> av_log(logctx, AV_LOG_DEBUG, ""Skipped PREFIX SEI %d\n"", type); <S2SV_EndVul> <S2SV_StartVul> skip_bits(gb, 8 * size); <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> case HEVC_SEI_TYPE_MASTERING_DISPLAY_INFO: return decode_nal_sei_mastering_display_info(&s->mastering_display, gb); case HEVC_SEI_TYPE_CONTENT_LIGHT_LEVEL_INFO: return decode_nal_sei_content_light_info(&s->content_light, gb); case HEVC_SEI_TYPE_ACTIVE_PARAMETER_SETS: active_parameter_sets(s, gb, logctx); av_log(logctx, AV_LOG_DEBUG, ""Skipped PREFIX SEI %d\n"", type); return 0; case HEVC_SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35: return decode_nal_sei_user_data_registered_itu_t_t35(s, gb, size); default: av_log(logctx, AV_LOG_DEBUG, ""Skipped PREFIX SEI %d\n"", type); skip_bits_long(gb, 8 * size); return 0; } }","- {
- int ret = decode_pic_timing(s, gb, ps, logctx);
- av_log(logctx, AV_LOG_DEBUG, ""Skipped PREFIX SEI %d\n"", type);
- skip_bits(gb, 8 * size);
- return ret;
- }
+ return decode_nal_sei_pic_timing(s, gb, ps, logctx, size);","static int decode_nal_sei_prefix(GetBitContext *gb, HEVCSEIContext *s, const HEVCParamSets *ps, int type, int size, void *logctx) { switch (type) { case 256: return decode_nal_sei_decoded_picture_hash(&s->picture_hash, gb); case HEVC_SEI_TYPE_FRAME_PACKING: return decode_nal_sei_frame_packing_arrangement(&s->frame_packing, gb); case HEVC_SEI_TYPE_DISPLAY_ORIENTATION: return decode_nal_sei_display_orientation(&s->display_orientation, gb); case HEVC_SEI_TYPE_PICTURE_TIMING: return decode_nal_sei_pic_timing(s, gb, ps, logctx, size); case HEVC_SEI_TYPE_MASTERING_DISPLAY_INFO: return decode_nal_sei_mastering_display_info(&s->mastering_display, gb); case HEVC_SEI_TYPE_CONTENT_LIGHT_LEVEL_INFO: return decode_nal_sei_content_light_info(&s->content_light, gb); case HEVC_SEI_TYPE_ACTIVE_PARAMETER_SETS: active_parameter_sets(s, gb, logctx); av_log(logctx, AV_LOG_DEBUG, ""Skipped PREFIX SEI %d\n"", type); return 0; case HEVC_SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35: return decode_nal_sei_user_data_registered_itu_t_t35(s, gb, size); default: av_log(logctx, AV_LOG_DEBUG, ""Skipped PREFIX SEI %d\n"", type); skip_bits_long(gb, 8 * size); return 0; } }"
10077----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_8f9848f4746988cfd7bb0007b847de5dbd43eb06_1.json----ngx_http_upstream_cache,"static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r, ngx_http_upstream_t *u) { ngx_int_t rc; ngx_http_cache_t *c; ngx_http_file_cache_t *cache; c = r->cache; if (c == NULL) { if (!(r->method & u->conf->cache_methods)) { return NGX_DECLINED; } rc = ngx_http_upstream_cache_get(r, u, &cache); if (rc != NGX_OK) { return rc; } if (r->method & NGX_HTTP_HEAD) { u->method = ngx_http_core_get_method; } if (ngx_http_file_cache_new(r) != NGX_OK) { return NGX_ERROR; } if (u->create_key(r) != NGX_OK) { return NGX_ERROR; } ngx_http_file_cache_create_key(r); if (r->cache->header_start + 256 >= u->conf->buffer_size) { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""%V_buffer_size %uz is not enough for cache key, "" ""it should be increased to at least %uz"", &u->conf->module, u->conf->buffer_size, ngx_align(r->cache->header_start + 256, 1024)); r->cache = NULL; return NGX_DECLINED; } u->cacheable = 1; c = r->cache; c->body_start = u->conf->buffer_size; c->min_uses = u->conf->cache_min_uses; c->file_cache = cache; switch (ngx_http_test_predicates(r, u->conf->cache_bypass)) { case NGX_ERROR: return NGX_ERROR; case NGX_DECLINED: u->cache_status = NGX_HTTP_CACHE_BYPASS; return NGX_DECLINED; default: break; } c->lock = u->conf->cache_lock; c->lock_timeout = u->conf->cache_lock_timeout; c->lock_age = u->conf->cache_lock_age; u->cache_status = NGX_HTTP_CACHE_MISS; } rc = ngx_http_file_cache_open(r); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream cache: %i"", rc); switch (rc) { case NGX_HTTP_CACHE_UPDATING: if (u->conf->cache_use_stale & NGX_HTTP_UPSTREAM_FT_UPDATING) { u->cache_status = rc; rc = NGX_OK; } else { rc = NGX_HTTP_CACHE_STALE; } break; case NGX_OK: u->cache_status = NGX_HTTP_CACHE_HIT; } switch (rc) { case NGX_OK: <S2SV_StartVul> rc = ngx_http_upstream_cache_send(r, u); <S2SV_EndVul> <S2SV_StartVul> if (rc != NGX_HTTP_UPSTREAM_INVALID_HEADER) { <S2SV_EndVul> <S2SV_StartVul> return rc; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> case NGX_HTTP_CACHE_STALE: c->valid_sec = 0; u->buffer.start = NULL; u->cache_status = NGX_HTTP_CACHE_EXPIRED; break; case NGX_DECLINED: if ((size_t) (u->buffer.end - u->buffer.start) < u->conf->buffer_size) { u->buffer.start = NULL; } else { u->buffer.pos = u->buffer.start + c->header_start; u->buffer.last = u->buffer.pos; } break; case NGX_HTTP_CACHE_SCARCE: u->cacheable = 0; break; case NGX_AGAIN: return NGX_BUSY; case NGX_ERROR: return NGX_ERROR; default: u->cache_status = NGX_HTTP_CACHE_HIT; return rc; } r->cached = 0; return NGX_DECLINED; }","- rc = ngx_http_upstream_cache_send(r, u);
- if (rc != NGX_HTTP_UPSTREAM_INVALID_HEADER) {
- return rc;
- }
- break;
+ return NGX_OK;","static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r, ngx_http_upstream_t *u) { ngx_int_t rc; ngx_http_cache_t *c; ngx_http_file_cache_t *cache; c = r->cache; if (c == NULL) { if (!(r->method & u->conf->cache_methods)) { return NGX_DECLINED; } rc = ngx_http_upstream_cache_get(r, u, &cache); if (rc != NGX_OK) { return rc; } if (r->method & NGX_HTTP_HEAD) { u->method = ngx_http_core_get_method; } if (ngx_http_file_cache_new(r) != NGX_OK) { return NGX_ERROR; } if (u->create_key(r) != NGX_OK) { return NGX_ERROR; } ngx_http_file_cache_create_key(r); if (r->cache->header_start + 256 >= u->conf->buffer_size) { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, ""%V_buffer_size %uz is not enough for cache key, "" ""it should be increased to at least %uz"", &u->conf->module, u->conf->buffer_size, ngx_align(r->cache->header_start + 256, 1024)); r->cache = NULL; return NGX_DECLINED; } u->cacheable = 1; c = r->cache; c->body_start = u->conf->buffer_size; c->min_uses = u->conf->cache_min_uses; c->file_cache = cache; switch (ngx_http_test_predicates(r, u->conf->cache_bypass)) { case NGX_ERROR: return NGX_ERROR; case NGX_DECLINED: u->cache_status = NGX_HTTP_CACHE_BYPASS; return NGX_DECLINED; default: break; } c->lock = u->conf->cache_lock; c->lock_timeout = u->conf->cache_lock_timeout; c->lock_age = u->conf->cache_lock_age; u->cache_status = NGX_HTTP_CACHE_MISS; } rc = ngx_http_file_cache_open(r); ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http upstream cache: %i"", rc); switch (rc) { case NGX_HTTP_CACHE_UPDATING: if (u->conf->cache_use_stale & NGX_HTTP_UPSTREAM_FT_UPDATING) { u->cache_status = rc; rc = NGX_OK; } else { rc = NGX_HTTP_CACHE_STALE; } break; case NGX_OK: u->cache_status = NGX_HTTP_CACHE_HIT; } switch (rc) { case NGX_OK: return NGX_OK; case NGX_HTTP_CACHE_STALE: c->valid_sec = 0; u->buffer.start = NULL; u->cache_status = NGX_HTTP_CACHE_EXPIRED; break; case NGX_DECLINED: if ((size_t) (u->buffer.end - u->buffer.start) < u->conf->buffer_size) { u->buffer.start = NULL; } else { u->buffer.pos = u->buffer.start + c->header_start; u->buffer.last = u->buffer.pos; } break; case NGX_HTTP_CACHE_SCARCE: u->cacheable = 0; break; case NGX_AGAIN: return NGX_BUSY; case NGX_ERROR: return NGX_ERROR; default: u->cache_status = NGX_HTTP_CACHE_HIT; return rc; } r->cached = 0; return NGX_DECLINED; }"
102----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0622d7dc4c79e86847c3d80471e7f4c81bcd7bbd_1.json----flac_decode_frame,"static int flac_decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size) { FLACContext *s = avctx->priv_data; int tmp = 0, i, j = 0, input_buf_size = 0; int16_t *samples_16 = data; int32_t *samples_32 = data; int alloc_data_size= *data_size; *data_size=0; if (s->max_framesize == 0) { s->max_framesize= FFMAX(4, buf_size); s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize); } if (1 && s->max_framesize) { if (s->bitstream_size < 4 || AV_RL32(s->bitstream) != MKTAG('f','L','a','C')) buf_size= FFMIN(buf_size, s->max_framesize - FFMIN(s->bitstream_size, s->max_framesize)); input_buf_size= buf_size; if (s->bitstream_size + buf_size < buf_size || s->bitstream_index + s->bitstream_size + buf_size < s->bitstream_index) return -1; if (s->allocated_bitstream_size < s->bitstream_size + buf_size) s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->bitstream_size + buf_size); if (s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size) { memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size); s->bitstream_index=0; } memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size); buf= &s->bitstream[s->bitstream_index]; buf_size += s->bitstream_size; s->bitstream_size= buf_size; if (buf_size < s->max_framesize && input_buf_size) { return input_buf_size; } } init_get_bits(&s->gb, buf, buf_size*8); <S2SV_StartVul> if (metadata_parse(s)) <S2SV_EndVul> goto end; tmp = show_bits(&s->gb, 16); if ((tmp & 0xFFFE) != 0xFFF8) { av_log(s->avctx, AV_LOG_ERROR, ""FRAME HEADER not here\n""); while (get_bits_count(&s->gb)/8+2 < buf_size && (show_bits(&s->gb, 16) & 0xFFFE) != 0xFFF8) skip_bits(&s->gb, 8); goto end; } skip_bits(&s->gb, 16); if (decode_frame(s, alloc_data_size) < 0) { av_log(s->avctx, AV_LOG_ERROR, ""decode_frame() failed\n""); s->bitstream_size=0; s->bitstream_index=0; return -1; } #define DECORRELATE(left,right) \ assert(s->channels == 2);\ for (i = 0; i < s->blocksize; i++) {\ int a= s->decoded[0][i];\ int b= s->decoded[1][i];\ if (s->is32) {\ *samples_32++ = (left) << s->sample_shift;\ *samples_32++ = (right) << s->sample_shift;\ } else {\ *samples_16++ = (left) << s->sample_shift;\ *samples_16++ = (right) << s->sample_shift;\ }\ }\ break; switch (s->decorrelation) { case INDEPENDENT: for (j = 0; j < s->blocksize; j++) { for (i = 0; i < s->channels; i++) { if (s->is32) *samples_32++ = s->decoded[i][j] << s->sample_shift; else *samples_16++ = s->decoded[i][j] << s->sample_shift; } } break; case LEFT_SIDE: DECORRELATE(a,a-b) case RIGHT_SIDE: DECORRELATE(a+b,b) case MID_SIDE: DECORRELATE( (a-=b>>1) + b, a) } *data_size = s->blocksize * s->channels * (s->is32 ? 4 : 2); end: i= (get_bits_count(&s->gb)+7)/8; if (i > buf_size) { av_log(s->avctx, AV_LOG_ERROR, ""overread: %d\n"", i - buf_size); s->bitstream_size=0; s->bitstream_index=0; return -1; } if (s->bitstream_size) { s->bitstream_index += i; s->bitstream_size -= i; return input_buf_size; } else return i; }","- if (metadata_parse(s))
+ if (show_bits_long(&s->gb, 32) == MKBETAG('f','L','a','C')) {
+ if (metadata_parse(s)) {
+ av_log(s->avctx, AV_LOG_ERROR, ""invalid header\n"");
+ return -1;
+ }
+ }","static int flac_decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size) { FLACContext *s = avctx->priv_data; int tmp = 0, i, j = 0, input_buf_size = 0; int16_t *samples_16 = data; int32_t *samples_32 = data; int alloc_data_size= *data_size; *data_size=0; if (s->max_framesize == 0) { s->max_framesize= FFMAX(4, buf_size); s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize); } if (1 && s->max_framesize) { if (s->bitstream_size < 4 || AV_RL32(s->bitstream) != MKTAG('f','L','a','C')) buf_size= FFMIN(buf_size, s->max_framesize - FFMIN(s->bitstream_size, s->max_framesize)); input_buf_size= buf_size; if (s->bitstream_size + buf_size < buf_size || s->bitstream_index + s->bitstream_size + buf_size < s->bitstream_index) return -1; if (s->allocated_bitstream_size < s->bitstream_size + buf_size) s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->bitstream_size + buf_size); if (s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size) { memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size); s->bitstream_index=0; } memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size); buf= &s->bitstream[s->bitstream_index]; buf_size += s->bitstream_size; s->bitstream_size= buf_size; if (buf_size < s->max_framesize && input_buf_size) { return input_buf_size; } } init_get_bits(&s->gb, buf, buf_size*8); if (show_bits_long(&s->gb, 32) == MKBETAG('f','L','a','C')) { if (metadata_parse(s)) { av_log(s->avctx, AV_LOG_ERROR, ""invalid header\n""); return -1; } goto end; } tmp = show_bits(&s->gb, 16); if ((tmp & 0xFFFE) != 0xFFF8) { av_log(s->avctx, AV_LOG_ERROR, ""FRAME HEADER not here\n""); while (get_bits_count(&s->gb)/8+2 < buf_size && (show_bits(&s->gb, 16) & 0xFFFE) != 0xFFF8) skip_bits(&s->gb, 8); goto end; } skip_bits(&s->gb, 16); if (decode_frame(s, alloc_data_size) < 0) { av_log(s->avctx, AV_LOG_ERROR, ""decode_frame() failed\n""); s->bitstream_size=0; s->bitstream_index=0; return -1; } #define DECORRELATE(left,right) \ assert(s->channels == 2);\ for (i = 0; i < s->blocksize; i++) {\ int a= s->decoded[0][i];\ int b= s->decoded[1][i];\ if (s->is32) {\ *samples_32++ = (left) << s->sample_shift;\ *samples_32++ = (right) << s->sample_shift;\ } else {\ *samples_16++ = (left) << s->sample_shift;\ *samples_16++ = (right) << s->sample_shift;\ }\ }\ break; switch (s->decorrelation) { case INDEPENDENT: for (j = 0; j < s->blocksize; j++) { for (i = 0; i < s->channels; i++) { if (s->is32) *samples_32++ = s->decoded[i][j] << s->sample_shift; else *samples_16++ = s->decoded[i][j] << s->sample_shift; } } break; case LEFT_SIDE: DECORRELATE(a,a-b) case RIGHT_SIDE: DECORRELATE(a+b,b) case MID_SIDE: DECORRELATE( (a-=b>>1) + b, a) } *data_size = s->blocksize * s->channels * (s->is32 ? 4 : 2); end: i= (get_bits_count(&s->gb)+7)/8; if (i > buf_size) { av_log(s->avctx, AV_LOG_ERROR, ""overread: %d\n"", i - buf_size); s->bitstream_size=0; s->bitstream_index=0; return -1; } if (s->bitstream_size) { s->bitstream_index += i; s->bitstream_size -= i; return input_buf_size; } else return i; }"
1481----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_522650996eeef4469dfee007d251619c2cc10442_1.json----scaling_list_data,"static int scaling_list_data(GetBitContext *gb, AVCodecContext *avctx, ScalingList *sl, HEVCSPS *sps) { uint8_t scaling_list_pred_mode_flag; int32_t scaling_list_dc_coef[2][6]; int size_id, matrix_id, pos; int i; for (size_id = 0; size_id < 4; size_id++) for (matrix_id = 0; matrix_id < 6; matrix_id += ((size_id == 3) ? 3 : 1)) { scaling_list_pred_mode_flag = get_bits1(gb); if (!scaling_list_pred_mode_flag) { unsigned int delta = get_ue_golomb_long(gb); if (delta) { if (matrix_id < delta) { av_log(avctx, AV_LOG_ERROR, ""Invalid delta in scaling list data: %d.\n"", delta); return AVERROR_INVALIDDATA; } memcpy(sl->sl[size_id][matrix_id], sl->sl[size_id][matrix_id - delta], size_id > 0 ? 64 : 16); if (size_id > 1) sl->sl_dc[size_id - 2][matrix_id] = sl->sl_dc[size_id - 2][matrix_id - delta]; } } else { int next_coef, coef_num; int32_t scaling_list_delta_coef; next_coef = 8; coef_num = FFMIN(64, 1 << (4 + (size_id << 1))); if (size_id > 1) { scaling_list_dc_coef[size_id - 2][matrix_id] = get_se_golomb(gb) + 8; next_coef = scaling_list_dc_coef[size_id - 2][matrix_id]; sl->sl_dc[size_id - 2][matrix_id] = next_coef; } for (i = 0; i < coef_num; i++) { if (size_id == 0) pos = 4 * ff_hevc_diag_scan4x4_y[i] + ff_hevc_diag_scan4x4_x[i]; else pos = 8 * ff_hevc_diag_scan8x8_y[i] + ff_hevc_diag_scan8x8_x[i]; scaling_list_delta_coef = get_se_golomb(gb); <S2SV_StartVul> next_coef = (next_coef + scaling_list_delta_coef + 256) % 256; <S2SV_EndVul> sl->sl[size_id][matrix_id][pos] = next_coef; } } } if (sps->chroma_format_idc == 3) { for (i = 0; i < 64; i++) { sl->sl[3][1][i] = sl->sl[2][1][i]; sl->sl[3][2][i] = sl->sl[2][2][i]; sl->sl[3][4][i] = sl->sl[2][4][i]; sl->sl[3][5][i] = sl->sl[2][5][i]; } sl->sl_dc[1][1] = sl->sl_dc[0][1]; sl->sl_dc[1][2] = sl->sl_dc[0][2]; sl->sl_dc[1][4] = sl->sl_dc[0][4]; sl->sl_dc[1][5] = sl->sl_dc[0][5]; } return 0; }","- next_coef = (next_coef + scaling_list_delta_coef + 256) % 256;
+ next_coef = (next_coef + 256U + scaling_list_delta_coef) % 256;","static int scaling_list_data(GetBitContext *gb, AVCodecContext *avctx, ScalingList *sl, HEVCSPS *sps) { uint8_t scaling_list_pred_mode_flag; int32_t scaling_list_dc_coef[2][6]; int size_id, matrix_id, pos; int i; for (size_id = 0; size_id < 4; size_id++) for (matrix_id = 0; matrix_id < 6; matrix_id += ((size_id == 3) ? 3 : 1)) { scaling_list_pred_mode_flag = get_bits1(gb); if (!scaling_list_pred_mode_flag) { unsigned int delta = get_ue_golomb_long(gb); if (delta) { if (matrix_id < delta) { av_log(avctx, AV_LOG_ERROR, ""Invalid delta in scaling list data: %d.\n"", delta); return AVERROR_INVALIDDATA; } memcpy(sl->sl[size_id][matrix_id], sl->sl[size_id][matrix_id - delta], size_id > 0 ? 64 : 16); if (size_id > 1) sl->sl_dc[size_id - 2][matrix_id] = sl->sl_dc[size_id - 2][matrix_id - delta]; } } else { int next_coef, coef_num; int32_t scaling_list_delta_coef; next_coef = 8; coef_num = FFMIN(64, 1 << (4 + (size_id << 1))); if (size_id > 1) { scaling_list_dc_coef[size_id - 2][matrix_id] = get_se_golomb(gb) + 8; next_coef = scaling_list_dc_coef[size_id - 2][matrix_id]; sl->sl_dc[size_id - 2][matrix_id] = next_coef; } for (i = 0; i < coef_num; i++) { if (size_id == 0) pos = 4 * ff_hevc_diag_scan4x4_y[i] + ff_hevc_diag_scan4x4_x[i]; else pos = 8 * ff_hevc_diag_scan8x8_y[i] + ff_hevc_diag_scan8x8_x[i]; scaling_list_delta_coef = get_se_golomb(gb); next_coef = (next_coef + 256U + scaling_list_delta_coef) % 256; sl->sl[size_id][matrix_id][pos] = next_coef; } } } if (sps->chroma_format_idc == 3) { for (i = 0; i < 64; i++) { sl->sl[3][1][i] = sl->sl[2][1][i]; sl->sl[3][2][i] = sl->sl[2][2][i]; sl->sl[3][4][i] = sl->sl[2][4][i]; sl->sl[3][5][i] = sl->sl[2][5][i]; } sl->sl_dc[1][1] = sl->sl_dc[0][1]; sl->sl_dc[1][2] = sl->sl_dc[0][2]; sl->sl_dc[1][4] = sl->sl_dc[0][4]; sl->sl_dc[1][5] = sl->sl_dc[0][5]; } return 0; }"
9200----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fd35adafef2a16eb21f928ee5a058137470ec2e3_1.json----sws_alloc_context,SwsContext *sws_alloc_context(void) { SwsContext *c = av_mallocz(sizeof(SwsContext)); <S2SV_StartVul> c->av_class = &sws_context_class; <S2SV_EndVul> <S2SV_StartVul> av_opt_set_defaults(c); <S2SV_EndVul> return c; },"- c->av_class = &sws_context_class;
- av_opt_set_defaults(c);
+ if (c) {
+ c->av_class = &sws_context_class;
+ av_opt_set_defaults(c);
+ }",SwsContext *sws_alloc_context(void) { SwsContext *c = av_mallocz(sizeof(SwsContext)); if (c) { c->av_class = &sws_context_class; av_opt_set_defaults(c); } return c; }
8501----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d43bbcb985df21168006246469e8e49549944630_1.json----decode_frame,"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; VmncContext * const c = avctx->priv_data; GetByteContext *gb = &c->gb; uint8_t *outptr; int dx, dy, w, h, depth, enc, chunks, res, size_left, ret; if ((ret = ff_reget_buffer(avctx, &c->pic)) < 0) { av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n""); return ret; } bytestream2_init(gb, buf, buf_size); c->pic.key_frame = 0; c->pic.pict_type = AV_PICTURE_TYPE_P; if (c->screendta) { int i; w = c->cur_w; if (c->width < c->cur_x + w) w = c->width - c->cur_x; h = c->cur_h; if (c->height < c->cur_y + h) h = c->height - c->cur_y; dx = c->cur_x; if (dx < 0) { w += dx; dx = 0; } dy = c->cur_y; if (dy < 0) { h += dy; dy = 0; } if ((w > 0) && (h > 0)) { outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0]; for (i = 0; i < h; i++) { memcpy(outptr, c->screendta + i * c->cur_w * c->bpp2, w * c->bpp2); outptr += c->pic.linesize[0]; } } } bytestream2_skip(gb, 2); chunks = bytestream2_get_be16(gb); while (chunks--) { dx = bytestream2_get_be16(gb); dy = bytestream2_get_be16(gb); w = bytestream2_get_be16(gb); h = bytestream2_get_be16(gb); enc = bytestream2_get_be32(gb); outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0]; size_left = bytestream2_get_bytes_left(gb); switch (enc) { case MAGIC_WMVd: if (size_left < 2 + w * h * c->bpp2 * 2) { av_log(avctx, AV_LOG_ERROR, ""Premature end of data! (need %i got %i)\n"", 2 + w * h * c->bpp2 * 2, size_left); return -1; } bytestream2_skip(gb, 2); c->cur_w = w; c->cur_h = h; c->cur_hx = dx; c->cur_hy = dy; if ((c->cur_hx > c->cur_w) || (c->cur_hy > c->cur_h)) { av_log(avctx, AV_LOG_ERROR, ""Cursor hot spot is not in image: "" ""%ix%i of %ix%i cursor size\n"", c->cur_hx, c->cur_hy, c->cur_w, c->cur_h); c->cur_hx = c->cur_hy = 0; } <S2SV_StartVul> c->curbits = av_realloc(c->curbits, c->cur_w * c->cur_h * c->bpp2); <S2SV_EndVul> <S2SV_StartVul> c->curmask = av_realloc(c->curmask, c->cur_w * c->cur_h * c->bpp2); <S2SV_EndVul> <S2SV_StartVul> c->screendta = av_realloc(c->screendta, c->cur_w * c->cur_h * c->bpp2); <S2SV_EndVul> load_cursor(c); break; case MAGIC_WMVe: bytestream2_skip(gb, 2); break; case MAGIC_WMVf: c->cur_x = dx - c->cur_hx; c->cur_y = dy - c->cur_hy; break; case MAGIC_WMVg: bytestream2_skip(gb, 10); break; case MAGIC_WMVh: bytestream2_skip(gb, 4); break; case MAGIC_WMVi: c->pic.key_frame = 1; c->pic.pict_type = AV_PICTURE_TYPE_I; depth = bytestream2_get_byte(gb); if (depth != c->bpp) { av_log(avctx, AV_LOG_INFO, ""Depth mismatch. Container %i bpp, "" ""Frame data: %i bpp\n"", c->bpp, depth); } bytestream2_skip(gb, 1); c->bigendian = bytestream2_get_byte(gb); if (c->bigendian & (~1)) { av_log(avctx, AV_LOG_INFO, ""Invalid header: bigendian flag = %i\n"", c->bigendian); return -1; } bytestream2_skip(gb, 13); break; case MAGIC_WMVj: bytestream2_skip(gb, 2); break; case 0x00000000: if ((dx + w > c->width) || (dy + h > c->height)) { av_log(avctx, AV_LOG_ERROR, ""Incorrect frame size: %ix%i+%ix%i of %ix%i\n"", w, h, dx, dy, c->width, c->height); return -1; } if (size_left < w * h * c->bpp2) { av_log(avctx, AV_LOG_ERROR, ""Premature end of data! (need %i got %i)\n"", w * h * c->bpp2, size_left); return -1; } paint_raw(outptr, w, h, gb, c->bpp2, c->bigendian, c->pic.linesize[0]); break; case 0x00000005: if ((dx + w > c->width) || (dy + h > c->height)) { av_log(avctx, AV_LOG_ERROR, ""Incorrect frame size: %ix%i+%ix%i of %ix%i\n"", w, h, dx, dy, c->width, c->height); return -1; } res = decode_hextile(c, outptr, gb, w, h, c->pic.linesize[0]); if (res < 0) return -1; break; default: av_log(avctx, AV_LOG_ERROR, ""Unsupported block type 0x%08X\n"", enc); chunks = 0; } } if (c->screendta) { int i; w = c->cur_w; if (c->width < c->cur_x + w) w = c->width - c->cur_x; h = c->cur_h; if (c->height < c->cur_y + h) h = c->height - c->cur_y; dx = c->cur_x; if (dx < 0) { w += dx; dx = 0; } dy = c->cur_y; if (dy < 0) { h += dy; dy = 0; } if ((w > 0) && (h > 0)) { outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0]; for (i = 0; i < h; i++) { memcpy(c->screendta + i * c->cur_w * c->bpp2, outptr, w * c->bpp2); outptr += c->pic.linesize[0]; } outptr = c->pic.data[0]; put_cursor(outptr, c->pic.linesize[0], c, c->cur_x, c->cur_y); } } *got_frame = 1; if ((ret = av_frame_ref(data, &c->pic)) < 0) return ret; return buf_size; }","- c->curbits = av_realloc(c->curbits, c->cur_w * c->cur_h * c->bpp2);
- c->curmask = av_realloc(c->curmask, c->cur_w * c->cur_h * c->bpp2);
- c->screendta = av_realloc(c->screendta, c->cur_w * c->cur_h * c->bpp2);
+ if (c->cur_w * c->cur_h >= INT_MAX / c->bpp2) {
+ reset_buffers(c);
+ return AVERROR(EINVAL);
+ } else {
+ int screen_size = c->cur_w * c->cur_h * c->bpp2;
+ if ((ret = av_reallocp(&c->curbits, screen_size)) < 0 ||
+ (ret = av_reallocp(&c->curmask, screen_size)) < 0 ||
+ (ret = av_reallocp(&c->screendta, screen_size)) < 0) {
+ reset_buffers(c);
+ return ret;
+ }
+ }","static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; VmncContext * const c = avctx->priv_data; GetByteContext *gb = &c->gb; uint8_t *outptr; int dx, dy, w, h, depth, enc, chunks, res, size_left, ret; if ((ret = ff_reget_buffer(avctx, &c->pic)) < 0) { av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n""); return ret; } bytestream2_init(gb, buf, buf_size); c->pic.key_frame = 0; c->pic.pict_type = AV_PICTURE_TYPE_P; if (c->screendta) { int i; w = c->cur_w; if (c->width < c->cur_x + w) w = c->width - c->cur_x; h = c->cur_h; if (c->height < c->cur_y + h) h = c->height - c->cur_y; dx = c->cur_x; if (dx < 0) { w += dx; dx = 0; } dy = c->cur_y; if (dy < 0) { h += dy; dy = 0; } if ((w > 0) && (h > 0)) { outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0]; for (i = 0; i < h; i++) { memcpy(outptr, c->screendta + i * c->cur_w * c->bpp2, w * c->bpp2); outptr += c->pic.linesize[0]; } } } bytestream2_skip(gb, 2); chunks = bytestream2_get_be16(gb); while (chunks--) { dx = bytestream2_get_be16(gb); dy = bytestream2_get_be16(gb); w = bytestream2_get_be16(gb); h = bytestream2_get_be16(gb); enc = bytestream2_get_be32(gb); outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0]; size_left = bytestream2_get_bytes_left(gb); switch (enc) { case MAGIC_WMVd: if (size_left < 2 + w * h * c->bpp2 * 2) { av_log(avctx, AV_LOG_ERROR, ""Premature end of data! (need %i got %i)\n"", 2 + w * h * c->bpp2 * 2, size_left); return -1; } bytestream2_skip(gb, 2); c->cur_w = w; c->cur_h = h; c->cur_hx = dx; c->cur_hy = dy; if ((c->cur_hx > c->cur_w) || (c->cur_hy > c->cur_h)) { av_log(avctx, AV_LOG_ERROR, ""Cursor hot spot is not in image: "" ""%ix%i of %ix%i cursor size\n"", c->cur_hx, c->cur_hy, c->cur_w, c->cur_h); c->cur_hx = c->cur_hy = 0; } if (c->cur_w * c->cur_h >= INT_MAX / c->bpp2) { reset_buffers(c); return AVERROR(EINVAL); } else { int screen_size = c->cur_w * c->cur_h * c->bpp2; if ((ret = av_reallocp(&c->curbits, screen_size)) < 0 || (ret = av_reallocp(&c->curmask, screen_size)) < 0 || (ret = av_reallocp(&c->screendta, screen_size)) < 0) { reset_buffers(c); return ret; } } load_cursor(c); break; case MAGIC_WMVe: bytestream2_skip(gb, 2); break; case MAGIC_WMVf: c->cur_x = dx - c->cur_hx; c->cur_y = dy - c->cur_hy; break; case MAGIC_WMVg: bytestream2_skip(gb, 10); break; case MAGIC_WMVh: bytestream2_skip(gb, 4); break; case MAGIC_WMVi: c->pic.key_frame = 1; c->pic.pict_type = AV_PICTURE_TYPE_I; depth = bytestream2_get_byte(gb); if (depth != c->bpp) { av_log(avctx, AV_LOG_INFO, ""Depth mismatch. Container %i bpp, "" ""Frame data: %i bpp\n"", c->bpp, depth); } bytestream2_skip(gb, 1); c->bigendian = bytestream2_get_byte(gb); if (c->bigendian & (~1)) { av_log(avctx, AV_LOG_INFO, ""Invalid header: bigendian flag = %i\n"", c->bigendian); return -1; } bytestream2_skip(gb, 13); break; case MAGIC_WMVj: bytestream2_skip(gb, 2); break; case 0x00000000: if ((dx + w > c->width) || (dy + h > c->height)) { av_log(avctx, AV_LOG_ERROR, ""Incorrect frame size: %ix%i+%ix%i of %ix%i\n"", w, h, dx, dy, c->width, c->height); return -1; } if (size_left < w * h * c->bpp2) { av_log(avctx, AV_LOG_ERROR, ""Premature end of data! (need %i got %i)\n"", w * h * c->bpp2, size_left); return -1; } paint_raw(outptr, w, h, gb, c->bpp2, c->bigendian, c->pic.linesize[0]); break; case 0x00000005: if ((dx + w > c->width) || (dy + h > c->height)) { av_log(avctx, AV_LOG_ERROR, ""Incorrect frame size: %ix%i+%ix%i of %ix%i\n"", w, h, dx, dy, c->width, c->height); return -1; } res = decode_hextile(c, outptr, gb, w, h, c->pic.linesize[0]); if (res < 0) return -1; break; default: av_log(avctx, AV_LOG_ERROR, ""Unsupported block type 0x%08X\n"", enc); chunks = 0; } } if (c->screendta) { int i; w = c->cur_w; if (c->width < c->cur_x + w) w = c->width - c->cur_x; h = c->cur_h; if (c->height < c->cur_y + h) h = c->height - c->cur_y; dx = c->cur_x; if (dx < 0) { w += dx; dx = 0; } dy = c->cur_y; if (dy < 0) { h += dy; dy = 0; } if ((w > 0) && (h > 0)) { outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0]; for (i = 0; i < h; i++) { memcpy(c->screendta + i * c->cur_w * c->bpp2, outptr, w * c->bpp2); outptr += c->pic.linesize[0]; } outptr = c->pic.data[0]; put_cursor(outptr, c->pic.linesize[0], c, c->cur_x, c->cur_y); } } *got_frame = 1; if ((ret = av_frame_ref(data, &c->pic)) < 0) return ret; return buf_size; }"
266----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_10377444b840149d827df9fc4e7e4a80554bf3c9_1.json----avi_write_header,"static int avi_write_header(AVFormatContext *s) { AVIContext *avi = s->priv_data; AVIOContext *pb = s->pb; int bitrate, n, i, nb_frames, au_byterate, au_ssize, au_scale; AVCodecParameters *video_par; AVStream *video_st = NULL; int64_t list1, list2, strh, strf; AVDictionaryEntry *t = NULL; if (s->nb_streams > AVI_MAX_STREAM_COUNT) { av_log(s, AV_LOG_ERROR, ""AVI does not support >%d streams\n"", AVI_MAX_STREAM_COUNT); return -1; } for (n = 0; n < s->nb_streams; n++) { s->streams[n]->priv_data = av_mallocz(sizeof(AVIStream)); if (!s->streams[n]->priv_data) return AVERROR(ENOMEM); } avi->riff_id = 0; list1 = avi_start_new_riff(s, pb, ""AVI "", ""hdrl""); ffio_wfourcc(pb, ""avih""); avio_wl32(pb, 14 * 4); bitrate = 0; video_par = NULL; for (n = 0; n < s->nb_streams; n++) { AVCodecParameters *par = s->streams[n]->codecpar; bitrate += par->bit_rate; if (par->codec_type == AVMEDIA_TYPE_VIDEO) { video_par = par; video_st = s->streams[n]; } } nb_frames = 0; if (video_st) avio_wl32(pb, (uint32_t) (INT64_C(1000000) * video_st->time_base.num / video_st->time_base.den)); else avio_wl32(pb, 0); avio_wl32(pb, bitrate / 8); avio_wl32(pb, 0); <S2SV_StartVul> if (!pb->seekable) <S2SV_EndVul> avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_ISINTERLEAVED); else avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_HASINDEX | AVIF_ISINTERLEAVED); avi->frames_hdr_all = avio_tell(pb); avio_wl32(pb, nb_frames); avio_wl32(pb, 0); avio_wl32(pb, s->nb_streams); avio_wl32(pb, 1024 * 1024); if (video_par) { avio_wl32(pb, video_par->width); avio_wl32(pb, video_par->height); } else { avio_wl32(pb, 0); avio_wl32(pb, 0); } avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); for (i = 0; i < n; i++) { AVStream *st = s->streams[i]; AVCodecParameters *par = st->codecpar; AVIStream *avist = st->priv_data; list2 = ff_start_tag(pb, ""LIST""); ffio_wfourcc(pb, ""strl""); strh = ff_start_tag(pb, ""strh""); switch (par->codec_type) { case AVMEDIA_TYPE_SUBTITLE: if (par->codec_id != AV_CODEC_ID_XSUB) { av_log(s, AV_LOG_ERROR, ""Subtitle streams other than DivX XSUB are not supported by the AVI muxer.\n""); return AVERROR_PATCHWELCOME; } case AVMEDIA_TYPE_VIDEO: ffio_wfourcc(pb, ""vids""); break; case AVMEDIA_TYPE_AUDIO: ffio_wfourcc(pb, ""auds""); break; case AVMEDIA_TYPE_DATA: ffio_wfourcc(pb, ""dats""); break; } if (par->codec_type == AVMEDIA_TYPE_VIDEO || par->codec_id == AV_CODEC_ID_XSUB) avio_wl32(pb, par->codec_tag); else avio_wl32(pb, 1); avio_wl32(pb, 0); avio_wl16(pb, 0); avio_wl16(pb, 0); avio_wl32(pb, 0); ff_parse_specific_params(st, &au_byterate, &au_ssize, &au_scale); avio_wl32(pb, au_scale); avio_wl32(pb, au_byterate); avpriv_set_pts_info(st, 64, au_scale, au_byterate); avio_wl32(pb, 0); avist->frames_hdr_strm = avio_tell(pb); <S2SV_StartVul> if (!pb->seekable) <S2SV_EndVul> avio_wl32(pb, AVI_MAX_RIFF_SIZE); else avio_wl32(pb, 0); if (par->codec_type == AVMEDIA_TYPE_VIDEO) avio_wl32(pb, 1024 * 1024); else if (par->codec_type == AVMEDIA_TYPE_AUDIO) avio_wl32(pb, 12 * 1024); else avio_wl32(pb, 0); avio_wl32(pb, -1); avio_wl32(pb, au_ssize); avio_wl32(pb, 0); avio_wl16(pb, par->width); avio_wl16(pb, par->height); ff_end_tag(pb, strh); if (par->codec_type != AVMEDIA_TYPE_DATA) { strf = ff_start_tag(pb, ""strf""); switch (par->codec_type) { case AVMEDIA_TYPE_SUBTITLE: if (par->codec_id != AV_CODEC_ID_XSUB) break; case AVMEDIA_TYPE_VIDEO: ff_put_bmp_header(pb, par, ff_codec_bmp_tags, 0); break; case AVMEDIA_TYPE_AUDIO: if (ff_put_wav_header(s, pb, par) < 0) return -1; break; default: return -1; } ff_end_tag(pb, strf); if ((t = av_dict_get(st->metadata, ""title"", NULL, 0))) { ff_riff_write_info_tag(s->pb, ""strn"", t->value); t = NULL; } } <S2SV_StartVul> if (pb->seekable) { <S2SV_EndVul> unsigned char tag[5]; int j; avist->indexes.entry = avist->indexes.ents_allocated = 0; avist->indexes.indx_start = ff_start_tag(pb, ""JUNK""); avio_wl16(pb, 4); avio_w8(pb, 0); avio_w8(pb, 0); avio_wl32(pb, 0); ffio_wfourcc(pb, avi_stream2fourcc(tag, i, par->codec_type)); avio_wl64(pb, 0); for (j = 0; j < AVI_MASTER_INDEX_SIZE * 2; j++) avio_wl64(pb, 0); ff_end_tag(pb, avist->indexes.indx_start); } if (par->codec_type == AVMEDIA_TYPE_VIDEO && st->sample_aspect_ratio.num > 0 && st->sample_aspect_ratio.den > 0) { int vprp = ff_start_tag(pb, ""vprp""); AVRational dar = av_mul_q(st->sample_aspect_ratio, (AVRational) { par->width, par->height }); int num, den; av_reduce(&num, &den, dar.num, dar.den, 0xFFFF); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, lrintf(1.0 / av_q2d(st->time_base))); avio_wl32(pb, par->width); avio_wl32(pb, par->height); avio_wl16(pb, den); avio_wl16(pb, num); avio_wl32(pb, par->width); avio_wl32(pb, par->height); avio_wl32(pb, 1); avio_wl32(pb, par->height); avio_wl32(pb, par->width); avio_wl32(pb, par->height); avio_wl32(pb, par->width); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); ff_end_tag(pb, vprp); } ff_end_tag(pb, list2); } <S2SV_StartVul> if (pb->seekable) { <S2SV_EndVul> avi->odml_list = ff_start_tag(pb, ""JUNK""); ffio_wfourcc(pb, ""odml""); ffio_wfourcc(pb, ""dmlh""); avio_wl32(pb, 248); for (i = 0; i < 248; i += 4) avio_wl32(pb, 0); ff_end_tag(pb, avi->odml_list); } ff_end_tag(pb, list1); ff_riff_write_info(s); list2 = ff_start_tag(pb, ""JUNK""); for (i = 0; i < 1016; i += 4) avio_wl32(pb, 0); ff_end_tag(pb, list2); avi->movi_list = ff_start_tag(pb, ""LIST""); ffio_wfourcc(pb, ""movi""); avio_flush(pb); return 0; }","- if (!pb->seekable)
- if (!pb->seekable)
- if (pb->seekable) {
- if (pb->seekable) {
+ if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))
+ if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))
+ if (pb->seekable & AVIO_SEEKABLE_NORMAL) {
+ if (pb->seekable & AVIO_SEEKABLE_NORMAL) {","static int avi_write_header(AVFormatContext *s) { AVIContext *avi = s->priv_data; AVIOContext *pb = s->pb; int bitrate, n, i, nb_frames, au_byterate, au_ssize, au_scale; AVCodecParameters *video_par; AVStream *video_st = NULL; int64_t list1, list2, strh, strf; AVDictionaryEntry *t = NULL; if (s->nb_streams > AVI_MAX_STREAM_COUNT) { av_log(s, AV_LOG_ERROR, ""AVI does not support >%d streams\n"", AVI_MAX_STREAM_COUNT); return -1; } for (n = 0; n < s->nb_streams; n++) { s->streams[n]->priv_data = av_mallocz(sizeof(AVIStream)); if (!s->streams[n]->priv_data) return AVERROR(ENOMEM); } avi->riff_id = 0; list1 = avi_start_new_riff(s, pb, ""AVI "", ""hdrl""); ffio_wfourcc(pb, ""avih""); avio_wl32(pb, 14 * 4); bitrate = 0; video_par = NULL; for (n = 0; n < s->nb_streams; n++) { AVCodecParameters *par = s->streams[n]->codecpar; bitrate += par->bit_rate; if (par->codec_type == AVMEDIA_TYPE_VIDEO) { video_par = par; video_st = s->streams[n]; } } nb_frames = 0; if (video_st) avio_wl32(pb, (uint32_t) (INT64_C(1000000) * video_st->time_base.num / video_st->time_base.den)); else avio_wl32(pb, 0); avio_wl32(pb, bitrate / 8); avio_wl32(pb, 0); if (!(pb->seekable & AVIO_SEEKABLE_NORMAL)) avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_ISINTERLEAVED); else avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_HASINDEX | AVIF_ISINTERLEAVED); avi->frames_hdr_all = avio_tell(pb); avio_wl32(pb, nb_frames); avio_wl32(pb, 0); avio_wl32(pb, s->nb_streams); avio_wl32(pb, 1024 * 1024); if (video_par) { avio_wl32(pb, video_par->width); avio_wl32(pb, video_par->height); } else { avio_wl32(pb, 0); avio_wl32(pb, 0); } avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); for (i = 0; i < n; i++) { AVStream *st = s->streams[i]; AVCodecParameters *par = st->codecpar; AVIStream *avist = st->priv_data; list2 = ff_start_tag(pb, ""LIST""); ffio_wfourcc(pb, ""strl""); strh = ff_start_tag(pb, ""strh""); switch (par->codec_type) { case AVMEDIA_TYPE_SUBTITLE: if (par->codec_id != AV_CODEC_ID_XSUB) { av_log(s, AV_LOG_ERROR, ""Subtitle streams other than DivX XSUB are not supported by the AVI muxer.\n""); return AVERROR_PATCHWELCOME; } case AVMEDIA_TYPE_VIDEO: ffio_wfourcc(pb, ""vids""); break; case AVMEDIA_TYPE_AUDIO: ffio_wfourcc(pb, ""auds""); break; case AVMEDIA_TYPE_DATA: ffio_wfourcc(pb, ""dats""); break; } if (par->codec_type == AVMEDIA_TYPE_VIDEO || par->codec_id == AV_CODEC_ID_XSUB) avio_wl32(pb, par->codec_tag); else avio_wl32(pb, 1); avio_wl32(pb, 0); avio_wl16(pb, 0); avio_wl16(pb, 0); avio_wl32(pb, 0); ff_parse_specific_params(st, &au_byterate, &au_ssize, &au_scale); avio_wl32(pb, au_scale); avio_wl32(pb, au_byterate); avpriv_set_pts_info(st, 64, au_scale, au_byterate); avio_wl32(pb, 0); avist->frames_hdr_strm = avio_tell(pb); if (!(pb->seekable & AVIO_SEEKABLE_NORMAL)) avio_wl32(pb, AVI_MAX_RIFF_SIZE); else avio_wl32(pb, 0); if (par->codec_type == AVMEDIA_TYPE_VIDEO) avio_wl32(pb, 1024 * 1024); else if (par->codec_type == AVMEDIA_TYPE_AUDIO) avio_wl32(pb, 12 * 1024); else avio_wl32(pb, 0); avio_wl32(pb, -1); avio_wl32(pb, au_ssize); avio_wl32(pb, 0); avio_wl16(pb, par->width); avio_wl16(pb, par->height); ff_end_tag(pb, strh); if (par->codec_type != AVMEDIA_TYPE_DATA) { strf = ff_start_tag(pb, ""strf""); switch (par->codec_type) { case AVMEDIA_TYPE_SUBTITLE: if (par->codec_id != AV_CODEC_ID_XSUB) break; case AVMEDIA_TYPE_VIDEO: ff_put_bmp_header(pb, par, ff_codec_bmp_tags, 0); break; case AVMEDIA_TYPE_AUDIO: if (ff_put_wav_header(s, pb, par) < 0) return -1; break; default: return -1; } ff_end_tag(pb, strf); if ((t = av_dict_get(st->metadata, ""title"", NULL, 0))) { ff_riff_write_info_tag(s->pb, ""strn"", t->value); t = NULL; } } if (pb->seekable & AVIO_SEEKABLE_NORMAL) { unsigned char tag[5]; int j; avist->indexes.entry = avist->indexes.ents_allocated = 0; avist->indexes.indx_start = ff_start_tag(pb, ""JUNK""); avio_wl16(pb, 4); avio_w8(pb, 0); avio_w8(pb, 0); avio_wl32(pb, 0); ffio_wfourcc(pb, avi_stream2fourcc(tag, i, par->codec_type)); avio_wl64(pb, 0); for (j = 0; j < AVI_MASTER_INDEX_SIZE * 2; j++) avio_wl64(pb, 0); ff_end_tag(pb, avist->indexes.indx_start); } if (par->codec_type == AVMEDIA_TYPE_VIDEO && st->sample_aspect_ratio.num > 0 && st->sample_aspect_ratio.den > 0) { int vprp = ff_start_tag(pb, ""vprp""); AVRational dar = av_mul_q(st->sample_aspect_ratio, (AVRational) { par->width, par->height }); int num, den; av_reduce(&num, &den, dar.num, dar.den, 0xFFFF); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, lrintf(1.0 / av_q2d(st->time_base))); avio_wl32(pb, par->width); avio_wl32(pb, par->height); avio_wl16(pb, den); avio_wl16(pb, num); avio_wl32(pb, par->width); avio_wl32(pb, par->height); avio_wl32(pb, 1); avio_wl32(pb, par->height); avio_wl32(pb, par->width); avio_wl32(pb, par->height); avio_wl32(pb, par->width); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); avio_wl32(pb, 0); ff_end_tag(pb, vprp); } ff_end_tag(pb, list2); } if (pb->seekable & AVIO_SEEKABLE_NORMAL) { avi->odml_list = ff_start_tag(pb, ""JUNK""); ffio_wfourcc(pb, ""odml""); ffio_wfourcc(pb, ""dmlh""); avio_wl32(pb, 248); for (i = 0; i < 248; i += 4) avio_wl32(pb, 0); ff_end_tag(pb, avi->odml_list); } ff_end_tag(pb, list1); ff_riff_write_info(s); list2 = ff_start_tag(pb, ""JUNK""); for (i = 0; i < 1016; i += 4) avio_wl32(pb, 0); ff_end_tag(pb, list2); avi->movi_list = ff_start_tag(pb, ""LIST""); ffio_wfourcc(pb, ""movi""); avio_flush(pb); return 0; }"
9308----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_1ae02def4133e470d92cdea055339ab0566fceae_1.json----TIFF_WriteOverview,"uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize, int nBitsPerPixel, int nPlanarConfig, int nSamples, int nBlockXSize, int nBlockYSize, int bTiled, int nCompressFlag, int nPhotometric, int nSampleFormat, unsigned short *panRed, unsigned short *panGreen, unsigned short *panBlue, int bUseSubIFDs, int nHorSubsampling, int nVerSubsampling ) { toff_t nBaseDirOffset; toff_t nOffset; (void) bUseSubIFDs; nBaseDirOffset = TIFFCurrentDirOffset( hTIFF ); TIFFCreateDirectory( hTIFF ); TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize ); TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize ); if( nSamples == 1 ) TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG ); else TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig ); TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel ); TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples ); TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag ); TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric ); TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat ); if( bTiled ) { TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize ); TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize ); } else TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize ); TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE ); if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB ) { TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling); } if( panRed != NULL ) { TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue ); } if( TIFFWriteCheck( hTIFF, bTiled, ""TIFFBuildOverviews"" ) == 0 ) return 0; TIFFWriteDirectory( hTIFF ); <S2SV_StartVul> TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) ); <S2SV_EndVul> nOffset = TIFFCurrentDirOffset( hTIFF ); TIFFSetSubDirectory( hTIFF, nBaseDirOffset ); return nOffset; }","- TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) );
+ tdir_t iNumDir;
+ iNumDir = TIFFNumberOfDirectories(hTIFF);
+ if( iNumDir > TIFF_DIR_MAX )
+ {
+ TIFFErrorExt( TIFFClientdata(hTIFF),
+ ""TIFF_WriteOverview"",
+ ""File `%s' has too many directories.\n"",
+ TIFFFileName(hTIFF) );
+ exit(-1);
+ }
+ TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );","uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize, int nBitsPerPixel, int nPlanarConfig, int nSamples, int nBlockXSize, int nBlockYSize, int bTiled, int nCompressFlag, int nPhotometric, int nSampleFormat, unsigned short *panRed, unsigned short *panGreen, unsigned short *panBlue, int bUseSubIFDs, int nHorSubsampling, int nVerSubsampling ) { toff_t nBaseDirOffset; toff_t nOffset; tdir_t iNumDir; (void) bUseSubIFDs; nBaseDirOffset = TIFFCurrentDirOffset( hTIFF ); TIFFCreateDirectory( hTIFF ); TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize ); TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize ); if( nSamples == 1 ) TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG ); else TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig ); TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel ); TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples ); TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag ); TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric ); TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat ); if( bTiled ) { TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize ); TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize ); } else TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize ); TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE ); if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB ) { TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling); } if( panRed != NULL ) { TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue ); } if( TIFFWriteCheck( hTIFF, bTiled, ""TIFFBuildOverviews"" ) == 0 ) return 0; TIFFWriteDirectory( hTIFF ); iNumDir = TIFFNumberOfDirectories(hTIFF); if( iNumDir > TIFF_DIR_MAX ) { TIFFErrorExt( TIFFClientdata(hTIFF), ""TIFF_WriteOverview"", ""File `%s' has too many directories.\n"", TIFFFileName(hTIFF) ); exit(-1); } TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) ); nOffset = TIFFCurrentDirOffset( hTIFF ); TIFFSetSubDirectory( hTIFF, nBaseDirOffset ); return nOffset; }"
5018----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_04c5b308e7eb4a6fc1eba7d7e5dc5b136ec5c13e_1.json----sao_band_filter_8,"static void FUNC(sao_band_filter)(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride, SAOParams *sao, int *borders, int width, int height, int c_idx, int class) { pixel *dst = (pixel *)_dst; pixel *src = (pixel *)_src; int offset_table[32] = { 0 }; int k, y, x; int chroma = !!c_idx; int shift = BIT_DEPTH - 5; int *sao_offset_val = sao->offset_val[c_idx]; int sao_left_class = sao->band_position[c_idx]; int init_y = 0, init_x = 0; stride /= sizeof(pixel); switch (class) { case 0: if (!borders[2]) width -= (8 >> chroma) + 2; if (!borders[3]) height -= (4 >> chroma) + 2; break; case 1: init_y = -(4 >> chroma) - 2; if (!borders[2]) width -= (8 >> chroma) + 2; height = (4 >> chroma) + 2; break; case 2: init_x = -(8 >> chroma) - 2; width = (8 >> chroma) + 2; if (!borders[3]) height -= (4 >> chroma) + 2; break; case 3: init_y = -(4 >> chroma) - 2; init_x = -(8 >> chroma) - 2; width = (8 >> chroma) + 2; height = (4 >> chroma) + 2; break; } dst = dst + (init_y * stride + init_x); src = src + (init_y * stride + init_x); for (k = 0; k < 4; k++) offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1]; for (y = 0; y < height; y++) { for (x = 0; x < width; x++) <S2SV_StartVul> dst[x] = av_clip_pixel(src[x] + offset_table[av_clip_pixel(src[x] >> shift)]); <S2SV_EndVul> dst += stride; src += stride; } }","- dst[x] = av_clip_pixel(src[x] + offset_table[av_clip_pixel(src[x] >> shift)]);
+ dst[x] = av_clip_pixel(src[x] + offset_table[src[x] >> shift]);","static void FUNC(sao_band_filter)(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride, SAOParams *sao, int *borders, int width, int height, int c_idx, int class) { pixel *dst = (pixel *)_dst; pixel *src = (pixel *)_src; int offset_table[32] = { 0 }; int k, y, x; int chroma = !!c_idx; int shift = BIT_DEPTH - 5; int *sao_offset_val = sao->offset_val[c_idx]; int sao_left_class = sao->band_position[c_idx]; int init_y = 0, init_x = 0; stride /= sizeof(pixel); switch (class) { case 0: if (!borders[2]) width -= (8 >> chroma) + 2; if (!borders[3]) height -= (4 >> chroma) + 2; break; case 1: init_y = -(4 >> chroma) - 2; if (!borders[2]) width -= (8 >> chroma) + 2; height = (4 >> chroma) + 2; break; case 2: init_x = -(8 >> chroma) - 2; width = (8 >> chroma) + 2; if (!borders[3]) height -= (4 >> chroma) + 2; break; case 3: init_y = -(4 >> chroma) - 2; init_x = -(8 >> chroma) - 2; width = (8 >> chroma) + 2; height = (4 >> chroma) + 2; break; } dst = dst + (init_y * stride + init_x); src = src + (init_y * stride + init_x); for (k = 0; k < 4; k++) offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1]; for (y = 0; y < height; y++) { for (x = 0; x < width; x++) dst[x] = av_clip_pixel(src[x] + offset_table[src[x] >> shift]); dst += stride; src += stride; } }"
16293----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d2638c5e3abf24038f3e29305b0c1a9bbdeceef1_1.json----b64_read_asn1,"static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it) { BIO *b64; ASN1_VALUE *val; if ((b64 = BIO_new(BIO_f_base64())) == NULL) { ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE); return 0; } bio = BIO_push(b64, bio); val = ASN1_item_d2i_bio(it, bio, NULL); if (!val) ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR); (void)BIO_flush(bio); <S2SV_StartVul> bio = BIO_pop(bio); <S2SV_EndVul> BIO_free(b64); return val; }","- bio = BIO_pop(bio);
+ BIO_pop(bio);","static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it) { BIO *b64; ASN1_VALUE *val; if ((b64 = BIO_new(BIO_f_base64())) == NULL) { ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE); return 0; } bio = BIO_push(b64, bio); val = ASN1_item_d2i_bio(it, bio, NULL); if (!val) ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR); (void)BIO_flush(bio); BIO_pop(bio); BIO_free(b64); return val; }"
9954----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_4ba4017fe37d85797c7e2c9e338c55719db264c1_1.json----ngx_slab_init,"void ngx_slab_init(ngx_slab_pool_t *pool) { u_char *p; size_t size; ngx_int_t m; ngx_uint_t i, n, pages; ngx_slab_page_t *slots, *page; if (ngx_slab_max_size == 0) { ngx_slab_max_size = ngx_pagesize / 2; ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t)); for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) { } } pool->min_size = 1 << pool->min_shift; slots = ngx_slab_slots(pool); p = (u_char *) slots; size = pool->end - p; ngx_slab_junk(p, size); n = ngx_pagesize_shift - pool->min_shift; for (i = 0; i < n; i++) { slots[i].slab = 0; slots[i].next = &slots[i]; slots[i].prev = 0; } p += n * sizeof(ngx_slab_page_t); <S2SV_StartVul> size -= n * sizeof(ngx_slab_page_t); <S2SV_EndVul> pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t))); pool->pages = (ngx_slab_page_t *) p; ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t)); page = pool->pages; pool->free.slab = 0; pool->free.next = page; pool->free.prev = 0; page->slab = pages; page->next = &pool->free; page->prev = (uintptr_t) &pool->free; pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t), ngx_pagesize); m = pages - (pool->end - pool->start) / ngx_pagesize; if (m > 0) { pages -= m; page->slab = pages; } pool->last = pool->pages + pages; pool->log_nomem = 1; pool->log_ctx = &pool->zero; pool->zero = '\0'; }","- size -= n * sizeof(ngx_slab_page_t);
+ pool->stats = (ngx_slab_stat_t *) p;
+ ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));
+ p += n * sizeof(ngx_slab_stat_t);
+ size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t));","void ngx_slab_init(ngx_slab_pool_t *pool) { u_char *p; size_t size; ngx_int_t m; ngx_uint_t i, n, pages; ngx_slab_page_t *slots, *page; if (ngx_slab_max_size == 0) { ngx_slab_max_size = ngx_pagesize / 2; ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t)); for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) { } } pool->min_size = 1 << pool->min_shift; slots = ngx_slab_slots(pool); p = (u_char *) slots; size = pool->end - p; ngx_slab_junk(p, size); n = ngx_pagesize_shift - pool->min_shift; for (i = 0; i < n; i++) { slots[i].slab = 0; slots[i].next = &slots[i]; slots[i].prev = 0; } p += n * sizeof(ngx_slab_page_t); pool->stats = (ngx_slab_stat_t *) p; ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t)); p += n * sizeof(ngx_slab_stat_t); size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t)); pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t))); pool->pages = (ngx_slab_page_t *) p; ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t)); page = pool->pages; pool->free.slab = 0; pool->free.next = page; pool->free.prev = 0; page->slab = pages; page->next = &pool->free; page->prev = (uintptr_t) &pool->free; pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t), ngx_pagesize); m = pages - (pool->end - pool->start) / ngx_pagesize; if (m > 0) { pages -= m; page->slab = pages; } pool->last = pool->pages + pages; pool->log_nomem = 1; pool->log_ctx = &pool->zero; pool->zero = '\0'; }"
11475----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2b47c1b91b47e71d3a4689a5a35fcd14f10b277b_1.json----gost_set_default_param,"int gost_set_default_param(int param, const char *value) { const char *tmp; if (param < 0 || param > GOST_PARAM_MAX) return 0; tmp = getenv(gost_envnames[param]); if (!tmp) tmp = value; OPENSSL_free(gost_params[param]); <S2SV_StartVul> gost_params[param] = BUF_strdup(tmp); <S2SV_EndVul> return 1; }","- gost_params[param] = BUF_strdup(tmp);
+ gost_params[param] = OPENSSL_strdup(tmp);","int gost_set_default_param(int param, const char *value) { const char *tmp; if (param < 0 || param > GOST_PARAM_MAX) return 0; tmp = getenv(gost_envnames[param]); if (!tmp) tmp = value; OPENSSL_free(gost_params[param]); gost_params[param] = OPENSSL_strdup(tmp); return 1; }"
700----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2680642b1d433a61a33e4a5666182d1a0effb45b_1.json----mov_read_ctts,"static int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; <S2SV_StartVul> unsigned int i, j, entries, ctts_count = 0; <S2SV_EndVul> if (c->fc->nb_streams < 1) return 0; st = c->fc->streams[c->fc->nb_streams-1]; sc = st->priv_data; avio_r8(pb); avio_rb24(pb); entries = avio_rb32(pb); av_log(c->fc, AV_LOG_TRACE, ""track[%u].ctts.entries = %u\n"", c->fc->nb_streams - 1, entries); if (!entries) return 0; if (entries >= UINT_MAX / sizeof(*sc->ctts_data)) return AVERROR_INVALIDDATA; av_freep(&sc->ctts_data); sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data)); if (!sc->ctts_data) return AVERROR(ENOMEM); for (i = 0; i < entries && !pb->eof_reached; i++) { int count =avio_rb32(pb); int duration =avio_rb32(pb); if (count <= 0) { av_log(c->fc, AV_LOG_TRACE, ""ignoring CTTS entry with count=%d duration=%d\n"", count, duration); continue; } <S2SV_StartVul> for (j = 0; j < count; j++) <S2SV_EndVul> <S2SV_StartVul> add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size, 1, duration); <S2SV_EndVul> av_log(c->fc, AV_LOG_TRACE, ""count=%d, duration=%d\n"", count, duration); if (FFNABS(duration) < -(1<<28) && i+2<entries) { av_log(c->fc, AV_LOG_WARNING, ""CTTS invalid\n""); av_freep(&sc->ctts_data); sc->ctts_count = 0; return 0; } if (i+2<entries) mov_update_dts_shift(sc, duration); } sc->ctts_count = ctts_count; if (pb->eof_reached) return AVERROR_EOF; av_log(c->fc, AV_LOG_TRACE, ""dts shift %d\n"", sc->dts_shift); return 0; }","- unsigned int i, j, entries, ctts_count = 0;
- for (j = 0; j < count; j++)
- add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size, 1, duration);
+ unsigned int i, entries, ctts_count = 0;
+ add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size,
+ count, duration);","static int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; unsigned int i, entries, ctts_count = 0; if (c->fc->nb_streams < 1) return 0; st = c->fc->streams[c->fc->nb_streams-1]; sc = st->priv_data; avio_r8(pb); avio_rb24(pb); entries = avio_rb32(pb); av_log(c->fc, AV_LOG_TRACE, ""track[%u].ctts.entries = %u\n"", c->fc->nb_streams - 1, entries); if (!entries) return 0; if (entries >= UINT_MAX / sizeof(*sc->ctts_data)) return AVERROR_INVALIDDATA; av_freep(&sc->ctts_data); sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data)); if (!sc->ctts_data) return AVERROR(ENOMEM); for (i = 0; i < entries && !pb->eof_reached; i++) { int count =avio_rb32(pb); int duration =avio_rb32(pb); if (count <= 0) { av_log(c->fc, AV_LOG_TRACE, ""ignoring CTTS entry with count=%d duration=%d\n"", count, duration); continue; } add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size, count, duration); av_log(c->fc, AV_LOG_TRACE, ""count=%d, duration=%d\n"", count, duration); if (FFNABS(duration) < -(1<<28) && i+2<entries) { av_log(c->fc, AV_LOG_WARNING, ""CTTS invalid\n""); av_freep(&sc->ctts_data); sc->ctts_count = 0; return 0; } if (i+2<entries) mov_update_dts_shift(sc, duration); } sc->ctts_count = ctts_count; if (pb->eof_reached) return AVERROR_EOF; av_log(c->fc, AV_LOG_TRACE, ""dts shift %d\n"", sc->dts_shift); return 0; }"
1806----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_63c477396317b6f2d55264532642d5446000ae35_1.json----set_sps,"static int set_sps(HEVCContext *s, const HEVCSPS *sps) { #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL) enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts; int ret; <S2SV_StartVul> export_stream_params(s->avctx, &s->ps, sps); <S2SV_EndVul> pic_arrays_free(s); ret = pic_arrays_init(s, sps); if (ret < 0) goto fail; if (sps->pix_fmt == AV_PIX_FMT_YUV420P || sps->pix_fmt == AV_PIX_FMT_YUVJ420P) { #if CONFIG_HEVC_DXVA2_HWACCEL *fmt++ = AV_PIX_FMT_DXVA2_VLD; #endif #if CONFIG_HEVC_D3D11VA_HWACCEL *fmt++ = AV_PIX_FMT_D3D11VA_VLD; #endif } *fmt++ = sps->pix_fmt; *fmt = AV_PIX_FMT_NONE; ret = ff_get_format(s->avctx, pix_fmts); if (ret < 0) goto fail; s->avctx->pix_fmt = ret; ff_hevc_pred_init(&s->hpc, sps->bit_depth); ff_hevc_dsp_init (&s->hevcdsp, sps->bit_depth); ff_videodsp_init (&s->vdsp, sps->bit_depth); if (sps->sao_enabled && !s->avctx->hwaccel) { av_frame_unref(s->tmp_frame); ret = ff_get_buffer(s->avctx, s->tmp_frame, AV_GET_BUFFER_FLAG_REF); if (ret < 0) goto fail; s->frame = s->tmp_frame; } s->ps.sps = sps; s->ps.vps = (HEVCVPS*) s->ps.vps_list[s->ps.sps->vps_id]->data; return 0; fail: pic_arrays_free(s); s->ps.sps = NULL; return ret; }","- export_stream_params(s->avctx, &s->ps, sps);
+ s->ps.sps = NULL;
+ s->ps.vps = NULL;
+ if (!sps)
+ return 0;
+ export_stream_params(s->avctx, &s->ps, sps);","static int set_sps(HEVCContext *s, const HEVCSPS *sps) { #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL) enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts; int ret; pic_arrays_free(s); s->ps.sps = NULL; s->ps.vps = NULL; if (!sps) return 0; ret = pic_arrays_init(s, sps); if (ret < 0) goto fail; export_stream_params(s->avctx, &s->ps, sps); if (sps->pix_fmt == AV_PIX_FMT_YUV420P || sps->pix_fmt == AV_PIX_FMT_YUVJ420P) { #if CONFIG_HEVC_DXVA2_HWACCEL *fmt++ = AV_PIX_FMT_DXVA2_VLD; #endif #if CONFIG_HEVC_D3D11VA_HWACCEL *fmt++ = AV_PIX_FMT_D3D11VA_VLD; #endif } *fmt++ = sps->pix_fmt; *fmt = AV_PIX_FMT_NONE; ret = ff_get_format(s->avctx, pix_fmts); if (ret < 0) goto fail; s->avctx->pix_fmt = ret; ff_hevc_pred_init(&s->hpc, sps->bit_depth); ff_hevc_dsp_init (&s->hevcdsp, sps->bit_depth); ff_videodsp_init (&s->vdsp, sps->bit_depth); if (sps->sao_enabled && !s->avctx->hwaccel) { av_frame_unref(s->tmp_frame); ret = ff_get_buffer(s->avctx, s->tmp_frame, AV_GET_BUFFER_FLAG_REF); if (ret < 0) goto fail; s->frame = s->tmp_frame; } s->ps.sps = sps; s->ps.vps = (HEVCVPS*) s->ps.vps_list[s->ps.sps->vps_id]->data; return 0; fail: pic_arrays_free(s); s->ps.sps = NULL; return ret; }"
11527----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2d2ffde7783c14431072b3a854fbdaaccadbbeaf_1.json----mem_gets,"static int mem_gets(BIO *bp, char *buf, int size) { int i, j; int ret = -1; char *p; <S2SV_StartVul> BUF_MEM *bm = (BUF_MEM *)bp->ptr; <S2SV_EndVul> BIO_clear_retry_flags(bp); j = bm->length; if ((size - 1) < j) j = size - 1; if (j <= 0) { *buf = '\0'; return 0; } p = bm->data; for (i = 0; i < j; i++) { if (p[i] == '\n') { i++; break; } } i = mem_read(bp, buf, i); if (i > 0) buf[i] = '\0'; ret = i; return (ret); }","- BUF_MEM *bm = (BUF_MEM *)bp->ptr;
+ BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)bp->ptr;
+ BUF_MEM *bm = bbm->readp;","static int mem_gets(BIO *bp, char *buf, int size) { int i, j; int ret = -1; char *p; BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)bp->ptr; BUF_MEM *bm = bbm->readp; BIO_clear_retry_flags(bp); j = bm->length; if ((size - 1) < j) j = size - 1; if (j <= 0) { *buf = '\0'; return 0; } p = bm->data; for (i = 0; i < j; i++) { if (p[i] == '\n') { i++; break; } } i = mem_read(bp, buf, i); if (i > 0) buf[i] = '\0'; ret = i; return (ret); }"
508----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1c913970521c09f41fa251434da770c361a6c60a_1.json----hls_window,"static int hls_window(AVFormatContext *s, int last) { HLSContext *hls = s->priv_data; ListEntry *en; int64_t target_duration = 0; int ret = 0; AVIOContext *out = NULL; char temp_filename[1024]; int64_t sequence = FFMAX(hls->start_sequence, hls->sequence - hls->size); snprintf(temp_filename, sizeof(temp_filename), ""%s.tmp"", s->filename); <S2SV_StartVul> if ((ret = avio_open2(&out, temp_filename, AVIO_FLAG_WRITE, <S2SV_EndVul> <S2SV_StartVul> &s->interrupt_callback, NULL)) < 0) <S2SV_EndVul> goto fail; for (en = hls->list; en; en = en->next) { if (target_duration < en->duration) target_duration = en->duration; } avio_printf(out, ""#EXTM3U\n""); avio_printf(out, ""#EXT-X-VERSION:%d\n"", hls->version); if (hls->allowcache == 0 || hls->allowcache == 1) { avio_printf(out, ""#EXT-X-ALLOW-CACHE:%s\n"", hls->allowcache == 0 ? ""NO"" : ""YES""); } avio_printf(out, ""#EXT-X-TARGETDURATION:%""PRId64""\n"", av_rescale_rnd(target_duration, 1, AV_TIME_BASE, AV_ROUND_UP)); avio_printf(out, ""#EXT-X-MEDIA-SEQUENCE:%""PRId64""\n"", sequence); av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%""PRId64""\n"", sequence); for (en = hls->list; en; en = en->next) { if (hls->version > 2) avio_printf(out, ""#EXTINF:%f\n"", (double)en->duration / AV_TIME_BASE); else avio_printf(out, ""#EXTINF:%""PRId64"",\n"", av_rescale(en->duration, 1, AV_TIME_BASE)); if (hls->baseurl) avio_printf(out, ""%s"", hls->baseurl); avio_printf(out, ""%s\n"", en->name); } if (last) avio_printf(out, ""#EXT-X-ENDLIST\n""); fail: <S2SV_StartVul> avio_closep(&out); <S2SV_EndVul> if (ret >= 0) ff_rename(temp_filename, s->filename); return ret; }","- if ((ret = avio_open2(&out, temp_filename, AVIO_FLAG_WRITE,
- &s->interrupt_callback, NULL)) < 0)
- avio_closep(&out);
+ if ((ret = s->io_open(s, &out, temp_filename, AVIO_FLAG_WRITE, NULL)) < 0)
+ ff_format_io_close(s, &out);","static int hls_window(AVFormatContext *s, int last) { HLSContext *hls = s->priv_data; ListEntry *en; int64_t target_duration = 0; int ret = 0; AVIOContext *out = NULL; char temp_filename[1024]; int64_t sequence = FFMAX(hls->start_sequence, hls->sequence - hls->size); snprintf(temp_filename, sizeof(temp_filename), ""%s.tmp"", s->filename); if ((ret = s->io_open(s, &out, temp_filename, AVIO_FLAG_WRITE, NULL)) < 0) goto fail; for (en = hls->list; en; en = en->next) { if (target_duration < en->duration) target_duration = en->duration; } avio_printf(out, ""#EXTM3U\n""); avio_printf(out, ""#EXT-X-VERSION:%d\n"", hls->version); if (hls->allowcache == 0 || hls->allowcache == 1) { avio_printf(out, ""#EXT-X-ALLOW-CACHE:%s\n"", hls->allowcache == 0 ? ""NO"" : ""YES""); } avio_printf(out, ""#EXT-X-TARGETDURATION:%""PRId64""\n"", av_rescale_rnd(target_duration, 1, AV_TIME_BASE, AV_ROUND_UP)); avio_printf(out, ""#EXT-X-MEDIA-SEQUENCE:%""PRId64""\n"", sequence); av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%""PRId64""\n"", sequence); for (en = hls->list; en; en = en->next) { if (hls->version > 2) avio_printf(out, ""#EXTINF:%f\n"", (double)en->duration / AV_TIME_BASE); else avio_printf(out, ""#EXTINF:%""PRId64"",\n"", av_rescale(en->duration, 1, AV_TIME_BASE)); if (hls->baseurl) avio_printf(out, ""%s"", hls->baseurl); avio_printf(out, ""%s\n"", en->name); } if (last) avio_printf(out, ""#EXT-X-ENDLIST\n""); fail: ff_format_io_close(s, &out); if (ret >= 0) ff_rename(temp_filename, s->filename); return ret; }"
920----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3256173f9160db6c0e69e5de5e3d2c8dc40f6ee5_1.json----frame_thread_init,"static int frame_thread_init(AVCodecContext *avctx) { int thread_count = avctx->thread_count; AVCodec *codec = avctx->codec; AVCodecContext *src = avctx; FrameThreadContext *fctx; int i, err = 0; if (thread_count <= 1) { avctx->active_thread_type = 0; return 0; } avctx->thread_opaque = fctx = av_mallocz(sizeof(FrameThreadContext)); fctx->threads = av_mallocz(sizeof(PerThreadContext) * thread_count); pthread_mutex_init(&fctx->buffer_mutex, NULL); fctx->delaying = 1; for (i = 0; i < thread_count; i++) { AVCodecContext *copy = av_malloc(sizeof(AVCodecContext)); PerThreadContext *p = &fctx->threads[i]; pthread_mutex_init(&p->mutex, NULL); pthread_mutex_init(&p->progress_mutex, NULL); pthread_cond_init(&p->input_cond, NULL); pthread_cond_init(&p->progress_cond, NULL); pthread_cond_init(&p->output_cond, NULL); p->parent = fctx; p->avctx = copy; if (!copy) { err = AVERROR(ENOMEM); goto error; } *copy = *src; copy->thread_opaque = p; copy->pkt = &p->avpkt; if (!i) { src = copy; if (codec->init) err = codec->init(copy); update_context_from_thread(avctx, copy, 1); } else { copy->priv_data = av_malloc(codec->priv_data_size); if (!copy->priv_data) { err = AVERROR(ENOMEM); goto error; } memcpy(copy->priv_data, src->priv_data, codec->priv_data_size); copy->internal = av_malloc(sizeof(AVCodecInternal)); if (!copy->internal) { err = AVERROR(ENOMEM); goto error; } *(copy->internal) = *(src->internal); copy->internal->is_copy = 1; if (codec->init_thread_copy) err = codec->init_thread_copy(copy); } if (err) goto error; <S2SV_StartVul> pthread_create(&p->thread, NULL, frame_worker_thread, p); <S2SV_EndVul> } return 0; error: frame_thread_free(avctx, i+1); return err; }","- pthread_create(&p->thread, NULL, frame_worker_thread, p);
+ p->thread_created= !pthread_create(&p->thread, NULL, frame_worker_thread, p);","static int frame_thread_init(AVCodecContext *avctx) { int thread_count = avctx->thread_count; AVCodec *codec = avctx->codec; AVCodecContext *src = avctx; FrameThreadContext *fctx; int i, err = 0; if (thread_count <= 1) { avctx->active_thread_type = 0; return 0; } avctx->thread_opaque = fctx = av_mallocz(sizeof(FrameThreadContext)); fctx->threads = av_mallocz(sizeof(PerThreadContext) * thread_count); pthread_mutex_init(&fctx->buffer_mutex, NULL); fctx->delaying = 1; for (i = 0; i < thread_count; i++) { AVCodecContext *copy = av_malloc(sizeof(AVCodecContext)); PerThreadContext *p = &fctx->threads[i]; pthread_mutex_init(&p->mutex, NULL); pthread_mutex_init(&p->progress_mutex, NULL); pthread_cond_init(&p->input_cond, NULL); pthread_cond_init(&p->progress_cond, NULL); pthread_cond_init(&p->output_cond, NULL); p->parent = fctx; p->avctx = copy; if (!copy) { err = AVERROR(ENOMEM); goto error; } *copy = *src; copy->thread_opaque = p; copy->pkt = &p->avpkt; if (!i) { src = copy; if (codec->init) err = codec->init(copy); update_context_from_thread(avctx, copy, 1); } else { copy->priv_data = av_malloc(codec->priv_data_size); if (!copy->priv_data) { err = AVERROR(ENOMEM); goto error; } memcpy(copy->priv_data, src->priv_data, codec->priv_data_size); copy->internal = av_malloc(sizeof(AVCodecInternal)); if (!copy->internal) { err = AVERROR(ENOMEM); goto error; } *(copy->internal) = *(src->internal); copy->internal->is_copy = 1; if (codec->init_thread_copy) err = codec->init_thread_copy(copy); } if (err) goto error; p->thread_created= !pthread_create(&p->thread, NULL, frame_worker_thread, p); } return 0; error: frame_thread_free(avctx, i+1); return err; }"
1573----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_57e4d1b2ee68faf7e72e7eb741a6ba481ed13a99_1.json----output_frame,"<S2SV_StartVul> static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src) <S2SV_EndVul> { int i; int ret = av_frame_ref(dst, src); if (ret < 0) return ret; <S2SV_StartVul> if (!h->sps.crop) <S2SV_EndVul> return 0; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? h->chroma_x_shift : 0; int vshift = (i > 0) ? h->chroma_y_shift : 0; <S2SV_StartVul> int off = ((h->sps.crop_left >> hshift) << h->pixel_shift) + <S2SV_EndVul> <S2SV_StartVul> (h->sps.crop_top >> vshift) * dst->linesize[i]; <S2SV_EndVul> dst->data[i] += off; } return 0; }","- static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)
- if (!h->sps.crop)
- int off = ((h->sps.crop_left >> hshift) << h->pixel_shift) +
- (h->sps.crop_top >> vshift) * dst->linesize[i];
+ static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)
+ AVFrame *src = &srcp->f;
+ if (!srcp->crop)
+ int off = ((srcp->crop_left >> hshift) << h->pixel_shift) +
+ (srcp->crop_top >> vshift) * dst->linesize[i];","static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp) { AVFrame *src = &srcp->f; int i; int ret = av_frame_ref(dst, src); if (ret < 0) return ret; if (!srcp->crop) return 0; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? h->chroma_x_shift : 0; int vshift = (i > 0) ? h->chroma_y_shift : 0; int off = ((srcp->crop_left >> hshift) << h->pixel_shift) + (srcp->crop_top >> vshift) * dst->linesize[i]; dst->data[i] += off; } return 0; }"
316----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_131d5e3899f250ff8f545b5f2e1c0b582267b886_1.json----adx_read_header,"static int adx_read_header(AVFormatContext *s) { ADXDemuxerContext *c = s->priv_data; AVCodecParameters *par; AVStream *st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); par = s->streams[0]->codecpar; if (avio_rb16(s->pb) != 0x8000) return AVERROR_INVALIDDATA; c->header_size = avio_rb16(s->pb) + 4; avio_seek(s->pb, -4, SEEK_CUR); if (ff_get_extradata(s, par, s->pb, c->header_size) < 0) return AVERROR(ENOMEM); if (par->extradata_size < 12) { av_log(s, AV_LOG_ERROR, ""Invalid extradata size.\n""); return AVERROR_INVALIDDATA; } par->channels = AV_RB8 (par->extradata + 7); par->sample_rate = AV_RB32(par->extradata + 8); if (par->channels <= 0) { av_log(s, AV_LOG_ERROR, ""invalid number of channels %d\n"", par->channels); return AVERROR_INVALIDDATA; } if (par->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, ""Invalid sample rate %d\n"", par->sample_rate); return AVERROR_INVALIDDATA; } par->codec_type = AVMEDIA_TYPE_AUDIO; par->codec_id = s->iformat->raw_codec_id; <S2SV_StartVul> par->bit_rate = par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES; <S2SV_EndVul> avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate); return 0; }","- par->bit_rate = par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;
+ par->bit_rate = (int64_t)par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;","static int adx_read_header(AVFormatContext *s) { ADXDemuxerContext *c = s->priv_data; AVCodecParameters *par; AVStream *st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); par = s->streams[0]->codecpar; if (avio_rb16(s->pb) != 0x8000) return AVERROR_INVALIDDATA; c->header_size = avio_rb16(s->pb) + 4; avio_seek(s->pb, -4, SEEK_CUR); if (ff_get_extradata(s, par, s->pb, c->header_size) < 0) return AVERROR(ENOMEM); if (par->extradata_size < 12) { av_log(s, AV_LOG_ERROR, ""Invalid extradata size.\n""); return AVERROR_INVALIDDATA; } par->channels = AV_RB8 (par->extradata + 7); par->sample_rate = AV_RB32(par->extradata + 8); if (par->channels <= 0) { av_log(s, AV_LOG_ERROR, ""invalid number of channels %d\n"", par->channels); return AVERROR_INVALIDDATA; } if (par->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, ""Invalid sample rate %d\n"", par->sample_rate); return AVERROR_INVALIDDATA; } par->codec_type = AVMEDIA_TYPE_AUDIO; par->codec_id = s->iformat->raw_codec_id; par->bit_rate = (int64_t)par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES; avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate); return 0; }"
14194----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_89af2271589c85f8ef8b2840a3ec24afa77611e0_1.json----CRYPTO_secure_malloc,"void *CRYPTO_secure_malloc(size_t num, const char *file, int line) { #ifdef IMPLEMENTED void *ret; size_t actual_size; if (!secure_mem_initialized) { <S2SV_StartVul> too_late = 1; <S2SV_EndVul> return CRYPTO_malloc(num, file, line); } CRYPTO_THREAD_write_lock(sec_malloc_lock); ret = sh_malloc(num); actual_size = ret ? sh_actual_size(ret) : 0; secure_mem_used += actual_size; CRYPTO_THREAD_unlock(sec_malloc_lock); return ret; #else return CRYPTO_malloc(num, file, line); #endif }",- too_late = 1;,"void *CRYPTO_secure_malloc(size_t num, const char *file, int line) { #ifdef IMPLEMENTED void *ret; size_t actual_size; if (!secure_mem_initialized) { return CRYPTO_malloc(num, file, line); } CRYPTO_THREAD_write_lock(sec_malloc_lock); ret = sh_malloc(num); actual_size = ret ? sh_actual_size(ret) : 0; secure_mem_used += actual_size; CRYPTO_THREAD_unlock(sec_malloc_lock); return ret; #else return CRYPTO_malloc(num, file, line); #endif }"
14692----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_9bcb3ad0e6dedeb54fec996bf7b16799de82e057_1.json----pkcs7_main,"int MAIN(int argc, char **argv) { PKCS7 *p7=NULL; int i,badops=0; BIO *in=NULL,*out=NULL; int informat,outformat; char *infile,*outfile,*prog; int print_certs=0,text=0,noout=0; int ret=0; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-noout"") == 0) noout=1; else if (strcmp(*argv,""-text"") == 0) text=1; else if (strcmp(*argv,""-print_certs"") == 0) print_certs=1; else { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - DER or PEM\n""); BIO_printf(bio_err,"" -outform arg output format - DER or PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -print_certs print any certs or crl in the input\n""); BIO_printf(bio_err,"" -text print full details of certificates\n""); BIO_printf(bio_err,"" -noout don't output encoded data\n""); EXIT(1); } ERR_load_crypto_strings(); in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) if (in == NULL) { perror(infile); goto end; } } if (informat == FORMAT_ASN1) p7=d2i_PKCS7_bio(in,NULL); else if (informat == FORMAT_PEM) p7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL); else { BIO_printf(bio_err,""bad input format specified for pkcs7 object\n""); goto end; } if (p7 == NULL) { BIO_printf(bio_err,""unable to load PKCS7 object\n""); ERR_print_errors(bio_err); goto end; } if (outfile == NULL) BIO_set_fp(out,stdout,BIO_NOCLOSE); else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (print_certs) { STACK_OF(X509) *certs=NULL; STACK_OF(X509_CRL) *crls=NULL; i=OBJ_obj2nid(p7->type); switch (i) { case NID_pkcs7_signed: certs=p7->d.sign->cert; crls=p7->d.sign->crl; break; case NID_pkcs7_signedAndEnveloped: certs=p7->d.signed_and_enveloped->cert; crls=p7->d.signed_and_enveloped->crl; break; default: break; } if (certs != NULL) { X509 *x; for (i=0; i<sk_X509_num(certs); i++) { x=sk_X509_value(certs,i); if(text) X509_print(out, x); else dump_cert_text(out, x); if(!noout) PEM_write_bio_X509(out,x); BIO_puts(out,""\n""); } } if (crls != NULL) { X509_CRL *crl; for (i=0; i<sk_X509_CRL_num(crls); i++) { crl=sk_X509_CRL_value(crls,i); X509_CRL_print(out, crl); if(!noout)PEM_write_bio_X509_CRL(out,crl); BIO_puts(out,""\n""); } } ret=0; goto end; } if(!noout) { if (outformat == FORMAT_ASN1) i=i2d_PKCS7_bio(out,p7); else if (outformat == FORMAT_PEM) i=PEM_write_bio_PKCS7(out,p7); else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } } ret=0; end: if (p7 != NULL) PKCS7_free(p7); if (in != NULL) BIO_free(in); <S2SV_StartVul> if (out != NULL) BIO_free(out); <S2SV_EndVul> EXIT(ret); }","- if (out != NULL) BIO_free(out);
+ {
+ #ifdef VMS
+ {
+ BIO *tmpbio = BIO_new(BIO_f_linebuffer());
+ out = BIO_push(tmpbio, out);
+ }
+ #endif
+ }
+ if (out != NULL) BIO_free_all(out);","int MAIN(int argc, char **argv) { PKCS7 *p7=NULL; int i,badops=0; BIO *in=NULL,*out=NULL; int informat,outformat; char *infile,*outfile,*prog; int print_certs=0,text=0,noout=0; int ret=0; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-noout"") == 0) noout=1; else if (strcmp(*argv,""-text"") == 0) text=1; else if (strcmp(*argv,""-print_certs"") == 0) print_certs=1; else { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - DER or PEM\n""); BIO_printf(bio_err,"" -outform arg output format - DER or PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -print_certs print any certs or crl in the input\n""); BIO_printf(bio_err,"" -text print full details of certificates\n""); BIO_printf(bio_err,"" -noout don't output encoded data\n""); EXIT(1); } ERR_load_crypto_strings(); in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) if (in == NULL) { perror(infile); goto end; } } if (informat == FORMAT_ASN1) p7=d2i_PKCS7_bio(in,NULL); else if (informat == FORMAT_PEM) p7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL); else { BIO_printf(bio_err,""bad input format specified for pkcs7 object\n""); goto end; } if (p7 == NULL) { BIO_printf(bio_err,""unable to load PKCS7 object\n""); ERR_print_errors(bio_err); goto end; } if (outfile == NULL) { BIO_set_fp(out,stdout,BIO_NOCLOSE); #ifdef VMS { BIO *tmpbio = BIO_new(BIO_f_linebuffer()); out = BIO_push(tmpbio, out); } #endif } else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (print_certs) { STACK_OF(X509) *certs=NULL; STACK_OF(X509_CRL) *crls=NULL; i=OBJ_obj2nid(p7->type); switch (i) { case NID_pkcs7_signed: certs=p7->d.sign->cert; crls=p7->d.sign->crl; break; case NID_pkcs7_signedAndEnveloped: certs=p7->d.signed_and_enveloped->cert; crls=p7->d.signed_and_enveloped->crl; break; default: break; } if (certs != NULL) { X509 *x; for (i=0; i<sk_X509_num(certs); i++) { x=sk_X509_value(certs,i); if(text) X509_print(out, x); else dump_cert_text(out, x); if(!noout) PEM_write_bio_X509(out,x); BIO_puts(out,""\n""); } } if (crls != NULL) { X509_CRL *crl; for (i=0; i<sk_X509_CRL_num(crls); i++) { crl=sk_X509_CRL_value(crls,i); X509_CRL_print(out, crl); if(!noout)PEM_write_bio_X509_CRL(out,crl); BIO_puts(out,""\n""); } } ret=0; goto end; } if(!noout) { if (outformat == FORMAT_ASN1) i=i2d_PKCS7_bio(out,p7); else if (outformat == FORMAT_PEM) i=PEM_write_bio_PKCS7(out,p7); else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } } ret=0; end: if (p7 != NULL) PKCS7_free(p7); if (in != NULL) BIO_free(in); if (out != NULL) BIO_free_all(out); EXIT(ret); }"
11073----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c42a9470dfbc423c6f0e8a098f283145e7124a6_1.json----OPENSSL_sk_dup,"OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk) { OPENSSL_STACK *ret; if (sk->num < 0) return NULL; if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) return NULL; *ret = *sk; if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL) goto err; <S2SV_StartVul> memcpy(ret->data, sk->data, sizeof(char *) * sk->num); <S2SV_EndVul> return ret; err: OPENSSL_sk_free(ret); return NULL; }","- memcpy(ret->data, sk->data, sizeof(char *) * sk->num);
+ memcpy(ret->data, sk->data, sizeof(void *) * sk->num);","OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk) { OPENSSL_STACK *ret; if (sk->num < 0) return NULL; if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) return NULL; *ret = *sk; if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL) goto err; memcpy(ret->data, sk->data, sizeof(void *) * sk->num); return ret; err: OPENSSL_sk_free(ret); return NULL; }"
11643----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_31ae451ec8b1bc838bff1acce280b4f1f7a48fa5_1.json----ssl3_send_client_verify,"int ssl3_send_client_verify(SSL *s) { unsigned char *p,*d; unsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH]; EVP_PKEY *pkey; EVP_PKEY_CTX *pctx=NULL; <S2SV_StartVul> #ifndef OPENSSL_NO_RSA <S2SV_EndVul> unsigned u=0; <S2SV_StartVul> #endif <S2SV_EndVul> unsigned long n; int j; if (s->state == SSL3_ST_CW_CERT_VRFY_A) { d=(unsigned char *)s->init_buf->data; p= &(d[4]); pkey=s->cert->key->privatekey; pctx = EVP_PKEY_CTX_new(pkey,NULL); EVP_PKEY_sign_init(pctx); if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0) { <S2SV_StartVul> s->method->ssl3_enc->cert_verify_mac(s, <S2SV_EndVul> NID_sha1, &(data[MD5_DIGEST_LENGTH])); } else { ERR_clear_error(); } #ifndef OPENSSL_NO_RSA if (pkey->type == EVP_PKEY_RSA) { s->method->ssl3_enc->cert_verify_mac(s, NID_md5, &(data[0])); if (RSA_sign(NID_md5_sha1, data, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, &(p[2]), &u, pkey->pkey.rsa) <= 0 ) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB); goto err; } s2n(u,p); n=u+2; } else #endif #ifndef OPENSSL_NO_DSA if (pkey->type == EVP_PKEY_DSA) { if (!DSA_sign(pkey->save_type, &(data[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,&(p[2]), (unsigned int *)&j,pkey->pkey.dsa)) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB); goto err; } s2n(j,p); n=j+2; } else #endif #ifndef OPENSSL_NO_ECDSA if (pkey->type == EVP_PKEY_EC) { if (!ECDSA_sign(pkey->save_type, &(data[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,&(p[2]), (unsigned int *)&j,pkey->pkey.ec)) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_ECDSA_LIB); goto err; } s2n(j,p); n=j+2; } else #endif if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) { unsigned char signbuf[64]; int i; size_t sigsize=64; s->method->ssl3_enc->cert_verify_mac(s, NID_id_GostR3411_94, data); if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR); goto err; } for (i=63,j=0; i>=0; j++, i--) { p[2+j]=signbuf[i]; } s2n(j,p); n=j+2; } else { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR); goto err; } *(d++)=SSL3_MT_CERTIFICATE_VERIFY; l2n3(n,d); s->state=SSL3_ST_CW_CERT_VRFY_B; s->init_num=(int)n+4; s->init_off=0; } EVP_PKEY_CTX_free(pctx); return(ssl3_do_write(s,SSL3_RT_HANDSHAKE)); err: EVP_PKEY_CTX_free(pctx); return(-1); }","- #ifndef OPENSSL_NO_RSA
- #endif
- s->method->ssl3_enc->cert_verify_mac(s,
+ EVP_MD_CTX mctx;
+ EVP_MD_CTX_init(&mctx);
+ if (s->version < TLS1_2_VERSION)
+ s->method->ssl3_enc->cert_verify_mac(s,
+ if (s->version >= TLS1_2_VERSION)
+ {
+ long hdatalen = 0;
+ void *hdata;
+ const EVP_MD *md = s->cert->key->digest;
+ hdatalen = BIO_get_mem_data(s->s3->handshake_buffer,
+ &hdata);
+ if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md))
+ {
+ SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
+ ERR_R_INTERNAL_ERROR);
+ goto err;
+ }
+ p += 2;
+ #ifdef SSL_DEBUG
+ fprintf(stderr, ""Using TLS 1.2 with client alg %s\n"",
+ EVP_MD_name(md));
+ #endif
+ if (!EVP_SignInit_ex(&mctx, md, NULL)
+ || !EVP_SignUpdate(&mctx, hdata, hdatalen)
+ || !EVP_SignFinal(&mctx, p + 2, &u, pkey))
+ {
+ SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,
+ ERR_R_EVP_LIB);
+ goto err;
+ }
+ s2n(u,p);
+ n = u + 4;
+ if (!ssl3_digest_cached_records(s))
+ goto err;
+ }
+ else
+ EVP_MD_CTX_cleanup(&mctx);
+ EVP_MD_CTX_cleanup(&mctx);","int ssl3_send_client_verify(SSL *s) { unsigned char *p,*d; unsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH]; EVP_PKEY *pkey; EVP_PKEY_CTX *pctx=NULL; EVP_MD_CTX mctx; unsigned u=0; unsigned long n; int j; EVP_MD_CTX_init(&mctx); if (s->state == SSL3_ST_CW_CERT_VRFY_A) { d=(unsigned char *)s->init_buf->data; p= &(d[4]); pkey=s->cert->key->privatekey; pctx = EVP_PKEY_CTX_new(pkey,NULL); EVP_PKEY_sign_init(pctx); if (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0) { if (s->version < TLS1_2_VERSION) s->method->ssl3_enc->cert_verify_mac(s, NID_sha1, &(data[MD5_DIGEST_LENGTH])); } else { ERR_clear_error(); } if (s->version >= TLS1_2_VERSION) { long hdatalen = 0; void *hdata; const EVP_MD *md = s->cert->key->digest; hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md)) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR); goto err; } p += 2; #ifdef SSL_DEBUG fprintf(stderr, ""Using TLS 1.2 with client alg %s\n"", EVP_MD_name(md)); #endif if (!EVP_SignInit_ex(&mctx, md, NULL) || !EVP_SignUpdate(&mctx, hdata, hdatalen) || !EVP_SignFinal(&mctx, p + 2, &u, pkey)) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_EVP_LIB); goto err; } s2n(u,p); n = u + 4; if (!ssl3_digest_cached_records(s)) goto err; } else #ifndef OPENSSL_NO_RSA if (pkey->type == EVP_PKEY_RSA) { s->method->ssl3_enc->cert_verify_mac(s, NID_md5, &(data[0])); if (RSA_sign(NID_md5_sha1, data, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, &(p[2]), &u, pkey->pkey.rsa) <= 0 ) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB); goto err; } s2n(u,p); n=u+2; } else #endif #ifndef OPENSSL_NO_DSA if (pkey->type == EVP_PKEY_DSA) { if (!DSA_sign(pkey->save_type, &(data[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,&(p[2]), (unsigned int *)&j,pkey->pkey.dsa)) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB); goto err; } s2n(j,p); n=j+2; } else #endif #ifndef OPENSSL_NO_ECDSA if (pkey->type == EVP_PKEY_EC) { if (!ECDSA_sign(pkey->save_type, &(data[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,&(p[2]), (unsigned int *)&j,pkey->pkey.ec)) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_ECDSA_LIB); goto err; } s2n(j,p); n=j+2; } else #endif if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) { unsigned char signbuf[64]; int i; size_t sigsize=64; s->method->ssl3_enc->cert_verify_mac(s, NID_id_GostR3411_94, data); if (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY, ERR_R_INTERNAL_ERROR); goto err; } for (i=63,j=0; i>=0; j++, i--) { p[2+j]=signbuf[i]; } s2n(j,p); n=j+2; } else { SSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR); goto err; } *(d++)=SSL3_MT_CERTIFICATE_VERIFY; l2n3(n,d); s->state=SSL3_ST_CW_CERT_VRFY_B; s->init_num=(int)n+4; s->init_off=0; } EVP_MD_CTX_cleanup(&mctx); EVP_PKEY_CTX_free(pctx); return(ssl3_do_write(s,SSL3_RT_HANDSHAKE)); err: EVP_MD_CTX_cleanup(&mctx); EVP_PKEY_CTX_free(pctx); return(-1); }"
61----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03af53a08437977a98869b09c34e92667684b965_1.json----av_packet_split_side_data,"int av_packet_split_side_data(AVPacket *pkt){ if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){ int i; unsigned int size; uint8_t *p; <S2SV_StartVul> av_dup_packet(pkt); <S2SV_EndVul> p = pkt->data + pkt->size - 8 - 5; for (i=1; ; i++){ size = AV_RB32(p); if (size>INT_MAX || p - pkt->data <= size) return 0; if (p[4]&128) break; p-= size+5; } pkt->side_data = av_malloc(i * sizeof(*pkt->side_data)); if (!pkt->side_data) return AVERROR(ENOMEM); p= pkt->data + pkt->size - 8 - 5; for (i=0; ; i++){ size= AV_RB32(p); av_assert0(size<=INT_MAX && p - pkt->data > size); pkt->side_data[i].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); pkt->side_data[i].size = size; pkt->side_data[i].type = p[4]&127; if (!pkt->side_data[i].data) return AVERROR(ENOMEM); memcpy(pkt->side_data[i].data, p-size, size); pkt->size -= size + 5; if(p[4]&128) break; p-= size+5; } pkt->size -= 8; pkt->side_data_elems = i+1; return 1; } return 0; }",- av_dup_packet(pkt);,"int av_packet_split_side_data(AVPacket *pkt){ if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){ int i; unsigned int size; uint8_t *p; p = pkt->data + pkt->size - 8 - 5; for (i=1; ; i++){ size = AV_RB32(p); if (size>INT_MAX || p - pkt->data <= size) return 0; if (p[4]&128) break; p-= size+5; } pkt->side_data = av_malloc(i * sizeof(*pkt->side_data)); if (!pkt->side_data) return AVERROR(ENOMEM); p= pkt->data + pkt->size - 8 - 5; for (i=0; ; i++){ size= AV_RB32(p); av_assert0(size<=INT_MAX && p - pkt->data > size); pkt->side_data[i].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE); pkt->side_data[i].size = size; pkt->side_data[i].type = p[4]&127; if (!pkt->side_data[i].data) return AVERROR(ENOMEM); memcpy(pkt->side_data[i].data, p-size, size); pkt->size -= size + 5; if(p[4]&128) break; p-= size+5; } pkt->size -= 8; pkt->side_data_elems = i+1; return 1; } return 0; }"
5357----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_189515a40204c431d8255dc93c743c5dc0c1887f_1.json----seg_write_packet,"static int seg_write_packet(AVFormatContext *s, AVPacket *pkt) { SegmentContext *seg = s->priv_data; AVFormatContext *oc = seg->avf; AVStream *st = s->streams[pkt->stream_index]; int64_t end_pts = seg->recording_time * seg->number; int ret, can_split = 1; if (!oc) return AVERROR(EINVAL); if (seg->has_video) { can_split = st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pkt->flags & AV_PKT_FLAG_KEY; } if (can_split && av_compare_ts(pkt->pts, st->time_base, end_pts, AV_TIME_BASE_Q) >= 0) { av_log(s, AV_LOG_DEBUG, ""Next segment starts at %d %""PRId64""\n"", pkt->stream_index, pkt->pts); ret = segment_end(oc, seg->individual_header_trailer); if (!ret) ret = segment_start(s, seg->individual_header_trailer); if (ret) goto fail; oc = seg->avf; if (seg->list) { if (seg->list_type == LIST_HLS) { if ((ret = segment_hls_window(s, 0)) < 0) goto fail; } else { avio_printf(seg->pb, ""%s\n"", oc->filename); avio_flush(seg->pb); if (seg->size && !(seg->number % seg->size)) { <S2SV_StartVul> avio_closep(&seg->pb); <S2SV_EndVul> <S2SV_StartVul> if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE, <S2SV_EndVul> <S2SV_StartVul> &s->interrupt_callback, NULL)) < 0) <S2SV_EndVul> goto fail; } } } } ret = ff_write_chained(oc, pkt->stream_index, pkt, s); fail: if (ret < 0) seg_free_context(seg); return ret; }","- avio_closep(&seg->pb);
- if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,
- &s->interrupt_callback, NULL)) < 0)
+ ff_format_io_close(s, &seg->pb);
+ if ((ret = s->io_open(s, &seg->pb, seg->list,
+ AVIO_FLAG_WRITE, NULL)) < 0)","static int seg_write_packet(AVFormatContext *s, AVPacket *pkt) { SegmentContext *seg = s->priv_data; AVFormatContext *oc = seg->avf; AVStream *st = s->streams[pkt->stream_index]; int64_t end_pts = seg->recording_time * seg->number; int ret, can_split = 1; if (!oc) return AVERROR(EINVAL); if (seg->has_video) { can_split = st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pkt->flags & AV_PKT_FLAG_KEY; } if (can_split && av_compare_ts(pkt->pts, st->time_base, end_pts, AV_TIME_BASE_Q) >= 0) { av_log(s, AV_LOG_DEBUG, ""Next segment starts at %d %""PRId64""\n"", pkt->stream_index, pkt->pts); ret = segment_end(oc, seg->individual_header_trailer); if (!ret) ret = segment_start(s, seg->individual_header_trailer); if (ret) goto fail; oc = seg->avf; if (seg->list) { if (seg->list_type == LIST_HLS) { if ((ret = segment_hls_window(s, 0)) < 0) goto fail; } else { avio_printf(seg->pb, ""%s\n"", oc->filename); avio_flush(seg->pb); if (seg->size && !(seg->number % seg->size)) { ff_format_io_close(s, &seg->pb); if ((ret = s->io_open(s, &seg->pb, seg->list, AVIO_FLAG_WRITE, NULL)) < 0) goto fail; } } } } ret = ff_write_chained(oc, pkt->stream_index, pkt, s); fail: if (ret < 0) seg_free_context(seg); return ret; }"
4873----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_9e38c15ecc5080516b876f1b81a3655b27f7ebf2_1.json----log_cookie,"static const char *log_cookie(request_rec *r, char *a) { const char *cookies_entry; if ((cookies_entry = apr_table_get(r->headers_in, ""Cookie""))) { char *cookie, *last1, *last2; char *cookies = apr_pstrdup(r->pool, cookies_entry); while ((cookie = apr_strtok(cookies, "";"", &last1))) { char *name = apr_strtok(cookie, ""="", &last2); <S2SV_StartVul> if (name) { <S2SV_EndVul> <S2SV_StartVul> char *value = name + strlen(name) + 1; <S2SV_EndVul> <S2SV_StartVul> apr_collapse_spaces(name, name); <S2SV_EndVul> if (!strcasecmp(name, a)) { <S2SV_StartVul> char *last; <S2SV_EndVul> <S2SV_StartVul> value += strspn(value, "" \t""); <S2SV_EndVul> <S2SV_StartVul> last = value + strlen(value) - 1; <S2SV_EndVul> while (last >= value && apr_isspace(*last)) { *last = '\0'; --last; } return ap_escape_logitem(r->pool, value); } } cookies = NULL; } } return NULL; }","- if (name) {
- char *value = name + strlen(name) + 1;
- apr_collapse_spaces(name, name);
- char *last;
- last = value + strlen(value) - 1;
+ char *value = last2;
+ if (name && *name && value && *value) {
+ char *last = value - 2;
+ name += strspn(name, "" \t"");
+ while (last >= name && apr_isspace(*last)) {
+ --last;
+ }
+ last = last1 - (*last1 ? 2 : 1);
+ value += strspn(value, "" \t"");","static const char *log_cookie(request_rec *r, char *a) { const char *cookies_entry; if ((cookies_entry = apr_table_get(r->headers_in, ""Cookie""))) { char *cookie, *last1, *last2; char *cookies = apr_pstrdup(r->pool, cookies_entry); while ((cookie = apr_strtok(cookies, "";"", &last1))) { char *name = apr_strtok(cookie, ""="", &last2); char *value = last2; if (name && *name && value && *value) { char *last = value - 2; name += strspn(name, "" \t""); while (last >= name && apr_isspace(*last)) { *last = '\0'; --last; } if (!strcasecmp(name, a)) { last = last1 - (*last1 ? 2 : 1); value += strspn(value, "" \t""); while (last >= value && apr_isspace(*last)) { *last = '\0'; --last; } return ap_escape_logitem(r->pool, value); } } cookies = NULL; } } return NULL; }"
10313----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_01b416b52ae95c48debaf21b8a9849a75f2055dc_1.json----RSA_print,"int RSA_print(BIO *bp, const RSA *x, int off) { char str[128]; const char *s; unsigned char *m=NULL; int ret=0; size_t buf_len=0, i; if (x->n) buf_len = (size_t)BN_num_bytes(x->n); if (x->e) if (buf_len < (i = (size_t)BN_num_bytes(x->e))) buf_len = i; if (x->d) if (buf_len < (i = (size_t)BN_num_bytes(x->d))) buf_len = i; if (x->p) if (buf_len < (i = (size_t)BN_num_bytes(x->p))) buf_len = i; if (x->q) if (buf_len < (i = (size_t)BN_num_bytes(x->q))) buf_len = i; if (x->dmp1) if (buf_len < (i = (size_t)BN_num_bytes(x->dmp1))) buf_len = i; if (x->dmq1) if (buf_len < (i = (size_t)BN_num_bytes(x->dmq1))) buf_len = i; if (x->iqmp) if (buf_len < (i = (size_t)BN_num_bytes(x->iqmp))) buf_len = i; m=(unsigned char *)OPENSSL_malloc(buf_len+10); if (m == NULL) { RSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE); goto err; } if (x->d != NULL) { if(!BIO_indent(bp,off,128)) goto err; if (BIO_printf(bp,""Private-Key: (%d bit)\n"",BN_num_bits(x->n)) <= 0) goto err; } if (x->d == NULL) <S2SV_StartVul> sprintf(str,""Modulus (%d bit):"",BN_num_bits(x->n)); <S2SV_EndVul> else <S2SV_StartVul> strcpy(str,""modulus:""); <S2SV_EndVul> if (!print(bp,str,x->n,m,off)) goto err; s=(x->d == NULL)?""Exponent:"":""publicExponent:""; if (!print(bp,s,x->e,m,off)) goto err; if (!print(bp,""privateExponent:"",x->d,m,off)) goto err; if (!print(bp,""prime1:"",x->p,m,off)) goto err; if (!print(bp,""prime2:"",x->q,m,off)) goto err; if (!print(bp,""exponent1:"",x->dmp1,m,off)) goto err; if (!print(bp,""exponent2:"",x->dmq1,m,off)) goto err; if (!print(bp,""coefficient:"",x->iqmp,m,off)) goto err; ret=1; err: if (m != NULL) OPENSSL_free(m); return(ret); }","- sprintf(str,""Modulus (%d bit):"",BN_num_bits(x->n));
- strcpy(str,""modulus:"");
+ BIO_snprintf(str,sizeof str,""Modulus (%d bit):"",BN_num_bits(x->n));
+ BUF_strlcpy(str,""modulus:"",sizeof str);","int RSA_print(BIO *bp, const RSA *x, int off) { char str[128]; const char *s; unsigned char *m=NULL; int ret=0; size_t buf_len=0, i; if (x->n) buf_len = (size_t)BN_num_bytes(x->n); if (x->e) if (buf_len < (i = (size_t)BN_num_bytes(x->e))) buf_len = i; if (x->d) if (buf_len < (i = (size_t)BN_num_bytes(x->d))) buf_len = i; if (x->p) if (buf_len < (i = (size_t)BN_num_bytes(x->p))) buf_len = i; if (x->q) if (buf_len < (i = (size_t)BN_num_bytes(x->q))) buf_len = i; if (x->dmp1) if (buf_len < (i = (size_t)BN_num_bytes(x->dmp1))) buf_len = i; if (x->dmq1) if (buf_len < (i = (size_t)BN_num_bytes(x->dmq1))) buf_len = i; if (x->iqmp) if (buf_len < (i = (size_t)BN_num_bytes(x->iqmp))) buf_len = i; m=(unsigned char *)OPENSSL_malloc(buf_len+10); if (m == NULL) { RSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE); goto err; } if (x->d != NULL) { if(!BIO_indent(bp,off,128)) goto err; if (BIO_printf(bp,""Private-Key: (%d bit)\n"",BN_num_bits(x->n)) <= 0) goto err; } if (x->d == NULL) BIO_snprintf(str,sizeof str,""Modulus (%d bit):"",BN_num_bits(x->n)); else BUF_strlcpy(str,""modulus:"",sizeof str); if (!print(bp,str,x->n,m,off)) goto err; s=(x->d == NULL)?""Exponent:"":""publicExponent:""; if (!print(bp,s,x->e,m,off)) goto err; if (!print(bp,""privateExponent:"",x->d,m,off)) goto err; if (!print(bp,""prime1:"",x->p,m,off)) goto err; if (!print(bp,""prime2:"",x->q,m,off)) goto err; if (!print(bp,""exponent1:"",x->dmp1,m,off)) goto err; if (!print(bp,""exponent2:"",x->dmq1,m,off)) goto err; if (!print(bp,""coefficient:"",x->iqmp,m,off)) goto err; ret=1; err: if (m != NULL) OPENSSL_free(m); return(ret); }"
11088----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1ccc4bec9f1bb2f12b91b3254023b89d6c677300_1.json----pkey_GOST94cp_decrypt,"int pkey_GOST94cp_decrypt (EVP_PKEY_CTX *ctx, unsigned char *key, size_t *key_len,const unsigned char *in, size_t in_len) { <S2SV_StartVul> DH *dh = DH_new(); <S2SV_EndVul> const unsigned char *p = in; GOST_KEY_TRANSPORT *gkt = NULL; unsigned char wrappedKey[44]; unsigned char sharedKey[32]; gost_ctx cctx; const struct gost_cipher_info *param=NULL; EVP_PKEY *eph_key=NULL; EVP_PKEY *priv= EVP_PKEY_CTX_get0_pkey(ctx); if (!key) { *key_len = 32; return 1; } <S2SV_StartVul> dh->g = BN_dup(priv->pkey.dsa->g); <S2SV_EndVul> <S2SV_StartVul> dh->p = BN_dup(priv->pkey.dsa->p); <S2SV_EndVul> <S2SV_StartVul> dh->priv_key = BN_dup(priv->pkey.dsa->priv_key); <S2SV_EndVul> gkt = d2i_GOST_KEY_TRANSPORT(NULL,(const unsigned char **)&p, in_len); if (!gkt) { GOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO); <S2SV_StartVul> DH_free(dh); <S2SV_EndVul> return 0; } eph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key); param = get_encryption_params(gkt->key_agreement_info->cipher); gost_init(&cctx,param->sblock); OPENSSL_assert(gkt->key_agreement_info->eph_iv->length==8); memcpy(wrappedKey,gkt->key_agreement_info->eph_iv->data,8); OPENSSL_assert(gkt->key_info->encrypted_key->length==32); memcpy(wrappedKey+8,gkt->key_info->encrypted_key->data,32); OPENSSL_assert(gkt->key_info->imit->length==4); memcpy(wrappedKey+40,gkt->key_info->imit->data,4); <S2SV_StartVul> make_cp_exchange_key(dh,eph_key,sharedKey); <S2SV_EndVul> if (!keyUnwrapCryptoPro(&cctx,sharedKey,wrappedKey,key)) { GOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT, GOST_R_ERROR_COMPUTING_SHARED_KEY); goto err; } EVP_PKEY_free(eph_key); GOST_KEY_TRANSPORT_free(gkt); <S2SV_StartVul> DH_free(dh); <S2SV_EndVul> return 1; err: EVP_PKEY_free(eph_key); GOST_KEY_TRANSPORT_free(gkt); <S2SV_StartVul> DH_free(dh); <S2SV_EndVul> return -1; }","- DH *dh = DH_new();
- dh->g = BN_dup(priv->pkey.dsa->g);
- dh->p = BN_dup(priv->pkey.dsa->p);
- dh->priv_key = BN_dup(priv->pkey.dsa->priv_key);
- DH_free(dh);
- make_cp_exchange_key(dh,eph_key,sharedKey);
- DH_free(dh);
- DH_free(dh);
+ if (!eph_key) {
+ eph_key = EVP_PKEY_CTX_get0_peerkey(ctx);
+ if (! eph_key) {
+ GOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,
+ GOST_R_NO_PEER_KEY);
+ goto err;
+ }
+ CRYPTO_add(&(eph_key->references),1 ,CRYPTO_LOCK_EVP_PKEY);
+ }
+ make_cp_exchange_key(gost_get0_priv_key(priv),eph_key,sharedKey);","int pkey_GOST94cp_decrypt (EVP_PKEY_CTX *ctx, unsigned char *key, size_t *key_len,const unsigned char *in, size_t in_len) { const unsigned char *p = in; GOST_KEY_TRANSPORT *gkt = NULL; unsigned char wrappedKey[44]; unsigned char sharedKey[32]; gost_ctx cctx; const struct gost_cipher_info *param=NULL; EVP_PKEY *eph_key=NULL; EVP_PKEY *priv= EVP_PKEY_CTX_get0_pkey(ctx); if (!key) { *key_len = 32; return 1; } gkt = d2i_GOST_KEY_TRANSPORT(NULL,(const unsigned char **)&p, in_len); if (!gkt) { GOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO); return 0; } eph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key); if (!eph_key) { eph_key = EVP_PKEY_CTX_get0_peerkey(ctx); if (! eph_key) { GOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT, GOST_R_NO_PEER_KEY); goto err; } CRYPTO_add(&(eph_key->references),1 ,CRYPTO_LOCK_EVP_PKEY); } param = get_encryption_params(gkt->key_agreement_info->cipher); gost_init(&cctx,param->sblock); OPENSSL_assert(gkt->key_agreement_info->eph_iv->length==8); memcpy(wrappedKey,gkt->key_agreement_info->eph_iv->data,8); OPENSSL_assert(gkt->key_info->encrypted_key->length==32); memcpy(wrappedKey+8,gkt->key_info->encrypted_key->data,32); OPENSSL_assert(gkt->key_info->imit->length==4); memcpy(wrappedKey+40,gkt->key_info->imit->data,4); make_cp_exchange_key(gost_get0_priv_key(priv),eph_key,sharedKey); if (!keyUnwrapCryptoPro(&cctx,sharedKey,wrappedKey,key)) { GOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT, GOST_R_ERROR_COMPUTING_SHARED_KEY); goto err; } EVP_PKEY_free(eph_key); GOST_KEY_TRANSPORT_free(gkt); return 1; err: EVP_PKEY_free(eph_key); GOST_KEY_TRANSPORT_free(gkt); return -1; }"
882----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_305f479e04cc476e60c41a5c23fa9c803d21c655_1.json----decode_init,"static av_cold int decode_init(AVCodecContext *avctx) { WMAProDecodeCtx *s = avctx->priv_data; uint8_t *edata_ptr = avctx->extradata; unsigned int channel_mask; int i, bits; int log2_max_num_subframes; int num_possible_block_sizes; if (avctx->codec_id == AV_CODEC_ID_XMA1 || avctx->codec_id == AV_CODEC_ID_XMA2) avctx->block_align = 2048; if (!avctx->block_align) { av_log(avctx, AV_LOG_ERROR, ""block_align is not set\n""); return AVERROR(EINVAL); } s->avctx = avctx; s->fdsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT); if (!s->fdsp) return AVERROR(ENOMEM); init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE); avctx->sample_fmt = AV_SAMPLE_FMT_FLTP; if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size >= 34) { s->decode_flags = 0x10d6; channel_mask = AV_RL32(edata_ptr+2); s->bits_per_sample = 16; for (i = 0; i < avctx->extradata_size; i++) ff_dlog(avctx, ""[%x] "", avctx->extradata[i]); ff_dlog(avctx, ""\n""); } else if (avctx->codec_id == AV_CODEC_ID_XMA1 && avctx->extradata_size >= 28) { s->decode_flags = 0x10d6; s->bits_per_sample = 16; channel_mask = 0; for (i = 0; i < avctx->extradata_size; i++) ff_dlog(avctx, ""[%x] "", avctx->extradata[i]); ff_dlog(avctx, ""\n""); } else if (avctx->extradata_size >= 18) { s->decode_flags = AV_RL16(edata_ptr+14); channel_mask = AV_RL32(edata_ptr+2); s->bits_per_sample = AV_RL16(edata_ptr); for (i = 0; i < avctx->extradata_size; i++) ff_dlog(avctx, ""[%x] "", avctx->extradata[i]); ff_dlog(avctx, ""\n""); } else { avpriv_request_sample(avctx, ""Unknown extradata size""); return AVERROR_PATCHWELCOME; } if (avctx->codec_id != AV_CODEC_ID_WMAPRO && avctx->channels > 2) { avpriv_report_missing_feature(avctx, "">2 channels support""); return AVERROR_PATCHWELCOME; } s->log2_frame_size = av_log2(avctx->block_align) + 4; if (s->log2_frame_size > 25) { avpriv_request_sample(avctx, ""Large block align""); return AVERROR_PATCHWELCOME; } if (avctx->codec_id != AV_CODEC_ID_WMAPRO) s->skip_frame = 0; else s->skip_frame = 1; s->packet_loss = 1; s->len_prefix = (s->decode_flags & 0x40); if (avctx->codec_id == AV_CODEC_ID_WMAPRO) { bits = ff_wma_get_frame_len_bits(avctx->sample_rate, 3, s->decode_flags); if (bits > WMAPRO_BLOCK_MAX_BITS) { avpriv_request_sample(avctx, ""14-bit block sizes""); return AVERROR_PATCHWELCOME; } s->samples_per_frame = 1 << bits; } else { s->samples_per_frame = 512; } log2_max_num_subframes = ((s->decode_flags & 0x38) >> 3); s->max_num_subframes = 1 << log2_max_num_subframes; if (s->max_num_subframes == 16 || s->max_num_subframes == 4) s->max_subframe_len_bit = 1; s->subframe_len_bits = av_log2(log2_max_num_subframes) + 1; num_possible_block_sizes = log2_max_num_subframes + 1; s->min_samples_per_subframe = s->samples_per_frame / s->max_num_subframes; s->dynamic_range_compression = (s->decode_flags & 0x80); if (s->max_num_subframes > MAX_SUBFRAMES) { av_log(avctx, AV_LOG_ERROR, ""invalid number of subframes %""PRId8""\n"", s->max_num_subframes); return AVERROR_INVALIDDATA; } if (s->min_samples_per_subframe < WMAPRO_BLOCK_MIN_SIZE) { av_log(avctx, AV_LOG_ERROR, ""min_samples_per_subframe of %d too small\n"", s->min_samples_per_subframe); return AVERROR_INVALIDDATA; } if (s->avctx->sample_rate <= 0) { av_log(avctx, AV_LOG_ERROR, ""invalid sample rate\n""); return AVERROR_INVALIDDATA; } if (avctx->channels < 0) { av_log(avctx, AV_LOG_ERROR, ""invalid number of channels %d\n"", avctx->channels); return AVERROR_INVALIDDATA; } else if (avctx->channels > WMAPRO_MAX_CHANNELS) { avpriv_request_sample(avctx, ""More than %d channels"", WMAPRO_MAX_CHANNELS); return AVERROR_PATCHWELCOME; } for (i = 0; i < avctx->channels; i++) s->channel[i].prev_block_len = s->samples_per_frame; s->lfe_channel = -1; if (channel_mask & 8) { unsigned int mask; for (mask = 1; mask < 16; mask <<= 1) { if (channel_mask & mask) ++s->lfe_channel; } } INIT_VLC_STATIC(&sf_vlc, SCALEVLCBITS, HUFF_SCALE_SIZE, scale_huffbits, 1, 1, scale_huffcodes, 2, 2, 616); INIT_VLC_STATIC(&sf_rl_vlc, VLCBITS, HUFF_SCALE_RL_SIZE, scale_rl_huffbits, 1, 1, scale_rl_huffcodes, 4, 4, 1406); INIT_VLC_STATIC(&coef_vlc[0], VLCBITS, HUFF_COEF0_SIZE, coef0_huffbits, 1, 1, coef0_huffcodes, 4, 4, 2108); INIT_VLC_STATIC(&coef_vlc[1], VLCBITS, HUFF_COEF1_SIZE, coef1_huffbits, 1, 1, coef1_huffcodes, 4, 4, 3912); INIT_VLC_STATIC(&vec4_vlc, VLCBITS, HUFF_VEC4_SIZE, vec4_huffbits, 1, 1, vec4_huffcodes, 2, 2, 604); INIT_VLC_STATIC(&vec2_vlc, VLCBITS, HUFF_VEC2_SIZE, vec2_huffbits, 1, 1, vec2_huffcodes, 2, 2, 562); INIT_VLC_STATIC(&vec1_vlc, VLCBITS, HUFF_VEC1_SIZE, vec1_huffbits, 1, 1, vec1_huffcodes, 2, 2, 562); for (i = 0; i < num_possible_block_sizes; i++) { int subframe_len = s->samples_per_frame >> i; int x; int band = 1; int rate = get_rate(avctx); s->sfb_offsets[i][0] = 0; for (x = 0; x < MAX_BANDS-1 && s->sfb_offsets[i][band - 1] < subframe_len; x++) { int offset = (subframe_len * 2 * critical_freq[x]) / rate + 2; offset &= ~3; if (offset > s->sfb_offsets[i][band - 1]) s->sfb_offsets[i][band++] = offset; if (offset >= subframe_len) break; } s->sfb_offsets[i][band - 1] = subframe_len; s->num_sfb[i] = band - 1; if (s->num_sfb[i] <= 0) { av_log(avctx, AV_LOG_ERROR, ""num_sfb invalid\n""); return AVERROR_INVALIDDATA; } } for (i = 0; i < num_possible_block_sizes; i++) { int b; for (b = 0; b < s->num_sfb[i]; b++) { int x; int offset = ((s->sfb_offsets[i][b] + s->sfb_offsets[i][b + 1] - 1) << i) >> 1; for (x = 0; x < num_possible_block_sizes; x++) { int v = 0; while (s->sfb_offsets[x][v + 1] << x < offset) { v++; av_assert0(v < MAX_BANDS); } s->sf_offsets[i][x][b] = v; } } } for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) ff_mdct_init(&s->mdct_ctx[i], WMAPRO_BLOCK_MIN_BITS+1+i, 1, 1.0 / (1 << (WMAPRO_BLOCK_MIN_BITS + i - 1)) / (1 << (s->bits_per_sample - 1))); for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) { const int win_idx = WMAPRO_BLOCK_MAX_BITS - i; ff_init_ff_sine_windows(win_idx); s->windows[WMAPRO_BLOCK_SIZES - i - 1] = ff_sine_windows[win_idx]; } for (i = 0; i < num_possible_block_sizes; i++) { int block_size = s->samples_per_frame >> i; <S2SV_StartVul> int cutoff = (440*block_size + 3 * (s->avctx->sample_rate >> 1) - 1) <S2SV_EndVul> / s->avctx->sample_rate; s->subwoofer_cutoffs[i] = av_clip(cutoff, 4, block_size); } for (i = 0; i < 33; i++) sin64[i] = sin(i*M_PI / 64.0); if (avctx->debug & FF_DEBUG_BITSTREAM) dump_context(s); avctx->channel_layout = channel_mask; return 0; }","- int cutoff = (440*block_size + 3 * (s->avctx->sample_rate >> 1) - 1)
+ int cutoff = (440*block_size + 3LL * (s->avctx->sample_rate >> 1) - 1)","static av_cold int decode_init(AVCodecContext *avctx) { WMAProDecodeCtx *s = avctx->priv_data; uint8_t *edata_ptr = avctx->extradata; unsigned int channel_mask; int i, bits; int log2_max_num_subframes; int num_possible_block_sizes; if (avctx->codec_id == AV_CODEC_ID_XMA1 || avctx->codec_id == AV_CODEC_ID_XMA2) avctx->block_align = 2048; if (!avctx->block_align) { av_log(avctx, AV_LOG_ERROR, ""block_align is not set\n""); return AVERROR(EINVAL); } s->avctx = avctx; s->fdsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT); if (!s->fdsp) return AVERROR(ENOMEM); init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE); avctx->sample_fmt = AV_SAMPLE_FMT_FLTP; if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size >= 34) { s->decode_flags = 0x10d6; channel_mask = AV_RL32(edata_ptr+2); s->bits_per_sample = 16; for (i = 0; i < avctx->extradata_size; i++) ff_dlog(avctx, ""[%x] "", avctx->extradata[i]); ff_dlog(avctx, ""\n""); } else if (avctx->codec_id == AV_CODEC_ID_XMA1 && avctx->extradata_size >= 28) { s->decode_flags = 0x10d6; s->bits_per_sample = 16; channel_mask = 0; for (i = 0; i < avctx->extradata_size; i++) ff_dlog(avctx, ""[%x] "", avctx->extradata[i]); ff_dlog(avctx, ""\n""); } else if (avctx->extradata_size >= 18) { s->decode_flags = AV_RL16(edata_ptr+14); channel_mask = AV_RL32(edata_ptr+2); s->bits_per_sample = AV_RL16(edata_ptr); for (i = 0; i < avctx->extradata_size; i++) ff_dlog(avctx, ""[%x] "", avctx->extradata[i]); ff_dlog(avctx, ""\n""); } else { avpriv_request_sample(avctx, ""Unknown extradata size""); return AVERROR_PATCHWELCOME; } if (avctx->codec_id != AV_CODEC_ID_WMAPRO && avctx->channels > 2) { avpriv_report_missing_feature(avctx, "">2 channels support""); return AVERROR_PATCHWELCOME; } s->log2_frame_size = av_log2(avctx->block_align) + 4; if (s->log2_frame_size > 25) { avpriv_request_sample(avctx, ""Large block align""); return AVERROR_PATCHWELCOME; } if (avctx->codec_id != AV_CODEC_ID_WMAPRO) s->skip_frame = 0; else s->skip_frame = 1; s->packet_loss = 1; s->len_prefix = (s->decode_flags & 0x40); if (avctx->codec_id == AV_CODEC_ID_WMAPRO) { bits = ff_wma_get_frame_len_bits(avctx->sample_rate, 3, s->decode_flags); if (bits > WMAPRO_BLOCK_MAX_BITS) { avpriv_request_sample(avctx, ""14-bit block sizes""); return AVERROR_PATCHWELCOME; } s->samples_per_frame = 1 << bits; } else { s->samples_per_frame = 512; } log2_max_num_subframes = ((s->decode_flags & 0x38) >> 3); s->max_num_subframes = 1 << log2_max_num_subframes; if (s->max_num_subframes == 16 || s->max_num_subframes == 4) s->max_subframe_len_bit = 1; s->subframe_len_bits = av_log2(log2_max_num_subframes) + 1; num_possible_block_sizes = log2_max_num_subframes + 1; s->min_samples_per_subframe = s->samples_per_frame / s->max_num_subframes; s->dynamic_range_compression = (s->decode_flags & 0x80); if (s->max_num_subframes > MAX_SUBFRAMES) { av_log(avctx, AV_LOG_ERROR, ""invalid number of subframes %""PRId8""\n"", s->max_num_subframes); return AVERROR_INVALIDDATA; } if (s->min_samples_per_subframe < WMAPRO_BLOCK_MIN_SIZE) { av_log(avctx, AV_LOG_ERROR, ""min_samples_per_subframe of %d too small\n"", s->min_samples_per_subframe); return AVERROR_INVALIDDATA; } if (s->avctx->sample_rate <= 0) { av_log(avctx, AV_LOG_ERROR, ""invalid sample rate\n""); return AVERROR_INVALIDDATA; } if (avctx->channels < 0) { av_log(avctx, AV_LOG_ERROR, ""invalid number of channels %d\n"", avctx->channels); return AVERROR_INVALIDDATA; } else if (avctx->channels > WMAPRO_MAX_CHANNELS) { avpriv_request_sample(avctx, ""More than %d channels"", WMAPRO_MAX_CHANNELS); return AVERROR_PATCHWELCOME; } for (i = 0; i < avctx->channels; i++) s->channel[i].prev_block_len = s->samples_per_frame; s->lfe_channel = -1; if (channel_mask & 8) { unsigned int mask; for (mask = 1; mask < 16; mask <<= 1) { if (channel_mask & mask) ++s->lfe_channel; } } INIT_VLC_STATIC(&sf_vlc, SCALEVLCBITS, HUFF_SCALE_SIZE, scale_huffbits, 1, 1, scale_huffcodes, 2, 2, 616); INIT_VLC_STATIC(&sf_rl_vlc, VLCBITS, HUFF_SCALE_RL_SIZE, scale_rl_huffbits, 1, 1, scale_rl_huffcodes, 4, 4, 1406); INIT_VLC_STATIC(&coef_vlc[0], VLCBITS, HUFF_COEF0_SIZE, coef0_huffbits, 1, 1, coef0_huffcodes, 4, 4, 2108); INIT_VLC_STATIC(&coef_vlc[1], VLCBITS, HUFF_COEF1_SIZE, coef1_huffbits, 1, 1, coef1_huffcodes, 4, 4, 3912); INIT_VLC_STATIC(&vec4_vlc, VLCBITS, HUFF_VEC4_SIZE, vec4_huffbits, 1, 1, vec4_huffcodes, 2, 2, 604); INIT_VLC_STATIC(&vec2_vlc, VLCBITS, HUFF_VEC2_SIZE, vec2_huffbits, 1, 1, vec2_huffcodes, 2, 2, 562); INIT_VLC_STATIC(&vec1_vlc, VLCBITS, HUFF_VEC1_SIZE, vec1_huffbits, 1, 1, vec1_huffcodes, 2, 2, 562); for (i = 0; i < num_possible_block_sizes; i++) { int subframe_len = s->samples_per_frame >> i; int x; int band = 1; int rate = get_rate(avctx); s->sfb_offsets[i][0] = 0; for (x = 0; x < MAX_BANDS-1 && s->sfb_offsets[i][band - 1] < subframe_len; x++) { int offset = (subframe_len * 2 * critical_freq[x]) / rate + 2; offset &= ~3; if (offset > s->sfb_offsets[i][band - 1]) s->sfb_offsets[i][band++] = offset; if (offset >= subframe_len) break; } s->sfb_offsets[i][band - 1] = subframe_len; s->num_sfb[i] = band - 1; if (s->num_sfb[i] <= 0) { av_log(avctx, AV_LOG_ERROR, ""num_sfb invalid\n""); return AVERROR_INVALIDDATA; } } for (i = 0; i < num_possible_block_sizes; i++) { int b; for (b = 0; b < s->num_sfb[i]; b++) { int x; int offset = ((s->sfb_offsets[i][b] + s->sfb_offsets[i][b + 1] - 1) << i) >> 1; for (x = 0; x < num_possible_block_sizes; x++) { int v = 0; while (s->sfb_offsets[x][v + 1] << x < offset) { v++; av_assert0(v < MAX_BANDS); } s->sf_offsets[i][x][b] = v; } } } for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) ff_mdct_init(&s->mdct_ctx[i], WMAPRO_BLOCK_MIN_BITS+1+i, 1, 1.0 / (1 << (WMAPRO_BLOCK_MIN_BITS + i - 1)) / (1 << (s->bits_per_sample - 1))); for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) { const int win_idx = WMAPRO_BLOCK_MAX_BITS - i; ff_init_ff_sine_windows(win_idx); s->windows[WMAPRO_BLOCK_SIZES - i - 1] = ff_sine_windows[win_idx]; } for (i = 0; i < num_possible_block_sizes; i++) { int block_size = s->samples_per_frame >> i; int cutoff = (440*block_size + 3LL * (s->avctx->sample_rate >> 1) - 1) / s->avctx->sample_rate; s->subwoofer_cutoffs[i] = av_clip(cutoff, 4, block_size); } for (i = 0; i < 33; i++) sin64[i] = sin(i*M_PI / 64.0); if (avctx->debug & FF_DEBUG_BITSTREAM) dump_context(s); avctx->channel_layout = channel_mask; return 0; }"
4292----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e8821820c3fc981f317f2b4d41d3c3723df8c187_1.json----transcode_subtitles,"static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output) { AVSubtitle subtitle; int i, ret = avcodec_decode_subtitle2(ist->dec_ctx, &subtitle, got_output, pkt); <S2SV_StartVul> if (*got_output || ret<0) <S2SV_EndVul> <S2SV_StartVul> decode_error_stat[ret<0] ++; <S2SV_EndVul> <S2SV_StartVul> if (ret < 0 && exit_on_error) <S2SV_EndVul> <S2SV_StartVul> exit_program(1); <S2SV_EndVul> if (ret < 0 || !*got_output) { if (!pkt->size) sub2video_flush(ist); return ret; } if (ist->fix_sub_duration) { int end = 1; if (ist->prev_sub.got_output) { end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts, 1000, AV_TIME_BASE); if (end < ist->prev_sub.subtitle.end_display_time) { av_log(ist->dec_ctx, AV_LOG_DEBUG, ""Subtitle duration reduced from %d to %d%s\n"", ist->prev_sub.subtitle.end_display_time, end, end <= 0 ? "", dropping it"" : """"); ist->prev_sub.subtitle.end_display_time = end; } } FFSWAP(int, *got_output, ist->prev_sub.got_output); FFSWAP(int, ret, ist->prev_sub.ret); FFSWAP(AVSubtitle, subtitle, ist->prev_sub.subtitle); if (end <= 0) goto out; } if (!*got_output) return ret; sub2video_update(ist, &subtitle); if (!subtitle.num_rects) goto out; ist->frames_decoded++; for (i = 0; i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || !ost->encoding_needed || ost->enc->type != AVMEDIA_TYPE_SUBTITLE) continue; do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle); } out: avsubtitle_free(&subtitle); return ret; }","- if (*got_output || ret<0)
- decode_error_stat[ret<0] ++;
- if (ret < 0 && exit_on_error)
- exit_program(1);
+ check_decode_result(got_output, ret);","static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output) { AVSubtitle subtitle; int i, ret = avcodec_decode_subtitle2(ist->dec_ctx, &subtitle, got_output, pkt); check_decode_result(got_output, ret); if (ret < 0 || !*got_output) { if (!pkt->size) sub2video_flush(ist); return ret; } if (ist->fix_sub_duration) { int end = 1; if (ist->prev_sub.got_output) { end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts, 1000, AV_TIME_BASE); if (end < ist->prev_sub.subtitle.end_display_time) { av_log(ist->dec_ctx, AV_LOG_DEBUG, ""Subtitle duration reduced from %d to %d%s\n"", ist->prev_sub.subtitle.end_display_time, end, end <= 0 ? "", dropping it"" : """"); ist->prev_sub.subtitle.end_display_time = end; } } FFSWAP(int, *got_output, ist->prev_sub.got_output); FFSWAP(int, ret, ist->prev_sub.ret); FFSWAP(AVSubtitle, subtitle, ist->prev_sub.subtitle); if (end <= 0) goto out; } if (!*got_output) return ret; sub2video_update(ist, &subtitle); if (!subtitle.num_rects) goto out; ist->frames_decoded++; for (i = 0; i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || !ost->encoding_needed || ost->enc->type != AVMEDIA_TYPE_SUBTITLE) continue; do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle); } out: avsubtitle_free(&subtitle); return ret; }"
8605----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d8baca8c57eeca5cce4c5929ac81c2c02cd84fea_1.json----pred_temp_direct_motion,"static void pred_temp_direct_motion(const H264Context *const h, H264SliceContext *sl, int *mb_type) { int b8_stride = 2; int b4_stride = h->b_stride; int mb_xy = sl->mb_xy, mb_y = sl->mb_y; int mb_type_col[2]; const int16_t (*l1mv0)[2], (*l1mv1)[2]; const int8_t *l1ref0, *l1ref1; const int is_b8x8 = IS_8X8(*mb_type); unsigned int sub_mb_type; int i8, i4; assert(sl->ref_list[1][0].reference & 3); <S2SV_StartVul> await_reference_mb_row(h, sl->ref_list[1][0].parent, <S2SV_EndVul> sl->mb_y + !!IS_INTERLACED(*mb_type)); if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { if (!IS_INTERLACED(*mb_type)) { mb_y = (sl->mb_y & ~1) + sl->col_parity; mb_xy = sl->mb_x + ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride; b8_stride = 0; } else { mb_y += sl->col_fieldoff; mb_xy += h->mb_stride * sl->col_fieldoff; } goto single_col; } else { if (IS_INTERLACED(*mb_type)) { mb_y = sl->mb_y & ~1; mb_xy = sl->mb_x + (sl->mb_y & ~1) * h->mb_stride; mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy]; mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride]; b8_stride = 2 + 4 * h->mb_stride; b4_stride *= 6; if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { mb_type_col[0] &= ~MB_TYPE_INTERLACED; mb_type_col[1] &= ~MB_TYPE_INTERLACED; } sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) && (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) && !is_b8x8) { *mb_type |= MB_TYPE_16x8 | MB_TYPE_L0L1 | MB_TYPE_DIRECT2; } else { *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1; } } else { single_col: mb_type_col[0] = mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy]; sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) { *mb_type |= MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; } else if (!is_b8x8 && (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) { *mb_type |= MB_TYPE_L0L1 | MB_TYPE_DIRECT2 | (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16)); } else { if (!h->ps.sps->direct_8x8_inference_flag) { sub_mb_type = MB_TYPE_8x8 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; } *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1; } } } <S2SV_StartVul> await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y); <S2SV_EndVul> l1mv0 = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]]; l1mv1 = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]]; l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy]; l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy]; if (!b8_stride) { if (sl->mb_y & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4_stride; l1mv1 += 2 * b4_stride; } } { const int *map_col_to_list0[2] = { sl->map_col_to_list0[0], sl->map_col_to_list0[1] }; const int *dist_scale_factor = sl->dist_scale_factor; int ref_offset; if (FRAME_MBAFF(h) && IS_INTERLACED(*mb_type)) { map_col_to_list0[0] = sl->map_col_to_list0_field[sl->mb_y & 1][0]; map_col_to_list0[1] = sl->map_col_to_list0_field[sl->mb_y & 1][1]; dist_scale_factor = sl->dist_scale_factor_field[sl->mb_y & 1]; } ref_offset = (sl->ref_list[1][0].parent->mbaff << 4) & (mb_type_col[0] >> 3); if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) { int y_shift = 2 * !IS_INTERLACED(*mb_type); assert(h->ps.sps->direct_8x8_inference_flag); for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; int ref0, scale; const int16_t (*l1mv)[2] = l1mv0; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1); if (IS_INTRA(mb_type_col[y8])) { fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1); fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8 * b8_stride]; if (ref0 >= 0) ref0 = map_col_to_list0[0][ref0 + ref_offset]; else { ref0 = map_col_to_list0[1][l1ref1[x8 + y8 * b8_stride] + ref_offset]; l1mv = l1mv1; } scale = dist_scale_factor[ref0]; fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, ref0, 1); { const int16_t *mv_col = l1mv[x8 * 3 + y8 * b4_stride]; int my_col = (mv_col[1] << y_shift) / 2; int mx = (scale * mv_col[0] + 128) >> 8; int my = (scale * my_col + 128) >> 8; fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx, my), 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx - mv_col[0], my - my_col), 4); } } return; } if (IS_16X16(*mb_type)) { int ref, mv0, mv1; fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1); if (IS_INTRA(mb_type_col[0])) { ref = mv0 = mv1 = 0; } else { const int ref0 = l1ref0[0] >= 0 ? map_col_to_list0[0][l1ref0[0] + ref_offset] : map_col_to_list0[1][l1ref1[0] + ref_offset]; const int scale = dist_scale_factor[ref0]; const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0]; int mv_l0[2]; mv_l0[0] = (scale * mv_col[0] + 128) >> 8; mv_l0[1] = (scale * mv_col[1] + 128) >> 8; ref = ref0; mv0 = pack16to32(mv_l0[0], mv_l0[1]); mv1 = pack16to32(mv_l0[0] - mv_col[0], mv_l0[1] - mv_col[1]); } fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1); fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, mv0, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, mv1, 4); } else { for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; int ref0, scale; const int16_t (*l1mv)[2] = l1mv0; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1); if (IS_INTRA(mb_type_col[0])) { fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1); fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); continue; } assert(b8_stride == 2); ref0 = l1ref0[i8]; if (ref0 >= 0) ref0 = map_col_to_list0[0][ref0 + ref_offset]; else { ref0 = map_col_to_list0[1][l1ref1[i8] + ref_offset]; l1mv = l1mv1; } scale = dist_scale_factor[ref0]; fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, ref0, 1); if (IS_SUB_8X8(sub_mb_type)) { const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride]; int mx = (scale * mv_col[0] + 128) >> 8; int my = (scale * mv_col[1] + 128) >> 8; fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx, my), 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx - mv_col[0], my - mv_col[1]), 4); } else { for (i4 = 0; i4 < 4; i4++) { const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4_stride]; int16_t *mv_l0 = sl->mv_cache[0][scan8[i8 * 4 + i4]]; mv_l0[0] = (scale * mv_col[0] + 128) >> 8; mv_l0[1] = (scale * mv_col[1] + 128) >> 8; AV_WN32A(sl->mv_cache[1][scan8[i8 * 4 + i4]], pack16to32(mv_l0[0] - mv_col[0], mv_l0[1] - mv_col[1])); } } } } } }","- await_reference_mb_row(h, sl->ref_list[1][0].parent,
- await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);
+ await_reference_mb_row(h, &sl->ref_list[1][0],
+ await_reference_mb_row(h, &sl->ref_list[1][0], mb_y);","static void pred_temp_direct_motion(const H264Context *const h, H264SliceContext *sl, int *mb_type) { int b8_stride = 2; int b4_stride = h->b_stride; int mb_xy = sl->mb_xy, mb_y = sl->mb_y; int mb_type_col[2]; const int16_t (*l1mv0)[2], (*l1mv1)[2]; const int8_t *l1ref0, *l1ref1; const int is_b8x8 = IS_8X8(*mb_type); unsigned int sub_mb_type; int i8, i4; assert(sl->ref_list[1][0].reference & 3); await_reference_mb_row(h, &sl->ref_list[1][0], sl->mb_y + !!IS_INTERLACED(*mb_type)); if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { if (!IS_INTERLACED(*mb_type)) { mb_y = (sl->mb_y & ~1) + sl->col_parity; mb_xy = sl->mb_x + ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride; b8_stride = 0; } else { mb_y += sl->col_fieldoff; mb_xy += h->mb_stride * sl->col_fieldoff; } goto single_col; } else { if (IS_INTERLACED(*mb_type)) { mb_y = sl->mb_y & ~1; mb_xy = sl->mb_x + (sl->mb_y & ~1) * h->mb_stride; mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy]; mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride]; b8_stride = 2 + 4 * h->mb_stride; b4_stride *= 6; if (IS_INTERLACED(mb_type_col[0]) != IS_INTERLACED(mb_type_col[1])) { mb_type_col[0] &= ~MB_TYPE_INTERLACED; mb_type_col[1] &= ~MB_TYPE_INTERLACED; } sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) && (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) && !is_b8x8) { *mb_type |= MB_TYPE_16x8 | MB_TYPE_L0L1 | MB_TYPE_DIRECT2; } else { *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1; } } else { single_col: mb_type_col[0] = mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy]; sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) { *mb_type |= MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; } else if (!is_b8x8 && (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) { *mb_type |= MB_TYPE_L0L1 | MB_TYPE_DIRECT2 | (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16)); } else { if (!h->ps.sps->direct_8x8_inference_flag) { sub_mb_type = MB_TYPE_8x8 | MB_TYPE_P0L0 | MB_TYPE_P0L1 | MB_TYPE_DIRECT2; } *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1; } } } await_reference_mb_row(h, &sl->ref_list[1][0], mb_y); l1mv0 = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]]; l1mv1 = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]]; l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy]; l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy]; if (!b8_stride) { if (sl->mb_y & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4_stride; l1mv1 += 2 * b4_stride; } } { const int *map_col_to_list0[2] = { sl->map_col_to_list0[0], sl->map_col_to_list0[1] }; const int *dist_scale_factor = sl->dist_scale_factor; int ref_offset; if (FRAME_MBAFF(h) && IS_INTERLACED(*mb_type)) { map_col_to_list0[0] = sl->map_col_to_list0_field[sl->mb_y & 1][0]; map_col_to_list0[1] = sl->map_col_to_list0_field[sl->mb_y & 1][1]; dist_scale_factor = sl->dist_scale_factor_field[sl->mb_y & 1]; } ref_offset = (sl->ref_list[1][0].parent->mbaff << 4) & (mb_type_col[0] >> 3); if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) { int y_shift = 2 * !IS_INTERLACED(*mb_type); assert(h->ps.sps->direct_8x8_inference_flag); for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; int ref0, scale; const int16_t (*l1mv)[2] = l1mv0; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1); if (IS_INTRA(mb_type_col[y8])) { fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1); fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8 * b8_stride]; if (ref0 >= 0) ref0 = map_col_to_list0[0][ref0 + ref_offset]; else { ref0 = map_col_to_list0[1][l1ref1[x8 + y8 * b8_stride] + ref_offset]; l1mv = l1mv1; } scale = dist_scale_factor[ref0]; fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, ref0, 1); { const int16_t *mv_col = l1mv[x8 * 3 + y8 * b4_stride]; int my_col = (mv_col[1] << y_shift) / 2; int mx = (scale * mv_col[0] + 128) >> 8; int my = (scale * my_col + 128) >> 8; fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx, my), 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx - mv_col[0], my - my_col), 4); } } return; } if (IS_16X16(*mb_type)) { int ref, mv0, mv1; fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1); if (IS_INTRA(mb_type_col[0])) { ref = mv0 = mv1 = 0; } else { const int ref0 = l1ref0[0] >= 0 ? map_col_to_list0[0][l1ref0[0] + ref_offset] : map_col_to_list0[1][l1ref1[0] + ref_offset]; const int scale = dist_scale_factor[ref0]; const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0]; int mv_l0[2]; mv_l0[0] = (scale * mv_col[0] + 128) >> 8; mv_l0[1] = (scale * mv_col[1] + 128) >> 8; ref = ref0; mv0 = pack16to32(mv_l0[0], mv_l0[1]); mv1 = pack16to32(mv_l0[0] - mv_col[0], mv_l0[1] - mv_col[1]); } fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1); fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, mv0, 4); fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, mv1, 4); } else { for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; int ref0, scale; const int16_t (*l1mv)[2] = l1mv0; if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8])) continue; sl->sub_mb_type[i8] = sub_mb_type; fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1); if (IS_INTRA(mb_type_col[0])) { fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1); fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); continue; } assert(b8_stride == 2); ref0 = l1ref0[i8]; if (ref0 >= 0) ref0 = map_col_to_list0[0][ref0 + ref_offset]; else { ref0 = map_col_to_list0[1][l1ref1[i8] + ref_offset]; l1mv = l1mv1; } scale = dist_scale_factor[ref0]; fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, ref0, 1); if (IS_SUB_8X8(sub_mb_type)) { const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride]; int mx = (scale * mv_col[0] + 128) >> 8; int my = (scale * mv_col[1] + 128) >> 8; fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx, my), 4); fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, pack16to32(mx - mv_col[0], my - mv_col[1]), 4); } else { for (i4 = 0; i4 < 4; i4++) { const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4_stride]; int16_t *mv_l0 = sl->mv_cache[0][scan8[i8 * 4 + i4]]; mv_l0[0] = (scale * mv_col[0] + 128) >> 8; mv_l0[1] = (scale * mv_col[1] + 128) >> 8; AV_WN32A(sl->mv_cache[1][scan8[i8 * 4 + i4]], pack16to32(mv_l0[0] - mv_col[0], mv_l0[1] - mv_col[1])); } } } } } }"
9324----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_2009d201808b1157aeecc5c6bf454cccce991338_1.json----EstimateStripByteCounts,"static int EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount) { static const char module[] = ""EstimateStripByteCounts""; TIFFDirEntry *dp; TIFFDirectory *td = &tif->tif_dir; uint32 strip; if( !_TIFFFillStrilesInternal( tif, 0 ) ) return -1; <S2SV_StartVul> if (td->td_stripbytecount) <S2SV_EndVul> <S2SV_StartVul> _TIFFfree(td->td_stripbytecount); <S2SV_EndVul> <S2SV_StartVul> td->td_stripbytecount = (uint64*) <S2SV_EndVul> _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64), ""for \""StripByteCounts\"" array""); <S2SV_StartVul> if( td->td_stripbytecount == NULL ) <S2SV_EndVul> return -1; if (td->td_compression != COMPRESSION_NONE) { uint64 space; uint64 filesize; uint16 n; filesize = TIFFGetFileSize(tif); if (!(tif->tif_flags&TIFF_BIGTIFF)) space=sizeof(TIFFHeaderClassic)+2+dircount*12+4; else space=sizeof(TIFFHeaderBig)+8+dircount*20+8; for (dp = dir, n = dircount; n > 0; n--, dp++) { uint32 typewidth; uint64 datasize; typewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type); if (typewidth == 0) { TIFFErrorExt(tif->tif_clientdata, module, ""Cannot determine size of unknown tag type %d"", dp->tdir_type); return -1; } datasize=(uint64)typewidth*dp->tdir_count; if (!(tif->tif_flags&TIFF_BIGTIFF)) { if (datasize<=4) datasize=0; } else { if (datasize<=8) datasize=0; } space+=datasize; } if( filesize < space ) space = filesize; else space = filesize - space; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) space /= td->td_samplesperpixel; for (strip = 0; strip < td->td_nstrips; strip++) <S2SV_StartVul> td->td_stripbytecount[strip] = space; <S2SV_EndVul> strip--; <S2SV_StartVul> if (td->td_stripoffset[strip]+td->td_stripbytecount[strip] > filesize) <S2SV_EndVul> <S2SV_StartVul> td->td_stripbytecount[strip] = filesize - td->td_stripoffset[strip]; <S2SV_EndVul> } else if (isTiled(tif)) { uint64 bytespertile = TIFFTileSize64(tif); for (strip = 0; strip < td->td_nstrips; strip++) <S2SV_StartVul> td->td_stripbytecount[strip] = bytespertile; <S2SV_EndVul> } else { uint64 rowbytes = TIFFScanlineSize64(tif); uint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage; for (strip = 0; strip < td->td_nstrips; strip++) <S2SV_StartVul> td->td_stripbytecount[strip] = rowbytes * rowsperstrip; <S2SV_EndVul> } TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS); if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP)) td->td_rowsperstrip = td->td_imagelength; return 1; }","- if (td->td_stripbytecount)
- _TIFFfree(td->td_stripbytecount);
- td->td_stripbytecount = (uint64*)
- if( td->td_stripbytecount == NULL )
- td->td_stripbytecount[strip] = space;
- if (td->td_stripoffset[strip]+td->td_stripbytecount[strip] > filesize)
- td->td_stripbytecount[strip] = filesize - td->td_stripoffset[strip];
- td->td_stripbytecount[strip] = bytespertile;
- td->td_stripbytecount[strip] = rowbytes * rowsperstrip;
+ if (td->td_stripbytecount_p)
+ _TIFFfree(td->td_stripbytecount_p);
+ td->td_stripbytecount_p = (uint64*)
+ if( td->td_stripbytecount_p == NULL )
+ td->td_stripbytecount_p[strip] = space;
+ if (td->td_stripoffset_p[strip]+td->td_stripbytecount_p[strip] > filesize)
+ td->td_stripbytecount_p[strip] = filesize - td->td_stripoffset_p[strip];
+ td->td_stripbytecount_p[strip] = bytespertile;
+ td->td_stripbytecount_p[strip] = rowbytes * rowsperstrip;","static int EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount) { static const char module[] = ""EstimateStripByteCounts""; TIFFDirEntry *dp; TIFFDirectory *td = &tif->tif_dir; uint32 strip; if( !_TIFFFillStrilesInternal( tif, 0 ) ) return -1; if (td->td_stripbytecount_p) _TIFFfree(td->td_stripbytecount_p); td->td_stripbytecount_p = (uint64*) _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64), ""for \""StripByteCounts\"" array""); if( td->td_stripbytecount_p == NULL ) return -1; if (td->td_compression != COMPRESSION_NONE) { uint64 space; uint64 filesize; uint16 n; filesize = TIFFGetFileSize(tif); if (!(tif->tif_flags&TIFF_BIGTIFF)) space=sizeof(TIFFHeaderClassic)+2+dircount*12+4; else space=sizeof(TIFFHeaderBig)+8+dircount*20+8; for (dp = dir, n = dircount; n > 0; n--, dp++) { uint32 typewidth; uint64 datasize; typewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type); if (typewidth == 0) { TIFFErrorExt(tif->tif_clientdata, module, ""Cannot determine size of unknown tag type %d"", dp->tdir_type); return -1; } datasize=(uint64)typewidth*dp->tdir_count; if (!(tif->tif_flags&TIFF_BIGTIFF)) { if (datasize<=4) datasize=0; } else { if (datasize<=8) datasize=0; } space+=datasize; } if( filesize < space ) space = filesize; else space = filesize - space; if (td->td_planarconfig == PLANARCONFIG_SEPARATE) space /= td->td_samplesperpixel; for (strip = 0; strip < td->td_nstrips; strip++) td->td_stripbytecount_p[strip] = space; strip--; if (td->td_stripoffset_p[strip]+td->td_stripbytecount_p[strip] > filesize) td->td_stripbytecount_p[strip] = filesize - td->td_stripoffset_p[strip]; } else if (isTiled(tif)) { uint64 bytespertile = TIFFTileSize64(tif); for (strip = 0; strip < td->td_nstrips; strip++) td->td_stripbytecount_p[strip] = bytespertile; } else { uint64 rowbytes = TIFFScanlineSize64(tif); uint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage; for (strip = 0; strip < td->td_nstrips; strip++) td->td_stripbytecount_p[strip] = rowbytes * rowsperstrip; } TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS); if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP)) td->td_rowsperstrip = td->td_imagelength; return 1; }"
16356----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d4df124a04cdb53450c19d310a5e05af95e7b5cf_1.json----SSKDF_mac_kdm,"static int SSKDF_mac_kdm(const EVP_MAC *kdf_mac, const EVP_MD *hmac_md, const unsigned char *kmac_custom, size_t kmac_custom_len, size_t kmac_out_len, const unsigned char *salt, size_t salt_len, const unsigned char *z, size_t z_len, const unsigned char *info, size_t info_len, unsigned char *derived_key, size_t derived_key_len) { int ret = 0; size_t counter, out_len, len; unsigned char c[4]; unsigned char mac_buf[EVP_MAX_MD_SIZE]; unsigned char *out = derived_key; EVP_MAC_CTX *ctx = NULL, *ctx_init = NULL; unsigned char *mac = mac_buf, *kmac_buffer = NULL; if (z_len > SSKDF_MAX_INLEN || info_len > SSKDF_MAX_INLEN || derived_key_len > SSKDF_MAX_INLEN || derived_key_len == 0) return 0; ctx = EVP_MAC_CTX_new(kdf_mac); ctx_init = EVP_MAC_CTX_new(kdf_mac); if (ctx == NULL || ctx_init == NULL) goto end; if (hmac_md != NULL && EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_MD, hmac_md) <= 0) goto end; if (EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_KEY, salt, salt_len) <= 0) goto end; if (!kmac_init(ctx_init, kmac_custom, kmac_custom_len, kmac_out_len, derived_key_len, &kmac_buffer)) goto end; if (kmac_buffer != NULL) mac = kmac_buffer; if (!EVP_MAC_init(ctx_init)) goto end; out_len = EVP_MAC_size(ctx_init); if (out_len <= 0) goto end; len = derived_key_len; for (counter = 1;; counter++) { c[0] = (unsigned char)((counter >> 24) & 0xff); c[1] = (unsigned char)((counter >> 16) & 0xff); c[2] = (unsigned char)((counter >> 8) & 0xff); c[3] = (unsigned char)(counter & 0xff); if (!(EVP_MAC_CTX_copy(ctx, ctx_init) && EVP_MAC_update(ctx, c, sizeof(c)) && EVP_MAC_update(ctx, z, z_len) && EVP_MAC_update(ctx, info, info_len))) goto end; if (len >= out_len) { if (!EVP_MAC_final(ctx, out, NULL)) goto end; out += out_len; len -= out_len; if (len == 0) break; } else { if (!EVP_MAC_final(ctx, mac, NULL)) goto end; memcpy(out, mac, len); break; } } ret = 1; end: <S2SV_StartVul> OPENSSL_free(kmac_buffer); <S2SV_EndVul> EVP_MAC_CTX_free(ctx); EVP_MAC_CTX_free(ctx_init); <S2SV_StartVul> OPENSSL_cleanse(mac, sizeof(mac)); <S2SV_EndVul> return ret; }","- OPENSSL_free(kmac_buffer);
- OPENSSL_cleanse(mac, sizeof(mac));
+ if (kmac_buffer != NULL)
+ OPENSSL_clear_free(kmac_buffer, kmac_out_len);
+ else
+ OPENSSL_cleanse(mac_buf, sizeof(mac_buf));","static int SSKDF_mac_kdm(const EVP_MAC *kdf_mac, const EVP_MD *hmac_md, const unsigned char *kmac_custom, size_t kmac_custom_len, size_t kmac_out_len, const unsigned char *salt, size_t salt_len, const unsigned char *z, size_t z_len, const unsigned char *info, size_t info_len, unsigned char *derived_key, size_t derived_key_len) { int ret = 0; size_t counter, out_len, len; unsigned char c[4]; unsigned char mac_buf[EVP_MAX_MD_SIZE]; unsigned char *out = derived_key; EVP_MAC_CTX *ctx = NULL, *ctx_init = NULL; unsigned char *mac = mac_buf, *kmac_buffer = NULL; if (z_len > SSKDF_MAX_INLEN || info_len > SSKDF_MAX_INLEN || derived_key_len > SSKDF_MAX_INLEN || derived_key_len == 0) return 0; ctx = EVP_MAC_CTX_new(kdf_mac); ctx_init = EVP_MAC_CTX_new(kdf_mac); if (ctx == NULL || ctx_init == NULL) goto end; if (hmac_md != NULL && EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_MD, hmac_md) <= 0) goto end; if (EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_KEY, salt, salt_len) <= 0) goto end; if (!kmac_init(ctx_init, kmac_custom, kmac_custom_len, kmac_out_len, derived_key_len, &kmac_buffer)) goto end; if (kmac_buffer != NULL) mac = kmac_buffer; if (!EVP_MAC_init(ctx_init)) goto end; out_len = EVP_MAC_size(ctx_init); if (out_len <= 0) goto end; len = derived_key_len; for (counter = 1;; counter++) { c[0] = (unsigned char)((counter >> 24) & 0xff); c[1] = (unsigned char)((counter >> 16) & 0xff); c[2] = (unsigned char)((counter >> 8) & 0xff); c[3] = (unsigned char)(counter & 0xff); if (!(EVP_MAC_CTX_copy(ctx, ctx_init) && EVP_MAC_update(ctx, c, sizeof(c)) && EVP_MAC_update(ctx, z, z_len) && EVP_MAC_update(ctx, info, info_len))) goto end; if (len >= out_len) { if (!EVP_MAC_final(ctx, out, NULL)) goto end; out += out_len; len -= out_len; if (len == 0) break; } else { if (!EVP_MAC_final(ctx, mac, NULL)) goto end; memcpy(out, mac, len); break; } } ret = 1; end: if (kmac_buffer != NULL) OPENSSL_clear_free(kmac_buffer, kmac_out_len); else OPENSSL_cleanse(mac_buf, sizeof(mac_buf)); EVP_MAC_CTX_free(ctx); EVP_MAC_CTX_free(ctx_init); return ret; }"
4252----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e61f6c53b7442b55788b83905110430f8205703f_1.json----real_parse_asm_rulebook,"static void real_parse_asm_rulebook(AVFormatContext *s, AVStream *orig_st, const char *p) { const char *end; <S2SV_StartVul> int n_rules, odd = 0; <S2SV_EndVul> AVStream *st; if (*p == '\""') p++; <S2SV_StartVul> for (n_rules = 0; s->nb_streams < MAX_STREAMS;) { <S2SV_EndVul> if (!(end = strchr(p, ';'))) break; if (!odd && end != p) { if (n_rules > 0) st = add_dstream(s, orig_st); else st = orig_st; real_parse_asm_rule(st, p, end); n_rules++; } p = end + 1; odd ^= 1; } }","- int n_rules, odd = 0;
- for (n_rules = 0; s->nb_streams < MAX_STREAMS;) {
+ int n_rules = 0, odd = 0;
+ while (1) {
+ if (!st)
+ break;","static void real_parse_asm_rulebook(AVFormatContext *s, AVStream *orig_st, const char *p) { const char *end; int n_rules = 0, odd = 0; AVStream *st; if (*p == '\""') p++; while (1) { if (!(end = strchr(p, ';'))) break; if (!odd && end != p) { if (n_rules > 0) st = add_dstream(s, orig_st); else st = orig_st; if (!st) break; real_parse_asm_rule(st, p, end); n_rules++; } p = end + 1; odd ^= 1; } }"
13226----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_685770b8fe26f3505731263595e67c3810a173a4_1.json----c2i_ASN1_OBJECT,"ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp, long len) { ASN1_OBJECT *ret=NULL; const unsigned char *p; unsigned char *data; int i; <S2SV_StartVul> for (i = 0, p = *pp + 1; i < len - 1; i++, p++) <S2SV_EndVul> { if (*p == 0x80 && (!i || !(p[-1] & 0x80))) { ASN1err(ASN1_F_C2I_ASN1_OBJECT,ASN1_R_INVALID_OBJECT_ENCODING); return NULL; } } if ((a == NULL) || ((*a) == NULL) || !((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC)) { if ((ret=ASN1_OBJECT_new()) == NULL) return(NULL); } else ret=(*a); p= *pp; data = (unsigned char *)ret->data; ret->data = NULL; if ((data == NULL) || (ret->length < len)) { ret->length=0; if (data != NULL) OPENSSL_free(data); data=(unsigned char *)OPENSSL_malloc(len ? (int)len : 1); if (data == NULL) { i=ERR_R_MALLOC_FAILURE; goto err; } ret->flags|=ASN1_OBJECT_FLAG_DYNAMIC_DATA; } memcpy(data,p,(int)len); ret->data =data; ret->length=(int)len; ret->sn=NULL; ret->ln=NULL; p+=len; if (a != NULL) (*a)=ret; *pp=p; return(ret); err: ASN1err(ASN1_F_C2I_ASN1_OBJECT,i); if ((ret != NULL) && ((a == NULL) || (*a != ret))) ASN1_OBJECT_free(ret); return(NULL); }","- for (i = 0, p = *pp + 1; i < len - 1; i++, p++)
+ for (i = 0, p = *pp; i < len; i++, p++)","ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp, long len) { ASN1_OBJECT *ret=NULL; const unsigned char *p; unsigned char *data; int i; for (i = 0, p = *pp; i < len; i++, p++) { if (*p == 0x80 && (!i || !(p[-1] & 0x80))) { ASN1err(ASN1_F_C2I_ASN1_OBJECT,ASN1_R_INVALID_OBJECT_ENCODING); return NULL; } } if ((a == NULL) || ((*a) == NULL) || !((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC)) { if ((ret=ASN1_OBJECT_new()) == NULL) return(NULL); } else ret=(*a); p= *pp; data = (unsigned char *)ret->data; ret->data = NULL; if ((data == NULL) || (ret->length < len)) { ret->length=0; if (data != NULL) OPENSSL_free(data); data=(unsigned char *)OPENSSL_malloc(len ? (int)len : 1); if (data == NULL) { i=ERR_R_MALLOC_FAILURE; goto err; } ret->flags|=ASN1_OBJECT_FLAG_DYNAMIC_DATA; } memcpy(data,p,(int)len); ret->data =data; ret->length=(int)len; ret->sn=NULL; ret->ln=NULL; p+=len; if (a != NULL) (*a)=ret; *pp=p; return(ret); err: ASN1err(ASN1_F_C2I_ASN1_OBJECT,i); if ((ret != NULL) && ((a == NULL) || (*a != ret))) ASN1_OBJECT_free(ret); return(NULL); }"
4485----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f30306ca4990ce174a45a9ffebb29747a47cb19c_1.json----decode_header,"static int decode_header(PSDContext * s) { <S2SV_StartVul> int signature, version, color_mode, compression; <S2SV_EndVul> int64_t len_section; int ret = 0; if (bytestream2_get_bytes_left(&s->gb) < 30) { av_log(s->avctx, AV_LOG_ERROR, ""Header too short to parse.\n""); return AVERROR_INVALIDDATA; } signature = bytestream2_get_le32(&s->gb); if (signature != MKTAG('8','B','P','S')) { av_log(s->avctx, AV_LOG_ERROR, ""Wrong signature %d.\n"", signature); return AVERROR_INVALIDDATA; } version = bytestream2_get_be16(&s->gb); if (version != 1) { av_log(s->avctx, AV_LOG_ERROR, ""Wrong version %d.\n"", version); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, 6); s->channel_count = bytestream2_get_be16(&s->gb); if ((s->channel_count < 1) || (s->channel_count > 56)) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid channel count %d.\n"", s->channel_count); return AVERROR_INVALIDDATA; } s->height = bytestream2_get_be32(&s->gb); if ((s->height > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) { av_log(s->avctx, AV_LOG_ERROR, ""Height > 30000 is experimental, add "" ""'-strict %d' if you want to try to decode the picture.\n"", FF_COMPLIANCE_EXPERIMENTAL); return AVERROR_EXPERIMENTAL; } s->width = bytestream2_get_be32(&s->gb); if ((s->width > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) { av_log(s->avctx, AV_LOG_ERROR, ""Width > 30000 is experimental, add "" ""'-strict %d' if you want to try to decode the picture.\n"", FF_COMPLIANCE_EXPERIMENTAL); return AVERROR_EXPERIMENTAL; } if ((ret = ff_set_dimensions(s->avctx, s->width, s->height)) < 0) return ret; s->channel_depth = bytestream2_get_be16(&s->gb); color_mode = bytestream2_get_be16(&s->gb); switch (color_mode) { case 0: s->color_mode = PSD_BITMAP; break; case 1: s->color_mode = PSD_GRAYSCALE; break; case 2: s->color_mode = PSD_INDEXED; break; case 3: s->color_mode = PSD_RGB; break; case 4: s->color_mode = PSD_CMYK; break; case 7: s->color_mode = PSD_MULTICHANNEL; break; case 8: s->color_mode = PSD_DUOTONE; break; case 9: s->color_mode = PSD_LAB; break; default: av_log(s->avctx, AV_LOG_ERROR, ""Unknown color mode %d.\n"", color_mode); return AVERROR_INVALIDDATA; } len_section = bytestream2_get_be32(&s->gb); if (len_section < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Negative size for color map data section.\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { av_log(s->avctx, AV_LOG_ERROR, ""Incomplete file.\n""); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, len_section); len_section = bytestream2_get_be32(&s->gb); if (len_section < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Negative size for image ressources section.\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { av_log(s->avctx, AV_LOG_ERROR, ""Incomplete file.\n""); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, len_section); len_section = bytestream2_get_be32(&s->gb); if (len_section < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Negative size for layers and masks data section.\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->gb) < len_section) { av_log(s->avctx, AV_LOG_ERROR, ""Incomplete file.\n""); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, len_section); if (bytestream2_get_bytes_left(&s->gb) < 2) { av_log(s->avctx, AV_LOG_ERROR, ""File without image data section.\n""); return AVERROR_INVALIDDATA; } s->compression = bytestream2_get_be16(&s->gb); switch (s->compression) { case 0: case 1: break; case 2: avpriv_request_sample(s->avctx, ""ZIP without predictor compression""); return AVERROR_PATCHWELCOME; break; case 3: avpriv_request_sample(s->avctx, ""ZIP with predictor compression""); return AVERROR_PATCHWELCOME; break; default: <S2SV_StartVul> av_log(s->avctx, AV_LOG_ERROR, ""Unknown compression %d.\n"", compression); <S2SV_EndVul> return AVERROR_INVALIDDATA; } return ret; }","- int signature, version, color_mode, compression;
- av_log(s->avctx, AV_LOG_ERROR, ""Unknown compression %d.\n"", compression);
+ int signature, version, color_mode;
+ av_log(s->avctx, AV_LOG_ERROR, ""Unknown compression %d.\n"", s->compression);","static int decode_header(PSDContext * s) { int signature, version, color_mode; int64_t len_section; int ret = 0; if (bytestream2_get_bytes_left(&s->gb) < 30) { av_log(s->avctx, AV_LOG_ERROR, ""Header too short to parse.\n""); return AVERROR_INVALIDDATA; } signature = bytestream2_get_le32(&s->gb); if (signature != MKTAG('8','B','P','S')) { av_log(s->avctx, AV_LOG_ERROR, ""Wrong signature %d.\n"", signature); return AVERROR_INVALIDDATA; } version = bytestream2_get_be16(&s->gb); if (version != 1) { av_log(s->avctx, AV_LOG_ERROR, ""Wrong version %d.\n"", version); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, 6); s->channel_count = bytestream2_get_be16(&s->gb); if ((s->channel_count < 1) || (s->channel_count > 56)) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid channel count %d.\n"", s->channel_count); return AVERROR_INVALIDDATA; } s->height = bytestream2_get_be32(&s->gb); if ((s->height > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) { av_log(s->avctx, AV_LOG_ERROR, ""Height > 30000 is experimental, add "" ""'-strict %d' if you want to try to decode the picture.\n"", FF_COMPLIANCE_EXPERIMENTAL); return AVERROR_EXPERIMENTAL; } s->width = bytestream2_get_be32(&s->gb); if ((s->width > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) { av_log(s->avctx, AV_LOG_ERROR, ""Width > 30000 is experimental, add "" ""'-strict %d' if you want to try to decode the picture.\n"", FF_COMPLIANCE_EXPERIMENTAL); return AVERROR_EXPERIMENTAL; } if ((ret = ff_set_dimensions(s->avctx, s->width, s->height)) < 0) return ret; s->channel_depth = bytestream2_get_be16(&s->gb); color_mode = bytestream2_get_be16(&s->gb); switch (color_mode) { case 0: s->color_mode = PSD_BITMAP; break; case 1: s->color_mode = PSD_GRAYSCALE; break; case 2: s->color_mode = PSD_INDEXED; break; case 3: s->color_mode = PSD_RGB; break; case 4: s->color_mode = PSD_CMYK; break; case 7: s->color_mode = PSD_MULTICHANNEL; break; case 8: s->color_mode = PSD_DUOTONE; break; case 9: s->color_mode = PSD_LAB; break; default: av_log(s->avctx, AV_LOG_ERROR, ""Unknown color mode %d.\n"", color_mode); return AVERROR_INVALIDDATA; } len_section = bytestream2_get_be32(&s->gb); if (len_section < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Negative size for color map data section.\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { av_log(s->avctx, AV_LOG_ERROR, ""Incomplete file.\n""); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, len_section); len_section = bytestream2_get_be32(&s->gb); if (len_section < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Negative size for image ressources section.\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { av_log(s->avctx, AV_LOG_ERROR, ""Incomplete file.\n""); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, len_section); len_section = bytestream2_get_be32(&s->gb); if (len_section < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Negative size for layers and masks data section.\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->gb) < len_section) { av_log(s->avctx, AV_LOG_ERROR, ""Incomplete file.\n""); return AVERROR_INVALIDDATA; } bytestream2_skip(&s->gb, len_section); if (bytestream2_get_bytes_left(&s->gb) < 2) { av_log(s->avctx, AV_LOG_ERROR, ""File without image data section.\n""); return AVERROR_INVALIDDATA; } s->compression = bytestream2_get_be16(&s->gb); switch (s->compression) { case 0: case 1: break; case 2: avpriv_request_sample(s->avctx, ""ZIP without predictor compression""); return AVERROR_PATCHWELCOME; break; case 3: avpriv_request_sample(s->avctx, ""ZIP with predictor compression""); return AVERROR_PATCHWELCOME; break; default: av_log(s->avctx, AV_LOG_ERROR, ""Unknown compression %d.\n"", s->compression); return AVERROR_INVALIDDATA; } return ret; }"
12687----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_555b95fa7dd6674978e11f3590ee75fa08e038dd_1.json----tls_construct_client_key_exchange,"int tls_construct_client_key_exchange(SSL *s) { unsigned char *p; int n; #ifndef OPENSSL_NO_PSK size_t pskhdrlen = 0; #endif unsigned long alg_k; #ifndef OPENSSL_NO_RSA unsigned char *q; EVP_PKEY *pkey = NULL; #endif #ifndef OPENSSL_NO_EC EVP_PKEY *ckey = NULL, *skey = NULL; unsigned char *encodedPoint = NULL; int encoded_pt_len = 0; #endif unsigned char *pms = NULL; size_t pmslen = 0; alg_k = s->s3->tmp.new_cipher->algorithm_mkey; p = ssl_handshake_start(s); #ifndef OPENSSL_NO_PSK if (alg_k & SSL_PSK) { int psk_err = 1; char identity[PSK_MAX_IDENTITY_LEN + 1]; size_t identitylen; unsigned char psk[PSK_MAX_PSK_LEN]; size_t psklen; if (s->psk_client_callback == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_PSK_NO_CLIENT_CB); goto err; } memset(identity, 0, sizeof(identity)); psklen = s->psk_client_callback(s, s->session->psk_identity_hint, identity, sizeof(identity) - 1, psk, sizeof(psk)); if (psklen > PSK_MAX_PSK_LEN) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto psk_err; } else if (psklen == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_PSK_IDENTITY_NOT_FOUND); goto psk_err; } OPENSSL_free(s->s3->tmp.psk); <S2SV_StartVul> s->s3->tmp.psk = BUF_memdup(psk, psklen); <S2SV_EndVul> OPENSSL_cleanse(psk, psklen); if (s->s3->tmp.psk == NULL) { OPENSSL_cleanse(identity, sizeof(identity)); goto memerr; } s->s3->tmp.psklen = psklen; identitylen = strlen(identity); if (identitylen > PSK_MAX_IDENTITY_LEN) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto psk_err; } OPENSSL_free(s->session->psk_identity); <S2SV_StartVul> s->session->psk_identity = BUF_strdup(identity); <S2SV_EndVul> if (s->session->psk_identity == NULL) { OPENSSL_cleanse(identity, sizeof(identity)); goto memerr; } s2n(identitylen, p); memcpy(p, identity, identitylen); pskhdrlen = 2 + identitylen; p += identitylen; psk_err = 0; psk_err: OPENSSL_cleanse(identity, sizeof(identity)); if (psk_err != 0) { ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); goto err; } } if (alg_k & SSL_kPSK) { n = 0; } else #endif if (0) { } #ifndef OPENSSL_NO_RSA else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) { RSA *rsa; pmslen = SSL_MAX_MASTER_KEY_LENGTH; pms = OPENSSL_malloc(pmslen); if (pms == NULL) goto memerr; if (s->session->peer == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } pkey = X509_get_pubkey(s->session->peer); if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA) || (pkey->pkey.rsa == NULL)) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); EVP_PKEY_free(pkey); goto err; } rsa = pkey->pkey.rsa; EVP_PKEY_free(pkey); pms[0] = s->client_version >> 8; pms[1] = s->client_version & 0xff; if (RAND_bytes(pms + 2, pmslen - 2) <= 0) goto err; q = p; if (s->version > SSL3_VERSION) p += 2; n = RSA_public_encrypt(pmslen, pms, p, rsa, RSA_PKCS1_PADDING); # ifdef PKCS1_CHECK if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++; if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0] = 0x70; # endif if (n <= 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_BAD_RSA_ENCRYPT); goto err; } if (s->version > SSL3_VERSION) { s2n(n, q); n += 2; } } #endif #ifndef OPENSSL_NO_DH else if (alg_k & (SSL_kDHE | SSL_kDHr | SSL_kDHd | SSL_kDHEPSK)) { DH *dh_srvr, *dh_clnt; if (s->s3->peer_dh_tmp != NULL) dh_srvr = s->s3->peer_dh_tmp; else { EVP_PKEY *spkey = NULL; dh_srvr = NULL; spkey = X509_get_pubkey(s->session->peer); if (spkey) { dh_srvr = EVP_PKEY_get1_DH(spkey); EVP_PKEY_free(spkey); } if (dh_srvr == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } } if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) { EVP_PKEY *clkey = s->cert->key->privatekey; dh_clnt = NULL; if (clkey) dh_clnt = EVP_PKEY_get1_DH(clkey); if (dh_clnt == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } } else { if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB); goto err; } if (!DH_generate_key(dh_clnt)) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB); DH_free(dh_clnt); goto err; } } pmslen = DH_size(dh_clnt); pms = OPENSSL_malloc(pmslen); if (pms == NULL) goto memerr; n = DH_compute_key(pms, dh_srvr->pub_key, dh_clnt); if (s->s3->peer_dh_tmp == NULL) DH_free(dh_srvr); if (n <= 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB); DH_free(dh_clnt); goto err; } pmslen = n; if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) n = 0; else { n = BN_num_bytes(dh_clnt->pub_key); s2n(n, p); BN_bn2bin(dh_clnt->pub_key, p); n += 2; } DH_free(dh_clnt); } #endif #ifndef OPENSSL_NO_EC else if (alg_k & (SSL_kECDHE | SSL_kECDHr | SSL_kECDHe | SSL_kECDHEPSK)) { if (s->s3->peer_tmp != NULL) { skey = s->s3->peer_tmp; } else { skey = X509_get0_pubkey(s->session->peer); if ((skey == NULL) || (skey->type != EVP_PKEY_EC) || (skey->pkey.ec == NULL)) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } } ckey = ssl_generate_pkey(skey, NID_undef); if (ssl_derive(s, ckey, skey) == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB); goto err; } encoded_pt_len = EC_KEY_key2buf(EVP_PKEY_get0_EC_KEY(ckey), POINT_CONVERSION_UNCOMPRESSED, &encodedPoint, NULL); if (encoded_pt_len == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB); goto err; } EVP_PKEY_free(ckey); ckey = NULL; n = encoded_pt_len; *p = n; p += 1; memcpy(p, encodedPoint, n); n += 1; OPENSSL_free(encodedPoint); } #endif #ifndef OPENSSL_NO_GOST else if (alg_k & SSL_kGOST) { EVP_PKEY_CTX *pkey_ctx; X509 *peer_cert; size_t msglen; unsigned int md_len; unsigned char shared_ukm[32], tmp[256]; EVP_MD_CTX *ukm_hash; EVP_PKEY *pub_key; int dgst_nid = NID_id_GostR3411_94; if ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aGOST12) != 0) dgst_nid = NID_id_GostR3411_2012_256; pmslen = 32; pms = OPENSSL_malloc(pmslen); if (pms == NULL) goto memerr; peer_cert = s->session->peer; if (!peer_cert) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER); goto err; } pkey_ctx = EVP_PKEY_CTX_new(pub_key = X509_get_pubkey(peer_cert), NULL); if (pkey_ctx == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE); goto err; } if (pkey_ctx == NULL || EVP_PKEY_encrypt_init(pkey_ctx) <= 0 || RAND_bytes(pms, pmslen) <= 0) { EVP_PKEY_CTX_free(pkey_ctx); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; }; if (s->s3->tmp.cert_req && s->cert->key->privatekey) { if (EVP_PKEY_derive_set_peer (pkey_ctx, s->cert->key->privatekey) <= 0) { ERR_clear_error(); } } ukm_hash = EVP_MD_CTX_new(); if (EVP_DigestInit(ukm_hash, EVP_get_digestbynid(dgst_nid)) <= 0 || EVP_DigestUpdate(ukm_hash, s->s3->client_random, SSL3_RANDOM_SIZE) <= 0 || EVP_DigestUpdate(ukm_hash, s->s3->server_random, SSL3_RANDOM_SIZE) <= 0 || EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) { EVP_MD_CTX_free(ukm_hash); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } EVP_MD_CTX_free(ukm_hash); if (EVP_PKEY_CTX_ctrl (pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) < 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_LIBRARY_BUG); goto err; } *(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED; msglen = 255; if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_LIBRARY_BUG); goto err; } if (msglen >= 0x80) { *(p++) = 0x81; *(p++) = msglen & 0xff; n = msglen + 3; } else { *(p++) = msglen & 0xff; n = msglen + 2; } memcpy(p, tmp, msglen); if (EVP_PKEY_CTX_ctrl (pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) { s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY; } EVP_PKEY_CTX_free(pkey_ctx); EVP_PKEY_free(pub_key); } #endif #ifndef OPENSSL_NO_SRP else if (alg_k & SSL_kSRP) { if (s->srp_ctx.A != NULL) { n = BN_num_bytes(s->srp_ctx.A); s2n(n, p); BN_bn2bin(s->srp_ctx.A, p); n += 2; } else { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } OPENSSL_free(s->session->srp_username); <S2SV_StartVul> s->session->srp_username = BUF_strdup(s->srp_ctx.login); <S2SV_EndVul> if (s->session->srp_username == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE); goto err; } } #endif else { ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } #ifndef OPENSSL_NO_PSK n += pskhdrlen; #endif if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, n)) { ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } if (pms != NULL) { s->s3->tmp.pms = pms; s->s3->tmp.pmslen = pmslen; } return 1; memerr: ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE); err: OPENSSL_clear_free(pms, pmslen); s->s3->tmp.pms = NULL; #ifndef OPENSSL_NO_EC OPENSSL_free(encodedPoint); EVP_PKEY_free(ckey); #endif #ifndef OPENSSL_NO_PSK OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen); s->s3->tmp.psk = NULL; #endif ossl_statem_set_error(s); return 0; }","- s->s3->tmp.psk = BUF_memdup(psk, psklen);
- s->session->psk_identity = BUF_strdup(identity);
- s->session->srp_username = BUF_strdup(s->srp_ctx.login);
+ s->s3->tmp.psk = OPENSSL_memdup(psk, psklen);
+ s->session->psk_identity = OPENSSL_strdup(identity);
+ s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login);","int tls_construct_client_key_exchange(SSL *s) { unsigned char *p; int n; #ifndef OPENSSL_NO_PSK size_t pskhdrlen = 0; #endif unsigned long alg_k; #ifndef OPENSSL_NO_RSA unsigned char *q; EVP_PKEY *pkey = NULL; #endif #ifndef OPENSSL_NO_EC EVP_PKEY *ckey = NULL, *skey = NULL; unsigned char *encodedPoint = NULL; int encoded_pt_len = 0; #endif unsigned char *pms = NULL; size_t pmslen = 0; alg_k = s->s3->tmp.new_cipher->algorithm_mkey; p = ssl_handshake_start(s); #ifndef OPENSSL_NO_PSK if (alg_k & SSL_PSK) { int psk_err = 1; char identity[PSK_MAX_IDENTITY_LEN + 1]; size_t identitylen; unsigned char psk[PSK_MAX_PSK_LEN]; size_t psklen; if (s->psk_client_callback == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_PSK_NO_CLIENT_CB); goto err; } memset(identity, 0, sizeof(identity)); psklen = s->psk_client_callback(s, s->session->psk_identity_hint, identity, sizeof(identity) - 1, psk, sizeof(psk)); if (psklen > PSK_MAX_PSK_LEN) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto psk_err; } else if (psklen == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_PSK_IDENTITY_NOT_FOUND); goto psk_err; } OPENSSL_free(s->s3->tmp.psk); s->s3->tmp.psk = OPENSSL_memdup(psk, psklen); OPENSSL_cleanse(psk, psklen); if (s->s3->tmp.psk == NULL) { OPENSSL_cleanse(identity, sizeof(identity)); goto memerr; } s->s3->tmp.psklen = psklen; identitylen = strlen(identity); if (identitylen > PSK_MAX_IDENTITY_LEN) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto psk_err; } OPENSSL_free(s->session->psk_identity); s->session->psk_identity = OPENSSL_strdup(identity); if (s->session->psk_identity == NULL) { OPENSSL_cleanse(identity, sizeof(identity)); goto memerr; } s2n(identitylen, p); memcpy(p, identity, identitylen); pskhdrlen = 2 + identitylen; p += identitylen; psk_err = 0; psk_err: OPENSSL_cleanse(identity, sizeof(identity)); if (psk_err != 0) { ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); goto err; } } if (alg_k & SSL_kPSK) { n = 0; } else #endif if (0) { } #ifndef OPENSSL_NO_RSA else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) { RSA *rsa; pmslen = SSL_MAX_MASTER_KEY_LENGTH; pms = OPENSSL_malloc(pmslen); if (pms == NULL) goto memerr; if (s->session->peer == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } pkey = X509_get_pubkey(s->session->peer); if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA) || (pkey->pkey.rsa == NULL)) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); EVP_PKEY_free(pkey); goto err; } rsa = pkey->pkey.rsa; EVP_PKEY_free(pkey); pms[0] = s->client_version >> 8; pms[1] = s->client_version & 0xff; if (RAND_bytes(pms + 2, pmslen - 2) <= 0) goto err; q = p; if (s->version > SSL3_VERSION) p += 2; n = RSA_public_encrypt(pmslen, pms, p, rsa, RSA_PKCS1_PADDING); # ifdef PKCS1_CHECK if (s->options & SSL_OP_PKCS1_CHECK_1) p[1]++; if (s->options & SSL_OP_PKCS1_CHECK_2) tmp_buf[0] = 0x70; # endif if (n <= 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_BAD_RSA_ENCRYPT); goto err; } if (s->version > SSL3_VERSION) { s2n(n, q); n += 2; } } #endif #ifndef OPENSSL_NO_DH else if (alg_k & (SSL_kDHE | SSL_kDHr | SSL_kDHd | SSL_kDHEPSK)) { DH *dh_srvr, *dh_clnt; if (s->s3->peer_dh_tmp != NULL) dh_srvr = s->s3->peer_dh_tmp; else { EVP_PKEY *spkey = NULL; dh_srvr = NULL; spkey = X509_get_pubkey(s->session->peer); if (spkey) { dh_srvr = EVP_PKEY_get1_DH(spkey); EVP_PKEY_free(spkey); } if (dh_srvr == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } } if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) { EVP_PKEY *clkey = s->cert->key->privatekey; dh_clnt = NULL; if (clkey) dh_clnt = EVP_PKEY_get1_DH(clkey); if (dh_clnt == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } } else { if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB); goto err; } if (!DH_generate_key(dh_clnt)) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB); DH_free(dh_clnt); goto err; } } pmslen = DH_size(dh_clnt); pms = OPENSSL_malloc(pmslen); if (pms == NULL) goto memerr; n = DH_compute_key(pms, dh_srvr->pub_key, dh_clnt); if (s->s3->peer_dh_tmp == NULL) DH_free(dh_srvr); if (n <= 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB); DH_free(dh_clnt); goto err; } pmslen = n; if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) n = 0; else { n = BN_num_bytes(dh_clnt->pub_key); s2n(n, p); BN_bn2bin(dh_clnt->pub_key, p); n += 2; } DH_free(dh_clnt); } #endif #ifndef OPENSSL_NO_EC else if (alg_k & (SSL_kECDHE | SSL_kECDHr | SSL_kECDHe | SSL_kECDHEPSK)) { if (s->s3->peer_tmp != NULL) { skey = s->s3->peer_tmp; } else { skey = X509_get0_pubkey(s->session->peer); if ((skey == NULL) || (skey->type != EVP_PKEY_EC) || (skey->pkey.ec == NULL)) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } } ckey = ssl_generate_pkey(skey, NID_undef); if (ssl_derive(s, ckey, skey) == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB); goto err; } encoded_pt_len = EC_KEY_key2buf(EVP_PKEY_get0_EC_KEY(ckey), POINT_CONVERSION_UNCOMPRESSED, &encodedPoint, NULL); if (encoded_pt_len == 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB); goto err; } EVP_PKEY_free(ckey); ckey = NULL; n = encoded_pt_len; *p = n; p += 1; memcpy(p, encodedPoint, n); n += 1; OPENSSL_free(encodedPoint); } #endif #ifndef OPENSSL_NO_GOST else if (alg_k & SSL_kGOST) { EVP_PKEY_CTX *pkey_ctx; X509 *peer_cert; size_t msglen; unsigned int md_len; unsigned char shared_ukm[32], tmp[256]; EVP_MD_CTX *ukm_hash; EVP_PKEY *pub_key; int dgst_nid = NID_id_GostR3411_94; if ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aGOST12) != 0) dgst_nid = NID_id_GostR3411_2012_256; pmslen = 32; pms = OPENSSL_malloc(pmslen); if (pms == NULL) goto memerr; peer_cert = s->session->peer; if (!peer_cert) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER); goto err; } pkey_ctx = EVP_PKEY_CTX_new(pub_key = X509_get_pubkey(peer_cert), NULL); if (pkey_ctx == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE); goto err; } if (pkey_ctx == NULL || EVP_PKEY_encrypt_init(pkey_ctx) <= 0 || RAND_bytes(pms, pmslen) <= 0) { EVP_PKEY_CTX_free(pkey_ctx); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; }; if (s->s3->tmp.cert_req && s->cert->key->privatekey) { if (EVP_PKEY_derive_set_peer (pkey_ctx, s->cert->key->privatekey) <= 0) { ERR_clear_error(); } } ukm_hash = EVP_MD_CTX_new(); if (EVP_DigestInit(ukm_hash, EVP_get_digestbynid(dgst_nid)) <= 0 || EVP_DigestUpdate(ukm_hash, s->s3->client_random, SSL3_RANDOM_SIZE) <= 0 || EVP_DigestUpdate(ukm_hash, s->s3->server_random, SSL3_RANDOM_SIZE) <= 0 || EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) { EVP_MD_CTX_free(ukm_hash); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } EVP_MD_CTX_free(ukm_hash); if (EVP_PKEY_CTX_ctrl (pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV, 8, shared_ukm) < 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_LIBRARY_BUG); goto err; } *(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED; msglen = 255; if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, SSL_R_LIBRARY_BUG); goto err; } if (msglen >= 0x80) { *(p++) = 0x81; *(p++) = msglen & 0xff; n = msglen + 3; } else { *(p++) = msglen & 0xff; n = msglen + 2; } memcpy(p, tmp, msglen); if (EVP_PKEY_CTX_ctrl (pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) { s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY; } EVP_PKEY_CTX_free(pkey_ctx); EVP_PKEY_free(pub_key); } #endif #ifndef OPENSSL_NO_SRP else if (alg_k & SSL_kSRP) { if (s->srp_ctx.A != NULL) { n = BN_num_bytes(s->srp_ctx.A); s2n(n, p); BN_bn2bin(s->srp_ctx.A, p); n += 2; } else { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } OPENSSL_free(s->session->srp_username); s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login); if (s->session->srp_username == NULL) { SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE); goto err; } } #endif else { ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } #ifndef OPENSSL_NO_PSK n += pskhdrlen; #endif if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, n)) { ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR); goto err; } if (pms != NULL) { s->s3->tmp.pms = pms; s->s3->tmp.pmslen = pmslen; } return 1; memerr: ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR); SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE); err: OPENSSL_clear_free(pms, pmslen); s->s3->tmp.pms = NULL; #ifndef OPENSSL_NO_EC OPENSSL_free(encodedPoint); EVP_PKEY_free(ckey); #endif #ifndef OPENSSL_NO_PSK OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen); s->s3->tmp.psk = NULL; #endif ossl_statem_set_error(s); return 0; }"
383----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_16590fc2ce552cf93b81ed0cef14e77faa24a66e_1.json----sync,"static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){ RMDemuxContext *rm = s->priv_data; ByteIOContext *pb = s->pb; int len, num, res, i; AVStream *st; uint32_t state=0xFFFFFFFF; while(!url_feof(pb)){ *pos= url_ftell(pb) - 3; if(rm->remaining_len > 0){ num= rm->current_stream; len= rm->remaining_len; *timestamp = AV_NOPTS_VALUE; *flags= 0; }else{ state= (state<<8) + get_byte(pb); if(state == MKBETAG('I', 'N', 'D', 'X')){ len = get_be16(pb) - 6; if(len<0) continue; goto skip; } if(state > (unsigned)0xFFFF || state < 12) continue; len=state; state= 0xFFFFFFFF; num = get_be16(pb); *timestamp = get_be32(pb); res= get_byte(pb); *flags = get_byte(pb); len -= 12; } for(i=0;i<s->nb_streams;i++) { st = s->streams[i]; if (num == st->id) break; } if (i == s->nb_streams) { skip: url_fskip(pb, len); <S2SV_StartVul> rm->remaining_len -= len; <S2SV_EndVul> continue; } *stream_index= i; return len; } return -1; }","- rm->remaining_len -= len;
+ rm->remaining_len = 0;","static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){ RMDemuxContext *rm = s->priv_data; ByteIOContext *pb = s->pb; int len, num, res, i; AVStream *st; uint32_t state=0xFFFFFFFF; while(!url_feof(pb)){ *pos= url_ftell(pb) - 3; if(rm->remaining_len > 0){ num= rm->current_stream; len= rm->remaining_len; *timestamp = AV_NOPTS_VALUE; *flags= 0; }else{ state= (state<<8) + get_byte(pb); if(state == MKBETAG('I', 'N', 'D', 'X')){ len = get_be16(pb) - 6; if(len<0) continue; goto skip; } if(state > (unsigned)0xFFFF || state < 12) continue; len=state; state= 0xFFFFFFFF; num = get_be16(pb); *timestamp = get_be32(pb); res= get_byte(pb); *flags = get_byte(pb); len -= 12; } for(i=0;i<s->nb_streams;i++) { st = s->streams[i]; if (num == st->id) break; } if (i == s->nb_streams) { skip: url_fskip(pb, len); rm->remaining_len = 0; continue; } *stream_index= i; return len; } return -1; }"
5388----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_19f33380a351fd13dae9d2b1716737459927825b_1.json----decode_nal_units,"static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){ MpegEncContext * const s = &h->s; AVCodecContext * const avctx= s->avctx; H264Context *hx; int buf_index; int context_count; int next_avc; int pass = !(avctx->active_thread_type & FF_THREAD_FRAME); int nals_needed=0; int nal_index; <S2SV_StartVul> h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1; <S2SV_EndVul> if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){ h->current_slice = 0; if (!s->first_field) s->current_picture_ptr= NULL; ff_h264_reset_sei(h); } for(;pass <= 1;pass++){ buf_index = 0; context_count = 0; next_avc = h->is_avc ? 0 : buf_size; nal_index = 0; for(;;){ int consumed; int dst_length; int bit_length; uint8_t *ptr; int i, nalsize = 0; int err; if(buf_index >= next_avc) { if (buf_index >= buf_size - h->nal_length_size) break; nalsize = 0; for(i = 0; i < h->nal_length_size; i++) nalsize = (nalsize << 8) | buf[buf_index++]; if(nalsize <= 0 || nalsize > buf_size - buf_index){ av_log(h->s.avctx, AV_LOG_ERROR, ""AVC: nal size %d\n"", nalsize); break; } next_avc= buf_index + nalsize; } else { for(; buf_index + 3 < next_avc; buf_index++){ if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1) break; } if(buf_index+3 >= buf_size) break; buf_index+=3; if(buf_index >= next_avc) continue; } hx = h->thread_context[context_count]; ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index); if (ptr==NULL || dst_length < 0){ return -1; } i= buf_index + consumed; if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc && buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0) s->workaround_bugs |= FF_BUG_TRUNCATED; if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){ while(ptr[dst_length - 1] == 0 && dst_length > 0) dst_length--; } bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1)); if(s->avctx->debug&FF_DEBUG_STARTCODE){ av_log(h->s.avctx, AV_LOG_DEBUG, ""NAL %d at %d/%d length %d\n"", hx->nal_unit_type, buf_index, buf_size, dst_length); } if (h->is_avc && (nalsize != consumed) && nalsize){ if (bit_length & 7) ptr[bit_length >> 3] = ptr[bit_length >> 3] & (0xff << 8 - (bit_length & 7)); av_log(h->s.avctx, AV_LOG_DEBUG, ""AVC: Consumed only %d bytes instead of %d\n"", consumed, nalsize); } buf_index += consumed; nal_index++; if(pass == 0) { switch (hx->nal_unit_type) { case NAL_SPS: case NAL_PPS: nals_needed = nal_index; break; case NAL_IDR_SLICE: case NAL_SLICE: init_get_bits(&hx->s.gb, ptr, bit_length); if (!get_ue_golomb(&hx->s.gb)) nals_needed = nal_index; } continue; } if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc == 0) continue; again: err = 0; switch(hx->nal_unit_type){ case NAL_IDR_SLICE: if (h->nal_unit_type != NAL_IDR_SLICE) { av_log(h->s.avctx, AV_LOG_ERROR, ""Invalid mix of idr and non-idr slices""); return -1; } idr(h); case NAL_SLICE: init_get_bits(&hx->s.gb, ptr, bit_length); hx->intra_gb_ptr= hx->inter_gb_ptr= &hx->s.gb; hx->s.data_partitioning = 0; if((err = decode_slice_header(hx, h))) break; s->current_picture_ptr->f.key_frame |= (hx->nal_unit_type == NAL_IDR_SLICE) || (h->sei_recovery_frame_cnt >= 0); if (h->current_slice == 1) { if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) { decode_postinit(h, nal_index >= nals_needed); } if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0) return -1; if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_h264_picture_start(s); } if(hx->redundant_pic_count==0 && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) && (avctx->skip_frame < AVDISCARD_BIDIR || hx->slice_type_nos!=AV_PICTURE_TYPE_B) && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I) && avctx->skip_frame < AVDISCARD_ALL){ if(avctx->hwaccel) { if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0) return -1; }else if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){ static const uint8_t start_code[] = {0x00, 0x00, 0x01}; ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code)); ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed ); }else context_count++; } break; case NAL_DPA: init_get_bits(&hx->s.gb, ptr, bit_length); hx->intra_gb_ptr= hx->inter_gb_ptr= NULL; if ((err = decode_slice_header(hx, h)) < 0) break; hx->s.data_partitioning = 1; break; case NAL_DPB: init_get_bits(&hx->intra_gb, ptr, bit_length); hx->intra_gb_ptr= &hx->intra_gb; break; case NAL_DPC: init_get_bits(&hx->inter_gb, ptr, bit_length); hx->inter_gb_ptr= &hx->inter_gb; if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning && s->context_initialized && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) && (avctx->skip_frame < AVDISCARD_BIDIR || hx->slice_type_nos!=AV_PICTURE_TYPE_B) && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I) && avctx->skip_frame < AVDISCARD_ALL) context_count++; break; case NAL_SEI: init_get_bits(&s->gb, ptr, bit_length); ff_h264_decode_sei(h); break; case NAL_SPS: init_get_bits(&s->gb, ptr, bit_length); ff_h264_decode_seq_parameter_set(h); if (s->flags& CODEC_FLAG_LOW_DELAY || (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames)) s->low_delay=1; if(avctx->has_b_frames < 2) avctx->has_b_frames= !s->low_delay; if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma || h->cur_chroma_format_idc != h->sps.chroma_format_idc) { if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) { avctx->bits_per_raw_sample = h->sps.bit_depth_luma; h->cur_chroma_format_idc = h->sps.chroma_format_idc; h->pixel_shift = h->sps.bit_depth_luma > 8; ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc); ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc); s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16; dsputil_init(&s->dsp, s->avctx); } else { av_log(avctx, AV_LOG_ERROR, ""Unsupported bit depth: %d\n"", h->sps.bit_depth_luma); return -1; } } break; case NAL_PPS: init_get_bits(&s->gb, ptr, bit_length); ff_h264_decode_picture_parameter_set(h, bit_length); break; case NAL_AUD: case NAL_END_SEQUENCE: case NAL_END_STREAM: case NAL_FILLER_DATA: case NAL_SPS_EXT: case NAL_AUXILIARY_SLICE: break; default: av_log(avctx, AV_LOG_DEBUG, ""Unknown NAL code: %d (%d bits)\n"", hx->nal_unit_type, bit_length); } if(context_count == h->max_contexts) { execute_decode_slices(h, context_count); context_count = 0; } if (err < 0) av_log(h->s.avctx, AV_LOG_ERROR, ""decode_slice_header error\n""); else if(err == 1) { h->nal_unit_type = hx->nal_unit_type; h->nal_ref_idc = hx->nal_ref_idc; hx = h; goto again; } } } if(context_count) execute_decode_slices(h, context_count); return buf_index; }","- h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;
+ h->max_contexts = s->slice_context_count;","static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){ MpegEncContext * const s = &h->s; AVCodecContext * const avctx= s->avctx; H264Context *hx; int buf_index; int context_count; int next_avc; int pass = !(avctx->active_thread_type & FF_THREAD_FRAME); int nals_needed=0; int nal_index; h->max_contexts = s->slice_context_count; if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){ h->current_slice = 0; if (!s->first_field) s->current_picture_ptr= NULL; ff_h264_reset_sei(h); } for(;pass <= 1;pass++){ buf_index = 0; context_count = 0; next_avc = h->is_avc ? 0 : buf_size; nal_index = 0; for(;;){ int consumed; int dst_length; int bit_length; uint8_t *ptr; int i, nalsize = 0; int err; if(buf_index >= next_avc) { if (buf_index >= buf_size - h->nal_length_size) break; nalsize = 0; for(i = 0; i < h->nal_length_size; i++) nalsize = (nalsize << 8) | buf[buf_index++]; if(nalsize <= 0 || nalsize > buf_size - buf_index){ av_log(h->s.avctx, AV_LOG_ERROR, ""AVC: nal size %d\n"", nalsize); break; } next_avc= buf_index + nalsize; } else { for(; buf_index + 3 < next_avc; buf_index++){ if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1) break; } if(buf_index+3 >= buf_size) break; buf_index+=3; if(buf_index >= next_avc) continue; } hx = h->thread_context[context_count]; ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index); if (ptr==NULL || dst_length < 0){ return -1; } i= buf_index + consumed; if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc && buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0) s->workaround_bugs |= FF_BUG_TRUNCATED; if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){ while(ptr[dst_length - 1] == 0 && dst_length > 0) dst_length--; } bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1)); if(s->avctx->debug&FF_DEBUG_STARTCODE){ av_log(h->s.avctx, AV_LOG_DEBUG, ""NAL %d at %d/%d length %d\n"", hx->nal_unit_type, buf_index, buf_size, dst_length); } if (h->is_avc && (nalsize != consumed) && nalsize){ if (bit_length & 7) ptr[bit_length >> 3] = ptr[bit_length >> 3] & (0xff << 8 - (bit_length & 7)); av_log(h->s.avctx, AV_LOG_DEBUG, ""AVC: Consumed only %d bytes instead of %d\n"", consumed, nalsize); } buf_index += consumed; nal_index++; if(pass == 0) { switch (hx->nal_unit_type) { case NAL_SPS: case NAL_PPS: nals_needed = nal_index; break; case NAL_IDR_SLICE: case NAL_SLICE: init_get_bits(&hx->s.gb, ptr, bit_length); if (!get_ue_golomb(&hx->s.gb)) nals_needed = nal_index; } continue; } if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc == 0) continue; again: err = 0; switch(hx->nal_unit_type){ case NAL_IDR_SLICE: if (h->nal_unit_type != NAL_IDR_SLICE) { av_log(h->s.avctx, AV_LOG_ERROR, ""Invalid mix of idr and non-idr slices""); return -1; } idr(h); case NAL_SLICE: init_get_bits(&hx->s.gb, ptr, bit_length); hx->intra_gb_ptr= hx->inter_gb_ptr= &hx->s.gb; hx->s.data_partitioning = 0; if((err = decode_slice_header(hx, h))) break; s->current_picture_ptr->f.key_frame |= (hx->nal_unit_type == NAL_IDR_SLICE) || (h->sei_recovery_frame_cnt >= 0); if (h->current_slice == 1) { if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) { decode_postinit(h, nal_index >= nals_needed); } if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0) return -1; if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_h264_picture_start(s); } if(hx->redundant_pic_count==0 && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) && (avctx->skip_frame < AVDISCARD_BIDIR || hx->slice_type_nos!=AV_PICTURE_TYPE_B) && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I) && avctx->skip_frame < AVDISCARD_ALL){ if(avctx->hwaccel) { if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0) return -1; }else if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){ static const uint8_t start_code[] = {0x00, 0x00, 0x01}; ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code)); ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed ); }else context_count++; } break; case NAL_DPA: init_get_bits(&hx->s.gb, ptr, bit_length); hx->intra_gb_ptr= hx->inter_gb_ptr= NULL; if ((err = decode_slice_header(hx, h)) < 0) break; hx->s.data_partitioning = 1; break; case NAL_DPB: init_get_bits(&hx->intra_gb, ptr, bit_length); hx->intra_gb_ptr= &hx->intra_gb; break; case NAL_DPC: init_get_bits(&hx->inter_gb, ptr, bit_length); hx->inter_gb_ptr= &hx->inter_gb; if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning && s->context_initialized && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc) && (avctx->skip_frame < AVDISCARD_BIDIR || hx->slice_type_nos!=AV_PICTURE_TYPE_B) && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I) && avctx->skip_frame < AVDISCARD_ALL) context_count++; break; case NAL_SEI: init_get_bits(&s->gb, ptr, bit_length); ff_h264_decode_sei(h); break; case NAL_SPS: init_get_bits(&s->gb, ptr, bit_length); ff_h264_decode_seq_parameter_set(h); if (s->flags& CODEC_FLAG_LOW_DELAY || (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames)) s->low_delay=1; if(avctx->has_b_frames < 2) avctx->has_b_frames= !s->low_delay; if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma || h->cur_chroma_format_idc != h->sps.chroma_format_idc) { if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) { avctx->bits_per_raw_sample = h->sps.bit_depth_luma; h->cur_chroma_format_idc = h->sps.chroma_format_idc; h->pixel_shift = h->sps.bit_depth_luma > 8; ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc); ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc); s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16; dsputil_init(&s->dsp, s->avctx); } else { av_log(avctx, AV_LOG_ERROR, ""Unsupported bit depth: %d\n"", h->sps.bit_depth_luma); return -1; } } break; case NAL_PPS: init_get_bits(&s->gb, ptr, bit_length); ff_h264_decode_picture_parameter_set(h, bit_length); break; case NAL_AUD: case NAL_END_SEQUENCE: case NAL_END_STREAM: case NAL_FILLER_DATA: case NAL_SPS_EXT: case NAL_AUXILIARY_SLICE: break; default: av_log(avctx, AV_LOG_DEBUG, ""Unknown NAL code: %d (%d bits)\n"", hx->nal_unit_type, bit_length); } if(context_count == h->max_contexts) { execute_decode_slices(h, context_count); context_count = 0; } if (err < 0) av_log(h->s.avctx, AV_LOG_ERROR, ""decode_slice_header error\n""); else if(err == 1) { h->nal_unit_type = hx->nal_unit_type; h->nal_ref_idc = hx->nal_ref_idc; hx = h; goto again; } } } if(context_count) execute_decode_slices(h, context_count); return buf_index; }"
1006----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_368a7a45bd4ee2fe713cfc0f4e6345fbac0d8686_1.json----get_lag,"static void get_lag(float *buf, const float *new, LongTermPrediction *ltp) { <S2SV_StartVul> int i, j, lag, max_corr = 0; <S2SV_EndVul> <S2SV_StartVul> float max_ratio; <S2SV_EndVul> for (i = 0; i < 2048; i++) { float corr, s0 = 0.0f, s1 = 0.0f; const int start = FFMAX(0, i - 1024); for (j = start; j < 2048; j++) { const int idx = j - i + 1024; s0 += new[j]*buf[idx]; s1 += buf[idx]*buf[idx]; } corr = s1 > 0.0f ? s0/sqrt(s1) : 0.0f; if (corr > max_corr) { max_corr = corr; lag = i; max_ratio = corr/(2048-start); } } ltp->lag = FFMAX(av_clip_uintp2(lag, 11), 0); ltp->coef_idx = quant_array_idx(max_ratio, ltp_coef, 8); ltp->coef = ltp_coef[ltp->coef_idx]; }","- int i, j, lag, max_corr = 0;
- float max_ratio;
+ int i, j, lag = 0, max_corr = 0;
+ float max_ratio = 0.0f;","static void get_lag(float *buf, const float *new, LongTermPrediction *ltp) { int i, j, lag = 0, max_corr = 0; float max_ratio = 0.0f; for (i = 0; i < 2048; i++) { float corr, s0 = 0.0f, s1 = 0.0f; const int start = FFMAX(0, i - 1024); for (j = start; j < 2048; j++) { const int idx = j - i + 1024; s0 += new[j]*buf[idx]; s1 += buf[idx]*buf[idx]; } corr = s1 > 0.0f ? s0/sqrt(s1) : 0.0f; if (corr > max_corr) { max_corr = corr; lag = i; max_ratio = corr/(2048-start); } } ltp->lag = FFMAX(av_clip_uintp2(lag, 11), 0); ltp->coef_idx = quant_array_idx(max_ratio, ltp_coef, 8); ltp->coef = ltp_coef[ltp->coef_idx]; }"
6880----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7253c7649136664c74320d2294bf3756561cdde1_1.json----mov_write_packet_internal,"static int mov_write_packet_internal(AVFormatContext *s, AVPacket *pkt) { MOVMuxContext *mov = s->priv_data; AVIOContext *pb = s->pb; MOVTrack *trk = &mov->tracks[pkt->stream_index]; AVCodecContext *enc = trk->enc; unsigned int samples_in_chunk = 0; int size= pkt->size; uint8_t *reformatted_data = NULL; if (!s->pb->seekable && !(mov->flags & FF_MOV_FLAG_EMPTY_MOOV)) return 0; if (!size) return 0; if ((mov->max_fragment_duration && trk->entry && av_rescale_q(pkt->dts - trk->cluster[0].dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q) >= mov->max_fragment_duration) || (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) || (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME && enc->codec_type == AVMEDIA_TYPE_VIDEO && trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) { mov_flush_fragment(s); } <S2SV_StartVul> if (mov->flags & FF_MOV_FLAG_FRAGMENT && mov->fragments > 0) { <S2SV_EndVul> <S2SV_StartVul> if (!trk->mdat_buf) { <S2SV_EndVul> <S2SV_StartVul> int ret; <S2SV_EndVul> <S2SV_StartVul> if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0) <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> } <S2SV_StartVul> pb = trk->mdat_buf; <S2SV_EndVul> } if (enc->codec_id == CODEC_ID_AMR_NB) { static uint16_t packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1}; int len = 0; while (len < size && samples_in_chunk < 100) { len += packed_size[(pkt->data[len] >> 3) & 0x0F]; samples_in_chunk++; } if (samples_in_chunk > 1) { av_log(s, AV_LOG_ERROR, ""fatal error, input is not a single packet, implement a AVParser for it\n""); return -1; } } else if (trk->sample_size) samples_in_chunk = size / trk->sample_size; else samples_in_chunk = 1; if (trk->vos_len == 0 && enc->extradata_size > 0) { trk->vos_len = enc->extradata_size; trk->vos_data = av_malloc(trk->vos_len); memcpy(trk->vos_data, enc->extradata, trk->vos_len); } if (enc->codec_id == CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1) { if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) { ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data, &size); avio_write(pb, reformatted_data, size); } else { size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size); } } else { avio_write(pb, pkt->data, size); } if ((enc->codec_id == CODEC_ID_DNXHD || enc->codec_id == CODEC_ID_AC3) && !trk->vos_len) { trk->vos_len = size; trk->vos_data = av_malloc(size); if (!trk->vos_data) return AVERROR(ENOMEM); memcpy(trk->vos_data, pkt->data, size); } if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) { trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = avio_tell(pb) - size; trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = samples_in_chunk; trk->cluster[trk->entry].dts = pkt->dts; if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) { trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration; } if (trk->start_dts == AV_NOPTS_VALUE) trk->start_dts = pkt->dts; trk->track_duration = pkt->dts - trk->start_dts + pkt->duration; if (pkt->pts == AV_NOPTS_VALUE) { av_log(s, AV_LOG_WARNING, ""pts has no value\n""); pkt->pts = pkt->dts; } if (pkt->dts != pkt->pts) trk->flags |= MOV_TRACK_CTTS; trk->cluster[trk->entry].cts = pkt->pts - pkt->dts; trk->cluster[trk->entry].flags = 0; if (enc->codec_id == CODEC_ID_VC1) { mov_parse_vc1_frame(pkt, trk, mov->fragments); } else if (pkt->flags & AV_PKT_FLAG_KEY) { if (mov->mode == MODE_MOV && enc->codec_id == CODEC_ID_MPEG2VIDEO && trk->entry > 0) { mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags); if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE) trk->flags |= MOV_TRACK_STPS; } else { trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE; } if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE) trk->has_keyframes++; } trk->entry++; trk->sample_count += samples_in_chunk; mov->mdat_size += size; avio_flush(pb); if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry, reformatted_data, size); av_free(reformatted_data); return 0; }","- if (mov->flags & FF_MOV_FLAG_FRAGMENT && mov->fragments > 0) {
- if (!trk->mdat_buf) {
- int ret;
- if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)
- return ret;
- pb = trk->mdat_buf;
+ if (mov->flags & FF_MOV_FLAG_FRAGMENT) {
+ int ret;
+ if (mov->fragments > 0) {
+ if (!trk->mdat_buf) {
+ if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)
+ return ret;
+ }
+ pb = trk->mdat_buf;
+ } else {
+ if (!mov->mdat_buf) {
+ if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)
+ return ret;
+ }
+ pb = mov->mdat_buf;","static int mov_write_packet_internal(AVFormatContext *s, AVPacket *pkt) { MOVMuxContext *mov = s->priv_data; AVIOContext *pb = s->pb; MOVTrack *trk = &mov->tracks[pkt->stream_index]; AVCodecContext *enc = trk->enc; unsigned int samples_in_chunk = 0; int size= pkt->size; uint8_t *reformatted_data = NULL; if (!s->pb->seekable && !(mov->flags & FF_MOV_FLAG_EMPTY_MOOV)) return 0; if (!size) return 0; if ((mov->max_fragment_duration && trk->entry && av_rescale_q(pkt->dts - trk->cluster[0].dts, s->streams[pkt->stream_index]->time_base, AV_TIME_BASE_Q) >= mov->max_fragment_duration) || (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) || (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME && enc->codec_type == AVMEDIA_TYPE_VIDEO && trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) { mov_flush_fragment(s); } if (mov->flags & FF_MOV_FLAG_FRAGMENT) { int ret; if (mov->fragments > 0) { if (!trk->mdat_buf) { if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0) return ret; } pb = trk->mdat_buf; } else { if (!mov->mdat_buf) { if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0) return ret; } pb = mov->mdat_buf; } } if (enc->codec_id == CODEC_ID_AMR_NB) { static uint16_t packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1}; int len = 0; while (len < size && samples_in_chunk < 100) { len += packed_size[(pkt->data[len] >> 3) & 0x0F]; samples_in_chunk++; } if (samples_in_chunk > 1) { av_log(s, AV_LOG_ERROR, ""fatal error, input is not a single packet, implement a AVParser for it\n""); return -1; } } else if (trk->sample_size) samples_in_chunk = size / trk->sample_size; else samples_in_chunk = 1; if (trk->vos_len == 0 && enc->extradata_size > 0) { trk->vos_len = enc->extradata_size; trk->vos_data = av_malloc(trk->vos_len); memcpy(trk->vos_data, enc->extradata, trk->vos_len); } if (enc->codec_id == CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1) { if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) { ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data, &size); avio_write(pb, reformatted_data, size); } else { size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size); } } else { avio_write(pb, pkt->data, size); } if ((enc->codec_id == CODEC_ID_DNXHD || enc->codec_id == CODEC_ID_AC3) && !trk->vos_len) { trk->vos_len = size; trk->vos_data = av_malloc(size); if (!trk->vos_data) return AVERROR(ENOMEM); memcpy(trk->vos_data, pkt->data, size); } if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) { trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = avio_tell(pb) - size; trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = samples_in_chunk; trk->cluster[trk->entry].dts = pkt->dts; if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) { trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration; } if (trk->start_dts == AV_NOPTS_VALUE) trk->start_dts = pkt->dts; trk->track_duration = pkt->dts - trk->start_dts + pkt->duration; if (pkt->pts == AV_NOPTS_VALUE) { av_log(s, AV_LOG_WARNING, ""pts has no value\n""); pkt->pts = pkt->dts; } if (pkt->dts != pkt->pts) trk->flags |= MOV_TRACK_CTTS; trk->cluster[trk->entry].cts = pkt->pts - pkt->dts; trk->cluster[trk->entry].flags = 0; if (enc->codec_id == CODEC_ID_VC1) { mov_parse_vc1_frame(pkt, trk, mov->fragments); } else if (pkt->flags & AV_PKT_FLAG_KEY) { if (mov->mode == MODE_MOV && enc->codec_id == CODEC_ID_MPEG2VIDEO && trk->entry > 0) { mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags); if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE) trk->flags |= MOV_TRACK_STPS; } else { trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE; } if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE) trk->has_keyframes++; } trk->entry++; trk->sample_count += samples_in_chunk; mov->mdat_size += size; avio_flush(pb); if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry, reformatted_data, size); av_free(reformatted_data); return 0; }"
1464----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_512a60de63ed8b77bc5adadc8b0ffc001bc465ea_1.json----pred8x8_top_dc_8_c,"static void FUNCC(pred8x8_top_dc)(uint8_t *_src, int stride){ int i; int dc0, dc1; pixel4 dc0splat, dc1splat; pixel *src = (pixel*)_src; stride /= sizeof(pixel); dc0=dc1=0; for(i=0;i<4; i++){ dc0+= src[i-stride]; dc1+= src[4+i-stride]; } dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2); dc1splat = PIXEL_SPLAT_X4((dc1 + 2)>>2); for(i=0; i<4; i++){ <S2SV_StartVul> ((pixel4*)(src+i*stride))[0]= dc0splat; <S2SV_EndVul> <S2SV_StartVul> ((pixel4*)(src+i*stride))[1]= dc1splat; <S2SV_EndVul> } for(i=4; i<8; i++){ <S2SV_StartVul> ((pixel4*)(src+i*stride))[0]= dc0splat; <S2SV_EndVul> <S2SV_StartVul> ((pixel4*)(src+i*stride))[1]= dc1splat; <S2SV_EndVul> } }","- ((pixel4*)(src+i*stride))[0]= dc0splat;
- ((pixel4*)(src+i*stride))[1]= dc1splat;
- ((pixel4*)(src+i*stride))[0]= dc0splat;
- ((pixel4*)(src+i*stride))[1]= dc1splat;
+ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat);
+ AV_WN4PA(((pixel4*)(src+i*stride))+1, dc1splat);
+ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat);
+ AV_WN4PA(((pixel4*)(src+i*stride))+1, dc1splat);","static void FUNCC(pred8x8_top_dc)(uint8_t *_src, int stride){ int i; int dc0, dc1; pixel4 dc0splat, dc1splat; pixel *src = (pixel*)_src; stride /= sizeof(pixel); dc0=dc1=0; for(i=0;i<4; i++){ dc0+= src[i-stride]; dc1+= src[4+i-stride]; } dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2); dc1splat = PIXEL_SPLAT_X4((dc1 + 2)>>2); for(i=0; i<4; i++){ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat); AV_WN4PA(((pixel4*)(src+i*stride))+1, dc1splat); } for(i=4; i<8; i++){ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat); AV_WN4PA(((pixel4*)(src+i*stride))+1, dc1splat); } }"
12030----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3d9a93cd6dec970aea7f1d787536c15caf5ad0a2_1.json----tls_construct_client_hello,"int tls_construct_client_hello(SSL *s, WPACKET *pkt) { unsigned char *p; size_t sess_id_len; int i, protverr; #ifndef OPENSSL_NO_COMP SSL_COMP *comp; #endif SSL_SESSION *sess = s->session; unsigned char *session_id; <S2SV_StartVul> if (!WPACKET_set_max_size(pkt, SSL3_RT_MAX_PLAIN_LENGTH)) { <S2SV_EndVul> <S2SV_StartVul> SSLfatal(s, SSL_AD_INTERNAL_ERROR, <S2SV_EndVul> <S2SV_StartVul> SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> protverr = ssl_set_client_hello_version(s); if (protverr != 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, protverr); return 0; } if (sess == NULL || !ssl_version_supported(s, sess->ssl_version, NULL) || !SSL_SESSION_is_resumable(sess)) { if (s->hello_retry_request == SSL_HRR_NONE && !ssl_get_new_session(s, 0)) { return 0; } } p = s->s3->client_random; if (SSL_IS_DTLS(s)) { size_t idx; i = 1; for (idx = 0; idx < sizeof(s->s3->client_random); idx++) { if (p[idx]) { i = 0; break; } } } else { i = (s->hello_retry_request == SSL_HRR_NONE); } if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random), DOWNGRADE_NONE) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!WPACKET_put_bytes_u16(pkt, s->client_version) || !WPACKET_memcpy(pkt, s->s3->client_random, SSL3_RANDOM_SIZE)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } session_id = s->session->session_id; if (s->new_session || s->session->ssl_version == TLS1_3_VERSION) { if (s->version == TLS1_3_VERSION && (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0) { sess_id_len = sizeof(s->tmp_session_id); s->tmp_session_id_len = sess_id_len; session_id = s->tmp_session_id; if (s->hello_retry_request == SSL_HRR_NONE && RAND_bytes(s->tmp_session_id, sess_id_len) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } } else { sess_id_len = 0; } } else { assert(s->session->session_id_length <= sizeof(s->session->session_id)); sess_id_len = s->session->session_id_length; if (s->version == TLS1_3_VERSION) { s->tmp_session_id_len = sess_id_len; memcpy(s->tmp_session_id, s->session->session_id, sess_id_len); } } if (!WPACKET_start_sub_packet_u8(pkt) || (sess_id_len != 0 && !WPACKET_memcpy(pkt, session_id, sess_id_len)) || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (SSL_IS_DTLS(s)) { if (s->d1->cookie_len > sizeof(s->d1->cookie) || !WPACKET_sub_memcpy_u8(pkt, s->d1->cookie, s->d1->cookie_len)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } } if (!WPACKET_start_sub_packet_u16(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), pkt)) { return 0; } if (!WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!WPACKET_start_sub_packet_u8(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } #ifndef OPENSSL_NO_COMP if (ssl_allow_compression(s) && s->ctx->comp_methods && (SSL_IS_DTLS(s) || s->s3->tmp.max_ver < TLS1_3_VERSION)) { int compnum = sk_SSL_COMP_num(s->ctx->comp_methods); for (i = 0; i < compnum; i++) { comp = sk_SSL_COMP_value(s->ctx->comp_methods, i); if (!WPACKET_put_bytes_u8(pkt, comp->id)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } } } #endif if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!tls_construct_extensions(s, pkt, SSL_EXT_CLIENT_HELLO, NULL, 0)) { return 0; } return 1; }","- if (!WPACKET_set_max_size(pkt, SSL3_RT_MAX_PLAIN_LENGTH)) {
- SSLfatal(s, SSL_AD_INTERNAL_ERROR,
- SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
- return 0;
- }","int tls_construct_client_hello(SSL *s, WPACKET *pkt) { unsigned char *p; size_t sess_id_len; int i, protverr; #ifndef OPENSSL_NO_COMP SSL_COMP *comp; #endif SSL_SESSION *sess = s->session; unsigned char *session_id; protverr = ssl_set_client_hello_version(s); if (protverr != 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, protverr); return 0; } if (sess == NULL || !ssl_version_supported(s, sess->ssl_version, NULL) || !SSL_SESSION_is_resumable(sess)) { if (s->hello_retry_request == SSL_HRR_NONE && !ssl_get_new_session(s, 0)) { return 0; } } p = s->s3->client_random; if (SSL_IS_DTLS(s)) { size_t idx; i = 1; for (idx = 0; idx < sizeof(s->s3->client_random); idx++) { if (p[idx]) { i = 0; break; } } } else { i = (s->hello_retry_request == SSL_HRR_NONE); } if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random), DOWNGRADE_NONE) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!WPACKET_put_bytes_u16(pkt, s->client_version) || !WPACKET_memcpy(pkt, s->s3->client_random, SSL3_RANDOM_SIZE)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } session_id = s->session->session_id; if (s->new_session || s->session->ssl_version == TLS1_3_VERSION) { if (s->version == TLS1_3_VERSION && (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0) { sess_id_len = sizeof(s->tmp_session_id); s->tmp_session_id_len = sess_id_len; session_id = s->tmp_session_id; if (s->hello_retry_request == SSL_HRR_NONE && RAND_bytes(s->tmp_session_id, sess_id_len) <= 0) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } } else { sess_id_len = 0; } } else { assert(s->session->session_id_length <= sizeof(s->session->session_id)); sess_id_len = s->session->session_id_length; if (s->version == TLS1_3_VERSION) { s->tmp_session_id_len = sess_id_len; memcpy(s->tmp_session_id, s->session->session_id, sess_id_len); } } if (!WPACKET_start_sub_packet_u8(pkt) || (sess_id_len != 0 && !WPACKET_memcpy(pkt, session_id, sess_id_len)) || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (SSL_IS_DTLS(s)) { if (s->d1->cookie_len > sizeof(s->d1->cookie) || !WPACKET_sub_memcpy_u8(pkt, s->d1->cookie, s->d1->cookie_len)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } } if (!WPACKET_start_sub_packet_u16(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), pkt)) { return 0; } if (!WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!WPACKET_start_sub_packet_u8(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } #ifndef OPENSSL_NO_COMP if (ssl_allow_compression(s) && s->ctx->comp_methods && (SSL_IS_DTLS(s) || s->s3->tmp.max_ver < TLS1_3_VERSION)) { int compnum = sk_SSL_COMP_num(s->ctx->comp_methods); for (i = 0; i < compnum; i++) { comp = sk_SSL_COMP_value(s->ctx->comp_methods, i); if (!WPACKET_put_bytes_u8(pkt, comp->id)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } } } #endif if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) { SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR); return 0; } if (!tls_construct_extensions(s, pkt, SSL_EXT_CLIENT_HELLO, NULL, 0)) { return 0; } return 1; }"
11978----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3bbde94becb16b0600d03a5b9ce2a1be93ad9b1f_1.json----RAND_query_egd_bytes,"int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes) { int ret = 0; struct sockaddr_un addr; int len, num, numbytes; int fd = -1; int success; unsigned char egdbuf[2], tempbuf[255], *retrievebuf; memset(&addr, 0, sizeof(addr)); addr.sun_family = AF_UNIX; if (strlen(path) >= sizeof(addr.sun_path)) return (-1); <S2SV_StartVul> strcpy(addr.sun_path,path); <S2SV_EndVul> len = offsetof(struct sockaddr_un, sun_path) + strlen(path); fd = socket(AF_UNIX, SOCK_STREAM, 0); if (fd == -1) return (-1); success = 0; while (!success) { if (connect(fd, (struct sockaddr *)&addr, len) == 0) success = 1; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif #ifdef EINPROGRESS case EINPROGRESS: #endif #ifdef EALREADY case EALREADY: #endif break; #ifdef EISCONN case EISCONN: success = 1; break; #endif default: goto err; } } } while(bytes > 0) { egdbuf[0] = 1; egdbuf[1] = bytes < 255 ? bytes : 255; numbytes = 0; while (numbytes != 2) { num = write(fd, egdbuf + numbytes, 2 - numbytes); if (num >= 0) numbytes += num; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif break; default: ret = -1; goto err; } } } numbytes = 0; while (numbytes != 1) { num = read(fd, egdbuf, 1); if (num >= 0) numbytes += num; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif break; default: ret = -1; goto err; } } } if(egdbuf[0] == 0) goto err; if (buf) retrievebuf = buf + ret; else retrievebuf = tempbuf; numbytes = 0; while (numbytes != egdbuf[0]) { num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes); if (num >= 0) numbytes += num; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif break; default: ret = -1; goto err; } } } ret += egdbuf[0]; bytes -= egdbuf[0]; if (!buf) RAND_seed(tempbuf, egdbuf[0]); } err: if (fd != -1) close(fd); return(ret); }","- strcpy(addr.sun_path,path);
+ BUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);","int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes) { int ret = 0; struct sockaddr_un addr; int len, num, numbytes; int fd = -1; int success; unsigned char egdbuf[2], tempbuf[255], *retrievebuf; memset(&addr, 0, sizeof(addr)); addr.sun_family = AF_UNIX; if (strlen(path) >= sizeof(addr.sun_path)) return (-1); BUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path); len = offsetof(struct sockaddr_un, sun_path) + strlen(path); fd = socket(AF_UNIX, SOCK_STREAM, 0); if (fd == -1) return (-1); success = 0; while (!success) { if (connect(fd, (struct sockaddr *)&addr, len) == 0) success = 1; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif #ifdef EINPROGRESS case EINPROGRESS: #endif #ifdef EALREADY case EALREADY: #endif break; #ifdef EISCONN case EISCONN: success = 1; break; #endif default: goto err; } } } while(bytes > 0) { egdbuf[0] = 1; egdbuf[1] = bytes < 255 ? bytes : 255; numbytes = 0; while (numbytes != 2) { num = write(fd, egdbuf + numbytes, 2 - numbytes); if (num >= 0) numbytes += num; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif break; default: ret = -1; goto err; } } } numbytes = 0; while (numbytes != 1) { num = read(fd, egdbuf, 1); if (num >= 0) numbytes += num; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif break; default: ret = -1; goto err; } } } if(egdbuf[0] == 0) goto err; if (buf) retrievebuf = buf + ret; else retrievebuf = tempbuf; numbytes = 0; while (numbytes != egdbuf[0]) { num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes); if (num >= 0) numbytes += num; else { switch (errno) { #ifdef EINTR case EINTR: #endif #ifdef EAGAIN case EAGAIN: #endif break; default: ret = -1; goto err; } } } ret += egdbuf[0]; bytes -= egdbuf[0]; if (!buf) RAND_seed(tempbuf, egdbuf[0]); } err: if (fd != -1) close(fd); return(ret); }"
10725----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_10fa91e12d5a405a42cbae7c9ee00b8efde01838_1.json----EVP_DigestInit_ex,"int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl) { EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED); #ifndef OPENSSL_NO_ENGINE if (ctx->engine && ctx->digest && (!type || (type && (type->type == ctx->digest->type)))) goto skip_to_init; if (type) { <S2SV_StartVul> if (ctx->engine) <S2SV_EndVul> <S2SV_StartVul> ENGINE_finish(ctx->engine); <S2SV_EndVul> <S2SV_StartVul> if (impl) { <S2SV_EndVul> if (!ENGINE_init(impl)) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR); return 0; } <S2SV_StartVul> } else <S2SV_EndVul> impl = ENGINE_get_digest_engine(type->type); <S2SV_StartVul> if (impl) { <S2SV_EndVul> const EVP_MD *d = ENGINE_get_digest(impl, type->type); <S2SV_StartVul> if (!d) { <S2SV_EndVul> EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR); ENGINE_finish(impl); return 0; } type = d; ctx->engine = impl; } else ctx->engine = NULL; } else { if (!ctx->digest) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET); return 0; } type = ctx->digest; } #endif if (ctx->digest != type) { if (ctx->digest && ctx->digest->ctx_size) OPENSSL_free(ctx->md_data); ctx->digest = type; if (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) { ctx->update = type->update; ctx->md_data = OPENSSL_zalloc(type->ctx_size); if (ctx->md_data == NULL) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE); return 0; } } } #ifndef OPENSSL_NO_ENGINE skip_to_init: #endif if (ctx->pctx) { int r; r = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG, EVP_PKEY_CTRL_DIGESTINIT, 0, ctx); if (r <= 0 && (r != -2)) return 0; } if (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) return 1; return ctx->digest->init(ctx); }","- if (ctx->engine)
- ENGINE_finish(ctx->engine);
- if (impl) {
- } else
- if (impl) {
- if (!d) {
+ ENGINE_finish(ctx->engine);
+ if (impl != NULL) {
+ } else {
+ }
+ if (impl != NULL) {
+ if (d == NULL) {","int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl) { EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED); #ifndef OPENSSL_NO_ENGINE if (ctx->engine && ctx->digest && (!type || (type && (type->type == ctx->digest->type)))) goto skip_to_init; if (type) { ENGINE_finish(ctx->engine); if (impl != NULL) { if (!ENGINE_init(impl)) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR); return 0; } } else { impl = ENGINE_get_digest_engine(type->type); } if (impl != NULL) { const EVP_MD *d = ENGINE_get_digest(impl, type->type); if (d == NULL) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR); ENGINE_finish(impl); return 0; } type = d; ctx->engine = impl; } else ctx->engine = NULL; } else { if (!ctx->digest) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET); return 0; } type = ctx->digest; } #endif if (ctx->digest != type) { if (ctx->digest && ctx->digest->ctx_size) OPENSSL_free(ctx->md_data); ctx->digest = type; if (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) { ctx->update = type->update; ctx->md_data = OPENSSL_zalloc(type->ctx_size); if (ctx->md_data == NULL) { EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE); return 0; } } } #ifndef OPENSSL_NO_ENGINE skip_to_init: #endif if (ctx->pctx) { int r; r = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG, EVP_PKEY_CTRL_DIGESTINIT, 0, ctx); if (r <= 0 && (r != -2)) return 0; } if (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) return 1; return ctx->digest->init(ctx); }"
2992----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a2ec20e4c3dda936587c4e45a27ad72e4e7cfb10_1.json----av_vsrc_buffer_add_frame,"int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts, AVRational pixel_aspect) { BufferSourceContext *c = buffer_filter->priv; AVFilterBufferRef *buf; int ret; <S2SV_StartVul> if (!buf) { <S2SV_EndVul> c->eof = 1; return 0; } else if (c->eof) return AVERROR(EINVAL); if (!av_fifo_space(c->fifo) && (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) + sizeof(buf))) < 0) return ret; CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format); buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE, c->w, c->h); av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize, c->pix_fmt, c->w, c->h); avfilter_copy_frame_props(buf, frame); buf->pts = pts; buf->video->pixel_aspect = pixel_aspect; if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) { avfilter_unref_buffer(buf); return ret; } return 0; }","- if (!buf) {
+ if (!frame) {","int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame, int64_t pts, AVRational pixel_aspect) { BufferSourceContext *c = buffer_filter->priv; AVFilterBufferRef *buf; int ret; if (!frame) { c->eof = 1; return 0; } else if (c->eof) return AVERROR(EINVAL); if (!av_fifo_space(c->fifo) && (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) + sizeof(buf))) < 0) return ret; CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format); buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE, c->w, c->h); av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize, c->pix_fmt, c->w, c->h); avfilter_copy_frame_props(buf, frame); buf->pts = pts; buf->video->pixel_aspect = pixel_aspect; if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) { avfilter_unref_buffer(buf); return ret; } return 0; }"
12717----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_565d73813b30a95858653b1732dab431ac777f4c_1.json----evp_signature_from_dispatch,"<S2SV_StartVul> static void *evp_signature_from_dispatch(const char *name, <S2SV_EndVul> const OSSL_DISPATCH *fns, OSSL_PROVIDER *prov, void *vkeymgmt_data) { struct keymgmt_data_st *keymgmt_data = vkeymgmt_data; <S2SV_StartVul> EVP_KEYMGMT *keymgmt = EVP_KEYMGMT_fetch(keymgmt_data->ctx, name, <S2SV_EndVul> <S2SV_StartVul> keymgmt_data->properties); <S2SV_EndVul> EVP_SIGNATURE *signature = NULL; int ctxfncnt = 0, signfncnt = 0, verifyfncnt = 0, verifyrecfncnt = 0; int gparamfncnt = 0, sparamfncnt = 0; if (keymgmt == NULL || EVP_KEYMGMT_provider(keymgmt) != prov) { ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEYMGMT_AVAILABLE); goto err; } <S2SV_StartVul> if ((signature = evp_signature_new(prov)) == NULL <S2SV_EndVul> <S2SV_StartVul> || (signature->name = OPENSSL_strdup(name)) == NULL) { <S2SV_EndVul> ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE); goto err; } signature->keymgmt = keymgmt; keymgmt = NULL; for (; fns->function_id != 0; fns++) { switch (fns->function_id) { case OSSL_FUNC_SIGNATURE_NEWCTX: if (signature->newctx != NULL) break; signature->newctx = OSSL_get_OP_signature_newctx(fns); ctxfncnt++; break; case OSSL_FUNC_SIGNATURE_SIGN_INIT: if (signature->sign_init != NULL) break; signature->sign_init = OSSL_get_OP_signature_sign_init(fns); signfncnt++; break; case OSSL_FUNC_SIGNATURE_SIGN: if (signature->sign != NULL) break; signature->sign = OSSL_get_OP_signature_sign(fns); signfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY_INIT: if (signature->verify_init != NULL) break; signature->verify_init = OSSL_get_OP_signature_verify_init(fns); verifyfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY: if (signature->verify != NULL) break; signature->verify = OSSL_get_OP_signature_verify(fns); verifyfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT: if (signature->verify_recover_init != NULL) break; signature->verify_recover_init = OSSL_get_OP_signature_verify_recover_init(fns); verifyrecfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER: if (signature->verify_recover != NULL) break; signature->verify_recover = OSSL_get_OP_signature_verify_recover(fns); verifyrecfncnt++; break; case OSSL_FUNC_SIGNATURE_FREECTX: if (signature->freectx != NULL) break; signature->freectx = OSSL_get_OP_signature_freectx(fns); ctxfncnt++; break; case OSSL_FUNC_SIGNATURE_DUPCTX: if (signature->dupctx != NULL) break; signature->dupctx = OSSL_get_OP_signature_dupctx(fns); break; case OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS: if (signature->get_ctx_params != NULL) break; signature->get_ctx_params = OSSL_get_OP_signature_get_ctx_params(fns); gparamfncnt++; break; case OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS: if (signature->gettable_ctx_params != NULL) break; signature->gettable_ctx_params = OSSL_get_OP_signature_gettable_ctx_params(fns); gparamfncnt++; break; case OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS: if (signature->set_ctx_params != NULL) break; signature->set_ctx_params = OSSL_get_OP_signature_set_ctx_params(fns); sparamfncnt++; break; case OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS: if (signature->settable_ctx_params != NULL) break; signature->settable_ctx_params = OSSL_get_OP_signature_settable_ctx_params(fns); sparamfncnt++; break; } } if (ctxfncnt != 2 || (signfncnt != 2 && verifyfncnt != 2 && verifyrecfncnt != 2) || (gparamfncnt != 0 && gparamfncnt != 2) || (sparamfncnt != 0 && sparamfncnt != 2)) { ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS); goto err; } return signature; err: EVP_SIGNATURE_free(signature); EVP_KEYMGMT_free(keymgmt); return NULL; }","- static void *evp_signature_from_dispatch(const char *name,
- EVP_KEYMGMT *keymgmt = EVP_KEYMGMT_fetch(keymgmt_data->ctx, name,
- keymgmt_data->properties);
- if ((signature = evp_signature_new(prov)) == NULL
- || (signature->name = OPENSSL_strdup(name)) == NULL) {
+ static void *evp_signature_from_dispatch(int name_id,
+ EVP_KEYMGMT *keymgmt =
+ evp_keymgmt_fetch_by_number(keymgmt_data->ctx, name_id,
+ keymgmt_data->properties);
+ if ((signature = evp_signature_new(prov)) == NULL) {
+ signature->name_id = name_id;","static void *evp_signature_from_dispatch(int name_id, const OSSL_DISPATCH *fns, OSSL_PROVIDER *prov, void *vkeymgmt_data) { struct keymgmt_data_st *keymgmt_data = vkeymgmt_data; EVP_KEYMGMT *keymgmt = evp_keymgmt_fetch_by_number(keymgmt_data->ctx, name_id, keymgmt_data->properties); EVP_SIGNATURE *signature = NULL; int ctxfncnt = 0, signfncnt = 0, verifyfncnt = 0, verifyrecfncnt = 0; int gparamfncnt = 0, sparamfncnt = 0; if (keymgmt == NULL || EVP_KEYMGMT_provider(keymgmt) != prov) { ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEYMGMT_AVAILABLE); goto err; } if ((signature = evp_signature_new(prov)) == NULL) { ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE); goto err; } signature->name_id = name_id; signature->keymgmt = keymgmt; keymgmt = NULL; for (; fns->function_id != 0; fns++) { switch (fns->function_id) { case OSSL_FUNC_SIGNATURE_NEWCTX: if (signature->newctx != NULL) break; signature->newctx = OSSL_get_OP_signature_newctx(fns); ctxfncnt++; break; case OSSL_FUNC_SIGNATURE_SIGN_INIT: if (signature->sign_init != NULL) break; signature->sign_init = OSSL_get_OP_signature_sign_init(fns); signfncnt++; break; case OSSL_FUNC_SIGNATURE_SIGN: if (signature->sign != NULL) break; signature->sign = OSSL_get_OP_signature_sign(fns); signfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY_INIT: if (signature->verify_init != NULL) break; signature->verify_init = OSSL_get_OP_signature_verify_init(fns); verifyfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY: if (signature->verify != NULL) break; signature->verify = OSSL_get_OP_signature_verify(fns); verifyfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT: if (signature->verify_recover_init != NULL) break; signature->verify_recover_init = OSSL_get_OP_signature_verify_recover_init(fns); verifyrecfncnt++; break; case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER: if (signature->verify_recover != NULL) break; signature->verify_recover = OSSL_get_OP_signature_verify_recover(fns); verifyrecfncnt++; break; case OSSL_FUNC_SIGNATURE_FREECTX: if (signature->freectx != NULL) break; signature->freectx = OSSL_get_OP_signature_freectx(fns); ctxfncnt++; break; case OSSL_FUNC_SIGNATURE_DUPCTX: if (signature->dupctx != NULL) break; signature->dupctx = OSSL_get_OP_signature_dupctx(fns); break; case OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS: if (signature->get_ctx_params != NULL) break; signature->get_ctx_params = OSSL_get_OP_signature_get_ctx_params(fns); gparamfncnt++; break; case OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS: if (signature->gettable_ctx_params != NULL) break; signature->gettable_ctx_params = OSSL_get_OP_signature_gettable_ctx_params(fns); gparamfncnt++; break; case OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS: if (signature->set_ctx_params != NULL) break; signature->set_ctx_params = OSSL_get_OP_signature_set_ctx_params(fns); sparamfncnt++; break; case OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS: if (signature->settable_ctx_params != NULL) break; signature->settable_ctx_params = OSSL_get_OP_signature_settable_ctx_params(fns); sparamfncnt++; break; } } if (ctxfncnt != 2 || (signfncnt != 2 && verifyfncnt != 2 && verifyrecfncnt != 2) || (gparamfncnt != 0 && gparamfncnt != 2) || (sparamfncnt != 0 && sparamfncnt != 2)) { ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS); goto err; } return signature; err: EVP_SIGNATURE_free(signature); EVP_KEYMGMT_free(keymgmt); return NULL; }"
10070----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_8dcd4fc2729bb48b8b52a4bbaafcf495a4295c4f_1.json----ngx_http_init_request,"static void ngx_http_init_request(ngx_event_t *rev) { ngx_time_t *tp; ngx_connection_t *c; ngx_http_request_t *r; ngx_http_log_ctx_t *ctx; ngx_http_connection_t *hc; ngx_http_core_srv_conf_t *cscf; ngx_http_core_loc_conf_t *clcf; ngx_http_core_main_conf_t *cmcf; c = rev->data; if (rev->timedout) { ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out""); ngx_http_close_connection(c); return; } c->requests++; hc = c->data; r = hc->request; if (r) { ngx_memzero(r, sizeof(ngx_http_request_t)); r->pipeline = hc->pipeline; if (hc->nbusy) { r->header_in = hc->busy[0]; } } else { r = ngx_pcalloc(c->pool, sizeof(ngx_http_request_t)); if (r == NULL) { ngx_http_close_connection(c); return; } hc->request = r; } c->data = r; r->http_connection = hc; c->sent = 0; r->signature = NGX_HTTP_MODULE; r->connection = c; r->main_conf = hc->conf_ctx->main_conf; r->srv_conf = hc->conf_ctx->srv_conf; r->loc_conf = hc->conf_ctx->loc_conf; <S2SV_StartVul> rev->handler = ngx_http_process_request_line; <S2SV_EndVul> r->read_event_handler = ngx_http_block_reading; <S2SV_StartVul> #if (NGX_HTTP_SSL) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> ngx_http_ssl_srv_conf_t *sscf; <S2SV_EndVul> <S2SV_StartVul> sscf = ngx_http_get_module_srv_conf(r, ngx_http_ssl_module); <S2SV_EndVul> <S2SV_StartVul> if (sscf->enable || hc->addr_conf->ssl) { <S2SV_EndVul> <S2SV_StartVul> if (c->ssl == NULL) { <S2SV_EndVul> <S2SV_StartVul> c->log->action = ""SSL handshaking""; <S2SV_EndVul> <S2SV_StartVul> if (hc->addr_conf->ssl && sscf->ssl.ctx == NULL) { <S2SV_EndVul> <S2SV_StartVul> ngx_log_error(NGX_LOG_ERR, c->log, 0, <S2SV_EndVul> <S2SV_StartVul> ""no \""ssl_certificate\"" is defined "" <S2SV_EndVul> <S2SV_StartVul> ""in server listening on SSL port""); <S2SV_EndVul> <S2SV_StartVul> ngx_http_close_connection(c); <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (ngx_ssl_create_connection(&sscf->ssl, c, NGX_SSL_BUFFER) <S2SV_EndVul> <S2SV_StartVul> != NGX_OK) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> ngx_http_close_connection(c); <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> rev->handler = ngx_http_ssl_handshake; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> r->main_filter_need_in_memory = 1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); ngx_http_set_connection_log(r->connection, clcf->error_log); cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module); if (c->buffer == NULL) { c->buffer = ngx_create_temp_buf(c->pool, cscf->client_header_buffer_size); if (c->buffer == NULL) { ngx_http_close_connection(c); return; } } if (r->header_in == NULL) { r->header_in = c->buffer; } r->pool = ngx_create_pool(cscf->request_pool_size, c->log); if (r->pool == NULL) { ngx_http_close_connection(c); return; } if (ngx_list_init(&r->headers_out.headers, r->pool, 20, sizeof(ngx_table_elt_t)) != NGX_OK) { ngx_destroy_pool(r->pool); ngx_http_close_connection(c); return; } r->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module); if (r->ctx == NULL) { ngx_destroy_pool(r->pool); ngx_http_close_connection(c); return; } cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module); r->variables = ngx_pcalloc(r->pool, cmcf->variables.nelts * sizeof(ngx_http_variable_value_t)); if (r->variables == NULL) { ngx_destroy_pool(r->pool); ngx_http_close_connection(c); return; } c->single_connection = 1; c->destroyed = 0; r->main = r; r->count = 1; tp = ngx_timeofday(); r->start_sec = tp->sec; r->start_msec = tp->msec; r->method = NGX_HTTP_UNKNOWN; r->headers_in.content_length_n = -1; r->headers_in.keep_alive_n = -1; r->headers_out.content_length_n = -1; r->headers_out.last_modified_time = -1; r->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1; r->subrequests = NGX_HTTP_MAX_SUBREQUESTS + 1; r->http_state = NGX_HTTP_READING_REQUEST_STATE; ctx = c->log->data; ctx->request = r; ctx->current_request = r; r->log_handler = ngx_http_log_error_handler; #if (NGX_STAT_STUB) (void) ngx_atomic_fetch_add(ngx_stat_reading, 1); r->stat_reading = 1; (void) ngx_atomic_fetch_add(ngx_stat_requests, 1); #endif <S2SV_StartVul> rev->handler(rev); <S2SV_EndVul> }","- rev->handler = ngx_http_process_request_line;
- #if (NGX_HTTP_SSL)
- {
- ngx_http_ssl_srv_conf_t *sscf;
- sscf = ngx_http_get_module_srv_conf(r, ngx_http_ssl_module);
- if (sscf->enable || hc->addr_conf->ssl) {
- if (c->ssl == NULL) {
- c->log->action = ""SSL handshaking"";
- if (hc->addr_conf->ssl && sscf->ssl.ctx == NULL) {
- ngx_log_error(NGX_LOG_ERR, c->log, 0,
- ""no \""ssl_certificate\"" is defined ""
- ""in server listening on SSL port"");
- ngx_http_close_connection(c);
- return;
- }
- if (ngx_ssl_create_connection(&sscf->ssl, c, NGX_SSL_BUFFER)
- != NGX_OK)
- {
- ngx_http_close_connection(c);
- return;
- }
- rev->handler = ngx_http_ssl_handshake;
- }
- r->main_filter_need_in_memory = 1;
- }
- }
- #endif
- rev->handler(rev);
+ #if (NGX_HTTP_SSL)
+ if (c->ssl) {
+ r->main_filter_need_in_memory = 1;
+ }
+ #endif
+ rev->handler = ngx_http_process_request_line;
+ ngx_http_process_request_line(rev);","static void ngx_http_init_request(ngx_event_t *rev) { ngx_time_t *tp; ngx_connection_t *c; ngx_http_request_t *r; ngx_http_log_ctx_t *ctx; ngx_http_connection_t *hc; ngx_http_core_srv_conf_t *cscf; ngx_http_core_loc_conf_t *clcf; ngx_http_core_main_conf_t *cmcf; c = rev->data; if (rev->timedout) { ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out""); ngx_http_close_connection(c); return; } c->requests++; hc = c->data; r = hc->request; if (r) { ngx_memzero(r, sizeof(ngx_http_request_t)); r->pipeline = hc->pipeline; if (hc->nbusy) { r->header_in = hc->busy[0]; } } else { r = ngx_pcalloc(c->pool, sizeof(ngx_http_request_t)); if (r == NULL) { ngx_http_close_connection(c); return; } hc->request = r; } c->data = r; r->http_connection = hc; c->sent = 0; r->signature = NGX_HTTP_MODULE; r->connection = c; r->main_conf = hc->conf_ctx->main_conf; r->srv_conf = hc->conf_ctx->srv_conf; r->loc_conf = hc->conf_ctx->loc_conf; r->read_event_handler = ngx_http_block_reading; clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); ngx_http_set_connection_log(r->connection, clcf->error_log); cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module); if (c->buffer == NULL) { c->buffer = ngx_create_temp_buf(c->pool, cscf->client_header_buffer_size); if (c->buffer == NULL) { ngx_http_close_connection(c); return; } } if (r->header_in == NULL) { r->header_in = c->buffer; } r->pool = ngx_create_pool(cscf->request_pool_size, c->log); if (r->pool == NULL) { ngx_http_close_connection(c); return; } if (ngx_list_init(&r->headers_out.headers, r->pool, 20, sizeof(ngx_table_elt_t)) != NGX_OK) { ngx_destroy_pool(r->pool); ngx_http_close_connection(c); return; } r->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module); if (r->ctx == NULL) { ngx_destroy_pool(r->pool); ngx_http_close_connection(c); return; } cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module); r->variables = ngx_pcalloc(r->pool, cmcf->variables.nelts * sizeof(ngx_http_variable_value_t)); if (r->variables == NULL) { ngx_destroy_pool(r->pool); ngx_http_close_connection(c); return; } c->single_connection = 1; c->destroyed = 0; #if (NGX_HTTP_SSL) if (c->ssl) { r->main_filter_need_in_memory = 1; } #endif r->main = r; r->count = 1; tp = ngx_timeofday(); r->start_sec = tp->sec; r->start_msec = tp->msec; r->method = NGX_HTTP_UNKNOWN; r->headers_in.content_length_n = -1; r->headers_in.keep_alive_n = -1; r->headers_out.content_length_n = -1; r->headers_out.last_modified_time = -1; r->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1; r->subrequests = NGX_HTTP_MAX_SUBREQUESTS + 1; r->http_state = NGX_HTTP_READING_REQUEST_STATE; ctx = c->log->data; ctx->request = r; ctx->current_request = r; r->log_handler = ngx_http_log_error_handler; #if (NGX_STAT_STUB) (void) ngx_atomic_fetch_add(ngx_stat_reading, 1); r->stat_reading = 1; (void) ngx_atomic_fetch_add(ngx_stat_requests, 1); #endif rev->handler = ngx_http_process_request_line; ngx_http_process_request_line(rev); }"
7200----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_85d8a1cc886b3a1e79125648580750c297f8be06_1.json----ff_acelp_lp_decode,"void ff_acelp_lp_decode(int16_t* lp_1st, int16_t* lp_2nd, const int16_t* lsp_2nd, const int16_t* lsp_prev, int lp_order) { <S2SV_StartVul> int16_t lsp_1st[lp_order]; int i; for(i=0; i<lp_order; i++) #ifdef G729_BITEXACT lsp_1st[i] = (lsp_2nd[i] >> 1) + (lsp_prev[i] >> 1); #else lsp_1st[i] = (lsp_2nd[i] + lsp_prev[i]) >> 1; #endif ff_acelp_lsp2lpc(lp_1st, lsp_1st, lp_order >> 1); ff_acelp_lsp2lpc(lp_2nd, lsp_2nd, lp_order >> 1); }","- int16_t lsp_1st[lp_order]; // (0.15)
+ int16_t lsp_1st[MAX_LP_ORDER]; // (0.15)","void ff_acelp_lp_decode(int16_t* lp_1st, int16_t* lp_2nd, const int16_t* lsp_2nd, const int16_t* lsp_prev, int lp_order) { int16_t lsp_1st[MAX_LP_ORDER]; int i; for(i=0; i<lp_order; i++) #ifdef G729_BITEXACT lsp_1st[i] = (lsp_2nd[i] >> 1) + (lsp_prev[i] >> 1); #else lsp_1st[i] = (lsp_2nd[i] + lsp_prev[i]) >> 1; #endif ff_acelp_lsp2lpc(lp_1st, lsp_1st, lp_order >> 1); ff_acelp_lsp2lpc(lp_2nd, lsp_2nd, lp_order >> 1); }"
16320----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d3604fe9dc1febbd5aebdae7db5a7b4959b42a02_1.json----prefix_write,"static int prefix_write(BIO *b, const char *out, size_t outl, size_t *numwritten) { PREFIX_CTX *ctx = BIO_get_data(b); if (ctx == NULL) return 0; if (ctx->prefix == NULL || *ctx->prefix == '\0') { if (outl > 0) ctx->linestart = (out[outl-1] == '\n'); return BIO_write_ex(BIO_next(b), out, outl, numwritten); } *numwritten = 0; <S2SV_StartVul> while (*out != '\0') { <S2SV_EndVul> size_t i; char c; if (ctx->linestart) { size_t dontcare; if (!BIO_write_ex(BIO_next(b), ctx->prefix, strlen(ctx->prefix), &dontcare)) return 0; ctx->linestart = 0; } <S2SV_StartVul> for (i = 0; (c = out[i]) != '\n' && c != '\0'; i++) <S2SV_EndVul> continue; if (c == '\n') i++; while (i > 0) { size_t num = 0; if (!BIO_write_ex(BIO_next(b), out, i, &num)) return 0; out += num; *numwritten += num; i -= num; } if (c == '\n') ctx->linestart = 1; } return 1; }","- while (*out != '\0') {
- for (i = 0; (c = out[i]) != '\n' && c != '\0'; i++)
+ while (outl > 0) {
+ for (i = 0, c = '\0'; i < outl && (c = out[i]) != '\n'; i++)
+ outl -= num;","static int prefix_write(BIO *b, const char *out, size_t outl, size_t *numwritten) { PREFIX_CTX *ctx = BIO_get_data(b); if (ctx == NULL) return 0; if (ctx->prefix == NULL || *ctx->prefix == '\0') { if (outl > 0) ctx->linestart = (out[outl-1] == '\n'); return BIO_write_ex(BIO_next(b), out, outl, numwritten); } *numwritten = 0; while (outl > 0) { size_t i; char c; if (ctx->linestart) { size_t dontcare; if (!BIO_write_ex(BIO_next(b), ctx->prefix, strlen(ctx->prefix), &dontcare)) return 0; ctx->linestart = 0; } for (i = 0, c = '\0'; i < outl && (c = out[i]) != '\n'; i++) continue; if (c == '\n') i++; while (i > 0) { size_t num = 0; if (!BIO_write_ex(BIO_next(b), out, i, &num)) return 0; out += num; outl -= num; *numwritten += num; i -= num; } if (c == '\n') ctx->linestart = 1; } return 1; }"
7990----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_b2c9b95fb38cfbaffe9940504366c515800c7b6c_1.json----read_packet,"<S2SV_StartVul> static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size) <S2SV_EndVul> { AVIOContext *pb = s->pb; <S2SV_StartVul> int skip, len; <S2SV_EndVul> for(;;) { <S2SV_StartVul> len = avio_read(pb, buf, TS_PACKET_SIZE); <S2SV_EndVul> if (len != TS_PACKET_SIZE) return len < 0 ? len : AVERROR_EOF; <S2SV_StartVul> if (buf[0] != 0x47) { <S2SV_EndVul> avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR); if (mpegts_resync(s) < 0) return AVERROR(EAGAIN); else continue; } else { <S2SV_StartVul> skip = raw_packet_size - TS_PACKET_SIZE; <S2SV_EndVul> <S2SV_StartVul> if (skip > 0) <S2SV_EndVul> <S2SV_StartVul> avio_skip(pb, skip); <S2SV_EndVul> break; } } return 0; }","- static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size)
- int skip, len;
- len = avio_read(pb, buf, TS_PACKET_SIZE);
- if (buf[0] != 0x47) {
- skip = raw_packet_size - TS_PACKET_SIZE;
- if (skip > 0)
- avio_skip(pb, skip);
+ static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)
+ int len;
+ len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);
+ if ((*data)[0] != 0x47) {","static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data) { AVIOContext *pb = s->pb; int len; for(;;) { len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data); if (len != TS_PACKET_SIZE) return len < 0 ? len : AVERROR_EOF; if ((*data)[0] != 0x47) { avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR); if (mpegts_resync(s) < 0) return AVERROR(EAGAIN); else continue; } else { break; } } return 0; }"
1118----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3d81816c7901897f78af211de469ac96e29e0c79_1.json----tget_long,"static unsigned tget_long(GetByteContext *gb, int le) { <S2SV_StartVul> unsigned v = le ? bytestream2_get_le32(gb) : bytestream2_get_be32(gb); <S2SV_EndVul> return v; }","- unsigned v = le ? bytestream2_get_le32(gb) : bytestream2_get_be32(gb);
+ unsigned v = le ? bytestream2_get_le32u(gb) : bytestream2_get_be32u(gb);","static unsigned tget_long(GetByteContext *gb, int le) { unsigned v = le ? bytestream2_get_le32u(gb) : bytestream2_get_be32u(gb); return v; }"
9423----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_4a926dbf3c916f07e0e8620e6c1bae4d745c7fb4_1.json----TIFFReadRawStrip,"tmsize_t TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size) { static const char module[] = ""TIFFReadRawStrip""; TIFFDirectory *td = &tif->tif_dir; uint64 bytecount; tmsize_t bytecountm; if (!TIFFCheckRead(tif, 0)) return ((tmsize_t)(-1)); if (strip >= td->td_nstrips) { TIFFErrorExt(tif->tif_clientdata, module, ""%lu: Strip out of range, max %lu"", (unsigned long) strip, (unsigned long) td->td_nstrips); return ((tmsize_t)(-1)); } if (tif->tif_flags&TIFF_NOREADRAW) { TIFFErrorExt(tif->tif_clientdata, module, ""Compression scheme does not support access to raw uncompressed data""); return ((tmsize_t)(-1)); } bytecount = TIFFGetStrileByteCount(tif, strip); <S2SV_StartVul> if ((int64)bytecount <= 0) { <S2SV_EndVul> <S2SV_StartVul> #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) <S2SV_EndVul> <S2SV_StartVul> TIFFErrorExt(tif->tif_clientdata, module, <S2SV_EndVul> <S2SV_StartVul> ""%I64u: Invalid strip byte count, strip %lu"", <S2SV_EndVul> <S2SV_StartVul> (unsigned __int64) bytecount, <S2SV_EndVul> <S2SV_StartVul> (unsigned long) strip); <S2SV_EndVul> <S2SV_StartVul> #else <S2SV_EndVul> <S2SV_StartVul> TIFFErrorExt(tif->tif_clientdata, module, <S2SV_EndVul> <S2SV_StartVul> ""%llu: Invalid strip byte count, strip %lu"", <S2SV_EndVul> <S2SV_StartVul> (unsigned long long) bytecount, <S2SV_EndVul> <S2SV_StartVul> (unsigned long) strip); <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> <S2SV_StartVul> return ((tmsize_t)(-1)); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> bytecountm = (tmsize_t)bytecount; <S2SV_EndVul> <S2SV_StartVul> if ((uint64)bytecountm!=bytecount) { <S2SV_EndVul> <S2SV_StartVul> TIFFErrorExt(tif->tif_clientdata, module, ""Integer overflow""); <S2SV_EndVul> return ((tmsize_t)(-1)); } if (size != (tmsize_t)(-1) && size < bytecountm) bytecountm = size; return (TIFFReadRawStrip1(tif, strip, buf, bytecountm, module)); }","- if ((int64)bytecount <= 0) {
- #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
- TIFFErrorExt(tif->tif_clientdata, module,
- ""%I64u: Invalid strip byte count, strip %lu"",
- (unsigned __int64) bytecount,
- (unsigned long) strip);
- #else
- TIFFErrorExt(tif->tif_clientdata, module,
- ""%llu: Invalid strip byte count, strip %lu"",
- (unsigned long long) bytecount,
- (unsigned long) strip);
- #endif
- return ((tmsize_t)(-1));
- }
- bytecountm = (tmsize_t)bytecount;
- if ((uint64)bytecountm!=bytecount) {
- TIFFErrorExt(tif->tif_clientdata, module, ""Integer overflow"");
+ bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount, module);
+ if (bytecountm == 0) {","tmsize_t TIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size) { static const char module[] = ""TIFFReadRawStrip""; TIFFDirectory *td = &tif->tif_dir; uint64 bytecount; tmsize_t bytecountm; if (!TIFFCheckRead(tif, 0)) return ((tmsize_t)(-1)); if (strip >= td->td_nstrips) { TIFFErrorExt(tif->tif_clientdata, module, ""%lu: Strip out of range, max %lu"", (unsigned long) strip, (unsigned long) td->td_nstrips); return ((tmsize_t)(-1)); } if (tif->tif_flags&TIFF_NOREADRAW) { TIFFErrorExt(tif->tif_clientdata, module, ""Compression scheme does not support access to raw uncompressed data""); return ((tmsize_t)(-1)); } bytecount = TIFFGetStrileByteCount(tif, strip); bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount, module); if (bytecountm == 0) { return ((tmsize_t)(-1)); } if (size != (tmsize_t)(-1) && size < bytecountm) bytecountm = size; return (TIFFReadRawStrip1(tif, strip, buf, bytecountm, module)); }"
2332----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7fc1a41337194f64e17dad00d263c42a3daee8c9_1.json----ff_network_init,"int ff_network_init(void) { #if HAVE_WINSOCK2_H WSADATA wsaData; <S2SV_StartVul> #endif <S2SV_EndVul> <S2SV_StartVul> if (!ff_network_inited_globally) <S2SV_EndVul> <S2SV_StartVul> av_log(NULL, AV_LOG_WARNING, ""Using network protocols without global "" <S2SV_EndVul> <S2SV_StartVul> ""network initialization. Please use "" <S2SV_EndVul> <S2SV_StartVul> ""avformat_network_init(), this will "" <S2SV_EndVul> <S2SV_StartVul> ""become mandatory later.\n""); <S2SV_EndVul> <S2SV_StartVul> #if HAVE_WINSOCK2_H <S2SV_EndVul> if (WSAStartup(MAKEWORD(1,1), &wsaData)) return 0; #endif return 1; }","- #endif
- if (!ff_network_inited_globally)
- av_log(NULL, AV_LOG_WARNING, ""Using network protocols without global ""
- ""network initialization. Please use ""
- ""avformat_network_init(), this will ""
- ""become mandatory later.\n"");
- #if HAVE_WINSOCK2_H","int ff_network_init(void) { #if HAVE_WINSOCK2_H WSADATA wsaData; if (WSAStartup(MAKEWORD(1,1), &wsaData)) return 0; #endif return 1; }"
11021----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1a7be78b5fdfe9518ad465e00ad8f2fcae759817_1.json----HMAC_CTX_copy,"int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx) { if (!hmac_ctx_alloc_mds(dctx)) goto err; if (!EVP_MD_CTX_copy_ex(dctx->i_ctx, sctx->i_ctx)) goto err; if (!EVP_MD_CTX_copy_ex(dctx->o_ctx, sctx->o_ctx)) goto err; if (!EVP_MD_CTX_copy_ex(dctx->md_ctx, sctx->md_ctx)) goto err; <S2SV_StartVul> memcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK); <S2SV_EndVul> dctx->key_length = sctx->key_length; dctx->md = sctx->md; return 1; err: hmac_ctx_cleanup(dctx); return 0; }","- memcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK);
+ memcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK_SIZE);","int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx) { if (!hmac_ctx_alloc_mds(dctx)) goto err; if (!EVP_MD_CTX_copy_ex(dctx->i_ctx, sctx->i_ctx)) goto err; if (!EVP_MD_CTX_copy_ex(dctx->o_ctx, sctx->o_ctx)) goto err; if (!EVP_MD_CTX_copy_ex(dctx->md_ctx, sctx->md_ctx)) goto err; memcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK_SIZE); dctx->key_length = sctx->key_length; dctx->md = sctx->md; return 1; err: hmac_ctx_cleanup(dctx); return 0; }"
10309----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018dcf8a27af741664ace7773e4fdf2ec9d7db81_1.json----test_encode_tls_sct,"static int test_encode_tls_sct() { const char log_id[] = ""3xwuwRUAlFJHqWFoMl3cXHlZ6PfG04j8AC4LvT9012Q=""; const uint64_t timestamp = 1; const char extensions[] = """"; const char signature[] = ""BAMARzBAMiBIL2dRrzXbplQ2vh/WZA89v5pBQpSVkkUwKI+j5"" ""eI+BgIhAOTtwNs6xXKx4vXoq2poBlOYfc9BAn3+/6EFUZ2J7b8I""; SCT *sct = NULL; SETUP_CT_TEST_FIXTURE(); fixture.sct_list = sk_SCT_new_null(); <S2SV_StartVul> sct = SCT_new_from_base64(SCT_VERSION_V1, log_id, <S2SV_EndVul> <S2SV_StartVul> CT_LOG_ENTRY_TYPE_X509, timestamp, <S2SV_EndVul> <S2SV_StartVul> extensions, signature); <S2SV_EndVul> <S2SV_StartVul> if (sct == NULL) { <S2SV_EndVul> <S2SV_StartVul> tear_down(fixture); <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""Failed to create SCT from base64-encoded test data\n""); <S2SV_EndVul> return 0; <S2SV_StartVul> } <S2SV_EndVul> sk_SCT_push(fixture.sct_list, sct); fixture.sct_dir = ct_dir; fixture.sct_text_file = ""tls1.sct""; EXECUTE_CT_TEST(); }","- sct = SCT_new_from_base64(SCT_VERSION_V1, log_id,
- CT_LOG_ENTRY_TYPE_X509, timestamp,
- extensions, signature);
- if (sct == NULL) {
- tear_down(fixture);
- fprintf(stderr, ""Failed to create SCT from base64-encoded test data\n"");
- }
+ if (!TEST_ptr(sct = SCT_new_from_base64(SCT_VERSION_V1, log_id,
+ CT_LOG_ENTRY_TYPE_X509, timestamp,
+ extensions, signature)))","static int test_encode_tls_sct() { const char log_id[] = ""3xwuwRUAlFJHqWFoMl3cXHlZ6PfG04j8AC4LvT9012Q=""; const uint64_t timestamp = 1; const char extensions[] = """"; const char signature[] = ""BAMARzBAMiBIL2dRrzXbplQ2vh/WZA89v5pBQpSVkkUwKI+j5"" ""eI+BgIhAOTtwNs6xXKx4vXoq2poBlOYfc9BAn3+/6EFUZ2J7b8I""; SCT *sct = NULL; SETUP_CT_TEST_FIXTURE(); fixture.sct_list = sk_SCT_new_null(); if (!TEST_ptr(sct = SCT_new_from_base64(SCT_VERSION_V1, log_id, CT_LOG_ENTRY_TYPE_X509, timestamp, extensions, signature))) return 0; sk_SCT_push(fixture.sct_list, sct); fixture.sct_dir = ct_dir; fixture.sct_text_file = ""tls1.sct""; EXECUTE_CT_TEST(); }"
13416----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6f4372479013731b10384a65af15820293e28da9_1.json----nseq_main,"int MAIN(int argc, char **argv) { char **args, *infile = NULL, *outfile = NULL; BIO *in = NULL, *out = NULL; int toseq = 0; X509 *x509 = NULL; NETSCAPE_CERT_SEQUENCE *seq = NULL; int i, ret = 1; int badarg = 0; if (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE); ERR_load_crypto_strings(); args = argv + 1; while (!badarg && *args && *args[0] == '-') { if (!strcmp (*args, ""-toseq"")) toseq = 1; else if (!strcmp (*args, ""-in"")) { if (args[1]) { args++; infile = *args; } else badarg = 1; } else if (!strcmp (*args, ""-out"")) { if (args[1]) { args++; outfile = *args; } else badarg = 1; } else badarg = 1; args++; } if (badarg) { BIO_printf (bio_err, ""Netscape certificate sequence utility\n""); BIO_printf (bio_err, ""Usage nseq [options]\n""); BIO_printf (bio_err, ""where options are\n""); BIO_printf (bio_err, ""-in file input file\n""); BIO_printf (bio_err, ""-out file output file\n""); BIO_printf (bio_err, ""-toseq output NS Sequence file\n""); EXIT(1); } if (infile) { if (!(in = BIO_new_file (infile, ""r""))) { BIO_printf (bio_err, ""Can't open input file %s\n"", infile); goto end; } } else in = BIO_new_fp(stdin, BIO_NOCLOSE); if (outfile) { if (!(out = BIO_new_file (outfile, ""w""))) { BIO_printf (bio_err, ""Can't open output file %s\n"", outfile); goto end; } <S2SV_StartVul> } else out = BIO_new_fp(stdout, BIO_NOCLOSE); <S2SV_EndVul> if (toseq) { seq = NETSCAPE_CERT_SEQUENCE_new(); seq->certs = sk_X509_new_null(); while((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL))) sk_X509_push(seq->certs,x509); if(!sk_X509_num(seq->certs)) { BIO_printf (bio_err, ""Error reading certs file %s\n"", infile); ERR_print_errors(bio_err); goto end; } PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq); ret = 0; goto end; } if (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) { BIO_printf (bio_err, ""Error reading sequence file %s\n"", infile); ERR_print_errors(bio_err); goto end; } for(i = 0; i < sk_X509_num(seq->certs); i++) { x509 = sk_X509_value(seq->certs, i); dump_cert_text(out, x509); PEM_write_bio_X509(out, x509); } ret = 0; end: BIO_free(in); <S2SV_StartVul> BIO_free(out); <S2SV_EndVul> NETSCAPE_CERT_SEQUENCE_free(seq); EXIT(ret); }","- } else out = BIO_new_fp(stdout, BIO_NOCLOSE);
- BIO_free(out);
+ } else {
+ out = BIO_new_fp(stdout, BIO_NOCLOSE);
+ #ifdef VMS
+ {
+ BIO *tmpbio = BIO_new(BIO_f_linebuffer());
+ out = BIO_push(tmpbio, out);
+ }
+ #endif
+ }
+ BIO_free_all(out);","int MAIN(int argc, char **argv) { char **args, *infile = NULL, *outfile = NULL; BIO *in = NULL, *out = NULL; int toseq = 0; X509 *x509 = NULL; NETSCAPE_CERT_SEQUENCE *seq = NULL; int i, ret = 1; int badarg = 0; if (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE); ERR_load_crypto_strings(); args = argv + 1; while (!badarg && *args && *args[0] == '-') { if (!strcmp (*args, ""-toseq"")) toseq = 1; else if (!strcmp (*args, ""-in"")) { if (args[1]) { args++; infile = *args; } else badarg = 1; } else if (!strcmp (*args, ""-out"")) { if (args[1]) { args++; outfile = *args; } else badarg = 1; } else badarg = 1; args++; } if (badarg) { BIO_printf (bio_err, ""Netscape certificate sequence utility\n""); BIO_printf (bio_err, ""Usage nseq [options]\n""); BIO_printf (bio_err, ""where options are\n""); BIO_printf (bio_err, ""-in file input file\n""); BIO_printf (bio_err, ""-out file output file\n""); BIO_printf (bio_err, ""-toseq output NS Sequence file\n""); EXIT(1); } if (infile) { if (!(in = BIO_new_file (infile, ""r""))) { BIO_printf (bio_err, ""Can't open input file %s\n"", infile); goto end; } } else in = BIO_new_fp(stdin, BIO_NOCLOSE); if (outfile) { if (!(out = BIO_new_file (outfile, ""w""))) { BIO_printf (bio_err, ""Can't open output file %s\n"", outfile); goto end; } } else { out = BIO_new_fp(stdout, BIO_NOCLOSE); #ifdef VMS { BIO *tmpbio = BIO_new(BIO_f_linebuffer()); out = BIO_push(tmpbio, out); } #endif } if (toseq) { seq = NETSCAPE_CERT_SEQUENCE_new(); seq->certs = sk_X509_new_null(); while((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL))) sk_X509_push(seq->certs,x509); if(!sk_X509_num(seq->certs)) { BIO_printf (bio_err, ""Error reading certs file %s\n"", infile); ERR_print_errors(bio_err); goto end; } PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq); ret = 0; goto end; } if (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) { BIO_printf (bio_err, ""Error reading sequence file %s\n"", infile); ERR_print_errors(bio_err); goto end; } for(i = 0; i < sk_X509_num(seq->certs); i++) { x509 = sk_X509_value(seq->certs, i); dump_cert_text(out, x509); PEM_write_bio_X509(out, x509); } ret = 0; end: BIO_free(in); BIO_free_all(out); NETSCAPE_CERT_SEQUENCE_free(seq); EXIT(ret); }"
546----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1e78889391a92a5584380641ac287daf23331ea2_1.json----pnm_decode_frame,"static int pnm_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; PNMContext * const s = avctx->priv_data; AVFrame * const p = data; int i, j, n, linesize, h, upgrade = 0, is_mono = 0; unsigned char *ptr; int components, sample_len, ret; <S2SV_StartVul> unsigned int maskval = 0; <S2SV_EndVul> s->bytestream_start = s->bytestream = (uint8_t *)buf; s->bytestream_end = (uint8_t *)buf + buf_size; if ((ret = ff_pnm_decode_header(avctx, s)) < 0) return ret; if ((ret = ff_get_buffer(avctx, p, 0)) < 0) return ret; p->pict_type = AV_PICTURE_TYPE_I; p->key_frame = 1; switch (avctx->pix_fmt) { default: return AVERROR(EINVAL); case AV_PIX_FMT_RGBA64BE: n = avctx->width * 8; components=4; sample_len=16; goto do_read; case AV_PIX_FMT_RGB48BE: n = avctx->width * 6; components=3; sample_len=16; goto do_read; case AV_PIX_FMT_RGBA: n = avctx->width * 4; components=4; sample_len=8; goto do_read; case AV_PIX_FMT_RGB24: n = avctx->width * 3; components=3; sample_len=8; goto do_read; case AV_PIX_FMT_GRAY8: n = avctx->width; components=1; sample_len=8; <S2SV_StartVul> if (s->maxval < 255) { <S2SV_EndVul> upgrade = 1; <S2SV_StartVul> maskval = (2 << av_log2(s->maxval)) - 1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> goto do_read; case AV_PIX_FMT_GRAY8A: n = avctx->width * 2; components=2; sample_len=8; goto do_read; case AV_PIX_FMT_GRAY16BE: case AV_PIX_FMT_GRAY16LE: n = avctx->width * 2; components=1; sample_len=16; <S2SV_StartVul> if (s->maxval < 65535) { <S2SV_EndVul> upgrade = 2; <S2SV_StartVul> maskval = (2 << av_log2(s->maxval)) - 1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> goto do_read; case AV_PIX_FMT_MONOWHITE: case AV_PIX_FMT_MONOBLACK: n = (avctx->width + 7) >> 3; components=1; sample_len=1; is_mono = 1; do_read: ptr = p->data[0]; linesize = p->linesize[0]; if (s->bytestream + n * avctx->height > s->bytestream_end) return AVERROR_INVALIDDATA; if(s->type < 4 || (is_mono && s->type==7)){ for (i=0; i<avctx->height; i++) { PutBitContext pb; init_put_bits(&pb, ptr, linesize); for(j=0; j<avctx->width * components; j++){ unsigned int c=0; int v=0; if(s->type < 4) while(s->bytestream < s->bytestream_end && (*s->bytestream < '0' || *s->bytestream > '9' )) s->bytestream++; if(s->bytestream >= s->bytestream_end) return AVERROR_INVALIDDATA; if (is_mono) { v = (*s->bytestream++)&1; } else { do { v = 10*v + c; c = (*s->bytestream++) - '0'; } while (c <= 9); } put_bits(&pb, sample_len, (((1<<sample_len)-1)*v + (s->maxval>>1))/s->maxval); } flush_put_bits(&pb); ptr+= linesize; } }else{ for (i = 0; i < avctx->height; i++) { if (!upgrade) memcpy(ptr, s->bytestream, n); else if (upgrade == 1) { unsigned int j, f = (255 * 128 + s->maxval / 2) / s->maxval; for (j = 0; j < n; j++) <S2SV_StartVul> ptr[j] = ((s->bytestream[j] & maskval) * f + 64) >> 7; <S2SV_EndVul> } else if (upgrade == 2) { unsigned int j, v, f = (65535 * 32768 + s->maxval / 2) / s->maxval; for (j = 0; j < n / 2; j++) { <S2SV_StartVul> v = av_be2ne16(((uint16_t *)s->bytestream)[j]) & maskval; <S2SV_EndVul> ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15; } } s->bytestream += n; ptr += linesize; } } break; case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV420P9BE: case AV_PIX_FMT_YUV420P10BE: { unsigned char *ptr1, *ptr2; n = avctx->width; ptr = p->data[0]; linesize = p->linesize[0]; if (s->maxval >= 256) n *= 2; if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end) return AVERROR_INVALIDDATA; for (i = 0; i < avctx->height; i++) { memcpy(ptr, s->bytestream, n); s->bytestream += n; ptr += linesize; } ptr1 = p->data[1]; ptr2 = p->data[2]; n >>= 1; h = avctx->height >> 1; for (i = 0; i < h; i++) { memcpy(ptr1, s->bytestream, n); s->bytestream += n; memcpy(ptr2, s->bytestream, n); s->bytestream += n; ptr1 += p->linesize[1]; ptr2 += p->linesize[2]; } } break; case AV_PIX_FMT_YUV420P16: { uint16_t *ptr1, *ptr2; const int f = (65535 * 32768 + s->maxval / 2) / s->maxval; unsigned int j, v; n = avctx->width * 2; ptr = p->data[0]; linesize = p->linesize[0]; if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end) return AVERROR_INVALIDDATA; for (i = 0; i < avctx->height; i++) { for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15; } s->bytestream += n; ptr += linesize; } ptr1 = (uint16_t*)p->data[1]; ptr2 = (uint16_t*)p->data[2]; n >>= 1; h = avctx->height >> 1; for (i = 0; i < h; i++) { for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ptr1[j] = (v * f + 16384) >> 15; } s->bytestream += n; for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ptr2[j] = (v * f + 16384) >> 15; } s->bytestream += n; ptr1 += p->linesize[1] / 2; ptr2 += p->linesize[2] / 2; } } break; } *got_frame = 1; return s->bytestream - s->bytestream_start; }","- unsigned int maskval = 0;
- if (s->maxval < 255) {
- maskval = (2 << av_log2(s->maxval)) - 1;
- }
- if (s->maxval < 65535) {
- maskval = (2 << av_log2(s->maxval)) - 1;
- }
- ptr[j] = ((s->bytestream[j] & maskval) * f + 64) >> 7;
- v = av_be2ne16(((uint16_t *)s->bytestream)[j]) & maskval;
+ if (s->maxval < 255)
+ if (s->maxval < 65535)
+ ptr[j] = (s->bytestream[j] * f + 64) >> 7;
+ v = av_be2ne16(((uint16_t *)s->bytestream)[j]);","static int pnm_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; PNMContext * const s = avctx->priv_data; AVFrame * const p = data; int i, j, n, linesize, h, upgrade = 0, is_mono = 0; unsigned char *ptr; int components, sample_len, ret; s->bytestream_start = s->bytestream = (uint8_t *)buf; s->bytestream_end = (uint8_t *)buf + buf_size; if ((ret = ff_pnm_decode_header(avctx, s)) < 0) return ret; if ((ret = ff_get_buffer(avctx, p, 0)) < 0) return ret; p->pict_type = AV_PICTURE_TYPE_I; p->key_frame = 1; switch (avctx->pix_fmt) { default: return AVERROR(EINVAL); case AV_PIX_FMT_RGBA64BE: n = avctx->width * 8; components=4; sample_len=16; goto do_read; case AV_PIX_FMT_RGB48BE: n = avctx->width * 6; components=3; sample_len=16; goto do_read; case AV_PIX_FMT_RGBA: n = avctx->width * 4; components=4; sample_len=8; goto do_read; case AV_PIX_FMT_RGB24: n = avctx->width * 3; components=3; sample_len=8; goto do_read; case AV_PIX_FMT_GRAY8: n = avctx->width; components=1; sample_len=8; if (s->maxval < 255) upgrade = 1; goto do_read; case AV_PIX_FMT_GRAY8A: n = avctx->width * 2; components=2; sample_len=8; goto do_read; case AV_PIX_FMT_GRAY16BE: case AV_PIX_FMT_GRAY16LE: n = avctx->width * 2; components=1; sample_len=16; if (s->maxval < 65535) upgrade = 2; goto do_read; case AV_PIX_FMT_MONOWHITE: case AV_PIX_FMT_MONOBLACK: n = (avctx->width + 7) >> 3; components=1; sample_len=1; is_mono = 1; do_read: ptr = p->data[0]; linesize = p->linesize[0]; if (s->bytestream + n * avctx->height > s->bytestream_end) return AVERROR_INVALIDDATA; if(s->type < 4 || (is_mono && s->type==7)){ for (i=0; i<avctx->height; i++) { PutBitContext pb; init_put_bits(&pb, ptr, linesize); for(j=0; j<avctx->width * components; j++){ unsigned int c=0; int v=0; if(s->type < 4) while(s->bytestream < s->bytestream_end && (*s->bytestream < '0' || *s->bytestream > '9' )) s->bytestream++; if(s->bytestream >= s->bytestream_end) return AVERROR_INVALIDDATA; if (is_mono) { v = (*s->bytestream++)&1; } else { do { v = 10*v + c; c = (*s->bytestream++) - '0'; } while (c <= 9); } put_bits(&pb, sample_len, (((1<<sample_len)-1)*v + (s->maxval>>1))/s->maxval); } flush_put_bits(&pb); ptr+= linesize; } }else{ for (i = 0; i < avctx->height; i++) { if (!upgrade) memcpy(ptr, s->bytestream, n); else if (upgrade == 1) { unsigned int j, f = (255 * 128 + s->maxval / 2) / s->maxval; for (j = 0; j < n; j++) ptr[j] = (s->bytestream[j] * f + 64) >> 7; } else if (upgrade == 2) { unsigned int j, v, f = (65535 * 32768 + s->maxval / 2) / s->maxval; for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15; } } s->bytestream += n; ptr += linesize; } } break; case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV420P9BE: case AV_PIX_FMT_YUV420P10BE: { unsigned char *ptr1, *ptr2; n = avctx->width; ptr = p->data[0]; linesize = p->linesize[0]; if (s->maxval >= 256) n *= 2; if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end) return AVERROR_INVALIDDATA; for (i = 0; i < avctx->height; i++) { memcpy(ptr, s->bytestream, n); s->bytestream += n; ptr += linesize; } ptr1 = p->data[1]; ptr2 = p->data[2]; n >>= 1; h = avctx->height >> 1; for (i = 0; i < h; i++) { memcpy(ptr1, s->bytestream, n); s->bytestream += n; memcpy(ptr2, s->bytestream, n); s->bytestream += n; ptr1 += p->linesize[1]; ptr2 += p->linesize[2]; } } break; case AV_PIX_FMT_YUV420P16: { uint16_t *ptr1, *ptr2; const int f = (65535 * 32768 + s->maxval / 2) / s->maxval; unsigned int j, v; n = avctx->width * 2; ptr = p->data[0]; linesize = p->linesize[0]; if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end) return AVERROR_INVALIDDATA; for (i = 0; i < avctx->height; i++) { for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15; } s->bytestream += n; ptr += linesize; } ptr1 = (uint16_t*)p->data[1]; ptr2 = (uint16_t*)p->data[2]; n >>= 1; h = avctx->height >> 1; for (i = 0; i < h; i++) { for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ptr1[j] = (v * f + 16384) >> 15; } s->bytestream += n; for (j = 0; j < n / 2; j++) { v = av_be2ne16(((uint16_t *)s->bytestream)[j]); ptr2[j] = (v * f + 16384) >> 15; } s->bytestream += n; ptr1 += p->linesize[1] / 2; ptr2 += p->linesize[2] / 2; } } break; } *got_frame = 1; return s->bytestream - s->bytestream_start; }"
16648----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_deabc03e2be169f0d232a254c025b4d6f98f9f02_1.json----SSL_get_shared_ciphers,"char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len) { char *p; STACK_OF(SSL_CIPHER) *sk; SSL_CIPHER *c; int i; if ((s->session == NULL) || (s->session->ciphers == NULL) || (len < 2)) return(NULL); if (sk_SSL_CIPHER_num(sk) == 0) return NULL; <S2SV_StartVul> p=buf; <S2SV_EndVul> <S2SV_StartVul> sk=s->session->ciphers; <S2SV_EndVul> for (i=0; i<sk_SSL_CIPHER_num(sk); i++) { int n; c=sk_SSL_CIPHER_value(sk,i); n=strlen(c->name); if (n+1 > len) { if (p != buf) --p; *p='\0'; return buf; } strcpy(p,c->name); p+=n; *(p++)=':'; len-=n+1; } p[-1]='\0'; return(buf); }","- p=buf;
- sk=s->session->ciphers;
+ p=buf;
+ sk=s->session->ciphers;","char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len) { char *p; STACK_OF(SSL_CIPHER) *sk; SSL_CIPHER *c; int i; if ((s->session == NULL) || (s->session->ciphers == NULL) || (len < 2)) return(NULL); p=buf; sk=s->session->ciphers; if (sk_SSL_CIPHER_num(sk) == 0) return NULL; for (i=0; i<sk_SSL_CIPHER_num(sk); i++) { int n; c=sk_SSL_CIPHER_value(sk,i); n=strlen(c->name); if (n+1 > len) { if (p != buf) --p; *p='\0'; return buf; } strcpy(p,c->name); p+=n; *(p++)=':'; len-=n+1; } p[-1]='\0'; return(buf); }"
13455----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_708d345b4e0c0594b035b83c7cb5f118305eb673_1.json----ssl_set_sig_mask,"void ssl_set_sig_mask(uint32_t *pmask_a, SSL *s, int op) { const uint16_t *sigalgs; size_t i, sigalgslen; uint32_t disabled_mask = SSL_aRSA | SSL_aDSS | SSL_aECDSA; sigalgslen = tls12_get_psigalgs(s, 1, &sigalgs); <S2SV_StartVul> for (i = 0; i < sigalgslen; i ++, sigalgs++) { <S2SV_EndVul> const SIGALG_LOOKUP *lu = tls1_lookup_sigalg(*sigalgs); const SSL_CERT_LOOKUP *clu; if (lu == NULL) continue; clu = ssl_cert_lookup_by_idx(lu->sig_idx); if ((clu->amask & disabled_mask) != 0 && tls12_sigalg_allowed(s, op, lu)) disabled_mask &= ~clu->amask; } *pmask_a |= disabled_mask; }","- for (i = 0; i < sigalgslen; i ++, sigalgs++) {
+ for (i = 0; i < sigalgslen; i++, sigalgs++) {
+ if (clu == NULL)
+ continue;","void ssl_set_sig_mask(uint32_t *pmask_a, SSL *s, int op) { const uint16_t *sigalgs; size_t i, sigalgslen; uint32_t disabled_mask = SSL_aRSA | SSL_aDSS | SSL_aECDSA; sigalgslen = tls12_get_psigalgs(s, 1, &sigalgs); for (i = 0; i < sigalgslen; i++, sigalgs++) { const SIGALG_LOOKUP *lu = tls1_lookup_sigalg(*sigalgs); const SSL_CERT_LOOKUP *clu; if (lu == NULL) continue; clu = ssl_cert_lookup_by_idx(lu->sig_idx); if (clu == NULL) continue; if ((clu->amask & disabled_mask) != 0 && tls12_sigalg_allowed(s, op, lu)) disabled_mask &= ~clu->amask; } *pmask_a |= disabled_mask; }"
9837----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_0199e2876a01c4465223787db4a78daa27f3a110_1.json----ngx_http_file_cache_update,"void ngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf) { off_t fs_size; ngx_int_t rc; ngx_file_uniq_t uniq; ngx_file_info_t fi; ngx_http_cache_t *c; ngx_ext_rename_file_t ext; ngx_http_file_cache_t *cache; c = r->cache; if (c->updated) { return; } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http file cache update""); cache = c->file_cache; <S2SV_StartVul> if (c->secondary <S2SV_EndVul> <S2SV_StartVul> && ngx_memcmp(c->variant, c->key, NGX_HTTP_CACHE_KEY_LEN) != 0) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, <S2SV_EndVul> <S2SV_StartVul> ""http file cache main key""); <S2SV_EndVul> <S2SV_StartVul> ngx_shmtx_lock(&cache->shpool->mutex); <S2SV_EndVul> <S2SV_StartVul> c->node->count--; <S2SV_EndVul> <S2SV_StartVul> c->node->updating = 0; <S2SV_EndVul> <S2SV_StartVul> c->node = NULL; <S2SV_EndVul> <S2SV_StartVul> ngx_shmtx_unlock(&cache->shpool->mutex); <S2SV_EndVul> <S2SV_StartVul> c->file.name.len = 0; <S2SV_EndVul> <S2SV_StartVul> ngx_memcpy(c->key, c->main, NGX_HTTP_CACHE_KEY_LEN); <S2SV_EndVul> <S2SV_StartVul> if (ngx_http_file_cache_exists(cache, c) == NGX_ERROR) { <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (ngx_http_file_cache_name(r, cache->path) != NGX_OK) { <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> c->updated = 1; c->updating = 0; uniq = 0; fs_size = 0; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http file cache rename: \""%s\"" to \""%s\"""", tf->file.name.data, c->file.name.data); ext.access = NGX_FILE_OWNER_ACCESS; ext.path_access = NGX_FILE_OWNER_ACCESS; ext.time = -1; ext.create_path = 1; ext.delete_file = 1; ext.log = r->connection->log; rc = ngx_ext_rename_file(&tf->file.name, &c->file.name, &ext); if (rc == NGX_OK) { if (ngx_fd_info(tf->file.fd, &fi) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, ngx_fd_info_n "" \""%s\"" failed"", tf->file.name.data); rc = NGX_ERROR; } else { uniq = ngx_file_uniq(&fi); fs_size = (ngx_file_fs_size(&fi) + cache->bsize - 1) / cache->bsize; } } ngx_shmtx_lock(&cache->shpool->mutex); c->node->count--; c->node->uniq = uniq; c->node->body_start = c->body_start; cache->sh->size += fs_size - c->node->fs_size; c->node->fs_size = fs_size; if (rc == NGX_OK) { c->node->exists = 1; } c->node->updating = 0; ngx_shmtx_unlock(&cache->shpool->mutex); }","- if (c->secondary
- && ngx_memcmp(c->variant, c->key, NGX_HTTP_CACHE_KEY_LEN) != 0)
- {
- ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
- ""http file cache main key"");
- ngx_shmtx_lock(&cache->shpool->mutex);
- c->node->count--;
- c->node->updating = 0;
- c->node = NULL;
- ngx_shmtx_unlock(&cache->shpool->mutex);
- c->file.name.len = 0;
- ngx_memcpy(c->key, c->main, NGX_HTTP_CACHE_KEY_LEN);
- if (ngx_http_file_cache_exists(cache, c) == NGX_ERROR) {
- return;
- }
- if (ngx_http_file_cache_name(r, cache->path) != NGX_OK) {
- return;
- }
- }","void ngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf) { off_t fs_size; ngx_int_t rc; ngx_file_uniq_t uniq; ngx_file_info_t fi; ngx_http_cache_t *c; ngx_ext_rename_file_t ext; ngx_http_file_cache_t *cache; c = r->cache; if (c->updated) { return; } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http file cache update""); cache = c->file_cache; c->updated = 1; c->updating = 0; uniq = 0; fs_size = 0; ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, ""http file cache rename: \""%s\"" to \""%s\"""", tf->file.name.data, c->file.name.data); ext.access = NGX_FILE_OWNER_ACCESS; ext.path_access = NGX_FILE_OWNER_ACCESS; ext.time = -1; ext.create_path = 1; ext.delete_file = 1; ext.log = r->connection->log; rc = ngx_ext_rename_file(&tf->file.name, &c->file.name, &ext); if (rc == NGX_OK) { if (ngx_fd_info(tf->file.fd, &fi) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, ngx_fd_info_n "" \""%s\"" failed"", tf->file.name.data); rc = NGX_ERROR; } else { uniq = ngx_file_uniq(&fi); fs_size = (ngx_file_fs_size(&fi) + cache->bsize - 1) / cache->bsize; } } ngx_shmtx_lock(&cache->shpool->mutex); c->node->count--; c->node->uniq = uniq; c->node->body_start = c->body_start; cache->sh->size += fs_size - c->node->fs_size; c->node->fs_size = fs_size; if (rc == NGX_OK) { c->node->exists = 1; } c->node->updating = 0; ngx_shmtx_unlock(&cache->shpool->mutex); }"
454----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1994a97def95085eace0f2f406ff17779a61f590_1.json----blend_frames,"static int blend_frames(AVFilterContext *ctx, int interpolate) { FrameRateContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; double interpolate_scene_score = 0; if ((s->flags & FRAMERATE_FLAG_SCD)) { if (s->score >= 0.0) interpolate_scene_score = s->score; else interpolate_scene_score = s->score = get_scene_score(ctx, s->f0, s->f1); ff_dlog(ctx, ""blend_frames() interpolate scene score:%f\n"", interpolate_scene_score); } if (interpolate_scene_score < s->scene_score) { ThreadData td; td.copy_src1 = s->f0; td.copy_src2 = s->f1; td.src2_factor = interpolate; <S2SV_StartVul> td.src1_factor = s->max - td.src2_factor; <S2SV_EndVul> s->work = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!s->work) return AVERROR(ENOMEM); av_frame_copy_props(s->work, s->f0); ff_dlog(ctx, ""blend_frames() INTERPOLATE to create work frame\n""); ctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx))); return 1; } return 0; }","- td.src1_factor = s->max - td.src2_factor;
+ td.src1_factor = s->blend_factor_max - td.src2_factor;","static int blend_frames(AVFilterContext *ctx, int interpolate) { FrameRateContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; double interpolate_scene_score = 0; if ((s->flags & FRAMERATE_FLAG_SCD)) { if (s->score >= 0.0) interpolate_scene_score = s->score; else interpolate_scene_score = s->score = get_scene_score(ctx, s->f0, s->f1); ff_dlog(ctx, ""blend_frames() interpolate scene score:%f\n"", interpolate_scene_score); } if (interpolate_scene_score < s->scene_score) { ThreadData td; td.copy_src1 = s->f0; td.copy_src2 = s->f1; td.src2_factor = interpolate; td.src1_factor = s->blend_factor_max - td.src2_factor; s->work = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!s->work) return AVERROR(ENOMEM); av_frame_copy_props(s->work, s->f0); ff_dlog(ctx, ""blend_frames() INTERPOLATE to create work frame\n""); ctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx))); return 1; } return 0; }"
1391----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4d0983b40ec098580465d8c88a3fa168e3d6aa1f_1.json----build_vlc,"static int build_vlc(AVCodecContext *avctx, VLC *vlc, const uint32_t *table) { Node nodes[512]; uint32_t bits[256]; int16_t lens[256]; uint8_t xlat[256]; int cur_node, i, j, pos = 0; ff_free_vlc(vlc); for (i = 0; i < 256; i++) { nodes[i].count = table[i]; nodes[i].sym = i; nodes[i].n0 = -2; nodes[i].l = i; nodes[i].r = i; } cur_node = 256; j = 0; do { for (i = 0; ; i++) { int new_node = j; int first_node = cur_node; int second_node = cur_node; <S2SV_StartVul> int nd, st; <S2SV_EndVul> nodes[cur_node].count = -1; do { int val = nodes[new_node].count; if (val && (val < nodes[first_node].count)) { if (val >= nodes[second_node].count) { first_node = new_node; } else { first_node = second_node; second_node = new_node; } } new_node += 1; } while (new_node != cur_node); if (first_node == cur_node) break; nd = nodes[second_node].count; st = nodes[first_node].count; nodes[second_node].count = 0; nodes[first_node].count = 0; nodes[cur_node].count = nd + st; nodes[cur_node].sym = -1; nodes[cur_node].n0 = cur_node; nodes[cur_node].l = first_node; nodes[cur_node].r = second_node; cur_node++; } j++; } while (cur_node - 256 == j); get_tree_codes(bits, lens, xlat, nodes, cur_node - 1, 0, 0, &pos); return ff_init_vlc_sparse(vlc, 10, pos, lens, 2, 2, bits, 4, 4, xlat, 1, 1, 0); }","- int nd, st;
+ unsigned nd, st;
+ if (nd >= UINT32_MAX - st) {
+ av_log(avctx, AV_LOG_ERROR, ""count overflow\n"");
+ return AVERROR_INVALIDDATA;
+ }","static int build_vlc(AVCodecContext *avctx, VLC *vlc, const uint32_t *table) { Node nodes[512]; uint32_t bits[256]; int16_t lens[256]; uint8_t xlat[256]; int cur_node, i, j, pos = 0; ff_free_vlc(vlc); for (i = 0; i < 256; i++) { nodes[i].count = table[i]; nodes[i].sym = i; nodes[i].n0 = -2; nodes[i].l = i; nodes[i].r = i; } cur_node = 256; j = 0; do { for (i = 0; ; i++) { int new_node = j; int first_node = cur_node; int second_node = cur_node; unsigned nd, st; nodes[cur_node].count = -1; do { int val = nodes[new_node].count; if (val && (val < nodes[first_node].count)) { if (val >= nodes[second_node].count) { first_node = new_node; } else { first_node = second_node; second_node = new_node; } } new_node += 1; } while (new_node != cur_node); if (first_node == cur_node) break; nd = nodes[second_node].count; st = nodes[first_node].count; nodes[second_node].count = 0; nodes[first_node].count = 0; if (nd >= UINT32_MAX - st) { av_log(avctx, AV_LOG_ERROR, ""count overflow\n""); return AVERROR_INVALIDDATA; } nodes[cur_node].count = nd + st; nodes[cur_node].sym = -1; nodes[cur_node].n0 = cur_node; nodes[cur_node].l = first_node; nodes[cur_node].r = second_node; cur_node++; } j++; } while (cur_node - 256 == j); get_tree_codes(bits, lens, xlat, nodes, cur_node - 1, 0, 0, &pos); return ff_init_vlc_sparse(vlc, 10, pos, lens, 2, 2, bits, 4, 4, xlat, 1, 1, 0); }"
16440----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d780ca441a4950d56edca5b2d678ab6761ca1602_1.json----RSA_free,"void RSA_free(RSA *r) { int i; if (r == NULL) return; i=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA); #ifdef REF_PRINT REF_PRINT(""RSA"",r); #endif if (i > 0) return; #ifdef REF_CHECK if (i < 0) { fprintf(stderr,""RSA_free, bad reference count\n""); abort(); } #endif CRYPTO_free_ex_data(rsa_meth,r,&r->ex_data); <S2SV_StartVul> if (r->meth->finish != NULL) <S2SV_EndVul> <S2SV_StartVul> r->meth->finish(r); <S2SV_EndVul> if (r->n != NULL) BN_clear_free(r->n); if (r->e != NULL) BN_clear_free(r->e); if (r->d != NULL) BN_clear_free(r->d); if (r->p != NULL) BN_clear_free(r->p); if (r->q != NULL) BN_clear_free(r->q); if (r->dmp1 != NULL) BN_clear_free(r->dmp1); if (r->dmq1 != NULL) BN_clear_free(r->dmq1); if (r->iqmp != NULL) BN_clear_free(r->iqmp); if (r->blinding != NULL) BN_BLINDING_free(r->blinding); if (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data); OPENSSL_free(r); }","- if (r->meth->finish != NULL)
- r->meth->finish(r);
+ RSA_METHOD *meth;
+ meth = ENGINE_get_RSA(r->engine);
+ if (meth->finish != NULL)
+ meth->finish(r);
+ ENGINE_finish(r->engine);","void RSA_free(RSA *r) { RSA_METHOD *meth; int i; if (r == NULL) return; i=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA); #ifdef REF_PRINT REF_PRINT(""RSA"",r); #endif if (i > 0) return; #ifdef REF_CHECK if (i < 0) { fprintf(stderr,""RSA_free, bad reference count\n""); abort(); } #endif CRYPTO_free_ex_data(rsa_meth,r,&r->ex_data); meth = ENGINE_get_RSA(r->engine); if (meth->finish != NULL) meth->finish(r); ENGINE_finish(r->engine); if (r->n != NULL) BN_clear_free(r->n); if (r->e != NULL) BN_clear_free(r->e); if (r->d != NULL) BN_clear_free(r->d); if (r->p != NULL) BN_clear_free(r->p); if (r->q != NULL) BN_clear_free(r->q); if (r->dmp1 != NULL) BN_clear_free(r->dmp1); if (r->dmq1 != NULL) BN_clear_free(r->dmq1); if (r->iqmp != NULL) BN_clear_free(r->iqmp); if (r->blinding != NULL) BN_BLINDING_free(r->blinding); if (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data); OPENSSL_free(r); }"
1245----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4337de1e16c8b331497fd1bfc860e2c4d3fed071_1.json----decode_hq_slice,"static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf) { int i, level, orientation, quant_idx; int qfactor[MAX_DWT_LEVELS][4], qoffset[MAX_DWT_LEVELS][4]; GetBitContext *gb = &slice->gb; SliceCoeffs coeffs_num[MAX_DWT_LEVELS]; skip_bits_long(gb, 8*s->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); <S2SV_StartVul> if (quant_idx > DIRAC_MAX_QUANT_INDEX) { <S2SV_EndVul> av_log(s->avctx, AV_LOG_ERROR, ""Invalid quantization index - %i\n"", quant_idx); return AVERROR_INVALIDDATA; } for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { const int quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0); qfactor[level][orientation] = ff_dirac_qscale_tab[quant]; qoffset[level][orientation] = ff_dirac_qoffset_intra_tab[quant] + 2; } } for (i = 0; i < 3; i++) { int coef_num, coef_par, off = 0; int64_t length = s->highquality.size_scaler*get_bits(gb, 8); int64_t bits_end = get_bits_count(gb) + 8*length; const uint8_t *addr = align_get_bits(gb); if (length*8 > get_bits_left(gb)) { av_log(s->avctx, AV_LOG_ERROR, ""end too far away\n""); return AVERROR_INVALIDDATA; } coef_num = subband_coeffs(s, slice->slice_x, slice->slice_y, i, coeffs_num); if (s->pshift) coef_par = ff_dirac_golomb_read_32bit(s->reader_ctx, addr, length, tmp_buf, coef_num); else coef_par = ff_dirac_golomb_read_16bit(s->reader_ctx, addr, length, tmp_buf, coef_num); if (coef_num > coef_par) { const int start_b = coef_par * (1 << (s->pshift + 1)); const int end_b = coef_num * (1 << (s->pshift + 1)); memset(&tmp_buf[start_b], 0, end_b - start_b); } for (level = 0; level < s->wavelet_depth; level++) { const SliceCoeffs *c = &coeffs_num[level]; for (orientation = !!level; orientation < 4; orientation++) { const SubBand *b1 = &s->plane[i].band[level][orientation]; uint8_t *buf = b1->ibuf + c->top * b1->stride + (c->left << (s->pshift + 1)); const int qfunc = s->pshift + 2*(c->tot_h <= 2); s->diracdsp.dequant_subband[qfunc](&tmp_buf[off], buf, b1->stride, qfactor[level][orientation], qoffset[level][orientation], c->tot_v, c->tot_h); off += c->tot << (s->pshift + 1); } } skip_bits_long(gb, bits_end - get_bits_count(gb)); } return 0; }","- if (quant_idx > DIRAC_MAX_QUANT_INDEX) {
+ if (quant_idx > DIRAC_MAX_QUANT_INDEX - 1) {","static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf) { int i, level, orientation, quant_idx; int qfactor[MAX_DWT_LEVELS][4], qoffset[MAX_DWT_LEVELS][4]; GetBitContext *gb = &slice->gb; SliceCoeffs coeffs_num[MAX_DWT_LEVELS]; skip_bits_long(gb, 8*s->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); if (quant_idx > DIRAC_MAX_QUANT_INDEX - 1) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid quantization index - %i\n"", quant_idx); return AVERROR_INVALIDDATA; } for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { const int quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0); qfactor[level][orientation] = ff_dirac_qscale_tab[quant]; qoffset[level][orientation] = ff_dirac_qoffset_intra_tab[quant] + 2; } } for (i = 0; i < 3; i++) { int coef_num, coef_par, off = 0; int64_t length = s->highquality.size_scaler*get_bits(gb, 8); int64_t bits_end = get_bits_count(gb) + 8*length; const uint8_t *addr = align_get_bits(gb); if (length*8 > get_bits_left(gb)) { av_log(s->avctx, AV_LOG_ERROR, ""end too far away\n""); return AVERROR_INVALIDDATA; } coef_num = subband_coeffs(s, slice->slice_x, slice->slice_y, i, coeffs_num); if (s->pshift) coef_par = ff_dirac_golomb_read_32bit(s->reader_ctx, addr, length, tmp_buf, coef_num); else coef_par = ff_dirac_golomb_read_16bit(s->reader_ctx, addr, length, tmp_buf, coef_num); if (coef_num > coef_par) { const int start_b = coef_par * (1 << (s->pshift + 1)); const int end_b = coef_num * (1 << (s->pshift + 1)); memset(&tmp_buf[start_b], 0, end_b - start_b); } for (level = 0; level < s->wavelet_depth; level++) { const SliceCoeffs *c = &coeffs_num[level]; for (orientation = !!level; orientation < 4; orientation++) { const SubBand *b1 = &s->plane[i].band[level][orientation]; uint8_t *buf = b1->ibuf + c->top * b1->stride + (c->left << (s->pshift + 1)); const int qfunc = s->pshift + 2*(c->tot_h <= 2); s->diracdsp.dequant_subband[qfunc](&tmp_buf[off], buf, b1->stride, qfactor[level][orientation], qoffset[level][orientation], c->tot_v, c->tot_h); off += c->tot << (s->pshift + 1); } } skip_bits_long(gb, bits_end - get_bits_count(gb)); } return 0; }"
1264----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_44529b2c3ad01420eaef34997e0264969b24e5bf_1.json----tta_decode_frame,"static int tta_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TTAContext *s = avctx->priv_data; int i; init_get_bits(&s->gb, buf, buf_size*8); { int cur_chan = 0, framelen = s->frame_length; int32_t *p; <S2SV_StartVul> if (*data_size < (framelen * s->channels * 2)) { <S2SV_EndVul> <S2SV_StartVul> av_log(avctx, AV_LOG_ERROR, ""Output buffer size is too small.\n""); <S2SV_EndVul> <S2SV_StartVul> return -1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> s->total_frames--; if (!s->total_frames && s->last_frame_length) framelen = s->last_frame_length; for (i = 0; i < s->channels; i++) { s->ch_ctx[i].predictor = 0; ttafilter_init(&s->ch_ctx[i].filter, ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]); rice_init(&s->ch_ctx[i].rice, 10, 10); } for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { int32_t *predictor = &s->ch_ctx[cur_chan].predictor; TTAFilter *filter = &s->ch_ctx[cur_chan].filter; TTARice *rice = &s->ch_ctx[cur_chan].rice; uint32_t unary, depth, k; int32_t value; unary = tta_get_unary(&s->gb); if (unary == 0) { depth = 0; k = rice->k0; } else { depth = 1; k = rice->k1; unary--; } if (get_bits_left(&s->gb) < k) return -1; if (k) { if (k > MIN_CACHE_BITS) return -1; value = (unary << k) + get_bits(&s->gb, k); } else value = unary; switch (depth) { case 1: rice->sum1 += value - (rice->sum1 >> 4); if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1]) rice->k1--; else if(rice->sum1 > shift_16[rice->k1 + 1]) rice->k1++; value += shift_1[rice->k0]; default: rice->sum0 += value - (rice->sum0 >> 4); if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0]) rice->k0--; else if(rice->sum0 > shift_16[rice->k0 + 1]) rice->k0++; } #define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1)) *p = UNFOLD(value); ttafilter_process(filter, p, 0); #define PRED(x,k) (int32_t)((((uint64_t)x << k) - x) >> k) switch (s->bps) { case 1: *p += PRED(*predictor, 4); break; case 2: case 3: *p += PRED(*predictor, 5); break; case 4: *p += *predictor; break; } *predictor = *p; if (cur_chan < (s->channels-1)) cur_chan++; else { if (s->channels > 1) { int32_t *r = p - 1; for (*p += *r / 2; r > p - s->channels; r--) *r = *(r + 1) - *r; } cur_chan = 0; } } if (get_bits_left(&s->gb) < 32) return -1; skip_bits(&s->gb, 32); switch(s->bps) { case 2: { uint16_t *samples = data; for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { *samples++ = *p; } *data_size = (uint8_t *)samples - (uint8_t *)data; break; } default: av_log(s->avctx, AV_LOG_ERROR, ""Error, only 16bit samples supported!\n""); } } return buf_size; }","- if (*data_size < (framelen * s->channels * 2)) {
- av_log(avctx, AV_LOG_ERROR, ""Output buffer size is too small.\n"");
- return -1;
- }
+ if (*data_size < (framelen * s->channels * 2)) {
+ av_log(avctx, AV_LOG_ERROR, ""Output buffer size is too small.\n"");
+ return -1;
+ }","static int tta_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; TTAContext *s = avctx->priv_data; int i; init_get_bits(&s->gb, buf, buf_size*8); { int cur_chan = 0, framelen = s->frame_length; int32_t *p; s->total_frames--; if (!s->total_frames && s->last_frame_length) framelen = s->last_frame_length; if (*data_size < (framelen * s->channels * 2)) { av_log(avctx, AV_LOG_ERROR, ""Output buffer size is too small.\n""); return -1; } for (i = 0; i < s->channels; i++) { s->ch_ctx[i].predictor = 0; ttafilter_init(&s->ch_ctx[i].filter, ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]); rice_init(&s->ch_ctx[i].rice, 10, 10); } for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { int32_t *predictor = &s->ch_ctx[cur_chan].predictor; TTAFilter *filter = &s->ch_ctx[cur_chan].filter; TTARice *rice = &s->ch_ctx[cur_chan].rice; uint32_t unary, depth, k; int32_t value; unary = tta_get_unary(&s->gb); if (unary == 0) { depth = 0; k = rice->k0; } else { depth = 1; k = rice->k1; unary--; } if (get_bits_left(&s->gb) < k) return -1; if (k) { if (k > MIN_CACHE_BITS) return -1; value = (unary << k) + get_bits(&s->gb, k); } else value = unary; switch (depth) { case 1: rice->sum1 += value - (rice->sum1 >> 4); if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1]) rice->k1--; else if(rice->sum1 > shift_16[rice->k1 + 1]) rice->k1++; value += shift_1[rice->k0]; default: rice->sum0 += value - (rice->sum0 >> 4); if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0]) rice->k0--; else if(rice->sum0 > shift_16[rice->k0 + 1]) rice->k0++; } #define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1)) *p = UNFOLD(value); ttafilter_process(filter, p, 0); #define PRED(x,k) (int32_t)((((uint64_t)x << k) - x) >> k) switch (s->bps) { case 1: *p += PRED(*predictor, 4); break; case 2: case 3: *p += PRED(*predictor, 5); break; case 4: *p += *predictor; break; } *predictor = *p; if (cur_chan < (s->channels-1)) cur_chan++; else { if (s->channels > 1) { int32_t *r = p - 1; for (*p += *r / 2; r > p - s->channels; r--) *r = *(r + 1) - *r; } cur_chan = 0; } } if (get_bits_left(&s->gb) < 32) return -1; skip_bits(&s->gb, 32); switch(s->bps) { case 2: { uint16_t *samples = data; for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) { *samples++ = *p; } *data_size = (uint8_t *)samples - (uint8_t *)data; break; } default: av_log(s->avctx, AV_LOG_ERROR, ""Error, only 16bit samples supported!\n""); } } return buf_size; }"
150----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_09438a4384996b253379c39982b9fcab650dcf62_1.json----parse_playlist,"static int parse_playlist(HLSContext *c, const char *url, struct variant *var, AVIOContext *in) { int ret = 0, duration = 0, is_segment = 0, is_variant = 0, bandwidth = 0; enum KeyType key_type = KEY_NONE; uint8_t iv[16] = """"; int has_iv = 0; char key[MAX_URL_SIZE] = """"; char line[1024]; const char *ptr; int close_in = 0; if (!in) { close_in = 1; <S2SV_StartVul> if ((ret = avio_open2(&in, url, AVIO_FLAG_READ, <S2SV_EndVul> <S2SV_StartVul> c->interrupt_callback, NULL)) < 0) <S2SV_EndVul> return ret; } read_chomp_line(in, line, sizeof(line)); if (strcmp(line, ""#EXTM3U"")) { ret = AVERROR_INVALIDDATA; goto fail; } if (var) { free_segment_list(var); var->finished = 0; } while (!url_feof(in)) { read_chomp_line(in, line, sizeof(line)); if (av_strstart(line, ""#EXT-X-STREAM-INF:"", &ptr)) { struct variant_info info = {{0}}; is_variant = 1; ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args, &info); bandwidth = atoi(info.bandwidth); } else if (av_strstart(line, ""#EXT-X-KEY:"", &ptr)) { struct key_info info = {{0}}; ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args, &info); key_type = KEY_NONE; has_iv = 0; if (!strcmp(info.method, ""AES-128"")) key_type = KEY_AES_128; if (!strncmp(info.iv, ""0x"", 2) || !strncmp(info.iv, ""0X"", 2)) { ff_hex_to_data(iv, info.iv + 2); has_iv = 1; } av_strlcpy(key, info.uri, sizeof(key)); } else if (av_strstart(line, ""#EXT-X-TARGETDURATION:"", &ptr)) { if (!var) { var = new_variant(c, 0, url, NULL); if (!var) { ret = AVERROR(ENOMEM); goto fail; } } var->target_duration = atoi(ptr); } else if (av_strstart(line, ""#EXT-X-MEDIA-SEQUENCE:"", &ptr)) { if (!var) { var = new_variant(c, 0, url, NULL); if (!var) { ret = AVERROR(ENOMEM); goto fail; } } var->start_seq_no = atoi(ptr); } else if (av_strstart(line, ""#EXT-X-ENDLIST"", &ptr)) { if (var) var->finished = 1; } else if (av_strstart(line, ""#EXTINF:"", &ptr)) { is_segment = 1; duration = atoi(ptr); } else if (av_strstart(line, ""#"", NULL)) { continue; } else if (line[0]) { if (is_variant) { if (!new_variant(c, bandwidth, line, url)) { ret = AVERROR(ENOMEM); goto fail; } is_variant = 0; bandwidth = 0; } if (is_segment) { struct segment *seg; if (!var) { var = new_variant(c, 0, url, NULL); if (!var) { ret = AVERROR(ENOMEM); goto fail; } } seg = av_malloc(sizeof(struct segment)); if (!seg) { ret = AVERROR(ENOMEM); goto fail; } seg->duration = duration; seg->key_type = key_type; if (has_iv) { memcpy(seg->iv, iv, sizeof(iv)); } else { int seq = var->start_seq_no + var->n_segments; memset(seg->iv, 0, sizeof(seg->iv)); AV_WB32(seg->iv + 12, seq); } ff_make_absolute_url(seg->key, sizeof(seg->key), url, key); ff_make_absolute_url(seg->url, sizeof(seg->url), url, line); dynarray_add(&var->segments, &var->n_segments, seg); is_segment = 0; } } } if (var) var->last_load_time = av_gettime(); fail: if (close_in) avio_close(in); return ret; }","- if ((ret = avio_open2(&in, url, AVIO_FLAG_READ,
- c->interrupt_callback, NULL)) < 0)
+ AVDictionary *opts = NULL;
+ av_dict_set(&opts, ""seekable"", ""0"", 0);
+ ret = avio_open2(&in, url, AVIO_FLAG_READ,
+ c->interrupt_callback, &opts);
+ av_dict_free(&opts);
+ if (ret < 0)","static int parse_playlist(HLSContext *c, const char *url, struct variant *var, AVIOContext *in) { int ret = 0, duration = 0, is_segment = 0, is_variant = 0, bandwidth = 0; enum KeyType key_type = KEY_NONE; uint8_t iv[16] = """"; int has_iv = 0; char key[MAX_URL_SIZE] = """"; char line[1024]; const char *ptr; int close_in = 0; if (!in) { AVDictionary *opts = NULL; close_in = 1; av_dict_set(&opts, ""seekable"", ""0"", 0); ret = avio_open2(&in, url, AVIO_FLAG_READ, c->interrupt_callback, &opts); av_dict_free(&opts); if (ret < 0) return ret; } read_chomp_line(in, line, sizeof(line)); if (strcmp(line, ""#EXTM3U"")) { ret = AVERROR_INVALIDDATA; goto fail; } if (var) { free_segment_list(var); var->finished = 0; } while (!url_feof(in)) { read_chomp_line(in, line, sizeof(line)); if (av_strstart(line, ""#EXT-X-STREAM-INF:"", &ptr)) { struct variant_info info = {{0}}; is_variant = 1; ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args, &info); bandwidth = atoi(info.bandwidth); } else if (av_strstart(line, ""#EXT-X-KEY:"", &ptr)) { struct key_info info = {{0}}; ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args, &info); key_type = KEY_NONE; has_iv = 0; if (!strcmp(info.method, ""AES-128"")) key_type = KEY_AES_128; if (!strncmp(info.iv, ""0x"", 2) || !strncmp(info.iv, ""0X"", 2)) { ff_hex_to_data(iv, info.iv + 2); has_iv = 1; } av_strlcpy(key, info.uri, sizeof(key)); } else if (av_strstart(line, ""#EXT-X-TARGETDURATION:"", &ptr)) { if (!var) { var = new_variant(c, 0, url, NULL); if (!var) { ret = AVERROR(ENOMEM); goto fail; } } var->target_duration = atoi(ptr); } else if (av_strstart(line, ""#EXT-X-MEDIA-SEQUENCE:"", &ptr)) { if (!var) { var = new_variant(c, 0, url, NULL); if (!var) { ret = AVERROR(ENOMEM); goto fail; } } var->start_seq_no = atoi(ptr); } else if (av_strstart(line, ""#EXT-X-ENDLIST"", &ptr)) { if (var) var->finished = 1; } else if (av_strstart(line, ""#EXTINF:"", &ptr)) { is_segment = 1; duration = atoi(ptr); } else if (av_strstart(line, ""#"", NULL)) { continue; } else if (line[0]) { if (is_variant) { if (!new_variant(c, bandwidth, line, url)) { ret = AVERROR(ENOMEM); goto fail; } is_variant = 0; bandwidth = 0; } if (is_segment) { struct segment *seg; if (!var) { var = new_variant(c, 0, url, NULL); if (!var) { ret = AVERROR(ENOMEM); goto fail; } } seg = av_malloc(sizeof(struct segment)); if (!seg) { ret = AVERROR(ENOMEM); goto fail; } seg->duration = duration; seg->key_type = key_type; if (has_iv) { memcpy(seg->iv, iv, sizeof(iv)); } else { int seq = var->start_seq_no + var->n_segments; memset(seg->iv, 0, sizeof(seg->iv)); AV_WB32(seg->iv + 12, seq); } ff_make_absolute_url(seg->key, sizeof(seg->key), url, key); ff_make_absolute_url(seg->url, sizeof(seg->url), url, line); dynarray_add(&var->segments, &var->n_segments, seg); is_segment = 0; } } } if (var) var->last_load_time = av_gettime(); fail: if (close_in) avio_close(in); return ret; }"
5426----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1c0af0eb99b9faf4841d053603f5057e57329942_1.json----ff_h264_decode_extradata,"int ff_h264_decode_extradata(H264Context *h) { <S2SV_StartVul> AVCodecContext *avctx = h->s.avctx; <S2SV_EndVul> if (avctx->extradata[0] == 1) { int i, cnt, nalsize; unsigned char *p = avctx->extradata; h->is_avc = 1; if (avctx->extradata_size < 7) { av_log(avctx, AV_LOG_ERROR, ""avcC too short\n""); return -1; } h->nal_length_size = 2; cnt = *(p + 5) & 0x1f; p += 6; for (i = 0; i < cnt; i++) { nalsize = AV_RB16(p) + 2; if (p - avctx->extradata + nalsize > avctx->extradata_size) return -1; if (decode_nal_units(h, p, nalsize, 1) < 0) { av_log(avctx, AV_LOG_ERROR, ""Decoding sps %d from avcC failed\n"", i); return -1; } p += nalsize; } cnt = *(p++); for (i = 0; i < cnt; i++) { nalsize = AV_RB16(p) + 2; if (p - avctx->extradata + nalsize > avctx->extradata_size) return -1; if (decode_nal_units(h, p, nalsize, 1) < 0) { av_log(avctx, AV_LOG_ERROR, ""Decoding pps %d from avcC failed\n"", i); return -1; } p += nalsize; } h->nal_length_size = (avctx->extradata[4] & 0x03) + 1; } else { h->is_avc = 0; if (decode_nal_units(h, avctx->extradata, avctx->extradata_size, 1) < 0) return -1; } return 0; }","- AVCodecContext *avctx = h->s.avctx;
+ AVCodecContext *avctx = h->avctx;","int ff_h264_decode_extradata(H264Context *h) { AVCodecContext *avctx = h->avctx; if (avctx->extradata[0] == 1) { int i, cnt, nalsize; unsigned char *p = avctx->extradata; h->is_avc = 1; if (avctx->extradata_size < 7) { av_log(avctx, AV_LOG_ERROR, ""avcC too short\n""); return -1; } h->nal_length_size = 2; cnt = *(p + 5) & 0x1f; p += 6; for (i = 0; i < cnt; i++) { nalsize = AV_RB16(p) + 2; if (p - avctx->extradata + nalsize > avctx->extradata_size) return -1; if (decode_nal_units(h, p, nalsize, 1) < 0) { av_log(avctx, AV_LOG_ERROR, ""Decoding sps %d from avcC failed\n"", i); return -1; } p += nalsize; } cnt = *(p++); for (i = 0; i < cnt; i++) { nalsize = AV_RB16(p) + 2; if (p - avctx->extradata + nalsize > avctx->extradata_size) return -1; if (decode_nal_units(h, p, nalsize, 1) < 0) { av_log(avctx, AV_LOG_ERROR, ""Decoding pps %d from avcC failed\n"", i); return -1; } p += nalsize; } h->nal_length_size = (avctx->extradata[4] & 0x03) + 1; } else { h->is_avc = 0; if (decode_nal_units(h, avctx->extradata, avctx->extradata_size, 1) < 0) return -1; } return 0; }"
10729----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_11189973bf616f00ae75b2bd6407fc6e6bb54cc3_1.json----CONF_get1_default_config_file,"char *CONF_get1_default_config_file(void) { char *file; int len; file = getenv(""OPENSSL_CONF""); if (file) return OPENSSL_strdup(file); len = strlen(X509_get_default_cert_area()); #ifndef OPENSSL_SYS_VMS len++; #endif len += strlen(OPENSSL_CONF); file = OPENSSL_malloc(len + 1); if (file == NULL) return NULL; <S2SV_StartVul> OPENSSL_strlcpy(file, X509_get_default_cert_area(), len + 1); <S2SV_EndVul> #ifndef OPENSSL_SYS_VMS <S2SV_StartVul> OPENSSL_strlcat(file, ""/"", len + 1); <S2SV_EndVul> #endif <S2SV_StartVul> OPENSSL_strlcat(file, OPENSSL_CONF, len + 1); <S2SV_EndVul> return file; }","- OPENSSL_strlcpy(file, X509_get_default_cert_area(), len + 1);
- OPENSSL_strlcat(file, ""/"", len + 1);
- OPENSSL_strlcat(file, OPENSSL_CONF, len + 1);
+ strcpy(file, X509_get_default_cert_area());
+ strcat(file, ""/"");
+ strcat(file, OPENSSL_CONF);","char *CONF_get1_default_config_file(void) { char *file; int len; file = getenv(""OPENSSL_CONF""); if (file) return OPENSSL_strdup(file); len = strlen(X509_get_default_cert_area()); #ifndef OPENSSL_SYS_VMS len++; #endif len += strlen(OPENSSL_CONF); file = OPENSSL_malloc(len + 1); if (file == NULL) return NULL; strcpy(file, X509_get_default_cert_area()); #ifndef OPENSSL_SYS_VMS strcat(file, ""/""); #endif strcat(file, OPENSSL_CONF); return file; }"
12281----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_475b00f398f353399595baa040397e030a5f66f6_1.json----sm2_encrypt,"int sm2_encrypt(const EC_KEY *key, const EVP_MD *digest, const uint8_t *msg, size_t msg_len, uint8_t *ciphertext_buf, size_t *ciphertext_len) { int rc = 0, ciphertext_leni; size_t i; BN_CTX *ctx = NULL; BIGNUM *k = NULL; BIGNUM *x1 = NULL; BIGNUM *y1 = NULL; BIGNUM *x2 = NULL; BIGNUM *y2 = NULL; EVP_MD_CTX *hash = EVP_MD_CTX_new(); struct SM2_Ciphertext_st ctext_struct; const EC_GROUP *group = EC_KEY_get0_group(key); const BIGNUM *order = EC_GROUP_get0_order(group); const EC_POINT *P = EC_KEY_get0_public_key(key); EC_POINT *kG = NULL; EC_POINT *kP = NULL; uint8_t *msg_mask = NULL; uint8_t *x2y2 = NULL; uint8_t *C3 = NULL; <S2SV_StartVul> const size_t field_size = ec_field_size(group); <S2SV_EndVul> <S2SV_StartVul> const size_t C3_size = EVP_MD_size(digest); <S2SV_EndVul> ctext_struct.C2 = NULL; ctext_struct.C3 = NULL; <S2SV_StartVul> if (hash == NULL <S2SV_EndVul> <S2SV_StartVul> || group == NULL <S2SV_EndVul> <S2SV_StartVul> || order == NULL <S2SV_EndVul> <S2SV_StartVul> || P == NULL <S2SV_EndVul> <S2SV_StartVul> || field_size == 0 <S2SV_EndVul> <S2SV_StartVul> || C3_size == 0) { <S2SV_EndVul> SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } kG = EC_POINT_new(group); kP = EC_POINT_new(group); ctx = BN_CTX_new(); if (kG == NULL || kP == NULL || ctx == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } BN_CTX_start(ctx); k = BN_CTX_get(ctx); x1 = BN_CTX_get(ctx); x2 = BN_CTX_get(ctx); y1 = BN_CTX_get(ctx); y2 = BN_CTX_get(ctx); if (y2 == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_BN_LIB); goto done; } x2y2 = OPENSSL_zalloc(2 * field_size); C3 = OPENSSL_zalloc(C3_size); if (x2y2 == NULL || C3 == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } memset(ciphertext_buf, 0, *ciphertext_len); if (!BN_priv_rand_range(k, order)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx) || !EC_POINT_get_affine_coordinates_GFp(group, kG, x1, y1, ctx) || !EC_POINT_mul(group, kP, NULL, P, k, ctx) || !EC_POINT_get_affine_coordinates_GFp(group, kP, x2, y2, ctx)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EC_LIB); goto done; } if (BN_bn2binpad(x2, x2y2, field_size) < 0 || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } msg_mask = OPENSSL_zalloc(msg_len); if (msg_mask == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } if (!ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0, digest)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB); goto done; } for (i = 0; i != msg_len; ++i) msg_mask[i] ^= msg[i]; if (EVP_DigestInit(hash, digest) == 0 || EVP_DigestUpdate(hash, x2y2, field_size) == 0 || EVP_DigestUpdate(hash, msg, msg_len) == 0 || EVP_DigestUpdate(hash, x2y2 + field_size, field_size) == 0 || EVP_DigestFinal(hash, C3, NULL) == 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB); goto done; } ctext_struct.C1x = x1; ctext_struct.C1y = y1; ctext_struct.C3 = ASN1_OCTET_STRING_new(); ctext_struct.C2 = ASN1_OCTET_STRING_new(); if (ctext_struct.C3 == NULL || ctext_struct.C2 == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } if (!ASN1_OCTET_STRING_set(ctext_struct.C3, C3, C3_size) || !ASN1_OCTET_STRING_set(ctext_struct.C2, msg_mask, msg_len)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } ciphertext_leni = i2d_SM2_Ciphertext(&ctext_struct, &ciphertext_buf); if (ciphertext_leni < 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } *ciphertext_len = (size_t)ciphertext_leni; rc = 1; done: ASN1_OCTET_STRING_free(ctext_struct.C2); ASN1_OCTET_STRING_free(ctext_struct.C3); OPENSSL_free(msg_mask); OPENSSL_free(x2y2); OPENSSL_free(C3); EVP_MD_CTX_free(hash); BN_CTX_free(ctx); EC_POINT_free(kG); EC_POINT_free(kP); return rc; }","- const size_t field_size = ec_field_size(group);
- const size_t C3_size = EVP_MD_size(digest);
- if (hash == NULL
- || group == NULL
- || order == NULL
- || P == NULL
- || field_size == 0
- || C3_size == 0) {
+ size_t field_size;
+ const int C3_size = EVP_MD_size(digest);
+ if (hash == NULL || C3_size <= 0) {
+ SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);
+ goto done;
+ }
+ field_size = ec_field_size(group);
+ if (field_size == 0) {","int sm2_encrypt(const EC_KEY *key, const EVP_MD *digest, const uint8_t *msg, size_t msg_len, uint8_t *ciphertext_buf, size_t *ciphertext_len) { int rc = 0, ciphertext_leni; size_t i; BN_CTX *ctx = NULL; BIGNUM *k = NULL; BIGNUM *x1 = NULL; BIGNUM *y1 = NULL; BIGNUM *x2 = NULL; BIGNUM *y2 = NULL; EVP_MD_CTX *hash = EVP_MD_CTX_new(); struct SM2_Ciphertext_st ctext_struct; const EC_GROUP *group = EC_KEY_get0_group(key); const BIGNUM *order = EC_GROUP_get0_order(group); const EC_POINT *P = EC_KEY_get0_public_key(key); EC_POINT *kG = NULL; EC_POINT *kP = NULL; uint8_t *msg_mask = NULL; uint8_t *x2y2 = NULL; uint8_t *C3 = NULL; size_t field_size; const int C3_size = EVP_MD_size(digest); ctext_struct.C2 = NULL; ctext_struct.C3 = NULL; if (hash == NULL || C3_size <= 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } field_size = ec_field_size(group); if (field_size == 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } kG = EC_POINT_new(group); kP = EC_POINT_new(group); ctx = BN_CTX_new(); if (kG == NULL || kP == NULL || ctx == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } BN_CTX_start(ctx); k = BN_CTX_get(ctx); x1 = BN_CTX_get(ctx); x2 = BN_CTX_get(ctx); y1 = BN_CTX_get(ctx); y2 = BN_CTX_get(ctx); if (y2 == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_BN_LIB); goto done; } x2y2 = OPENSSL_zalloc(2 * field_size); C3 = OPENSSL_zalloc(C3_size); if (x2y2 == NULL || C3 == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } memset(ciphertext_buf, 0, *ciphertext_len); if (!BN_priv_rand_range(k, order)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx) || !EC_POINT_get_affine_coordinates_GFp(group, kG, x1, y1, ctx) || !EC_POINT_mul(group, kP, NULL, P, k, ctx) || !EC_POINT_get_affine_coordinates_GFp(group, kP, x2, y2, ctx)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EC_LIB); goto done; } if (BN_bn2binpad(x2, x2y2, field_size) < 0 || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } msg_mask = OPENSSL_zalloc(msg_len); if (msg_mask == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } if (!ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0, digest)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB); goto done; } for (i = 0; i != msg_len; ++i) msg_mask[i] ^= msg[i]; if (EVP_DigestInit(hash, digest) == 0 || EVP_DigestUpdate(hash, x2y2, field_size) == 0 || EVP_DigestUpdate(hash, msg, msg_len) == 0 || EVP_DigestUpdate(hash, x2y2 + field_size, field_size) == 0 || EVP_DigestFinal(hash, C3, NULL) == 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB); goto done; } ctext_struct.C1x = x1; ctext_struct.C1y = y1; ctext_struct.C3 = ASN1_OCTET_STRING_new(); ctext_struct.C2 = ASN1_OCTET_STRING_new(); if (ctext_struct.C3 == NULL || ctext_struct.C2 == NULL) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE); goto done; } if (!ASN1_OCTET_STRING_set(ctext_struct.C3, C3, C3_size) || !ASN1_OCTET_STRING_set(ctext_struct.C2, msg_mask, msg_len)) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } ciphertext_leni = i2d_SM2_Ciphertext(&ctext_struct, &ciphertext_buf); if (ciphertext_leni < 0) { SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR); goto done; } *ciphertext_len = (size_t)ciphertext_leni; rc = 1; done: ASN1_OCTET_STRING_free(ctext_struct.C2); ASN1_OCTET_STRING_free(ctext_struct.C3); OPENSSL_free(msg_mask); OPENSSL_free(x2y2); OPENSSL_free(C3); EVP_MD_CTX_free(hash); BN_CTX_free(ctx); EC_POINT_free(kG); EC_POINT_free(kP); return rc; }"
117----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_06ff29e9bc5c67316880f0c68f7c5bbacfc3e348_1.json----cinepak_decode_vectors,"static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip, int chunk_id, int size, const uint8_t *data) { const uint8_t *eod = (data + size); uint32_t flag, mask; uint8_t *cb0, *cb1, *cb2, *cb3; <S2SV_StartVul> unsigned int x, y; <S2SV_EndVul> char *ip0, *ip1, *ip2, *ip3; flag = 0; mask = 0; for (y=strip->y1; y < strip->y2; y+=4) { ip0 = ip1 = ip2 = ip3 = s->frame->data[0] + (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]); if(s->avctx->height - y > 1) { ip1 = ip0 + s->frame->linesize[0]; if(s->avctx->height - y > 2) { ip2 = ip1 + s->frame->linesize[0]; if(s->avctx->height - y > 3) { ip3 = ip2 + s->frame->linesize[0]; } } } for (x=strip->x1; x < strip->x2; x+=4) { if ((chunk_id & 0x01) && !(mask >>= 1)) { if ((data + 4) > eod) return AVERROR_INVALIDDATA; flag = AV_RB32 (data); data += 4; mask = 0x80000000; } if (!(chunk_id & 0x01) || (flag & mask)) { if (!(chunk_id & 0x02) && !(mask >>= 1)) { if ((data + 4) > eod) return AVERROR_INVALIDDATA; flag = AV_RB32 (data); data += 4; mask = 0x80000000; } if ((chunk_id & 0x02) || (~flag & mask)) { uint8_t *p; if (data >= eod) return AVERROR_INVALIDDATA; p = strip->v1_codebook[*data++]; if (s->palette_video) { ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6]; ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9]; ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0]; ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3]; } else { p += 6; memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3); memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3); p += 3; memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3); memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3); p -= 9; memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3); memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3); p += 3; memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3); memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3); } } else if (flag & mask) { if ((data + 4) > eod) return AVERROR_INVALIDDATA; cb0 = strip->v4_codebook[*data++]; cb1 = strip->v4_codebook[*data++]; cb2 = strip->v4_codebook[*data++]; cb3 = strip->v4_codebook[*data++]; if (s->palette_video) { uint8_t *p; p = ip3; *p++ = cb2[6]; *p++ = cb2[9]; *p++ = cb3[6]; *p = cb3[9]; p = ip2; *p++ = cb2[0]; *p++ = cb2[3]; *p++ = cb3[0]; *p = cb3[3]; p = ip1; *p++ = cb0[6]; *p++ = cb0[9]; *p++ = cb1[6]; *p = cb1[9]; p = ip0; *p++ = cb0[0]; *p++ = cb0[3]; *p++ = cb1[0]; *p = cb1[3]; } else { memcpy(ip3 + 0, cb2 + 6, 6); memcpy(ip3 + 6, cb3 + 6, 6); memcpy(ip2 + 0, cb2 + 0, 6); memcpy(ip2 + 6, cb3 + 0, 6); memcpy(ip1 + 0, cb0 + 6, 6); memcpy(ip1 + 6, cb1 + 6, 6); memcpy(ip0 + 0, cb0 + 0, 6); memcpy(ip0 + 6, cb1 + 0, 6); } } } if (s->palette_video) { ip0 += 4; ip1 += 4; ip2 += 4; ip3 += 4; } else { ip0 += 12; ip1 += 12; ip2 += 12; ip3 += 12; } } } return 0; }","- unsigned int x, y;
+ int x, y;","static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip, int chunk_id, int size, const uint8_t *data) { const uint8_t *eod = (data + size); uint32_t flag, mask; uint8_t *cb0, *cb1, *cb2, *cb3; int x, y; char *ip0, *ip1, *ip2, *ip3; flag = 0; mask = 0; for (y=strip->y1; y < strip->y2; y+=4) { ip0 = ip1 = ip2 = ip3 = s->frame->data[0] + (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]); if(s->avctx->height - y > 1) { ip1 = ip0 + s->frame->linesize[0]; if(s->avctx->height - y > 2) { ip2 = ip1 + s->frame->linesize[0]; if(s->avctx->height - y > 3) { ip3 = ip2 + s->frame->linesize[0]; } } } for (x=strip->x1; x < strip->x2; x+=4) { if ((chunk_id & 0x01) && !(mask >>= 1)) { if ((data + 4) > eod) return AVERROR_INVALIDDATA; flag = AV_RB32 (data); data += 4; mask = 0x80000000; } if (!(chunk_id & 0x01) || (flag & mask)) { if (!(chunk_id & 0x02) && !(mask >>= 1)) { if ((data + 4) > eod) return AVERROR_INVALIDDATA; flag = AV_RB32 (data); data += 4; mask = 0x80000000; } if ((chunk_id & 0x02) || (~flag & mask)) { uint8_t *p; if (data >= eod) return AVERROR_INVALIDDATA; p = strip->v1_codebook[*data++]; if (s->palette_video) { ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6]; ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9]; ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0]; ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3]; } else { p += 6; memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3); memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3); p += 3; memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3); memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3); p -= 9; memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3); memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3); p += 3; memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3); memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3); } } else if (flag & mask) { if ((data + 4) > eod) return AVERROR_INVALIDDATA; cb0 = strip->v4_codebook[*data++]; cb1 = strip->v4_codebook[*data++]; cb2 = strip->v4_codebook[*data++]; cb3 = strip->v4_codebook[*data++]; if (s->palette_video) { uint8_t *p; p = ip3; *p++ = cb2[6]; *p++ = cb2[9]; *p++ = cb3[6]; *p = cb3[9]; p = ip2; *p++ = cb2[0]; *p++ = cb2[3]; *p++ = cb3[0]; *p = cb3[3]; p = ip1; *p++ = cb0[6]; *p++ = cb0[9]; *p++ = cb1[6]; *p = cb1[9]; p = ip0; *p++ = cb0[0]; *p++ = cb0[3]; *p++ = cb1[0]; *p = cb1[3]; } else { memcpy(ip3 + 0, cb2 + 6, 6); memcpy(ip3 + 6, cb3 + 6, 6); memcpy(ip2 + 0, cb2 + 0, 6); memcpy(ip2 + 6, cb3 + 0, 6); memcpy(ip1 + 0, cb0 + 6, 6); memcpy(ip1 + 6, cb1 + 6, 6); memcpy(ip0 + 0, cb0 + 0, 6); memcpy(ip0 + 6, cb1 + 0, 6); } } } if (s->palette_video) { ip0 += 4; ip1 += 4; ip2 += 4; ip3 += 4; } else { ip0 += 12; ip1 += 12; ip2 += 12; ip3 += 12; } } } return 0; }"
7597----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_9cb9bb024de5b837fd19b6633ed1fa3b57375c99_1.json----svq1_motion_inter_block,"static int svq1_motion_inter_block(DSPContext *dsp, GetBitContext *bitbuf, uint8_t *current, uint8_t *previous, <S2SV_StartVul> int pitch, svq1_pmv *motion, int x, int y) <S2SV_EndVul> { uint8_t *src; uint8_t *dst; svq1_pmv mv; svq1_pmv *pmv[3]; int result; pmv[0] = &motion[0]; if (y == 0) { pmv[1] = pmv[2] = pmv[0]; } else { pmv[1] = &motion[x / 8 + 2]; pmv[2] = &motion[x / 8 + 4]; } result = svq1_decode_motion_vector(bitbuf, &mv, pmv); if (result != 0) return result; motion[0].x = motion[x / 8 + 2].x = motion[x / 8 + 3].x = mv.x; motion[0].y = motion[x / 8 + 2].y = motion[x / 8 + 3].y = mv.y; <S2SV_StartVul> if (y + (mv.y >> 1) < 0) <S2SV_EndVul> <S2SV_StartVul> mv.y = 0; <S2SV_EndVul> <S2SV_StartVul> if (x + (mv.x >> 1) < 0) <S2SV_EndVul> <S2SV_StartVul> mv.x = 0; <S2SV_EndVul> src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1)) * pitch]; dst = current; dsp->put_pixels_tab[0][(mv.y & 1) << 1 | (mv.x & 1)](dst, src, pitch, 16); return 0; }","- int pitch, svq1_pmv *motion, int x, int y)
- if (y + (mv.y >> 1) < 0)
- mv.y = 0;
- if (x + (mv.x >> 1) < 0)
- mv.x = 0;
+ int pitch, svq1_pmv *motion, int x, int y,
+ int width, int height)
+ mv.x = av_clip(mv.x, -2 * x, 2 * (width - x - 16));
+ mv.y = av_clip(mv.y, -2 * y, 2 * (height - y - 16));","static int svq1_motion_inter_block(DSPContext *dsp, GetBitContext *bitbuf, uint8_t *current, uint8_t *previous, int pitch, svq1_pmv *motion, int x, int y, int width, int height) { uint8_t *src; uint8_t *dst; svq1_pmv mv; svq1_pmv *pmv[3]; int result; pmv[0] = &motion[0]; if (y == 0) { pmv[1] = pmv[2] = pmv[0]; } else { pmv[1] = &motion[x / 8 + 2]; pmv[2] = &motion[x / 8 + 4]; } result = svq1_decode_motion_vector(bitbuf, &mv, pmv); if (result != 0) return result; motion[0].x = motion[x / 8 + 2].x = motion[x / 8 + 3].x = mv.x; motion[0].y = motion[x / 8 + 2].y = motion[x / 8 + 3].y = mv.y; mv.x = av_clip(mv.x, -2 * x, 2 * (width - x - 16)); mv.y = av_clip(mv.y, -2 * y, 2 * (height - y - 16)); src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1)) * pitch]; dst = current; dsp->put_pixels_tab[0][(mv.y & 1) << 1 | (mv.x & 1)](dst, src, pitch, 16); return 0; }"
6226----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c9aaafc67ab78d51bc442576f908e297cb70ca8_1.json----vc1_decode_frame,"static int vc1_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size, n_slices = 0, i; VC1Context *v = avctx->priv_data; MpegEncContext *s = &v->s; AVFrame *pict = data; uint8_t *buf2 = NULL; const uint8_t *buf_start = buf; struct { uint8_t *buf; GetBitContext gb; int mby_start; } *slices = NULL; if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) { if (s->low_delay==0 && s->next_picture_ptr) { *pict= *(AVFrame*)s->next_picture_ptr; s->next_picture_ptr= NULL; *data_size = sizeof(AVFrame); } return 0; } <S2SV_EndVul> <S2SV_StartVul> if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) { <S2SV_EndVul> <S2SV_StartVul> int i= ff_find_unused_picture(s, 0); <S2SV_EndVul> <S2SV_StartVul> s->current_picture_ptr= &s->picture[i]; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){ if (v->profile < PROFILE_ADVANCED) avctx->pix_fmt = PIX_FMT_VDPAU_WMV3; else avctx->pix_fmt = PIX_FMT_VDPAU_VC1; } if (avctx->codec_id == CODEC_ID_VC1 || avctx->codec_id == CODEC_ID_VC1IMAGE) { int buf_size2 = 0; buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if(IS_MARKER(AV_RB32(buf))){ const uint8_t *start, *end, *next; int size; next = buf; for(start = buf, end = buf + buf_size; next < end; start = next){ next = find_next_marker(start + 4, end); size = next - start - 4; if(size <= 0) continue; switch(AV_RB32(start)){ case VC1_CODE_FRAME: if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start = start; buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); break; case VC1_CODE_ENTRYPOINT: buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); init_get_bits(&s->gb, buf2, buf_size2*8); vc1_decode_entry_point(avctx, v, &s->gb); break; case VC1_CODE_SLICE: { int buf_size3; slices = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!slices) goto err; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(start + 4, size, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9); n_slices++; break; } } } }else if(v->interlace && ((buf[0] & 0xC0) == 0xC0)){ const uint8_t *divider; divider = find_next_marker(buf, buf + buf_size); if((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD){ av_log(avctx, AV_LOG_ERROR, ""Error in WVC1 interlaced frame\n""); goto err; } buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2); if(!v->warn_interlaced++) av_log(v->s.avctx, AV_LOG_ERROR, ""Interlaced WVC1 support is not implemented\n""); goto err; }else{ buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2); } init_get_bits(&s->gb, buf2, buf_size2*8); } else init_get_bits(&s->gb, buf, buf_size*8); if (v->res_sprite) { v->new_sprite = !get_bits1(&s->gb); v->two_sprites = get_bits1(&s->gb); if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) { if (v->new_sprite) { avctx->width = avctx->coded_width = v->sprite_width; avctx->height = avctx->coded_height = v->sprite_height; } else { goto image; } } } if(v->profile < PROFILE_ADVANCED) { if(vc1_parse_frame_header(v, &s->gb) == -1) { goto err; } } else { if(vc1_parse_frame_header_adv(v, &s->gb) == -1) { goto err; } } if ((avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) && s->pict_type!=AV_PICTURE_TYPE_I) { av_log(v->s.avctx, AV_LOG_ERROR, ""Sprite decoder: expected I-frame\n""); goto err; } s->current_picture_ptr->f.repeat_pict = 0; if (v->rff){ s->current_picture_ptr->f.repeat_pict = 1; }else if (v->rptfrm){ s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2; } s->current_picture.f.pict_type = s->pict_type; s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; if(s->last_picture_ptr==NULL && (s->pict_type==AV_PICTURE_TYPE_B || s->dropable)){ goto err; } if( (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==AV_PICTURE_TYPE_B) || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) { goto end; } if(s->next_p_frame_damaged){ if(s->pict_type==AV_PICTURE_TYPE_B) goto end; else s->next_p_frame_damaged=0; } if(MPV_frame_start(s, avctx) < 0) { goto err; } s->me.qpel_put= s->dsp.put_qpel_pixels_tab; s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab; if ((CONFIG_VC1_VDPAU_DECODER) &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start); else if (avctx->hwaccel) { if (avctx->hwaccel->start_frame(avctx, buf, buf_size) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; } else { ff_er_frame_start(s); v->bits = buf_size * 8; for (i = 0; i <= n_slices; i++) { if (i && get_bits1(&s->gb)) vc1_parse_frame_header_adv(v, &s->gb); s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start); s->end_mb_y = (i == n_slices) ? s->mb_height : FFMIN(s->mb_height, slices[i].mby_start); vc1_decode_blocks(v); if (i != n_slices) s->gb = slices[i].gb; } ff_er_frame_end(s); } MPV_frame_end(s); assert(s->current_picture.f.pict_type == s->current_picture_ptr->f.pict_type); assert(s->current_picture.f.pict_type == s->pict_type); if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) { image: avctx->width = avctx->coded_width = v->output_width; avctx->height = avctx->coded_height = v->output_height; if (avctx->skip_frame >= AVDISCARD_NONREF) goto end; #if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER if (vc1_decode_sprites(v, &s->gb)) goto err; #endif *pict = v->sprite_output_frame; *data_size = sizeof(AVFrame); } else { if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) { *pict= *(AVFrame*)s->current_picture_ptr; } else if (s->last_picture_ptr != NULL) { *pict= *(AVFrame*)s->last_picture_ptr; } if(s->last_picture_ptr || s->low_delay){ *data_size = sizeof(AVFrame); ff_print_debug_info(s, pict); } } end: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return buf_size; err: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return -1; }","- if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {
- int i= ff_find_unused_picture(s, 0);
- s->current_picture_ptr= &s->picture[i];
- }
+ if (s->context_initialized &&
+ (s->width != avctx->coded_width ||
+ s->height != avctx->coded_height)) {
+ vc1_decode_end(avctx);
+ }
+ if (!s->context_initialized) {
+ if (ff_msmpeg4_decode_init(avctx) < 0 || vc1_decode_init_alloc_tables(v) < 0)
+ return -1;
+ s->low_delay = !avctx->has_b_frames || v->res_sprite;
+ if (v->profile == PROFILE_ADVANCED) {
+ s->h_edge_pos = avctx->coded_width;
+ s->v_edge_pos = avctx->coded_height;
+ }
+ }
+ if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {
+ int i= ff_find_unused_picture(s, 0);
+ s->current_picture_ptr= &s->picture[i];
+ }","static int vc1_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size, n_slices = 0, i; VC1Context *v = avctx->priv_data; MpegEncContext *s = &v->s; AVFrame *pict = data; uint8_t *buf2 = NULL; const uint8_t *buf_start = buf; struct { uint8_t *buf; GetBitContext gb; int mby_start; } *slices = NULL; if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) { if (s->low_delay==0 && s->next_picture_ptr) { *pict= *(AVFrame*)s->next_picture_ptr; s->next_picture_ptr= NULL; *data_size = sizeof(AVFrame); } return 0; } if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){ if (v->profile < PROFILE_ADVANCED) avctx->pix_fmt = PIX_FMT_VDPAU_WMV3; else avctx->pix_fmt = PIX_FMT_VDPAU_VC1; } if (avctx->codec_id == CODEC_ID_VC1 || avctx->codec_id == CODEC_ID_VC1IMAGE) { int buf_size2 = 0; buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if(IS_MARKER(AV_RB32(buf))){ const uint8_t *start, *end, *next; int size; next = buf; for(start = buf, end = buf + buf_size; next < end; start = next){ next = find_next_marker(start + 4, end); size = next - start - 4; if(size <= 0) continue; switch(AV_RB32(start)){ case VC1_CODE_FRAME: if (avctx->hwaccel || s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) buf_start = start; buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); break; case VC1_CODE_ENTRYPOINT: buf_size2 = vc1_unescape_buffer(start + 4, size, buf2); init_get_bits(&s->gb, buf2, buf_size2*8); vc1_decode_entry_point(avctx, v, &s->gb); break; case VC1_CODE_SLICE: { int buf_size3; slices = av_realloc(slices, sizeof(*slices) * (n_slices+1)); if (!slices) goto err; slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE); if (!slices[n_slices].buf) goto err; buf_size3 = vc1_unescape_buffer(start + 4, size, slices[n_slices].buf); init_get_bits(&slices[n_slices].gb, slices[n_slices].buf, buf_size3 << 3); slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9); n_slices++; break; } } } }else if(v->interlace && ((buf[0] & 0xC0) == 0xC0)){ const uint8_t *divider; divider = find_next_marker(buf, buf + buf_size); if((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD){ av_log(avctx, AV_LOG_ERROR, ""Error in WVC1 interlaced frame\n""); goto err; } buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2); if(!v->warn_interlaced++) av_log(v->s.avctx, AV_LOG_ERROR, ""Interlaced WVC1 support is not implemented\n""); goto err; }else{ buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2); } init_get_bits(&s->gb, buf2, buf_size2*8); } else init_get_bits(&s->gb, buf, buf_size*8); if (v->res_sprite) { v->new_sprite = !get_bits1(&s->gb); v->two_sprites = get_bits1(&s->gb); if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) { if (v->new_sprite) { avctx->width = avctx->coded_width = v->sprite_width; avctx->height = avctx->coded_height = v->sprite_height; } else { goto image; } } } if (s->context_initialized && (s->width != avctx->coded_width || s->height != avctx->coded_height)) { vc1_decode_end(avctx); } if (!s->context_initialized) { if (ff_msmpeg4_decode_init(avctx) < 0 || vc1_decode_init_alloc_tables(v) < 0) return -1; s->low_delay = !avctx->has_b_frames || v->res_sprite; if (v->profile == PROFILE_ADVANCED) { s->h_edge_pos = avctx->coded_width; s->v_edge_pos = avctx->coded_height; } } if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) { int i= ff_find_unused_picture(s, 0); s->current_picture_ptr= &s->picture[i]; } if(v->profile < PROFILE_ADVANCED) { if(vc1_parse_frame_header(v, &s->gb) == -1) { goto err; } } else { if(vc1_parse_frame_header_adv(v, &s->gb) == -1) { goto err; } } if ((avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) && s->pict_type!=AV_PICTURE_TYPE_I) { av_log(v->s.avctx, AV_LOG_ERROR, ""Sprite decoder: expected I-frame\n""); goto err; } s->current_picture_ptr->f.repeat_pict = 0; if (v->rff){ s->current_picture_ptr->f.repeat_pict = 1; }else if (v->rptfrm){ s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2; } s->current_picture.f.pict_type = s->pict_type; s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; if(s->last_picture_ptr==NULL && (s->pict_type==AV_PICTURE_TYPE_B || s->dropable)){ goto err; } if( (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==AV_PICTURE_TYPE_B) || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=AV_PICTURE_TYPE_I) || avctx->skip_frame >= AVDISCARD_ALL) { goto end; } if(s->next_p_frame_damaged){ if(s->pict_type==AV_PICTURE_TYPE_B) goto end; else s->next_p_frame_damaged=0; } if(MPV_frame_start(s, avctx) < 0) { goto err; } s->me.qpel_put= s->dsp.put_qpel_pixels_tab; s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab; if ((CONFIG_VC1_VDPAU_DECODER) &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start); else if (avctx->hwaccel) { if (avctx->hwaccel->start_frame(avctx, buf, buf_size) < 0) goto err; if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0) goto err; if (avctx->hwaccel->end_frame(avctx) < 0) goto err; } else { ff_er_frame_start(s); v->bits = buf_size * 8; for (i = 0; i <= n_slices; i++) { if (i && get_bits1(&s->gb)) vc1_parse_frame_header_adv(v, &s->gb); s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start); s->end_mb_y = (i == n_slices) ? s->mb_height : FFMIN(s->mb_height, slices[i].mby_start); vc1_decode_blocks(v); if (i != n_slices) s->gb = slices[i].gb; } ff_er_frame_end(s); } MPV_frame_end(s); assert(s->current_picture.f.pict_type == s->current_picture_ptr->f.pict_type); assert(s->current_picture.f.pict_type == s->pict_type); if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) { image: avctx->width = avctx->coded_width = v->output_width; avctx->height = avctx->coded_height = v->output_height; if (avctx->skip_frame >= AVDISCARD_NONREF) goto end; #if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER if (vc1_decode_sprites(v, &s->gb)) goto err; #endif *pict = v->sprite_output_frame; *data_size = sizeof(AVFrame); } else { if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) { *pict= *(AVFrame*)s->current_picture_ptr; } else if (s->last_picture_ptr != NULL) { *pict= *(AVFrame*)s->last_picture_ptr; } if(s->last_picture_ptr || s->low_delay){ *data_size = sizeof(AVFrame); ff_print_debug_info(s, pict); } } end: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return buf_size; err: av_free(buf2); for (i = 0; i < n_slices; i++) av_free(slices[i].buf); av_free(slices); return -1; }"
581----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_207558789c5c1fe3b12b14693b5506bf6250ac1e_1.json----encode_block,"static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size) { PutBitContext pb; int i, j, band, block, best_idx, power_idx = 0; float power_val, coeff, coeff_sum; float pows[NELLY_FILL_LEN]; int bits[NELLY_BUF_LEN], idx_table[NELLY_BANDS]; float cand[NELLY_BANDS]; apply_mdct(s); <S2SV_StartVul> init_put_bits(&pb, output, output_size * 8); <S2SV_EndVul> i = 0; for (band = 0; band < NELLY_BANDS; band++) { coeff_sum = 0; for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) { coeff_sum += s->mdct_out[i ] * s->mdct_out[i ] + s->mdct_out[i + NELLY_BUF_LEN] * s->mdct_out[i + NELLY_BUF_LEN]; } cand[band] = log(FFMAX(1.0, coeff_sum / (ff_nelly_band_sizes_table[band] << 7))) * 1024.0 / M_LN2; } if (s->avctx->trellis) { get_exponent_dynamic(s, cand, idx_table); } else { get_exponent_greedy(s, cand, idx_table); } i = 0; for (band = 0; band < NELLY_BANDS; band++) { if (band) { power_idx += ff_nelly_delta_table[idx_table[band]]; put_bits(&pb, 5, idx_table[band]); } else { power_idx = ff_nelly_init_table[idx_table[0]]; put_bits(&pb, 6, idx_table[0]); } power_val = pow_table[power_idx & 0x7FF] / (1 << ((power_idx >> 11) + POW_TABLE_OFFSET)); for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) { s->mdct_out[i] *= power_val; s->mdct_out[i + NELLY_BUF_LEN] *= power_val; pows[i] = power_idx; } } ff_nelly_get_sample_bits(pows, bits); for (block = 0; block < 2; block++) { for (i = 0; i < NELLY_FILL_LEN; i++) { if (bits[i] > 0) { const float *table = ff_nelly_dequantization_table + (1 << bits[i]) - 1; coeff = s->mdct_out[block * NELLY_BUF_LEN + i]; best_idx = quant_lut[av_clip ( coeff * quant_lut_mul[bits[i]] + quant_lut_add[bits[i]], quant_lut_offset[bits[i]], quant_lut_offset[bits[i]+1] - 1 )]; if (fabs(coeff - table[best_idx]) > fabs(coeff - table[best_idx + 1])) best_idx++; put_bits(&pb, bits[i], best_idx); } } if (!block) put_bits(&pb, NELLY_HEADER_BITS + NELLY_DETAIL_BITS - put_bits_count(&pb), 0); } flush_put_bits(&pb); memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb)); }","- init_put_bits(&pb, output, output_size * 8);
+ init_put_bits(&pb, output, output_size);","static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size) { PutBitContext pb; int i, j, band, block, best_idx, power_idx = 0; float power_val, coeff, coeff_sum; float pows[NELLY_FILL_LEN]; int bits[NELLY_BUF_LEN], idx_table[NELLY_BANDS]; float cand[NELLY_BANDS]; apply_mdct(s); init_put_bits(&pb, output, output_size); i = 0; for (band = 0; band < NELLY_BANDS; band++) { coeff_sum = 0; for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) { coeff_sum += s->mdct_out[i ] * s->mdct_out[i ] + s->mdct_out[i + NELLY_BUF_LEN] * s->mdct_out[i + NELLY_BUF_LEN]; } cand[band] = log(FFMAX(1.0, coeff_sum / (ff_nelly_band_sizes_table[band] << 7))) * 1024.0 / M_LN2; } if (s->avctx->trellis) { get_exponent_dynamic(s, cand, idx_table); } else { get_exponent_greedy(s, cand, idx_table); } i = 0; for (band = 0; band < NELLY_BANDS; band++) { if (band) { power_idx += ff_nelly_delta_table[idx_table[band]]; put_bits(&pb, 5, idx_table[band]); } else { power_idx = ff_nelly_init_table[idx_table[0]]; put_bits(&pb, 6, idx_table[0]); } power_val = pow_table[power_idx & 0x7FF] / (1 << ((power_idx >> 11) + POW_TABLE_OFFSET)); for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) { s->mdct_out[i] *= power_val; s->mdct_out[i + NELLY_BUF_LEN] *= power_val; pows[i] = power_idx; } } ff_nelly_get_sample_bits(pows, bits); for (block = 0; block < 2; block++) { for (i = 0; i < NELLY_FILL_LEN; i++) { if (bits[i] > 0) { const float *table = ff_nelly_dequantization_table + (1 << bits[i]) - 1; coeff = s->mdct_out[block * NELLY_BUF_LEN + i]; best_idx = quant_lut[av_clip ( coeff * quant_lut_mul[bits[i]] + quant_lut_add[bits[i]], quant_lut_offset[bits[i]], quant_lut_offset[bits[i]+1] - 1 )]; if (fabs(coeff - table[best_idx]) > fabs(coeff - table[best_idx + 1])) best_idx++; put_bits(&pb, bits[i], best_idx); } } if (!block) put_bits(&pb, NELLY_HEADER_BITS + NELLY_DETAIL_BITS - put_bits_count(&pb), 0); } flush_put_bits(&pb); memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb)); }"
15810----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c2abd58491012e6925ca69f39c620f50632e8c37_1.json----GENERAL_NAME_print,"int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen) { unsigned char *p; int i; switch (gen->type) { case GEN_OTHERNAME: BIO_printf(out, ""othername:<unsupported>""); break; case GEN_X400: BIO_printf(out, ""X400Name:<unsupported>""); break; case GEN_EDIPARTY: BIO_printf(out, ""EdiPartyName:<unsupported>""); break; case GEN_EMAIL: BIO_printf(out, ""email:%s"", gen->d.ia5->data); break; case GEN_DNS: BIO_printf(out, ""DNS:%s"", gen->d.ia5->data); break; case GEN_URI: BIO_printf(out, ""URI:%s"", gen->d.ia5->data); break; case GEN_DIRNAME: <S2SV_StartVul> BIO_printf(out, ""DirName: ""); <S2SV_EndVul> X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE); break; case GEN_IPADD: p = gen->d.ip->data; if (gen->d.ip->length == 4) BIO_printf(out, ""IP Address:%d.%d.%d.%d"", p[0], p[1], p[2], p[3]); else if (gen->d.ip->length == 16) { BIO_printf(out, ""IP Address""); for (i = 0; i < 8; i++) { BIO_printf(out, "":%X"", p[0] << 8 | p[1]); p += 2; } BIO_puts(out, ""\n""); } else { BIO_printf(out, ""IP Address:<invalid>""); break; } break; case GEN_RID: <S2SV_StartVul> BIO_printf(out, ""Registered ID""); <S2SV_EndVul> i2a_ASN1_OBJECT(out, gen->d.rid); break; } return 1; }","- BIO_printf(out, ""DirName: "");
- BIO_printf(out, ""Registered ID"");
+ BIO_printf(out, ""DirName:"");
+ BIO_printf(out, ""Registered ID:"");","int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen) { unsigned char *p; int i; switch (gen->type) { case GEN_OTHERNAME: BIO_printf(out, ""othername:<unsupported>""); break; case GEN_X400: BIO_printf(out, ""X400Name:<unsupported>""); break; case GEN_EDIPARTY: BIO_printf(out, ""EdiPartyName:<unsupported>""); break; case GEN_EMAIL: BIO_printf(out, ""email:%s"", gen->d.ia5->data); break; case GEN_DNS: BIO_printf(out, ""DNS:%s"", gen->d.ia5->data); break; case GEN_URI: BIO_printf(out, ""URI:%s"", gen->d.ia5->data); break; case GEN_DIRNAME: BIO_printf(out, ""DirName:""); X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE); break; case GEN_IPADD: p = gen->d.ip->data; if (gen->d.ip->length == 4) BIO_printf(out, ""IP Address:%d.%d.%d.%d"", p[0], p[1], p[2], p[3]); else if (gen->d.ip->length == 16) { BIO_printf(out, ""IP Address""); for (i = 0; i < 8; i++) { BIO_printf(out, "":%X"", p[0] << 8 | p[1]); p += 2; } BIO_puts(out, ""\n""); } else { BIO_printf(out, ""IP Address:<invalid>""); break; } break; case GEN_RID: BIO_printf(out, ""Registered ID:""); i2a_ASN1_OBJECT(out, gen->d.rid); break; } return 1; }"
10930----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_175a5b06518602e4c080ef6264b90a991bce880d_1.json----ssl3_get_finished,"int ssl3_get_finished(SSL *s, int a, int b) { <S2SV_StartVul> int al, i, ok; <S2SV_EndVul> long n; <S2SV_StartVul> unsigned char *p; <S2SV_EndVul> #ifdef OPENSSL_NO_NEXTPROTONEG #endif n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok); if (!ok) return ((int)n); if (!s->s3->change_cipher_spec) { al = SSL_AD_UNEXPECTED_MESSAGE; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS); <S2SV_EndVul> goto f_err; } s->s3->change_cipher_spec = 0; p = (unsigned char *)s->init_msg; i = s->s3->tmp.peer_finish_md_len; <S2SV_StartVul> if (i != n) { <S2SV_EndVul> al = SSL_AD_DECODE_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_BAD_DIGEST_LENGTH); <S2SV_EndVul> goto f_err; } if (CRYPTO_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0) { al = SSL_AD_DECRYPT_ERROR; <S2SV_StartVul> SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_DIGEST_CHECK_FAILED); <S2SV_EndVul> goto f_err; } if (s->type == SSL_ST_ACCEPT) { OPENSSL_assert(i <= EVP_MAX_MD_SIZE); memcpy(s->s3->previous_client_finished, s->s3->tmp.peer_finish_md, i); s->s3->previous_client_finished_len = i; } else { OPENSSL_assert(i <= EVP_MAX_MD_SIZE); memcpy(s->s3->previous_server_finished, s->s3->tmp.peer_finish_md, i); s->s3->previous_server_finished_len = i; } <S2SV_StartVul> return (1); <S2SV_EndVul> f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); <S2SV_StartVul> return (0); <S2SV_EndVul> }","- int al, i, ok;
- unsigned char *p;
- SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS);
- if (i != n) {
- SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_BAD_DIGEST_LENGTH);
- SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_DIGEST_CHECK_FAILED);
- return (1);
- return (0);
+ int ok;
+ return tls_process_finished(s, (unsigned long)n);
+ }","int ssl3_get_finished(SSL *s, int a, int b) { int ok; long n; #ifdef OPENSSL_NO_NEXTPROTONEG #endif n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok); if (!ok) return ((int)n); return tls_process_finished(s, (unsigned long)n); }"
4768----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_1dd753b9ef6163f85ec8b70eb1067df599e212ba_1.json----remove_any_filter,"static void remove_any_filter(ap_filter_t *f, ap_filter_t **r_filt, ap_filter_t **p_filt, ap_filter_t **c_filt) { ap_filter_t **curr = r_filt ? r_filt : c_filt; ap_filter_t *fscan = *curr; <S2SV_StartVul> if (is_pending_filter(f)) { <S2SV_EndVul> <S2SV_StartVul> apr_pool_cleanup_run(f->r ? f->r->pool : f->c->pool, <S2SV_EndVul> <S2SV_StartVul> f, pending_filter_cleanup); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (p_filt && *p_filt == f) *p_filt = (*p_filt)->next; if (*curr == f) { *curr = (*curr)->next; return; } while (fscan->next != f) { if (!(fscan = fscan->next)) { return; } } fscan->next = f->next; }","- if (is_pending_filter(f)) {
- apr_pool_cleanup_run(f->r ? f->r->pool : f->c->pool,
- f, pending_filter_cleanup);
- }
+ pending_filter_cleanup(f);","static void remove_any_filter(ap_filter_t *f, ap_filter_t **r_filt, ap_filter_t **p_filt, ap_filter_t **c_filt) { ap_filter_t **curr = r_filt ? r_filt : c_filt; ap_filter_t *fscan = *curr; pending_filter_cleanup(f); if (p_filt && *p_filt == f) *p_filt = (*p_filt)->next; if (*curr == f) { *curr = (*curr)->next; return; } while (fscan->next != f) { if (!(fscan = fscan->next)) { return; } } fscan->next = f->next; }"
11814----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3700b0bcff75f2a3f4b6309024bae1fad6f45bea_1.json----X509_NAME_cmp,"int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) { int ret; if (!a->canon_enc || a->modified) { ret = i2d_X509_NAME((X509_NAME *)a, NULL); if (ret < 0) return -2; } if (!b->canon_enc || b->modified) { ret = i2d_X509_NAME((X509_NAME *)b, NULL); if (ret < 0) return -2; } ret = a->canon_enclen - b->canon_enclen; <S2SV_StartVul> if (ret) <S2SV_EndVul> return ret; return memcmp(a->canon_enc, b->canon_enc, a->canon_enclen); }","- if (ret)
+ if (ret != 0 || a->canon_enclen == 0)","int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b) { int ret; if (!a->canon_enc || a->modified) { ret = i2d_X509_NAME((X509_NAME *)a, NULL); if (ret < 0) return -2; } if (!b->canon_enc || b->modified) { ret = i2d_X509_NAME((X509_NAME *)b, NULL); if (ret < 0) return -2; } ret = a->canon_enclen - b->canon_enclen; if (ret != 0 || a->canon_enclen == 0) return ret; return memcmp(a->canon_enc, b->canon_enc, a->canon_enclen); }"
1981----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6c04f54c8361a64fc09b68fd573587a2d0b29327_1.json----mpeg_motion_internal,"static av_always_inline void mpeg_motion_internal(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h, int is_mpeg12, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos; <S2SV_StartVul> emuedge_linesize_type uvlinesize, linesize; <S2SV_EndVul> #if 0 if(s->quarter_sample) { motion_x>>=1; motion_y>>=1; } #endif v_edge_pos = s->v_edge_pos >> field_based; linesize = s->current_picture.f.linesize[0] << field_based; uvlinesize = s->current_picture.f.linesize[1] << field_based; dxy = ((motion_y & 1) << 1) | (motion_x & 1); src_x = s->mb_x* 16 + (motion_x >> 1); src_y =( mb_y<<(4-field_based)) + (motion_y >> 1); if (!is_mpeg12 && s->out_format == FMT_H263) { if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){ mx = (motion_x>>1)|(motion_x&1); my = motion_y >>1; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x* 8 + (mx >> 1); uvsrc_y =( mb_y<<(3-field_based))+ (my >> 1); }else{ uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1); uvsrc_x = src_x>>1; uvsrc_y = src_y>>1; } }else if(!is_mpeg12 && s->out_format == FMT_H261){ mx = motion_x / 4; my = motion_y / 4; uvdxy = 0; uvsrc_x = s->mb_x*8 + mx; uvsrc_y = mb_y*8 + my; } else { if(s->chroma_y_shift){ mx = motion_x / 2; my = motion_y / 2; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x* 8 + (mx >> 1); uvsrc_y =( mb_y<<(3-field_based))+ (my >> 1); } else { if(s->chroma_x_shift){ mx = motion_x / 2; uvdxy = ((motion_y & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x* 8 + (mx >> 1); uvsrc_y = src_y; } else { uvdxy = dxy; uvsrc_x = src_x; uvsrc_y = src_y; } } } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if( (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0) || (unsigned)src_y > FFMAX( v_edge_pos - (motion_y&1) - h , 0)){ if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || s->codec_id == AV_CODEC_ID_MPEG1VIDEO){ av_log(s->avctx,AV_LOG_DEBUG, ""MPEG motion vector out of boundary (%d %d)\n"", src_x, src_y); return; } s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize, 17, 17+field_based, src_x, src_y<<field_based, s->h_edge_pos, s->v_edge_pos); ptr_y = s->edge_emu_buffer; if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize; s->vdsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9, 9+field_based, uvsrc_x, uvsrc_y<<field_based, s->h_edge_pos>>1, s->v_edge_pos>>1); s->vdsp.emulated_edge_mc(uvbuf+16, ptr_cr, s->uvlinesize, 9, 9+field_based, uvsrc_x, uvsrc_y<<field_based, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr_cb= uvbuf; ptr_cr= uvbuf+16; } } if(bottom_field){ dest_y += s->linesize; dest_cb+= s->uvlinesize; dest_cr+= s->uvlinesize; } if(field_select){ ptr_y += s->linesize; ptr_cb+= s->uvlinesize; ptr_cr+= s->uvlinesize; } pix_op[0][dxy](dest_y, ptr_y, linesize, h); if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ pix_op[s->chroma_x_shift][uvdxy] (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift); pix_op[s->chroma_x_shift][uvdxy] (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift); } if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) && s->out_format == FMT_H261){ ff_h261_loop_filter(s); } }","- emuedge_linesize_type uvlinesize, linesize;
+ ptrdiff_t uvlinesize, linesize;","static av_always_inline void mpeg_motion_internal(MpegEncContext *s, uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr, int field_based, int bottom_field, int field_select, uint8_t **ref_picture, op_pixels_func (*pix_op)[4], int motion_x, int motion_y, int h, int is_mpeg12, int mb_y) { uint8_t *ptr_y, *ptr_cb, *ptr_cr; int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos; ptrdiff_t uvlinesize, linesize; #if 0 if(s->quarter_sample) { motion_x>>=1; motion_y>>=1; } #endif v_edge_pos = s->v_edge_pos >> field_based; linesize = s->current_picture.f.linesize[0] << field_based; uvlinesize = s->current_picture.f.linesize[1] << field_based; dxy = ((motion_y & 1) << 1) | (motion_x & 1); src_x = s->mb_x* 16 + (motion_x >> 1); src_y =( mb_y<<(4-field_based)) + (motion_y >> 1); if (!is_mpeg12 && s->out_format == FMT_H263) { if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){ mx = (motion_x>>1)|(motion_x&1); my = motion_y >>1; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x* 8 + (mx >> 1); uvsrc_y =( mb_y<<(3-field_based))+ (my >> 1); }else{ uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1); uvsrc_x = src_x>>1; uvsrc_y = src_y>>1; } }else if(!is_mpeg12 && s->out_format == FMT_H261){ mx = motion_x / 4; my = motion_y / 4; uvdxy = 0; uvsrc_x = s->mb_x*8 + mx; uvsrc_y = mb_y*8 + my; } else { if(s->chroma_y_shift){ mx = motion_x / 2; my = motion_y / 2; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x* 8 + (mx >> 1); uvsrc_y =( mb_y<<(3-field_based))+ (my >> 1); } else { if(s->chroma_x_shift){ mx = motion_x / 2; uvdxy = ((motion_y & 1) << 1) | (mx & 1); uvsrc_x = s->mb_x* 8 + (mx >> 1); uvsrc_y = src_y; } else { uvdxy = dxy; uvsrc_x = src_x; uvsrc_y = src_y; } } } ptr_y = ref_picture[0] + src_y * linesize + src_x; ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x; ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x; if( (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0) || (unsigned)src_y > FFMAX( v_edge_pos - (motion_y&1) - h , 0)){ if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || s->codec_id == AV_CODEC_ID_MPEG1VIDEO){ av_log(s->avctx,AV_LOG_DEBUG, ""MPEG motion vector out of boundary (%d %d)\n"", src_x, src_y); return; } s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize, 17, 17+field_based, src_x, src_y<<field_based, s->h_edge_pos, s->v_edge_pos); ptr_y = s->edge_emu_buffer; if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize; s->vdsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9, 9+field_based, uvsrc_x, uvsrc_y<<field_based, s->h_edge_pos>>1, s->v_edge_pos>>1); s->vdsp.emulated_edge_mc(uvbuf+16, ptr_cr, s->uvlinesize, 9, 9+field_based, uvsrc_x, uvsrc_y<<field_based, s->h_edge_pos>>1, s->v_edge_pos>>1); ptr_cb= uvbuf; ptr_cr= uvbuf+16; } } if(bottom_field){ dest_y += s->linesize; dest_cb+= s->uvlinesize; dest_cr+= s->uvlinesize; } if(field_select){ ptr_y += s->linesize; ptr_cb+= s->uvlinesize; ptr_cr+= s->uvlinesize; } pix_op[0][dxy](dest_y, ptr_y, linesize, h); if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){ pix_op[s->chroma_x_shift][uvdxy] (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift); pix_op[s->chroma_x_shift][uvdxy] (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift); } if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) && s->out_format == FMT_H261){ ff_h261_loop_filter(s); } }"
1265----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4466b5b924d8c259775cf5b76851bb43b21a7461_1.json----dvbsub_display_end_segment,"static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf, int buf_size, AVSubtitle *sub) { DVBSubContext *ctx = avctx->priv_data; DVBSubDisplayDefinition *display_def = ctx->display_definition; DVBSubRegion *region; DVBSubRegionDisplay *display; AVSubtitleRect *rect; DVBSubCLUT *clut; uint32_t *clut_table; int i; int offset_x=0, offset_y=0; sub->end_display_time = ctx->time_out * 1000; if (display_def) { offset_x = display_def->x; offset_y = display_def->y; } <S2SV_StartVul> sub->num_rects = ctx->display_list_size; <S2SV_EndVul> if (sub->num_rects > 0){ sub->rects = av_mallocz(sizeof(*sub->rects) * sub->num_rects); for(i=0; i<sub->num_rects; i++) sub->rects[i] = av_mallocz(sizeof(*sub->rects[i])); i = 0; for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (!region) continue; if (!region->dirty) continue; rect = sub->rects[i]; rect->x = display->x_pos + offset_x; rect->y = display->y_pos + offset_y; rect->w = region->width; rect->h = region->height; rect->nb_colors = (1 << region->depth); rect->type = SUBTITLE_BITMAP; rect->pict.linesize[0] = region->width; clut = get_clut(ctx, region->clut); if (!clut) clut = &default_clut; switch (region->depth) { case 2: clut_table = clut->clut4; break; case 8: clut_table = clut->clut256; break; case 4: default: clut_table = clut->clut16; break; } rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE); memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t)); rect->pict.data[0] = av_malloc(region->buf_size); memcpy(rect->pict.data[0], region->pbuf, region->buf_size); i++; } <S2SV_StartVul> sub->num_rects = i; <S2SV_EndVul> } #ifdef DEBUG save_display_set(ctx); #endif return 1; }","- sub->num_rects = ctx->display_list_size;
- sub->num_rects = i;
+ sub->num_rects = 0;
+ for (display = ctx->display_list; display; display = display->next)
+ {
+ region = get_region(ctx, display->region_id);
+ if (region && region->dirty)
+ sub->num_rects++;
+ }","static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf, int buf_size, AVSubtitle *sub) { DVBSubContext *ctx = avctx->priv_data; DVBSubDisplayDefinition *display_def = ctx->display_definition; DVBSubRegion *region; DVBSubRegionDisplay *display; AVSubtitleRect *rect; DVBSubCLUT *clut; uint32_t *clut_table; int i; int offset_x=0, offset_y=0; sub->end_display_time = ctx->time_out * 1000; if (display_def) { offset_x = display_def->x; offset_y = display_def->y; } sub->num_rects = 0; for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (region && region->dirty) sub->num_rects++; } if (sub->num_rects > 0){ sub->rects = av_mallocz(sizeof(*sub->rects) * sub->num_rects); for(i=0; i<sub->num_rects; i++) sub->rects[i] = av_mallocz(sizeof(*sub->rects[i])); i = 0; for (display = ctx->display_list; display; display = display->next) { region = get_region(ctx, display->region_id); if (!region) continue; if (!region->dirty) continue; rect = sub->rects[i]; rect->x = display->x_pos + offset_x; rect->y = display->y_pos + offset_y; rect->w = region->width; rect->h = region->height; rect->nb_colors = (1 << region->depth); rect->type = SUBTITLE_BITMAP; rect->pict.linesize[0] = region->width; clut = get_clut(ctx, region->clut); if (!clut) clut = &default_clut; switch (region->depth) { case 2: clut_table = clut->clut4; break; case 8: clut_table = clut->clut256; break; case 4: default: clut_table = clut->clut16; break; } rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE); memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t)); rect->pict.data[0] = av_malloc(region->buf_size); memcpy(rect->pict.data[0], region->pbuf, region->buf_size); i++; } } #ifdef DEBUG save_display_set(ctx); #endif return 1; }"
4334----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_eab90bb15321424ab777faaeb826e21fef67b387_1.json----filter_mb_edgecv,"static void av_noinline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) { <S2SV_StartVul> const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset; <S2SV_EndVul> const int alpha = alpha_table[index_a]; <S2SV_StartVul> const int beta = (beta_table+52)[qp + h->slice_beta_offset]; <S2SV_EndVul> if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]+1; tc[1] = tc0_table[index_a][bS[1]]+1; tc[2] = tc0_table[index_a][bS[2]]+1; tc[3] = tc0_table[index_a][bS[3]]+1; h->s.dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc); } else { h->s.dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta); } }","- const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;
- const int beta = (beta_table+52)[qp + h->slice_beta_offset];
+ const unsigned int index_a = qp + h->slice_alpha_c0_offset;
+ const int beta = beta_table[qp + h->slice_beta_offset];","static void av_noinline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) { const unsigned int index_a = qp + h->slice_alpha_c0_offset; const int alpha = alpha_table[index_a]; const int beta = beta_table[qp + h->slice_beta_offset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8_t tc[4]; tc[0] = tc0_table[index_a][bS[0]]+1; tc[1] = tc0_table[index_a][bS[1]]+1; tc[2] = tc0_table[index_a][bS[2]]+1; tc[3] = tc0_table[index_a][bS[3]]+1; h->s.dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc); } else { h->s.dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta); } }"
1224----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_425bb358ef4206e3dff879e0d68661bd99092ebb_1.json----ass_split_section,"static const char *ass_split_section(ASSSplitContext *ctx, const char *buf) { const ASSSection *section = &ass_sections[ctx->current_section]; int *number = &ctx->field_number[ctx->current_section]; int *order = ctx->field_order[ctx->current_section]; int *tmp, i, len; while (buf && *buf) { if (buf[0] == '[') { ctx->current_section = -1; break; } if (buf[0] == ';' || (buf[0] == '!' && buf[1] == ':')) { } else if (section->format_header && !order) { len = strlen(section->format_header); if (strncmp(buf, section->format_header, len) || buf[len] != ':') return NULL; buf += len + 1; while (!is_eol(*buf)) { buf = skip_space(buf); len = strcspn(buf, "", \r\n""); if (!(tmp = av_realloc(order, (*number + 1) * sizeof(*order)))) return NULL; order = tmp; order[*number] = -1; for (i=0; section->fields[i].name; i++) if (!strncmp(buf, section->fields[i].name, len)) { order[*number] = i; break; } (*number)++; buf = skip_space(buf + len + (buf[len] == ',')); } ctx->field_order[ctx->current_section] = order; } else if (section->fields_header) { len = strlen(section->fields_header); if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') { uint8_t *ptr, *struct_ptr = realloc_section_array(ctx); if (!struct_ptr) return NULL; buf += len + 1; for (i=0; !is_eol(*buf) && i < *number; i++) { int last = i == *number - 1; buf = skip_space(buf); len = strcspn(buf, last ? ""\r\n"" : "",\r\n""); if (order[i] >= 0) { ASSFieldType type = section->fields[order[i]].type; ptr = struct_ptr + section->fields[order[i]].offset; convert_func[type](ptr, buf, len); } buf = skip_space(buf + len + !last); } } } else { len = strcspn(buf, "":\r\n""); if (buf[len] == ':') { for (i=0; section->fields[i].name; i++) if (!strncmp(buf, section->fields[i].name, len)) { ASSFieldType type = section->fields[i].type; uint8_t *ptr = (uint8_t *)&ctx->ass + section->offset; ptr += section->fields[i].offset; buf = skip_space(buf + len + 1); convert_func[type](ptr, buf, strcspn(buf, ""\r\n"")); break; } } } <S2SV_StartVul> buf += strcspn(buf, ""\n"") + 1; <S2SV_EndVul> } return buf; }","- buf += strcspn(buf, ""\n"") + 1;
+ buf += strcspn(buf, ""\n"");
+ buf += !!*buf;","static const char *ass_split_section(ASSSplitContext *ctx, const char *buf) { const ASSSection *section = &ass_sections[ctx->current_section]; int *number = &ctx->field_number[ctx->current_section]; int *order = ctx->field_order[ctx->current_section]; int *tmp, i, len; while (buf && *buf) { if (buf[0] == '[') { ctx->current_section = -1; break; } if (buf[0] == ';' || (buf[0] == '!' && buf[1] == ':')) { } else if (section->format_header && !order) { len = strlen(section->format_header); if (strncmp(buf, section->format_header, len) || buf[len] != ':') return NULL; buf += len + 1; while (!is_eol(*buf)) { buf = skip_space(buf); len = strcspn(buf, "", \r\n""); if (!(tmp = av_realloc(order, (*number + 1) * sizeof(*order)))) return NULL; order = tmp; order[*number] = -1; for (i=0; section->fields[i].name; i++) if (!strncmp(buf, section->fields[i].name, len)) { order[*number] = i; break; } (*number)++; buf = skip_space(buf + len + (buf[len] == ',')); } ctx->field_order[ctx->current_section] = order; } else if (section->fields_header) { len = strlen(section->fields_header); if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') { uint8_t *ptr, *struct_ptr = realloc_section_array(ctx); if (!struct_ptr) return NULL; buf += len + 1; for (i=0; !is_eol(*buf) && i < *number; i++) { int last = i == *number - 1; buf = skip_space(buf); len = strcspn(buf, last ? ""\r\n"" : "",\r\n""); if (order[i] >= 0) { ASSFieldType type = section->fields[order[i]].type; ptr = struct_ptr + section->fields[order[i]].offset; convert_func[type](ptr, buf, len); } buf = skip_space(buf + len + !last); } } } else { len = strcspn(buf, "":\r\n""); if (buf[len] == ':') { for (i=0; section->fields[i].name; i++) if (!strncmp(buf, section->fields[i].name, len)) { ASSFieldType type = section->fields[i].type; uint8_t *ptr = (uint8_t *)&ctx->ass + section->offset; ptr += section->fields[i].offset; buf = skip_space(buf + len + 1); convert_func[type](ptr, buf, strcspn(buf, ""\r\n"")); break; } } } buf += strcspn(buf, ""\n""); buf += !!*buf; } return buf; }"
438----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_18ff55a0eff23f14e1b459153a24e967cc2a3b44_1.json----aac_sync,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info, int *need_next_header, int *new_frame_start) { GetBitContext bits; <S2SV_StartVul> int size, rdb, ch, sr; <S2SV_EndVul> union { uint64_t u64; uint8_t u8[8]; } tmp; tmp.u64 = be2me_64(state); init_get_bits(&bits, tmp.u8+8-AAC_HEADER_SIZE, AAC_HEADER_SIZE * 8); <S2SV_StartVul> if(get_bits(&bits, 12) != 0xfff) <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> skip_bits(&bits, 2); <S2SV_EndVul> <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> skip_bits(&bits, 2); <S2SV_EndVul> <S2SV_StartVul> sr = get_bits(&bits, 4); <S2SV_EndVul> <S2SV_StartVul> if(!ff_mpeg4audio_sample_rates[sr]) <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> ch = get_bits(&bits, 3); <S2SV_EndVul> <S2SV_StartVul> if(!ff_mpeg4audio_channels[ch]) <S2SV_EndVul> return 0; <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> skip_bits1(&bits); <S2SV_EndVul> <S2SV_StartVul> size = get_bits(&bits, 13); <S2SV_EndVul> <S2SV_StartVul> if(size < AAC_HEADER_SIZE) <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> skip_bits(&bits, 11); <S2SV_EndVul> <S2SV_StartVul> rdb = get_bits(&bits, 2); <S2SV_EndVul> <S2SV_StartVul> hdr_info->channels = ff_mpeg4audio_channels[ch]; <S2SV_EndVul> <S2SV_StartVul> hdr_info->sample_rate = ff_mpeg4audio_sample_rates[sr]; <S2SV_EndVul> <S2SV_StartVul> hdr_info->samples = (rdb + 1) * 1024; <S2SV_EndVul> <S2SV_StartVul> hdr_info->bit_rate = size * 8 * hdr_info->sample_rate / hdr_info->samples; <S2SV_EndVul> *need_next_header = 0; *new_frame_start = 1; return size; }","- int size, rdb, ch, sr;
- if(get_bits(&bits, 12) != 0xfff)
- return 0;
- if(!ff_mpeg4audio_sample_rates[sr])
- return 0;
- if(!ff_mpeg4audio_channels[ch])
- if(size < AAC_HEADER_SIZE)
- return 0;
- hdr_info->channels = ff_mpeg4audio_channels[ch];
- hdr_info->sample_rate = ff_mpeg4audio_sample_rates[sr];
- hdr_info->samples = (rdb + 1) * 1024;
- hdr_info->bit_rate = size * 8 * hdr_info->sample_rate / hdr_info->samples;
+ AACADTSHeaderInfo hdr;
+ int size;
+ if ((size = ff_aac_parse_header(&bits, &hdr)) < 0)
+ hdr_info->sample_rate = hdr.sample_rate;
+ hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config];
+ hdr_info->samples = hdr.samples;
+ hdr_info->bit_rate = hdr.bit_rate;","static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info, int *need_next_header, int *new_frame_start) { GetBitContext bits; AACADTSHeaderInfo hdr; int size; union { uint64_t u64; uint8_t u8[8]; } tmp; tmp.u64 = be2me_64(state); init_get_bits(&bits, tmp.u8+8-AAC_HEADER_SIZE, AAC_HEADER_SIZE * 8); if ((size = ff_aac_parse_header(&bits, &hdr)) < 0) return 0; *need_next_header = 0; *new_frame_start = 1; hdr_info->sample_rate = hdr.sample_rate; hdr_info->channels = ff_mpeg4audio_channels[hdr.chan_config]; hdr_info->samples = hdr.samples; hdr_info->bit_rate = hdr.bit_rate; return size; }"
12402----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_4bec462972291cca57a2581001387ea7d76b85f2_1.json----ERR_print_errors_cb,"void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u), void *u) { unsigned long l; char buf[256]; <S2SV_StartVul> char buf2[4096]; <S2SV_EndVul> const char *file, *data; int line, flags; <S2SV_EndVul> <S2SV_StartVul> union { <S2SV_EndVul> <S2SV_StartVul> CRYPTO_THREAD_ID tid; <S2SV_EndVul> <S2SV_StartVul> unsigned long ltid; <S2SV_EndVul> <S2SV_StartVul> } tid; <S2SV_EndVul> <S2SV_StartVul> tid.ltid = 0; <S2SV_EndVul> <S2SV_StartVul> tid.tid = CRYPTO_THREAD_get_current_id(); <S2SV_EndVul> while ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) != 0) { ERR_error_string_n(l, buf, sizeof(buf)); <S2SV_StartVul> BIO_snprintf(buf2, sizeof(buf2), ""%lu:%s:%s:%d:%s\n"", tid.ltid, buf, <S2SV_EndVul> <S2SV_StartVul> file, line, (flags & ERR_TXT_STRING) ? data : """"); <S2SV_EndVul> if (cb(buf2, strlen(buf2), u) <= 0) break; } }","- char buf2[4096];
- union {
- CRYPTO_THREAD_ID tid;
- unsigned long ltid;
- } tid;
- tid.ltid = 0;
- tid.tid = CRYPTO_THREAD_get_current_id();
- BIO_snprintf(buf2, sizeof(buf2), ""%lu:%s:%s:%d:%s\n"", tid.ltid, buf,
- file, line, (flags & ERR_TXT_STRING) ? data : """");
+ CRYPTO_THREAD_ID tid = CRYPTO_THREAD_get_current_id();
+ char buf2[4096], *hex;
+ hex = OPENSSL_buf2hexstr((const unsigned char *)&tid, sizeof(tid));
+ BIO_snprintf(buf2, sizeof(buf2), ""%s:%s:%s:%d:%s\n"", hex, buf, file,
+ line, (flags & ERR_TXT_STRING) ? data : """");
+ OPENSSL_free(hex);","void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u), void *u) { CRYPTO_THREAD_ID tid = CRYPTO_THREAD_get_current_id(); unsigned long l; char buf[256]; char buf2[4096], *hex; const char *file, *data; int line, flags; while ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) != 0) { ERR_error_string_n(l, buf, sizeof(buf)); hex = OPENSSL_buf2hexstr((const unsigned char *)&tid, sizeof(tid)); BIO_snprintf(buf2, sizeof(buf2), ""%s:%s:%s:%d:%s\n"", hex, buf, file, line, (flags & ERR_TXT_STRING) ? data : """"); OPENSSL_free(hex); if (cb(buf2, strlen(buf2), u) <= 0) break; } }"
16254----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d1614bb8aa9fafda10e485a9a6b1c88a4ecde179_1.json----X509V3_EXT_add,"int X509V3_EXT_add(X509V3_EXT_METHOD *ext) { <S2SV_StartVul> if(!ext_list && !(ext_list = sk_new((int (*)(const void *, const void *))ext_cmp))) { <S2SV_EndVul> X509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE); return 0; } <S2SV_StartVul> if(!sk_push(ext_list, (char *)ext)) { <S2SV_EndVul> X509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE); return 0; } return 1; }","- if(!ext_list && !(ext_list = sk_new((int (*)(const void *, const void *))ext_cmp))) {
- if(!sk_push(ext_list, (char *)ext)) {
+ if(!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {
+ if(!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {","int X509V3_EXT_add(X509V3_EXT_METHOD *ext) { if(!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) { X509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE); return 0; } if(!sk_X509V3_EXT_METHOD_push(ext_list, ext)) { X509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE); return 0; } return 1; }"
5604----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2672936e870e0dc6d087920fbb7f1b9639770e4c_1.json----ff_fdct248_islow,"GLOBAL(void) ff_fdct248_islow (DCTELEM * data) { <S2SV_StartVul> int_fast32_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; <S2SV_EndVul> <S2SV_StartVul> int_fast32_t tmp10, tmp11, tmp12, tmp13; <S2SV_EndVul> <S2SV_StartVul> int_fast32_t z1; <S2SV_EndVul> DCTELEM *dataptr; int ctr; row_fdct(data); dataptr = data; for (ctr = DCTSIZE-1; ctr >= 0; ctr--) { tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*1]; tmp1 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3]; tmp2 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*5]; tmp3 = dataptr[DCTSIZE*6] + dataptr[DCTSIZE*7]; tmp4 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*1]; tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3]; tmp6 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*5]; tmp7 = dataptr[DCTSIZE*6] - dataptr[DCTSIZE*7]; tmp10 = tmp0 + tmp3; tmp11 = tmp1 + tmp2; tmp12 = tmp1 - tmp2; tmp13 = tmp0 - tmp3; dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS); dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS); z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100); dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865), CONST_BITS+PASS1_BITS); dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065), CONST_BITS+PASS1_BITS); tmp10 = tmp4 + tmp7; tmp11 = tmp5 + tmp6; tmp12 = tmp5 - tmp6; tmp13 = tmp4 - tmp7; dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS); dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS); z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100); dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865), CONST_BITS+PASS1_BITS); dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065), CONST_BITS+PASS1_BITS); dataptr++; } }","- int_fast32_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
- int_fast32_t tmp10, tmp11, tmp12, tmp13;
- int_fast32_t z1;
+ int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
+ int tmp10, tmp11, tmp12, tmp13;
+ int z1;","GLOBAL(void) ff_fdct248_islow (DCTELEM * data) { int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7; int tmp10, tmp11, tmp12, tmp13; int z1; DCTELEM *dataptr; int ctr; row_fdct(data); dataptr = data; for (ctr = DCTSIZE-1; ctr >= 0; ctr--) { tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*1]; tmp1 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3]; tmp2 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*5]; tmp3 = dataptr[DCTSIZE*6] + dataptr[DCTSIZE*7]; tmp4 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*1]; tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3]; tmp6 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*5]; tmp7 = dataptr[DCTSIZE*6] - dataptr[DCTSIZE*7]; tmp10 = tmp0 + tmp3; tmp11 = tmp1 + tmp2; tmp12 = tmp1 - tmp2; tmp13 = tmp0 - tmp3; dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS); dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS); z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100); dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865), CONST_BITS+PASS1_BITS); dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065), CONST_BITS+PASS1_BITS); tmp10 = tmp4 + tmp7; tmp11 = tmp5 + tmp6; tmp12 = tmp5 - tmp6; tmp13 = tmp4 - tmp7; dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS); dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS); z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100); dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865), CONST_BITS+PASS1_BITS); dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065), CONST_BITS+PASS1_BITS); dataptr++; } }"
7116----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8093fcd4548b7e08ce1b7195d06f5c8d32cf0c28_1.json----await_reference_mb_row,"<S2SV_StartVul> static void await_reference_mb_row(const H264Context *const h, H264Picture *ref, <S2SV_EndVul> int mb_y) { int ref_field = ref->reference - 1; <S2SV_StartVul> int ref_field_picture = ref->field_picture; <S2SV_EndVul> int ref_height = 16 * h->mb_height >> ref_field_picture; if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_FRAME)) return; <S2SV_StartVul> ff_thread_await_progress(&ref->tf, <S2SV_EndVul> FFMIN(16 * mb_y >> ref_field_picture, ref_height - 1), ref_field_picture && ref_field); }","- static void await_reference_mb_row(const H264Context *const h, H264Picture *ref,
- int ref_field_picture = ref->field_picture;
- ff_thread_await_progress(&ref->tf,
+ static void await_reference_mb_row(const H264Context *const h, H264Ref *ref,
+ int ref_field_picture = ref->parent->field_picture;
+ ff_thread_await_progress(&ref->parent->tf,","static void await_reference_mb_row(const H264Context *const h, H264Ref *ref, int mb_y) { int ref_field = ref->reference - 1; int ref_field_picture = ref->parent->field_picture; int ref_height = 16 * h->mb_height >> ref_field_picture; if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_FRAME)) return; ff_thread_await_progress(&ref->parent->tf, FFMIN(16 * mb_y >> ref_field_picture, ref_height - 1), ref_field_picture && ref_field); }"
6248----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4ddb9614b2eabf855f065fd3ce2ebbb65a8a910c_1.json----mxf_edit_unit_absolute_offset,"static int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag) { int i; <S2SV_StartVul> int offset_temp = 0; <S2SV_EndVul> for (i = 0; i < index_table->nb_segments; i++) { MXFIndexTableSegment *s = index_table->segments[i]; edit_unit = FFMAX(edit_unit, s->index_start_position); if (edit_unit < s->index_start_position + s->index_duration) { int64_t index = edit_unit - s->index_start_position; if (s->edit_unit_byte_count) offset_temp += s->edit_unit_byte_count * index; else if (s->nb_index_entries) { if (s->nb_index_entries == 2 * s->index_duration + 1) index *= 2; if (index < 0 || index > s->nb_index_entries) { av_log(mxf->fc, AV_LOG_ERROR, ""IndexSID %i segment at %""PRId64"" IndexEntryArray too small\n"", index_table->index_sid, s->index_start_position); return AVERROR_INVALIDDATA; } offset_temp = s->stream_offset_entries[index]; } else { av_log(mxf->fc, AV_LOG_ERROR, ""IndexSID %i segment at %""PRId64"" missing EditUnitByteCount and IndexEntryArray\n"", index_table->index_sid, s->index_start_position); return AVERROR_INVALIDDATA; } if (edit_unit_out) *edit_unit_out = edit_unit; return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out); } else { offset_temp += s->edit_unit_byte_count * s->index_duration; } } if (nag) av_log(mxf->fc, AV_LOG_ERROR, ""failed to map EditUnit %""PRId64"" in IndexSID %i to an offset\n"", edit_unit, index_table->index_sid); return AVERROR_INVALIDDATA; }","- int offset_temp = 0;
+ int64_t offset_temp = 0;","static int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag) { int i; int64_t offset_temp = 0; for (i = 0; i < index_table->nb_segments; i++) { MXFIndexTableSegment *s = index_table->segments[i]; edit_unit = FFMAX(edit_unit, s->index_start_position); if (edit_unit < s->index_start_position + s->index_duration) { int64_t index = edit_unit - s->index_start_position; if (s->edit_unit_byte_count) offset_temp += s->edit_unit_byte_count * index; else if (s->nb_index_entries) { if (s->nb_index_entries == 2 * s->index_duration + 1) index *= 2; if (index < 0 || index > s->nb_index_entries) { av_log(mxf->fc, AV_LOG_ERROR, ""IndexSID %i segment at %""PRId64"" IndexEntryArray too small\n"", index_table->index_sid, s->index_start_position); return AVERROR_INVALIDDATA; } offset_temp = s->stream_offset_entries[index]; } else { av_log(mxf->fc, AV_LOG_ERROR, ""IndexSID %i segment at %""PRId64"" missing EditUnitByteCount and IndexEntryArray\n"", index_table->index_sid, s->index_start_position); return AVERROR_INVALIDDATA; } if (edit_unit_out) *edit_unit_out = edit_unit; return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out); } else { offset_temp += s->edit_unit_byte_count * s->index_duration; } } if (nag) av_log(mxf->fc, AV_LOG_ERROR, ""failed to map EditUnit %""PRId64"" in IndexSID %i to an offset\n"", edit_unit, index_table->index_sid); return AVERROR_INVALIDDATA; }"
784----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2afa70c9848a688ee659195631cc9e5ca3b8121f_1.json----write_packet,"<S2SV_StartVul> static void write_packet(AVFormatContext *s, AVPacket *pkt, OutputStream *ost) <S2SV_EndVul> { AVStream *st = ost->st; int ret; if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed)) { if (ost->frame_number >= ost->max_frames) { av_packet_unref(pkt); return; } ost->frame_number++; } if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) { uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_FACTOR, NULL); ost->quality = sd ? *(int *)sd : -1; if (ost->frame_rate.num) { pkt->duration = av_rescale_q(1, av_inv_q(ost->frame_rate), ost->st->time_base); } } if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS) && ost->last_mux_dts != AV_NOPTS_VALUE && pkt->dts < ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT)) { av_log(NULL, AV_LOG_WARNING, ""Non-monotonous DTS in output stream "" ""%d:%d; previous: %""PRId64"", current: %""PRId64""; "", ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts); if (exit_on_error) { av_log(NULL, AV_LOG_FATAL, ""aborting.\n""); exit_program(1); } av_log(NULL, AV_LOG_WARNING, ""changing to %""PRId64"". This may result "" ""in incorrect timestamps in the output file.\n"", ost->last_mux_dts + 1); pkt->dts = ost->last_mux_dts + 1; if (pkt->pts != AV_NOPTS_VALUE) pkt->pts = FFMAX(pkt->pts, pkt->dts); } ost->last_mux_dts = pkt->dts; ost->data_size += pkt->size; ost->packets_written++; pkt->stream_index = ost->index; ret = av_interleaved_write_frame(s, pkt); if (ret < 0) { print_error(""av_interleaved_write_frame()"", ret); exit_program(1); } }","- static void write_packet(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)
+ static void write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost)
+ AVFormatContext *s = of->ctx;
+ if (!of->header_written) {
+ AVPacket tmp_pkt;
+ if (!av_fifo_space(ost->muxing_queue)) {
+ int new_size = FFMIN(2 * av_fifo_size(ost->muxing_queue),
+ ost->max_muxing_queue_size);
+ if (new_size <= av_fifo_size(ost->muxing_queue)) {
+ av_log(NULL, AV_LOG_ERROR,
+ ""Too many packets buffered for output stream %d:%d.\n"",
+ ost->file_index, ost->st->index);
+ exit_program(1);
+ }
+ ret = av_fifo_realloc2(ost->muxing_queue, new_size);
+ if (ret < 0)
+ exit_program(1);
+ }
+ av_packet_move_ref(&tmp_pkt, pkt);
+ av_fifo_generic_write(ost->muxing_queue, &tmp_pkt, sizeof(tmp_pkt), NULL);
+ return;
+ }","static void write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost) { AVFormatContext *s = of->ctx; AVStream *st = ost->st; int ret; if (!of->header_written) { AVPacket tmp_pkt; if (!av_fifo_space(ost->muxing_queue)) { int new_size = FFMIN(2 * av_fifo_size(ost->muxing_queue), ost->max_muxing_queue_size); if (new_size <= av_fifo_size(ost->muxing_queue)) { av_log(NULL, AV_LOG_ERROR, ""Too many packets buffered for output stream %d:%d.\n"", ost->file_index, ost->st->index); exit_program(1); } ret = av_fifo_realloc2(ost->muxing_queue, new_size); if (ret < 0) exit_program(1); } av_packet_move_ref(&tmp_pkt, pkt); av_fifo_generic_write(ost->muxing_queue, &tmp_pkt, sizeof(tmp_pkt), NULL); return; } if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed)) { if (ost->frame_number >= ost->max_frames) { av_packet_unref(pkt); return; } ost->frame_number++; } if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) { uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_FACTOR, NULL); ost->quality = sd ? *(int *)sd : -1; if (ost->frame_rate.num) { pkt->duration = av_rescale_q(1, av_inv_q(ost->frame_rate), ost->st->time_base); } } if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS) && ost->last_mux_dts != AV_NOPTS_VALUE && pkt->dts < ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT)) { av_log(NULL, AV_LOG_WARNING, ""Non-monotonous DTS in output stream "" ""%d:%d; previous: %""PRId64"", current: %""PRId64""; "", ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts); if (exit_on_error) { av_log(NULL, AV_LOG_FATAL, ""aborting.\n""); exit_program(1); } av_log(NULL, AV_LOG_WARNING, ""changing to %""PRId64"". This may result "" ""in incorrect timestamps in the output file.\n"", ost->last_mux_dts + 1); pkt->dts = ost->last_mux_dts + 1; if (pkt->pts != AV_NOPTS_VALUE) pkt->pts = FFMAX(pkt->pts, pkt->dts); } ost->last_mux_dts = pkt->dts; ost->data_size += pkt->size; ost->packets_written++; pkt->stream_index = ost->index; ret = av_interleaved_write_frame(s, pkt); if (ret < 0) { print_error(""av_interleaved_write_frame()"", ret); exit_program(1); } }"
1387----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4cd84eb23bd64a0e53b5447eec29e6d3f3d2d05d_1.json----rv34_decoder_alloc,static int rv34_decoder_alloc(RV34DecContext *r) { r->intra_types_stride = r->s.mb_width * 4 + 4; <S2SV_StartVul> r->cbp_chroma = av_malloc(r->s.mb_stride * r->s.mb_height * <S2SV_EndVul> sizeof(*r->cbp_chroma)); <S2SV_StartVul> r->cbp_luma = av_malloc(r->s.mb_stride * r->s.mb_height * <S2SV_EndVul> sizeof(*r->cbp_luma)); <S2SV_StartVul> r->deblock_coefs = av_malloc(r->s.mb_stride * r->s.mb_height * <S2SV_EndVul> sizeof(*r->deblock_coefs)); r->intra_types_hist = av_malloc(r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist)); r->mb_type = av_mallocz(r->s.mb_stride * r->s.mb_height * sizeof(*r->mb_type)); if (!(r->cbp_chroma && r->cbp_luma && r->deblock_coefs && r->intra_types_hist && r->mb_type)) { rv34_decoder_free(r); return AVERROR(ENOMEM); } r->intra_types = r->intra_types_hist + r->intra_types_stride * 4; return 0; },"- r->cbp_chroma = av_malloc(r->s.mb_stride * r->s.mb_height *
- r->cbp_luma = av_malloc(r->s.mb_stride * r->s.mb_height *
- r->deblock_coefs = av_malloc(r->s.mb_stride * r->s.mb_height *
+ r->cbp_chroma = av_mallocz(r->s.mb_stride * r->s.mb_height *
+ r->cbp_luma = av_mallocz(r->s.mb_stride * r->s.mb_height *
+ r->deblock_coefs = av_mallocz(r->s.mb_stride * r->s.mb_height *",static int rv34_decoder_alloc(RV34DecContext *r) { r->intra_types_stride = r->s.mb_width * 4 + 4; r->cbp_chroma = av_mallocz(r->s.mb_stride * r->s.mb_height * sizeof(*r->cbp_chroma)); r->cbp_luma = av_mallocz(r->s.mb_stride * r->s.mb_height * sizeof(*r->cbp_luma)); r->deblock_coefs = av_mallocz(r->s.mb_stride * r->s.mb_height * sizeof(*r->deblock_coefs)); r->intra_types_hist = av_malloc(r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist)); r->mb_type = av_mallocz(r->s.mb_stride * r->s.mb_height * sizeof(*r->mb_type)); if (!(r->cbp_chroma && r->cbp_luma && r->deblock_coefs && r->intra_types_hist && r->mb_type)) { rv34_decoder_free(r); return AVERROR(ENOMEM); } r->intra_types = r->intra_types_hist + r->intra_types_stride * 4; return 0; }
6555----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_608c0fc57de2027cfb67c513ff7e1610e81fc272_1.json----quantize_mantissas,"static void quantize_mantissas(AC3EncodeContext *s) { int blk, ch, ch0=0, got_cpl; for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { AC3Block *block = &s->blocks[blk]; <S2SV_StartVul> AC3Block *ref_block; <S2SV_EndVul> AC3Mant m = { 0 }; got_cpl = !block->cpl_in_use; for (ch = 1; ch <= s->channels; ch++) { if (!got_cpl && ch > 1 && block->channel_in_cpl[ch-1]) { ch0 = ch - 1; ch = CPL_CH; got_cpl = 1; } <S2SV_StartVul> ref_block = block->exp_ref_block[ch]; <S2SV_EndVul> quantize_mantissas_blk_ch(&m, block->fixed_coef[ch], <S2SV_StartVul> ref_block->exp[ch], <S2SV_EndVul> <S2SV_StartVul> ref_block->bap[ch], block->qmant[ch], <S2SV_EndVul> s->start_freq[ch], block->end_freq[ch]); if (ch == CPL_CH) ch = ch0; } } }","- AC3Block *ref_block;
- ref_block = block->exp_ref_block[ch];
- ref_block->exp[ch],
- ref_block->bap[ch], block->qmant[ch],
+ s->blocks[s->exp_ref_block[ch][blk]].exp[ch],
+ s->ref_bap[ch][blk], block->qmant[ch],","static void quantize_mantissas(AC3EncodeContext *s) { int blk, ch, ch0=0, got_cpl; for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { AC3Block *block = &s->blocks[blk]; AC3Mant m = { 0 }; got_cpl = !block->cpl_in_use; for (ch = 1; ch <= s->channels; ch++) { if (!got_cpl && ch > 1 && block->channel_in_cpl[ch-1]) { ch0 = ch - 1; ch = CPL_CH; got_cpl = 1; } quantize_mantissas_blk_ch(&m, block->fixed_coef[ch], s->blocks[s->exp_ref_block[ch][blk]].exp[ch], s->ref_bap[ch][blk], block->qmant[ch], s->start_freq[ch], block->end_freq[ch]); if (ch == CPL_CH) ch = ch0; } } }"
1260----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_440078157d08ceedc22e95f8adc752b88ef1ccd4_1.json----do_subtitle_out,"static void do_subtitle_out(AVFormatContext *s, OutputStream *ost, InputStream *ist, AVSubtitle *sub) { int subtitle_out_max_size = 1024 * 1024; int subtitle_out_size, nb, i; AVCodecContext *enc; AVPacket pkt; int64_t pts; if (sub->pts == AV_NOPTS_VALUE) { av_log(NULL, AV_LOG_ERROR, ""Subtitle packets must have a pts\n""); if (exit_on_error) exit_program(1); return; } enc = ost->enc_ctx; if (!subtitle_out) { subtitle_out = av_malloc(subtitle_out_max_size); if (!subtitle_out) { av_log(NULL, AV_LOG_FATAL, ""Failed to allocate subtitle_out\n""); exit_program(1); } } if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) nb = 2; else nb = 1; pts = sub->pts; if (output_files[ost->file_index]->start_time != AV_NOPTS_VALUE) pts -= output_files[ost->file_index]->start_time; for (i = 0; i < nb; i++) { unsigned save_num_rects = sub->num_rects; ost->sync_opts = av_rescale_q(pts, AV_TIME_BASE_Q, enc->time_base); if (!check_recording_time(ost)) return; sub->pts = pts; sub->pts += av_rescale_q(sub->start_display_time, (AVRational){ 1, 1000 }, AV_TIME_BASE_Q); sub->end_display_time -= sub->start_display_time; sub->start_display_time = 0; if (i == 1) sub->num_rects = 0; ost->frames_encoded++; subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out, subtitle_out_max_size, sub); if (i == 1) sub->num_rects = save_num_rects; if (subtitle_out_size < 0) { av_log(NULL, AV_LOG_FATAL, ""Subtitle encoding failed\n""); exit_program(1); } av_init_packet(&pkt); pkt.data = subtitle_out; pkt.size = subtitle_out_size; pkt.pts = av_rescale_q(sub->pts, AV_TIME_BASE_Q, ost->st->time_base); pkt.duration = av_rescale_q(sub->end_display_time, (AVRational){ 1, 1000 }, ost->st->time_base); if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) { if (i == 0) pkt.pts += 90 * sub->start_display_time; else pkt.pts += 90 * sub->end_display_time; } pkt.dts = pkt.pts; <S2SV_StartVul> write_frame(s, &pkt, ost); <S2SV_EndVul> } }","- write_frame(s, &pkt, ost);
+ output_packet(s, &pkt, ost);","static void do_subtitle_out(AVFormatContext *s, OutputStream *ost, InputStream *ist, AVSubtitle *sub) { int subtitle_out_max_size = 1024 * 1024; int subtitle_out_size, nb, i; AVCodecContext *enc; AVPacket pkt; int64_t pts; if (sub->pts == AV_NOPTS_VALUE) { av_log(NULL, AV_LOG_ERROR, ""Subtitle packets must have a pts\n""); if (exit_on_error) exit_program(1); return; } enc = ost->enc_ctx; if (!subtitle_out) { subtitle_out = av_malloc(subtitle_out_max_size); if (!subtitle_out) { av_log(NULL, AV_LOG_FATAL, ""Failed to allocate subtitle_out\n""); exit_program(1); } } if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) nb = 2; else nb = 1; pts = sub->pts; if (output_files[ost->file_index]->start_time != AV_NOPTS_VALUE) pts -= output_files[ost->file_index]->start_time; for (i = 0; i < nb; i++) { unsigned save_num_rects = sub->num_rects; ost->sync_opts = av_rescale_q(pts, AV_TIME_BASE_Q, enc->time_base); if (!check_recording_time(ost)) return; sub->pts = pts; sub->pts += av_rescale_q(sub->start_display_time, (AVRational){ 1, 1000 }, AV_TIME_BASE_Q); sub->end_display_time -= sub->start_display_time; sub->start_display_time = 0; if (i == 1) sub->num_rects = 0; ost->frames_encoded++; subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out, subtitle_out_max_size, sub); if (i == 1) sub->num_rects = save_num_rects; if (subtitle_out_size < 0) { av_log(NULL, AV_LOG_FATAL, ""Subtitle encoding failed\n""); exit_program(1); } av_init_packet(&pkt); pkt.data = subtitle_out; pkt.size = subtitle_out_size; pkt.pts = av_rescale_q(sub->pts, AV_TIME_BASE_Q, ost->st->time_base); pkt.duration = av_rescale_q(sub->end_display_time, (AVRational){ 1, 1000 }, ost->st->time_base); if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) { if (i == 0) pkt.pts += 90 * sub->start_display_time; else pkt.pts += 90 * sub->end_display_time; } pkt.dts = pkt.pts; output_packet(s, &pkt, ost); } }"
617----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_21fc61493139bc0a239adce4644354397351cab7_1.json----ff_lpc_calc_coefs,"int ff_lpc_calc_coefs(LPCContext *s, const int32_t *samples, int blocksize, int min_order, int max_order, int precision, int32_t coefs[][MAX_LPC_ORDER], int *shift, enum FFLPCType lpc_type, int lpc_passes, int omethod, int max_shift, int zero_shift) { double autoc[MAX_LPC_ORDER+1]; double ref[MAX_LPC_ORDER]; double lpc[MAX_LPC_ORDER][MAX_LPC_ORDER]; int i, j, pass = 0; int opt_order; av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER && lpc_type > FF_LPC_TYPE_FIXED); if (blocksize != s->blocksize || max_order != s->max_order || lpc_type != s->lpc_type) { ff_lpc_end(s); ff_lpc_init(s, blocksize, max_order, lpc_type); } if(lpc_passes <= 0) lpc_passes = 2; if (lpc_type == FF_LPC_TYPE_LEVINSON || (lpc_type == FF_LPC_TYPE_CHOLESKY && lpc_passes > 1)) { s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples); s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc); compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1); for(i=0; i<max_order; i++) ref[i] = fabs(lpc[i][i]); pass++; } if (lpc_type == FF_LPC_TYPE_CHOLESKY) { LLSModel m[2]; LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]); double av_uninit(weight); memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var)); for(j=0; j<max_order; j++) m[0].coeff[max_order-1][j] = -lpc[max_order-1][j]; for(; pass<lpc_passes; pass++){ avpriv_init_lls(&m[pass&1], max_order); weight=0; for(i=max_order; i<blocksize; i++){ for(j=0; j<=max_order; j++) var[j]= samples[i-j]; if(pass){ double eval, inv, rinv; <S2SV_StartVul> eval= m[(pass-1)&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1); <S2SV_EndVul> eval= (512>>pass) + fabs(eval - var[0]); inv = 1/eval; rinv = sqrt(inv); for(j=0; j<=max_order; j++) var[j] *= rinv; weight += inv; }else weight++; m[pass&1].update_lls(&m[pass&1], var); } avpriv_solve_lls(&m[pass&1], 0.001, 0); } for(i=0; i<max_order; i++){ for(j=0; j<max_order; j++) lpc[i][j]=-m[(pass-1)&1].coeff[i][j]; ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000; } for(i=max_order-1; i>0; i--) ref[i] = ref[i-1] - ref[i]; } opt_order = max_order; if(omethod == ORDER_METHOD_EST) { opt_order = estimate_best_order(ref, min_order, max_order); i = opt_order-1; quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift); } else { for(i=min_order-1; i<max_order; i++) { quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift); } } return opt_order; }","- eval= m[(pass-1)&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);
+ eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);","int ff_lpc_calc_coefs(LPCContext *s, const int32_t *samples, int blocksize, int min_order, int max_order, int precision, int32_t coefs[][MAX_LPC_ORDER], int *shift, enum FFLPCType lpc_type, int lpc_passes, int omethod, int max_shift, int zero_shift) { double autoc[MAX_LPC_ORDER+1]; double ref[MAX_LPC_ORDER]; double lpc[MAX_LPC_ORDER][MAX_LPC_ORDER]; int i, j, pass = 0; int opt_order; av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER && lpc_type > FF_LPC_TYPE_FIXED); if (blocksize != s->blocksize || max_order != s->max_order || lpc_type != s->lpc_type) { ff_lpc_end(s); ff_lpc_init(s, blocksize, max_order, lpc_type); } if(lpc_passes <= 0) lpc_passes = 2; if (lpc_type == FF_LPC_TYPE_LEVINSON || (lpc_type == FF_LPC_TYPE_CHOLESKY && lpc_passes > 1)) { s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples); s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc); compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1); for(i=0; i<max_order; i++) ref[i] = fabs(lpc[i][i]); pass++; } if (lpc_type == FF_LPC_TYPE_CHOLESKY) { LLSModel m[2]; LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]); double av_uninit(weight); memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var)); for(j=0; j<max_order; j++) m[0].coeff[max_order-1][j] = -lpc[max_order-1][j]; for(; pass<lpc_passes; pass++){ avpriv_init_lls(&m[pass&1], max_order); weight=0; for(i=max_order; i<blocksize; i++){ for(j=0; j<=max_order; j++) var[j]= samples[i-j]; if(pass){ double eval, inv, rinv; eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1); eval= (512>>pass) + fabs(eval - var[0]); inv = 1/eval; rinv = sqrt(inv); for(j=0; j<=max_order; j++) var[j] *= rinv; weight += inv; }else weight++; m[pass&1].update_lls(&m[pass&1], var); } avpriv_solve_lls(&m[pass&1], 0.001, 0); } for(i=0; i<max_order; i++){ for(j=0; j<max_order; j++) lpc[i][j]=-m[(pass-1)&1].coeff[i][j]; ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000; } for(i=max_order-1; i>0; i--) ref[i] = ref[i-1] - ref[i]; } opt_order = max_order; if(omethod == ORDER_METHOD_EST) { opt_order = estimate_best_order(ref, min_order, max_order); i = opt_order-1; quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift); } else { for(i=min_order-1; i<max_order; i++) { quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift); } } return opt_order; }"
5487----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1ff6f9bb238d5f71ea34c8f191144d09de051c6c_1.json----av_fill_image_linesizes,"int av_fill_image_linesizes(int linesizes[4], enum PixelFormat pix_fmt, int width) { int i; const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt]; int max_step [4]; int max_step_comp[4]; memset(linesizes, 0, 4*sizeof(linesizes[0])); if (desc->flags & PIX_FMT_HWACCEL) return AVERROR(EINVAL); if (desc->flags & PIX_FMT_BITSTREAM) { linesizes[0] = (width * (desc->comp[0].step_minus1+1) + 7) >> 3; return 0; } <S2SV_StartVul> av_fill_image_max_pixstep(max_step, max_step_comp, desc); <S2SV_EndVul> for (i = 0; i < 4; i++) { int s = (max_step_comp[i] == 1 || max_step_comp[i] == 2) ? desc->log2_chroma_w : 0; linesizes[i] = max_step[i] * (((width + (1 << s) - 1)) >> s); } return 0; }","- av_fill_image_max_pixstep(max_step, max_step_comp, desc);
+ av_fill_image_max_pixsteps(max_step, max_step_comp, desc);","int av_fill_image_linesizes(int linesizes[4], enum PixelFormat pix_fmt, int width) { int i; const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt]; int max_step [4]; int max_step_comp[4]; memset(linesizes, 0, 4*sizeof(linesizes[0])); if (desc->flags & PIX_FMT_HWACCEL) return AVERROR(EINVAL); if (desc->flags & PIX_FMT_BITSTREAM) { linesizes[0] = (width * (desc->comp[0].step_minus1+1) + 7) >> 3; return 0; } av_fill_image_max_pixsteps(max_step, max_step_comp, desc); for (i = 0; i < 4; i++) { int s = (max_step_comp[i] == 1 || max_step_comp[i] == 2) ? desc->log2_chroma_w : 0; linesizes[i] = max_step[i] * (((width + (1 << s) - 1)) >> s); } return 0; }"
181----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0abd4ffb8a19405df16711ea2d44b6ba3171f1b2_1.json----ea_read_packet,"static int ea_read_packet(AVFormatContext *s, AVPacket *pkt) { EaDemuxContext *ea = s->priv_data; AVIOContext *pb = s->pb; int ret = 0; int packet_read = 0; unsigned int chunk_type, chunk_size; int key = 0; int av_uninit(num_samples); while (!packet_read) { chunk_type = avio_rl32(pb); <S2SV_StartVul> chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8; <S2SV_EndVul> switch (chunk_type) { case ISNh_TAG: avio_skip(pb, 32); chunk_size -= 32; case ISNd_TAG: case SCDl_TAG: case SNDC_TAG: case SDEN_TAG: if (!ea->audio_codec) { avio_skip(pb, chunk_size); break; } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR || ea->audio_codec == CODEC_ID_MP3) { num_samples = avio_rl32(pb); avio_skip(pb, 8); chunk_size -= 12; } ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->audio_stream_index; switch (ea->audio_codec) { case CODEC_ID_ADPCM_EA: case CODEC_ID_ADPCM_EA_R1: case CODEC_ID_ADPCM_EA_R2: case CODEC_ID_ADPCM_IMA_EA_EACS: pkt->duration = AV_RL32(pkt->data); break; case CODEC_ID_ADPCM_EA_R3: pkt->duration = AV_RB32(pkt->data); break; case CODEC_ID_ADPCM_IMA_EA_SEAD: pkt->duration = ret * 2 / ea->num_channels; break; case CODEC_ID_PCM_S16LE_PLANAR: case CODEC_ID_MP3: pkt->duration = num_samples; break; default: pkt->duration = chunk_size / (ea->bytes * ea->num_channels); } packet_read = 1; break; case 0: case ISNe_TAG: case SCEl_TAG: case SEND_TAG: case SEEN_TAG: ret = AVERROR(EIO); packet_read = 1; break; case MVIh_TAG: case kVGT_TAG: case pQGT_TAG: case TGQs_TAG: case MADk_TAG: key = AV_PKT_FLAG_KEY; case MVIf_TAG: case fVGT_TAG: case MADm_TAG: case MADe_TAG: avio_seek(pb, -8, SEEK_CUR); chunk_size += 8; goto get_video_packet; case mTCD_TAG: avio_skip(pb, 8); chunk_size -= 8; goto get_video_packet; case MV0K_TAG: case MPCh_TAG: case pIQT_TAG: key = AV_PKT_FLAG_KEY; case MV0F_TAG: get_video_packet: ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->video_stream_index; pkt->flags |= key; packet_read = 1; break; default: avio_skip(pb, chunk_size); break; } } return ret; }","- chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;
+ chunk_size = ea->big_endian ? avio_rb32(pb) : avio_rl32(pb);
+ if (chunk_size <= 8)
+ return AVERROR_INVALIDDATA;
+ chunk_size -= 8;
+ if (chunk_size < 32)
+ return AVERROR_INVALIDDATA;","static int ea_read_packet(AVFormatContext *s, AVPacket *pkt) { EaDemuxContext *ea = s->priv_data; AVIOContext *pb = s->pb; int ret = 0; int packet_read = 0; unsigned int chunk_type, chunk_size; int key = 0; int av_uninit(num_samples); while (!packet_read) { chunk_type = avio_rl32(pb); chunk_size = ea->big_endian ? avio_rb32(pb) : avio_rl32(pb); if (chunk_size <= 8) return AVERROR_INVALIDDATA; chunk_size -= 8; switch (chunk_type) { case ISNh_TAG: if (chunk_size < 32) return AVERROR_INVALIDDATA; avio_skip(pb, 32); chunk_size -= 32; case ISNd_TAG: case SCDl_TAG: case SNDC_TAG: case SDEN_TAG: if (!ea->audio_codec) { avio_skip(pb, chunk_size); break; } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR || ea->audio_codec == CODEC_ID_MP3) { num_samples = avio_rl32(pb); avio_skip(pb, 8); chunk_size -= 12; } ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->audio_stream_index; switch (ea->audio_codec) { case CODEC_ID_ADPCM_EA: case CODEC_ID_ADPCM_EA_R1: case CODEC_ID_ADPCM_EA_R2: case CODEC_ID_ADPCM_IMA_EA_EACS: pkt->duration = AV_RL32(pkt->data); break; case CODEC_ID_ADPCM_EA_R3: pkt->duration = AV_RB32(pkt->data); break; case CODEC_ID_ADPCM_IMA_EA_SEAD: pkt->duration = ret * 2 / ea->num_channels; break; case CODEC_ID_PCM_S16LE_PLANAR: case CODEC_ID_MP3: pkt->duration = num_samples; break; default: pkt->duration = chunk_size / (ea->bytes * ea->num_channels); } packet_read = 1; break; case 0: case ISNe_TAG: case SCEl_TAG: case SEND_TAG: case SEEN_TAG: ret = AVERROR(EIO); packet_read = 1; break; case MVIh_TAG: case kVGT_TAG: case pQGT_TAG: case TGQs_TAG: case MADk_TAG: key = AV_PKT_FLAG_KEY; case MVIf_TAG: case fVGT_TAG: case MADm_TAG: case MADe_TAG: avio_seek(pb, -8, SEEK_CUR); chunk_size += 8; goto get_video_packet; case mTCD_TAG: avio_skip(pb, 8); chunk_size -= 8; goto get_video_packet; case MV0K_TAG: case MPCh_TAG: case pIQT_TAG: key = AV_PKT_FLAG_KEY; case MV0F_TAG: get_video_packet: ret = av_get_packet(pb, pkt, chunk_size); if (ret < 0) return ret; pkt->stream_index = ea->video_stream_index; pkt->flags |= key; packet_read = 1; break; default: avio_skip(pb, chunk_size); break; } } return ret; }"
1928----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_69ce18f3085fe62e4a3a4bea6a4a7b95958d98a1_1.json----hls_mux_init,"static int hls_mux_init(AVFormatContext *s) { HLSContext *hls = s->priv_data; AVFormatContext *oc; <S2SV_StartVul> AVFormatContext *vtt_oc; <S2SV_EndVul> int i, ret; ret = avformat_alloc_output_context2(&hls->avf, hls->oformat, NULL, NULL); if (ret < 0) return ret; oc = hls->avf; oc->oformat = hls->oformat; oc->interrupt_callback = s->interrupt_callback; oc->max_delay = s->max_delay; av_dict_copy(&oc->metadata, s->metadata, 0); if(hls->vtt_oformat) { ret = avformat_alloc_output_context2(&hls->vtt_avf, hls->vtt_oformat, NULL, NULL); if (ret < 0) return ret; vtt_oc = hls->vtt_avf; vtt_oc->oformat = hls->vtt_oformat; av_dict_copy(&vtt_oc->metadata, s->metadata, 0); } for (i = 0; i < s->nb_streams; i++) { AVStream *st; AVFormatContext *loc; if (s->streams[i]->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) loc = vtt_oc; else loc = oc; if (!(st = avformat_new_stream(loc, NULL))) return AVERROR(ENOMEM); avcodec_copy_context(st->codec, s->streams[i]->codec); st->sample_aspect_ratio = s->streams[i]->sample_aspect_ratio; st->time_base = s->streams[i]->time_base; } hls->start_pos = 0; return 0; }","- AVFormatContext *vtt_oc;
+ AVFormatContext *vtt_oc = NULL;","static int hls_mux_init(AVFormatContext *s) { HLSContext *hls = s->priv_data; AVFormatContext *oc; AVFormatContext *vtt_oc = NULL; int i, ret; ret = avformat_alloc_output_context2(&hls->avf, hls->oformat, NULL, NULL); if (ret < 0) return ret; oc = hls->avf; oc->oformat = hls->oformat; oc->interrupt_callback = s->interrupt_callback; oc->max_delay = s->max_delay; av_dict_copy(&oc->metadata, s->metadata, 0); if(hls->vtt_oformat) { ret = avformat_alloc_output_context2(&hls->vtt_avf, hls->vtt_oformat, NULL, NULL); if (ret < 0) return ret; vtt_oc = hls->vtt_avf; vtt_oc->oformat = hls->vtt_oformat; av_dict_copy(&vtt_oc->metadata, s->metadata, 0); } for (i = 0; i < s->nb_streams; i++) { AVStream *st; AVFormatContext *loc; if (s->streams[i]->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) loc = vtt_oc; else loc = oc; if (!(st = avformat_new_stream(loc, NULL))) return AVERROR(ENOMEM); avcodec_copy_context(st->codec, s->streams[i]->codec); st->sample_aspect_ratio = s->streams[i]->sample_aspect_ratio; st->time_base = s->streams[i]->time_base; } hls->start_pos = 0; return 0; }"
497----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1be04b49ca05fa17f823c0cc4bb17e5735840422_1.json----mkv_write_header,"static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header; AVDictionaryEntry *tag; int ret, i, version = 2; int64_t creation_time; if (!strcmp(s->oformat->name, ""webm"")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->metadata, ""alpha_mode"", NULL, 0)) version = 4; for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, ""The Matroska muxer does not yet support muxing %s\n"", avcodec_get_name(s->streams[i]->codecpar->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->streams[i]->metadata, ""alpha_mode"", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { ret = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { ret = AVERROR(ENOMEM); goto fail; } ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if (ret < 0) goto fail; <S2SV_StartVul> ret = start_ebml_master_crc32(pb, &mkv->info_bc, &mkv->info, MATROSKA_ID_INFO, 0); <S2SV_EndVul> if (ret < 0) return ret; pb = mkv->info_bc; put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if ((tag = av_dict_get(s->metadata, ""title"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if ((tag = av_dict_get(s->metadata, ""encoding_tool"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); if (mkv->mode != MODE_WEBM) { uint32_t segment_uid[4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) segment_uid[i] = av_lfg_get(&lfg); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16); } } else { const char *ident = ""Lavf""; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) { int64_t date_utc = (creation_time - 978307200000000LL) * 1000; uint8_t date_utc_buf[8]; AV_WB64(date_utc_buf, date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { int64_t metadata_duration = get_metadata_duration(s); if (s->duration > 0) { int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, ""Write early duration from recording time = %"" PRIu64 ""\n"", scaledDuration); } else if (metadata_duration > 0) { int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, ""Write early duration from metadata = %"" PRIu64 ""\n"", scaledDuration); } else { put_ebml_void(pb, 11); } } if (s->pb->seekable) <S2SV_StartVul> put_ebml_void(s->pb, avio_tell(pb) + ((mkv->write_crc && mkv->mode != MODE_WEBM) ? 2 + 4 : 0)); <S2SV_EndVul> else end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info); pb = s->pb; mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); ret = mkv_write_tracks(s); if (ret < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); if (mkv->mode != MODE_WEBM) { ret = mkv_write_chapters(s); if (ret < 0) goto fail; ret = mkv_write_attachments(s); if (ret < 0) goto fail; ret = mkv_write_tags(s); if (ret < 0) goto fail; } if (!s->pb->seekable && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { ret = AVERROR(ENOMEM); goto fail; } if (pb->seekable && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return ret; }","- ret = start_ebml_master_crc32(pb, &mkv->info_bc, &mkv->info, MATROSKA_ID_INFO, 0);
- put_ebml_void(s->pb, avio_tell(pb) + ((mkv->write_crc && mkv->mode != MODE_WEBM) ? 2 /* ebml id + data size */ + 4 /* CRC32 */ : 0));
+ ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);
+ put_ebml_void(s->pb, avio_tell(pb));","static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header; AVDictionaryEntry *tag; int ret, i, version = 2; int64_t creation_time; if (!strcmp(s->oformat->name, ""webm"")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->metadata, ""alpha_mode"", NULL, 0)) version = 4; for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, ""The Matroska muxer does not yet support muxing %s\n"", avcodec_get_name(s->streams[i]->codecpar->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, ""stereo_mode"", NULL, 0) || av_dict_get(s->streams[i]->metadata, ""alpha_mode"", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { ret = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { ret = AVERROR(ENOMEM); goto fail; } ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if (ret < 0) goto fail; ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0); if (ret < 0) return ret; pb = mkv->info_bc; put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if ((tag = av_dict_get(s->metadata, ""title"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if ((tag = av_dict_get(s->metadata, ""encoding_tool"", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); if (mkv->mode != MODE_WEBM) { uint32_t segment_uid[4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) segment_uid[i] = av_lfg_get(&lfg); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16); } } else { const char *ident = ""Lavf""; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) { int64_t date_utc = (creation_time - 978307200000000LL) * 1000; uint8_t date_utc_buf[8]; AV_WB64(date_utc_buf, date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { int64_t metadata_duration = get_metadata_duration(s); if (s->duration > 0) { int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, ""Write early duration from recording time = %"" PRIu64 ""\n"", scaledDuration); } else if (metadata_duration > 0) { int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, ""Write early duration from metadata = %"" PRIu64 ""\n"", scaledDuration); } else { put_ebml_void(pb, 11); } } if (s->pb->seekable) put_ebml_void(s->pb, avio_tell(pb)); else end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info); pb = s->pb; mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); ret = mkv_write_tracks(s); if (ret < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); if (mkv->mode != MODE_WEBM) { ret = mkv_write_chapters(s); if (ret < 0) goto fail; ret = mkv_write_attachments(s); if (ret < 0) goto fail; ret = mkv_write_tags(s); if (ret < 0) goto fail; } if (!s->pb->seekable && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { ret = AVERROR(ENOMEM); goto fail; } if (pb->seekable && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return ret; }"
13588----PULSE_MEMORY_LEAK----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7550e9fcd7d2c5e0eb3c8f71cb423c1c0495b1fa_1.json----OSSL_STORE_LOADER_new,"OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme) { <S2SV_StartVul> OSSL_STORE_LOADER *res = OPENSSL_zalloc(sizeof(*res)); <S2SV_EndVul> <S2SV_StartVul> if (res == NULL) { <S2SV_EndVul> <S2SV_StartVul> OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE); <S2SV_EndVul> <S2SV_StartVul> return NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (scheme == NULL) { OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, OSSL_STORE_R_INVALID_SCHEME); return NULL; } res->engine = e; res->scheme = scheme; return res; }","- OSSL_STORE_LOADER *res = OPENSSL_zalloc(sizeof(*res));
- if (res == NULL) {
- OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE);
- return NULL;
- }
+ OSSL_STORE_LOADER *res = NULL;
+ if ((res = OPENSSL_zalloc(sizeof(*res))) == NULL) {
+ OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE);
+ return NULL;
+ }","OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme) { OSSL_STORE_LOADER *res = NULL; if (scheme == NULL) { OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, OSSL_STORE_R_INVALID_SCHEME); return NULL; } if ((res = OPENSSL_zalloc(sizeof(*res))) == NULL) { OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE); return NULL; } res->engine = e; res->scheme = scheme; return res; }"
6478----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5c056afc005e2e5d923ba6e09c235653d6efc1a6_1.json----sdp_parse_line,"static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1, int letter, const char *buf) { RTSPState *rt = s->priv_data; char buf1[64], st_type[64]; const char *p; enum CodecType codec_type; int payload_type, i; AVStream *st; RTSPStream *rtsp_st; struct in_addr sdp_ip; int ttl; dprintf(s, ""sdp: %c='%s'\n"", letter, buf); p = buf; if (s1->skip_media && letter != 'm') return; switch (letter) { case 'c': get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, ""IN"") != 0) return; get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, ""IP4"") != 0) return; get_word_sep(buf1, sizeof(buf1), ""/"", &p); if (ff_inet_aton(buf1, &sdp_ip) == 0) return; ttl = 16; if (*p == '/') { p++; get_word_sep(buf1, sizeof(buf1), ""/"", &p); ttl = atoi(buf1); } if (s->nb_streams == 0) { s1->default_ip = sdp_ip; s1->default_ttl = ttl; } else { st = s->streams[s->nb_streams - 1]; rtsp_st = st->priv_data; rtsp_st->sdp_ip = sdp_ip; rtsp_st->sdp_ttl = ttl; } break; case 's': av_metadata_set(&s->metadata, ""title"", p); break; case 'i': if (s->nb_streams == 0) { av_metadata_set(&s->metadata, ""comment"", p); break; } break; case 'm': s1->skip_media = 0; get_word(st_type, sizeof(st_type), &p); if (!strcmp(st_type, ""audio"")) { codec_type = CODEC_TYPE_AUDIO; } else if (!strcmp(st_type, ""video"")) { codec_type = CODEC_TYPE_VIDEO; } else if (!strcmp(st_type, ""application"")) { codec_type = CODEC_TYPE_DATA; } else { s1->skip_media = 1; return; } rtsp_st = av_mallocz(sizeof(RTSPStream)); if (!rtsp_st) return; rtsp_st->stream_index = -1; dynarray_add(&rt->rtsp_streams, &rt->nb_rtsp_streams, rtsp_st); rtsp_st->sdp_ip = s1->default_ip; rtsp_st->sdp_ttl = s1->default_ttl; get_word(buf1, sizeof(buf1), &p); rtsp_st->sdp_port = atoi(buf1); get_word(buf1, sizeof(buf1), &p); get_word(buf1, sizeof(buf1), &p); rtsp_st->sdp_payload_type = atoi(buf1); if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), ""MP2T"")) { } else { st = av_new_stream(s, 0); if (!st) return; st->priv_data = rtsp_st; rtsp_st->stream_index = st->index; st->codec->codec_type = codec_type; if (rtsp_st->sdp_payload_type < RTP_PT_PRIVATE) { ff_rtp_get_codec_info(st->codec, rtsp_st->sdp_payload_type); } } av_strlcpy(rtsp_st->control_url, rt->control_uri, sizeof(rtsp_st->control_url)); break; case 'a': if (av_strstart(p, ""control:"", &p)) { if (s->nb_streams == 0) { if (!strncmp(p, ""rtsp://"", 7)) av_strlcpy(rt->control_uri, p, sizeof(rt->control_uri)); } else { char proto[32]; st = s->streams[s->nb_streams - 1]; rtsp_st = st->priv_data; <S2SV_StartVul> url_split(proto, sizeof(proto), NULL, 0, NULL, 0, <S2SV_EndVul> NULL, NULL, 0, p); if (proto[0] == '\0') { if (rtsp_st->control_url[strlen(rtsp_st->control_url)-1]!='/') av_strlcat(rtsp_st->control_url, ""/"", sizeof(rtsp_st->control_url)); av_strlcat(rtsp_st->control_url, p, sizeof(rtsp_st->control_url)); } else av_strlcpy(rtsp_st->control_url, p, sizeof(rtsp_st->control_url)); } } else if (av_strstart(p, ""rtpmap:"", &p) && s->nb_streams > 0) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); st = s->streams[s->nb_streams - 1]; rtsp_st = st->priv_data; sdp_parse_rtpmap(s, st->codec, rtsp_st, payload_type, p); } else if (av_strstart(p, ""fmtp:"", &p)) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; rtsp_st = st->priv_data; if (rtsp_st->sdp_payload_type == payload_type) { if (!(rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line && rtsp_st->dynamic_handler->parse_sdp_a_line(s, i, rtsp_st->dynamic_protocol_context, buf))) sdp_parse_fmtp(st, p); } } } else if (av_strstart(p, ""framesize:"", &p)) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; rtsp_st = st->priv_data; if (rtsp_st->sdp_payload_type == payload_type && rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) rtsp_st->dynamic_handler->parse_sdp_a_line(s, i, rtsp_st->dynamic_protocol_context, buf); } } else if (av_strstart(p, ""range:"", &p)) { int64_t start, end; rtsp_parse_range_npt(p, &start, &end); s->start_time = start; s->duration = (end == AV_NOPTS_VALUE) ? AV_NOPTS_VALUE : end - start; } else if (av_strstart(p, ""IsRealDataType:integer;"",&p)) { if (atoi(p) == 1) rt->transport = RTSP_TRANSPORT_RDT; } else { if (rt->server_type == RTSP_SERVER_WMS) ff_wms_parse_sdp_a_line(s, p); if (s->nb_streams > 0) { if (rt->server_type == RTSP_SERVER_REAL) ff_real_parse_sdp_a_line(s, s->nb_streams - 1, p); rtsp_st = s->streams[s->nb_streams - 1]->priv_data; if (rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) rtsp_st->dynamic_handler->parse_sdp_a_line(s, s->nb_streams - 1, rtsp_st->dynamic_protocol_context, buf); } } break; } }","- url_split(proto, sizeof(proto), NULL, 0, NULL, 0,
+ ff_url_split(proto, sizeof(proto), NULL, 0, NULL, 0,","static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1, int letter, const char *buf) { RTSPState *rt = s->priv_data; char buf1[64], st_type[64]; const char *p; enum CodecType codec_type; int payload_type, i; AVStream *st; RTSPStream *rtsp_st; struct in_addr sdp_ip; int ttl; dprintf(s, ""sdp: %c='%s'\n"", letter, buf); p = buf; if (s1->skip_media && letter != 'm') return; switch (letter) { case 'c': get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, ""IN"") != 0) return; get_word(buf1, sizeof(buf1), &p); if (strcmp(buf1, ""IP4"") != 0) return; get_word_sep(buf1, sizeof(buf1), ""/"", &p); if (ff_inet_aton(buf1, &sdp_ip) == 0) return; ttl = 16; if (*p == '/') { p++; get_word_sep(buf1, sizeof(buf1), ""/"", &p); ttl = atoi(buf1); } if (s->nb_streams == 0) { s1->default_ip = sdp_ip; s1->default_ttl = ttl; } else { st = s->streams[s->nb_streams - 1]; rtsp_st = st->priv_data; rtsp_st->sdp_ip = sdp_ip; rtsp_st->sdp_ttl = ttl; } break; case 's': av_metadata_set(&s->metadata, ""title"", p); break; case 'i': if (s->nb_streams == 0) { av_metadata_set(&s->metadata, ""comment"", p); break; } break; case 'm': s1->skip_media = 0; get_word(st_type, sizeof(st_type), &p); if (!strcmp(st_type, ""audio"")) { codec_type = CODEC_TYPE_AUDIO; } else if (!strcmp(st_type, ""video"")) { codec_type = CODEC_TYPE_VIDEO; } else if (!strcmp(st_type, ""application"")) { codec_type = CODEC_TYPE_DATA; } else { s1->skip_media = 1; return; } rtsp_st = av_mallocz(sizeof(RTSPStream)); if (!rtsp_st) return; rtsp_st->stream_index = -1; dynarray_add(&rt->rtsp_streams, &rt->nb_rtsp_streams, rtsp_st); rtsp_st->sdp_ip = s1->default_ip; rtsp_st->sdp_ttl = s1->default_ttl; get_word(buf1, sizeof(buf1), &p); rtsp_st->sdp_port = atoi(buf1); get_word(buf1, sizeof(buf1), &p); get_word(buf1, sizeof(buf1), &p); rtsp_st->sdp_payload_type = atoi(buf1); if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), ""MP2T"")) { } else { st = av_new_stream(s, 0); if (!st) return; st->priv_data = rtsp_st; rtsp_st->stream_index = st->index; st->codec->codec_type = codec_type; if (rtsp_st->sdp_payload_type < RTP_PT_PRIVATE) { ff_rtp_get_codec_info(st->codec, rtsp_st->sdp_payload_type); } } av_strlcpy(rtsp_st->control_url, rt->control_uri, sizeof(rtsp_st->control_url)); break; case 'a': if (av_strstart(p, ""control:"", &p)) { if (s->nb_streams == 0) { if (!strncmp(p, ""rtsp://"", 7)) av_strlcpy(rt->control_uri, p, sizeof(rt->control_uri)); } else { char proto[32]; st = s->streams[s->nb_streams - 1]; rtsp_st = st->priv_data; ff_url_split(proto, sizeof(proto), NULL, 0, NULL, 0, NULL, NULL, 0, p); if (proto[0] == '\0') { if (rtsp_st->control_url[strlen(rtsp_st->control_url)-1]!='/') av_strlcat(rtsp_st->control_url, ""/"", sizeof(rtsp_st->control_url)); av_strlcat(rtsp_st->control_url, p, sizeof(rtsp_st->control_url)); } else av_strlcpy(rtsp_st->control_url, p, sizeof(rtsp_st->control_url)); } } else if (av_strstart(p, ""rtpmap:"", &p) && s->nb_streams > 0) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); st = s->streams[s->nb_streams - 1]; rtsp_st = st->priv_data; sdp_parse_rtpmap(s, st->codec, rtsp_st, payload_type, p); } else if (av_strstart(p, ""fmtp:"", &p)) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; rtsp_st = st->priv_data; if (rtsp_st->sdp_payload_type == payload_type) { if (!(rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line && rtsp_st->dynamic_handler->parse_sdp_a_line(s, i, rtsp_st->dynamic_protocol_context, buf))) sdp_parse_fmtp(st, p); } } } else if (av_strstart(p, ""framesize:"", &p)) { get_word(buf1, sizeof(buf1), &p); payload_type = atoi(buf1); for (i = 0; i < s->nb_streams; i++) { st = s->streams[i]; rtsp_st = st->priv_data; if (rtsp_st->sdp_payload_type == payload_type && rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) rtsp_st->dynamic_handler->parse_sdp_a_line(s, i, rtsp_st->dynamic_protocol_context, buf); } } else if (av_strstart(p, ""range:"", &p)) { int64_t start, end; rtsp_parse_range_npt(p, &start, &end); s->start_time = start; s->duration = (end == AV_NOPTS_VALUE) ? AV_NOPTS_VALUE : end - start; } else if (av_strstart(p, ""IsRealDataType:integer;"",&p)) { if (atoi(p) == 1) rt->transport = RTSP_TRANSPORT_RDT; } else { if (rt->server_type == RTSP_SERVER_WMS) ff_wms_parse_sdp_a_line(s, p); if (s->nb_streams > 0) { if (rt->server_type == RTSP_SERVER_REAL) ff_real_parse_sdp_a_line(s, s->nb_streams - 1, p); rtsp_st = s->streams[s->nb_streams - 1]->priv_data; if (rtsp_st->dynamic_handler && rtsp_st->dynamic_handler->parse_sdp_a_line) rtsp_st->dynamic_handler->parse_sdp_a_line(s, s->nb_streams - 1, rtsp_st->dynamic_protocol_context, buf); } } break; } }"
9243----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_0050b58a796d2d103174eafa6406837e6692556f_1.json----TIFFFillTile,"int TIFFFillTile(TIFF* tif, uint32 tile) { static const char module[] = ""TIFFFillTile""; TIFFDirectory *td = &tif->tif_dir; if ((tif->tif_flags&TIFF_NOREADRAW)==0) { uint64 bytecount = TIFFGetStrileByteCount(tif, tile); <S2SV_StartVul> if ((int64)bytecount <= 0) { <S2SV_EndVul> #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, ""%I64u: Invalid tile byte count, tile %lu"", (unsigned __int64) bytecount, (unsigned long) tile); #else TIFFErrorExt(tif->tif_clientdata, module, ""%llu: Invalid tile byte count, tile %lu"", (unsigned long long) bytecount, (unsigned long) tile); #endif return (0); } if( bytecount > 1024 * 1024 ) { tmsize_t stripsize = TIFFTileSize(tif); if( stripsize != 0 && (bytecount - 4096) / 10 > (uint64)stripsize ) { uint64 newbytecount = (uint64)stripsize * 10 + 4096; <S2SV_StartVul> if( (int64)newbytecount >= 0 ) <S2SV_EndVul> { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFWarningExt(tif->tif_clientdata, module, ""Too large tile byte count %I64u, tile %lu. Limiting to %I64u"", (unsigned __int64) bytecount, (unsigned long) tile, (unsigned __int64) newbytecount); #else TIFFErrorExt(tif->tif_clientdata, module, ""Too large tile byte count %llu, tile %lu. Limiting to %llu"", (unsigned long long) bytecount, (unsigned long) tile, (unsigned long long) newbytecount); #endif bytecount = newbytecount; } } } if (isMapped(tif)) { if (bytecount > (uint64)tif->tif_size || TIFFGetStrileOffset(tif, tile) > (uint64)tif->tif_size - bytecount) { tif->tif_curtile = NOTILE; return (0); } } if (isMapped(tif) && (isFillOrder(tif, td->td_fillorder) || (tif->tif_flags & TIFF_NOBITREV))) { if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawdatasize = 0; } tif->tif_flags &= ~TIFF_MYBUFFER; tif->tif_rawdatasize = (tmsize_t)bytecount; tif->tif_rawdata = tif->tif_base + (tmsize_t)TIFFGetStrileOffset(tif, tile); tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = (tmsize_t) bytecount; tif->tif_flags |= TIFF_BUFFERMMAP; } else { tmsize_t bytecountm; bytecountm=(tmsize_t)bytecount; if ((uint64)bytecountm!=bytecount) { TIFFErrorExt(tif->tif_clientdata,module,""Integer overflow""); return(0); } if (bytecountm > tif->tif_rawdatasize) { tif->tif_curtile = NOTILE; if ((tif->tif_flags & TIFF_MYBUFFER) == 0) { TIFFErrorExt(tif->tif_clientdata, module, ""Data buffer too small to hold tile %lu"", (unsigned long) tile); return (0); } } if (tif->tif_flags&TIFF_BUFFERMMAP) { tif->tif_curtile = NOTILE; tif->tif_rawdata = NULL; tif->tif_rawdatasize = 0; tif->tif_flags &= ~TIFF_BUFFERMMAP; } if( isMapped(tif) ) { if (bytecountm > tif->tif_rawdatasize && !TIFFReadBufferSetup(tif, 0, bytecountm)) { return (0); } if (TIFFReadRawTile1(tif, tile, tif->tif_rawdata, bytecountm, module) != bytecountm) { return (0); } } else { if (TIFFReadRawStripOrTile2(tif, tile, 0, bytecountm, module) != bytecountm) { return (0); } } tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = bytecountm; if (tif->tif_rawdata != NULL && !isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(tif->tif_rawdata, tif->tif_rawdataloaded); } } return (TIFFStartTile(tif, tile)); }","- if ((int64)bytecount <= 0) {
- if( (int64)newbytecount >= 0 )
+ if( bytecount == 0 || bytecount > (uint64)TIFF_INT64_MAX ) {
+ if( newbytecount == 0 || newbytecount > (uint64)TIFF_INT64_MAX )","int TIFFFillTile(TIFF* tif, uint32 tile) { static const char module[] = ""TIFFFillTile""; TIFFDirectory *td = &tif->tif_dir; if ((tif->tif_flags&TIFF_NOREADRAW)==0) { uint64 bytecount = TIFFGetStrileByteCount(tif, tile); if( bytecount == 0 || bytecount > (uint64)TIFF_INT64_MAX ) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFErrorExt(tif->tif_clientdata, module, ""%I64u: Invalid tile byte count, tile %lu"", (unsigned __int64) bytecount, (unsigned long) tile); #else TIFFErrorExt(tif->tif_clientdata, module, ""%llu: Invalid tile byte count, tile %lu"", (unsigned long long) bytecount, (unsigned long) tile); #endif return (0); } if( bytecount > 1024 * 1024 ) { tmsize_t stripsize = TIFFTileSize(tif); if( stripsize != 0 && (bytecount - 4096) / 10 > (uint64)stripsize ) { uint64 newbytecount = (uint64)stripsize * 10 + 4096; if( newbytecount == 0 || newbytecount > (uint64)TIFF_INT64_MAX ) { #if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__)) TIFFWarningExt(tif->tif_clientdata, module, ""Too large tile byte count %I64u, tile %lu. Limiting to %I64u"", (unsigned __int64) bytecount, (unsigned long) tile, (unsigned __int64) newbytecount); #else TIFFErrorExt(tif->tif_clientdata, module, ""Too large tile byte count %llu, tile %lu. Limiting to %llu"", (unsigned long long) bytecount, (unsigned long) tile, (unsigned long long) newbytecount); #endif bytecount = newbytecount; } } } if (isMapped(tif)) { if (bytecount > (uint64)tif->tif_size || TIFFGetStrileOffset(tif, tile) > (uint64)tif->tif_size - bytecount) { tif->tif_curtile = NOTILE; return (0); } } if (isMapped(tif) && (isFillOrder(tif, td->td_fillorder) || (tif->tif_flags & TIFF_NOBITREV))) { if ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) { _TIFFfree(tif->tif_rawdata); tif->tif_rawdata = NULL; tif->tif_rawdatasize = 0; } tif->tif_flags &= ~TIFF_MYBUFFER; tif->tif_rawdatasize = (tmsize_t)bytecount; tif->tif_rawdata = tif->tif_base + (tmsize_t)TIFFGetStrileOffset(tif, tile); tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = (tmsize_t) bytecount; tif->tif_flags |= TIFF_BUFFERMMAP; } else { tmsize_t bytecountm; bytecountm=(tmsize_t)bytecount; if ((uint64)bytecountm!=bytecount) { TIFFErrorExt(tif->tif_clientdata,module,""Integer overflow""); return(0); } if (bytecountm > tif->tif_rawdatasize) { tif->tif_curtile = NOTILE; if ((tif->tif_flags & TIFF_MYBUFFER) == 0) { TIFFErrorExt(tif->tif_clientdata, module, ""Data buffer too small to hold tile %lu"", (unsigned long) tile); return (0); } } if (tif->tif_flags&TIFF_BUFFERMMAP) { tif->tif_curtile = NOTILE; tif->tif_rawdata = NULL; tif->tif_rawdatasize = 0; tif->tif_flags &= ~TIFF_BUFFERMMAP; } if( isMapped(tif) ) { if (bytecountm > tif->tif_rawdatasize && !TIFFReadBufferSetup(tif, 0, bytecountm)) { return (0); } if (TIFFReadRawTile1(tif, tile, tif->tif_rawdata, bytecountm, module) != bytecountm) { return (0); } } else { if (TIFFReadRawStripOrTile2(tif, tile, 0, bytecountm, module) != bytecountm) { return (0); } } tif->tif_rawdataoff = 0; tif->tif_rawdataloaded = bytecountm; if (tif->tif_rawdata != NULL && !isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(tif->tif_rawdata, tif->tif_rawdataloaded); } } return (TIFFStartTile(tif, tile)); }"
8954----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_ed8a85d8451e5b6e1158e0cce60cdfadce2614d7_1.json----put_rv40_qpel8_mc33_c,"static void put_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, int stride){ <S2SV_StartVul> put_pixels8_xy2_c(dst, src, stride, 8); <S2SV_EndVul> }","- put_pixels8_xy2_c(dst, src, stride, 8);
+ put_pixels8_xy2_8_c(dst, src, stride, 8);","static void put_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, int stride){ put_pixels8_xy2_8_c(dst, src, stride, 8); }"
3855----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ceb64ee8c1d5782b50f151565d10a03e544c3483_1.json----mxf_set_audio_pts,"static int mxf_set_audio_pts(MXFContext *mxf, AVCodecContext *codec, AVPacket *pkt) { MXFTrack *track = mxf->fc->streams[pkt->stream_index]->priv_data; pkt->pts = track->sample_count; if (codec->channels <= 0 || av_get_bits_per_sample(codec->codec_id) <= 0) return AVERROR(EINVAL); <S2SV_StartVul> track->sample_count += pkt->size / (codec->channels * av_get_bits_per_sample(codec->codec_id) / 8); <S2SV_EndVul> return 0; }","- track->sample_count += pkt->size / (codec->channels * av_get_bits_per_sample(codec->codec_id) / 8);
+ track->sample_count += pkt->size / (codec->channels * (int64_t)av_get_bits_per_sample(codec->codec_id) / 8);","static int mxf_set_audio_pts(MXFContext *mxf, AVCodecContext *codec, AVPacket *pkt) { MXFTrack *track = mxf->fc->streams[pkt->stream_index]->priv_data; pkt->pts = track->sample_count; if (codec->channels <= 0 || av_get_bits_per_sample(codec->codec_id) <= 0) return AVERROR(EINVAL); track->sample_count += pkt->size / (codec->channels * (int64_t)av_get_bits_per_sample(codec->codec_id) / 8); return 0; }"
10010----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_6b974c261e83553fcd4c26f7f32b90e6893e4049_1.json----ngx_http_variable_realpath_root,"static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) { size_t len; ngx_str_t path; ngx_http_core_loc_conf_t *clcf; <S2SV_StartVul> u_char real[NGX_MAX_PATH]; <S2SV_EndVul> clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (clcf->root_lengths == NULL) { path = clcf->root; } else { if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 1, clcf->root_values->elts) == NULL) { return NGX_ERROR; } path.data[path.len - 1] = '\0'; if (ngx_conf_full_name((ngx_cycle_t *) ngx_cycle, &path, 0) != NGX_OK) { return NGX_ERROR; } } <S2SV_StartVul> if (ngx_realpath(path.data, real) == NULL) { <S2SV_EndVul> ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, ngx_realpath_n "" \""%s\"" failed"", path.data); return NGX_ERROR; } len = ngx_strlen(real); v->data = ngx_pnalloc(r->pool, len); if (v->data == NULL) { return NGX_ERROR; } v->len = len; v->valid = 1; v->no_cacheable = 0; v->not_found = 0; ngx_memcpy(v->data, real, len); return NGX_OK; }","- u_char real[NGX_MAX_PATH];
- if (ngx_realpath(path.data, real) == NULL) {
+ u_char *real;
+ #if (NGX_HAVE_MAX_PATH)
+ u_char buffer[NGX_MAX_PATH];
+ #endif
+ #if (NGX_HAVE_MAX_PATH)
+ real = buffer;
+ #else
+ real = NULL;
+ #endif
+ real = ngx_realpath(path.data, real);
+ if (real == NULL) {
+ #if !(NGX_HAVE_MAX_PATH)
+ ngx_free(real);
+ #endif
+ #if !(NGX_HAVE_MAX_PATH)
+ ngx_free(real);
+ #endif","static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r, ngx_http_variable_value_t *v, uintptr_t data) { u_char *real; size_t len; ngx_str_t path; ngx_http_core_loc_conf_t *clcf; #if (NGX_HAVE_MAX_PATH) u_char buffer[NGX_MAX_PATH]; #endif clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module); if (clcf->root_lengths == NULL) { path = clcf->root; } else { if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 1, clcf->root_values->elts) == NULL) { return NGX_ERROR; } path.data[path.len - 1] = '\0'; if (ngx_conf_full_name((ngx_cycle_t *) ngx_cycle, &path, 0) != NGX_OK) { return NGX_ERROR; } } #if (NGX_HAVE_MAX_PATH) real = buffer; #else real = NULL; #endif real = ngx_realpath(path.data, real); if (real == NULL) { ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno, ngx_realpath_n "" \""%s\"" failed"", path.data); return NGX_ERROR; } len = ngx_strlen(real); v->data = ngx_pnalloc(r->pool, len); if (v->data == NULL) { #if !(NGX_HAVE_MAX_PATH) ngx_free(real); #endif return NGX_ERROR; } v->len = len; v->valid = 1; v->no_cacheable = 0; v->not_found = 0; ngx_memcpy(v->data, real, len); #if !(NGX_HAVE_MAX_PATH) ngx_free(real); #endif return NGX_OK; }"
6053----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_40c55758b2fa171cb0d0b7e519ca75e01d62b1df_1.json----ff_vorbis_len2vlc,"<S2SV_StartVul> int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, uint_fast32_t num) <S2SV_EndVul> { uint_fast32_t exit_at_level[33] = { 404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; <S2SV_StartVul> uint_fast8_t i, j; <S2SV_EndVul> <S2SV_StartVul> uint_fast32_t code, p; <S2SV_EndVul> #ifdef V_DEBUG GetBitContext gb; #endif for (p = 0; (bits[p] == 0) && (p < num); ++p) ; if (p == num) { return 0; } codes[p] = 0; if (bits[p] > 32) return 1; for (i = 0; i < bits[p]; ++i) exit_at_level[i+1] = 1 << i; #ifdef V_DEBUG <S2SV_StartVul> av_log(NULL, AV_LOG_INFO, "" %d. of %d code len %d code %d - "", p, num, bits[p], codes[p]); <S2SV_EndVul> <S2SV_StartVul> init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]); <S2SV_EndVul> for (i = 0; i < bits[p]; ++i) av_log(NULL, AV_LOG_INFO, ""%s"", get_bits1(&gb) ? ""1"" : ""0""); av_log(NULL, AV_LOG_INFO, ""\n""); #endif ++p; for (; p < num; ++p) { if (bits[p] > 32) return 1; if (bits[p] == 0) continue; for (i = bits[p]; i > 0; --i) if (exit_at_level[i]) break; if (!i) return 1; code = exit_at_level[i]; exit_at_level[i] = 0; for (j = i + 1 ;j <= bits[p]; ++j) exit_at_level[j] = code + (1 << (j - 1)); codes[p] = code; #ifdef V_DEBUG av_log(NULL, AV_LOG_INFO, "" %d. code len %d code %d - "", p, bits[p], codes[p]); init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]); for (i = 0; i < bits[p]; ++i) av_log(NULL, AV_LOG_INFO, ""%s"", get_bits1(&gb) ? ""1"" : ""0""); av_log(NULL, AV_LOG_INFO, ""\n""); #endif } for (p = 1; p < 33; p++) if (exit_at_level[p]) return 1; return 0; }","- int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, uint_fast32_t num)
- uint_fast8_t i, j;
- uint_fast32_t code, p;
- av_log(NULL, AV_LOG_INFO, "" %d. of %d code len %d code %d - "", p, num, bits[p], codes[p]);
- init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]);
+ int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, unsigned num)
+ unsigned i, j, p, code;
+ av_log(NULL, AV_LOG_INFO, "" %u. of %u code len %d code %d - "", p, num, bits[p], codes[p]);
+ init_get_bits(&gb, (uint8_t *)&codes[p], bits[p]);","int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, unsigned num) { uint_fast32_t exit_at_level[33] = { 404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; unsigned i, j, p, code; #ifdef V_DEBUG GetBitContext gb; #endif for (p = 0; (bits[p] == 0) && (p < num); ++p) ; if (p == num) { return 0; } codes[p] = 0; if (bits[p] > 32) return 1; for (i = 0; i < bits[p]; ++i) exit_at_level[i+1] = 1 << i; #ifdef V_DEBUG av_log(NULL, AV_LOG_INFO, "" %u. of %u code len %d code %d - "", p, num, bits[p], codes[p]); init_get_bits(&gb, (uint8_t *)&codes[p], bits[p]); for (i = 0; i < bits[p]; ++i) av_log(NULL, AV_LOG_INFO, ""%s"", get_bits1(&gb) ? ""1"" : ""0""); av_log(NULL, AV_LOG_INFO, ""\n""); #endif ++p; for (; p < num; ++p) { if (bits[p] > 32) return 1; if (bits[p] == 0) continue; for (i = bits[p]; i > 0; --i) if (exit_at_level[i]) break; if (!i) return 1; code = exit_at_level[i]; exit_at_level[i] = 0; for (j = i + 1 ;j <= bits[p]; ++j) exit_at_level[j] = code + (1 << (j - 1)); codes[p] = code; #ifdef V_DEBUG av_log(NULL, AV_LOG_INFO, "" %d. code len %d code %d - "", p, bits[p], codes[p]); init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]); for (i = 0; i < bits[p]; ++i) av_log(NULL, AV_LOG_INFO, ""%s"", get_bits1(&gb) ? ""1"" : ""0""); av_log(NULL, AV_LOG_INFO, ""\n""); #endif } for (p = 1; p < 33; p++) if (exit_at_level[p]) return 1; return 0; }"
17080----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_ee69f3f79b14cab8dd61fbd0ea5a999467ab6c04_1.json----crl2pkcs7_main,"int crl2pkcs7_main(int argc, char **argv) { BIO *in = NULL, *out = NULL; PKCS7 *p7 = NULL; PKCS7_SIGNED *p7s = NULL; STACK_OF(OPENSSL_STRING) *certflst = NULL; STACK_OF(X509) *cert_stack = NULL; STACK_OF(X509_CRL) *crl_stack = NULL; X509_CRL *crl = NULL; char *infile = NULL, *outfile = NULL, *prog, *certfile; int i = 0, informat = FORMAT_PEM, outformat = FORMAT_PEM, ret = 1, nocrl = 0; OPTION_CHOICE o; prog = opt_init(argc, argv, crl2pkcs7_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: opt_help(crl2pkcs7_options); ret = 0; goto end; case OPT_INFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat)) goto opthelp; break; case OPT_OUTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat)) goto opthelp; break; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; case OPT_NOCRL: nocrl = 1; break; case OPT_CERTFILE: if ((certflst == NULL) && (certflst = sk_OPENSSL_STRING_new_null()) == NULL) goto end; if (!sk_OPENSSL_STRING_push(certflst, *(++argv))) { sk_OPENSSL_STRING_free(certflst); goto end; } break; } } argc = opt_num_rest(); argv = opt_rest(); if (!app_load_modules(NULL)) goto end; if (!nocrl) { <S2SV_StartVul> in = bio_open_default(infile, RB(informat)); <S2SV_EndVul> if (in == NULL) goto end; if (informat == FORMAT_ASN1) crl = d2i_X509_CRL_bio(in, NULL); else if (informat == FORMAT_PEM) crl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL); if (crl == NULL) { BIO_printf(bio_err, ""unable to load CRL\n""); ERR_print_errors(bio_err); goto end; } } if ((p7 = PKCS7_new()) == NULL) goto end; if ((p7s = PKCS7_SIGNED_new()) == NULL) goto end; p7->type = OBJ_nid2obj(NID_pkcs7_signed); p7->d.sign = p7s; p7s->contents->type = OBJ_nid2obj(NID_pkcs7_data); if (!ASN1_INTEGER_set(p7s->version, 1)) goto end; if ((crl_stack = sk_X509_CRL_new_null()) == NULL) goto end; p7s->crl = crl_stack; if (crl != NULL) { sk_X509_CRL_push(crl_stack, crl); crl = NULL; } if ((cert_stack = sk_X509_new_null()) == NULL) goto end; p7s->cert = cert_stack; if (certflst) for (i = 0; i < sk_OPENSSL_STRING_num(certflst); i++) { certfile = sk_OPENSSL_STRING_value(certflst, i); if (add_certs_from_file(cert_stack, certfile) < 0) { BIO_printf(bio_err, ""error loading certificates\n""); ERR_print_errors(bio_err); goto end; } } sk_OPENSSL_STRING_free(certflst); <S2SV_StartVul> out = bio_open_default(outfile, WB(outformat)); <S2SV_EndVul> if (out == NULL) goto end; if (outformat == FORMAT_ASN1) i = i2d_PKCS7_bio(out, p7); else if (outformat == FORMAT_PEM) i = PEM_write_bio_PKCS7(out, p7); if (!i) { BIO_printf(bio_err, ""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } ret = 0; end: BIO_free(in); BIO_free_all(out); PKCS7_free(p7); X509_CRL_free(crl); return (ret); }","- in = bio_open_default(infile, RB(informat));
- out = bio_open_default(outfile, WB(outformat));
+ in = bio_open_default(infile, 'r', informat);
+ out = bio_open_default(outfile, 'w', outformat);","int crl2pkcs7_main(int argc, char **argv) { BIO *in = NULL, *out = NULL; PKCS7 *p7 = NULL; PKCS7_SIGNED *p7s = NULL; STACK_OF(OPENSSL_STRING) *certflst = NULL; STACK_OF(X509) *cert_stack = NULL; STACK_OF(X509_CRL) *crl_stack = NULL; X509_CRL *crl = NULL; char *infile = NULL, *outfile = NULL, *prog, *certfile; int i = 0, informat = FORMAT_PEM, outformat = FORMAT_PEM, ret = 1, nocrl = 0; OPTION_CHOICE o; prog = opt_init(argc, argv, crl2pkcs7_options); while ((o = opt_next()) != OPT_EOF) { switch (o) { case OPT_EOF: case OPT_ERR: opthelp: BIO_printf(bio_err, ""%s: Use -help for summary.\n"", prog); goto end; case OPT_HELP: opt_help(crl2pkcs7_options); ret = 0; goto end; case OPT_INFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat)) goto opthelp; break; case OPT_OUTFORM: if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat)) goto opthelp; break; case OPT_IN: infile = opt_arg(); break; case OPT_OUT: outfile = opt_arg(); break; case OPT_NOCRL: nocrl = 1; break; case OPT_CERTFILE: if ((certflst == NULL) && (certflst = sk_OPENSSL_STRING_new_null()) == NULL) goto end; if (!sk_OPENSSL_STRING_push(certflst, *(++argv))) { sk_OPENSSL_STRING_free(certflst); goto end; } break; } } argc = opt_num_rest(); argv = opt_rest(); if (!app_load_modules(NULL)) goto end; if (!nocrl) { in = bio_open_default(infile, 'r', informat); if (in == NULL) goto end; if (informat == FORMAT_ASN1) crl = d2i_X509_CRL_bio(in, NULL); else if (informat == FORMAT_PEM) crl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL); if (crl == NULL) { BIO_printf(bio_err, ""unable to load CRL\n""); ERR_print_errors(bio_err); goto end; } } if ((p7 = PKCS7_new()) == NULL) goto end; if ((p7s = PKCS7_SIGNED_new()) == NULL) goto end; p7->type = OBJ_nid2obj(NID_pkcs7_signed); p7->d.sign = p7s; p7s->contents->type = OBJ_nid2obj(NID_pkcs7_data); if (!ASN1_INTEGER_set(p7s->version, 1)) goto end; if ((crl_stack = sk_X509_CRL_new_null()) == NULL) goto end; p7s->crl = crl_stack; if (crl != NULL) { sk_X509_CRL_push(crl_stack, crl); crl = NULL; } if ((cert_stack = sk_X509_new_null()) == NULL) goto end; p7s->cert = cert_stack; if (certflst) for (i = 0; i < sk_OPENSSL_STRING_num(certflst); i++) { certfile = sk_OPENSSL_STRING_value(certflst, i); if (add_certs_from_file(cert_stack, certfile) < 0) { BIO_printf(bio_err, ""error loading certificates\n""); ERR_print_errors(bio_err); goto end; } } sk_OPENSSL_STRING_free(certflst); out = bio_open_default(outfile, 'w', outformat); if (out == NULL) goto end; if (outformat == FORMAT_ASN1) i = i2d_PKCS7_bio(out, p7); else if (outformat == FORMAT_PEM) i = PEM_write_bio_PKCS7(out, p7); if (!i) { BIO_printf(bio_err, ""unable to write pkcs7 object\n""); ERR_print_errors(bio_err); goto end; } ret = 0; end: BIO_free(in); BIO_free_all(out); PKCS7_free(p7); X509_CRL_free(crl); return (ret); }"
13348----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6cf2b5b5c24452a54b670c2e7d086ebab6b7f82b_1.json----sh_clearbit,"static void sh_clearbit(char *ptr, int list, unsigned char *table) { <S2SV_StartVul> int bit; <S2SV_EndVul> OPENSSL_assert(list >= 0 && list < sh.freelist_size); OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0); <S2SV_StartVul> bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list)); <S2SV_EndVul> OPENSSL_assert(bit > 0 && bit < sh.bittable_size); OPENSSL_assert(TESTBIT(table, bit)); CLEARBIT(table, bit); }","- int bit;
- bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));
+ size_t bit;
+ bit = (ONE << list) + ((ptr - sh.arena) / (sh.arena_size >> list));","static void sh_clearbit(char *ptr, int list, unsigned char *table) { size_t bit; OPENSSL_assert(list >= 0 && list < sh.freelist_size); OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0); bit = (ONE << list) + ((ptr - sh.arena) / (sh.arena_size >> list)); OPENSSL_assert(bit > 0 && bit < sh.bittable_size); OPENSSL_assert(TESTBIT(table, bit)); CLEARBIT(table, bit); }"
541----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1e0aa65feb017435bc208ba78307923fa3a0fe12_1.json----decode_mb_row_no_filter,"static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void *tdata, int jobnr, int threadnr, int is_vp7) { VP8Context *s = avctx->priv_data; VP8ThreadData *prev_td, *next_td, *td = &s->thread_data[threadnr]; <S2SV_StartVul> int mb_y = td->thread_mb_pos >> 16; <S2SV_EndVul> int mb_x, mb_xy = mb_y * s->mb_width; int num_jobs = s->num_jobs; VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame; VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)]; VP8Macroblock *mb; uint8_t *dst[3] = { curframe->tf.f->data[0] + 16 * mb_y * s->linesize, curframe->tf.f->data[1] + 8 * mb_y * s->uvlinesize, curframe->tf.f->data[2] + 8 * mb_y * s->uvlinesize }; if (c->end <= c->buffer && c->bits >= 0) return AVERROR_INVALIDDATA; if (mb_y == 0) prev_td = td; else prev_td = &s->thread_data[(jobnr + num_jobs - 1) % num_jobs]; if (mb_y == s->mb_height - 1) next_td = td; else next_td = &s->thread_data[(jobnr + 1) % num_jobs]; if (s->mb_layout == 1) mb = s->macroblocks_base + ((s->mb_width + 1) * (mb_y + 1) + 1); else { if (prev_frame && s->segmentation.enabled && !s->segmentation.update_map) ff_thread_await_progress(&prev_frame->tf, mb_y, 0); mb = s->macroblocks + (s->mb_height - mb_y - 1) * 2; memset(mb - 1, 0, sizeof(*mb)); AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED * 0x01010101); } if (!is_vp7 || mb_y == 0) memset(td->left_nnz, 0, sizeof(td->left_nnz)); s->mv_min.x = -MARGIN; s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN; for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) { if (c->end <= c->buffer && c->bits >= 0) return AVERROR_INVALIDDATA; if (prev_td != td) { if (threadnr != 0) { check_thread_pos(td, prev_td, mb_x + (is_vp7 ? 2 : 1), mb_y - (is_vp7 ? 2 : 1)); } else { check_thread_pos(td, prev_td, mb_x + (is_vp7 ? 2 : 1) + s->mb_width + 3, mb_y - (is_vp7 ? 2 : 1)); } } s->vdsp.prefetch(dst[0] + (mb_x & 3) * 4 * s->linesize + 64, s->linesize, 4); s->vdsp.prefetch(dst[1] + (mb_x & 7) * s->uvlinesize + 64, dst[2] - dst[1], 2); if (!s->mb_layout) decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy, prev_frame && prev_frame->seg_map ? prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS); if (!mb->skip) decode_mb_coeffs(s, td, c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7); if (mb->mode <= MODE_I4x4) intra_predict(s, td, dst, mb, mb_x, mb_y, is_vp7); else inter_predict(s, td, dst, mb, mb_x, mb_y); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN); if (!mb->skip) { idct_mb(s, td, dst, mb); } else { AV_ZERO64(td->left_nnz); AV_WN64(s->top_nnz[mb_x], 0); if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) { td->left_nnz[8] = 0; s->top_nnz[mb_x][8] = 0; } } if (s->deblock_filter) filter_level_for_mb(s, mb, &td->filter_strength[mb_x], is_vp7); if (s->deblock_filter && num_jobs != 1 && threadnr == num_jobs - 1) { if (s->filter.simple) backup_mb_border(s->top_border[mb_x + 1], dst[0], NULL, NULL, s->linesize, 0, 1); else backup_mb_border(s->top_border[mb_x + 1], dst[0], dst[1], dst[2], s->linesize, s->uvlinesize, 0); } prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2); dst[0] += 16; dst[1] += 8; dst[2] += 8; s->mv_min.x -= 64; s->mv_max.x -= 64; if (mb_x == s->mb_width + 1) { update_pos(td, mb_y, s->mb_width + 3); } else { update_pos(td, mb_y, mb_x); } } return 0; }","- int mb_y = td->thread_mb_pos >> 16;
+ int mb_y = atomic_load(&td->thread_mb_pos) >> 16;","static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void *tdata, int jobnr, int threadnr, int is_vp7) { VP8Context *s = avctx->priv_data; VP8ThreadData *prev_td, *next_td, *td = &s->thread_data[threadnr]; int mb_y = atomic_load(&td->thread_mb_pos) >> 16; int mb_x, mb_xy = mb_y * s->mb_width; int num_jobs = s->num_jobs; VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame; VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)]; VP8Macroblock *mb; uint8_t *dst[3] = { curframe->tf.f->data[0] + 16 * mb_y * s->linesize, curframe->tf.f->data[1] + 8 * mb_y * s->uvlinesize, curframe->tf.f->data[2] + 8 * mb_y * s->uvlinesize }; if (c->end <= c->buffer && c->bits >= 0) return AVERROR_INVALIDDATA; if (mb_y == 0) prev_td = td; else prev_td = &s->thread_data[(jobnr + num_jobs - 1) % num_jobs]; if (mb_y == s->mb_height - 1) next_td = td; else next_td = &s->thread_data[(jobnr + 1) % num_jobs]; if (s->mb_layout == 1) mb = s->macroblocks_base + ((s->mb_width + 1) * (mb_y + 1) + 1); else { if (prev_frame && s->segmentation.enabled && !s->segmentation.update_map) ff_thread_await_progress(&prev_frame->tf, mb_y, 0); mb = s->macroblocks + (s->mb_height - mb_y - 1) * 2; memset(mb - 1, 0, sizeof(*mb)); AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED * 0x01010101); } if (!is_vp7 || mb_y == 0) memset(td->left_nnz, 0, sizeof(td->left_nnz)); s->mv_min.x = -MARGIN; s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN; for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) { if (c->end <= c->buffer && c->bits >= 0) return AVERROR_INVALIDDATA; if (prev_td != td) { if (threadnr != 0) { check_thread_pos(td, prev_td, mb_x + (is_vp7 ? 2 : 1), mb_y - (is_vp7 ? 2 : 1)); } else { check_thread_pos(td, prev_td, mb_x + (is_vp7 ? 2 : 1) + s->mb_width + 3, mb_y - (is_vp7 ? 2 : 1)); } } s->vdsp.prefetch(dst[0] + (mb_x & 3) * 4 * s->linesize + 64, s->linesize, 4); s->vdsp.prefetch(dst[1] + (mb_x & 7) * s->uvlinesize + 64, dst[2] - dst[1], 2); if (!s->mb_layout) decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy, prev_frame && prev_frame->seg_map ? prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS); if (!mb->skip) decode_mb_coeffs(s, td, c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7); if (mb->mode <= MODE_I4x4) intra_predict(s, td, dst, mb, mb_x, mb_y, is_vp7); else inter_predict(s, td, dst, mb, mb_x, mb_y); prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN); if (!mb->skip) { idct_mb(s, td, dst, mb); } else { AV_ZERO64(td->left_nnz); AV_WN64(s->top_nnz[mb_x], 0); if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) { td->left_nnz[8] = 0; s->top_nnz[mb_x][8] = 0; } } if (s->deblock_filter) filter_level_for_mb(s, mb, &td->filter_strength[mb_x], is_vp7); if (s->deblock_filter && num_jobs != 1 && threadnr == num_jobs - 1) { if (s->filter.simple) backup_mb_border(s->top_border[mb_x + 1], dst[0], NULL, NULL, s->linesize, 0, 1); else backup_mb_border(s->top_border[mb_x + 1], dst[0], dst[1], dst[2], s->linesize, s->uvlinesize, 0); } prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2); dst[0] += 16; dst[1] += 8; dst[2] += 8; s->mv_min.x -= 64; s->mv_max.x -= 64; if (mb_x == s->mb_width + 1) { update_pos(td, mb_y, s->mb_width + 3); } else { update_pos(td, mb_y, mb_x); } } return 0; }"
16228----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d04190439d672a078adba166b7ec198d1ce89218_1.json----tls_process_client_certificate,"enum MSG_PROCESS_RETURN tls_process_client_certificate(SSL *s, PACKET *pkt) { <S2SV_StartVul> int i, al, ret = MSG_PROCESS_ERROR; <S2SV_EndVul> X509 *x = NULL; unsigned long l, llen; const unsigned char *certstart; unsigned char *certbytes; STACK_OF(X509) *sk = NULL; PACKET spkt; if ((sk = sk_X509_new_null()) == NULL) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE); goto f_err; } if (!PACKET_get_net_3(pkt, &llen) || !PACKET_get_sub_packet(pkt, &spkt, llen) || PACKET_remaining(pkt) != 0) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_LENGTH_MISMATCH); goto f_err; } while (PACKET_remaining(&spkt) > 0) { if (!PACKET_get_net_3(&spkt, &l) || !PACKET_get_bytes(&spkt, &certbytes, l)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH); goto f_err; } certstart = certbytes; x = d2i_X509(NULL, (const unsigned char **)&certbytes, l); if (x == NULL) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB); goto f_err; } if (certbytes != (certstart + l)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH); goto f_err; } if (!sk_X509_push(sk, x)) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE); goto f_err; } x = NULL; } if (sk_X509_num(sk) <= 0) { if (s->version == SSL3_VERSION) { al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_NO_CERTIFICATES_RETURNED); goto f_err; } else if ((s->verify_mode & SSL_VERIFY_PEER) && (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE); al = SSL_AD_HANDSHAKE_FAILURE; goto f_err; } if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s, 0)) { <S2SV_StartVul> al = SSL_AD_INTERNAL_ERROR; <S2SV_EndVul> goto f_err; } } else { EVP_PKEY *pkey; i = ssl_verify_cert_chain(s, sk); if (i <= 0) { al = ssl_verify_alarm_type(s->verify_result); SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_CERTIFICATE_VERIFY_FAILED); goto f_err; } if (i > 1) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, i); al = SSL_AD_HANDSHAKE_FAILURE; goto f_err; } pkey = X509_get_pubkey(sk_X509_value(sk, 0)); if (pkey == NULL) { al = SSL3_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE); goto f_err; } EVP_PKEY_free(pkey); } X509_free(s->session->peer); s->session->peer = sk_X509_shift(sk); s->session->verify_result = s->verify_result; sk_X509_pop_free(s->session->peer_chain, X509_free); s->session->peer_chain = sk; sk = NULL; ret = MSG_PROCESS_CONTINUE_READING; goto done; f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); ossl_statem_set_error(s); done: X509_free(x); sk_X509_pop_free(sk, X509_free); return ret; }","- int i, al, ret = MSG_PROCESS_ERROR;
- al = SSL_AD_INTERNAL_ERROR;
+ int i, al = SSL_AD_INTERNAL_ERROR, ret = MSG_PROCESS_ERROR;","enum MSG_PROCESS_RETURN tls_process_client_certificate(SSL *s, PACKET *pkt) { int i, al = SSL_AD_INTERNAL_ERROR, ret = MSG_PROCESS_ERROR; X509 *x = NULL; unsigned long l, llen; const unsigned char *certstart; unsigned char *certbytes; STACK_OF(X509) *sk = NULL; PACKET spkt; if ((sk = sk_X509_new_null()) == NULL) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE); goto f_err; } if (!PACKET_get_net_3(pkt, &llen) || !PACKET_get_sub_packet(pkt, &spkt, llen) || PACKET_remaining(pkt) != 0) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_LENGTH_MISMATCH); goto f_err; } while (PACKET_remaining(&spkt) > 0) { if (!PACKET_get_net_3(&spkt, &l) || !PACKET_get_bytes(&spkt, &certbytes, l)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH); goto f_err; } certstart = certbytes; x = d2i_X509(NULL, (const unsigned char **)&certbytes, l); if (x == NULL) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB); goto f_err; } if (certbytes != (certstart + l)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_CERT_LENGTH_MISMATCH); goto f_err; } if (!sk_X509_push(sk, x)) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE); goto f_err; } x = NULL; } if (sk_X509_num(sk) <= 0) { if (s->version == SSL3_VERSION) { al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_NO_CERTIFICATES_RETURNED); goto f_err; } else if ((s->verify_mode & SSL_VERIFY_PEER) && (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE); al = SSL_AD_HANDSHAKE_FAILURE; goto f_err; } if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s, 0)) { goto f_err; } } else { EVP_PKEY *pkey; i = ssl_verify_cert_chain(s, sk); if (i <= 0) { al = ssl_verify_alarm_type(s->verify_result); SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_CERTIFICATE_VERIFY_FAILED); goto f_err; } if (i > 1) { SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, i); al = SSL_AD_HANDSHAKE_FAILURE; goto f_err; } pkey = X509_get_pubkey(sk_X509_value(sk, 0)); if (pkey == NULL) { al = SSL3_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_UNKNOWN_CERTIFICATE_TYPE); goto f_err; } EVP_PKEY_free(pkey); } X509_free(s->session->peer); s->session->peer = sk_X509_shift(sk); s->session->verify_result = s->verify_result; sk_X509_pop_free(s->session->peer_chain, X509_free); s->session->peer_chain = sk; sk = NULL; ret = MSG_PROCESS_CONTINUE_READING; goto done; f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); ossl_statem_set_error(s); done: X509_free(x); sk_X509_pop_free(sk, X509_free); return ret; }"
988----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_35f3d8c35be1323afe8f230eecb35f9311405248_1.json----amf_parse_object,"static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, unsigned int max_pos, int depth) { AVCodecContext *acodec, *vcodec; ByteIOContext *ioc; AMFDataType amf_type; char str_val[256]; double num_val; num_val = 0; ioc = s->pb; amf_type = get_byte(ioc); switch(amf_type) { case AMF_DATA_TYPE_NUMBER: num_val = av_int2dbl(get_be64(ioc)); break; case AMF_DATA_TYPE_BOOL: num_val = get_byte(ioc); break; case AMF_DATA_TYPE_STRING: if(amf_get_string(ioc, str_val, sizeof(str_val)) < 0) return -1; break; case AMF_DATA_TYPE_OBJECT: { unsigned int keylen; while(url_ftell(ioc) < max_pos - 2 && (keylen = get_be16(ioc))) { url_fskip(ioc, keylen); if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0) return -1; } if(get_byte(ioc) != AMF_END_OF_OBJECT) return -1; } break; case AMF_DATA_TYPE_NULL: case AMF_DATA_TYPE_UNDEFINED: case AMF_DATA_TYPE_UNSUPPORTED: break; case AMF_DATA_TYPE_MIXEDARRAY: url_fskip(ioc, 4); while(url_ftell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) { if(amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0) return -1; } if(get_byte(ioc) != AMF_END_OF_OBJECT) return -1; break; case AMF_DATA_TYPE_ARRAY: { unsigned int arraylen, i; arraylen = get_be32(ioc); for(i = 0; i < arraylen && url_ftell(ioc) < max_pos - 1; i++) { if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0) return -1; } } break; case AMF_DATA_TYPE_DATE: url_fskip(ioc, 8 + 2); break; default: return -1; } if(depth == 1 && key) { acodec = astream ? astream->codec : NULL; vcodec = vstream ? vstream->codec : NULL; if(amf_type == AMF_DATA_TYPE_BOOL) { if(!strcmp(key, ""stereo"") && acodec) acodec->channels = num_val > 0 ? 2 : 1; } else if(amf_type == AMF_DATA_TYPE_NUMBER) { if(!strcmp(key, ""duration"")) s->duration = num_val * AV_TIME_BASE; <S2SV_StartVul> else if(!strcmp(key, ""audiocodecid"") && acodec) flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET); <S2SV_EndVul> <S2SV_StartVul> else if(!strcmp(key, ""videocodecid"") && vcodec) flv_set_video_codec(s, vstream, (int)num_val); <S2SV_EndVul> <S2SV_StartVul> else if(!strcmp(key, ""audiosamplesize"") && acodec && num_val >= 0) { <S2SV_EndVul> acodec->bits_per_sample = num_val; if(num_val == 8 && (acodec->codec_id == CODEC_ID_PCM_S16BE || acodec->codec_id == CODEC_ID_PCM_S16LE)) acodec->codec_id = CODEC_ID_PCM_S8; } else if(!strcmp(key, ""audiosamplerate"") && acodec && num_val >= 0) { if (!acodec->sample_rate) { switch((int)num_val) { case 44000: acodec->sample_rate = 44100 ; break; case 22000: acodec->sample_rate = 22050 ; break; case 11000: acodec->sample_rate = 11025 ; break; case 5000 : acodec->sample_rate = 5512 ; break; default : acodec->sample_rate = num_val; } } } } } return 0; }","- else if(!strcmp(key, ""audiocodecid"") && acodec) flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET);
- else if(!strcmp(key, ""videocodecid"") && vcodec) flv_set_video_codec(s, vstream, (int)num_val);
- else if(!strcmp(key, ""audiosamplesize"") && acodec && num_val >= 0) {
+ else if(!strcmp(key, ""audiocodecid"") && acodec && 0 <= (int)num_val)
+ flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET);
+ else if(!strcmp(key, ""videocodecid"") && vcodec && 0 <= (int)num_val)
+ flv_set_video_codec(s, vstream, (int)num_val);
+ else if(!strcmp(key, ""audiosamplesize"") && acodec && 0 < (int)num_val) {","static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, unsigned int max_pos, int depth) { AVCodecContext *acodec, *vcodec; ByteIOContext *ioc; AMFDataType amf_type; char str_val[256]; double num_val; num_val = 0; ioc = s->pb; amf_type = get_byte(ioc); switch(amf_type) { case AMF_DATA_TYPE_NUMBER: num_val = av_int2dbl(get_be64(ioc)); break; case AMF_DATA_TYPE_BOOL: num_val = get_byte(ioc); break; case AMF_DATA_TYPE_STRING: if(amf_get_string(ioc, str_val, sizeof(str_val)) < 0) return -1; break; case AMF_DATA_TYPE_OBJECT: { unsigned int keylen; while(url_ftell(ioc) < max_pos - 2 && (keylen = get_be16(ioc))) { url_fskip(ioc, keylen); if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0) return -1; } if(get_byte(ioc) != AMF_END_OF_OBJECT) return -1; } break; case AMF_DATA_TYPE_NULL: case AMF_DATA_TYPE_UNDEFINED: case AMF_DATA_TYPE_UNSUPPORTED: break; case AMF_DATA_TYPE_MIXEDARRAY: url_fskip(ioc, 4); while(url_ftell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) { if(amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0) return -1; } if(get_byte(ioc) != AMF_END_OF_OBJECT) return -1; break; case AMF_DATA_TYPE_ARRAY: { unsigned int arraylen, i; arraylen = get_be32(ioc); for(i = 0; i < arraylen && url_ftell(ioc) < max_pos - 1; i++) { if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0) return -1; } } break; case AMF_DATA_TYPE_DATE: url_fskip(ioc, 8 + 2); break; default: return -1; } if(depth == 1 && key) { acodec = astream ? astream->codec : NULL; vcodec = vstream ? vstream->codec : NULL; if(amf_type == AMF_DATA_TYPE_BOOL) { if(!strcmp(key, ""stereo"") && acodec) acodec->channels = num_val > 0 ? 2 : 1; } else if(amf_type == AMF_DATA_TYPE_NUMBER) { if(!strcmp(key, ""duration"")) s->duration = num_val * AV_TIME_BASE; else if(!strcmp(key, ""audiocodecid"") && acodec && 0 <= (int)num_val) flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET); else if(!strcmp(key, ""videocodecid"") && vcodec && 0 <= (int)num_val) flv_set_video_codec(s, vstream, (int)num_val); else if(!strcmp(key, ""audiosamplesize"") && acodec && 0 < (int)num_val) { acodec->bits_per_sample = num_val; if(num_val == 8 && (acodec->codec_id == CODEC_ID_PCM_S16BE || acodec->codec_id == CODEC_ID_PCM_S16LE)) acodec->codec_id = CODEC_ID_PCM_S8; } else if(!strcmp(key, ""audiosamplerate"") && acodec && num_val >= 0) { if (!acodec->sample_rate) { switch((int)num_val) { case 44000: acodec->sample_rate = 44100 ; break; case 22000: acodec->sample_rate = 22050 ; break; case 11000: acodec->sample_rate = 11025 ; break; case 5000 : acodec->sample_rate = 5512 ; break; default : acodec->sample_rate = num_val; } } } } } return 0; }"
11205----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_21ad2f506edd48898282bcedd3657df4b80d45f5_1.json----ts_get_status_text,"static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text) { int i; <S2SV_StartVul> unsigned int length = 0; <S2SV_EndVul> char *result = NULL; char *p; for (i = 0; i < sk_ASN1_UTF8STRING_num(text); ++i) { ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i); length += ASN1_STRING_length(current); length += 1; } if ((result = OPENSSL_malloc(length)) == NULL) { TSerr(TS_F_TS_GET_STATUS_TEXT, ERR_R_MALLOC_FAILURE); return NULL; } for (i = 0, p = result; i < sk_ASN1_UTF8STRING_num(text); ++i) { ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i); length = ASN1_STRING_length(current); if (i > 0) *p++ = '/'; strncpy(p, (const char *)ASN1_STRING_data(current), length); p += length; } *p = '\0'; return result; }","- unsigned int length = 0;
+ int length = 0;
+ if (ASN1_STRING_length(current) > TS_MAX_STATUS_LENGTH - length - 1)
+ return NULL;","static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text) { int i; int length = 0; char *result = NULL; char *p; for (i = 0; i < sk_ASN1_UTF8STRING_num(text); ++i) { ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i); if (ASN1_STRING_length(current) > TS_MAX_STATUS_LENGTH - length - 1) return NULL; length += ASN1_STRING_length(current); length += 1; } if ((result = OPENSSL_malloc(length)) == NULL) { TSerr(TS_F_TS_GET_STATUS_TEXT, ERR_R_MALLOC_FAILURE); return NULL; } for (i = 0, p = result; i < sk_ASN1_UTF8STRING_num(text); ++i) { ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i); length = ASN1_STRING_length(current); if (i > 0) *p++ = '/'; strncpy(p, (const char *)ASN1_STRING_data(current), length); p += length; } *p = '\0'; return result; }"
15977----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c84d95cf53304b2647bf1dda1122ee665bdd3a35_1.json----do_EC_KEY_print,"static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype) { const char *ecstr; unsigned char *priv = NULL, *pub = NULL; size_t privlen = 0, publen = 0; int ret = 0; const EC_GROUP *group; if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) { ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_PASSED_NULL_PARAMETER); return 0; } <S2SV_StartVul> if (ktype != EC_KEY_PRINT_PARAM) { <S2SV_EndVul> publen = EC_KEY_key2buf(x, EC_KEY_get_conv_form(x), &pub, NULL); if (publen == 0) goto err; } if (ktype == EC_KEY_PRINT_PRIVATE && EC_KEY_get0_private_key(x) != NULL) { privlen = EC_KEY_priv2buf(x, &priv); if (privlen == 0) goto err; } if (ktype == EC_KEY_PRINT_PRIVATE) ecstr = ""Private-Key""; else if (ktype == EC_KEY_PRINT_PUBLIC) ecstr = ""Public-Key""; else ecstr = ""ECDSA-Parameters""; if (!BIO_indent(bp, off, 128)) goto err; if (BIO_printf(bp, ""%s: (%d bit)\n"", ecstr, EC_GROUP_order_bits(group)) <= 0) goto err; if (privlen != 0) { if (BIO_printf(bp, ""%*spriv:\n"", off, """") <= 0) goto err; if (ASN1_buf_print(bp, priv, privlen, off + 4) == 0) goto err; } if (publen != 0) { if (BIO_printf(bp, ""%*spub:\n"", off, """") <= 0) goto err; if (ASN1_buf_print(bp, pub, publen, off + 4) == 0) goto err; } if (!ECPKParameters_print(bp, group, off)) goto err; ret = 1; err: if (!ret) ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_EC_LIB); OPENSSL_clear_free(priv, privlen); OPENSSL_free(pub); return ret; }","- if (ktype != EC_KEY_PRINT_PARAM) {
+ if (ktype != EC_KEY_PRINT_PARAM && EC_KEY_get0_public_key(x) != NULL) {","static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype) { const char *ecstr; unsigned char *priv = NULL, *pub = NULL; size_t privlen = 0, publen = 0; int ret = 0; const EC_GROUP *group; if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) { ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_PASSED_NULL_PARAMETER); return 0; } if (ktype != EC_KEY_PRINT_PARAM && EC_KEY_get0_public_key(x) != NULL) { publen = EC_KEY_key2buf(x, EC_KEY_get_conv_form(x), &pub, NULL); if (publen == 0) goto err; } if (ktype == EC_KEY_PRINT_PRIVATE && EC_KEY_get0_private_key(x) != NULL) { privlen = EC_KEY_priv2buf(x, &priv); if (privlen == 0) goto err; } if (ktype == EC_KEY_PRINT_PRIVATE) ecstr = ""Private-Key""; else if (ktype == EC_KEY_PRINT_PUBLIC) ecstr = ""Public-Key""; else ecstr = ""ECDSA-Parameters""; if (!BIO_indent(bp, off, 128)) goto err; if (BIO_printf(bp, ""%s: (%d bit)\n"", ecstr, EC_GROUP_order_bits(group)) <= 0) goto err; if (privlen != 0) { if (BIO_printf(bp, ""%*spriv:\n"", off, """") <= 0) goto err; if (ASN1_buf_print(bp, priv, privlen, off + 4) == 0) goto err; } if (publen != 0) { if (BIO_printf(bp, ""%*spub:\n"", off, """") <= 0) goto err; if (ASN1_buf_print(bp, pub, publen, off + 4) == 0) goto err; } if (!ECPKParameters_print(bp, group, off)) goto err; ret = 1; err: if (!ret) ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_EC_LIB); OPENSSL_clear_free(priv, privlen); OPENSSL_free(pub); return ret; }"
9743----MEMORY_LEAK----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_cc89c456a3c35b9c712b83119d254599b1722135_1.json----JPEGFixupTagsSubsampling,"static void JPEGFixupTagsSubsampling(TIFF* tif) { static const char module[] = ""JPEGFixupTagsSubsampling""; struct JPEGFixupTagsSubsamplingData m; <S2SV_StartVul> _TIFFFillStriles( tif ); <S2SV_EndVul> <S2SV_StartVul> if( tif->tif_dir.td_stripbytecount == NULL <S2SV_EndVul> <S2SV_StartVul> || tif->tif_dir.td_stripoffset == NULL <S2SV_EndVul> <S2SV_StartVul> || tif->tif_dir.td_stripbytecount[0] == 0 ) <S2SV_EndVul> { return; } m.tif=tif; m.buffersize=2048; m.buffer=_TIFFmalloc(m.buffersize); if (m.buffer==NULL) { TIFFWarningExt(tif->tif_clientdata,module, ""Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped""); return; } m.buffercurrentbyte=NULL; m.bufferbytesleft=0; <S2SV_StartVul> m.fileoffset=tif->tif_dir.td_stripoffset[0]; <S2SV_EndVul> m.filepositioned=0; <S2SV_StartVul> m.filebytesleft=tif->tif_dir.td_stripbytecount[0]; <S2SV_EndVul> if (!JPEGFixupTagsSubsamplingSec(&m)) TIFFWarningExt(tif->tif_clientdata,module, ""Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-correcting skipped""); _TIFFfree(m.buffer); }","- _TIFFFillStriles( tif );
- if( tif->tif_dir.td_stripbytecount == NULL
- || tif->tif_dir.td_stripoffset == NULL
- || tif->tif_dir.td_stripbytecount[0] == 0 )
- m.fileoffset=tif->tif_dir.td_stripoffset[0];
- m.filebytesleft=tif->tif_dir.td_stripbytecount[0];
+ uint64 fileoffset = TIFFGetStrileOffset(tif, 0);
+ if( fileoffset == 0 )
+ m.fileoffset=fileoffset;
+ m.filebytesleft=TIFFGetStrileByteCount(tif, 0);","static void JPEGFixupTagsSubsampling(TIFF* tif) { static const char module[] = ""JPEGFixupTagsSubsampling""; struct JPEGFixupTagsSubsamplingData m; uint64 fileoffset = TIFFGetStrileOffset(tif, 0); if( fileoffset == 0 ) { return; } m.tif=tif; m.buffersize=2048; m.buffer=_TIFFmalloc(m.buffersize); if (m.buffer==NULL) { TIFFWarningExt(tif->tif_clientdata,module, ""Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped""); return; } m.buffercurrentbyte=NULL; m.bufferbytesleft=0; m.fileoffset=fileoffset; m.filepositioned=0; m.filebytesleft=TIFFGetStrileByteCount(tif, 0); if (!JPEGFixupTagsSubsamplingSec(&m)) TIFFWarningExt(tif->tif_clientdata,module, ""Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-correcting skipped""); _TIFFfree(m.buffer); }"
1225----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_425e74354b72b06df00443c1941054479671797b_1.json----avcodec_open2,"int attribute_align_arg avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options) { int ret = 0; AVDictionary *tmp = NULL; if (avcodec_is_open(avctx)) return 0; if ((!codec && !avctx->codec)) { av_log(avctx, AV_LOG_ERROR, ""No codec provided to avcodec_open2().\n""); return AVERROR(EINVAL); } if ((codec && avctx->codec && codec != avctx->codec)) { av_log(avctx, AV_LOG_ERROR, ""This AVCodecContext was allocated for %s, "" ""but %s passed to avcodec_open2().\n"", avctx->codec->name, codec->name); return AVERROR(EINVAL); } if (!codec) codec = avctx->codec; if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE) return AVERROR(EINVAL); if (options) av_dict_copy(&tmp, *options, 0); if (ff_lockmgr_cb) { if ((*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN)) return -1; } entangled_thread_counter++; if(entangled_thread_counter != 1){ av_log(avctx, AV_LOG_ERROR, ""insufficient thread locking around avcodec_open/close()\n""); ret = -1; goto end; } avctx->internal = av_mallocz(sizeof(AVCodecInternal)); if (!avctx->internal) { ret = AVERROR(ENOMEM); goto end; } if (codec->priv_data_size > 0) { if(!avctx->priv_data){ avctx->priv_data = av_mallocz(codec->priv_data_size); if (!avctx->priv_data) { ret = AVERROR(ENOMEM); goto end; } if (codec->priv_class) { *(const AVClass**)avctx->priv_data= codec->priv_class; av_opt_set_defaults(avctx->priv_data); } } if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0) goto free_and_end; } else { avctx->priv_data = NULL; } if ((ret = av_opt_set_dict(avctx, &tmp)) < 0) goto free_and_end; if (codec->capabilities & CODEC_CAP_EXPERIMENTAL) if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log(avctx, AV_LOG_ERROR, ""Codec is experimental but experimental codecs are not enabled, try -strict -2\n""); ret = -1; goto free_and_end; } if(!( avctx->coded_width && avctx->coded_height && avctx->width && avctx->height && avctx->codec_id == CODEC_ID_H264)){ if(avctx->coded_width && avctx->coded_height) avcodec_set_dimensions(avctx, avctx->coded_width, avctx->coded_height); else if(avctx->width && avctx->height) avcodec_set_dimensions(avctx, avctx->width, avctx->height); } if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height) && ( av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx) < 0 || av_image_check_size(avctx->width, avctx->height, 0, avctx) < 0)) { av_log(avctx, AV_LOG_WARNING, ""ignoring invalid width/height values\n""); avcodec_set_dimensions(avctx, 0, 0); } if (av_codec_is_decoder(codec)) av_freep(&avctx->subtitle_header); #define SANE_NB_CHANNELS 128U if (avctx->channels > SANE_NB_CHANNELS) { ret = AVERROR(EINVAL); goto free_and_end; } avctx->codec = codec; if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) && avctx->codec_id == CODEC_ID_NONE) { avctx->codec_type = codec->type; avctx->codec_id = codec->id; } if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) { av_log(avctx, AV_LOG_ERROR, ""codec type or id mismatches\n""); ret = AVERROR(EINVAL); goto free_and_end; } avctx->frame_number = 0; if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && (!avctx->time_base.num || !avctx->time_base.den)) { avctx->time_base.num = 1; avctx->time_base.den = avctx->sample_rate; } if (!HAVE_THREADS) av_log(avctx, AV_LOG_WARNING, ""Warning: not compiled with thread support, using thread emulation\n""); <S2SV_StartVul> if (HAVE_THREADS && !avctx->thread_opaque) { <S2SV_EndVul> ret = ff_thread_init(avctx); if (ret < 0) { goto free_and_end; } } if (!HAVE_THREADS && !(codec->capabilities & CODEC_CAP_AUTO_THREADS)) avctx->thread_count = 1; if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) { av_log(avctx, AV_LOG_ERROR, ""The maximum value for lowres supported by the decoder is %d\n"", avctx->codec->max_lowres); ret = AVERROR(EINVAL); goto free_and_end; } if (av_codec_is_encoder(avctx->codec)) { int i; if (avctx->codec->sample_fmts) { for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) if (avctx->sample_fmt == avctx->codec->sample_fmts[i]) break; if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) { av_log(avctx, AV_LOG_ERROR, ""Specified sample_fmt is not supported.\n""); ret = AVERROR(EINVAL); goto free_and_end; } } if (avctx->codec->pix_fmts) { for (i = 0; avctx->codec->pix_fmts[i] != PIX_FMT_NONE; i++) if (avctx->pix_fmt == avctx->codec->pix_fmts[i]) break; if (avctx->codec->pix_fmts[i] == PIX_FMT_NONE && !((avctx->codec_id == CODEC_ID_MJPEG || avctx->codec_id == CODEC_ID_LJPEG) && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) { av_log(avctx, AV_LOG_ERROR, ""Specified pix_fmt is not supported\n""); ret = AVERROR(EINVAL); goto free_and_end; } } if (avctx->codec->supported_samplerates) { for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++) if (avctx->sample_rate == avctx->codec->supported_samplerates[i]) break; if (avctx->codec->supported_samplerates[i] == 0) { av_log(avctx, AV_LOG_ERROR, ""Specified sample_rate is not supported\n""); ret = AVERROR(EINVAL); goto free_and_end; } } if (avctx->codec->channel_layouts) { if (!avctx->channel_layout) { av_log(avctx, AV_LOG_WARNING, ""channel_layout not specified\n""); } else { for (i = 0; avctx->codec->channel_layouts[i] != 0; i++) if (avctx->channel_layout == avctx->codec->channel_layouts[i]) break; if (avctx->codec->channel_layouts[i] == 0) { av_log(avctx, AV_LOG_ERROR, ""Specified channel_layout is not supported\n""); ret = AVERROR(EINVAL); goto free_and_end; } } } if (avctx->channel_layout && avctx->channels) { if (av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) { av_log(avctx, AV_LOG_ERROR, ""channel layout does not match number of channels\n""); ret = AVERROR(EINVAL); goto free_and_end; } } else if (avctx->channel_layout) { avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout); } } avctx->pts_correction_num_faulty_pts = avctx->pts_correction_num_faulty_dts = 0; avctx->pts_correction_last_pts = avctx->pts_correction_last_dts = INT64_MIN; <S2SV_StartVul> if(avctx->codec->init && !(avctx->active_thread_type&FF_THREAD_FRAME)){ <S2SV_EndVul> ret = avctx->codec->init(avctx); if (ret < 0) { goto free_and_end; } } ret=0; if (av_codec_is_decoder(avctx->codec)) { if (!avctx->bit_rate) avctx->bit_rate = get_bit_rate(avctx); if (avctx->channel_layout && av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) { av_log(avctx, AV_LOG_WARNING, ""channel layout does not match number of channels\n""); avctx->channel_layout = 0; } } end: entangled_thread_counter--; if (ff_lockmgr_cb) { (*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_RELEASE); } if (options) { av_dict_free(options); *options = tmp; } return ret; free_and_end: av_dict_free(&tmp); av_freep(&avctx->priv_data); av_freep(&avctx->internal); avctx->codec= NULL; goto end; }","- if (HAVE_THREADS && !avctx->thread_opaque) {
- if(avctx->codec->init && !(avctx->active_thread_type&FF_THREAD_FRAME)){
+ entangled_thread_counter--; //we will instanciate a few encoders thus kick the counter to prevent false detection of a problem
+ ret = ff_frame_thread_encoder_init(avctx);
+ entangled_thread_counter++;
+ if (ret < 0)
+ goto free_and_end;
+ if (HAVE_THREADS && !avctx->thread_opaque
+ && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {
+ if(avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME) || avctx->internal->frame_thread_encoder)){","int attribute_align_arg avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options) { int ret = 0; AVDictionary *tmp = NULL; if (avcodec_is_open(avctx)) return 0; if ((!codec && !avctx->codec)) { av_log(avctx, AV_LOG_ERROR, ""No codec provided to avcodec_open2().\n""); return AVERROR(EINVAL); } if ((codec && avctx->codec && codec != avctx->codec)) { av_log(avctx, AV_LOG_ERROR, ""This AVCodecContext was allocated for %s, "" ""but %s passed to avcodec_open2().\n"", avctx->codec->name, codec->name); return AVERROR(EINVAL); } if (!codec) codec = avctx->codec; if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE) return AVERROR(EINVAL); if (options) av_dict_copy(&tmp, *options, 0); if (ff_lockmgr_cb) { if ((*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN)) return -1; } entangled_thread_counter++; if(entangled_thread_counter != 1){ av_log(avctx, AV_LOG_ERROR, ""insufficient thread locking around avcodec_open/close()\n""); ret = -1; goto end; } avctx->internal = av_mallocz(sizeof(AVCodecInternal)); if (!avctx->internal) { ret = AVERROR(ENOMEM); goto end; } if (codec->priv_data_size > 0) { if(!avctx->priv_data){ avctx->priv_data = av_mallocz(codec->priv_data_size); if (!avctx->priv_data) { ret = AVERROR(ENOMEM); goto end; } if (codec->priv_class) { *(const AVClass**)avctx->priv_data= codec->priv_class; av_opt_set_defaults(avctx->priv_data); } } if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0) goto free_and_end; } else { avctx->priv_data = NULL; } if ((ret = av_opt_set_dict(avctx, &tmp)) < 0) goto free_and_end; if (codec->capabilities & CODEC_CAP_EXPERIMENTAL) if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) { av_log(avctx, AV_LOG_ERROR, ""Codec is experimental but experimental codecs are not enabled, try -strict -2\n""); ret = -1; goto free_and_end; } if(!( avctx->coded_width && avctx->coded_height && avctx->width && avctx->height && avctx->codec_id == CODEC_ID_H264)){ if(avctx->coded_width && avctx->coded_height) avcodec_set_dimensions(avctx, avctx->coded_width, avctx->coded_height); else if(avctx->width && avctx->height) avcodec_set_dimensions(avctx, avctx->width, avctx->height); } if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height) && ( av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx) < 0 || av_image_check_size(avctx->width, avctx->height, 0, avctx) < 0)) { av_log(avctx, AV_LOG_WARNING, ""ignoring invalid width/height values\n""); avcodec_set_dimensions(avctx, 0, 0); } if (av_codec_is_decoder(codec)) av_freep(&avctx->subtitle_header); #define SANE_NB_CHANNELS 128U if (avctx->channels > SANE_NB_CHANNELS) { ret = AVERROR(EINVAL); goto free_and_end; } avctx->codec = codec; if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) && avctx->codec_id == CODEC_ID_NONE) { avctx->codec_type = codec->type; avctx->codec_id = codec->id; } if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) { av_log(avctx, AV_LOG_ERROR, ""codec type or id mismatches\n""); ret = AVERROR(EINVAL); goto free_and_end; } avctx->frame_number = 0; if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && (!avctx->time_base.num || !avctx->time_base.den)) { avctx->time_base.num = 1; avctx->time_base.den = avctx->sample_rate; } if (!HAVE_THREADS) av_log(avctx, AV_LOG_WARNING, ""Warning: not compiled with thread support, using thread emulation\n""); entangled_thread_counter--; ret = ff_frame_thread_encoder_init(avctx); entangled_thread_counter++; if (ret < 0) goto free_and_end; if (HAVE_THREADS && !avctx->thread_opaque && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) { ret = ff_thread_init(avctx); if (ret < 0) { goto free_and_end; } } if (!HAVE_THREADS && !(codec->capabilities & CODEC_CAP_AUTO_THREADS)) avctx->thread_count = 1; if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) { av_log(avctx, AV_LOG_ERROR, ""The maximum value for lowres supported by the decoder is %d\n"", avctx->codec->max_lowres); ret = AVERROR(EINVAL); goto free_and_end; } if (av_codec_is_encoder(avctx->codec)) { int i; if (avctx->codec->sample_fmts) { for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++) if (avctx->sample_fmt == avctx->codec->sample_fmts[i]) break; if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) { av_log(avctx, AV_LOG_ERROR, ""Specified sample_fmt is not supported.\n""); ret = AVERROR(EINVAL); goto free_and_end; } } if (avctx->codec->pix_fmts) { for (i = 0; avctx->codec->pix_fmts[i] != PIX_FMT_NONE; i++) if (avctx->pix_fmt == avctx->codec->pix_fmts[i]) break; if (avctx->codec->pix_fmts[i] == PIX_FMT_NONE && !((avctx->codec_id == CODEC_ID_MJPEG || avctx->codec_id == CODEC_ID_LJPEG) && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) { av_log(avctx, AV_LOG_ERROR, ""Specified pix_fmt is not supported\n""); ret = AVERROR(EINVAL); goto free_and_end; } } if (avctx->codec->supported_samplerates) { for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++) if (avctx->sample_rate == avctx->codec->supported_samplerates[i]) break; if (avctx->codec->supported_samplerates[i] == 0) { av_log(avctx, AV_LOG_ERROR, ""Specified sample_rate is not supported\n""); ret = AVERROR(EINVAL); goto free_and_end; } } if (avctx->codec->channel_layouts) { if (!avctx->channel_layout) { av_log(avctx, AV_LOG_WARNING, ""channel_layout not specified\n""); } else { for (i = 0; avctx->codec->channel_layouts[i] != 0; i++) if (avctx->channel_layout == avctx->codec->channel_layouts[i]) break; if (avctx->codec->channel_layouts[i] == 0) { av_log(avctx, AV_LOG_ERROR, ""Specified channel_layout is not supported\n""); ret = AVERROR(EINVAL); goto free_and_end; } } } if (avctx->channel_layout && avctx->channels) { if (av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) { av_log(avctx, AV_LOG_ERROR, ""channel layout does not match number of channels\n""); ret = AVERROR(EINVAL); goto free_and_end; } } else if (avctx->channel_layout) { avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout); } } avctx->pts_correction_num_faulty_pts = avctx->pts_correction_num_faulty_dts = 0; avctx->pts_correction_last_pts = avctx->pts_correction_last_dts = INT64_MIN; if(avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME) || avctx->internal->frame_thread_encoder)){ ret = avctx->codec->init(avctx); if (ret < 0) { goto free_and_end; } } ret=0; if (av_codec_is_decoder(avctx->codec)) { if (!avctx->bit_rate) avctx->bit_rate = get_bit_rate(avctx); if (avctx->channel_layout && av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) { av_log(avctx, AV_LOG_WARNING, ""channel layout does not match number of channels\n""); avctx->channel_layout = 0; } } end: entangled_thread_counter--; if (ff_lockmgr_cb) { (*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_RELEASE); } if (options) { av_dict_free(options); *options = tmp; } return ret; free_and_end: av_dict_free(&tmp); av_freep(&avctx->priv_data); av_freep(&avctx->internal); avctx->codec= NULL; goto end; }"
3217----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_af19031ee648a35e08f4d4de56b3bf4cc9c5f402_1.json----ass_decode_init,"static av_cold int ass_decode_init(AVCodecContext *avctx) { avctx->subtitle_header = av_malloc(avctx->extradata_size); <S2SV_StartVul> if (!avctx->extradata) <S2SV_EndVul> return AVERROR(ENOMEM); memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size); avctx->subtitle_header_size = avctx->extradata_size; return 0; }","- if (!avctx->extradata)
+ if (!avctx->subtitle_header)","static av_cold int ass_decode_init(AVCodecContext *avctx) { avctx->subtitle_header = av_malloc(avctx->extradata_size); if (!avctx->subtitle_header) return AVERROR(ENOMEM); memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size); avctx->subtitle_header_size = avctx->extradata_size; return 0; }"
5960----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3b8a2c0f6ec12337ac0af726a7493247187134ad_1.json----ff_rtp_check_and_send_back_rr,"int ff_rtp_check_and_send_back_rr(RTPDemuxContext *s, URLContext *fd, AVIOContext *avio, int count) { AVIOContext *pb; uint8_t *buf; int len; int rtcp_bytes; RTPStatistics *stats = &s->statistics; uint32_t lost; uint32_t extended_max; uint32_t expected_interval; uint32_t received_interval; uint32_t lost_interval; uint32_t expected; uint32_t fraction; <S2SV_StartVul> uint64_t ntp_time = s->last_rtcp_ntp_time; if ((!fd && !avio) || (count < 1)) return -1; s->octet_count += count; rtcp_bytes = ((s->octet_count - s->last_octet_count) * RTCP_TX_RATIO_NUM) / RTCP_TX_RATIO_DEN; rtcp_bytes /= 50; if (rtcp_bytes < 28) return -1; s->last_octet_count = s->octet_count; if (!fd) pb = avio; else if (avio_open_dyn_buf(&pb) < 0) return -1; avio_w8(pb, (RTP_VERSION << 6) + 1); avio_w8(pb, RTCP_RR); avio_wb16(pb, 7); avio_wb32(pb, s->ssrc + 1); avio_wb32(pb, s->ssrc); extended_max = stats->cycles + stats->max_seq; expected = extended_max - stats->base_seq; lost = expected - stats->received; lost = FFMIN(lost, 0xffffff); expected_interval = expected - stats->expected_prior; stats->expected_prior = expected; received_interval = stats->received - stats->received_prior; stats->received_prior = stats->received; lost_interval = expected_interval - received_interval; if (expected_interval == 0 || lost_interval <= 0) fraction = 0; else fraction = (lost_interval << 8) / expected_interval; fraction = (fraction << 24) | lost; avio_wb32(pb, fraction); avio_wb32(pb, extended_max); avio_wb32(pb, stats->jitter >> 4); if (s->last_rtcp_ntp_time == AV_NOPTS_VALUE) { avio_wb32(pb, 0); avio_wb32(pb, 0); } else { uint32_t middle_32_bits = s->last_rtcp_ntp_time >> 16; <S2SV_StartVul> uint32_t delay_since_last = ntp_time - s->last_rtcp_ntp_time; <S2SV_EndVul> avio_wb32(pb, middle_32_bits); avio_wb32(pb, delay_since_last); } avio_w8(pb, (RTP_VERSION << 6) + 1); avio_w8(pb, RTCP_SDES); len = strlen(s->hostname); avio_wb16(pb, (7 + len + 3) / 4); avio_wb32(pb, s->ssrc + 1); avio_w8(pb, 0x01); avio_w8(pb, len); avio_write(pb, s->hostname, len); avio_w8(pb, 0); for (len = (7 + len) % 4; len % 4; len++) avio_w8(pb, 0); avio_flush(pb); if (!fd) return 0; len = avio_close_dyn_buf(pb, &buf); if ((len > 0) && buf) { int av_unused result; av_dlog(s->ic, ""sending %d bytes of RR\n"", len); result = ffurl_write(fd, buf, len); av_dlog(s->ic, ""result from ffurl_write: %d\n"", result); av_free(buf); } return 0; }","- uint64_t ntp_time = s->last_rtcp_ntp_time; // TODO: Get local ntp time?
- uint32_t delay_since_last = ntp_time - s->last_rtcp_ntp_time;
+ uint32_t delay_since_last = av_rescale(av_gettime() - s->last_rtcp_reception_time,
+ 65536, AV_TIME_BASE);","int ff_rtp_check_and_send_back_rr(RTPDemuxContext *s, URLContext *fd, AVIOContext *avio, int count) { AVIOContext *pb; uint8_t *buf; int len; int rtcp_bytes; RTPStatistics *stats = &s->statistics; uint32_t lost; uint32_t extended_max; uint32_t expected_interval; uint32_t received_interval; uint32_t lost_interval; uint32_t expected; uint32_t fraction; if ((!fd && !avio) || (count < 1)) return -1; s->octet_count += count; rtcp_bytes = ((s->octet_count - s->last_octet_count) * RTCP_TX_RATIO_NUM) / RTCP_TX_RATIO_DEN; rtcp_bytes /= 50; if (rtcp_bytes < 28) return -1; s->last_octet_count = s->octet_count; if (!fd) pb = avio; else if (avio_open_dyn_buf(&pb) < 0) return -1; avio_w8(pb, (RTP_VERSION << 6) + 1); avio_w8(pb, RTCP_RR); avio_wb16(pb, 7); avio_wb32(pb, s->ssrc + 1); avio_wb32(pb, s->ssrc); extended_max = stats->cycles + stats->max_seq; expected = extended_max - stats->base_seq; lost = expected - stats->received; lost = FFMIN(lost, 0xffffff); expected_interval = expected - stats->expected_prior; stats->expected_prior = expected; received_interval = stats->received - stats->received_prior; stats->received_prior = stats->received; lost_interval = expected_interval - received_interval; if (expected_interval == 0 || lost_interval <= 0) fraction = 0; else fraction = (lost_interval << 8) / expected_interval; fraction = (fraction << 24) | lost; avio_wb32(pb, fraction); avio_wb32(pb, extended_max); avio_wb32(pb, stats->jitter >> 4); if (s->last_rtcp_ntp_time == AV_NOPTS_VALUE) { avio_wb32(pb, 0); avio_wb32(pb, 0); } else { uint32_t middle_32_bits = s->last_rtcp_ntp_time >> 16; uint32_t delay_since_last = av_rescale(av_gettime() - s->last_rtcp_reception_time, 65536, AV_TIME_BASE); avio_wb32(pb, middle_32_bits); avio_wb32(pb, delay_since_last); } avio_w8(pb, (RTP_VERSION << 6) + 1); avio_w8(pb, RTCP_SDES); len = strlen(s->hostname); avio_wb16(pb, (7 + len + 3) / 4); avio_wb32(pb, s->ssrc + 1); avio_w8(pb, 0x01); avio_w8(pb, len); avio_write(pb, s->hostname, len); avio_w8(pb, 0); for (len = (7 + len) % 4; len % 4; len++) avio_w8(pb, 0); avio_flush(pb); if (!fd) return 0; len = avio_close_dyn_buf(pb, &buf); if ((len > 0) && buf) { int av_unused result; av_dlog(s->ic, ""sending %d bytes of RR\n"", len); result = ffurl_write(fd, buf, len); av_dlog(s->ic, ""result from ffurl_write: %d\n"", result); av_free(buf); } return 0; }"
15050----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a867feac9eddc917e3b01d15062aebb143e2fa80_1.json----wait_for_async,"void wait_for_async(SSL *s) { <S2SV_StartVul> int width, fd; <S2SV_EndVul> fd_set asyncfds; <S2SV_StartVul> fd = SSL_get_async_wait_fd(s); <S2SV_EndVul> <S2SV_StartVul> if (fd < 0) <S2SV_EndVul> return; <S2SV_StartVul> width = fd + 1; <S2SV_EndVul> FD_ZERO(&asyncfds); <S2SV_StartVul> openssl_fdset(fd, &asyncfds); <S2SV_EndVul> select(width, (void *)&asyncfds, NULL, NULL, NULL); }","- int width, fd;
- fd = SSL_get_async_wait_fd(s);
- if (fd < 0)
- width = fd + 1;
- openssl_fdset(fd, &asyncfds);
+ int width = 0;
+ OSSL_ASYNC_FD *fds;
+ size_t numfds;
+ if (!SSL_get_all_async_fds(s, NULL, &numfds))
+ return;
+ if (numfds == 0)
+ fds = OPENSSL_malloc(sizeof(OSSL_ASYNC_FD) * numfds);
+ if (!SSL_get_all_async_fds(s, fds, &numfds)) {
+ OPENSSL_free(fds);
+ }
+ while (numfds > 0) {
+ if (width <= (int)*fds)
+ width = (int)*fds + 1;
+ openssl_fdset((int)*fds, &asyncfds);
+ numfds--;
+ fds++;
+ }","void wait_for_async(SSL *s) { int width = 0; fd_set asyncfds; OSSL_ASYNC_FD *fds; size_t numfds; if (!SSL_get_all_async_fds(s, NULL, &numfds)) return; if (numfds == 0) return; fds = OPENSSL_malloc(sizeof(OSSL_ASYNC_FD) * numfds); if (!SSL_get_all_async_fds(s, fds, &numfds)) { OPENSSL_free(fds); } FD_ZERO(&asyncfds); while (numfds > 0) { if (width <= (int)*fds) width = (int)*fds + 1; openssl_fdset((int)*fds, &asyncfds); numfds--; fds++; } select(width, (void *)&asyncfds, NULL, NULL, NULL); }"
9143----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fab74083b4b793562a46efd9bcaa924fb6f5863f_1.json----pmt_cb,"static void pmt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len) { MpegTSContext *ts = filter->u.section_filter.opaque; SectionHeader h1, *h = &h1; PESContext *pes; AVStream *st; const uint8_t *p, *p_end, *desc_list_end; int program_info_length, pcr_pid, pid, stream_type; int desc_list_len; uint32_t prog_reg_desc = 0; Mp4Descr mp4_descr[MAX_MP4_DESCR_COUNT] = {{ 0 }}; int mp4_descr_count = 0; int i; av_dlog(ts->stream, ""PMT: len %i\n"", section_len); hex_dump_debug(ts->stream, (uint8_t *)section, section_len); p_end = section + section_len - 4; p = section; if (parse_section_header(h, &p, p_end) < 0) return; av_dlog(ts->stream, ""sid=0x%x sec_num=%d/%d\n"", h->id, h->sec_num, h->last_sec_num); if (h->tid != PMT_TID) return; clear_program(ts, h->id); pcr_pid = get16(&p, p_end) & 0x1fff; if (pcr_pid < 0) return; add_pid_to_pmt(ts, h->id, pcr_pid); av_dlog(ts->stream, ""pcr_pid=0x%x\n"", pcr_pid); program_info_length = get16(&p, p_end) & 0xfff; if (program_info_length < 0) return; while(program_info_length >= 2) { uint8_t tag, len; tag = get8(&p, p_end); len = get8(&p, p_end); av_dlog(ts->stream, ""program tag: 0x%02x len=%d\n"", tag, len); if(len > program_info_length - 2) break; program_info_length -= len + 2; if (tag == 0x1d) { get8(&p, p_end); get8(&p, p_end); len -= 2; mp4_read_iods(ts->stream, p, len, mp4_descr + mp4_descr_count, &mp4_descr_count, MAX_MP4_DESCR_COUNT); } else if (tag == 0x05 && len >= 4) { prog_reg_desc = bytestream_get_le32(&p); len -= 4; } p += len; } p += program_info_length; if (p >= p_end) goto out; if (!ts->stream->nb_streams) ts->stop_parse = 1; for(;;) { st = 0; pes = NULL; stream_type = get8(&p, p_end); if (stream_type < 0) break; pid = get16(&p, p_end) & 0x1fff; if (pid < 0) break; if (ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES) { pes = ts->pids[pid]->u.pes_filter.opaque; if (!pes->st) { pes->st = avformat_new_stream(pes->stream, NULL); pes->st->id = pes->pid; } st = pes->st; } else if (stream_type != 0x13) { if (ts->pids[pid]) mpegts_close_filter(ts, ts->pids[pid]); pes = add_pes_stream(ts, pid, pcr_pid); if (pes) { st = avformat_new_stream(pes->stream, NULL); st->id = pes->pid; } } else { int idx = ff_find_stream_index(ts->stream, pid); if (idx >= 0) { st = ts->stream->streams[idx]; } else { <S2SV_StartVul> st = avformat_new_stream(pes->stream, NULL); <S2SV_EndVul> st->id = pid; st->codec->codec_type = AVMEDIA_TYPE_DATA; } } if (!st) goto out; if (pes && !pes->stream_type) mpegts_set_stream_info(st, pes, stream_type, prog_reg_desc); add_pid_to_pmt(ts, h->id, pid); ff_program_add_stream_index(ts->stream, h->id, st->index); desc_list_len = get16(&p, p_end) & 0xfff; if (desc_list_len < 0) break; desc_list_end = p + desc_list_len; if (desc_list_end > p_end) break; for(;;) { if (ff_parse_mpeg2_descriptor(ts->stream, st, stream_type, &p, desc_list_end, mp4_descr, mp4_descr_count, pid, ts) < 0) break; if (pes && prog_reg_desc == AV_RL32(""HDMV"") && stream_type == 0x83 && pes->sub_st) { ff_program_add_stream_index(ts->stream, h->id, pes->sub_st->index); pes->sub_st->codec->codec_tag = st->codec->codec_tag; } } p = desc_list_end; } out: for (i = 0; i < mp4_descr_count; i++) av_free(mp4_descr[i].dec_config_descr); }","- st = avformat_new_stream(pes->stream, NULL);
+ st = avformat_new_stream(ts->stream, NULL);","static void pmt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len) { MpegTSContext *ts = filter->u.section_filter.opaque; SectionHeader h1, *h = &h1; PESContext *pes; AVStream *st; const uint8_t *p, *p_end, *desc_list_end; int program_info_length, pcr_pid, pid, stream_type; int desc_list_len; uint32_t prog_reg_desc = 0; Mp4Descr mp4_descr[MAX_MP4_DESCR_COUNT] = {{ 0 }}; int mp4_descr_count = 0; int i; av_dlog(ts->stream, ""PMT: len %i\n"", section_len); hex_dump_debug(ts->stream, (uint8_t *)section, section_len); p_end = section + section_len - 4; p = section; if (parse_section_header(h, &p, p_end) < 0) return; av_dlog(ts->stream, ""sid=0x%x sec_num=%d/%d\n"", h->id, h->sec_num, h->last_sec_num); if (h->tid != PMT_TID) return; clear_program(ts, h->id); pcr_pid = get16(&p, p_end) & 0x1fff; if (pcr_pid < 0) return; add_pid_to_pmt(ts, h->id, pcr_pid); av_dlog(ts->stream, ""pcr_pid=0x%x\n"", pcr_pid); program_info_length = get16(&p, p_end) & 0xfff; if (program_info_length < 0) return; while(program_info_length >= 2) { uint8_t tag, len; tag = get8(&p, p_end); len = get8(&p, p_end); av_dlog(ts->stream, ""program tag: 0x%02x len=%d\n"", tag, len); if(len > program_info_length - 2) break; program_info_length -= len + 2; if (tag == 0x1d) { get8(&p, p_end); get8(&p, p_end); len -= 2; mp4_read_iods(ts->stream, p, len, mp4_descr + mp4_descr_count, &mp4_descr_count, MAX_MP4_DESCR_COUNT); } else if (tag == 0x05 && len >= 4) { prog_reg_desc = bytestream_get_le32(&p); len -= 4; } p += len; } p += program_info_length; if (p >= p_end) goto out; if (!ts->stream->nb_streams) ts->stop_parse = 1; for(;;) { st = 0; pes = NULL; stream_type = get8(&p, p_end); if (stream_type < 0) break; pid = get16(&p, p_end) & 0x1fff; if (pid < 0) break; if (ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES) { pes = ts->pids[pid]->u.pes_filter.opaque; if (!pes->st) { pes->st = avformat_new_stream(pes->stream, NULL); pes->st->id = pes->pid; } st = pes->st; } else if (stream_type != 0x13) { if (ts->pids[pid]) mpegts_close_filter(ts, ts->pids[pid]); pes = add_pes_stream(ts, pid, pcr_pid); if (pes) { st = avformat_new_stream(pes->stream, NULL); st->id = pes->pid; } } else { int idx = ff_find_stream_index(ts->stream, pid); if (idx >= 0) { st = ts->stream->streams[idx]; } else { st = avformat_new_stream(ts->stream, NULL); st->id = pid; st->codec->codec_type = AVMEDIA_TYPE_DATA; } } if (!st) goto out; if (pes && !pes->stream_type) mpegts_set_stream_info(st, pes, stream_type, prog_reg_desc); add_pid_to_pmt(ts, h->id, pid); ff_program_add_stream_index(ts->stream, h->id, st->index); desc_list_len = get16(&p, p_end) & 0xfff; if (desc_list_len < 0) break; desc_list_end = p + desc_list_len; if (desc_list_end > p_end) break; for(;;) { if (ff_parse_mpeg2_descriptor(ts->stream, st, stream_type, &p, desc_list_end, mp4_descr, mp4_descr_count, pid, ts) < 0) break; if (pes && prog_reg_desc == AV_RL32(""HDMV"") && stream_type == 0x83 && pes->sub_st) { ff_program_add_stream_index(ts->stream, h->id, pes->sub_st->index); pes->sub_st->codec->codec_tag = st->codec->codec_tag; } } p = desc_list_end; } out: for (i = 0; i < mp4_descr_count; i++) av_free(mp4_descr[i].dec_config_descr); }"
4667----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fb8e9e6b8f377af308bc40a9f3025fe9aa2b06b9_1.json----matroska_read_header,"static int matroska_read_header (AVFormatContext *s, AVFormatParameters *ap) { MatroskaDemuxContext *matroska = s->priv_data; char *doctype; int version, last_level, res = 0; uint32_t id; matroska->ctx = s; doctype = NULL; if ((res = ebml_read_header(matroska, &doctype, &version)) < 0) return res; if ((doctype == NULL) || strcmp(doctype, ""matroska"")) { av_log(matroska->ctx, AV_LOG_ERROR, ""Wrong EBML doctype ('%s' != 'matroska').\n"", doctype ? doctype : ""(none)""); if (doctype) av_free(doctype); return AVERROR_NOFMT; } av_free(doctype); if (version > 2) { av_log(matroska->ctx, AV_LOG_ERROR, ""Matroska demuxer version 2 too old for file version %d\n"", version); return AVERROR_NOFMT; } while (1) { if (!(id = ebml_peek_id(matroska, &last_level))) return AVERROR(EIO); if (id == MATROSKA_ID_SEGMENT) break; av_log(matroska->ctx, AV_LOG_INFO, ""Expected a Segment ID (0x%x), but received 0x%x!\n"", MATROSKA_ID_SEGMENT, id); if ((res = ebml_read_skip(matroska)) < 0) return res; } if ((res = ebml_read_master(matroska, &id)) < 0) return res; matroska->segment_start = url_ftell(s->pb); matroska->time_scale = 1000000; while (res == 0) { if (!(id = ebml_peek_id(matroska, &matroska->level_up))) { res = AVERROR(EIO); break; } else if (matroska->level_up) { matroska->level_up--; break; } switch (id) { case MATROSKA_ID_INFO: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_info(matroska); break; } case MATROSKA_ID_TRACKS: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_tracks(matroska); break; } case MATROSKA_ID_CUES: { if (!matroska->index_parsed) { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_index(matroska); } else res = ebml_read_skip(matroska); break; } case MATROSKA_ID_TAGS: { if (!matroska->metadata_parsed) { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_metadata(matroska); } else res = ebml_read_skip(matroska); break; } case MATROSKA_ID_SEEKHEAD: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_seekhead(matroska); break; } case MATROSKA_ID_ATTACHMENTS: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_attachments(s); break; } case MATROSKA_ID_CLUSTER: { res = 1; break; } default: av_log(matroska->ctx, AV_LOG_INFO, ""Unknown matroska file header ID 0x%x\n"", id); case EBML_ID_VOID: res = ebml_read_skip(matroska); break; } if (matroska->level_up) { matroska->level_up--; break; } } if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) { int i, j; MatroskaTrack *track; AVStream *st; for (i = 0; i < matroska->num_tracks; i++) { enum CodecID codec_id = CODEC_ID_NONE; uint8_t *extradata = NULL; int extradata_size = 0; int extradata_offset = 0; track = matroska->tracks[i]; track->stream_index = -1; if (track->codec_id == NULL) continue; for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){ if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id, strlen(ff_mkv_codec_tags[j].str))){ codec_id= ff_mkv_codec_tags[j].id; break; } } if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC) && (track->codec_priv_size >= 40) && (track->codec_priv != NULL)) { MatroskaVideoTrack *vtrack = (MatroskaVideoTrack *) track; vtrack->fourcc = AV_RL32(track->codec_priv + 16); codec_id = codec_get_id(codec_bmp_tags, vtrack->fourcc); } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_AUDIO_ACM) && (track->codec_priv_size >= 18) && (track->codec_priv != NULL)) { uint16_t tag; tag = AV_RL16(track->codec_priv); codec_id = codec_get_id(codec_wav_tags, tag); } else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track; int profile = matroska_aac_profile(track->codec_id); int sri = matroska_aac_sri(audiotrack->internal_samplerate); extradata = av_malloc(5); if (extradata == NULL) return AVERROR(ENOMEM); extradata[0] = (profile << 3) | ((sri&0x0E) >> 1); extradata[1] = ((sri&0x01) << 7) | (audiotrack->channels<<3); if (strstr(track->codec_id, ""SBR"")) { sri = matroska_aac_sri(audiotrack->samplerate); extradata[2] = 0x56; extradata[3] = 0xE5; extradata[4] = 0x80 | (sri<<3); extradata_size = 5; } else { extradata_size = 2; } } else if (codec_id == CODEC_ID_TTA) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track; ByteIOContext b; extradata_size = 30; extradata = av_mallocz(extradata_size); if (extradata == NULL) return AVERROR(ENOMEM); init_put_byte(&b, extradata, extradata_size, 1, NULL, NULL, NULL, NULL); put_buffer(&b, ""TTA1"", 4); put_le16(&b, 1); put_le16(&b, audiotrack->channels); put_le16(&b, audiotrack->bitdepth); put_le32(&b, audiotrack->samplerate); put_le32(&b, matroska->ctx->duration * audiotrack->samplerate); } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 || codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) { extradata_offset = 26; track->codec_priv_size -= extradata_offset; } else if (codec_id == CODEC_ID_RA_144) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track; audiotrack->samplerate = 8000; audiotrack->channels = 1; } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK || codec_id == CODEC_ID_ATRAC3) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track; ByteIOContext b; init_put_byte(&b, track->codec_priv, track->codec_priv_size, 0, NULL, NULL, NULL, NULL); url_fskip(&b, 24); audiotrack->coded_framesize = get_be32(&b); url_fskip(&b, 12); audiotrack->sub_packet_h = get_be16(&b); audiotrack->frame_size = get_be16(&b); audiotrack->sub_packet_size = get_be16(&b); audiotrack->buf = av_malloc(audiotrack->frame_size * audiotrack->sub_packet_h); if (codec_id == CODEC_ID_RA_288) { audiotrack->block_align = audiotrack->coded_framesize; track->codec_priv_size = 0; } else { audiotrack->block_align = audiotrack->sub_packet_size; extradata_offset = 78; track->codec_priv_size -= extradata_offset; } } if (codec_id == CODEC_ID_NONE) { av_log(matroska->ctx, AV_LOG_INFO, ""Unknown/unsupported CodecID %s.\n"", track->codec_id); } track->stream_index = matroska->num_streams; matroska->num_streams++; st = av_new_stream(s, track->stream_index); if (st == NULL) return AVERROR(ENOMEM); av_set_pts_info(st, 64, matroska->time_scale, 1000*1000*1000); st->codec->codec_id = codec_id; st->start_time = 0; if (strcmp(track->language, ""und"")) strcpy(st->language, track->language); if (track->flags & MATROSKA_TRACK_DEFAULT) st->disposition |= AV_DISPOSITION_DEFAULT; if (track->default_duration) av_reduce(&st->codec->time_base.num, &st->codec->time_base.den, track->default_duration, 1000000000, 30000); if(extradata){ st->codec->extradata = extradata; st->codec->extradata_size = extradata_size; } else if(track->codec_priv && track->codec_priv_size > 0){ st->codec->extradata = av_malloc(track->codec_priv_size); if(st->codec->extradata == NULL) return AVERROR(ENOMEM); st->codec->extradata_size = track->codec_priv_size; memcpy(st->codec->extradata,track->codec_priv+extradata_offset, track->codec_priv_size); } if (track->type == MATROSKA_TRACK_TYPE_VIDEO) { MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_tag = videotrack->fourcc; st->codec->width = videotrack->pixel_width; st->codec->height = videotrack->pixel_height; if (videotrack->display_width == 0) videotrack->display_width= videotrack->pixel_width; if (videotrack->display_height == 0) videotrack->display_height= videotrack->pixel_height; av_reduce(&st->codec->sample_aspect_ratio.num, &st->codec->sample_aspect_ratio.den, st->codec->height * videotrack->display_width, st->codec-> width * videotrack->display_height, 255); st->need_parsing = AVSTREAM_PARSE_HEADERS; } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->sample_rate = audiotrack->samplerate; st->codec->channels = audiotrack->channels; st->codec->block_align = audiotrack->block_align; } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) { st->codec->codec_type = CODEC_TYPE_SUBTITLE; } } res = 0; } if (matroska->index_parsed) { int i, track, stream; for (i=0; i<matroska->num_indexes; i++) { MatroskaDemuxIndex *idx = &matroska->index[i]; track = matroska_find_track_by_num(matroska, idx->track); stream = matroska->tracks[track]->stream_index; <S2SV_StartVul> if (stream >= 0) <S2SV_EndVul> av_add_index_entry(matroska->ctx->streams[stream], idx->pos, idx->time/matroska->time_scale, 0, 0, AVINDEX_KEYFRAME); } } return res; }","- if (stream >= 0)
+ if (stream >= 0 && stream < matroska->ctx->nb_streams)","static int matroska_read_header (AVFormatContext *s, AVFormatParameters *ap) { MatroskaDemuxContext *matroska = s->priv_data; char *doctype; int version, last_level, res = 0; uint32_t id; matroska->ctx = s; doctype = NULL; if ((res = ebml_read_header(matroska, &doctype, &version)) < 0) return res; if ((doctype == NULL) || strcmp(doctype, ""matroska"")) { av_log(matroska->ctx, AV_LOG_ERROR, ""Wrong EBML doctype ('%s' != 'matroska').\n"", doctype ? doctype : ""(none)""); if (doctype) av_free(doctype); return AVERROR_NOFMT; } av_free(doctype); if (version > 2) { av_log(matroska->ctx, AV_LOG_ERROR, ""Matroska demuxer version 2 too old for file version %d\n"", version); return AVERROR_NOFMT; } while (1) { if (!(id = ebml_peek_id(matroska, &last_level))) return AVERROR(EIO); if (id == MATROSKA_ID_SEGMENT) break; av_log(matroska->ctx, AV_LOG_INFO, ""Expected a Segment ID (0x%x), but received 0x%x!\n"", MATROSKA_ID_SEGMENT, id); if ((res = ebml_read_skip(matroska)) < 0) return res; } if ((res = ebml_read_master(matroska, &id)) < 0) return res; matroska->segment_start = url_ftell(s->pb); matroska->time_scale = 1000000; while (res == 0) { if (!(id = ebml_peek_id(matroska, &matroska->level_up))) { res = AVERROR(EIO); break; } else if (matroska->level_up) { matroska->level_up--; break; } switch (id) { case MATROSKA_ID_INFO: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_info(matroska); break; } case MATROSKA_ID_TRACKS: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_tracks(matroska); break; } case MATROSKA_ID_CUES: { if (!matroska->index_parsed) { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_index(matroska); } else res = ebml_read_skip(matroska); break; } case MATROSKA_ID_TAGS: { if (!matroska->metadata_parsed) { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_metadata(matroska); } else res = ebml_read_skip(matroska); break; } case MATROSKA_ID_SEEKHEAD: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_seekhead(matroska); break; } case MATROSKA_ID_ATTACHMENTS: { if ((res = ebml_read_master(matroska, &id)) < 0) break; res = matroska_parse_attachments(s); break; } case MATROSKA_ID_CLUSTER: { res = 1; break; } default: av_log(matroska->ctx, AV_LOG_INFO, ""Unknown matroska file header ID 0x%x\n"", id); case EBML_ID_VOID: res = ebml_read_skip(matroska); break; } if (matroska->level_up) { matroska->level_up--; break; } } if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) { int i, j; MatroskaTrack *track; AVStream *st; for (i = 0; i < matroska->num_tracks; i++) { enum CodecID codec_id = CODEC_ID_NONE; uint8_t *extradata = NULL; int extradata_size = 0; int extradata_offset = 0; track = matroska->tracks[i]; track->stream_index = -1; if (track->codec_id == NULL) continue; for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){ if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id, strlen(ff_mkv_codec_tags[j].str))){ codec_id= ff_mkv_codec_tags[j].id; break; } } if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC) && (track->codec_priv_size >= 40) && (track->codec_priv != NULL)) { MatroskaVideoTrack *vtrack = (MatroskaVideoTrack *) track; vtrack->fourcc = AV_RL32(track->codec_priv + 16); codec_id = codec_get_id(codec_bmp_tags, vtrack->fourcc); } else if (!strcmp(track->codec_id, MATROSKA_CODEC_ID_AUDIO_ACM) && (track->codec_priv_size >= 18) && (track->codec_priv != NULL)) { uint16_t tag; tag = AV_RL16(track->codec_priv); codec_id = codec_get_id(codec_wav_tags, tag); } else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track; int profile = matroska_aac_profile(track->codec_id); int sri = matroska_aac_sri(audiotrack->internal_samplerate); extradata = av_malloc(5); if (extradata == NULL) return AVERROR(ENOMEM); extradata[0] = (profile << 3) | ((sri&0x0E) >> 1); extradata[1] = ((sri&0x01) << 7) | (audiotrack->channels<<3); if (strstr(track->codec_id, ""SBR"")) { sri = matroska_aac_sri(audiotrack->samplerate); extradata[2] = 0x56; extradata[3] = 0xE5; extradata[4] = 0x80 | (sri<<3); extradata_size = 5; } else { extradata_size = 2; } } else if (codec_id == CODEC_ID_TTA) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track; ByteIOContext b; extradata_size = 30; extradata = av_mallocz(extradata_size); if (extradata == NULL) return AVERROR(ENOMEM); init_put_byte(&b, extradata, extradata_size, 1, NULL, NULL, NULL, NULL); put_buffer(&b, ""TTA1"", 4); put_le16(&b, 1); put_le16(&b, audiotrack->channels); put_le16(&b, audiotrack->bitdepth); put_le32(&b, audiotrack->samplerate); put_le32(&b, matroska->ctx->duration * audiotrack->samplerate); } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 || codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) { extradata_offset = 26; track->codec_priv_size -= extradata_offset; } else if (codec_id == CODEC_ID_RA_144) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track; audiotrack->samplerate = 8000; audiotrack->channels = 1; } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK || codec_id == CODEC_ID_ATRAC3) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track; ByteIOContext b; init_put_byte(&b, track->codec_priv, track->codec_priv_size, 0, NULL, NULL, NULL, NULL); url_fskip(&b, 24); audiotrack->coded_framesize = get_be32(&b); url_fskip(&b, 12); audiotrack->sub_packet_h = get_be16(&b); audiotrack->frame_size = get_be16(&b); audiotrack->sub_packet_size = get_be16(&b); audiotrack->buf = av_malloc(audiotrack->frame_size * audiotrack->sub_packet_h); if (codec_id == CODEC_ID_RA_288) { audiotrack->block_align = audiotrack->coded_framesize; track->codec_priv_size = 0; } else { audiotrack->block_align = audiotrack->sub_packet_size; extradata_offset = 78; track->codec_priv_size -= extradata_offset; } } if (codec_id == CODEC_ID_NONE) { av_log(matroska->ctx, AV_LOG_INFO, ""Unknown/unsupported CodecID %s.\n"", track->codec_id); } track->stream_index = matroska->num_streams; matroska->num_streams++; st = av_new_stream(s, track->stream_index); if (st == NULL) return AVERROR(ENOMEM); av_set_pts_info(st, 64, matroska->time_scale, 1000*1000*1000); st->codec->codec_id = codec_id; st->start_time = 0; if (strcmp(track->language, ""und"")) strcpy(st->language, track->language); if (track->flags & MATROSKA_TRACK_DEFAULT) st->disposition |= AV_DISPOSITION_DEFAULT; if (track->default_duration) av_reduce(&st->codec->time_base.num, &st->codec->time_base.den, track->default_duration, 1000000000, 30000); if(extradata){ st->codec->extradata = extradata; st->codec->extradata_size = extradata_size; } else if(track->codec_priv && track->codec_priv_size > 0){ st->codec->extradata = av_malloc(track->codec_priv_size); if(st->codec->extradata == NULL) return AVERROR(ENOMEM); st->codec->extradata_size = track->codec_priv_size; memcpy(st->codec->extradata,track->codec_priv+extradata_offset, track->codec_priv_size); } if (track->type == MATROSKA_TRACK_TYPE_VIDEO) { MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track; st->codec->codec_type = CODEC_TYPE_VIDEO; st->codec->codec_tag = videotrack->fourcc; st->codec->width = videotrack->pixel_width; st->codec->height = videotrack->pixel_height; if (videotrack->display_width == 0) videotrack->display_width= videotrack->pixel_width; if (videotrack->display_height == 0) videotrack->display_height= videotrack->pixel_height; av_reduce(&st->codec->sample_aspect_ratio.num, &st->codec->sample_aspect_ratio.den, st->codec->height * videotrack->display_width, st->codec-> width * videotrack->display_height, 255); st->need_parsing = AVSTREAM_PARSE_HEADERS; } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track; st->codec->codec_type = CODEC_TYPE_AUDIO; st->codec->sample_rate = audiotrack->samplerate; st->codec->channels = audiotrack->channels; st->codec->block_align = audiotrack->block_align; } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) { st->codec->codec_type = CODEC_TYPE_SUBTITLE; } } res = 0; } if (matroska->index_parsed) { int i, track, stream; for (i=0; i<matroska->num_indexes; i++) { MatroskaDemuxIndex *idx = &matroska->index[i]; track = matroska_find_track_by_num(matroska, idx->track); stream = matroska->tracks[track]->stream_index; if (stream >= 0 && stream < matroska->ctx->nb_streams) av_add_index_entry(matroska->ctx->streams[stream], idx->pos, idx->time/matroska->time_scale, 0, 0, AVINDEX_KEYFRAME); } } return res; }"
14962----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a572b57ec1cb118b4dc531ffe774495b52d44b48_1.json----ssl3_get_cert_verify,"int ssl3_get_cert_verify(SSL *s) { EVP_PKEY *pkey=NULL; unsigned char *p; int al,ok,ret=0; long n; int type=0,i,j; X509 *peer; const EVP_MD *md = NULL; EVP_MD_CTX mctx; EVP_MD_CTX_init(&mctx); n=s->method->ssl_get_message(s, SSL3_ST_SR_CERT_VRFY_A, SSL3_ST_SR_CERT_VRFY_B, -1, 514, &ok); if (!ok) return((int)n); if (s->session->peer != NULL) { peer=s->session->peer; pkey=X509_get_pubkey(peer); type=X509_certificate_type(peer,pkey); } else { peer=NULL; pkey=NULL; } if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY) { s->s3->tmp.reuse_message=1; if ((peer != NULL) && (type | EVP_PKT_SIGN)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE); goto f_err; } ret=1; goto end; } if (peer == NULL) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } if (!(type & EVP_PKT_SIGN)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE); al=SSL_AD_ILLEGAL_PARAMETER; goto f_err; } if (s->s3->change_cipher_spec) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } p=(unsigned char *)s->init_msg; if (n==64 && (pkey->type==NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) ) { i=64; } else { <S2SV_StartVul> if (s->version >= TLS1_2_VERSION) <S2SV_EndVul> { int sigalg = tls12_get_sigid(pkey); if (sigalg == -1) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR); al=SSL_AD_INTERNAL_ERROR; goto f_err; } if (sigalg != (int)p[1]) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_TYPE); al=SSL_AD_DECODE_ERROR; goto f_err; } md = tls12_get_hash(p[0]); if (md == NULL) { SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNKNOWN_DIGEST); al=SSL_AD_DECODE_ERROR; goto f_err; } #ifdef SSL_DEBUG fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md)); #endif p += 2; n -= 2; } n2s(p,i); n-=2; if (i > n) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH); al=SSL_AD_DECODE_ERROR; goto f_err; } } j=EVP_PKEY_size(pkey); if ((i > j) || (n > j) || (n <= 0)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE); al=SSL_AD_DECODE_ERROR; goto f_err; } <S2SV_StartVul> if (s->version >= TLS1_2_VERSION) <S2SV_EndVul> { long hdatalen = 0; void *hdata; hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen <= 0) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR); al=SSL_AD_INTERNAL_ERROR; goto f_err; } #ifdef SSL_DEBUG fprintf(stderr, ""Using TLS 1.2 with client verify alg %s\n"", EVP_MD_name(md)); #endif if (!EVP_VerifyInit_ex(&mctx, md, NULL) || !EVP_VerifyUpdate(&mctx, hdata, hdatalen)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB); al=SSL_AD_INTERNAL_ERROR; goto f_err; } if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE); goto f_err; } } else #ifndef OPENSSL_NO_RSA if (pkey->type == EVP_PKEY_RSA) { i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, pkey->pkey.rsa); if (i < 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT); goto f_err; } if (i == 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_DSA if (pkey->type == EVP_PKEY_DSA) { j=DSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_ECDSA if (pkey->type == EVP_PKEY_EC) { j=ECDSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else #endif if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) { unsigned char signature[64]; int idx; EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL); EVP_PKEY_verify_init(pctx); if (i!=64) { fprintf(stderr,""GOST signature length is %d"",i); } for (idx=0;idx<64;idx++) { signature[63-idx]=p[idx]; } j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32); EVP_PKEY_CTX_free(pctx); if (j<=0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR); al=SSL_AD_UNSUPPORTED_CERTIFICATE; goto f_err; } ret=1; if (0) { f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); } end: if (s->s3->handshake_buffer) { BIO_free(s->s3->handshake_buffer); s->s3->handshake_buffer = NULL; s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE; } EVP_MD_CTX_cleanup(&mctx); EVP_PKEY_free(pkey); return(ret); }","- if (s->version >= TLS1_2_VERSION)
- if (s->version >= TLS1_2_VERSION)
+ if (TLS1_get_version(s) >= TLS1_2_VERSION)
+ if (TLS1_get_version(s) >= TLS1_2_VERSION)","int ssl3_get_cert_verify(SSL *s) { EVP_PKEY *pkey=NULL; unsigned char *p; int al,ok,ret=0; long n; int type=0,i,j; X509 *peer; const EVP_MD *md = NULL; EVP_MD_CTX mctx; EVP_MD_CTX_init(&mctx); n=s->method->ssl_get_message(s, SSL3_ST_SR_CERT_VRFY_A, SSL3_ST_SR_CERT_VRFY_B, -1, 514, &ok); if (!ok) return((int)n); if (s->session->peer != NULL) { peer=s->session->peer; pkey=X509_get_pubkey(peer); type=X509_certificate_type(peer,pkey); } else { peer=NULL; pkey=NULL; } if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY) { s->s3->tmp.reuse_message=1; if ((peer != NULL) && (type | EVP_PKT_SIGN)) { al=SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE); goto f_err; } ret=1; goto end; } if (peer == NULL) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } if (!(type & EVP_PKT_SIGN)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE); al=SSL_AD_ILLEGAL_PARAMETER; goto f_err; } if (s->s3->change_cipher_spec) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY); al=SSL_AD_UNEXPECTED_MESSAGE; goto f_err; } p=(unsigned char *)s->init_msg; if (n==64 && (pkey->type==NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) ) { i=64; } else { if (TLS1_get_version(s) >= TLS1_2_VERSION) { int sigalg = tls12_get_sigid(pkey); if (sigalg == -1) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR); al=SSL_AD_INTERNAL_ERROR; goto f_err; } if (sigalg != (int)p[1]) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_TYPE); al=SSL_AD_DECODE_ERROR; goto f_err; } md = tls12_get_hash(p[0]); if (md == NULL) { SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNKNOWN_DIGEST); al=SSL_AD_DECODE_ERROR; goto f_err; } #ifdef SSL_DEBUG fprintf(stderr, ""USING TLSv1.2 HASH %s\n"", EVP_MD_name(md)); #endif p += 2; n -= 2; } n2s(p,i); n-=2; if (i > n) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH); al=SSL_AD_DECODE_ERROR; goto f_err; } } j=EVP_PKEY_size(pkey); if ((i > j) || (n > j) || (n <= 0)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE); al=SSL_AD_DECODE_ERROR; goto f_err; } if (TLS1_get_version(s) >= TLS1_2_VERSION) { long hdatalen = 0; void *hdata; hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata); if (hdatalen <= 0) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR); al=SSL_AD_INTERNAL_ERROR; goto f_err; } #ifdef SSL_DEBUG fprintf(stderr, ""Using TLS 1.2 with client verify alg %s\n"", EVP_MD_name(md)); #endif if (!EVP_VerifyInit_ex(&mctx, md, NULL) || !EVP_VerifyUpdate(&mctx, hdata, hdatalen)) { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB); al=SSL_AD_INTERNAL_ERROR; goto f_err; } if (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE); goto f_err; } } else #ifndef OPENSSL_NO_RSA if (pkey->type == EVP_PKEY_RSA) { i=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md, MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, pkey->pkey.rsa); if (i < 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT); goto f_err; } if (i == 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_DSA if (pkey->type == EVP_PKEY_DSA) { j=DSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE); goto f_err; } } else #endif #ifndef OPENSSL_NO_ECDSA if (pkey->type == EVP_PKEY_EC) { j=ECDSA_verify(pkey->save_type, &(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]), SHA_DIGEST_LENGTH,p,i,pkey->pkey.ec); if (j <= 0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else #endif if (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) { unsigned char signature[64]; int idx; EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL); EVP_PKEY_verify_init(pctx); if (i!=64) { fprintf(stderr,""GOST signature length is %d"",i); } for (idx=0;idx<64;idx++) { signature[63-idx]=p[idx]; } j=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32); EVP_PKEY_CTX_free(pctx); if (j<=0) { al=SSL_AD_DECRYPT_ERROR; SSLerr(SSL_F_SSL3_GET_CERT_VERIFY, SSL_R_BAD_ECDSA_SIGNATURE); goto f_err; } } else { SSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR); al=SSL_AD_UNSUPPORTED_CERTIFICATE; goto f_err; } ret=1; if (0) { f_err: ssl3_send_alert(s,SSL3_AL_FATAL,al); } end: if (s->s3->handshake_buffer) { BIO_free(s->s3->handshake_buffer); s->s3->handshake_buffer = NULL; s->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE; } EVP_MD_CTX_cleanup(&mctx); EVP_PKEY_free(pkey); return(ret); }"
3306----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b3845f35227bdba24b41e340b66abaf3d81b336c_1.json----show_stream,"static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx) { AVStream *stream = fmt_ctx->streams[stream_idx]; AVCodecContext *dec_ctx; AVCodec *dec; char val_str[128]; AVRational display_aspect_ratio; struct print_buf pbuf = {.s = NULL}; print_section_header(""stream""); print_int(""index"", stream->index); if ((dec_ctx = stream->codec)) { if ((dec = dec_ctx->codec)) { print_str(""codec_name"", dec->name); print_str(""codec_long_name"", dec->long_name); } else { <S2SV_StartVul> print_str(""codec_name"", ""unknown""); <S2SV_EndVul> } <S2SV_StartVul> print_str(""codec_type"", av_x_if_null(av_get_media_type_string(dec_ctx->codec_type), ""unknown"")); <S2SV_EndVul> print_fmt(""codec_time_base"", ""%d/%d"", dec_ctx->time_base.num, dec_ctx->time_base.den); av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag); print_str(""codec_tag_string"", val_str); print_fmt(""codec_tag"", ""0x%04x"", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int(""width"", dec_ctx->width); print_int(""height"", dec_ctx->height); print_int(""has_b_frames"", dec_ctx->has_b_frames); if (dec_ctx->sample_aspect_ratio.num) { print_fmt(""sample_aspect_ratio"", ""%d:%d"", dec_ctx->sample_aspect_ratio.num, dec_ctx->sample_aspect_ratio.den); av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den, dec_ctx->width * dec_ctx->sample_aspect_ratio.num, dec_ctx->height * dec_ctx->sample_aspect_ratio.den, 1024*1024); print_fmt(""display_aspect_ratio"", ""%d:%d"", display_aspect_ratio.num, display_aspect_ratio.den); } <S2SV_StartVul> print_str(""pix_fmt"", av_x_if_null(av_get_pix_fmt_name(dec_ctx->pix_fmt), ""unknown"")); <S2SV_EndVul> print_int(""level"", dec_ctx->level); break; case AVMEDIA_TYPE_AUDIO: <S2SV_StartVul> print_str(""sample_fmt"", <S2SV_EndVul> <S2SV_StartVul> av_x_if_null(av_get_sample_fmt_name(dec_ctx->sample_fmt), ""unknown"")); <S2SV_EndVul> print_val(""sample_rate"", dec_ctx->sample_rate, unit_hertz_str); print_int(""channels"", dec_ctx->channels); print_int(""bits_per_sample"", av_get_bits_per_sample(dec_ctx->codec_id)); break; } } else { <S2SV_StartVul> print_str(""codec_type"", ""unknown""); <S2SV_EndVul> } if (dec_ctx->codec && dec_ctx->codec->priv_class) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } <S2SV_StartVul> if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) <S2SV_EndVul> <S2SV_StartVul> print_fmt(""id"", ""0x%x"", stream->id); <S2SV_EndVul> print_fmt(""r_frame_rate"", ""%d/%d"", stream->r_frame_rate.num, stream->r_frame_rate.den); print_fmt(""avg_frame_rate"", ""%d/%d"", stream->avg_frame_rate.num, stream->avg_frame_rate.den); print_fmt(""time_base"", ""%d/%d"", stream->time_base.num, stream->time_base.den); print_time(""start_time"", stream->start_time, &stream->time_base); print_time(""duration"", stream->duration, &stream->time_base); <S2SV_StartVul> if (stream->nb_frames) <S2SV_EndVul> <S2SV_StartVul> print_fmt(""nb_frames"", ""%""PRId64, stream->nb_frames); <S2SV_EndVul> show_tags(stream->metadata); print_section_footer(""stream""); av_free(pbuf.s); fflush(stdout); }","- print_str(""codec_name"", ""unknown"");
- print_str(""codec_type"", av_x_if_null(av_get_media_type_string(dec_ctx->codec_type), ""unknown""));
- print_str(""pix_fmt"", av_x_if_null(av_get_pix_fmt_name(dec_ctx->pix_fmt), ""unknown""));
- print_str(""sample_fmt"",
- av_x_if_null(av_get_sample_fmt_name(dec_ctx->sample_fmt), ""unknown""));
- print_str(""codec_type"", ""unknown"");
- if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)
- print_fmt(""id"", ""0x%x"", stream->id);
- if (stream->nb_frames)
- print_fmt(""nb_frames"", ""%""PRId64, stream->nb_frames);
+ const char *s;
+ print_str_opt(""codec_name"", ""unknown"");
+ print_str_opt(""codec_long_name"", ""unknown"");
+ s = av_get_media_type_string(dec_ctx->codec_type);
+ if (s) print_str (""codec_type"", s);
+ else print_str_opt(""codec_type"", ""unknown"");
+ } else {
+ print_str_opt(""sample_aspect_ratio"", ""N/A"");
+ print_str_opt(""display_aspect_ratio"", ""N/A"");
+ s = av_get_pix_fmt_name(dec_ctx->pix_fmt);
+ if (s) print_str (""pix_fmt"", s);
+ else print_str_opt(""pix_fmt"", ""unknown"");
+ s = av_get_sample_fmt_name(dec_ctx->sample_fmt);
+ if (s) print_str (""sample_fmt"", s);
+ else print_str_opt(""sample_fmt"", ""unknown"");
+ print_str_opt(""codec_type"", ""unknown"");
+ if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt (""id"", ""0x%x"", stream->id);
+ else print_str_opt(""id"", ""N/A"");
+ if (stream->nb_frames) print_fmt (""nb_frames"", ""%""PRId64, stream->nb_frames);
+ else print_str_opt(""nb_frames"", ""N/A"");","static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx) { AVStream *stream = fmt_ctx->streams[stream_idx]; AVCodecContext *dec_ctx; AVCodec *dec; char val_str[128]; const char *s; AVRational display_aspect_ratio; struct print_buf pbuf = {.s = NULL}; print_section_header(""stream""); print_int(""index"", stream->index); if ((dec_ctx = stream->codec)) { if ((dec = dec_ctx->codec)) { print_str(""codec_name"", dec->name); print_str(""codec_long_name"", dec->long_name); } else { print_str_opt(""codec_name"", ""unknown""); print_str_opt(""codec_long_name"", ""unknown""); } s = av_get_media_type_string(dec_ctx->codec_type); if (s) print_str (""codec_type"", s); else print_str_opt(""codec_type"", ""unknown""); print_fmt(""codec_time_base"", ""%d/%d"", dec_ctx->time_base.num, dec_ctx->time_base.den); av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag); print_str(""codec_tag_string"", val_str); print_fmt(""codec_tag"", ""0x%04x"", dec_ctx->codec_tag); switch (dec_ctx->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int(""width"", dec_ctx->width); print_int(""height"", dec_ctx->height); print_int(""has_b_frames"", dec_ctx->has_b_frames); if (dec_ctx->sample_aspect_ratio.num) { print_fmt(""sample_aspect_ratio"", ""%d:%d"", dec_ctx->sample_aspect_ratio.num, dec_ctx->sample_aspect_ratio.den); av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den, dec_ctx->width * dec_ctx->sample_aspect_ratio.num, dec_ctx->height * dec_ctx->sample_aspect_ratio.den, 1024*1024); print_fmt(""display_aspect_ratio"", ""%d:%d"", display_aspect_ratio.num, display_aspect_ratio.den); } else { print_str_opt(""sample_aspect_ratio"", ""N/A""); print_str_opt(""display_aspect_ratio"", ""N/A""); } s = av_get_pix_fmt_name(dec_ctx->pix_fmt); if (s) print_str (""pix_fmt"", s); else print_str_opt(""pix_fmt"", ""unknown""); print_int(""level"", dec_ctx->level); break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(dec_ctx->sample_fmt); if (s) print_str (""sample_fmt"", s); else print_str_opt(""sample_fmt"", ""unknown""); print_val(""sample_rate"", dec_ctx->sample_rate, unit_hertz_str); print_int(""channels"", dec_ctx->channels); print_int(""bits_per_sample"", av_get_bits_per_sample(dec_ctx->codec_id)); break; } } else { print_str_opt(""codec_type"", ""unknown""); } if (dec_ctx->codec && dec_ctx->codec->priv_class) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt (""id"", ""0x%x"", stream->id); else print_str_opt(""id"", ""N/A""); print_fmt(""r_frame_rate"", ""%d/%d"", stream->r_frame_rate.num, stream->r_frame_rate.den); print_fmt(""avg_frame_rate"", ""%d/%d"", stream->avg_frame_rate.num, stream->avg_frame_rate.den); print_fmt(""time_base"", ""%d/%d"", stream->time_base.num, stream->time_base.den); print_time(""start_time"", stream->start_time, &stream->time_base); print_time(""duration"", stream->duration, &stream->time_base); if (stream->nb_frames) print_fmt (""nb_frames"", ""%""PRId64, stream->nb_frames); else print_str_opt(""nb_frames"", ""N/A""); show_tags(stream->metadata); print_section_footer(""stream""); av_free(pbuf.s); fflush(stdout); }"
734----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_27b6dbc8d408adfa769a47cda3d7d0fe7689c406_1.json----ff_dca_core_parse,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size) { int ret; s->ext_audio_mask = 0; s->xch_pos = s->xxch_pos = s->x96_pos = 0; if ((ret = init_get_bits8(&s->gb, data, size)) < 0) return ret; s->gb_in = s->gb; if ((ret = parse_frame_header(s)) < 0) return ret; if ((ret = alloc_sample_buffer(s)) < 0) return ret; if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0) return ret; if ((ret = parse_optional_info(s)) < 0) return ret; <S2SV_StartVul> if (s->frame_size > size && s->frame_size < size + 4) <S2SV_EndVul> s->frame_size = size; if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) { av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n""); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_INVALIDDATA; } return 0; }","- if (s->frame_size > size && s->frame_size < size + 4)
+ if (s->frame_size > size)","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size) { int ret; s->ext_audio_mask = 0; s->xch_pos = s->xxch_pos = s->x96_pos = 0; if ((ret = init_get_bits8(&s->gb, data, size)) < 0) return ret; s->gb_in = s->gb; if ((ret = parse_frame_header(s)) < 0) return ret; if ((ret = alloc_sample_buffer(s)) < 0) return ret; if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0) return ret; if ((ret = parse_optional_info(s)) < 0) return ret; if (s->frame_size > size) s->frame_size = size; if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) { av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n""); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_INVALIDDATA; } return 0; }"
10989----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_1.json----pkey_set_type,"static int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len) { const EVP_PKEY_ASN1_METHOD *ameth; ENGINE *e = NULL; if (pkey) { if (pkey->pkey.ptr) EVP_PKEY_free_it(pkey); if ((type == pkey->save_type) && pkey->ameth) return 1; #ifndef OPENSSL_NO_ENGINE <S2SV_StartVul> if (pkey->engine) { <S2SV_EndVul> <S2SV_StartVul> ENGINE_finish(pkey->engine); <S2SV_EndVul> <S2SV_StartVul> pkey->engine = NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> #endif } if (str) ameth = EVP_PKEY_asn1_find_str(&e, str, len); else ameth = EVP_PKEY_asn1_find(&e, type); #ifndef OPENSSL_NO_ENGINE <S2SV_StartVul> if (!pkey && e) <S2SV_EndVul> ENGINE_finish(e); #endif <S2SV_StartVul> if (!ameth) { <S2SV_EndVul> EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM); return 0; } if (pkey) { pkey->ameth = ameth; pkey->engine = e; pkey->type = pkey->ameth->pkey_id; pkey->save_type = type; } return 1; }","- if (pkey->engine) {
- ENGINE_finish(pkey->engine);
- pkey->engine = NULL;
- }
- if (!pkey && e)
- if (!ameth) {
+ ENGINE_finish(pkey->engine);
+ pkey->engine = NULL;
+ if (pkey == NULL)
+ if (ameth == NULL) {","static int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len) { const EVP_PKEY_ASN1_METHOD *ameth; ENGINE *e = NULL; if (pkey) { if (pkey->pkey.ptr) EVP_PKEY_free_it(pkey); if ((type == pkey->save_type) && pkey->ameth) return 1; #ifndef OPENSSL_NO_ENGINE ENGINE_finish(pkey->engine); pkey->engine = NULL; #endif } if (str) ameth = EVP_PKEY_asn1_find_str(&e, str, len); else ameth = EVP_PKEY_asn1_find(&e, type); #ifndef OPENSSL_NO_ENGINE if (pkey == NULL) ENGINE_finish(e); #endif if (ameth == NULL) { EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM); return 0; } if (pkey) { pkey->ameth = ameth; pkey->engine = e; pkey->type = pkey->ameth->pkey_id; pkey->save_type = type; } return 1; }"
2454----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_8646ed0f061439ee9b19dcb370d3bab11d889799_1.json----postprocess_chroma,"static void postprocess_chroma(AVFrame *frame, int w, int h, int depth) { uint16_t *dstu = (uint16_t *)frame->data[1]; uint16_t *dstv = (uint16_t *)frame->data[2]; int16_t *srcu = (int16_t *)frame->data[1]; int16_t *srcv = (int16_t *)frame->data[2]; ptrdiff_t strideu = frame->linesize[1] / 2; ptrdiff_t stridev = frame->linesize[2] / 2; <S2SV_StartVul> const int add = 1 << (depth - 1); <S2SV_EndVul> <S2SV_StartVul> const int shift = 16 - depth; <S2SV_EndVul> int i, j; for (j = 0; j < h; j++) { for (i = 0; i < w; i++) { dstu[i] = (add + srcu[i]) << shift; dstv[i] = (add + srcv[i]) << shift; } dstu += strideu; dstv += stridev; srcu += strideu; srcv += stridev; } }","- const int add = 1 << (depth - 1);
- const int shift = 16 - depth;
+ const unsigned add = 1 << (depth - 1);
+ const unsigned shift = 16 - depth;","static void postprocess_chroma(AVFrame *frame, int w, int h, int depth) { uint16_t *dstu = (uint16_t *)frame->data[1]; uint16_t *dstv = (uint16_t *)frame->data[2]; int16_t *srcu = (int16_t *)frame->data[1]; int16_t *srcv = (int16_t *)frame->data[2]; ptrdiff_t strideu = frame->linesize[1] / 2; ptrdiff_t stridev = frame->linesize[2] / 2; const unsigned add = 1 << (depth - 1); const unsigned shift = 16 - depth; int i, j; for (j = 0; j < h; j++) { for (i = 0; i < w; i++) { dstu[i] = (add + srcu[i]) << shift; dstv[i] = (add + srcv[i]) << shift; } dstu += strideu; dstv += stridev; srcu += strideu; srcv += stridev; } }"
10415----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_04a31f82ffb91b9f1a88b0b360385283a2ab8a3b_1.json----PEM_dek_info,"void PEM_dek_info(char *buf, const char *type, int len, char *str) { static const unsigned char map[17]=""0123456789ABCDEF""; long i; int j; <S2SV_StartVul> strcat(buf,""DEK-Info: ""); <S2SV_EndVul> <S2SV_StartVul> strcat(buf,type); <S2SV_EndVul> <S2SV_StartVul> strcat(buf,"",""); <S2SV_EndVul> j=strlen(buf); for (i=0; i<len; i++) { buf[j+i*2] =map[(str[i]>>4)&0x0f]; buf[j+i*2+1]=map[(str[i] )&0x0f]; } buf[j+i*2]='\n'; buf[j+i*2+1]='\0'; }","- strcat(buf,""DEK-Info: "");
- strcat(buf,type);
- strcat(buf,"","");
+ BUF_strlcat(buf,""DEK-Info: "",PEM_BUFSIZE);
+ BUF_strlcat(buf,type,PEM_BUFSIZE);
+ BUF_strlcat(buf,"","",PEM_BUFSIZE);
+ if (j + (len * 2) + 1 > PEM_BUFSIZE)
+ return;","void PEM_dek_info(char *buf, const char *type, int len, char *str) { static const unsigned char map[17]=""0123456789ABCDEF""; long i; int j; BUF_strlcat(buf,""DEK-Info: "",PEM_BUFSIZE); BUF_strlcat(buf,type,PEM_BUFSIZE); BUF_strlcat(buf,"","",PEM_BUFSIZE); j=strlen(buf); if (j + (len * 2) + 1 > PEM_BUFSIZE) return; for (i=0; i<len; i++) { buf[j+i*2] =map[(str[i]>>4)&0x0f]; buf[j+i*2+1]=map[(str[i] )&0x0f]; } buf[j+i*2]='\n'; buf[j+i*2+1]='\0'; }"
5897----INTEGER_OVERFLOW_L1----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3644247598a032833b6daee2c2f78f5ba73d7d0d_1.json----ff_mov_close_hinting,void ff_mov_close_hinting(MOVTrack *track) { AVFormatContext *rtp_ctx = track->rtp_ctx; <S2SV_StartVul> av_freep(&track->enc); <S2SV_EndVul> sample_queue_free(&track->sample_queue); if (!rtp_ctx) return; if (rtp_ctx->pb) { av_write_trailer(rtp_ctx); ffio_free_dyn_buf(&rtp_ctx->pb); } avformat_free_context(rtp_ctx); },"- av_freep(&track->enc);
+ avcodec_parameters_free(&track->par);",void ff_mov_close_hinting(MOVTrack *track) { AVFormatContext *rtp_ctx = track->rtp_ctx; avcodec_parameters_free(&track->par); sample_queue_free(&track->sample_queue); if (!rtp_ctx) return; if (rtp_ctx->pb) { av_write_trailer(rtp_ctx); ffio_free_dyn_buf(&rtp_ctx->pb); } avformat_free_context(rtp_ctx); }
14176----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_88e1b2a7a8c46de216d606056df8de59d967acfe_1.json----test_modexp_mont5,"static int test_modexp_mont5(void) { BIGNUM *a = NULL, *p = NULL, *m = NULL, *d = NULL, *e = NULL; BIGNUM *b = NULL, *n = NULL, *c = NULL; BN_MONT_CTX *mont = NULL; int st = 0; if (!TEST_ptr(a = BN_new()) || !TEST_ptr(p = BN_new()) || !TEST_ptr(m = BN_new()) || !TEST_ptr(d = BN_new()) || !TEST_ptr(e = BN_new()) || !TEST_ptr(b = BN_new()) || !TEST_ptr(n = BN_new()) || !TEST_ptr(c = BN_new()) || !TEST_ptr(mont = BN_MONT_CTX_new())) goto err; BN_bntest_rand(m, 1024, 0, 1); BN_bntest_rand(a, 1024, 0, 0); BN_zero(p); if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL))) goto err; if (!TEST_BN_eq_one(d)) goto err; BN_hex2bn(&a, ""7878787878787878787878787878787878787878787878787878787878787878"" ""7878787878787878787878787878787878787878787878787878787878787878"" ""7878787878787878787878787878787878787878787878787878787878787878"" ""7878787878787878787878787878787878787878787878787878787878787878""); BN_hex2bn(&b, ""095D72C08C097BA488C5E439C655A192EAFB6380073D8C2664668EDDB4060744"" ""E16E57FB4EDB9AE10A0CEFCDC28A894F689A128379DB279D48A2E20849D68593"" ""9B7803BCF46CEBF5C533FB0DD35B080593DE5472E3FE5DB951B8BFF9B4CB8F03"" ""9CC638A5EE8CDD703719F8000E6A9F63BEED5F2FCD52FF293EA05A251BB4AB81""); BN_hex2bn(&n, ""D78AF684E71DB0C39CFF4E64FB9DB567132CB9C50CC98009FEB820B26F2DED9B"" ""91B9B5E2B83AE0AE4EB4E0523CA726BFBE969B89FD754F674CE99118C3F2D1C5"" ""D81FDC7C54E02B60262B241D53C040E99E45826ECA37A804668E690E1AFC1CA4"" ""2C9A15D84D4954425F0B7642FC0BD9D7B24E2618D2DCC9B729D944BADACFDDAF""); BN_MONT_CTX_set(mont, n, ctx); BN_mod_mul_montgomery(c, a, b, mont, ctx); BN_mod_mul_montgomery(d, b, a, mont, ctx); if (!TEST_BN_eq(c, d)) goto err; parse_bigBN(&n, bn1strings); parse_bigBN(&a, bn2strings); BN_free(b); b = BN_dup(a); BN_MONT_CTX_set(mont, n, ctx); BN_mod_mul_montgomery(c, a, a, mont, ctx); BN_mod_mul_montgomery(d, a, b, mont, ctx); if (!TEST_BN_eq(c, d)) goto err; { static const char *ahex[] = { ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8FFEADBCFC4DAE7FFF908E92820306B"", ""9544D954000000006C0000000000000000000000000000000000000000000000"", ""00000000000000000000FF030202FFFFF8FFEBDBCFC4DAE7FFF908E92820306B"", ""9544D954000000006C000000FF0302030000000000FFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01FC00FF02FFFFFFFF"", ""00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FCFD"", ""FCFFFFFFFFFF000000000000000000FF0302030000000000FFFFFFFFFFFFFFFF"", ""FF00FCFDFDFF030202FF00000000FFFFFFFFFFFFFFFFFF00FCFDFCFFFFFFFFFF"", NULL }; static const char *nhex[] = { ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8F8F8F8000000"", ""00000010000000006C0000000000000000000000000000000000000000000000"", ""00000000000000000000000000000000000000FFFFFFFFFFFFF8F8F8F8000000"", ""00000010000000006C000000000000000000000000FFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFF000000000000000000000000000000000000FFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", NULL }; parse_bigBN(&a, ahex); parse_bigBN(&n, nhex); } BN_free(b); b = BN_dup(a); BN_MONT_CTX_set(mont, n, ctx); <S2SV_StartVul> BN_mod_mul_montgomery(c, a, a, mont, ctx); <S2SV_EndVul> <S2SV_StartVul> BN_mod_mul_montgomery(d, a, b, mont, ctx); <S2SV_EndVul> <S2SV_StartVul> if (!TEST_BN_eq(c, d)) <S2SV_EndVul> goto err; BN_hex2bn(&a, ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020DF""); BN_hex2bn(&b, ""2020202020202020202020202020202020202020202020202020202020202020"" ""2020202020202020202020202020202020202020202020202020202020202020"" ""20202020202020FF202020202020202020202020202020202020202020202020"" ""2020202020202020202020202020202020202020202020202020202020202020""); BN_hex2bn(&n, ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020FF""); BN_MONT_CTX_set(mont, n, ctx); BN_mod_exp_mont_consttime(c, a, b, n, ctx, mont); BN_mod_exp_mont(d, a, b, n, ctx, mont); if (!TEST_BN_eq(c, d)) goto err; BN_bntest_rand(p, 1024, 0, 0); BN_zero(a); if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL)) || !TEST_BN_eq_zero(d)) goto err; BN_one(a); BN_MONT_CTX_set(mont, m, ctx); if (!TEST_true(BN_from_montgomery(e, a, mont, ctx)) || !TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL)) || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx)) || !TEST_BN_eq(a, d)) goto err; BN_bntest_rand(e, 1024, 0, 0); if (!TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL)) || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx)) || !TEST_BN_eq(a, d)) goto err; st = 1; err: BN_MONT_CTX_free(mont); BN_free(a); BN_free(p); BN_free(m); BN_free(d); BN_free(e); BN_free(b); BN_free(n); BN_free(c); return st; }","- BN_mod_mul_montgomery(c, a, a, mont, ctx);
- BN_mod_mul_montgomery(d, a, b, mont, ctx);
- if (!TEST_BN_eq(c, d))
+ if (!TEST_true(BN_mod_mul_montgomery(c, a, a, mont, ctx))
+ || !TEST_true(BN_mod_mul_montgomery(d, a, b, mont, ctx))
+ || !TEST_BN_eq(c, d))
+ goto err;
+ BN_hex2bn(&a,
+ ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""
+ ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""
+ ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"");
+ BN_hex2bn(&n,
+ ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""
+ ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"");
+ BN_MONT_CTX_set(mont, n, ctx);
+ if (!TEST_false(BN_mod_mul_montgomery(d, a, a, mont, ctx)))","static int test_modexp_mont5(void) { BIGNUM *a = NULL, *p = NULL, *m = NULL, *d = NULL, *e = NULL; BIGNUM *b = NULL, *n = NULL, *c = NULL; BN_MONT_CTX *mont = NULL; int st = 0; if (!TEST_ptr(a = BN_new()) || !TEST_ptr(p = BN_new()) || !TEST_ptr(m = BN_new()) || !TEST_ptr(d = BN_new()) || !TEST_ptr(e = BN_new()) || !TEST_ptr(b = BN_new()) || !TEST_ptr(n = BN_new()) || !TEST_ptr(c = BN_new()) || !TEST_ptr(mont = BN_MONT_CTX_new())) goto err; BN_bntest_rand(m, 1024, 0, 1); BN_bntest_rand(a, 1024, 0, 0); BN_zero(p); if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL))) goto err; if (!TEST_BN_eq_one(d)) goto err; BN_hex2bn(&a, ""7878787878787878787878787878787878787878787878787878787878787878"" ""7878787878787878787878787878787878787878787878787878787878787878"" ""7878787878787878787878787878787878787878787878787878787878787878"" ""7878787878787878787878787878787878787878787878787878787878787878""); BN_hex2bn(&b, ""095D72C08C097BA488C5E439C655A192EAFB6380073D8C2664668EDDB4060744"" ""E16E57FB4EDB9AE10A0CEFCDC28A894F689A128379DB279D48A2E20849D68593"" ""9B7803BCF46CEBF5C533FB0DD35B080593DE5472E3FE5DB951B8BFF9B4CB8F03"" ""9CC638A5EE8CDD703719F8000E6A9F63BEED5F2FCD52FF293EA05A251BB4AB81""); BN_hex2bn(&n, ""D78AF684E71DB0C39CFF4E64FB9DB567132CB9C50CC98009FEB820B26F2DED9B"" ""91B9B5E2B83AE0AE4EB4E0523CA726BFBE969B89FD754F674CE99118C3F2D1C5"" ""D81FDC7C54E02B60262B241D53C040E99E45826ECA37A804668E690E1AFC1CA4"" ""2C9A15D84D4954425F0B7642FC0BD9D7B24E2618D2DCC9B729D944BADACFDDAF""); BN_MONT_CTX_set(mont, n, ctx); BN_mod_mul_montgomery(c, a, b, mont, ctx); BN_mod_mul_montgomery(d, b, a, mont, ctx); if (!TEST_BN_eq(c, d)) goto err; parse_bigBN(&n, bn1strings); parse_bigBN(&a, bn2strings); BN_free(b); b = BN_dup(a); BN_MONT_CTX_set(mont, n, ctx); BN_mod_mul_montgomery(c, a, a, mont, ctx); BN_mod_mul_montgomery(d, a, b, mont, ctx); if (!TEST_BN_eq(c, d)) goto err; { static const char *ahex[] = { ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8FFEADBCFC4DAE7FFF908E92820306B"", ""9544D954000000006C0000000000000000000000000000000000000000000000"", ""00000000000000000000FF030202FFFFF8FFEBDBCFC4DAE7FFF908E92820306B"", ""9544D954000000006C000000FF0302030000000000FFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01FC00FF02FFFFFFFF"", ""00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FCFD"", ""FCFFFFFFFFFF000000000000000000FF0302030000000000FFFFFFFFFFFFFFFF"", ""FF00FCFDFDFF030202FF00000000FFFFFFFFFFFFFFFFFF00FCFDFCFFFFFFFFFF"", NULL }; static const char *nhex[] = { ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8F8F8F8000000"", ""00000010000000006C0000000000000000000000000000000000000000000000"", ""00000000000000000000000000000000000000FFFFFFFFFFFFF8F8F8F8000000"", ""00000010000000006C000000000000000000000000FFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFF000000000000000000000000000000000000FFFFFFFFFFFFFFFF"", ""FFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"", NULL }; parse_bigBN(&a, ahex); parse_bigBN(&n, nhex); } BN_free(b); b = BN_dup(a); BN_MONT_CTX_set(mont, n, ctx); if (!TEST_true(BN_mod_mul_montgomery(c, a, a, mont, ctx)) || !TEST_true(BN_mod_mul_montgomery(d, a, b, mont, ctx)) || !TEST_BN_eq(c, d)) goto err; BN_hex2bn(&a, ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""); BN_hex2bn(&n, ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF""); BN_MONT_CTX_set(mont, n, ctx); if (!TEST_false(BN_mod_mul_montgomery(d, a, a, mont, ctx))) goto err; BN_hex2bn(&a, ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020DF""); BN_hex2bn(&b, ""2020202020202020202020202020202020202020202020202020202020202020"" ""2020202020202020202020202020202020202020202020202020202020202020"" ""20202020202020FF202020202020202020202020202020202020202020202020"" ""2020202020202020202020202020202020202020202020202020202020202020""); BN_hex2bn(&n, ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"" ""FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020FF""); BN_MONT_CTX_set(mont, n, ctx); BN_mod_exp_mont_consttime(c, a, b, n, ctx, mont); BN_mod_exp_mont(d, a, b, n, ctx, mont); if (!TEST_BN_eq(c, d)) goto err; BN_bntest_rand(p, 1024, 0, 0); BN_zero(a); if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL)) || !TEST_BN_eq_zero(d)) goto err; BN_one(a); BN_MONT_CTX_set(mont, m, ctx); if (!TEST_true(BN_from_montgomery(e, a, mont, ctx)) || !TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL)) || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx)) || !TEST_BN_eq(a, d)) goto err; BN_bntest_rand(e, 1024, 0, 0); if (!TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL)) || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx)) || !TEST_BN_eq(a, d)) goto err; st = 1; err: BN_MONT_CTX_free(mont); BN_free(a); BN_free(p); BN_free(m); BN_free(d); BN_free(e); BN_free(b); BN_free(n); BN_free(c); return st; }"
11514----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2cd53e61f29e3accda637c7621f00d495d9045a9_1.json----dh_init,"<S2SV_StartVul> static int dh_init(void *vpdhctx, OSSL_PARAM params[]) <S2SV_EndVul> { PROV_DH_CTX *pdhctx = (PROV_DH_CTX *)vpdhctx; DH_free(pdhctx->dh); <S2SV_StartVul> pdhctx->dh = param_to_dh(params, 1); <S2SV_EndVul> return pdhctx->dh != NULL; }","- static int dh_init(void *vpdhctx, OSSL_PARAM params[])
- pdhctx->dh = param_to_dh(params, 1);
+ static int dh_init(void *vpdhctx, void *vdh)
+ pdhctx->dh = vdh;
+ DH_up_ref(pdhctx->dh);","static int dh_init(void *vpdhctx, void *vdh) { PROV_DH_CTX *pdhctx = (PROV_DH_CTX *)vpdhctx; DH_free(pdhctx->dh); pdhctx->dh = vdh; DH_up_ref(pdhctx->dh); return pdhctx->dh != NULL; }"
11082----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c933a249550ce37ead5f92298d2d7282f0158e2_1.json----do_dtls1_write,"int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment) { unsigned char *p,*pseq; int i,mac_size,clear=0; int prefix_len = 0; SSL3_RECORD *wr; SSL3_BUFFER *wb; SSL_SESSION *sess; int bs; if (s->s3->wbuf.left != 0) { OPENSSL_assert(0); return(ssl3_write_pending(s,type,buf,len)); } if (s->s3->alert_dispatch) { i=s->method->ssl_dispatch_alert(s); if (i <= 0) return(i); } if (len == 0 && !create_empty_fragment) return 0; wr= &(s->s3->wrec); wb= &(s->s3->wbuf); sess=s->session; if ( (sess == NULL) || (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) clear=1; if (clear) mac_size=0; else mac_size=EVP_MD_CTX_size(s->write_hash); #if 0 if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done && SSL_version(s) != DTLS1_VERSION) { if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) { prefix_len = s->method->do_ssl_write(s, type, buf, 0, 1); if (prefix_len <= 0) goto err; if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE) { SSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR); goto err; } } s->s3->empty_fragment_done = 1; } #endif p = wb->buf + prefix_len; *(p++)=type&0xff; wr->type=type; *(p++)=(s->version>>8); *(p++)=s->version&0xff; pseq=p; p+=10; if ( s->enc_write_ctx && (EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE)) bs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher); else bs = 0; wr->data=p + bs; wr->length=(int)len; wr->input=(unsigned char *)buf; if (s->compress != NULL) { if (!ssl3_do_compress(s)) { SSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE); goto err; } } else { memcpy(wr->data,wr->input,wr->length); wr->input=wr->data; } if (mac_size != 0) { s->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1); wr->length+=mac_size; } wr->input=p; wr->data=p; <S2SV_StartVul> wr->length += bs; <S2SV_EndVul> s->method->ssl3_enc->enc(s,1); s2n(s->d1->w_epoch, pseq); memcpy(pseq, &(s->s3->write_sequence[2]), 6); pseq+=6; s2n(wr->length,pseq); wr->type=type; wr->length+=DTLS1_RT_HEADER_LENGTH; #if 0 if ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC) dtls1_buffer_record(s, wr->data, wr->length, *((PQ_64BIT *)&(s->s3->write_sequence[0]))); #endif ssl3_record_sequence_update(&(s->s3->write_sequence[0])); if (create_empty_fragment) { return wr->length; } wb->left = prefix_len + wr->length; wb->offset = 0; s->s3->wpend_tot=len; s->s3->wpend_buf=buf; s->s3->wpend_type=type; s->s3->wpend_ret=len; return ssl3_write_pending(s,type,buf,len); err: return -1; }","- wr->length += bs; /* bs != 0 in case of CBC. The enc fn provides
+ {
+ RAND_pseudo_bytes(p,bs);
+ wr->length += bs;
+ }","int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment) { unsigned char *p,*pseq; int i,mac_size,clear=0; int prefix_len = 0; SSL3_RECORD *wr; SSL3_BUFFER *wb; SSL_SESSION *sess; int bs; if (s->s3->wbuf.left != 0) { OPENSSL_assert(0); return(ssl3_write_pending(s,type,buf,len)); } if (s->s3->alert_dispatch) { i=s->method->ssl_dispatch_alert(s); if (i <= 0) return(i); } if (len == 0 && !create_empty_fragment) return 0; wr= &(s->s3->wrec); wb= &(s->s3->wbuf); sess=s->session; if ( (sess == NULL) || (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) clear=1; if (clear) mac_size=0; else mac_size=EVP_MD_CTX_size(s->write_hash); #if 0 if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done && SSL_version(s) != DTLS1_VERSION) { if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) { prefix_len = s->method->do_ssl_write(s, type, buf, 0, 1); if (prefix_len <= 0) goto err; if (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE) { SSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR); goto err; } } s->s3->empty_fragment_done = 1; } #endif p = wb->buf + prefix_len; *(p++)=type&0xff; wr->type=type; *(p++)=(s->version>>8); *(p++)=s->version&0xff; pseq=p; p+=10; if ( s->enc_write_ctx && (EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE)) bs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher); else bs = 0; wr->data=p + bs; wr->length=(int)len; wr->input=(unsigned char *)buf; if (s->compress != NULL) { if (!ssl3_do_compress(s)) { SSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE); goto err; } } else { memcpy(wr->data,wr->input,wr->length); wr->input=wr->data; } if (mac_size != 0) { s->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1); wr->length+=mac_size; } wr->input=p; wr->data=p; if (bs) { RAND_pseudo_bytes(p,bs); wr->length += bs; } s->method->ssl3_enc->enc(s,1); s2n(s->d1->w_epoch, pseq); memcpy(pseq, &(s->s3->write_sequence[2]), 6); pseq+=6; s2n(wr->length,pseq); wr->type=type; wr->length+=DTLS1_RT_HEADER_LENGTH; #if 0 if ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC) dtls1_buffer_record(s, wr->data, wr->length, *((PQ_64BIT *)&(s->s3->write_sequence[0]))); #endif ssl3_record_sequence_update(&(s->s3->write_sequence[0])); if (create_empty_fragment) { return wr->length; } wb->left = prefix_len + wr->length; wb->offset = 0; s->s3->wpend_tot=len; s->s3->wpend_buf=buf; s->s3->wpend_type=type; s->s3->wpend_ret=len; return ssl3_write_pending(s,type,buf,len); err: return -1; }"
5619----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26c345d5e1490ea3c0739e1d13190ea184c0c2a6_1.json----decode_frame,"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; <S2SV_StartVul> MpegEncContext *s = &h->s; <S2SV_EndVul> AVFrame *pict = data; int buf_index = 0; <S2SV_StartVul> s->flags = avctx->flags; <S2SV_EndVul> <S2SV_StartVul> s->flags2 = avctx->flags2; <S2SV_EndVul> out: if (buf_size == 0) { Picture *out; int i, out_idx; <S2SV_StartVul> s->current_picture_ptr = NULL; <S2SV_EndVul> out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { *got_frame = 1; *pict = out->f; } return buf_index; } buf_index = decode_nal_units(h, buf, buf_size, 0); if (buf_index < 0) return -1; <S2SV_StartVul> if (!s->current_picture_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { <S2SV_EndVul> buf_size = 0; goto out; } <S2SV_StartVul> if (!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr) { <S2SV_EndVul> if (avctx->skip_frame >= AVDISCARD_NONREF) return 0; av_log(avctx, AV_LOG_ERROR, ""no frame!\n""); return -1; } <S2SV_StartVul> if (!(s->flags2 & CODEC_FLAG2_CHUNKS) || <S2SV_EndVul> <S2SV_StartVul> (s->mb_y >= s->mb_height && s->mb_height)) { <S2SV_EndVul> <S2SV_StartVul> if (s->flags2 & CODEC_FLAG2_CHUNKS) <S2SV_EndVul> decode_postinit(h, 1); field_end(h, 0); <S2SV_StartVul> h->context_reinitialized = 0; <S2SV_EndVul> if (!h->next_output_pic) { *got_frame = 0; } else { *got_frame = 1; *pict = h->next_output_pic->f; } } assert(pict->data[0] || !*got_frame); <S2SV_StartVul> ff_print_debug_info(s, pict); <S2SV_EndVul> <S2SV_StartVul> return get_consumed_bytes(s, buf_index, buf_size); <S2SV_EndVul> }","- MpegEncContext *s = &h->s;
- s->flags = avctx->flags;
- s->flags2 = avctx->flags2;
- s->current_picture_ptr = NULL;
- if (!s->current_picture_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {
- if (!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr) {
- if (!(s->flags2 & CODEC_FLAG2_CHUNKS) ||
- (s->mb_y >= s->mb_height && s->mb_height)) {
- if (s->flags2 & CODEC_FLAG2_CHUNKS)
- h->context_reinitialized = 0;
- ff_print_debug_info(s, pict);
- return get_consumed_bytes(s, buf_index, buf_size);
+ h->flags = avctx->flags;
+ h->cur_pic_ptr = NULL;
+ if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {
+ if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {
+ if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||
+ (h->mb_y >= h->mb_height && h->mb_height)) {
+ if (avctx->flags2 & CODEC_FLAG2_CHUNKS)
+ return get_consumed_bytes(buf_index, buf_size);","static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; H264Context *h = avctx->priv_data; AVFrame *pict = data; int buf_index = 0; h->flags = avctx->flags; out: if (buf_size == 0) { Picture *out; int i, out_idx; h->cur_pic_ptr = NULL; out = h->delayed_pic[0]; out_idx = 0; for (i = 1; h->delayed_pic[i] && !h->delayed_pic[i]->f.key_frame && !h->delayed_pic[i]->mmco_reset; i++) if (h->delayed_pic[i]->poc < out->poc) { out = h->delayed_pic[i]; out_idx = i; } for (i = out_idx; h->delayed_pic[i]; i++) h->delayed_pic[i] = h->delayed_pic[i + 1]; if (out) { *got_frame = 1; *pict = out->f; } return buf_index; } buf_index = decode_nal_units(h, buf, buf_size, 0); if (buf_index < 0) return -1; if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) { buf_size = 0; goto out; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) { if (avctx->skip_frame >= AVDISCARD_NONREF) return 0; av_log(avctx, AV_LOG_ERROR, ""no frame!\n""); return -1; } if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) || (h->mb_y >= h->mb_height && h->mb_height)) { if (avctx->flags2 & CODEC_FLAG2_CHUNKS) decode_postinit(h, 1); field_end(h, 0); if (!h->next_output_pic) { *got_frame = 0; } else { *got_frame = 1; *pict = h->next_output_pic->f; } } assert(pict->data[0] || !*got_frame); return get_consumed_bytes(buf_index, buf_size); }"
2065----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7129e33db931264ec425cd5e7f43770f36f9e501_1.json----rm_assemble_video_frame,"static int rm_assemble_video_frame(AVFormatContext *s, ByteIOContext *pb, RMDemuxContext *rm, RMStream *vst, AVPacket *pkt, int len) { int hdr, seq, pic_num, len2, pos; int type; hdr = get_byte(pb); len--; type = hdr >> 6; if(type != 3){ seq = get_byte(pb); len--; } if(type != 1){ len2 = get_num(pb, &len); pos = get_num(pb, &len); pic_num = get_byte(pb); len--; } if(len<0) return -1; rm->remaining_len = len; if(type&1){ if(type == 3) len= len2; if(rm->remaining_len < len) return -1; rm->remaining_len -= len; if(av_new_packet(pkt, len + 9) < 0) return AVERROR(EIO); pkt->data[0] = 0; AV_WL32(pkt->data + 1, 1); AV_WL32(pkt->data + 5, 0); get_buffer(pb, pkt->data + 9, len); return 0; } if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){ vst->slices = ((hdr & 0x3F) << 1) + 1; vst->videobufsize = len2 + 8*vst->slices + 1; av_free_packet(&vst->pkt); if(av_new_packet(&vst->pkt, vst->videobufsize) < 0) return AVERROR(ENOMEM); vst->videobufpos = 8*vst->slices + 1; vst->cur_slice = 0; vst->curpic_num = pic_num; vst->pktpos = url_ftell(pb); } if(type == 2) len = FFMIN(len, pos); if(++vst->cur_slice > vst->slices) return 1; AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1); AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1); if(vst->videobufpos + len > vst->videobufsize) return 1; if (get_buffer(pb, vst->pkt.data + vst->videobufpos, len) != len) return AVERROR(EIO); vst->videobufpos += len; rm->remaining_len-= len; if(type == 2 || (vst->videobufpos) == vst->videobufsize){ vst->pkt.data[0] = vst->cur_slice-1; *pkt= vst->pkt; vst->pkt.data= vst->pkt.size= 0; if(vst->slices != vst->cur_slice) memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices, vst->videobufpos - 1 - 8*vst->slices); <S2SV_StartVul> pkt->size += 8*(vst->cur_slice - vst->slices); <S2SV_EndVul> pkt->pts = AV_NOPTS_VALUE; pkt->pos = vst->pktpos; return 0; } return 1; }","- pkt->size += 8*(vst->cur_slice - vst->slices);
+ pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices);","static int rm_assemble_video_frame(AVFormatContext *s, ByteIOContext *pb, RMDemuxContext *rm, RMStream *vst, AVPacket *pkt, int len) { int hdr, seq, pic_num, len2, pos; int type; hdr = get_byte(pb); len--; type = hdr >> 6; if(type != 3){ seq = get_byte(pb); len--; } if(type != 1){ len2 = get_num(pb, &len); pos = get_num(pb, &len); pic_num = get_byte(pb); len--; } if(len<0) return -1; rm->remaining_len = len; if(type&1){ if(type == 3) len= len2; if(rm->remaining_len < len) return -1; rm->remaining_len -= len; if(av_new_packet(pkt, len + 9) < 0) return AVERROR(EIO); pkt->data[0] = 0; AV_WL32(pkt->data + 1, 1); AV_WL32(pkt->data + 5, 0); get_buffer(pb, pkt->data + 9, len); return 0; } if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){ vst->slices = ((hdr & 0x3F) << 1) + 1; vst->videobufsize = len2 + 8*vst->slices + 1; av_free_packet(&vst->pkt); if(av_new_packet(&vst->pkt, vst->videobufsize) < 0) return AVERROR(ENOMEM); vst->videobufpos = 8*vst->slices + 1; vst->cur_slice = 0; vst->curpic_num = pic_num; vst->pktpos = url_ftell(pb); } if(type == 2) len = FFMIN(len, pos); if(++vst->cur_slice > vst->slices) return 1; AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1); AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1); if(vst->videobufpos + len > vst->videobufsize) return 1; if (get_buffer(pb, vst->pkt.data + vst->videobufpos, len) != len) return AVERROR(EIO); vst->videobufpos += len; rm->remaining_len-= len; if(type == 2 || (vst->videobufpos) == vst->videobufsize){ vst->pkt.data[0] = vst->cur_slice-1; *pkt= vst->pkt; vst->pkt.data= vst->pkt.size= 0; if(vst->slices != vst->cur_slice) memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices, vst->videobufpos - 1 - 8*vst->slices); pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices); pkt->pts = AV_NOPTS_VALUE; pkt->pos = vst->pktpos; return 0; } return 1; }"
7592----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_9c1ec15923ed80cafef4c4dd435bd79a88c53506_1.json----decode_ac_coeffs,"static inline void decode_ac_coeffs(GetBitContext *gb, DCTELEM *out, int blocks_per_slice, int plane_size_factor, const uint8_t *scan) { int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index; int max_coeffs, bits_left; run = 4; level = 2; max_coeffs = blocks_per_slice << 6; block_mask = blocks_per_slice - 1; for (pos = blocks_per_slice - 1; pos < max_coeffs;) { run_cb_index = run_to_cb_index[FFMIN(run, 15)]; lev_cb_index = lev_to_cb_index[FFMIN(level, 9)]; bits_left = get_bits_left(gb); <S2SV_StartVul> if (bits_left <= 8 && !show_bits(gb, bits_left)) <S2SV_EndVul> return; run = decode_vlc_codeword(gb, ac_codebook[run_cb_index]); bits_left = get_bits_left(gb); <S2SV_StartVul> if (bits_left <= 8 && !show_bits(gb, bits_left)) <S2SV_EndVul> return; level = decode_vlc_codeword(gb, ac_codebook[lev_cb_index]) + 1; pos += run + 1; if (pos >= max_coeffs) break; sign = get_sbits(gb, 1); out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] = (level ^ sign) - sign; } }","- if (bits_left <= 8 && !show_bits(gb, bits_left))
- if (bits_left <= 8 && !show_bits(gb, bits_left))
+ if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))
+ if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))","static inline void decode_ac_coeffs(GetBitContext *gb, DCTELEM *out, int blocks_per_slice, int plane_size_factor, const uint8_t *scan) { int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index; int max_coeffs, bits_left; run = 4; level = 2; max_coeffs = blocks_per_slice << 6; block_mask = blocks_per_slice - 1; for (pos = blocks_per_slice - 1; pos < max_coeffs;) { run_cb_index = run_to_cb_index[FFMIN(run, 15)]; lev_cb_index = lev_to_cb_index[FFMIN(level, 9)]; bits_left = get_bits_left(gb); if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left))) return; run = decode_vlc_codeword(gb, ac_codebook[run_cb_index]); bits_left = get_bits_left(gb); if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left))) return; level = decode_vlc_codeword(gb, ac_codebook[lev_cb_index]) + 1; pos += run + 1; if (pos >= max_coeffs) break; sign = get_sbits(gb, 1); out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] = (level ^ sign) - sign; } }"
15241----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_aecad434706c8bb0b140168ce2e12a1a77c547a4_1.json----ssl_cert_set0_chain,"<S2SV_StartVul> int ssl_cert_set0_chain(CERT *c, STACK_OF(X509) *chain) <S2SV_EndVul> { <S2SV_StartVul> CERT_PKEY *cpk = c->key; <S2SV_EndVul> if (!cpk) return 0; if (cpk->chain) sk_X509_pop_free(cpk->chain, X509_free); cpk->chain = chain; return 1; }","- int ssl_cert_set0_chain(CERT *c, STACK_OF(X509) *chain)
- CERT_PKEY *cpk = c->key;
+ int ssl_cert_set0_chain(SSL *s, SSL_CTX *ctx, STACK_OF(X509) *chain)
+ int i, r;
+ CERT_PKEY *cpk = s ? s->cert->key : ctx->cert->key;
+ for (i = 0; i < sk_X509_num(chain); i++)
+ {
+ r = ssl_security_cert(s, ctx, sk_X509_value(chain, i), 0, 0);
+ if (r != 1)
+ {
+ SSLerr(SSL_F_SSL_CERT_SET0_CHAIN, r);
+ return 0;
+ }
+ }","int ssl_cert_set0_chain(SSL *s, SSL_CTX *ctx, STACK_OF(X509) *chain) { int i, r; CERT_PKEY *cpk = s ? s->cert->key : ctx->cert->key; if (!cpk) return 0; if (cpk->chain) sk_X509_pop_free(cpk->chain, X509_free); for (i = 0; i < sk_X509_num(chain); i++) { r = ssl_security_cert(s, ctx, sk_X509_value(chain, i), 0, 0); if (r != 1) { SSLerr(SSL_F_SSL_CERT_SET0_CHAIN, r); return 0; } } cpk->chain = chain; return 1; }"
11855----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_384f1da828754015a605aef19222a60d2f80c036_1.json----verify_main,"int MAIN(int argc, char **argv) { int i,ret=1; int purpose = -1; char *CApath=NULL,*CAfile=NULL; <S2SV_StartVul> char *untfile = NULL; <S2SV_EndVul> <S2SV_StartVul> STACK_OF(X509) *untrusted = NULL; <S2SV_EndVul> X509_STORE *cert_ctx=NULL; X509_LOOKUP *lookup=NULL; cert_ctx=X509_STORE_new(); if (cert_ctx == NULL) goto end; X509_STORE_set_verify_cb_func(cert_ctx,cb); ERR_load_crypto_strings(); apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); argc--; argv++; for (;;) { if (argc >= 1) { if (strcmp(*argv,""-CApath"") == 0) { if (argc-- < 1) goto end; CApath= *(++argv); } else if (strcmp(*argv,""-CAfile"") == 0) { if (argc-- < 1) goto end; CAfile= *(++argv); } else if (strcmp(*argv,""-purpose"") == 0) { X509_PURPOSE *xptmp; if (argc-- < 1) goto end; i = X509_PURPOSE_get_by_sname(*(++argv)); if(i < 0) { BIO_printf(bio_err, ""unrecognized purpose\n""); goto end; } xptmp = X509_PURPOSE_get0(i); purpose = X509_PURPOSE_get_id(xptmp); } else if (strcmp(*argv,""-untrusted"") == 0) { if (argc-- < 1) goto end; untfile= *(++argv); } else if (strcmp(*argv,""-help"") == 0) goto end; else if (strcmp(*argv,""-verbose"") == 0) v_verbose=1; else if (argv[0][0] == '-') goto end; else break; argc--; argv++; } else break; } lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file()); if (lookup == NULL) abort(); if (CAfile) { i=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM); if(!i) { BIO_printf(bio_err, ""Error loading file %s\n"", CAfile); ERR_print_errors(bio_err); goto end; } } else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT); lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir()); if (lookup == NULL) abort(); if (CApath) { i=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM); if(!i) { BIO_printf(bio_err, ""Error loading directory %s\n"", CApath); ERR_print_errors(bio_err); goto end; } } else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT); ERR_clear_error(); if(untfile) { if(!(untrusted = load_untrusted(untfile))) { BIO_printf(bio_err, ""Error loading untrusted file %s\n"", untfile); ERR_print_errors(bio_err); goto end; } } <S2SV_StartVul> if (argc < 1) check(cert_ctx, NULL, untrusted, purpose); <S2SV_EndVul> else for (i=0; i<argc; i++) <S2SV_StartVul> check(cert_ctx,argv[i], untrusted, purpose); <S2SV_EndVul> ret=0; end: if (ret == 1) { BIO_printf(bio_err,""usage: verify [-verbose] [-CApath path] [-CAfile file] [-purpose purpose] cert1 cert2 ...\n""); BIO_printf(bio_err,""recognized usages:\n""); for(i = 0; i < X509_PURPOSE_get_count(); i++) { X509_PURPOSE *ptmp; ptmp = X509_PURPOSE_get0(i); BIO_printf(bio_err, ""\t%-10s\t%s\n"", X509_PURPOSE_get0_sname(ptmp), X509_PURPOSE_get0_name(ptmp)); } } if (cert_ctx != NULL) X509_STORE_free(cert_ctx); sk_X509_pop_free(untrusted, X509_free); EXIT(ret); }","- char *untfile = NULL;
- STACK_OF(X509) *untrusted = NULL;
- if (argc < 1) check(cert_ctx, NULL, untrusted, purpose);
- check(cert_ctx,argv[i], untrusted, purpose);
+ char *untfile = NULL, *trustfile = NULL;
+ STACK_OF(X509) *untrusted = NULL, *trusted = NULL;
+ else if (strcmp(*argv,""-trusted"") == 0)
+ {
+ if (argc-- < 1) goto end;
+ trustfile= *(++argv);
+ }
+ if(trustfile) {
+ if(!(trusted = load_untrusted(trustfile))) {
+ BIO_printf(bio_err, ""Error loading untrusted file %s\n"", trustfile);
+ ERR_print_errors(bio_err);
+ goto end;
+ }
+ }
+ if (argc < 1) check(cert_ctx, NULL, untrusted, trusted, purpose);
+ check(cert_ctx,argv[i], untrusted, trusted, purpose);
+ sk_X509_pop_free(trusted, X509_free);","int MAIN(int argc, char **argv) { int i,ret=1; int purpose = -1; char *CApath=NULL,*CAfile=NULL; char *untfile = NULL, *trustfile = NULL; STACK_OF(X509) *untrusted = NULL, *trusted = NULL; X509_STORE *cert_ctx=NULL; X509_LOOKUP *lookup=NULL; cert_ctx=X509_STORE_new(); if (cert_ctx == NULL) goto end; X509_STORE_set_verify_cb_func(cert_ctx,cb); ERR_load_crypto_strings(); apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); argc--; argv++; for (;;) { if (argc >= 1) { if (strcmp(*argv,""-CApath"") == 0) { if (argc-- < 1) goto end; CApath= *(++argv); } else if (strcmp(*argv,""-CAfile"") == 0) { if (argc-- < 1) goto end; CAfile= *(++argv); } else if (strcmp(*argv,""-purpose"") == 0) { X509_PURPOSE *xptmp; if (argc-- < 1) goto end; i = X509_PURPOSE_get_by_sname(*(++argv)); if(i < 0) { BIO_printf(bio_err, ""unrecognized purpose\n""); goto end; } xptmp = X509_PURPOSE_get0(i); purpose = X509_PURPOSE_get_id(xptmp); } else if (strcmp(*argv,""-untrusted"") == 0) { if (argc-- < 1) goto end; untfile= *(++argv); } else if (strcmp(*argv,""-trusted"") == 0) { if (argc-- < 1) goto end; trustfile= *(++argv); } else if (strcmp(*argv,""-help"") == 0) goto end; else if (strcmp(*argv,""-verbose"") == 0) v_verbose=1; else if (argv[0][0] == '-') goto end; else break; argc--; argv++; } else break; } lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file()); if (lookup == NULL) abort(); if (CAfile) { i=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM); if(!i) { BIO_printf(bio_err, ""Error loading file %s\n"", CAfile); ERR_print_errors(bio_err); goto end; } } else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT); lookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir()); if (lookup == NULL) abort(); if (CApath) { i=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM); if(!i) { BIO_printf(bio_err, ""Error loading directory %s\n"", CApath); ERR_print_errors(bio_err); goto end; } } else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT); ERR_clear_error(); if(untfile) { if(!(untrusted = load_untrusted(untfile))) { BIO_printf(bio_err, ""Error loading untrusted file %s\n"", untfile); ERR_print_errors(bio_err); goto end; } } if(trustfile) { if(!(trusted = load_untrusted(trustfile))) { BIO_printf(bio_err, ""Error loading untrusted file %s\n"", trustfile); ERR_print_errors(bio_err); goto end; } } if (argc < 1) check(cert_ctx, NULL, untrusted, trusted, purpose); else for (i=0; i<argc; i++) check(cert_ctx,argv[i], untrusted, trusted, purpose); ret=0; end: if (ret == 1) { BIO_printf(bio_err,""usage: verify [-verbose] [-CApath path] [-CAfile file] [-purpose purpose] cert1 cert2 ...\n""); BIO_printf(bio_err,""recognized usages:\n""); for(i = 0; i < X509_PURPOSE_get_count(); i++) { X509_PURPOSE *ptmp; ptmp = X509_PURPOSE_get0(i); BIO_printf(bio_err, ""\t%-10s\t%s\n"", X509_PURPOSE_get0_sname(ptmp), X509_PURPOSE_get0_name(ptmp)); } } if (cert_ctx != NULL) X509_STORE_free(cert_ctx); sk_X509_pop_free(untrusted, X509_free); sk_X509_pop_free(trusted, X509_free); EXIT(ret); }"
9530----PULSE_MEMORY_LEAK----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_7a431772956d0f855855330afae832f180e23b7e_1.json----OJPEGReadHeaderInfoSecStreamDht,"static int OJPEGReadHeaderInfoSecStreamDht(TIFF* tif) { static const char module[]=""OJPEGReadHeaderInfoSecStreamDht""; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint16 m; uint32 na; uint8* nb; uint8 o; if (OJPEGReadWord(sp,&m)==0) return(0); if (m<=2) { if (sp->subsamplingcorrect==0) TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); return(0); } if (sp->subsamplingcorrect!=0) { OJPEGReadSkip(sp,m-2); } else { na=sizeof(uint32)+2+m; nb=_TIFFmalloc(na); if (nb==0) { TIFFErrorExt(tif->tif_clientdata,module,""Out of memory""); return(0); } *(uint32*)nb=na; nb[sizeof(uint32)]=255; nb[sizeof(uint32)+1]=JPEG_MARKER_DHT; nb[sizeof(uint32)+2]=(m>>8); nb[sizeof(uint32)+3]=(m&255); <S2SV_StartVul> if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) <S2SV_EndVul> return(0); o=nb[sizeof(uint32)+4]; if ((o&240)==0) { if (3<o) { TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); return(0); } if (sp->dctable[o]!=0) _TIFFfree(sp->dctable[o]); sp->dctable[o]=nb; } else { if ((o&240)!=16) { TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); return(0); } o&=15; if (3<o) { TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); return(0); } if (sp->actable[o]!=0) _TIFFfree(sp->actable[o]); sp->actable[o]=nb; } } return(1); }","- if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0)
+ if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) {
+ _TIFFfree(nb);
+ }
+ _TIFFfree(nb);
+ _TIFFfree(nb);
+ _TIFFfree(nb);","static int OJPEGReadHeaderInfoSecStreamDht(TIFF* tif) { static const char module[]=""OJPEGReadHeaderInfoSecStreamDht""; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint16 m; uint32 na; uint8* nb; uint8 o; if (OJPEGReadWord(sp,&m)==0) return(0); if (m<=2) { if (sp->subsamplingcorrect==0) TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); return(0); } if (sp->subsamplingcorrect!=0) { OJPEGReadSkip(sp,m-2); } else { na=sizeof(uint32)+2+m; nb=_TIFFmalloc(na); if (nb==0) { TIFFErrorExt(tif->tif_clientdata,module,""Out of memory""); return(0); } *(uint32*)nb=na; nb[sizeof(uint32)]=255; nb[sizeof(uint32)+1]=JPEG_MARKER_DHT; nb[sizeof(uint32)+2]=(m>>8); nb[sizeof(uint32)+3]=(m&255); if (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) { _TIFFfree(nb); return(0); } o=nb[sizeof(uint32)+4]; if ((o&240)==0) { if (3<o) { TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); _TIFFfree(nb); return(0); } if (sp->dctable[o]!=0) _TIFFfree(sp->dctable[o]); sp->dctable[o]=nb; } else { if ((o&240)!=16) { TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); _TIFFfree(nb); return(0); } o&=15; if (3<o) { TIFFErrorExt(tif->tif_clientdata,module,""Corrupt DHT marker in JPEG data""); _TIFFfree(nb); return(0); } if (sp->actable[o]!=0) _TIFFfree(sp->actable[o]); sp->actable[o]=nb; } } return(1); }"
7106----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7f848f889e2cc759651b139a2cae956e8e5c4c10_1.json----pred8x8_top_dc_rv40_c,"<S2SV_StartVul> static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){ <S2SV_EndVul> int i; unsigned dc0; dc0=0; for(i=0;i<8; i++) dc0+= src[i-stride]; dc0= 0x01010101*((dc0 + 4)>>3); for(i=0; i<8; i++){ ((uint32_t*)(src+i*stride))[0]= ((uint32_t*)(src+i*stride))[1]= dc0; } }","- static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
+ static void pred8x8_top_dc_rv40_c(uint8_t *src, ptrdiff_t stride)
+ {","static void pred8x8_top_dc_rv40_c(uint8_t *src, ptrdiff_t stride) { int i; unsigned dc0; dc0=0; for(i=0;i<8; i++) dc0+= src[i-stride]; dc0= 0x01010101*((dc0 + 4)>>3); for(i=0; i<8; i++){ ((uint32_t*)(src+i*stride))[0]= ((uint32_t*)(src+i*stride))[1]= dc0; } }"
10103----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_9afc53f49764d4738fb7b665bfb139ecd7dabe14_1.json----ngx_reopen_files,"void ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user) { ngx_fd_t fd; ngx_uint_t i; ngx_list_part_t *part; ngx_open_file_t *file; part = &cycle->open_files.part; file = part->elts; for (i = 0; ; i++) { if (i >= part->nelts) { if (part->next == NULL) { break; } part = part->next; file = part->elts; i = 0; } if (file[i].name.len == 0) { continue; } if (file[i].flush) { file[i].flush(&file[i], cycle->log); } fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND, NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS); ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""reopen file \""%s\"", old:%d new:%d"", file[i].name.data, file[i].fd, fd); if (fd == NGX_INVALID_FILE) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_open_file_n "" \""%s\"" failed"", file[i].name.data); continue; } #if !(NGX_WIN32) if (user != (ngx_uid_t) NGX_CONF_UNSET_UINT) { ngx_file_info_t fi; if (ngx_file_info((const char *) file[i].name.data, &fi) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_file_info_n "" \""%s\"" failed"", file[i].name.data); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } } if (fi.st_uid != user) { if (chown((const char *) file[i].name.data, user, -1) == -1) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ""chown(\""%s\"", %d) failed"", file[i].name.data, user); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } } } if ((fi.st_mode & (S_IRUSR|S_IWUSR)) != (S_IRUSR|S_IWUSR)) { fi.st_mode |= (S_IRUSR|S_IWUSR); if (chmod((const char *) file[i].name.data, fi.st_mode) == -1) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ""chmod() \""%s\"" failed"", file[i].name.data); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } } } } if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ""fcntl(FD_CLOEXEC) \""%s\"" failed"", file[i].name.data); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } continue; } #endif if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } file[i].fd = fd; } <S2SV_StartVul> if (!cycle->log_use_stderr && cycle->log->file->fd != ngx_stderr) { <S2SV_EndVul> <S2SV_StartVul> if (ngx_set_stderr(cycle->log->file->fd) == NGX_FILE_ERROR) { <S2SV_EndVul> <S2SV_StartVul> ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno, <S2SV_EndVul> <S2SV_StartVul> ngx_set_stderr_n "" failed""); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> }","- if (!cycle->log_use_stderr && cycle->log->file->fd != ngx_stderr) {
- if (ngx_set_stderr(cycle->log->file->fd) == NGX_FILE_ERROR) {
- ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,
- ngx_set_stderr_n "" failed"");
- }
- }
+ (void) ngx_log_redirect_stderr(cycle);","void ngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user) { ngx_fd_t fd; ngx_uint_t i; ngx_list_part_t *part; ngx_open_file_t *file; part = &cycle->open_files.part; file = part->elts; for (i = 0; ; i++) { if (i >= part->nelts) { if (part->next == NULL) { break; } part = part->next; file = part->elts; i = 0; } if (file[i].name.len == 0) { continue; } if (file[i].flush) { file[i].flush(&file[i], cycle->log); } fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND, NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS); ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0, ""reopen file \""%s\"", old:%d new:%d"", file[i].name.data, file[i].fd, fd); if (fd == NGX_INVALID_FILE) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_open_file_n "" \""%s\"" failed"", file[i].name.data); continue; } #if !(NGX_WIN32) if (user != (ngx_uid_t) NGX_CONF_UNSET_UINT) { ngx_file_info_t fi; if (ngx_file_info((const char *) file[i].name.data, &fi) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_file_info_n "" \""%s\"" failed"", file[i].name.data); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } } if (fi.st_uid != user) { if (chown((const char *) file[i].name.data, user, -1) == -1) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ""chown(\""%s\"", %d) failed"", file[i].name.data, user); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } } } if ((fi.st_mode & (S_IRUSR|S_IWUSR)) != (S_IRUSR|S_IWUSR)) { fi.st_mode |= (S_IRUSR|S_IWUSR); if (chmod((const char *) file[i].name.data, fi.st_mode) == -1) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ""chmod() \""%s\"" failed"", file[i].name.data); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } } } } if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ""fcntl(FD_CLOEXEC) \""%s\"" failed"", file[i].name.data); if (ngx_close_file(fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } continue; } #endif if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) { ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno, ngx_close_file_n "" \""%s\"" failed"", file[i].name.data); } file[i].fd = fd; } (void) ngx_log_redirect_stderr(cycle); }"
4313----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e9da91c96aa2af7e924fa11b853201744eeec747_1.json----ff_slice_buffer_init,"void ff_slice_buffer_init(slice_buffer *buf, int line_count, int max_allocated_lines, int line_width, IDWTELEM *base_buffer) { int i; buf->base_buffer = base_buffer; buf->line_count = line_count; buf->line_width = line_width; buf->data_count = max_allocated_lines; buf->line = av_mallocz(sizeof(IDWTELEM *) * line_count); buf->data_stack = av_malloc(sizeof(IDWTELEM *) * max_allocated_lines); <S2SV_StartVul> for (i = 0; i < max_allocated_lines; i++) <S2SV_EndVul> buf->data_stack[i] = av_malloc(sizeof(IDWTELEM) * line_width); buf->data_stack_top = max_allocated_lines - 1; }","- for (i = 0; i < max_allocated_lines; i++)
+ if (!buf->line)
+ return AVERROR(ENOMEM);
+ if (!buf->data_stack) {
+ av_free(buf->line);
+ return AVERROR(ENOMEM);
+ }
+ for (i = 0; i < max_allocated_lines; i++) {
+ if (!buf->data_stack[i]) {
+ for (i--; i >=0; i--)
+ av_free(buf->data_stack[i]);
+ av_free(buf->data_stack);
+ av_free(buf->line);
+ return AVERROR(ENOMEM);
+ }
+ }","void ff_slice_buffer_init(slice_buffer *buf, int line_count, int max_allocated_lines, int line_width, IDWTELEM *base_buffer) { int i; buf->base_buffer = base_buffer; buf->line_count = line_count; buf->line_width = line_width; buf->data_count = max_allocated_lines; buf->line = av_mallocz(sizeof(IDWTELEM *) * line_count); if (!buf->line) return AVERROR(ENOMEM); buf->data_stack = av_malloc(sizeof(IDWTELEM *) * max_allocated_lines); if (!buf->data_stack) { av_free(buf->line); return AVERROR(ENOMEM); } for (i = 0; i < max_allocated_lines; i++) { buf->data_stack[i] = av_malloc(sizeof(IDWTELEM) * line_width); if (!buf->data_stack[i]) { for (i--; i >=0; i--) av_free(buf->data_stack[i]); av_free(buf->data_stack); av_free(buf->line); return AVERROR(ENOMEM); } } buf->data_stack_top = max_allocated_lines - 1; }"
5612----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_1.json----decode_ics,"static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb, int common_window, int scale_flag) { Pulse pulse; TemporalNoiseShaping *tns = &sce->tns; IndividualChannelStream *ics = &sce->ics; float *out = sce->coeffs; int global_gain, pulse_present = 0; pulse.num_pulse = 0; global_gain = get_bits(gb, 8); if (!common_window && !scale_flag) { if (decode_ics_info(ac, ics, gb) < 0) return AVERROR_INVALIDDATA; } if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0) return -1; if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0) return -1; pulse_present = 0; if (!scale_flag) { if ((pulse_present = get_bits1(gb))) { if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { av_log(ac->avctx, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.\n""); return -1; } if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) { av_log(ac->avctx, AV_LOG_ERROR, ""Pulse data corrupt or invalid.\n""); return -1; } } if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics)) return -1; if (get_bits1(gb)) { av_log_missing_feature(ac->avctx, ""SSR"", 1); return -1; } } if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0) return -1; <S2SV_StartVul> if (ac->m4ac.object_type == AOT_AAC_MAIN && !common_window) <S2SV_EndVul> apply_prediction(ac, sce); return 0; }","- if (ac->m4ac.object_type == AOT_AAC_MAIN && !common_window)
+ if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN && !common_window)","static int decode_ics(AACContext *ac, SingleChannelElement *sce, GetBitContext *gb, int common_window, int scale_flag) { Pulse pulse; TemporalNoiseShaping *tns = &sce->tns; IndividualChannelStream *ics = &sce->ics; float *out = sce->coeffs; int global_gain, pulse_present = 0; pulse.num_pulse = 0; global_gain = get_bits(gb, 8); if (!common_window && !scale_flag) { if (decode_ics_info(ac, ics, gb) < 0) return AVERROR_INVALIDDATA; } if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0) return -1; if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0) return -1; pulse_present = 0; if (!scale_flag) { if ((pulse_present = get_bits1(gb))) { if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) { av_log(ac->avctx, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.\n""); return -1; } if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) { av_log(ac->avctx, AV_LOG_ERROR, ""Pulse data corrupt or invalid.\n""); return -1; } } if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics)) return -1; if (get_bits1(gb)) { av_log_missing_feature(ac->avctx, ""SSR"", 1); return -1; } } if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0) return -1; if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN && !common_window) apply_prediction(ac, sce); return 0; }"
9241----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_004888c8312af55699e6ca080f496ba9a08891c3_1.json----_TIFFCheckRealloc,"void* _TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what) { void* cp = NULL; <S2SV_StartVul> tmsize_t bytes = nmemb * elem_size; <S2SV_EndVul> <S2SV_StartVul> if (nmemb && elem_size && bytes / elem_size == nmemb) <S2SV_EndVul> <S2SV_StartVul> cp = _TIFFrealloc(buffer, bytes); <S2SV_EndVul> if (cp == NULL) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, ""Failed to allocate memory for %s "" ""(%ld elements of %ld bytes each)"", what,(long) nmemb, (long) elem_size); } return cp; }","- tmsize_t bytes = nmemb * elem_size;
- if (nmemb && elem_size && bytes / elem_size == nmemb)
- cp = _TIFFrealloc(buffer, bytes);
+ tmsize_t count = _TIFFMultiplySSize(tif, nmemb, elem_size, NULL);
+ if (count != 0)
+ {
+ cp = _TIFFrealloc(buffer, count);
+ }","void* _TIFFCheckRealloc(TIFF* tif, void* buffer, tmsize_t nmemb, tmsize_t elem_size, const char* what) { void* cp = NULL; tmsize_t count = _TIFFMultiplySSize(tif, nmemb, elem_size, NULL); if (count != 0) { cp = _TIFFrealloc(buffer, count); } if (cp == NULL) { TIFFErrorExt(tif->tif_clientdata, tif->tif_name, ""Failed to allocate memory for %s "" ""(%ld elements of %ld bytes each)"", what,(long) nmemb, (long) elem_size); } return cp; }"
5898----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3659127dd05895ee8870adefc5c4f47c40fd7d8e_1.json----ff_vc1_decode_blocks,"void ff_vc1_decode_blocks(VC1Context *v) { v->s.esc3_level_length = 0; if (v->x8_type) { <S2SV_StartVul> ff_intrax8_decode_picture(&v->x8, &v->s.current_picture, &v->s.gb, <S2SV_EndVul> 2 * v->pq + v->halfpq, v->pq * !v->pquantizer, v->s.loop_filter); ff_er_add_slice(&v->s.er, 0, 0, (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1, ER_MB_END); } else { v->cur_blk_idx = 0; v->left_blk_idx = -1; v->topleft_blk_idx = 1; v->top_blk_idx = 2; switch (v->s.pict_type) { case AV_PICTURE_TYPE_I: if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); break; case AV_PICTURE_TYPE_P: if (v->p_frame_skipped) vc1_decode_skip_blocks(v); else vc1_decode_p_blocks(v); break; case AV_PICTURE_TYPE_B: if (v->bi_type) { if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); } else vc1_decode_b_blocks(v); break; } } }","- ff_intrax8_decode_picture(&v->x8, &v->s.current_picture, &v->s.gb,
+ ff_intrax8_decode_picture(&v->x8, &v->s.current_picture,
+ &v->s.gb, &v->s.mb_x, &v->s.mb_y,","void ff_vc1_decode_blocks(VC1Context *v) { v->s.esc3_level_length = 0; if (v->x8_type) { ff_intrax8_decode_picture(&v->x8, &v->s.current_picture, &v->s.gb, &v->s.mb_x, &v->s.mb_y, 2 * v->pq + v->halfpq, v->pq * !v->pquantizer, v->s.loop_filter); ff_er_add_slice(&v->s.er, 0, 0, (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1, ER_MB_END); } else { v->cur_blk_idx = 0; v->left_blk_idx = -1; v->topleft_blk_idx = 1; v->top_blk_idx = 2; switch (v->s.pict_type) { case AV_PICTURE_TYPE_I: if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); break; case AV_PICTURE_TYPE_P: if (v->p_frame_skipped) vc1_decode_skip_blocks(v); else vc1_decode_p_blocks(v); break; case AV_PICTURE_TYPE_B: if (v->bi_type) { if (v->profile == PROFILE_ADVANCED) vc1_decode_i_blocks_adv(v); else vc1_decode_i_blocks(v); } else vc1_decode_b_blocks(v); break; } } }"
4614----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f84d1763a5fbbc52eae32da2599efdbc2ef5302f_1.json----filter_frame,"static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *cur_buf) { AlphaExtractContext *extract = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFilterBufferRef *out_buf = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h); int ret; if (!out_buf) { ret = AVERROR(ENOMEM); goto end; } avfilter_copy_buffer_ref_props(out_buf, cur_buf); if (extract->is_packed_rgb) { int x, y; uint8_t *pin, *pout; for (y = 0; y < out_buf->video->h; y++) { pin = cur_buf->data[0] + y * cur_buf->linesize[0] + extract->rgba_map[A]; pout = out_buf->data[0] + y * out_buf->linesize[0]; for (x = 0; x < out_buf->video->w; x++) { *pout = *pin; pout += 1; pin += 4; } } } else { <S2SV_StartVul> const int linesize = FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]); <S2SV_EndVul> int y; for (y = 0; y < out_buf->video->h; y++) { memcpy(out_buf->data[Y] + y * out_buf->linesize[Y], cur_buf->data[A] + y * cur_buf->linesize[A], linesize); } } ret = ff_filter_frame(outlink, out_buf); end: avfilter_unref_buffer(cur_buf); return ret; }","- const int linesize = FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]);
+ const int linesize = abs(FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]));","static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *cur_buf) { AlphaExtractContext *extract = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFilterBufferRef *out_buf = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h); int ret; if (!out_buf) { ret = AVERROR(ENOMEM); goto end; } avfilter_copy_buffer_ref_props(out_buf, cur_buf); if (extract->is_packed_rgb) { int x, y; uint8_t *pin, *pout; for (y = 0; y < out_buf->video->h; y++) { pin = cur_buf->data[0] + y * cur_buf->linesize[0] + extract->rgba_map[A]; pout = out_buf->data[0] + y * out_buf->linesize[0]; for (x = 0; x < out_buf->video->w; x++) { *pout = *pin; pout += 1; pin += 4; } } } else { const int linesize = abs(FFMIN(out_buf->linesize[Y], cur_buf->linesize[A])); int y; for (y = 0; y < out_buf->video->h; y++) { memcpy(out_buf->data[Y] + y * out_buf->linesize[Y], cur_buf->data[A] + y * cur_buf->linesize[A], linesize); } } ret = ff_filter_frame(outlink, out_buf); end: avfilter_unref_buffer(cur_buf); return ret; }"
9896----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_25176bafe8a006b6a2fea2a5bc9aa90d0ca0378f_1.json----ngx_inet_addr,"in_addr_t ngx_inet_addr(u_char *text, size_t len) { u_char *p, c; in_addr_t addr; ngx_uint_t octet, n; addr = 0; octet = 0; n = 0; for (p = text; p < text + len; p++) { <S2SV_StartVul> if (octet > 255) { <S2SV_EndVul> <S2SV_StartVul> return INADDR_NONE; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> c = *p; if (c >= '0' && c <= '9') { octet = octet * 10 + (c - '0'); continue; } if (c == '.') { addr = (addr << 8) + octet; octet = 0; n++; continue; } return INADDR_NONE; } if (n == 3) { addr = (addr << 8) + octet; return htonl(addr); } return INADDR_NONE; }","- if (octet > 255) {
- return INADDR_NONE;
- }
+ if (octet > 255) {
+ return INADDR_NONE;
+ }","in_addr_t ngx_inet_addr(u_char *text, size_t len) { u_char *p, c; in_addr_t addr; ngx_uint_t octet, n; addr = 0; octet = 0; n = 0; for (p = text; p < text + len; p++) { c = *p; if (c >= '0' && c <= '9') { octet = octet * 10 + (c - '0'); if (octet > 255) { return INADDR_NONE; } continue; } if (c == '.') { addr = (addr << 8) + octet; octet = 0; n++; continue; } return INADDR_NONE; } if (n == 3) { addr = (addr << 8) + octet; return htonl(addr); } return INADDR_NONE; }"
721----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_27290c00872fe5ce79d9fd10482556e001e175a3_1.json----filter_common,"static av_always_inline void filter_common(uint8_t *p, ptrdiff_t stride, <S2SV_StartVul> int is4tap) <S2SV_EndVul> { LOAD_PIXELS int a, f1, f2; const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP; a = 3 * (q0 - p0); if (is4tap) a += clip_int8(p1 - q1); a = clip_int8(a); f1 = FFMIN(a + 4, 127) >> 3; <S2SV_StartVul> f2 = FFMIN(a + 3, 127) >> 3; <S2SV_EndVul> p[-1 * stride] = cm[p0 + f2]; p[ 0 * stride] = cm[q0 - f1]; if (!is4tap) { <S2SV_StartVul> a = (f1 + 1) >> 1; <S2SV_EndVul> p[-2 * stride] = cm[p1 + a]; p[ 1 * stride] = cm[q1 - a]; } }","- int is4tap)
- f2 = FFMIN(a + 3, 127) >> 3;
- a = (f1 + 1) >> 1;
+ int is4tap, int is_vp7)
+ if (is_vp7)
+ f2 = f1 - ((a & 7) == 4);
+ else
+ f2 = FFMIN(a + 3, 127) >> 3;
+ a = (f1 + 1) >> 1;","static av_always_inline void filter_common(uint8_t *p, ptrdiff_t stride, int is4tap, int is_vp7) { LOAD_PIXELS int a, f1, f2; const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP; a = 3 * (q0 - p0); if (is4tap) a += clip_int8(p1 - q1); a = clip_int8(a); f1 = FFMIN(a + 4, 127) >> 3; if (is_vp7) f2 = f1 - ((a & 7) == 4); else f2 = FFMIN(a + 3, 127) >> 3; p[-1 * stride] = cm[p0 + f2]; p[ 0 * stride] = cm[q0 - f1]; if (!is4tap) { a = (f1 + 1) >> 1; p[-2 * stride] = cm[p1 + a]; p[ 1 * stride] = cm[q1 - a]; } }"
5069----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0729d81ee685e03e069781e830a733a372b6b4d7_1.json----pred8x8_left_dc_8_c,"<S2SV_StartVul> static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){ <S2SV_EndVul> int i; int dc0, dc2; pixel4 dc0splat, dc2splat; pixel *src = (pixel*)_src; stride /= sizeof(pixel); dc0=dc2=0; for(i=0;i<4; i++){ dc0+= src[-1+i*stride]; dc2+= src[-1+(i+4)*stride]; } dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2); dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2); for(i=0; i<4; i++){ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat); AV_WN4PA(((pixel4*)(src+i*stride))+1, dc0splat); } for(i=4; i<8; i++){ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc2splat); AV_WN4PA(((pixel4*)(src+i*stride))+1, dc2splat); } }","- static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
+ static void FUNCC(pred8x8_left_dc)(uint8_t *_src, ptrdiff_t stride)
+ {","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, ptrdiff_t stride) { int i; int dc0, dc2; pixel4 dc0splat, dc2splat; pixel *src = (pixel*)_src; stride /= sizeof(pixel); dc0=dc2=0; for(i=0;i<4; i++){ dc0+= src[-1+i*stride]; dc2+= src[-1+(i+4)*stride]; } dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2); dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2); for(i=0; i<4; i++){ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat); AV_WN4PA(((pixel4*)(src+i*stride))+1, dc0splat); } for(i=4; i<8; i++){ AV_WN4PA(((pixel4*)(src+i*stride))+0, dc2splat); AV_WN4PA(((pixel4*)(src+i*stride))+1, dc2splat); } }"
10797----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_130062532cf831fa5086a4d6d34fc09340a20c05_1.json----d2i_SSL_SESSION,"SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length) { long id; size_t tmpl; const unsigned char *p = *pp; SSL_SESSION_ASN1 *as = NULL; SSL_SESSION *ret = NULL; as = d2i_SSL_SESSION_ASN1(NULL, &p, length); if (as == NULL) goto err; if (!a || !*a) { ret = SSL_SESSION_new(); if (ret == NULL) goto err; } else { ret = *a; } if (as->version != SSL_SESSION_ASN1_VERSION) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNKNOWN_SSL_VERSION); goto err; } if ((as->ssl_version >> 8) != SSL3_VERSION_MAJOR && (as->ssl_version >> 8) != DTLS1_VERSION_MAJOR && as->ssl_version != DTLS1_BAD_VER) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION); goto err; } ret->ssl_version = (int)as->ssl_version; if (as->cipher->length != 2) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_CIPHER_CODE_WRONG_LENGTH); goto err; } p = as->cipher->data; id = 0x03000000L | ((unsigned long)p[0] << 8L) | (unsigned long)p[1]; <S2SV_StartVul> ret->cipher = NULL; <S2SV_EndVul> ret->cipher_id = id; if (!ssl_session_memcpy(ret->session_id, &ret->session_id_length, as->session_id, SSL3_MAX_SSL_SESSION_ID_LENGTH)) goto err; if (!ssl_session_memcpy(ret->master_key, &tmpl, as->master_key, SSL_MAX_MASTER_KEY_LENGTH)) goto err; ret->master_key_length = tmpl; if (as->time != 0) ret->time = as->time; else ret->time = (unsigned long)time(NULL); if (as->timeout != 0) ret->timeout = as->timeout; else ret->timeout = 3; X509_free(ret->peer); ret->peer = as->peer; as->peer = NULL; if (!ssl_session_memcpy(ret->sid_ctx, &ret->sid_ctx_length, as->session_id_context, SSL_MAX_SID_CTX_LENGTH)) goto err; ret->verify_result = as->verify_result; if (!ssl_session_strndup(&ret->ext.hostname, as->tlsext_hostname)) goto err; #ifndef OPENSSL_NO_PSK if (!ssl_session_strndup(&ret->psk_identity_hint, as->psk_identity_hint)) goto err; if (!ssl_session_strndup(&ret->psk_identity, as->psk_identity)) goto err; #endif ret->ext.tick_lifetime_hint = as->tlsext_tick_lifetime_hint; ret->ext.tick_age_add = as->tlsext_tick_age_add; if (as->tlsext_tick) { ret->ext.tick = as->tlsext_tick->data; ret->ext.ticklen = as->tlsext_tick->length; as->tlsext_tick->data = NULL; } else { ret->ext.tick = NULL; } #ifndef OPENSSL_NO_COMP if (as->comp_id) { if (as->comp_id->length != 1) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_BAD_LENGTH); goto err; } ret->compress_meth = as->comp_id->data[0]; } else { ret->compress_meth = 0; } #endif #ifndef OPENSSL_NO_SRP if (!ssl_session_strndup(&ret->srp_username, as->srp_username)) goto err; #endif ret->flags = as->flags; M_ASN1_free_of(as, SSL_SESSION_ASN1); if ((a != NULL) && (*a == NULL)) *a = ret; *pp = p; return ret; err: M_ASN1_free_of(as, SSL_SESSION_ASN1); if ((a == NULL) || (*a != ret)) SSL_SESSION_free(ret); return NULL; }","- ret->cipher = NULL;
+ ret->cipher = ssl3_get_cipher_by_id(id);
+ if (ret->cipher == NULL)
+ goto err;","SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp, long length) { long id; size_t tmpl; const unsigned char *p = *pp; SSL_SESSION_ASN1 *as = NULL; SSL_SESSION *ret = NULL; as = d2i_SSL_SESSION_ASN1(NULL, &p, length); if (as == NULL) goto err; if (!a || !*a) { ret = SSL_SESSION_new(); if (ret == NULL) goto err; } else { ret = *a; } if (as->version != SSL_SESSION_ASN1_VERSION) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNKNOWN_SSL_VERSION); goto err; } if ((as->ssl_version >> 8) != SSL3_VERSION_MAJOR && (as->ssl_version >> 8) != DTLS1_VERSION_MAJOR && as->ssl_version != DTLS1_BAD_VER) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION); goto err; } ret->ssl_version = (int)as->ssl_version; if (as->cipher->length != 2) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_CIPHER_CODE_WRONG_LENGTH); goto err; } p = as->cipher->data; id = 0x03000000L | ((unsigned long)p[0] << 8L) | (unsigned long)p[1]; ret->cipher_id = id; ret->cipher = ssl3_get_cipher_by_id(id); if (ret->cipher == NULL) goto err; if (!ssl_session_memcpy(ret->session_id, &ret->session_id_length, as->session_id, SSL3_MAX_SSL_SESSION_ID_LENGTH)) goto err; if (!ssl_session_memcpy(ret->master_key, &tmpl, as->master_key, SSL_MAX_MASTER_KEY_LENGTH)) goto err; ret->master_key_length = tmpl; if (as->time != 0) ret->time = as->time; else ret->time = (unsigned long)time(NULL); if (as->timeout != 0) ret->timeout = as->timeout; else ret->timeout = 3; X509_free(ret->peer); ret->peer = as->peer; as->peer = NULL; if (!ssl_session_memcpy(ret->sid_ctx, &ret->sid_ctx_length, as->session_id_context, SSL_MAX_SID_CTX_LENGTH)) goto err; ret->verify_result = as->verify_result; if (!ssl_session_strndup(&ret->ext.hostname, as->tlsext_hostname)) goto err; #ifndef OPENSSL_NO_PSK if (!ssl_session_strndup(&ret->psk_identity_hint, as->psk_identity_hint)) goto err; if (!ssl_session_strndup(&ret->psk_identity, as->psk_identity)) goto err; #endif ret->ext.tick_lifetime_hint = as->tlsext_tick_lifetime_hint; ret->ext.tick_age_add = as->tlsext_tick_age_add; if (as->tlsext_tick) { ret->ext.tick = as->tlsext_tick->data; ret->ext.ticklen = as->tlsext_tick->length; as->tlsext_tick->data = NULL; } else { ret->ext.tick = NULL; } #ifndef OPENSSL_NO_COMP if (as->comp_id) { if (as->comp_id->length != 1) { SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_BAD_LENGTH); goto err; } ret->compress_meth = as->comp_id->data[0]; } else { ret->compress_meth = 0; } #endif #ifndef OPENSSL_NO_SRP if (!ssl_session_strndup(&ret->srp_username, as->srp_username)) goto err; #endif ret->flags = as->flags; M_ASN1_free_of(as, SSL_SESSION_ASN1); if ((a != NULL) && (*a == NULL)) *a = ret; *pp = p; return ret; err: M_ASN1_free_of(as, SSL_SESSION_ASN1); if ((a == NULL) || (*a != ret)) SSL_SESSION_free(ret); return NULL; }"
4418----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_eefdd9cc950a8a8ccece93135830a743a8d1c3ef_1.json----encode_picture,"static int encode_picture(MpegEncContext *s, int picture_number) { int i, ret; int bits; int context_count = s->slice_context_count; s->picture_number = picture_number; s->me.mb_var_sum_temp = s->me.mc_mb_var_sum_temp = 0; if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || (s->h263_pred && !s->msmpeg4_version)) set_frame_distances(s); if(CONFIG_MPEG4_ENCODER && s->codec_id == AV_CODEC_ID_MPEG4) ff_set_mpeg4_time(s); s->me.scene_change_score=0; if(s->pict_type==AV_PICTURE_TYPE_I){ if(s->msmpeg4_version >= 3) s->no_rounding=1; else s->no_rounding=0; }else if(s->pict_type!=AV_PICTURE_TYPE_B){ if(s->flipflop_rounding || s->codec_id == AV_CODEC_ID_H263P || s->codec_id == AV_CODEC_ID_MPEG4) s->no_rounding ^= 1; } if(s->flags & CODEC_FLAG_PASS2){ if (estimate_qp(s,1) < 0) return -1; ff_get_2pass_fcode(s); }else if(!(s->flags & CODEC_FLAG_QSCALE)){ if(s->pict_type==AV_PICTURE_TYPE_B) s->lambda= s->last_lambda_for[s->pict_type]; else s->lambda= s->last_lambda_for[s->last_non_b_pict_type]; update_qscale(s); } if(s->codec_id != AV_CODEC_ID_AMV && s->codec_id != AV_CODEC_ID_MJPEG){ if(s->q_chroma_intra_matrix != s->q_intra_matrix ) av_freep(&s->q_chroma_intra_matrix); if(s->q_chroma_intra_matrix16 != s->q_intra_matrix16) av_freep(&s->q_chroma_intra_matrix16); s->q_chroma_intra_matrix = s->q_intra_matrix; s->q_chroma_intra_matrix16 = s->q_intra_matrix16; } s->mb_intra=0; for(i=1; i<context_count; i++){ ret = ff_update_duplicate_context(s->thread_context[i], s); if (ret < 0) return ret; } if(ff_init_me(s)<0) return -1; if(s->pict_type != AV_PICTURE_TYPE_I){ s->lambda = (s->lambda * s->avctx->me_penalty_compensation + 128)>>8; s->lambda2= (s->lambda2* (int64_t)s->avctx->me_penalty_compensation + 128)>>8; if (s->pict_type != AV_PICTURE_TYPE_B) { if((s->avctx->pre_me && s->last_non_b_pict_type==AV_PICTURE_TYPE_I) || s->avctx->pre_me==2){ s->avctx->execute(s->avctx, pre_estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); } } s->avctx->execute(s->avctx, estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); }else { for(i=0; i<s->mb_stride*s->mb_height; i++) s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA; if(!s->fixed_qscale){ s->avctx->execute(s->avctx, mb_var_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); } } for(i=1; i<context_count; i++){ merge_context_after_me(s, s->thread_context[i]); } s->current_picture.mc_mb_var_sum= s->current_picture_ptr->mc_mb_var_sum= s->me.mc_mb_var_sum_temp; s->current_picture. mb_var_sum= s->current_picture_ptr-> mb_var_sum= s->me. mb_var_sum_temp; emms_c(); if(s->me.scene_change_score > s->avctx->scenechange_threshold && s->pict_type == AV_PICTURE_TYPE_P){ s->pict_type= AV_PICTURE_TYPE_I; for(i=0; i<s->mb_stride*s->mb_height; i++) s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA; if(s->msmpeg4_version >= 3) s->no_rounding=1; <S2SV_StartVul> av_dlog(s, ""Scene change detected, encoding as I Frame %d %d\n"", <S2SV_EndVul> s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum); } if(!s->umvplus){ if(s->pict_type==AV_PICTURE_TYPE_P || s->pict_type==AV_PICTURE_TYPE_S) { s->f_code= ff_get_best_fcode(s, s->p_mv_table, CANDIDATE_MB_TYPE_INTER); if(s->flags & CODEC_FLAG_INTERLACED_ME){ int a,b; a= ff_get_best_fcode(s, s->p_field_mv_table[0][0], CANDIDATE_MB_TYPE_INTER_I); b= ff_get_best_fcode(s, s->p_field_mv_table[1][1], CANDIDATE_MB_TYPE_INTER_I); s->f_code= FFMAX3(s->f_code, a, b); } ff_fix_long_p_mvs(s); ff_fix_long_mvs(s, NULL, 0, s->p_mv_table, s->f_code, CANDIDATE_MB_TYPE_INTER, 0); if(s->flags & CODEC_FLAG_INTERLACED_ME){ int j; for(i=0; i<2; i++){ for(j=0; j<2; j++) ff_fix_long_mvs(s, s->p_field_select_table[i], j, s->p_field_mv_table[i][j], s->f_code, CANDIDATE_MB_TYPE_INTER_I, 0); } } } if(s->pict_type==AV_PICTURE_TYPE_B){ int a, b; a = ff_get_best_fcode(s, s->b_forw_mv_table, CANDIDATE_MB_TYPE_FORWARD); b = ff_get_best_fcode(s, s->b_bidir_forw_mv_table, CANDIDATE_MB_TYPE_BIDIR); s->f_code = FFMAX(a, b); a = ff_get_best_fcode(s, s->b_back_mv_table, CANDIDATE_MB_TYPE_BACKWARD); b = ff_get_best_fcode(s, s->b_bidir_back_mv_table, CANDIDATE_MB_TYPE_BIDIR); s->b_code = FFMAX(a, b); ff_fix_long_mvs(s, NULL, 0, s->b_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_FORWARD, 1); ff_fix_long_mvs(s, NULL, 0, s->b_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BACKWARD, 1); ff_fix_long_mvs(s, NULL, 0, s->b_bidir_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_BIDIR, 1); ff_fix_long_mvs(s, NULL, 0, s->b_bidir_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BIDIR, 1); if(s->flags & CODEC_FLAG_INTERLACED_ME){ int dir, j; for(dir=0; dir<2; dir++){ for(i=0; i<2; i++){ for(j=0; j<2; j++){ int type= dir ? (CANDIDATE_MB_TYPE_BACKWARD_I|CANDIDATE_MB_TYPE_BIDIR_I) : (CANDIDATE_MB_TYPE_FORWARD_I |CANDIDATE_MB_TYPE_BIDIR_I); ff_fix_long_mvs(s, s->b_field_select_table[dir][i], j, s->b_field_mv_table[dir][i][j], dir ? s->b_code : s->f_code, type, 1); } } } } } } if (estimate_qp(s, 0) < 0) return -1; if(s->qscale < 3 && s->max_qcoeff<=128 && s->pict_type==AV_PICTURE_TYPE_I && !(s->flags & CODEC_FLAG_QSCALE)) s->qscale= 3; if (s->out_format == FMT_MJPEG) { const uint16_t * luma_matrix = ff_mpeg1_default_intra_matrix; const uint16_t *chroma_matrix = ff_mpeg1_default_intra_matrix; if (s->avctx->intra_matrix) { chroma_matrix = luma_matrix = s->avctx->intra_matrix; } if (s->avctx->chroma_intra_matrix) chroma_matrix = s->avctx->chroma_intra_matrix; for(i=1;i<64;i++){ int j= s->dsp.idct_permutation[i]; s->chroma_intra_matrix[j] = av_clip_uint8((chroma_matrix[i] * s->qscale) >> 3); s-> intra_matrix[j] = av_clip_uint8(( luma_matrix[i] * s->qscale) >> 3); } s->y_dc_scale_table= s->c_dc_scale_table= ff_mpeg2_dc_scale_table[s->intra_dc_precision]; s->chroma_intra_matrix[0] = s->intra_matrix[0] = ff_mpeg2_dc_scale_table[s->intra_dc_precision][8]; ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16, s->intra_matrix, s->intra_quant_bias, 8, 8, 1); ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16, s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1); s->qscale= 8; } if(s->codec_id == AV_CODEC_ID_AMV){ static const uint8_t y[32]={13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13}; static const uint8_t c[32]={14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14}; for(i=1;i<64;i++){ int j= s->dsp.idct_permutation[ff_zigzag_direct[i]]; s->intra_matrix[j] = sp5x_quant_table[5*2+0][i]; s->chroma_intra_matrix[j] = sp5x_quant_table[5*2+1][i]; } s->y_dc_scale_table= y; s->c_dc_scale_table= c; s->intra_matrix[0] = 13; s->chroma_intra_matrix[0] = 14; ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16, s->intra_matrix, s->intra_quant_bias, 8, 8, 1); ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16, s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1); s->qscale= 8; } s->current_picture_ptr->f.key_frame = s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; s->current_picture_ptr->f.pict_type = s->current_picture.f.pict_type = s->pict_type; if (s->current_picture.f.key_frame) s->picture_in_gop_number=0; s->mb_x = s->mb_y = 0; s->last_bits= put_bits_count(&s->pb); switch(s->out_format) { case FMT_MJPEG: if (CONFIG_MJPEG_ENCODER) ff_mjpeg_encode_picture_header(s->avctx, &s->pb, &s->intra_scantable, s->intra_matrix, s->chroma_intra_matrix); break; case FMT_H261: if (CONFIG_H261_ENCODER) ff_h261_encode_picture_header(s, picture_number); break; case FMT_H263: if (CONFIG_WMV2_ENCODER && s->codec_id == AV_CODEC_ID_WMV2) ff_wmv2_encode_picture_header(s, picture_number); else if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version) ff_msmpeg4_encode_picture_header(s, picture_number); else if (CONFIG_MPEG4_ENCODER && s->h263_pred) ff_mpeg4_encode_picture_header(s, picture_number); else if (CONFIG_RV10_ENCODER && s->codec_id == AV_CODEC_ID_RV10) ff_rv10_encode_picture_header(s, picture_number); else if (CONFIG_RV20_ENCODER && s->codec_id == AV_CODEC_ID_RV20) ff_rv20_encode_picture_header(s, picture_number); else if (CONFIG_FLV_ENCODER && s->codec_id == AV_CODEC_ID_FLV1) ff_flv_encode_picture_header(s, picture_number); else if (CONFIG_H263_ENCODER) ff_h263_encode_picture_header(s, picture_number); break; case FMT_MPEG1: if (CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER) ff_mpeg1_encode_picture_header(s, picture_number); break; default: av_assert0(0); } bits= put_bits_count(&s->pb); s->header_bits= bits - s->last_bits; for(i=1; i<context_count; i++){ update_duplicate_context_after_me(s->thread_context[i], s); } s->avctx->execute(s->avctx, encode_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); for(i=1; i<context_count; i++){ merge_context_after_encode(s, s->thread_context[i]); } emms_c(); return 0; }","- av_dlog(s, ""Scene change detected, encoding as I Frame %d %d\n"",
+ av_dlog(s, ""Scene change detected, encoding as I Frame %""PRId64"" %""PRId64""\n"",","static int encode_picture(MpegEncContext *s, int picture_number) { int i, ret; int bits; int context_count = s->slice_context_count; s->picture_number = picture_number; s->me.mb_var_sum_temp = s->me.mc_mb_var_sum_temp = 0; if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || (s->h263_pred && !s->msmpeg4_version)) set_frame_distances(s); if(CONFIG_MPEG4_ENCODER && s->codec_id == AV_CODEC_ID_MPEG4) ff_set_mpeg4_time(s); s->me.scene_change_score=0; if(s->pict_type==AV_PICTURE_TYPE_I){ if(s->msmpeg4_version >= 3) s->no_rounding=1; else s->no_rounding=0; }else if(s->pict_type!=AV_PICTURE_TYPE_B){ if(s->flipflop_rounding || s->codec_id == AV_CODEC_ID_H263P || s->codec_id == AV_CODEC_ID_MPEG4) s->no_rounding ^= 1; } if(s->flags & CODEC_FLAG_PASS2){ if (estimate_qp(s,1) < 0) return -1; ff_get_2pass_fcode(s); }else if(!(s->flags & CODEC_FLAG_QSCALE)){ if(s->pict_type==AV_PICTURE_TYPE_B) s->lambda= s->last_lambda_for[s->pict_type]; else s->lambda= s->last_lambda_for[s->last_non_b_pict_type]; update_qscale(s); } if(s->codec_id != AV_CODEC_ID_AMV && s->codec_id != AV_CODEC_ID_MJPEG){ if(s->q_chroma_intra_matrix != s->q_intra_matrix ) av_freep(&s->q_chroma_intra_matrix); if(s->q_chroma_intra_matrix16 != s->q_intra_matrix16) av_freep(&s->q_chroma_intra_matrix16); s->q_chroma_intra_matrix = s->q_intra_matrix; s->q_chroma_intra_matrix16 = s->q_intra_matrix16; } s->mb_intra=0; for(i=1; i<context_count; i++){ ret = ff_update_duplicate_context(s->thread_context[i], s); if (ret < 0) return ret; } if(ff_init_me(s)<0) return -1; if(s->pict_type != AV_PICTURE_TYPE_I){ s->lambda = (s->lambda * s->avctx->me_penalty_compensation + 128)>>8; s->lambda2= (s->lambda2* (int64_t)s->avctx->me_penalty_compensation + 128)>>8; if (s->pict_type != AV_PICTURE_TYPE_B) { if((s->avctx->pre_me && s->last_non_b_pict_type==AV_PICTURE_TYPE_I) || s->avctx->pre_me==2){ s->avctx->execute(s->avctx, pre_estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); } } s->avctx->execute(s->avctx, estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); }else { for(i=0; i<s->mb_stride*s->mb_height; i++) s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA; if(!s->fixed_qscale){ s->avctx->execute(s->avctx, mb_var_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); } } for(i=1; i<context_count; i++){ merge_context_after_me(s, s->thread_context[i]); } s->current_picture.mc_mb_var_sum= s->current_picture_ptr->mc_mb_var_sum= s->me.mc_mb_var_sum_temp; s->current_picture. mb_var_sum= s->current_picture_ptr-> mb_var_sum= s->me. mb_var_sum_temp; emms_c(); if(s->me.scene_change_score > s->avctx->scenechange_threshold && s->pict_type == AV_PICTURE_TYPE_P){ s->pict_type= AV_PICTURE_TYPE_I; for(i=0; i<s->mb_stride*s->mb_height; i++) s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA; if(s->msmpeg4_version >= 3) s->no_rounding=1; av_dlog(s, ""Scene change detected, encoding as I Frame %""PRId64"" %""PRId64""\n"", s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum); } if(!s->umvplus){ if(s->pict_type==AV_PICTURE_TYPE_P || s->pict_type==AV_PICTURE_TYPE_S) { s->f_code= ff_get_best_fcode(s, s->p_mv_table, CANDIDATE_MB_TYPE_INTER); if(s->flags & CODEC_FLAG_INTERLACED_ME){ int a,b; a= ff_get_best_fcode(s, s->p_field_mv_table[0][0], CANDIDATE_MB_TYPE_INTER_I); b= ff_get_best_fcode(s, s->p_field_mv_table[1][1], CANDIDATE_MB_TYPE_INTER_I); s->f_code= FFMAX3(s->f_code, a, b); } ff_fix_long_p_mvs(s); ff_fix_long_mvs(s, NULL, 0, s->p_mv_table, s->f_code, CANDIDATE_MB_TYPE_INTER, 0); if(s->flags & CODEC_FLAG_INTERLACED_ME){ int j; for(i=0; i<2; i++){ for(j=0; j<2; j++) ff_fix_long_mvs(s, s->p_field_select_table[i], j, s->p_field_mv_table[i][j], s->f_code, CANDIDATE_MB_TYPE_INTER_I, 0); } } } if(s->pict_type==AV_PICTURE_TYPE_B){ int a, b; a = ff_get_best_fcode(s, s->b_forw_mv_table, CANDIDATE_MB_TYPE_FORWARD); b = ff_get_best_fcode(s, s->b_bidir_forw_mv_table, CANDIDATE_MB_TYPE_BIDIR); s->f_code = FFMAX(a, b); a = ff_get_best_fcode(s, s->b_back_mv_table, CANDIDATE_MB_TYPE_BACKWARD); b = ff_get_best_fcode(s, s->b_bidir_back_mv_table, CANDIDATE_MB_TYPE_BIDIR); s->b_code = FFMAX(a, b); ff_fix_long_mvs(s, NULL, 0, s->b_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_FORWARD, 1); ff_fix_long_mvs(s, NULL, 0, s->b_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BACKWARD, 1); ff_fix_long_mvs(s, NULL, 0, s->b_bidir_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_BIDIR, 1); ff_fix_long_mvs(s, NULL, 0, s->b_bidir_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BIDIR, 1); if(s->flags & CODEC_FLAG_INTERLACED_ME){ int dir, j; for(dir=0; dir<2; dir++){ for(i=0; i<2; i++){ for(j=0; j<2; j++){ int type= dir ? (CANDIDATE_MB_TYPE_BACKWARD_I|CANDIDATE_MB_TYPE_BIDIR_I) : (CANDIDATE_MB_TYPE_FORWARD_I |CANDIDATE_MB_TYPE_BIDIR_I); ff_fix_long_mvs(s, s->b_field_select_table[dir][i], j, s->b_field_mv_table[dir][i][j], dir ? s->b_code : s->f_code, type, 1); } } } } } } if (estimate_qp(s, 0) < 0) return -1; if(s->qscale < 3 && s->max_qcoeff<=128 && s->pict_type==AV_PICTURE_TYPE_I && !(s->flags & CODEC_FLAG_QSCALE)) s->qscale= 3; if (s->out_format == FMT_MJPEG) { const uint16_t * luma_matrix = ff_mpeg1_default_intra_matrix; const uint16_t *chroma_matrix = ff_mpeg1_default_intra_matrix; if (s->avctx->intra_matrix) { chroma_matrix = luma_matrix = s->avctx->intra_matrix; } if (s->avctx->chroma_intra_matrix) chroma_matrix = s->avctx->chroma_intra_matrix; for(i=1;i<64;i++){ int j= s->dsp.idct_permutation[i]; s->chroma_intra_matrix[j] = av_clip_uint8((chroma_matrix[i] * s->qscale) >> 3); s-> intra_matrix[j] = av_clip_uint8(( luma_matrix[i] * s->qscale) >> 3); } s->y_dc_scale_table= s->c_dc_scale_table= ff_mpeg2_dc_scale_table[s->intra_dc_precision]; s->chroma_intra_matrix[0] = s->intra_matrix[0] = ff_mpeg2_dc_scale_table[s->intra_dc_precision][8]; ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16, s->intra_matrix, s->intra_quant_bias, 8, 8, 1); ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16, s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1); s->qscale= 8; } if(s->codec_id == AV_CODEC_ID_AMV){ static const uint8_t y[32]={13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13}; static const uint8_t c[32]={14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14}; for(i=1;i<64;i++){ int j= s->dsp.idct_permutation[ff_zigzag_direct[i]]; s->intra_matrix[j] = sp5x_quant_table[5*2+0][i]; s->chroma_intra_matrix[j] = sp5x_quant_table[5*2+1][i]; } s->y_dc_scale_table= y; s->c_dc_scale_table= c; s->intra_matrix[0] = 13; s->chroma_intra_matrix[0] = 14; ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16, s->intra_matrix, s->intra_quant_bias, 8, 8, 1); ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16, s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1); s->qscale= 8; } s->current_picture_ptr->f.key_frame = s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; s->current_picture_ptr->f.pict_type = s->current_picture.f.pict_type = s->pict_type; if (s->current_picture.f.key_frame) s->picture_in_gop_number=0; s->mb_x = s->mb_y = 0; s->last_bits= put_bits_count(&s->pb); switch(s->out_format) { case FMT_MJPEG: if (CONFIG_MJPEG_ENCODER) ff_mjpeg_encode_picture_header(s->avctx, &s->pb, &s->intra_scantable, s->intra_matrix, s->chroma_intra_matrix); break; case FMT_H261: if (CONFIG_H261_ENCODER) ff_h261_encode_picture_header(s, picture_number); break; case FMT_H263: if (CONFIG_WMV2_ENCODER && s->codec_id == AV_CODEC_ID_WMV2) ff_wmv2_encode_picture_header(s, picture_number); else if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version) ff_msmpeg4_encode_picture_header(s, picture_number); else if (CONFIG_MPEG4_ENCODER && s->h263_pred) ff_mpeg4_encode_picture_header(s, picture_number); else if (CONFIG_RV10_ENCODER && s->codec_id == AV_CODEC_ID_RV10) ff_rv10_encode_picture_header(s, picture_number); else if (CONFIG_RV20_ENCODER && s->codec_id == AV_CODEC_ID_RV20) ff_rv20_encode_picture_header(s, picture_number); else if (CONFIG_FLV_ENCODER && s->codec_id == AV_CODEC_ID_FLV1) ff_flv_encode_picture_header(s, picture_number); else if (CONFIG_H263_ENCODER) ff_h263_encode_picture_header(s, picture_number); break; case FMT_MPEG1: if (CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER) ff_mpeg1_encode_picture_header(s, picture_number); break; default: av_assert0(0); } bits= put_bits_count(&s->pb); s->header_bits= bits - s->last_bits; for(i=1; i<context_count; i++){ update_duplicate_context_after_me(s->thread_context[i], s); } s->avctx->execute(s->avctx, encode_thread, &s->thread_context[0], NULL, context_count, sizeof(void*)); for(i=1; i<context_count; i++){ merge_context_after_encode(s, s->thread_context[i]); } emms_c(); return 0; }"
11078----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c73b428ce6569c8ef199734eda1f530c2b807d8_1.json----EC_KEY_free,"void EC_KEY_free(EC_KEY *r) { int i; if (r == NULL) return; i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC); REF_PRINT_COUNT(""EC_KEY"", r); if (i > 0) return; REF_ASSERT_ISNT(i < 0); if (r->meth->finish != NULL) r->meth->finish(r); #ifndef OPENSSL_NO_ENGINE <S2SV_StartVul> if (r->engine != NULL) <S2SV_EndVul> <S2SV_StartVul> ENGINE_finish(r->engine); <S2SV_EndVul> #endif CRYPTO_free_ex_data(CRYPTO_EX_INDEX_EC_KEY, r, &r->ex_data); EC_GROUP_free(r->group); EC_POINT_free(r->pub_key); BN_clear_free(r->priv_key); OPENSSL_clear_free((void *)r, sizeof(EC_KEY)); }","- if (r->engine != NULL)
- ENGINE_finish(r->engine);
+ ENGINE_finish(r->engine);","void EC_KEY_free(EC_KEY *r) { int i; if (r == NULL) return; i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC); REF_PRINT_COUNT(""EC_KEY"", r); if (i > 0) return; REF_ASSERT_ISNT(i < 0); if (r->meth->finish != NULL) r->meth->finish(r); #ifndef OPENSSL_NO_ENGINE ENGINE_finish(r->engine); #endif CRYPTO_free_ex_data(CRYPTO_EX_INDEX_EC_KEY, r, &r->ex_data); EC_GROUP_free(r->group); EC_POINT_free(r->pub_key); BN_clear_free(r->priv_key); OPENSSL_clear_free((void *)r, sizeof(EC_KEY)); }"
9887----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_20929aa7119dc0f1338b484d9449ff9b3cfa05e5_1.json----ngx_http_map,"static char * ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf) { ngx_int_t rc, index; <S2SV_StartVul> ngx_str_t *value, file, name; <S2SV_EndVul> ngx_uint_t i, key; ngx_http_map_conf_ctx_t *ctx; ngx_http_variable_value_t *var, **vp; ctx = cf->ctx; value = cf->args->elts; if (cf->args->nelts == 1 && ngx_strcmp(value[0].data, ""hostnames"") == 0) { ctx->hostnames = 1; return NGX_CONF_OK; } else if (cf->args->nelts != 2) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid number of the map parameters""); return NGX_CONF_ERROR; } if (ngx_strcmp(value[0].data, ""include"") == 0) { <S2SV_StartVul> file = value[1]; <S2SV_EndVul> <S2SV_StartVul> if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) { <S2SV_EndVul> <S2SV_StartVul> return NGX_CONF_ERROR; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data); <S2SV_EndVul> <S2SV_StartVul> return ngx_conf_parse(cf, &file); <S2SV_EndVul> } if (value[1].data[0] == '$') { name = value[1]; name.len--; name.data++; index = ngx_http_get_variable_index(ctx->cf, &name); if (index == NGX_ERROR) { return NGX_CONF_ERROR; } var = ctx->var_values.elts; for (i = 0; i < ctx->var_values.nelts; i++) { if (index == (ngx_int_t) var[i].data) { var = &var[i]; goto found; } } var = ngx_array_push(&ctx->var_values); if (var == NULL) { return NGX_CONF_ERROR; } var->valid = 0; var->no_cacheable = 0; var->not_found = 0; var->len = 0; var->data = (u_char *) index; goto found; } key = 0; for (i = 0; i < value[1].len; i++) { key = ngx_hash(key, value[1].data[i]); } key %= ctx->keys.hsize; vp = ctx->values_hash[key].elts; if (vp) { for (i = 0; i < ctx->values_hash[key].nelts; i++) { if (value[1].len != (size_t) vp[i]->len) { continue; } if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) { var = vp[i]; goto found; } } } else { if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4, sizeof(ngx_http_variable_value_t *)) != NGX_OK) { return NGX_CONF_ERROR; } } var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t)); if (var == NULL) { return NGX_CONF_ERROR; } var->len = value[1].len; var->data = ngx_pstrdup(ctx->keys.pool, &value[1]); if (var->data == NULL) { return NGX_CONF_ERROR; } var->valid = 1; var->no_cacheable = 0; var->not_found = 0; vp = ngx_array_push(&ctx->values_hash[key]); if (vp == NULL) { return NGX_CONF_ERROR; } *vp = var; found: if (ngx_strcmp(value[0].data, ""default"") == 0) { if (ctx->default_value) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""duplicate default map parameter""); return NGX_CONF_ERROR; } ctx->default_value = var; return NGX_CONF_OK; } #if (NGX_PCRE) if (value[0].len && value[0].data[0] == '~') { ngx_regex_compile_t rc; ngx_http_map_regex_t *regex; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_array_push(&ctx->regexes); if (regex == NULL) { return NGX_CONF_ERROR; } value[0].len--; value[0].data++; ngx_memzero(&rc, sizeof(ngx_regex_compile_t)); if (value[0].data[0] == '*') { value[0].len--; value[0].data++; rc.options = NGX_REGEX_CASELESS; } rc.pattern = value[0]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; regex->regex = ngx_http_regex_compile(ctx->cf, &rc); if (regex->regex == NULL) { return NGX_CONF_ERROR; } regex->value = var; return NGX_CONF_OK; } #endif if (value[0].len && value[0].data[0] == '\\') { value[0].len--; value[0].data++; } rc = ngx_hash_add_key(&ctx->keys, &value[0], var, (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0); if (rc == NGX_OK) { return NGX_CONF_OK; } if (rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid hostname or wildcard \""%V\"""", &value[0]); } if (rc == NGX_BUSY) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""conflicting parameter \""%V\"""", &value[0]); } return NGX_CONF_ERROR; }","- ngx_str_t *value, file, name;
- file = value[1];
- if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {
- return NGX_CONF_ERROR;
- }
- ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, ""include %s"", file.data);
- return ngx_conf_parse(cf, &file);
+ ngx_str_t *value, name;
+ return ngx_conf_include(cf, dummy, conf);","static char * ngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf) { ngx_int_t rc, index; ngx_str_t *value, name; ngx_uint_t i, key; ngx_http_map_conf_ctx_t *ctx; ngx_http_variable_value_t *var, **vp; ctx = cf->ctx; value = cf->args->elts; if (cf->args->nelts == 1 && ngx_strcmp(value[0].data, ""hostnames"") == 0) { ctx->hostnames = 1; return NGX_CONF_OK; } else if (cf->args->nelts != 2) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid number of the map parameters""); return NGX_CONF_ERROR; } if (ngx_strcmp(value[0].data, ""include"") == 0) { return ngx_conf_include(cf, dummy, conf); } if (value[1].data[0] == '$') { name = value[1]; name.len--; name.data++; index = ngx_http_get_variable_index(ctx->cf, &name); if (index == NGX_ERROR) { return NGX_CONF_ERROR; } var = ctx->var_values.elts; for (i = 0; i < ctx->var_values.nelts; i++) { if (index == (ngx_int_t) var[i].data) { var = &var[i]; goto found; } } var = ngx_array_push(&ctx->var_values); if (var == NULL) { return NGX_CONF_ERROR; } var->valid = 0; var->no_cacheable = 0; var->not_found = 0; var->len = 0; var->data = (u_char *) index; goto found; } key = 0; for (i = 0; i < value[1].len; i++) { key = ngx_hash(key, value[1].data[i]); } key %= ctx->keys.hsize; vp = ctx->values_hash[key].elts; if (vp) { for (i = 0; i < ctx->values_hash[key].nelts; i++) { if (value[1].len != (size_t) vp[i]->len) { continue; } if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) { var = vp[i]; goto found; } } } else { if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4, sizeof(ngx_http_variable_value_t *)) != NGX_OK) { return NGX_CONF_ERROR; } } var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t)); if (var == NULL) { return NGX_CONF_ERROR; } var->len = value[1].len; var->data = ngx_pstrdup(ctx->keys.pool, &value[1]); if (var->data == NULL) { return NGX_CONF_ERROR; } var->valid = 1; var->no_cacheable = 0; var->not_found = 0; vp = ngx_array_push(&ctx->values_hash[key]); if (vp == NULL) { return NGX_CONF_ERROR; } *vp = var; found: if (ngx_strcmp(value[0].data, ""default"") == 0) { if (ctx->default_value) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""duplicate default map parameter""); return NGX_CONF_ERROR; } ctx->default_value = var; return NGX_CONF_OK; } #if (NGX_PCRE) if (value[0].len && value[0].data[0] == '~') { ngx_regex_compile_t rc; ngx_http_map_regex_t *regex; u_char errstr[NGX_MAX_CONF_ERRSTR]; regex = ngx_array_push(&ctx->regexes); if (regex == NULL) { return NGX_CONF_ERROR; } value[0].len--; value[0].data++; ngx_memzero(&rc, sizeof(ngx_regex_compile_t)); if (value[0].data[0] == '*') { value[0].len--; value[0].data++; rc.options = NGX_REGEX_CASELESS; } rc.pattern = value[0]; rc.err.len = NGX_MAX_CONF_ERRSTR; rc.err.data = errstr; regex->regex = ngx_http_regex_compile(ctx->cf, &rc); if (regex->regex == NULL) { return NGX_CONF_ERROR; } regex->value = var; return NGX_CONF_OK; } #endif if (value[0].len && value[0].data[0] == '\\') { value[0].len--; value[0].data++; } rc = ngx_hash_add_key(&ctx->keys, &value[0], var, (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0); if (rc == NGX_OK) { return NGX_CONF_OK; } if (rc == NGX_DECLINED) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""invalid hostname or wildcard \""%V\"""", &value[0]); } if (rc == NGX_BUSY) { ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, ""conflicting parameter \""%V\"""", &value[0]); } return NGX_CONF_ERROR; }"
5716----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2c97ee8af248a7efd522edfa7c8bc9b8ba80cb0f_1.json----decode_frame,"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; const uint8_t *buf_end = buf + avpkt->size; KgvContext * const c = avctx->priv_data; int offsets[8]; uint16_t *out, *prev; int outcnt = 0, maxcnt; int w, h, i, res; if (avpkt->size < 2) return AVERROR_INVALIDDATA; w = (buf[0] + 1) * 8; h = (buf[1] + 1) * 8; buf += 2; if (w != avctx->width || h != avctx->height) { <S2SV_StartVul> av_frame_unref(c->prev); <S2SV_EndVul> if ((res = ff_set_dimensions(avctx, w, h)) < 0) return res; } maxcnt = w * h; <S2SV_StartVul> if ((res = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0) <S2SV_EndVul> return res; <S2SV_StartVul> out = (uint16_t *) frame->data[0]; <S2SV_EndVul> <S2SV_StartVul> if (c->prev->data[0]) { <S2SV_EndVul> <S2SV_StartVul> prev = (uint16_t *) c->prev->data[0]; <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> prev = NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> for (i = 0; i < 8; i++) offsets[i] = -1; while (outcnt < maxcnt && buf_end - 2 > buf) { int code = AV_RL16(buf); buf += 2; if (!(code & 0x8000)) { out[outcnt++] = code; } else { int count; int inp_off; uint16_t *inp; if ((code & 0x6000) == 0x6000) { int oidx = (code >> 10) & 7; int start; count = (code & 0x3FF) + 3; if (offsets[oidx] < 0) { if (buf_end - 3 < buf) break; offsets[oidx] = AV_RL24(buf); buf += 3; } start = (outcnt + offsets[oidx]) % maxcnt; if (maxcnt - start < count) break; if (!prev) { av_log(avctx, AV_LOG_ERROR, ""Frame reference does not exist\n""); break; } inp = prev; inp_off = start; } else { int offset = (code & 0x1FFF) + 1; if (!(code & 0x6000)) { count = 2; } else if ((code & 0x6000) == 0x2000) { count = 3; } else { if (buf_end - 1 < buf) break; count = 4 + *buf++; } if (outcnt < offset) break; inp = out; inp_off = outcnt - offset; } if (maxcnt - outcnt < count) break; for (i = inp_off; i < count + inp_off; i++) { out[outcnt++] = inp[i]; } } } if (outcnt - maxcnt) av_log(avctx, AV_LOG_DEBUG, ""frame finished with %d diff\n"", outcnt - maxcnt); <S2SV_StartVul> av_frame_unref(c->prev); <S2SV_EndVul> <S2SV_StartVul> if ((res = av_frame_ref(c->prev, frame)) < 0) <S2SV_EndVul> <S2SV_StartVul> return res; <S2SV_EndVul> *got_frame = 1; return avpkt->size; }","- av_frame_unref(c->prev);
- if ((res = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)
- out = (uint16_t *) frame->data[0];
- if (c->prev->data[0]) {
- prev = (uint16_t *) c->prev->data[0];
- } else {
- prev = NULL;
- }
- av_frame_unref(c->prev);
- if ((res = av_frame_ref(c->prev, frame)) < 0)
- return res;
+ av_freep(&c->frame_buffer);
+ av_freep(&c->last_frame_buffer);
+ if (!c->frame_buffer) {
+ c->frame_buffer = av_mallocz(avctx->width * avctx->height * 2);
+ c->last_frame_buffer = av_mallocz(avctx->width * avctx->height * 2);
+ if (!c->frame_buffer || !c->last_frame_buffer) {
+ decode_flush(avctx);
+ return AVERROR(ENOMEM);
+ }
+ }
+ if ((res = ff_get_buffer(avctx, frame, 0)) < 0)
+ out = c->frame_buffer;
+ prev = c->last_frame_buffer;
+ av_image_copy_plane(frame->data[0], frame->linesize[0],
+ (const uint8_t*)c->frame_buffer, avctx->width * 2,
+ avctx->width * 2, avctx->height);
+ FFSWAP(uint16_t *, c->frame_buffer, c->last_frame_buffer);","static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; const uint8_t *buf_end = buf + avpkt->size; KgvContext * const c = avctx->priv_data; int offsets[8]; uint16_t *out, *prev; int outcnt = 0, maxcnt; int w, h, i, res; if (avpkt->size < 2) return AVERROR_INVALIDDATA; w = (buf[0] + 1) * 8; h = (buf[1] + 1) * 8; buf += 2; if (w != avctx->width || h != avctx->height) { av_freep(&c->frame_buffer); av_freep(&c->last_frame_buffer); if ((res = ff_set_dimensions(avctx, w, h)) < 0) return res; } if (!c->frame_buffer) { c->frame_buffer = av_mallocz(avctx->width * avctx->height * 2); c->last_frame_buffer = av_mallocz(avctx->width * avctx->height * 2); if (!c->frame_buffer || !c->last_frame_buffer) { decode_flush(avctx); return AVERROR(ENOMEM); } } maxcnt = w * h; if ((res = ff_get_buffer(avctx, frame, 0)) < 0) return res; out = c->frame_buffer; prev = c->last_frame_buffer; for (i = 0; i < 8; i++) offsets[i] = -1; while (outcnt < maxcnt && buf_end - 2 > buf) { int code = AV_RL16(buf); buf += 2; if (!(code & 0x8000)) { out[outcnt++] = code; } else { int count; int inp_off; uint16_t *inp; if ((code & 0x6000) == 0x6000) { int oidx = (code >> 10) & 7; int start; count = (code & 0x3FF) + 3; if (offsets[oidx] < 0) { if (buf_end - 3 < buf) break; offsets[oidx] = AV_RL24(buf); buf += 3; } start = (outcnt + offsets[oidx]) % maxcnt; if (maxcnt - start < count) break; if (!prev) { av_log(avctx, AV_LOG_ERROR, ""Frame reference does not exist\n""); break; } inp = prev; inp_off = start; } else { int offset = (code & 0x1FFF) + 1; if (!(code & 0x6000)) { count = 2; } else if ((code & 0x6000) == 0x2000) { count = 3; } else { if (buf_end - 1 < buf) break; count = 4 + *buf++; } if (outcnt < offset) break; inp = out; inp_off = outcnt - offset; } if (maxcnt - outcnt < count) break; for (i = inp_off; i < count + inp_off; i++) { out[outcnt++] = inp[i]; } } } if (outcnt - maxcnt) av_log(avctx, AV_LOG_DEBUG, ""frame finished with %d diff\n"", outcnt - maxcnt); av_image_copy_plane(frame->data[0], frame->linesize[0], (const uint8_t*)c->frame_buffer, avctx->width * 2, avctx->width * 2, avctx->height); FFSWAP(uint16_t *, c->frame_buffer, c->last_frame_buffer); *got_frame = 1; return avpkt->size; }"
9288----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_1340d006666c194aafb4065eb48bc918c4a820fe_1.json----TIFFVStripSize,"tmsize_t TIFFVStripSize(TIFF* tif, uint32 nrows) { static const char module[] = ""TIFFVStripSize""; uint64 m; <S2SV_StartVul> tmsize_t n; <S2SV_EndVul> m=TIFFVStripSize64(tif,nrows); <S2SV_StartVul> n=(tmsize_t)m; <S2SV_EndVul> <S2SV_StartVul> if ((uint64)n!=m) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> TIFFErrorExt(tif->tif_clientdata,module,""Integer overflow""); <S2SV_EndVul> <S2SV_StartVul> n=0; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return(n); <S2SV_EndVul> }","- tmsize_t n;
- n=(tmsize_t)m;
- if ((uint64)n!=m)
- {
- TIFFErrorExt(tif->tif_clientdata,module,""Integer overflow"");
- n=0;
- }
- return(n);
+ return _TIFFCastUInt64ToSSize(tif, m, module);","tmsize_t TIFFVStripSize(TIFF* tif, uint32 nrows) { static const char module[] = ""TIFFVStripSize""; uint64 m; m=TIFFVStripSize64(tif,nrows); return _TIFFCastUInt64ToSSize(tif, m, module); }"
7048----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7b9818ec3c24ccabdc039e1b0085113ebad9f1e3_1.json----ff_rm_retrieve_cache,"int ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, AVPacket *pkt) { RMDemuxContext *rm = s->priv_data; assert (rm->audio_pkt_cnt > 0); if (ast->deint_id == DEINT_ID_VBRF || ast->deint_id == DEINT_ID_VBRS) av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]); else { <S2SV_StartVul> int ret = av_new_packet(pkt, st->codec->block_align); <S2SV_EndVul> if (ret < 0) return ret; <S2SV_StartVul> memcpy(pkt->data, ast->pkt.data + st->codec->block_align * <S2SV_StartVul> (ast->sub_packet_h * ast->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt), <S2SV_EndVul> <S2SV_StartVul> st->codec->block_align); <S2SV_EndVul> } rm->audio_pkt_cnt--; if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) { ast->audiotimestamp = AV_NOPTS_VALUE; pkt->flags = AV_PKT_FLAG_KEY; } else pkt->flags = 0; pkt->stream_index = st->index; return rm->audio_pkt_cnt; }","- int ret = av_new_packet(pkt, st->codec->block_align);
- memcpy(pkt->data, ast->pkt.data + st->codec->block_align * //FIXME avoid this
- (ast->sub_packet_h * ast->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt),
- st->codec->block_align);
+ int ret = av_new_packet(pkt, st->codecpar->block_align);
+ memcpy(pkt->data, ast->pkt.data + st->codecpar->block_align * //FIXME avoid this
+ (ast->sub_packet_h * ast->audio_framesize / st->codecpar->block_align - rm->audio_pkt_cnt),
+ st->codecpar->block_align);","int ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, AVPacket *pkt) { RMDemuxContext *rm = s->priv_data; assert (rm->audio_pkt_cnt > 0); if (ast->deint_id == DEINT_ID_VBRF || ast->deint_id == DEINT_ID_VBRS) av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]); else { int ret = av_new_packet(pkt, st->codecpar->block_align); if (ret < 0) return ret; memcpy(pkt->data, ast->pkt.data + st->codecpar->block_align * (ast->sub_packet_h * ast->audio_framesize / st->codecpar->block_align - rm->audio_pkt_cnt), st->codecpar->block_align); } rm->audio_pkt_cnt--; if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) { ast->audiotimestamp = AV_NOPTS_VALUE; pkt->flags = AV_PKT_FLAG_KEY; } else pkt->flags = 0; pkt->stream_index = st->index; return rm->audio_pkt_cnt; }"
1428----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4efdee98b33b34de7afafca39db9eb93e21de09d_1.json----gif_image_write_header,"static int gif_image_write_header(AVFormatContext *s, int width, int height, int loop_count, uint32_t *palette) { AVIOContext *pb = s->pb; AVRational sar = s->streams[0]->codec->sample_aspect_ratio; <S2SV_StartVul> int i, aspect = 0; <S2SV_EndVul> if (sar.num > 0 && sar.den > 0) { <S2SV_StartVul> aspect = sar.num * 64 / sar.den - 15; <S2SV_EndVul> if (aspect < 0 || aspect > 255) aspect = 0; } avio_write(pb, ""GIF"", 3); avio_write(pb, ""89a"", 3); avio_wl16(pb, width); avio_wl16(pb, height); if (palette) { avio_w8(pb, 0xf7); avio_w8(pb, 0x1f); avio_w8(pb, aspect); for (i = 0; i < 256; i++) { const uint32_t v = palette[i] & 0xffffff; avio_wb24(pb, v); } } else { avio_w8(pb, 0); avio_w8(pb, 0); avio_w8(pb, aspect); } if (loop_count >= 0 ) { avio_w8(pb, 0x21); avio_w8(pb, 0xff); avio_w8(pb, 0x0b); avio_write(pb, ""NETSCAPE2.0"", sizeof(""NETSCAPE2.0"") - 1); avio_w8(pb, 0x03); avio_w8(pb, 0x01); avio_wl16(pb, (uint16_t)loop_count); avio_w8(pb, 0x00); } return 0; }","- int i, aspect = 0;
- aspect = sar.num * 64 / sar.den - 15;
+ int i;
+ int64_t aspect = 0;
+ aspect = sar.num * 64LL / sar.den - 15;","static int gif_image_write_header(AVFormatContext *s, int width, int height, int loop_count, uint32_t *palette) { AVIOContext *pb = s->pb; AVRational sar = s->streams[0]->codec->sample_aspect_ratio; int i; int64_t aspect = 0; if (sar.num > 0 && sar.den > 0) { aspect = sar.num * 64LL / sar.den - 15; if (aspect < 0 || aspect > 255) aspect = 0; } avio_write(pb, ""GIF"", 3); avio_write(pb, ""89a"", 3); avio_wl16(pb, width); avio_wl16(pb, height); if (palette) { avio_w8(pb, 0xf7); avio_w8(pb, 0x1f); avio_w8(pb, aspect); for (i = 0; i < 256; i++) { const uint32_t v = palette[i] & 0xffffff; avio_wb24(pb, v); } } else { avio_w8(pb, 0); avio_w8(pb, 0); avio_w8(pb, aspect); } if (loop_count >= 0 ) { avio_w8(pb, 0x21); avio_w8(pb, 0xff); avio_w8(pb, 0x0b); avio_write(pb, ""NETSCAPE2.0"", sizeof(""NETSCAPE2.0"") - 1); avio_w8(pb, 0x03); avio_w8(pb, 0x01); avio_wl16(pb, (uint16_t)loop_count); avio_w8(pb, 0x00); } return 0; }"
1546----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5602392c6b7966ca628d035fdc8f8143d102a79f_1.json----mv_pred_direct,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw, cavs_vector *col_mv) { cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS; <S2SV_StartVul> int den = h->direct_den[col_mv->ref]; <S2SV_EndVul> int m = FF_SIGNBIT(col_mv->x); pmv_fw->dist = h->dist[1]; pmv_bw->dist = h->dist[0]; pmv_fw->ref = 1; pmv_bw->ref = 0; pmv_fw->x = (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); m = FF_SIGNBIT(col_mv->y); pmv_fw->y = (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); }","- int den = h->direct_den[col_mv->ref];
+ unsigned den = h->direct_den[col_mv->ref];","static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw, cavs_vector *col_mv) { cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS; unsigned den = h->direct_den[col_mv->ref]; int m = FF_SIGNBIT(col_mv->x); pmv_fw->dist = h->dist[1]; pmv_bw->dist = h->dist[0]; pmv_fw->ref = 1; pmv_bw->ref = 0; pmv_fw->x = (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); m = FF_SIGNBIT(col_mv->y); pmv_fw->y = (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m); }"
1565----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_573f195ba032beef6bef422f9054e8aab866a360_1.json----bfi_read_header,"static int bfi_read_header(AVFormatContext * s) { BFIContext *bfi = s->priv_data; AVIOContext *pb = s->pb; AVStream *vstream; AVStream *astream; int fps, chunk_header; vstream = avformat_new_stream(s, NULL); if (!vstream) return AVERROR(ENOMEM); astream = avformat_new_stream(s, NULL); if (!astream) return AVERROR(ENOMEM); avio_skip(pb, 8); chunk_header = avio_rl32(pb); bfi->nframes = avio_rl32(pb); avio_rl32(pb); avio_rl32(pb); avio_rl32(pb); fps = avio_rl32(pb); avio_skip(pb, 12); vstream->codecpar->width = avio_rl32(pb); vstream->codecpar->height = avio_rl32(pb); avio_skip(pb, 8); vstream->codecpar->extradata = av_malloc(768); if (!vstream->codecpar->extradata) return AVERROR(ENOMEM); vstream->codecpar->extradata_size = 768; avio_read(pb, vstream->codecpar->extradata, vstream->codecpar->extradata_size); astream->codecpar->sample_rate = avio_rl32(pb); if (astream->codecpar->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, ""Invalid sample rate %d\n"", astream->codecpar->sample_rate); return AVERROR_INVALIDDATA; } avpriv_set_pts_info(vstream, 32, 1, fps); vstream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO; vstream->codecpar->codec_id = AV_CODEC_ID_BFI; vstream->codecpar->format = AV_PIX_FMT_PAL8; vstream->nb_frames = vstream->duration = bfi->nframes; astream->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; astream->codecpar->codec_id = AV_CODEC_ID_PCM_U8; astream->codecpar->channels = 1; astream->codecpar->channel_layout = AV_CH_LAYOUT_MONO; astream->codecpar->bits_per_coded_sample = 8; astream->codecpar->bit_rate = <S2SV_StartVul> astream->codecpar->sample_rate * astream->codecpar->bits_per_coded_sample; <S2SV_EndVul> avio_seek(pb, chunk_header - 3, SEEK_SET); avpriv_set_pts_info(astream, 64, 1, astream->codecpar->sample_rate); return 0; }","- astream->codecpar->sample_rate * astream->codecpar->bits_per_coded_sample;
+ (int64_t)astream->codecpar->sample_rate * astream->codecpar->bits_per_coded_sample;","static int bfi_read_header(AVFormatContext * s) { BFIContext *bfi = s->priv_data; AVIOContext *pb = s->pb; AVStream *vstream; AVStream *astream; int fps, chunk_header; vstream = avformat_new_stream(s, NULL); if (!vstream) return AVERROR(ENOMEM); astream = avformat_new_stream(s, NULL); if (!astream) return AVERROR(ENOMEM); avio_skip(pb, 8); chunk_header = avio_rl32(pb); bfi->nframes = avio_rl32(pb); avio_rl32(pb); avio_rl32(pb); avio_rl32(pb); fps = avio_rl32(pb); avio_skip(pb, 12); vstream->codecpar->width = avio_rl32(pb); vstream->codecpar->height = avio_rl32(pb); avio_skip(pb, 8); vstream->codecpar->extradata = av_malloc(768); if (!vstream->codecpar->extradata) return AVERROR(ENOMEM); vstream->codecpar->extradata_size = 768; avio_read(pb, vstream->codecpar->extradata, vstream->codecpar->extradata_size); astream->codecpar->sample_rate = avio_rl32(pb); if (astream->codecpar->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, ""Invalid sample rate %d\n"", astream->codecpar->sample_rate); return AVERROR_INVALIDDATA; } avpriv_set_pts_info(vstream, 32, 1, fps); vstream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO; vstream->codecpar->codec_id = AV_CODEC_ID_BFI; vstream->codecpar->format = AV_PIX_FMT_PAL8; vstream->nb_frames = vstream->duration = bfi->nframes; astream->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; astream->codecpar->codec_id = AV_CODEC_ID_PCM_U8; astream->codecpar->channels = 1; astream->codecpar->channel_layout = AV_CH_LAYOUT_MONO; astream->codecpar->bits_per_coded_sample = 8; astream->codecpar->bit_rate = (int64_t)astream->codecpar->sample_rate * astream->codecpar->bits_per_coded_sample; avio_seek(pb, chunk_header - 3, SEEK_SET); avpriv_set_pts_info(astream, 64, 1, astream->codecpar->sample_rate); return 0; }"
10812----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1389c74ded70b29b6d46e0891261b1d841f4af9d_1.json----rsa_main,"int MAIN(int argc, char **argv) { int ret=1; RSA *rsa=NULL; int i,badops=0; const EVP_CIPHER *enc=NULL; BIO *in=NULL,*out=NULL; int informat,outformat,text=0,check=0,noout=0; int pubin = 0, pubout = 0; char *infile,*outfile,*prog; char *passin = NULL, *passout = NULL; int modulus=0; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-passin"") == 0) { if (--argc < 1) goto bad; passin= *(++argv); } else if (strcmp(*argv,""-envpassin"") == 0) { if (--argc < 1) goto bad; if(!(passin= getenv(*(++argv)))) { BIO_printf(bio_err, ""Can't read environment variable %s\n"", *argv); badops = 1; } } else if (strcmp(*argv,""-envpassout"") == 0) { if (--argc < 1) goto bad; if(!(passout= getenv(*(++argv)))) { BIO_printf(bio_err, ""Can't read environment variable %s\n"", *argv); badops = 1; } argv++; } else if (strcmp(*argv,""-passout"") == 0) { if (--argc < 1) goto bad; passout= *(++argv); } else if (strcmp(*argv,""-pubin"") == 0) pubin=1; else if (strcmp(*argv,""-pubout"") == 0) pubout=1; else if (strcmp(*argv,""-noout"") == 0) noout=1; else if (strcmp(*argv,""-text"") == 0) text=1; else if (strcmp(*argv,""-modulus"") == 0) modulus=1; else if (strcmp(*argv,""-check"") == 0) check=1; else if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL) { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - one of DER NET PEM\n""); BIO_printf(bio_err,"" -outform arg output format - one of DER NET PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -passin arg input file pass phrase\n""); BIO_printf(bio_err,"" -envpassin arg environment variable containing input file pass phrase\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -passout arg input file pass phrase\n""); BIO_printf(bio_err,"" -envpassout arg environment variable containing input file pass phrase\n""); BIO_printf(bio_err,"" -des encrypt PEM output with cbc des\n""); BIO_printf(bio_err,"" -des3 encrypt PEM output with ede cbc des using 168 bit key\n""); #ifndef NO_IDEA BIO_printf(bio_err,"" -idea encrypt PEM output with cbc idea\n""); #endif BIO_printf(bio_err,"" -text print the key in text\n""); BIO_printf(bio_err,"" -noout don't print key out\n""); BIO_printf(bio_err,"" -modulus print the RSA key modulus\n""); BIO_printf(bio_err,"" -check verify key consistency\n""); BIO_printf(bio_err,"" -pubin expect a public key in input file\n""); BIO_printf(bio_err,"" -pubout output a public key\n""); goto end; } ERR_load_crypto_strings(); in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) { perror(infile); goto end; } } <S2SV_StartVul> BIO_printf(bio_err,""read RSA private key\n""); <S2SV_EndVul> if (informat == FORMAT_ASN1) { <S2SV_StartVul> if (pubin) rsa=d2i_RSAPublicKey_bio(in,NULL); <S2SV_EndVul> else rsa=d2i_RSAPrivateKey_bio(in,NULL); } #ifndef NO_RC4 else if (informat == FORMAT_NETSCAPE) { BUF_MEM *buf=NULL; unsigned char *p; int size=0; buf=BUF_MEM_new(); for (;;) { if ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10))) goto end; i=BIO_read(in,&(buf->data[size]),1024*10); size+=i; if (i == 0) break; if (i < 0) { perror(""reading private key""); BUF_MEM_free(buf); goto end; } } p=(unsigned char *)buf->data; rsa=(RSA *)d2i_Netscape_RSA(NULL,&p,(long)size,NULL); BUF_MEM_free(buf); } #endif else if (informat == FORMAT_PEM) { <S2SV_StartVul> if(pubin) rsa=PEM_read_bio_RSAPublicKey(in,NULL,NULL,NULL); <S2SV_EndVul> else { if(passin) rsa=PEM_read_bio_RSAPrivateKey(in,NULL, key_cb,passin); else rsa=PEM_read_bio_RSAPrivateKey(in,NULL,NULL,NULL); } } else { BIO_printf(bio_err,""bad input format specified for key\n""); goto end; } if (rsa == NULL) { <S2SV_StartVul> BIO_printf(bio_err,""unable to load Key\n""); <S2SV_EndVul> ERR_print_errors(bio_err); goto end; } if (outfile == NULL) BIO_set_fp(out,stdout,BIO_NOCLOSE); else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (text) if (!RSA_print(out,rsa,0)) { perror(outfile); ERR_print_errors(bio_err); goto end; } if (modulus) { <S2SV_StartVul> fprintf(stdout,""Modulus=""); <S2SV_EndVul> BN_print(out,rsa->n); <S2SV_StartVul> fprintf(stdout,""\n""); <S2SV_EndVul> } if (check) { int r = RSA_check_key(rsa); if (r == 1) BIO_printf(out,""RSA key ok\n""); else if (r == 0) { long e; while ((e = ERR_peek_error()) != 0 && ERR_GET_LIB(e) == ERR_LIB_RSA && ERR_GET_FUNC(e) == RSA_F_RSA_CHECK_KEY && ERR_GET_REASON(e) != ERR_R_MALLOC_FAILURE) { BIO_printf(out, ""RSA key error: %s\n"", ERR_reason_error_string(e)); ERR_get_error(); } } if (r == -1 || ERR_peek_error() != 0) { ERR_print_errors(bio_err); goto end; } } if (noout) { ret = 0; goto end; } BIO_printf(bio_err,""writing RSA key\n""); if (outformat == FORMAT_ASN1) { <S2SV_StartVul> if(pubout || pubin) i=i2d_RSAPublicKey_bio(out,rsa); <S2SV_EndVul> else i=i2d_RSAPrivateKey_bio(out,rsa); } #ifndef NO_RC4 else if (outformat == FORMAT_NETSCAPE) { unsigned char *p,*pp; int size; i=1; size=i2d_Netscape_RSA(rsa,NULL,NULL); if ((p=(unsigned char *)Malloc(size)) == NULL) { BIO_printf(bio_err,""Malloc failure\n""); goto end; } pp=p; i2d_Netscape_RSA(rsa,&p,NULL); BIO_write(out,(char *)pp,size); Free(pp); } #endif else if (outformat == FORMAT_PEM) { if(pubout || pubin) <S2SV_StartVul> i=PEM_write_bio_RSAPublicKey(out,rsa); <S2SV_EndVul> else { if(passout) i=PEM_write_bio_RSAPrivateKey(out,rsa, enc,NULL,0,key_cb,passout); else i=PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL, 0,NULL,NULL); } } else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write key\n""); ERR_print_errors(bio_err); } else ret=0; end: if (in != NULL) BIO_free(in); if (out != NULL) BIO_free(out); if (rsa != NULL) RSA_free(rsa); EXIT(ret); }","- BIO_printf(bio_err,""read RSA private key\n"");
- if (pubin) rsa=d2i_RSAPublicKey_bio(in,NULL);
- if(pubin) rsa=PEM_read_bio_RSAPublicKey(in,NULL,NULL,NULL);
- BIO_printf(bio_err,""unable to load Key\n"");
- fprintf(stdout,""Modulus="");
- fprintf(stdout,""\n"");
- if(pubout || pubin) i=i2d_RSAPublicKey_bio(out,rsa);
- i=PEM_write_bio_RSAPublicKey(out,rsa);
+ if(check && pubin) {
+ BIO_printf(bio_err, ""Only private keys can be checked\n"");
+ goto end;
+ }
+ BIO_printf(bio_err,""read RSA key\n"");
+ if (pubin) rsa=d2i_RSA_PUBKEY_bio(in,NULL);
+ if(pubin) rsa=PEM_read_bio_RSA_PUBKEY(in,NULL,NULL,NULL);
+ BIO_printf(bio_err,""unable to load key\n"");
+ BIO_printf(out,""Modulus="");
+ BIO_printf(out,""\n"");
+ if(pubout || pubin) i=i2d_RSA_PUBKEY_bio(out,rsa);
+ i=PEM_write_bio_RSA_PUBKEY(out,rsa);","int MAIN(int argc, char **argv) { int ret=1; RSA *rsa=NULL; int i,badops=0; const EVP_CIPHER *enc=NULL; BIO *in=NULL,*out=NULL; int informat,outformat,text=0,check=0,noout=0; int pubin = 0, pubout = 0; char *infile,*outfile,*prog; char *passin = NULL, *passout = NULL; int modulus=0; apps_startup(); if (bio_err == NULL) if ((bio_err=BIO_new(BIO_s_file())) != NULL) BIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT); infile=NULL; outfile=NULL; informat=FORMAT_PEM; outformat=FORMAT_PEM; prog=argv[0]; argc--; argv++; while (argc >= 1) { if (strcmp(*argv,""-inform"") == 0) { if (--argc < 1) goto bad; informat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-outform"") == 0) { if (--argc < 1) goto bad; outformat=str2fmt(*(++argv)); } else if (strcmp(*argv,""-in"") == 0) { if (--argc < 1) goto bad; infile= *(++argv); } else if (strcmp(*argv,""-out"") == 0) { if (--argc < 1) goto bad; outfile= *(++argv); } else if (strcmp(*argv,""-passin"") == 0) { if (--argc < 1) goto bad; passin= *(++argv); } else if (strcmp(*argv,""-envpassin"") == 0) { if (--argc < 1) goto bad; if(!(passin= getenv(*(++argv)))) { BIO_printf(bio_err, ""Can't read environment variable %s\n"", *argv); badops = 1; } } else if (strcmp(*argv,""-envpassout"") == 0) { if (--argc < 1) goto bad; if(!(passout= getenv(*(++argv)))) { BIO_printf(bio_err, ""Can't read environment variable %s\n"", *argv); badops = 1; } argv++; } else if (strcmp(*argv,""-passout"") == 0) { if (--argc < 1) goto bad; passout= *(++argv); } else if (strcmp(*argv,""-pubin"") == 0) pubin=1; else if (strcmp(*argv,""-pubout"") == 0) pubout=1; else if (strcmp(*argv,""-noout"") == 0) noout=1; else if (strcmp(*argv,""-text"") == 0) text=1; else if (strcmp(*argv,""-modulus"") == 0) modulus=1; else if (strcmp(*argv,""-check"") == 0) check=1; else if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL) { BIO_printf(bio_err,""unknown option %s\n"",*argv); badops=1; break; } argc--; argv++; } if (badops) { bad: BIO_printf(bio_err,""%s [options] <infile >outfile\n"",prog); BIO_printf(bio_err,""where options are\n""); BIO_printf(bio_err,"" -inform arg input format - one of DER NET PEM\n""); BIO_printf(bio_err,"" -outform arg output format - one of DER NET PEM\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -passin arg input file pass phrase\n""); BIO_printf(bio_err,"" -envpassin arg environment variable containing input file pass phrase\n""); BIO_printf(bio_err,"" -in arg input file\n""); BIO_printf(bio_err,"" -out arg output file\n""); BIO_printf(bio_err,"" -passout arg input file pass phrase\n""); BIO_printf(bio_err,"" -envpassout arg environment variable containing input file pass phrase\n""); BIO_printf(bio_err,"" -des encrypt PEM output with cbc des\n""); BIO_printf(bio_err,"" -des3 encrypt PEM output with ede cbc des using 168 bit key\n""); #ifndef NO_IDEA BIO_printf(bio_err,"" -idea encrypt PEM output with cbc idea\n""); #endif BIO_printf(bio_err,"" -text print the key in text\n""); BIO_printf(bio_err,"" -noout don't print key out\n""); BIO_printf(bio_err,"" -modulus print the RSA key modulus\n""); BIO_printf(bio_err,"" -check verify key consistency\n""); BIO_printf(bio_err,"" -pubin expect a public key in input file\n""); BIO_printf(bio_err,"" -pubout output a public key\n""); goto end; } ERR_load_crypto_strings(); if(check && pubin) { BIO_printf(bio_err, ""Only private keys can be checked\n""); goto end; } in=BIO_new(BIO_s_file()); out=BIO_new(BIO_s_file()); if ((in == NULL) || (out == NULL)) { ERR_print_errors(bio_err); goto end; } if (infile == NULL) BIO_set_fp(in,stdin,BIO_NOCLOSE); else { if (BIO_read_filename(in,infile) <= 0) { perror(infile); goto end; } } BIO_printf(bio_err,""read RSA key\n""); if (informat == FORMAT_ASN1) { if (pubin) rsa=d2i_RSA_PUBKEY_bio(in,NULL); else rsa=d2i_RSAPrivateKey_bio(in,NULL); } #ifndef NO_RC4 else if (informat == FORMAT_NETSCAPE) { BUF_MEM *buf=NULL; unsigned char *p; int size=0; buf=BUF_MEM_new(); for (;;) { if ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10))) goto end; i=BIO_read(in,&(buf->data[size]),1024*10); size+=i; if (i == 0) break; if (i < 0) { perror(""reading private key""); BUF_MEM_free(buf); goto end; } } p=(unsigned char *)buf->data; rsa=(RSA *)d2i_Netscape_RSA(NULL,&p,(long)size,NULL); BUF_MEM_free(buf); } #endif else if (informat == FORMAT_PEM) { if(pubin) rsa=PEM_read_bio_RSA_PUBKEY(in,NULL,NULL,NULL); else { if(passin) rsa=PEM_read_bio_RSAPrivateKey(in,NULL, key_cb,passin); else rsa=PEM_read_bio_RSAPrivateKey(in,NULL,NULL,NULL); } } else { BIO_printf(bio_err,""bad input format specified for key\n""); goto end; } if (rsa == NULL) { BIO_printf(bio_err,""unable to load key\n""); ERR_print_errors(bio_err); goto end; } if (outfile == NULL) BIO_set_fp(out,stdout,BIO_NOCLOSE); else { if (BIO_write_filename(out,outfile) <= 0) { perror(outfile); goto end; } } if (text) if (!RSA_print(out,rsa,0)) { perror(outfile); ERR_print_errors(bio_err); goto end; } if (modulus) { BIO_printf(out,""Modulus=""); BN_print(out,rsa->n); BIO_printf(out,""\n""); } if (check) { int r = RSA_check_key(rsa); if (r == 1) BIO_printf(out,""RSA key ok\n""); else if (r == 0) { long e; while ((e = ERR_peek_error()) != 0 && ERR_GET_LIB(e) == ERR_LIB_RSA && ERR_GET_FUNC(e) == RSA_F_RSA_CHECK_KEY && ERR_GET_REASON(e) != ERR_R_MALLOC_FAILURE) { BIO_printf(out, ""RSA key error: %s\n"", ERR_reason_error_string(e)); ERR_get_error(); } } if (r == -1 || ERR_peek_error() != 0) { ERR_print_errors(bio_err); goto end; } } if (noout) { ret = 0; goto end; } BIO_printf(bio_err,""writing RSA key\n""); if (outformat == FORMAT_ASN1) { if(pubout || pubin) i=i2d_RSA_PUBKEY_bio(out,rsa); else i=i2d_RSAPrivateKey_bio(out,rsa); } #ifndef NO_RC4 else if (outformat == FORMAT_NETSCAPE) { unsigned char *p,*pp; int size; i=1; size=i2d_Netscape_RSA(rsa,NULL,NULL); if ((p=(unsigned char *)Malloc(size)) == NULL) { BIO_printf(bio_err,""Malloc failure\n""); goto end; } pp=p; i2d_Netscape_RSA(rsa,&p,NULL); BIO_write(out,(char *)pp,size); Free(pp); } #endif else if (outformat == FORMAT_PEM) { if(pubout || pubin) i=PEM_write_bio_RSA_PUBKEY(out,rsa); else { if(passout) i=PEM_write_bio_RSAPrivateKey(out,rsa, enc,NULL,0,key_cb,passout); else i=PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL, 0,NULL,NULL); } } else { BIO_printf(bio_err,""bad output format specified for outfile\n""); goto end; } if (!i) { BIO_printf(bio_err,""unable to write key\n""); ERR_print_errors(bio_err); } else ret=0; end: if (in != NULL) BIO_free(in); if (out != NULL) BIO_free(out); if (rsa != NULL) RSA_free(rsa); EXIT(ret); }"
360----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_154dc68c474a3d56a3531d66ff351c690b3c4230_1.json----mpeg_er_decode_mb,"static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type, int (*mv)[2][4][2], int mb_x, int mb_y, int mb_intra, int mb_skipped) { MpegEncContext *s = opaque; s->mv_dir = mv_dir; s->mv_type = mv_type; s->mb_intra = mb_intra; s->mb_skipped = mb_skipped; s->mb_x = mb_x; s->mb_y = mb_y; memcpy(s->mv, mv, sizeof(*mv)); ff_init_block_index(s); ff_update_block_index(s); s->dsp.clear_blocks(s->block[0]); <S2SV_StartVul> s->dest[0] = s->current_picture.f.data[0] + (s->mb_y * 16 * s->linesize) + s->mb_x * 16; <S2SV_EndVul> <S2SV_StartVul> s->dest[1] = s->current_picture.f.data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift); <S2SV_EndVul> <S2SV_StartVul> s->dest[2] = s->current_picture.f.data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift); <S2SV_EndVul> assert(ref == 0); ff_MPV_decode_mb(s, s->block); }","- s->dest[0] = s->current_picture.f.data[0] + (s->mb_y * 16 * s->linesize) + s->mb_x * 16;
- s->dest[1] = s->current_picture.f.data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);
- s->dest[2] = s->current_picture.f.data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);
+ s->dest[0] = s->current_picture.f->data[0] + (s->mb_y * 16 * s->linesize) + s->mb_x * 16;
+ s->dest[1] = s->current_picture.f->data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);
+ s->dest[2] = s->current_picture.f->data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);","static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type, int (*mv)[2][4][2], int mb_x, int mb_y, int mb_intra, int mb_skipped) { MpegEncContext *s = opaque; s->mv_dir = mv_dir; s->mv_type = mv_type; s->mb_intra = mb_intra; s->mb_skipped = mb_skipped; s->mb_x = mb_x; s->mb_y = mb_y; memcpy(s->mv, mv, sizeof(*mv)); ff_init_block_index(s); ff_update_block_index(s); s->dsp.clear_blocks(s->block[0]); s->dest[0] = s->current_picture.f->data[0] + (s->mb_y * 16 * s->linesize) + s->mb_x * 16; s->dest[1] = s->current_picture.f->data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift); s->dest[2] = s->current_picture.f->data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift); assert(ref == 0); ff_MPV_decode_mb(s, s->block); }"
1273----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_44cc7d03fd44f5e9fe2532f3f0931328e0802fad_1.json----av_int2dbl,"double av_int2dbl(int64_t v){ <S2SV_StartVul> if(v+v > 0xFFEULL<<52) <S2SV_EndVul> return NAN; return ldexp(((v&((1LL<<52)-1)) + (1LL<<52)) * (v>>63|1), (v>>52&0x7FF)-1075); }","- if(v+v > 0xFFEULL<<52)
+ if((uint64_t)v+v > 0xFFEULL<<52)","double av_int2dbl(int64_t v){ if((uint64_t)v+v > 0xFFEULL<<52) return NAN; return ldexp(((v&((1LL<<52)-1)) + (1LL<<52)) * (v>>63|1), (v>>52&0x7FF)-1075); }"
16502----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_da21ed89ab2422923ff183f61851981d263fa51b_1.json----RAND_poll,"int RAND_poll(void) { int ret = 0; RAND_POOL *pool = NULL; const RAND_METHOD *meth = RAND_get_rand_method(); if (meth == RAND_OpenSSL()) { RAND_DRBG *drbg = RAND_DRBG_get0_master(); if (drbg == NULL) return 0; rand_drbg_lock(drbg); ret = rand_drbg_restart(drbg, NULL, 0, 0); rand_drbg_unlock(drbg); return ret; } else { pool = rand_pool_new(RAND_DRBG_STRENGTH, RAND_DRBG_STRENGTH / 8, <S2SV_StartVul> DRBG_MINMAX_FACTOR * (RAND_DRBG_STRENGTH / 8)); <S2SV_EndVul> if (pool == NULL) return 0; if (rand_pool_acquire_entropy(pool) == 0) goto err; if (meth->add == NULL || meth->add(rand_pool_buffer(pool), rand_pool_length(pool), (rand_pool_entropy(pool) / 8.0)) == 0) goto err; ret = 1; } err: rand_pool_free(pool); return ret; }","- DRBG_MINMAX_FACTOR * (RAND_DRBG_STRENGTH / 8));
+ RAND_POOL_MAX_LENGTH);","int RAND_poll(void) { int ret = 0; RAND_POOL *pool = NULL; const RAND_METHOD *meth = RAND_get_rand_method(); if (meth == RAND_OpenSSL()) { RAND_DRBG *drbg = RAND_DRBG_get0_master(); if (drbg == NULL) return 0; rand_drbg_lock(drbg); ret = rand_drbg_restart(drbg, NULL, 0, 0); rand_drbg_unlock(drbg); return ret; } else { pool = rand_pool_new(RAND_DRBG_STRENGTH, RAND_DRBG_STRENGTH / 8, RAND_POOL_MAX_LENGTH); if (pool == NULL) return 0; if (rand_pool_acquire_entropy(pool) == 0) goto err; if (meth->add == NULL || meth->add(rand_pool_buffer(pool), rand_pool_length(pool), (rand_pool_entropy(pool) / 8.0)) == 0) goto err; ret = 1; } err: rand_pool_free(pool); return ret; }"
13252----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_698c2b1bfbbd2714c819dc083b360de7e44a4799_1.json----test_PACKET_get_1,"<S2SV_StartVul> static int test_PACKET_get_1(unsigned char buf[BUF_LEN]) <S2SV_EndVul> { unsigned int i; PACKET pkt; <S2SV_StartVul> if ( !PACKET_buf_init(&pkt, buf, BUF_LEN) <S2SV_EndVul> <S2SV_StartVul> || !PACKET_get_1(&pkt, &i) <S2SV_EndVul> <S2SV_StartVul> || i != 0x02 <S2SV_EndVul> <S2SV_StartVul> || !PACKET_forward(&pkt, BUF_LEN - 2) <S2SV_EndVul> <S2SV_StartVul> || !PACKET_get_1(&pkt, &i) <S2SV_EndVul> <S2SV_StartVul> || i != 0xfe <S2SV_EndVul> <S2SV_StartVul> || PACKET_get_1(&pkt, &i)) { <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""test_PACKET_get_1() failed\n""); <S2SV_EndVul> return 0; <S2SV_StartVul> } <S2SV_EndVul> return 1; }","- static int test_PACKET_get_1(unsigned char buf[BUF_LEN])
- if ( !PACKET_buf_init(&pkt, buf, BUF_LEN)
- || !PACKET_get_1(&pkt, &i)
- || i != 0x02
- || !PACKET_forward(&pkt, BUF_LEN - 2)
- || !PACKET_get_1(&pkt, &i)
- || i != 0xfe
- || PACKET_get_1(&pkt, &i)) {
- fprintf(stderr, ""test_PACKET_get_1() failed\n"");
- }
+ static int test_PACKET_get_1()
+ if (!TEST_true(PACKET_buf_init(&pkt, smbuf, BUF_LEN))
+ || !TEST_true(PACKET_get_1(&pkt, &i))
+ || !TEST_uint_eq(i, 0x02)
+ || !TEST_true(PACKET_forward(&pkt, BUF_LEN - 2))
+ || !TEST_true(PACKET_get_1(&pkt, &i))
+ || !TEST_uint_eq(i, 0xfe)
+ || !TEST_false(PACKET_get_1(&pkt, &i)))","static int test_PACKET_get_1() { unsigned int i; PACKET pkt; if (!TEST_true(PACKET_buf_init(&pkt, smbuf, BUF_LEN)) || !TEST_true(PACKET_get_1(&pkt, &i)) || !TEST_uint_eq(i, 0x02) || !TEST_true(PACKET_forward(&pkt, BUF_LEN - 2)) || !TEST_true(PACKET_get_1(&pkt, &i)) || !TEST_uint_eq(i, 0xfe) || !TEST_false(PACKET_get_1(&pkt, &i))) return 0; return 1; }"
644----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_23126356b24757bdcfe0674fcfb66697fdd13393_1.json----end_frame,static void end_frame(AVFilterLink *link) { ff_end_frame(link->dst->outputs[0]); avfilter_unref_buffer(link->dst->outputs[0]->out_buf); <S2SV_StartVul> avfilter_unref_buffer(link->cur_buf); <S2SV_EndVul> },- avfilter_unref_buffer(link->cur_buf);,static void end_frame(AVFilterLink *link) { ff_end_frame(link->dst->outputs[0]); avfilter_unref_buffer(link->dst->outputs[0]->out_buf); }
3761----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ca0c9794c109ad6e45be52fd3eaa158b420d6542_1.json----unpack_codebook,"static CodeBook unpack_codebook(GetBitContext* gb, unsigned depth, unsigned size) { unsigned i, j; CodeBook cb = { 0 }; <S2SV_StartVul> if (!can_safely_read(gb, (uint64_t)size * 34)) <S2SV_EndVul> return cb; if (size >= INT_MAX / sizeof(MacroBlock)) return cb; cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1); if (!cb.blocks) return cb; cb.depth = depth; cb.size = size; for (i = 0; i < size; i++) { unsigned mask_bits = get_bits(gb, 4); unsigned color0 = get_bits(gb, 15); unsigned color1 = get_bits(gb, 15); for (j = 0; j < 4; j++) { if (mask_bits & (1 << j)) cb.blocks[i].pixels[j] = color1; else cb.blocks[i].pixels[j] = color0; } } return cb; }","- if (!can_safely_read(gb, (uint64_t)size * 34))
+ if (size >= INT_MAX / 34 || get_bits_left(gb) < size * 34)","static CodeBook unpack_codebook(GetBitContext* gb, unsigned depth, unsigned size) { unsigned i, j; CodeBook cb = { 0 }; if (size >= INT_MAX / 34 || get_bits_left(gb) < size * 34) return cb; if (size >= INT_MAX / sizeof(MacroBlock)) return cb; cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1); if (!cb.blocks) return cb; cb.depth = depth; cb.size = size; for (i = 0; i < size; i++) { unsigned mask_bits = get_bits(gb, 4); unsigned color0 = get_bits(gb, 15); unsigned color1 = get_bits(gb, 15); for (j = 0; j < 4; j++) { if (mask_bits & (1 << j)) cb.blocks[i].pixels[j] = color1; else cb.blocks[i].pixels[j] = color0; } } return cb; }"
3158----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ab81507ea9bb50c6061558765251101735069158_1.json----gxf_packet,"static int gxf_packet(AVFormatContext *s, AVPacket *pkt) { ByteIOContext *pb = s->pb; pkt_type_t pkt_type; int pkt_len; while (!url_feof(pb)) { int track_type, track_id, ret; <S2SV_StartVul> int field_nr; <S2SV_EndVul> int stream_index; if (!parse_packet_header(pb, &pkt_type, &pkt_len)) { if (!url_feof(pb)) av_log(s, AV_LOG_ERROR, ""GXF: sync lost\n""); return -1; } if (pkt_type == PKT_FLT) { gxf_read_index(s, pkt_len); continue; } if (pkt_type != PKT_MEDIA) { url_fskip(pb, pkt_len); continue; } if (pkt_len < 16) { av_log(s, AV_LOG_ERROR, ""GXF: invalid media packet length\n""); continue; } pkt_len -= 16; track_type = get_byte(pb); track_id = get_byte(pb); stream_index = get_sindex(s, track_id, track_type); if (stream_index < 0) return stream_index; field_nr = get_be32(pb); <S2SV_StartVul> get_be32(pb); get_be32(pb); get_byte(pb); get_byte(pb); ret = av_get_packet(pb, pkt, pkt_len); pkt->stream_index = stream_index; pkt->dts = field_nr; return ret; } return AVERROR(EIO); }","- int field_nr;
- get_be32(pb); // field information
+ AVStream *st;
+ int field_nr, field_info, skip = 0;
+ st = s->streams[stream_index];
+ field_info = get_be32(pb);
+ if (st->codec->codec_id == CODEC_ID_PCM_S24LE ||
+ st->codec->codec_id == CODEC_ID_PCM_S16LE) {
+ int first = field_info >> 16;
+ int last = field_info & 0xffff; // last is exclusive
+ int bps = av_get_bits_per_sample(st->codec->codec_id)>>3;
+ if (first <= last && last*bps <= pkt_len) {
+ url_fskip(pb, first*bps);
+ skip = pkt_len - last*bps;
+ pkt_len = (last-first)*bps;
+ } else
+ av_log(s, AV_LOG_ERROR, ""invalid first and last sample values\n"");
+ }
+ if (skip)
+ url_fskip(pb, skip);","static int gxf_packet(AVFormatContext *s, AVPacket *pkt) { ByteIOContext *pb = s->pb; pkt_type_t pkt_type; int pkt_len; while (!url_feof(pb)) { AVStream *st; int track_type, track_id, ret; int field_nr, field_info, skip = 0; int stream_index; if (!parse_packet_header(pb, &pkt_type, &pkt_len)) { if (!url_feof(pb)) av_log(s, AV_LOG_ERROR, ""GXF: sync lost\n""); return -1; } if (pkt_type == PKT_FLT) { gxf_read_index(s, pkt_len); continue; } if (pkt_type != PKT_MEDIA) { url_fskip(pb, pkt_len); continue; } if (pkt_len < 16) { av_log(s, AV_LOG_ERROR, ""GXF: invalid media packet length\n""); continue; } pkt_len -= 16; track_type = get_byte(pb); track_id = get_byte(pb); stream_index = get_sindex(s, track_id, track_type); if (stream_index < 0) return stream_index; st = s->streams[stream_index]; field_nr = get_be32(pb); field_info = get_be32(pb); get_be32(pb); get_byte(pb); get_byte(pb); if (st->codec->codec_id == CODEC_ID_PCM_S24LE || st->codec->codec_id == CODEC_ID_PCM_S16LE) { int first = field_info >> 16; int last = field_info & 0xffff; int bps = av_get_bits_per_sample(st->codec->codec_id)>>3; if (first <= last && last*bps <= pkt_len) { url_fskip(pb, first*bps); skip = pkt_len - last*bps; pkt_len = (last-first)*bps; } else av_log(s, AV_LOG_ERROR, ""invalid first and last sample values\n""); } ret = av_get_packet(pb, pkt, pkt_len); if (skip) url_fskip(pb, skip); pkt->stream_index = stream_index; pkt->dts = field_nr; return ret; } return AVERROR(EIO); }"
9138----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fa508c73c8ae5ffe26b0e76063a3947f11c02b86_1.json----vc1_decode_skip_blocks,"static void vc1_decode_skip_blocks(VC1Context *v) { MpegEncContext *s = &v->s; ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END); s->first_slice_line = 1; for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) { s->mb_x = 0; <S2SV_StartVul> ff_init_block_index(s); <S2SV_EndVul> ff_update_block_index(s); memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize, s->linesize * 16); memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y * 8 * s->uvlinesize, s->uvlinesize * 8); memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y * 8 * s->uvlinesize, s->uvlinesize * 8); ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16); s->first_slice_line = 0; } s->pict_type = AV_PICTURE_TYPE_P; }","- ff_init_block_index(s);
+ init_block_index(v);","static void vc1_decode_skip_blocks(VC1Context *v) { MpegEncContext *s = &v->s; ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END); s->first_slice_line = 1; for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) { s->mb_x = 0; init_block_index(v); ff_update_block_index(s); memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize, s->linesize * 16); memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y * 8 * s->uvlinesize, s->uvlinesize * 8); memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y * 8 * s->uvlinesize, s->uvlinesize * 8); ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16); s->first_slice_line = 0; } s->pict_type = AV_PICTURE_TYPE_P; }"
10405----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_041a1aee0d2e8593dc3ca89319b9b470b266fe84_1.json----X509V3_add_value,"int X509V3_add_value(const char *name, const char *value, STACK_OF(CONF_VALUE) **extlist) { CONF_VALUE *vtmp = NULL; char *tname = NULL, *tvalue = NULL; <S2SV_StartVul> if (name && (tname = BUF_strdup(name)) == NULL) <S2SV_EndVul> goto err; <S2SV_StartVul> if (value && (tvalue = BUF_strdup(value)) == NULL) <S2SV_EndVul> goto err; if ((vtmp = OPENSSL_malloc(sizeof(*vtmp))) == NULL) goto err; if (*extlist == NULL && (*extlist = sk_CONF_VALUE_new_null()) == NULL) goto err; vtmp->section = NULL; vtmp->name = tname; vtmp->value = tvalue; if (!sk_CONF_VALUE_push(*extlist, vtmp)) goto err; return 1; err: X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE); OPENSSL_free(vtmp); OPENSSL_free(tname); OPENSSL_free(tvalue); return 0; }","- if (name && (tname = BUF_strdup(name)) == NULL)
- if (value && (tvalue = BUF_strdup(value)) == NULL)
+ if (name && (tname = OPENSSL_strdup(name)) == NULL)
+ if (value && (tvalue = OPENSSL_strdup(value)) == NULL)","int X509V3_add_value(const char *name, const char *value, STACK_OF(CONF_VALUE) **extlist) { CONF_VALUE *vtmp = NULL; char *tname = NULL, *tvalue = NULL; if (name && (tname = OPENSSL_strdup(name)) == NULL) goto err; if (value && (tvalue = OPENSSL_strdup(value)) == NULL) goto err; if ((vtmp = OPENSSL_malloc(sizeof(*vtmp))) == NULL) goto err; if (*extlist == NULL && (*extlist = sk_CONF_VALUE_new_null()) == NULL) goto err; vtmp->section = NULL; vtmp->name = tname; vtmp->value = tvalue; if (!sk_CONF_VALUE_push(*extlist, vtmp)) goto err; return 1; err: X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE); OPENSSL_free(vtmp); OPENSSL_free(tname); OPENSSL_free(tvalue); return 0; }"
10596----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0bbc4f3f7d03e8b8f0463e1e5c77a65c6282fa7d_1.json----tls13_hkdf_expand,"int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret, const unsigned char *label, size_t labellen, <S2SV_StartVul> const unsigned char *hash, <S2SV_EndVul> unsigned char *out, size_t outlen) { const unsigned char label_prefix[] = ""tls13 ""; EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, NULL); int ret; size_t hkdflabellen; size_t hashlen; unsigned char hkdflabel[sizeof(uint16_t) + sizeof(uint8_t) + + sizeof(label_prefix) + TLS13_MAX_LABEL_LEN + EVP_MAX_MD_SIZE]; WPACKET pkt; if (pctx == NULL) return 0; hashlen = EVP_MD_size(md); if (!WPACKET_init_static_len(&pkt, hkdflabel, sizeof(hkdflabel), 0) || !WPACKET_put_bytes_u16(&pkt, outlen) || !WPACKET_start_sub_packet_u8(&pkt) || !WPACKET_memcpy(&pkt, label_prefix, sizeof(label_prefix) - 1) || !WPACKET_memcpy(&pkt, label, labellen) || !WPACKET_close(&pkt) <S2SV_StartVul> || !WPACKET_sub_memcpy_u8(&pkt, hash, (hash == NULL) ? 0 : hashlen) <S2SV_EndVul> || !WPACKET_get_total_written(&pkt, &hkdflabellen) || !WPACKET_finish(&pkt)) { EVP_PKEY_CTX_free(pctx); WPACKET_cleanup(&pkt); return 0; } ret = EVP_PKEY_derive_init(pctx) <= 0 || EVP_PKEY_CTX_hkdf_mode(pctx, EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) <= 0 || EVP_PKEY_CTX_set_hkdf_md(pctx, md) <= 0 || EVP_PKEY_CTX_set1_hkdf_key(pctx, secret, hashlen) <= 0 || EVP_PKEY_CTX_add1_hkdf_info(pctx, hkdflabel, hkdflabellen) <= 0 || EVP_PKEY_derive(pctx, out, &outlen) <= 0; EVP_PKEY_CTX_free(pctx); return ret == 0; }","- const unsigned char *hash,
- || !WPACKET_sub_memcpy_u8(&pkt, hash, (hash == NULL) ? 0 : hashlen)
+ const unsigned char *data, size_t datalen,
+ || !WPACKET_sub_memcpy_u8(&pkt, data, (data == NULL) ? 0 : datalen)","int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret, const unsigned char *label, size_t labellen, const unsigned char *data, size_t datalen, unsigned char *out, size_t outlen) { const unsigned char label_prefix[] = ""tls13 ""; EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, NULL); int ret; size_t hkdflabellen; size_t hashlen; unsigned char hkdflabel[sizeof(uint16_t) + sizeof(uint8_t) + + sizeof(label_prefix) + TLS13_MAX_LABEL_LEN + EVP_MAX_MD_SIZE]; WPACKET pkt; if (pctx == NULL) return 0; hashlen = EVP_MD_size(md); if (!WPACKET_init_static_len(&pkt, hkdflabel, sizeof(hkdflabel), 0) || !WPACKET_put_bytes_u16(&pkt, outlen) || !WPACKET_start_sub_packet_u8(&pkt) || !WPACKET_memcpy(&pkt, label_prefix, sizeof(label_prefix) - 1) || !WPACKET_memcpy(&pkt, label, labellen) || !WPACKET_close(&pkt) || !WPACKET_sub_memcpy_u8(&pkt, data, (data == NULL) ? 0 : datalen) || !WPACKET_get_total_written(&pkt, &hkdflabellen) || !WPACKET_finish(&pkt)) { EVP_PKEY_CTX_free(pctx); WPACKET_cleanup(&pkt); return 0; } ret = EVP_PKEY_derive_init(pctx) <= 0 || EVP_PKEY_CTX_hkdf_mode(pctx, EVP_PKEY_HKDEF_MODE_EXPAND_ONLY) <= 0 || EVP_PKEY_CTX_set_hkdf_md(pctx, md) <= 0 || EVP_PKEY_CTX_set1_hkdf_key(pctx, secret, hashlen) <= 0 || EVP_PKEY_CTX_add1_hkdf_info(pctx, hkdflabel, hkdflabellen) <= 0 || EVP_PKEY_derive(pctx, out, &outlen) <= 0; EVP_PKEY_CTX_free(pctx); return ret == 0; }"
5031----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_059049eb868293b44d1fb21a64ff34e03a27278d_1.json----start_frame,"static void start_frame(AVFilterLink *link, AVFilterBufferRef *picref) { ScaleContext *scale = link->dst->priv; AVFilterLink *outlink = link->dst->outputs[0]; AVFilterBufferRef *outpicref; scale->hsub = av_pix_fmt_descriptors[link->format].log2_chroma_w; scale->vsub = av_pix_fmt_descriptors[link->format].log2_chroma_h; outpicref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h); avfilter_copy_buffer_ref_props(outpicref, picref); outlink->out_buf = outpicref; <S2SV_StartVul> av_reduce(&outpicref->pixel_aspect.num, &outpicref->pixel_aspect.den, <S2SV_EndVul> <S2SV_StartVul> (int64_t)picref->pixel_aspect.num * outlink->h * link->w, <S2SV_EndVul> <S2SV_StartVul> (int64_t)picref->pixel_aspect.den * outlink->w * link->h, <S2SV_EndVul> INT_MAX); scale->slice_y = 0; avfilter_start_frame(outlink, avfilter_ref_buffer(outpicref, ~0)); }","- av_reduce(&outpicref->pixel_aspect.num, &outpicref->pixel_aspect.den,
- (int64_t)picref->pixel_aspect.num * outlink->h * link->w,
- (int64_t)picref->pixel_aspect.den * outlink->w * link->h,
+ av_reduce(&outpicref->video->pixel_aspect.num, &outpicref->video->pixel_aspect.den,
+ (int64_t)picref->video->pixel_aspect.num * outlink->h * link->w,
+ (int64_t)picref->video->pixel_aspect.den * outlink->w * link->h,","static void start_frame(AVFilterLink *link, AVFilterBufferRef *picref) { ScaleContext *scale = link->dst->priv; AVFilterLink *outlink = link->dst->outputs[0]; AVFilterBufferRef *outpicref; scale->hsub = av_pix_fmt_descriptors[link->format].log2_chroma_w; scale->vsub = av_pix_fmt_descriptors[link->format].log2_chroma_h; outpicref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h); avfilter_copy_buffer_ref_props(outpicref, picref); outlink->out_buf = outpicref; av_reduce(&outpicref->video->pixel_aspect.num, &outpicref->video->pixel_aspect.den, (int64_t)picref->video->pixel_aspect.num * outlink->h * link->w, (int64_t)picref->video->pixel_aspect.den * outlink->w * link->h, INT_MAX); scale->slice_y = 0; avfilter_start_frame(outlink, avfilter_ref_buffer(outpicref, ~0)); }"
10322----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0210599e776d56fc5e87091ee443f56b5f0d2734_1.json----ctr_XOR,"static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen) { size_t i, n; if (in == NULL || inlen == 0) return; n = inlen < cctx->keylen ? inlen : cctx->keylen; for (i = 0; i < n; i++) cctx->K[i] ^= in[i]; if (inlen <= cctx->keylen) return; n = inlen - cctx->keylen; if (n > 16) { n = 16; } <S2SV_StartVul> for (i = 0; i < 16; i++) <S2SV_EndVul> cctx->V[i] ^= in[i + cctx->keylen]; }","- for (i = 0; i < 16; i++)
+ for (i = 0; i < n; i++)","static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen) { size_t i, n; if (in == NULL || inlen == 0) return; n = inlen < cctx->keylen ? inlen : cctx->keylen; for (i = 0; i < n; i++) cctx->K[i] ^= in[i]; if (inlen <= cctx->keylen) return; n = inlen - cctx->keylen; if (n > 16) { n = 16; } for (i = 0; i < n; i++) cctx->V[i] ^= in[i + cctx->keylen]; }"
4621----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f8bb12758b05c7b93430b2df420ea3239e27d218_1.json----theora_packet,"static int theora_packet(AVFormatContext *s, int idx) { struct ogg *ogg = s->priv_data; struct ogg_stream *os = ogg->streams + idx; int duration; if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) { int seg; duration = 1; for (seg = os->segp; seg < os->nsegs; seg++) { if (os->segments[seg] < 255) duration ++; } os->lastpts = os->lastdts = theora_gptopts(s, idx, os->granule, NULL) - duration; if(s->streams[idx]->start_time == AV_NOPTS_VALUE) { s->streams[idx]->start_time = os->lastpts; <S2SV_StartVul> if (s->streams[idx]->duration) <S2SV_EndVul> s->streams[idx]->duration -= s->streams[idx]->start_time; } } if (os->psize > 0) { os->pduration = 1; } return 0; }","- if (s->streams[idx]->duration)
+ if (s->streams[idx]->duration > 0)","static int theora_packet(AVFormatContext *s, int idx) { struct ogg *ogg = s->priv_data; struct ogg_stream *os = ogg->streams + idx; int duration; if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) { int seg; duration = 1; for (seg = os->segp; seg < os->nsegs; seg++) { if (os->segments[seg] < 255) duration ++; } os->lastpts = os->lastdts = theora_gptopts(s, idx, os->granule, NULL) - duration; if(s->streams[idx]->start_time == AV_NOPTS_VALUE) { s->streams[idx]->start_time = os->lastpts; if (s->streams[idx]->duration > 0) s->streams[idx]->duration -= s->streams[idx]->start_time; } } if (os->psize > 0) { os->pduration = 1; } return 0; }"
13999----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_832ac31b36d068df128575e47ed9e25649039f82_1.json----def_load_bio,"static int def_load_bio(CONF *conf, BIO *in, long *line) { #define CONFBUFSIZE 512 int bufnum=0,i,ii; BUF_MEM *buff=NULL; char *s,*p,*end; int again,n; long eline=0; char btmp[DECIMAL_SIZE(eline)+1]; CONF_VALUE *v=NULL,*tv; CONF_VALUE *sv=NULL; char *section=NULL,*buf; STACK_OF(CONF_VALUE) *section_sk=NULL,*ts; char *start,*psection,*pname; void *h = (void *)(conf->data); if ((buff=BUF_MEM_new()) == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB); goto err; } section=(char *)OPENSSL_malloc(10); if (section == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE); goto err; } <S2SV_StartVul> strcpy(section,""default""); <S2SV_EndVul> if (_CONF_new_data(conf) == 0) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE); goto err; } sv=_CONF_new_section(conf,section); if (sv == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } section_sk=(STACK_OF(CONF_VALUE) *)sv->value; bufnum=0; again=0; for (;;) { if (!BUF_MEM_grow(buff,bufnum+CONFBUFSIZE)) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB); goto err; } p= &(buff->data[bufnum]); *p='\0'; BIO_gets(in, p, CONFBUFSIZE-1); p[CONFBUFSIZE-1]='\0'; ii=i=strlen(p); if (i == 0 && !again) break; again=0; while (i > 0) { if ((p[i-1] != '\r') && (p[i-1] != '\n')) break; else i--; } if (ii && i == ii) again=1; else { p[i]='\0'; eline++; } bufnum+=i; v=NULL; if (bufnum >= 1) { p= &(buff->data[bufnum-1]); if (IS_ESC(conf,p[0]) && ((bufnum <= 1) || !IS_ESC(conf,p[-1]))) { bufnum--; again=1; } } if (again) continue; bufnum=0; buf=buff->data; clear_comments(conf, buf); n=strlen(buf); s=eat_ws(conf, buf); if (IS_EOF(conf,*s)) continue; if (*s == '[') { char *ss; s++; start=eat_ws(conf, s); ss=start; again: end=eat_alpha_numeric(conf, ss); p=eat_ws(conf, end); if (*p != ']') { if (*p != '\0') { ss=p; goto again; } CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_MISSING_CLOSE_SQUARE_BRACKET); goto err; } *end='\0'; if (!str_copy(conf,NULL,&section,start)) goto err; if ((sv=_CONF_get_section(conf,section)) == NULL) sv=_CONF_new_section(conf,section); if (sv == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } section_sk=(STACK_OF(CONF_VALUE) *)sv->value; continue; } else { pname=s; psection=NULL; end=eat_alpha_numeric(conf, s); if ((end[0] == ':') && (end[1] == ':')) { *end='\0'; end+=2; psection=pname; pname=end; end=eat_alpha_numeric(conf, end); } p=eat_ws(conf, end); if (*p != '=') { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN); goto err; } *end='\0'; p++; start=eat_ws(conf, p); while (!IS_EOF(conf,*p)) p++; p--; while ((p != start) && (IS_WS(conf,*p))) p--; p++; *p='\0'; if (!(v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE)))) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } if (psection == NULL) psection=section; v->name=(char *)OPENSSL_malloc(strlen(pname)+1); v->value=NULL; if (v->name == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } <S2SV_StartVul> strcpy(v->name,pname); <S2SV_EndVul> if (!str_copy(conf,psection,&(v->value),start)) goto err; if (strcmp(psection,section) != 0) { if ((tv=_CONF_get_section(conf,psection)) == NULL) tv=_CONF_new_section(conf,psection); if (tv == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } ts=(STACK_OF(CONF_VALUE) *)tv->value; } else { tv=sv; ts=section_sk; } #if 1 if (_CONF_add_string(conf, tv, v) == 0) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } #else v->section=tv->section; if (!sk_CONF_VALUE_push(ts,v)) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } vv=(CONF_VALUE *)lh_insert(conf->data,v); if (vv != NULL) { sk_CONF_VALUE_delete_ptr(ts,vv); OPENSSL_free(vv->name); OPENSSL_free(vv->value); OPENSSL_free(vv); } #endif v=NULL; } } if (buff != NULL) BUF_MEM_free(buff); if (section != NULL) OPENSSL_free(section); return(1); err: if (buff != NULL) BUF_MEM_free(buff); if (section != NULL) OPENSSL_free(section); if (line != NULL) *line=eline; <S2SV_StartVul> sprintf(btmp,""%ld"",eline); <S2SV_EndVul> ERR_add_error_data(2,""line "",btmp); if ((h != conf->data) && (conf->data != NULL)) { CONF_free(conf->data); conf->data=NULL; } if (v != NULL) { if (v->name != NULL) OPENSSL_free(v->name); if (v->value != NULL) OPENSSL_free(v->value); if (v != NULL) OPENSSL_free(v); } return(0); }","- strcpy(section,""default"");
- strcpy(v->name,pname);
- sprintf(btmp,""%ld"",eline);
+ BUF_strlcpy(section,""default"",10);
+ BUF_strlcpy(v->name,pname,strlen(pname)+1);
+ BIO_snprintf(btmp,sizeof btmp,""%ld"",eline);","static int def_load_bio(CONF *conf, BIO *in, long *line) { #define CONFBUFSIZE 512 int bufnum=0,i,ii; BUF_MEM *buff=NULL; char *s,*p,*end; int again,n; long eline=0; char btmp[DECIMAL_SIZE(eline)+1]; CONF_VALUE *v=NULL,*tv; CONF_VALUE *sv=NULL; char *section=NULL,*buf; STACK_OF(CONF_VALUE) *section_sk=NULL,*ts; char *start,*psection,*pname; void *h = (void *)(conf->data); if ((buff=BUF_MEM_new()) == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB); goto err; } section=(char *)OPENSSL_malloc(10); if (section == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE); goto err; } BUF_strlcpy(section,""default"",10); if (_CONF_new_data(conf) == 0) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE); goto err; } sv=_CONF_new_section(conf,section); if (sv == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } section_sk=(STACK_OF(CONF_VALUE) *)sv->value; bufnum=0; again=0; for (;;) { if (!BUF_MEM_grow(buff,bufnum+CONFBUFSIZE)) { CONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB); goto err; } p= &(buff->data[bufnum]); *p='\0'; BIO_gets(in, p, CONFBUFSIZE-1); p[CONFBUFSIZE-1]='\0'; ii=i=strlen(p); if (i == 0 && !again) break; again=0; while (i > 0) { if ((p[i-1] != '\r') && (p[i-1] != '\n')) break; else i--; } if (ii && i == ii) again=1; else { p[i]='\0'; eline++; } bufnum+=i; v=NULL; if (bufnum >= 1) { p= &(buff->data[bufnum-1]); if (IS_ESC(conf,p[0]) && ((bufnum <= 1) || !IS_ESC(conf,p[-1]))) { bufnum--; again=1; } } if (again) continue; bufnum=0; buf=buff->data; clear_comments(conf, buf); n=strlen(buf); s=eat_ws(conf, buf); if (IS_EOF(conf,*s)) continue; if (*s == '[') { char *ss; s++; start=eat_ws(conf, s); ss=start; again: end=eat_alpha_numeric(conf, ss); p=eat_ws(conf, end); if (*p != ']') { if (*p != '\0') { ss=p; goto again; } CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_MISSING_CLOSE_SQUARE_BRACKET); goto err; } *end='\0'; if (!str_copy(conf,NULL,&section,start)) goto err; if ((sv=_CONF_get_section(conf,section)) == NULL) sv=_CONF_new_section(conf,section); if (sv == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } section_sk=(STACK_OF(CONF_VALUE) *)sv->value; continue; } else { pname=s; psection=NULL; end=eat_alpha_numeric(conf, s); if ((end[0] == ':') && (end[1] == ':')) { *end='\0'; end+=2; psection=pname; pname=end; end=eat_alpha_numeric(conf, end); } p=eat_ws(conf, end); if (*p != '=') { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN); goto err; } *end='\0'; p++; start=eat_ws(conf, p); while (!IS_EOF(conf,*p)) p++; p--; while ((p != start) && (IS_WS(conf,*p))) p--; p++; *p='\0'; if (!(v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE)))) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } if (psection == NULL) psection=section; v->name=(char *)OPENSSL_malloc(strlen(pname)+1); v->value=NULL; if (v->name == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } BUF_strlcpy(v->name,pname,strlen(pname)+1); if (!str_copy(conf,psection,&(v->value),start)) goto err; if (strcmp(psection,section) != 0) { if ((tv=_CONF_get_section(conf,psection)) == NULL) tv=_CONF_new_section(conf,psection); if (tv == NULL) { CONFerr(CONF_F_CONF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION); goto err; } ts=(STACK_OF(CONF_VALUE) *)tv->value; } else { tv=sv; ts=section_sk; } #if 1 if (_CONF_add_string(conf, tv, v) == 0) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } #else v->section=tv->section; if (!sk_CONF_VALUE_push(ts,v)) { CONFerr(CONF_F_CONF_LOAD_BIO, ERR_R_MALLOC_FAILURE); goto err; } vv=(CONF_VALUE *)lh_insert(conf->data,v); if (vv != NULL) { sk_CONF_VALUE_delete_ptr(ts,vv); OPENSSL_free(vv->name); OPENSSL_free(vv->value); OPENSSL_free(vv); } #endif v=NULL; } } if (buff != NULL) BUF_MEM_free(buff); if (section != NULL) OPENSSL_free(section); return(1); err: if (buff != NULL) BUF_MEM_free(buff); if (section != NULL) OPENSSL_free(section); if (line != NULL) *line=eline; BIO_snprintf(btmp,sizeof btmp,""%ld"",eline); ERR_add_error_data(2,""line "",btmp); if ((h != conf->data) && (conf->data != NULL)) { CONF_free(conf->data); conf->data=NULL; } if (v != NULL) { if (v->name != NULL) OPENSSL_free(v->name); if (v->value != NULL) OPENSSL_free(v->value); if (v != NULL) OPENSSL_free(v); } return(0); }"
7395----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_913aa142ab7de323cee76a7d4023ee491f942ece_1.json----common_init,"static av_cold void common_init(H264Context *h) { <S2SV_StartVul> MpegEncContext *const s = &h->s; <S2SV_EndVul> <S2SV_StartVul> s->width = s->avctx->width; <S2SV_EndVul> <S2SV_StartVul> s->height = s->avctx->height; <S2SV_EndVul> <S2SV_StartVul> s->codec_id = s->avctx->codec->id; <S2SV_EndVul> ff_h264dsp_init(&h->h264dsp, 8, 1); ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma); ff_h264qpel_init(&h->h264qpel, 8); <S2SV_StartVul> ff_h264_pred_init(&h->hpc, s->codec_id, 8, 1); <S2SV_EndVul> h->dequant_coeff_pps = -1; <S2SV_StartVul> s->unrestricted_mv = 1; <S2SV_EndVul> <S2SV_StartVul> ff_dsputil_init(&s->dsp, s->avctx); <S2SV_EndVul> <S2SV_StartVul> ff_videodsp_init(&s->vdsp, 8); <S2SV_EndVul> memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t)); memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t)); }","- MpegEncContext *const s = &h->s;
- s->width = s->avctx->width;
- s->height = s->avctx->height;
- s->codec_id = s->avctx->codec->id;
- ff_h264_pred_init(&h->hpc, s->codec_id, 8, 1);
- s->unrestricted_mv = 1;
- ff_dsputil_init(&s->dsp, s->avctx);
- ff_videodsp_init(&s->vdsp, 8);
+ h->width = h->avctx->width;
+ h->height = h->avctx->height;
+ h->bit_depth_luma = 8;
+ h->chroma_format_idc = 1;
+ ff_h264_pred_init(&h->hpc, h->avctx->codec_id, 8, 1);
+ ff_dsputil_init(&h->dsp, h->avctx);
+ ff_videodsp_init(&h->vdsp, 8);","static av_cold void common_init(H264Context *h) { h->width = h->avctx->width; h->height = h->avctx->height; h->bit_depth_luma = 8; h->chroma_format_idc = 1; ff_h264dsp_init(&h->h264dsp, 8, 1); ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma); ff_h264qpel_init(&h->h264qpel, 8); ff_h264_pred_init(&h->hpc, h->avctx->codec_id, 8, 1); h->dequant_coeff_pps = -1; ff_dsputil_init(&h->dsp, h->avctx); ff_videodsp_init(&h->vdsp, 8); memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t)); memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t)); }"
486----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b6ed816a2df8cad92a552ad1bdb035a92ab0696_1.json----ir2_decode_plane,"static int ir2_decode_plane(Ir2Context *ctx, int width, int height, uint8_t *dst, int pitch, const uint8_t *table) { int i; int j; int out = 0; if (width & 1) return AVERROR_INVALIDDATA; while (out < width) { int c = ir2_get_code(&ctx->gb); if (c >= 0x80) { c -= 0x7F; if (out + c*2 > width) return AVERROR_INVALIDDATA; for (i = 0; i < c * 2; i++) dst[out++] = 0x80; } else { dst[out++] = table[c * 2]; dst[out++] = table[(c * 2) + 1]; } } dst += pitch; for (j = 1; j < height; j++) { out = 0; if (get_bits_left(&ctx->gb) <= 0) return AVERROR_INVALIDDATA; while (out < width) { int c = ir2_get_code(&ctx->gb); if (c >= 0x80) { c -= 0x7F; if (out + c*2 > width) return AVERROR_INVALIDDATA; for (i = 0; i < c * 2; i++) { dst[out] = dst[out - pitch]; out++; } } else { <S2SV_StartVul> int t = dst[out - pitch] + (table[c * 2] - 128); <S2SV_EndVul> t = av_clip_uint8(t); dst[out] = t; out++; t = dst[out - pitch] + (table[(c * 2) + 1] - 128); t = av_clip_uint8(t); dst[out] = t; out++; } } dst += pitch; } return 0; }","- int t = dst[out - pitch] + (table[c * 2] - 128);
+ if (c <= 0)
+ return AVERROR_INVALIDDATA;
+ int t;
+ if (c <= 0)
+ return AVERROR_INVALIDDATA;
+ t = dst[out - pitch] + (table[c * 2] - 128);","static int ir2_decode_plane(Ir2Context *ctx, int width, int height, uint8_t *dst, int pitch, const uint8_t *table) { int i; int j; int out = 0; if (width & 1) return AVERROR_INVALIDDATA; while (out < width) { int c = ir2_get_code(&ctx->gb); if (c >= 0x80) { c -= 0x7F; if (out + c*2 > width) return AVERROR_INVALIDDATA; for (i = 0; i < c * 2; i++) dst[out++] = 0x80; } else { if (c <= 0) return AVERROR_INVALIDDATA; dst[out++] = table[c * 2]; dst[out++] = table[(c * 2) + 1]; } } dst += pitch; for (j = 1; j < height; j++) { out = 0; if (get_bits_left(&ctx->gb) <= 0) return AVERROR_INVALIDDATA; while (out < width) { int c = ir2_get_code(&ctx->gb); if (c >= 0x80) { c -= 0x7F; if (out + c*2 > width) return AVERROR_INVALIDDATA; for (i = 0; i < c * 2; i++) { dst[out] = dst[out - pitch]; out++; } } else { int t; if (c <= 0) return AVERROR_INVALIDDATA; t = dst[out - pitch] + (table[c * 2] - 128); t = av_clip_uint8(t); dst[out] = t; out++; t = dst[out - pitch] + (table[(c * 2) + 1] - 128); t = av_clip_uint8(t); dst[out] = t; out++; } } dst += pitch; } return 0; }"
5846----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_331fff10f3cc255d28117d2f0d513af06855ac63_1.json----film_read_packet,"static int film_read_packet(AVFormatContext *s, AVPacket *pkt) { FilmDemuxContext *film = s->priv_data; AVIOContext *pb = s->pb; film_sample *sample; int ret = 0; if (film->current_sample >= film->sample_count) return AVERROR(EIO); sample = &film->sample_table[film->current_sample]; avio_seek(pb, sample->sample_offset, SEEK_SET); <S2SV_StartVul> if ((sample->stream == film->video_stream_index) && <S2SV_EndVul> <S2SV_StartVul> (film->video_type == AV_CODEC_ID_CINEPAK)) { <S2SV_EndVul> <S2SV_StartVul> pkt->pos= avio_tell(pb); <S2SV_EndVul> <S2SV_StartVul> if (av_new_packet(pkt, sample->sample_size)) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> <S2SV_StartVul> avio_read(pb, pkt->data, sample->sample_size); <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> ret= av_get_packet(pb, pkt, sample->sample_size); <S2SV_EndVul> <S2SV_StartVul> if (ret != sample->sample_size) <S2SV_EndVul> <S2SV_StartVul> ret = AVERROR(EIO); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> pkt->stream_index = sample->stream; pkt->pts = sample->pts; film->current_sample++; return ret; }","- if ((sample->stream == film->video_stream_index) &&
- (film->video_type == AV_CODEC_ID_CINEPAK)) {
- pkt->pos= avio_tell(pb);
- if (av_new_packet(pkt, sample->sample_size))
- return AVERROR(ENOMEM);
- avio_read(pb, pkt->data, sample->sample_size);
- } else {
- ret= av_get_packet(pb, pkt, sample->sample_size);
- if (ret != sample->sample_size)
- ret = AVERROR(EIO);
- }
+ ret = av_get_packet(pb, pkt, sample->sample_size);
+ if (ret < 0)
+ return ret;","static int film_read_packet(AVFormatContext *s, AVPacket *pkt) { FilmDemuxContext *film = s->priv_data; AVIOContext *pb = s->pb; film_sample *sample; int ret = 0; if (film->current_sample >= film->sample_count) return AVERROR(EIO); sample = &film->sample_table[film->current_sample]; avio_seek(pb, sample->sample_offset, SEEK_SET); ret = av_get_packet(pb, pkt, sample->sample_size); if (ret < 0) return ret; pkt->stream_index = sample->stream; pkt->pts = sample->pts; film->current_sample++; return ret; }"
