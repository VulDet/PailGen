{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_00d5bcf19ac61544540101d65a0659a5f2d49170_1.json----ff_fast_malloc", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_00d5bcf19ac61544540101d65a0659a5f2d49170_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_00d5bcf19ac61544540101d65a0659a5f2d49170_1.json", "function_name": "ff_fast_malloc", "vul_func_code": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void *val;\n\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(17 * min_size / 16 + 32, min_size);\n    av_freep(ptr);\n    val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    memcpy(ptr, &val, sizeof(val));\n    if (!val)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "patch_func_code": "static inline int ff_fast_malloc(void *ptr, unsigned int *size, size_t min_size, int zero_realloc)\n{\n    void *val;\n\n    if (min_size < *size)\n        return 0;\n    min_size = FFMAX(min_size + min_size / 16 + 32, min_size);\n    av_freep(ptr);\n    val = zero_realloc ? av_mallocz(min_size) : av_malloc(min_size);\n    memcpy(ptr, &val, sizeof(val));\n    if (!val)\n        min_size = 0;\n    *size = min_size;\n    return 1;\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 0}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "28----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_01f051b7b0f6bed96361bd551add29db577d0170_1.json----blend_frames_c", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_01f051b7b0f6bed96361bd551add29db577d0170_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_01f051b7b0f6bed96361bd551add29db577d0170_1.json", "function_name": "blend_frames_c", "vul_func_code": "static void blend_frames_c(BLEND_FUNC_PARAMS)\n{\n    int line, pixel;\n    for (line = 0; line < height; line++) {\n        for (pixel = 0; pixel < width; pixel++) {\n            // integer version of (src1 * factor1) + (src2 * factor2) + 0.5\n            // 0.5 is for rounding\n            // 128 is the integer representation of 0.5 << 8\n            dst[pixel] = ((src1[pixel] * factor1) + (src2[pixel] * factor2) + 128) >> 8;\n        }\n        src1 += src1_linesize;\n        src2 += src2_linesize;\n        dst  += dst_linesize;\n    }\n}", "patch_func_code": "static void blend_frames_c(BLEND_FUNC_PARAMS)\n{\n    int line, pixel;\n    for (line = 0; line < height; line++) {\n        for (pixel = 0; pixel < width; pixel++)\n            dst[pixel] = ((src1[pixel] * factor1) + (src2[pixel] * factor2) + half) >> BLEND_FACTOR_DEPTH8;\n        src1 += src1_linesize;\n        src2 += src2_linesize;\n        dst  += dst_linesize;\n    }\n}", "before_change_lines": [5, 9, 10], "raw_before_change_lines": [5, 6, 7, 8, 9, 10], "after_change_lines": [5, 6], "raw_after_change_lines": [5, 6], "bug_lines": [5, 6, 7, 8, 9, 10], "added": [false, false, false, false, false, false], "idx": 1}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "40----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0298aa6f29fec45f1adf1ed30ddda5eb4a5fc5f7_1.json----ass_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0298aa6f29fec45f1adf1ed30ddda5eb4a5fc5f7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0298aa6f29fec45f1adf1ed30ddda5eb4a5fc5f7_1.json", "function_name": "ass_decode_frame", "vul_func_code": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n                            AVPacket *avpkt)\n{\n    const char *ptr = avpkt->data;\n    int len, size = avpkt->size;\n\n    while (size > 0) {\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n        int duration = dialog->end - dialog->start;\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n        if (len < 0)\n            return len;\n        ptr  += len;\n        size -= len;\n    }\n\n    *got_sub_ptr = avpkt->size > 0;\n    return avpkt->size;\n}", "patch_func_code": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n                            AVPacket *avpkt)\n{\n    const char *ptr = avpkt->data;\n    int len, size = avpkt->size;\n\n    while (size > 0) {\n        int duration;\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n        if (!dialog)\n            return AVERROR_INVALIDDATA;\n        duration = dialog->end - dialog->start;\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n        if (len < 0)\n            return len;\n        ptr  += len;\n        size -= len;\n    }\n\n    *got_sub_ptr = avpkt->size > 0;\n    return avpkt->size;\n}", "before_change_lines": [9], "raw_before_change_lines": [9], "after_change_lines": [8, 10, 11, 12], "raw_after_change_lines": [8, 10, 11, 12], "bug_lines": [9], "added": [false], "idx": 2}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "41----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_029c887679414a6a62442e60648b455161af6980_1.json----hl_decode_mb_internal", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_029c887679414a6a62442e60648b455161af6980_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_029c887679414a6a62442e60648b455161af6980_1.json", "function_name": "hl_decode_mb_internal", "vul_func_code": "static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){\n    MpegEncContext * const s = &h->s;\n    const int mb_x= s->mb_x;\n    const int mb_y= s->mb_y;\n    const int mb_xy= h->mb_xy;\n    const int mb_type= s->current_picture.mb_type[mb_xy];\n    uint8_t  *dest_y, *dest_cb, *dest_cr;\n    int linesize, uvlinesize /*dct_offset*/;\n    int i;\n    int *block_offset = &h->block_offset[0];\n    const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass);\n    /* is_h264 should always be true if SVQ3 is disabled. */\n    const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264;\n    void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride);\n\n    dest_y  = s->current_picture.data[0] + (mb_x + mb_y * s->linesize  ) * 16;\n    dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8;\n    dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8;\n\n    s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4);\n    s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2);\n\n    if (!simple && MB_FIELD) {\n        linesize   = h->mb_linesize   = s->linesize * 2;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;\n        block_offset = &h->block_offset[24];\n        if(mb_y&1){ //FIXME move out of this function?\n            dest_y -= s->linesize*15;\n            dest_cb-= s->uvlinesize*7;\n            dest_cr-= s->uvlinesize*7;\n        }\n        if(FRAME_MBAFF) {\n            int list;\n            for(list=0; list<h->list_count; list++){\n                if(!USES_LIST(mb_type, list))\n                    continue;\n                if(IS_16X16(mb_type)){\n                    int8_t *ref = &h->ref_cache[list][scan8[0]];\n                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);\n                }else{\n                    for(i=0; i<16; i+=4){\n                        int ref = h->ref_cache[list][scan8[i]];\n                        if(ref >= 0)\n                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);\n                    }\n                }\n            }\n        }\n    } else {\n        linesize   = h->mb_linesize   = s->linesize;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize;\n//        dct_offset = s->linesize * 16;\n    }\n\n    if (!simple && IS_INTRA_PCM(mb_type)) {\n        for (i=0; i<16; i++) {\n            memcpy(dest_y + i*  linesize, h->mb       + i*8, 16);\n        }\n        for (i=0; i<8; i++) {\n            memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4,  8);\n            memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4,  8);\n        }\n    } else {\n        if(IS_INTRA(mb_type)){\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);\n\n            if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);\n            }\n\n            if(IS_INTRA4x4(mb_type)){\n                if(simple || !s->encoding){\n                    if(IS_8x8DCT(mb_type)){\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels8;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct8_dc_add;\n                            idct_add    = s->dsp.h264_idct8_add;\n                        }\n                        for(i=0; i<16; i+=4){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                const int nnz = h->non_zero_count_cache[ scan8[i] ];\n                                h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,\n                                                            (h->topright_samples_available<<i)&0x4000, linesize);\n                                if(nnz){\n                                    if(nnz == 1 && h->mb[i*16])\n                                        idct_dc_add(ptr, h->mb + i*16, linesize);\n                                    else\n                                        idct_add   (ptr, h->mb + i*16, linesize);\n                                }\n                            }\n                        }\n                    }else{\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels4;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct_dc_add;\n                            idct_add    = s->dsp.h264_idct_add;\n                        }\n                        for(i=0; i<16; i++){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                uint8_t *topright;\n                                int nnz, tr;\n                                if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){\n                                    const int topright_avail= (h->topright_samples_available<<i)&0x8000;\n                                    assert(mb_y || linesize <= block_offset[i]);\n                                    if(!topright_avail){\n                                        tr= ptr[3 - linesize]*0x01010101;\n                                        topright= (uint8_t*) &tr;\n                                    }else\n                                        topright= ptr + 4 - linesize;\n                                }else\n                                    topright= NULL;\n\n                                h->hpc.pred4x4[ dir ](ptr, topright, linesize);\n                                nnz = h->non_zero_count_cache[ scan8[i] ];\n                                if(nnz){\n                                    if(is_h264){\n                                        if(nnz == 1 && h->mb[i*16])\n                                            idct_dc_add(ptr, h->mb + i*16, linesize);\n                                        else\n                                            idct_add   (ptr, h->mb + i*16, linesize);\n                                    }else\n                                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0);\n                                }\n                            }\n                        }\n                    }\n                }\n            }else{\n                h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);\n                if(is_h264){\n                    if(!transform_bypass)\n                        h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);\n                }else\n                    svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);\n            }\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple);\n        }else if(is_h264){\n            hl_motion(h, dest_y, dest_cb, dest_cr,\n                      s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,\n                      s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab,\n                      s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab);\n        }\n\n\n        if(!IS_INTRA4x4(mb_type)){\n            if(is_h264){\n                if(IS_INTRA16x16(mb_type)){\n                    if(transform_bypass){\n                        if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){\n                            h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize);\n                        }else{\n                            for(i=0; i<16; i++){\n                                if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                                    s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                         s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                    }\n                }else if(h->cbp&15){\n                    if(transform_bypass){\n                        const int di = IS_8x8DCT(mb_type) ? 4 : 1;\n                        idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4;\n                        for(i=0; i<16; i+=di){\n                            if(h->non_zero_count_cache[ scan8[i] ]){\n                                idct_add(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                        if(IS_8x8DCT(mb_type)){\n                            s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }else{\n                            s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }\n                    }\n                }\n            }else{\n                for(i=0; i<16; i++){\n                    if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ //FIXME benchmark weird rule, & below\n                        uint8_t * const ptr= dest_y + block_offset[i];\n                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0);\n                    }\n                }\n            }\n        }\n\n        if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){\n            uint8_t *dest[2] = {dest_cb, dest_cr};\n            if(transform_bypass){\n                if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize);\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize);\n                }else{\n                    idct_add = s->dsp.add_pixels4;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }\n            }else{\n                chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]);\n                chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]);\n                if(is_h264){\n                    idct_add = s->dsp.h264_idct_add;\n                    idct_dc_add = s->dsp.h264_idct_dc_add;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                        else if(h->mb[i*16])\n                            idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }else{\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){\n                            uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i];\n                            svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, chroma_qp[s->qscale + 12] - 12, 2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(h->cbp || IS_INTRA(mb_type))\n        s->dsp.clear_blocks(h->mb);\n\n    if(h->deblocking_filter) {\n        backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple);\n        fill_caches(h, mb_type, 1); //FIXME don't fill stuff which isn't used by filter_mb\n        h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]);\n        h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]);\n        if (!simple && FRAME_MBAFF) {\n            filter_mb     (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        } else {\n            filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        }\n    }\n}", "patch_func_code": "static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){\n    MpegEncContext * const s = &h->s;\n    const int mb_x= s->mb_x;\n    const int mb_y= s->mb_y;\n    const int mb_xy= h->mb_xy;\n    const int mb_type= s->current_picture.mb_type[mb_xy];\n    uint8_t  *dest_y, *dest_cb, *dest_cr;\n    int linesize, uvlinesize /*dct_offset*/;\n    int i;\n    int *block_offset = &h->block_offset[0];\n    const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass);\n    /* is_h264 should always be true if SVQ3 is disabled. */\n    const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264;\n    void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride);\n\n    dest_y  = s->current_picture.data[0] + (mb_x + mb_y * s->linesize  ) * 16;\n    dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8;\n    dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8;\n\n    s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4);\n    s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2);\n\n    if (!simple && MB_FIELD) {\n        linesize   = h->mb_linesize   = s->linesize * 2;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;\n        block_offset = &h->block_offset[24];\n        if(mb_y&1){ //FIXME move out of this function?\n            dest_y -= s->linesize*15;\n            dest_cb-= s->uvlinesize*7;\n            dest_cr-= s->uvlinesize*7;\n        }\n        if(FRAME_MBAFF) {\n            int list;\n            for(list=0; list<h->list_count; list++){\n                if(!USES_LIST(mb_type, list))\n                    continue;\n                if(IS_16X16(mb_type)){\n                    int8_t *ref = &h->ref_cache[list][scan8[0]];\n                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);\n                }else{\n                    for(i=0; i<16; i+=4){\n                        int ref = h->ref_cache[list][scan8[i]];\n                        if(ref >= 0)\n                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);\n                    }\n                }\n            }\n        }\n    } else {\n        linesize   = h->mb_linesize   = s->linesize;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize;\n//        dct_offset = s->linesize * 16;\n    }\n\n    if (!simple && IS_INTRA_PCM(mb_type)) {\n        for (i=0; i<16; i++) {\n            memcpy(dest_y + i*  linesize, h->mb       + i*8, 16);\n        }\n        for (i=0; i<8; i++) {\n            memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4,  8);\n            memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4,  8);\n        }\n    } else {\n        if(IS_INTRA(mb_type)){\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);\n\n            if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);\n            }\n\n            if(IS_INTRA4x4(mb_type)){\n                if(simple || !s->encoding){\n                    if(IS_8x8DCT(mb_type)){\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels8;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct8_dc_add;\n                            idct_add    = s->dsp.h264_idct8_add;\n                        }\n                        for(i=0; i<16; i+=4){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                const int nnz = h->non_zero_count_cache[ scan8[i] ];\n                                h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,\n                                                            (h->topright_samples_available<<i)&0x4000, linesize);\n                                if(nnz){\n                                    if(nnz == 1 && h->mb[i*16])\n                                        idct_dc_add(ptr, h->mb + i*16, linesize);\n                                    else\n                                        idct_add   (ptr, h->mb + i*16, linesize);\n                                }\n                            }\n                        }\n                    }else{\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels4;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct_dc_add;\n                            idct_add    = s->dsp.h264_idct_add;\n                        }\n                        for(i=0; i<16; i++){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                uint8_t *topright;\n                                int nnz, tr;\n                                if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){\n                                    const int topright_avail= (h->topright_samples_available<<i)&0x8000;\n                                    assert(mb_y || linesize <= block_offset[i]);\n                                    if(!topright_avail){\n                                        tr= ptr[3 - linesize]*0x01010101;\n                                        topright= (uint8_t*) &tr;\n                                    }else\n                                        topright= ptr + 4 - linesize;\n                                }else\n                                    topright= NULL;\n\n                                h->hpc.pred4x4[ dir ](ptr, topright, linesize);\n                                nnz = h->non_zero_count_cache[ scan8[i] ];\n                                if(nnz){\n                                    if(is_h264){\n                                        if(nnz == 1 && h->mb[i*16])\n                                            idct_dc_add(ptr, h->mb + i*16, linesize);\n                                        else\n                                            idct_add   (ptr, h->mb + i*16, linesize);\n                                    }else\n                                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0);\n                                }\n                            }\n                        }\n                    }\n                }\n            }else{\n                h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);\n                if(is_h264){\n                    if(!transform_bypass)\n                        h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);\n                }else\n                    svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);\n            }\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple);\n        }else if(is_h264){\n            hl_motion(h, dest_y, dest_cb, dest_cr,\n                      s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,\n                      s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab,\n                      s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab);\n        }\n\n\n        if(!IS_INTRA4x4(mb_type)){\n            if(is_h264){\n                if(IS_INTRA16x16(mb_type)){\n                    if(transform_bypass){\n                        if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){\n                            h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize);\n                        }else{\n                            for(i=0; i<16; i++){\n                                if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                                    s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                         s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                    }\n                }else if(h->cbp&15){\n                    if(transform_bypass){\n                        const int di = IS_8x8DCT(mb_type) ? 4 : 1;\n                        idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4;\n                        for(i=0; i<16; i+=di){\n                            if(h->non_zero_count_cache[ scan8[i] ]){\n                                idct_add(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                        if(IS_8x8DCT(mb_type)){\n                            s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }else{\n                            s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }\n                    }\n                }\n            }else{\n                for(i=0; i<16; i++){\n                    if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ //FIXME benchmark weird rule, & below\n                        uint8_t * const ptr= dest_y + block_offset[i];\n                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0);\n                    }\n                }\n            }\n        }\n\n        if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){\n            uint8_t *dest[2] = {dest_cb, dest_cr};\n            if(transform_bypass){\n                if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize);\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize);\n                }else{\n                    idct_add = s->dsp.add_pixels4;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }\n            }else{\n                chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]);\n                chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]);\n                if(is_h264){\n                    idct_add = s->dsp.h264_idct_add;\n                    idct_dc_add = s->dsp.h264_idct_dc_add;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                        else if(h->mb[i*16])\n                            idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }else{\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){\n                            uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i];\n                            svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, chroma_qp[s->qscale + 12] - 12, 2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(h->cbp || IS_INTRA(mb_type))\n        s->dsp.clear_blocks(h->mb);\n\n    if(h->deblocking_filter) {\n        backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple);\n        fill_caches(h, mb_type, 1); //FIXME don't fill stuff which isn't used by filter_mb\n        h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]);\n        h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]);\n        if (!simple && FRAME_MBAFF) {\n            ff_h264_filter_mb     (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        } else {\n            ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        }\n    }\n}", "before_change_lines": [249, 251], "raw_before_change_lines": [249, 251], "after_change_lines": [249, 251], "raw_after_change_lines": [249, 251], "bug_lines": [249, 251], "added": [false, false], "idx": 3}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "49----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03337126d300793f1d2684ee7705327b30237d40_1.json----old_codec47", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_03337126d300793f1d2684ee7705327b30237d40_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03337126d300793f1d2684ee7705327b30237d40_1.json", "function_name": "old_codec47", "vul_func_code": "static int old_codec47(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int i, j, seq, compr, new_rot, tbl_pos, skip;\n    int stride     = ctx->pitch;\n    uint8_t *dst   = ((uint8_t*)ctx->frm0) + left + top * stride;\n    uint8_t *prev1 = (uint8_t*)ctx->frm1;\n    uint8_t *prev2 = (uint8_t*)ctx->frm2;\n    uint32_t decoded_size;\n\n    tbl_pos = bytestream2_tell(&ctx->gb);\n    seq     = bytestream2_get_le16(&ctx->gb);\n    compr   = bytestream2_get_byte(&ctx->gb);\n    new_rot = bytestream2_get_byte(&ctx->gb);\n    skip    = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 9);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 8);\n\n    if (decoded_size > height * stride - left - top * stride) {\n        decoded_size = height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    if (skip & 1)\n        bytestream2_skip(&ctx->gb, 0x8080);\n    if (!seq) {\n        ctx->prev_seq = -1;\n        memset(prev1, 0, ctx->height * stride);\n        memset(prev2, 0, ctx->height * stride);\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        if (bytestream2_get_bytes_left(&ctx->gb) < width * height)\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j++) {\n            bytestream2_get_bufferu(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        break;\n    case 1:\n        if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1))\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j += 2) {\n            for (i = 0; i < width; i += 2) {\n                dst[i] = dst[i + 1] =\n                dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb);\n            }\n            dst += stride * 2;\n        }\n        break;\n    case 2:\n        if (seq == ctx->prev_seq + 1) {\n            for (j = 0; j < height; j += 8) {\n                for (i = 0; i < width; i += 8) {\n                    if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride,\n                                      tbl_pos + 8, 8))\n                        return AVERROR_INVALIDDATA;\n                }\n                dst   += stride * 8;\n                prev1 += stride * 8;\n                prev2 += stride * 8;\n            }\n        }\n        break;\n    case 3:\n        memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height);\n        break;\n    case 4:\n        memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height);\n        break;\n    case 5:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 47 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (seq == ctx->prev_seq + 1)\n        ctx->rotate_code = new_rot;\n    else\n        ctx->rotate_code = 0;\n    ctx->prev_seq = seq;\n\n    return 0;\n}", "patch_func_code": "static int old_codec47(SANMVideoContext *ctx, int top,\n                       int left, int width, int height)\n{\n    int i, j, seq, compr, new_rot, tbl_pos, skip;\n    int stride     = ctx->pitch;\n    uint8_t *dst   = ((uint8_t*)ctx->frm0) + left + top * stride;\n    uint8_t *prev1 = (uint8_t*)ctx->frm1;\n    uint8_t *prev2 = (uint8_t*)ctx->frm2;\n    uint32_t decoded_size;\n\n    tbl_pos = bytestream2_tell(&ctx->gb);\n    seq     = bytestream2_get_le16(&ctx->gb);\n    compr   = bytestream2_get_byte(&ctx->gb);\n    new_rot = bytestream2_get_byte(&ctx->gb);\n    skip    = bytestream2_get_byte(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 9);\n    decoded_size = bytestream2_get_le32(&ctx->gb);\n    bytestream2_skip(&ctx->gb, 8);\n\n    if (decoded_size > ctx->height * stride - left - top * stride) {\n        decoded_size = ctx->height * stride - left - top * stride;\n        av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n    }\n\n    if (skip & 1)\n        bytestream2_skip(&ctx->gb, 0x8080);\n    if (!seq) {\n        ctx->prev_seq = -1;\n        memset(prev1, 0, ctx->height * stride);\n        memset(prev2, 0, ctx->height * stride);\n    }\n    av_dlog(ctx->avctx, \"compression %d\\n\", compr);\n    switch (compr) {\n    case 0:\n        if (bytestream2_get_bytes_left(&ctx->gb) < width * height)\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j++) {\n            bytestream2_get_bufferu(&ctx->gb, dst, width);\n            dst += stride;\n        }\n        break;\n    case 1:\n        if (bytestream2_get_bytes_left(&ctx->gb) < ((width + 1) >> 1) * ((height + 1) >> 1))\n            return AVERROR_INVALIDDATA;\n        for (j = 0; j < height; j += 2) {\n            for (i = 0; i < width; i += 2) {\n                dst[i] = dst[i + 1] =\n                dst[stride + i] = dst[stride + i + 1] = bytestream2_get_byteu(&ctx->gb);\n            }\n            dst += stride * 2;\n        }\n        break;\n    case 2:\n        if (seq == ctx->prev_seq + 1) {\n            for (j = 0; j < height; j += 8) {\n                for (i = 0; i < width; i += 8) {\n                    if (process_block(ctx, dst + i, prev1 + i, prev2 + i, stride,\n                                      tbl_pos + 8, 8))\n                        return AVERROR_INVALIDDATA;\n                }\n                dst   += stride * 8;\n                prev1 += stride * 8;\n                prev2 += stride * 8;\n            }\n        }\n        break;\n    case 3:\n        memcpy(ctx->frm0, ctx->frm2, ctx->pitch * ctx->height);\n        break;\n    case 4:\n        memcpy(ctx->frm0, ctx->frm1, ctx->pitch * ctx->height);\n        break;\n    case 5:\n        if (rle_decode(ctx, dst, decoded_size))\n            return AVERROR_INVALIDDATA;\n        break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"subcodec 47 compression %d not implemented\\n\", compr);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (seq == ctx->prev_seq + 1)\n        ctx->rotate_code = new_rot;\n    else\n        ctx->rotate_code = 0;\n    ctx->prev_seq = seq;\n\n    return 0;\n}", "before_change_lines": [20, 21], "raw_before_change_lines": [20, 21], "after_change_lines": [20, 21], "raw_after_change_lines": [20, 21], "bug_lines": [20, 21], "added": [false, false], "idx": 4}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "59----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03ae18bd120f731321855813a9b52acc20058859_1.json----decode_nal_units", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_03ae18bd120f731321855813a9b52acc20058859_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03ae18bd120f731321855813a9b52acc20058859_1.json", "function_name": "decode_nal_units", "vul_func_code": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)\n{\n    AVCodecContext *const avctx = h->avctx;\n    unsigned context_count = 0;\n    int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts\n    int i, ret = 0;\n\n    h->max_contexts = h->slice_context_count;\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) {\n        h->current_slice = 0;\n        if (!h->first_field)\n            h->cur_pic_ptr = NULL;\n        ff_h264_sei_uninit(&h->sei);\n    }\n\n    ret = ff_h2645_packet_split(&h->pkt, buf, buf_size, avctx, h->is_avc,\n                                h->nal_length_size, avctx->codec_id);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Error splitting the input into NAL units.\\n\");\n        return ret;\n    }\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n        nals_needed = get_last_needed_nal(h);\n\n    for (i = 0; i < h->pkt.nb_nals; i++) {\n        H2645NAL *nal = &h->pkt.nals[i];\n        H264SliceContext *sl = &h->slice_ctx[context_count];\n        int err;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF &&\n            nal->ref_idc == 0 && nal->type != NAL_SEI)\n            continue;\n\nagain:\n        // FIXME these should stop being context-global variables\n        h->nal_ref_idc   = nal->ref_idc;\n        h->nal_unit_type = nal->type;\n\n        err = 0;\n        switch (nal->type) {\n        case NAL_IDR_SLICE:\n            if (nal->type != NAL_IDR_SLICE) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"Invalid mix of idr and non-idr slices\\n\");\n                ret = -1;\n                goto end;\n            }\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n        case NAL_SLICE:\n            sl->gb = nal->gb;\n\n            if ((err = ff_h264_decode_slice_header(h, sl)))\n                break;\n\n            if (h->sei.recovery_point.recovery_frame_cnt >= 0 && h->recovery_frame < 0) {\n                h->recovery_frame = (h->poc.frame_num + h->sei.recovery_point.recovery_frame_cnt) &\n                                    ((1 << h->ps.sps->log2_max_frame_num) - 1);\n            }\n\n            h->cur_pic_ptr->f->key_frame |=\n                (nal->type == NAL_IDR_SLICE) || (h->sei.recovery_point.recovery_frame_cnt >= 0);\n\n            if (nal->type == NAL_IDR_SLICE || h->recovery_frame == h->poc.frame_num) {\n                h->recovery_frame         = -1;\n                h->cur_pic_ptr->recovered = 1;\n            }\n            // If we have an IDR, all frames after it in decoded order are\n            // \"recovered\".\n            if (nal->type == NAL_IDR_SLICE)\n                h->frame_recovered |= FRAME_RECOVERED_IDR;\n            h->cur_pic_ptr->recovered |= !!(h->frame_recovered & FRAME_RECOVERED_IDR);\n\n            if (h->current_slice == 1) {\n                if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS))\n                    decode_postinit(h, i >= nals_needed);\n\n                if (h->avctx->hwaccel &&\n                    (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0)\n                    return ret;\n            }\n\n            if (sl->redundant_pic_count == 0 &&\n                (avctx->skip_frame < AVDISCARD_NONREF || nal->ref_idc) &&\n                (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                 sl->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                (avctx->skip_frame < AVDISCARD_NONKEY ||\n                 h->cur_pic_ptr->f->key_frame) &&\n                avctx->skip_frame < AVDISCARD_ALL) {\n                if (avctx->hwaccel) {\n                    ret = avctx->hwaccel->decode_slice(avctx, nal->raw_data, nal->raw_size);\n                    if (ret < 0)\n                        return ret;\n                } else\n                    context_count++;\n            }\n            break;\n        case NAL_DPA:\n        case NAL_DPB:\n        case NAL_DPC:\n            avpriv_request_sample(avctx, \"data partitioning\");\n            ret = AVERROR(ENOSYS);\n            goto end;\n            break;\n        case NAL_SEI:\n            ret = ff_h264_sei_decode(&h->sei, &nal->gb, &h->ps, avctx);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_SPS:\n            ret = ff_h264_decode_seq_parameter_set(&nal->gb, avctx, &h->ps);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_PPS:\n            ret = ff_h264_decode_picture_parameter_set(&nal->gb, avctx, &h->ps,\n                                                       nal->size_bits);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_AUD:\n        case NAL_END_SEQUENCE:\n        case NAL_END_STREAM:\n        case NAL_FILLER_DATA:\n        case NAL_SPS_EXT:\n        case NAL_AUXILIARY_SLICE:\n            break;\n        case NAL_FF_IGNORE:\n            break;\n        default:\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\",\n                   nal->type, nal->size_bits);\n        }\n\n        if (context_count == h->max_contexts) {\n            ret = ff_h264_execute_decode_slices(h, context_count);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            context_count = 0;\n        }\n\n        if (err < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n            sl->ref_count[0] = sl->ref_count[1] = sl->list_count = 0;\n        } else if (err == 1) {\n            /* Slice could not be decoded in parallel mode, restart. */\n            sl               = &h->slice_ctx[0];\n            goto again;\n        }\n    }\n    if (context_count) {\n        ret = ff_h264_execute_decode_slices(h, context_count);\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n            goto end;\n    }\n\n    ret = 0;\nend:\n    /* clean up */\n    if (h->cur_pic_ptr && !h->droppable) {\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    }\n\n    return (ret < 0) ? ret : buf_size;\n}", "patch_func_code": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size)\n{\n    AVCodecContext *const avctx = h->avctx;\n    unsigned context_count = 0;\n    int nals_needed = 0; ///< number of NALs that need decoding before the next frame thread starts\n    int i, ret = 0;\n\n    h->max_contexts = h->slice_context_count;\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)) {\n        h->current_slice = 0;\n        if (!h->first_field)\n            h->cur_pic_ptr = NULL;\n        ff_h264_sei_uninit(&h->sei);\n    }\n\n    ret = ff_h2645_packet_split(&h->pkt, buf, buf_size, avctx, h->is_avc,\n                                h->nal_length_size, avctx->codec_id);\n    if (ret < 0) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Error splitting the input into NAL units.\\n\");\n        return ret;\n    }\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n        nals_needed = get_last_needed_nal(h);\n\n    for (i = 0; i < h->pkt.nb_nals; i++) {\n        H2645NAL *nal = &h->pkt.nals[i];\n        H264SliceContext *sl = &h->slice_ctx[context_count];\n        int err;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF &&\n            nal->ref_idc == 0 && nal->type != NAL_SEI)\n            continue;\n\n        // FIXME these should stop being context-global variables\n        h->nal_ref_idc   = nal->ref_idc;\n        h->nal_unit_type = nal->type;\n\n        err = 0;\n        switch (nal->type) {\n        case NAL_IDR_SLICE:\n            if (nal->type != NAL_IDR_SLICE) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"Invalid mix of idr and non-idr slices\\n\");\n                ret = -1;\n                goto end;\n            }\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n        case NAL_SLICE:\n            sl->gb = nal->gb;\n\n            if ((err = ff_h264_decode_slice_header(h, sl)))\n                break;\n\n            if (h->sei.recovery_point.recovery_frame_cnt >= 0 && h->recovery_frame < 0) {\n                h->recovery_frame = (h->poc.frame_num + h->sei.recovery_point.recovery_frame_cnt) &\n                                    ((1 << h->ps.sps->log2_max_frame_num) - 1);\n            }\n\n            h->cur_pic_ptr->f->key_frame |=\n                (nal->type == NAL_IDR_SLICE) || (h->sei.recovery_point.recovery_frame_cnt >= 0);\n\n            if (nal->type == NAL_IDR_SLICE || h->recovery_frame == h->poc.frame_num) {\n                h->recovery_frame         = -1;\n                h->cur_pic_ptr->recovered = 1;\n            }\n            // If we have an IDR, all frames after it in decoded order are\n            // \"recovered\".\n            if (nal->type == NAL_IDR_SLICE)\n                h->frame_recovered |= FRAME_RECOVERED_IDR;\n            h->cur_pic_ptr->recovered |= !!(h->frame_recovered & FRAME_RECOVERED_IDR);\n\n            if (h->current_slice == 1) {\n                if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS))\n                    decode_postinit(h, i >= nals_needed);\n\n                if (h->avctx->hwaccel &&\n                    (ret = h->avctx->hwaccel->start_frame(h->avctx, NULL, 0)) < 0)\n                    return ret;\n            }\n\n            if (sl->redundant_pic_count == 0 &&\n                (avctx->skip_frame < AVDISCARD_NONREF || nal->ref_idc) &&\n                (avctx->skip_frame < AVDISCARD_BIDIR  ||\n                 sl->slice_type_nos != AV_PICTURE_TYPE_B) &&\n                (avctx->skip_frame < AVDISCARD_NONKEY ||\n                 h->cur_pic_ptr->f->key_frame) &&\n                avctx->skip_frame < AVDISCARD_ALL) {\n                if (avctx->hwaccel) {\n                    ret = avctx->hwaccel->decode_slice(avctx, nal->raw_data, nal->raw_size);\n                    if (ret < 0)\n                        return ret;\n                } else\n                    context_count++;\n            }\n            break;\n        case NAL_DPA:\n        case NAL_DPB:\n        case NAL_DPC:\n            avpriv_request_sample(avctx, \"data partitioning\");\n            ret = AVERROR(ENOSYS);\n            goto end;\n            break;\n        case NAL_SEI:\n            ret = ff_h264_sei_decode(&h->sei, &nal->gb, &h->ps, avctx);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_SPS:\n            ret = ff_h264_decode_seq_parameter_set(&nal->gb, avctx, &h->ps);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_PPS:\n            ret = ff_h264_decode_picture_parameter_set(&nal->gb, avctx, &h->ps,\n                                                       nal->size_bits);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            break;\n        case NAL_AUD:\n        case NAL_END_SEQUENCE:\n        case NAL_END_STREAM:\n        case NAL_FILLER_DATA:\n        case NAL_SPS_EXT:\n        case NAL_AUXILIARY_SLICE:\n            break;\n        case NAL_FF_IGNORE:\n            break;\n        default:\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\",\n                   nal->type, nal->size_bits);\n        }\n\n        if (context_count == h->max_contexts) {\n            ret = ff_h264_execute_decode_slices(h, context_count);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                goto end;\n            context_count = 0;\n        }\n\n        if (err < 0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n            sl->ref_count[0] = sl->ref_count[1] = sl->list_count = 0;\n        }\n    }\n    if (context_count) {\n        ret = ff_h264_execute_decode_slices(h, context_count);\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n            goto end;\n    }\n\n    ret = 0;\nend:\n    /* clean up */\n    if (h->cur_pic_ptr && !h->droppable) {\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    }\n\n    return (ret < 0) ? ret : buf_size;\n}", "before_change_lines": [36, 146, 148, 149], "raw_before_change_lines": [36, 146, 147, 148, 149], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [36, 146, 147, 148, 149], "added": [false, false, false, false, false], "idx": 5}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "61----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03af53a08437977a98869b09c34e92667684b965_1.json----av_packet_split_side_data", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_03af53a08437977a98869b09c34e92667684b965_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_03af53a08437977a98869b09c34e92667684b965_1.json", "function_name": "av_packet_split_side_data", "vul_func_code": "int av_packet_split_side_data(AVPacket *pkt){\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n        int i;\n        unsigned int size;\n        uint8_t *p;\n\n        av_dup_packet(pkt);\n\n        p = pkt->data + pkt->size - 8 - 5;\n        for (i=1; ; i++){\n            size = AV_RB32(p);\n            if (size>INT_MAX || p - pkt->data <= size)\n                return 0;\n            if (p[4]&128)\n                break;\n            p-= size+5;\n        }\n\n        pkt->side_data = av_malloc(i * sizeof(*pkt->side_data));\n        if (!pkt->side_data)\n            return AVERROR(ENOMEM);\n\n        p= pkt->data + pkt->size - 8 - 5;\n        for (i=0; ; i++){\n            size= AV_RB32(p);\n            av_assert0(size<=INT_MAX && p - pkt->data > size);\n            pkt->side_data[i].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);\n            pkt->side_data[i].size = size;\n            pkt->side_data[i].type = p[4]&127;\n            if (!pkt->side_data[i].data)\n                return AVERROR(ENOMEM);\n            memcpy(pkt->side_data[i].data, p-size, size);\n            pkt->size -= size + 5;\n            if(p[4]&128)\n                break;\n            p-= size+5;\n        }\n        pkt->size -= 8;\n        pkt->side_data_elems = i+1;\n        return 1;\n    }\n    return 0;\n}", "patch_func_code": "int av_packet_split_side_data(AVPacket *pkt){\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n        int i;\n        unsigned int size;\n        uint8_t *p;\n\n        p = pkt->data + pkt->size - 8 - 5;\n        for (i=1; ; i++){\n            size = AV_RB32(p);\n            if (size>INT_MAX || p - pkt->data <= size)\n                return 0;\n            if (p[4]&128)\n                break;\n            p-= size+5;\n        }\n\n        pkt->side_data = av_malloc(i * sizeof(*pkt->side_data));\n        if (!pkt->side_data)\n            return AVERROR(ENOMEM);\n\n        p= pkt->data + pkt->size - 8 - 5;\n        for (i=0; ; i++){\n            size= AV_RB32(p);\n            av_assert0(size<=INT_MAX && p - pkt->data > size);\n            pkt->side_data[i].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);\n            pkt->side_data[i].size = size;\n            pkt->side_data[i].type = p[4]&127;\n            if (!pkt->side_data[i].data)\n                return AVERROR(ENOMEM);\n            memcpy(pkt->side_data[i].data, p-size, size);\n            pkt->size -= size + 5;\n            if(p[4]&128)\n                break;\n            p-= size+5;\n        }\n        pkt->size -= 8;\n        pkt->side_data_elems = i+1;\n        return 1;\n    }\n    return 0;\n}", "before_change_lines": [7], "raw_before_change_lines": [7, 8], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [7, 8], "added": [false, false], "idx": 6}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "97----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_05dce424ef3e9ac8cd853d25c7b38c8840ab6ed6_1.json----mpeg_motion_internal", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_05dce424ef3e9ac8cd853d25c7b38c8840ab6ed6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_05dce424ef3e9ac8cd853d25c7b38c8840ab6ed6_1.json", "function_name": "mpeg_motion_internal", "vul_func_code": "static av_always_inline\nvoid mpeg_motion_internal(MpegEncContext *s,\n                          uint8_t *dest_y,\n                          uint8_t *dest_cb,\n                          uint8_t *dest_cr,\n                          int field_based,\n                          int bottom_field,\n                          int field_select,\n                          uint8_t **ref_picture,\n                          op_pixels_func (*pix_op)[4],\n                          int motion_x,\n                          int motion_y,\n                          int h,\n                          int is_mpeg12,\n                          int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int dxy, uvdxy, mx, my, src_x, src_y,\n        uvsrc_x, uvsrc_y, v_edge_pos;\n    ptrdiff_t uvlinesize, linesize;\n\n#if 0\n    if (s->quarter_sample) {\n        motion_x >>= 1;\n        motion_y >>= 1;\n    }\n#endif\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n    dxy   = ((motion_y & 1) << 1) | (motion_x & 1);\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n    src_y = (mb_y << (4 - field_based)) + (motion_y >> 1);\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n        if ((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based) {\n            mx      = (motion_x >> 1) | (motion_x & 1);\n            my      = motion_y >> 1;\n            uvdxy   = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x * 8 + (mx >> 1);\n            uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1);\n        } else {\n            uvdxy   = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n            uvsrc_x = src_x >> 1;\n            uvsrc_y = src_y >> 1;\n        }\n    // Even chroma mv's are full pel in H261\n    } else if (!is_mpeg12 && s->out_format == FMT_H261) {\n        mx      = motion_x / 4;\n        my      = motion_y / 4;\n        uvdxy   = 0;\n        uvsrc_x = s->mb_x * 8 + mx;\n        uvsrc_y = mb_y * 8 + my;\n    } else {\n        if (s->chroma_y_shift) {\n            mx      = motion_x / 2;\n            my      = motion_y / 2;\n            uvdxy   = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x * 8 + (mx >> 1);\n            uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1);\n        } else {\n            if (s->chroma_x_shift) {\n                // Chroma422\n                mx      = motion_x / 2;\n                uvdxy   = ((motion_y & 1) << 1) | (mx & 1);\n                uvsrc_x = s->mb_x * 8 + (mx >> 1);\n                uvsrc_y = src_y;\n            } else {\n                // Chroma444\n                uvdxy   = dxy;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 16, 0) ||\n        (unsigned)src_y > FFMAX(v_edge_pos - (motion_y & 1) - h, 0)) {\n        if (is_mpeg12 ||\n            s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n            s->codec_id == AV_CODEC_ID_MPEG1VIDEO) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"MPEG motion vector out of boundary (%d %d)\\n\", src_x,\n                   src_y);\n            return;\n        }\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n                                 s->linesize, s->linesize,\n                                 17, 17 + field_based,\n                                 src_x, src_y << field_based,\n                                 s->h_edge_pos, s->v_edge_pos);\n        ptr_y = s->edge_emu_buffer;\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n            s->vdsp.emulated_edge_mc(uvbuf, ptr_cb,\n                                     s->uvlinesize, s->uvlinesize,\n                                     9, 9 + field_based,\n                                     uvsrc_x, uvsrc_y << field_based,\n                                     s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n            s->vdsp.emulated_edge_mc(uvbuf + 16, ptr_cr,\n                                     s->uvlinesize, s->uvlinesize,\n                                     9, 9 + field_based,\n                                     uvsrc_x, uvsrc_y << field_based,\n                                     s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n            ptr_cb = uvbuf;\n            ptr_cr = uvbuf + 16;\n        }\n    }\n\n    /* FIXME use this for field pix too instead of the obnoxious hack which\n     * changes picture.data */\n    if (bottom_field) {\n        dest_y  += s->linesize;\n        dest_cb += s->uvlinesize;\n        dest_cr += s->uvlinesize;\n    }\n\n    if (field_select) {\n        ptr_y  += s->linesize;\n        ptr_cb += s->uvlinesize;\n        ptr_cr += s->uvlinesize;\n    }\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n        pix_op[s->chroma_x_shift][uvdxy]\n            (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n        pix_op[s->chroma_x_shift][uvdxy]\n            (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n    }\n    if (!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n        s->out_format == FMT_H261) {\n        ff_h261_loop_filter(s);\n    }\n}", "patch_func_code": "static av_always_inline\nvoid mpeg_motion_internal(MpegEncContext *s,\n                          uint8_t *dest_y,\n                          uint8_t *dest_cb,\n                          uint8_t *dest_cr,\n                          int field_based,\n                          int bottom_field,\n                          int field_select,\n                          uint8_t **ref_picture,\n                          op_pixels_func (*pix_op)[4],\n                          int motion_x,\n                          int motion_y,\n                          int h,\n                          int is_mpeg12,\n                          int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int dxy, uvdxy, mx, my, src_x, src_y,\n        uvsrc_x, uvsrc_y, v_edge_pos;\n    ptrdiff_t uvlinesize, linesize;\n\n#if 0\n    if (s->quarter_sample) {\n        motion_x >>= 1;\n        motion_y >>= 1;\n    }\n#endif\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n    linesize   = s->current_picture.f->linesize[0] << field_based;\n    uvlinesize = s->current_picture.f->linesize[1] << field_based;\n\n    dxy   = ((motion_y & 1) << 1) | (motion_x & 1);\n    src_x = s->mb_x * 16 + (motion_x >> 1);\n    src_y = (mb_y << (4 - field_based)) + (motion_y >> 1);\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n        if ((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based) {\n            mx      = (motion_x >> 1) | (motion_x & 1);\n            my      = motion_y >> 1;\n            uvdxy   = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x * 8 + (mx >> 1);\n            uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1);\n        } else {\n            uvdxy   = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n            uvsrc_x = src_x >> 1;\n            uvsrc_y = src_y >> 1;\n        }\n    // Even chroma mv's are full pel in H261\n    } else if (!is_mpeg12 && s->out_format == FMT_H261) {\n        mx      = motion_x / 4;\n        my      = motion_y / 4;\n        uvdxy   = 0;\n        uvsrc_x = s->mb_x * 8 + mx;\n        uvsrc_y = mb_y * 8 + my;\n    } else {\n        if (s->chroma_y_shift) {\n            mx      = motion_x / 2;\n            my      = motion_y / 2;\n            uvdxy   = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x * 8 + (mx >> 1);\n            uvsrc_y = (mb_y << (3 - field_based)) + (my >> 1);\n        } else {\n            if (s->chroma_x_shift) {\n                // Chroma422\n                mx      = motion_x / 2;\n                uvdxy   = ((motion_y & 1) << 1) | (mx & 1);\n                uvsrc_x = s->mb_x * 8 + (mx >> 1);\n                uvsrc_y = src_y;\n            } else {\n                // Chroma444\n                uvdxy   = dxy;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 16, 0) ||\n        (unsigned)src_y > FFMAX(v_edge_pos - (motion_y & 1) - h, 0)) {\n        if (is_mpeg12 ||\n            s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n            s->codec_id == AV_CODEC_ID_MPEG1VIDEO) {\n            av_log(s->avctx, AV_LOG_DEBUG,\n                   \"MPEG motion vector out of boundary (%d %d)\\n\", src_x,\n                   src_y);\n            return;\n        }\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y,\n                                 s->linesize, s->linesize,\n                                 17, 17 + field_based,\n                                 src_x, src_y << field_based,\n                                 s->h_edge_pos, s->v_edge_pos);\n        ptr_y = s->edge_emu_buffer;\n        if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n            uint8_t *uvbuf = s->edge_emu_buffer + 18 * s->linesize;\n            s->vdsp.emulated_edge_mc(uvbuf, ptr_cb,\n                                     s->uvlinesize, s->uvlinesize,\n                                     9, 9 + field_based,\n                                     uvsrc_x, uvsrc_y << field_based,\n                                     s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n            s->vdsp.emulated_edge_mc(uvbuf + 16, ptr_cr,\n                                     s->uvlinesize, s->uvlinesize,\n                                     9, 9 + field_based,\n                                     uvsrc_x, uvsrc_y << field_based,\n                                     s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n            ptr_cb = uvbuf;\n            ptr_cr = uvbuf + 16;\n        }\n    }\n\n    /* FIXME use this for field pix too instead of the obnoxious hack which\n     * changes picture.data */\n    if (bottom_field) {\n        dest_y  += s->linesize;\n        dest_cb += s->uvlinesize;\n        dest_cr += s->uvlinesize;\n    }\n\n    if (field_select) {\n        ptr_y  += s->linesize;\n        ptr_cb += s->uvlinesize;\n        ptr_cr += s->uvlinesize;\n    }\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n        pix_op[s->chroma_x_shift][uvdxy]\n            (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n        pix_op[s->chroma_x_shift][uvdxy]\n            (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n    }\n    if (!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n        s->out_format == FMT_H261) {\n        ff_h261_loop_filter(s);\n    }\n}", "before_change_lines": [30, 31], "raw_before_change_lines": [30, 31], "after_change_lines": [30, 31], "raw_after_change_lines": [30, 31], "bug_lines": [30, 31], "added": [false, false], "idx": 7}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "102----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0622d7dc4c79e86847c3d80471e7f4c81bcd7bbd_1.json----flac_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0622d7dc4c79e86847c3d80471e7f4c81bcd7bbd_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0622d7dc4c79e86847c3d80471e7f4c81bcd7bbd_1.json", "function_name": "flac_decode_frame", "vul_func_code": "static int flac_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            const uint8_t *buf, int buf_size)\n{\n    FLACContext *s = avctx->priv_data;\n    int tmp = 0, i, j = 0, input_buf_size = 0;\n    int16_t *samples_16 = data;\n    int32_t *samples_32 = data;\n    int alloc_data_size= *data_size;\n\n    *data_size=0;\n\n    if (s->max_framesize == 0) {\n        s->max_framesize= FFMAX(4, buf_size); // should hopefully be enough for the first header\n        s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n    }\n\n    if (1 && s->max_framesize) { //FIXME truncated\n        if (s->bitstream_size < 4 || AV_RL32(s->bitstream) != MKTAG('f','L','a','C'))\n            buf_size= FFMIN(buf_size, s->max_framesize - FFMIN(s->bitstream_size, s->max_framesize));\n        input_buf_size= buf_size;\n\n        if (s->bitstream_size + buf_size < buf_size || s->bitstream_index + s->bitstream_size + buf_size < s->bitstream_index)\n            return -1;\n\n        if (s->allocated_bitstream_size < s->bitstream_size + buf_size)\n            s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->bitstream_size + buf_size);\n\n        if (s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size) {\n            memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n                    s->bitstream_size);\n            s->bitstream_index=0;\n        }\n        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size],\n               buf, buf_size);\n        buf= &s->bitstream[s->bitstream_index];\n        buf_size += s->bitstream_size;\n        s->bitstream_size= buf_size;\n\n        if (buf_size < s->max_framesize && input_buf_size) {\n            return input_buf_size;\n        }\n    }\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n\n    if (metadata_parse(s))\n        goto end;\n\n    tmp = show_bits(&s->gb, 16);\n    if ((tmp & 0xFFFE) != 0xFFF8) {\n        av_log(s->avctx, AV_LOG_ERROR, \"FRAME HEADER not here\\n\");\n        while (get_bits_count(&s->gb)/8+2 < buf_size && (show_bits(&s->gb, 16) & 0xFFFE) != 0xFFF8)\n            skip_bits(&s->gb, 8);\n        goto end; // we may not have enough bits left to decode a frame, so try next time\n    }\n    skip_bits(&s->gb, 16);\n    if (decode_frame(s, alloc_data_size) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_frame() failed\\n\");\n        s->bitstream_size=0;\n        s->bitstream_index=0;\n        return -1;\n    }\n\n#define DECORRELATE(left, right)\\\n            assert(s->channels == 2);\\\n            for (i = 0; i < s->blocksize; i++) {\\\n                int a= s->decoded[0][i];\\\n                int b= s->decoded[1][i];\\\n                if (s->is32) {\\\n                    *samples_32++ = (left)  << s->sample_shift;\\\n                    *samples_32++ = (right) << s->sample_shift;\\\n                } else {\\\n                    *samples_16++ = (left)  << s->sample_shift;\\\n                    *samples_16++ = (right) << s->sample_shift;\\\n                }\\\n            }\\\n            break;\n\n    switch (s->decorrelation) {\n    case INDEPENDENT:\n        for (j = 0; j < s->blocksize; j++) {\n            for (i = 0; i < s->channels; i++) {\n                if (s->is32)\n                    *samples_32++ = s->decoded[i][j] << s->sample_shift;\n                else\n                    *samples_16++ = s->decoded[i][j] << s->sample_shift;\n            }\n        }\n        break;\n    case LEFT_SIDE:\n        DECORRELATE(a,a-b)\n    case RIGHT_SIDE:\n        DECORRELATE(a+b,b)\n    case MID_SIDE:\n        DECORRELATE( (a-=b>>1) + b, a)\n    }\n\n    *data_size = s->blocksize * s->channels * (s->is32 ? 4 : 2);\n\nend:\n    i= (get_bits_count(&s->gb)+7)/8;\n    if (i > buf_size) {\n        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);\n        s->bitstream_size=0;\n        s->bitstream_index=0;\n        return -1;\n    }\n\n    if (s->bitstream_size) {\n        s->bitstream_index += i;\n        s->bitstream_size  -= i;\n        return input_buf_size;\n    } else\n        return i;\n}", "patch_func_code": "static int flac_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            const uint8_t *buf, int buf_size)\n{\n    FLACContext *s = avctx->priv_data;\n    int tmp = 0, i, j = 0, input_buf_size = 0;\n    int16_t *samples_16 = data;\n    int32_t *samples_32 = data;\n    int alloc_data_size= *data_size;\n\n    *data_size=0;\n\n    if (s->max_framesize == 0) {\n        s->max_framesize= FFMAX(4, buf_size); // should hopefully be enough for the first header\n        s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n    }\n\n    if (1 && s->max_framesize) { //FIXME truncated\n        if (s->bitstream_size < 4 || AV_RL32(s->bitstream) != MKTAG('f','L','a','C'))\n            buf_size= FFMIN(buf_size, s->max_framesize - FFMIN(s->bitstream_size, s->max_framesize));\n        input_buf_size= buf_size;\n\n        if (s->bitstream_size + buf_size < buf_size || s->bitstream_index + s->bitstream_size + buf_size < s->bitstream_index)\n            return -1;\n\n        if (s->allocated_bitstream_size < s->bitstream_size + buf_size)\n            s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->bitstream_size + buf_size);\n\n        if (s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size) {\n            memmove(s->bitstream, &s->bitstream[s->bitstream_index],\n                    s->bitstream_size);\n            s->bitstream_index=0;\n        }\n        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size],\n               buf, buf_size);\n        buf= &s->bitstream[s->bitstream_index];\n        buf_size += s->bitstream_size;\n        s->bitstream_size= buf_size;\n\n        if (buf_size < s->max_framesize && input_buf_size) {\n            return input_buf_size;\n        }\n    }\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n\n    /* check for inline header */\n    if (show_bits_long(&s->gb, 32) == MKBETAG('f','L','a','C')) {\n        if (metadata_parse(s)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid header\\n\");\n            return -1;\n        }\n        goto end;\n    }\n\n    tmp = show_bits(&s->gb, 16);\n    if ((tmp & 0xFFFE) != 0xFFF8) {\n        av_log(s->avctx, AV_LOG_ERROR, \"FRAME HEADER not here\\n\");\n        while (get_bits_count(&s->gb)/8+2 < buf_size && (show_bits(&s->gb, 16) & 0xFFFE) != 0xFFF8)\n            skip_bits(&s->gb, 8);\n        goto end; // we may not have enough bits left to decode a frame, so try next time\n    }\n    skip_bits(&s->gb, 16);\n    if (decode_frame(s, alloc_data_size) < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"decode_frame() failed\\n\");\n        s->bitstream_size=0;\n        s->bitstream_index=0;\n        return -1;\n    }\n\n#define DECORRELATE(left, right)\\\n            assert(s->channels == 2);\\\n            for (i = 0; i < s->blocksize; i++) {\\\n                int a= s->decoded[0][i];\\\n                int b= s->decoded[1][i];\\\n                if (s->is32) {\\\n                    *samples_32++ = (left)  << s->sample_shift;\\\n                    *samples_32++ = (right) << s->sample_shift;\\\n                } else {\\\n                    *samples_16++ = (left)  << s->sample_shift;\\\n                    *samples_16++ = (right) << s->sample_shift;\\\n                }\\\n            }\\\n            break;\n\n    switch (s->decorrelation) {\n    case INDEPENDENT:\n        for (j = 0; j < s->blocksize; j++) {\n            for (i = 0; i < s->channels; i++) {\n                if (s->is32)\n                    *samples_32++ = s->decoded[i][j] << s->sample_shift;\n                else\n                    *samples_16++ = s->decoded[i][j] << s->sample_shift;\n            }\n        }\n        break;\n    case LEFT_SIDE:\n        DECORRELATE(a,a-b)\n    case RIGHT_SIDE:\n        DECORRELATE(a+b,b)\n    case MID_SIDE:\n        DECORRELATE( (a-=b>>1) + b, a)\n    }\n\n    *data_size = s->blocksize * s->channels * (s->is32 ? 4 : 2);\n\nend:\n    i= (get_bits_count(&s->gb)+7)/8;\n    if (i > buf_size) {\n        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);\n        s->bitstream_size=0;\n        s->bitstream_index=0;\n        return -1;\n    }\n\n    if (s->bitstream_size) {\n        s->bitstream_index += i;\n        s->bitstream_size  -= i;\n        return input_buf_size;\n    } else\n        return i;\n}", "before_change_lines": [47], "raw_before_change_lines": [47], "after_change_lines": [48, 49, 50, 51, 52, 54], "raw_after_change_lines": [47, 48, 49, 50, 51, 52, 54], "bug_lines": [47], "added": [false], "idx": 8}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "117----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_06ff29e9bc5c67316880f0c68f7c5bbacfc3e348_1.json----cinepak_decode_vectors", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_06ff29e9bc5c67316880f0c68f7c5bbacfc3e348_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_06ff29e9bc5c67316880f0c68f7c5bbacfc3e348_1.json", "function_name": "cinepak_decode_vectors", "vul_func_code": "static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n                                   int chunk_id, int size, const uint8_t *data)\n{\n    const uint8_t   *eod = (data + size);\n    uint32_t         flag, mask;\n    uint8_t         *cb0, *cb1, *cb2, *cb3;\n    unsigned int     x, y;\n    char            *ip0, *ip1, *ip2, *ip3;\n\n    flag = 0;\n    mask = 0;\n\n    for (y=strip->y1; y < strip->y2; y+=4) {\n\n/* take care of y dimension not being multiple of 4, such streams exist */\n        ip0 = ip1 = ip2 = ip3 = s->frame->data[0] +\n          (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]);\n        if(s->avctx->height - y > 1) {\n            ip1 = ip0 + s->frame->linesize[0];\n            if(s->avctx->height - y > 2) {\n                ip2 = ip1 + s->frame->linesize[0];\n                if(s->avctx->height - y > 3) {\n                    ip3 = ip2 + s->frame->linesize[0];\n                }\n            }\n        }\n/* to get the correct picture for not-multiple-of-4 cases let us fill\n * each block from the bottom up, thus possibly overwriting the top line\n * more than once but ending with the correct data in place\n * (instead of in-loop checking) */\n\n        for (x=strip->x1; x < strip->x2; x+=4) {\n            if ((chunk_id & 0x01) && !(mask >>= 1)) {\n                if ((data + 4) > eod)\n                    return AVERROR_INVALIDDATA;\n\n                flag  = AV_RB32 (data);\n                data += 4;\n                mask  = 0x80000000;\n            }\n\n            if (!(chunk_id & 0x01) || (flag & mask)) {\n                if (!(chunk_id & 0x02) && !(mask >>= 1)) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    flag  = AV_RB32 (data);\n                    data += 4;\n                    mask  = 0x80000000;\n                }\n\n                if ((chunk_id & 0x02) || (~flag & mask)) {\n                    uint8_t *p;\n                    if (data >= eod)\n                        return AVERROR_INVALIDDATA;\n\n                    p = strip->v1_codebook[*data++];\n                    if (s->palette_video) {\n                        ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n                        ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n                        ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n                        ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n                    } else {\n                        p += 6;\n                        memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n                        memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n                        p += 3; /* ... + 9 */\n                        memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n                        memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n                        p -= 9; /* ... + 0 */\n                        memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n                        memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n                        p += 3; /* ... + 3 */\n                        memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n                        memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n                    }\n\n                } else if (flag & mask) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    cb0 = strip->v4_codebook[*data++];\n                    cb1 = strip->v4_codebook[*data++];\n                    cb2 = strip->v4_codebook[*data++];\n                    cb3 = strip->v4_codebook[*data++];\n                    if (s->palette_video) {\n                        uint8_t *p;\n                        p = ip3;\n                        *p++ = cb2[6];\n                        *p++ = cb2[9];\n                        *p++ = cb3[6];\n                        *p   = cb3[9];\n                        p = ip2;\n                        *p++ = cb2[0];\n                        *p++ = cb2[3];\n                        *p++ = cb3[0];\n                        *p   = cb3[3];\n                        p = ip1;\n                        *p++ = cb0[6];\n                        *p++ = cb0[9];\n                        *p++ = cb1[6];\n                        *p   = cb1[9];\n                        p = ip0;\n                        *p++ = cb0[0];\n                        *p++ = cb0[3];\n                        *p++ = cb1[0];\n                        *p   = cb1[3];\n                    } else {\n                        memcpy(ip3 + 0, cb2 + 6, 6);\n                        memcpy(ip3 + 6, cb3 + 6, 6);\n                        memcpy(ip2 + 0, cb2 + 0, 6);\n                        memcpy(ip2 + 6, cb3 + 0, 6);\n                        memcpy(ip1 + 0, cb0 + 6, 6);\n                        memcpy(ip1 + 6, cb1 + 6, 6);\n                        memcpy(ip0 + 0, cb0 + 0, 6);\n                        memcpy(ip0 + 6, cb1 + 0, 6);\n                    }\n\n                }\n            }\n\n            if (s->palette_video) {\n                ip0 += 4;  ip1 += 4;\n                ip2 += 4;  ip3 += 4;\n            } else {\n                ip0 += 12;  ip1 += 12;\n                ip2 += 12;  ip3 += 12;\n            }\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n                                   int chunk_id, int size, const uint8_t *data)\n{\n    const uint8_t   *eod = (data + size);\n    uint32_t         flag, mask;\n    uint8_t         *cb0, *cb1, *cb2, *cb3;\n    int             x, y;\n    char            *ip0, *ip1, *ip2, *ip3;\n\n    flag = 0;\n    mask = 0;\n\n    for (y=strip->y1; y < strip->y2; y+=4) {\n\n/* take care of y dimension not being multiple of 4, such streams exist */\n        ip0 = ip1 = ip2 = ip3 = s->frame->data[0] +\n          (s->palette_video?strip->x1:strip->x1*3) + (y * s->frame->linesize[0]);\n        if(s->avctx->height - y > 1) {\n            ip1 = ip0 + s->frame->linesize[0];\n            if(s->avctx->height - y > 2) {\n                ip2 = ip1 + s->frame->linesize[0];\n                if(s->avctx->height - y > 3) {\n                    ip3 = ip2 + s->frame->linesize[0];\n                }\n            }\n        }\n/* to get the correct picture for not-multiple-of-4 cases let us fill\n * each block from the bottom up, thus possibly overwriting the top line\n * more than once but ending with the correct data in place\n * (instead of in-loop checking) */\n\n        for (x=strip->x1; x < strip->x2; x+=4) {\n            if ((chunk_id & 0x01) && !(mask >>= 1)) {\n                if ((data + 4) > eod)\n                    return AVERROR_INVALIDDATA;\n\n                flag  = AV_RB32 (data);\n                data += 4;\n                mask  = 0x80000000;\n            }\n\n            if (!(chunk_id & 0x01) || (flag & mask)) {\n                if (!(chunk_id & 0x02) && !(mask >>= 1)) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    flag  = AV_RB32 (data);\n                    data += 4;\n                    mask  = 0x80000000;\n                }\n\n                if ((chunk_id & 0x02) || (~flag & mask)) {\n                    uint8_t *p;\n                    if (data >= eod)\n                        return AVERROR_INVALIDDATA;\n\n                    p = strip->v1_codebook[*data++];\n                    if (s->palette_video) {\n                        ip3[0] = ip3[1] = ip2[0] = ip2[1] = p[6];\n                        ip3[2] = ip3[3] = ip2[2] = ip2[3] = p[9];\n                        ip1[0] = ip1[1] = ip0[0] = ip0[1] = p[0];\n                        ip1[2] = ip1[3] = ip0[2] = ip0[3] = p[3];\n                    } else {\n                        p += 6;\n                        memcpy(ip3 + 0, p, 3); memcpy(ip3 + 3, p, 3);\n                        memcpy(ip2 + 0, p, 3); memcpy(ip2 + 3, p, 3);\n                        p += 3; /* ... + 9 */\n                        memcpy(ip3 + 6, p, 3); memcpy(ip3 + 9, p, 3);\n                        memcpy(ip2 + 6, p, 3); memcpy(ip2 + 9, p, 3);\n                        p -= 9; /* ... + 0 */\n                        memcpy(ip1 + 0, p, 3); memcpy(ip1 + 3, p, 3);\n                        memcpy(ip0 + 0, p, 3); memcpy(ip0 + 3, p, 3);\n                        p += 3; /* ... + 3 */\n                        memcpy(ip1 + 6, p, 3); memcpy(ip1 + 9, p, 3);\n                        memcpy(ip0 + 6, p, 3); memcpy(ip0 + 9, p, 3);\n                    }\n\n                } else if (flag & mask) {\n                    if ((data + 4) > eod)\n                        return AVERROR_INVALIDDATA;\n\n                    cb0 = strip->v4_codebook[*data++];\n                    cb1 = strip->v4_codebook[*data++];\n                    cb2 = strip->v4_codebook[*data++];\n                    cb3 = strip->v4_codebook[*data++];\n                    if (s->palette_video) {\n                        uint8_t *p;\n                        p = ip3;\n                        *p++ = cb2[6];\n                        *p++ = cb2[9];\n                        *p++ = cb3[6];\n                        *p   = cb3[9];\n                        p = ip2;\n                        *p++ = cb2[0];\n                        *p++ = cb2[3];\n                        *p++ = cb3[0];\n                        *p   = cb3[3];\n                        p = ip1;\n                        *p++ = cb0[6];\n                        *p++ = cb0[9];\n                        *p++ = cb1[6];\n                        *p   = cb1[9];\n                        p = ip0;\n                        *p++ = cb0[0];\n                        *p++ = cb0[3];\n                        *p++ = cb1[0];\n                        *p   = cb1[3];\n                    } else {\n                        memcpy(ip3 + 0, cb2 + 6, 6);\n                        memcpy(ip3 + 6, cb3 + 6, 6);\n                        memcpy(ip2 + 0, cb2 + 0, 6);\n                        memcpy(ip2 + 6, cb3 + 0, 6);\n                        memcpy(ip1 + 0, cb0 + 6, 6);\n                        memcpy(ip1 + 6, cb1 + 6, 6);\n                        memcpy(ip0 + 0, cb0 + 0, 6);\n                        memcpy(ip0 + 6, cb1 + 0, 6);\n                    }\n\n                }\n            }\n\n            if (s->palette_video) {\n                ip0 += 4;  ip1 += 4;\n                ip2 += 4;  ip3 += 4;\n            } else {\n                ip0 += 12;  ip1 += 12;\n                ip2 += 12;  ip3 += 12;\n            }\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 9}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "131----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_081bf85e2aa98cf6d20cd64b16e8b853c2da63ef_1.json----hl_decode_mb_internal", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_081bf85e2aa98cf6d20cd64b16e8b853c2da63ef_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_081bf85e2aa98cf6d20cd64b16e8b853c2da63ef_1.json", "function_name": "hl_decode_mb_internal", "vul_func_code": "static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){\n    MpegEncContext * const s = &h->s;\n    const int mb_x= s->mb_x;\n    const int mb_y= s->mb_y;\n    const int mb_xy= h->mb_xy;\n    const int mb_type= s->current_picture.mb_type[mb_xy];\n    uint8_t  *dest_y, *dest_cb, *dest_cr;\n    int linesize, uvlinesize /*dct_offset*/;\n    int i;\n    int *block_offset = &h->block_offset[0];\n    const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass);\n    /* is_h264 should always be true if SVQ3 is disabled. */\n    const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264;\n    void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride);\n\n    dest_y  = s->current_picture.data[0] + (mb_x + mb_y * s->linesize  ) * 16;\n    dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8;\n    dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8;\n\n    s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4);\n    s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2);\n\n    if (!simple && MB_FIELD) {\n        linesize   = h->mb_linesize   = s->linesize * 2;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;\n        block_offset = &h->block_offset[24];\n        if(mb_y&1){ //FIXME move out of this function?\n            dest_y -= s->linesize*15;\n            dest_cb-= s->uvlinesize*7;\n            dest_cr-= s->uvlinesize*7;\n        }\n        if(FRAME_MBAFF) {\n            int list;\n            for(list=0; list<h->list_count; list++){\n                if(!USES_LIST(mb_type, list))\n                    continue;\n                if(IS_16X16(mb_type)){\n                    int8_t *ref = &h->ref_cache[list][scan8[0]];\n                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);\n                }else{\n                    for(i=0; i<16; i+=4){\n                        int ref = h->ref_cache[list][scan8[i]];\n                        if(ref >= 0)\n                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);\n                    }\n                }\n            }\n        }\n    } else {\n        linesize   = h->mb_linesize   = s->linesize;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize;\n//        dct_offset = s->linesize * 16;\n    }\n\n    if (!simple && IS_INTRA_PCM(mb_type)) {\n        for (i=0; i<16; i++) {\n            memcpy(dest_y + i*  linesize, h->mb       + i*8, 16);\n        }\n        for (i=0; i<8; i++) {\n            memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4,  8);\n            memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4,  8);\n        }\n    } else {\n        if(IS_INTRA(mb_type)){\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);\n\n            if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);\n            }\n\n            if(IS_INTRA4x4(mb_type)){\n                if(simple || !s->encoding){\n                    if(IS_8x8DCT(mb_type)){\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels8;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct8_dc_add;\n                            idct_add    = s->dsp.h264_idct8_add;\n                        }\n                        for(i=0; i<16; i+=4){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                const int nnz = h->non_zero_count_cache[ scan8[i] ];\n                                h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,\n                                                            (h->topright_samples_available<<i)&0x4000, linesize);\n                                if(nnz){\n                                    if(nnz == 1 && h->mb[i*16])\n                                        idct_dc_add(ptr, h->mb + i*16, linesize);\n                                    else\n                                        idct_add   (ptr, h->mb + i*16, linesize);\n                                }\n                            }\n                        }\n                    }else{\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels4;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct_dc_add;\n                            idct_add    = s->dsp.h264_idct_add;\n                        }\n                        for(i=0; i<16; i++){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                uint8_t *topright;\n                                int nnz, tr;\n                                if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){\n                                    const int topright_avail= (h->topright_samples_available<<i)&0x8000;\n                                    assert(mb_y || linesize <= block_offset[i]);\n                                    if(!topright_avail){\n                                        tr= ptr[3 - linesize]*0x01010101;\n                                        topright= (uint8_t*) &tr;\n                                    }else\n                                        topright= ptr + 4 - linesize;\n                                }else\n                                    topright= NULL;\n\n                                h->hpc.pred4x4[ dir ](ptr, topright, linesize);\n                                nnz = h->non_zero_count_cache[ scan8[i] ];\n                                if(nnz){\n                                    if(is_h264){\n                                        if(nnz == 1 && h->mb[i*16])\n                                            idct_dc_add(ptr, h->mb + i*16, linesize);\n                                        else\n                                            idct_add   (ptr, h->mb + i*16, linesize);\n                                    }else\n                                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0);\n                                }\n                            }\n                        }\n                    }\n                }\n            }else{\n                h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);\n                if(is_h264){\n                    if(!transform_bypass)\n                        h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);\n                }else\n                    svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);\n            }\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple);\n        }else if(is_h264){\n            hl_motion(h, dest_y, dest_cb, dest_cr,\n                      s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,\n                      s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab,\n                      s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab);\n        }\n\n\n        if(!IS_INTRA4x4(mb_type)){\n            if(is_h264){\n                if(IS_INTRA16x16(mb_type)){\n                    if(transform_bypass){\n                        if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){\n                            h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize);\n                        }else{\n                            for(i=0; i<16; i++){\n                                if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                                    s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                         s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                    }\n                }else if(h->cbp&15){\n                    if(transform_bypass){\n                        const int di = IS_8x8DCT(mb_type) ? 4 : 1;\n                        idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4;\n                        for(i=0; i<16; i+=di){\n                            if(h->non_zero_count_cache[ scan8[i] ]){\n                                idct_add(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                        if(IS_8x8DCT(mb_type)){\n                            s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }else{\n                            s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }\n                    }\n                }\n            }else{\n                for(i=0; i<16; i++){\n                    if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ //FIXME benchmark weird rule, & below\n                        uint8_t * const ptr= dest_y + block_offset[i];\n                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0);\n                    }\n                }\n            }\n        }\n\n        if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){\n            uint8_t *dest[2] = {dest_cb, dest_cr};\n            if(transform_bypass){\n                if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize);\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize);\n                }else{\n                    idct_add = s->dsp.add_pixels4;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }\n            }else{\n                chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]);\n                chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]);\n                if(is_h264){\n                    idct_add = s->dsp.h264_idct_add;\n                    idct_dc_add = s->dsp.h264_idct_dc_add;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                        else if(h->mb[i*16])\n                            idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }else{\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){\n                            uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i];\n                            svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, ff_h264_chroma_qp[s->qscale + 12] - 12, 2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(h->cbp || IS_INTRA(mb_type))\n        s->dsp.clear_blocks(h->mb);\n\n    if(h->deblocking_filter) {\n        backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple);\n        fill_caches(h, mb_type, 1); //FIXME don't fill stuff which isn't used by filter_mb\n        h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]);\n        h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]);\n        if (!simple && FRAME_MBAFF) {\n            ff_h264_filter_mb     (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        } else {\n            ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        }\n    }\n}", "patch_func_code": "static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){\n    MpegEncContext * const s = &h->s;\n    const int mb_x= s->mb_x;\n    const int mb_y= s->mb_y;\n    const int mb_xy= h->mb_xy;\n    const int mb_type= s->current_picture.mb_type[mb_xy];\n    uint8_t  *dest_y, *dest_cb, *dest_cr;\n    int linesize, uvlinesize /*dct_offset*/;\n    int i;\n    int *block_offset = &h->block_offset[0];\n    const int transform_bypass = !simple && (s->qscale == 0 && h->sps.transform_bypass);\n    /* is_h264 should always be true if SVQ3 is disabled. */\n    const int is_h264 = !CONFIG_SVQ3_DECODER || simple || s->codec_id == CODEC_ID_H264;\n    void (*idct_add)(uint8_t *dst, DCTELEM *block, int stride);\n    void (*idct_dc_add)(uint8_t *dst, DCTELEM *block, int stride);\n\n    dest_y  = s->current_picture.data[0] + (mb_x + mb_y * s->linesize  ) * 16;\n    dest_cb = s->current_picture.data[1] + (mb_x + mb_y * s->uvlinesize) * 8;\n    dest_cr = s->current_picture.data[2] + (mb_x + mb_y * s->uvlinesize) * 8;\n\n    s->dsp.prefetch(dest_y + (s->mb_x&3)*4*s->linesize + 64, s->linesize, 4);\n    s->dsp.prefetch(dest_cb + (s->mb_x&7)*s->uvlinesize + 64, dest_cr - dest_cb, 2);\n\n    h->list_counts[mb_xy]= h->list_count;\n\n    if (!simple && MB_FIELD) {\n        linesize   = h->mb_linesize   = s->linesize * 2;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize * 2;\n        block_offset = &h->block_offset[24];\n        if(mb_y&1){ //FIXME move out of this function?\n            dest_y -= s->linesize*15;\n            dest_cb-= s->uvlinesize*7;\n            dest_cr-= s->uvlinesize*7;\n        }\n        if(FRAME_MBAFF) {\n            int list;\n            for(list=0; list<h->list_count; list++){\n                if(!USES_LIST(mb_type, list))\n                    continue;\n                if(IS_16X16(mb_type)){\n                    int8_t *ref = &h->ref_cache[list][scan8[0]];\n                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);\n                }else{\n                    for(i=0; i<16; i+=4){\n                        int ref = h->ref_cache[list][scan8[i]];\n                        if(ref >= 0)\n                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);\n                    }\n                }\n            }\n        }\n    } else {\n        linesize   = h->mb_linesize   = s->linesize;\n        uvlinesize = h->mb_uvlinesize = s->uvlinesize;\n//        dct_offset = s->linesize * 16;\n    }\n\n    if (!simple && IS_INTRA_PCM(mb_type)) {\n        for (i=0; i<16; i++) {\n            memcpy(dest_y + i*  linesize, h->mb       + i*8, 16);\n        }\n        for (i=0; i<8; i++) {\n            memcpy(dest_cb+ i*uvlinesize, h->mb + 128 + i*4,  8);\n            memcpy(dest_cr+ i*uvlinesize, h->mb + 160 + i*4,  8);\n        }\n    } else {\n        if(IS_INTRA(mb_type)){\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);\n\n            if(simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);\n                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);\n            }\n\n            if(IS_INTRA4x4(mb_type)){\n                if(simple || !s->encoding){\n                    if(IS_8x8DCT(mb_type)){\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels8;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct8_dc_add;\n                            idct_add    = s->dsp.h264_idct8_add;\n                        }\n                        for(i=0; i<16; i+=4){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred8x8l_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                const int nnz = h->non_zero_count_cache[ scan8[i] ];\n                                h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,\n                                                            (h->topright_samples_available<<i)&0x4000, linesize);\n                                if(nnz){\n                                    if(nnz == 1 && h->mb[i*16])\n                                        idct_dc_add(ptr, h->mb + i*16, linesize);\n                                    else\n                                        idct_add   (ptr, h->mb + i*16, linesize);\n                                }\n                            }\n                        }\n                    }else{\n                        if(transform_bypass){\n                            idct_dc_add =\n                            idct_add    = s->dsp.add_pixels4;\n                        }else{\n                            idct_dc_add = s->dsp.h264_idct_dc_add;\n                            idct_add    = s->dsp.h264_idct_add;\n                        }\n                        for(i=0; i<16; i++){\n                            uint8_t * const ptr= dest_y + block_offset[i];\n                            const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];\n\n                            if(transform_bypass && h->sps.profile_idc==244 && dir<=1){\n                                h->hpc.pred4x4_add[dir](ptr, h->mb + i*16, linesize);\n                            }else{\n                                uint8_t *topright;\n                                int nnz, tr;\n                                if(dir == DIAG_DOWN_LEFT_PRED || dir == VERT_LEFT_PRED){\n                                    const int topright_avail= (h->topright_samples_available<<i)&0x8000;\n                                    assert(mb_y || linesize <= block_offset[i]);\n                                    if(!topright_avail){\n                                        tr= ptr[3 - linesize]*0x01010101;\n                                        topright= (uint8_t*) &tr;\n                                    }else\n                                        topright= ptr + 4 - linesize;\n                                }else\n                                    topright= NULL;\n\n                                h->hpc.pred4x4[ dir ](ptr, topright, linesize);\n                                nnz = h->non_zero_count_cache[ scan8[i] ];\n                                if(nnz){\n                                    if(is_h264){\n                                        if(nnz == 1 && h->mb[i*16])\n                                            idct_dc_add(ptr, h->mb + i*16, linesize);\n                                        else\n                                            idct_add   (ptr, h->mb + i*16, linesize);\n                                    }else\n                                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, 0);\n                                }\n                            }\n                        }\n                    }\n                }\n            }else{\n                h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);\n                if(is_h264){\n                    if(!transform_bypass)\n                        h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);\n                }else\n                    svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);\n            }\n            if(h->deblocking_filter)\n                xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 0, simple);\n        }else if(is_h264){\n            hl_motion(h, dest_y, dest_cb, dest_cr,\n                      s->me.qpel_put, s->dsp.put_h264_chroma_pixels_tab,\n                      s->me.qpel_avg, s->dsp.avg_h264_chroma_pixels_tab,\n                      s->dsp.weight_h264_pixels_tab, s->dsp.biweight_h264_pixels_tab);\n        }\n\n\n        if(!IS_INTRA4x4(mb_type)){\n            if(is_h264){\n                if(IS_INTRA16x16(mb_type)){\n                    if(transform_bypass){\n                        if(h->sps.profile_idc==244 && (h->intra16x16_pred_mode==VERT_PRED8x8 || h->intra16x16_pred_mode==HOR_PRED8x8)){\n                            h->hpc.pred16x16_add[h->intra16x16_pred_mode](dest_y, block_offset, h->mb, linesize);\n                        }else{\n                            for(i=0; i<16; i++){\n                                if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                                    s->dsp.add_pixels4(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                         s->dsp.h264_idct_add16intra(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                    }\n                }else if(h->cbp&15){\n                    if(transform_bypass){\n                        const int di = IS_8x8DCT(mb_type) ? 4 : 1;\n                        idct_add= IS_8x8DCT(mb_type) ? s->dsp.add_pixels8 : s->dsp.add_pixels4;\n                        for(i=0; i<16; i+=di){\n                            if(h->non_zero_count_cache[ scan8[i] ]){\n                                idct_add(dest_y + block_offset[i], h->mb + i*16, linesize);\n                            }\n                        }\n                    }else{\n                        if(IS_8x8DCT(mb_type)){\n                            s->dsp.h264_idct8_add4(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }else{\n                            s->dsp.h264_idct_add16(dest_y, block_offset, h->mb, linesize, h->non_zero_count_cache);\n                        }\n                    }\n                }\n            }else{\n                for(i=0; i<16; i++){\n                    if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){ //FIXME benchmark weird rule, & below\n                        uint8_t * const ptr= dest_y + block_offset[i];\n                        svq3_add_idct_c(ptr, h->mb + i*16, linesize, s->qscale, IS_INTRA(mb_type) ? 1 : 0);\n                    }\n                }\n            }\n        }\n\n        if((simple || !CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)) && (h->cbp&0x30)){\n            uint8_t *dest[2] = {dest_cb, dest_cr};\n            if(transform_bypass){\n                if(IS_INTRA(mb_type) && h->sps.profile_idc==244 && (h->chroma_pred_mode==VERT_PRED8x8 || h->chroma_pred_mode==HOR_PRED8x8)){\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[0], block_offset + 16, h->mb + 16*16, uvlinesize);\n                    h->hpc.pred8x8_add[h->chroma_pred_mode](dest[1], block_offset + 20, h->mb + 20*16, uvlinesize);\n                }else{\n                    idct_add = s->dsp.add_pixels4;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }\n            }else{\n                chroma_dc_dequant_idct_c(h->mb + 16*16, h->chroma_qp[0], h->dequant4_coeff[IS_INTRA(mb_type) ? 1:4][h->chroma_qp[0]][0]);\n                chroma_dc_dequant_idct_c(h->mb + 16*16+4*16, h->chroma_qp[1], h->dequant4_coeff[IS_INTRA(mb_type) ? 2:5][h->chroma_qp[1]][0]);\n                if(is_h264){\n                    idct_add = s->dsp.h264_idct_add;\n                    idct_dc_add = s->dsp.h264_idct_dc_add;\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ])\n                            idct_add   (dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                        else if(h->mb[i*16])\n                            idct_dc_add(dest[(i&4)>>2] + block_offset[i], h->mb + i*16, uvlinesize);\n                    }\n                }else{\n                    for(i=16; i<16+8; i++){\n                        if(h->non_zero_count_cache[ scan8[i] ] || h->mb[i*16]){\n                            uint8_t * const ptr= dest[(i&4)>>2] + block_offset[i];\n                            svq3_add_idct_c(ptr, h->mb + i*16, uvlinesize, ff_h264_chroma_qp[s->qscale + 12] - 12, 2);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(h->cbp || IS_INTRA(mb_type))\n        s->dsp.clear_blocks(h->mb);\n\n    if(h->deblocking_filter && 0) {\n        backup_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, simple);\n        fill_caches(h, mb_type, 1); //FIXME don't fill stuff which isn't used by filter_mb\n        h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]);\n        h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]);\n        if (!simple && FRAME_MBAFF) {\n            ff_h264_filter_mb     (h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        } else {\n            ff_h264_filter_mb_fast(h, mb_x, mb_y, dest_y, dest_cb, dest_cr, linesize, uvlinesize);\n        }\n    }\n}", "before_change_lines": [243], "raw_before_change_lines": [243], "after_change_lines": [24, 245], "raw_after_change_lines": [24, 25, 245], "bug_lines": [243], "added": [false], "idx": 10}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "134----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_08371baf079e42b07ec2ade795b67121eafe05e8_1.json----raw_decode", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_08371baf079e42b07ec2ade795b67121eafe05e8_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_08371baf079e42b07ec2ade795b67121eafe05e8_1.json", "function_name": "raw_decode", "vul_func_code": "static int raw_decode(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    int linesize_align = 4;\n    RawVideoContext *context = avctx->priv_data;\n\n    AVFrame * frame = (AVFrame *) data;\n    AVPicture * picture = (AVPicture *) data;\n\n    frame->pict_type        = avctx->coded_frame->pict_type;\n    frame->interlaced_frame = avctx->coded_frame->interlaced_frame;\n    frame->top_field_first = avctx->coded_frame->top_field_first;\n    frame->reordered_opaque = avctx->reordered_opaque;\n    frame->pkt_pts          = avctx->pkt->pts;\n    frame->pkt_pos          = avctx->pkt->pos;\n\n    if(context->tff>=0){\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = context->tff;\n    }\n\n    //2bpp and 4bpp raw in avi and mov (yes this is ugly ...)\n    if (context->buffer) {\n        int i;\n        uint8_t *dst = context->buffer;\n        buf_size = context->length - 256*4;\n        if (avctx->bits_per_coded_sample == 4){\n            for(i=0; 2*i+1 < buf_size; i++){\n                dst[2*i+0]= buf[i]>>4;\n                dst[2*i+1]= buf[i]&15;\n            }\n            linesize_align = 8;\n        } else {\n            for(i=0; 4*i+3 < buf_size; i++){\n                dst[4*i+0]= buf[i]>>6;\n                dst[4*i+1]= buf[i]>>4&3;\n                dst[4*i+2]= buf[i]>>2&3;\n                dst[4*i+3]= buf[i]   &3;\n            }\n            linesize_align = 16;\n        }\n        buf= dst;\n    }\n\n    if(avctx->codec_tag == MKTAG('A', 'V', '1', 'x') ||\n       avctx->codec_tag == MKTAG('A', 'V', 'u', 'p'))\n        buf += buf_size - context->length;\n\n    if(buf_size < context->length - (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0))\n        return -1;\n\n    avpicture_fill(picture, buf, avctx->pix_fmt, avctx->width, avctx->height);\n    if((avctx->pix_fmt==PIX_FMT_PAL8 && buf_size < context->length) ||\n       (av_pix_fmt_descriptors[avctx->pix_fmt].flags & PIX_FMT_PSEUDOPAL)) {\n        frame->data[1]= context->palette;\n    }\n    if (avctx->pix_fmt == PIX_FMT_PAL8) {\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n            memcpy(frame->data[1], pal, AVPALETTE_SIZE);\n            frame->palette_has_changed = 1;\n        }\n    }\n    if((avctx->pix_fmt==PIX_FMT_BGR24    ||\n        avctx->pix_fmt==PIX_FMT_GRAY8    ||\n        avctx->pix_fmt==PIX_FMT_RGB555LE ||\n        avctx->pix_fmt==PIX_FMT_RGB555BE ||\n        avctx->pix_fmt==PIX_FMT_RGB565LE ||\n        avctx->pix_fmt==PIX_FMT_MONOWHITE ||\n        avctx->pix_fmt==PIX_FMT_PAL8) &&\n        FFALIGN(frame->linesize[0], linesize_align)*avctx->height <= buf_size)\n        frame->linesize[0] = FFALIGN(frame->linesize[0], linesize_align);\n\n    if(context->flip)\n        flip(avctx, picture);\n\n    if (   avctx->codec_tag == MKTAG('Y', 'V', '1', '2')\n        || avctx->codec_tag == MKTAG('Y', 'V', '1', '6')\n        || avctx->codec_tag == MKTAG('Y', 'V', '2', '4')\n        || avctx->codec_tag == MKTAG('Y', 'V', 'U', '9'))\n        FFSWAP(uint8_t *, picture->data[1], picture->data[2]);\n\n    if(avctx->codec_tag == AV_RL32(\"yuv2\") &&\n       avctx->pix_fmt   == PIX_FMT_YUYV422) {\n        int x, y;\n        uint8_t *line = picture->data[0];\n        for(y = 0; y < avctx->height; y++) {\n            for(x = 0; x < avctx->width; x++)\n                line[2*x + 1] ^= 0x80;\n            line += picture->linesize[0];\n        }\n    }\n\n    *data_size = sizeof(AVPicture);\n    return buf_size;\n}", "patch_func_code": "static int raw_decode(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    int linesize_align = 4;\n    RawVideoContext *context = avctx->priv_data;\n\n    AVFrame * frame = (AVFrame *) data;\n    AVPicture * picture = (AVPicture *) data;\n\n    frame->pict_type        = avctx->coded_frame->pict_type;\n    frame->interlaced_frame = avctx->coded_frame->interlaced_frame;\n    frame->top_field_first = avctx->coded_frame->top_field_first;\n    frame->reordered_opaque = avctx->reordered_opaque;\n    frame->pkt_pts          = avctx->pkt->pts;\n    frame->pkt_pos          = avctx->pkt->pos;\n\n    if(context->tff>=0){\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = context->tff;\n    }\n\n    //2bpp and 4bpp raw in avi and mov (yes this is ugly ...)\n    if (context->buffer) {\n        int i;\n        uint8_t *dst = context->buffer;\n        buf_size = context->length - 256*4;\n        if (avctx->bits_per_coded_sample == 4){\n            for(i=0; 2*i+1 < buf_size && i<avpkt->size; i++){\n                dst[2*i+0]= buf[i]>>4;\n                dst[2*i+1]= buf[i]&15;\n            }\n            linesize_align = 8;\n        } else {\n            for(i=0; 4*i+3 < buf_size && i<avpkt->size; i++){\n                dst[4*i+0]= buf[i]>>6;\n                dst[4*i+1]= buf[i]>>4&3;\n                dst[4*i+2]= buf[i]>>2&3;\n                dst[4*i+3]= buf[i]   &3;\n            }\n            linesize_align = 16;\n        }\n        buf= dst;\n    }\n\n    if(avctx->codec_tag == MKTAG('A', 'V', '1', 'x') ||\n       avctx->codec_tag == MKTAG('A', 'V', 'u', 'p'))\n        buf += buf_size - context->length;\n\n    if(buf_size < context->length - (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0))\n        return -1;\n\n    avpicture_fill(picture, buf, avctx->pix_fmt, avctx->width, avctx->height);\n    if((avctx->pix_fmt==PIX_FMT_PAL8 && buf_size < context->length) ||\n       (av_pix_fmt_descriptors[avctx->pix_fmt].flags & PIX_FMT_PSEUDOPAL)) {\n        frame->data[1]= context->palette;\n    }\n    if (avctx->pix_fmt == PIX_FMT_PAL8) {\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n            memcpy(frame->data[1], pal, AVPALETTE_SIZE);\n            frame->palette_has_changed = 1;\n        }\n    }\n    if((avctx->pix_fmt==PIX_FMT_BGR24    ||\n        avctx->pix_fmt==PIX_FMT_GRAY8    ||\n        avctx->pix_fmt==PIX_FMT_RGB555LE ||\n        avctx->pix_fmt==PIX_FMT_RGB555BE ||\n        avctx->pix_fmt==PIX_FMT_RGB565LE ||\n        avctx->pix_fmt==PIX_FMT_MONOWHITE ||\n        avctx->pix_fmt==PIX_FMT_PAL8) &&\n        FFALIGN(frame->linesize[0], linesize_align)*avctx->height <= buf_size)\n        frame->linesize[0] = FFALIGN(frame->linesize[0], linesize_align);\n\n    if(context->flip)\n        flip(avctx, picture);\n\n    if (   avctx->codec_tag == MKTAG('Y', 'V', '1', '2')\n        || avctx->codec_tag == MKTAG('Y', 'V', '1', '6')\n        || avctx->codec_tag == MKTAG('Y', 'V', '2', '4')\n        || avctx->codec_tag == MKTAG('Y', 'V', 'U', '9'))\n        FFSWAP(uint8_t *, picture->data[1], picture->data[2]);\n\n    if(avctx->codec_tag == AV_RL32(\"yuv2\") &&\n       avctx->pix_fmt   == PIX_FMT_YUYV422) {\n        int x, y;\n        uint8_t *line = picture->data[0];\n        for(y = 0; y < avctx->height; y++) {\n            for(x = 0; x < avctx->width; x++)\n                line[2*x + 1] ^= 0x80;\n            line += picture->linesize[0];\n        }\n    }\n\n    *data_size = sizeof(AVPicture);\n    return buf_size;\n}", "before_change_lines": [31, 37], "raw_before_change_lines": [31, 37], "after_change_lines": [31, 37], "raw_after_change_lines": [31, 37], "bug_lines": [31, 37], "added": [false, false], "idx": 11}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "150----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_09438a4384996b253379c39982b9fcab650dcf62_1.json----parse_playlist", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_09438a4384996b253379c39982b9fcab650dcf62_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_09438a4384996b253379c39982b9fcab650dcf62_1.json", "function_name": "parse_playlist", "vul_func_code": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct variant *var, AVIOContext *in)\n{\n    int ret = 0, duration = 0, is_segment = 0, is_variant = 0, bandwidth = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[1024];\n    const char *ptr;\n    int close_in = 0;\n\n    if (!in) {\n        close_in = 1;\n        if ((ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                              c->interrupt_callback, NULL)) < 0)\n            return ret;\n    }\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (var) {\n        free_segment_list(var);\n        var->finished = 0;\n    }\n    while (!url_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            struct variant_info info = {{0}};\n            is_variant = 1;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &info);\n            bandwidth = atoi(info.bandwidth);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            if (!var) {\n                var = new_variant(c, 0, url, NULL);\n                if (!var) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n            }\n            var->target_duration = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            if (!var) {\n                var = new_variant(c, 0, url, NULL);\n                if (!var) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n            }\n            var->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (var)\n                var->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atoi(ptr);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, bandwidth, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n                bandwidth  = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!var) {\n                    var = new_variant(c, 0, url, NULL);\n                    if (!var) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = var->start_seq_no + var->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n                ff_make_absolute_url(seg->key, sizeof(seg->key), url, key);\n                ff_make_absolute_url(seg->url, sizeof(seg->url), url, line);\n                dynarray_add(&var->segments, &var->n_segments, seg);\n                is_segment = 0;\n            }\n        }\n    }\n    if (var)\n        var->last_load_time = av_gettime();\n\nfail:\n    if (close_in)\n        avio_close(in);\n    return ret;\n}", "patch_func_code": "static int parse_playlist(HLSContext *c, const char *url,\n                          struct variant *var, AVIOContext *in)\n{\n    int ret = 0, duration = 0, is_segment = 0, is_variant = 0, bandwidth = 0;\n    enum KeyType key_type = KEY_NONE;\n    uint8_t iv[16] = \"\";\n    int has_iv = 0;\n    char key[MAX_URL_SIZE] = \"\";\n    char line[1024];\n    const char *ptr;\n    int close_in = 0;\n\n    if (!in) {\n        AVDictionary *opts = NULL;\n        close_in = 1;\n        /* Some HLS servers dont like being sent the range header */\n        av_dict_set(&opts, \"seekable\", \"0\", 0);\n        ret = avio_open2(&in, url, AVIO_FLAG_READ,\n                         c->interrupt_callback, &opts);\n        av_dict_free(&opts);\n        if (ret < 0)\n            return ret;\n    }\n\n    read_chomp_line(in, line, sizeof(line));\n    if (strcmp(line, \"#EXTM3U\")) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if (var) {\n        free_segment_list(var);\n        var->finished = 0;\n    }\n    while (!url_feof(in)) {\n        read_chomp_line(in, line, sizeof(line));\n        if (av_strstart(line, \"#EXT-X-STREAM-INF:\", &ptr)) {\n            struct variant_info info = {{0}};\n            is_variant = 1;\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_variant_args,\n                               &info);\n            bandwidth = atoi(info.bandwidth);\n        } else if (av_strstart(line, \"#EXT-X-KEY:\", &ptr)) {\n            struct key_info info = {{0}};\n            ff_parse_key_value(ptr, (ff_parse_key_val_cb) handle_key_args,\n                               &info);\n            key_type = KEY_NONE;\n            has_iv = 0;\n            if (!strcmp(info.method, \"AES-128\"))\n                key_type = KEY_AES_128;\n            if (!strncmp(info.iv, \"0x\", 2) || !strncmp(info.iv, \"0X\", 2)) {\n                ff_hex_to_data(iv, info.iv + 2);\n                has_iv = 1;\n            }\n            av_strlcpy(key, info.uri, sizeof(key));\n        } else if (av_strstart(line, \"#EXT-X-TARGETDURATION:\", &ptr)) {\n            if (!var) {\n                var = new_variant(c, 0, url, NULL);\n                if (!var) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n            }\n            var->target_duration = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-MEDIA-SEQUENCE:\", &ptr)) {\n            if (!var) {\n                var = new_variant(c, 0, url, NULL);\n                if (!var) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n            }\n            var->start_seq_no = atoi(ptr);\n        } else if (av_strstart(line, \"#EXT-X-ENDLIST\", &ptr)) {\n            if (var)\n                var->finished = 1;\n        } else if (av_strstart(line, \"#EXTINF:\", &ptr)) {\n            is_segment = 1;\n            duration   = atoi(ptr);\n        } else if (av_strstart(line, \"#\", NULL)) {\n            continue;\n        } else if (line[0]) {\n            if (is_variant) {\n                if (!new_variant(c, bandwidth, line, url)) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                is_variant = 0;\n                bandwidth  = 0;\n            }\n            if (is_segment) {\n                struct segment *seg;\n                if (!var) {\n                    var = new_variant(c, 0, url, NULL);\n                    if (!var) {\n                        ret = AVERROR(ENOMEM);\n                        goto fail;\n                    }\n                }\n                seg = av_malloc(sizeof(struct segment));\n                if (!seg) {\n                    ret = AVERROR(ENOMEM);\n                    goto fail;\n                }\n                seg->duration = duration;\n                seg->key_type = key_type;\n                if (has_iv) {\n                    memcpy(seg->iv, iv, sizeof(iv));\n                } else {\n                    int seq = var->start_seq_no + var->n_segments;\n                    memset(seg->iv, 0, sizeof(seg->iv));\n                    AV_WB32(seg->iv + 12, seq);\n                }\n                ff_make_absolute_url(seg->key, sizeof(seg->key), url, key);\n                ff_make_absolute_url(seg->url, sizeof(seg->url), url, line);\n                dynarray_add(&var->segments, &var->n_segments, seg);\n                is_segment = 0;\n            }\n        }\n    }\n    if (var)\n        var->last_load_time = av_gettime();\n\nfail:\n    if (close_in)\n        avio_close(in);\n    return ret;\n}", "before_change_lines": [15, 16], "raw_before_change_lines": [15, 16], "after_change_lines": [14, 17, 18, 19, 20, 21], "raw_after_change_lines": [14, 16, 17, 18, 19, 20, 21], "bug_lines": [15, 16], "added": [false, false], "idx": 12}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "153----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_098ed9ede86eb1eb57b8bc2c35e265e315eb4a82_1.json----decode_chunks", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_098ed9ede86eb1eb57b8bc2c35e265e315eb4a82_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_098ed9ede86eb1eb57b8bc2c35e265e315eb4a82_1.json", "function_name": "decode_chunks", "vul_func_code": "static int decode_chunks(AVCodecContext *avctx,\n                             AVFrame *picture, int *data_size,\n                             const uint8_t *buf, int buf_size)\n{\n    Mpeg1Context *s = avctx->priv_data;\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n    const uint8_t *buf_ptr = buf;\n    const uint8_t *buf_end = buf + buf_size;\n    int ret, input_size;\n    int last_code= 0;\n\n    for(;;) {\n        /* find next start code */\n        uint32_t start_code = -1;\n        buf_ptr = ff_find_start_code(buf_ptr,buf_end, &start_code);\n        if (start_code > 0x1ff){\n            if(s2->pict_type != AV_PICTURE_TYPE_B || avctx->skip_frame <= AVDISCARD_DEFAULT){\n                if(avctx->thread_count > 1){\n                    int i;\n\n                    avctx->execute(avctx, slice_decode_thread,  &s2->thread_context[0], NULL, s->slice_count, sizeof(void*));\n                    for(i=0; i<s->slice_count; i++)\n                        s2->error_count += s2->thread_context[i]->error_count;\n                }\n\n                if (CONFIG_MPEG_VDPAU_DECODER && avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n                    ff_vdpau_mpeg_picture_complete(s2, buf, buf_size, s->slice_count);\n\n                if (slice_end(avctx, picture)) {\n                    if(s2->last_picture_ptr || s2->low_delay) //FIXME merge with the stuff in mpeg_decode_slice\n                        *data_size = sizeof(AVPicture);\n                }\n            }\n            s2->pict_type= 0;\n            return FFMAX(0, buf_ptr - buf - s2->parse_context.last_index);\n        }\n\n        input_size = buf_end - buf_ptr;\n\n        if(avctx->debug & FF_DEBUG_STARTCODE){\n            av_log(avctx, AV_LOG_DEBUG, \"%3X at %td left %d\\n\", start_code, buf_ptr-buf, input_size);\n        }\n\n        /* prepare data for next start code */\n        switch(start_code) {\n        case SEQ_START_CODE:\n            if(last_code == 0){\n            mpeg1_decode_sequence(avctx, buf_ptr,\n                                    input_size);\n                s->sync=1;\n            }else{\n                av_log(avctx, AV_LOG_ERROR, \"ignoring SEQ_START_CODE after %X\\n\", last_code);\n            }\n            break;\n\n        case PICTURE_START_CODE:\n            if (HAVE_THREADS && (avctx->active_thread_type&FF_THREAD_SLICE) && s->slice_count) {\n                int i;\n\n                avctx->execute(avctx, slice_decode_thread,\n                               s2->thread_context, NULL,\n                               s->slice_count, sizeof(void*));\n                for (i = 0; i < s->slice_count; i++)\n                    s2->error_count += s2->thread_context[i]->error_count;\n                s->slice_count = 0;\n            }\n            if(last_code == 0 || last_code == SLICE_MIN_START_CODE){\n            if(mpeg_decode_postinit(avctx) < 0){\n                av_log(avctx, AV_LOG_ERROR, \"mpeg_decode_postinit() failure\\n\");\n                return -1;\n            }\n\n            /* we have a complete image: we try to decompress it */\n            if(mpeg1_decode_picture(avctx,\n                                    buf_ptr, input_size) < 0)\n                s2->pict_type=0;\n                s2->first_slice = 1;\n            last_code= PICTURE_START_CODE;\n            }else{\n                av_log(avctx, AV_LOG_ERROR, \"ignoring pic after %X\\n\", last_code);\n            }\n            break;\n        case EXT_START_CODE:\n            init_get_bits(&s2->gb, buf_ptr, input_size*8);\n\n            switch(get_bits(&s2->gb, 4)) {\n            case 0x1:\n                if(last_code == 0){\n                mpeg_decode_sequence_extension(s);\n                }else{\n                    av_log(avctx, AV_LOG_ERROR, \"ignoring seq ext after %X\\n\", last_code);\n                }\n                break;\n            case 0x2:\n                mpeg_decode_sequence_display_extension(s);\n                break;\n            case 0x3:\n                mpeg_decode_quant_matrix_extension(s2);\n                break;\n            case 0x7:\n                mpeg_decode_picture_display_extension(s);\n                break;\n            case 0x8:\n                if(last_code == PICTURE_START_CODE){\n                mpeg_decode_picture_coding_extension(s);\n                }else{\n                    av_log(avctx, AV_LOG_ERROR, \"ignoring pic cod ext after %X\\n\", last_code);\n                }\n                break;\n            }\n            break;\n        case USER_START_CODE:\n            mpeg_decode_user_data(avctx,\n                                    buf_ptr, input_size);\n            break;\n        case GOP_START_CODE:\n            if(last_code == 0){\n            s2->first_field=0;\n            mpeg_decode_gop(avctx,\n                                    buf_ptr, input_size);\n                s->sync=1;\n            }else{\n                av_log(avctx, AV_LOG_ERROR, \"ignoring GOP_START_CODE after %X\\n\", last_code);\n            }\n            break;\n        default:\n            if (start_code >= SLICE_MIN_START_CODE &&\n                start_code <= SLICE_MAX_START_CODE && last_code!=0) {\n                const int field_pic= s2->picture_structure != PICT_FRAME;\n                int mb_y= (start_code - SLICE_MIN_START_CODE) << field_pic;\n                last_code= SLICE_MIN_START_CODE;\n\n                if(s2->picture_structure == PICT_BOTTOM_FIELD)\n                    mb_y++;\n\n                if (mb_y >= s2->mb_height){\n                    av_log(s2->avctx, AV_LOG_ERROR, \"slice below image (%d >= %d)\\n\", mb_y, s2->mb_height);\n                    return -1;\n                }\n\n                if(s2->last_picture_ptr==NULL){\n                /* Skip B-frames if we do not have reference frames and gop is not closed */\n                    if(s2->pict_type==AV_PICTURE_TYPE_B){\n                        if(!s2->closed_gop)\n                            break;\n                    }\n                }\n                if(s2->pict_type==AV_PICTURE_TYPE_I)\n                    s->sync=1;\n                if(s2->next_picture_ptr==NULL){\n                /* Skip P-frames if we do not have a reference frame or we have an invalid header. */\n                    if(s2->pict_type==AV_PICTURE_TYPE_P && !s->sync) break;\n                }\n                if(  (avctx->skip_frame >= AVDISCARD_NONREF && s2->pict_type==AV_PICTURE_TYPE_B)\n                    ||(avctx->skip_frame >= AVDISCARD_NONKEY && s2->pict_type!=AV_PICTURE_TYPE_I)\n                    || avctx->skip_frame >= AVDISCARD_ALL)\n                    break;\n\n                if (!s->mpeg_enc_ctx_allocated) break;\n\n                if(s2->codec_id == CODEC_ID_MPEG2VIDEO){\n                    if(mb_y < avctx->skip_top || mb_y >= s2->mb_height - avctx->skip_bottom)\n                        break;\n                }\n\n                if(!s2->pict_type){\n                    av_log(avctx, AV_LOG_ERROR, \"Missing picture start code\\n\");\n                    break;\n                }\n\n                if(s2->first_slice){\n                    s2->first_slice=0;\n                    if(mpeg_field_start(s2, buf, buf_size) < 0)\n                        return -1;\n                }\n                if(!s2->current_picture_ptr){\n                    av_log(avctx, AV_LOG_ERROR, \"current_picture not initialized\\n\");\n                    return -1;\n                }\n\n                if (avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {\n                    s->slice_count++;\n                    break;\n                }\n\n                if(avctx->thread_count > 1){\n                    int threshold= (s2->mb_height*s->slice_count + avctx->thread_count/2) / avctx->thread_count;\n                    if(threshold <= mb_y){\n                        MpegEncContext *thread_context= s2->thread_context[s->slice_count];\n\n                        thread_context->start_mb_y= mb_y;\n                        thread_context->end_mb_y  = s2->mb_height;\n                        if(s->slice_count){\n                            s2->thread_context[s->slice_count-1]->end_mb_y= mb_y;\n                            ff_update_duplicate_context(thread_context, s2);\n                        }\n                        init_get_bits(&thread_context->gb, buf_ptr, input_size*8);\n                        s->slice_count++;\n                    }\n                    buf_ptr += 2; //FIXME add minimum number of bytes per slice\n                }else{\n                    ret = mpeg_decode_slice(s, mb_y, &buf_ptr, input_size);\n                    emms_c();\n\n                    if(ret < 0){\n                        if(s2->resync_mb_x>=0 && s2->resync_mb_y>=0)\n                            ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x, s2->mb_y, AC_ERROR|DC_ERROR|MV_ERROR);\n                    }else{\n                        ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x-1, s2->mb_y, AC_END|DC_END|MV_END);\n                    }\n                }\n            }\n            break;\n        }\n    }\n}", "patch_func_code": "static int decode_chunks(AVCodecContext *avctx,\n                             AVFrame *picture, int *data_size,\n                             const uint8_t *buf, int buf_size)\n{\n    Mpeg1Context *s = avctx->priv_data;\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n    const uint8_t *buf_ptr = buf;\n    const uint8_t *buf_end = buf + buf_size;\n    int ret, input_size;\n    int last_code= 0;\n\n    for(;;) {\n        /* find next start code */\n        uint32_t start_code = -1;\n        buf_ptr = ff_find_start_code(buf_ptr,buf_end, &start_code);\n        if (start_code > 0x1ff){\n            if(s2->pict_type != AV_PICTURE_TYPE_B || avctx->skip_frame <= AVDISCARD_DEFAULT){\n                if((avctx->active_thread_type & FF_THREAD_SLICE) && avctx->thread_count > 1){\n                    int i;\n\n                    avctx->execute(avctx, slice_decode_thread,  &s2->thread_context[0], NULL, s->slice_count, sizeof(void*));\n                    for(i=0; i<s->slice_count; i++)\n                        s2->error_count += s2->thread_context[i]->error_count;\n                }\n\n                if (CONFIG_MPEG_VDPAU_DECODER && avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n                    ff_vdpau_mpeg_picture_complete(s2, buf, buf_size, s->slice_count);\n\n                if (slice_end(avctx, picture)) {\n                    if(s2->last_picture_ptr || s2->low_delay) //FIXME merge with the stuff in mpeg_decode_slice\n                        *data_size = sizeof(AVPicture);\n                }\n            }\n            s2->pict_type= 0;\n            return FFMAX(0, buf_ptr - buf - s2->parse_context.last_index);\n        }\n\n        input_size = buf_end - buf_ptr;\n\n        if(avctx->debug & FF_DEBUG_STARTCODE){\n            av_log(avctx, AV_LOG_DEBUG, \"%3X at %td left %d\\n\", start_code, buf_ptr-buf, input_size);\n        }\n\n        /* prepare data for next start code */\n        switch(start_code) {\n        case SEQ_START_CODE:\n            if(last_code == 0){\n            mpeg1_decode_sequence(avctx, buf_ptr,\n                                    input_size);\n                s->sync=1;\n            }else{\n                av_log(avctx, AV_LOG_ERROR, \"ignoring SEQ_START_CODE after %X\\n\", last_code);\n            }\n            break;\n\n        case PICTURE_START_CODE:\n            if (HAVE_THREADS && (avctx->active_thread_type&FF_THREAD_SLICE) && s->slice_count) {\n                int i;\n\n                avctx->execute(avctx, slice_decode_thread,\n                               s2->thread_context, NULL,\n                               s->slice_count, sizeof(void*));\n                for (i = 0; i < s->slice_count; i++)\n                    s2->error_count += s2->thread_context[i]->error_count;\n                s->slice_count = 0;\n            }\n            if(last_code == 0 || last_code == SLICE_MIN_START_CODE){\n            if(mpeg_decode_postinit(avctx) < 0){\n                av_log(avctx, AV_LOG_ERROR, \"mpeg_decode_postinit() failure\\n\");\n                return -1;\n            }\n\n            /* we have a complete image: we try to decompress it */\n            if(mpeg1_decode_picture(avctx,\n                                    buf_ptr, input_size) < 0)\n                s2->pict_type=0;\n                s2->first_slice = 1;\n            last_code= PICTURE_START_CODE;\n            }else{\n                av_log(avctx, AV_LOG_ERROR, \"ignoring pic after %X\\n\", last_code);\n            }\n            break;\n        case EXT_START_CODE:\n            init_get_bits(&s2->gb, buf_ptr, input_size*8);\n\n            switch(get_bits(&s2->gb, 4)) {\n            case 0x1:\n                if(last_code == 0){\n                mpeg_decode_sequence_extension(s);\n                }else{\n                    av_log(avctx, AV_LOG_ERROR, \"ignoring seq ext after %X\\n\", last_code);\n                }\n                break;\n            case 0x2:\n                mpeg_decode_sequence_display_extension(s);\n                break;\n            case 0x3:\n                mpeg_decode_quant_matrix_extension(s2);\n                break;\n            case 0x7:\n                mpeg_decode_picture_display_extension(s);\n                break;\n            case 0x8:\n                if(last_code == PICTURE_START_CODE){\n                mpeg_decode_picture_coding_extension(s);\n                }else{\n                    av_log(avctx, AV_LOG_ERROR, \"ignoring pic cod ext after %X\\n\", last_code);\n                }\n                break;\n            }\n            break;\n        case USER_START_CODE:\n            mpeg_decode_user_data(avctx,\n                                    buf_ptr, input_size);\n            break;\n        case GOP_START_CODE:\n            if(last_code == 0){\n            s2->first_field=0;\n            mpeg_decode_gop(avctx,\n                                    buf_ptr, input_size);\n                s->sync=1;\n            }else{\n                av_log(avctx, AV_LOG_ERROR, \"ignoring GOP_START_CODE after %X\\n\", last_code);\n            }\n            break;\n        default:\n            if (start_code >= SLICE_MIN_START_CODE &&\n                start_code <= SLICE_MAX_START_CODE && last_code!=0) {\n                const int field_pic= s2->picture_structure != PICT_FRAME;\n                int mb_y= (start_code - SLICE_MIN_START_CODE) << field_pic;\n                last_code= SLICE_MIN_START_CODE;\n\n                if(s2->picture_structure == PICT_BOTTOM_FIELD)\n                    mb_y++;\n\n                if (mb_y >= s2->mb_height){\n                    av_log(s2->avctx, AV_LOG_ERROR, \"slice below image (%d >= %d)\\n\", mb_y, s2->mb_height);\n                    return -1;\n                }\n\n                if(s2->last_picture_ptr==NULL){\n                /* Skip B-frames if we do not have reference frames and gop is not closed */\n                    if(s2->pict_type==AV_PICTURE_TYPE_B){\n                        if(!s2->closed_gop)\n                            break;\n                    }\n                }\n                if(s2->pict_type==AV_PICTURE_TYPE_I)\n                    s->sync=1;\n                if(s2->next_picture_ptr==NULL){\n                /* Skip P-frames if we do not have a reference frame or we have an invalid header. */\n                    if(s2->pict_type==AV_PICTURE_TYPE_P && !s->sync) break;\n                }\n                if(  (avctx->skip_frame >= AVDISCARD_NONREF && s2->pict_type==AV_PICTURE_TYPE_B)\n                    ||(avctx->skip_frame >= AVDISCARD_NONKEY && s2->pict_type!=AV_PICTURE_TYPE_I)\n                    || avctx->skip_frame >= AVDISCARD_ALL)\n                    break;\n\n                if (!s->mpeg_enc_ctx_allocated) break;\n\n                if(s2->codec_id == CODEC_ID_MPEG2VIDEO){\n                    if(mb_y < avctx->skip_top || mb_y >= s2->mb_height - avctx->skip_bottom)\n                        break;\n                }\n\n                if(!s2->pict_type){\n                    av_log(avctx, AV_LOG_ERROR, \"Missing picture start code\\n\");\n                    break;\n                }\n\n                if(s2->first_slice){\n                    s2->first_slice=0;\n                    if(mpeg_field_start(s2, buf, buf_size) < 0)\n                        return -1;\n                }\n                if(!s2->current_picture_ptr){\n                    av_log(avctx, AV_LOG_ERROR, \"current_picture not initialized\\n\");\n                    return -1;\n                }\n\n                if (avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {\n                    s->slice_count++;\n                    break;\n                }\n\n                if((avctx->active_thread_type & FF_THREAD_SLICE) && avctx->thread_count > 1){\n                    int threshold= (s2->mb_height*s->slice_count + avctx->thread_count/2) / avctx->thread_count;\n                    if(threshold <= mb_y){\n                        MpegEncContext *thread_context= s2->thread_context[s->slice_count];\n\n                        thread_context->start_mb_y= mb_y;\n                        thread_context->end_mb_y  = s2->mb_height;\n                        if(s->slice_count){\n                            s2->thread_context[s->slice_count-1]->end_mb_y= mb_y;\n                            ff_update_duplicate_context(thread_context, s2);\n                        }\n                        init_get_bits(&thread_context->gb, buf_ptr, input_size*8);\n                        s->slice_count++;\n                    }\n                    buf_ptr += 2; //FIXME add minimum number of bytes per slice\n                }else{\n                    ret = mpeg_decode_slice(s, mb_y, &buf_ptr, input_size);\n                    emms_c();\n\n                    if(ret < 0){\n                        if(s2->resync_mb_x>=0 && s2->resync_mb_y>=0)\n                            ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x, s2->mb_y, AC_ERROR|DC_ERROR|MV_ERROR);\n                    }else{\n                        ff_er_add_slice(s2, s2->resync_mb_x, s2->resync_mb_y, s2->mb_x-1, s2->mb_y, AC_END|DC_END|MV_END);\n                    }\n                }\n            }\n            break;\n        }\n    }\n}", "before_change_lines": [18, 186], "raw_before_change_lines": [18, 186], "after_change_lines": [18, 186], "raw_after_change_lines": [18, 186], "bug_lines": [18, 186], "added": [false, false], "idx": 13}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "181----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0abd4ffb8a19405df16711ea2d44b6ba3171f1b2_1.json----ea_read_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0abd4ffb8a19405df16711ea2d44b6ba3171f1b2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0abd4ffb8a19405df16711ea2d44b6ba3171f1b2_1.json", "function_name": "ea_read_packet", "vul_func_code": "static int ea_read_packet(AVFormatContext *s,\n                          AVPacket *pkt)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret = 0;\n    int packet_read = 0;\n    unsigned int chunk_type, chunk_size;\n    int key = 0;\n    int av_uninit(num_samples);\n\n    while (!packet_read) {\n        chunk_type = avio_rl32(pb);\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n        switch (chunk_type) {\n        /* audio data */\n        case ISNh_TAG:\n            /* header chunk also contains data; skip over the header portion*/\n            avio_skip(pb, 32);\n            chunk_size -= 32;\n        case ISNd_TAG:\n        case SCDl_TAG:\n        case SNDC_TAG:\n        case SDEN_TAG:\n            if (!ea->audio_codec) {\n                avio_skip(pb, chunk_size);\n                break;\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n                       ea->audio_codec == CODEC_ID_MP3) {\n                num_samples = avio_rl32(pb);\n                avio_skip(pb, 8);\n                chunk_size -= 12;\n            }\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->audio_stream_index;\n\n            switch (ea->audio_codec) {\n            case CODEC_ID_ADPCM_EA:\n            case CODEC_ID_ADPCM_EA_R1:\n            case CODEC_ID_ADPCM_EA_R2:\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n                pkt->duration = AV_RL32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_EA_R3:\n                pkt->duration = AV_RB32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n                pkt->duration = ret * 2 / ea->num_channels;\n                break;\n            case CODEC_ID_PCM_S16LE_PLANAR:\n            case CODEC_ID_MP3:\n                pkt->duration = num_samples;\n                break;\n            default:\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n            }\n\n            packet_read = 1;\n            break;\n\n        /* ending tag */\n        case 0:\n        case ISNe_TAG:\n        case SCEl_TAG:\n        case SEND_TAG:\n        case SEEN_TAG:\n            ret = AVERROR(EIO);\n            packet_read = 1;\n            break;\n\n        case MVIh_TAG:\n        case kVGT_TAG:\n        case pQGT_TAG:\n        case TGQs_TAG:\n        case MADk_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MVIf_TAG:\n        case fVGT_TAG:\n        case MADm_TAG:\n        case MADe_TAG:\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n            chunk_size += 8;\n            goto get_video_packet;\n\n        case mTCD_TAG:\n            avio_skip(pb, 8);  // skip ea dct header\n            chunk_size -= 8;\n            goto get_video_packet;\n\n        case MV0K_TAG:\n        case MPCh_TAG:\n        case pIQT_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MV0F_TAG:\nget_video_packet:\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->video_stream_index;\n            pkt->flags |= key;\n            packet_read = 1;\n            break;\n\n        default:\n            avio_skip(pb, chunk_size);\n            break;\n        }\n    }\n\n    return ret;\n}", "patch_func_code": "static int ea_read_packet(AVFormatContext *s,\n                          AVPacket *pkt)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret = 0;\n    int packet_read = 0;\n    unsigned int chunk_type, chunk_size;\n    int key = 0;\n    int av_uninit(num_samples);\n\n    while (!packet_read) {\n        chunk_type = avio_rl32(pb);\n        chunk_size = ea->big_endian ? avio_rb32(pb) : avio_rl32(pb);\n        if (chunk_size <= 8)\n            return AVERROR_INVALIDDATA;\n        chunk_size -= 8;\n\n        switch (chunk_type) {\n        /* audio data */\n        case ISNh_TAG:\n            /* header chunk also contains data; skip over the header portion*/\n            if (chunk_size < 32)\n                return AVERROR_INVALIDDATA;\n            avio_skip(pb, 32);\n            chunk_size -= 32;\n        case ISNd_TAG:\n        case SCDl_TAG:\n        case SNDC_TAG:\n        case SDEN_TAG:\n            if (!ea->audio_codec) {\n                avio_skip(pb, chunk_size);\n                break;\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n                       ea->audio_codec == CODEC_ID_MP3) {\n                num_samples = avio_rl32(pb);\n                avio_skip(pb, 8);\n                chunk_size -= 12;\n            }\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->audio_stream_index;\n\n            switch (ea->audio_codec) {\n            case CODEC_ID_ADPCM_EA:\n            case CODEC_ID_ADPCM_EA_R1:\n            case CODEC_ID_ADPCM_EA_R2:\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n                pkt->duration = AV_RL32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_EA_R3:\n                pkt->duration = AV_RB32(pkt->data);\n                break;\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n                pkt->duration = ret * 2 / ea->num_channels;\n                break;\n            case CODEC_ID_PCM_S16LE_PLANAR:\n            case CODEC_ID_MP3:\n                pkt->duration = num_samples;\n                break;\n            default:\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n            }\n\n            packet_read = 1;\n            break;\n\n        /* ending tag */\n        case 0:\n        case ISNe_TAG:\n        case SCEl_TAG:\n        case SEND_TAG:\n        case SEEN_TAG:\n            ret = AVERROR(EIO);\n            packet_read = 1;\n            break;\n\n        case MVIh_TAG:\n        case kVGT_TAG:\n        case pQGT_TAG:\n        case TGQs_TAG:\n        case MADk_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MVIf_TAG:\n        case fVGT_TAG:\n        case MADm_TAG:\n        case MADe_TAG:\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n            chunk_size += 8;\n            goto get_video_packet;\n\n        case mTCD_TAG:\n            avio_skip(pb, 8);  // skip ea dct header\n            chunk_size -= 8;\n            goto get_video_packet;\n\n        case MV0K_TAG:\n        case MPCh_TAG:\n        case pIQT_TAG:\n            key = AV_PKT_FLAG_KEY;\n        case MV0F_TAG:\nget_video_packet:\n            ret = av_get_packet(pb, pkt, chunk_size);\n            if (ret < 0)\n                return ret;\n            pkt->stream_index = ea->video_stream_index;\n            pkt->flags |= key;\n            packet_read = 1;\n            break;\n\n        default:\n            avio_skip(pb, chunk_size);\n            break;\n        }\n    }\n\n    return ret;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [14, 15, 16, 17, 23, 24], "raw_after_change_lines": [14, 15, 16, 17, 23, 24], "bug_lines": [14], "added": [false], "idx": 14}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "185----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0af298c1026b2f183f159fc2297ea2668ec36211_1.json----sdp_parse_fmtp_config_h264", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0af298c1026b2f183f159fc2297ea2668ec36211_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0af298c1026b2f183f159fc2297ea2668ec36211_1.json", "function_name": "sdp_parse_fmtp_config_h264", "vul_func_code": "static int sdp_parse_fmtp_config_h264(AVStream * stream,\n                                      PayloadContext * h264_data,\n                                      char *attr, char *value)\n{\n    AVCodecContext *codec = stream->codec;\n    assert(codec->codec_id == CODEC_ID_H264);\n    assert(h264_data != NULL);\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n           Packetization Mode:\n           0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n           1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n           2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A), and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(codec, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6) {\n            char buffer[3];\n            // 6 characters=3 bytes, in hex.\n            uint8_t profile_idc;\n            uint8_t profile_iop;\n            uint8_t level_idc;\n\n            buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\\0';\n            profile_idc = strtol(buffer, NULL, 16);\n            buffer[0] = value[2]; buffer[1] = value[3];\n            profile_iop = strtol(buffer, NULL, 16);\n            buffer[0] = value[4]; buffer[1] = value[5];\n            level_idc = strtol(buffer, NULL, 16);\n\n            // set the parameters...\n            av_log(codec, AV_LOG_DEBUG,\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n                   profile_idc, profile_iop, level_idc);\n            h264_data->profile_idc = profile_idc;\n            h264_data->profile_iop = profile_iop;\n            h264_data->level_idc = level_idc;\n        }\n    } else  if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        uint8_t start_sequence[]= { 0, 0, 1 };\n        codec->extradata_size= 0;\n        codec->extradata= NULL;\n\n        while (*value) {\n            char base64packet[1024];\n            uint8_t decoded_packet[1024];\n            uint32_t packet_size;\n            char *dst = base64packet;\n\n            while (*value && *value != ','\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n                *dst++ = *value++;\n            }\n            *dst++ = '\\0';\n\n            if (*value == ',')\n                value++;\n\n            packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet));\n            if (packet_size) {\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n                                         codec->extradata_size +\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n                if(dest)\n                {\n                    if(codec->extradata_size)\n                    {\n                        // av_realloc?\n                        memcpy(dest, codec->extradata, codec->extradata_size);\n                        av_free(codec->extradata);\n                    }\n\n                    memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence));\n                    memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size);\n                    memset(dest+codec->extradata_size+sizeof(start_sequence)+\n                           packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    codec->extradata= dest;\n                    codec->extradata_size+= sizeof(start_sequence)+packet_size;\n                } else {\n                    av_log(codec, AV_LOG_ERROR, \"Unable to allocate memory for extradata!\");\n                    return AVERROR(ENOMEM);\n                }\n            }\n        }\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\", codec->extradata, codec->extradata_size);\n    }\n    return 0;\n}", "patch_func_code": "static int sdp_parse_fmtp_config_h264(AVStream * stream,\n                                      PayloadContext * h264_data,\n                                      char *attr, char *value)\n{\n    AVCodecContext *codec = stream->codec;\n    assert(codec->codec_id == CODEC_ID_H264);\n    assert(h264_data != NULL);\n\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(codec, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        /*\n           Packetization Mode:\n           0 or not present: Single NAL mode (Only nals from 1-23 are allowed)\n           1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.\n           2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A), and 29 (FU-B) are allowed.\n         */\n        if (h264_data->packetization_mode > 1)\n            av_log(codec, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6) {\n            char buffer[3];\n            // 6 characters=3 bytes, in hex.\n            uint8_t profile_idc;\n            uint8_t profile_iop;\n            uint8_t level_idc;\n\n            buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\\0';\n            profile_idc = strtol(buffer, NULL, 16);\n            buffer[0] = value[2]; buffer[1] = value[3];\n            profile_iop = strtol(buffer, NULL, 16);\n            buffer[0] = value[4]; buffer[1] = value[5];\n            level_idc = strtol(buffer, NULL, 16);\n\n            // set the parameters...\n            av_log(codec, AV_LOG_DEBUG,\n                   \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\",\n                   profile_idc, profile_iop, level_idc);\n            h264_data->profile_idc = profile_idc;\n            h264_data->profile_iop = profile_iop;\n            h264_data->level_idc = level_idc;\n        }\n    } else  if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        uint8_t start_sequence[]= { 0, 0, 1 };\n        codec->extradata_size= 0;\n        codec->extradata= NULL;\n\n        while (*value) {\n            char base64packet[1024];\n            uint8_t decoded_packet[1024];\n            int packet_size;\n            char *dst = base64packet;\n\n            while (*value && *value != ','\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n                *dst++ = *value++;\n            }\n            *dst++ = '\\0';\n\n            if (*value == ',')\n                value++;\n\n            packet_size= av_base64_decode(decoded_packet, base64packet, sizeof(decoded_packet));\n            if (packet_size > 0) {\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n                                         codec->extradata_size +\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n                if(dest)\n                {\n                    if(codec->extradata_size)\n                    {\n                        // av_realloc?\n                        memcpy(dest, codec->extradata, codec->extradata_size);\n                        av_free(codec->extradata);\n                    }\n\n                    memcpy(dest+codec->extradata_size, start_sequence, sizeof(start_sequence));\n                    memcpy(dest+codec->extradata_size+sizeof(start_sequence), decoded_packet, packet_size);\n                    memset(dest+codec->extradata_size+sizeof(start_sequence)+\n                           packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    codec->extradata= dest;\n                    codec->extradata_size+= sizeof(start_sequence)+packet_size;\n                } else {\n                    av_log(codec, AV_LOG_ERROR, \"Unable to allocate memory for extradata!\");\n                    return AVERROR(ENOMEM);\n                }\n            }\n        }\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\", codec->extradata, codec->extradata_size);\n    }\n    return 0;\n}", "before_change_lines": [52, 65], "raw_before_change_lines": [52, 65], "after_change_lines": [52, 65], "raw_after_change_lines": [52, 65], "bug_lines": [52, 65], "added": [false, false], "idx": 15}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "208----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0c522e6248daf0957b8bf6b2a0b14c035cff32f4_1.json----dxtory_decode_v2_rgb", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0c522e6248daf0957b8bf6b2a0b14c035cff32f4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0c522e6248daf0957b8bf6b2a0b14c035cff32f4_1.json", "function_name": "dxtory_decode_v2_rgb", "vul_func_code": "static int dxtory_decode_v2_rgb(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    GetByteContext gb;\n    GetBitContext  gb2;\n    int nslices, slice, slice_height;\n    uint32_t off, slice_size;\n    uint8_t *dst;\n    int ret;\n\n    bytestream2_init(&gb, src, src_size);\n    nslices = bytestream2_get_le16(&gb);\n    off = FFALIGN(nslices * 4 + 2, 16);\n    if (src_size < off) {\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!nslices || avctx->height % nslices) {\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n                              avctx->width, avctx->height);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    slice_height = avctx->height / nslices;\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    dst = pic->data[0];\n    for (slice = 0; slice < nslices; slice++) {\n        slice_size = bytestream2_get_le32(&gb);\n        if (slice_size > src_size - off) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n                   slice_size, src_size - off);\n            return AVERROR_INVALIDDATA;\n        }\n        if (slice_size <= 16) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\",\n                   slice_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n                   AV_RL32(src + off), slice_size - 16);\n        }\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n        dx2_decode_slice_rgb(&gb2, avctx->width, slice_height, dst,\n                             pic->linesize[0]);\n\n        dst += pic->linesize[0] * slice_height;\n        off += slice_size;\n    }\n\n    return 0;\n}", "patch_func_code": "static int dxtory_decode_v2_rgb(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    GetByteContext gb;\n    GetBitContext  gb2;\n    int nslices, slice, slice_height;\n    uint32_t off, slice_size;\n    uint8_t *dst;\n    int ret;\n\n    bytestream2_init(&gb, src, src_size);\n    nslices = bytestream2_get_le16(&gb);\n    off = FFALIGN(nslices * 4 + 2, 16);\n    if (src_size < off) {\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!nslices || avctx->height % nslices) {\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n                              avctx->width, avctx->height);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    slice_height = avctx->height / nslices;\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    dst = pic->data[0];\n    for (slice = 0; slice < nslices; slice++) {\n        slice_size = bytestream2_get_le32(&gb);\n\n        ret = check_slice_size(avctx, src, src_size, slice_size, off);\n        if (ret < 0)\n            return ret;\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n        dx2_decode_slice_rgb(&gb2, avctx->width, slice_height, dst,\n                             pic->linesize[0]);\n\n        dst += pic->linesize[0] * slice_height;\n        off += slice_size;\n    }\n\n    return 0;\n}", "before_change_lines": [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49], "raw_before_change_lines": [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49], "after_change_lines": [34, 35, 36], "raw_after_change_lines": [34, 35, 36, 37], "bug_lines": [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 16}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "235----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0de14753e6799762dbe3995570e3772b1822d075_1.json----tscc2_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0de14753e6799762dbe3995570e3772b1822d075_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0de14753e6799762dbe3995570e3772b1822d075_1.json", "function_name": "tscc2_decode_frame", "vul_func_code": "static int tscc2_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TSCC2Context *c = avctx->priv_data;\n    GetByteContext gb;\n    uint32_t frame_type, size;\n    int i, val, len, pos = 0;\n    int num_mb = c->mb_width * c->mb_height;\n    int ret;\n\n    bytestream2_init(&gb, buf, buf_size);\n    frame_type = bytestream2_get_byte(&gb);\n    if (frame_type > 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect frame type %\"PRIu32\"\\n\",\n               frame_type);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_reget_buffer(avctx, c->pic)) < 0) {\n        return ret;\n    }\n\n    if (frame_type == 0) {\n        *got_frame      = 1;\n        if ((ret = av_frame_ref(data, c->pic)) < 0)\n            return ret;\n\n        return buf_size;\n    }\n\n    if (bytestream2_get_bytes_left(&gb) < 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too short\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->quant[0] = bytestream2_get_byte(&gb);\n    c->quant[1] = bytestream2_get_byte(&gb);\n    if (c->quant[0] < 2 || c->quant[0] > NUM_VLC_SETS + 1 ||\n        c->quant[1] < 2 || c->quant[1] > NUM_VLC_SETS + 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid quantisers %d / %d\\n\",\n               c->quant[0], c->quant[1]);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < 3; i++) {\n        c->q[0][i] = tscc2_quants[c->quant[0] - 2][i];\n        c->q[1][i] = tscc2_quants[c->quant[1] - 2][i];\n    }\n\n    bytestream2_skip(&gb, 1);\n\n    size = bytestream2_get_le32(&gb);\n    if (size > bytestream2_get_bytes_left(&gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Slice properties chunk is too large\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < size; i++) {\n        val   = bytestream2_get_byte(&gb);\n        len   = val & 0x3F;\n        val >>= 6;\n        if (pos + len > num_mb) {\n            av_log(avctx, AV_LOG_ERROR, \"Too many slice properties\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        memset(c->slice_quants + pos, val, len);\n        pos += len;\n    }\n    if (pos < num_mb) {\n        av_log(avctx, AV_LOG_ERROR, \"Too few slice properties (%d / %d)\\n\",\n               pos, num_mb);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < c->mb_height; i++) {\n        size = bytestream2_peek_byte(&gb);\n        if (size & 1) {\n            size = bytestream2_get_byte(&gb) - 1;\n        } else {\n            size = bytestream2_get_le32(&gb) >> 1;\n        }\n        if (!size) {\n            int skip_row = 1, j, off = i * c->mb_width;\n            for (j = 0; j < c->mb_width; j++) {\n                if (c->slice_quants[off + j] == 1 ||\n                    c->slice_quants[off + j] == 2) {\n                    skip_row = 0;\n                    break;\n                }\n            }\n            if (!skip_row) {\n                av_log(avctx, AV_LOG_ERROR, \"Non-skip row with zero size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        if (bytestream2_get_bytes_left(&gb) < size) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice size (%\"PRIu32\"/%u)\\n\",\n                   size, bytestream2_get_bytes_left(&gb));\n            return AVERROR_INVALIDDATA;\n        }\n        ret = tscc2_decode_slice(c, i, buf + bytestream2_tell(&gb), size);\n        if (ret) {\n            av_log(avctx, AV_LOG_ERROR, \"Error decoding slice %d\\n\", i);\n            return ret;\n        }\n        bytestream2_skip(&gb, size);\n    }\n\n    *got_frame      = 1;\n    if ((ret = av_frame_ref(data, c->pic)) < 0)\n        return ret;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}", "patch_func_code": "static int tscc2_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TSCC2Context *c = avctx->priv_data;\n    GetByteContext gb;\n    uint32_t frame_type, size;\n    int i, val, len, pos = 0;\n    int num_mb = c->mb_width * c->mb_height;\n    int ret;\n\n    bytestream2_init(&gb, buf, buf_size);\n    frame_type = bytestream2_get_byte(&gb);\n    if (frame_type > 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect frame type %\"PRIu32\"\\n\",\n               frame_type);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (frame_type == 0) {\n        // Skip duplicate frames\n        return buf_size;\n    }\n\n    if ((ret = ff_reget_buffer(avctx, c->pic)) < 0) {\n        return ret;\n    }\n\n    if (bytestream2_get_bytes_left(&gb) < 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Frame is too short\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->quant[0] = bytestream2_get_byte(&gb);\n    c->quant[1] = bytestream2_get_byte(&gb);\n    if (c->quant[0] < 2 || c->quant[0] > NUM_VLC_SETS + 1 ||\n        c->quant[1] < 2 || c->quant[1] > NUM_VLC_SETS + 1) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid quantisers %d / %d\\n\",\n               c->quant[0], c->quant[1]);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < 3; i++) {\n        c->q[0][i] = tscc2_quants[c->quant[0] - 2][i];\n        c->q[1][i] = tscc2_quants[c->quant[1] - 2][i];\n    }\n\n    bytestream2_skip(&gb, 1);\n\n    size = bytestream2_get_le32(&gb);\n    if (size > bytestream2_get_bytes_left(&gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Slice properties chunk is too large\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < size; i++) {\n        val   = bytestream2_get_byte(&gb);\n        len   = val & 0x3F;\n        val >>= 6;\n        if (pos + len > num_mb) {\n            av_log(avctx, AV_LOG_ERROR, \"Too many slice properties\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        memset(c->slice_quants + pos, val, len);\n        pos += len;\n    }\n    if (pos < num_mb) {\n        av_log(avctx, AV_LOG_ERROR, \"Too few slice properties (%d / %d)\\n\",\n               pos, num_mb);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i < c->mb_height; i++) {\n        size = bytestream2_peek_byte(&gb);\n        if (size & 1) {\n            size = bytestream2_get_byte(&gb) - 1;\n        } else {\n            size = bytestream2_get_le32(&gb) >> 1;\n        }\n        if (!size) {\n            int skip_row = 1, j, off = i * c->mb_width;\n            for (j = 0; j < c->mb_width; j++) {\n                if (c->slice_quants[off + j] == 1 ||\n                    c->slice_quants[off + j] == 2) {\n                    skip_row = 0;\n                    break;\n                }\n            }\n            if (!skip_row) {\n                av_log(avctx, AV_LOG_ERROR, \"Non-skip row with zero size\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n        if (bytestream2_get_bytes_left(&gb) < size) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice size (%\"PRIu32\"/%u)\\n\",\n                   size, bytestream2_get_bytes_left(&gb));\n            return AVERROR_INVALIDDATA;\n        }\n        ret = tscc2_decode_slice(c, i, buf + bytestream2_tell(&gb), size);\n        if (ret) {\n            av_log(avctx, AV_LOG_ERROR, \"Error decoding slice %d\\n\", i);\n            return ret;\n        }\n        bytestream2_skip(&gb, size);\n    }\n\n    *got_frame      = 1;\n    if ((ret = av_frame_ref(data, c->pic)) < 0)\n        return ret;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}", "before_change_lines": [21, 22, 23, 26, 27, 28], "raw_before_change_lines": [21, 22, 23, 24, 26, 27, 28, 29], "after_change_lines": [26, 27, 28], "raw_after_change_lines": [22, 26, 27, 28, 29], "bug_lines": [21, 22, 23, 24, 26, 27, 28, 29], "added": [false, false, false, false, false, false, false, false], "idx": 17}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "251----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0ef01e07116080f9ea0b2c831c54515dce008181_1.json----av_image_get_linesize", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0ef01e07116080f9ea0b2c831c54515dce008181_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0ef01e07116080f9ea0b2c831c54515dce008181_1.json", "function_name": "av_image_get_linesize", "vul_func_code": "int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n\n    if ((unsigned)pix_fmt >= AV_PIX_FMT_NB || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)\n        return AVERROR(EINVAL);\n\n    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);\n    return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc);\n}", "patch_func_code": "int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n\n    if (!desc || desc->flags & AV_PIX_FMT_FLAG_HWACCEL)\n        return AVERROR(EINVAL);\n\n    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);\n    return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc);\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 18}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "263----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0ff2969da58abc84fef1ba005ad7555000d94456_1.json----get_qcx", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_0ff2969da58abc84fef1ba005ad7555000d94456_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_0ff2969da58abc84fef1ba005ad7555000d94456_1.json", "function_name": "get_qcx", "vul_func_code": "static int get_qcx(J2kDecoderContext *s, int n, J2kQuantStyle *q)\n{\n    int i, x;\n\n    if (s->buf_end - s->buf < 1)\n        return AVERROR(EINVAL);\n\n    x = bytestream_get_byte(&s->buf); // Sqcd\n\n    q->nguardbits = x >> 5;\n      q->quantsty = x & 0x1f;\n\n    if (q->quantsty == J2K_QSTY_NONE){\n        n -= 3;\n        if (s->buf_end - s->buf < n)\n            return AVERROR(EINVAL);\n        for (i = 0; i < n; i++)\n            q->expn[i] = bytestream_get_byte(&s->buf) >> 3;\n    } else if (q->quantsty == J2K_QSTY_SI){\n        if (s->buf_end - s->buf < 2)\n            return AVERROR(EINVAL);\n        x = bytestream_get_be16(&s->buf);\n        q->expn[0] = x >> 11;\n        q->mant[0] = x & 0x7ff;\n        for (i = 1; i < 32 * 3; i++){\n            int curexpn = FFMAX(0, q->expn[0] - (i-1)/3);\n            q->expn[i] = curexpn;\n            q->mant[i] = q->mant[0];\n        }\n    } else{\n        n = (n - 3) >> 1;\n        if (s->buf_end - s->buf < n)\n            return AVERROR(EINVAL);\n        for (i = 0; i < n; i++){\n            x = bytestream_get_be16(&s->buf);\n            q->expn[i] = x >> 11;\n            q->mant[i] = x & 0x7ff;\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int get_qcx(J2kDecoderContext *s, int n, J2kQuantStyle *q)\n{\n    int i, x;\n\n    if (s->buf_end - s->buf < 1)\n        return AVERROR(EINVAL);\n\n    x = bytestream_get_byte(&s->buf); // Sqcd\n\n    q->nguardbits = x >> 5;\n      q->quantsty = x & 0x1f;\n\n    if (q->quantsty == J2K_QSTY_NONE){\n        n -= 3;\n        if (s->buf_end - s->buf < n || 32*3 < n)\n            return AVERROR(EINVAL);\n        for (i = 0; i < n; i++)\n            q->expn[i] = bytestream_get_byte(&s->buf) >> 3;\n    } else if (q->quantsty == J2K_QSTY_SI){\n        if (s->buf_end - s->buf < 2)\n            return AVERROR(EINVAL);\n        x = bytestream_get_be16(&s->buf);\n        q->expn[0] = x >> 11;\n        q->mant[0] = x & 0x7ff;\n        for (i = 1; i < 32 * 3; i++){\n            int curexpn = FFMAX(0, q->expn[0] - (i-1)/3);\n            q->expn[i] = curexpn;\n            q->mant[i] = q->mant[0];\n        }\n    } else{\n        n = (n - 3) >> 1;\n        if (s->buf_end - s->buf < n || 32*3 < n)\n            return AVERROR(EINVAL);\n        for (i = 0; i < n; i++){\n            x = bytestream_get_be16(&s->buf);\n            q->expn[i] = x >> 11;\n            q->mant[i] = x & 0x7ff;\n        }\n    }\n    return 0;\n}", "before_change_lines": [15, 32], "raw_before_change_lines": [15, 32], "after_change_lines": [15, 32], "raw_after_change_lines": [15, 32], "bug_lines": [15, 32], "added": [false, false], "idx": 19}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "266----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_10377444b840149d827df9fc4e7e4a80554bf3c9_1.json----avi_write_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_10377444b840149d827df9fc4e7e4a80554bf3c9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_10377444b840149d827df9fc4e7e4a80554bf3c9_1.json", "function_name": "avi_write_header", "vul_func_code": "static int avi_write_header(AVFormatContext *s)\n{\n    AVIContext *avi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int bitrate, n, i, nb_frames, au_byterate, au_ssize, au_scale;\n    AVCodecParameters *video_par;\n    AVStream *video_st = NULL;\n    int64_t list1, list2, strh, strf;\n    AVDictionaryEntry *t = NULL;\n\n    if (s->nb_streams > AVI_MAX_STREAM_COUNT) {\n        av_log(s, AV_LOG_ERROR, \"AVI does not support >%d streams\\n\",\n               AVI_MAX_STREAM_COUNT);\n        return -1;\n    }\n\n    for (n = 0; n < s->nb_streams; n++) {\n        s->streams[n]->priv_data = av_mallocz(sizeof(AVIStream));\n        if (!s->streams[n]->priv_data)\n            return AVERROR(ENOMEM);\n    }\n\n    /* header list */\n    avi->riff_id = 0;\n    list1 = avi_start_new_riff(s, pb, \"AVI \", \"hdrl\");\n\n    /* avi header */\n    ffio_wfourcc(pb, \"avih\");\n    avio_wl32(pb, 14 * 4);\n    bitrate = 0;\n\n    video_par = NULL;\n    for (n = 0; n < s->nb_streams; n++) {\n        AVCodecParameters *par = s->streams[n]->codecpar;\n        bitrate += par->bit_rate;\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            video_par = par;\n            video_st = s->streams[n];\n        }\n    }\n\n    nb_frames = 0;\n\n    // TODO: should be avg_frame_rate\n    if (video_st)\n        avio_wl32(pb, (uint32_t) (INT64_C(1000000) * video_st->time_base.num /\n                                  video_st->time_base.den));\n    else\n        avio_wl32(pb, 0);\n    avio_wl32(pb, bitrate / 8); /* XXX: not quite exact */\n    avio_wl32(pb, 0); /* padding */\n    if (!pb->seekable)\n        avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_ISINTERLEAVED);  /* flags */\n    else\n        avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_HASINDEX | AVIF_ISINTERLEAVED);  /* flags */\n    avi->frames_hdr_all = avio_tell(pb); /* remember this offset to fill later */\n    avio_wl32(pb, nb_frames); /* nb frames, filled later */\n    avio_wl32(pb, 0); /* initial frame */\n    avio_wl32(pb, s->nb_streams); /* nb streams */\n    avio_wl32(pb, 1024 * 1024); /* suggested buffer size */\n    if (video_par) {\n        avio_wl32(pb, video_par->width);\n        avio_wl32(pb, video_par->height);\n    } else {\n        avio_wl32(pb, 0);\n        avio_wl32(pb, 0);\n    }\n    avio_wl32(pb, 0); /* reserved */\n    avio_wl32(pb, 0); /* reserved */\n    avio_wl32(pb, 0); /* reserved */\n    avio_wl32(pb, 0); /* reserved */\n\n    /* stream list */\n    for (i = 0; i < n; i++) {\n        AVStream *st = s->streams[i];\n        AVCodecParameters *par = st->codecpar;\n        AVIStream *avist = st->priv_data;\n        list2 = ff_start_tag(pb, \"LIST\");\n        ffio_wfourcc(pb, \"strl\");\n\n        /* stream generic header */\n        strh = ff_start_tag(pb, \"strh\");\n        switch (par->codec_type) {\n        case AVMEDIA_TYPE_SUBTITLE:\n            // XSUB subtitles behave like video tracks, other subtitles\n            // are not (yet) supported.\n            if (par->codec_id != AV_CODEC_ID_XSUB) {\n                av_log(s, AV_LOG_ERROR,\n                       \"Subtitle streams other than DivX XSUB are not supported by the AVI muxer.\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n        case AVMEDIA_TYPE_VIDEO:\n            ffio_wfourcc(pb, \"vids\");\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            ffio_wfourcc(pb, \"auds\");\n            break;\n//      case AVMEDIA_TYPE_TEXT:\n//          ffio_wfourcc(pb, \"txts\");\n//          break;\n        case AVMEDIA_TYPE_DATA:\n            ffio_wfourcc(pb, \"dats\");\n            break;\n        }\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO ||\n            par->codec_id == AV_CODEC_ID_XSUB)\n            avio_wl32(pb, par->codec_tag);\n        else\n            avio_wl32(pb, 1);\n        avio_wl32(pb, 0); /* flags */\n        avio_wl16(pb, 0); /* priority */\n        avio_wl16(pb, 0); /* language */\n        avio_wl32(pb, 0); /* initial frame */\n\n        ff_parse_specific_params(st, &au_byterate, &au_ssize, &au_scale);\n\n        avio_wl32(pb, au_scale); /* scale */\n        avio_wl32(pb, au_byterate); /* rate */\n        avpriv_set_pts_info(st, 64, au_scale, au_byterate);\n\n        avio_wl32(pb, 0); /* start */\n        /* remember this offset to fill later */\n        avist->frames_hdr_strm = avio_tell(pb);\n        if (!pb->seekable)\n            /* FIXME: this may be broken, but who cares */\n            avio_wl32(pb, AVI_MAX_RIFF_SIZE);\n        else\n            avio_wl32(pb, 0);  /* length, XXX: filled later */\n\n        /* suggested buffer size */ //FIXME set at the end to largest chunk\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO)\n            avio_wl32(pb, 1024 * 1024);\n        else if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n            avio_wl32(pb, 12 * 1024);\n        else\n            avio_wl32(pb, 0);\n        avio_wl32(pb, -1); /* quality */\n        avio_wl32(pb, au_ssize); /* sample size */\n        avio_wl32(pb, 0);\n        avio_wl16(pb, par->width);\n        avio_wl16(pb, par->height);\n        ff_end_tag(pb, strh);\n\n        if (par->codec_type != AVMEDIA_TYPE_DATA) {\n            strf = ff_start_tag(pb, \"strf\");\n            switch (par->codec_type) {\n            case AVMEDIA_TYPE_SUBTITLE:\n                /* XSUB subtitles behave like video tracks, other subtitles\n                 * are not (yet) supported. */\n                if (par->codec_id != AV_CODEC_ID_XSUB)\n                    break;\n            case AVMEDIA_TYPE_VIDEO:\n                ff_put_bmp_header(pb, par, ff_codec_bmp_tags, 0);\n                break;\n            case AVMEDIA_TYPE_AUDIO:\n                if (ff_put_wav_header(s, pb, par) < 0)\n                    return -1;\n                break;\n            default:\n                return -1;\n            }\n            ff_end_tag(pb, strf);\n            if ((t = av_dict_get(st->metadata, \"title\", NULL, 0))) {\n                ff_riff_write_info_tag(s->pb, \"strn\", t->value);\n                t = NULL;\n            }\n        }\n\n        if (pb->seekable) {\n            unsigned char tag[5];\n            int j;\n\n            /* Starting to lay out AVI OpenDML master index.\n             * We want to make it JUNK entry for now, since we'd\n             * like to get away without making AVI an OpenDML one\n             * for compatibility reasons. */\n            avist->indexes.entry      = avist->indexes.ents_allocated = 0;\n            avist->indexes.indx_start = ff_start_tag(pb, \"JUNK\");\n            avio_wl16(pb, 4);   /* wLongsPerEntry */\n            avio_w8(pb, 0);     /* bIndexSubType (0 == frame index) */\n            avio_w8(pb, 0);     /* bIndexType (0 == AVI_INDEX_OF_INDEXES) */\n            avio_wl32(pb, 0);   /* nEntriesInUse (will fill out later on) */\n            ffio_wfourcc(pb, avi_stream2fourcc(tag, i, par->codec_type));\n                                /* dwChunkId */\n            avio_wl64(pb, 0);   /* dwReserved[3] */\n            // avio_wl32(pb, 0);   /* Must be 0.    */\n            for (j = 0; j < AVI_MASTER_INDEX_SIZE * 2; j++)\n                avio_wl64(pb, 0);\n            ff_end_tag(pb, avist->indexes.indx_start);\n        }\n\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO   &&\n            st->sample_aspect_ratio.num > 0 &&\n            st->sample_aspect_ratio.den > 0) {\n            int vprp       = ff_start_tag(pb, \"vprp\");\n            AVRational dar = av_mul_q(st->sample_aspect_ratio,\n                                      (AVRational) { par->width,\n                                                     par->height });\n            int num, den;\n            av_reduce(&num, &den, dar.num, dar.den, 0xFFFF);\n\n            avio_wl32(pb, 0); // video format   = unknown\n            avio_wl32(pb, 0); // video standard = unknown\n            // TODO: should be avg_frame_rate\n            avio_wl32(pb, lrintf(1.0 / av_q2d(st->time_base)));\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, par->height);\n            avio_wl16(pb, den);\n            avio_wl16(pb, num);\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, par->height);\n            avio_wl32(pb, 1); // progressive FIXME\n\n            avio_wl32(pb, par->height);\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, par->height);\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, 0);\n            avio_wl32(pb, 0);\n\n            avio_wl32(pb, 0);\n            avio_wl32(pb, 0);\n            ff_end_tag(pb, vprp);\n        }\n\n        ff_end_tag(pb, list2);\n    }\n\n    if (pb->seekable) {\n        /* AVI could become an OpenDML one, if it grows beyond 2Gb range */\n        avi->odml_list = ff_start_tag(pb, \"JUNK\");\n        ffio_wfourcc(pb, \"odml\");\n        ffio_wfourcc(pb, \"dmlh\");\n        avio_wl32(pb, 248);\n        for (i = 0; i < 248; i += 4)\n            avio_wl32(pb, 0);\n        ff_end_tag(pb, avi->odml_list);\n    }\n\n    ff_end_tag(pb, list1);\n\n    ff_riff_write_info(s);\n\n    /* some padding for easier tag editing */\n    list2 = ff_start_tag(pb, \"JUNK\");\n    for (i = 0; i < 1016; i += 4)\n        avio_wl32(pb, 0);\n    ff_end_tag(pb, list2);\n\n    avi->movi_list = ff_start_tag(pb, \"LIST\");\n    ffio_wfourcc(pb, \"movi\");\n\n    avio_flush(pb);\n\n    return 0;\n}", "patch_func_code": "static int avi_write_header(AVFormatContext *s)\n{\n    AVIContext *avi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int bitrate, n, i, nb_frames, au_byterate, au_ssize, au_scale;\n    AVCodecParameters *video_par;\n    AVStream *video_st = NULL;\n    int64_t list1, list2, strh, strf;\n    AVDictionaryEntry *t = NULL;\n\n    if (s->nb_streams > AVI_MAX_STREAM_COUNT) {\n        av_log(s, AV_LOG_ERROR, \"AVI does not support >%d streams\\n\",\n               AVI_MAX_STREAM_COUNT);\n        return -1;\n    }\n\n    for (n = 0; n < s->nb_streams; n++) {\n        s->streams[n]->priv_data = av_mallocz(sizeof(AVIStream));\n        if (!s->streams[n]->priv_data)\n            return AVERROR(ENOMEM);\n    }\n\n    /* header list */\n    avi->riff_id = 0;\n    list1 = avi_start_new_riff(s, pb, \"AVI \", \"hdrl\");\n\n    /* avi header */\n    ffio_wfourcc(pb, \"avih\");\n    avio_wl32(pb, 14 * 4);\n    bitrate = 0;\n\n    video_par = NULL;\n    for (n = 0; n < s->nb_streams; n++) {\n        AVCodecParameters *par = s->streams[n]->codecpar;\n        bitrate += par->bit_rate;\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n            video_par = par;\n            video_st = s->streams[n];\n        }\n    }\n\n    nb_frames = 0;\n\n    // TODO: should be avg_frame_rate\n    if (video_st)\n        avio_wl32(pb, (uint32_t) (INT64_C(1000000) * video_st->time_base.num /\n                                  video_st->time_base.den));\n    else\n        avio_wl32(pb, 0);\n    avio_wl32(pb, bitrate / 8); /* XXX: not quite exact */\n    avio_wl32(pb, 0); /* padding */\n    if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))\n        avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_ISINTERLEAVED);  /* flags */\n    else\n        avio_wl32(pb, AVIF_TRUSTCKTYPE | AVIF_HASINDEX | AVIF_ISINTERLEAVED);  /* flags */\n    avi->frames_hdr_all = avio_tell(pb); /* remember this offset to fill later */\n    avio_wl32(pb, nb_frames); /* nb frames, filled later */\n    avio_wl32(pb, 0); /* initial frame */\n    avio_wl32(pb, s->nb_streams); /* nb streams */\n    avio_wl32(pb, 1024 * 1024); /* suggested buffer size */\n    if (video_par) {\n        avio_wl32(pb, video_par->width);\n        avio_wl32(pb, video_par->height);\n    } else {\n        avio_wl32(pb, 0);\n        avio_wl32(pb, 0);\n    }\n    avio_wl32(pb, 0); /* reserved */\n    avio_wl32(pb, 0); /* reserved */\n    avio_wl32(pb, 0); /* reserved */\n    avio_wl32(pb, 0); /* reserved */\n\n    /* stream list */\n    for (i = 0; i < n; i++) {\n        AVStream *st = s->streams[i];\n        AVCodecParameters *par = st->codecpar;\n        AVIStream *avist = st->priv_data;\n        list2 = ff_start_tag(pb, \"LIST\");\n        ffio_wfourcc(pb, \"strl\");\n\n        /* stream generic header */\n        strh = ff_start_tag(pb, \"strh\");\n        switch (par->codec_type) {\n        case AVMEDIA_TYPE_SUBTITLE:\n            // XSUB subtitles behave like video tracks, other subtitles\n            // are not (yet) supported.\n            if (par->codec_id != AV_CODEC_ID_XSUB) {\n                av_log(s, AV_LOG_ERROR,\n                       \"Subtitle streams other than DivX XSUB are not supported by the AVI muxer.\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n        case AVMEDIA_TYPE_VIDEO:\n            ffio_wfourcc(pb, \"vids\");\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            ffio_wfourcc(pb, \"auds\");\n            break;\n//      case AVMEDIA_TYPE_TEXT:\n//          ffio_wfourcc(pb, \"txts\");\n//          break;\n        case AVMEDIA_TYPE_DATA:\n            ffio_wfourcc(pb, \"dats\");\n            break;\n        }\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO ||\n            par->codec_id == AV_CODEC_ID_XSUB)\n            avio_wl32(pb, par->codec_tag);\n        else\n            avio_wl32(pb, 1);\n        avio_wl32(pb, 0); /* flags */\n        avio_wl16(pb, 0); /* priority */\n        avio_wl16(pb, 0); /* language */\n        avio_wl32(pb, 0); /* initial frame */\n\n        ff_parse_specific_params(st, &au_byterate, &au_ssize, &au_scale);\n\n        avio_wl32(pb, au_scale); /* scale */\n        avio_wl32(pb, au_byterate); /* rate */\n        avpriv_set_pts_info(st, 64, au_scale, au_byterate);\n\n        avio_wl32(pb, 0); /* start */\n        /* remember this offset to fill later */\n        avist->frames_hdr_strm = avio_tell(pb);\n        if (!(pb->seekable & AVIO_SEEKABLE_NORMAL))\n            /* FIXME: this may be broken, but who cares */\n            avio_wl32(pb, AVI_MAX_RIFF_SIZE);\n        else\n            avio_wl32(pb, 0);  /* length, XXX: filled later */\n\n        /* suggested buffer size */ //FIXME set at the end to largest chunk\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO)\n            avio_wl32(pb, 1024 * 1024);\n        else if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n            avio_wl32(pb, 12 * 1024);\n        else\n            avio_wl32(pb, 0);\n        avio_wl32(pb, -1); /* quality */\n        avio_wl32(pb, au_ssize); /* sample size */\n        avio_wl32(pb, 0);\n        avio_wl16(pb, par->width);\n        avio_wl16(pb, par->height);\n        ff_end_tag(pb, strh);\n\n        if (par->codec_type != AVMEDIA_TYPE_DATA) {\n            strf = ff_start_tag(pb, \"strf\");\n            switch (par->codec_type) {\n            case AVMEDIA_TYPE_SUBTITLE:\n                /* XSUB subtitles behave like video tracks, other subtitles\n                 * are not (yet) supported. */\n                if (par->codec_id != AV_CODEC_ID_XSUB)\n                    break;\n            case AVMEDIA_TYPE_VIDEO:\n                ff_put_bmp_header(pb, par, ff_codec_bmp_tags, 0);\n                break;\n            case AVMEDIA_TYPE_AUDIO:\n                if (ff_put_wav_header(s, pb, par) < 0)\n                    return -1;\n                break;\n            default:\n                return -1;\n            }\n            ff_end_tag(pb, strf);\n            if ((t = av_dict_get(st->metadata, \"title\", NULL, 0))) {\n                ff_riff_write_info_tag(s->pb, \"strn\", t->value);\n                t = NULL;\n            }\n        }\n\n        if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n            unsigned char tag[5];\n            int j;\n\n            /* Starting to lay out AVI OpenDML master index.\n             * We want to make it JUNK entry for now, since we'd\n             * like to get away without making AVI an OpenDML one\n             * for compatibility reasons. */\n            avist->indexes.entry      = avist->indexes.ents_allocated = 0;\n            avist->indexes.indx_start = ff_start_tag(pb, \"JUNK\");\n            avio_wl16(pb, 4);   /* wLongsPerEntry */\n            avio_w8(pb, 0);     /* bIndexSubType (0 == frame index) */\n            avio_w8(pb, 0);     /* bIndexType (0 == AVI_INDEX_OF_INDEXES) */\n            avio_wl32(pb, 0);   /* nEntriesInUse (will fill out later on) */\n            ffio_wfourcc(pb, avi_stream2fourcc(tag, i, par->codec_type));\n                                /* dwChunkId */\n            avio_wl64(pb, 0);   /* dwReserved[3] */\n            // avio_wl32(pb, 0);   /* Must be 0.    */\n            for (j = 0; j < AVI_MASTER_INDEX_SIZE * 2; j++)\n                avio_wl64(pb, 0);\n            ff_end_tag(pb, avist->indexes.indx_start);\n        }\n\n        if (par->codec_type == AVMEDIA_TYPE_VIDEO   &&\n            st->sample_aspect_ratio.num > 0 &&\n            st->sample_aspect_ratio.den > 0) {\n            int vprp       = ff_start_tag(pb, \"vprp\");\n            AVRational dar = av_mul_q(st->sample_aspect_ratio,\n                                      (AVRational) { par->width,\n                                                     par->height });\n            int num, den;\n            av_reduce(&num, &den, dar.num, dar.den, 0xFFFF);\n\n            avio_wl32(pb, 0); // video format   = unknown\n            avio_wl32(pb, 0); // video standard = unknown\n            // TODO: should be avg_frame_rate\n            avio_wl32(pb, lrintf(1.0 / av_q2d(st->time_base)));\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, par->height);\n            avio_wl16(pb, den);\n            avio_wl16(pb, num);\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, par->height);\n            avio_wl32(pb, 1); // progressive FIXME\n\n            avio_wl32(pb, par->height);\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, par->height);\n            avio_wl32(pb, par->width);\n            avio_wl32(pb, 0);\n            avio_wl32(pb, 0);\n\n            avio_wl32(pb, 0);\n            avio_wl32(pb, 0);\n            ff_end_tag(pb, vprp);\n        }\n\n        ff_end_tag(pb, list2);\n    }\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        /* AVI could become an OpenDML one, if it grows beyond 2Gb range */\n        avi->odml_list = ff_start_tag(pb, \"JUNK\");\n        ffio_wfourcc(pb, \"odml\");\n        ffio_wfourcc(pb, \"dmlh\");\n        avio_wl32(pb, 248);\n        for (i = 0; i < 248; i += 4)\n            avio_wl32(pb, 0);\n        ff_end_tag(pb, avi->odml_list);\n    }\n\n    ff_end_tag(pb, list1);\n\n    ff_riff_write_info(s);\n\n    /* some padding for easier tag editing */\n    list2 = ff_start_tag(pb, \"JUNK\");\n    for (i = 0; i < 1016; i += 4)\n        avio_wl32(pb, 0);\n    ff_end_tag(pb, list2);\n\n    avi->movi_list = ff_start_tag(pb, \"LIST\");\n    ffio_wfourcc(pb, \"movi\");\n\n    avio_flush(pb);\n\n    return 0;\n}", "before_change_lines": [52, 124, 169, 229], "raw_before_change_lines": [52, 124, 169, 229], "after_change_lines": [52, 124, 169, 229], "raw_after_change_lines": [52, 124, 169, 229], "bug_lines": [52, 124, 169, 229], "added": [false, false, false, false], "idx": 20}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "286----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_11ac454ba0552583439dd3011dbdb23528528a7a_1.json----alloc_sequence_buffers", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_11ac454ba0552583439dd3011dbdb23528528a7a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_11ac454ba0552583439dd3011dbdb23528528a7a_1.json", "function_name": "alloc_sequence_buffers", "vul_func_code": "static int alloc_sequence_buffers(DiracContext *s)\n{\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n    int sbheight = DIVRNDUP(s->source.height, 4);\n    int i, w, h, top_padding;\n\n    /* todo: think more about this / use or set Plane here */\n    for (i = 0; i < 3; i++) {\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n        /* we allocate the max we support here since num decompositions can\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n         * on each side */\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n        s->plane[i].idwt_buf_base = av_mallocz_array((w+max_xblen), h * sizeof(IDWTELEM));\n        s->plane[i].idwt_tmp      = av_malloc_array((w+16), sizeof(IDWTELEM));\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    w = s->source.width;\n    h = s->source.height;\n\n    /* fixme: allocate using real stride here */\n    s->sbsplit  = av_malloc_array(sbwidth, sbheight);\n    s->blmotion = av_malloc_array(sbwidth, sbheight * 16 * sizeof(*s->blmotion));\n    s->edge_emu_buffer_base = av_malloc_array((w+64), MAX_BLOCKSIZE);\n\n    s->mctmp     = av_malloc_array((w+64+MAX_BLOCKSIZE), (h+MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n    s->mcscratch = av_malloc_array((w+64), MAX_BLOCKSIZE);\n\n    if (!s->sbsplit || !s->blmotion || !s->mctmp || !s->mcscratch)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "patch_func_code": "static int alloc_sequence_buffers(DiracContext *s)\n{\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n    int sbheight = DIVRNDUP(s->source.height, 4);\n    int i, w, h, top_padding;\n\n    /* todo: think more about this / use or set Plane here */\n    for (i = 0; i < 3; i++) {\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n        /* we allocate the max we support here since num decompositions can\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n         * on each side */\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n        s->plane[i].idwt_buf_base = av_mallocz_array((w+max_xblen), h * sizeof(IDWTELEM));\n        s->plane[i].idwt_tmp      = av_malloc_array((w+16), sizeof(IDWTELEM));\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n            return AVERROR(ENOMEM);\n    }\n\n    /* fixme: allocate using real stride here */\n    s->sbsplit  = av_malloc_array(sbwidth, sbheight);\n    s->blmotion = av_malloc_array(sbwidth, sbheight * 16 * sizeof(*s->blmotion));\n\n    if (!s->sbsplit || !s->blmotion)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "before_change_lines": [30, 31, 36, 38, 39, 41], "raw_before_change_lines": [30, 31, 32, 36, 38, 39, 41], "after_change_lines": [34, 35, 36, 37], "raw_after_change_lines": [34, 35, 36, 37], "bug_lines": [30, 31, 32, 36, 38, 39, 41], "added": [false, false, false, false, false, false, false], "idx": 21}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "290----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_11f75d1b5e115cf7a6cdb8848d6ff529cec81f3b_1.json----av_reallocp_array", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_11f75d1b5e115cf7a6cdb8848d6ff529cec81f3b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_11f75d1b5e115cf7a6cdb8848d6ff529cec81f3b_1.json", "function_name": "av_reallocp_array", "vul_func_code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "patch_func_code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && nmemb && size)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5], "added": [false], "idx": 22}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "305----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_128f727236544c25a169d4a5c3e91b55ec4da604_1.json----show_packets", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_128f727236544c25a169d4a5c3e91b55ec4da604_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_128f727236544c25a169d4a5c3e91b55ec4da604_1.json", "function_name": "show_packets", "vul_func_code": "static void show_packets(AVFormatContext *fmt_ctx)\n{\n    AVPacket pkt;\n\n    av_init_packet(&pkt);\n    probe_array_header(\"packets\", 0);\n    while (!av_read_frame(fmt_ctx, &pkt))\n        show_packet(fmt_ctx, &pkt);\n    probe_array_footer(\"packets\", 0);\n}", "patch_func_code": "static void show_packets(AVFormatContext *fmt_ctx)\n{\n    AVPacket pkt;\n\n    av_init_packet(&pkt);\n    probe_array_header(\"packets\", 0);\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n        show_packet(fmt_ctx, &pkt);\n        av_packet_unref(&pkt);\n    }\n    probe_array_footer(\"packets\", 0);\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7, 9, 10], "raw_after_change_lines": [7, 9, 10], "bug_lines": [7], "added": [false], "idx": 23}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "316----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_131d5e3899f250ff8f545b5f2e1c0b582267b886_1.json----adx_read_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_131d5e3899f250ff8f545b5f2e1c0b582267b886_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_131d5e3899f250ff8f545b5f2e1c0b582267b886_1.json", "function_name": "adx_read_header", "vul_func_code": "static int adx_read_header(AVFormatContext *s)\n{\n    ADXDemuxerContext *c = s->priv_data;\n    AVCodecParameters *par;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    par = s->streams[0]->codecpar;\n\n    if (avio_rb16(s->pb) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    c->header_size = avio_rb16(s->pb) + 4;\n    avio_seek(s->pb, -4, SEEK_CUR);\n\n    if (ff_get_extradata(s, par, s->pb, c->header_size) < 0)\n        return AVERROR(ENOMEM);\n\n    if (par->extradata_size < 12) {\n        av_log(s, AV_LOG_ERROR, \"Invalid extradata size.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    par->channels    = AV_RB8 (par->extradata + 7);\n    par->sample_rate = AV_RB32(par->extradata + 8);\n\n    if (par->channels <= 0) {\n        av_log(s, AV_LOG_ERROR, \"invalid number of channels %d\\n\", par->channels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (par->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", par->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    par->codec_type  = AVMEDIA_TYPE_AUDIO;\n    par->codec_id    = s->iformat->raw_codec_id;\n    par->bit_rate    = par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;\n\n    avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate);\n\n    return 0;\n}", "patch_func_code": "static int adx_read_header(AVFormatContext *s)\n{\n    ADXDemuxerContext *c = s->priv_data;\n    AVCodecParameters *par;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    par = s->streams[0]->codecpar;\n\n    if (avio_rb16(s->pb) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    c->header_size = avio_rb16(s->pb) + 4;\n    avio_seek(s->pb, -4, SEEK_CUR);\n\n    if (ff_get_extradata(s, par, s->pb, c->header_size) < 0)\n        return AVERROR(ENOMEM);\n\n    if (par->extradata_size < 12) {\n        av_log(s, AV_LOG_ERROR, \"Invalid extradata size.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    par->channels    = AV_RB8 (par->extradata + 7);\n    par->sample_rate = AV_RB32(par->extradata + 8);\n\n    if (par->channels <= 0) {\n        av_log(s, AV_LOG_ERROR, \"invalid number of channels %d\\n\", par->channels);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (par->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", par->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    par->codec_type  = AVMEDIA_TYPE_AUDIO;\n    par->codec_id    = s->iformat->raw_codec_id;\n    par->bit_rate    = (int64_t)par->sample_rate * par->channels * BLOCK_SIZE * 8LL / BLOCK_SAMPLES;\n\n    avpriv_set_pts_info(st, 64, BLOCK_SAMPLES, par->sample_rate);\n\n    return 0;\n}", "before_change_lines": [38], "raw_before_change_lines": [38], "after_change_lines": [38], "raw_after_change_lines": [38], "bug_lines": [38], "added": [false], "idx": 24}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "360----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_154dc68c474a3d56a3531d66ff351c690b3c4230_1.json----mpeg_er_decode_mb", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_154dc68c474a3d56a3531d66ff351c690b3c4230_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_154dc68c474a3d56a3531d66ff351c690b3c4230_1.json", "function_name": "mpeg_er_decode_mb", "vul_func_code": "static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n                              int (*mv)[2][4][2],\n                              int mb_x, int mb_y, int mb_intra, int mb_skipped)\n{\n    MpegEncContext *s = opaque;\n\n    s->mv_dir     = mv_dir;\n    s->mv_type    = mv_type;\n    s->mb_intra   = mb_intra;\n    s->mb_skipped = mb_skipped;\n    s->mb_x       = mb_x;\n    s->mb_y       = mb_y;\n    memcpy(s->mv, mv, sizeof(*mv));\n\n    ff_init_block_index(s);\n    ff_update_block_index(s);\n\n    s->dsp.clear_blocks(s->block[0]);\n\n    s->dest[0] = s->current_picture.f.data[0] + (s->mb_y *  16                       * s->linesize)   + s->mb_x *  16;\n    s->dest[1] = s->current_picture.f.data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);\n    s->dest[2] = s->current_picture.f.data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);\n\n    assert(ref == 0);\n    ff_MPV_decode_mb(s, s->block);\n}", "patch_func_code": "static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n                              int (*mv)[2][4][2],\n                              int mb_x, int mb_y, int mb_intra, int mb_skipped)\n{\n    MpegEncContext *s = opaque;\n\n    s->mv_dir     = mv_dir;\n    s->mv_type    = mv_type;\n    s->mb_intra   = mb_intra;\n    s->mb_skipped = mb_skipped;\n    s->mb_x       = mb_x;\n    s->mb_y       = mb_y;\n    memcpy(s->mv, mv, sizeof(*mv));\n\n    ff_init_block_index(s);\n    ff_update_block_index(s);\n\n    s->dsp.clear_blocks(s->block[0]);\n\n    s->dest[0] = s->current_picture.f->data[0] + (s->mb_y *  16                       * s->linesize)   + s->mb_x *  16;\n    s->dest[1] = s->current_picture.f->data[1] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);\n    s->dest[2] = s->current_picture.f->data[2] + (s->mb_y * (16 >> s->chroma_y_shift) * s->uvlinesize) + s->mb_x * (16 >> s->chroma_x_shift);\n\n    assert(ref == 0);\n    ff_MPV_decode_mb(s, s->block);\n}", "before_change_lines": [20, 21, 22], "raw_before_change_lines": [20, 21, 22], "after_change_lines": [20, 21, 22], "raw_after_change_lines": [20, 21, 22], "bug_lines": [20, 21, 22], "added": [false, false, false], "idx": 25}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "382----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_16560b07277aec13fc540d047e21145823f71429_1.json----compand_delay", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_16560b07277aec13fc540d047e21145823f71429_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_16560b07277aec13fc540d047e21145823f71429_1.json", "function_name": "compand_delay", "vul_func_code": "static int compand_delay(AVFilterContext *ctx, AVFrame *frame)\n{\n    CompandContext *s    = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    const int channels = inlink->channels;\n    const int nb_samples = frame->nb_samples;\n    int chan, i, av_uninit(dindex), oindex, av_uninit(count);\n    AVFrame *out_frame   = NULL;\n\n    if (s->pts == AV_NOPTS_VALUE) {\n        s->pts = (frame->pts == AV_NOPTS_VALUE) ? 0 : frame->pts;\n    }\n\n    av_assert1(channels > 0); /* would corrupt delay_count and delay_index */\n\n    for (chan = 0; chan < channels; chan++) {\n        AVFrame *delay_frame = s->delay_frame;\n        const double *src = (double *)frame->extended_data[chan];\n        double *dbuf      = (double *)delay_frame->extended_data[chan];\n        ChanParam *cp        = &s->channels[chan];\n        double *dst;\n\n        count  = s->delay_count;\n        dindex = s->delay_index;\n        for (i = 0, oindex = 0; i < nb_samples; i++) {\n            const double in = src[i];\n            update_volume(cp, fabs(in));\n\n            if (count >= s->delay_samples) {\n                if (!out_frame) {\n                    out_frame = ff_get_audio_buffer(inlink, nb_samples - i);\n                    if (!out_frame) {\n                        av_frame_free(&frame);\n                        return AVERROR(ENOMEM);\n                    }\n                    av_frame_copy_props(out_frame, frame);\n                    out_frame->pts = s->pts;\n                    s->pts += av_rescale_q(nb_samples - i,\n                        (AVRational){ 1, inlink->sample_rate },\n                        inlink->time_base);\n                }\n\n                dst = (double *)out_frame->extended_data[chan];\n                dst[oindex++] = av_clipd(dbuf[dindex] *\n                        get_volume(s, cp->volume), -1, 1);\n            } else {\n                count++;\n            }\n\n            dbuf[dindex] = in;\n            dindex = MOD(dindex + 1, s->delay_samples);\n        }\n    }\n\n    s->delay_count = count;\n    s->delay_index = dindex;\n\n    av_frame_free(&frame);\n    return out_frame ? ff_filter_frame(ctx->outputs[0], out_frame) : 0;\n}", "patch_func_code": "static int compand_delay(AVFilterContext *ctx, AVFrame *frame)\n{\n    CompandContext *s    = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    const int channels = inlink->channels;\n    const int nb_samples = frame->nb_samples;\n    int chan, i, av_uninit(dindex), oindex, av_uninit(count);\n    AVFrame *out_frame   = NULL;\n    int err;\n\n    if (s->pts == AV_NOPTS_VALUE) {\n        s->pts = (frame->pts == AV_NOPTS_VALUE) ? 0 : frame->pts;\n    }\n\n    av_assert1(channels > 0); /* would corrupt delay_count and delay_index */\n\n    for (chan = 0; chan < channels; chan++) {\n        AVFrame *delay_frame = s->delay_frame;\n        const double *src = (double *)frame->extended_data[chan];\n        double *dbuf      = (double *)delay_frame->extended_data[chan];\n        ChanParam *cp        = &s->channels[chan];\n        double *dst;\n\n        count  = s->delay_count;\n        dindex = s->delay_index;\n        for (i = 0, oindex = 0; i < nb_samples; i++) {\n            const double in = src[i];\n            update_volume(cp, fabs(in));\n\n            if (count >= s->delay_samples) {\n                if (!out_frame) {\n                    out_frame = ff_get_audio_buffer(inlink, nb_samples - i);\n                    if (!out_frame) {\n                        av_frame_free(&frame);\n                        return AVERROR(ENOMEM);\n                    }\n                    err = av_frame_copy_props(out_frame, frame);\n                    if (err < 0) {\n                        av_frame_free(&out_frame);\n                        av_frame_free(&frame);\n                        return err;\n                    }\n                    out_frame->pts = s->pts;\n                    s->pts += av_rescale_q(nb_samples - i,\n                        (AVRational){ 1, inlink->sample_rate },\n                        inlink->time_base);\n                }\n\n                dst = (double *)out_frame->extended_data[chan];\n                dst[oindex++] = av_clipd(dbuf[dindex] *\n                        get_volume(s, cp->volume), -1, 1);\n            } else {\n                count++;\n            }\n\n            dbuf[dindex] = in;\n            dindex = MOD(dindex + 1, s->delay_samples);\n        }\n    }\n\n    s->delay_count = count;\n    s->delay_index = dindex;\n\n    av_frame_free(&frame);\n    return out_frame ? ff_filter_frame(ctx->outputs[0], out_frame) : 0;\n}", "before_change_lines": [36], "raw_before_change_lines": [36], "after_change_lines": [9, 37, 38, 39, 40, 41, 42], "raw_after_change_lines": [9, 37, 38, 39, 40, 41, 42], "bug_lines": [36], "added": [false], "idx": 26}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "383----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_16590fc2ce552cf93b81ed0cef14e77faa24a66e_1.json----sync", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_16590fc2ce552cf93b81ed0cef14e77faa24a66e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_16590fc2ce552cf93b81ed0cef14e77faa24a66e_1.json", "function_name": "sync", "vul_func_code": "static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    ByteIOContext *pb = s->pb;\n    int len, num, res, i;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n\n    while(!url_feof(pb)){\n        *pos= url_ftell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + get_byte(pb);\n\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                len = get_be16(pb) - 6;\n                if(len<0)\n                    continue;\n                goto skip;\n            }\n\n            if(state > (unsigned)0xFFFF || state < 12)\n                continue;\n            len=state;\n            state= 0xFFFFFFFF;\n\n            num = get_be16(pb);\n            *timestamp = get_be32(pb);\n            res= get_byte(pb); /* reserved */\n            *flags = get_byte(pb); /* flags */\n\n\n            len -= 12;\n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            /* skip packet if unknown number */\n            url_fskip(pb, len);\n            rm->remaining_len -= len;\n            continue;\n        }\n        *stream_index= i;\n\n        return len;\n    }\n    return -1;\n}", "patch_func_code": "static int sync(AVFormatContext *s, int64_t *timestamp, int *flags, int *stream_index, int64_t *pos){\n    RMDemuxContext *rm = s->priv_data;\n    ByteIOContext *pb = s->pb;\n    int len, num, res, i;\n    AVStream *st;\n    uint32_t state=0xFFFFFFFF;\n\n    while(!url_feof(pb)){\n        *pos= url_ftell(pb) - 3;\n        if(rm->remaining_len > 0){\n            num= rm->current_stream;\n            len= rm->remaining_len;\n            *timestamp = AV_NOPTS_VALUE;\n            *flags= 0;\n        }else{\n            state= (state<<8) + get_byte(pb);\n\n            if(state == MKBETAG('I', 'N', 'D', 'X')){\n                len = get_be16(pb) - 6;\n                if(len<0)\n                    continue;\n                goto skip;\n            }\n\n            if(state > (unsigned)0xFFFF || state < 12)\n                continue;\n            len=state;\n            state= 0xFFFFFFFF;\n\n            num = get_be16(pb);\n            *timestamp = get_be32(pb);\n            res= get_byte(pb); /* reserved */\n            *flags = get_byte(pb); /* flags */\n\n\n            len -= 12;\n        }\n        for(i=0;i<s->nb_streams;i++) {\n            st = s->streams[i];\n            if (num == st->id)\n                break;\n        }\n        if (i == s->nb_streams) {\nskip:\n            /* skip packet if unknown number */\n            url_fskip(pb, len);\n            rm->remaining_len = 0;\n            continue;\n        }\n        *stream_index= i;\n\n        return len;\n    }\n    return -1;\n}", "before_change_lines": [47], "raw_before_change_lines": [47], "after_change_lines": [47], "raw_after_change_lines": [47], "bug_lines": [47], "added": [false], "idx": 27}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "385----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_166a6aa90fbb9a2458a28b936f85c8952e9a2098_1.json----compute_images_mse", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_166a6aa90fbb9a2458a28b936f85c8952e9a2098_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_166a6aa90fbb9a2458a28b936f85c8952e9a2098_1.json", "function_name": "compute_images_mse", "vul_func_code": "static inline\nvoid compute_images_mse(PSNRContext *s,\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n                        int w, int h, double mse[4])\n{\n    int i, c, j;\n\n    for (c = 0; c < s->nb_components; c++) {\n        const int outw = s->planewidth[c];\n        const int outh = s->planeheight[c];\n        const uint8_t *main_line = main_data[c];\n        const uint8_t *ref_line = ref_data[c];\n        const int ref_linesize = ref_linesizes[c];\n        const int main_linesize = main_linesizes[c];\n        int m = 0;\n\n        for (i = 0; i < outh; i++) {\n            for (j = 0; j < outw; j++)\n                m += pow2(main_line[j] - ref_line[j]);\n            ref_line += ref_linesize;\n            main_line += main_linesize;\n        }\n        mse[c] = m / (double)(outw * outh);\n    }\n}", "patch_func_code": "static inline\nvoid compute_images_mse(PSNRContext *s,\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n                        int w, int h, double mse[4])\n{\n    int i, c, j;\n\n    for (c = 0; c < s->nb_components; c++) {\n        const int outw = s->planewidth[c];\n        const int outh = s->planeheight[c];\n        const uint8_t *main_line = main_data[c];\n        const uint8_t *ref_line = ref_data[c];\n        const int ref_linesize = ref_linesizes[c];\n        const int main_linesize = main_linesizes[c];\n        uint64_t m = 0;\n\n        for (i = 0; i < outh; i++) {\n            for (j = 0; j < outw; j++)\n                m += pow2(main_line[j] - ref_line[j]);\n            ref_line += ref_linesize;\n            main_line += main_linesize;\n        }\n        mse[c] = m / (double)(outw * outh);\n    }\n}", "before_change_lines": [16], "raw_before_change_lines": [16], "after_change_lines": [16], "raw_after_change_lines": [16], "bug_lines": [16], "added": [false], "idx": 28}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "434----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_18cb71162f5a52881ba3481f8f20296b9587049e_1.json----ff_interleave_add_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_18cb71162f5a52881ba3481f8f20296b9587049e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_18cb71162f5a52881ba3481f8f20296b9587049e_1.json", "function_name": "ff_interleave_add_packet", "vul_func_code": "void ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,\n                              int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\n{\n    AVPacketList **next_point, *this_pktl;\n\n    this_pktl      = av_mallocz(sizeof(AVPacketList));\n    this_pktl->pkt = *pkt;\n#if FF_API_DESTRUCT_PACKET\nFF_DISABLE_DEPRECATION_WARNINGS\n    pkt->destruct  = NULL;           // do not free original but only the copy\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    pkt->buf       = NULL;\n    av_dup_packet(&this_pktl->pkt);  // duplicate the packet if it uses non-alloced memory\n\n    if (s->streams[pkt->stream_index]->last_in_packet_buffer) {\n        next_point = &(s->streams[pkt->stream_index]->last_in_packet_buffer->next);\n    } else\n        next_point = &s->packet_buffer;\n\n    if (*next_point) {\n        if (compare(s, &s->packet_buffer_end->pkt, pkt)) {\n            while (!compare(s, &(*next_point)->pkt, pkt))\n                next_point = &(*next_point)->next;\n            goto next_non_null;\n        } else {\n            next_point = &(s->packet_buffer_end->next);\n        }\n    }\n    assert(!*next_point);\n\n    s->packet_buffer_end = this_pktl;\nnext_non_null:\n\n    this_pktl->next = *next_point;\n\n    s->streams[pkt->stream_index]->last_in_packet_buffer =\n        *next_point                                      = this_pktl;\n}", "patch_func_code": "int ff_interleave_add_packet(AVFormatContext *s, AVPacket *pkt,\n                             int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))\n{\n    int ret;\n    AVPacketList **next_point, *this_pktl;\n\n    this_pktl      = av_mallocz(sizeof(AVPacketList));\n    if (!this_pktl)\n        return AVERROR(ENOMEM);\n    this_pktl->pkt = *pkt;\n#if FF_API_DESTRUCT_PACKET\nFF_DISABLE_DEPRECATION_WARNINGS\n    pkt->destruct  = NULL;           // do not free original but only the copy\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n    pkt->buf       = NULL;\n    // Duplicate the packet if it uses non-allocated memory\n    if ((ret = av_dup_packet(&this_pktl->pkt)) < 0) {\n        av_free(this_pktl);\n        return ret;\n    }\n\n    if (s->streams[pkt->stream_index]->last_in_packet_buffer) {\n        next_point = &(s->streams[pkt->stream_index]->last_in_packet_buffer->next);\n    } else\n        next_point = &s->packet_buffer;\n\n    if (*next_point) {\n        if (compare(s, &s->packet_buffer_end->pkt, pkt)) {\n            while (!compare(s, &(*next_point)->pkt, pkt))\n                next_point = &(*next_point)->next;\n            goto next_non_null;\n        } else {\n            next_point = &(s->packet_buffer_end->next);\n        }\n    }\n    assert(!*next_point);\n\n    s->packet_buffer_end = this_pktl;\nnext_non_null:\n\n    this_pktl->next = *next_point;\n\n    s->streams[pkt->stream_index]->last_in_packet_buffer =\n        *next_point                                      = this_pktl;\n\n    return 0;\n}", "before_change_lines": [1, 2, 14], "raw_before_change_lines": [1, 2, 14], "after_change_lines": [1, 2, 4, 8, 9, 18, 19, 20, 21, 47], "raw_after_change_lines": [1, 2, 4, 8, 9, 17, 18, 19, 20, 21, 46, 47], "bug_lines": [1, 2, 14], "added": [false, false, false], "idx": 29}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "438----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_18ff55a0eff23f14e1b459153a24e967cc2a3b44_1.json----aac_sync", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_18ff55a0eff23f14e1b459153a24e967cc2a3b44_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_18ff55a0eff23f14e1b459153a24e967cc2a3b44_1.json", "function_name": "aac_sync", "vul_func_code": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n        int *need_next_header, int *new_frame_start)\n{\n    GetBitContext bits;\n    int size, rdb, ch, sr;\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } tmp;\n\n    tmp.u64 = be2me_64(state);\n    init_get_bits(&bits, tmp.u8+8-AAC_HEADER_SIZE, AAC_HEADER_SIZE * 8);\n\n    if(get_bits(&bits, 12) != 0xfff)\n        return 0;\n\n    skip_bits1(&bits);          /* id */\n    skip_bits(&bits, 2);        /* layer */\n    skip_bits1(&bits);          /* protection_absent */\n    skip_bits(&bits, 2);        /* profile_objecttype */\n    sr = get_bits(&bits, 4);    /* sample_frequency_index */\n    if(!ff_mpeg4audio_sample_rates[sr])\n        return 0;\n    skip_bits1(&bits);          /* private_bit */\n    ch = get_bits(&bits, 3);    /* channel_configuration */\n    if(!ff_mpeg4audio_channels[ch])\n        return 0;\n    skip_bits1(&bits);          /* original/copy */\n    skip_bits1(&bits);          /* home */\n\n    /* adts_variable_header */\n    skip_bits1(&bits);          /* copyright_identification_bit */\n    skip_bits1(&bits);          /* copyright_identification_start */\n    size = get_bits(&bits, 13); /* aac_frame_length */\n    if(size < AAC_HEADER_SIZE)\n        return 0;\n\n    skip_bits(&bits, 11);       /* adts_buffer_fullness */\n    rdb = get_bits(&bits, 2);   /* number_of_raw_data_blocks_in_frame */\n\n    hdr_info->channels = ff_mpeg4audio_channels[ch];\n    hdr_info->sample_rate = ff_mpeg4audio_sample_rates[sr];\n    hdr_info->samples = (rdb + 1) * 1024;\n    hdr_info->bit_rate = size * 8 * hdr_info->sample_rate / hdr_info->samples;\n\n    *need_next_header = 0;\n    *new_frame_start  = 1;\n    return size;\n}", "patch_func_code": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n        int *need_next_header, int *new_frame_start)\n{\n    GetBitContext bits;\n    AACADTSHeaderInfo hdr;\n    int size;\n    union {\n        uint64_t u64;\n        uint8_t  u8[8];\n    } tmp;\n\n    tmp.u64 = be2me_64(state);\n    init_get_bits(&bits, tmp.u8+8-AAC_HEADER_SIZE, AAC_HEADER_SIZE * 8);\n\n    if ((size = ff_aac_parse_header(&bits, &hdr)) < 0)\n        return 0;\n    *need_next_header = 0;\n    *new_frame_start  = 1;\n    hdr_info->sample_rate = hdr.sample_rate;\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n    hdr_info->samples     = hdr.samples;\n    hdr_info->bit_rate    = hdr.bit_rate;\n    return size;\n}", "before_change_lines": [5, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 32, 33, 34, 35, 36, 38, 39, 41, 42, 43, 44], "raw_before_change_lines": [5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45], "after_change_lines": [5, 6, 15, 19, 20, 21, 22], "raw_after_change_lines": [5, 6, 15, 19, 20, 21, 22], "bug_lines": [5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 30}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "440----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_190244feea6af3a02a566aff9acb4e932bb7711f_1.json----mm_decode_inter", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_190244feea6af3a02a566aff9acb4e932bb7711f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_190244feea6af3a02a566aff9acb4e932bb7711f_1.json", "function_name": "mm_decode_inter", "vul_func_code": "static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size)\n{\n    const int data_ptr = 2 + AV_RL16(&buf[0]);\n    int d, r, y;\n    d = data_ptr; r = 2; y = 0;\n\n    while(r < data_ptr) {\n        int i, j;\n        int length = buf[r] & 0x7f;\n        int x = buf[r+1] + ((buf[r] & 0x80) << 1);\n        r += 2;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        for(i=0; i<length; i++) {\n            for(j=0; j<8; j++) {\n                int replace = (buf[r+i] >> (7-j)) & 1;\n                if (replace) {\n                    int color = buf[d];\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                    d++;\n                }\n                x += half_horiz ? 2 : 1;\n            }\n        }\n\n        r += length;\n        y += half_vert ? 2 : 1;\n    }\n}", "patch_func_code": "static void mm_decode_inter(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size)\n{\n    const int data_ptr = 2 + AV_RL16(&buf[0]);\n    int d, r, y;\n    d = data_ptr; r = 2; y = 0;\n\n    while(r < data_ptr) {\n        int i, j;\n        int length = buf[r] & 0x7f;\n        int x = buf[r+1] + ((buf[r] & 0x80) << 1);\n        r += 2;\n\n        if (length==0) {\n            y += x;\n            continue;\n        }\n\n        for(i=0; i<length; i++) {\n            for(j=0; j<8; j++) {\n                int replace = (buf[r+i] >> (7-j)) & 1;\n                if (replace) {\n                    int color = buf[d];\n                    s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n                    if (half_horiz)\n                        s->frame.data[0][y*s->frame.linesize[0] + x + 1] = color;\n                    if (half_vert) {\n                        s->frame.data[0][(y+1)*s->frame.linesize[0] + x] = color;\n                        if (half_horiz)\n                            s->frame.data[0][(y+1)*s->frame.linesize[0] + x + 1] = color;\n                    }\n                    d++;\n                }\n                x += 1 + half_horiz;\n            }\n        }\n\n        r += length;\n        y += 1 + half_vert;\n    }\n}", "before_change_lines": [33, 38], "raw_before_change_lines": [33, 38], "after_change_lines": [33, 38], "raw_after_change_lines": [33, 38], "bug_lines": [33, 38], "added": [false, false], "idx": 31}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "445----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1935e3f78e4ec0fddadbfb257bf41428e90282fa_1.json----allocate_buffers", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1935e3f78e4ec0fddadbfb257bf41428e90282fa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1935e3f78e4ec0fddadbfb257bf41428e90282fa_1.json", "function_name": "allocate_buffers", "vul_func_code": "static int allocate_buffers(ALACContext *alac)\n{\n    int ch;\n    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n                         buf_size, buf_alloc_fail);\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n        if (!alac->direct_output) {\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n                             buf_size, buf_alloc_fail);\n        }\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n                         buf_size, buf_alloc_fail);\n    }\n    return 0;\nbuf_alloc_fail:\n    alac_decode_close(alac->avctx);\n    return AVERROR(ENOMEM);\n}", "patch_func_code": "static int allocate_buffers(ALACContext *alac)\n{\n    int ch;\n    int buf_size;\n\n    if (alac->max_samples_per_frame > INT_MAX / sizeof(int32_t))\n        goto buf_alloc_fail;\n    buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n                         buf_size, buf_alloc_fail);\n\n        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);\n        if (!alac->direct_output) {\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n                             buf_size, buf_alloc_fail);\n        }\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n                         buf_size, buf_alloc_fail);\n    }\n    return 0;\nbuf_alloc_fail:\n    alac_decode_close(alac->avctx);\n    return AVERROR(ENOMEM);\n}", "before_change_lines": [4], "raw_before_change_lines": [4], "after_change_lines": [4, 6, 7, 8], "raw_after_change_lines": [4, 5, 6, 7, 8], "bug_lines": [4], "added": [false], "idx": 32}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "449----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_19835309342c6c05b23d3bfe9d38937aad3c2046_1.json----verify_md5", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_19835309342c6c05b23d3bfe9d38937aad3c2046_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_19835309342c6c05b23d3bfe9d38937aad3c2046_1.json", "function_name": "verify_md5", "vul_func_code": "static int verify_md5(HEVCContext *s, AVFrame *frame)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    int pixel_shift = desc->comp[0].depth_minus1 > 7;\n    int i, j;\n\n    if (!desc)\n        return AVERROR(EINVAL);\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"Verifying checksum for frame with POC %d: \",\n           s->poc);\n\n    /* the checksums are LE, so we have to byteswap for >8bpp formats\n     * on BE arches */\n#if HAVE_BIGENDIAN\n    if (pixel_shift && !s->checksum_buf) {\n        av_fast_malloc(&s->checksum_buf, &s->checksum_buf_size,\n                       FFMAX3(frame->linesize[0], frame->linesize[1],\n                              frame->linesize[2]));\n        if (!s->checksum_buf)\n            return AVERROR(ENOMEM);\n    }\n#endif\n\n    for (i = 0; frame->data[i]; i++) {\n        int width  = s->avctx->coded_width;\n        int height = s->avctx->coded_height;\n        int w = (i == 1 || i == 2) ? (width  >> desc->log2_chroma_w) : width;\n        int h = (i == 1 || i == 2) ? (height >> desc->log2_chroma_h) : height;\n        uint8_t md5[16];\n\n        av_md5_init(s->md5_ctx);\n        for (j = 0; j < h; j++) {\n            const uint8_t *src = frame->data[i] + j * frame->linesize[i];\n#if HAVE_BIGENDIAN\n            if (pixel_shift) {\n                s->dsp.bswap16_buf((uint16_t*)s->checksum_buf,\n                                   (const uint16_t*)src, w);\n                src = s->checksum_buf;\n            }\n#endif\n            av_md5_update(s->md5_ctx, src, w << pixel_shift);\n        }\n        av_md5_final(s->md5_ctx, md5);\n\n        if (!memcmp(md5, s->md5[i], 16)) {\n            av_log   (s->avctx, AV_LOG_DEBUG, \"plane %d - correct \", i);\n            print_md5(s->avctx, AV_LOG_DEBUG, md5);\n            av_log   (s->avctx, AV_LOG_DEBUG, \"; \");\n        } else {\n            av_log   (s->avctx, AV_LOG_ERROR, \"mismatching checksum of plane %d - \", i);\n            print_md5(s->avctx, AV_LOG_ERROR, md5);\n            av_log   (s->avctx, AV_LOG_ERROR, \" != \");\n            print_md5(s->avctx, AV_LOG_ERROR, s->md5[i]);\n            av_log   (s->avctx, AV_LOG_ERROR, \"\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n    return 0;\n}", "patch_func_code": "static int verify_md5(HEVCContext *s, AVFrame *frame)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n    int pixel_shift;\n    int i, j;\n\n    if (!desc)\n        return AVERROR(EINVAL);\n\n    pixel_shift = desc->comp[0].depth_minus1 > 7;\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"Verifying checksum for frame with POC %d: \",\n           s->poc);\n\n    /* the checksums are LE, so we have to byteswap for >8bpp formats\n     * on BE arches */\n#if HAVE_BIGENDIAN\n    if (pixel_shift && !s->checksum_buf) {\n        av_fast_malloc(&s->checksum_buf, &s->checksum_buf_size,\n                       FFMAX3(frame->linesize[0], frame->linesize[1],\n                              frame->linesize[2]));\n        if (!s->checksum_buf)\n            return AVERROR(ENOMEM);\n    }\n#endif\n\n    for (i = 0; frame->data[i]; i++) {\n        int width  = s->avctx->coded_width;\n        int height = s->avctx->coded_height;\n        int w = (i == 1 || i == 2) ? (width  >> desc->log2_chroma_w) : width;\n        int h = (i == 1 || i == 2) ? (height >> desc->log2_chroma_h) : height;\n        uint8_t md5[16];\n\n        av_md5_init(s->md5_ctx);\n        for (j = 0; j < h; j++) {\n            const uint8_t *src = frame->data[i] + j * frame->linesize[i];\n#if HAVE_BIGENDIAN\n            if (pixel_shift) {\n                s->dsp.bswap16_buf((uint16_t*)s->checksum_buf,\n                                   (const uint16_t*)src, w);\n                src = s->checksum_buf;\n            }\n#endif\n            av_md5_update(s->md5_ctx, src, w << pixel_shift);\n        }\n        av_md5_final(s->md5_ctx, md5);\n\n        if (!memcmp(md5, s->md5[i], 16)) {\n            av_log   (s->avctx, AV_LOG_DEBUG, \"plane %d - correct \", i);\n            print_md5(s->avctx, AV_LOG_DEBUG, md5);\n            av_log   (s->avctx, AV_LOG_DEBUG, \"; \");\n        } else {\n            av_log   (s->avctx, AV_LOG_ERROR, \"mismatching checksum of plane %d - \", i);\n            print_md5(s->avctx, AV_LOG_ERROR, md5);\n            av_log   (s->avctx, AV_LOG_ERROR, \" != \");\n            print_md5(s->avctx, AV_LOG_ERROR, s->md5[i]);\n            av_log   (s->avctx, AV_LOG_ERROR, \"\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n\n    return 0;\n}", "before_change_lines": [4], "raw_before_change_lines": [4], "after_change_lines": [4, 10], "raw_after_change_lines": [4, 10, 11], "bug_lines": [4], "added": [false], "idx": 33}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "454----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1994a97def95085eace0f2f406ff17779a61f590_1.json----blend_frames", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1994a97def95085eace0f2f406ff17779a61f590_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1994a97def95085eace0f2f406ff17779a61f590_1.json", "function_name": "blend_frames", "vul_func_code": "static int blend_frames(AVFilterContext *ctx, int interpolate)\n{\n    FrameRateContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    double interpolate_scene_score = 0;\n\n    if ((s->flags & FRAMERATE_FLAG_SCD)) {\n        if (s->score >= 0.0)\n            interpolate_scene_score = s->score;\n        else\n            interpolate_scene_score = s->score = get_scene_score(ctx, s->f0, s->f1);\n        ff_dlog(ctx, \"blend_frames() interpolate scene score:%f\\n\", interpolate_scene_score);\n    }\n    // decide if the shot-change detection allows us to blend two frames\n    if (interpolate_scene_score < s->scene_score) {\n        ThreadData td;\n        td.copy_src1 = s->f0;\n        td.copy_src2 = s->f1;\n        td.src2_factor = interpolate;\n        td.src1_factor = s->max - td.src2_factor;\n\n        // get work-space for output frame\n        s->work = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!s->work)\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(s->work, s->f0);\n\n        ff_dlog(ctx, \"blend_frames() INTERPOLATE to create work frame\\n\");\n        ctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx)));\n        return 1;\n    }\n    return 0;\n}", "patch_func_code": "static int blend_frames(AVFilterContext *ctx, int interpolate)\n{\n    FrameRateContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    double interpolate_scene_score = 0;\n\n    if ((s->flags & FRAMERATE_FLAG_SCD)) {\n        if (s->score >= 0.0)\n            interpolate_scene_score = s->score;\n        else\n            interpolate_scene_score = s->score = get_scene_score(ctx, s->f0, s->f1);\n        ff_dlog(ctx, \"blend_frames() interpolate scene score:%f\\n\", interpolate_scene_score);\n    }\n    // decide if the shot-change detection allows us to blend two frames\n    if (interpolate_scene_score < s->scene_score) {\n        ThreadData td;\n        td.copy_src1 = s->f0;\n        td.copy_src2 = s->f1;\n        td.src2_factor = interpolate;\n        td.src1_factor = s->blend_factor_max - td.src2_factor;\n\n        // get work-space for output frame\n        s->work = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!s->work)\n            return AVERROR(ENOMEM);\n\n        av_frame_copy_props(s->work, s->f0);\n\n        ff_dlog(ctx, \"blend_frames() INTERPOLATE to create work frame\\n\");\n        ctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx)));\n        return 1;\n    }\n    return 0;\n}", "before_change_lines": [20], "raw_before_change_lines": [20], "after_change_lines": [20], "raw_after_change_lines": [20], "bug_lines": [20], "added": [false], "idx": 34}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "483----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b58d326672e7923df49a060697cf5ed471dcb0c_1.json----av_get_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1b58d326672e7923df49a060697cf5ed471dcb0c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b58d326672e7923df49a060697cf5ed471dcb0c_1.json", "function_name": "av_get_packet", "vul_func_code": "int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)\n{\n    int ret= av_new_packet(pkt, size);\n\n    if(ret<0)\n        return ret;\n\n    pkt->pos= avio_tell(s);\n\n    ret= avio_read(s, pkt->data, size);\n    if(ret<=0)\n        av_free_packet(pkt);\n    else\n        av_shrink_packet(pkt, ret);\n\n    return ret;\n}", "patch_func_code": "int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)\n{\n    int ret;\n\n    if(s->maxsize>0){\n        int64_t remaining= s->maxsize - avio_tell(s);\n        if(remaining>=0)\n            size= FFMIN(size, remaining);\n    }\n\n    ret= av_new_packet(pkt, size);\n\n    if(ret<0)\n        return ret;\n\n    pkt->pos= avio_tell(s);\n\n    ret= avio_read(s, pkt->data, size);\n    if(ret<=0)\n        av_free_packet(pkt);\n    else\n        av_shrink_packet(pkt, ret);\n\n    return ret;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3, 5, 6, 7, 8, 9, 11], "raw_after_change_lines": [3, 4, 5, 6, 7, 8, 9, 10, 11], "bug_lines": [3], "added": [false], "idx": 35}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "486----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b6ed816a2df8cad92a552ad1bdb035a92ab0696_1.json----ir2_decode_plane", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1b6ed816a2df8cad92a552ad1bdb035a92ab0696_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b6ed816a2df8cad92a552ad1bdb035a92ab0696_1.json", "function_name": "ir2_decode_plane", "vul_func_code": "static int ir2_decode_plane(Ir2Context *ctx, int width, int height, uint8_t *dst,\n                            int pitch, const uint8_t *table)\n{\n    int i;\n    int j;\n    int out = 0;\n\n    if (width & 1)\n        return AVERROR_INVALIDDATA;\n\n    /* first line contain absolute values, other lines contain deltas */\n    while (out < width) {\n        int c = ir2_get_code(&ctx->gb);\n        if (c >= 0x80) { /* we have a run */\n            c -= 0x7F;\n            if (out + c*2 > width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < c * 2; i++)\n                dst[out++] = 0x80;\n        } else { /* copy two values from table */\n            dst[out++] = table[c * 2];\n            dst[out++] = table[(c * 2) + 1];\n        }\n    }\n    dst += pitch;\n\n    for (j = 1; j < height; j++) {\n        out = 0;\n        if (get_bits_left(&ctx->gb) <= 0)\n            return AVERROR_INVALIDDATA;\n        while (out < width) {\n            int c = ir2_get_code(&ctx->gb);\n            if (c >= 0x80) { /* we have a skip */\n                c -= 0x7F;\n                if (out + c*2 > width)\n                    return AVERROR_INVALIDDATA;\n                for (i = 0; i < c * 2; i++) {\n                    dst[out] = dst[out - pitch];\n                    out++;\n                }\n            } else { /* add two deltas from table */\n                int t    = dst[out - pitch] + (table[c * 2] - 128);\n                t        = av_clip_uint8(t);\n                dst[out] = t;\n                out++;\n                t        = dst[out - pitch] + (table[(c * 2) + 1] - 128);\n                t        = av_clip_uint8(t);\n                dst[out] = t;\n                out++;\n            }\n        }\n        dst += pitch;\n    }\n    return 0;\n}", "patch_func_code": "static int ir2_decode_plane(Ir2Context *ctx, int width, int height, uint8_t *dst,\n                            int pitch, const uint8_t *table)\n{\n    int i;\n    int j;\n    int out = 0;\n\n    if (width & 1)\n        return AVERROR_INVALIDDATA;\n\n    /* first line contain absolute values, other lines contain deltas */\n    while (out < width) {\n        int c = ir2_get_code(&ctx->gb);\n        if (c >= 0x80) { /* we have a run */\n            c -= 0x7F;\n            if (out + c*2 > width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < c * 2; i++)\n                dst[out++] = 0x80;\n        } else { /* copy two values from table */\n            if (c <= 0)\n                return AVERROR_INVALIDDATA;\n            dst[out++] = table[c * 2];\n            dst[out++] = table[(c * 2) + 1];\n        }\n    }\n    dst += pitch;\n\n    for (j = 1; j < height; j++) {\n        out = 0;\n        if (get_bits_left(&ctx->gb) <= 0)\n            return AVERROR_INVALIDDATA;\n        while (out < width) {\n            int c = ir2_get_code(&ctx->gb);\n            if (c >= 0x80) { /* we have a skip */\n                c -= 0x7F;\n                if (out + c*2 > width)\n                    return AVERROR_INVALIDDATA;\n                for (i = 0; i < c * 2; i++) {\n                    dst[out] = dst[out - pitch];\n                    out++;\n                }\n            } else { /* add two deltas from table */\n                int t;\n                if (c <= 0)\n                    return AVERROR_INVALIDDATA;\n                t        = dst[out - pitch] + (table[c * 2] - 128);\n                t        = av_clip_uint8(t);\n                dst[out] = t;\n                out++;\n                t        = dst[out - pitch] + (table[(c * 2) + 1] - 128);\n                t        = av_clip_uint8(t);\n                dst[out] = t;\n                out++;\n            }\n        }\n        dst += pitch;\n    }\n    return 0;\n}", "before_change_lines": [42], "raw_before_change_lines": [42], "after_change_lines": [21, 22, 44, 45, 46, 47], "raw_after_change_lines": [21, 22, 44, 45, 46, 47], "bug_lines": [42], "added": [false], "idx": 36}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "490----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b864c9ef37160c1e99e592d63be8e91973300ea_1.json----ff_h264_filter_mb_fast", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1b864c9ef37160c1e99e592d63be8e91973300ea_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1b864c9ef37160c1e99e592d63be8e91973300ea_1.json", "function_name": "ff_h264_filter_mb_fast", "vul_func_code": "void ff_h264_filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) {\n    MpegEncContext * const s = &h->s;\n    int mb_y_firstrow = s->picture_structure == PICT_BOTTOM_FIELD;\n    int mb_xy, mb_type;\n    int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh;\n\n    mb_xy = h->mb_xy;\n\n    if(mb_x==0 || mb_y==mb_y_firstrow || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff ||\n       (h->deblocking_filter == 2 && (h->slice_num != h->slice_table[h->top_mb_xy] ||\n                                      h->slice_num != h->slice_table[mb_xy - 1]))) {\n        ff_h264_filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n        return;\n    }\n    assert(!FRAME_MBAFF);\n\n    mb_type = s->current_picture.mb_type[mb_xy];\n    qp = s->current_picture.qscale_table[mb_xy];\n    qp0 = s->current_picture.qscale_table[mb_xy-1];\n    qp1 = s->current_picture.qscale_table[h->top_mb_xy];\n    qpc = get_chroma_qp( h, 0, qp );\n    qpc0 = get_chroma_qp( h, 0, qp0 );\n    qpc1 = get_chroma_qp( h, 0, qp1 );\n    qp0 = (qp + qp0 + 1) >> 1;\n    qp1 = (qp + qp1 + 1) >> 1;\n    qpc0 = (qpc + qpc0 + 1) >> 1;\n    qpc1 = (qpc + qpc1 + 1) >> 1;\n    qp_thresh = 15 - h->slice_alpha_c0_offset;\n    if(qp <= qp_thresh && qp0 <= qp_thresh && qp1 <= qp_thresh &&\n       qpc <= qp_thresh && qpc0 <= qp_thresh && qpc1 <= qp_thresh)\n        return;\n\n    if( IS_INTRA(mb_type) ) {\n        int16_t bS4[4] = {4,4,4,4};\n        int16_t bS3[4] = {3,3,3,3};\n        int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;\n        if( IS_8x8DCT(mb_type) ) {\n            filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h);\n            filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h);\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h);\n        } else {\n            filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h);\n            filter_mb_edgev( &img_y[4*1], linesize, bS3, qp, h);\n            filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h);\n            filter_mb_edgev( &img_y[4*3], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h);\n            filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, h);\n        }\n        filter_mb_edgecv( &img_cb[2*0], uvlinesize, bS4, qpc0, h);\n        filter_mb_edgecv( &img_cb[2*2], uvlinesize, bS3, qpc, h);\n        filter_mb_edgecv( &img_cr[2*0], uvlinesize, bS4, qpc0, h);\n        filter_mb_edgecv( &img_cr[2*2], uvlinesize, bS3, qpc, h);\n        filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, h);\n        filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, h);\n        filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, h);\n        filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, h);\n        return;\n    } else {\n        DECLARE_ALIGNED_8(int16_t, bS)[2][4][4];\n        uint64_t (*bSv)[4] = (uint64_t(*)[4])bS;\n        int edges;\n        if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 ) {\n            edges = 4;\n            bSv[0][0] = bSv[0][2] = bSv[1][0] = bSv[1][2] = 0x0002000200020002ULL;\n        } else {\n            int mask_edge1 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 :\n                             (mb_type & MB_TYPE_16x8) ? 1 : 0;\n            int mask_edge0 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16))\n                             && (s->current_picture.mb_type[mb_xy-1] & (MB_TYPE_16x16 | MB_TYPE_8x16))\n                             ? 3 : 0;\n            int step = IS_8x8DCT(mb_type) ? 2 : 1;\n            edges = (mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;\n            s->dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,\n                                              (h->slice_type_nos == FF_B_TYPE), edges, step, mask_edge0, mask_edge1, FIELD_PICTURE);\n        }\n        if( IS_INTRA(s->current_picture.mb_type[mb_xy-1]) )\n            bSv[0][0] = 0x0004000400040004ULL;\n        if( IS_INTRA(s->current_picture.mb_type[h->top_mb_xy]) )\n            bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL;\n\n#define FILTER(hv,dir,edge)\\\n        if(bSv[dir][edge]) {\\\n            filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1)], linesize, bS[dir][edge], edge ? qp : qp##dir, h );\\\n            if(!(edge&1)) {\\\n                filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\\\n                filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\\\n            }\\\n        }\n        if( edges == 1 ) {\n            FILTER(v,0,0);\n            FILTER(h,1,0);\n        } else if( IS_8x8DCT(mb_type) ) {\n            FILTER(v,0,0);\n            FILTER(v,0,2);\n            FILTER(h,1,0);\n            FILTER(h,1,2);\n        } else {\n            FILTER(v,0,0);\n            FILTER(v,0,1);\n            FILTER(v,0,2);\n            FILTER(v,0,3);\n            FILTER(h,1,0);\n            FILTER(h,1,1);\n            FILTER(h,1,2);\n            FILTER(h,1,3);\n        }\n#undef FILTER\n    }\n}", "patch_func_code": "void ff_h264_filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) {\n    MpegEncContext * const s = &h->s;\n    int mb_y_firstrow = s->picture_structure == PICT_BOTTOM_FIELD;\n    int mb_xy, mb_type;\n    int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh;\n\n    mb_xy = h->mb_xy;\n\n    if(mb_x==0 || mb_y==mb_y_firstrow || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff ||\n       (h->deblocking_filter == 2 && (h->slice_num != h->slice_table[h->top_mb_xy] ||\n                                      h->slice_num != h->slice_table[mb_xy - 1]))) {\n        ff_h264_filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n        return;\n    }\n    assert(!FRAME_MBAFF);\n\n    mb_type = s->current_picture.mb_type[mb_xy];\n    qp = s->current_picture.qscale_table[mb_xy];\n    qp0 = s->current_picture.qscale_table[mb_xy-1];\n    qp1 = s->current_picture.qscale_table[h->top_mb_xy];\n    qpc = get_chroma_qp( h, 0, qp );\n    qpc0 = get_chroma_qp( h, 0, qp0 );\n    qpc1 = get_chroma_qp( h, 0, qp1 );\n    qp0 = (qp + qp0 + 1) >> 1;\n    qp1 = (qp + qp1 + 1) >> 1;\n    qpc0 = (qpc + qpc0 + 1) >> 1;\n    qpc1 = (qpc + qpc1 + 1) >> 1;\n    qp_thresh = 15+52 - h->slice_alpha_c0_offset;\n    if(qp <= qp_thresh && qp0 <= qp_thresh && qp1 <= qp_thresh &&\n       qpc <= qp_thresh && qpc0 <= qp_thresh && qpc1 <= qp_thresh)\n        return;\n\n    if( IS_INTRA(mb_type) ) {\n        int16_t bS4[4] = {4,4,4,4};\n        int16_t bS3[4] = {3,3,3,3};\n        int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;\n        if( IS_8x8DCT(mb_type) ) {\n            filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h);\n            filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h);\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h);\n        } else {\n            filter_mb_edgev( &img_y[4*0], linesize, bS4, qp0, h);\n            filter_mb_edgev( &img_y[4*1], linesize, bS3, qp, h);\n            filter_mb_edgev( &img_y[4*2], linesize, bS3, qp, h);\n            filter_mb_edgev( &img_y[4*3], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, h);\n            filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, h);\n            filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, h);\n        }\n        filter_mb_edgecv( &img_cb[2*0], uvlinesize, bS4, qpc0, h);\n        filter_mb_edgecv( &img_cb[2*2], uvlinesize, bS3, qpc, h);\n        filter_mb_edgecv( &img_cr[2*0], uvlinesize, bS4, qpc0, h);\n        filter_mb_edgecv( &img_cr[2*2], uvlinesize, bS3, qpc, h);\n        filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, h);\n        filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, h);\n        filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, h);\n        filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, h);\n        return;\n    } else {\n        DECLARE_ALIGNED_8(int16_t, bS)[2][4][4];\n        uint64_t (*bSv)[4] = (uint64_t(*)[4])bS;\n        int edges;\n        if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 ) {\n            edges = 4;\n            bSv[0][0] = bSv[0][2] = bSv[1][0] = bSv[1][2] = 0x0002000200020002ULL;\n        } else {\n            int mask_edge1 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 :\n                             (mb_type & MB_TYPE_16x8) ? 1 : 0;\n            int mask_edge0 = (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16))\n                             && (s->current_picture.mb_type[mb_xy-1] & (MB_TYPE_16x16 | MB_TYPE_8x16))\n                             ? 3 : 0;\n            int step = IS_8x8DCT(mb_type) ? 2 : 1;\n            edges = (mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;\n            s->dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,\n                                              (h->slice_type_nos == FF_B_TYPE), edges, step, mask_edge0, mask_edge1, FIELD_PICTURE);\n        }\n        if( IS_INTRA(s->current_picture.mb_type[mb_xy-1]) )\n            bSv[0][0] = 0x0004000400040004ULL;\n        if( IS_INTRA(s->current_picture.mb_type[h->top_mb_xy]) )\n            bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL;\n\n#define FILTER(hv,dir,edge)\\\n        if(bSv[dir][edge]) {\\\n            filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1)], linesize, bS[dir][edge], edge ? qp : qp##dir, h );\\\n            if(!(edge&1)) {\\\n                filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\\\n                filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, h );\\\n            }\\\n        }\n        if( edges == 1 ) {\n            FILTER(v,0,0);\n            FILTER(h,1,0);\n        } else if( IS_8x8DCT(mb_type) ) {\n            FILTER(v,0,0);\n            FILTER(v,0,2);\n            FILTER(h,1,0);\n            FILTER(h,1,2);\n        } else {\n            FILTER(v,0,0);\n            FILTER(v,0,1);\n            FILTER(v,0,2);\n            FILTER(v,0,3);\n            FILTER(h,1,0);\n            FILTER(h,1,1);\n            FILTER(h,1,2);\n            FILTER(h,1,3);\n        }\n#undef FILTER\n    }\n}", "before_change_lines": [28], "raw_before_change_lines": [28], "after_change_lines": [28], "raw_after_change_lines": [28], "bug_lines": [28], "added": [false], "idx": 37}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "497----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1be04b49ca05fa17f823c0cc4bb17e5735840422_1.json----mkv_write_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1be04b49ca05fa17f823c0cc4bb17e5735840422_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1be04b49ca05fa17f823c0cc4bb17e5735840422_1.json", "function_name": "mkv_write_header", "vul_func_code": "static int mkv_write_header(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ebml_master ebml_header;\n    AVDictionaryEntry *tag;\n    int ret, i, version = 2;\n    int64_t creation_time;\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n        mkv->mode = MODE_WEBM;\n    else\n        mkv->mode = MODE_MATROSKAv2;\n\n    if (mkv->mode != MODE_WEBM ||\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n        version = 4;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n            av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n            return AVERROR_PATCHWELCOME;\n        }\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n            version = 4;\n    }\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n    if (!mkv->tracks) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n    end_ebml_master(pb, ebml_header);\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n    mkv->segment_offset = avio_tell(pb);\n\n    // we write 2 seek heads - one at the end of the file to point to each\n    // cluster, and one at the beginning to point to all other level one\n    // elements (including the seek head at the end of the file), which\n    // isn't more than 10 elements if we only write one of each other\n    // currently defined level 1 element\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n    if (!mkv->main_seekhead) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n    if (ret < 0) goto fail;\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, &mkv->info, MATROSKA_ID_INFO, 0);\n    if (ret < 0)\n        return ret;\n    pb = mkv->info_bc;\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n        else\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n        if (mkv->mode != MODE_WEBM) {\n            uint32_t segment_uid[4];\n            AVLFG lfg;\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n            for (i = 0; i < 4; i++)\n                segment_uid[i] = av_lfg_get(&lfg);\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n        }\n    } else {\n        const char *ident = \"Lavf\";\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n    }\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n        uint8_t date_utc_buf[8];\n        AV_WB64(date_utc_buf, date_utc);\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n    }\n\n    // reserve space for the duration\n    mkv->duration = 0;\n    mkv->duration_offset = avio_tell(pb);\n    if (!mkv->is_live) {\n        int64_t metadata_duration = get_metadata_duration(s);\n\n        if (s->duration > 0) {\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n        } else if (metadata_duration > 0) {\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n        } else {\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n        }\n    }\n    if (s->pb->seekable)\n        put_ebml_void(s->pb, avio_tell(pb) + ((mkv->write_crc && mkv->mode != MODE_WEBM) ? 2 /* ebml id + data size */ + 4 /* CRC32 */ : 0));\n    else\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n    pb = s->pb;\n\n    // initialize stream_duration fields\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    ret = mkv_write_tracks(s);\n    if (ret < 0)\n        goto fail;\n\n    for (i = 0; i < s->nb_chapters; i++)\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n    if (mkv->mode != MODE_WEBM) {\n        ret = mkv_write_chapters(s);\n        if (ret < 0)\n            goto fail;\n\n        ret = mkv_write_attachments(s);\n        if (ret < 0)\n            goto fail;\n\n        ret = mkv_write_tags(s);\n        if (ret < 0)\n            goto fail;\n    }\n\n    if (!s->pb->seekable && !mkv->is_live)\n        mkv_write_seekhead(pb, mkv);\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n    if (!mkv->cues) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if (pb->seekable && mkv->reserve_cues_space) {\n        mkv->cues_pos = avio_tell(pb);\n        put_ebml_void(pb, mkv->reserve_cues_space);\n    }\n\n    av_init_packet(&mkv->cur_audio_pkt);\n    mkv->cur_audio_pkt.size = 0;\n    mkv->cluster_pos = -1;\n\n    avio_flush(pb);\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n    // after 4k and on a keyframe\n    if (pb->seekable) {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 5000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n    } else {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 1000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 32 * 1024;\n    }\n\n    return 0;\nfail:\n    mkv_free(mkv);\n    return ret;\n}", "patch_func_code": "static int mkv_write_header(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ebml_master ebml_header;\n    AVDictionaryEntry *tag;\n    int ret, i, version = 2;\n    int64_t creation_time;\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n        mkv->mode = MODE_WEBM;\n    else\n        mkv->mode = MODE_MATROSKAv2;\n\n    if (mkv->mode != MODE_WEBM ||\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n        version = 4;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n            av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n            return AVERROR_PATCHWELCOME;\n        }\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n            version = 4;\n    }\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n    if (!mkv->tracks) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n    end_ebml_master(pb, ebml_header);\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n    mkv->segment_offset = avio_tell(pb);\n\n    // we write 2 seek heads - one at the end of the file to point to each\n    // cluster, and one at the beginning to point to all other level one\n    // elements (including the seek head at the end of the file), which\n    // isn't more than 10 elements if we only write one of each other\n    // currently defined level 1 element\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n    if (!mkv->main_seekhead) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n    if (ret < 0) goto fail;\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n    if (ret < 0)\n        return ret;\n    pb = mkv->info_bc;\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n        else\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n        if (mkv->mode != MODE_WEBM) {\n            uint32_t segment_uid[4];\n            AVLFG lfg;\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n            for (i = 0; i < 4; i++)\n                segment_uid[i] = av_lfg_get(&lfg);\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n        }\n    } else {\n        const char *ident = \"Lavf\";\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n    }\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n        uint8_t date_utc_buf[8];\n        AV_WB64(date_utc_buf, date_utc);\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n    }\n\n    // reserve space for the duration\n    mkv->duration = 0;\n    mkv->duration_offset = avio_tell(pb);\n    if (!mkv->is_live) {\n        int64_t metadata_duration = get_metadata_duration(s);\n\n        if (s->duration > 0) {\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n        } else if (metadata_duration > 0) {\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n        } else {\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n        }\n    }\n    if (s->pb->seekable)\n        put_ebml_void(s->pb, avio_tell(pb));\n    else\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n    pb = s->pb;\n\n    // initialize stream_duration fields\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    ret = mkv_write_tracks(s);\n    if (ret < 0)\n        goto fail;\n\n    for (i = 0; i < s->nb_chapters; i++)\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n    if (mkv->mode != MODE_WEBM) {\n        ret = mkv_write_chapters(s);\n        if (ret < 0)\n            goto fail;\n\n        ret = mkv_write_attachments(s);\n        if (ret < 0)\n            goto fail;\n\n        ret = mkv_write_tags(s);\n        if (ret < 0)\n            goto fail;\n    }\n\n    if (!s->pb->seekable && !mkv->is_live)\n        mkv_write_seekhead(pb, mkv);\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n    if (!mkv->cues) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if (pb->seekable && mkv->reserve_cues_space) {\n        mkv->cues_pos = avio_tell(pb);\n        put_ebml_void(pb, mkv->reserve_cues_space);\n    }\n\n    av_init_packet(&mkv->cur_audio_pkt);\n    mkv->cur_audio_pkt.size = 0;\n    mkv->cluster_pos = -1;\n\n    avio_flush(pb);\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n    // after 4k and on a keyframe\n    if (pb->seekable) {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 5000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n    } else {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 1000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 32 * 1024;\n    }\n\n    return 0;\nfail:\n    mkv_free(mkv);\n    return ret;\n}", "before_change_lines": [70, 129], "raw_before_change_lines": [70, 129], "after_change_lines": [70, 129], "raw_after_change_lines": [70, 129], "bug_lines": [70, 129], "added": [false, false], "idx": 38}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "508----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1c913970521c09f41fa251434da770c361a6c60a_1.json----hls_window", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1c913970521c09f41fa251434da770c361a6c60a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1c913970521c09f41fa251434da770c361a6c60a_1.json", "function_name": "hls_window", "vul_func_code": "static int hls_window(AVFormatContext *s, int last)\n{\n    HLSContext *hls = s->priv_data;\n    ListEntry *en;\n    int64_t target_duration = 0;\n    int ret = 0;\n    AVIOContext *out = NULL;\n    char temp_filename[1024];\n    int64_t sequence = FFMAX(hls->start_sequence, hls->sequence - hls->size);\n\n    snprintf(temp_filename, sizeof(temp_filename), \"%s.tmp\", s->filename);\n    if ((ret = avio_open2(&out, temp_filename, AVIO_FLAG_WRITE,\n                          &s->interrupt_callback, NULL)) < 0)\n        goto fail;\n\n    for (en = hls->list; en; en = en->next) {\n        if (target_duration < en->duration)\n            target_duration = en->duration;\n    }\n\n    avio_printf(out, \"#EXTM3U\\n\");\n    avio_printf(out, \"#EXT-X-VERSION:%d\\n\", hls->version);\n    if (hls->allowcache == 0 || hls->allowcache == 1) {\n        avio_printf(out, \"#EXT-X-ALLOW-CACHE:%s\\n\", hls->allowcache == 0 ? \"NO\" : \"YES\");\n    }\n    avio_printf(out, \"#EXT-X-TARGETDURATION:%\"PRId64\"\\n\",\n                av_rescale_rnd(target_duration, 1, AV_TIME_BASE,\n                               AV_ROUND_UP));\n    avio_printf(out, \"#EXT-X-MEDIA-SEQUENCE:%\"PRId64\"\\n\", sequence);\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%\"PRId64\"\\n\",\n           sequence);\n\n    for (en = hls->list; en; en = en->next) {\n        if (hls->version > 2)\n            avio_printf(out, \"#EXTINF:%f\\n\",\n                        (double)en->duration / AV_TIME_BASE);\n        else\n            avio_printf(out, \"#EXTINF:%\"PRId64\",\\n\",\n                        av_rescale(en->duration, 1, AV_TIME_BASE));\n        if (hls->baseurl)\n            avio_printf(out, \"%s\", hls->baseurl);\n        avio_printf(out, \"%s\\n\", en->name);\n    }\n\n    if (last)\n        avio_printf(out, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n    avio_closep(&out);\n    if (ret >= 0)\n        ff_rename(temp_filename, s->filename);\n    return ret;\n}", "patch_func_code": "static int hls_window(AVFormatContext *s, int last)\n{\n    HLSContext *hls = s->priv_data;\n    ListEntry *en;\n    int64_t target_duration = 0;\n    int ret = 0;\n    AVIOContext *out = NULL;\n    char temp_filename[1024];\n    int64_t sequence = FFMAX(hls->start_sequence, hls->sequence - hls->size);\n\n    snprintf(temp_filename, sizeof(temp_filename), \"%s.tmp\", s->filename);\n    if ((ret = s->io_open(s, &out, temp_filename, AVIO_FLAG_WRITE, NULL)) < 0)\n        goto fail;\n\n    for (en = hls->list; en; en = en->next) {\n        if (target_duration < en->duration)\n            target_duration = en->duration;\n    }\n\n    avio_printf(out, \"#EXTM3U\\n\");\n    avio_printf(out, \"#EXT-X-VERSION:%d\\n\", hls->version);\n    if (hls->allowcache == 0 || hls->allowcache == 1) {\n        avio_printf(out, \"#EXT-X-ALLOW-CACHE:%s\\n\", hls->allowcache == 0 ? \"NO\" : \"YES\");\n    }\n    avio_printf(out, \"#EXT-X-TARGETDURATION:%\"PRId64\"\\n\",\n                av_rescale_rnd(target_duration, 1, AV_TIME_BASE,\n                               AV_ROUND_UP));\n    avio_printf(out, \"#EXT-X-MEDIA-SEQUENCE:%\"PRId64\"\\n\", sequence);\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%\"PRId64\"\\n\",\n           sequence);\n\n    for (en = hls->list; en; en = en->next) {\n        if (hls->version > 2)\n            avio_printf(out, \"#EXTINF:%f\\n\",\n                        (double)en->duration / AV_TIME_BASE);\n        else\n            avio_printf(out, \"#EXTINF:%\"PRId64\",\\n\",\n                        av_rescale(en->duration, 1, AV_TIME_BASE));\n        if (hls->baseurl)\n            avio_printf(out, \"%s\", hls->baseurl);\n        avio_printf(out, \"%s\\n\", en->name);\n    }\n\n    if (last)\n        avio_printf(out, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n    ff_format_io_close(s, &out);\n    if (ret >= 0)\n        ff_rename(temp_filename, s->filename);\n    return ret;\n}", "before_change_lines": [12, 13, 50], "raw_before_change_lines": [12, 13, 50], "after_change_lines": [12, 49], "raw_after_change_lines": [12, 49], "bug_lines": [12, 13, 50], "added": [false, false, false], "idx": 39}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "540----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1df9158086d4899a3dbfc92117dcca59bbe5e95a_1.json----get_len", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1df9158086d4899a3dbfc92117dcca59bbe5e95a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1df9158086d4899a3dbfc92117dcca59bbe5e95a_1.json", "function_name": "get_len", "vul_func_code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "patch_func_code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c))) {\n            if (cnt >= INT_MAX - 1000) {\n                c->error |= AV_LZO_ERROR;\n                break;\n            }\n            cnt += 255;\n        }\n        cnt += mask + x;\n    }\n    return cnt;\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5, 6, 7, 8, 9, 11], "raw_after_change_lines": [5, 6, 7, 8, 9, 11], "bug_lines": [5], "added": [false], "idx": 40}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "541----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1e0aa65feb017435bc208ba78307923fa3a0fe12_1.json----decode_mb_row_no_filter", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1e0aa65feb017435bc208ba78307923fa3a0fe12_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1e0aa65feb017435bc208ba78307923fa3a0fe12_1.json", "function_name": "decode_mb_row_no_filter", "vul_func_code": "static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void *tdata,\n                                        int jobnr, int threadnr, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    VP8ThreadData *prev_td, *next_td, *td = &s->thread_data[threadnr];\n    int mb_y = td->thread_mb_pos >> 16;\n    int mb_x, mb_xy = mb_y * s->mb_width;\n    int num_jobs = s->num_jobs;\n    VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame;\n    VP56RangeCoder *c  = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)];\n    VP8Macroblock *mb;\n    uint8_t *dst[3] = {\n        curframe->tf.f->data[0] + 16 * mb_y * s->linesize,\n        curframe->tf.f->data[1] +  8 * mb_y * s->uvlinesize,\n        curframe->tf.f->data[2] +  8 * mb_y * s->uvlinesize\n    };\n\n    if (c->end <= c->buffer && c->bits >= 0)\n         return AVERROR_INVALIDDATA;\n\n    if (mb_y == 0)\n        prev_td = td;\n    else\n        prev_td = &s->thread_data[(jobnr + num_jobs - 1) % num_jobs];\n    if (mb_y == s->mb_height - 1)\n        next_td = td;\n    else\n        next_td = &s->thread_data[(jobnr + 1) % num_jobs];\n    if (s->mb_layout == 1)\n        mb = s->macroblocks_base + ((s->mb_width + 1) * (mb_y + 1) + 1);\n    else {\n        // Make sure the previous frame has read its segmentation map,\n        // if we re-use the same map.\n        if (prev_frame && s->segmentation.enabled &&\n            !s->segmentation.update_map)\n            ff_thread_await_progress(&prev_frame->tf, mb_y, 0);\n        mb = s->macroblocks + (s->mb_height - mb_y - 1) * 2;\n        memset(mb - 1, 0, sizeof(*mb)); // zero left macroblock\n        AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED * 0x01010101);\n    }\n\n    if (!is_vp7 || mb_y == 0)\n        memset(td->left_nnz, 0, sizeof(td->left_nnz));\n\n    s->mv_min.x = -MARGIN;\n    s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;\n\n    for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {\n        if (c->end <= c->buffer && c->bits >= 0)\n            return AVERROR_INVALIDDATA;\n        // Wait for previous thread to read mb_x+2, and reach mb_y-1.\n        if (prev_td != td) {\n            if (threadnr != 0) {\n                check_thread_pos(td, prev_td,\n                                 mb_x + (is_vp7 ? 2 : 1),\n                                 mb_y - (is_vp7 ? 2 : 1));\n            } else {\n                check_thread_pos(td, prev_td,\n                                 mb_x + (is_vp7 ? 2 : 1) + s->mb_width + 3,\n                                 mb_y - (is_vp7 ? 2 : 1));\n            }\n        }\n\n        s->vdsp.prefetch(dst[0] + (mb_x & 3) * 4 * s->linesize + 64,\n                         s->linesize, 4);\n        s->vdsp.prefetch(dst[1] + (mb_x & 7) * s->uvlinesize + 64,\n                         dst[2] - dst[1], 2);\n\n        if (!s->mb_layout)\n            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,\n                           prev_frame && prev_frame->seg_map ?\n                           prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7);\n\n        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);\n\n        if (!mb->skip)\n            decode_mb_coeffs(s, td, c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7);\n\n        if (mb->mode <= MODE_I4x4)\n            intra_predict(s, td, dst, mb, mb_x, mb_y, is_vp7);\n        else\n            inter_predict(s, td, dst, mb, mb_x, mb_y);\n\n        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);\n\n        if (!mb->skip) {\n            idct_mb(s, td, dst, mb);\n        } else {\n            AV_ZERO64(td->left_nnz);\n            AV_WN64(s->top_nnz[mb_x], 0);   // array of 9, so unaligned\n\n            /* Reset DC block predictors if they would exist\n             * if the mb had coefficients */\n            if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {\n                td->left_nnz[8]     = 0;\n                s->top_nnz[mb_x][8] = 0;\n            }\n        }\n\n        if (s->deblock_filter)\n            filter_level_for_mb(s, mb, &td->filter_strength[mb_x], is_vp7);\n\n        if (s->deblock_filter && num_jobs != 1 && threadnr == num_jobs - 1) {\n            if (s->filter.simple)\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 NULL, NULL, s->linesize, 0, 1);\n            else\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 dst[1], dst[2], s->linesize, s->uvlinesize, 0);\n        }\n\n        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);\n\n        dst[0]      += 16;\n        dst[1]      += 8;\n        dst[2]      += 8;\n        s->mv_min.x -= 64;\n        s->mv_max.x -= 64;\n\n        if (mb_x == s->mb_width + 1) {\n            update_pos(td, mb_y, s->mb_width + 3);\n        } else {\n            update_pos(td, mb_y, mb_x);\n        }\n    }\n    return 0;\n}", "patch_func_code": "static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void *tdata,\n                                        int jobnr, int threadnr, int is_vp7)\n{\n    VP8Context *s = avctx->priv_data;\n    VP8ThreadData *prev_td, *next_td, *td = &s->thread_data[threadnr];\n    int mb_y = atomic_load(&td->thread_mb_pos) >> 16;\n    int mb_x, mb_xy = mb_y * s->mb_width;\n    int num_jobs = s->num_jobs;\n    VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame;\n    VP56RangeCoder *c  = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)];\n    VP8Macroblock *mb;\n    uint8_t *dst[3] = {\n        curframe->tf.f->data[0] + 16 * mb_y * s->linesize,\n        curframe->tf.f->data[1] +  8 * mb_y * s->uvlinesize,\n        curframe->tf.f->data[2] +  8 * mb_y * s->uvlinesize\n    };\n\n    if (c->end <= c->buffer && c->bits >= 0)\n         return AVERROR_INVALIDDATA;\n\n    if (mb_y == 0)\n        prev_td = td;\n    else\n        prev_td = &s->thread_data[(jobnr + num_jobs - 1) % num_jobs];\n    if (mb_y == s->mb_height - 1)\n        next_td = td;\n    else\n        next_td = &s->thread_data[(jobnr + 1) % num_jobs];\n    if (s->mb_layout == 1)\n        mb = s->macroblocks_base + ((s->mb_width + 1) * (mb_y + 1) + 1);\n    else {\n        // Make sure the previous frame has read its segmentation map,\n        // if we re-use the same map.\n        if (prev_frame && s->segmentation.enabled &&\n            !s->segmentation.update_map)\n            ff_thread_await_progress(&prev_frame->tf, mb_y, 0);\n        mb = s->macroblocks + (s->mb_height - mb_y - 1) * 2;\n        memset(mb - 1, 0, sizeof(*mb)); // zero left macroblock\n        AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED * 0x01010101);\n    }\n\n    if (!is_vp7 || mb_y == 0)\n        memset(td->left_nnz, 0, sizeof(td->left_nnz));\n\n    s->mv_min.x = -MARGIN;\n    s->mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;\n\n    for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {\n        if (c->end <= c->buffer && c->bits >= 0)\n            return AVERROR_INVALIDDATA;\n        // Wait for previous thread to read mb_x+2, and reach mb_y-1.\n        if (prev_td != td) {\n            if (threadnr != 0) {\n                check_thread_pos(td, prev_td,\n                                 mb_x + (is_vp7 ? 2 : 1),\n                                 mb_y - (is_vp7 ? 2 : 1));\n            } else {\n                check_thread_pos(td, prev_td,\n                                 mb_x + (is_vp7 ? 2 : 1) + s->mb_width + 3,\n                                 mb_y - (is_vp7 ? 2 : 1));\n            }\n        }\n\n        s->vdsp.prefetch(dst[0] + (mb_x & 3) * 4 * s->linesize + 64,\n                         s->linesize, 4);\n        s->vdsp.prefetch(dst[1] + (mb_x & 7) * s->uvlinesize + 64,\n                         dst[2] - dst[1], 2);\n\n        if (!s->mb_layout)\n            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,\n                           prev_frame && prev_frame->seg_map ?\n                           prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7);\n\n        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);\n\n        if (!mb->skip)\n            decode_mb_coeffs(s, td, c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7);\n\n        if (mb->mode <= MODE_I4x4)\n            intra_predict(s, td, dst, mb, mb_x, mb_y, is_vp7);\n        else\n            inter_predict(s, td, dst, mb, mb_x, mb_y);\n\n        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);\n\n        if (!mb->skip) {\n            idct_mb(s, td, dst, mb);\n        } else {\n            AV_ZERO64(td->left_nnz);\n            AV_WN64(s->top_nnz[mb_x], 0);   // array of 9, so unaligned\n\n            /* Reset DC block predictors if they would exist\n             * if the mb had coefficients */\n            if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {\n                td->left_nnz[8]     = 0;\n                s->top_nnz[mb_x][8] = 0;\n            }\n        }\n\n        if (s->deblock_filter)\n            filter_level_for_mb(s, mb, &td->filter_strength[mb_x], is_vp7);\n\n        if (s->deblock_filter && num_jobs != 1 && threadnr == num_jobs - 1) {\n            if (s->filter.simple)\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 NULL, NULL, s->linesize, 0, 1);\n            else\n                backup_mb_border(s->top_border[mb_x + 1], dst[0],\n                                 dst[1], dst[2], s->linesize, s->uvlinesize, 0);\n        }\n\n        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);\n\n        dst[0]      += 16;\n        dst[1]      += 8;\n        dst[2]      += 8;\n        s->mv_min.x -= 64;\n        s->mv_max.x -= 64;\n\n        if (mb_x == s->mb_width + 1) {\n            update_pos(td, mb_y, s->mb_width + 3);\n        } else {\n            update_pos(td, mb_y, mb_x);\n        }\n    }\n    return 0;\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6], "raw_after_change_lines": [6], "bug_lines": [6], "added": [false], "idx": 41}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "546----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1e78889391a92a5584380641ac287daf23331ea2_1.json----pnm_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1e78889391a92a5584380641ac287daf23331ea2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1e78889391a92a5584380641ac287daf23331ea2_1.json", "function_name": "pnm_decode_frame", "vul_func_code": "static int pnm_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf   = avpkt->data;\n    int buf_size         = avpkt->size;\n    PNMContext * const s = avctx->priv_data;\n    AVFrame * const p    = data;\n    int i, j, n, linesize, h, upgrade = 0, is_mono = 0;\n    unsigned char *ptr;\n    int components, sample_len, ret;\n    unsigned int maskval = 0;\n\n    s->bytestream_start =\n    s->bytestream       = (uint8_t *)buf;\n    s->bytestream_end   = (uint8_t *)buf + buf_size;\n\n    if ((ret = ff_pnm_decode_header(avctx, s)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n\n    switch (avctx->pix_fmt) {\n    default:\n        return AVERROR(EINVAL);\n    case AV_PIX_FMT_RGBA64BE:\n        n = avctx->width * 8;\n        components=4;\n        sample_len=16;\n        goto do_read;\n    case AV_PIX_FMT_RGB48BE:\n        n = avctx->width * 6;\n        components=3;\n        sample_len=16;\n        goto do_read;\n    case AV_PIX_FMT_RGBA:\n        n = avctx->width * 4;\n        components=4;\n        sample_len=8;\n        goto do_read;\n    case AV_PIX_FMT_RGB24:\n        n = avctx->width * 3;\n        components=3;\n        sample_len=8;\n        goto do_read;\n    case AV_PIX_FMT_GRAY8:\n        n = avctx->width;\n        components=1;\n        sample_len=8;\n        if (s->maxval < 255) {\n            upgrade = 1;\n            maskval = (2 << av_log2(s->maxval)) - 1;\n        }\n        goto do_read;\n    case AV_PIX_FMT_GRAY8A:\n        n = avctx->width * 2;\n        components=2;\n        sample_len=8;\n        goto do_read;\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n        n = avctx->width * 2;\n        components=1;\n        sample_len=16;\n        if (s->maxval < 65535) {\n            upgrade = 2;\n            maskval = (2 << av_log2(s->maxval)) - 1;\n        }\n        goto do_read;\n    case AV_PIX_FMT_MONOWHITE:\n    case AV_PIX_FMT_MONOBLACK:\n        n = (avctx->width + 7) >> 3;\n        components=1;\n        sample_len=1;\n        is_mono = 1;\n    do_read:\n        ptr      = p->data[0];\n        linesize = p->linesize[0];\n        if (s->bytestream + n * avctx->height > s->bytestream_end)\n            return AVERROR_INVALIDDATA;\n        if(s->type < 4 || (is_mono && s->type==7)){\n            for (i=0; i<avctx->height; i++) {\n                PutBitContext pb;\n                init_put_bits(&pb, ptr, linesize);\n                for(j=0; j<avctx->width * components; j++){\n                    unsigned int c=0;\n                    int v=0;\n                    if(s->type < 4)\n                    while(s->bytestream < s->bytestream_end && (*s->bytestream < '0' || *s->bytestream > '9' ))\n                        s->bytestream++;\n                    if(s->bytestream >= s->bytestream_end)\n                        return AVERROR_INVALIDDATA;\n                    if (is_mono) {\n                        /* read a single digit */\n                        v = (*s->bytestream++)&1;\n                    } else {\n                        /* read a sequence of digits */\n                        do {\n                            v = 10*v + c;\n                            c = (*s->bytestream++) - '0';\n                        } while (c <= 9);\n                    }\n                    put_bits(&pb, sample_len, (((1<<sample_len)-1)*v + (s->maxval>>1))/s->maxval);\n                }\n                flush_put_bits(&pb);\n                ptr+= linesize;\n            }\n        }else{\n        for (i = 0; i < avctx->height; i++) {\n            if (!upgrade)\n                memcpy(ptr, s->bytestream, n);\n            else if (upgrade == 1) {\n                unsigned int j, f = (255 * 128 + s->maxval / 2) / s->maxval;\n                for (j = 0; j < n; j++)\n                    ptr[j] = ((s->bytestream[j] & maskval) * f + 64) >> 7;\n            } else if (upgrade == 2) {\n                unsigned int j, v, f = (65535 * 32768 + s->maxval / 2) / s->maxval;\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]) & maskval;\n                    ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15;\n                }\n            }\n            s->bytestream += n;\n            ptr           += linesize;\n        }\n        }\n        break;\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10BE:\n        {\n            unsigned char *ptr1, *ptr2;\n\n            n        = avctx->width;\n            ptr      = p->data[0];\n            linesize = p->linesize[0];\n            if (s->maxval >= 256)\n                n *= 2;\n            if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < avctx->height; i++) {\n                memcpy(ptr, s->bytestream, n);\n                s->bytestream += n;\n                ptr           += linesize;\n            }\n            ptr1 = p->data[1];\n            ptr2 = p->data[2];\n            n >>= 1;\n            h = avctx->height >> 1;\n            for (i = 0; i < h; i++) {\n                memcpy(ptr1, s->bytestream, n);\n                s->bytestream += n;\n                memcpy(ptr2, s->bytestream, n);\n                s->bytestream += n;\n                ptr1 += p->linesize[1];\n                ptr2 += p->linesize[2];\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV420P16:\n        {\n            uint16_t *ptr1, *ptr2;\n            const int f = (65535 * 32768 + s->maxval / 2) / s->maxval;\n            unsigned int j, v;\n\n            n        = avctx->width * 2;\n            ptr      = p->data[0];\n            linesize = p->linesize[0];\n            if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < avctx->height; i++) {\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15;\n                }\n                s->bytestream += n;\n                ptr           += linesize;\n            }\n            ptr1 = (uint16_t*)p->data[1];\n            ptr2 = (uint16_t*)p->data[2];\n            n >>= 1;\n            h = avctx->height >> 1;\n            for (i = 0; i < h; i++) {\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ptr1[j] = (v * f + 16384) >> 15;\n                }\n                s->bytestream += n;\n\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ptr2[j] = (v * f + 16384) >> 15;\n                }\n                s->bytestream += n;\n\n                ptr1 += p->linesize[1] / 2;\n                ptr2 += p->linesize[2] / 2;\n            }\n        }\n        break;\n    }\n    *got_frame = 1;\n\n    return s->bytestream - s->bytestream_start;\n}", "patch_func_code": "static int pnm_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf   = avpkt->data;\n    int buf_size         = avpkt->size;\n    PNMContext * const s = avctx->priv_data;\n    AVFrame * const p    = data;\n    int i, j, n, linesize, h, upgrade = 0, is_mono = 0;\n    unsigned char *ptr;\n    int components, sample_len, ret;\n\n    s->bytestream_start =\n    s->bytestream       = (uint8_t *)buf;\n    s->bytestream_end   = (uint8_t *)buf + buf_size;\n\n    if ((ret = ff_pnm_decode_header(avctx, s)) < 0)\n        return ret;\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n\n    switch (avctx->pix_fmt) {\n    default:\n        return AVERROR(EINVAL);\n    case AV_PIX_FMT_RGBA64BE:\n        n = avctx->width * 8;\n        components=4;\n        sample_len=16;\n        goto do_read;\n    case AV_PIX_FMT_RGB48BE:\n        n = avctx->width * 6;\n        components=3;\n        sample_len=16;\n        goto do_read;\n    case AV_PIX_FMT_RGBA:\n        n = avctx->width * 4;\n        components=4;\n        sample_len=8;\n        goto do_read;\n    case AV_PIX_FMT_RGB24:\n        n = avctx->width * 3;\n        components=3;\n        sample_len=8;\n        goto do_read;\n    case AV_PIX_FMT_GRAY8:\n        n = avctx->width;\n        components=1;\n        sample_len=8;\n        if (s->maxval < 255)\n            upgrade = 1;\n        goto do_read;\n    case AV_PIX_FMT_GRAY8A:\n        n = avctx->width * 2;\n        components=2;\n        sample_len=8;\n        goto do_read;\n    case AV_PIX_FMT_GRAY16BE:\n    case AV_PIX_FMT_GRAY16LE:\n        n = avctx->width * 2;\n        components=1;\n        sample_len=16;\n        if (s->maxval < 65535)\n            upgrade = 2;\n        goto do_read;\n    case AV_PIX_FMT_MONOWHITE:\n    case AV_PIX_FMT_MONOBLACK:\n        n = (avctx->width + 7) >> 3;\n        components=1;\n        sample_len=1;\n        is_mono = 1;\n    do_read:\n        ptr      = p->data[0];\n        linesize = p->linesize[0];\n        if (s->bytestream + n * avctx->height > s->bytestream_end)\n            return AVERROR_INVALIDDATA;\n        if(s->type < 4 || (is_mono && s->type==7)){\n            for (i=0; i<avctx->height; i++) {\n                PutBitContext pb;\n                init_put_bits(&pb, ptr, linesize);\n                for(j=0; j<avctx->width * components; j++){\n                    unsigned int c=0;\n                    int v=0;\n                    if(s->type < 4)\n                    while(s->bytestream < s->bytestream_end && (*s->bytestream < '0' || *s->bytestream > '9' ))\n                        s->bytestream++;\n                    if(s->bytestream >= s->bytestream_end)\n                        return AVERROR_INVALIDDATA;\n                    if (is_mono) {\n                        /* read a single digit */\n                        v = (*s->bytestream++)&1;\n                    } else {\n                        /* read a sequence of digits */\n                        do {\n                            v = 10*v + c;\n                            c = (*s->bytestream++) - '0';\n                        } while (c <= 9);\n                    }\n                    put_bits(&pb, sample_len, (((1<<sample_len)-1)*v + (s->maxval>>1))/s->maxval);\n                }\n                flush_put_bits(&pb);\n                ptr+= linesize;\n            }\n        }else{\n        for (i = 0; i < avctx->height; i++) {\n            if (!upgrade)\n                memcpy(ptr, s->bytestream, n);\n            else if (upgrade == 1) {\n                unsigned int j, f = (255 * 128 + s->maxval / 2) / s->maxval;\n                for (j = 0; j < n; j++)\n                    ptr[j] = (s->bytestream[j] * f + 64) >> 7;\n            } else if (upgrade == 2) {\n                unsigned int j, v, f = (65535 * 32768 + s->maxval / 2) / s->maxval;\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15;\n                }\n            }\n            s->bytestream += n;\n            ptr           += linesize;\n        }\n        }\n        break;\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV420P9BE:\n    case AV_PIX_FMT_YUV420P10BE:\n        {\n            unsigned char *ptr1, *ptr2;\n\n            n        = avctx->width;\n            ptr      = p->data[0];\n            linesize = p->linesize[0];\n            if (s->maxval >= 256)\n                n *= 2;\n            if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < avctx->height; i++) {\n                memcpy(ptr, s->bytestream, n);\n                s->bytestream += n;\n                ptr           += linesize;\n            }\n            ptr1 = p->data[1];\n            ptr2 = p->data[2];\n            n >>= 1;\n            h = avctx->height >> 1;\n            for (i = 0; i < h; i++) {\n                memcpy(ptr1, s->bytestream, n);\n                s->bytestream += n;\n                memcpy(ptr2, s->bytestream, n);\n                s->bytestream += n;\n                ptr1 += p->linesize[1];\n                ptr2 += p->linesize[2];\n            }\n        }\n        break;\n    case AV_PIX_FMT_YUV420P16:\n        {\n            uint16_t *ptr1, *ptr2;\n            const int f = (65535 * 32768 + s->maxval / 2) / s->maxval;\n            unsigned int j, v;\n\n            n        = avctx->width * 2;\n            ptr      = p->data[0];\n            linesize = p->linesize[0];\n            if (s->bytestream + n * avctx->height * 3 / 2 > s->bytestream_end)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < avctx->height; i++) {\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15;\n                }\n                s->bytestream += n;\n                ptr           += linesize;\n            }\n            ptr1 = (uint16_t*)p->data[1];\n            ptr2 = (uint16_t*)p->data[2];\n            n >>= 1;\n            h = avctx->height >> 1;\n            for (i = 0; i < h; i++) {\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ptr1[j] = (v * f + 16384) >> 15;\n                }\n                s->bytestream += n;\n\n                for (j = 0; j < n / 2; j++) {\n                    v = av_be2ne16(((uint16_t *)s->bytestream)[j]);\n                    ptr2[j] = (v * f + 16384) >> 15;\n                }\n                s->bytestream += n;\n\n                ptr1 += p->linesize[1] / 2;\n                ptr2 += p->linesize[2] / 2;\n            }\n        }\n        break;\n    }\n    *got_frame = 1;\n\n    return s->bytestream - s->bytestream_start;\n}", "before_change_lines": [11, 52, 54, 55, 67, 69, 70, 117, 121], "raw_before_change_lines": [11, 52, 54, 55, 67, 69, 70, 117, 121], "after_change_lines": [51, 64, 112, 116], "raw_after_change_lines": [51, 64, 112, 116], "bug_lines": [11, 52, 54, 55, 67, 69, 70, 117, 121], "added": [false, false, false, false, false, false, false, false, false], "idx": 42}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "562----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1f6e23ee894701106c59e794b0e36d9f3fd44aba_1.json----parse_nal_units", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_1f6e23ee894701106c59e794b0e36d9f3fd44aba_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_1f6e23ee894701106c59e794b0e36d9f3fd44aba_1.json", "function_name": "parse_nal_units", "vul_func_code": "static inline int parse_nal_units(AVCodecParserContext *s, const uint8_t *buf,\n                           int buf_size, AVCodecContext *avctx)\n{\n    HEVCParserContext *ctx = s->priv_data;\n    HEVCContext       *h   = &ctx->h;\n    GetBitContext      *gb;\n    SliceHeader        *sh = &h->sh;\n    HEVCParamSets *ps = &h->ps;\n    HEVCPacket   *pkt = &ctx->pkt;\n    const uint8_t *buf_end = buf + buf_size;\n    int state = -1, i;\n    HEVCNAL *nal;\n    int is_global = buf == avctx->extradata;\n\n    if (!h->HEVClc)\n        h->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!h->HEVClc)\n        return AVERROR(ENOMEM);\n\n    gb = &h->HEVClc->gb;\n\n    /* set some sane default values */\n    s->pict_type         = AV_PICTURE_TYPE_I;\n    s->key_frame         = 0;\n    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;\n\n    h->avctx = avctx;\n\n    if (!buf_size)\n        return 0;\n\n    if (pkt->nals_allocated < 1) {\n        HEVCNAL *tmp = av_realloc_array(pkt->nals, 1, sizeof(*tmp));\n        if (!tmp)\n            return AVERROR(ENOMEM);\n        pkt->nals = tmp;\n        memset(pkt->nals, 0, sizeof(*tmp));\n        pkt->nals_allocated = 1;\n    }\n\n    nal = &pkt->nals[0];\n\n    for (;;) {\n        int src_length, consumed;\n        int ret;\n        buf = avpriv_find_start_code(buf, buf_end, &state);\n        if (--buf + 2 >= buf_end)\n            break;\n        src_length = buf_end - buf;\n\n        h->nal_unit_type = (*buf >> 1) & 0x3f;\n        h->temporal_id   = (*(buf + 1) & 0x07) - 1;\n        if (h->nal_unit_type <= NAL_CRA_NUT) {\n            // Do not walk the whole buffer just to decode slice segment header\n            if (src_length > 20)\n                src_length = 20;\n        }\n\n        consumed = ff_hevc_extract_rbsp(NULL, buf, src_length, nal);\n        if (consumed < 0)\n            return consumed;\n\n        ret = init_get_bits8(gb, nal->data + 2, nal->size);\n        if (ret < 0)\n            return ret;\n\n        switch (h->nal_unit_type) {\n        case NAL_VPS:\n            ff_hevc_decode_nal_vps(gb, avctx, ps);\n            break;\n        case NAL_SPS:\n            ff_hevc_decode_nal_sps(gb, avctx, ps, 1);\n            break;\n        case NAL_PPS:\n            ff_hevc_decode_nal_pps(gb, avctx, ps);\n            break;\n        case NAL_SEI_PREFIX:\n        case NAL_SEI_SUFFIX:\n            ff_hevc_decode_nal_sei(h);\n            break;\n        case NAL_TRAIL_N:\n        case NAL_TRAIL_R:\n        case NAL_TSA_N:\n        case NAL_TSA_R:\n        case NAL_STSA_N:\n        case NAL_STSA_R:\n        case NAL_RADL_N:\n        case NAL_RADL_R:\n        case NAL_RASL_N:\n        case NAL_RASL_R:\n        case NAL_BLA_W_LP:\n        case NAL_BLA_W_RADL:\n        case NAL_BLA_N_LP:\n        case NAL_IDR_W_RADL:\n        case NAL_IDR_N_LP:\n        case NAL_CRA_NUT:\n\n            if (is_global) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid NAL unit: %d\\n\", h->nal_unit_type);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->first_slice_in_pic_flag = get_bits1(gb);\n            s->picture_structure = h->picture_struct;\n            s->field_order = h->picture_struct;\n\n            if (IS_IRAP(h)) {\n                s->key_frame = 1;\n                sh->no_output_of_prior_pics_flag = get_bits1(gb);\n            }\n\n            sh->pps_id = get_ue_golomb(gb);\n            if (sh->pps_id >= MAX_PPS_COUNT || !ps->pps_list[sh->pps_id]) {\n                av_log(avctx, AV_LOG_ERROR, \"PPS id out of range: %d\\n\", sh->pps_id);\n                return AVERROR_INVALIDDATA;\n            }\n            ps->pps = (HEVCPPS*)ps->pps_list[sh->pps_id]->data;\n\n            if (ps->pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[ps->pps->sps_id]) {\n                av_log(avctx, AV_LOG_ERROR, \"SPS id out of range: %d\\n\", ps->pps->sps_id);\n                return AVERROR_INVALIDDATA;\n            }\n            if (ps->sps != (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data) {\n                ps->sps = (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data;\n                ps->vps = (HEVCVPS*)ps->vps_list[ps->sps->vps_id]->data;\n            }\n\n            if (!sh->first_slice_in_pic_flag) {\n                int slice_address_length;\n\n                if (ps->pps->dependent_slice_segments_enabled_flag)\n                    sh->dependent_slice_segment_flag = get_bits1(gb);\n                else\n                    sh->dependent_slice_segment_flag = 0;\n\n                slice_address_length = av_ceil_log2_c(ps->sps->ctb_width *\n                                                      ps->sps->ctb_height);\n                sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n                if (sh->slice_segment_addr >= ps->sps->ctb_width * ps->sps->ctb_height) {\n                    av_log(avctx, AV_LOG_ERROR, \"Invalid slice segment address: %u.\\n\",\n                           sh->slice_segment_addr);\n                    return AVERROR_INVALIDDATA;\n                }\n            } else\n                sh->dependent_slice_segment_flag = 0;\n\n            if (sh->dependent_slice_segment_flag)\n                break;\n\n            for (i = 0; i < ps->pps->num_extra_slice_header_bits; i++)\n                skip_bits(gb, 1); // slice_reserved_undetermined_flag[]\n\n            sh->slice_type = get_ue_golomb(gb);\n            if (!(sh->slice_type == I_SLICE || sh->slice_type == P_SLICE ||\n                  sh->slice_type == B_SLICE)) {\n                av_log(avctx, AV_LOG_ERROR, \"Unknown slice type: %d.\\n\",\n                       sh->slice_type);\n                return AVERROR_INVALIDDATA;\n            }\n            s->pict_type = sh->slice_type == B_SLICE ? AV_PICTURE_TYPE_B :\n                           sh->slice_type == P_SLICE ? AV_PICTURE_TYPE_P :\n                                                       AV_PICTURE_TYPE_I;\n\n            if (ps->pps->output_flag_present_flag)\n                sh->pic_output_flag = get_bits1(gb);\n\n            if (ps->sps->separate_colour_plane_flag)\n                sh->colour_plane_id = get_bits(gb, 2);\n\n            if (!IS_IDR(h)) {\n                sh->pic_order_cnt_lsb = get_bits(gb, ps->sps->log2_max_poc_lsb);\n                s->output_picture_number = h->poc = ff_hevc_compute_poc(h, sh->pic_order_cnt_lsb);\n            } else\n                s->output_picture_number = h->poc = 0;\n\n            if (h->temporal_id == 0 &&\n                h->nal_unit_type != NAL_TRAIL_N &&\n                h->nal_unit_type != NAL_TSA_N &&\n                h->nal_unit_type != NAL_STSA_N &&\n                h->nal_unit_type != NAL_RADL_N &&\n                h->nal_unit_type != NAL_RASL_N &&\n                h->nal_unit_type != NAL_RADL_R &&\n                h->nal_unit_type != NAL_RASL_R)\n                h->pocTid0 = h->poc;\n\n            return 0; /* no need to evaluate the rest */\n        }\n        buf += consumed;\n    }\n    /* didn't find a picture! */\n    if (!is_global)\n        av_log(h->avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n    return -1;\n}", "patch_func_code": "static inline int parse_nal_units(AVCodecParserContext *s, const uint8_t *buf,\n                           int buf_size, AVCodecContext *avctx)\n{\n    HEVCParserContext *ctx = s->priv_data;\n    HEVCContext       *h   = &ctx->h;\n    GetBitContext      *gb;\n    SliceHeader        *sh = &h->sh;\n    HEVCParamSets *ps = &h->ps;\n    HEVCPacket   *pkt = &ctx->pkt;\n    const uint8_t *buf_end = buf + buf_size;\n    int state = -1, i;\n    HEVCNAL *nal;\n    int is_global = buf == avctx->extradata;\n\n    if (!h->HEVClc)\n        h->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!h->HEVClc)\n        return AVERROR(ENOMEM);\n\n    gb = &h->HEVClc->gb;\n\n    /* set some sane default values */\n    s->pict_type         = AV_PICTURE_TYPE_I;\n    s->key_frame         = 0;\n    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;\n\n    h->avctx = avctx;\n\n    if (!buf_size)\n        return 0;\n\n    if (pkt->nals_allocated < 1) {\n        HEVCNAL *tmp = av_realloc_array(pkt->nals, 1, sizeof(*tmp));\n        if (!tmp)\n            return AVERROR(ENOMEM);\n        pkt->nals = tmp;\n        memset(pkt->nals, 0, sizeof(*tmp));\n        pkt->nals_allocated = 1;\n    }\n\n    nal = &pkt->nals[0];\n\n    for (;;) {\n        int src_length, consumed;\n        int ret;\n        buf = avpriv_find_start_code(buf, buf_end, &state);\n        if (--buf + 2 >= buf_end)\n            break;\n        src_length = buf_end - buf;\n\n        h->nal_unit_type = (*buf >> 1) & 0x3f;\n        h->temporal_id   = (*(buf + 1) & 0x07) - 1;\n        if (h->nal_unit_type <= NAL_CRA_NUT) {\n            // Do not walk the whole buffer just to decode slice segment header\n            if (src_length > 20)\n                src_length = 20;\n        }\n\n        consumed = ff_hevc_extract_rbsp(buf, src_length, nal);\n        if (consumed < 0)\n            return consumed;\n\n        ret = init_get_bits8(gb, nal->data + 2, nal->size);\n        if (ret < 0)\n            return ret;\n\n        switch (h->nal_unit_type) {\n        case NAL_VPS:\n            ff_hevc_decode_nal_vps(gb, avctx, ps);\n            break;\n        case NAL_SPS:\n            ff_hevc_decode_nal_sps(gb, avctx, ps, 1);\n            break;\n        case NAL_PPS:\n            ff_hevc_decode_nal_pps(gb, avctx, ps);\n            break;\n        case NAL_SEI_PREFIX:\n        case NAL_SEI_SUFFIX:\n            ff_hevc_decode_nal_sei(h);\n            break;\n        case NAL_TRAIL_N:\n        case NAL_TRAIL_R:\n        case NAL_TSA_N:\n        case NAL_TSA_R:\n        case NAL_STSA_N:\n        case NAL_STSA_R:\n        case NAL_RADL_N:\n        case NAL_RADL_R:\n        case NAL_RASL_N:\n        case NAL_RASL_R:\n        case NAL_BLA_W_LP:\n        case NAL_BLA_W_RADL:\n        case NAL_BLA_N_LP:\n        case NAL_IDR_W_RADL:\n        case NAL_IDR_N_LP:\n        case NAL_CRA_NUT:\n\n            if (is_global) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid NAL unit: %d\\n\", h->nal_unit_type);\n                return AVERROR_INVALIDDATA;\n            }\n\n            sh->first_slice_in_pic_flag = get_bits1(gb);\n            s->picture_structure = h->picture_struct;\n            s->field_order = h->picture_struct;\n\n            if (IS_IRAP(h)) {\n                s->key_frame = 1;\n                sh->no_output_of_prior_pics_flag = get_bits1(gb);\n            }\n\n            sh->pps_id = get_ue_golomb(gb);\n            if (sh->pps_id >= MAX_PPS_COUNT || !ps->pps_list[sh->pps_id]) {\n                av_log(avctx, AV_LOG_ERROR, \"PPS id out of range: %d\\n\", sh->pps_id);\n                return AVERROR_INVALIDDATA;\n            }\n            ps->pps = (HEVCPPS*)ps->pps_list[sh->pps_id]->data;\n\n            if (ps->pps->sps_id >= MAX_SPS_COUNT || !ps->sps_list[ps->pps->sps_id]) {\n                av_log(avctx, AV_LOG_ERROR, \"SPS id out of range: %d\\n\", ps->pps->sps_id);\n                return AVERROR_INVALIDDATA;\n            }\n            if (ps->sps != (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data) {\n                ps->sps = (HEVCSPS*)ps->sps_list[ps->pps->sps_id]->data;\n                ps->vps = (HEVCVPS*)ps->vps_list[ps->sps->vps_id]->data;\n            }\n\n            if (!sh->first_slice_in_pic_flag) {\n                int slice_address_length;\n\n                if (ps->pps->dependent_slice_segments_enabled_flag)\n                    sh->dependent_slice_segment_flag = get_bits1(gb);\n                else\n                    sh->dependent_slice_segment_flag = 0;\n\n                slice_address_length = av_ceil_log2_c(ps->sps->ctb_width *\n                                                      ps->sps->ctb_height);\n                sh->slice_segment_addr = get_bitsz(gb, slice_address_length);\n                if (sh->slice_segment_addr >= ps->sps->ctb_width * ps->sps->ctb_height) {\n                    av_log(avctx, AV_LOG_ERROR, \"Invalid slice segment address: %u.\\n\",\n                           sh->slice_segment_addr);\n                    return AVERROR_INVALIDDATA;\n                }\n            } else\n                sh->dependent_slice_segment_flag = 0;\n\n            if (sh->dependent_slice_segment_flag)\n                break;\n\n            for (i = 0; i < ps->pps->num_extra_slice_header_bits; i++)\n                skip_bits(gb, 1); // slice_reserved_undetermined_flag[]\n\n            sh->slice_type = get_ue_golomb(gb);\n            if (!(sh->slice_type == I_SLICE || sh->slice_type == P_SLICE ||\n                  sh->slice_type == B_SLICE)) {\n                av_log(avctx, AV_LOG_ERROR, \"Unknown slice type: %d.\\n\",\n                       sh->slice_type);\n                return AVERROR_INVALIDDATA;\n            }\n            s->pict_type = sh->slice_type == B_SLICE ? AV_PICTURE_TYPE_B :\n                           sh->slice_type == P_SLICE ? AV_PICTURE_TYPE_P :\n                                                       AV_PICTURE_TYPE_I;\n\n            if (ps->pps->output_flag_present_flag)\n                sh->pic_output_flag = get_bits1(gb);\n\n            if (ps->sps->separate_colour_plane_flag)\n                sh->colour_plane_id = get_bits(gb, 2);\n\n            if (!IS_IDR(h)) {\n                sh->pic_order_cnt_lsb = get_bits(gb, ps->sps->log2_max_poc_lsb);\n                s->output_picture_number = h->poc = ff_hevc_compute_poc(h, sh->pic_order_cnt_lsb);\n            } else\n                s->output_picture_number = h->poc = 0;\n\n            if (h->temporal_id == 0 &&\n                h->nal_unit_type != NAL_TRAIL_N &&\n                h->nal_unit_type != NAL_TSA_N &&\n                h->nal_unit_type != NAL_STSA_N &&\n                h->nal_unit_type != NAL_RADL_N &&\n                h->nal_unit_type != NAL_RASL_N &&\n                h->nal_unit_type != NAL_RADL_R &&\n                h->nal_unit_type != NAL_RASL_R)\n                h->pocTid0 = h->poc;\n\n            return 0; /* no need to evaluate the rest */\n        }\n        buf += consumed;\n    }\n    /* didn't find a picture! */\n    if (!is_global)\n        av_log(h->avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n    return -1;\n}", "before_change_lines": [59], "raw_before_change_lines": [59], "after_change_lines": [59], "raw_after_change_lines": [59], "bug_lines": [59], "added": [false], "idx": 43}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "573----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2028b814431e9fc430ecf8bafc132fd42e8e12e9_1.json----decode_cblk", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2028b814431e9fc430ecf8bafc132fd42e8e12e9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2028b814431e9fc430ecf8bafc132fd42e8e12e9_1.json", "function_name": "decode_cblk", "vul_func_code": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int pass_cnt = 0;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    int term_cnt = 0;\n    int coder_type;\n\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n\n    /* If code-block contains no compressed data: nothing to do. */\n    if (!cblk->length)\n        return 0;\n\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data, 0, 1);\n\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1, vert_causal_ctx_csty_symbol);\n            break;\n        case 2:\n            av_assert2(!t1->mqc.raw);\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            break;\n        }\n        if (codsty->cblk_style & JPEG2000_CBLK_RESET) // XXX no testcase for just this\n            ff_mqc_init_contexts(&t1->mqc);\n\n        if (passno && (coder_type = needs_termination(codsty->cblk_style, pass_cnt))) {\n            if (term_cnt >= cblk->nb_terminations) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing needed termination \\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            ff_mqc_initdec(&t1->mqc, cblk->data + cblk->data_start[++term_cnt], coder_type == 2, 0);\n        }\n\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n        pass_cnt ++;\n    }\n\n    if (cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) != t1->mqc.bp) {\n        av_log(s->avctx, AV_LOG_WARNING, \"End mismatch %\"PTRDIFF_SPECIFIER\"\\n\",\n               cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) - t1->mqc.bp);\n    }\n\n    return 0;\n}", "patch_func_code": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int pass_cnt = 0;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    int term_cnt = 0;\n    int coder_type;\n\n    av_assert0(width <= 1024U && height <= 1024U);\n    av_assert0(width*height <= 4096);\n\n    memset(t1->data, 0, t1->stride * height * sizeof(*t1->data));\n\n    /* If code-block contains no compressed data: nothing to do. */\n    if (!cblk->length)\n        return 0;\n\n    memset(t1->flags, 0, t1->stride * (height + 2) * sizeof(*t1->flags));\n\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data, 0, 1);\n\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1, vert_causal_ctx_csty_symbol);\n            break;\n        case 2:\n            av_assert2(!t1->mqc.raw);\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            break;\n        }\n        if (codsty->cblk_style & JPEG2000_CBLK_RESET) // XXX no testcase for just this\n            ff_mqc_init_contexts(&t1->mqc);\n\n        if (passno && (coder_type = needs_termination(codsty->cblk_style, pass_cnt))) {\n            if (term_cnt >= cblk->nb_terminations) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Missing needed termination \\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            ff_mqc_initdec(&t1->mqc, cblk->data + cblk->data_start[++term_cnt], coder_type == 2, 0);\n        }\n\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n        pass_cnt ++;\n    }\n\n    if (cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) != t1->mqc.bp) {\n        av_log(s->avctx, AV_LOG_WARNING, \"End mismatch %\"PTRDIFF_SPECIFIER\"\\n\",\n               cblk->data + cblk->length - 2*(term_cnt < cblk->nb_terminations) - t1->mqc.bp);\n    }\n\n    return 0;\n}", "before_change_lines": [11, 12, 14, 15, 21, 22], "raw_before_change_lines": [11, 12, 14, 15, 21, 22], "after_change_lines": [11, 12, 14, 20], "raw_after_change_lines": [11, 12, 14, 20], "bug_lines": [11, 12, 14, 15, 21, 22], "added": [false, false, false, false, false, false], "idx": 44}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "574----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_203932dd8d56e3c3ec243dec70a4fde845f05f6c_1.json----hwupload_query_formats", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_203932dd8d56e3c3ec243dec70a4fde845f05f6c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_203932dd8d56e3c3ec243dec70a4fde845f05f6c_1.json", "function_name": "hwupload_query_formats", "vul_func_code": "static int hwupload_query_formats(AVFilterContext *avctx)\n{\n    HWUploadContext *ctx = avctx->priv;\n    AVHWFramesConstraints *constraints = NULL;\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n    AVFilterFormats *input_formats = NULL;\n    int err, i;\n\n    if (!avctx->hw_device_ctx) {\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n               \"to upload frames to.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n    if (!ctx->hwdevice_ref)\n        return AVERROR(ENOMEM);\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n    if (!constraints) {\n        err = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n    output_pix_fmts = constraints->valid_hw_formats;\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n    if (!input_formats) {\n        err = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if (input_pix_fmts) {\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n            if (err < 0) {\n                ff_formats_unref(&input_formats);\n                goto fail;\n            }\n        }\n    }\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n                   &avctx->outputs[0]->in_formats);\n\n    av_hwframe_constraints_free(&constraints);\n    return 0;\n\nfail:\n    av_buffer_unref(&ctx->hwdevice_ref);\n    av_hwframe_constraints_free(&constraints);\n    return err;\n}", "patch_func_code": "static int hwupload_query_formats(AVFilterContext *avctx)\n{\n    HWUploadContext *ctx = avctx->priv;\n    AVHWFramesConstraints *constraints = NULL;\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n    AVFilterFormats *input_formats = NULL;\n    int err, i;\n\n    if (!avctx->hw_device_ctx) {\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n               \"to upload frames to.\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n    if (!ctx->hwdevice_ref)\n        return AVERROR(ENOMEM);\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n    if (!constraints) {\n        err = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n    output_pix_fmts = constraints->valid_hw_formats;\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n    if (!input_formats) {\n        err = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if (input_pix_fmts) {\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n            if (err < 0)\n                goto fail;\n        }\n    }\n\n    if ((err = ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats)) < 0 ||\n        (err = ff_formats_ref(ff_make_format_list(output_pix_fmts),\n                              &avctx->outputs[0]->in_formats)) < 0)\n        goto fail;\n\n    av_hwframe_constraints_free(&constraints);\n    return 0;\n\nfail:\n    av_buffer_unref(&ctx->hwdevice_ref);\n    av_hwframe_constraints_free(&constraints);\n    return err;\n}", "before_change_lines": [37, 38, 40, 44, 46, 47], "raw_before_change_lines": [37, 38, 40, 44, 45, 46, 47], "after_change_lines": [37, 42, 43, 44, 45], "raw_after_change_lines": [37, 42, 43, 44, 45], "bug_lines": [37, 38, 40, 44, 45, 46, 47], "added": [false, false, false, false, false, false, false], "idx": 45}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "581----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_207558789c5c1fe3b12b14693b5506bf6250ac1e_1.json----encode_block", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_207558789c5c1fe3b12b14693b5506bf6250ac1e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_207558789c5c1fe3b12b14693b5506bf6250ac1e_1.json", "function_name": "encode_block", "vul_func_code": "static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size)\n{\n    PutBitContext pb;\n    int i, j, band, block, best_idx, power_idx = 0;\n    float power_val, coeff, coeff_sum;\n    float pows[NELLY_FILL_LEN];\n    int bits[NELLY_BUF_LEN], idx_table[NELLY_BANDS];\n    float cand[NELLY_BANDS];\n\n    apply_mdct(s);\n\n    init_put_bits(&pb, output, output_size * 8);\n\n    i = 0;\n    for (band = 0; band < NELLY_BANDS; band++) {\n        coeff_sum = 0;\n        for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n            coeff_sum += s->mdct_out[i                ] * s->mdct_out[i                ]\n                       + s->mdct_out[i + NELLY_BUF_LEN] * s->mdct_out[i + NELLY_BUF_LEN];\n        }\n        cand[band] =\n            log(FFMAX(1.0, coeff_sum / (ff_nelly_band_sizes_table[band] << 7))) * 1024.0 / M_LN2;\n    }\n\n    if (s->avctx->trellis) {\n        get_exponent_dynamic(s, cand, idx_table);\n    } else {\n        get_exponent_greedy(s, cand, idx_table);\n    }\n\n    i = 0;\n    for (band = 0; band < NELLY_BANDS; band++) {\n        if (band) {\n            power_idx += ff_nelly_delta_table[idx_table[band]];\n            put_bits(&pb, 5, idx_table[band]);\n        } else {\n            power_idx = ff_nelly_init_table[idx_table[0]];\n            put_bits(&pb, 6, idx_table[0]);\n        }\n        power_val = pow_table[power_idx & 0x7FF] / (1 << ((power_idx >> 11) + POW_TABLE_OFFSET));\n        for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n            s->mdct_out[i] *= power_val;\n            s->mdct_out[i + NELLY_BUF_LEN] *= power_val;\n            pows[i] = power_idx;\n        }\n    }\n\n    ff_nelly_get_sample_bits(pows, bits);\n\n    for (block = 0; block < 2; block++) {\n        for (i = 0; i < NELLY_FILL_LEN; i++) {\n            if (bits[i] > 0) {\n                const float *table = ff_nelly_dequantization_table + (1 << bits[i]) - 1;\n                coeff = s->mdct_out[block * NELLY_BUF_LEN + i];\n                best_idx =\n                    quant_lut[av_clip (\n                            coeff * quant_lut_mul[bits[i]] + quant_lut_add[bits[i]],\n                            quant_lut_offset[bits[i]],\n                            quant_lut_offset[bits[i]+1] - 1\n                            )];\n                if (fabs(coeff - table[best_idx]) > fabs(coeff - table[best_idx + 1]))\n                    best_idx++;\n\n                put_bits(&pb, bits[i], best_idx);\n            }\n        }\n        if (!block)\n            put_bits(&pb, NELLY_HEADER_BITS + NELLY_DETAIL_BITS - put_bits_count(&pb), 0);\n    }\n\n    flush_put_bits(&pb);\n    memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb));\n}", "patch_func_code": "static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size)\n{\n    PutBitContext pb;\n    int i, j, band, block, best_idx, power_idx = 0;\n    float power_val, coeff, coeff_sum;\n    float pows[NELLY_FILL_LEN];\n    int bits[NELLY_BUF_LEN], idx_table[NELLY_BANDS];\n    float cand[NELLY_BANDS];\n\n    apply_mdct(s);\n\n    init_put_bits(&pb, output, output_size);\n\n    i = 0;\n    for (band = 0; band < NELLY_BANDS; band++) {\n        coeff_sum = 0;\n        for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n            coeff_sum += s->mdct_out[i                ] * s->mdct_out[i                ]\n                       + s->mdct_out[i + NELLY_BUF_LEN] * s->mdct_out[i + NELLY_BUF_LEN];\n        }\n        cand[band] =\n            log(FFMAX(1.0, coeff_sum / (ff_nelly_band_sizes_table[band] << 7))) * 1024.0 / M_LN2;\n    }\n\n    if (s->avctx->trellis) {\n        get_exponent_dynamic(s, cand, idx_table);\n    } else {\n        get_exponent_greedy(s, cand, idx_table);\n    }\n\n    i = 0;\n    for (band = 0; band < NELLY_BANDS; band++) {\n        if (band) {\n            power_idx += ff_nelly_delta_table[idx_table[band]];\n            put_bits(&pb, 5, idx_table[band]);\n        } else {\n            power_idx = ff_nelly_init_table[idx_table[0]];\n            put_bits(&pb, 6, idx_table[0]);\n        }\n        power_val = pow_table[power_idx & 0x7FF] / (1 << ((power_idx >> 11) + POW_TABLE_OFFSET));\n        for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n            s->mdct_out[i] *= power_val;\n            s->mdct_out[i + NELLY_BUF_LEN] *= power_val;\n            pows[i] = power_idx;\n        }\n    }\n\n    ff_nelly_get_sample_bits(pows, bits);\n\n    for (block = 0; block < 2; block++) {\n        for (i = 0; i < NELLY_FILL_LEN; i++) {\n            if (bits[i] > 0) {\n                const float *table = ff_nelly_dequantization_table + (1 << bits[i]) - 1;\n                coeff = s->mdct_out[block * NELLY_BUF_LEN + i];\n                best_idx =\n                    quant_lut[av_clip (\n                            coeff * quant_lut_mul[bits[i]] + quant_lut_add[bits[i]],\n                            quant_lut_offset[bits[i]],\n                            quant_lut_offset[bits[i]+1] - 1\n                            )];\n                if (fabs(coeff - table[best_idx]) > fabs(coeff - table[best_idx + 1]))\n                    best_idx++;\n\n                put_bits(&pb, bits[i], best_idx);\n            }\n        }\n        if (!block)\n            put_bits(&pb, NELLY_HEADER_BITS + NELLY_DETAIL_BITS - put_bits_count(&pb), 0);\n    }\n\n    flush_put_bits(&pb);\n    memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb));\n}", "before_change_lines": [12], "raw_before_change_lines": [12], "after_change_lines": [12], "raw_after_change_lines": [12], "bug_lines": [12], "added": [false], "idx": 46}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "594----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_21345d971ad82f01390813a2312822322913ced7_1.json----tta_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_21345d971ad82f01390813a2312822322913ced7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_21345d971ad82f01390813a2312822322913ced7_1.json", "function_name": "tta_decode_frame", "vul_func_code": "static int tta_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TTAContext *s = avctx->priv_data;\n    int i;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n    {\n        int32_t predictors[s->channels];\n        TTAFilter filters[s->channels];\n        TTARice rices[s->channels];\n        int cur_chan = 0, framelen = s->frame_length;\n        int32_t *p;\n\n        // FIXME: seeking\n        s->total_frames--;\n        if (!s->total_frames && s->last_frame_length)\n            framelen = s->last_frame_length;\n\n        // init per channel states\n        for (i = 0; i < s->channels; i++) {\n            predictors[i] = 0;\n            ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]);\n            rice_init(&(rices[i]), 10, 10);\n        }\n\n        for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n            int32_t *predictor = &(predictors[cur_chan]);\n            TTAFilter *filter = &(filters[cur_chan]);\n            TTARice *rice = &(rices[cur_chan]);\n            uint32_t unary, depth, k;\n            int32_t value;\n\n            unary = tta_get_unary(&s->gb);\n\n            if (unary == 0) {\n                depth = 0;\n                k = rice->k0;\n            } else {\n                depth = 1;\n                k = rice->k1;\n                unary--;\n            }\n\n            if (k)\n                value = (unary << k) + get_bits(&s->gb, k);\n            else\n                value = unary;\n\n            // FIXME: copy paste from original\n            switch (depth) {\n            case 1:\n                rice->sum1 += value - (rice->sum1 >> 4);\n                if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1])\n                    rice->k1--;\n                else if(rice->sum1 > shift_16[rice->k1 + 1])\n                    rice->k1++;\n                value += shift_1[rice->k0];\n            default:\n                rice->sum0 += value - (rice->sum0 >> 4);\n                if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0])\n                    rice->k0--;\n                else if(rice->sum0 > shift_16[rice->k0 + 1])\n                    rice->k0++;\n            }\n\n            // extract coded value\n#define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1))\n            *p = UNFOLD(value);\n\n            // run hybrid filter\n            ttafilter_process(filter, p, 0);\n\n            // fixed order prediction\n#define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k)\n            switch (s->bps) {\n                case 1: *p += PRED(*predictor, 4); break;\n                case 2:\n                case 3: *p += PRED(*predictor, 5); break;\n                case 4: *p += *predictor; break;\n            }\n            *predictor = *p;\n\n#if 0\n            // extract 32bit float from last two int samples\n            if (s->is_float && ((p - data) & 1)) {\n                uint32_t neg = *p & 0x80000000;\n                uint32_t hi = *(p - 1);\n                uint32_t lo = abs(*p) - 1;\n\n                hi += (hi || lo) ? 0x3f80 : 0;\n                // SWAP16: swap all the 16 bits\n                *(p - 1) = (hi << 16) | SWAP16(lo) | neg;\n            }\n#endif\n\n            /*if ((get_bits_count(&s->gb)+7)/8 > buf_size)\n            {\n                av_log(NULL, AV_LOG_INFO, \"overread!!\\n\");\n                break;\n            }*/\n\n            // flip channels\n            if (cur_chan < (s->channels-1))\n                cur_chan++;\n            else {\n                // decorrelate in case of stereo integer\n                if (!s->is_float && (s->channels > 1)) {\n                    int32_t *r = p - 1;\n                    for (*p += *r / 2; r > p - s->channels; r--)\n                        *r = *(r + 1) - *r;\n                }\n                cur_chan = 0;\n            }\n        }\n\n        skip_bits(&s->gb, 32); // frame crc\n\n        // convert to output buffer\n        switch(s->bps) {\n            case 2: {\n                uint16_t *samples = data;\n                for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n//                    *samples++ = (unsigned char)*p;\n//                    *samples++ = (unsigned char)(*p >> 8);\n                    *samples++ = *p;\n                }\n                *data_size = (uint8_t *)samples - (uint8_t *)data;\n                break;\n            }\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"Error, only 16bit samples supported!\\n\");\n        }\n    }\n\n//    return get_bits_count(&s->gb)+7)/8;\n    return buf_size;\n}", "patch_func_code": "static int tta_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TTAContext *s = avctx->priv_data;\n    int i;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n    {\n        int32_t predictors[s->channels];\n        TTAFilter filters[s->channels];\n        TTARice rices[s->channels];\n        int cur_chan = 0, framelen = s->frame_length;\n        int32_t *p;\n\n        // FIXME: seeking\n        s->total_frames--;\n        if (!s->total_frames && s->last_frame_length)\n            framelen = s->last_frame_length;\n\n        // init per channel states\n        for (i = 0; i < s->channels; i++) {\n            predictors[i] = 0;\n            ttafilter_init(&(filters[i]), ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]);\n            rice_init(&(rices[i]), 10, 10);\n        }\n\n        for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n            int32_t *predictor = &(predictors[cur_chan]);\n            TTAFilter *filter = &(filters[cur_chan]);\n            TTARice *rice = &(rices[cur_chan]);\n            uint32_t unary, depth, k;\n            int32_t value;\n\n            unary = tta_get_unary(&s->gb);\n\n            if (unary == 0) {\n                depth = 0;\n                k = rice->k0;\n            } else {\n                depth = 1;\n                k = rice->k1;\n                unary--;\n            }\n\n            if (get_bits_left(&s->gb) < k)\n                return -1;\n\n            if (k) {\n                if (k > MIN_CACHE_BITS)\n                    return -1;\n                value = (unary << k) + get_bits(&s->gb, k);\n            } else\n                value = unary;\n\n            // FIXME: copy paste from original\n            switch (depth) {\n            case 1:\n                rice->sum1 += value - (rice->sum1 >> 4);\n                if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1])\n                    rice->k1--;\n                else if(rice->sum1 > shift_16[rice->k1 + 1])\n                    rice->k1++;\n                value += shift_1[rice->k0];\n            default:\n                rice->sum0 += value - (rice->sum0 >> 4);\n                if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0])\n                    rice->k0--;\n                else if(rice->sum0 > shift_16[rice->k0 + 1])\n                    rice->k0++;\n            }\n\n            // extract coded value\n#define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1))\n            *p = UNFOLD(value);\n\n            // run hybrid filter\n            ttafilter_process(filter, p, 0);\n\n            // fixed order prediction\n#define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k)\n            switch (s->bps) {\n                case 1: *p += PRED(*predictor, 4); break;\n                case 2:\n                case 3: *p += PRED(*predictor, 5); break;\n                case 4: *p += *predictor; break;\n            }\n            *predictor = *p;\n\n#if 0\n            // extract 32bit float from last two int samples\n            if (s->is_float && ((p - data) & 1)) {\n                uint32_t neg = *p & 0x80000000;\n                uint32_t hi = *(p - 1);\n                uint32_t lo = abs(*p) - 1;\n\n                hi += (hi || lo) ? 0x3f80 : 0;\n                // SWAP16: swap all the 16 bits\n                *(p - 1) = (hi << 16) | SWAP16(lo) | neg;\n            }\n#endif\n\n            /*if ((get_bits_count(&s->gb)+7)/8 > buf_size)\n            {\n                av_log(NULL, AV_LOG_INFO, \"overread!!\\n\");\n                break;\n            }*/\n\n            // flip channels\n            if (cur_chan < (s->channels-1))\n                cur_chan++;\n            else {\n                // decorrelate in case of stereo integer\n                if (!s->is_float && (s->channels > 1)) {\n                    int32_t *r = p - 1;\n                    for (*p += *r / 2; r > p - s->channels; r--)\n                        *r = *(r + 1) - *r;\n                }\n                cur_chan = 0;\n            }\n        }\n\n        if (get_bits_left(&s->gb) < 32)\n            return -1;\n        skip_bits(&s->gb, 32); // frame crc\n\n        // convert to output buffer\n        switch(s->bps) {\n            case 2: {\n                uint16_t *samples = data;\n                for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n//                    *samples++ = (unsigned char)*p;\n//                    *samples++ = (unsigned char)(*p >> 8);\n                    *samples++ = *p;\n                }\n                *data_size = (uint8_t *)samples - (uint8_t *)data;\n                break;\n            }\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"Error, only 16bit samples supported!\\n\");\n        }\n    }\n\n//    return get_bits_count(&s->gb)+7)/8;\n    return buf_size;\n}", "before_change_lines": [48, 50], "raw_before_change_lines": [48, 50], "after_change_lines": [48, 49, 51, 52, 53, 55, 125, 126], "raw_after_change_lines": [48, 49, 50, 51, 52, 53, 55, 125, 126], "bug_lines": [48, 50], "added": [false, false], "idx": 47}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "603----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2166d21a0ac18fb4d0e5e0e9d0c645d31e425e26_1.json----ff_rate_control_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2166d21a0ac18fb4d0e5e0e9d0c645d31e425e26_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2166d21a0ac18fb4d0e5e0e9d0c645d31e425e26_1.json", "function_name": "ff_rate_control_init", "vul_func_code": "int ff_rate_control_init(MpegEncContext *s)\n{\n    RateControlContext *rcc = &s->rc_context;\n    int i, res;\n    static const char * const const_names[] = {\n        \"PI\",\n        \"E\",\n        \"iTex\",\n        \"pTex\",\n        \"tex\",\n        \"mv\",\n        \"fCode\",\n        \"iCount\",\n        \"mcVar\",\n        \"var\",\n        \"isI\",\n        \"isP\",\n        \"isB\",\n        \"avgQP\",\n        \"qComp\",\n#if 0\n        \"lastIQP\",\n        \"lastPQP\",\n        \"lastBQP\",\n        \"nextNonBQP\",\n#endif\n        \"avgIITex\",\n        \"avgPITex\",\n        \"avgPPTex\",\n        \"avgBPTex\",\n        \"avgTex\",\n        NULL\n    };\n    static double (* const func1[])(void *, double) = {\n        (void *)bits2qp,\n        (void *)qp2bits,\n        NULL\n    };\n    static const char * const func1_names[] = {\n        \"bits2qp\",\n        \"qp2bits\",\n        NULL\n    };\n    emms_c();\n\n    if (!s->avctx->rc_max_available_vbv_use && s->avctx->rc_buffer_size) {\n        if (s->avctx->rc_max_rate) {\n            s->avctx->rc_max_available_vbv_use = av_clipf(s->avctx->rc_max_rate/(s->avctx->rc_buffer_size*get_fps(s->avctx)), 1.0/3, 1.0);\n        } else\n            s->avctx->rc_max_available_vbv_use = 1.0;\n    }\n\n    res = av_expr_parse(&rcc->rc_eq_eval,\n                        s->avctx->rc_eq ? s->avctx->rc_eq : \"tex^qComp\",\n                        const_names, func1_names, func1,\n                        NULL, NULL, 0, s->avctx);\n    if (res < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Error parsing rc_eq \\\"%s\\\"\\n\", s->avctx->rc_eq);\n        return res;\n    }\n\n    for (i = 0; i < 5; i++) {\n        rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0;\n        rcc->pred[i].count = 1.0;\n        rcc->pred[i].decay = 0.4;\n\n        rcc->i_cplx_sum [i] =\n        rcc->p_cplx_sum [i] =\n        rcc->mv_bits_sum[i] =\n        rcc->qscale_sum [i] =\n        rcc->frame_count[i] = 1; // 1 is better because of 1/0 and such\n\n        rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5;\n    }\n    rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy;\n    if (!rcc->buffer_index)\n        rcc->buffer_index = s->avctx->rc_buffer_size * 3 / 4;\n\n    if (s->flags & CODEC_FLAG_PASS2) {\n        int i;\n        char *p;\n\n        /* find number of pics */\n        p = s->avctx->stats_in;\n        for (i = -1; p; i++)\n            p = strchr(p + 1, ';');\n        i += s->max_b_frames;\n        if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry))\n            return -1;\n        rcc->entry       = av_mallocz(i * sizeof(RateControlEntry));\n        rcc->num_entries = i;\n\n        /* init all to skipped p frames\n         * (with b frames we might have a not encoded frame at the end FIXME) */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;\n            rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;\n            rce->misc_bits  = s->mb_num + 10;\n            rce->mb_var_sum = s->mb_num * 100;\n        }\n\n        /* read stats */\n        p = s->avctx->stats_in;\n        for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n            RateControlEntry *rce;\n            int picture_number;\n            int e;\n            char *next;\n\n            next = strchr(p, ';');\n            if (next) {\n                (*next) = 0; // sscanf in unbelievably slow on looong strings // FIXME copy / do not write\n                next++;\n            }\n            e = sscanf(p, \" in:%d \", &picture_number);\n\n            assert(picture_number >= 0);\n            assert(picture_number < rcc->num_entries);\n            rce = &rcc->entry[picture_number];\n\n            e += sscanf(p, \" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d\",\n                        &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits,\n                        &rce->mv_bits, &rce->misc_bits,\n                        &rce->f_code, &rce->b_code,\n                        &rce->mc_mb_var_sum, &rce->mb_var_sum,\n                        &rce->i_count, &rce->skip_count, &rce->header_bits);\n            if (e != 14) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"statistics are damaged at line %d, parser out=%d\\n\",\n                       i, e);\n                return -1;\n            }\n\n            p = next;\n        }\n\n        if (init_pass2(s) < 0)\n            return -1;\n\n        // FIXME maybe move to end\n        if ((s->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {\n#if CONFIG_LIBXVID\n            return ff_xvid_rate_control_init(s);\n#else\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Xvid ratecontrol requires libavcodec compiled with Xvid support.\\n\");\n            return -1;\n#endif\n        }\n    }\n\n    if (!(s->flags & CODEC_FLAG_PASS2)) {\n        rcc->short_term_qsum   = 0.001;\n        rcc->short_term_qcount = 0.001;\n\n        rcc->pass1_rc_eq_output_sum = 0.001;\n        rcc->pass1_wanted_bits      = 0.001;\n\n        if (s->avctx->qblur > 1.0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"qblur too large\\n\");\n            return -1;\n        }\n        /* init stuff with the user specified complexity */\n        if (s->avctx->rc_initial_cplx) {\n            for (i = 0; i < 60 * 30; i++) {\n                double bits = s->avctx->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num;\n                RateControlEntry rce;\n\n                if (i % ((s->gop_size + 3) / 4) == 0)\n                    rce.pict_type = AV_PICTURE_TYPE_I;\n                else if (i % (s->max_b_frames + 1))\n                    rce.pict_type = AV_PICTURE_TYPE_B;\n                else\n                    rce.pict_type = AV_PICTURE_TYPE_P;\n\n                rce.new_pict_type = rce.pict_type;\n                rce.mc_mb_var_sum = bits * s->mb_num / 100000;\n                rce.mb_var_sum    = s->mb_num;\n\n                rce.qscale    = FF_QP2LAMBDA * 2;\n                rce.f_code    = 2;\n                rce.b_code    = 1;\n                rce.misc_bits = 1;\n\n                if (s->pict_type == AV_PICTURE_TYPE_I) {\n                    rce.i_count    = s->mb_num;\n                    rce.i_tex_bits = bits;\n                    rce.p_tex_bits = 0;\n                    rce.mv_bits    = 0;\n                } else {\n                    rce.i_count    = 0; // FIXME we do know this approx\n                    rce.i_tex_bits = 0;\n                    rce.p_tex_bits = bits * 0.9;\n                    rce.mv_bits    = bits * 0.1;\n                }\n                rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;\n                rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;\n                rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;\n                rcc->frame_count[rce.pict_type]++;\n\n                get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);\n\n                // FIXME misbehaves a little for variable fps\n                rcc->pass1_wanted_bits += s->bit_rate / get_fps(s->avctx);\n            }\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "int ff_rate_control_init(MpegEncContext *s)\n{\n    RateControlContext *rcc = &s->rc_context;\n    int i, res;\n    static const char * const const_names[] = {\n        \"PI\",\n        \"E\",\n        \"iTex\",\n        \"pTex\",\n        \"tex\",\n        \"mv\",\n        \"fCode\",\n        \"iCount\",\n        \"mcVar\",\n        \"var\",\n        \"isI\",\n        \"isP\",\n        \"isB\",\n        \"avgQP\",\n        \"qComp\",\n#if 0\n        \"lastIQP\",\n        \"lastPQP\",\n        \"lastBQP\",\n        \"nextNonBQP\",\n#endif\n        \"avgIITex\",\n        \"avgPITex\",\n        \"avgPPTex\",\n        \"avgBPTex\",\n        \"avgTex\",\n        NULL\n    };\n    static double (* const func1[])(void *, double) = {\n        (void *)bits2qp,\n        (void *)qp2bits,\n        NULL\n    };\n    static const char * const func1_names[] = {\n        \"bits2qp\",\n        \"qp2bits\",\n        NULL\n    };\n    emms_c();\n\n    if (!s->avctx->rc_max_available_vbv_use && s->avctx->rc_buffer_size) {\n        if (s->avctx->rc_max_rate) {\n            s->avctx->rc_max_available_vbv_use = av_clipf(s->avctx->rc_max_rate/(s->avctx->rc_buffer_size*get_fps(s->avctx)), 1.0/3, 1.0);\n        } else\n            s->avctx->rc_max_available_vbv_use = 1.0;\n    }\n\n    res = av_expr_parse(&rcc->rc_eq_eval,\n                        s->avctx->rc_eq ? s->avctx->rc_eq : \"tex^qComp\",\n                        const_names, func1_names, func1,\n                        NULL, NULL, 0, s->avctx);\n    if (res < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Error parsing rc_eq \\\"%s\\\"\\n\", s->avctx->rc_eq);\n        return res;\n    }\n\n    for (i = 0; i < 5; i++) {\n        rcc->pred[i].coeff = FF_QP2LAMBDA * 7.0;\n        rcc->pred[i].count = 1.0;\n        rcc->pred[i].decay = 0.4;\n\n        rcc->i_cplx_sum [i] =\n        rcc->p_cplx_sum [i] =\n        rcc->mv_bits_sum[i] =\n        rcc->qscale_sum [i] =\n        rcc->frame_count[i] = 1; // 1 is better because of 1/0 and such\n\n        rcc->last_qscale_for[i] = FF_QP2LAMBDA * 5;\n    }\n    rcc->buffer_index = s->avctx->rc_initial_buffer_occupancy;\n    if (!rcc->buffer_index)\n        rcc->buffer_index = s->avctx->rc_buffer_size * 3 / 4;\n\n    if (s->flags & CODEC_FLAG_PASS2) {\n        int i;\n        char *p;\n\n        /* find number of pics */\n        p = s->avctx->stats_in;\n        for (i = -1; p; i++)\n            p = strchr(p + 1, ';');\n        i += s->max_b_frames;\n        if (i <= 0 || i >= INT_MAX / sizeof(RateControlEntry))\n            return -1;\n        rcc->entry       = av_mallocz(i * sizeof(RateControlEntry));\n        rcc->num_entries = i;\n\n        /* init all to skipped p frames\n         * (with b frames we might have a not encoded frame at the end FIXME) */\n        for (i = 0; i < rcc->num_entries; i++) {\n            RateControlEntry *rce = &rcc->entry[i];\n\n            rce->pict_type  = rce->new_pict_type = AV_PICTURE_TYPE_P;\n            rce->qscale     = rce->new_qscale    = FF_QP2LAMBDA * 2;\n            rce->misc_bits  = s->mb_num + 10;\n            rce->mb_var_sum = s->mb_num * 100;\n        }\n\n        /* read stats */\n        p = s->avctx->stats_in;\n        for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n            RateControlEntry *rce;\n            int picture_number;\n            int e;\n            char *next;\n\n            next = strchr(p, ';');\n            if (next) {\n                (*next) = 0; // sscanf in unbelievably slow on looong strings // FIXME copy / do not write\n                next++;\n            }\n            e = sscanf(p, \" in:%d \", &picture_number);\n\n            assert(picture_number >= 0);\n            assert(picture_number < rcc->num_entries);\n            rce = &rcc->entry[picture_number];\n\n            e += sscanf(p, \" in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%\"SCNd64\" var:%\"SCNd64\" icount:%d skipcount:%d hbits:%d\",\n                        &rce->pict_type, &rce->qscale, &rce->i_tex_bits, &rce->p_tex_bits,\n                        &rce->mv_bits, &rce->misc_bits,\n                        &rce->f_code, &rce->b_code,\n                        &rce->mc_mb_var_sum, &rce->mb_var_sum,\n                        &rce->i_count, &rce->skip_count, &rce->header_bits);\n            if (e != 14) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"statistics are damaged at line %d, parser out=%d\\n\",\n                       i, e);\n                return -1;\n            }\n\n            p = next;\n        }\n\n        if (init_pass2(s) < 0)\n            return -1;\n\n        // FIXME maybe move to end\n        if ((s->flags & CODEC_FLAG_PASS2) && s->avctx->rc_strategy == FF_RC_STRATEGY_XVID) {\n#if CONFIG_LIBXVID\n            return ff_xvid_rate_control_init(s);\n#else\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"Xvid ratecontrol requires libavcodec compiled with Xvid support.\\n\");\n            return -1;\n#endif\n        }\n    }\n\n    if (!(s->flags & CODEC_FLAG_PASS2)) {\n        rcc->short_term_qsum   = 0.001;\n        rcc->short_term_qcount = 0.001;\n\n        rcc->pass1_rc_eq_output_sum = 0.001;\n        rcc->pass1_wanted_bits      = 0.001;\n\n        if (s->avctx->qblur > 1.0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"qblur too large\\n\");\n            return -1;\n        }\n        /* init stuff with the user specified complexity */\n        if (s->avctx->rc_initial_cplx) {\n            for (i = 0; i < 60 * 30; i++) {\n                double bits = s->avctx->rc_initial_cplx * (i / 10000.0 + 1.0) * s->mb_num;\n                RateControlEntry rce;\n\n                if (i % ((s->gop_size + 3) / 4) == 0)\n                    rce.pict_type = AV_PICTURE_TYPE_I;\n                else if (i % (s->max_b_frames + 1))\n                    rce.pict_type = AV_PICTURE_TYPE_B;\n                else\n                    rce.pict_type = AV_PICTURE_TYPE_P;\n\n                rce.new_pict_type = rce.pict_type;\n                rce.mc_mb_var_sum = bits * s->mb_num / 100000;\n                rce.mb_var_sum    = s->mb_num;\n\n                rce.qscale    = FF_QP2LAMBDA * 2;\n                rce.f_code    = 2;\n                rce.b_code    = 1;\n                rce.misc_bits = 1;\n\n                if (s->pict_type == AV_PICTURE_TYPE_I) {\n                    rce.i_count    = s->mb_num;\n                    rce.i_tex_bits = bits;\n                    rce.p_tex_bits = 0;\n                    rce.mv_bits    = 0;\n                } else {\n                    rce.i_count    = 0; // FIXME we do know this approx\n                    rce.i_tex_bits = 0;\n                    rce.p_tex_bits = bits * 0.9;\n                    rce.mv_bits    = bits * 0.1;\n                }\n                rcc->i_cplx_sum[rce.pict_type]  += rce.i_tex_bits * rce.qscale;\n                rcc->p_cplx_sum[rce.pict_type]  += rce.p_tex_bits * rce.qscale;\n                rcc->mv_bits_sum[rce.pict_type] += rce.mv_bits;\n                rcc->frame_count[rce.pict_type]++;\n\n                get_qscale(s, &rce, rcc->pass1_wanted_bits / rcc->pass1_rc_eq_output_sum, i);\n\n                // FIXME misbehaves a little for variable fps\n                rcc->pass1_wanted_bits += s->bit_rate / get_fps(s->avctx);\n            }\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [123], "raw_before_change_lines": [123], "after_change_lines": [123], "raw_after_change_lines": [123], "bug_lines": [123], "added": [false], "idx": 48}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "617----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_21fc61493139bc0a239adce4644354397351cab7_1.json----ff_lpc_calc_coefs", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_21fc61493139bc0a239adce4644354397351cab7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_21fc61493139bc0a239adce4644354397351cab7_1.json", "function_name": "ff_lpc_calc_coefs", "vul_func_code": "int ff_lpc_calc_coefs(LPCContext *s,\n                      const int32_t *samples, int blocksize, int min_order,\n                      int max_order, int precision,\n                      int32_t coefs[][MAX_LPC_ORDER], int *shift,\n                      enum FFLPCType lpc_type, int lpc_passes,\n                      int omethod, int max_shift, int zero_shift)\n{\n    double autoc[MAX_LPC_ORDER+1];\n    double ref[MAX_LPC_ORDER];\n    double lpc[MAX_LPC_ORDER][MAX_LPC_ORDER];\n    int i, j, pass = 0;\n    int opt_order;\n\n    av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&\n           lpc_type > FF_LPC_TYPE_FIXED);\n\n    /* reinit LPC context if parameters have changed */\n    if (blocksize != s->blocksize || max_order != s->max_order ||\n        lpc_type  != s->lpc_type) {\n        ff_lpc_end(s);\n        ff_lpc_init(s, blocksize, max_order, lpc_type);\n    }\n\n    if(lpc_passes <= 0)\n        lpc_passes = 2;\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON || (lpc_type == FF_LPC_TYPE_CHOLESKY && lpc_passes > 1)) {\n        s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples);\n\n        s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc);\n\n        compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1);\n\n        for(i=0; i<max_order; i++)\n            ref[i] = fabs(lpc[i][i]);\n\n        pass++;\n    }\n\n    if (lpc_type == FF_LPC_TYPE_CHOLESKY) {\n        LLSModel m[2];\n        LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]);\n        double av_uninit(weight);\n        memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var));\n\n        for(j=0; j<max_order; j++)\n            m[0].coeff[max_order-1][j] = -lpc[max_order-1][j];\n\n        for(; pass<lpc_passes; pass++){\n            avpriv_init_lls(&m[pass&1], max_order);\n\n            weight=0;\n            for(i=max_order; i<blocksize; i++){\n                for(j=0; j<=max_order; j++)\n                    var[j]= samples[i-j];\n\n                if(pass){\n                    double eval, inv, rinv;\n                    eval= m[(pass-1)&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);\n                    eval= (512>>pass) + fabs(eval - var[0]);\n                    inv = 1/eval;\n                    rinv = sqrt(inv);\n                    for(j=0; j<=max_order; j++)\n                        var[j] *= rinv;\n                    weight += inv;\n                }else\n                    weight++;\n\n                m[pass&1].update_lls(&m[pass&1], var);\n            }\n            avpriv_solve_lls(&m[pass&1], 0.001, 0);\n        }\n\n        for(i=0; i<max_order; i++){\n            for(j=0; j<max_order; j++)\n                lpc[i][j]=-m[(pass-1)&1].coeff[i][j];\n            ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000;\n        }\n        for(i=max_order-1; i>0; i--)\n            ref[i] = ref[i-1] - ref[i];\n    }\n\n    opt_order = max_order;\n\n    if(omethod == ORDER_METHOD_EST) {\n        opt_order = estimate_best_order(ref, min_order, max_order);\n        i = opt_order-1;\n        quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);\n    } else {\n        for(i=min_order-1; i<max_order; i++) {\n            quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);\n        }\n    }\n\n    return opt_order;\n}", "patch_func_code": "int ff_lpc_calc_coefs(LPCContext *s,\n                      const int32_t *samples, int blocksize, int min_order,\n                      int max_order, int precision,\n                      int32_t coefs[][MAX_LPC_ORDER], int *shift,\n                      enum FFLPCType lpc_type, int lpc_passes,\n                      int omethod, int max_shift, int zero_shift)\n{\n    double autoc[MAX_LPC_ORDER+1];\n    double ref[MAX_LPC_ORDER];\n    double lpc[MAX_LPC_ORDER][MAX_LPC_ORDER];\n    int i, j, pass = 0;\n    int opt_order;\n\n    av_assert2(max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER &&\n           lpc_type > FF_LPC_TYPE_FIXED);\n\n    /* reinit LPC context if parameters have changed */\n    if (blocksize != s->blocksize || max_order != s->max_order ||\n        lpc_type  != s->lpc_type) {\n        ff_lpc_end(s);\n        ff_lpc_init(s, blocksize, max_order, lpc_type);\n    }\n\n    if(lpc_passes <= 0)\n        lpc_passes = 2;\n\n    if (lpc_type == FF_LPC_TYPE_LEVINSON || (lpc_type == FF_LPC_TYPE_CHOLESKY && lpc_passes > 1)) {\n        s->lpc_apply_welch_window(samples, blocksize, s->windowed_samples);\n\n        s->lpc_compute_autocorr(s->windowed_samples, blocksize, max_order, autoc);\n\n        compute_lpc_coefs(autoc, max_order, &lpc[0][0], MAX_LPC_ORDER, 0, 1);\n\n        for(i=0; i<max_order; i++)\n            ref[i] = fabs(lpc[i][i]);\n\n        pass++;\n    }\n\n    if (lpc_type == FF_LPC_TYPE_CHOLESKY) {\n        LLSModel m[2];\n        LOCAL_ALIGNED(32, double, var, [FFALIGN(MAX_LPC_ORDER+1,4)]);\n        double av_uninit(weight);\n        memset(var, 0, FFALIGN(MAX_LPC_ORDER+1,4)*sizeof(*var));\n\n        for(j=0; j<max_order; j++)\n            m[0].coeff[max_order-1][j] = -lpc[max_order-1][j];\n\n        for(; pass<lpc_passes; pass++){\n            avpriv_init_lls(&m[pass&1], max_order);\n\n            weight=0;\n            for(i=max_order; i<blocksize; i++){\n                for(j=0; j<=max_order; j++)\n                    var[j]= samples[i-j];\n\n                if(pass){\n                    double eval, inv, rinv;\n                    eval= m[pass&1].evaluate_lls(&m[(pass-1)&1], var+1, max_order-1);\n                    eval= (512>>pass) + fabs(eval - var[0]);\n                    inv = 1/eval;\n                    rinv = sqrt(inv);\n                    for(j=0; j<=max_order; j++)\n                        var[j] *= rinv;\n                    weight += inv;\n                }else\n                    weight++;\n\n                m[pass&1].update_lls(&m[pass&1], var);\n            }\n            avpriv_solve_lls(&m[pass&1], 0.001, 0);\n        }\n\n        for(i=0; i<max_order; i++){\n            for(j=0; j<max_order; j++)\n                lpc[i][j]=-m[(pass-1)&1].coeff[i][j];\n            ref[i]= sqrt(m[(pass-1)&1].variance[i] / weight) * (blocksize - max_order) / 4000;\n        }\n        for(i=max_order-1; i>0; i--)\n            ref[i] = ref[i-1] - ref[i];\n    }\n\n    opt_order = max_order;\n\n    if(omethod == ORDER_METHOD_EST) {\n        opt_order = estimate_best_order(ref, min_order, max_order);\n        i = opt_order-1;\n        quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);\n    } else {\n        for(i=min_order-1; i<max_order; i++) {\n            quantize_lpc_coefs(lpc[i], i+1, precision, coefs[i], &shift[i], max_shift, zero_shift);\n        }\n    }\n\n    return opt_order;\n}", "before_change_lines": [59], "raw_before_change_lines": [59], "after_change_lines": [59], "raw_after_change_lines": [59], "bug_lines": [59], "added": [false], "idx": 49}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "618----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2204fb69aca783fb5dd0d83979f1779450165d42_1.json----open_input_stream", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2204fb69aca783fb5dd0d83979f1779450165d42_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2204fb69aca783fb5dd0d83979f1779450165d42_1.json", "function_name": "open_input_stream", "vul_func_code": "static int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 0);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else if (find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 1);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else\n            stream_pos = 0;\n    }\n    if (input_filename[0] == '\\0')\n        return -1;\n\n#if 0\n    { time_t when = stream_pos / 1000000;\n    http_log(\"Stream pos = %\"PRId64\", time=%s\", stream_pos, ctime(&when));\n    }\n#endif\n\n    /* open stream */\n    if ((ret = av_open_input_file(&s, input_filename, c->stream->ifmt,\n                                  buf_size, c->stream->ap_in)) < 0) {\n        http_log(\"could not open %s: %d\\n\", input_filename, ret);\n        return -1;\n    }\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    av_find_stream_info(c->fmt_in);\n\n    /* open each parser */\n    for(i=0;i<s->nb_streams;i++)\n        open_parser(s, i);\n\n    /* choose stream as clock source (we favorize video stream if\n       present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n#if 1\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n#endif\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}", "patch_func_code": "static int open_input_stream(HTTPContext *c, const char *info)\n{\n    char buf[128];\n    char input_filename[1024];\n    AVFormatContext *s;\n    int buf_size, i, ret;\n    int64_t stream_pos;\n\n    /* find file name */\n    if (c->stream->feed) {\n        strcpy(input_filename, c->stream->feed->feed_filename);\n        buf_size = FFM_PACKET_SIZE;\n        /* compute position (absolute time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 0);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else if (find_info_tag(buf, sizeof(buf), \"buffer\", info)) {\n            int prebuffer = strtol(buf, 0, 10);\n            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;\n        } else\n            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;\n    } else {\n        strcpy(input_filename, c->stream->feed_filename);\n        buf_size = 0;\n        /* compute position (relative time) */\n        if (find_info_tag(buf, sizeof(buf), \"date\", info)) {\n            stream_pos = parse_date(buf, 1);\n            if (stream_pos == INT64_MIN)\n                return -1;\n        } else\n            stream_pos = 0;\n    }\n    if (input_filename[0] == '\\0')\n        return -1;\n\n#if 0\n    { time_t when = stream_pos / 1000000;\n    http_log(\"Stream pos = %\"PRId64\", time=%s\", stream_pos, ctime(&when));\n    }\n#endif\n\n    /* open stream */\n    if ((ret = av_open_input_file(&s, input_filename, c->stream->ifmt,\n                                  buf_size, c->stream->ap_in)) < 0) {\n        http_log(\"could not open %s: %d\\n\", input_filename, ret);\n        return -1;\n    }\n    s->flags |= AVFMT_FLAG_GENPTS;\n    c->fmt_in = s;\n    if (av_find_stream_info(c->fmt_in) < 0) {\n        http_log(\"Could not find stream info '%s'\\n\", input_filename);\n        av_close_input_file(s);\n        return -1;\n    }\n\n    /* open each parser */\n    for(i=0;i<s->nb_streams;i++)\n        open_parser(s, i);\n\n    /* choose stream as clock source (we favorize video stream if\n       present) for packet sending */\n    c->pts_stream_index = 0;\n    for(i=0;i<c->stream->nb_streams;i++) {\n        if (c->pts_stream_index == 0 &&\n            c->stream->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {\n            c->pts_stream_index = i;\n        }\n    }\n\n#if 1\n    if (c->fmt_in->iformat->read_seek)\n        av_seek_frame(c->fmt_in, -1, stream_pos, 0);\n#endif\n    /* set the start time (needed for maxtime and RTP packet timing) */\n    c->start_time = cur_time;\n    c->first_pts = AV_NOPTS_VALUE;\n    return 0;\n}", "before_change_lines": [51], "raw_before_change_lines": [51], "after_change_lines": [51, 52, 53, 54, 55], "raw_after_change_lines": [51, 52, 53, 54, 55], "bug_lines": [51], "added": [false], "idx": 50}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "644----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_23126356b24757bdcfe0674fcfb66697fdd13393_1.json----end_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_23126356b24757bdcfe0674fcfb66697fdd13393_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_23126356b24757bdcfe0674fcfb66697fdd13393_1.json", "function_name": "end_frame", "vul_func_code": "static void end_frame(AVFilterLink *link)\n{\n    ff_end_frame(link->dst->outputs[0]);\n    avfilter_unref_buffer(link->dst->outputs[0]->out_buf);\n    avfilter_unref_buffer(link->cur_buf);\n}", "patch_func_code": "static void end_frame(AVFilterLink *link)\n{\n    ff_end_frame(link->dst->outputs[0]);\n    avfilter_unref_buffer(link->dst->outputs[0]->out_buf);\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [5], "added": [false], "idx": 51}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "652----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2352924e0fc310971e5383b08d56165af4aeec89_1.json----dxtory_decode_v1_420", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2352924e0fc310971e5383b08d56165af4aeec89_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2352924e0fc310971e5383b08d56165af4aeec89_1.json", "function_name": "dxtory_decode_v1_420", "vul_func_code": "static int dxtory_decode_v1_420(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    int h, w;\n    uint8_t *Y1, *Y2, *U, *V;\n    int ret;\n\n    if (src_size < avctx->width * avctx->height * 3LL / 2) {\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y1 = pic->data[0];\n    Y2 = pic->data[0] + pic->linesize[0];\n    U  = pic->data[1];\n    V  = pic->data[2];\n    for (h = 0; h < avctx->height; h += 2) {\n        for (w = 0; w < avctx->width; w += 2) {\n            AV_COPY16(Y1 + w, src);\n            AV_COPY16(Y2 + w, src + 2);\n            U[w >> 1] = src[4] + 0x80;\n            V[w >> 1] = src[5] + 0x80;\n            src += 6;\n        }\n        Y1 += pic->linesize[0] << 1;\n        Y2 += pic->linesize[0] << 1;\n        U  += pic->linesize[1];\n        V  += pic->linesize[2];\n    }\n\n    return 0;\n}", "patch_func_code": "static int dxtory_decode_v1_420(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    int h, w;\n    uint8_t *Y1, *Y2, *U, *V;\n    int ret;\n\n    if (src_size < FFALIGN(avctx->width, 2) * FFALIGN(avctx->height, 2) * 3LL / 2) {\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y1 = pic->data[0];\n    Y2 = pic->data[0] + pic->linesize[0];\n    U  = pic->data[1];\n    V  = pic->data[2];\n    for (h = 0; h < avctx->height; h += 2) {\n        for (w = 0; w < avctx->width; w += 2) {\n            AV_COPY16(Y1 + w, src);\n            AV_COPY16(Y2 + w, src + 2);\n            U[w >> 1] = src[4] + 0x80;\n            V[w >> 1] = src[5] + 0x80;\n            src += 6;\n        }\n        Y1 += pic->linesize[0] << 1;\n        Y2 += pic->linesize[0] << 1;\n        U  += pic->linesize[1];\n        V  += pic->linesize[2];\n    }\n\n    return 0;\n}", "before_change_lines": [8], "raw_before_change_lines": [8], "after_change_lines": [8], "raw_after_change_lines": [8], "bug_lines": [8], "added": [false], "idx": 52}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "660----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_23a70a5448dce09e7e2d832bdcb5a7ee403e922b_1.json----encode_quant_matrix", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_23a70a5448dce09e7e2d832bdcb5a7ee403e922b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_23a70a5448dce09e7e2d832bdcb5a7ee403e922b_1.json", "function_name": "encode_quant_matrix", "vul_func_code": "static void encode_quant_matrix(VC2EncContext *s)\n{\n    int level, custom_quant_matrix = 0;\n    if (s->wavelet_depth > 4 || s->quant_matrix != VC2_QM_DEF)\n        custom_quant_matrix = 1;\n    put_bits(&s->pb, 1, custom_quant_matrix);\n    if (custom_quant_matrix) {\n        init_custom_qm(s);\n        put_vc2_ue_uint(&s->pb, s->quant[0][0]);\n        for (level = 0; level < s->wavelet_depth; level++) {\n            put_vc2_ue_uint(&s->pb, s->quant[level][1]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][2]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][3]);\n        }\n    } else {\n        for (level = 0; level < s->wavelet_depth; level++) {\n            s->quant[level][0] = ff_dirac_default_qmat[s->wavelet_idx][level][0];\n            s->quant[level][1] = ff_dirac_default_qmat[s->wavelet_idx][level][1];\n            s->quant[level][2] = ff_dirac_default_qmat[s->wavelet_idx][level][2];\n            s->quant[level][3] = ff_dirac_default_qmat[s->wavelet_idx][level][3];\n        }\n    }\n}", "patch_func_code": "static void encode_quant_matrix(VC2EncContext *s)\n{\n    int level;\n    put_bits(&s->pb, 1, s->custom_quant_matrix);\n    if (s->custom_quant_matrix) {\n        put_vc2_ue_uint(&s->pb, s->quant[0][0]);\n        for (level = 0; level < s->wavelet_depth; level++) {\n            put_vc2_ue_uint(&s->pb, s->quant[level][1]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][2]);\n            put_vc2_ue_uint(&s->pb, s->quant[level][3]);\n        }\n    }\n}", "before_change_lines": [3, 4, 5, 6, 7, 8, 15, 16, 17, 18, 19, 20, 21], "raw_before_change_lines": [3, 4, 5, 6, 7, 8, 15, 16, 17, 18, 19, 20, 21], "after_change_lines": [3, 4, 5], "raw_after_change_lines": [3, 4, 5], "bug_lines": [3, 4, 5, 6, 7, 8, 15, 16, 17, 18, 19, 20, 21], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 53}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "669----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_24a241122ffd03eb3a9da75a76adfba43ceefe0b_1.json----mov_stsc_index_valid", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_24a241122ffd03eb3a9da75a76adfba43ceefe0b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_24a241122ffd03eb3a9da75a76adfba43ceefe0b_1.json", "function_name": "mov_stsc_index_valid", "vul_func_code": "static inline int mov_stsc_index_valid(int index, int count)\n{\n    return index + 1 < count;\n}", "patch_func_code": "static inline int mov_stsc_index_valid(unsigned int index, unsigned int count)\n{\n    return index < count - 1;\n}", "before_change_lines": [1, 3], "raw_before_change_lines": [1, 3], "after_change_lines": [1, 3], "raw_after_change_lines": [1, 3], "bug_lines": [1, 3], "added": [false, false], "idx": 54}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "675----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_24e87409b562f998244ee8cc6fb72e24de14fb73_1.json----avi_sync", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_24e87409b562f998244ee8cc6fb72e24de14fb73_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_24e87409b562f998244ee8cc6fb72e24de14fb73_1.json", "function_name": "avi_sync", "vul_func_code": "static int avi_sync(AVFormatContext *s, int exit_early)\n{\n    AVIContext *avi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int n;\n    unsigned int d[8];\n    unsigned int size;\n    int64_t i, sync;\n\nstart_sync:\n    memset(d, -1, sizeof(d));\n    for (i = sync = avio_tell(pb); !avio_feof(pb); i++) {\n        int j;\n\n        for (j = 0; j < 7; j++)\n            d[j] = d[j + 1];\n        d[7] = avio_r8(pb);\n\n        size = d[4] + (d[5] << 8) + (d[6] << 16) + (d[7] << 24);\n\n        n = get_stream_idx(d + 2);\n        ff_tlog(s, \"%X %X %X %X %X %X %X %X %\"PRId64\" %u %d\\n\",\n                d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n);\n        if (i*(avi->io_fsize>0) + (uint64_t)size > avi->fsize || d[0] > 127)\n            continue;\n\n        // parse ix##\n        if ((d[0] == 'i' && d[1] == 'x' && n < s->nb_streams) ||\n            // parse JUNK\n            (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K') ||\n            (d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1') ||\n            (d[0] == 'i' && d[1] == 'n' && d[2] == 'd' && d[3] == 'x')) {\n            avio_skip(pb, size);\n            goto start_sync;\n        }\n\n        // parse stray LIST\n        if (d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T') {\n            avio_skip(pb, 4);\n            goto start_sync;\n        }\n\n        n = get_stream_idx(d);\n\n        if (!((i - avi->last_pkt_pos) & 1) &&\n            get_stream_idx(d + 1) < s->nb_streams)\n            continue;\n\n        // detect ##ix chunk and skip\n        if (d[2] == 'i' && d[3] == 'x' && n < s->nb_streams) {\n            avio_skip(pb, size);\n            goto start_sync;\n        }\n\n        if (avi->dv_demux && n != 0)\n            continue;\n\n        // parse ##dc/##wb\n        if (n < s->nb_streams) {\n            AVStream *st;\n            AVIStream *ast;\n            st  = s->streams[n];\n            ast = st->priv_data;\n\n            if (!ast) {\n                av_log(s, AV_LOG_WARNING, \"Skipping foreign stream %d packet\\n\", n);\n                continue;\n            }\n\n            if (s->nb_streams >= 2) {\n                AVStream *st1   = s->streams[1];\n                AVIStream *ast1 = st1->priv_data;\n                // workaround for broken small-file-bug402.avi\n                if (   d[2] == 'w' && d[3] == 'b'\n                   && n == 0\n                   && st ->codecpar->codec_type == AVMEDIA_TYPE_VIDEO\n                   && st1->codecpar->codec_type == AVMEDIA_TYPE_AUDIO\n                   && ast->prefix == 'd'*256+'c'\n                   && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count)\n                  ) {\n                    n   = 1;\n                    st  = st1;\n                    ast = ast1;\n                    av_log(s, AV_LOG_WARNING,\n                           \"Invalid stream + prefix combination, assuming audio.\\n\");\n                }\n            }\n\n            if (!avi->dv_demux &&\n                ((st->discard >= AVDISCARD_DEFAULT && size == 0) /* ||\n                 // FIXME: needs a little reordering\n                 (st->discard >= AVDISCARD_NONKEY &&\n                 !(pkt->flags & AV_PKT_FLAG_KEY)) */\n                || st->discard >= AVDISCARD_ALL)) {\n                if (!exit_early) {\n                    ast->frame_offset += get_duration(ast, size);\n                    avio_skip(pb, size);\n                    goto start_sync;\n                }\n            }\n\n            if (d[2] == 'p' && d[3] == 'c' && size <= 4 * 256 + 4) {\n                int k    = avio_r8(pb);\n                int last = (k + avio_r8(pb) - 1) & 0xFF;\n\n                avio_rl16(pb); // flags\n\n                // b + (g << 8) + (r << 16);\n                for (; k <= last; k++)\n                    ast->pal[k] = 0xFFU<<24 | avio_rb32(pb)>>8;\n\n                ast->has_pal = 1;\n                goto start_sync;\n            } else if (((ast->prefix_count < 5 || sync + 9 > i) &&\n                        d[2] < 128 && d[3] < 128) ||\n                       d[2] * 256 + d[3] == ast->prefix /* ||\n                       (d[2] == 'd' && d[3] == 'c') ||\n                       (d[2] == 'w' && d[3] == 'b') */) {\n                if (exit_early)\n                    return 0;\n                if (d[2] * 256 + d[3] == ast->prefix)\n                    ast->prefix_count++;\n                else {\n                    ast->prefix       = d[2] * 256 + d[3];\n                    ast->prefix_count = 0;\n                }\n\n                avi->stream_index = n;\n                ast->packet_size  = size + 8;\n                ast->remaining    = size;\n\n                if (size) {\n                    uint64_t pos = avio_tell(pb) - 8;\n                    if (!st->index_entries || !st->nb_index_entries ||\n                        st->index_entries[st->nb_index_entries - 1].pos < pos) {\n                        av_add_index_entry(st, pos, ast->frame_offset, size,\n                                           0, AVINDEX_KEYFRAME);\n                    }\n                }\n                return 0;\n            }\n        }\n    }\n\n    if (pb->error)\n        return pb->error;\n    return AVERROR_EOF;\n}", "patch_func_code": "static int avi_sync(AVFormatContext *s, int exit_early)\n{\n    AVIContext *avi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int n;\n    unsigned int d[8];\n    unsigned int size;\n    int64_t i, sync;\n\nstart_sync:\n    memset(d, -1, sizeof(d));\n    for (i = sync = avio_tell(pb); !avio_feof(pb); i++) {\n        int j;\n\n        for (j = 0; j < 7; j++)\n            d[j] = d[j + 1];\n        d[7] = avio_r8(pb);\n\n        size = d[4] + (d[5] << 8) + (d[6] << 16) + (d[7] << 24);\n\n        n = get_stream_idx(d + 2);\n        ff_tlog(s, \"%X %X %X %X %X %X %X %X %\"PRId64\" %u %d\\n\",\n                d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], i, size, n);\n        if (i*(avi->io_fsize>0) + (uint64_t)size > avi->fsize || d[0] > 127)\n            continue;\n\n        // parse ix##\n        if ((d[0] == 'i' && d[1] == 'x' && n < s->nb_streams) ||\n            // parse JUNK\n            (d[0] == 'J' && d[1] == 'U' && d[2] == 'N' && d[3] == 'K') ||\n            (d[0] == 'i' && d[1] == 'd' && d[2] == 'x' && d[3] == '1') ||\n            (d[0] == 'i' && d[1] == 'n' && d[2] == 'd' && d[3] == 'x')) {\n            avio_skip(pb, size);\n            goto start_sync;\n        }\n\n        // parse stray LIST\n        if (d[0] == 'L' && d[1] == 'I' && d[2] == 'S' && d[3] == 'T') {\n            avio_skip(pb, 4);\n            goto start_sync;\n        }\n\n        n = get_stream_idx(d);\n\n        if (!((i - avi->last_pkt_pos) & 1) &&\n            get_stream_idx(d + 1) < s->nb_streams)\n            continue;\n\n        // detect ##ix chunk and skip\n        if (d[2] == 'i' && d[3] == 'x' && n < s->nb_streams) {\n            avio_skip(pb, size);\n            goto start_sync;\n        }\n\n        if (avi->dv_demux && n != 0)\n            continue;\n\n        // parse ##dc/##wb\n        if (n < s->nb_streams) {\n            AVStream *st;\n            AVIStream *ast;\n            st  = s->streams[n];\n            ast = st->priv_data;\n\n            if (!ast) {\n                av_log(s, AV_LOG_WARNING, \"Skipping foreign stream %d packet\\n\", n);\n                continue;\n            }\n\n            if (s->nb_streams >= 2) {\n                AVStream *st1   = s->streams[1];\n                AVIStream *ast1 = st1->priv_data;\n                // workaround for broken small-file-bug402.avi\n                if (   d[2] == 'w' && d[3] == 'b'\n                   && n == 0\n                   && st ->codecpar->codec_type == AVMEDIA_TYPE_VIDEO\n                   && st1->codecpar->codec_type == AVMEDIA_TYPE_AUDIO\n                   && ast->prefix == 'd'*256+'c'\n                   && (d[2]*256+d[3] == ast1->prefix || !ast1->prefix_count)\n                  ) {\n                    n   = 1;\n                    st  = st1;\n                    ast = ast1;\n                    av_log(s, AV_LOG_WARNING,\n                           \"Invalid stream + prefix combination, assuming audio.\\n\");\n                }\n            }\n\n            if (d[2] == 'p' && d[3] == 'c' && size <= 4 * 256 + 4) {\n                int k    = avio_r8(pb);\n                int last = (k + avio_r8(pb) - 1) & 0xFF;\n\n                avio_rl16(pb); // flags\n\n                // b + (g << 8) + (r << 16);\n                for (; k <= last; k++)\n                    ast->pal[k] = 0xFFU<<24 | avio_rb32(pb)>>8;\n\n                ast->has_pal = 1;\n                goto start_sync;\n            } else if (((ast->prefix_count < 5 || sync + 9 > i) &&\n                        d[2] < 128 && d[3] < 128) ||\n                       d[2] * 256 + d[3] == ast->prefix /* ||\n                       (d[2] == 'd' && d[3] == 'c') ||\n                       (d[2] == 'w' && d[3] == 'b') */) {\n                if (exit_early)\n                    return 0;\n                if (d[2] * 256 + d[3] == ast->prefix)\n                    ast->prefix_count++;\n                else {\n                    ast->prefix       = d[2] * 256 + d[3];\n                    ast->prefix_count = 0;\n                }\n\n                if (!avi->dv_demux &&\n                    ((st->discard >= AVDISCARD_DEFAULT && size == 0) /* ||\n                        // FIXME: needs a little reordering\n                        (st->discard >= AVDISCARD_NONKEY &&\n                        !(pkt->flags & AV_PKT_FLAG_KEY)) */\n                    || st->discard >= AVDISCARD_ALL)) {\n\n                    ast->frame_offset += get_duration(ast, size);\n                    avio_skip(pb, size);\n                    goto start_sync;\n                }\n\n                avi->stream_index = n;\n                ast->packet_size  = size + 8;\n                ast->remaining    = size;\n\n                if (size) {\n                    uint64_t pos = avio_tell(pb) - 8;\n                    if (!st->index_entries || !st->nb_index_entries ||\n                        st->index_entries[st->nb_index_entries - 1].pos < pos) {\n                        av_add_index_entry(st, pos, ast->frame_offset, size,\n                                           0, AVINDEX_KEYFRAME);\n                    }\n                }\n                return 0;\n            }\n        }\n    }\n\n    if (pb->error)\n        return pb->error;\n    return AVERROR_EOF;\n}", "before_change_lines": [89, 90, 92, 93, 94, 95, 96, 97, 98, 99, 100], "raw_before_change_lines": [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101], "after_change_lines": [115, 116, 118, 119, 120, 122, 123, 124, 125], "raw_after_change_lines": [115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126], "bug_lines": [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 55}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "699----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_267f6ad7426977eee133ce432c2958786fdc0138_1.json----decode_video", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_267f6ad7426977eee133ce432c2958786fdc0138_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_267f6ad7426977eee133ce432c2958786fdc0138_1.json", "function_name": "decode_video", "vul_func_code": "static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output)\n{\n    AVFrame *decoded_frame, *f;\n    int i, ret = 0, err = 0, resample_changed;\n    int64_t best_effort_timestamp;\n    AVRational *frame_sample_aspect;\n\n    if (!ist->decoded_frame && !(ist->decoded_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    if (!ist->filter_frame && !(ist->filter_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    decoded_frame = ist->decoded_frame;\n    pkt->dts  = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ist->st->time_base);\n\n    update_benchmark(NULL);\n    ret = avcodec_decode_video2(ist->dec_ctx,\n                                decoded_frame, got_output, pkt);\n    update_benchmark(\"decode_video %d.%d\", ist->file_index, ist->st->index);\n\n    // The following line may be required in some cases where there is no parser\n    // or the parser does not has_b_frames correctly\n    if (ist->st->codec->has_b_frames < ist->dec_ctx->has_b_frames) {\n        if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) {\n            ist->st->codec->has_b_frames = ist->dec_ctx->has_b_frames;\n        } else\n            av_log(ist->dec_ctx, AV_LOG_WARNING,\n                   \"has_b_frames is larger in decoder than demuxer %d > %d.\\n\"\n                   \"If you want to help, upload a sample \"\n                   \"of this file to ftp://upload.ffmpeg.org/incoming/ \"\n                   \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\",\n                   ist->dec_ctx->has_b_frames,\n                   ist->st->codec->has_b_frames);\n    }\n\n    if (*got_output || ret<0)\n        decode_error_stat[ret<0] ++;\n\n    if (ret < 0 && exit_on_error)\n        exit_program(1);\n\n    if (*got_output && ret >= 0) {\n        if (ist->dec_ctx->width  != decoded_frame->width ||\n            ist->dec_ctx->height != decoded_frame->height ||\n            ist->dec_ctx->pix_fmt != decoded_frame->format) {\n            av_log(NULL, AV_LOG_DEBUG, \"Frame parameters mismatch context %d,%d,%d != %d,%d,%d\\n\",\n                decoded_frame->width,\n                decoded_frame->height,\n                decoded_frame->format,\n                ist->dec_ctx->width,\n                ist->dec_ctx->height,\n                ist->dec_ctx->pix_fmt);\n        }\n    }\n\n    if (!*got_output || ret < 0)\n        return ret;\n\n    if(ist->top_field_first>=0)\n        decoded_frame->top_field_first = ist->top_field_first;\n\n    ist->frames_decoded++;\n\n    if (ist->hwaccel_retrieve_data && decoded_frame->format == ist->hwaccel_pix_fmt) {\n        err = ist->hwaccel_retrieve_data(ist->dec_ctx, decoded_frame);\n        if (err < 0)\n            goto fail;\n    }\n    ist->hwaccel_retrieved_pix_fmt = decoded_frame->format;\n\n    best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame);\n    if(best_effort_timestamp != AV_NOPTS_VALUE)\n        ist->next_pts = ist->pts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"decoder -> ist_index:%d type:video \"\n               \"frame_pts:%s frame_pts_time:%s best_effort_ts:%\"PRId64\" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\\n\",\n               ist->st->index, av_ts2str(decoded_frame->pts),\n               av_ts2timestr(decoded_frame->pts, &ist->st->time_base),\n               best_effort_timestamp,\n               av_ts2timestr(best_effort_timestamp, &ist->st->time_base),\n               decoded_frame->key_frame, decoded_frame->pict_type,\n               ist->st->time_base.num, ist->st->time_base.den);\n    }\n\n    pkt->size = 0;\n\n    if (ist->st->sample_aspect_ratio.num)\n        decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio;\n\n    resample_changed = ist->resample_width   != decoded_frame->width  ||\n                       ist->resample_height  != decoded_frame->height ||\n                       ist->resample_pix_fmt != decoded_frame->format;\n    if (resample_changed) {\n        av_log(NULL, AV_LOG_INFO,\n               \"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n               ist->file_index, ist->st->index,\n               ist->resample_width,  ist->resample_height,  av_get_pix_fmt_name(ist->resample_pix_fmt),\n               decoded_frame->width, decoded_frame->height, av_get_pix_fmt_name(decoded_frame->format));\n\n        ist->resample_width   = decoded_frame->width;\n        ist->resample_height  = decoded_frame->height;\n        ist->resample_pix_fmt = decoded_frame->format;\n\n        for (i = 0; i < nb_filtergraphs; i++) {\n            if (ist_in_filtergraph(filtergraphs[i], ist) && ist->reinit_filters &&\n                configure_filtergraph(filtergraphs[i]) < 0) {\n                av_log(NULL, AV_LOG_FATAL, \"Error reinitializing filters!\\n\");\n                exit_program(1);\n            }\n        }\n    }\n\n    frame_sample_aspect= av_opt_ptr(avcodec_get_frame_class(), decoded_frame, \"sample_aspect_ratio\");\n    for (i = 0; i < ist->nb_filters; i++) {\n        if (!frame_sample_aspect->num)\n            *frame_sample_aspect = ist->st->sample_aspect_ratio;\n\n        if (i < ist->nb_filters - 1) {\n            f = ist->filter_frame;\n            err = av_frame_ref(f, decoded_frame);\n            if (err < 0)\n                break;\n        } else\n            f = decoded_frame;\n        ret = av_buffersrc_add_frame_flags(ist->filters[i]->filter, f, AV_BUFFERSRC_FLAG_PUSH);\n        if (ret == AVERROR_EOF) {\n            ret = 0; /* ignore */\n        } else if (ret < 0) {\n            av_log(NULL, AV_LOG_FATAL,\n                   \"Failed to inject frame into filter network: %s\\n\", av_err2str(ret));\n            exit_program(1);\n        }\n    }\n\nfail:\n    av_frame_unref(ist->filter_frame);\n    av_frame_unref(decoded_frame);\n    return err < 0 ? err : ret;\n}", "patch_func_code": "static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output)\n{\n    AVFrame *decoded_frame, *f;\n    int i, ret = 0, err = 0, resample_changed;\n    int64_t best_effort_timestamp;\n    AVRational *frame_sample_aspect;\n\n    if (!ist->decoded_frame && !(ist->decoded_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    if (!ist->filter_frame && !(ist->filter_frame = av_frame_alloc()))\n        return AVERROR(ENOMEM);\n    decoded_frame = ist->decoded_frame;\n    pkt->dts  = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ist->st->time_base);\n\n    update_benchmark(NULL);\n    ret = avcodec_decode_video2(ist->dec_ctx,\n                                decoded_frame, got_output, pkt);\n    update_benchmark(\"decode_video %d.%d\", ist->file_index, ist->st->index);\n\n    // The following line may be required in some cases where there is no parser\n    // or the parser does not has_b_frames correctly\n    if (ist->st->codec->has_b_frames < ist->dec_ctx->has_b_frames) {\n        if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) {\n            ist->st->codec->has_b_frames = ist->dec_ctx->has_b_frames;\n        } else\n            av_log(ist->dec_ctx, AV_LOG_WARNING,\n                   \"has_b_frames is larger in decoder than demuxer %d > %d.\\n\"\n                   \"If you want to help, upload a sample \"\n                   \"of this file to ftp://upload.ffmpeg.org/incoming/ \"\n                   \"and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\",\n                   ist->dec_ctx->has_b_frames,\n                   ist->st->codec->has_b_frames);\n    }\n\n    check_decode_result(got_output, ret);\n\n    if (*got_output && ret >= 0) {\n        if (ist->dec_ctx->width  != decoded_frame->width ||\n            ist->dec_ctx->height != decoded_frame->height ||\n            ist->dec_ctx->pix_fmt != decoded_frame->format) {\n            av_log(NULL, AV_LOG_DEBUG, \"Frame parameters mismatch context %d,%d,%d != %d,%d,%d\\n\",\n                decoded_frame->width,\n                decoded_frame->height,\n                decoded_frame->format,\n                ist->dec_ctx->width,\n                ist->dec_ctx->height,\n                ist->dec_ctx->pix_fmt);\n        }\n    }\n\n    if (!*got_output || ret < 0)\n        return ret;\n\n    if(ist->top_field_first>=0)\n        decoded_frame->top_field_first = ist->top_field_first;\n\n    ist->frames_decoded++;\n\n    if (ist->hwaccel_retrieve_data && decoded_frame->format == ist->hwaccel_pix_fmt) {\n        err = ist->hwaccel_retrieve_data(ist->dec_ctx, decoded_frame);\n        if (err < 0)\n            goto fail;\n    }\n    ist->hwaccel_retrieved_pix_fmt = decoded_frame->format;\n\n    best_effort_timestamp= av_frame_get_best_effort_timestamp(decoded_frame);\n    if(best_effort_timestamp != AV_NOPTS_VALUE)\n        ist->next_pts = ist->pts = av_rescale_q(decoded_frame->pts = best_effort_timestamp, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if (debug_ts) {\n        av_log(NULL, AV_LOG_INFO, \"decoder -> ist_index:%d type:video \"\n               \"frame_pts:%s frame_pts_time:%s best_effort_ts:%\"PRId64\" best_effort_ts_time:%s keyframe:%d frame_type:%d time_base:%d/%d\\n\",\n               ist->st->index, av_ts2str(decoded_frame->pts),\n               av_ts2timestr(decoded_frame->pts, &ist->st->time_base),\n               best_effort_timestamp,\n               av_ts2timestr(best_effort_timestamp, &ist->st->time_base),\n               decoded_frame->key_frame, decoded_frame->pict_type,\n               ist->st->time_base.num, ist->st->time_base.den);\n    }\n\n    pkt->size = 0;\n\n    if (ist->st->sample_aspect_ratio.num)\n        decoded_frame->sample_aspect_ratio = ist->st->sample_aspect_ratio;\n\n    resample_changed = ist->resample_width   != decoded_frame->width  ||\n                       ist->resample_height  != decoded_frame->height ||\n                       ist->resample_pix_fmt != decoded_frame->format;\n    if (resample_changed) {\n        av_log(NULL, AV_LOG_INFO,\n               \"Input stream #%d:%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n               ist->file_index, ist->st->index,\n               ist->resample_width,  ist->resample_height,  av_get_pix_fmt_name(ist->resample_pix_fmt),\n               decoded_frame->width, decoded_frame->height, av_get_pix_fmt_name(decoded_frame->format));\n\n        ist->resample_width   = decoded_frame->width;\n        ist->resample_height  = decoded_frame->height;\n        ist->resample_pix_fmt = decoded_frame->format;\n\n        for (i = 0; i < nb_filtergraphs; i++) {\n            if (ist_in_filtergraph(filtergraphs[i], ist) && ist->reinit_filters &&\n                configure_filtergraph(filtergraphs[i]) < 0) {\n                av_log(NULL, AV_LOG_FATAL, \"Error reinitializing filters!\\n\");\n                exit_program(1);\n            }\n        }\n    }\n\n    frame_sample_aspect= av_opt_ptr(avcodec_get_frame_class(), decoded_frame, \"sample_aspect_ratio\");\n    for (i = 0; i < ist->nb_filters; i++) {\n        if (!frame_sample_aspect->num)\n            *frame_sample_aspect = ist->st->sample_aspect_ratio;\n\n        if (i < ist->nb_filters - 1) {\n            f = ist->filter_frame;\n            err = av_frame_ref(f, decoded_frame);\n            if (err < 0)\n                break;\n        } else\n            f = decoded_frame;\n        ret = av_buffersrc_add_frame_flags(ist->filters[i]->filter, f, AV_BUFFERSRC_FLAG_PUSH);\n        if (ret == AVERROR_EOF) {\n            ret = 0; /* ignore */\n        } else if (ret < 0) {\n            av_log(NULL, AV_LOG_FATAL,\n                   \"Failed to inject frame into filter network: %s\\n\", av_err2str(ret));\n            exit_program(1);\n        }\n    }\n\nfail:\n    av_frame_unref(ist->filter_frame);\n    av_frame_unref(decoded_frame);\n    return err < 0 ? err : ret;\n}", "before_change_lines": [35, 36, 38, 39], "raw_before_change_lines": [35, 36, 37, 38, 39], "after_change_lines": [35], "raw_after_change_lines": [35], "bug_lines": [35, 36, 37, 38, 39], "added": [false, false, false, false, false], "idx": 56}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "700----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2680642b1d433a61a33e4a5666182d1a0effb45b_1.json----mov_read_ctts", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2680642b1d433a61a33e4a5666182d1a0effb45b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2680642b1d433a61a33e4a5666182d1a0effb45b_1.json", "function_name": "mov_read_ctts", "vul_func_code": "static int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, j, entries, ctts_count = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].ctts.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->ctts_data);\n    sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int count    =avio_rb32(pb);\n        int duration =avio_rb32(pb);\n\n        if (count <= 0) {\n            av_log(c->fc, AV_LOG_TRACE,\n                   \"ignoring CTTS entry with count=%d duration=%d\\n\",\n                   count, duration);\n            continue;\n        }\n\n        /* Expand entries such that we have a 1-1 mapping with samples. */\n        for (j = 0; j < count; j++)\n            add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size, 1, duration);\n\n        av_log(c->fc, AV_LOG_TRACE, \"count=%d, duration=%d\\n\",\n                count, duration);\n\n        if (FFNABS(duration) < -(1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (i+2<entries)\n            mov_update_dts_shift(sc, duration);\n    }\n\n    sc->ctts_count = ctts_count;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    av_log(c->fc, AV_LOG_TRACE, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}", "patch_func_code": "static int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, ctts_count = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].ctts.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->ctts_data);\n    sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int count    =avio_rb32(pb);\n        int duration =avio_rb32(pb);\n\n        if (count <= 0) {\n            av_log(c->fc, AV_LOG_TRACE,\n                   \"ignoring CTTS entry with count=%d duration=%d\\n\",\n                   count, duration);\n            continue;\n        }\n\n        add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size,\n                       count, duration);\n\n        av_log(c->fc, AV_LOG_TRACE, \"count=%d, duration=%d\\n\",\n                count, duration);\n\n        if (FFNABS(duration) < -(1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (i+2<entries)\n            mov_update_dts_shift(sc, duration);\n    }\n\n    sc->ctts_count = ctts_count;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    av_log(c->fc, AV_LOG_TRACE, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}", "before_change_lines": [5, 39, 40], "raw_before_change_lines": [5, 38, 39, 40], "after_change_lines": [5, 38, 39], "raw_after_change_lines": [5, 38, 39], "bug_lines": [5, 38, 39, 40], "added": [false, false, false, false], "idx": 57}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "713----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_26fb1b43b41aa953643242b75bfff1ca03e802d4_1.json----shorten_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_26fb1b43b41aa953643242b75bfff1ca03e802d4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_26fb1b43b41aa953643242b75bfff1ca03e802d4_1.json", "function_name": "shorten_decode_frame", "vul_func_code": "static int shorten_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ShortenContext *s = avctx->priv_data;\n    int i, input_buf_size = 0;\n    int16_t *samples = data;\n    if(s->max_framesize == 0){\n        s->max_framesize= 1024; // should hopefully be enough for the first header\n        s->bitstream= av_fast_realloc(s->bitstream, &s->allocated_bitstream_size, s->max_framesize);\n    }\n\n    if(1 && s->max_framesize){//FIXME truncated\n        buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n        input_buf_size= buf_size;\n\n        if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){\n            //                printf(\"memmove\\n\");\n            memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);\n            s->bitstream_index=0;\n        }\n        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size);\n        buf= &s->bitstream[s->bitstream_index];\n        buf_size += s->bitstream_size;\n        s->bitstream_size= buf_size;\n\n        if(buf_size < s->max_framesize){\n            *data_size = 0;\n            return input_buf_size;\n        }\n    }\n    init_get_bits(&s->gb, buf, buf_size*8);\n    skip_bits(&s->gb, s->bitindex);\n    if (!s->blocksize)\n    {\n        int ret;\n        if ((ret = read_header(s)) < 0)\n            return ret;\n        *data_size = 0;\n    }\n    else\n    {\n        int cmd;\n        int len;\n        cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);\n\n        if (cmd > FN_VERBATIM) {\n            av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd);\n            if (s->bitstream_size > 0) {\n                s->bitstream_index++;\n                s->bitstream_size--;\n            }\n            return -1;\n        }\n\n        if (!is_audio_command[cmd]) {\n            /* process non-audio command */\n            switch (cmd) {\n                case FN_VERBATIM:\n                    len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);\n                    while (len--) {\n                        get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);\n                    }\n                    break;\n                case FN_BITSHIFT:\n                    s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);\n                    break;\n                case FN_BLOCKSIZE: {\n                    int blocksize = get_uint(s, av_log2(s->blocksize));\n                    if (blocksize > s->blocksize) {\n                        av_log(avctx, AV_LOG_ERROR, \"Increasing block size is not supported\\n\");\n                        return AVERROR_PATCHWELCOME;\n                    }\n                    s->blocksize = blocksize;\n                    break;\n                }\n                case FN_QUIT:\n                    break;\n            }\n            *data_size = 0;\n        } else {\n            /* process audio command */\n            int ret;\n            int residual_size = 0;\n            int channel = s->cur_chan;\n            int32_t coffset;\n            if (cmd != FN_ZERO) {\n                residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);\n                /* this is a hack as version 0 differed in defintion of get_sr_golomb_shorten */\n                if (s->version == 0)\n                    residual_size--;\n            }\n\n            if (s->nmean == 0)\n                coffset = s->offset[channel][0];\n            else {\n                int32_t sum = (s->version < 2) ? 0 : s->nmean / 2;\n                for (i=0; i<s->nmean; i++)\n                    sum += s->offset[channel][i];\n                coffset = sum / s->nmean;\n                if (s->version >= 2)\n                    coffset >>= FFMIN(1, s->bitshift);\n            }\n            switch (cmd) {\n                case FN_ZERO:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = 0;\n                    break;\n                case FN_DIFF0:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + coffset;\n                    break;\n                case FN_DIFF1:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + s->decoded[channel][i - 1];\n                    break;\n                case FN_DIFF2:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 2*s->decoded[channel][i-1]\n                                                                                              -   s->decoded[channel][i-2];\n                    break;\n                case FN_DIFF3:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 3*s->decoded[channel][i-1]\n                                                                                              - 3*s->decoded[channel][i-2]\n                                                                                              +   s->decoded[channel][i-3];\n                    break;\n                case FN_QLPC:\n                    if ((ret = decode_subframe_lpc(s, channel, residual_size, coffset)) < 0)\n                        return ret;\n                    break;\n            }\n            if (s->nmean > 0) {\n                int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2;\n                for (i=0; i<s->blocksize; i++)\n                    sum += s->decoded[channel][i];\n\n                for (i=1; i<s->nmean; i++)\n                    s->offset[channel][i-1] = s->offset[channel][i];\n\n                if (s->version < 2)\n                    s->offset[channel][s->nmean - 1] = sum / s->blocksize;\n                else\n                    s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift;\n            }\n            for (i=-s->nwrap; i<0; i++)\n                s->decoded[channel][i] = s->decoded[channel][i + s->blocksize];\n\n            fix_bitshift(s, s->decoded[channel]);\n\n            s->cur_chan++;\n            if (s->cur_chan == s->channels) {\n                samples = interleave_buffer(samples, s->channels, s->blocksize, s->decoded);\n                s->cur_chan = 0;\n                *data_size = (int8_t *)samples - (int8_t *)data;\n            } else {\n                *data_size = 0;\n            }\n        }\n    }\n\n    //    s->last_blocksize = s->blocksize;\n    s->bitindex = get_bits_count(&s->gb) - 8*((get_bits_count(&s->gb))/8);\n    i= (get_bits_count(&s->gb))/8;\n    if (i > buf_size) {\n        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);\n        s->bitstream_size=0;\n        s->bitstream_index=0;\n        return -1;\n    }\n    if (s->bitstream_size) {\n        s->bitstream_index += i;\n        s->bitstream_size  -= i;\n        return input_buf_size;\n    } else\n        return i;\n}", "patch_func_code": "static int shorten_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ShortenContext *s = avctx->priv_data;\n    int i, input_buf_size = 0;\n    int16_t *samples = data;\n    if(s->max_framesize == 0){\n        void *tmp_ptr;\n        s->max_framesize= 1024; // should hopefully be enough for the first header\n        tmp_ptr = av_fast_realloc(s->bitstream, &s->allocated_bitstream_size,\n                                  s->max_framesize);\n        if (!tmp_ptr) {\n            av_log(avctx, AV_LOG_ERROR, \"error allocating bitstream buffer\\n\");\n            return AVERROR(ENOMEM);\n        }\n        s->bitstream = tmp_ptr;\n    }\n\n    if(1 && s->max_framesize){//FIXME truncated\n        buf_size= FFMIN(buf_size, s->max_framesize - s->bitstream_size);\n        input_buf_size= buf_size;\n\n        if(s->bitstream_index + s->bitstream_size + buf_size > s->allocated_bitstream_size){\n            //                printf(\"memmove\\n\");\n            memmove(s->bitstream, &s->bitstream[s->bitstream_index], s->bitstream_size);\n            s->bitstream_index=0;\n        }\n        memcpy(&s->bitstream[s->bitstream_index + s->bitstream_size], buf, buf_size);\n        buf= &s->bitstream[s->bitstream_index];\n        buf_size += s->bitstream_size;\n        s->bitstream_size= buf_size;\n\n        if(buf_size < s->max_framesize){\n            *data_size = 0;\n            return input_buf_size;\n        }\n    }\n    init_get_bits(&s->gb, buf, buf_size*8);\n    skip_bits(&s->gb, s->bitindex);\n    if (!s->blocksize)\n    {\n        int ret;\n        if ((ret = read_header(s)) < 0)\n            return ret;\n        *data_size = 0;\n    }\n    else\n    {\n        int cmd;\n        int len;\n        cmd = get_ur_golomb_shorten(&s->gb, FNSIZE);\n\n        if (cmd > FN_VERBATIM) {\n            av_log(avctx, AV_LOG_ERROR, \"unknown shorten function %d\\n\", cmd);\n            if (s->bitstream_size > 0) {\n                s->bitstream_index++;\n                s->bitstream_size--;\n            }\n            return -1;\n        }\n\n        if (!is_audio_command[cmd]) {\n            /* process non-audio command */\n            switch (cmd) {\n                case FN_VERBATIM:\n                    len = get_ur_golomb_shorten(&s->gb, VERBATIM_CKSIZE_SIZE);\n                    while (len--) {\n                        get_ur_golomb_shorten(&s->gb, VERBATIM_BYTE_SIZE);\n                    }\n                    break;\n                case FN_BITSHIFT:\n                    s->bitshift = get_ur_golomb_shorten(&s->gb, BITSHIFTSIZE);\n                    break;\n                case FN_BLOCKSIZE: {\n                    int blocksize = get_uint(s, av_log2(s->blocksize));\n                    if (blocksize > s->blocksize) {\n                        av_log(avctx, AV_LOG_ERROR, \"Increasing block size is not supported\\n\");\n                        return AVERROR_PATCHWELCOME;\n                    }\n                    s->blocksize = blocksize;\n                    break;\n                }\n                case FN_QUIT:\n                    break;\n            }\n            *data_size = 0;\n        } else {\n            /* process audio command */\n            int ret;\n            int residual_size = 0;\n            int channel = s->cur_chan;\n            int32_t coffset;\n            if (cmd != FN_ZERO) {\n                residual_size = get_ur_golomb_shorten(&s->gb, ENERGYSIZE);\n                /* this is a hack as version 0 differed in defintion of get_sr_golomb_shorten */\n                if (s->version == 0)\n                    residual_size--;\n            }\n\n            if (s->nmean == 0)\n                coffset = s->offset[channel][0];\n            else {\n                int32_t sum = (s->version < 2) ? 0 : s->nmean / 2;\n                for (i=0; i<s->nmean; i++)\n                    sum += s->offset[channel][i];\n                coffset = sum / s->nmean;\n                if (s->version >= 2)\n                    coffset >>= FFMIN(1, s->bitshift);\n            }\n            switch (cmd) {\n                case FN_ZERO:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = 0;\n                    break;\n                case FN_DIFF0:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + coffset;\n                    break;\n                case FN_DIFF1:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + s->decoded[channel][i - 1];\n                    break;\n                case FN_DIFF2:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 2*s->decoded[channel][i-1]\n                                                                                              -   s->decoded[channel][i-2];\n                    break;\n                case FN_DIFF3:\n                    for (i=0; i<s->blocksize; i++)\n                        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + 3*s->decoded[channel][i-1]\n                                                                                              - 3*s->decoded[channel][i-2]\n                                                                                              +   s->decoded[channel][i-3];\n                    break;\n                case FN_QLPC:\n                    if ((ret = decode_subframe_lpc(s, channel, residual_size, coffset)) < 0)\n                        return ret;\n                    break;\n            }\n            if (s->nmean > 0) {\n                int32_t sum = (s->version < 2) ? 0 : s->blocksize / 2;\n                for (i=0; i<s->blocksize; i++)\n                    sum += s->decoded[channel][i];\n\n                for (i=1; i<s->nmean; i++)\n                    s->offset[channel][i-1] = s->offset[channel][i];\n\n                if (s->version < 2)\n                    s->offset[channel][s->nmean - 1] = sum / s->blocksize;\n                else\n                    s->offset[channel][s->nmean - 1] = (sum / s->blocksize) << s->bitshift;\n            }\n            for (i=-s->nwrap; i<0; i++)\n                s->decoded[channel][i] = s->decoded[channel][i + s->blocksize];\n\n            fix_bitshift(s, s->decoded[channel]);\n\n            s->cur_chan++;\n            if (s->cur_chan == s->channels) {\n                samples = interleave_buffer(samples, s->channels, s->blocksize, s->decoded);\n                s->cur_chan = 0;\n                *data_size = (int8_t *)samples - (int8_t *)data;\n            } else {\n                *data_size = 0;\n            }\n        }\n    }\n\n    //    s->last_blocksize = s->blocksize;\n    s->bitindex = get_bits_count(&s->gb) - 8*((get_bits_count(&s->gb))/8);\n    i= (get_bits_count(&s->gb))/8;\n    if (i > buf_size) {\n        av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", i - buf_size);\n        s->bitstream_size=0;\n        s->bitstream_index=0;\n        return -1;\n    }\n    if (s->bitstream_size) {\n        s->bitstream_index += i;\n        s->bitstream_size  -= i;\n        return input_buf_size;\n    } else\n        return i;\n}", "before_change_lines": [12], "raw_before_change_lines": [12], "after_change_lines": [11, 13, 14, 15, 16, 17, 18, 19], "raw_after_change_lines": [11, 13, 14, 15, 16, 17, 18, 19], "bug_lines": [12], "added": [false], "idx": 58}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "721----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_27290c00872fe5ce79d9fd10482556e001e175a3_1.json----filter_common", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_27290c00872fe5ce79d9fd10482556e001e175a3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_27290c00872fe5ce79d9fd10482556e001e175a3_1.json", "function_name": "filter_common", "vul_func_code": "static av_always_inline void filter_common(uint8_t *p, ptrdiff_t stride,\n                                           int is4tap)\n{\n    LOAD_PIXELS\n    int a, f1, f2;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n\n    a = 3 * (q0 - p0);\n\n    if (is4tap)\n        a += clip_int8(p1 - q1);\n\n    a = clip_int8(a);\n\n    // We deviate from the spec here with c(a+3) >> 3\n    // since that's what libvpx does.\n    f1 = FFMIN(a + 4, 127) >> 3;\n    f2 = FFMIN(a + 3, 127) >> 3;\n\n    // Despite what the spec says, we do need to clamp here to\n    // be bitexact with libvpx.\n    p[-1 * stride] = cm[p0 + f2];\n    p[ 0 * stride] = cm[q0 - f1];\n\n    // only used for _inner on blocks without high edge variance\n    if (!is4tap) {\n        a = (f1 + 1) >> 1;\n        p[-2 * stride] = cm[p1 + a];\n        p[ 1 * stride] = cm[q1 - a];\n    }\n}", "patch_func_code": "static av_always_inline void filter_common(uint8_t *p, ptrdiff_t stride,\n                                           int is4tap, int is_vp7)\n{\n    LOAD_PIXELS\n    int a, f1, f2;\n    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;\n\n    a = 3 * (q0 - p0);\n\n    if (is4tap)\n        a += clip_int8(p1 - q1);\n\n    a = clip_int8(a);\n\n    // We deviate from the spec here with c(a+3) >> 3\n    // since that's what libvpx does.\n    f1 = FFMIN(a + 4, 127) >> 3;\n\n    if (is_vp7)\n        f2 = f1 - ((a & 7) == 4);\n    else\n        f2 = FFMIN(a + 3, 127) >> 3;\n\n    // Despite what the spec says, we do need to clamp here to\n    // be bitexact with libvpx.\n    p[-1 * stride] = cm[p0 + f2];\n    p[ 0 * stride] = cm[q0 - f1];\n\n    // only used for _inner on blocks without high edge variance\n    if (!is4tap) {\n        a              = (f1 + 1) >> 1;\n        p[-2 * stride] = cm[p1 + a];\n        p[ 1 * stride] = cm[q1 - a];\n    }\n}", "before_change_lines": [2, 18, 27], "raw_before_change_lines": [2, 18, 27], "after_change_lines": [2, 19, 20, 21, 22, 31], "raw_after_change_lines": [2, 18, 19, 20, 21, 22, 31], "bug_lines": [2, 18, 27], "added": [false, false, false], "idx": 59}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "734----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_27b6dbc8d408adfa769a47cda3d7d0fe7689c406_1.json----ff_dca_core_parse", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_27b6dbc8d408adfa769a47cda3d7d0fe7689c406_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_27b6dbc8d408adfa769a47cda3d7d0fe7689c406_1.json", "function_name": "ff_dca_core_parse", "vul_func_code": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n{\n    int ret;\n\n    s->ext_audio_mask = 0;\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n        return ret;\n    s->gb_in = s->gb;\n\n    if ((ret = parse_frame_header(s)) < 0)\n        return ret;\n    if ((ret = alloc_sample_buffer(s)) < 0)\n        return ret;\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n        return ret;\n    if ((ret = parse_optional_info(s)) < 0)\n        return ret;\n\n    // Workaround for DTS in WAV\n    if (s->frame_size > size && s->frame_size < size + 4)\n        s->frame_size = size;\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "patch_func_code": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n{\n    int ret;\n\n    s->ext_audio_mask = 0;\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n        return ret;\n    s->gb_in = s->gb;\n\n    if ((ret = parse_frame_header(s)) < 0)\n        return ret;\n    if ((ret = alloc_sample_buffer(s)) < 0)\n        return ret;\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n        return ret;\n    if ((ret = parse_optional_info(s)) < 0)\n        return ret;\n\n    // Workaround for DTS in WAV\n    if (s->frame_size > size)\n        s->frame_size = size;\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n            return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "before_change_lines": [22], "raw_before_change_lines": [22], "after_change_lines": [22], "raw_after_change_lines": [22], "bug_lines": [22], "added": [false], "idx": 60}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "746----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_28831a56da3d3a71460805e8c60b3be56f2cc7fb_1.json----sbr_hf_calc_npatches", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_28831a56da3d3a71460805e8c60b3be56f2cc7fb_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_28831a56da3d3a71460805e8c60b3be56f2cc7fb_1.json", "function_name": "sbr_hf_calc_npatches", "vul_func_code": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n{\n    int i, k, sb = 0;\n    int msb = sbr->k[0];\n    int usb = sbr->kx[1];\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n    sbr->num_patches = 0;\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n    } else\n        k = sbr->n_master;\n\n    do {\n        int odd = 0;\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n            sb = sbr->f_master[i];\n            odd = (sb + sbr->k[0]) & 1;\n        }\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n            usb = sb;\n            msb = sb;\n            sbr->num_patches++;\n        } else\n            msb = sbr->kx[1];\n\n        if (sbr->f_master[k] - sb < 3)\n            k = sbr->n_master;\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n        sbr->num_patches--;\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n    // However the Coding Technologies decoder check uses 6 patches\n    if (sbr->num_patches > 6) {\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n        return -1;\n    }\n\n    return 0;\n}", "patch_func_code": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n{\n    int i, k, sb = 0;\n    int msb = sbr->k[0];\n    int usb = sbr->kx[1];\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n    sbr->num_patches = 0;\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n    } else\n        k = sbr->n_master;\n\n    do {\n        int odd = 0;\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n            sb = sbr->f_master[i];\n            odd = (sb + sbr->k[0]) & 1;\n        }\n\n        // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5.\n        // After this check the final number of patches can still be six which is\n        // illegal however the Coding Technologies decoder check stream has a final\n        // count of 6 patches\n        if (sbr->num_patches > 5) {\n            av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n            return -1;\n        }\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n            usb = sb;\n            msb = sb;\n            sbr->num_patches++;\n        } else\n            msb = sbr->kx[1];\n\n        if (sbr->f_master[k] - sb < 3)\n            k = sbr->n_master;\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n        sbr->num_patches--;\n\n    return 0;\n}", "before_change_lines": [41, 42, 43, 44], "raw_before_change_lines": [39, 40, 41, 42, 43, 44, 45], "after_change_lines": [26, 27, 28, 29], "raw_after_change_lines": [22, 23, 24, 25, 26, 27, 28, 29, 30], "bug_lines": [39, 40, 41, 42, 43, 44, 45], "added": [false, false, false, false, false, false, false], "idx": 61}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "784----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2afa70c9848a688ee659195631cc9e5ca3b8121f_1.json----write_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2afa70c9848a688ee659195631cc9e5ca3b8121f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2afa70c9848a688ee659195631cc9e5ca3b8121f_1.json", "function_name": "write_packet", "vul_func_code": "static void write_packet(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n{\n    AVStream *st = ost->st;\n    int ret;\n\n    /*\n     * Audio encoders may split the packets --  #frames in != #packets out.\n     * But there is no reordering, so we can limit the number of output packets\n     * by simply dropping them here.\n     * Counting encoded video frames needs to be done separately because of\n     * reordering, see do_video_out()\n     */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed)) {\n        if (ost->frame_number >= ost->max_frames) {\n            av_packet_unref(pkt);\n            return;\n        }\n        ost->frame_number++;\n    }\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_FACTOR,\n                                              NULL);\n        ost->quality = sd ? *(int *)sd : -1;\n\n        if (ost->frame_rate.num) {\n            pkt->duration = av_rescale_q(1, av_inv_q(ost->frame_rate),\n                                         ost->st->time_base);\n        }\n    }\n\n    if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS) &&\n        ost->last_mux_dts != AV_NOPTS_VALUE &&\n        pkt->dts < ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT)) {\n        av_log(NULL, AV_LOG_WARNING, \"Non-monotonous DTS in output stream \"\n               \"%d:%d; previous: %\"PRId64\", current: %\"PRId64\"; \",\n               ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts);\n        if (exit_on_error) {\n            av_log(NULL, AV_LOG_FATAL, \"aborting.\\n\");\n            exit_program(1);\n        }\n        av_log(NULL, AV_LOG_WARNING, \"changing to %\"PRId64\". This may result \"\n               \"in incorrect timestamps in the output file.\\n\",\n               ost->last_mux_dts + 1);\n        pkt->dts = ost->last_mux_dts + 1;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts = FFMAX(pkt->pts, pkt->dts);\n    }\n    ost->last_mux_dts = pkt->dts;\n\n    ost->data_size += pkt->size;\n    ost->packets_written++;\n\n    pkt->stream_index = ost->index;\n    ret = av_interleaved_write_frame(s, pkt);\n    if (ret < 0) {\n        print_error(\"av_interleaved_write_frame()\", ret);\n        exit_program(1);\n    }\n}", "patch_func_code": "static void write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost)\n{\n    AVFormatContext *s = of->ctx;\n    AVStream *st = ost->st;\n    int ret;\n\n    if (!of->header_written) {\n        AVPacket tmp_pkt;\n        /* the muxer is not initialized yet, buffer the packet */\n        if (!av_fifo_space(ost->muxing_queue)) {\n            int new_size = FFMIN(2 * av_fifo_size(ost->muxing_queue),\n                                 ost->max_muxing_queue_size);\n            if (new_size <= av_fifo_size(ost->muxing_queue)) {\n                av_log(NULL, AV_LOG_ERROR,\n                       \"Too many packets buffered for output stream %d:%d.\\n\",\n                       ost->file_index, ost->st->index);\n                exit_program(1);\n            }\n            ret = av_fifo_realloc2(ost->muxing_queue, new_size);\n            if (ret < 0)\n                exit_program(1);\n        }\n        av_packet_move_ref(&tmp_pkt, pkt);\n        av_fifo_generic_write(ost->muxing_queue, &tmp_pkt, sizeof(tmp_pkt), NULL);\n        return;\n    }\n\n    /*\n     * Audio encoders may split the packets --  #frames in != #packets out.\n     * But there is no reordering, so we can limit the number of output packets\n     * by simply dropping them here.\n     * Counting encoded video frames needs to be done separately because of\n     * reordering, see do_video_out()\n     */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed)) {\n        if (ost->frame_number >= ost->max_frames) {\n            av_packet_unref(pkt);\n            return;\n        }\n        ost->frame_number++;\n    }\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        uint8_t *sd = av_packet_get_side_data(pkt, AV_PKT_DATA_QUALITY_FACTOR,\n                                              NULL);\n        ost->quality = sd ? *(int *)sd : -1;\n\n        if (ost->frame_rate.num) {\n            pkt->duration = av_rescale_q(1, av_inv_q(ost->frame_rate),\n                                         ost->st->time_base);\n        }\n    }\n\n    if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS) &&\n        ost->last_mux_dts != AV_NOPTS_VALUE &&\n        pkt->dts < ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT)) {\n        av_log(NULL, AV_LOG_WARNING, \"Non-monotonous DTS in output stream \"\n               \"%d:%d; previous: %\"PRId64\", current: %\"PRId64\"; \",\n               ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts);\n        if (exit_on_error) {\n            av_log(NULL, AV_LOG_FATAL, \"aborting.\\n\");\n            exit_program(1);\n        }\n        av_log(NULL, AV_LOG_WARNING, \"changing to %\"PRId64\". This may result \"\n               \"in incorrect timestamps in the output file.\\n\",\n               ost->last_mux_dts + 1);\n        pkt->dts = ost->last_mux_dts + 1;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts = FFMAX(pkt->pts, pkt->dts);\n    }\n    ost->last_mux_dts = pkt->dts;\n\n    ost->data_size += pkt->size;\n    ost->packets_written++;\n\n    pkt->stream_index = ost->index;\n    ret = av_interleaved_write_frame(s, pkt);\n    if (ret < 0) {\n        print_error(\"av_interleaved_write_frame()\", ret);\n        exit_program(1);\n    }\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1, 3, 7, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26], "raw_after_change_lines": [1, 3, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27], "bug_lines": [1], "added": [false], "idx": 62}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "799----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2bdb329dc5ae63c78558cb1617c21fb0dcec65c4_1.json----avfilter_start_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2bdb329dc5ae63c78558cb1617c21fb0dcec65c4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2bdb329dc5ae63c78558cb1617c21fb0dcec65c4_1.json", "function_name": "avfilter_start_frame", "vul_func_code": "void avfilter_start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n{\n    void (*start_frame)(AVFilterLink *, AVFilterBufferRef *);\n    AVFilterPad *dst = link->dstpad;\n\n    FF_DPRINTF_START(NULL, start_frame); ff_dprintf_link(NULL, link, 0); dprintf(NULL, \" \"); ff_dprintf_ref(NULL, picref, 1);\n\n    if (!(start_frame = dst->start_frame))\n        start_frame = avfilter_default_start_frame;\n\n    /* prepare to copy the picture if it has insufficient permissions */\n    if ((dst->min_perms & picref->perms) != dst->min_perms ||\n         dst->rej_perms & picref->perms) {\n        av_log(link->dst, AV_LOG_DEBUG,\n                \"frame copy needed (have perms %x, need %x, reject %x)\\n\",\n                picref->perms,\n                link->dstpad->min_perms, link->dstpad->rej_perms);\n\n        link->cur_buf = avfilter_get_video_buffer(link, dst->min_perms, link->w, link->h);\n        link->src_buf = picref;\n        avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf);\n    }\n    else\n        link->cur_buf = picref;\n\n    start_frame(link, link->cur_buf);\n}", "patch_func_code": "void avfilter_start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n{\n    void (*start_frame)(AVFilterLink *, AVFilterBufferRef *);\n    AVFilterPad *dst = link->dstpad;\n    int perms = picref->perms;\n\n    FF_DPRINTF_START(NULL, start_frame); ff_dprintf_link(NULL, link, 0); dprintf(NULL, \" \"); ff_dprintf_ref(NULL, picref, 1);\n\n    if (!(start_frame = dst->start_frame))\n        start_frame = avfilter_default_start_frame;\n\n    if (picref->linesize[0] < 0)\n        perms |= AV_PERM_NEG_LINESIZES;\n    /* prepare to copy the picture if it has insufficient permissions */\n    if ((dst->min_perms & perms) != dst->min_perms || dst->rej_perms & perms) {\n        av_log(link->dst, AV_LOG_DEBUG,\n                \"frame copy needed (have perms %x, need %x, reject %x)\\n\",\n                picref->perms,\n                link->dstpad->min_perms, link->dstpad->rej_perms);\n\n        link->cur_buf = avfilter_get_video_buffer(link, dst->min_perms, link->w, link->h);\n        link->src_buf = picref;\n        avfilter_copy_buffer_ref_props(link->cur_buf, link->src_buf);\n    }\n    else\n        link->cur_buf = picref;\n\n    start_frame(link, link->cur_buf);\n}", "before_change_lines": [12, 13], "raw_before_change_lines": [12, 13], "after_change_lines": [5, 12, 13, 15], "raw_after_change_lines": [5, 12, 13, 15], "bug_lines": [12, 13], "added": [false, false], "idx": 63}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "800----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2be7fa1eed74d33b22a60b9093c9e8f17f9d1ff4_1.json----compute_pkt_fields", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2be7fa1eed74d33b22a60b9093c9e8f17f9d1ff4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2be7fa1eed74d33b22a60b9093c9e8f17f9d1ff4_1.json", "function_name": "compute_pkt_fields", "vul_func_code": "static void compute_pkt_fields(AVFormatContext *s, AVStream *st,\n                               AVCodecParserContext *pc, AVPacket *pkt,\n                               int64_t next_dts, int64_t next_pts)\n{\n    int num, den, presentation_delayed, delay, i;\n    int64_t offset;\n    AVRational duration;\n    int onein_oneout = st->codec->codec_id != AV_CODEC_ID_H264 &&\n                       st->codec->codec_id != AV_CODEC_ID_HEVC;\n\n    if (s->flags & AVFMT_FLAG_NOFILLIN)\n        return;\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pkt->dts != AV_NOPTS_VALUE) {\n        if (pkt->dts == pkt->pts && st->last_dts_for_order_check != AV_NOPTS_VALUE) {\n            if (st->last_dts_for_order_check <= pkt->dts) {\n                st->dts_ordered++;\n            } else {\n                av_log(s, st->dts_misordered ? AV_LOG_DEBUG : AV_LOG_WARNING,\n                       \"DTS %\"PRIi64\" < %\"PRIi64\" out of order\\n\",\n                       pkt->dts,\n                       st->last_dts_for_order_check);\n                st->dts_misordered++;\n            }\n            if (st->dts_ordered + st->dts_misordered > 250) {\n                st->dts_ordered    >>= 1;\n                st->dts_misordered >>= 1;\n            }\n        }\n\n        st->last_dts_for_order_check = pkt->dts;\n        if (st->dts_ordered < 8*st->dts_misordered && pkt->dts == pkt->pts)\n            pkt->dts = AV_NOPTS_VALUE;\n    }\n\n    if ((s->flags & AVFMT_FLAG_IGNDTS) && pkt->pts != AV_NOPTS_VALUE)\n        pkt->dts = AV_NOPTS_VALUE;\n\n    if (pc && pc->pict_type == AV_PICTURE_TYPE_B\n        && !st->codec->has_b_frames)\n        //FIXME Set low_delay = 0 when has_b_frames = 1\n        st->codec->has_b_frames = 1;\n\n    /* do we have a video B-frame ? */\n    delay = st->codec->has_b_frames;\n    presentation_delayed = 0;\n\n    /* XXX: need has_b_frame, but cannot get it if the codec is\n     *  not initialized */\n    if (delay &&\n        pc && pc->pict_type != AV_PICTURE_TYPE_B)\n        presentation_delayed = 1;\n\n    if (pkt->pts != AV_NOPTS_VALUE && pkt->dts != AV_NOPTS_VALUE &&\n        st->pts_wrap_bits < 63 &&\n        pkt->dts - (1LL << (st->pts_wrap_bits - 1)) > pkt->pts) {\n        if (is_relative(st->cur_dts) || pkt->dts - (1LL<<(st->pts_wrap_bits - 1)) > st->cur_dts) {\n            pkt->dts -= 1LL << st->pts_wrap_bits;\n        } else\n            pkt->pts += 1LL << st->pts_wrap_bits;\n    }\n\n    /* Some MPEG-2 in MPEG-PS lack dts (issue #171 / input_file.mpg).\n     * We take the conservative approach and discard both.\n     * Note: If this is misbehaving for an H.264 file, then possibly\n     * presentation_delayed is not set correctly. */\n    if (delay == 1 && pkt->dts == pkt->pts &&\n        pkt->dts != AV_NOPTS_VALUE && presentation_delayed) {\n        av_log(s, AV_LOG_DEBUG, \"invalid dts/pts combination %\"PRIi64\"\\n\", pkt->dts);\n        if (    strcmp(s->iformat->name, \"mov,mp4,m4a,3gp,3g2,mj2\")\n             && strcmp(s->iformat->name, \"flv\")) // otherwise we discard correct timestamps for vc1-wmapro.ism\n            pkt->dts = AV_NOPTS_VALUE;\n    }\n\n    duration = av_mul_q((AVRational) {pkt->duration, 1}, st->time_base);\n    if (pkt->duration == 0) {\n        ff_compute_frame_duration(s, &num, &den, st, pc, pkt);\n        if (den && num) {\n            duration = (AVRational) {num, den};\n            pkt->duration = av_rescale_rnd(1,\n                                           num * (int64_t) st->time_base.den,\n                                           den * (int64_t) st->time_base.num,\n                                           AV_ROUND_DOWN);\n        }\n    }\n\n    if (pkt->duration != 0 && (s->packet_buffer || s->parse_queue))\n        update_initial_durations(s, st, pkt->stream_index, pkt->duration);\n\n    /* Correct timestamps with byte offset if demuxers only have timestamps\n     * on packet boundaries */\n    if (pc && st->need_parsing == AVSTREAM_PARSE_TIMESTAMPS && pkt->size) {\n        /* this will estimate bitrate based on this frame's duration and size */\n        offset = av_rescale(pc->offset, pkt->duration, pkt->size);\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n    }\n\n    /* This may be redundant, but it should not hurt. */\n    if (pkt->dts != AV_NOPTS_VALUE &&\n        pkt->pts != AV_NOPTS_VALUE &&\n        pkt->pts > pkt->dts)\n        presentation_delayed = 1;\n\n    av_dlog(NULL,\n            \"IN delayed:%d pts:%s, dts:%s cur_dts:%s st:%d pc:%p duration:%d delay:%d onein_oneout:%d\\n\",\n            presentation_delayed, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts),\n            pkt->stream_index, pc, pkt->duration, delay, onein_oneout);\n    /* Interpolate PTS and DTS if they are not present. We skip H264\n     * currently because delay and has_b_frames are not reliably set. */\n    if ((delay == 0 || (delay == 1 && pc)) &&\n        onein_oneout) {\n        if (presentation_delayed) {\n            /* DTS = decompression timestamp */\n            /* PTS = presentation timestamp */\n            if (pkt->dts == AV_NOPTS_VALUE)\n                pkt->dts = st->last_IP_pts;\n            update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt);\n            if (pkt->dts == AV_NOPTS_VALUE)\n                pkt->dts = st->cur_dts;\n\n            /* This is tricky: the dts must be incremented by the duration\n             * of the frame we are displaying, i.e. the last I- or P-frame. */\n            if (st->last_IP_duration == 0)\n                st->last_IP_duration = pkt->duration;\n            if (pkt->dts != AV_NOPTS_VALUE)\n                st->cur_dts = pkt->dts + st->last_IP_duration;\n            if (pkt->dts != AV_NOPTS_VALUE &&\n                pkt->pts == AV_NOPTS_VALUE &&\n                st->last_IP_duration > 0 &&\n                (st->cur_dts - next_dts) <= 1 &&\n                next_dts != next_pts &&\n                next_pts != AV_NOPTS_VALUE)\n                pkt->pts = next_dts;\n\n            st->last_IP_duration = pkt->duration;\n            st->last_IP_pts      = pkt->pts;\n            /* Cannot compute PTS if not present (we can compute it only\n             * by knowing the future. */\n        } else if (pkt->pts != AV_NOPTS_VALUE ||\n                   pkt->dts != AV_NOPTS_VALUE ||\n                   pkt->duration                ) {\n\n            /* presentation is not delayed : PTS and DTS are the same */\n            if (pkt->pts == AV_NOPTS_VALUE)\n                pkt->pts = pkt->dts;\n            update_initial_timestamps(s, pkt->stream_index, pkt->pts,\n                                      pkt->pts, pkt);\n            if (pkt->pts == AV_NOPTS_VALUE)\n                pkt->pts = st->cur_dts;\n            pkt->dts = pkt->pts;\n            if (pkt->pts != AV_NOPTS_VALUE)\n                st->cur_dts = av_add_stable(st->time_base, pkt->pts, duration, 1);\n        }\n    }\n\n    if (pkt->pts != AV_NOPTS_VALUE && delay <= MAX_REORDER_DELAY && has_decode_delay_been_guessed(st)) {\n        st->pts_buffer[0] = pkt->pts;\n        for (i = 0; i<delay && st->pts_buffer[i] > st->pts_buffer[i + 1]; i++)\n            FFSWAP(int64_t, st->pts_buffer[i], st->pts_buffer[i + 1]);\n\n        pkt->dts = select_from_pts_buffer(st, st->pts_buffer, pkt->dts);\n    }\n    // We skipped it above so we try here.\n    if (!onein_oneout)\n        // This should happen on the first packet\n        update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt);\n    if (pkt->dts > st->cur_dts)\n        st->cur_dts = pkt->dts;\n\n    av_dlog(NULL, \"OUTdelayed:%d/%d pts:%s, dts:%s cur_dts:%s\\n\",\n            presentation_delayed, delay, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts));\n\n    /* update flags */\n    if (is_intra_only(st->codec))\n        pkt->flags |= AV_PKT_FLAG_KEY;\n    if (pc)\n        pkt->convergence_duration = pc->convergence_duration;\n}", "patch_func_code": "static void compute_pkt_fields(AVFormatContext *s, AVStream *st,\n                               AVCodecParserContext *pc, AVPacket *pkt,\n                               int64_t next_dts, int64_t next_pts)\n{\n    int num, den, presentation_delayed, delay, i;\n    int64_t offset;\n    AVRational duration;\n    int onein_oneout = st->codec->codec_id != AV_CODEC_ID_H264 &&\n                       st->codec->codec_id != AV_CODEC_ID_HEVC;\n\n    if (s->flags & AVFMT_FLAG_NOFILLIN)\n        return;\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO && pkt->dts != AV_NOPTS_VALUE) {\n        if (pkt->dts == pkt->pts && st->last_dts_for_order_check != AV_NOPTS_VALUE) {\n            if (st->last_dts_for_order_check <= pkt->dts) {\n                st->dts_ordered++;\n            } else {\n                av_log(s, st->dts_misordered ? AV_LOG_DEBUG : AV_LOG_WARNING,\n                       \"DTS %\"PRIi64\" < %\"PRIi64\" out of order\\n\",\n                       pkt->dts,\n                       st->last_dts_for_order_check);\n                st->dts_misordered++;\n            }\n            if (st->dts_ordered + st->dts_misordered > 250) {\n                st->dts_ordered    >>= 1;\n                st->dts_misordered >>= 1;\n            }\n        }\n\n        st->last_dts_for_order_check = pkt->dts;\n        if (st->dts_ordered < 8*st->dts_misordered && pkt->dts == pkt->pts)\n            pkt->dts = AV_NOPTS_VALUE;\n    }\n\n    if ((s->flags & AVFMT_FLAG_IGNDTS) && pkt->pts != AV_NOPTS_VALUE)\n        pkt->dts = AV_NOPTS_VALUE;\n\n    if (pc && pc->pict_type == AV_PICTURE_TYPE_B\n        && !st->codec->has_b_frames)\n        //FIXME Set low_delay = 0 when has_b_frames = 1\n        st->codec->has_b_frames = 1;\n\n    /* do we have a video B-frame ? */\n    delay = st->codec->has_b_frames;\n    presentation_delayed = 0;\n\n    /* XXX: need has_b_frame, but cannot get it if the codec is\n     *  not initialized */\n    if (delay &&\n        pc && pc->pict_type != AV_PICTURE_TYPE_B)\n        presentation_delayed = 1;\n\n    if (pkt->pts != AV_NOPTS_VALUE && pkt->dts != AV_NOPTS_VALUE &&\n        st->pts_wrap_bits < 63 &&\n        pkt->dts - (1LL << (st->pts_wrap_bits - 1)) > pkt->pts) {\n        if (is_relative(st->cur_dts) || pkt->dts - (1LL<<(st->pts_wrap_bits - 1)) > st->cur_dts) {\n            pkt->dts -= 1LL << st->pts_wrap_bits;\n        } else\n            pkt->pts += 1LL << st->pts_wrap_bits;\n    }\n\n    /* Some MPEG-2 in MPEG-PS lack dts (issue #171 / input_file.mpg).\n     * We take the conservative approach and discard both.\n     * Note: If this is misbehaving for an H.264 file, then possibly\n     * presentation_delayed is not set correctly. */\n    if (delay == 1 && pkt->dts == pkt->pts &&\n        pkt->dts != AV_NOPTS_VALUE && presentation_delayed) {\n        av_log(s, AV_LOG_DEBUG, \"invalid dts/pts combination %\"PRIi64\"\\n\", pkt->dts);\n        if (    strcmp(s->iformat->name, \"mov,mp4,m4a,3gp,3g2,mj2\")\n             && strcmp(s->iformat->name, \"flv\")) // otherwise we discard correct timestamps for vc1-wmapro.ism\n            pkt->dts = AV_NOPTS_VALUE;\n    }\n\n    duration = av_mul_q((AVRational) {pkt->duration, 1}, st->time_base);\n    if (pkt->duration == 0) {\n        ff_compute_frame_duration(s, &num, &den, st, pc, pkt);\n        if (den && num) {\n            duration = (AVRational) {num, den};\n            pkt->duration = av_rescale_rnd(1,\n                                           num * (int64_t) st->time_base.den,\n                                           den * (int64_t) st->time_base.num,\n                                           AV_ROUND_DOWN);\n        }\n    }\n\n    if (pkt->duration != 0 && (s->packet_buffer || s->parse_queue))\n        update_initial_durations(s, st, pkt->stream_index, pkt->duration);\n\n    /* Correct timestamps with byte offset if demuxers only have timestamps\n     * on packet boundaries */\n    if (pc && st->need_parsing == AVSTREAM_PARSE_TIMESTAMPS && pkt->size) {\n        /* this will estimate bitrate based on this frame's duration and size */\n        offset = av_rescale(pc->offset, pkt->duration, pkt->size);\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n    }\n\n    /* This may be redundant, but it should not hurt. */\n    if (pkt->dts != AV_NOPTS_VALUE &&\n        pkt->pts != AV_NOPTS_VALUE &&\n        pkt->pts > pkt->dts)\n        presentation_delayed = 1;\n\n    av_dlog(NULL,\n            \"IN delayed:%d pts:%s, dts:%s cur_dts:%s st:%d pc:%p duration:%d delay:%d onein_oneout:%d\\n\",\n            presentation_delayed, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts),\n            pkt->stream_index, pc, pkt->duration, delay, onein_oneout);\n    /* Interpolate PTS and DTS if they are not present. We skip H264\n     * currently because delay and has_b_frames are not reliably set. */\n    if ((delay == 0 || (delay == 1 && pc)) &&\n        onein_oneout) {\n        if (presentation_delayed) {\n            /* DTS = decompression timestamp */\n            /* PTS = presentation timestamp */\n            if (pkt->dts == AV_NOPTS_VALUE)\n                pkt->dts = st->last_IP_pts;\n            update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt);\n            if (pkt->dts == AV_NOPTS_VALUE)\n                pkt->dts = st->cur_dts;\n\n            /* This is tricky: the dts must be incremented by the duration\n             * of the frame we are displaying, i.e. the last I- or P-frame. */\n            if (st->last_IP_duration == 0)\n                st->last_IP_duration = pkt->duration;\n            if (pkt->dts != AV_NOPTS_VALUE)\n                st->cur_dts = pkt->dts + st->last_IP_duration;\n            if (pkt->dts != AV_NOPTS_VALUE &&\n                pkt->pts == AV_NOPTS_VALUE &&\n                st->last_IP_duration > 0 &&\n                ((uint64_t)st->cur_dts - (uint64_t)next_dts + 1) <= 2 &&\n                next_dts != next_pts &&\n                next_pts != AV_NOPTS_VALUE)\n                pkt->pts = next_dts;\n\n            st->last_IP_duration = pkt->duration;\n            st->last_IP_pts      = pkt->pts;\n            /* Cannot compute PTS if not present (we can compute it only\n             * by knowing the future. */\n        } else if (pkt->pts != AV_NOPTS_VALUE ||\n                   pkt->dts != AV_NOPTS_VALUE ||\n                   pkt->duration                ) {\n\n            /* presentation is not delayed : PTS and DTS are the same */\n            if (pkt->pts == AV_NOPTS_VALUE)\n                pkt->pts = pkt->dts;\n            update_initial_timestamps(s, pkt->stream_index, pkt->pts,\n                                      pkt->pts, pkt);\n            if (pkt->pts == AV_NOPTS_VALUE)\n                pkt->pts = st->cur_dts;\n            pkt->dts = pkt->pts;\n            if (pkt->pts != AV_NOPTS_VALUE)\n                st->cur_dts = av_add_stable(st->time_base, pkt->pts, duration, 1);\n        }\n    }\n\n    if (pkt->pts != AV_NOPTS_VALUE && delay <= MAX_REORDER_DELAY && has_decode_delay_been_guessed(st)) {\n        st->pts_buffer[0] = pkt->pts;\n        for (i = 0; i<delay && st->pts_buffer[i] > st->pts_buffer[i + 1]; i++)\n            FFSWAP(int64_t, st->pts_buffer[i], st->pts_buffer[i + 1]);\n\n        pkt->dts = select_from_pts_buffer(st, st->pts_buffer, pkt->dts);\n    }\n    // We skipped it above so we try here.\n    if (!onein_oneout)\n        // This should happen on the first packet\n        update_initial_timestamps(s, pkt->stream_index, pkt->dts, pkt->pts, pkt);\n    if (pkt->dts > st->cur_dts)\n        st->cur_dts = pkt->dts;\n\n    av_dlog(NULL, \"OUTdelayed:%d/%d pts:%s, dts:%s cur_dts:%s\\n\",\n            presentation_delayed, delay, av_ts2str(pkt->pts), av_ts2str(pkt->dts), av_ts2str(st->cur_dts));\n\n    /* update flags */\n    if (is_intra_only(st->codec))\n        pkt->flags |= AV_PKT_FLAG_KEY;\n    if (pc)\n        pkt->convergence_duration = pc->convergence_duration;\n}", "before_change_lines": [133], "raw_before_change_lines": [133], "after_change_lines": [133], "raw_after_change_lines": [133], "bug_lines": [133], "added": [false], "idx": 64}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "825----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2d50633d5f9b530971c3eef37c77a1f38ce6d50d_1.json----ea_read_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2d50633d5f9b530971c3eef37c77a1f38ce6d50d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2d50633d5f9b530971c3eef37c77a1f38ce6d50d_1.json", "function_name": "ea_read_header", "vul_func_code": "static int ea_read_header(AVFormatContext *s)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVStream *st;\n\n    if (process_ea_header(s)<=0)\n        return AVERROR(EIO);\n\n    if (init_video_stream(s, &ea->video) || init_video_stream(s, &ea->alpha))\n        return AVERROR(ENOMEM);\n\n    if (ea->audio_codec) {\n        if (ea->num_channels <= 0 || ea->num_channels > 2) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Unsupported number of channels: %d\\n\", ea->num_channels);\n            ea->audio_codec = 0;\n            return 1;\n        }\n        if (ea->sample_rate <= 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Unsupported sample rate: %d\\n\", ea->sample_rate);\n            ea->audio_codec = 0;\n            return 1;\n        }\n        if (ea->bytes <= 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Invalid number of bytes per sample: %d\\n\", ea->bytes);\n            ea->audio_codec = AV_CODEC_ID_NONE;\n            return 1;\n        }\n\n        /* initialize the audio decoder stream */\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(st, 33, 1, ea->sample_rate);\n        st->codecpar->codec_type            = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id              = ea->audio_codec;\n        st->codecpar->codec_tag             = 0;   /* no tag */\n        st->codecpar->channels              = ea->num_channels;\n        st->codecpar->sample_rate           = ea->sample_rate;\n        st->codecpar->bits_per_coded_sample = ea->bytes * 8;\n        st->codecpar->bit_rate              = st->codecpar->channels *\n                                              st->codecpar->sample_rate *\n                                              st->codecpar->bits_per_coded_sample / 4;\n        st->codecpar->block_align           = st->codecpar->channels *\n                                              st->codecpar->bits_per_coded_sample;\n        ea->audio_stream_index           = st->index;\n        st->start_time                   = 0;\n    }\n\n    return 1;\n}", "patch_func_code": "static int ea_read_header(AVFormatContext *s)\n{\n    EaDemuxContext *ea = s->priv_data;\n    AVStream *st;\n\n    if (process_ea_header(s)<=0)\n        return AVERROR(EIO);\n\n    if (init_video_stream(s, &ea->video) || init_video_stream(s, &ea->alpha))\n        return AVERROR(ENOMEM);\n\n    if (ea->audio_codec) {\n        if (ea->num_channels <= 0 || ea->num_channels > 2) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Unsupported number of channels: %d\\n\", ea->num_channels);\n            ea->audio_codec = 0;\n            return 1;\n        }\n        if (ea->sample_rate <= 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Unsupported sample rate: %d\\n\", ea->sample_rate);\n            ea->audio_codec = 0;\n            return 1;\n        }\n        if (ea->bytes <= 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"Invalid number of bytes per sample: %d\\n\", ea->bytes);\n            ea->audio_codec = AV_CODEC_ID_NONE;\n            return 1;\n        }\n\n        /* initialize the audio decoder stream */\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        avpriv_set_pts_info(st, 33, 1, ea->sample_rate);\n        st->codecpar->codec_type            = AVMEDIA_TYPE_AUDIO;\n        st->codecpar->codec_id              = ea->audio_codec;\n        st->codecpar->codec_tag             = 0;   /* no tag */\n        st->codecpar->channels              = ea->num_channels;\n        st->codecpar->sample_rate           = ea->sample_rate;\n        st->codecpar->bits_per_coded_sample = ea->bytes * 8;\n        st->codecpar->bit_rate              = (int64_t)st->codecpar->channels *\n                                              st->codecpar->sample_rate *\n                                              st->codecpar->bits_per_coded_sample / 4;\n        st->codecpar->block_align           = st->codecpar->channels *\n                                              st->codecpar->bits_per_coded_sample;\n        ea->audio_stream_index           = st->index;\n        st->start_time                   = 0;\n    }\n\n    return 1;\n}", "before_change_lines": [43], "raw_before_change_lines": [43], "after_change_lines": [43], "raw_after_change_lines": [43], "bug_lines": [43], "added": [false], "idx": 65}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "846----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2e65dbd2bdab6c98dfe334e2e89e2877c3e0f98d_1.json----hls_prediction_unit", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2e65dbd2bdab6c98dfe334e2e89e2877c3e0f98d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2e65dbd2bdab6c98dfe334e2e89e2877c3e0f98d_1.json", "function_name": "hls_prediction_unit", "vul_func_code": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n                                int nPbW, int nPbH,\n                                int log2_cb_size, int partIdx)\n{\n#define POS(c_idx, x, y)                                                              \\\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n    HEVCLocalContext *lc = &s->HEVClc;\n    int merge_idx = 0;\n    struct MvField current_mv = {{{ 0 }}};\n\n    int min_pu_width = s->sps->min_pu_width;\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n    RefPicList  *refPicList = s->ref->refPicList;\n    HEVCFrame *ref0, *ref1;\n\n    int tmpstride = MAX_PB_SIZE;\n\n    uint8_t *dst0 = POS(0, x0, y0);\n    uint8_t *dst1 = POS(1, x0, y0);\n    uint8_t *dst2 = POS(2, x0, y0);\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n    int min_cb_width     = s->sps->min_cb_width;\n    int x_cb             = x0 >> log2_min_cb_size;\n    int y_cb             = y0 >> log2_min_cb_size;\n    int x_pu, y_pu;\n    int i, j;\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n    if (!skip_flag)\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n    if (skip_flag || lc->pu.merge_flag) {\n        if (s->sh.max_num_merge_cand > 1)\n            merge_idx = ff_hevc_merge_idx_decode(s);\n        else\n            merge_idx = 0;\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n                                   partIdx, merge_idx, &current_mv);\n    } else {\n        enum InterPredIdc inter_pred_idc = PRED_L0;\n        int mvp_flag;\n\n        ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n        if (s->sh.slice_type == B_SLICE)\n            inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH);\n\n        if (inter_pred_idc != PRED_L1) {\n            if (s->sh.nb_refs[L0]) {\n                current_mv.ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]);\n            }\n            current_mv.pred_flag[0] = 1;\n            hls_mvd_coding(s, x0, y0, 0);\n            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);\n            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n                                     partIdx, merge_idx, &current_mv,\n                                     mvp_flag, 0);\n            current_mv.mv[0].x += lc->pu.mvd.x;\n            current_mv.mv[0].y += lc->pu.mvd.y;\n        }\n\n        if (inter_pred_idc != PRED_L0) {\n            if (s->sh.nb_refs[L1]) {\n                current_mv.ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]);\n            }\n\n            if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) {\n                AV_ZERO32(&lc->pu.mvd);\n            } else {\n                hls_mvd_coding(s, x0, y0, 1);\n            }\n\n            current_mv.pred_flag[1] = 1;\n            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);\n            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n                                     partIdx, merge_idx, &current_mv,\n                                     mvp_flag, 1);\n            current_mv.mv[1].x += lc->pu.mvd.x;\n            current_mv.mv[1].y += lc->pu.mvd.y;\n        }\n    }\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n    if (current_mv.pred_flag[0]) {\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n        if (!ref0)\n            return;\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n    }\n    if (current_mv.pred_flag[1]) {\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n        if (!ref1)\n            return;\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n    }\n\n    if (current_mv.pred_flag[0] && !current_mv.pred_flag[1]) {\n        DECLARE_ALIGNED(16, int16_t,  tmp[MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        luma_mc(s, tmp, tmpstride, ref0->frame,\n                &current_mv.mv[0], x0, y0, nPbW, nPbH);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,\n                                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n                                     s->sh.luma_offset_l0[current_mv.ref_idx[0]],\n                                     dst0, s->frame->linesize[0], tmp,\n                                     tmpstride, nPbW, nPbH);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);\n        }\n        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,\n                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],\n                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],\n                                     dst1, s->frame->linesize[1], tmp, tmpstride,\n                                     nPbW / 2, nPbH / 2);\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],\n                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],\n                                     dst2, s->frame->linesize[2], tmp2, tmpstride,\n                                     nPbW / 2, nPbH / 2);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n        }\n    } else if (!current_mv.pred_flag[0] && current_mv.pred_flag[1]) {\n        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        if (!ref1)\n            return;\n\n        luma_mc(s, tmp, tmpstride, ref1->frame,\n                &current_mv.mv[1], x0, y0, nPbW, nPbH);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,\n                                      s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n                                      s->sh.luma_offset_l1[current_mv.ref_idx[1]],\n                                      dst0, s->frame->linesize[0], tmp, tmpstride,\n                                      nPbW, nPbH);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);\n        }\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref1->frame,\n                  &current_mv.mv[1], x0/2, y0/2, nPbW/2, nPbH/2);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],\n                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],\n                                     dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],\n                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],\n                                     dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n        }\n    } else if (current_mv.pred_flag[0] && current_mv.pred_flag[1]) {\n        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp3[MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp4[MAX_PB_SIZE * MAX_PB_SIZE]);\n        HEVCFrame *ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n        HEVCFrame *ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n        if (!ref0 || !ref1)\n            return;\n\n        luma_mc(s, tmp, tmpstride, ref0->frame,\n                &current_mv.mv[0], x0, y0, nPbW, nPbH);\n        luma_mc(s, tmp2, tmpstride, ref1->frame,\n                &current_mv.mv[1], x0, y0, nPbW, nPbH);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred_avg(s->sh.luma_log2_weight_denom,\n                                         s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n                                         s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n                                         s->sh.luma_offset_l0[current_mv.ref_idx[0]],\n                                         s->sh.luma_offset_l1[current_mv.ref_idx[1]],\n                                         dst0, s->frame->linesize[0],\n                                         tmp, tmp2, tmpstride, nPbW, nPbH);\n        } else {\n            s->hevcdsp.put_weighted_pred_avg(dst0, s->frame->linesize[0],\n                                             tmp, tmp2, tmpstride, nPbW, nPbH);\n        }\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,\n                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n        chroma_mc(s, tmp3, tmp4, tmpstride, ref1->frame,\n                  &current_mv.mv[1], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,\n                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],\n                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],\n                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],\n                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],\n                                         dst1, s->frame->linesize[1], tmp, tmp3,\n                                         tmpstride, nPbW / 2, nPbH / 2);\n            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,\n                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],\n                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],\n                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],\n                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],\n                                         dst2, s->frame->linesize[2], tmp2, tmp4,\n                                         tmpstride, nPbW / 2, nPbH / 2);\n        } else {\n            s->hevcdsp.put_weighted_pred_avg(dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.put_weighted_pred_avg(dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW/2, nPbH/2);\n        }\n    }\n}", "patch_func_code": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n                                int nPbW, int nPbH,\n                                int log2_cb_size, int partIdx)\n{\n#define POS(c_idx, x, y)                                                              \\\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n    HEVCLocalContext *lc = &s->HEVClc;\n    int merge_idx = 0;\n    struct MvField current_mv = {{{ 0 }}};\n\n    int min_pu_width = s->sps->min_pu_width;\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n    RefPicList  *refPicList = s->ref->refPicList;\n    HEVCFrame *ref0, *ref1;\n\n    int tmpstride = MAX_PB_SIZE;\n\n    uint8_t *dst0 = POS(0, x0, y0);\n    uint8_t *dst1 = POS(1, x0, y0);\n    uint8_t *dst2 = POS(2, x0, y0);\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n    int min_cb_width     = s->sps->min_cb_width;\n    int x_cb             = x0 >> log2_min_cb_size;\n    int y_cb             = y0 >> log2_min_cb_size;\n    int x_pu, y_pu;\n    int i, j;\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n    if (!skip_flag)\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n    if (skip_flag || lc->pu.merge_flag) {\n        if (s->sh.max_num_merge_cand > 1)\n            merge_idx = ff_hevc_merge_idx_decode(s);\n        else\n            merge_idx = 0;\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n                                   partIdx, merge_idx, &current_mv);\n    } else {\n        enum InterPredIdc inter_pred_idc = PRED_L0;\n        int mvp_flag;\n\n        ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n        if (s->sh.slice_type == B_SLICE)\n            inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH);\n\n        if (inter_pred_idc != PRED_L1) {\n            if (s->sh.nb_refs[L0]) {\n                current_mv.ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]);\n            }\n            current_mv.pred_flag[0] = 1;\n            hls_mvd_coding(s, x0, y0, 0);\n            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);\n            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n                                     partIdx, merge_idx, &current_mv,\n                                     mvp_flag, 0);\n            current_mv.mv[0].x += lc->pu.mvd.x;\n            current_mv.mv[0].y += lc->pu.mvd.y;\n        }\n\n        if (inter_pred_idc != PRED_L0) {\n            if (s->sh.nb_refs[L1]) {\n                current_mv.ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]);\n            }\n\n            if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) {\n                AV_ZERO32(&lc->pu.mvd);\n            } else {\n                hls_mvd_coding(s, x0, y0, 1);\n            }\n\n            current_mv.pred_flag[1] = 1;\n            mvp_flag = ff_hevc_mvp_lx_flag_decode(s);\n            ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n                                     partIdx, merge_idx, &current_mv,\n                                     mvp_flag, 1);\n            current_mv.mv[1].x += lc->pu.mvd.x;\n            current_mv.mv[1].y += lc->pu.mvd.y;\n        }\n    }\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n    if (current_mv.pred_flag[0]) {\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n        if (!ref0)\n            return;\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n    }\n    if (current_mv.pred_flag[1]) {\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n        if (!ref1)\n            return;\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n    }\n\n    if (current_mv.pred_flag[0] && !current_mv.pred_flag[1]) {\n        DECLARE_ALIGNED(16, int16_t,  tmp[MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        luma_mc(s, tmp, tmpstride, ref0->frame,\n                &current_mv.mv[0], x0, y0, nPbW, nPbH);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,\n                                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n                                     s->sh.luma_offset_l0[current_mv.ref_idx[0]],\n                                     dst0, s->frame->linesize[0], tmp,\n                                     tmpstride, nPbW, nPbH);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);\n        }\n        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,\n                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],\n                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],\n                                     dst1, s->frame->linesize[1], tmp, tmpstride,\n                                     nPbW / 2, nPbH / 2);\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],\n                                     s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],\n                                     dst2, s->frame->linesize[2], tmp2, tmpstride,\n                                     nPbW / 2, nPbH / 2);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n        }\n    } else if (!current_mv.pred_flag[0] && current_mv.pred_flag[1]) {\n        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        luma_mc(s, tmp, tmpstride, ref1->frame,\n                &current_mv.mv[1], x0, y0, nPbW, nPbH);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.luma_log2_weight_denom,\n                                      s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n                                      s->sh.luma_offset_l1[current_mv.ref_idx[1]],\n                                      dst0, s->frame->linesize[0], tmp, tmpstride,\n                                      nPbW, nPbH);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst0, s->frame->linesize[0], tmp, tmpstride, nPbW, nPbH);\n        }\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref1->frame,\n                  &current_mv.mv[1], x0/2, y0/2, nPbW/2, nPbH/2);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],\n                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],\n                                     dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.weighted_pred(s->sh.chroma_log2_weight_denom,\n                                     s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],\n                                     s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],\n                                     dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n        } else {\n            s->hevcdsp.put_unweighted_pred(dst1, s->frame->linesize[1], tmp, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.put_unweighted_pred(dst2, s->frame->linesize[2], tmp2, tmpstride, nPbW/2, nPbH/2);\n        }\n    } else if (current_mv.pred_flag[0] && current_mv.pred_flag[1]) {\n        DECLARE_ALIGNED(16, int16_t, tmp [MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp2[MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp3[MAX_PB_SIZE * MAX_PB_SIZE]);\n        DECLARE_ALIGNED(16, int16_t, tmp4[MAX_PB_SIZE * MAX_PB_SIZE]);\n\n        luma_mc(s, tmp, tmpstride, ref0->frame,\n                &current_mv.mv[0], x0, y0, nPbW, nPbH);\n        luma_mc(s, tmp2, tmpstride, ref1->frame,\n                &current_mv.mv[1], x0, y0, nPbW, nPbH);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred_avg(s->sh.luma_log2_weight_denom,\n                                         s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n                                         s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n                                         s->sh.luma_offset_l0[current_mv.ref_idx[0]],\n                                         s->sh.luma_offset_l1[current_mv.ref_idx[1]],\n                                         dst0, s->frame->linesize[0],\n                                         tmp, tmp2, tmpstride, nPbW, nPbH);\n        } else {\n            s->hevcdsp.put_weighted_pred_avg(dst0, s->frame->linesize[0],\n                                             tmp, tmp2, tmpstride, nPbW, nPbH);\n        }\n\n        chroma_mc(s, tmp, tmp2, tmpstride, ref0->frame,\n                  &current_mv.mv[0], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n        chroma_mc(s, tmp3, tmp4, tmpstride, ref1->frame,\n                  &current_mv.mv[1], x0 / 2, y0 / 2, nPbW / 2, nPbH / 2);\n\n        if ((s->sh.slice_type == P_SLICE && s->pps->weighted_pred_flag) ||\n            (s->sh.slice_type == B_SLICE && s->pps->weighted_bipred_flag)) {\n            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,\n                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0],\n                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0],\n                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0],\n                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0],\n                                         dst1, s->frame->linesize[1], tmp, tmp3,\n                                         tmpstride, nPbW / 2, nPbH / 2);\n            s->hevcdsp.weighted_pred_avg(s->sh.chroma_log2_weight_denom,\n                                         s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1],\n                                         s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1],\n                                         s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1],\n                                         s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1],\n                                         dst2, s->frame->linesize[2], tmp2, tmp4,\n                                         tmpstride, nPbW / 2, nPbH / 2);\n        } else {\n            s->hevcdsp.put_weighted_pred_avg(dst1, s->frame->linesize[1], tmp, tmp3, tmpstride, nPbW/2, nPbH/2);\n            s->hevcdsp.put_weighted_pred_avg(dst2, s->frame->linesize[2], tmp2, tmp4, tmpstride, nPbW/2, nPbH/2);\n        }\n    }\n}", "before_change_lines": [146, 147, 185, 186, 188, 189], "raw_before_change_lines": [146, 147, 148, 185, 186, 187, 188, 189], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [146, 147, 148, 185, 186, 187, 188, 189], "added": [false, false, false, false, false, false, false, false], "idx": 66}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "860----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2f21bbc819b0b66474110099f4df35edf950a584_1.json----read_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_2f21bbc819b0b66474110099f4df35edf950a584_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_2f21bbc819b0b66474110099f4df35edf950a584_1.json", "function_name": "read_frame", "vul_func_code": "static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt,\n                      uint8_t block_type, AVFormatContext *s)\n{\n    uint8_t * vidbuf_start = NULL;\n    int vidbuf_nbytes = 0;\n    int code;\n    int bytes_copied = 0;\n    int position, duration, npixels;\n    unsigned int vidbuf_capacity;\n    int ret = 0;\n    AVStream *st;\n\n    if (vid->video_index < 0) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        vid->video_index = st->index;\n        if (vid->audio_index < 0) {\n            av_log_ask_for_sample(s, \"No audio packet before first video \"\n                                  \"packet. Using default video time base.\\n\");\n        }\n        avpriv_set_pts_info(st, 64, 185, vid->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id   = AV_CODEC_ID_BETHSOFTVID;\n        st->codec->width      = vid->width;\n        st->codec->height     = vid->height;\n    }\n    st      = s->streams[vid->video_index];\n    npixels = st->codec->width * st->codec->height;\n\n    vidbuf_start = av_malloc(vidbuf_capacity = BUFFER_PADDING_SIZE);\n    if(!vidbuf_start)\n        return AVERROR(ENOMEM);\n\n    // save the file position for the packet, include block type\n    position = avio_tell(pb) - 1;\n\n    vidbuf_start[vidbuf_nbytes++] = block_type;\n\n    // get the current packet duration\n    duration = vid->bethsoft_global_delay + avio_rl16(pb);\n\n    // set the y offset if it exists (decoder header data should be in data section)\n    if(block_type == VIDEO_YOFF_P_FRAME){\n        if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) {\n            ret = AVERROR(EIO);\n            goto fail;\n        }\n        vidbuf_nbytes += 2;\n    }\n\n    do{\n        vidbuf_start = av_fast_realloc(vidbuf_start, &vidbuf_capacity, vidbuf_nbytes + BUFFER_PADDING_SIZE);\n        if(!vidbuf_start)\n            return AVERROR(ENOMEM);\n\n        code = avio_r8(pb);\n        vidbuf_start[vidbuf_nbytes++] = code;\n\n        if(code >= 0x80){ // rle sequence\n            if(block_type == VIDEO_I_FRAME)\n                vidbuf_start[vidbuf_nbytes++] = avio_r8(pb);\n        } else if(code){ // plain sequence\n            if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) {\n                ret = AVERROR(EIO);\n                goto fail;\n            }\n            vidbuf_nbytes += code;\n        }\n        bytes_copied += code & 0x7F;\n        if(bytes_copied == npixels){ // sometimes no stop character is given, need to keep track of bytes copied\n            // may contain a 0 byte even if read all pixels\n            if(avio_r8(pb))\n                avio_seek(pb, -1, SEEK_CUR);\n            break;\n        }\n        if (bytes_copied > npixels) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    } while(code);\n\n    // copy data into packet\n    if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0)\n        goto fail;\n    memcpy(pkt->data, vidbuf_start, vidbuf_nbytes);\n    av_free(vidbuf_start);\n\n    pkt->pos = position;\n    pkt->stream_index = vid->video_index;\n    pkt->duration = duration;\n    if (block_type == VIDEO_I_FRAME)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    /* if there is a new palette available, add it to packet side data */\n    if (vid->palette) {\n        uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n                                                 BVID_PALETTE_SIZE);\n        memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);\n        av_freep(&vid->palette);\n    }\n\n    vid->nframes--;  // used to check if all the frames were read\n    return 0;\nfail:\n    av_free(vidbuf_start);\n    return ret;\n}", "patch_func_code": "static int read_frame(BVID_DemuxContext *vid, AVIOContext *pb, AVPacket *pkt,\n                      uint8_t block_type, AVFormatContext *s)\n{\n    uint8_t * vidbuf_start = NULL;\n    int vidbuf_nbytes = 0;\n    int code;\n    int bytes_copied = 0;\n    int position, duration, npixels;\n    unsigned int vidbuf_capacity;\n    int ret = 0;\n    AVStream *st;\n\n    if (vid->video_index < 0) {\n        st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n        vid->video_index = st->index;\n        if (vid->audio_index < 0) {\n            av_log_ask_for_sample(s, \"No audio packet before first video \"\n                                  \"packet. Using default video time base.\\n\");\n        }\n        avpriv_set_pts_info(st, 64, 185, vid->sample_rate);\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n        st->codec->codec_id   = AV_CODEC_ID_BETHSOFTVID;\n        st->codec->width      = vid->width;\n        st->codec->height     = vid->height;\n    }\n    st      = s->streams[vid->video_index];\n    npixels = st->codec->width * st->codec->height;\n\n    vidbuf_start = av_malloc(vidbuf_capacity = BUFFER_PADDING_SIZE);\n    if(!vidbuf_start)\n        return AVERROR(ENOMEM);\n\n    // save the file position for the packet, include block type\n    position = avio_tell(pb) - 1;\n\n    vidbuf_start[vidbuf_nbytes++] = block_type;\n\n    // get the current packet duration\n    duration = vid->bethsoft_global_delay + avio_rl16(pb);\n\n    // set the y offset if it exists (decoder header data should be in data section)\n    if(block_type == VIDEO_YOFF_P_FRAME){\n        if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], 2) != 2) {\n            ret = AVERROR(EIO);\n            goto fail;\n        }\n        vidbuf_nbytes += 2;\n    }\n\n    do{\n        vidbuf_start = av_fast_realloc(vidbuf_start, &vidbuf_capacity, vidbuf_nbytes + BUFFER_PADDING_SIZE);\n        if(!vidbuf_start)\n            return AVERROR(ENOMEM);\n\n        code = avio_r8(pb);\n        vidbuf_start[vidbuf_nbytes++] = code;\n\n        if(code >= 0x80){ // rle sequence\n            if(block_type == VIDEO_I_FRAME)\n                vidbuf_start[vidbuf_nbytes++] = avio_r8(pb);\n        } else if(code){ // plain sequence\n            if (avio_read(pb, &vidbuf_start[vidbuf_nbytes], code) != code) {\n                ret = AVERROR(EIO);\n                goto fail;\n            }\n            vidbuf_nbytes += code;\n        }\n        bytes_copied += code & 0x7F;\n        if(bytes_copied == npixels){ // sometimes no stop character is given, need to keep track of bytes copied\n            // may contain a 0 byte even if read all pixels\n            if(avio_r8(pb))\n                avio_seek(pb, -1, SEEK_CUR);\n            break;\n        }\n        if (bytes_copied > npixels) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    } while(code);\n\n    // copy data into packet\n    if ((ret = av_new_packet(pkt, vidbuf_nbytes)) < 0)\n        goto fail;\n    memcpy(pkt->data, vidbuf_start, vidbuf_nbytes);\n    av_free(vidbuf_start);\n\n    pkt->pos = position;\n    pkt->stream_index = vid->video_index;\n    pkt->duration = duration;\n    if (block_type == VIDEO_I_FRAME)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    /* if there is a new palette available, add it to packet side data */\n    if (vid->palette) {\n        uint8_t *pdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n                                                 BVID_PALETTE_SIZE);\n        if (pdata)\n            memcpy(pdata, vid->palette, BVID_PALETTE_SIZE);\n        av_freep(&vid->palette);\n    }\n\n    vid->nframes--;  // used to check if all the frames were read\n    return 0;\nfail:\n    av_free(vidbuf_start);\n    return ret;\n}", "before_change_lines": [99], "raw_before_change_lines": [99], "after_change_lines": [99, 100], "raw_after_change_lines": [99, 100], "bug_lines": [99], "added": [false], "idx": 67}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "882----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_305f479e04cc476e60c41a5c23fa9c803d21c655_1.json----decode_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_305f479e04cc476e60c41a5c23fa9c803d21c655_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_305f479e04cc476e60c41a5c23fa9c803d21c655_1.json", "function_name": "decode_init", "vul_func_code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    WMAProDecodeCtx *s = avctx->priv_data;\n    uint8_t *edata_ptr = avctx->extradata;\n    unsigned int channel_mask;\n    int i, bits;\n    int log2_max_num_subframes;\n    int num_possible_block_sizes;\n\n    if (avctx->codec_id == AV_CODEC_ID_XMA1 || avctx->codec_id == AV_CODEC_ID_XMA2)\n        avctx->block_align = 2048;\n\n    if (!avctx->block_align) {\n        av_log(avctx, AV_LOG_ERROR, \"block_align is not set\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    s->avctx = avctx;\n    s->fdsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);\n    if (!s->fdsp)\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n    if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size >= 34) {\n        s->decode_flags    = 0x10d6;\n        channel_mask       = AV_RL32(edata_ptr+2);\n        s->bits_per_sample = 16;\n        /** dump the extradata */\n        for (i = 0; i < avctx->extradata_size; i++)\n            ff_dlog(avctx, \"[%x] \", avctx->extradata[i]);\n        ff_dlog(avctx, \"\\n\");\n\n     } else if (avctx->codec_id == AV_CODEC_ID_XMA1 && avctx->extradata_size >= 28) {\n        s->decode_flags    = 0x10d6;\n        s->bits_per_sample = 16;\n        channel_mask       = 0;\n        /** dump the extradata */\n        for (i = 0; i < avctx->extradata_size; i++)\n            ff_dlog(avctx, \"[%x] \", avctx->extradata[i]);\n        ff_dlog(avctx, \"\\n\");\n\n     } else if (avctx->extradata_size >= 18) {\n        s->decode_flags    = AV_RL16(edata_ptr+14);\n        channel_mask       = AV_RL32(edata_ptr+2);\n        s->bits_per_sample = AV_RL16(edata_ptr);\n        /** dump the extradata */\n        for (i = 0; i < avctx->extradata_size; i++)\n            ff_dlog(avctx, \"[%x] \", avctx->extradata[i]);\n        ff_dlog(avctx, \"\\n\");\n\n    } else {\n        avpriv_request_sample(avctx, \"Unknown extradata size\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (avctx->codec_id != AV_CODEC_ID_WMAPRO && avctx->channels > 2) {\n        avpriv_report_missing_feature(avctx, \">2 channels support\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /** generic init */\n    s->log2_frame_size = av_log2(avctx->block_align) + 4;\n    if (s->log2_frame_size > 25) {\n        avpriv_request_sample(avctx, \"Large block align\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /** frame info */\n    if (avctx->codec_id != AV_CODEC_ID_WMAPRO)\n        s->skip_frame = 0;\n    else\n        s->skip_frame = 1; /* skip first frame */\n\n    s->packet_loss = 1;\n    s->len_prefix  = (s->decode_flags & 0x40);\n\n    /** get frame len */\n    if (avctx->codec_id == AV_CODEC_ID_WMAPRO) {\n        bits = ff_wma_get_frame_len_bits(avctx->sample_rate, 3, s->decode_flags);\n        if (bits > WMAPRO_BLOCK_MAX_BITS) {\n            avpriv_request_sample(avctx, \"14-bit block sizes\");\n            return AVERROR_PATCHWELCOME;\n        }\n        s->samples_per_frame = 1 << bits;\n    } else {\n        s->samples_per_frame = 512;\n    }\n\n    /** subframe info */\n    log2_max_num_subframes       = ((s->decode_flags & 0x38) >> 3);\n    s->max_num_subframes         = 1 << log2_max_num_subframes;\n    if (s->max_num_subframes == 16 || s->max_num_subframes == 4)\n        s->max_subframe_len_bit = 1;\n    s->subframe_len_bits = av_log2(log2_max_num_subframes) + 1;\n\n    num_possible_block_sizes     = log2_max_num_subframes + 1;\n    s->min_samples_per_subframe  = s->samples_per_frame / s->max_num_subframes;\n    s->dynamic_range_compression = (s->decode_flags & 0x80);\n\n    if (s->max_num_subframes > MAX_SUBFRAMES) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of subframes %\"PRId8\"\\n\",\n               s->max_num_subframes);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->min_samples_per_subframe < WMAPRO_BLOCK_MIN_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"min_samples_per_subframe of %d too small\\n\",\n               s->min_samples_per_subframe);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->avctx->sample_rate <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (avctx->channels < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of channels %d\\n\",\n               avctx->channels);\n        return AVERROR_INVALIDDATA;\n    } else if (avctx->channels > WMAPRO_MAX_CHANNELS) {\n        avpriv_request_sample(avctx,\n                              \"More than %d channels\", WMAPRO_MAX_CHANNELS);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /** init previous block len */\n    for (i = 0; i < avctx->channels; i++)\n        s->channel[i].prev_block_len = s->samples_per_frame;\n\n    /** extract lfe channel position */\n    s->lfe_channel = -1;\n\n    if (channel_mask & 8) {\n        unsigned int mask;\n        for (mask = 1; mask < 16; mask <<= 1) {\n            if (channel_mask & mask)\n                ++s->lfe_channel;\n        }\n    }\n\n    INIT_VLC_STATIC(&sf_vlc, SCALEVLCBITS, HUFF_SCALE_SIZE,\n                    scale_huffbits, 1, 1,\n                    scale_huffcodes, 2, 2, 616);\n\n    INIT_VLC_STATIC(&sf_rl_vlc, VLCBITS, HUFF_SCALE_RL_SIZE,\n                    scale_rl_huffbits, 1, 1,\n                    scale_rl_huffcodes, 4, 4, 1406);\n\n    INIT_VLC_STATIC(&coef_vlc[0], VLCBITS, HUFF_COEF0_SIZE,\n                    coef0_huffbits, 1, 1,\n                    coef0_huffcodes, 4, 4, 2108);\n\n    INIT_VLC_STATIC(&coef_vlc[1], VLCBITS, HUFF_COEF1_SIZE,\n                    coef1_huffbits, 1, 1,\n                    coef1_huffcodes, 4, 4, 3912);\n\n    INIT_VLC_STATIC(&vec4_vlc, VLCBITS, HUFF_VEC4_SIZE,\n                    vec4_huffbits, 1, 1,\n                    vec4_huffcodes, 2, 2, 604);\n\n    INIT_VLC_STATIC(&vec2_vlc, VLCBITS, HUFF_VEC2_SIZE,\n                    vec2_huffbits, 1, 1,\n                    vec2_huffcodes, 2, 2, 562);\n\n    INIT_VLC_STATIC(&vec1_vlc, VLCBITS, HUFF_VEC1_SIZE,\n                    vec1_huffbits, 1, 1,\n                    vec1_huffcodes, 2, 2, 562);\n\n    /** calculate number of scale factor bands and their offsets\n        for every possible block size */\n    for (i = 0; i < num_possible_block_sizes; i++) {\n        int subframe_len = s->samples_per_frame >> i;\n        int x;\n        int band = 1;\n        int rate = get_rate(avctx);\n\n        s->sfb_offsets[i][0] = 0;\n\n        for (x = 0; x < MAX_BANDS-1 && s->sfb_offsets[i][band - 1] < subframe_len; x++) {\n            int offset = (subframe_len * 2 * critical_freq[x]) / rate + 2;\n            offset &= ~3;\n            if (offset > s->sfb_offsets[i][band - 1])\n                s->sfb_offsets[i][band++] = offset;\n\n            if (offset >= subframe_len)\n                break;\n        }\n        s->sfb_offsets[i][band - 1] = subframe_len;\n        s->num_sfb[i]               = band - 1;\n        if (s->num_sfb[i] <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"num_sfb invalid\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n\n    /** Scale factors can be shared between blocks of different size\n        as every block has a different scale factor band layout.\n        The matrix sf_offsets is needed to find the correct scale factor.\n     */\n\n    for (i = 0; i < num_possible_block_sizes; i++) {\n        int b;\n        for (b = 0; b < s->num_sfb[i]; b++) {\n            int x;\n            int offset = ((s->sfb_offsets[i][b]\n                           + s->sfb_offsets[i][b + 1] - 1) << i) >> 1;\n            for (x = 0; x < num_possible_block_sizes; x++) {\n                int v = 0;\n                while (s->sfb_offsets[x][v + 1] << x < offset) {\n                    v++;\n                    av_assert0(v < MAX_BANDS);\n                }\n                s->sf_offsets[i][x][b] = v;\n            }\n        }\n    }\n\n    /** init MDCT, FIXME: only init needed sizes */\n    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++)\n        ff_mdct_init(&s->mdct_ctx[i], WMAPRO_BLOCK_MIN_BITS+1+i, 1,\n                     1.0 / (1 << (WMAPRO_BLOCK_MIN_BITS + i - 1))\n                     / (1 << (s->bits_per_sample - 1)));\n\n    /** init MDCT windows: simple sine window */\n    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) {\n        const int win_idx = WMAPRO_BLOCK_MAX_BITS - i;\n        ff_init_ff_sine_windows(win_idx);\n        s->windows[WMAPRO_BLOCK_SIZES - i - 1] = ff_sine_windows[win_idx];\n    }\n\n    /** calculate subwoofer cutoff values */\n    for (i = 0; i < num_possible_block_sizes; i++) {\n        int block_size = s->samples_per_frame >> i;\n        int cutoff = (440*block_size + 3 * (s->avctx->sample_rate >> 1) - 1)\n                     / s->avctx->sample_rate;\n        s->subwoofer_cutoffs[i] = av_clip(cutoff, 4, block_size);\n    }\n\n    /** calculate sine values for the decorrelation matrix */\n    for (i = 0; i < 33; i++)\n        sin64[i] = sin(i*M_PI / 64.0);\n\n    if (avctx->debug & FF_DEBUG_BITSTREAM)\n        dump_context(s);\n\n    avctx->channel_layout = channel_mask;\n\n    return 0;\n}", "patch_func_code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    WMAProDecodeCtx *s = avctx->priv_data;\n    uint8_t *edata_ptr = avctx->extradata;\n    unsigned int channel_mask;\n    int i, bits;\n    int log2_max_num_subframes;\n    int num_possible_block_sizes;\n\n    if (avctx->codec_id == AV_CODEC_ID_XMA1 || avctx->codec_id == AV_CODEC_ID_XMA2)\n        avctx->block_align = 2048;\n\n    if (!avctx->block_align) {\n        av_log(avctx, AV_LOG_ERROR, \"block_align is not set\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    s->avctx = avctx;\n    s->fdsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);\n    if (!s->fdsp)\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n    if (avctx->codec_id == AV_CODEC_ID_XMA2 && avctx->extradata_size >= 34) {\n        s->decode_flags    = 0x10d6;\n        channel_mask       = AV_RL32(edata_ptr+2);\n        s->bits_per_sample = 16;\n        /** dump the extradata */\n        for (i = 0; i < avctx->extradata_size; i++)\n            ff_dlog(avctx, \"[%x] \", avctx->extradata[i]);\n        ff_dlog(avctx, \"\\n\");\n\n     } else if (avctx->codec_id == AV_CODEC_ID_XMA1 && avctx->extradata_size >= 28) {\n        s->decode_flags    = 0x10d6;\n        s->bits_per_sample = 16;\n        channel_mask       = 0;\n        /** dump the extradata */\n        for (i = 0; i < avctx->extradata_size; i++)\n            ff_dlog(avctx, \"[%x] \", avctx->extradata[i]);\n        ff_dlog(avctx, \"\\n\");\n\n     } else if (avctx->extradata_size >= 18) {\n        s->decode_flags    = AV_RL16(edata_ptr+14);\n        channel_mask       = AV_RL32(edata_ptr+2);\n        s->bits_per_sample = AV_RL16(edata_ptr);\n        /** dump the extradata */\n        for (i = 0; i < avctx->extradata_size; i++)\n            ff_dlog(avctx, \"[%x] \", avctx->extradata[i]);\n        ff_dlog(avctx, \"\\n\");\n\n    } else {\n        avpriv_request_sample(avctx, \"Unknown extradata size\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (avctx->codec_id != AV_CODEC_ID_WMAPRO && avctx->channels > 2) {\n        avpriv_report_missing_feature(avctx, \">2 channels support\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /** generic init */\n    s->log2_frame_size = av_log2(avctx->block_align) + 4;\n    if (s->log2_frame_size > 25) {\n        avpriv_request_sample(avctx, \"Large block align\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /** frame info */\n    if (avctx->codec_id != AV_CODEC_ID_WMAPRO)\n        s->skip_frame = 0;\n    else\n        s->skip_frame = 1; /* skip first frame */\n\n    s->packet_loss = 1;\n    s->len_prefix  = (s->decode_flags & 0x40);\n\n    /** get frame len */\n    if (avctx->codec_id == AV_CODEC_ID_WMAPRO) {\n        bits = ff_wma_get_frame_len_bits(avctx->sample_rate, 3, s->decode_flags);\n        if (bits > WMAPRO_BLOCK_MAX_BITS) {\n            avpriv_request_sample(avctx, \"14-bit block sizes\");\n            return AVERROR_PATCHWELCOME;\n        }\n        s->samples_per_frame = 1 << bits;\n    } else {\n        s->samples_per_frame = 512;\n    }\n\n    /** subframe info */\n    log2_max_num_subframes       = ((s->decode_flags & 0x38) >> 3);\n    s->max_num_subframes         = 1 << log2_max_num_subframes;\n    if (s->max_num_subframes == 16 || s->max_num_subframes == 4)\n        s->max_subframe_len_bit = 1;\n    s->subframe_len_bits = av_log2(log2_max_num_subframes) + 1;\n\n    num_possible_block_sizes     = log2_max_num_subframes + 1;\n    s->min_samples_per_subframe  = s->samples_per_frame / s->max_num_subframes;\n    s->dynamic_range_compression = (s->decode_flags & 0x80);\n\n    if (s->max_num_subframes > MAX_SUBFRAMES) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of subframes %\"PRId8\"\\n\",\n               s->max_num_subframes);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->min_samples_per_subframe < WMAPRO_BLOCK_MIN_SIZE) {\n        av_log(avctx, AV_LOG_ERROR, \"min_samples_per_subframe of %d too small\\n\",\n               s->min_samples_per_subframe);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (s->avctx->sample_rate <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample rate\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (avctx->channels < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of channels %d\\n\",\n               avctx->channels);\n        return AVERROR_INVALIDDATA;\n    } else if (avctx->channels > WMAPRO_MAX_CHANNELS) {\n        avpriv_request_sample(avctx,\n                              \"More than %d channels\", WMAPRO_MAX_CHANNELS);\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /** init previous block len */\n    for (i = 0; i < avctx->channels; i++)\n        s->channel[i].prev_block_len = s->samples_per_frame;\n\n    /** extract lfe channel position */\n    s->lfe_channel = -1;\n\n    if (channel_mask & 8) {\n        unsigned int mask;\n        for (mask = 1; mask < 16; mask <<= 1) {\n            if (channel_mask & mask)\n                ++s->lfe_channel;\n        }\n    }\n\n    INIT_VLC_STATIC(&sf_vlc, SCALEVLCBITS, HUFF_SCALE_SIZE,\n                    scale_huffbits, 1, 1,\n                    scale_huffcodes, 2, 2, 616);\n\n    INIT_VLC_STATIC(&sf_rl_vlc, VLCBITS, HUFF_SCALE_RL_SIZE,\n                    scale_rl_huffbits, 1, 1,\n                    scale_rl_huffcodes, 4, 4, 1406);\n\n    INIT_VLC_STATIC(&coef_vlc[0], VLCBITS, HUFF_COEF0_SIZE,\n                    coef0_huffbits, 1, 1,\n                    coef0_huffcodes, 4, 4, 2108);\n\n    INIT_VLC_STATIC(&coef_vlc[1], VLCBITS, HUFF_COEF1_SIZE,\n                    coef1_huffbits, 1, 1,\n                    coef1_huffcodes, 4, 4, 3912);\n\n    INIT_VLC_STATIC(&vec4_vlc, VLCBITS, HUFF_VEC4_SIZE,\n                    vec4_huffbits, 1, 1,\n                    vec4_huffcodes, 2, 2, 604);\n\n    INIT_VLC_STATIC(&vec2_vlc, VLCBITS, HUFF_VEC2_SIZE,\n                    vec2_huffbits, 1, 1,\n                    vec2_huffcodes, 2, 2, 562);\n\n    INIT_VLC_STATIC(&vec1_vlc, VLCBITS, HUFF_VEC1_SIZE,\n                    vec1_huffbits, 1, 1,\n                    vec1_huffcodes, 2, 2, 562);\n\n    /** calculate number of scale factor bands and their offsets\n        for every possible block size */\n    for (i = 0; i < num_possible_block_sizes; i++) {\n        int subframe_len = s->samples_per_frame >> i;\n        int x;\n        int band = 1;\n        int rate = get_rate(avctx);\n\n        s->sfb_offsets[i][0] = 0;\n\n        for (x = 0; x < MAX_BANDS-1 && s->sfb_offsets[i][band - 1] < subframe_len; x++) {\n            int offset = (subframe_len * 2 * critical_freq[x]) / rate + 2;\n            offset &= ~3;\n            if (offset > s->sfb_offsets[i][band - 1])\n                s->sfb_offsets[i][band++] = offset;\n\n            if (offset >= subframe_len)\n                break;\n        }\n        s->sfb_offsets[i][band - 1] = subframe_len;\n        s->num_sfb[i]               = band - 1;\n        if (s->num_sfb[i] <= 0) {\n            av_log(avctx, AV_LOG_ERROR, \"num_sfb invalid\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n\n    /** Scale factors can be shared between blocks of different size\n        as every block has a different scale factor band layout.\n        The matrix sf_offsets is needed to find the correct scale factor.\n     */\n\n    for (i = 0; i < num_possible_block_sizes; i++) {\n        int b;\n        for (b = 0; b < s->num_sfb[i]; b++) {\n            int x;\n            int offset = ((s->sfb_offsets[i][b]\n                           + s->sfb_offsets[i][b + 1] - 1) << i) >> 1;\n            for (x = 0; x < num_possible_block_sizes; x++) {\n                int v = 0;\n                while (s->sfb_offsets[x][v + 1] << x < offset) {\n                    v++;\n                    av_assert0(v < MAX_BANDS);\n                }\n                s->sf_offsets[i][x][b] = v;\n            }\n        }\n    }\n\n    /** init MDCT, FIXME: only init needed sizes */\n    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++)\n        ff_mdct_init(&s->mdct_ctx[i], WMAPRO_BLOCK_MIN_BITS+1+i, 1,\n                     1.0 / (1 << (WMAPRO_BLOCK_MIN_BITS + i - 1))\n                     / (1 << (s->bits_per_sample - 1)));\n\n    /** init MDCT windows: simple sine window */\n    for (i = 0; i < WMAPRO_BLOCK_SIZES; i++) {\n        const int win_idx = WMAPRO_BLOCK_MAX_BITS - i;\n        ff_init_ff_sine_windows(win_idx);\n        s->windows[WMAPRO_BLOCK_SIZES - i - 1] = ff_sine_windows[win_idx];\n    }\n\n    /** calculate subwoofer cutoff values */\n    for (i = 0; i < num_possible_block_sizes; i++) {\n        int block_size = s->samples_per_frame >> i;\n        int cutoff = (440*block_size + 3LL * (s->avctx->sample_rate >> 1) - 1)\n                     / s->avctx->sample_rate;\n        s->subwoofer_cutoffs[i] = av_clip(cutoff, 4, block_size);\n    }\n\n    /** calculate sine values for the decorrelation matrix */\n    for (i = 0; i < 33; i++)\n        sin64[i] = sin(i*M_PI / 64.0);\n\n    if (avctx->debug & FF_DEBUG_BITSTREAM)\n        dump_context(s);\n\n    avctx->channel_layout = channel_mask;\n\n    return 0;\n}", "before_change_lines": [239], "raw_before_change_lines": [239], "after_change_lines": [239], "raw_after_change_lines": [239], "bug_lines": [239], "added": [false], "idx": 68}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "885----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_30936f0c18b712564dd84bc406c6ac8810d0825f_1.json----ff_subblock_synthesis", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_30936f0c18b712564dd84bc406c6ac8810d0825f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_30936f0c18b712564dd84bc406c6ac8810d0825f_1.json", "function_name": "ff_subblock_synthesis", "vul_func_code": "void ff_subblock_synthesis(RA144Context *ractx, const int16_t *lpc_coefs,\n                           int cba_idx, int cb1_idx, int cb2_idx,\n                           int gval, int gain)\n{\n    int16_t buffer_a[BLOCKSIZE];\n    int16_t *block;\n    int m[3];\n\n    if (cba_idx) {\n        cba_idx += BLOCKSIZE/2 - 1;\n        ff_copy_and_dup(buffer_a, ractx->adapt_cb, cba_idx);\n        m[0] = (ff_irms(buffer_a) * gval) >> 12;\n    } else {\n        m[0] = 0;\n    }\n    m[1] = (ff_cb1_base[cb1_idx] * gval) >> 8;\n    m[2] = (ff_cb2_base[cb2_idx] * gval) >> 8;\n    memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE,\n            (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb));\n\n    block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE;\n\n    add_wav(block, gain, cba_idx, m, cba_idx? buffer_a: NULL,\n            ff_cb1_vects[cb1_idx], ff_cb2_vects[cb2_idx]);\n\n    memcpy(ractx->curr_sblock, ractx->curr_sblock + BLOCKSIZE,\n           LPC_ORDER*sizeof(*ractx->curr_sblock));\n\n    if (ff_celp_lp_synthesis_filter(ractx->curr_sblock + LPC_ORDER, lpc_coefs,\n                                    block, BLOCKSIZE, LPC_ORDER, 1, 0, 0xfff))\n        memset(ractx->curr_sblock, 0, (LPC_ORDER+BLOCKSIZE)*sizeof(*ractx->curr_sblock));\n}", "patch_func_code": "void ff_subblock_synthesis(RA144Context *ractx, const int16_t *lpc_coefs,\n                           int cba_idx, int cb1_idx, int cb2_idx,\n                           int gval, int gain)\n{\n    int16_t *block;\n    int m[3];\n\n    if (cba_idx) {\n        cba_idx += BLOCKSIZE/2 - 1;\n        ff_copy_and_dup(ractx->buffer_a, ractx->adapt_cb, cba_idx);\n        m[0] = (ff_irms(&ractx->dsp, ractx->buffer_a) * gval) >> 12;\n    } else {\n        m[0] = 0;\n    }\n    m[1] = (ff_cb1_base[cb1_idx] * gval) >> 8;\n    m[2] = (ff_cb2_base[cb2_idx] * gval) >> 8;\n    memmove(ractx->adapt_cb, ractx->adapt_cb + BLOCKSIZE,\n            (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx->adapt_cb));\n\n    block = ractx->adapt_cb + BUFFERSIZE - BLOCKSIZE;\n\n    add_wav(block, gain, cba_idx, m, cba_idx? ractx->buffer_a: NULL,\n            ff_cb1_vects[cb1_idx], ff_cb2_vects[cb2_idx]);\n\n    memcpy(ractx->curr_sblock, ractx->curr_sblock + BLOCKSIZE,\n           LPC_ORDER*sizeof(*ractx->curr_sblock));\n\n    if (ff_celp_lp_synthesis_filter(ractx->curr_sblock + LPC_ORDER, lpc_coefs,\n                                    block, BLOCKSIZE, LPC_ORDER, 1, 0, 0xfff))\n        memset(ractx->curr_sblock, 0, (LPC_ORDER+BLOCKSIZE)*sizeof(*ractx->curr_sblock));\n}", "before_change_lines": [5, 11, 12, 23], "raw_before_change_lines": [5, 11, 12, 23], "after_change_lines": [10, 11, 22], "raw_after_change_lines": [10, 11, 22], "bug_lines": [5, 11, 12, 23], "added": [false, false, false, false], "idx": 69}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "888----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_30c429d9190e93f9c67160818d16aa2e62f7478c_1.json----decode_byterun", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_30c429d9190e93f9c67160818d16aa2e62f7478c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_30c429d9190e93f9c67160818d16aa2e62f7478c_1.json", "function_name": "decode_byterun", "vul_func_code": "static int decode_byterun(uint8_t *dst, int dst_size,\n                          const uint8_t *buf, const uint8_t *const buf_end)\n{\n    const uint8_t *const buf_start = buf;\n    unsigned x;\n    for (x = 0; x < dst_size && buf < buf_end;) {\n        unsigned length;\n        const int8_t value = *buf++;\n        if (value >= 0) {\n            length = value + 1;\n            memcpy(dst + x, buf, FFMIN3(length, dst_size - x, buf_end - buf));\n            buf += length;\n        } else if (value > -128) {\n            length = -value + 1;\n            memset(dst + x, *buf++, FFMIN(length, dst_size - x));\n        } else { // noop\n            continue;\n        }\n        x += length;\n    }\n    if (x < dst_size) {\n        av_log(NULL, AV_LOG_WARNING, \"decode_byterun ended before plane size\\n\");\n        memset(dst+x, 0, dst_size - x);\n    }\n    return buf - buf_start;\n}", "patch_func_code": "static int decode_byterun(uint8_t *dst, int dst_size,\n                          const uint8_t *buf, const uint8_t *const buf_end)\n{\n    const uint8_t *const buf_start = buf;\n    unsigned x;\n    for (x = 0; x < dst_size && buf < buf_end;) {\n        unsigned length;\n        const int8_t value = *buf++;\n        if (value >= 0) {\n            length = FFMIN3(value + 1, dst_size - x, buf_end - buf);\n            memcpy(dst + x, buf, length);\n            buf += length;\n        } else if (value > -128) {\n            length = FFMIN(-value + 1, dst_size - x);\n            memset(dst + x, *buf++, length);\n        } else { // noop\n            continue;\n        }\n        x += length;\n    }\n    if (x < dst_size) {\n        av_log(NULL, AV_LOG_WARNING, \"decode_byterun ended before plane size\\n\");\n        memset(dst+x, 0, dst_size - x);\n    }\n    return buf - buf_start;\n}", "before_change_lines": [10, 11, 14, 15], "raw_before_change_lines": [10, 11, 14, 15], "after_change_lines": [10, 11, 14, 15], "raw_after_change_lines": [10, 11, 14, 15], "bug_lines": [10, 11, 14, 15], "added": [false, false, false, false], "idx": 70}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "920----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3256173f9160db6c0e69e5de5e3d2c8dc40f6ee5_1.json----frame_thread_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_3256173f9160db6c0e69e5de5e3d2c8dc40f6ee5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3256173f9160db6c0e69e5de5e3d2c8dc40f6ee5_1.json", "function_name": "frame_thread_init", "vul_func_code": "static int frame_thread_init(AVCodecContext *avctx)\n{\n    int thread_count = avctx->thread_count;\n    AVCodec *codec = avctx->codec;\n    AVCodecContext *src = avctx;\n    FrameThreadContext *fctx;\n    int i, err = 0;\n\n    if (thread_count <= 1) {\n        avctx->active_thread_type = 0;\n        return 0;\n    }\n\n    avctx->thread_opaque = fctx = av_mallocz(sizeof(FrameThreadContext));\n\n    fctx->threads = av_mallocz(sizeof(PerThreadContext) * thread_count);\n    pthread_mutex_init(&fctx->buffer_mutex, NULL);\n    fctx->delaying = 1;\n\n    for (i = 0; i < thread_count; i++) {\n        AVCodecContext *copy = av_malloc(sizeof(AVCodecContext));\n        PerThreadContext *p  = &fctx->threads[i];\n\n        pthread_mutex_init(&p->mutex, NULL);\n        pthread_mutex_init(&p->progress_mutex, NULL);\n        pthread_cond_init(&p->input_cond, NULL);\n        pthread_cond_init(&p->progress_cond, NULL);\n        pthread_cond_init(&p->output_cond, NULL);\n\n        p->parent = fctx;\n        p->avctx  = copy;\n\n        if (!copy) {\n            err = AVERROR(ENOMEM);\n            goto error;\n        }\n\n        *copy = *src;\n        copy->thread_opaque = p;\n        copy->pkt = &p->avpkt;\n\n        if (!i) {\n            src = copy;\n\n            if (codec->init)\n                err = codec->init(copy);\n\n            update_context_from_thread(avctx, copy, 1);\n        } else {\n            copy->priv_data = av_malloc(codec->priv_data_size);\n            if (!copy->priv_data) {\n                err = AVERROR(ENOMEM);\n                goto error;\n            }\n            memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);\n            copy->internal = av_malloc(sizeof(AVCodecInternal));\n            if (!copy->internal) {\n                err = AVERROR(ENOMEM);\n                goto error;\n            }\n            *(copy->internal) = *(src->internal);\n            copy->internal->is_copy = 1;\n\n            if (codec->init_thread_copy)\n                err = codec->init_thread_copy(copy);\n        }\n\n        if (err) goto error;\n\n        pthread_create(&p->thread, NULL, frame_worker_thread, p);\n    }\n\n    return 0;\n\nerror:\n    frame_thread_free(avctx, i+1);\n\n    return err;\n}", "patch_func_code": "static int frame_thread_init(AVCodecContext *avctx)\n{\n    int thread_count = avctx->thread_count;\n    AVCodec *codec = avctx->codec;\n    AVCodecContext *src = avctx;\n    FrameThreadContext *fctx;\n    int i, err = 0;\n\n    if (thread_count <= 1) {\n        avctx->active_thread_type = 0;\n        return 0;\n    }\n\n    avctx->thread_opaque = fctx = av_mallocz(sizeof(FrameThreadContext));\n\n    fctx->threads = av_mallocz(sizeof(PerThreadContext) * thread_count);\n    pthread_mutex_init(&fctx->buffer_mutex, NULL);\n    fctx->delaying = 1;\n\n    for (i = 0; i < thread_count; i++) {\n        AVCodecContext *copy = av_malloc(sizeof(AVCodecContext));\n        PerThreadContext *p  = &fctx->threads[i];\n\n        pthread_mutex_init(&p->mutex, NULL);\n        pthread_mutex_init(&p->progress_mutex, NULL);\n        pthread_cond_init(&p->input_cond, NULL);\n        pthread_cond_init(&p->progress_cond, NULL);\n        pthread_cond_init(&p->output_cond, NULL);\n\n        p->parent = fctx;\n        p->avctx  = copy;\n\n        if (!copy) {\n            err = AVERROR(ENOMEM);\n            goto error;\n        }\n\n        *copy = *src;\n        copy->thread_opaque = p;\n        copy->pkt = &p->avpkt;\n\n        if (!i) {\n            src = copy;\n\n            if (codec->init)\n                err = codec->init(copy);\n\n            update_context_from_thread(avctx, copy, 1);\n        } else {\n            copy->priv_data = av_malloc(codec->priv_data_size);\n            if (!copy->priv_data) {\n                err = AVERROR(ENOMEM);\n                goto error;\n            }\n            memcpy(copy->priv_data, src->priv_data, codec->priv_data_size);\n            copy->internal = av_malloc(sizeof(AVCodecInternal));\n            if (!copy->internal) {\n                err = AVERROR(ENOMEM);\n                goto error;\n            }\n            *(copy->internal) = *(src->internal);\n            copy->internal->is_copy = 1;\n\n            if (codec->init_thread_copy)\n                err = codec->init_thread_copy(copy);\n        }\n\n        if (err) goto error;\n\n        p->thread_created= !pthread_create(&p->thread, NULL, frame_worker_thread, p);\n    }\n\n    return 0;\n\nerror:\n    frame_thread_free(avctx, i+1);\n\n    return err;\n}", "before_change_lines": [70], "raw_before_change_lines": [70], "after_change_lines": [70], "raw_after_change_lines": [70], "bug_lines": [70], "added": [false], "idx": 71}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "925----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_32a15841b75f9e0c9941c0741fed329559510d9d_1.json----configure_filtergraph", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_32a15841b75f9e0c9941c0741fed329559510d9d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_32a15841b75f9e0c9941c0741fed329559510d9d_1.json", "function_name": "configure_filtergraph", "vul_func_code": "static int configure_filtergraph(FilterGraph *fg)\n{\n    return fg->graph_desc ? configure_complex_filter(fg) : configure_video_filters(fg);\n}", "patch_func_code": "static int configure_filtergraph(FilterGraph *fg)\n{\n    return fg->graph_desc ? configure_complex_filter(fg) :\n                            configure_simple_filtergraph(fg);\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3, 4], "raw_after_change_lines": [3, 4], "bug_lines": [3], "added": [false], "idx": 72}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "949----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3391f57802554ead0f9b02060f0f54dee86f7fda_1.json----av_image_get_linesize", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_3391f57802554ead0f9b02060f0f54dee86f7fda_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3391f57802554ead0f9b02060f0f54dee86f7fda_1.json", "function_name": "av_image_get_linesize", "vul_func_code": "int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane)\n{\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n    int s, linesize;\n\n    if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL)\n        return AVERROR(EINVAL);\n\n    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);\n    s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0;\n    linesize = max_step[plane] * (((width + (1 << s) - 1)) >> s);\n    if (desc->flags & PIX_FMT_BITSTREAM)\n        linesize = (linesize + 7) >> 3;\n    return linesize;\n}", "patch_func_code": "int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane)\n{\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n\n    if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL)\n        return AVERROR(EINVAL);\n\n    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);\n    return image_get_linesize(width, plane, max_step[plane], max_step_comp[plane], desc);\n}", "before_change_lines": [6, 12, 13, 14, 15, 16], "raw_before_change_lines": [6, 12, 13, 14, 15, 16], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [6, 12, 13, 14, 15, 16], "added": [false, false, false, false, false, false], "idx": 73}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "988----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_35f3d8c35be1323afe8f230eecb35f9311405248_1.json----amf_parse_object", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_35f3d8c35be1323afe8f230eecb35f9311405248_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_35f3d8c35be1323afe8f230eecb35f9311405248_1.json", "function_name": "amf_parse_object", "vul_func_code": "static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, unsigned int max_pos, int depth) {\n    AVCodecContext *acodec, *vcodec;\n    ByteIOContext *ioc;\n    AMFDataType amf_type;\n    char str_val[256];\n    double num_val;\n\n    num_val = 0;\n    ioc = s->pb;\n\n    amf_type = get_byte(ioc);\n\n    switch(amf_type) {\n        case AMF_DATA_TYPE_NUMBER:\n            num_val = av_int2dbl(get_be64(ioc)); break;\n        case AMF_DATA_TYPE_BOOL:\n            num_val = get_byte(ioc); break;\n        case AMF_DATA_TYPE_STRING:\n            if(amf_get_string(ioc, str_val, sizeof(str_val)) < 0)\n                return -1;\n            break;\n        case AMF_DATA_TYPE_OBJECT: {\n            unsigned int keylen;\n\n            while(url_ftell(ioc) < max_pos - 2 && (keylen = get_be16(ioc))) {\n                url_fskip(ioc, keylen); //skip key string\n                if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0)\n                    return -1; //if we couldn't skip, bomb out.\n            }\n            if(get_byte(ioc) != AMF_END_OF_OBJECT)\n                return -1;\n        }\n            break;\n        case AMF_DATA_TYPE_NULL:\n        case AMF_DATA_TYPE_UNDEFINED:\n        case AMF_DATA_TYPE_UNSUPPORTED:\n            break; //these take up no additional space\n        case AMF_DATA_TYPE_MIXEDARRAY:\n            url_fskip(ioc, 4); //skip 32-bit max array index\n            while(url_ftell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) {\n                //this is the only case in which we would want a nested parse to not skip over the object\n                if(amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0)\n                    return -1;\n            }\n            if(get_byte(ioc) != AMF_END_OF_OBJECT)\n                return -1;\n            break;\n        case AMF_DATA_TYPE_ARRAY: {\n            unsigned int arraylen, i;\n\n            arraylen = get_be32(ioc);\n            for(i = 0; i < arraylen && url_ftell(ioc) < max_pos - 1; i++) {\n                if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0)\n                    return -1; //if we couldn't skip, bomb out.\n            }\n        }\n            break;\n        case AMF_DATA_TYPE_DATE:\n            url_fskip(ioc, 8 + 2); //timestamp (double) and UTC offset (int16)\n            break;\n        default: //unsupported type, we couldn't skip\n            return -1;\n    }\n\n    if(depth == 1 && key) { //only look for metadata values when we are not nested and key != NULL\n        acodec = astream ? astream->codec : NULL;\n        vcodec = vstream ? vstream->codec : NULL;\n\n        if(amf_type == AMF_DATA_TYPE_BOOL) {\n            if(!strcmp(key, \"stereo\") && acodec) acodec->channels = num_val > 0 ? 2 : 1;\n        } else if(amf_type == AMF_DATA_TYPE_NUMBER) {\n            if(!strcmp(key, \"duration\")) s->duration = num_val * AV_TIME_BASE;\n//            else if(!strcmp(key, \"width\")  && vcodec && num_val > 0) vcodec->width  = num_val;\n//            else if(!strcmp(key, \"height\") && vcodec && num_val > 0) vcodec->height = num_val;\n            else if(!strcmp(key, \"audiocodecid\") && acodec) flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET);\n            else if(!strcmp(key, \"videocodecid\") && vcodec) flv_set_video_codec(s, vstream, (int)num_val);\n            else if(!strcmp(key, \"audiosamplesize\") && acodec && num_val >= 0) {\n                acodec->bits_per_sample = num_val;\n                //we may have to rewrite a previously read codecid because FLV only marks PCM endianness.\n                if(num_val == 8 && (acodec->codec_id == CODEC_ID_PCM_S16BE || acodec->codec_id == CODEC_ID_PCM_S16LE))\n                    acodec->codec_id = CODEC_ID_PCM_S8;\n            }\n            else if(!strcmp(key, \"audiosamplerate\") && acodec && num_val >= 0) {\n                //some tools, like FLVTool2, write consistently approximate metadata sample rates\n                if (!acodec->sample_rate) {\n                    switch((int)num_val) {\n                        case 44000: acodec->sample_rate = 44100  ; break;\n                        case 22000: acodec->sample_rate = 22050  ; break;\n                        case 11000: acodec->sample_rate = 11025  ; break;\n                        case 5000 : acodec->sample_rate = 5512   ; break;\n                        default   : acodec->sample_rate = num_val;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int amf_parse_object(AVFormatContext *s, AVStream *astream, AVStream *vstream, const char *key, unsigned int max_pos, int depth) {\n    AVCodecContext *acodec, *vcodec;\n    ByteIOContext *ioc;\n    AMFDataType amf_type;\n    char str_val[256];\n    double num_val;\n\n    num_val = 0;\n    ioc = s->pb;\n\n    amf_type = get_byte(ioc);\n\n    switch(amf_type) {\n        case AMF_DATA_TYPE_NUMBER:\n            num_val = av_int2dbl(get_be64(ioc)); break;\n        case AMF_DATA_TYPE_BOOL:\n            num_val = get_byte(ioc); break;\n        case AMF_DATA_TYPE_STRING:\n            if(amf_get_string(ioc, str_val, sizeof(str_val)) < 0)\n                return -1;\n            break;\n        case AMF_DATA_TYPE_OBJECT: {\n            unsigned int keylen;\n\n            while(url_ftell(ioc) < max_pos - 2 && (keylen = get_be16(ioc))) {\n                url_fskip(ioc, keylen); //skip key string\n                if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0)\n                    return -1; //if we couldn't skip, bomb out.\n            }\n            if(get_byte(ioc) != AMF_END_OF_OBJECT)\n                return -1;\n        }\n            break;\n        case AMF_DATA_TYPE_NULL:\n        case AMF_DATA_TYPE_UNDEFINED:\n        case AMF_DATA_TYPE_UNSUPPORTED:\n            break; //these take up no additional space\n        case AMF_DATA_TYPE_MIXEDARRAY:\n            url_fskip(ioc, 4); //skip 32-bit max array index\n            while(url_ftell(ioc) < max_pos - 2 && amf_get_string(ioc, str_val, sizeof(str_val)) > 0) {\n                //this is the only case in which we would want a nested parse to not skip over the object\n                if(amf_parse_object(s, astream, vstream, str_val, max_pos, depth + 1) < 0)\n                    return -1;\n            }\n            if(get_byte(ioc) != AMF_END_OF_OBJECT)\n                return -1;\n            break;\n        case AMF_DATA_TYPE_ARRAY: {\n            unsigned int arraylen, i;\n\n            arraylen = get_be32(ioc);\n            for(i = 0; i < arraylen && url_ftell(ioc) < max_pos - 1; i++) {\n                if(amf_parse_object(s, NULL, NULL, NULL, max_pos, depth + 1) < 0)\n                    return -1; //if we couldn't skip, bomb out.\n            }\n        }\n            break;\n        case AMF_DATA_TYPE_DATE:\n            url_fskip(ioc, 8 + 2); //timestamp (double) and UTC offset (int16)\n            break;\n        default: //unsupported type, we couldn't skip\n            return -1;\n    }\n\n    if(depth == 1 && key) { //only look for metadata values when we are not nested and key != NULL\n        acodec = astream ? astream->codec : NULL;\n        vcodec = vstream ? vstream->codec : NULL;\n\n        if(amf_type == AMF_DATA_TYPE_BOOL) {\n            if(!strcmp(key, \"stereo\") && acodec) acodec->channels = num_val > 0 ? 2 : 1;\n        } else if(amf_type == AMF_DATA_TYPE_NUMBER) {\n            if(!strcmp(key, \"duration\")) s->duration = num_val * AV_TIME_BASE;\n//            else if(!strcmp(key, \"width\")  && vcodec && num_val > 0) vcodec->width  = num_val;\n//            else if(!strcmp(key, \"height\") && vcodec && num_val > 0) vcodec->height = num_val;\n            else if(!strcmp(key, \"audiocodecid\") && acodec && 0 <= (int)num_val)\n                flv_set_audio_codec(s, astream, (int)num_val << FLV_AUDIO_CODECID_OFFSET);\n            else if(!strcmp(key, \"videocodecid\") && vcodec && 0 <= (int)num_val)\n                flv_set_video_codec(s, vstream, (int)num_val);\n            else if(!strcmp(key, \"audiosamplesize\") && acodec && 0 < (int)num_val) {\n                acodec->bits_per_sample = num_val;\n                //we may have to rewrite a previously read codecid because FLV only marks PCM endianness.\n                if(num_val == 8 && (acodec->codec_id == CODEC_ID_PCM_S16BE || acodec->codec_id == CODEC_ID_PCM_S16LE))\n                    acodec->codec_id = CODEC_ID_PCM_S8;\n            }\n            else if(!strcmp(key, \"audiosamplerate\") && acodec && num_val >= 0) {\n                //some tools, like FLVTool2, write consistently approximate metadata sample rates\n                if (!acodec->sample_rate) {\n                    switch((int)num_val) {\n                        case 44000: acodec->sample_rate = 44100  ; break;\n                        case 22000: acodec->sample_rate = 22050  ; break;\n                        case 11000: acodec->sample_rate = 11025  ; break;\n                        case 5000 : acodec->sample_rate = 5512   ; break;\n                        default   : acodec->sample_rate = num_val;\n                    }\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [75, 76, 77], "raw_before_change_lines": [75, 76, 77], "after_change_lines": [75, 76, 77, 78, 79], "raw_after_change_lines": [75, 76, 77, 78, 79], "bug_lines": [75, 76, 77], "added": [false, false, false], "idx": 74}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "996----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_364779faba5a2ebb298d614166ad15d4dea4c51d_1.json----add_metadata", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_364779faba5a2ebb298d614166ad15d4dea4c51d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_364779faba5a2ebb298d614166ad15d4dea4c51d_1.json", "function_name": "add_metadata", "vul_func_code": "static int add_metadata(const uint8_t **buf, int count, int type,\n                        const char *name, const char *sep, TiffContext *s)\n{\n    switch(type) {\n    case TIFF_DOUBLE: return add_doubles_metadata(buf, count, name, sep, s);\n    case TIFF_SHORT : return add_shorts_metadata(buf, count, name, sep, s);\n    default         : return AVERROR_INVALIDDATA;\n    };\n}", "patch_func_code": "static int add_metadata(int count, int type,\n                        const char *name, const char *sep, TiffContext *s)\n{\n    switch(type) {\n    case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s);\n    case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s);\n    default         : return AVERROR_INVALIDDATA;\n    };\n}", "before_change_lines": [1, 5, 6], "raw_before_change_lines": [1, 5, 6], "after_change_lines": [1, 5, 6], "raw_after_change_lines": [1, 5, 6], "bug_lines": [1, 5, 6], "added": [false, false, false], "idx": 75}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "1006----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_368a7a45bd4ee2fe713cfc0f4e6345fbac0d8686_1.json----get_lag", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_368a7a45bd4ee2fe713cfc0f4e6345fbac0d8686_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_368a7a45bd4ee2fe713cfc0f4e6345fbac0d8686_1.json", "function_name": "get_lag", "vul_func_code": "static void get_lag(float *buf, const float *new, LongTermPrediction *ltp)\n{\n    int i, j, lag, max_corr = 0;\n    float max_ratio;\n    for (i = 0; i < 2048; i++) {\n        float corr, s0 = 0.0f, s1 = 0.0f;\n        const int start = FFMAX(0, i - 1024);\n        for (j = start; j < 2048; j++) {\n            const int idx = j - i + 1024;\n            s0 += new[j]*buf[idx];\n            s1 += buf[idx]*buf[idx];\n        }\n        corr = s1 > 0.0f ? s0/sqrt(s1) : 0.0f;\n        if (corr > max_corr) {\n            max_corr = corr;\n            lag = i;\n            max_ratio = corr/(2048-start);\n        }\n    }\n    ltp->lag = FFMAX(av_clip_uintp2(lag, 11), 0);\n    ltp->coef_idx = quant_array_idx(max_ratio, ltp_coef, 8);\n    ltp->coef = ltp_coef[ltp->coef_idx];\n}", "patch_func_code": "static void get_lag(float *buf, const float *new, LongTermPrediction *ltp)\n{\n    int i, j, lag = 0, max_corr = 0;\n    float max_ratio = 0.0f;\n    for (i = 0; i < 2048; i++) {\n        float corr, s0 = 0.0f, s1 = 0.0f;\n        const int start = FFMAX(0, i - 1024);\n        for (j = start; j < 2048; j++) {\n            const int idx = j - i + 1024;\n            s0 += new[j]*buf[idx];\n            s1 += buf[idx]*buf[idx];\n        }\n        corr = s1 > 0.0f ? s0/sqrt(s1) : 0.0f;\n        if (corr > max_corr) {\n            max_corr = corr;\n            lag = i;\n            max_ratio = corr/(2048-start);\n        }\n    }\n    ltp->lag = FFMAX(av_clip_uintp2(lag, 11), 0);\n    ltp->coef_idx = quant_array_idx(max_ratio, ltp_coef, 8);\n    ltp->coef = ltp_coef[ltp->coef_idx];\n}", "before_change_lines": [3, 4], "raw_before_change_lines": [3, 4], "after_change_lines": [3, 4], "raw_after_change_lines": [3, 4], "bug_lines": [3, 4], "added": [false, false], "idx": 76}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1020----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_37488348161af749c086b1b05caebb99b2e88ccd_1.json----ff_convert_matrix", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_37488348161af749c086b1b05caebb99b2e88ccd_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_37488348161af749c086b1b05caebb99b2e88ccd_1.json", "function_name": "ff_convert_matrix", "vul_func_code": "void ff_convert_matrix(DSPContext *dsp, int (*qmat)[64],\n                       uint16_t (*qmat16)[2][64],\n                       const uint16_t *quant_matrix,\n                       int bias, int qmin, int qmax, int intra)\n{\n    int qscale;\n    int shift = 0;\n\n    for (qscale = qmin; qscale <= qmax; qscale++) {\n        int i;\n        if (dsp->fdct == ff_jpeg_fdct_islow_8 ||\n            dsp->fdct == ff_jpeg_fdct_islow_10 ||\n            dsp->fdct == ff_faandct) {\n            for (i = 0; i < 64; i++) {\n                const int j = dsp->idct_permutation[i];\n                /* 16 <= qscale * quant_matrix[i] <= 7905\n                 * Assume x = ff_aanscales[i] * qscale * quant_matrix[i]\n                 *             19952 <=              x  <= 249205026\n                 * (1 << 36) / 19952 >= (1 << 36) / (x) >= (1 << 36) / 249205026\n                 *           3444240 >= (1 << 36) / (x) >= 275 */\n\n                qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) /\n                                        (qscale * quant_matrix[j]));\n            }\n        } else if (dsp->fdct == ff_fdct_ifast) {\n            for (i = 0; i < 64; i++) {\n                const int j = dsp->idct_permutation[i];\n                /* 16 <= qscale * quant_matrix[i] <= 7905\n                 * Assume x = ff_aanscales[i] * qscale * quant_matrix[i]\n                 *             19952 <=              x  <= 249205026\n                 * (1 << 36) / 19952 >= (1 << 36) / (x) >= (1 << 36) / 249205026\n                 *           3444240 >= (1 << 36) / (x) >= 275 */\n\n                qmat[qscale][i] = (int)((UINT64_C(1) << (QMAT_SHIFT + 14)) /\n                                        (ff_aanscales[i] * qscale * quant_matrix[j]));\n            }\n        } else {\n            for (i = 0; i < 64; i++) {\n                const int j = dsp->idct_permutation[i];\n                /* We can safely suppose that 16 <= quant_matrix[i] <= 255\n                 * Assume x = qscale * quant_matrix[i]\n                 * So             16 <=              x  <= 7905\n                 * so (1 << 19) / 16 >= (1 << 19) / (x) >= (1 << 19) / 7905\n                 * so          32768 >= (1 << 19) / (x) >= 67 */\n                qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) /\n                                        (qscale * quant_matrix[j]));\n                //qmat  [qscale][i] = (1 << QMAT_SHIFT_MMX) /\n                //                    (qscale * quant_matrix[i]);\n                qmat16[qscale][0][i] = (1 << QMAT_SHIFT_MMX) /\n                                       (qscale * quant_matrix[j]);\n\n                if (qmat16[qscale][0][i] == 0 ||\n                    qmat16[qscale][0][i] == 128 * 256)\n                    qmat16[qscale][0][i] = 128 * 256 - 1;\n                qmat16[qscale][1][i] =\n                    ROUNDED_DIV(bias << (16 - QUANT_BIAS_SHIFT),\n                                qmat16[qscale][0][i]);\n            }\n        }\n\n        for (i = intra; i < 64; i++) {\n            int64_t max = 8191;\n            if (dsp->fdct == ff_fdct_ifast) {\n                max = (8191LL * ff_aanscales[i]) >> 14;\n            }\n            while (((max * qmat[qscale][i]) >> shift) > INT_MAX) {\n                shift++;\n            }\n        }\n    }\n    if (shift) {\n        av_log(NULL, AV_LOG_INFO,\n               \"Warning, QMAT_SHIFT is larger than %d, overflows possible\\n\",\n               QMAT_SHIFT - shift);\n    }\n}", "patch_func_code": "void ff_convert_matrix(DSPContext *dsp, int (*qmat)[64],\n                       uint16_t (*qmat16)[2][64],\n                       const uint16_t *quant_matrix,\n                       int bias, int qmin, int qmax, int intra)\n{\n    int qscale;\n    int shift = 0;\n\n    for (qscale = qmin; qscale <= qmax; qscale++) {\n        int i;\n        if (dsp->fdct == ff_jpeg_fdct_islow_8 ||\n            dsp->fdct == ff_jpeg_fdct_islow_10 ||\n            dsp->fdct == ff_faandct) {\n            for (i = 0; i < 64; i++) {\n                const int j = dsp->idct_permutation[i];\n                /* 16 <= qscale * quant_matrix[i] <= 7905\n                 * Assume x = ff_aanscales[i] * qscale * quant_matrix[i]\n                 *             19952 <=              x  <= 249205026\n                 * (1 << 36) / 19952 >= (1 << 36) / (x) >= (1 << 36) / 249205026\n                 *           3444240 >= (1 << 36) / (x) >= 275 */\n\n                qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) /\n                                        (qscale * quant_matrix[j]));\n            }\n        } else if (dsp->fdct == ff_fdct_ifast) {\n            for (i = 0; i < 64; i++) {\n                const int j = dsp->idct_permutation[i];\n                /* 16 <= qscale * quant_matrix[i] <= 7905\n                 * Assume x = ff_aanscales[i] * qscale * quant_matrix[i]\n                 *             19952 <=              x  <= 249205026\n                 * (1 << 36) / 19952 >= (1 << 36) / (x) >= (1 << 36) / 249205026\n                 *           3444240 >= (1 << 36) / (x) >= 275 */\n\n                qmat[qscale][i] = (int)((UINT64_C(1) << (QMAT_SHIFT + 14)) /\n                                        (ff_aanscales[i] * (int64_t)qscale * quant_matrix[j]));\n            }\n        } else {\n            for (i = 0; i < 64; i++) {\n                const int j = dsp->idct_permutation[i];\n                /* We can safely suppose that 16 <= quant_matrix[i] <= 255\n                 * Assume x = qscale * quant_matrix[i]\n                 * So             16 <=              x  <= 7905\n                 * so (1 << 19) / 16 >= (1 << 19) / (x) >= (1 << 19) / 7905\n                 * so          32768 >= (1 << 19) / (x) >= 67 */\n                qmat[qscale][i] = (int)((UINT64_C(1) << QMAT_SHIFT) /\n                                        (qscale * quant_matrix[j]));\n                //qmat  [qscale][i] = (1 << QMAT_SHIFT_MMX) /\n                //                    (qscale * quant_matrix[i]);\n                qmat16[qscale][0][i] = (1 << QMAT_SHIFT_MMX) /\n                                       (qscale * quant_matrix[j]);\n\n                if (qmat16[qscale][0][i] == 0 ||\n                    qmat16[qscale][0][i] == 128 * 256)\n                    qmat16[qscale][0][i] = 128 * 256 - 1;\n                qmat16[qscale][1][i] =\n                    ROUNDED_DIV(bias << (16 - QUANT_BIAS_SHIFT),\n                                qmat16[qscale][0][i]);\n            }\n        }\n\n        for (i = intra; i < 64; i++) {\n            int64_t max = 8191;\n            if (dsp->fdct == ff_fdct_ifast) {\n                max = (8191LL * ff_aanscales[i]) >> 14;\n            }\n            while (((max * qmat[qscale][i]) >> shift) > INT_MAX) {\n                shift++;\n            }\n        }\n    }\n    if (shift) {\n        av_log(NULL, AV_LOG_INFO,\n               \"Warning, QMAT_SHIFT is larger than %d, overflows possible\\n\",\n               QMAT_SHIFT - shift);\n    }\n}", "before_change_lines": [35], "raw_before_change_lines": [35], "after_change_lines": [35], "raw_after_change_lines": [35], "bug_lines": [35], "added": [false], "idx": 77}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1035----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38694e57192cb61911f1307a9398363c03f5aa33_1.json----set_expr", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_38694e57192cb61911f1307a9398363c03f5aa33_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38694e57192cb61911f1307a9398363c03f5aa33_1.json", "function_name": "set_expr", "vul_func_code": "static int set_expr(AVExpr **pexpr, const char *expr, void *log_ctx)\n{\n    int ret;\n\n    if (*pexpr)\n        av_expr_free(*pexpr);\n    *pexpr = NULL;\n    ret = av_expr_parse(pexpr, expr, var_names,\n                        NULL, NULL, NULL, NULL, 0, log_ctx);\n    if (ret < 0)\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Error when evaluating the expression '%s'\\n\", expr);\n    return ret;\n}", "patch_func_code": "static int set_expr(AVExpr **pexpr, const char *expr, void *log_ctx)\n{\n    int ret;\n    AVExpr *old = NULL;\n\n    if (*pexpr)\n        old = *pexpr;\n    ret = av_expr_parse(pexpr, expr, var_names,\n                        NULL, NULL, NULL, NULL, 0, log_ctx);\n    if (ret < 0) {\n        av_log(log_ctx, AV_LOG_ERROR,\n               \"Error when evaluating the expression '%s'\\n\", expr);\n        *pexpr = old;\n        return ret;\n    }\n\n    av_expr_free(old);\n    return 0;\n}", "before_change_lines": [6, 7, 10, 13], "raw_before_change_lines": [6, 7, 10, 13], "after_change_lines": [4, 7, 10, 13, 14, 15, 17, 18], "raw_after_change_lines": [4, 7, 10, 13, 14, 15, 16, 17, 18], "bug_lines": [6, 7, 10, 13], "added": [false, false, false, false], "idx": 78}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1038----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38a40d1cab1051c3b0d8be4eef69f34c4ef1b867_1.json----adx_encode", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_38a40d1cab1051c3b0d8be4eef69f34c4ef1b867_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38a40d1cab1051c3b0d8be4eef69f34c4ef1b867_1.json", "function_name": "adx_encode", "vul_func_code": "static void adx_encode(unsigned char *adx,const short *wav,\n                       ADXChannelState *prev)\n{\n    int scale;\n    int i;\n    int s0,s1,s2,d;\n    int max=0;\n    int min=0;\n    int data[32];\n\n    s1 = prev->s1;\n    s2 = prev->s2;\n    for(i=0;i<32;i++) {\n        s0 = wav[i];\n        d = ((s0<<14) - SCALE1*s1 + SCALE2*s2)/BASEVOL;\n        data[i]=d;\n        if (max<d) max=d;\n        if (min>d) min=d;\n        s2 = s1;\n        s1 = s0;\n    }\n    prev->s1 = s1;\n    prev->s2 = s2;\n\n    /* -8..+7 */\n\n    if (max==0 && min==0) {\n        memset(adx,0,18);\n        return;\n    }\n\n    if (max/7>-min/8) scale = max/7;\n    else scale = -min/8;\n\n    if (scale==0) scale=1;\n\n    AV_WB16(adx, scale);\n\n    for(i=0;i<16;i++) {\n        adx[i+2] = ((data[i*2]/scale)<<4) | ((data[i*2+1]/scale)&0xf);\n    }\n}", "patch_func_code": "static void adx_encode(unsigned char *adx,const short *wav,\n                       ADXChannelState *prev)\n{\n    int scale;\n    int i;\n    int s0,s1,s2,d;\n    int max=0;\n    int min=0;\n    int data[32];\n\n    s1 = prev->s1;\n    s2 = prev->s2;\n    for(i=0;i<32;i++) {\n        s0 = wav[i];\n        d = ((s0 << COEFF_BITS) - COEFF1 * s1 + COEFF2 * s2) >> COEFF_BITS;\n        data[i]=d;\n        if (max<d) max=d;\n        if (min>d) min=d;\n        s2 = s1;\n        s1 = s0;\n    }\n    prev->s1 = s1;\n    prev->s2 = s2;\n\n    /* -8..+7 */\n\n    if (max==0 && min==0) {\n        memset(adx,0,18);\n        return;\n    }\n\n    if (max/7>-min/8) scale = max/7;\n    else scale = -min/8;\n\n    if (scale==0) scale=1;\n\n    AV_WB16(adx, scale);\n\n    for(i=0;i<16;i++) {\n        adx[i+2] = ((data[i*2]/scale)<<4) | ((data[i*2+1]/scale)&0xf);\n    }\n}", "before_change_lines": [15], "raw_before_change_lines": [15], "after_change_lines": [15], "raw_after_change_lines": [15], "bug_lines": [15], "added": [false], "idx": 79}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1043----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38d25a19a3dacaf85848a3ef5e98cc62c1526d15_1.json----avpriv_adx_decode_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_38d25a19a3dacaf85848a3ef5e98cc62c1526d15_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_38d25a19a3dacaf85848a3ef5e98cc62c1526d15_1.json", "function_name": "avpriv_adx_decode_header", "vul_func_code": "int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf,\n                             int bufsize, int *header_size, int *coeff)\n{\n    int offset, cutoff;\n\n    if (bufsize < 24)\n        return AVERROR_INVALIDDATA;\n\n    if (AV_RB16(buf) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    offset = AV_RB16(buf + 2) + 4;\n\n    /* if copyright string is within the provided data, validate it */\n    if (bufsize >= offset && memcmp(buf + offset - 6, \"(c)CRI\", 6))\n        return AVERROR_INVALIDDATA;\n\n    /* check for encoding=3 block_size=18, sample_size=4 */\n    if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) {\n        av_log_ask_for_sample(avctx, \"unsupported ADX format\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* channels */\n    avctx->channels = buf[7];\n    if (avctx->channels > 2)\n        return AVERROR_INVALIDDATA;\n\n    /* sample rate */\n    avctx->sample_rate = AV_RB32(buf + 8);\n    if (avctx->sample_rate < 1 ||\n        avctx->sample_rate > INT_MAX / (avctx->channels * BLOCK_SIZE * 8))\n        return AVERROR_INVALIDDATA;\n\n    /* bit rate */\n    avctx->bit_rate = avctx->sample_rate * avctx->channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES;\n\n    /* LPC coefficients */\n    if (coeff) {\n        cutoff = AV_RB16(buf + 16);\n        ff_adx_calculate_coeffs(cutoff, avctx->sample_rate, COEFF_BITS, coeff);\n    }\n\n    *header_size = offset;\n    return 0;\n}", "patch_func_code": "int avpriv_adx_decode_header(AVCodecContext *avctx, const uint8_t *buf,\n                             int bufsize, int *header_size, int *coeff)\n{\n    int offset, cutoff;\n\n    if (bufsize < 24)\n        return AVERROR_INVALIDDATA;\n\n    if (AV_RB16(buf) != 0x8000)\n        return AVERROR_INVALIDDATA;\n    offset = AV_RB16(buf + 2) + 4;\n\n    /* if copyright string is within the provided data, validate it */\n    if (bufsize >= offset && memcmp(buf + offset - 6, \"(c)CRI\", 6))\n        return AVERROR_INVALIDDATA;\n\n    /* check for encoding=3 block_size=18, sample_size=4 */\n    if (buf[4] != 3 || buf[5] != 18 || buf[6] != 4) {\n        av_log_ask_for_sample(avctx, \"unsupported ADX format\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    /* channels */\n    avctx->channels = buf[7];\n    if (avctx->channels <= 0 || avctx->channels > 2)\n        return AVERROR_INVALIDDATA;\n\n    /* sample rate */\n    avctx->sample_rate = AV_RB32(buf + 8);\n    if (avctx->sample_rate < 1 ||\n        avctx->sample_rate > INT_MAX / (avctx->channels * BLOCK_SIZE * 8))\n        return AVERROR_INVALIDDATA;\n\n    /* bit rate */\n    avctx->bit_rate = avctx->sample_rate * avctx->channels * BLOCK_SIZE * 8 / BLOCK_SAMPLES;\n\n    /* LPC coefficients */\n    if (coeff) {\n        cutoff = AV_RB16(buf + 16);\n        ff_adx_calculate_coeffs(cutoff, avctx->sample_rate, COEFF_BITS, coeff);\n    }\n\n    *header_size = offset;\n    return 0;\n}", "before_change_lines": [25], "raw_before_change_lines": [25], "after_change_lines": [25], "raw_after_change_lines": [25], "bug_lines": [25], "added": [false], "idx": 80}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "1053----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_39ccaaadd29fd263e8d757fd1ab6e0ecb173c263_1.json----ff_rv34_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_39ccaaadd29fd263e8d757fd1ab6e0ecb173c263_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_39ccaaadd29fd263e8d757fd1ab6e0ecb173c263_1.json", "function_name": "ff_rv34_decode_frame", "vul_func_code": "int ff_rv34_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            const uint8_t *buf, int buf_size)\n{\n    RV34DecContext *r = avctx->priv_data;\n    MpegEncContext *s = &r->s;\n    AVFrame *pict = data;\n    SliceInfo si;\n    int i;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n    int last = 0;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            *pict= *(AVFrame*)s->next_picture_ptr;\n            s->next_picture_ptr= NULL;\n\n            *data_size = sizeof(AVFrame);\n        }\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    for(i=0; i<slice_count; i++){\n        int offset= get_slice_offset(avctx, slices_hdr, i);\n        int size;\n        if(i+1 == slice_count)\n            size= buf_size - offset;\n        else\n            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(offset > buf_size){\n            av_log(avctx, AV_LOG_ERROR, \"Slice offset is greater than frame size\\n\");\n            break;\n        }\n\n        r->si.end = s->mb_width * s->mb_height;\n        if(i+1 < slice_count){\n            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n                if(i+2 < slice_count)\n                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n                else\n                    size = buf_size - offset;\n            }else\n                r->si.end = si.start;\n        }\n        if(!i && si.type == FF_B_TYPE && (!s->last_picture_ptr || !s->last_picture_ptr->data[0]))\n            return -1;\n        last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n        if(last)\n            break;\n    }\n\n    if(last){\n        if(r->loop_filter)\n            r->loop_filter(r, s->mb_height - 1);\n        ff_er_frame_end(s);\n        MPV_frame_end(s);\n        if (s->pict_type == FF_B_TYPE || s->low_delay) {\n            *pict= *(AVFrame*)s->current_picture_ptr;\n        } else if (s->last_picture_ptr != NULL) {\n            *pict= *(AVFrame*)s->last_picture_ptr;\n        }\n\n        if(s->last_picture_ptr || s->low_delay){\n            *data_size = sizeof(AVFrame);\n            ff_print_debug_info(s, pict);\n        }\n        s->current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)\n    }\n    return buf_size;\n}", "patch_func_code": "int ff_rv34_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            const uint8_t *buf, int buf_size)\n{\n    RV34DecContext *r = avctx->priv_data;\n    MpegEncContext *s = &r->s;\n    AVFrame *pict = data;\n    SliceInfo si;\n    int i;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n    int last = 0;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            *pict= *(AVFrame*)s->next_picture_ptr;\n            s->next_picture_ptr= NULL;\n\n            *data_size = sizeof(AVFrame);\n        }\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    //parse first slice header to check whether this frame can be decoded\n    if(get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n        av_log(avctx, AV_LOG_ERROR, \"Slice offset is greater than frame size\\n\");\n        return -1;\n    }\n    init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), buf_size-get_slice_offset(avctx, slices_hdr, 0));\n    if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n        av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n        return -1;\n    }\n    if((!s->last_picture_ptr || !s->last_picture_ptr->data[0]) && si.type == FF_B_TYPE)\n        return -1;\n\n    for(i=0; i<slice_count; i++){\n        int offset= get_slice_offset(avctx, slices_hdr, i);\n        int size;\n        if(i+1 == slice_count)\n            size= buf_size - offset;\n        else\n            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(offset > buf_size){\n            av_log(avctx, AV_LOG_ERROR, \"Slice offset is greater than frame size\\n\");\n            break;\n        }\n\n        r->si.end = s->mb_width * s->mb_height;\n        if(i+1 < slice_count){\n            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n                if(i+2 < slice_count)\n                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n                else\n                    size = buf_size - offset;\n            }else\n                r->si.end = si.start;\n        }\n        last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n        if(last)\n            break;\n    }\n\n    if(last){\n        if(r->loop_filter)\n            r->loop_filter(r, s->mb_height - 1);\n        ff_er_frame_end(s);\n        MPV_frame_end(s);\n        if (s->pict_type == FF_B_TYPE || s->low_delay) {\n            *pict= *(AVFrame*)s->current_picture_ptr;\n        } else if (s->last_picture_ptr != NULL) {\n            *pict= *(AVFrame*)s->last_picture_ptr;\n        }\n\n        if(s->last_picture_ptr || s->low_delay){\n            *data_size = sizeof(AVFrame);\n            ff_print_debug_info(s, pict);\n        }\n        s->current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)\n    }\n    return buf_size;\n}", "before_change_lines": [57, 58], "raw_before_change_lines": [57, 58], "after_change_lines": [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "raw_after_change_lines": [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45], "bug_lines": [57, 58], "added": [false, false], "idx": 81}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1118----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3d81816c7901897f78af211de469ac96e29e0c79_1.json----tget_long", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_3d81816c7901897f78af211de469ac96e29e0c79_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3d81816c7901897f78af211de469ac96e29e0c79_1.json", "function_name": "tget_long", "vul_func_code": "static unsigned tget_long(GetByteContext *gb, int le)\n{\n    unsigned v = le ? bytestream2_get_le32(gb) : bytestream2_get_be32(gb);\n    return v;\n}", "patch_func_code": "static unsigned tget_long(GetByteContext *gb, int le)\n{\n    unsigned v = le ? bytestream2_get_le32u(gb) : bytestream2_get_be32u(gb);\n    return v;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 82}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1126----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3df2b2de10ce93fea4b9653852e250154d91ac0c_1.json----tee_write_trailer", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_3df2b2de10ce93fea4b9653852e250154d91ac0c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3df2b2de10ce93fea4b9653852e250154d91ac0c_1.json", "function_name": "tee_write_trailer", "vul_func_code": "static int tee_write_trailer(AVFormatContext *avf)\n{\n    TeeContext *tee = avf->priv_data;\n    AVFormatContext *avf2;\n    int ret_all = 0, ret;\n    unsigned i;\n\n    for (i = 0; i < tee->nb_slaves; i++) {\n        avf2 = tee->slaves[i].avf;\n        if ((ret = av_write_trailer(avf2)) < 0)\n            if (!ret_all)\n                ret_all = ret;\n        if (!(avf2->oformat->flags & AVFMT_NOFILE))\n            ff_format_io_close(avf2, &avf2->pb);\n    }\n    close_slaves(avf);\n    return ret_all;\n}", "patch_func_code": "static int tee_write_trailer(AVFormatContext *avf)\n{\n    TeeContext *tee = avf->priv_data;\n    int ret_all = 0, ret;\n    unsigned i;\n\n    for (i = 0; i < tee->nb_slaves; i++) {\n        if ((ret = close_slave(&tee->slaves[i])) < 0)\n            if (!ret_all)\n                ret_all = ret;\n    }\n    return ret_all;\n}", "before_change_lines": [4, 9, 10, 13, 14, 16], "raw_before_change_lines": [4, 9, 10, 13, 14, 16], "after_change_lines": [8], "raw_after_change_lines": [8], "bug_lines": [4, 9, 10, 13, 14, 16], "added": [false, false, false, false, false, false], "idx": 83}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1149----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3ed90b1d3449c31a9c72c6f1758e47d18cd3f765_1.json----ffv1_init_slice_contexts", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_3ed90b1d3449c31a9c72c6f1758e47d18cd3f765_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3ed90b1d3449c31a9c72c6f1758e47d18cd3f765_1.json", "function_name": "ffv1_init_slice_contexts", "vul_func_code": "int ffv1_init_slice_contexts(FFV1Context *f)\n{\n    int i;\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n    if (f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    for (i = 0; i < f->slice_count; i++) {\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n        int sx          = i % f->num_h_slices;\n        int sy          = i / f->num_h_slices;\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n        f->slice_context[i] = fs;\n        memcpy(fs, f, sizeof(*fs));\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n        fs->slice_width  = sxe - sxs;\n        fs->slice_height = sye - sys;\n        fs->slice_x      = sxs;\n        fs->slice_y      = sys;\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n                                      sizeof(*fs->sample_buffer));\n        if (!fs->sample_buffer)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "patch_func_code": "int ffv1_init_slice_contexts(FFV1Context *f)\n{\n    int i, j;\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n    if (f->slice_count <= 0) {\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    for (i = 0; i < f->slice_count; i++) {\n        int sx          = i % f->num_h_slices;\n        int sy          = i / f->num_h_slices;\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n        if (!fs)\n            goto memfail;\n\n        f->slice_context[i] = fs;\n        memcpy(fs, f, sizeof(*fs));\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n        fs->slice_width  = sxe - sxs;\n        fs->slice_height = sye - sys;\n        fs->slice_x      = sxs;\n        fs->slice_y      = sys;\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n                                      sizeof(*fs->sample_buffer));\n        if (!fs->sample_buffer) {\n            av_free(fs);\n            goto memfail;\n        }\n    }\n    return 0;\n\nmemfail:\n    for (j = 0; j < i; j++) {\n        av_free(&f->slice_context[j]->sample_buffer);\n        av_free(&f->slice_context[j]);\n    }\n    return AVERROR(ENOMEM);\n}", "before_change_lines": [3, 12, 30, 31], "raw_before_change_lines": [3, 12, 30, 31], "after_change_lines": [3, 18, 19, 20, 33, 34, 35, 36, 40, 41, 42, 43, 44, 45], "raw_after_change_lines": [3, 18, 19, 20, 21, 33, 34, 35, 36, 39, 40, 41, 42, 43, 44, 45], "bug_lines": [3, 12, 30, 31], "added": [false, false, false, false], "idx": 84}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1154----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3eeaeb56edfdc114edb0514a66b59925360071bf_1.json----hevc_loop_filter_luma_8", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_3eeaeb56edfdc114edb0514a66b59925360071bf_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_3eeaeb56edfdc114edb0514a66b59925360071bf_1.json", "function_name": "hevc_loop_filter_luma_8", "vul_func_code": "static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix,\n                                        ptrdiff_t _xstride, ptrdiff_t _ystride,\n                                        int *_beta, int *_tc,\n                                        uint8_t *_no_p, uint8_t *_no_q)\n{\n    int d, j;\n    pixel *pix        = (pixel *)_pix;\n    ptrdiff_t xstride = _xstride / sizeof(pixel);\n    ptrdiff_t ystride = _ystride / sizeof(pixel);\n\n    for (j = 0; j < 2; j++) {\n        const int dp0  = abs(P2  - 2 * P1  + P0);\n        const int dq0  = abs(Q2  - 2 * Q1  + Q0);\n        const int dp3  = abs(TP2 - 2 * TP1 + TP0);\n        const int dq3  = abs(TQ2 - 2 * TQ1 + TQ0);\n        const int d0   = dp0 + dq0;\n        const int d3   = dp3 + dq3;\n        const int beta = _beta[j] << (BIT_DEPTH - 8);\n        const int tc   = _tc[j]   << (BIT_DEPTH - 8);\n        const int no_p = _no_p[j];\n        const int no_q = _no_q[j];\n\n        if (d0 + d3 >= beta) {\n            pix += 4 * ystride;\n            continue;\n        } else {\n            const int beta_3 = beta >> 3;\n            const int beta_2 = beta >> 2;\n            const int tc25   = ((tc * 5 + 1) >> 1);\n\n            if (abs(P3  -  P0) + abs(Q3  -  Q0) < beta_3 && abs(P0  -  Q0) < tc25 &&\n                abs(TP3 - TP0) + abs(TQ3 - TQ0) < beta_3 && abs(TP0 - TQ0) < tc25 &&\n                                      (d0 << 1) < beta_2 &&      (d3 << 1) < beta_2) {\n                // strong filtering\n                const int tc2 = tc << 1;\n                for (d = 0; d < 4; d++) {\n                    const int p3 = P3;\n                    const int p2 = P2;\n                    const int p1 = P1;\n                    const int p0 = P0;\n                    const int q0 = Q0;\n                    const int q1 = Q1;\n                    const int q2 = Q2;\n                    const int q3 = Q3;\n                    if (!no_p) {\n                        P0 = p0 + av_clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3) - p0, -tc2, tc2);\n                        P1 = p1 + av_clip(((p2 + p1 + p0 + q0 + 2) >> 2) - p1, -tc2, tc2);\n                        P2 = p2 + av_clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3) - p2, -tc2, tc2);\n                    }\n                    if (!no_q) {\n                        Q0 = q0 + av_clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3) - q0, -tc2, tc2);\n                        Q1 = q1 + av_clip(((p0 + q0 + q1 + q2 + 2) >> 2) - q1, -tc2, tc2);\n                        Q2 = q2 + av_clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3) - q2, -tc2, tc2);\n                    }\n                    pix += ystride;\n                }\n            } else { // normal filtering\n                int nd_p = 1;\n                int nd_q = 1;\n                const int tc_2 = tc >> 1;\n                if (dp0 + dp3 < ((beta + (beta >> 1)) >> 3))\n                    nd_p = 2;\n                if (dq0 + dq3 < ((beta + (beta >> 1)) >> 3))\n                    nd_q = 2;\n\n                for (d = 0; d < 4; d++) {\n                    const int p2 = P2;\n                    const int p1 = P1;\n                    const int p0 = P0;\n                    const int q0 = Q0;\n                    const int q1 = Q1;\n                    const int q2 = Q2;\n                    int delta0   = (9 * (q0 - p0) - 3 * (q1 - p1) + 8) >> 4;\n                    if (abs(delta0) < 10 * tc) {\n                        delta0 = av_clip(delta0, -tc, tc);\n                        if (!no_p)\n                            P0 = av_clip_pixel(p0 + delta0);\n                        if (!no_q)\n                            Q0 = av_clip_pixel(q0 - delta0);\n                        if (!no_p && nd_p > 1) {\n                            const int deltap1 = av_clip((((p2 + p0 + 1) >> 1) - p1 + delta0) >> 1, -tc_2, tc_2);\n                            P1 = av_clip_pixel(p1 + deltap1);\n                        }\n                        if (!no_q && nd_q > 1) {\n                            const int deltaq1 = av_clip((((q2 + q0 + 1) >> 1) - q1 - delta0) >> 1, -tc_2, tc_2);\n                            Q1 = av_clip_pixel(q1 + deltaq1);\n                        }\n                    }\n                    pix += ystride;\n                }\n            }\n        }\n    }\n}", "patch_func_code": "static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix,\n                                        ptrdiff_t _xstride, ptrdiff_t _ystride,\n                                        int beta, int *_tc,\n                                        uint8_t *_no_p, uint8_t *_no_q)\n{\n    int d, j;\n    pixel *pix        = (pixel *)_pix;\n    ptrdiff_t xstride = _xstride / sizeof(pixel);\n    ptrdiff_t ystride = _ystride / sizeof(pixel);\n\n    beta <<= BIT_DEPTH - 8;\n\n    for (j = 0; j < 2; j++) {\n        const int dp0  = abs(P2  - 2 * P1  + P0);\n        const int dq0  = abs(Q2  - 2 * Q1  + Q0);\n        const int dp3  = abs(TP2 - 2 * TP1 + TP0);\n        const int dq3  = abs(TQ2 - 2 * TQ1 + TQ0);\n        const int d0   = dp0 + dq0;\n        const int d3   = dp3 + dq3;\n        const int tc   = _tc[j]   << (BIT_DEPTH - 8);\n        const int no_p = _no_p[j];\n        const int no_q = _no_q[j];\n\n        if (d0 + d3 >= beta) {\n            pix += 4 * ystride;\n            continue;\n        } else {\n            const int beta_3 = beta >> 3;\n            const int beta_2 = beta >> 2;\n            const int tc25   = ((tc * 5 + 1) >> 1);\n\n            if (abs(P3  -  P0) + abs(Q3  -  Q0) < beta_3 && abs(P0  -  Q0) < tc25 &&\n                abs(TP3 - TP0) + abs(TQ3 - TQ0) < beta_3 && abs(TP0 - TQ0) < tc25 &&\n                                      (d0 << 1) < beta_2 &&      (d3 << 1) < beta_2) {\n                // strong filtering\n                const int tc2 = tc << 1;\n                for (d = 0; d < 4; d++) {\n                    const int p3 = P3;\n                    const int p2 = P2;\n                    const int p1 = P1;\n                    const int p0 = P0;\n                    const int q0 = Q0;\n                    const int q1 = Q1;\n                    const int q2 = Q2;\n                    const int q3 = Q3;\n                    if (!no_p) {\n                        P0 = p0 + av_clip(((p2 + 2 * p1 + 2 * p0 + 2 * q0 + q1 + 4) >> 3) - p0, -tc2, tc2);\n                        P1 = p1 + av_clip(((p2 + p1 + p0 + q0 + 2) >> 2) - p1, -tc2, tc2);\n                        P2 = p2 + av_clip(((2 * p3 + 3 * p2 + p1 + p0 + q0 + 4) >> 3) - p2, -tc2, tc2);\n                    }\n                    if (!no_q) {\n                        Q0 = q0 + av_clip(((p1 + 2 * p0 + 2 * q0 + 2 * q1 + q2 + 4) >> 3) - q0, -tc2, tc2);\n                        Q1 = q1 + av_clip(((p0 + q0 + q1 + q2 + 2) >> 2) - q1, -tc2, tc2);\n                        Q2 = q2 + av_clip(((2 * q3 + 3 * q2 + q1 + q0 + p0 + 4) >> 3) - q2, -tc2, tc2);\n                    }\n                    pix += ystride;\n                }\n            } else { // normal filtering\n                int nd_p = 1;\n                int nd_q = 1;\n                const int tc_2 = tc >> 1;\n                if (dp0 + dp3 < ((beta + (beta >> 1)) >> 3))\n                    nd_p = 2;\n                if (dq0 + dq3 < ((beta + (beta >> 1)) >> 3))\n                    nd_q = 2;\n\n                for (d = 0; d < 4; d++) {\n                    const int p2 = P2;\n                    const int p1 = P1;\n                    const int p0 = P0;\n                    const int q0 = Q0;\n                    const int q1 = Q1;\n                    const int q2 = Q2;\n                    int delta0   = (9 * (q0 - p0) - 3 * (q1 - p1) + 8) >> 4;\n                    if (abs(delta0) < 10 * tc) {\n                        delta0 = av_clip(delta0, -tc, tc);\n                        if (!no_p)\n                            P0 = av_clip_pixel(p0 + delta0);\n                        if (!no_q)\n                            Q0 = av_clip_pixel(q0 - delta0);\n                        if (!no_p && nd_p > 1) {\n                            const int deltap1 = av_clip((((p2 + p0 + 1) >> 1) - p1 + delta0) >> 1, -tc_2, tc_2);\n                            P1 = av_clip_pixel(p1 + deltap1);\n                        }\n                        if (!no_q && nd_q > 1) {\n                            const int deltaq1 = av_clip((((q2 + q0 + 1) >> 1) - q1 - delta0) >> 1, -tc_2, tc_2);\n                            Q1 = av_clip_pixel(q1 + deltaq1);\n                        }\n                    }\n                    pix += ystride;\n                }\n            }\n        }\n    }\n}", "before_change_lines": [3, 18], "raw_before_change_lines": [3, 18], "after_change_lines": [3, 11], "raw_after_change_lines": [3, 11, 12], "bug_lines": [3, 18], "added": [false, false], "idx": 85}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "1190----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_40f1dadac0826affb49726324ec4d3709b48a6ec_1.json----format_name", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_40f1dadac0826affb49726324ec4d3709b48a6ec_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_40f1dadac0826affb49726324ec4d3709b48a6ec_1.json", "function_name": "format_name", "vul_func_code": "static int format_name(char *buf, int buf_len, int index)\n{\n    const char *proto, *dir;\n    char *orig_buf_dup = NULL, *mod_buf_dup = NULL;\n    int ret = 0;\n\n    if (!av_stristr(buf, \"%v\"))\n        return ret;\n\n    orig_buf_dup = av_strdup(buf);\n    if (!orig_buf_dup) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if (replace_int_data_in_filename(buf, buf_len, orig_buf_dup, 'v', index) < 1) {\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    proto = avio_find_protocol_name(orig_buf_dup);\n    dir = av_dirname(orig_buf_dup);\n\n    /* if %v is present in the file's directory, create sub-directory */\n    if (av_stristr(dir, \"%v\") && proto && !strcmp(proto, \"file\")) {\n        mod_buf_dup = av_strdup(buf);\n        if (!mod_buf_dup) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        dir = av_dirname(mod_buf_dup);\n        if (mkdir_p(dir) == -1 && errno != EEXIST) {\n            ret = AVERROR(errno);\n            goto fail;\n        }\n    }\n\nfail:\n    av_freep(&orig_buf_dup);\n    av_freep(&mod_buf_dup);\n    return ret;\n}", "patch_func_code": "static int format_name(char *buf, int buf_len, int index)\n{\n    const char *proto, *dir;\n    char *orig_buf_dup = NULL, *mod_buf = NULL, *mod_buf_dup = NULL;\n    int ret = 0;\n\n    if (!av_stristr(buf, \"%v\"))\n        return ret;\n\n    orig_buf_dup = av_strdup(buf);\n    if (!orig_buf_dup) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if (replace_int_data_in_filename(&mod_buf, orig_buf_dup, 'v', index) < 1) {\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n    av_strlcpy(buf, mod_buf, buf_len);\n\n    proto = avio_find_protocol_name(orig_buf_dup);\n    dir = av_dirname(orig_buf_dup);\n\n    /* if %v is present in the file's directory, create sub-directory */\n    if (av_stristr(dir, \"%v\") && proto && !strcmp(proto, \"file\")) {\n        mod_buf_dup = av_strdup(buf);\n        if (!mod_buf_dup) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        dir = av_dirname(mod_buf_dup);\n        if (mkdir_p(dir) == -1 && errno != EEXIST) {\n            ret = AVERROR(errno);\n            goto fail;\n        }\n    }\n\nfail:\n    av_freep(&orig_buf_dup);\n    av_freep(&mod_buf_dup);\n    av_freep(&mod_buf);\n    return ret;\n}", "before_change_lines": [4, 16], "raw_before_change_lines": [4, 16], "after_change_lines": [4, 16, 20, 43], "raw_after_change_lines": [4, 16, 20, 43], "bug_lines": [4, 16], "added": [false, false], "idx": 86}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "1194----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4112a7048e03ff6df31df70d6ebe622d6fc9e1ea_1.json----mov_read_trun", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4112a7048e03ff6df31df70d6ebe622d6fc9e1ea_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4112a7048e03ff6df31df70d6ebe622d6fc9e1ea_1.json", "function_name": "mov_read_trun", "vul_func_code": "static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i, found_keyframe = 0, err;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %d\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_dlog(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);\n\n    /* Always assume the presence of composition time offsets.\n     * Without this assumption, for instance, we cannot deal with a track in fragmented movies that meet the following.\n     *  1) in the initial movie, there are no samples.\n     *  2) in the first movie fragment, there is only one sample without composition time offset.\n     *  3) in the subsequent movie fragments, there are samples with composition time offset. */\n    if (!sc->ctts_count && sc->sample_count)\n    {\n        /* Complement ctts table if moov atom doesn't have ctts atom. */\n        ctts_data = av_realloc(NULL, sizeof(*sc->ctts_data));\n        if (!ctts_data)\n            return AVERROR(ENOMEM);\n        sc->ctts_data = ctts_data;\n        sc->ctts_data[sc->ctts_count].count = sc->sample_count;\n        sc->ctts_data[sc->ctts_count].duration = 0;\n        sc->ctts_count++;\n    }\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp_array(&sc->ctts_data, entries + sc->ctts_count,\n                                 sizeof(*sc->ctts_data))) < 0) {\n        sc->ctts_count = 0;\n        return err;\n    }\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_dlog(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        int keyframe = 0;\n        int sample_cts = 0;\n        int64_t cts;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      sample_cts      = avio_rb32(pb);\n        sc->ctts_data[sc->ctts_count].count    = 1;\n        sc->ctts_data[sc->ctts_count].duration = sample_cts;\n        mov_update_dts_shift(sc, sc->ctts_data[sc->ctts_count].duration);\n        if (frag->time != AV_NOPTS_VALUE) {\n            if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n                int64_t pts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \" sc->dts_shift %d ctts.duration %d\"\n                        \" sc->time_offset %\"PRId64\" flags & MOV_TRUN_SAMPLE_CTS %d\\n\", pts,\n                        sc->dts_shift, sc->ctts_data[sc->ctts_count].duration,\n                        sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n                dts = pts - sc->dts_shift;\n                if (flags & MOV_TRUN_SAMPLE_CTS) {\n                    dts -= sc->ctts_data[sc->ctts_count].duration;\n                } else {\n                    dts -= sc->time_offset;\n                }\n                av_log(c->fc, AV_LOG_DEBUG, \"calculated into dts %\"PRId64\"\\n\", dts);\n            } else {\n                dts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n            frag->time = AV_NOPTS_VALUE;\n        }\n        cts = dts + sample_cts;\n\n        sc->ctts_count++;\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else if (!found_keyframe)\n            keyframe = found_keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        err = av_add_index_entry(st, offset, INT64_MAX/2, sample_size, distance,\n                                 keyframe ? AVINDEX_KEYFRAME : 0);\n        if (err < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n        } else\n            st->index_entries[st->nb_index_entries - 1].timestamp = cts;\n        av_dlog(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", cts %\"PRId64\", \"\n                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,\n                offset, cts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n        sc->duration_for_fps += sample_duration;\n        sc->nb_frames_for_fps ++;\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    frag->implicit_offset = offset;\n    st->duration = sc->track_end = dts + sc->time_offset;\n    return 0;\n}", "patch_func_code": "static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i, found_keyframe = 0, err;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %d\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_dlog(c->fc, \"flags 0x%x entries %d\\n\", flags, entries);\n\n    /* Always assume the presence of composition time offsets.\n     * Without this assumption, for instance, we cannot deal with a track in fragmented movies that meet the following.\n     *  1) in the initial movie, there are no samples.\n     *  2) in the first movie fragment, there is only one sample without composition time offset.\n     *  3) in the subsequent movie fragments, there are samples with composition time offset. */\n    if (!sc->ctts_count && sc->sample_count)\n    {\n        /* Complement ctts table if moov atom doesn't have ctts atom. */\n        ctts_data = av_realloc(NULL, sizeof(*sc->ctts_data));\n        if (!ctts_data)\n            return AVERROR(ENOMEM);\n        sc->ctts_data = ctts_data;\n        sc->ctts_data[sc->ctts_count].count = sc->sample_count;\n        sc->ctts_data[sc->ctts_count].duration = 0;\n        sc->ctts_count++;\n    }\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp_array(&sc->ctts_data, entries + sc->ctts_count,\n                                 sizeof(*sc->ctts_data))) < 0) {\n        sc->ctts_count = 0;\n        return err;\n    }\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_dlog(c->fc, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        int keyframe = 0;\n        int sample_cts = 0;\n        int64_t cts;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      sample_cts      = avio_rb32(pb);\n        sc->ctts_data[sc->ctts_count].count    = 1;\n        sc->ctts_data[sc->ctts_count].duration = sample_cts;\n        mov_update_dts_shift(sc, sc->ctts_data[sc->ctts_count].duration);\n        if (frag->time != AV_NOPTS_VALUE) {\n            if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n                int64_t pts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \" sc->dts_shift %d ctts.duration %d\"\n                        \" sc->time_offset %\"PRId64\" flags & MOV_TRUN_SAMPLE_CTS %d\\n\", pts,\n                        sc->dts_shift, sc->ctts_data[sc->ctts_count].duration,\n                        sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n                dts = pts - sc->dts_shift;\n                if (flags & MOV_TRUN_SAMPLE_CTS) {\n                    dts -= sc->ctts_data[sc->ctts_count].duration;\n                } else {\n                    dts -= sc->time_offset;\n                }\n                av_log(c->fc, AV_LOG_DEBUG, \"calculated into dts %\"PRId64\"\\n\", dts);\n            } else {\n                dts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n            frag->time = AV_NOPTS_VALUE;\n        }\n        cts = dts + sample_cts;\n\n        sc->ctts_count++;\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else if (!found_keyframe)\n            keyframe = found_keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        err = av_add_index_entry(st, offset, cts, sample_size, distance,\n                                 keyframe ? AVINDEX_KEYFRAME : 0);\n        if (err < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n        }\n        av_dlog(c->fc, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", cts %\"PRId64\", \"\n                \"size %d, distance %d, keyframe %d\\n\", st->index, sc->sample_count+i,\n                offset, cts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n        sc->duration_for_fps += sample_duration;\n        sc->nb_frames_for_fps ++;\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    frag->implicit_offset = offset;\n    st->duration = sc->track_end = dts + sc->time_offset;\n    return 0;\n}", "before_change_lines": [108, 112, 113], "raw_before_change_lines": [108, 112, 113], "after_change_lines": [108, 112], "raw_after_change_lines": [108, 112], "bug_lines": [108, 112, 113], "added": [false, false, false], "idx": 87}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "1224----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_425bb358ef4206e3dff879e0d68661bd99092ebb_1.json----ass_split_section", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_425bb358ef4206e3dff879e0d68661bd99092ebb_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_425bb358ef4206e3dff879e0d68661bd99092ebb_1.json", "function_name": "ass_split_section", "vul_func_code": "static const char *ass_split_section(ASSSplitContext *ctx, const char *buf)\n{\n    const ASSSection *section = &ass_sections[ctx->current_section];\n    int *number = &ctx->field_number[ctx->current_section];\n    int *order = ctx->field_order[ctx->current_section];\n    int *tmp, i, len;\n\n    while (buf && *buf) {\n        if (buf[0] == '[') {\n            ctx->current_section = -1;\n            break;\n        }\n        if (buf[0] == ';' || (buf[0] == '!' && buf[1] == ':')) {\n            /* skip comments */\n        } else if (section->format_header && !order) {\n            len = strlen(section->format_header);\n            if (strncmp(buf, section->format_header, len) || buf[len] != ':')\n                return NULL;\n            buf += len + 1;\n            while (!is_eol(*buf)) {\n                buf = skip_space(buf);\n                len = strcspn(buf, \", \\r\\n\");\n                if (!(tmp = av_realloc(order, (*number + 1) * sizeof(*order))))\n                    return NULL;\n                order = tmp;\n                order[*number] = -1;\n                for (i=0; section->fields[i].name; i++)\n                    if (!strncmp(buf, section->fields[i].name, len)) {\n                        order[*number] = i;\n                        break;\n                    }\n                (*number)++;\n                buf = skip_space(buf + len + (buf[len] == ','));\n            }\n            ctx->field_order[ctx->current_section] = order;\n        } else if (section->fields_header) {\n            len = strlen(section->fields_header);\n            if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') {\n                uint8_t *ptr, *struct_ptr = realloc_section_array(ctx);\n                if (!struct_ptr)  return NULL;\n                buf += len + 1;\n                for (i=0; !is_eol(*buf) && i < *number; i++) {\n                    int last = i == *number - 1;\n                    buf = skip_space(buf);\n                    len = strcspn(buf, last ? \"\\r\\n\" : \",\\r\\n\");\n                    if (order[i] >= 0) {\n                        ASSFieldType type = section->fields[order[i]].type;\n                        ptr = struct_ptr + section->fields[order[i]].offset;\n                        convert_func[type](ptr, buf, len);\n                    }\n                    buf = skip_space(buf + len + !last);\n                }\n            }\n        } else {\n            len = strcspn(buf, \":\\r\\n\");\n            if (buf[len] == ':') {\n                for (i=0; section->fields[i].name; i++)\n                    if (!strncmp(buf, section->fields[i].name, len)) {\n                        ASSFieldType type = section->fields[i].type;\n                        uint8_t *ptr = (uint8_t *)&ctx->ass + section->offset;\n                        ptr += section->fields[i].offset;\n                        buf = skip_space(buf + len + 1);\n                        convert_func[type](ptr, buf, strcspn(buf, \"\\r\\n\"));\n                        break;\n                    }\n            }\n        }\n        buf += strcspn(buf, \"\\n\") + 1;\n    }\n    return buf;\n}", "patch_func_code": "static const char *ass_split_section(ASSSplitContext *ctx, const char *buf)\n{\n    const ASSSection *section = &ass_sections[ctx->current_section];\n    int *number = &ctx->field_number[ctx->current_section];\n    int *order = ctx->field_order[ctx->current_section];\n    int *tmp, i, len;\n\n    while (buf && *buf) {\n        if (buf[0] == '[') {\n            ctx->current_section = -1;\n            break;\n        }\n        if (buf[0] == ';' || (buf[0] == '!' && buf[1] == ':')) {\n            /* skip comments */\n        } else if (section->format_header && !order) {\n            len = strlen(section->format_header);\n            if (strncmp(buf, section->format_header, len) || buf[len] != ':')\n                return NULL;\n            buf += len + 1;\n            while (!is_eol(*buf)) {\n                buf = skip_space(buf);\n                len = strcspn(buf, \", \\r\\n\");\n                if (!(tmp = av_realloc(order, (*number + 1) * sizeof(*order))))\n                    return NULL;\n                order = tmp;\n                order[*number] = -1;\n                for (i=0; section->fields[i].name; i++)\n                    if (!strncmp(buf, section->fields[i].name, len)) {\n                        order[*number] = i;\n                        break;\n                    }\n                (*number)++;\n                buf = skip_space(buf + len + (buf[len] == ','));\n            }\n            ctx->field_order[ctx->current_section] = order;\n        } else if (section->fields_header) {\n            len = strlen(section->fields_header);\n            if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') {\n                uint8_t *ptr, *struct_ptr = realloc_section_array(ctx);\n                if (!struct_ptr)  return NULL;\n                buf += len + 1;\n                for (i=0; !is_eol(*buf) && i < *number; i++) {\n                    int last = i == *number - 1;\n                    buf = skip_space(buf);\n                    len = strcspn(buf, last ? \"\\r\\n\" : \",\\r\\n\");\n                    if (order[i] >= 0) {\n                        ASSFieldType type = section->fields[order[i]].type;\n                        ptr = struct_ptr + section->fields[order[i]].offset;\n                        convert_func[type](ptr, buf, len);\n                    }\n                    buf = skip_space(buf + len + !last);\n                }\n            }\n        } else {\n            len = strcspn(buf, \":\\r\\n\");\n            if (buf[len] == ':') {\n                for (i=0; section->fields[i].name; i++)\n                    if (!strncmp(buf, section->fields[i].name, len)) {\n                        ASSFieldType type = section->fields[i].type;\n                        uint8_t *ptr = (uint8_t *)&ctx->ass + section->offset;\n                        ptr += section->fields[i].offset;\n                        buf = skip_space(buf + len + 1);\n                        convert_func[type](ptr, buf, strcspn(buf, \"\\r\\n\"));\n                        break;\n                    }\n            }\n        }\n        buf += strcspn(buf, \"\\n\");\n        buf += !!*buf;\n    }\n    return buf;\n}", "before_change_lines": [68], "raw_before_change_lines": [68], "after_change_lines": [68, 69], "raw_after_change_lines": [68, 69], "bug_lines": [68], "added": [false], "idx": 88}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "1225----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_425e74354b72b06df00443c1941054479671797b_1.json----avcodec_open2", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_425e74354b72b06df00443c1941054479671797b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_425e74354b72b06df00443c1941054479671797b_1.json", "function_name": "avcodec_open2", "vul_func_code": "int attribute_align_arg avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    AVDictionary *tmp = NULL;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2().\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n               \"but %s passed to avcodec_open2().\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    /* If there is a user-supplied mutex locking routine, call it. */\n    if (ff_lockmgr_cb) {\n        if ((*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n            return -1;\n    }\n\n    entangled_thread_counter++;\n    if(entangled_thread_counter != 1){\n        av_log(avctx, AV_LOG_ERROR, \"insufficient thread locking around avcodec_open/close()\\n\");\n        ret = -1;\n        goto end;\n    }\n\n    avctx->internal = av_mallocz(sizeof(AVCodecInternal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    if (codec->priv_data_size > 0) {\n      if(!avctx->priv_data){\n        avctx->priv_data = av_mallocz(codec->priv_data_size);\n        if (!avctx->priv_data) {\n            ret = AVERROR(ENOMEM);\n            goto end;\n        }\n        if (codec->priv_class) {\n            *(const AVClass**)avctx->priv_data= codec->priv_class;\n            av_opt_set_defaults(avctx->priv_data);\n        }\n      }\n      if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n          goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (codec->capabilities & CODEC_CAP_EXPERIMENTAL)\n        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n            av_log(avctx, AV_LOG_ERROR, \"Codec is experimental but experimental codecs are not enabled, try -strict -2\\n\");\n            ret = -1;\n            goto free_and_end;\n        }\n\n    //We only call avcodec_set_dimensions() for non h264 codecs so as not to overwrite previously setup dimensions\n    if(!( avctx->coded_width && avctx->coded_height && avctx->width && avctx->height && avctx->codec_id == CODEC_ID_H264)){\n    if(avctx->coded_width && avctx->coded_height)\n        avcodec_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if(avctx->width && avctx->height)\n        avcodec_set_dimensions(avctx, avctx->width, avctx->height);\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx) < 0\n           || av_image_check_size(avctx->width,       avctx->height,       0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"ignoring invalid width/height values\\n\");\n        avcodec_set_dimensions(avctx, 0, 0);\n    }\n\n    /* if the decoder init function was already called previously,\n       free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n#define SANE_NB_CHANNELS 128U\n    if (avctx->channels > SANE_NB_CHANNELS) {\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                           && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    if (HAVE_THREADS && !avctx->thread_opaque) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++)\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample_fmt is not supported.\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == PIX_FMT_NONE\n                && !((avctx->codec_id == CODEC_ID_MJPEG || avctx->codec_id == CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified pix_fmt is not supported\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample_rate is not supported\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"channel_layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel_layout is not supported\\n\");\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            if (av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) {\n                av_log(avctx, AV_LOG_ERROR, \"channel layout does not match number of channels\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if(avctx->codec->init && !(avctx->active_thread_type&FF_THREAD_FRAME)){\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout &&\n            av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) {\n            av_log(avctx, AV_LOG_WARNING, \"channel layout does not match number of channels\\n\");\n            avctx->channel_layout = 0;\n        }\n    }\nend:\n    entangled_thread_counter--;\n\n    /* Release any user-supplied mutex. */\n    if (ff_lockmgr_cb) {\n        (*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_RELEASE);\n    }\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    av_freep(&avctx->internal);\n    avctx->codec= NULL;\n    goto end;\n}", "patch_func_code": "int attribute_align_arg avcodec_open2(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)\n{\n    int ret = 0;\n    AVDictionary *tmp = NULL;\n\n    if (avcodec_is_open(avctx))\n        return 0;\n\n    if ((!codec && !avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"No codec provided to avcodec_open2().\\n\");\n        return AVERROR(EINVAL);\n    }\n    if ((codec && avctx->codec && codec != avctx->codec)) {\n        av_log(avctx, AV_LOG_ERROR, \"This AVCodecContext was allocated for %s, \"\n               \"but %s passed to avcodec_open2().\\n\", avctx->codec->name, codec->name);\n        return AVERROR(EINVAL);\n    }\n    if (!codec)\n        codec = avctx->codec;\n\n    if (avctx->extradata_size < 0 || avctx->extradata_size >= FF_MAX_EXTRADATA_SIZE)\n        return AVERROR(EINVAL);\n\n    if (options)\n        av_dict_copy(&tmp, *options, 0);\n\n    /* If there is a user-supplied mutex locking routine, call it. */\n    if (ff_lockmgr_cb) {\n        if ((*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_OBTAIN))\n            return -1;\n    }\n\n    entangled_thread_counter++;\n    if(entangled_thread_counter != 1){\n        av_log(avctx, AV_LOG_ERROR, \"insufficient thread locking around avcodec_open/close()\\n\");\n        ret = -1;\n        goto end;\n    }\n\n    avctx->internal = av_mallocz(sizeof(AVCodecInternal));\n    if (!avctx->internal) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n\n    if (codec->priv_data_size > 0) {\n      if(!avctx->priv_data){\n        avctx->priv_data = av_mallocz(codec->priv_data_size);\n        if (!avctx->priv_data) {\n            ret = AVERROR(ENOMEM);\n            goto end;\n        }\n        if (codec->priv_class) {\n            *(const AVClass**)avctx->priv_data= codec->priv_class;\n            av_opt_set_defaults(avctx->priv_data);\n        }\n      }\n      if (codec->priv_class && (ret = av_opt_set_dict(avctx->priv_data, &tmp)) < 0)\n          goto free_and_end;\n    } else {\n        avctx->priv_data = NULL;\n    }\n    if ((ret = av_opt_set_dict(avctx, &tmp)) < 0)\n        goto free_and_end;\n\n    if (codec->capabilities & CODEC_CAP_EXPERIMENTAL)\n        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n            av_log(avctx, AV_LOG_ERROR, \"Codec is experimental but experimental codecs are not enabled, try -strict -2\\n\");\n            ret = -1;\n            goto free_and_end;\n        }\n\n    //We only call avcodec_set_dimensions() for non h264 codecs so as not to overwrite previously setup dimensions\n    if(!( avctx->coded_width && avctx->coded_height && avctx->width && avctx->height && avctx->codec_id == CODEC_ID_H264)){\n    if(avctx->coded_width && avctx->coded_height)\n        avcodec_set_dimensions(avctx, avctx->coded_width, avctx->coded_height);\n    else if(avctx->width && avctx->height)\n        avcodec_set_dimensions(avctx, avctx->width, avctx->height);\n    }\n\n    if ((avctx->coded_width || avctx->coded_height || avctx->width || avctx->height)\n        && (  av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx) < 0\n           || av_image_check_size(avctx->width,       avctx->height,       0, avctx) < 0)) {\n        av_log(avctx, AV_LOG_WARNING, \"ignoring invalid width/height values\\n\");\n        avcodec_set_dimensions(avctx, 0, 0);\n    }\n\n    /* if the decoder init function was already called previously,\n       free the already allocated subtitle_header before overwriting it */\n    if (av_codec_is_decoder(codec))\n        av_freep(&avctx->subtitle_header);\n\n#define SANE_NB_CHANNELS 128U\n    if (avctx->channels > SANE_NB_CHANNELS) {\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    avctx->codec = codec;\n    if ((avctx->codec_type == AVMEDIA_TYPE_UNKNOWN || avctx->codec_type == codec->type) &&\n        avctx->codec_id == CODEC_ID_NONE) {\n        avctx->codec_type = codec->type;\n        avctx->codec_id   = codec->id;\n    }\n    if (avctx->codec_id != codec->id || (avctx->codec_type != codec->type\n                           && avctx->codec_type != AVMEDIA_TYPE_ATTACHMENT)) {\n        av_log(avctx, AV_LOG_ERROR, \"codec type or id mismatches\\n\");\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n    avctx->frame_number = 0;\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO &&\n        (!avctx->time_base.num || !avctx->time_base.den)) {\n        avctx->time_base.num = 1;\n        avctx->time_base.den = avctx->sample_rate;\n    }\n\n    if (!HAVE_THREADS)\n        av_log(avctx, AV_LOG_WARNING, \"Warning: not compiled with thread support, using thread emulation\\n\");\n\n    entangled_thread_counter--; //we will instanciate a few encoders thus kick the counter to prevent false detection of a problem\n    ret = ff_frame_thread_encoder_init(avctx);\n    entangled_thread_counter++;\n    if (ret < 0)\n        goto free_and_end;\n\n    if (HAVE_THREADS && !avctx->thread_opaque\n        && !(avctx->internal->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {\n        ret = ff_thread_init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n    if (!HAVE_THREADS && !(codec->capabilities & CODEC_CAP_AUTO_THREADS))\n        avctx->thread_count = 1;\n\n    if (avctx->codec->max_lowres < avctx->lowres || avctx->lowres < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"The maximum value for lowres supported by the decoder is %d\\n\",\n               avctx->codec->max_lowres);\n        ret = AVERROR(EINVAL);\n        goto free_and_end;\n    }\n\n    if (av_codec_is_encoder(avctx->codec)) {\n        int i;\n        if (avctx->codec->sample_fmts) {\n            for (i = 0; avctx->codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++)\n                if (avctx->sample_fmt == avctx->codec->sample_fmts[i])\n                    break;\n            if (avctx->codec->sample_fmts[i] == AV_SAMPLE_FMT_NONE) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample_fmt is not supported.\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->pix_fmts) {\n            for (i = 0; avctx->codec->pix_fmts[i] != PIX_FMT_NONE; i++)\n                if (avctx->pix_fmt == avctx->codec->pix_fmts[i])\n                    break;\n            if (avctx->codec->pix_fmts[i] == PIX_FMT_NONE\n                && !((avctx->codec_id == CODEC_ID_MJPEG || avctx->codec_id == CODEC_ID_LJPEG)\n                     && avctx->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL)) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified pix_fmt is not supported\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->supported_samplerates) {\n            for (i = 0; avctx->codec->supported_samplerates[i] != 0; i++)\n                if (avctx->sample_rate == avctx->codec->supported_samplerates[i])\n                    break;\n            if (avctx->codec->supported_samplerates[i] == 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Specified sample_rate is not supported\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        }\n        if (avctx->codec->channel_layouts) {\n            if (!avctx->channel_layout) {\n                av_log(avctx, AV_LOG_WARNING, \"channel_layout not specified\\n\");\n            } else {\n                for (i = 0; avctx->codec->channel_layouts[i] != 0; i++)\n                    if (avctx->channel_layout == avctx->codec->channel_layouts[i])\n                        break;\n                if (avctx->codec->channel_layouts[i] == 0) {\n                    av_log(avctx, AV_LOG_ERROR, \"Specified channel_layout is not supported\\n\");\n                    ret = AVERROR(EINVAL);\n                    goto free_and_end;\n                }\n            }\n        }\n        if (avctx->channel_layout && avctx->channels) {\n            if (av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) {\n                av_log(avctx, AV_LOG_ERROR, \"channel layout does not match number of channels\\n\");\n                ret = AVERROR(EINVAL);\n                goto free_and_end;\n            }\n        } else if (avctx->channel_layout) {\n            avctx->channels = av_get_channel_layout_nb_channels(avctx->channel_layout);\n        }\n    }\n\n    avctx->pts_correction_num_faulty_pts =\n    avctx->pts_correction_num_faulty_dts = 0;\n    avctx->pts_correction_last_pts =\n    avctx->pts_correction_last_dts = INT64_MIN;\n\n    if(avctx->codec->init && (!(avctx->active_thread_type&FF_THREAD_FRAME) || avctx->internal->frame_thread_encoder)){\n        ret = avctx->codec->init(avctx);\n        if (ret < 0) {\n            goto free_and_end;\n        }\n    }\n\n    ret=0;\n\n    if (av_codec_is_decoder(avctx->codec)) {\n        if (!avctx->bit_rate)\n            avctx->bit_rate = get_bit_rate(avctx);\n        /* validate channel layout from the decoder */\n        if (avctx->channel_layout &&\n            av_get_channel_layout_nb_channels(avctx->channel_layout) != avctx->channels) {\n            av_log(avctx, AV_LOG_WARNING, \"channel layout does not match number of channels\\n\");\n            avctx->channel_layout = 0;\n        }\n    }\nend:\n    entangled_thread_counter--;\n\n    /* Release any user-supplied mutex. */\n    if (ff_lockmgr_cb) {\n        (*ff_lockmgr_cb)(&codec_mutex, AV_LOCK_RELEASE);\n    }\n    if (options) {\n        av_dict_free(options);\n        *options = tmp;\n    }\n\n    return ret;\nfree_and_end:\n    av_dict_free(&tmp);\n    av_freep(&avctx->priv_data);\n    av_freep(&avctx->internal);\n    avctx->codec= NULL;\n    goto end;\n}", "before_change_lines": [122, 202], "raw_before_change_lines": [122, 202], "after_change_lines": [122, 123, 124, 125, 126, 128, 129, 209], "raw_after_change_lines": [122, 123, 124, 125, 126, 127, 128, 129, 209], "bug_lines": [122, 202], "added": [false, false], "idx": 89}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1226----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_426b81c52b59bf79f63473f1037049a77f706154_1.json----dequantize_slice_buffered", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_426b81c52b59bf79f63473f1037049a77f706154_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_426b81c52b59bf79f63473f1037049a77f706154_1.json", "function_name": "dequantize_slice_buffered", "vul_func_code": "static void dequantize_slice_buffered(SnowContext *s, slice_buffer * sb, SubBand *b, IDWTELEM *src, int stride, int start_y, int end_y){\n    const int w= b->width;\n    const int qlog= av_clip(s->qlog + b->qlog, 0, QROOT*16);\n    const int qmul= ff_qexp[qlog&(QROOT-1)]<<(qlog>>QSHIFT);\n    const int qadd= (s->qbias*qmul)>>QBIAS_SHIFT;\n    int x,y;\n\n    if(s->qlog == LOSSLESS_QLOG) return;\n\n    for(y=start_y; y<end_y; y++){\n//        DWTELEM * line = slice_buffer_get_line_from_address(sb, src + (y * stride));\n        IDWTELEM * line = slice_buffer_get_line(sb, (y * b->stride_line) + b->buf_y_offset) + b->buf_x_offset;\n        for(x=0; x<w; x++){\n            int i= line[x];\n            if(i<0){\n                line[x]= -((-i*qmul + qadd)>>(QEXPSHIFT)); //FIXME try different bias\n            }else if(i>0){\n                line[x]=  (( i*qmul + qadd)>>(QEXPSHIFT));\n            }\n        }\n    }\n}", "patch_func_code": "static void dequantize_slice_buffered(SnowContext *s, slice_buffer * sb, SubBand *b, IDWTELEM *src, int stride, int start_y, int end_y){\n    const int w= b->width;\n    const int qlog= av_clip(s->qlog + b->qlog, 0, QROOT*16);\n    const int qmul= ff_qexp[qlog&(QROOT-1)]<<(qlog>>QSHIFT);\n    const int qadd= (s->qbias*qmul)>>QBIAS_SHIFT;\n    int x,y;\n\n    if(s->qlog == LOSSLESS_QLOG) return;\n\n    for(y=start_y; y<end_y; y++){\n//        DWTELEM * line = slice_buffer_get_line_from_address(sb, src + (y * stride));\n        IDWTELEM * line = slice_buffer_get_line(sb, (y * b->stride_line) + b->buf_y_offset) + b->buf_x_offset;\n        for(x=0; x<w; x++){\n            int i= line[x];\n            if(i<0){\n                line[x]= -((-i*(unsigned)qmul + qadd)>>(QEXPSHIFT)); //FIXME try different bias\n            }else if(i>0){\n                line[x]=  (( i*(unsigned)qmul + qadd)>>(QEXPSHIFT));\n            }\n        }\n    }\n}", "before_change_lines": [16, 18], "raw_before_change_lines": [16, 18], "after_change_lines": [16, 18], "raw_after_change_lines": [16, 18], "bug_lines": [16, 18], "added": [false, false], "idx": 90}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1245----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4337de1e16c8b331497fd1bfc860e2c4d3fed071_1.json----decode_hq_slice", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4337de1e16c8b331497fd1bfc860e2c4d3fed071_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4337de1e16c8b331497fd1bfc860e2c4d3fed071_1.json", "function_name": "decode_hq_slice", "vul_func_code": "static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)\n{\n    int i, level, orientation, quant_idx;\n    int qfactor[MAX_DWT_LEVELS][4], qoffset[MAX_DWT_LEVELS][4];\n    GetBitContext *gb = &slice->gb;\n    SliceCoeffs coeffs_num[MAX_DWT_LEVELS];\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n    quant_idx = get_bits(gb, 8);\n\n    if (quant_idx > DIRAC_MAX_QUANT_INDEX) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid quantization index - %i\\n\", quant_idx);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n    for (level = 0; level < s->wavelet_depth; level++) {\n        for (orientation = !!level; orientation < 4; orientation++) {\n            const int quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n            qfactor[level][orientation] = ff_dirac_qscale_tab[quant];\n            qoffset[level][orientation] = ff_dirac_qoffset_intra_tab[quant] + 2;\n        }\n    }\n\n    /* Luma + 2 Chroma planes */\n    for (i = 0; i < 3; i++) {\n        int coef_num, coef_par, off = 0;\n        int64_t length = s->highquality.size_scaler*get_bits(gb, 8);\n        int64_t bits_end = get_bits_count(gb) + 8*length;\n        const uint8_t *addr = align_get_bits(gb);\n\n        if (length*8 > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        coef_num = subband_coeffs(s, slice->slice_x, slice->slice_y, i, coeffs_num);\n\n        if (s->pshift)\n            coef_par = ff_dirac_golomb_read_32bit(s->reader_ctx, addr,\n                                                  length, tmp_buf, coef_num);\n        else\n            coef_par = ff_dirac_golomb_read_16bit(s->reader_ctx, addr,\n                                                  length, tmp_buf, coef_num);\n\n        if (coef_num > coef_par) {\n            const int start_b = coef_par * (1 << (s->pshift + 1));\n            const int end_b   = coef_num * (1 << (s->pshift + 1));\n            memset(&tmp_buf[start_b], 0, end_b - start_b);\n        }\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n            const SliceCoeffs *c = &coeffs_num[level];\n            for (orientation = !!level; orientation < 4; orientation++) {\n                const SubBand *b1 = &s->plane[i].band[level][orientation];\n                uint8_t *buf = b1->ibuf + c->top * b1->stride + (c->left << (s->pshift + 1));\n\n                /* Change to c->tot_h <= 4 for AVX2 dequantization */\n                const int qfunc = s->pshift + 2*(c->tot_h <= 2);\n                s->diracdsp.dequant_subband[qfunc](&tmp_buf[off], buf, b1->stride,\n                                                   qfactor[level][orientation],\n                                                   qoffset[level][orientation],\n                                                   c->tot_v, c->tot_h);\n\n                off += c->tot << (s->pshift + 1);\n            }\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n    }\n\n    return 0;\n}", "patch_func_code": "static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)\n{\n    int i, level, orientation, quant_idx;\n    int qfactor[MAX_DWT_LEVELS][4], qoffset[MAX_DWT_LEVELS][4];\n    GetBitContext *gb = &slice->gb;\n    SliceCoeffs coeffs_num[MAX_DWT_LEVELS];\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n    quant_idx = get_bits(gb, 8);\n\n    if (quant_idx > DIRAC_MAX_QUANT_INDEX - 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid quantization index - %i\\n\", quant_idx);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n    for (level = 0; level < s->wavelet_depth; level++) {\n        for (orientation = !!level; orientation < 4; orientation++) {\n            const int quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n            qfactor[level][orientation] = ff_dirac_qscale_tab[quant];\n            qoffset[level][orientation] = ff_dirac_qoffset_intra_tab[quant] + 2;\n        }\n    }\n\n    /* Luma + 2 Chroma planes */\n    for (i = 0; i < 3; i++) {\n        int coef_num, coef_par, off = 0;\n        int64_t length = s->highquality.size_scaler*get_bits(gb, 8);\n        int64_t bits_end = get_bits_count(gb) + 8*length;\n        const uint8_t *addr = align_get_bits(gb);\n\n        if (length*8 > get_bits_left(gb)) {\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        coef_num = subband_coeffs(s, slice->slice_x, slice->slice_y, i, coeffs_num);\n\n        if (s->pshift)\n            coef_par = ff_dirac_golomb_read_32bit(s->reader_ctx, addr,\n                                                  length, tmp_buf, coef_num);\n        else\n            coef_par = ff_dirac_golomb_read_16bit(s->reader_ctx, addr,\n                                                  length, tmp_buf, coef_num);\n\n        if (coef_num > coef_par) {\n            const int start_b = coef_par * (1 << (s->pshift + 1));\n            const int end_b   = coef_num * (1 << (s->pshift + 1));\n            memset(&tmp_buf[start_b], 0, end_b - start_b);\n        }\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n            const SliceCoeffs *c = &coeffs_num[level];\n            for (orientation = !!level; orientation < 4; orientation++) {\n                const SubBand *b1 = &s->plane[i].band[level][orientation];\n                uint8_t *buf = b1->ibuf + c->top * b1->stride + (c->left << (s->pshift + 1));\n\n                /* Change to c->tot_h <= 4 for AVX2 dequantization */\n                const int qfunc = s->pshift + 2*(c->tot_h <= 2);\n                s->diracdsp.dequant_subband[qfunc](&tmp_buf[off], buf, b1->stride,\n                                                   qfactor[level][orientation],\n                                                   qoffset[level][orientation],\n                                                   c->tot_v, c->tot_h);\n\n                off += c->tot << (s->pshift + 1);\n            }\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n    }\n\n    return 0;\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [11], "added": [false], "idx": 91}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "1248----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_437bdd486a45c19a4edef898d70419aebd227188_1.json----cookie_string", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_437bdd486a45c19a4edef898d70419aebd227188_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_437bdd486a45c19a4edef898d70419aebd227188_1.json", "function_name": "cookie_string", "vul_func_code": "static int cookie_string(AVDictionary *dict, char **cookies)\n{\n    AVDictionaryEntry *e = NULL;\n    int len = 1;\n\n    // determine how much memory is needed for the cookies string\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n    // reallocate the cookies\n    e = NULL;\n    if (*cookies) av_free(*cookies);\n    *cookies = av_malloc(len);\n    if (!cookies) return AVERROR(ENOMEM);\n    *cookies[0] = '\\0';\n\n    // write out the cookies\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n    return 0;\n}", "patch_func_code": "static int cookie_string(AVDictionary *dict, char **cookies)\n{\n    AVDictionaryEntry *e = NULL;\n    int len = 1;\n\n    // determine how much memory is needed for the cookies string\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n    // reallocate the cookies\n    e = NULL;\n    if (*cookies) av_free(*cookies);\n    *cookies = av_malloc(len);\n    if (!*cookies) return AVERROR(ENOMEM);\n    *cookies[0] = '\\0';\n\n    // write out the cookies\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n    return 0;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [14], "raw_after_change_lines": [14], "bug_lines": [14], "added": [false], "idx": 92}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "1260----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_440078157d08ceedc22e95f8adc752b88ef1ccd4_1.json----do_subtitle_out", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_440078157d08ceedc22e95f8adc752b88ef1ccd4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_440078157d08ceedc22e95f8adc752b88ef1ccd4_1.json", "function_name": "do_subtitle_out", "vul_func_code": "static void do_subtitle_out(AVFormatContext *s,\n                            OutputStream *ost,\n                            InputStream *ist,\n                            AVSubtitle *sub)\n{\n    int subtitle_out_max_size = 1024 * 1024;\n    int subtitle_out_size, nb, i;\n    AVCodecContext *enc;\n    AVPacket pkt;\n    int64_t pts;\n\n    if (sub->pts == AV_NOPTS_VALUE) {\n        av_log(NULL, AV_LOG_ERROR, \"Subtitle packets must have a pts\\n\");\n        if (exit_on_error)\n            exit_program(1);\n        return;\n    }\n\n    enc = ost->enc_ctx;\n\n    if (!subtitle_out) {\n        subtitle_out = av_malloc(subtitle_out_max_size);\n        if (!subtitle_out) {\n            av_log(NULL, AV_LOG_FATAL, \"Failed to allocate subtitle_out\\n\");\n            exit_program(1);\n        }\n    }\n\n    /* Note: DVB subtitle need one packet to draw them and one other\n       packet to clear them */\n    /* XXX: signal it in the codec context ? */\n    if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE)\n        nb = 2;\n    else\n        nb = 1;\n\n    /* shift timestamp to honor -ss and make check_recording_time() work with -t */\n    pts = sub->pts;\n    if (output_files[ost->file_index]->start_time != AV_NOPTS_VALUE)\n        pts -= output_files[ost->file_index]->start_time;\n    for (i = 0; i < nb; i++) {\n        unsigned save_num_rects = sub->num_rects;\n\n        ost->sync_opts = av_rescale_q(pts, AV_TIME_BASE_Q, enc->time_base);\n        if (!check_recording_time(ost))\n            return;\n\n        sub->pts = pts;\n        // start_display_time is required to be 0\n        sub->pts               += av_rescale_q(sub->start_display_time, (AVRational){ 1, 1000 }, AV_TIME_BASE_Q);\n        sub->end_display_time  -= sub->start_display_time;\n        sub->start_display_time = 0;\n        if (i == 1)\n            sub->num_rects = 0;\n\n        ost->frames_encoded++;\n\n        subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out,\n                                                    subtitle_out_max_size, sub);\n        if (i == 1)\n            sub->num_rects = save_num_rects;\n        if (subtitle_out_size < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Subtitle encoding failed\\n\");\n            exit_program(1);\n        }\n\n        av_init_packet(&pkt);\n        pkt.data = subtitle_out;\n        pkt.size = subtitle_out_size;\n        pkt.pts  = av_rescale_q(sub->pts, AV_TIME_BASE_Q, ost->st->time_base);\n        pkt.duration = av_rescale_q(sub->end_display_time, (AVRational){ 1, 1000 }, ost->st->time_base);\n        if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n            /* XXX: the pts correction is handled here. Maybe handling\n               it in the codec would be better */\n            if (i == 0)\n                pkt.pts += 90 * sub->start_display_time;\n            else\n                pkt.pts += 90 * sub->end_display_time;\n        }\n        pkt.dts = pkt.pts;\n        write_frame(s, &pkt, ost);\n    }\n}", "patch_func_code": "static void do_subtitle_out(AVFormatContext *s,\n                            OutputStream *ost,\n                            InputStream *ist,\n                            AVSubtitle *sub)\n{\n    int subtitle_out_max_size = 1024 * 1024;\n    int subtitle_out_size, nb, i;\n    AVCodecContext *enc;\n    AVPacket pkt;\n    int64_t pts;\n\n    if (sub->pts == AV_NOPTS_VALUE) {\n        av_log(NULL, AV_LOG_ERROR, \"Subtitle packets must have a pts\\n\");\n        if (exit_on_error)\n            exit_program(1);\n        return;\n    }\n\n    enc = ost->enc_ctx;\n\n    if (!subtitle_out) {\n        subtitle_out = av_malloc(subtitle_out_max_size);\n        if (!subtitle_out) {\n            av_log(NULL, AV_LOG_FATAL, \"Failed to allocate subtitle_out\\n\");\n            exit_program(1);\n        }\n    }\n\n    /* Note: DVB subtitle need one packet to draw them and one other\n       packet to clear them */\n    /* XXX: signal it in the codec context ? */\n    if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE)\n        nb = 2;\n    else\n        nb = 1;\n\n    /* shift timestamp to honor -ss and make check_recording_time() work with -t */\n    pts = sub->pts;\n    if (output_files[ost->file_index]->start_time != AV_NOPTS_VALUE)\n        pts -= output_files[ost->file_index]->start_time;\n    for (i = 0; i < nb; i++) {\n        unsigned save_num_rects = sub->num_rects;\n\n        ost->sync_opts = av_rescale_q(pts, AV_TIME_BASE_Q, enc->time_base);\n        if (!check_recording_time(ost))\n            return;\n\n        sub->pts = pts;\n        // start_display_time is required to be 0\n        sub->pts               += av_rescale_q(sub->start_display_time, (AVRational){ 1, 1000 }, AV_TIME_BASE_Q);\n        sub->end_display_time  -= sub->start_display_time;\n        sub->start_display_time = 0;\n        if (i == 1)\n            sub->num_rects = 0;\n\n        ost->frames_encoded++;\n\n        subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out,\n                                                    subtitle_out_max_size, sub);\n        if (i == 1)\n            sub->num_rects = save_num_rects;\n        if (subtitle_out_size < 0) {\n            av_log(NULL, AV_LOG_FATAL, \"Subtitle encoding failed\\n\");\n            exit_program(1);\n        }\n\n        av_init_packet(&pkt);\n        pkt.data = subtitle_out;\n        pkt.size = subtitle_out_size;\n        pkt.pts  = av_rescale_q(sub->pts, AV_TIME_BASE_Q, ost->st->time_base);\n        pkt.duration = av_rescale_q(sub->end_display_time, (AVRational){ 1, 1000 }, ost->st->time_base);\n        if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n            /* XXX: the pts correction is handled here. Maybe handling\n               it in the codec would be better */\n            if (i == 0)\n                pkt.pts += 90 * sub->start_display_time;\n            else\n                pkt.pts += 90 * sub->end_display_time;\n        }\n        pkt.dts = pkt.pts;\n        output_packet(s, &pkt, ost);\n    }\n}", "before_change_lines": [81], "raw_before_change_lines": [81], "after_change_lines": [81], "raw_after_change_lines": [81], "bug_lines": [81], "added": [false], "idx": 93}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1264----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_44529b2c3ad01420eaef34997e0264969b24e5bf_1.json----tta_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_44529b2c3ad01420eaef34997e0264969b24e5bf_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_44529b2c3ad01420eaef34997e0264969b24e5bf_1.json", "function_name": "tta_decode_frame", "vul_func_code": "static int tta_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TTAContext *s = avctx->priv_data;\n    int i;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n    {\n        int cur_chan = 0, framelen = s->frame_length;\n        int32_t *p;\n\n        if (*data_size < (framelen * s->channels * 2)) {\n            av_log(avctx, AV_LOG_ERROR, \"Output buffer size is too small.\\n\");\n            return -1;\n        }\n        // FIXME: seeking\n        s->total_frames--;\n        if (!s->total_frames && s->last_frame_length)\n            framelen = s->last_frame_length;\n\n        // init per channel states\n        for (i = 0; i < s->channels; i++) {\n            s->ch_ctx[i].predictor = 0;\n            ttafilter_init(&s->ch_ctx[i].filter, ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]);\n            rice_init(&s->ch_ctx[i].rice, 10, 10);\n        }\n\n        for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n            int32_t *predictor = &s->ch_ctx[cur_chan].predictor;\n            TTAFilter *filter = &s->ch_ctx[cur_chan].filter;\n            TTARice *rice = &s->ch_ctx[cur_chan].rice;\n            uint32_t unary, depth, k;\n            int32_t value;\n\n            unary = tta_get_unary(&s->gb);\n\n            if (unary == 0) {\n                depth = 0;\n                k = rice->k0;\n            } else {\n                depth = 1;\n                k = rice->k1;\n                unary--;\n            }\n\n            if (get_bits_left(&s->gb) < k)\n                return -1;\n\n            if (k) {\n                if (k > MIN_CACHE_BITS)\n                    return -1;\n                value = (unary << k) + get_bits(&s->gb, k);\n            } else\n                value = unary;\n\n            // FIXME: copy paste from original\n            switch (depth) {\n            case 1:\n                rice->sum1 += value - (rice->sum1 >> 4);\n                if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1])\n                    rice->k1--;\n                else if(rice->sum1 > shift_16[rice->k1 + 1])\n                    rice->k1++;\n                value += shift_1[rice->k0];\n            default:\n                rice->sum0 += value - (rice->sum0 >> 4);\n                if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0])\n                    rice->k0--;\n                else if(rice->sum0 > shift_16[rice->k0 + 1])\n                    rice->k0++;\n            }\n\n            // extract coded value\n#define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1))\n            *p = UNFOLD(value);\n\n            // run hybrid filter\n            ttafilter_process(filter, p, 0);\n\n            // fixed order prediction\n#define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k)\n            switch (s->bps) {\n                case 1: *p += PRED(*predictor, 4); break;\n                case 2:\n                case 3: *p += PRED(*predictor, 5); break;\n                case 4: *p += *predictor; break;\n            }\n            *predictor = *p;\n\n            // flip channels\n            if (cur_chan < (s->channels-1))\n                cur_chan++;\n            else {\n                // decorrelate in case of stereo integer\n                if (s->channels > 1) {\n                    int32_t *r = p - 1;\n                    for (*p += *r / 2; r > p - s->channels; r--)\n                        *r = *(r + 1) - *r;\n                }\n                cur_chan = 0;\n            }\n        }\n\n        if (get_bits_left(&s->gb) < 32)\n            return -1;\n        skip_bits(&s->gb, 32); // frame crc\n\n        // convert to output buffer\n        switch(s->bps) {\n            case 2: {\n                uint16_t *samples = data;\n                for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n                    *samples++ = *p;\n                }\n                *data_size = (uint8_t *)samples - (uint8_t *)data;\n                break;\n            }\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"Error, only 16bit samples supported!\\n\");\n        }\n    }\n\n    return buf_size;\n}", "patch_func_code": "static int tta_decode_frame(AVCodecContext *avctx,\n        void *data, int *data_size,\n        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    TTAContext *s = avctx->priv_data;\n    int i;\n\n    init_get_bits(&s->gb, buf, buf_size*8);\n    {\n        int cur_chan = 0, framelen = s->frame_length;\n        int32_t *p;\n\n        // FIXME: seeking\n        s->total_frames--;\n        if (!s->total_frames && s->last_frame_length)\n            framelen = s->last_frame_length;\n\n        if (*data_size < (framelen * s->channels * 2)) {\n            av_log(avctx, AV_LOG_ERROR, \"Output buffer size is too small.\\n\");\n            return -1;\n        }\n\n        // init per channel states\n        for (i = 0; i < s->channels; i++) {\n            s->ch_ctx[i].predictor = 0;\n            ttafilter_init(&s->ch_ctx[i].filter, ttafilter_configs[s->bps-1][0], ttafilter_configs[s->bps-1][1]);\n            rice_init(&s->ch_ctx[i].rice, 10, 10);\n        }\n\n        for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n            int32_t *predictor = &s->ch_ctx[cur_chan].predictor;\n            TTAFilter *filter = &s->ch_ctx[cur_chan].filter;\n            TTARice *rice = &s->ch_ctx[cur_chan].rice;\n            uint32_t unary, depth, k;\n            int32_t value;\n\n            unary = tta_get_unary(&s->gb);\n\n            if (unary == 0) {\n                depth = 0;\n                k = rice->k0;\n            } else {\n                depth = 1;\n                k = rice->k1;\n                unary--;\n            }\n\n            if (get_bits_left(&s->gb) < k)\n                return -1;\n\n            if (k) {\n                if (k > MIN_CACHE_BITS)\n                    return -1;\n                value = (unary << k) + get_bits(&s->gb, k);\n            } else\n                value = unary;\n\n            // FIXME: copy paste from original\n            switch (depth) {\n            case 1:\n                rice->sum1 += value - (rice->sum1 >> 4);\n                if (rice->k1 > 0 && rice->sum1 < shift_16[rice->k1])\n                    rice->k1--;\n                else if(rice->sum1 > shift_16[rice->k1 + 1])\n                    rice->k1++;\n                value += shift_1[rice->k0];\n            default:\n                rice->sum0 += value - (rice->sum0 >> 4);\n                if (rice->k0 > 0 && rice->sum0 < shift_16[rice->k0])\n                    rice->k0--;\n                else if(rice->sum0 > shift_16[rice->k0 + 1])\n                    rice->k0++;\n            }\n\n            // extract coded value\n#define UNFOLD(x) (((x)&1) ? (++(x)>>1) : (-(x)>>1))\n            *p = UNFOLD(value);\n\n            // run hybrid filter\n            ttafilter_process(filter, p, 0);\n\n            // fixed order prediction\n#define PRED(x, k) (int32_t)((((uint64_t)x << k) - x) >> k)\n            switch (s->bps) {\n                case 1: *p += PRED(*predictor, 4); break;\n                case 2:\n                case 3: *p += PRED(*predictor, 5); break;\n                case 4: *p += *predictor; break;\n            }\n            *predictor = *p;\n\n            // flip channels\n            if (cur_chan < (s->channels-1))\n                cur_chan++;\n            else {\n                // decorrelate in case of stereo integer\n                if (s->channels > 1) {\n                    int32_t *r = p - 1;\n                    for (*p += *r / 2; r > p - s->channels; r--)\n                        *r = *(r + 1) - *r;\n                }\n                cur_chan = 0;\n            }\n        }\n\n        if (get_bits_left(&s->gb) < 32)\n            return -1;\n        skip_bits(&s->gb, 32); // frame crc\n\n        // convert to output buffer\n        switch(s->bps) {\n            case 2: {\n                uint16_t *samples = data;\n                for (p = s->decode_buffer; p < s->decode_buffer + (framelen * s->channels); p++) {\n                    *samples++ = *p;\n                }\n                *data_size = (uint8_t *)samples - (uint8_t *)data;\n                break;\n            }\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"Error, only 16bit samples supported!\\n\");\n        }\n    }\n\n    return buf_size;\n}", "before_change_lines": [15, 16, 17, 18], "raw_before_change_lines": [15, 16, 17, 18], "after_change_lines": [20, 21, 22, 23], "raw_after_change_lines": [20, 21, 22, 23, 24], "bug_lines": [15, 16, 17, 18], "added": [false, false, false, false], "idx": 94}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "1265----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4466b5b924d8c259775cf5b76851bb43b21a7461_1.json----dvbsub_display_end_segment", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4466b5b924d8c259775cf5b76851bb43b21a7461_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4466b5b924d8c259775cf5b76851bb43b21a7461_1.json", "function_name": "dvbsub_display_end_segment", "vul_func_code": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n                                        int buf_size, AVSubtitle *sub)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n    DVBSubRegion *region;\n    DVBSubRegionDisplay *display;\n    AVSubtitleRect *rect;\n    DVBSubCLUT *clut;\n    uint32_t *clut_table;\n    int i;\n    int offset_x=0, offset_y=0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    if (display_def) {\n        offset_x = display_def->x;\n        offset_y = display_def->y;\n    }\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects > 0){\n        sub->rects = av_mallocz(sizeof(*sub->rects) * sub->num_rects);\n        for(i=0; i<sub->num_rects; i++)\n            sub->rects[i] = av_mallocz(sizeof(*sub->rects[i]));\n\n    i = 0;\n\n    for (display = ctx->display_list; display; display = display->next) {\n        region = get_region(ctx, display->region_id);\n\n        if (!region)\n            continue;\n\n        if (!region->dirty)\n            continue;\n\n        rect = sub->rects[i];\n        rect->x = display->x_pos + offset_x;\n        rect->y = display->y_pos + offset_y;\n        rect->w = region->width;\n        rect->h = region->height;\n        rect->nb_colors = (1 << region->depth);\n        rect->type      = SUBTITLE_BITMAP;\n        rect->pict.linesize[0] = region->width;\n\n        clut = get_clut(ctx, region->clut);\n\n        if (!clut)\n            clut = &default_clut;\n\n        switch (region->depth) {\n        case 2:\n            clut_table = clut->clut4;\n            break;\n        case 8:\n            clut_table = clut->clut256;\n            break;\n        case 4:\n        default:\n            clut_table = clut->clut16;\n            break;\n        }\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n        i++;\n    }\n\n    sub->num_rects = i;\n    }\n#ifdef DEBUG\n    save_display_set(ctx);\n#endif\n\n    return 1;\n}", "patch_func_code": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n                                        int buf_size, AVSubtitle *sub)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n    DVBSubRegion *region;\n    DVBSubRegionDisplay *display;\n    AVSubtitleRect *rect;\n    DVBSubCLUT *clut;\n    uint32_t *clut_table;\n    int i;\n    int offset_x=0, offset_y=0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    if (display_def) {\n        offset_x = display_def->x;\n        offset_y = display_def->y;\n    }\n\n    sub->num_rects = 0;\n    for (display = ctx->display_list; display; display = display->next)\n    {\n        region = get_region(ctx, display->region_id);\n        if (region && region->dirty)\n            sub->num_rects++;\n    }\n\n    if (sub->num_rects > 0){\n        sub->rects = av_mallocz(sizeof(*sub->rects) * sub->num_rects);\n        for(i=0; i<sub->num_rects; i++)\n            sub->rects[i] = av_mallocz(sizeof(*sub->rects[i]));\n\n    i = 0;\n\n    for (display = ctx->display_list; display; display = display->next) {\n        region = get_region(ctx, display->region_id);\n\n        if (!region)\n            continue;\n\n        if (!region->dirty)\n            continue;\n\n        rect = sub->rects[i];\n        rect->x = display->x_pos + offset_x;\n        rect->y = display->y_pos + offset_y;\n        rect->w = region->width;\n        rect->h = region->height;\n        rect->nb_colors = (1 << region->depth);\n        rect->type      = SUBTITLE_BITMAP;\n        rect->pict.linesize[0] = region->width;\n\n        clut = get_clut(ctx, region->clut);\n\n        if (!clut)\n            clut = &default_clut;\n\n        switch (region->depth) {\n        case 2:\n            clut_table = clut->clut4;\n            break;\n        case 8:\n            clut_table = clut->clut256;\n            break;\n        case 4:\n        default:\n            clut_table = clut->clut16;\n            break;\n        }\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n        i++;\n    }\n    }\n#ifdef DEBUG\n    save_display_set(ctx);\n#endif\n\n    return 1;\n}", "before_change_lines": [22, 76], "raw_before_change_lines": [22, 75, 76], "after_change_lines": [22, 23, 24, 25, 26, 27, 28], "raw_after_change_lines": [22, 23, 24, 25, 26, 27, 28], "bug_lines": [22, 75, 76], "added": [false, false, false], "idx": 95}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1273----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_44cc7d03fd44f5e9fe2532f3f0931328e0802fad_1.json----av_int2dbl", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_44cc7d03fd44f5e9fe2532f3f0931328e0802fad_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_44cc7d03fd44f5e9fe2532f3f0931328e0802fad_1.json", "function_name": "av_int2dbl", "vul_func_code": "double av_int2dbl(int64_t v){\n    if(v+v > 0xFFEULL<<52)\n        return NAN;\n    return ldexp(((v&((1LL<<52)-1)) + (1LL<<52)) * (v>>63|1), (v>>52&0x7FF)-1075);\n}", "patch_func_code": "double av_int2dbl(int64_t v){\n    if((uint64_t)v+v > 0xFFEULL<<52)\n        return NAN;\n    return ldexp(((v&((1LL<<52)-1)) + (1LL<<52)) * (v>>63|1), (v>>52&0x7FF)-1075);\n}", "before_change_lines": [2], "raw_before_change_lines": [2], "after_change_lines": [2], "raw_after_change_lines": [2], "bug_lines": [2], "added": [false], "idx": 96}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "1317----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_481f317ebdad07473d5f94ac05bc9c986685159c_1.json----ff_iir_filter_init_coeffs", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_481f317ebdad07473d5f94ac05bc9c986685159c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_481f317ebdad07473d5f94ac05bc9c986685159c_1.json", "function_name": "ff_iir_filter_init_coeffs", "vul_func_code": "struct FFIIRFilterCoeffs* ff_iir_filter_init_coeffs(enum IIRFilterType filt_type,\n                                                    enum IIRFilterMode filt_mode,\n                                                    int order, float cutoff_ratio,\n                                                    float stopband, float ripple)\n{\n    int i, j;\n    FFIIRFilterCoeffs *c;\n    double wa;\n    double p[MAXORDER + 1][2];\n\n    if(filt_type != FF_FILTER_TYPE_BUTTERWORTH || filt_mode != FF_FILTER_MODE_LOWPASS)\n        return NULL;\n    if(order <= 1 || (order & 1) || order > MAXORDER || cutoff_ratio >= 1.0)\n        return NULL;\n\n    c = av_malloc(sizeof(FFIIRFilterCoeffs));\n    c->cx = av_malloc(sizeof(c->cx[0]) * ((order >> 1) + 1));\n    c->cy = av_malloc(sizeof(c->cy[0]) * order);\n    c->order = order;\n\n    wa = 2 * tan(M_PI * 0.5 * cutoff_ratio);\n\n    c->cx[0] = 1;\n    for(i = 1; i < (order >> 1) + 1; i++)\n        c->cx[i] = c->cx[i - 1] * (order - i + 1LL) / i;\n\n    p[0][0] = 1.0;\n    p[0][1] = 0.0;\n    for(i = 1; i <= order; i++)\n        p[i][0] = p[i][1] = 0.0;\n    for(i = 0; i < order; i++){\n        double zp[2];\n        double th = (i + (order >> 1) + 0.5) * M_PI / order;\n        double a_re, a_im, c_re, c_im;\n        zp[0] = cos(th) * wa;\n        zp[1] = sin(th) * wa;\n        a_re = zp[0] + 2.0;\n        c_re = zp[0] - 2.0;\n        a_im =\n        c_im = zp[1];\n        zp[0] = (a_re * c_re + a_im * c_im) / (c_re * c_re + c_im * c_im);\n        zp[1] = (a_im * c_re - a_re * c_im) / (c_re * c_re + c_im * c_im);\n\n        for(j = order; j >= 1; j--)\n        {\n            a_re = p[j][0];\n            a_im = p[j][1];\n            p[j][0] = a_re*zp[0] - a_im*zp[1] + p[j-1][0];\n            p[j][1] = a_re*zp[1] + a_im*zp[0] + p[j-1][1];\n        }\n        a_re    = p[0][0]*zp[0] - p[0][1]*zp[1];\n        p[0][1] = p[0][0]*zp[1] + p[0][1]*zp[0];\n        p[0][0] = a_re;\n    }\n    c->gain = p[order][0];\n    for(i = 0; i < order; i++){\n        c->gain += p[i][0];\n        c->cy[i] = (-p[i][0] * p[order][0] + -p[i][1] * p[order][1]) /\n                   (p[order][0] * p[order][0] + p[order][1] * p[order][1]);\n    }\n    c->gain /= 1 << order;\n\n    return c;\n}", "patch_func_code": "struct FFIIRFilterCoeffs* ff_iir_filter_init_coeffs(void *avc,\n                                                enum IIRFilterType filt_type,\n                                                    enum IIRFilterMode filt_mode,\n                                                    int order, float cutoff_ratio,\n                                                    float stopband, float ripple)\n{\n    int i, j;\n    FFIIRFilterCoeffs *c;\n    double wa;\n    double p[MAXORDER + 1][2];\n\n    if(filt_type != FF_FILTER_TYPE_BUTTERWORTH || filt_mode != FF_FILTER_MODE_LOWPASS)\n        return NULL;\n    if(order <= 1 || (order & 1) || order > MAXORDER || cutoff_ratio >= 1.0)\n        return NULL;\n\n    FF_ALLOCZ_OR_GOTO(avc, c,     sizeof(FFIIRFilterCoeffs),\n                      init_fail);\n    FF_ALLOC_OR_GOTO (avc, c->cx, sizeof(c->cx[0]) * ((order >> 1) + 1),\n                      init_fail);\n    FF_ALLOC_OR_GOTO (avc, c->cy, sizeof(c->cy[0]) * order,\n                      init_fail);\n    c->order = order;\n\n    wa = 2 * tan(M_PI * 0.5 * cutoff_ratio);\n\n    c->cx[0] = 1;\n    for(i = 1; i < (order >> 1) + 1; i++)\n        c->cx[i] = c->cx[i - 1] * (order - i + 1LL) / i;\n\n    p[0][0] = 1.0;\n    p[0][1] = 0.0;\n    for(i = 1; i <= order; i++)\n        p[i][0] = p[i][1] = 0.0;\n    for(i = 0; i < order; i++){\n        double zp[2];\n        double th = (i + (order >> 1) + 0.5) * M_PI / order;\n        double a_re, a_im, c_re, c_im;\n        zp[0] = cos(th) * wa;\n        zp[1] = sin(th) * wa;\n        a_re = zp[0] + 2.0;\n        c_re = zp[0] - 2.0;\n        a_im =\n        c_im = zp[1];\n        zp[0] = (a_re * c_re + a_im * c_im) / (c_re * c_re + c_im * c_im);\n        zp[1] = (a_im * c_re - a_re * c_im) / (c_re * c_re + c_im * c_im);\n\n        for(j = order; j >= 1; j--)\n        {\n            a_re = p[j][0];\n            a_im = p[j][1];\n            p[j][0] = a_re*zp[0] - a_im*zp[1] + p[j-1][0];\n            p[j][1] = a_re*zp[1] + a_im*zp[0] + p[j-1][1];\n        }\n        a_re    = p[0][0]*zp[0] - p[0][1]*zp[1];\n        p[0][1] = p[0][0]*zp[1] + p[0][1]*zp[0];\n        p[0][0] = a_re;\n    }\n    c->gain = p[order][0];\n    for(i = 0; i < order; i++){\n        c->gain += p[i][0];\n        c->cy[i] = (-p[i][0] * p[order][0] + -p[i][1] * p[order][1]) /\n                   (p[order][0] * p[order][0] + p[order][1] * p[order][1]);\n    }\n    c->gain /= 1 << order;\n\n    return c;\n\ninit_fail:\n    ff_iir_filter_free_coeffs(c);\n    return NULL;\n}", "before_change_lines": [1, 16, 17, 18], "raw_before_change_lines": [1, 16, 17, 18], "after_change_lines": [1, 2, 17, 18, 19, 20, 21, 22, 69, 70, 71], "raw_after_change_lines": [1, 2, 17, 18, 19, 20, 21, 22, 68, 69, 70, 71], "bug_lines": [1, 16, 17, 18], "added": [false, false, false, false], "idx": 97}
{"project": "ffmpeg", "vul_type": "DIVIDE_BY_ZERO", "filepath_func": "1348----DIVIDE_BY_ZERO----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_49a64f20437fd80ef3330e65973402f92eee83e5_1.json----av_get_int", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_49a64f20437fd80ef3330e65973402f92eee83e5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_49a64f20437fd80ef3330e65973402f92eee83e5_1.json", "function_name": "av_get_int", "vul_func_code": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n{\n    int64_t intnum=1;\n    double num=1;\n    int den=1;\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n    return num*intnum/den;\n}", "patch_func_code": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n{\n    int64_t intnum=1;\n    double num=1;\n    int den=1;\n\n    if (av_get_number(obj, name, o_out, &num, &den, &intnum) < 0)\n        return -1;\n    return num*intnum/den;\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7, 8], "raw_after_change_lines": [7, 8], "bug_lines": [7], "added": [false], "idx": 98}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1362----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4aee4f7d228c05591e23cd9cc81e6eb9b6fc42cf_1.json----scene_sad16", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4aee4f7d228c05591e23cd9cc81e6eb9b6fc42cf_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4aee4f7d228c05591e23cd9cc81e6eb9b6fc42cf_1.json", "function_name": "scene_sad16", "vul_func_code": "static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, int height)\n{\n    int64_t sad;\n    int x, y;\n    for (sad = y = 0; y < height; y += 8) {\n        for (x = 0; x < p1_linesize; x += 8) {\n            sad += sad_8x8_16(p1 + y * p1_linesize + x,\n                              p1_linesize,\n                              p2 + y * p2_linesize + x,\n                              p2_linesize);\n        }\n    }\n    return sad;\n}", "patch_func_code": "static int64_t scene_sad16(FrameRateContext *s, const uint16_t *p1, int p1_linesize, const uint16_t* p2, int p2_linesize, const int width, const int height)\n{\n    int64_t sad;\n    int x, y;\n    for (sad = y = 0; y < height - 7; y += 8) {\n        for (x = 0; x < width - 7; x += 8) {\n            sad += sad_8x8_16(p1 + y * p1_linesize + x,\n                              p1_linesize,\n                              p2 + y * p2_linesize + x,\n                              p2_linesize);\n        }\n    }\n    return sad;\n}", "before_change_lines": [1, 5, 6], "raw_before_change_lines": [1, 5, 6], "after_change_lines": [1, 5, 6], "raw_after_change_lines": [1, 5, 6], "bug_lines": [1, 5, 6], "added": [false, false, false], "idx": 99}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "1387----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4cd84eb23bd64a0e53b5447eec29e6d3f3d2d05d_1.json----rv34_decoder_alloc", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4cd84eb23bd64a0e53b5447eec29e6d3f3d2d05d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4cd84eb23bd64a0e53b5447eec29e6d3f3d2d05d_1.json", "function_name": "rv34_decoder_alloc", "vul_func_code": "static int rv34_decoder_alloc(RV34DecContext *r)\n{\n    r->intra_types_stride = r->s.mb_width * 4 + 4;\n\n    r->cbp_chroma       = av_malloc(r->s.mb_stride * r->s.mb_height *\n                                    sizeof(*r->cbp_chroma));\n    r->cbp_luma         = av_malloc(r->s.mb_stride * r->s.mb_height *\n                                    sizeof(*r->cbp_luma));\n    r->deblock_coefs    = av_malloc(r->s.mb_stride * r->s.mb_height *\n                                    sizeof(*r->deblock_coefs));\n    r->intra_types_hist = av_malloc(r->intra_types_stride * 4 * 2 *\n                                    sizeof(*r->intra_types_hist));\n    r->mb_type          = av_mallocz(r->s.mb_stride * r->s.mb_height *\n                                     sizeof(*r->mb_type));\n\n    if (!(r->cbp_chroma       && r->cbp_luma && r->deblock_coefs &&\n          r->intra_types_hist && r->mb_type)) {\n        rv34_decoder_free(r);\n        return AVERROR(ENOMEM);\n    }\n\n    r->intra_types = r->intra_types_hist + r->intra_types_stride * 4;\n\n    return 0;\n}", "patch_func_code": "static int rv34_decoder_alloc(RV34DecContext *r)\n{\n    r->intra_types_stride = r->s.mb_width * 4 + 4;\n\n    r->cbp_chroma       = av_mallocz(r->s.mb_stride * r->s.mb_height *\n                                    sizeof(*r->cbp_chroma));\n    r->cbp_luma         = av_mallocz(r->s.mb_stride * r->s.mb_height *\n                                    sizeof(*r->cbp_luma));\n    r->deblock_coefs    = av_mallocz(r->s.mb_stride * r->s.mb_height *\n                                    sizeof(*r->deblock_coefs));\n    r->intra_types_hist = av_malloc(r->intra_types_stride * 4 * 2 *\n                                    sizeof(*r->intra_types_hist));\n    r->mb_type          = av_mallocz(r->s.mb_stride * r->s.mb_height *\n                                     sizeof(*r->mb_type));\n\n    if (!(r->cbp_chroma       && r->cbp_luma && r->deblock_coefs &&\n          r->intra_types_hist && r->mb_type)) {\n        rv34_decoder_free(r);\n        return AVERROR(ENOMEM);\n    }\n\n    r->intra_types = r->intra_types_hist + r->intra_types_stride * 4;\n\n    return 0;\n}", "before_change_lines": [5, 7, 9], "raw_before_change_lines": [5, 7, 9], "after_change_lines": [5, 7, 9], "raw_after_change_lines": [5, 7, 9], "bug_lines": [5, 7, 9], "added": [false, false, false], "idx": 100}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1391----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4d0983b40ec098580465d8c88a3fa168e3d6aa1f_1.json----build_vlc", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4d0983b40ec098580465d8c88a3fa168e3d6aa1f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4d0983b40ec098580465d8c88a3fa168e3d6aa1f_1.json", "function_name": "build_vlc", "vul_func_code": "static int build_vlc(AVCodecContext *avctx, VLC *vlc, const uint32_t *table)\n{\n    Node nodes[512];\n    uint32_t bits[256];\n    int16_t lens[256];\n    uint8_t xlat[256];\n    int cur_node, i, j, pos = 0;\n\n    ff_free_vlc(vlc);\n\n    for (i = 0; i < 256; i++) {\n        nodes[i].count = table[i];\n        nodes[i].sym   = i;\n        nodes[i].n0    = -2;\n        nodes[i].l     = i;\n        nodes[i].r     = i;\n    }\n\n    cur_node = 256;\n    j = 0;\n    do {\n        for (i = 0; ; i++) {\n            int new_node = j;\n            int first_node = cur_node;\n            int second_node = cur_node;\n            int nd, st;\n\n            nodes[cur_node].count = -1;\n\n            do {\n                int val = nodes[new_node].count;\n                if (val && (val < nodes[first_node].count)) {\n                    if (val >= nodes[second_node].count) {\n                        first_node = new_node;\n                    } else {\n                        first_node = second_node;\n                        second_node = new_node;\n                    }\n                }\n                new_node += 1;\n            } while (new_node != cur_node);\n\n            if (first_node == cur_node)\n                break;\n\n            nd = nodes[second_node].count;\n            st = nodes[first_node].count;\n            nodes[second_node].count = 0;\n            nodes[first_node].count  = 0;\n            nodes[cur_node].count = nd + st;\n            nodes[cur_node].sym = -1;\n            nodes[cur_node].n0 = cur_node;\n            nodes[cur_node].l = first_node;\n            nodes[cur_node].r = second_node;\n            cur_node++;\n        }\n        j++;\n    } while (cur_node - 256 == j);\n\n    get_tree_codes(bits, lens, xlat, nodes, cur_node - 1, 0, 0, &pos);\n\n    return ff_init_vlc_sparse(vlc, 10, pos, lens, 2, 2, bits, 4, 4, xlat, 1, 1, 0);\n}", "patch_func_code": "static int build_vlc(AVCodecContext *avctx, VLC *vlc, const uint32_t *table)\n{\n    Node nodes[512];\n    uint32_t bits[256];\n    int16_t lens[256];\n    uint8_t xlat[256];\n    int cur_node, i, j, pos = 0;\n\n    ff_free_vlc(vlc);\n\n    for (i = 0; i < 256; i++) {\n        nodes[i].count = table[i];\n        nodes[i].sym   = i;\n        nodes[i].n0    = -2;\n        nodes[i].l     = i;\n        nodes[i].r     = i;\n    }\n\n    cur_node = 256;\n    j = 0;\n    do {\n        for (i = 0; ; i++) {\n            int new_node = j;\n            int first_node = cur_node;\n            int second_node = cur_node;\n            unsigned nd, st;\n\n            nodes[cur_node].count = -1;\n\n            do {\n                int val = nodes[new_node].count;\n                if (val && (val < nodes[first_node].count)) {\n                    if (val >= nodes[second_node].count) {\n                        first_node = new_node;\n                    } else {\n                        first_node = second_node;\n                        second_node = new_node;\n                    }\n                }\n                new_node += 1;\n            } while (new_node != cur_node);\n\n            if (first_node == cur_node)\n                break;\n\n            nd = nodes[second_node].count;\n            st = nodes[first_node].count;\n            nodes[second_node].count = 0;\n            nodes[first_node].count  = 0;\n            if (nd >= UINT32_MAX - st) {\n                av_log(avctx, AV_LOG_ERROR, \"count overflow\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            nodes[cur_node].count = nd + st;\n            nodes[cur_node].sym = -1;\n            nodes[cur_node].n0 = cur_node;\n            nodes[cur_node].l = first_node;\n            nodes[cur_node].r = second_node;\n            cur_node++;\n        }\n        j++;\n    } while (cur_node - 256 == j);\n\n    get_tree_codes(bits, lens, xlat, nodes, cur_node - 1, 0, 0, &pos);\n\n    return ff_init_vlc_sparse(vlc, 10, pos, lens, 2, 2, bits, 4, 4, xlat, 1, 1, 0);\n}", "before_change_lines": [26], "raw_before_change_lines": [26], "after_change_lines": [26, 50, 51, 52, 53], "raw_after_change_lines": [26, 50, 51, 52, 53], "bug_lines": [26], "added": [false], "idx": 101}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1428----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4efdee98b33b34de7afafca39db9eb93e21de09d_1.json----gif_image_write_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4efdee98b33b34de7afafca39db9eb93e21de09d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4efdee98b33b34de7afafca39db9eb93e21de09d_1.json", "function_name": "gif_image_write_header", "vul_func_code": "static int gif_image_write_header(AVFormatContext *s, int width, int height,\n                                  int loop_count, uint32_t *palette)\n{\n    AVIOContext *pb = s->pb;\n    AVRational sar = s->streams[0]->codec->sample_aspect_ratio;\n    int i, aspect = 0;\n\n    if (sar.num > 0 && sar.den > 0) {\n        aspect = sar.num * 64 / sar.den - 15;\n        if (aspect < 0 || aspect > 255)\n            aspect = 0;\n    }\n\n    avio_write(pb, \"GIF\", 3);\n    avio_write(pb, \"89a\", 3);\n    avio_wl16(pb, width);\n    avio_wl16(pb, height);\n\n    if (palette) {\n        avio_w8(pb, 0xf7); /* flags: global clut, 256 entries */\n        avio_w8(pb, 0x1f); /* background color index */\n        avio_w8(pb, aspect);\n        for (i = 0; i < 256; i++) {\n            const uint32_t v = palette[i] & 0xffffff;\n            avio_wb24(pb, v);\n        }\n    } else {\n        avio_w8(pb, 0); /* flags */\n        avio_w8(pb, 0); /* background color index */\n        avio_w8(pb, aspect);\n    }\n\n\n    if (loop_count >= 0 ) {\n        /* \"NETSCAPE EXTENSION\" for looped animation GIF */\n        avio_w8(pb, 0x21); /* GIF Extension code */\n        avio_w8(pb, 0xff); /* Application Extension Label */\n        avio_w8(pb, 0x0b); /* Length of Application Block */\n        avio_write(pb, \"NETSCAPE2.0\", sizeof(\"NETSCAPE2.0\") - 1);\n        avio_w8(pb, 0x03); /* Length of Data Sub-Block */\n        avio_w8(pb, 0x01);\n        avio_wl16(pb, (uint16_t)loop_count);\n        avio_w8(pb, 0x00); /* Data Sub-block Terminator */\n    }\n\n    return 0;\n}", "patch_func_code": "static int gif_image_write_header(AVFormatContext *s, int width, int height,\n                                  int loop_count, uint32_t *palette)\n{\n    AVIOContext *pb = s->pb;\n    AVRational sar = s->streams[0]->codec->sample_aspect_ratio;\n    int i;\n    int64_t aspect = 0;\n\n    if (sar.num > 0 && sar.den > 0) {\n        aspect = sar.num * 64LL / sar.den - 15;\n        if (aspect < 0 || aspect > 255)\n            aspect = 0;\n    }\n\n    avio_write(pb, \"GIF\", 3);\n    avio_write(pb, \"89a\", 3);\n    avio_wl16(pb, width);\n    avio_wl16(pb, height);\n\n    if (palette) {\n        avio_w8(pb, 0xf7); /* flags: global clut, 256 entries */\n        avio_w8(pb, 0x1f); /* background color index */\n        avio_w8(pb, aspect);\n        for (i = 0; i < 256; i++) {\n            const uint32_t v = palette[i] & 0xffffff;\n            avio_wb24(pb, v);\n        }\n    } else {\n        avio_w8(pb, 0); /* flags */\n        avio_w8(pb, 0); /* background color index */\n        avio_w8(pb, aspect);\n    }\n\n\n    if (loop_count >= 0 ) {\n        /* \"NETSCAPE EXTENSION\" for looped animation GIF */\n        avio_w8(pb, 0x21); /* GIF Extension code */\n        avio_w8(pb, 0xff); /* Application Extension Label */\n        avio_w8(pb, 0x0b); /* Length of Application Block */\n        avio_write(pb, \"NETSCAPE2.0\", sizeof(\"NETSCAPE2.0\") - 1);\n        avio_w8(pb, 0x03); /* Length of Data Sub-Block */\n        avio_w8(pb, 0x01);\n        avio_wl16(pb, (uint16_t)loop_count);\n        avio_w8(pb, 0x00); /* Data Sub-block Terminator */\n    }\n\n    return 0;\n}", "before_change_lines": [6, 9], "raw_before_change_lines": [6, 9], "after_change_lines": [6, 7, 10], "raw_after_change_lines": [6, 7, 10], "bug_lines": [6, 9], "added": [false, false], "idx": 102}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1435----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4f4d84eb2e09649978d7a9bbe792dabb5dfa55ce_1.json----rm_read_audio_stream_info", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4f4d84eb2e09649978d7a9bbe792dabb5dfa55ce_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4f4d84eb2e09649978d7a9bbe792dabb5dfa55ce_1.json", "function_name": "rm_read_audio_stream_info", "vul_func_code": "static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb,\n                                     AVStream *st, int read_all)\n{\n    RMDemuxContext *rm = s->priv_data;\n    char buf[256];\n    uint32_t version;\n    int i;\n\n    /* ra type header */\n    version = get_be32(pb); /* version */\n    if (((version >> 16) & 0xff) == 3) {\n        int64_t startpos = url_ftell(pb);\n        /* very old version */\n        for(i = 0; i < 14; i++)\n            get_byte(pb);\n        get_str8(pb, s->title, sizeof(s->title));\n        get_str8(pb, s->author, sizeof(s->author));\n        get_str8(pb, s->copyright, sizeof(s->copyright));\n        get_str8(pb, s->comment, sizeof(s->comment));\n        if ((startpos + (version & 0xffff)) >= url_ftell(pb) + 2) {\n            // fourcc (should always be \"lpcJ\")\n            get_byte(pb);\n            get_str8(pb, buf, sizeof(buf));\n        }\n        // Skip extra header crap (this should never happen)\n        if ((startpos + (version & 0xffff)) > url_ftell(pb))\n            url_fskip(pb, (version & 0xffff) + startpos - url_ftell(pb));\n        st->codec->sample_rate = 8000;\n        st->codec->channels = 1;\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n        st->codec->codec_id = CODEC_ID_RA_144;\n    } else {\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n        /* old version (4) */\n        get_be32(pb); /* .ra4 */\n        get_be32(pb); /* data size */\n        get_be16(pb); /* version2 */\n        get_be32(pb); /* header size */\n        flavor= get_be16(pb); /* add codec info / flavor */\n        rm->coded_framesize = coded_framesize = get_be32(pb); /* coded frame size */\n        get_be32(pb); /* ??? */\n        get_be32(pb); /* ??? */\n        get_be32(pb); /* ??? */\n        rm->sub_packet_h = sub_packet_h = get_be16(pb); /* 1 */\n        st->codec->block_align= get_be16(pb); /* frame size */\n        rm->sub_packet_size = sub_packet_size = get_be16(pb); /* sub packet size */\n        get_be16(pb); /* ??? */\n        if (((version >> 16) & 0xff) == 5) {\n            get_be16(pb); get_be16(pb); get_be16(pb);\n        }\n        st->codec->sample_rate = get_be16(pb);\n        get_be32(pb);\n        st->codec->channels = get_be16(pb);\n        if (((version >> 16) & 0xff) == 5) {\n            get_be32(pb);\n            buf[0] = get_byte(pb);\n            buf[1] = get_byte(pb);\n            buf[2] = get_byte(pb);\n            buf[3] = get_byte(pb);\n            buf[4] = 0;\n        } else {\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n        }\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n        if (!strcmp(buf, \"dnet\")) {\n            st->codec->codec_id = CODEC_ID_AC3;\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n        } else if (!strcmp(buf, \"28_8\")) {\n            st->codec->codec_id = CODEC_ID_RA_288;\n            st->codec->extradata_size= 0;\n            rm->audio_framesize = st->codec->block_align;\n            st->codec->block_align = coded_framesize;\n\n            if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n                av_log(s, AV_LOG_ERROR, \"rm->audio_framesize * sub_packet_h too large\\n\");\n                return -1;\n            }\n\n            rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h);\n        } else if ((!strcmp(buf, \"cook\")) || (!strcmp(buf, \"atrc\")) || (!strcmp(buf, \"sipr\"))) {\n            int codecdata_length, i;\n            get_be16(pb); get_byte(pb);\n            if (((version >> 16) & 0xff) == 5)\n                get_byte(pb);\n            codecdata_length = get_be32(pb);\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                return -1;\n            }\n\n            if(sub_packet_size <= 0){\n                av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n                return -1;\n            }\n\n            if (!strcmp(buf, \"cook\")) st->codec->codec_id = CODEC_ID_COOK;\n            else if (!strcmp(buf, \"sipr\")) st->codec->codec_id = CODEC_ID_SIPR;\n            else st->codec->codec_id = CODEC_ID_ATRAC3;\n            st->codec->extradata_size= codecdata_length;\n            st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n            for(i = 0; i < codecdata_length; i++)\n                ((uint8_t*)st->codec->extradata)[i] = get_byte(pb);\n            rm->audio_framesize = st->codec->block_align;\n            st->codec->block_align = rm->sub_packet_size;\n\n            if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n                av_log(s, AV_LOG_ERROR, \"rm->audio_framesize * sub_packet_h too large\\n\");\n                return -1;\n            }\n\n            rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h);\n        } else if (!strcmp(buf, \"raac\") || !strcmp(buf, \"racp\")) {\n            int codecdata_length, i;\n            get_be16(pb); get_byte(pb);\n            if (((version >> 16) & 0xff) == 5)\n                get_byte(pb);\n            st->codec->codec_id = CODEC_ID_AAC;\n            codecdata_length = get_be32(pb);\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                return -1;\n            }\n            if (codecdata_length >= 1) {\n                st->codec->extradata_size = codecdata_length - 1;\n                st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n                get_byte(pb);\n                for(i = 0; i < st->codec->extradata_size; i++)\n                    ((uint8_t*)st->codec->extradata)[i] = get_byte(pb);\n            }\n        } else {\n            st->codec->codec_id = CODEC_ID_NONE;\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n        }\n        if (read_all) {\n            get_byte(pb);\n            get_byte(pb);\n            get_byte(pb);\n\n            get_str8(pb, s->title, sizeof(s->title));\n            get_str8(pb, s->author, sizeof(s->author));\n            get_str8(pb, s->copyright, sizeof(s->copyright));\n            get_str8(pb, s->comment, sizeof(s->comment));\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb,\n                                     AVStream *st, int read_all)\n{\n    RMDemuxContext *rm = s->priv_data;\n    char buf[256];\n    uint32_t version;\n\n    /* ra type header */\n    version = get_be32(pb); /* version */\n    if (((version >> 16) & 0xff) == 3) {\n        int64_t startpos = url_ftell(pb);\n        url_fskip(pb, 14);\n        get_str8(pb, s->title, sizeof(s->title));\n        get_str8(pb, s->author, sizeof(s->author));\n        get_str8(pb, s->copyright, sizeof(s->copyright));\n        get_str8(pb, s->comment, sizeof(s->comment));\n        if ((startpos + (version & 0xffff)) >= url_ftell(pb) + 2) {\n            // fourcc (should always be \"lpcJ\")\n            get_byte(pb);\n            get_str8(pb, buf, sizeof(buf));\n        }\n        // Skip extra header crap (this should never happen)\n        if ((startpos + (version & 0xffff)) > url_ftell(pb))\n            url_fskip(pb, (version & 0xffff) + startpos - url_ftell(pb));\n        st->codec->sample_rate = 8000;\n        st->codec->channels = 1;\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n        st->codec->codec_id = CODEC_ID_RA_144;\n    } else {\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n        /* old version (4) */\n        get_be32(pb); /* .ra4 */\n        get_be32(pb); /* data size */\n        get_be16(pb); /* version2 */\n        get_be32(pb); /* header size */\n        flavor= get_be16(pb); /* add codec info / flavor */\n        rm->coded_framesize = coded_framesize = get_be32(pb); /* coded frame size */\n        get_be32(pb); /* ??? */\n        get_be32(pb); /* ??? */\n        get_be32(pb); /* ??? */\n        rm->sub_packet_h = sub_packet_h = get_be16(pb); /* 1 */\n        st->codec->block_align= get_be16(pb); /* frame size */\n        rm->sub_packet_size = sub_packet_size = get_be16(pb); /* sub packet size */\n        get_be16(pb); /* ??? */\n        if (((version >> 16) & 0xff) == 5) {\n            get_be16(pb); get_be16(pb); get_be16(pb);\n        }\n        st->codec->sample_rate = get_be16(pb);\n        get_be32(pb);\n        st->codec->channels = get_be16(pb);\n        if (((version >> 16) & 0xff) == 5) {\n            get_be32(pb);\n            get_buffer(pb, buf, 4);\n            buf[4] = 0;\n        } else {\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n        }\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n        if (!strcmp(buf, \"dnet\")) {\n            st->codec->codec_id = CODEC_ID_AC3;\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n        } else if (!strcmp(buf, \"28_8\")) {\n            st->codec->codec_id = CODEC_ID_RA_288;\n            st->codec->extradata_size= 0;\n            rm->audio_framesize = st->codec->block_align;\n            st->codec->block_align = coded_framesize;\n\n            if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n                av_log(s, AV_LOG_ERROR, \"rm->audio_framesize * sub_packet_h too large\\n\");\n                return -1;\n            }\n\n            rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h);\n        } else if ((!strcmp(buf, \"cook\")) || (!strcmp(buf, \"atrc\")) || (!strcmp(buf, \"sipr\"))) {\n            int codecdata_length;\n            get_be16(pb); get_byte(pb);\n            if (((version >> 16) & 0xff) == 5)\n                get_byte(pb);\n            codecdata_length = get_be32(pb);\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                return -1;\n            }\n\n            if(sub_packet_size <= 0){\n                av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n                return -1;\n            }\n\n            if (!strcmp(buf, \"cook\")) st->codec->codec_id = CODEC_ID_COOK;\n            else if (!strcmp(buf, \"sipr\")) st->codec->codec_id = CODEC_ID_SIPR;\n            else st->codec->codec_id = CODEC_ID_ATRAC3;\n            st->codec->extradata_size= codecdata_length;\n            st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n            get_buffer(pb, st->codec->extradata, st->codec->extradata_size);\n            rm->audio_framesize = st->codec->block_align;\n            st->codec->block_align = rm->sub_packet_size;\n\n            if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n                av_log(s, AV_LOG_ERROR, \"rm->audio_framesize * sub_packet_h too large\\n\");\n                return -1;\n            }\n\n            rm->audiobuf = av_malloc(rm->audio_framesize * sub_packet_h);\n        } else if (!strcmp(buf, \"raac\") || !strcmp(buf, \"racp\")) {\n            int codecdata_length;\n            get_be16(pb); get_byte(pb);\n            if (((version >> 16) & 0xff) == 5)\n                get_byte(pb);\n            st->codec->codec_id = CODEC_ID_AAC;\n            codecdata_length = get_be32(pb);\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n                return -1;\n            }\n            if (codecdata_length >= 1) {\n                st->codec->extradata_size = codecdata_length - 1;\n                st->codec->extradata = av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n                get_byte(pb);\n                get_buffer(pb, st->codec->extradata, st->codec->extradata_size);\n            }\n        } else {\n            st->codec->codec_id = CODEC_ID_NONE;\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n        }\n        if (read_all) {\n            get_byte(pb);\n            get_byte(pb);\n            get_byte(pb);\n\n            get_str8(pb, s->title, sizeof(s->title));\n            get_str8(pb, s->author, sizeof(s->author));\n            get_str8(pb, s->copyright, sizeof(s->copyright));\n            get_str8(pb, s->comment, sizeof(s->comment));\n        }\n    }\n    return 0;\n}", "before_change_lines": [7, 14, 15, 56, 57, 58, 59, 82, 102, 103, 114, 128, 129], "raw_before_change_lines": [7, 13, 14, 15, 56, 57, 58, 59, 82, 102, 103, 114, 128, 129], "after_change_lines": [12, 53, 76, 96, 107, 121], "raw_after_change_lines": [12, 53, 76, 96, 107, 121], "bug_lines": [7, 13, 14, 15, 56, 57, 58, 59, 82, 102, 103, 114, 128, 129], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 103}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1447----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4fb9ce3b4cc54cba14ce5ef3c1672bc3d73784f2_1.json----ff_psy_preprocess_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_4fb9ce3b4cc54cba14ce5ef3c1672bc3d73784f2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_4fb9ce3b4cc54cba14ce5ef3c1672bc3d73784f2_1.json", "function_name": "ff_psy_preprocess_init", "vul_func_code": "struct FFPsyPreprocessContext* ff_psy_preprocess_init(AVCodecContext *avctx)\n{\n    FFPsyPreprocessContext *ctx;\n    int i;\n    float cutoff_coeff = 0;\n    ctx        = av_mallocz(sizeof(FFPsyPreprocessContext));\n    if (!ctx)\n        return NULL;\n    ctx->avctx = avctx;\n\n    if (avctx->cutoff > 0)\n        cutoff_coeff = 2.0 * avctx->cutoff / avctx->sample_rate;\n\n    if (!cutoff_coeff && avctx->codec_id == AV_CODEC_ID_AAC)\n        cutoff_coeff = 2.0 * AAC_CUTOFF(avctx) / avctx->sample_rate;\n\n    if (cutoff_coeff && cutoff_coeff < 0.98)\n    ctx->fcoeffs = ff_iir_filter_init_coeffs(avctx, FF_FILTER_TYPE_BUTTERWORTH,\n                                             FF_FILTER_MODE_LOWPASS, FILT_ORDER,\n                                             cutoff_coeff, 0.0, 0.0);\n    if (ctx->fcoeffs) {\n        ctx->fstate = av_mallocz_array(sizeof(ctx->fstate[0]), avctx->channels);\n        if (!ctx->fstate) {\n            av_free(ctx);\n            return NULL;\n        }\n        for (i = 0; i < avctx->channels; i++)\n            ctx->fstate[i] = ff_iir_filter_init_state(FILT_ORDER);\n    }\n\n    ff_iir_filter_init(&ctx->fiir);\n\n    return ctx;\n}", "patch_func_code": "struct FFPsyPreprocessContext* ff_psy_preprocess_init(AVCodecContext *avctx)\n{\n    FFPsyPreprocessContext *ctx;\n    int i;\n    float cutoff_coeff = 0;\n    ctx        = av_mallocz(sizeof(FFPsyPreprocessContext));\n    if (!ctx)\n        return NULL;\n    ctx->avctx = avctx;\n\n    /* AAC has its own LP method */\n    if (avctx->codec_id != AV_CODEC_ID_AAC) {\n    if (avctx->cutoff > 0)\n        cutoff_coeff = 2.0 * avctx->cutoff / avctx->sample_rate;\n\n    if (cutoff_coeff && cutoff_coeff < 0.98)\n    ctx->fcoeffs = ff_iir_filter_init_coeffs(avctx, FF_FILTER_TYPE_BUTTERWORTH,\n                                             FF_FILTER_MODE_LOWPASS, FILT_ORDER,\n                                             cutoff_coeff, 0.0, 0.0);\n    if (ctx->fcoeffs) {\n        ctx->fstate = av_mallocz(sizeof(ctx->fstate[0]) * avctx->channels);\n        for (i = 0; i < avctx->channels; i++)\n            ctx->fstate[i] = ff_iir_filter_init_state(FILT_ORDER);\n    }\n    }\n\n    ff_iir_filter_init(&ctx->fiir);\n\n    return ctx;\n}", "before_change_lines": [14, 15, 22, 23, 24, 25, 26], "raw_before_change_lines": [14, 15, 16, 22, 23, 24, 25, 26], "after_change_lines": [12, 21, 25], "raw_after_change_lines": [11, 12, 21, 25], "bug_lines": [14, 15, 16, 22, 23, 24, 25, 26], "added": [false, false, false, false, false, false, false, false], "idx": 104}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1464----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_512a60de63ed8b77bc5adadc8b0ffc001bc465ea_1.json----pred8x8_top_dc_8_c", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_512a60de63ed8b77bc5adadc8b0ffc001bc465ea_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_512a60de63ed8b77bc5adadc8b0ffc001bc465ea_1.json", "function_name": "pred8x8_top_dc_8_c", "vul_func_code": "static void FUNCC(pred8x8_top_dc)(uint8_t *_src, int stride){\n    int i;\n    int dc0, dc1;\n    pixel4 dc0splat, dc1splat;\n    pixel *src = (pixel*)_src;\n    stride /= sizeof(pixel);\n\n    dc0=dc1=0;\n    for(i=0;i<4; i++){\n        dc0+= src[i-stride];\n        dc1+= src[4+i-stride];\n    }\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n    dc1splat = PIXEL_SPLAT_X4((dc1 + 2)>>2);\n\n    for(i=0; i<4; i++){\n        ((pixel4*)(src+i*stride))[0]= dc0splat;\n        ((pixel4*)(src+i*stride))[1]= dc1splat;\n    }\n    for(i=4; i<8; i++){\n        ((pixel4*)(src+i*stride))[0]= dc0splat;\n        ((pixel4*)(src+i*stride))[1]= dc1splat;\n    }\n}", "patch_func_code": "static void FUNCC(pred8x8_top_dc)(uint8_t *_src, int stride){\n    int i;\n    int dc0, dc1;\n    pixel4 dc0splat, dc1splat;\n    pixel *src = (pixel*)_src;\n    stride /= sizeof(pixel);\n\n    dc0=dc1=0;\n    for(i=0;i<4; i++){\n        dc0+= src[i-stride];\n        dc1+= src[4+i-stride];\n    }\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n    dc1splat = PIXEL_SPLAT_X4((dc1 + 2)>>2);\n\n    for(i=0; i<4; i++){\n        AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat);\n        AV_WN4PA(((pixel4*)(src+i*stride))+1, dc1splat);\n    }\n    for(i=4; i<8; i++){\n        AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat);\n        AV_WN4PA(((pixel4*)(src+i*stride))+1, dc1splat);\n    }\n}", "before_change_lines": [17, 18, 21, 22], "raw_before_change_lines": [17, 18, 21, 22], "after_change_lines": [17, 18, 21, 22], "raw_after_change_lines": [17, 18, 21, 22], "bug_lines": [17, 18, 21, 22], "added": [false, false, false, false], "idx": 105}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1481----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_522650996eeef4469dfee007d251619c2cc10442_1.json----scaling_list_data", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_522650996eeef4469dfee007d251619c2cc10442_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_522650996eeef4469dfee007d251619c2cc10442_1.json", "function_name": "scaling_list_data", "vul_func_code": "static int scaling_list_data(GetBitContext *gb, AVCodecContext *avctx, ScalingList *sl, HEVCSPS *sps)\n{\n    uint8_t scaling_list_pred_mode_flag;\n    int32_t scaling_list_dc_coef[2][6];\n    int size_id, matrix_id, pos;\n    int i;\n\n    for (size_id = 0; size_id < 4; size_id++)\n        for (matrix_id = 0; matrix_id < 6; matrix_id += ((size_id == 3) ? 3 : 1)) {\n            scaling_list_pred_mode_flag = get_bits1(gb);\n            if (!scaling_list_pred_mode_flag) {\n                unsigned int delta = get_ue_golomb_long(gb);\n                /* Only need to handle non-zero delta. Zero means default,\n                 * which should already be in the arrays. */\n                if (delta) {\n                    // Copy from previous array.\n                    if (matrix_id < delta) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"Invalid delta in scaling list data: %d.\\n\", delta);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    memcpy(sl->sl[size_id][matrix_id],\n                           sl->sl[size_id][matrix_id - delta],\n                           size_id > 0 ? 64 : 16);\n                    if (size_id > 1)\n                        sl->sl_dc[size_id - 2][matrix_id] = sl->sl_dc[size_id - 2][matrix_id - delta];\n                }\n            } else {\n                int next_coef, coef_num;\n                int32_t scaling_list_delta_coef;\n\n                next_coef = 8;\n                coef_num  = FFMIN(64, 1 << (4 + (size_id << 1)));\n                if (size_id > 1) {\n                    scaling_list_dc_coef[size_id - 2][matrix_id] = get_se_golomb(gb) + 8;\n                    next_coef = scaling_list_dc_coef[size_id - 2][matrix_id];\n                    sl->sl_dc[size_id - 2][matrix_id] = next_coef;\n                }\n                for (i = 0; i < coef_num; i++) {\n                    if (size_id == 0)\n                        pos = 4 * ff_hevc_diag_scan4x4_y[i] +\n                                  ff_hevc_diag_scan4x4_x[i];\n                    else\n                        pos = 8 * ff_hevc_diag_scan8x8_y[i] +\n                                  ff_hevc_diag_scan8x8_x[i];\n\n                    scaling_list_delta_coef = get_se_golomb(gb);\n                    next_coef = (next_coef + scaling_list_delta_coef + 256) % 256;\n                    sl->sl[size_id][matrix_id][pos] = next_coef;\n                }\n            }\n        }\n\n    if (sps->chroma_format_idc == 3) {\n        for (i = 0; i < 64; i++) {\n            sl->sl[3][1][i] = sl->sl[2][1][i];\n            sl->sl[3][2][i] = sl->sl[2][2][i];\n            sl->sl[3][4][i] = sl->sl[2][4][i];\n            sl->sl[3][5][i] = sl->sl[2][5][i];\n        }\n        sl->sl_dc[1][1] = sl->sl_dc[0][1];\n        sl->sl_dc[1][2] = sl->sl_dc[0][2];\n        sl->sl_dc[1][4] = sl->sl_dc[0][4];\n        sl->sl_dc[1][5] = sl->sl_dc[0][5];\n    }\n\n\n    return 0;\n}", "patch_func_code": "static int scaling_list_data(GetBitContext *gb, AVCodecContext *avctx, ScalingList *sl, HEVCSPS *sps)\n{\n    uint8_t scaling_list_pred_mode_flag;\n    int32_t scaling_list_dc_coef[2][6];\n    int size_id, matrix_id, pos;\n    int i;\n\n    for (size_id = 0; size_id < 4; size_id++)\n        for (matrix_id = 0; matrix_id < 6; matrix_id += ((size_id == 3) ? 3 : 1)) {\n            scaling_list_pred_mode_flag = get_bits1(gb);\n            if (!scaling_list_pred_mode_flag) {\n                unsigned int delta = get_ue_golomb_long(gb);\n                /* Only need to handle non-zero delta. Zero means default,\n                 * which should already be in the arrays. */\n                if (delta) {\n                    // Copy from previous array.\n                    if (matrix_id < delta) {\n                        av_log(avctx, AV_LOG_ERROR,\n                               \"Invalid delta in scaling list data: %d.\\n\", delta);\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    memcpy(sl->sl[size_id][matrix_id],\n                           sl->sl[size_id][matrix_id - delta],\n                           size_id > 0 ? 64 : 16);\n                    if (size_id > 1)\n                        sl->sl_dc[size_id - 2][matrix_id] = sl->sl_dc[size_id - 2][matrix_id - delta];\n                }\n            } else {\n                int next_coef, coef_num;\n                int32_t scaling_list_delta_coef;\n\n                next_coef = 8;\n                coef_num  = FFMIN(64, 1 << (4 + (size_id << 1)));\n                if (size_id > 1) {\n                    scaling_list_dc_coef[size_id - 2][matrix_id] = get_se_golomb(gb) + 8;\n                    next_coef = scaling_list_dc_coef[size_id - 2][matrix_id];\n                    sl->sl_dc[size_id - 2][matrix_id] = next_coef;\n                }\n                for (i = 0; i < coef_num; i++) {\n                    if (size_id == 0)\n                        pos = 4 * ff_hevc_diag_scan4x4_y[i] +\n                                  ff_hevc_diag_scan4x4_x[i];\n                    else\n                        pos = 8 * ff_hevc_diag_scan8x8_y[i] +\n                                  ff_hevc_diag_scan8x8_x[i];\n\n                    scaling_list_delta_coef = get_se_golomb(gb);\n                    next_coef = (next_coef + 256U + scaling_list_delta_coef) % 256;\n                    sl->sl[size_id][matrix_id][pos] = next_coef;\n                }\n            }\n        }\n\n    if (sps->chroma_format_idc == 3) {\n        for (i = 0; i < 64; i++) {\n            sl->sl[3][1][i] = sl->sl[2][1][i];\n            sl->sl[3][2][i] = sl->sl[2][2][i];\n            sl->sl[3][4][i] = sl->sl[2][4][i];\n            sl->sl[3][5][i] = sl->sl[2][5][i];\n        }\n        sl->sl_dc[1][1] = sl->sl_dc[0][1];\n        sl->sl_dc[1][2] = sl->sl_dc[0][2];\n        sl->sl_dc[1][4] = sl->sl_dc[0][4];\n        sl->sl_dc[1][5] = sl->sl_dc[0][5];\n    }\n\n\n    return 0;\n}", "before_change_lines": [49], "raw_before_change_lines": [49], "after_change_lines": [49], "raw_after_change_lines": [49], "bug_lines": [49], "added": [false], "idx": 106}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "1483----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_524e958707ee245a4e9167a2ed68ff8f43d5fe1d_1.json----amf_parse_object", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_524e958707ee245a4e9167a2ed68ff8f43d5fe1d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_524e958707ee245a4e9167a2ed68ff8f43d5fe1d_1.json", "function_name": "amf_parse_object", "vul_func_code": "static int amf_parse_object(AVFormatContext *s, AVStream *astream,\n                            AVStream *vstream, const char *key,\n                            int64_t max_pos, int depth)\n{\n    AVCodecContext *acodec, *vcodec;\n    FLVContext *flv = s->priv_data;\n    AVIOContext *ioc;\n    AMFDataType amf_type;\n    char str_val[256];\n    double num_val;\n\n    num_val  = 0;\n    ioc      = s->pb;\n    amf_type = avio_r8(ioc);\n\n    switch (amf_type) {\n    case AMF_DATA_TYPE_NUMBER:\n        num_val = av_int2double(avio_rb64(ioc));\n        break;\n    case AMF_DATA_TYPE_BOOL:\n        num_val = avio_r8(ioc);\n        break;\n    case AMF_DATA_TYPE_STRING:\n        if (amf_get_string(ioc, str_val, sizeof(str_val)) < 0)\n            return -1;\n        break;\n    case AMF_DATA_TYPE_OBJECT:\n        if ((vstream || astream) && key &&\n            ioc->seekable &&\n            !strcmp(KEYFRAMES_TAG, key) && depth == 1)\n            if (parse_keyframes_index(s, ioc, vstream ? vstream : astream,\n                                      max_pos) < 0)\n                av_log(s, AV_LOG_ERROR, \"Keyframe index parsing failed\\n\");\n\n        while (avio_tell(ioc) < max_pos - 2 &&\n               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)\n            if (amf_parse_object(s, astream, vstream, str_val, max_pos,\n                                 depth + 1) < 0)\n                return -1;     // if we couldn't skip, bomb out.\n        if (avio_r8(ioc) != AMF_END_OF_OBJECT)\n            return -1;\n        break;\n    case AMF_DATA_TYPE_NULL:\n    case AMF_DATA_TYPE_UNDEFINED:\n    case AMF_DATA_TYPE_UNSUPPORTED:\n        break;     // these take up no additional space\n    case AMF_DATA_TYPE_MIXEDARRAY:\n        avio_skip(ioc, 4);     // skip 32-bit max array index\n        while (avio_tell(ioc) < max_pos - 2 &&\n               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)\n            // this is the only case in which we would want a nested\n            // parse to not skip over the object\n            if (amf_parse_object(s, astream, vstream, str_val, max_pos,\n                                 depth + 1) < 0)\n                return -1;\n        if (avio_r8(ioc) != AMF_END_OF_OBJECT)\n            return -1;\n        break;\n    case AMF_DATA_TYPE_ARRAY:\n    {\n        unsigned int arraylen, i;\n\n        arraylen = avio_rb32(ioc);\n        for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++)\n            if (amf_parse_object(s, NULL, NULL, NULL, max_pos,\n                                 depth + 1) < 0)\n                return -1;      // if we couldn't skip, bomb out.\n    }\n    break;\n    case AMF_DATA_TYPE_DATE:\n        avio_skip(ioc, 8 + 2);  // timestamp (double) and UTC offset (int16)\n        break;\n    default:                    // unsupported type, we couldn't skip\n        return -1;\n    }\n\n    if (key) {\n        // stream info doesn't live any deeper than the first object\n        if (depth == 1) {\n            acodec = astream ? astream->codec : NULL;\n            vcodec = vstream ? vstream->codec : NULL;\n\n            if (amf_type == AMF_DATA_TYPE_NUMBER ||\n                amf_type == AMF_DATA_TYPE_BOOL) {\n                if (!strcmp(key, \"duration\"))\n                    s->duration = num_val * AV_TIME_BASE;\n                else if (!strcmp(key, \"videodatarate\") && vcodec &&\n                         0 <= (int)(num_val * 1024.0))\n                    vcodec->bit_rate = num_val * 1024.0;\n                else if (!strcmp(key, \"audiodatarate\") && acodec &&\n                         0 <= (int)(num_val * 1024.0))\n                    acodec->bit_rate = num_val * 1024.0;\n                else if (!strcmp(key, \"datastream\")) {\n                    AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA);\n                    if (!st)\n                        return AVERROR(ENOMEM);\n                    st->codec->codec_id = AV_CODEC_ID_TEXT;\n                } else if (flv->trust_metadata) {\n                    if (!strcmp(key, \"videocodecid\") && vcodec) {\n                        flv_set_video_codec(s, vstream, num_val, 0);\n                    } else if (!strcmp(key, \"audiocodecid\") && acodec) {\n                        int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET;\n                        flv_set_audio_codec(s, astream, acodec, id);\n                    } else if (!strcmp(key, \"audiosamplerate\") && acodec) {\n                        acodec->sample_rate = num_val;\n                    } else if (!strcmp(key, \"audiosamplesize\") && acodec) {\n                        acodec->bits_per_coded_sample = num_val;\n                    } else if (!strcmp(key, \"stereo\") && acodec) {\n                        acodec->channels       = num_val + 1;\n                        acodec->channel_layout = acodec->channels == 2 ?\n                                                 AV_CH_LAYOUT_STEREO :\n                                                 AV_CH_LAYOUT_MONO;\n                    } else if (!strcmp(key, \"width\") && vcodec) {\n                        vcodec->width = num_val;\n                    } else if (!strcmp(key, \"height\") && vcodec) {\n                        vcodec->height = num_val;\n                    }\n                }\n            }\n        }\n\n        if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 &&\n           ((!acodec && !strcmp(key, \"audiocodecid\")) ||\n            (!vcodec && !strcmp(key, \"videocodecid\"))))\n                s->ctx_flags &= ~AVFMTCTX_NOHEADER; //If there is either audio/video missing, codecid will be an empty object\n\n        if (!strcmp(key, \"duration\")        ||\n            !strcmp(key, \"filesize\")        ||\n            !strcmp(key, \"width\")           ||\n            !strcmp(key, \"height\")          ||\n            !strcmp(key, \"videodatarate\")   ||\n            !strcmp(key, \"framerate\")       ||\n            !strcmp(key, \"videocodecid\")    ||\n            !strcmp(key, \"audiodatarate\")   ||\n            !strcmp(key, \"audiosamplerate\") ||\n            !strcmp(key, \"audiosamplesize\") ||\n            !strcmp(key, \"stereo\")          ||\n            !strcmp(key, \"audiocodecid\")    ||\n            !strcmp(key, \"datastream\"))\n            return 0;\n\n        s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n        if (amf_type == AMF_DATA_TYPE_BOOL) {\n            av_strlcpy(str_val, num_val > 0 ? \"true\" : \"false\",\n                       sizeof(str_val));\n            av_dict_set(&s->metadata, key, str_val, 0);\n        } else if (amf_type == AMF_DATA_TYPE_NUMBER) {\n            snprintf(str_val, sizeof(str_val), \"%.f\", num_val);\n            av_dict_set(&s->metadata, key, str_val, 0);\n        } else if (amf_type == AMF_DATA_TYPE_STRING)\n            av_dict_set(&s->metadata, key, str_val, 0);\n    }\n\n    return 0;\n}", "patch_func_code": "static int amf_parse_object(AVFormatContext *s, AVStream *astream,\n                            AVStream *vstream, const char *key,\n                            int64_t max_pos, int depth)\n{\n    AVCodecContext *acodec, *vcodec;\n    FLVContext *flv = s->priv_data;\n    AVIOContext *ioc;\n    AMFDataType amf_type;\n    char str_val[256];\n    double num_val;\n\n    num_val  = 0;\n    ioc      = s->pb;\n    amf_type = avio_r8(ioc);\n\n    switch (amf_type) {\n    case AMF_DATA_TYPE_NUMBER:\n        num_val = av_int2double(avio_rb64(ioc));\n        break;\n    case AMF_DATA_TYPE_BOOL:\n        num_val = avio_r8(ioc);\n        break;\n    case AMF_DATA_TYPE_STRING:\n        if (amf_get_string(ioc, str_val, sizeof(str_val)) < 0)\n            return -1;\n        break;\n    case AMF_DATA_TYPE_OBJECT:\n        if ((vstream || astream) && key &&\n            ioc->seekable &&\n            !strcmp(KEYFRAMES_TAG, key) && depth == 1)\n            if (parse_keyframes_index(s, ioc, vstream ? vstream : astream,\n                                      max_pos) < 0)\n                av_log(s, AV_LOG_ERROR, \"Keyframe index parsing failed\\n\");\n\n        while (avio_tell(ioc) < max_pos - 2 &&\n               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)\n            if (amf_parse_object(s, astream, vstream, str_val, max_pos,\n                                 depth + 1) < 0)\n                return -1;     // if we couldn't skip, bomb out.\n        if (avio_r8(ioc) != AMF_END_OF_OBJECT)\n            return -1;\n        break;\n    case AMF_DATA_TYPE_NULL:\n    case AMF_DATA_TYPE_UNDEFINED:\n    case AMF_DATA_TYPE_UNSUPPORTED:\n        break;     // these take up no additional space\n    case AMF_DATA_TYPE_MIXEDARRAY:\n        avio_skip(ioc, 4);     // skip 32-bit max array index\n        while (avio_tell(ioc) < max_pos - 2 &&\n               amf_get_string(ioc, str_val, sizeof(str_val)) > 0)\n            // this is the only case in which we would want a nested\n            // parse to not skip over the object\n            if (amf_parse_object(s, astream, vstream, str_val, max_pos,\n                                 depth + 1) < 0)\n                return -1;\n        if (avio_r8(ioc) != AMF_END_OF_OBJECT)\n            return -1;\n        break;\n    case AMF_DATA_TYPE_ARRAY:\n    {\n        unsigned int arraylen, i;\n\n        arraylen = avio_rb32(ioc);\n        for (i = 0; i < arraylen && avio_tell(ioc) < max_pos - 1; i++)\n            if (amf_parse_object(s, NULL, NULL, NULL, max_pos,\n                                 depth + 1) < 0)\n                return -1;      // if we couldn't skip, bomb out.\n    }\n    break;\n    case AMF_DATA_TYPE_DATE:\n        avio_skip(ioc, 8 + 2);  // timestamp (double) and UTC offset (int16)\n        break;\n    default:                    // unsupported type, we couldn't skip\n        return -1;\n    }\n\n    if (key) {\n        acodec = astream ? astream->codec : NULL;\n        vcodec = vstream ? vstream->codec : NULL;\n\n        // stream info doesn't live any deeper than the first object\n        if (depth == 1) {\n            if (amf_type == AMF_DATA_TYPE_NUMBER ||\n                amf_type == AMF_DATA_TYPE_BOOL) {\n                if (!strcmp(key, \"duration\"))\n                    s->duration = num_val * AV_TIME_BASE;\n                else if (!strcmp(key, \"videodatarate\") && vcodec &&\n                         0 <= (int)(num_val * 1024.0))\n                    vcodec->bit_rate = num_val * 1024.0;\n                else if (!strcmp(key, \"audiodatarate\") && acodec &&\n                         0 <= (int)(num_val * 1024.0))\n                    acodec->bit_rate = num_val * 1024.0;\n                else if (!strcmp(key, \"datastream\")) {\n                    AVStream *st = create_stream(s, AVMEDIA_TYPE_DATA);\n                    if (!st)\n                        return AVERROR(ENOMEM);\n                    st->codec->codec_id = AV_CODEC_ID_TEXT;\n                } else if (flv->trust_metadata) {\n                    if (!strcmp(key, \"videocodecid\") && vcodec) {\n                        flv_set_video_codec(s, vstream, num_val, 0);\n                    } else if (!strcmp(key, \"audiocodecid\") && acodec) {\n                        int id = ((int)num_val) << FLV_AUDIO_CODECID_OFFSET;\n                        flv_set_audio_codec(s, astream, acodec, id);\n                    } else if (!strcmp(key, \"audiosamplerate\") && acodec) {\n                        acodec->sample_rate = num_val;\n                    } else if (!strcmp(key, \"audiosamplesize\") && acodec) {\n                        acodec->bits_per_coded_sample = num_val;\n                    } else if (!strcmp(key, \"stereo\") && acodec) {\n                        acodec->channels       = num_val + 1;\n                        acodec->channel_layout = acodec->channels == 2 ?\n                                                 AV_CH_LAYOUT_STEREO :\n                                                 AV_CH_LAYOUT_MONO;\n                    } else if (!strcmp(key, \"width\") && vcodec) {\n                        vcodec->width = num_val;\n                    } else if (!strcmp(key, \"height\") && vcodec) {\n                        vcodec->height = num_val;\n                    }\n                }\n            }\n        }\n\n        if (amf_type == AMF_DATA_TYPE_OBJECT && s->nb_streams == 1 &&\n           ((!acodec && !strcmp(key, \"audiocodecid\")) ||\n            (!vcodec && !strcmp(key, \"videocodecid\"))))\n                s->ctx_flags &= ~AVFMTCTX_NOHEADER; //If there is either audio/video missing, codecid will be an empty object\n\n        if (!strcmp(key, \"duration\")        ||\n            !strcmp(key, \"filesize\")        ||\n            !strcmp(key, \"width\")           ||\n            !strcmp(key, \"height\")          ||\n            !strcmp(key, \"videodatarate\")   ||\n            !strcmp(key, \"framerate\")       ||\n            !strcmp(key, \"videocodecid\")    ||\n            !strcmp(key, \"audiodatarate\")   ||\n            !strcmp(key, \"audiosamplerate\") ||\n            !strcmp(key, \"audiosamplesize\") ||\n            !strcmp(key, \"stereo\")          ||\n            !strcmp(key, \"audiocodecid\")    ||\n            !strcmp(key, \"datastream\"))\n            return 0;\n\n        s->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n        if (amf_type == AMF_DATA_TYPE_BOOL) {\n            av_strlcpy(str_val, num_val > 0 ? \"true\" : \"false\",\n                       sizeof(str_val));\n            av_dict_set(&s->metadata, key, str_val, 0);\n        } else if (amf_type == AMF_DATA_TYPE_NUMBER) {\n            snprintf(str_val, sizeof(str_val), \"%.f\", num_val);\n            av_dict_set(&s->metadata, key, str_val, 0);\n        } else if (amf_type == AMF_DATA_TYPE_STRING)\n            av_dict_set(&s->metadata, key, str_val, 0);\n    }\n\n    return 0;\n}", "before_change_lines": [80, 81], "raw_before_change_lines": [80, 81, 82], "after_change_lines": [78, 79], "raw_after_change_lines": [78, 79, 80], "bug_lines": [80, 81, 82], "added": [false, false, false], "idx": 107}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1492----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_52e106e92fdff9e1f67c694f074adcb4473e0c0f_1.json----cinaudio_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_52e106e92fdff9e1f67c694f074adcb4473e0c0f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_52e106e92fdff9e1f67c694f074adcb4473e0c0f_1.json", "function_name": "cinaudio_decode_frame", "vul_func_code": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n                                 void *data, int *data_size,\n                                 AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    CinAudioContext *cin = avctx->priv_data;\n    const uint8_t *src = buf;\n    int16_t *samples = data;\n    int delta;\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n    delta = cin->delta;\n    if (cin->initial_decode_frame) {\n        cin->initial_decode_frame = 0;\n        delta = (int16_t)AV_RL16(src); src += 2;\n        *samples++ = delta;\n        buf_size -= 2;\n    }\n    while (buf_size > 0) {\n        delta += cinaudio_delta16_table[*src++];\n        delta = av_clip_int16(delta);\n        *samples++ = delta;\n        --buf_size;\n    }\n    cin->delta = delta;\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n}", "patch_func_code": "static int cinaudio_decode_frame(AVCodecContext *avctx,\n                                 void *data, int *data_size,\n                                 AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    CinAudioContext *cin = avctx->priv_data;\n    const uint8_t *buf_end = buf + avpkt->size;\n    int16_t *samples = data;\n    int delta, out_size;\n\n    out_size = (avpkt->size - cin->initial_decode_frame) *\n               av_get_bytes_per_sample(avctx->sample_fmt);\n    if (*data_size < out_size) {\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    delta = cin->delta;\n    if (cin->initial_decode_frame) {\n        cin->initial_decode_frame = 0;\n        delta = (int16_t)AV_RL16(buf);\n        buf += 2;\n        *samples++ = delta;\n    }\n    while (buf < buf_end) {\n        delta += cinaudio_delta16_table[*buf++];\n        delta = av_clip_int16(delta);\n        *samples++ = delta;\n    }\n    cin->delta = delta;\n\n    *data_size = out_size;\n\n    return avpkt->size;\n}", "before_change_lines": [6, 8, 10, 12, 17, 19, 21, 22, 25, 29, 31], "raw_before_change_lines": [6, 8, 10, 12, 17, 19, 21, 22, 25, 29, 31], "after_change_lines": [7, 9, 11, 12, 13, 14, 15, 16, 21, 22, 25, 26, 32, 34], "raw_after_change_lines": [7, 9, 11, 12, 13, 14, 15, 16, 21, 22, 25, 26, 32, 34], "bug_lines": [6, 8, 10, 12, 17, 19, 21, 22, 25, 29, 31], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 108}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "1505----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_539c43b2acfee98dd535e0a32ded95d9dd0590c5_1.json----get_format", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_539c43b2acfee98dd535e0a32ded95d9dd0590c5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_539c43b2acfee98dd535e0a32ded95d9dd0590c5_1.json", "function_name": "get_format", "vul_func_code": "static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps)\n{\n    #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL)\n    enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;\n\n    switch (sps->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUVJ420P:\n#if CONFIG_HEVC_DXVA2_HWACCEL\n        *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n#endif\n#if CONFIG_HEVC_D3D11VA_HWACCEL\n        *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n#endif\n#if CONFIG_HEVC_VAAPI_HWACCEL\n        *fmt++ = AV_PIX_FMT_VAAPI;\n#endif\n#if CONFIG_HEVC_VDPAU_HWACCEL\n        *fmt++ = AV_PIX_FMT_VDPAU;\n#endif\n        break;\n    case AV_PIX_FMT_YUV420P10:\n#if CONFIG_HEVC_DXVA2_HWACCEL\n        *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n#endif\n#if CONFIG_HEVC_D3D11VA_HWACCEL\n        *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n#endif\n#if CONFIG_HEVC_VAAPI_HWACCEL\n        *fmt++ = AV_PIX_FMT_VAAPI;\n#endif\n        break;\n    }\n\n    *fmt++ = sps->pix_fmt;\n    *fmt = AV_PIX_FMT_NONE;\n\n    return ff_get_format(s->avctx, pix_fmts);\n}", "patch_func_code": "static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps)\n{\n    #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL + CONFIG_HEVC_VAAPI_HWACCEL + CONFIG_HEVC_VDPAU_HWACCEL)\n    enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;\n\n    switch (sps->pix_fmt) {\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUVJ420P:\n#if CONFIG_HEVC_DXVA2_HWACCEL\n        *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n#endif\n#if CONFIG_HEVC_D3D11VA_HWACCEL\n        *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n#endif\n#if CONFIG_HEVC_VAAPI_HWACCEL\n        *fmt++ = AV_PIX_FMT_VAAPI;\n#endif\n#if CONFIG_HEVC_VDPAU_HWACCEL\n        *fmt++ = AV_PIX_FMT_VDPAU;\n#endif\n        break;\n    case AV_PIX_FMT_YUV420P10:\n#if CONFIG_HEVC_DXVA2_HWACCEL\n        *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n#endif\n#if CONFIG_HEVC_D3D11VA_HWACCEL\n        *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n#endif\n#if CONFIG_HEVC_VAAPI_HWACCEL\n        *fmt++ = AV_PIX_FMT_VAAPI;\n#endif\n        break;\n    }\n\n    *fmt++ = sps->pix_fmt;\n    *fmt = AV_PIX_FMT_NONE;\n\n    return ff_thread_get_format(s->avctx, pix_fmts);\n}", "before_change_lines": [38], "raw_before_change_lines": [38], "after_change_lines": [38], "raw_after_change_lines": [38], "bug_lines": [38], "added": [false], "idx": 109}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1512----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_53fbcac5b44f1be44b9826c1c320df2b2950644f_1.json----g2m_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_53fbcac5b44f1be44b9826c1c320df2b2950644f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_53fbcac5b44f1be44b9826c1c320df2b2950644f_1.json", "function_name": "g2m_decode_frame", "vul_func_code": "static int g2m_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_picture_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    G2MContext *c = avctx->priv_data;\n    AVFrame *pic = data;\n    GetByteContext bc, tbc;\n    int magic;\n    int got_header = 0;\n    uint32_t chunk_size, cur_size;\n    int chunk_type;\n    int i;\n    int ret;\n\n    if (buf_size < 12) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame should have at least 12 bytes, got %d instead\\n\",\n               buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_init(&bc, buf, buf_size);\n\n    magic = bytestream2_get_be32(&bc);\n    if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||\n        (magic & 0xF) < 2 || (magic & 0xF) > 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic %08X\\n\", magic);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((magic & 0xF) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"G2M2 and G2M3 are not yet supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    while (bytestream2_get_bytes_left(&bc) > 5) {\n        chunk_size = bytestream2_get_le32(&bc) - 1;\n        chunk_type = bytestream2_get_byte(&bc);\n        if (chunk_size > bytestream2_get_bytes_left(&bc)) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid chunk size %d type %02X\\n\",\n                   chunk_size, chunk_type);\n            break;\n        }\n        switch (chunk_type) {\n        case FRAME_INFO:\n            c->got_header = 0;\n            if (chunk_size < 21) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid frame info size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->width  = bytestream2_get_be32(&bc);\n            c->height = bytestream2_get_be32(&bc);\n            if (c->width  < 16 || c->width  > avctx->width ||\n                c->height < 16 || c->height > avctx->height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid frame dimensions %dx%d\\n\",\n                       c->width, c->height);\n                c->width = c->height = 0;\n                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n            }\n            if (c->width != avctx->width || c->height != avctx->height)\n                avcodec_set_dimensions(avctx, c->width, c->height);\n            c->compression = bytestream2_get_be32(&bc);\n            if (c->compression != 2 && c->compression != 3) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Unknown compression method %d\\n\",\n                       c->compression);\n                return AVERROR_PATCHWELCOME;\n            }\n            c->tile_width  = bytestream2_get_be32(&bc);\n            c->tile_height = bytestream2_get_be32(&bc);\n            if (!c->tile_width || !c->tile_height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile dimensions %dx%d\\n\",\n                       c->tile_width, c->tile_height);\n                return AVERROR_INVALIDDATA;\n            }\n            c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;\n            c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;\n            c->bpp = bytestream2_get_byte(&bc);\n            chunk_size -= 21;\n            bytestream2_skip(&bc, chunk_size);\n            if (g2m_init_buffers(c))\n                return AVERROR(ENOMEM);\n            got_header = 1;\n            break;\n        case TILE_DATA:\n            if (!c->tiles_x || !c->tiles_y) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"No frame header - skipping tile\\n\");\n                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n                break;\n            }\n            if (chunk_size < 2) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid tile data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->tile_x = bytestream2_get_byte(&bc);\n            c->tile_y = bytestream2_get_byte(&bc);\n            if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile pos %d,%d (in %dx%d grid)\\n\",\n                       c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);\n                break;\n            }\n            chunk_size -= 2;\n            ret = 0;\n            switch (c->compression) {\n            case COMPR_EPIC_J_B:\n                av_log(avctx, AV_LOG_ERROR,\n                       \"ePIC j-b compression is not implemented yet\\n\");\n                return AVERROR(ENOSYS);\n            case COMPR_KEMPF_J_B:\n                ret = kempf_decode_tile(c, c->tile_x, c->tile_y,\n                                        buf + bytestream2_tell(&bc),\n                                        chunk_size);\n                break;\n            }\n            if (ret && c->framebuf)\n                av_log(avctx, AV_LOG_ERROR, \"Error decoding tile %d,%d\\n\",\n                       c->tile_x, c->tile_y);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CURSOR_POS:\n            if (chunk_size < 5) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor pos size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->cursor_x = bytestream2_get_be16(&bc);\n            c->cursor_y = bytestream2_get_be16(&bc);\n            bytestream2_skip(&bc, chunk_size - 4);\n            break;\n        case CURSOR_SHAPE:\n            if (chunk_size < 8) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            bytestream2_init(&tbc, buf + bytestream2_tell(&bc),\n                             chunk_size - 4);\n            cur_size        = bytestream2_get_be32(&tbc);\n            c->cursor_w     = bytestream2_get_byte(&tbc);\n            c->cursor_h     = bytestream2_get_byte(&tbc);\n            c->cursor_hot_x = bytestream2_get_byte(&tbc);\n            c->cursor_hot_y = bytestream2_get_byte(&tbc);\n            c->cursor_fmt   = bytestream2_get_byte(&tbc);\n            if (cur_size >= chunk_size ||\n                c->cursor_w * c->cursor_h / 4 > cur_size) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            g2m_load_cursor(c, &tbc);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CHUNK_CC:\n        case CHUNK_CD:\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        default:\n            av_log(avctx, AV_LOG_WARNING, \"Skipping chunk type %02X\\n\",\n                   chunk_type);\n            bytestream2_skip(&bc, chunk_size);\n        }\n    }\n    if (got_header)\n        c->got_header = 1;\n\n    if (c->width && c->height && c->framebuf) {\n        if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n            return ret;\n        }\n\n        pic->key_frame = got_header;\n        pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n        for (i = 0; i < avctx->height; i++)\n            memcpy(pic->data[0] + i * pic->linesize[0],\n                   c->framebuf  + i * c->framebuf_stride,\n                   c->width * 3);\n        g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);\n\n        *got_picture_ptr = 1;\n    }\n\n    return buf_size;\n}", "patch_func_code": "static int g2m_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_picture_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    G2MContext *c = avctx->priv_data;\n    AVFrame *pic = data;\n    GetByteContext bc, tbc;\n    int magic;\n    int got_header = 0;\n    uint32_t chunk_size, cur_size;\n    int chunk_type;\n    int i;\n    int ret;\n    int cursor_w, cursor_h, cursor_hot_x, cursor_hot_y, cursor_fmt;\n\n    if (buf_size < 12) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Frame should have at least 12 bytes, got %d instead\\n\",\n               buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_init(&bc, buf, buf_size);\n\n    magic = bytestream2_get_be32(&bc);\n    if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||\n        (magic & 0xF) < 2 || (magic & 0xF) > 4) {\n        av_log(avctx, AV_LOG_ERROR, \"Wrong magic %08X\\n\", magic);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((magic & 0xF) != 4) {\n        av_log(avctx, AV_LOG_ERROR, \"G2M2 and G2M3 are not yet supported\\n\");\n        return AVERROR(ENOSYS);\n    }\n\n    while (bytestream2_get_bytes_left(&bc) > 5) {\n        chunk_size = bytestream2_get_le32(&bc) - 1;\n        chunk_type = bytestream2_get_byte(&bc);\n        if (chunk_size > bytestream2_get_bytes_left(&bc)) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid chunk size %d type %02X\\n\",\n                   chunk_size, chunk_type);\n            break;\n        }\n        switch (chunk_type) {\n        case FRAME_INFO:\n            c->got_header = 0;\n            if (chunk_size < 21) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid frame info size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->width  = bytestream2_get_be32(&bc);\n            c->height = bytestream2_get_be32(&bc);\n            if (c->width  < 16 || c->width  > avctx->width ||\n                c->height < 16 || c->height > avctx->height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid frame dimensions %dx%d\\n\",\n                       c->width, c->height);\n                c->width = c->height = 0;\n                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n            }\n            if (c->width != avctx->width || c->height != avctx->height)\n                avcodec_set_dimensions(avctx, c->width, c->height);\n            c->compression = bytestream2_get_be32(&bc);\n            if (c->compression != 2 && c->compression != 3) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Unknown compression method %d\\n\",\n                       c->compression);\n                return AVERROR_PATCHWELCOME;\n            }\n            c->tile_width  = bytestream2_get_be32(&bc);\n            c->tile_height = bytestream2_get_be32(&bc);\n            if (!c->tile_width || !c->tile_height) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile dimensions %dx%d\\n\",\n                       c->tile_width, c->tile_height);\n                return AVERROR_INVALIDDATA;\n            }\n            c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;\n            c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;\n            c->bpp = bytestream2_get_byte(&bc);\n            chunk_size -= 21;\n            bytestream2_skip(&bc, chunk_size);\n            if (g2m_init_buffers(c))\n                return AVERROR(ENOMEM);\n            got_header = 1;\n            break;\n        case TILE_DATA:\n            if (!c->tiles_x || !c->tiles_y) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"No frame header - skipping tile\\n\");\n                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n                break;\n            }\n            if (chunk_size < 2) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid tile data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->tile_x = bytestream2_get_byte(&bc);\n            c->tile_y = bytestream2_get_byte(&bc);\n            if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Invalid tile pos %d,%d (in %dx%d grid)\\n\",\n                       c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);\n                break;\n            }\n            chunk_size -= 2;\n            ret = 0;\n            switch (c->compression) {\n            case COMPR_EPIC_J_B:\n                av_log(avctx, AV_LOG_ERROR,\n                       \"ePIC j-b compression is not implemented yet\\n\");\n                return AVERROR(ENOSYS);\n            case COMPR_KEMPF_J_B:\n                ret = kempf_decode_tile(c, c->tile_x, c->tile_y,\n                                        buf + bytestream2_tell(&bc),\n                                        chunk_size);\n                break;\n            }\n            if (ret && c->framebuf)\n                av_log(avctx, AV_LOG_ERROR, \"Error decoding tile %d,%d\\n\",\n                       c->tile_x, c->tile_y);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CURSOR_POS:\n            if (chunk_size < 5) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor pos size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->cursor_x = bytestream2_get_be16(&bc);\n            c->cursor_y = bytestream2_get_be16(&bc);\n            bytestream2_skip(&bc, chunk_size - 4);\n            break;\n        case CURSOR_SHAPE:\n            if (chunk_size < 8) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            bytestream2_init(&tbc, buf + bytestream2_tell(&bc),\n                             chunk_size - 4);\n            cur_size        = bytestream2_get_be32(&tbc);\n            cursor_w        = bytestream2_get_byte(&tbc);\n            cursor_h        = bytestream2_get_byte(&tbc);\n            cursor_hot_x    = bytestream2_get_byte(&tbc);\n            cursor_hot_y    = bytestream2_get_byte(&tbc);\n            cursor_fmt      = bytestream2_get_byte(&tbc);\n            if (cur_size >= chunk_size ||\n                c->cursor_w * c->cursor_h / 4 > cur_size) {\n                av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",\n                       chunk_size);\n                break;\n            }\n            c->cursor_w     = cursor_w;\n            c->cursor_h     = cursor_h;\n            c->cursor_hot_x = cursor_hot_x;\n            c->cursor_hot_y = cursor_hot_y;\n            c->cursor_fmt   = cursor_fmt;\n            g2m_load_cursor(c, &tbc);\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        case CHUNK_CC:\n        case CHUNK_CD:\n            bytestream2_skip(&bc, chunk_size);\n            break;\n        default:\n            av_log(avctx, AV_LOG_WARNING, \"Skipping chunk type %02X\\n\",\n                   chunk_type);\n            bytestream2_skip(&bc, chunk_size);\n        }\n    }\n    if (got_header)\n        c->got_header = 1;\n\n    if (c->width && c->height && c->framebuf) {\n        if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n            return ret;\n        }\n\n        pic->key_frame = got_header;\n        pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n        for (i = 0; i < avctx->height; i++)\n            memcpy(pic->data[0] + i * pic->linesize[0],\n                   c->framebuf  + i * c->framebuf_stride,\n                   c->width * 3);\n        g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);\n\n        *got_picture_ptr = 1;\n    }\n\n    return buf_size;\n}", "before_change_lines": [146, 147, 148, 149, 150], "raw_before_change_lines": [146, 147, 148, 149, 150], "after_change_lines": [15, 147, 148, 149, 150, 151, 158, 159, 160, 161, 162], "raw_after_change_lines": [15, 147, 148, 149, 150, 151, 158, 159, 160, 161, 162], "bug_lines": [146, 147, 148, 149, 150], "added": [false, false, false, false, false], "idx": 110}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1535----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_554330e3fa92f3008f5301a523363dbdf3a0f070_1.json----decode_nal_sei_prefix", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_554330e3fa92f3008f5301a523363dbdf3a0f070_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_554330e3fa92f3008f5301a523363dbdf3a0f070_1.json", "function_name": "decode_nal_sei_prefix", "vul_func_code": "static int decode_nal_sei_prefix(GetBitContext *gb, HEVCSEIContext *s, const HEVCParamSets *ps,\n                                 int type, int size, void *logctx)\n{\n    switch (type) {\n    case 256:  // Mismatched value from HM 8.1\n        return decode_nal_sei_decoded_picture_hash(&s->picture_hash, gb);\n    case HEVC_SEI_TYPE_FRAME_PACKING:\n        return decode_nal_sei_frame_packing_arrangement(&s->frame_packing, gb);\n    case HEVC_SEI_TYPE_DISPLAY_ORIENTATION:\n        return decode_nal_sei_display_orientation(&s->display_orientation, gb);\n    case HEVC_SEI_TYPE_PICTURE_TIMING:\n        {\n            int ret = decode_pic_timing(s, gb, ps, logctx);\n            av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n            skip_bits(gb, 8 * size);\n            return ret;\n        }\n    case HEVC_SEI_TYPE_MASTERING_DISPLAY_INFO:\n        return decode_nal_sei_mastering_display_info(&s->mastering_display, gb);\n    case HEVC_SEI_TYPE_CONTENT_LIGHT_LEVEL_INFO:\n        return decode_nal_sei_content_light_info(&s->content_light, gb);\n    case HEVC_SEI_TYPE_ACTIVE_PARAMETER_SETS:\n        active_parameter_sets(s, gb, logctx);\n        av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n        return 0;\n    case HEVC_SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35:\n        return decode_nal_sei_user_data_registered_itu_t_t35(s, gb, size);\n    default:\n        av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n        skip_bits_long(gb, 8 * size);\n        return 0;\n    }\n}", "patch_func_code": "static int decode_nal_sei_prefix(GetBitContext *gb, HEVCSEIContext *s, const HEVCParamSets *ps,\n                                 int type, int size, void *logctx)\n{\n    switch (type) {\n    case 256:  // Mismatched value from HM 8.1\n        return decode_nal_sei_decoded_picture_hash(&s->picture_hash, gb);\n    case HEVC_SEI_TYPE_FRAME_PACKING:\n        return decode_nal_sei_frame_packing_arrangement(&s->frame_packing, gb);\n    case HEVC_SEI_TYPE_DISPLAY_ORIENTATION:\n        return decode_nal_sei_display_orientation(&s->display_orientation, gb);\n    case HEVC_SEI_TYPE_PICTURE_TIMING:\n        return decode_nal_sei_pic_timing(s, gb, ps, logctx, size);\n    case HEVC_SEI_TYPE_MASTERING_DISPLAY_INFO:\n        return decode_nal_sei_mastering_display_info(&s->mastering_display, gb);\n    case HEVC_SEI_TYPE_CONTENT_LIGHT_LEVEL_INFO:\n        return decode_nal_sei_content_light_info(&s->content_light, gb);\n    case HEVC_SEI_TYPE_ACTIVE_PARAMETER_SETS:\n        active_parameter_sets(s, gb, logctx);\n        av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n        return 0;\n    case HEVC_SEI_TYPE_USER_DATA_REGISTERED_ITU_T_T35:\n        return decode_nal_sei_user_data_registered_itu_t_t35(s, gb, size);\n    default:\n        av_log(logctx, AV_LOG_DEBUG, \"Skipped PREFIX SEI %d\\n\", type);\n        skip_bits_long(gb, 8 * size);\n        return 0;\n    }\n}", "before_change_lines": [12, 13, 14, 15, 16, 17], "raw_before_change_lines": [12, 13, 14, 15, 16, 17], "after_change_lines": [12], "raw_after_change_lines": [12], "bug_lines": [12, 13, 14, 15, 16, 17], "added": [false, false, false, false, false, false], "idx": 111}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1546----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5602392c6b7966ca628d035fdc8f8143d102a79f_1.json----mv_pred_direct", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_5602392c6b7966ca628d035fdc8f8143d102a79f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5602392c6b7966ca628d035fdc8f8143d102a79f_1.json", "function_name": "mv_pred_direct", "vul_func_code": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n                                  cavs_vector *col_mv)\n{\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n    int den = h->direct_den[col_mv->ref];\n    int m = FF_SIGNBIT(col_mv->x);\n\n    pmv_fw->dist = h->dist[1];\n    pmv_bw->dist = h->dist[0];\n    pmv_fw->ref = 1;\n    pmv_bw->ref = 0;\n    /* scale the co-located motion vector according to its temporal span */\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n    m = FF_SIGNBIT(col_mv->y);\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n}", "patch_func_code": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n                                  cavs_vector *col_mv)\n{\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n    unsigned den = h->direct_den[col_mv->ref];\n    int m = FF_SIGNBIT(col_mv->x);\n\n    pmv_fw->dist = h->dist[1];\n    pmv_bw->dist = h->dist[0];\n    pmv_fw->ref = 1;\n    pmv_bw->ref = 0;\n    /* scale the co-located motion vector according to its temporal span */\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n    m = FF_SIGNBIT(col_mv->y);\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5], "added": [false], "idx": 112}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1565----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_573f195ba032beef6bef422f9054e8aab866a360_1.json----bfi_read_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_573f195ba032beef6bef422f9054e8aab866a360_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_573f195ba032beef6bef422f9054e8aab866a360_1.json", "function_name": "bfi_read_header", "vul_func_code": "static int bfi_read_header(AVFormatContext * s)\n{\n    BFIContext *bfi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *vstream;\n    AVStream *astream;\n    int fps, chunk_header;\n\n    /* Initialize the video codec... */\n    vstream = avformat_new_stream(s, NULL);\n    if (!vstream)\n        return AVERROR(ENOMEM);\n\n    /* Initialize the audio codec... */\n    astream = avformat_new_stream(s, NULL);\n    if (!astream)\n        return AVERROR(ENOMEM);\n\n    /* Set the total number of frames. */\n    avio_skip(pb, 8);\n    chunk_header           = avio_rl32(pb);\n    bfi->nframes           = avio_rl32(pb);\n    avio_rl32(pb);\n    avio_rl32(pb);\n    avio_rl32(pb);\n    fps                    = avio_rl32(pb);\n    avio_skip(pb, 12);\n    vstream->codecpar->width  = avio_rl32(pb);\n    vstream->codecpar->height = avio_rl32(pb);\n\n    /*Load the palette to extradata */\n    avio_skip(pb, 8);\n    vstream->codecpar->extradata      = av_malloc(768);\n    if (!vstream->codecpar->extradata)\n        return AVERROR(ENOMEM);\n    vstream->codecpar->extradata_size = 768;\n    avio_read(pb, vstream->codecpar->extradata,\n               vstream->codecpar->extradata_size);\n\n    astream->codecpar->sample_rate = avio_rl32(pb);\n    if (astream->codecpar->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", astream->codecpar->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Set up the video codec... */\n    avpriv_set_pts_info(vstream, 32, 1, fps);\n    vstream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    vstream->codecpar->codec_id   = AV_CODEC_ID_BFI;\n    vstream->codecpar->format     = AV_PIX_FMT_PAL8;\n    vstream->nb_frames            =\n    vstream->duration             = bfi->nframes;\n\n    /* Set up the audio codec now... */\n    astream->codecpar->codec_type      = AVMEDIA_TYPE_AUDIO;\n    astream->codecpar->codec_id        = AV_CODEC_ID_PCM_U8;\n    astream->codecpar->channels        = 1;\n    astream->codecpar->channel_layout  = AV_CH_LAYOUT_MONO;\n    astream->codecpar->bits_per_coded_sample = 8;\n    astream->codecpar->bit_rate        =\n        astream->codecpar->sample_rate * astream->codecpar->bits_per_coded_sample;\n    avio_seek(pb, chunk_header - 3, SEEK_SET);\n    avpriv_set_pts_info(astream, 64, 1, astream->codecpar->sample_rate);\n    return 0;\n}", "patch_func_code": "static int bfi_read_header(AVFormatContext * s)\n{\n    BFIContext *bfi = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *vstream;\n    AVStream *astream;\n    int fps, chunk_header;\n\n    /* Initialize the video codec... */\n    vstream = avformat_new_stream(s, NULL);\n    if (!vstream)\n        return AVERROR(ENOMEM);\n\n    /* Initialize the audio codec... */\n    astream = avformat_new_stream(s, NULL);\n    if (!astream)\n        return AVERROR(ENOMEM);\n\n    /* Set the total number of frames. */\n    avio_skip(pb, 8);\n    chunk_header           = avio_rl32(pb);\n    bfi->nframes           = avio_rl32(pb);\n    avio_rl32(pb);\n    avio_rl32(pb);\n    avio_rl32(pb);\n    fps                    = avio_rl32(pb);\n    avio_skip(pb, 12);\n    vstream->codecpar->width  = avio_rl32(pb);\n    vstream->codecpar->height = avio_rl32(pb);\n\n    /*Load the palette to extradata */\n    avio_skip(pb, 8);\n    vstream->codecpar->extradata      = av_malloc(768);\n    if (!vstream->codecpar->extradata)\n        return AVERROR(ENOMEM);\n    vstream->codecpar->extradata_size = 768;\n    avio_read(pb, vstream->codecpar->extradata,\n               vstream->codecpar->extradata_size);\n\n    astream->codecpar->sample_rate = avio_rl32(pb);\n    if (astream->codecpar->sample_rate <= 0) {\n        av_log(s, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", astream->codecpar->sample_rate);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* Set up the video codec... */\n    avpriv_set_pts_info(vstream, 32, 1, fps);\n    vstream->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    vstream->codecpar->codec_id   = AV_CODEC_ID_BFI;\n    vstream->codecpar->format     = AV_PIX_FMT_PAL8;\n    vstream->nb_frames            =\n    vstream->duration             = bfi->nframes;\n\n    /* Set up the audio codec now... */\n    astream->codecpar->codec_type      = AVMEDIA_TYPE_AUDIO;\n    astream->codecpar->codec_id        = AV_CODEC_ID_PCM_U8;\n    astream->codecpar->channels        = 1;\n    astream->codecpar->channel_layout  = AV_CH_LAYOUT_MONO;\n    astream->codecpar->bits_per_coded_sample = 8;\n    astream->codecpar->bit_rate        =\n        (int64_t)astream->codecpar->sample_rate * astream->codecpar->bits_per_coded_sample;\n    avio_seek(pb, chunk_header - 3, SEEK_SET);\n    avpriv_set_pts_info(astream, 64, 1, astream->codecpar->sample_rate);\n    return 0;\n}", "before_change_lines": [61], "raw_before_change_lines": [61], "after_change_lines": [61], "raw_after_change_lines": [61], "bug_lines": [61], "added": [false], "idx": 113}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1573----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_57e4d1b2ee68faf7e72e7eb741a6ba481ed13a99_1.json----output_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_57e4d1b2ee68faf7e72e7eb741a6ba481ed13a99_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_57e4d1b2ee68faf7e72e7eb741a6ba481ed13a99_1.json", "function_name": "output_frame", "vul_func_code": "static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n{\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    if (!h->sps.crop)\n        return 0;\n\n    for (i = 0; i < 3; i++) {\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}", "patch_func_code": "static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)\n{\n    AVFrame *src = &srcp->f;\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    if (!srcp->crop)\n        return 0;\n\n    for (i = 0; i < 3; i++) {\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +\n            (srcp->crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}", "before_change_lines": [1, 8, 14, 15], "raw_before_change_lines": [1, 8, 14, 15], "after_change_lines": [1, 3, 9, 15, 16], "raw_after_change_lines": [1, 3, 9, 15, 16], "bug_lines": [1, 8, 14, 15], "added": [false, false, false, false], "idx": 114}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "1582----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_585255eed3ce6685ba43022e63aa9ffe744a0871_1.json----matroska_parse_block", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_585255eed3ce6685ba43022e63aa9ffe744a0871_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_585255eed3ce6685ba43022e63aa9ffe744a0871_1.json", "function_name": "matroska_parse_block", "vul_func_code": "static int\nmatroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            if (size == 0) {\n                res = -1;\n                break;\n            }\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int offset = 0;\n\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, lace_size[n]-offset) < 0) {\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                memcpy (pkt->data, data+offset, lace_size[n]-offset);\n\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n\n                matroska_queue_packet(matroska, pkt);\n            }\n\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "patch_func_code": "static int\nmatroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            if (size == 0) {\n                res = -1;\n                break;\n            }\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int offset = 0;\n\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, lace_size[n]-offset) < 0) {\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                memcpy (pkt->data, data+offset, lace_size[n]-offset);\n\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n\n                matroska_queue_packet(matroska, pkt);\n            }\n\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "before_change_lines": [35], "raw_before_change_lines": [35], "after_change_lines": [35], "raw_after_change_lines": [35], "bug_lines": [35], "added": [false], "idx": 115}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1614----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5a7328fc29c8630147b4b2f19d350e1af8828f5e_1.json----ff_h263_decode_picture_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_5a7328fc29c8630147b4b2f19d350e1af8828f5e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5a7328fc29c8630147b4b2f19d350e1af8828f5e_1.json", "function_name": "ff_h263_decode_picture_header", "vul_func_code": "int ff_h263_decode_picture_header(MpegEncContext *s)\n{\n    int format, width, height, i;\n    uint32_t startcode;\n\n    align_get_bits(&s->gb);\n\n    if (show_bits(&s->gb, 2) == 2 && s->avctx->frame_number == 0) {\n         av_log(s->avctx, AV_LOG_WARNING, \"Header looks like RTP instead of H.263\\n\");\n    }\n\n    startcode= get_bits(&s->gb, 22-8);\n\n    for(i= get_bits_left(&s->gb); i>24; i-=8) {\n        startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF;\n\n        if(startcode == 0x20)\n            break;\n    }\n\n    if (startcode != 0x20) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n        return -1;\n    }\n    /* temporal reference */\n    i = get_bits(&s->gb, 8); /* picture timestamp */\n    if( (s->picture_number&~0xFF)+i < s->picture_number)\n        i+= 256;\n    s->picture_number= (s->picture_number&~0xFF) + i;\n\n    /* PTYPE starts here */\n    if (get_bits1(&s->gb) != 1) {\n        /* marker */\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n        return -1;\n    }\n    if (get_bits1(&s->gb) != 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n        return -1;      /* h263 id */\n    }\n    skip_bits1(&s->gb);         /* split screen off */\n    skip_bits1(&s->gb);         /* camera  off */\n    skip_bits1(&s->gb);         /* freeze picture release off */\n\n    format = get_bits(&s->gb, 3);\n    /*\n        0    forbidden\n        1    sub-QCIF\n        10   QCIF\n        7       extended PTYPE (PLUSPTYPE)\n    */\n\n    if (format != 7 && format != 6) {\n        s->h263_plus = 0;\n        /* H.263v1 */\n        width = ff_h263_format[format][0];\n        height = ff_h263_format[format][1];\n        if (!width)\n            return -1;\n\n        s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb);\n\n        s->h263_long_vectors = get_bits1(&s->gb);\n\n        if (get_bits1(&s->gb) != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"H263 SAC not supported\\n\");\n            return -1; /* SAC: off */\n        }\n        s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n        s->unrestricted_mv = s->h263_long_vectors || s->obmc;\n\n        s->pb_frame = get_bits1(&s->gb);\n        s->chroma_qscale= s->qscale = get_bits(&s->gb, 5);\n        skip_bits1(&s->gb); /* Continuous Presence Multipoint mode: off */\n\n        s->width = width;\n        s->height = height;\n        s->avctx->sample_aspect_ratio= (AVRational){12,11};\n        s->avctx->framerate = (AVRational){ 30000, 1001 };\n    } else {\n        int ufep;\n\n        /* H.263v2 */\n        s->h263_plus = 1;\n        ufep = get_bits(&s->gb, 3); /* Update Full Extended PTYPE */\n\n        /* ufep other than 0 and 1 are reserved */\n        if (ufep == 1) {\n            /* OPPTYPE */\n            format = get_bits(&s->gb, 3);\n            av_dlog(s->avctx, \"ufep=1, format: %d\\n\", format);\n            s->custom_pcf= get_bits1(&s->gb);\n            s->umvplus = get_bits1(&s->gb); /* Unrestricted Motion Vector */\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Syntax-based Arithmetic Coding (SAC) not supported\\n\");\n            }\n            s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n            s->h263_aic = get_bits1(&s->gb); /* Advanced Intra Coding (AIC) */\n            s->loop_filter= get_bits1(&s->gb);\n            s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter;\n            if(s->avctx->lowres)\n                s->loop_filter = 0;\n\n            s->h263_slice_structured= get_bits1(&s->gb);\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Reference Picture Selection not supported\\n\");\n            }\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Independent Segment Decoding not supported\\n\");\n            }\n            s->alt_inter_vlc= get_bits1(&s->gb);\n            s->modified_quant= get_bits1(&s->gb);\n            if(s->modified_quant)\n                s->chroma_qscale_table= ff_h263_chroma_qscale_table;\n\n            skip_bits(&s->gb, 1); /* Prevent start code emulation */\n\n            skip_bits(&s->gb, 3); /* Reserved */\n        } else if (ufep != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Bad UFEP type (%d)\\n\", ufep);\n            return -1;\n        }\n\n        /* MPPTYPE */\n        s->pict_type = get_bits(&s->gb, 3);\n        switch(s->pict_type){\n        case 0: s->pict_type= AV_PICTURE_TYPE_I;break;\n        case 1: s->pict_type= AV_PICTURE_TYPE_P;break;\n        case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break;\n        case 3: s->pict_type= AV_PICTURE_TYPE_B;break;\n        case 7: s->pict_type= AV_PICTURE_TYPE_I;break; //ZYGO\n        default:\n            return -1;\n        }\n        skip_bits(&s->gb, 2);\n        s->no_rounding = get_bits1(&s->gb);\n        skip_bits(&s->gb, 4);\n\n        /* Get the picture dimensions */\n        if (ufep) {\n            if (format == 6) {\n                /* Custom Picture Format (CPFMT) */\n                s->aspect_ratio_info = get_bits(&s->gb, 4);\n                av_dlog(s->avctx, \"aspect: %d\\n\", s->aspect_ratio_info);\n                /* aspect ratios:\n                0 - forbidden\n                1 - 1:1\n                2 - 12:11 (CIF 4:3)\n                3 - 10:11 (525-type 4:3)\n                4 - 16:11 (CIF 16:9)\n                5 - 40:33 (525-type 16:9)\n                6-14 - reserved\n                */\n                width = (get_bits(&s->gb, 9) + 1) * 4;\n                skip_bits1(&s->gb);\n                height = get_bits(&s->gb, 9) * 4;\n                av_dlog(s->avctx, \"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n                if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                    /* aspected dimensions */\n                    s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8);\n                    s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8);\n                }else{\n                    s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info];\n                }\n            } else {\n                width = ff_h263_format[format][0];\n                height = ff_h263_format[format][1];\n                s->avctx->sample_aspect_ratio= (AVRational){12,11};\n            }\n            s->avctx->sample_aspect_ratio.den <<= s->ehc_mode;\n            if ((width == 0) || (height == 0))\n                return -1;\n            s->width = width;\n            s->height = height;\n\n            if(s->custom_pcf){\n                int gcd;\n                s->avctx->framerate.num  = 1800000;\n                s->avctx->framerate.den  = 1000 + get_bits1(&s->gb);\n                s->avctx->framerate.den *= get_bits(&s->gb, 7);\n                if(s->avctx->framerate.den == 0){\n                    av_log(s, AV_LOG_ERROR, \"zero framerate\\n\");\n                    return -1;\n                }\n                gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num);\n                s->avctx->framerate.den /= gcd;\n                s->avctx->framerate.num /= gcd;\n            }else{\n                s->avctx->framerate = (AVRational){ 30000, 1001 };\n            }\n        }\n\n        if(s->custom_pcf){\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        }\n\n        if (ufep) {\n            if (s->umvplus) {\n                if(get_bits1(&s->gb)==0) /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n                    skip_bits1(&s->gb);\n            }\n            if(s->h263_slice_structured){\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"rectangular slices not supported\\n\");\n                }\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"unordered slices not supported\\n\");\n                }\n            }\n        }\n\n        s->qscale = get_bits(&s->gb, 5);\n    }\n\n    if (s->width == 0 || s->height == 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"dimensions 0\\n\");\n        return -1;\n    }\n    s->mb_width = (s->width  + 15) / 16;\n    s->mb_height = (s->height  + 15) / 16;\n    s->mb_num = s->mb_width * s->mb_height;\n\n    if (s->pb_frame) {\n        skip_bits(&s->gb, 3); /* Temporal reference for B-pictures */\n        if (s->custom_pcf)\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        skip_bits(&s->gb, 2); /* Quantization information for B-pictures */\n    }\n\n    if (s->pict_type!=AV_PICTURE_TYPE_B) {\n        s->time            = s->picture_number;\n        s->pp_time         = s->time - s->last_non_b_time;\n        s->last_non_b_time = s->time;\n    }else{\n        s->time    = s->picture_number;\n        s->pb_time = s->pp_time - (s->last_non_b_time - s->time);\n        if (s->pp_time <=s->pb_time ||\n            s->pp_time <= s->pp_time - s->pb_time ||\n            s->pp_time <= 0){\n            s->pp_time = 2;\n            s->pb_time = 1;\n        }\n        ff_mpeg4_init_direct_mv(s);\n    }\n\n    /* PEI */\n    if (skip_1stop_8data_bits(&s->gb) < 0)\n        return AVERROR_INVALIDDATA;\n\n    if(s->h263_slice_structured){\n        if (get_bits1(&s->gb) != 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"SEPB1 marker missing\\n\");\n            return -1;\n        }\n\n        ff_h263_decode_mba(s);\n\n        if (get_bits1(&s->gb) != 1) {\n            av_log(s->avctx, AV_LOG_ERROR, \"SEPB2 marker missing\\n\");\n            return -1;\n        }\n    }\n    s->f_code = 1;\n\n    if(s->h263_aic){\n         s->y_dc_scale_table=\n         s->c_dc_scale_table= ff_aic_dc_scale_table;\n    }else{\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n    }\n\n        ff_h263_show_pict_info(s);\n    if (s->pict_type == AV_PICTURE_TYPE_I && s->codec_tag == AV_RL32(\"ZYGO\") && get_bits_left(&s->gb) >= 85 + 13*3*16 + 50){\n        int i,j;\n        for(i=0; i<85; i++) av_log(s->avctx, AV_LOG_DEBUG, \"%d\", get_bits1(&s->gb));\n        av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        for(i=0; i<13; i++){\n            for(j=0; j<3; j++){\n                int v= get_bits(&s->gb, 8);\n                v |= get_sbits(&s->gb, 8)<<8;\n                av_log(s->avctx, AV_LOG_DEBUG, \" %5d\", v);\n            }\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        }\n        for(i=0; i<50; i++) av_log(s->avctx, AV_LOG_DEBUG, \"%d\", get_bits1(&s->gb));\n    }\n\n    return 0;\n}", "patch_func_code": "int ff_h263_decode_picture_header(MpegEncContext *s)\n{\n    int format, width, height, i;\n    uint32_t startcode;\n\n    align_get_bits(&s->gb);\n\n    if (show_bits(&s->gb, 2) == 2 && s->avctx->frame_number == 0) {\n         av_log(s->avctx, AV_LOG_WARNING, \"Header looks like RTP instead of H.263\\n\");\n    }\n\n    startcode= get_bits(&s->gb, 22-8);\n\n    for(i= get_bits_left(&s->gb); i>24; i-=8) {\n        startcode = ((startcode << 8) | get_bits(&s->gb, 8)) & 0x003FFFFF;\n\n        if(startcode == 0x20)\n            break;\n    }\n\n    if (startcode != 0x20) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n        return -1;\n    }\n    /* temporal reference */\n    i = get_bits(&s->gb, 8); /* picture timestamp */\n    if( (s->picture_number&~0xFF)+i < s->picture_number)\n        i+= 256;\n    s->picture_number= (s->picture_number&~0xFF) + i;\n\n    /* PTYPE starts here */\n    if (check_marker(&s->gb, \"in PTYPE\") != 1) {\n        return -1;\n    }\n    if (get_bits1(&s->gb) != 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n        return -1;      /* h263 id */\n    }\n    skip_bits1(&s->gb);         /* split screen off */\n    skip_bits1(&s->gb);         /* camera  off */\n    skip_bits1(&s->gb);         /* freeze picture release off */\n\n    format = get_bits(&s->gb, 3);\n    /*\n        0    forbidden\n        1    sub-QCIF\n        10   QCIF\n        7       extended PTYPE (PLUSPTYPE)\n    */\n\n    if (format != 7 && format != 6) {\n        s->h263_plus = 0;\n        /* H.263v1 */\n        width = ff_h263_format[format][0];\n        height = ff_h263_format[format][1];\n        if (!width)\n            return -1;\n\n        s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb);\n\n        s->h263_long_vectors = get_bits1(&s->gb);\n\n        if (get_bits1(&s->gb) != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"H263 SAC not supported\\n\");\n            return -1; /* SAC: off */\n        }\n        s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n        s->unrestricted_mv = s->h263_long_vectors || s->obmc;\n\n        s->pb_frame = get_bits1(&s->gb);\n        s->chroma_qscale= s->qscale = get_bits(&s->gb, 5);\n        skip_bits1(&s->gb); /* Continuous Presence Multipoint mode: off */\n\n        s->width = width;\n        s->height = height;\n        s->avctx->sample_aspect_ratio= (AVRational){12,11};\n        s->avctx->framerate = (AVRational){ 30000, 1001 };\n    } else {\n        int ufep;\n\n        /* H.263v2 */\n        s->h263_plus = 1;\n        ufep = get_bits(&s->gb, 3); /* Update Full Extended PTYPE */\n\n        /* ufep other than 0 and 1 are reserved */\n        if (ufep == 1) {\n            /* OPPTYPE */\n            format = get_bits(&s->gb, 3);\n            av_dlog(s->avctx, \"ufep=1, format: %d\\n\", format);\n            s->custom_pcf= get_bits1(&s->gb);\n            s->umvplus = get_bits1(&s->gb); /* Unrestricted Motion Vector */\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Syntax-based Arithmetic Coding (SAC) not supported\\n\");\n            }\n            s->obmc= get_bits1(&s->gb); /* Advanced prediction mode */\n            s->h263_aic = get_bits1(&s->gb); /* Advanced Intra Coding (AIC) */\n            s->loop_filter= get_bits1(&s->gb);\n            s->unrestricted_mv = s->umvplus || s->obmc || s->loop_filter;\n            if(s->avctx->lowres)\n                s->loop_filter = 0;\n\n            s->h263_slice_structured= get_bits1(&s->gb);\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Reference Picture Selection not supported\\n\");\n            }\n            if (get_bits1(&s->gb) != 0) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Independent Segment Decoding not supported\\n\");\n            }\n            s->alt_inter_vlc= get_bits1(&s->gb);\n            s->modified_quant= get_bits1(&s->gb);\n            if(s->modified_quant)\n                s->chroma_qscale_table= ff_h263_chroma_qscale_table;\n\n            skip_bits(&s->gb, 1); /* Prevent start code emulation */\n\n            skip_bits(&s->gb, 3); /* Reserved */\n        } else if (ufep != 0) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Bad UFEP type (%d)\\n\", ufep);\n            return -1;\n        }\n\n        /* MPPTYPE */\n        s->pict_type = get_bits(&s->gb, 3);\n        switch(s->pict_type){\n        case 0: s->pict_type= AV_PICTURE_TYPE_I;break;\n        case 1: s->pict_type= AV_PICTURE_TYPE_P;break;\n        case 2: s->pict_type= AV_PICTURE_TYPE_P;s->pb_frame = 3;break;\n        case 3: s->pict_type= AV_PICTURE_TYPE_B;break;\n        case 7: s->pict_type= AV_PICTURE_TYPE_I;break; //ZYGO\n        default:\n            return -1;\n        }\n        skip_bits(&s->gb, 2);\n        s->no_rounding = get_bits1(&s->gb);\n        skip_bits(&s->gb, 4);\n\n        /* Get the picture dimensions */\n        if (ufep) {\n            if (format == 6) {\n                /* Custom Picture Format (CPFMT) */\n                s->aspect_ratio_info = get_bits(&s->gb, 4);\n                av_dlog(s->avctx, \"aspect: %d\\n\", s->aspect_ratio_info);\n                /* aspect ratios:\n                0 - forbidden\n                1 - 1:1\n                2 - 12:11 (CIF 4:3)\n                3 - 10:11 (525-type 4:3)\n                4 - 16:11 (CIF 16:9)\n                5 - 40:33 (525-type 16:9)\n                6-14 - reserved\n                */\n                width = (get_bits(&s->gb, 9) + 1) * 4;\n                check_marker(&s->gb, \"in dimensions\");\n                height = get_bits(&s->gb, 9) * 4;\n                av_dlog(s->avctx, \"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n                if (s->aspect_ratio_info == FF_ASPECT_EXTENDED) {\n                    /* aspected dimensions */\n                    s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 8);\n                    s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 8);\n                }else{\n                    s->avctx->sample_aspect_ratio= ff_h263_pixel_aspect[s->aspect_ratio_info];\n                }\n            } else {\n                width = ff_h263_format[format][0];\n                height = ff_h263_format[format][1];\n                s->avctx->sample_aspect_ratio= (AVRational){12,11};\n            }\n            s->avctx->sample_aspect_ratio.den <<= s->ehc_mode;\n            if ((width == 0) || (height == 0))\n                return -1;\n            s->width = width;\n            s->height = height;\n\n            if(s->custom_pcf){\n                int gcd;\n                s->avctx->framerate.num  = 1800000;\n                s->avctx->framerate.den  = 1000 + get_bits1(&s->gb);\n                s->avctx->framerate.den *= get_bits(&s->gb, 7);\n                if(s->avctx->framerate.den == 0){\n                    av_log(s, AV_LOG_ERROR, \"zero framerate\\n\");\n                    return -1;\n                }\n                gcd= av_gcd(s->avctx->framerate.den, s->avctx->framerate.num);\n                s->avctx->framerate.den /= gcd;\n                s->avctx->framerate.num /= gcd;\n            }else{\n                s->avctx->framerate = (AVRational){ 30000, 1001 };\n            }\n        }\n\n        if(s->custom_pcf){\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        }\n\n        if (ufep) {\n            if (s->umvplus) {\n                if(get_bits1(&s->gb)==0) /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n                    skip_bits1(&s->gb);\n            }\n            if(s->h263_slice_structured){\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"rectangular slices not supported\\n\");\n                }\n                if (get_bits1(&s->gb) != 0) {\n                    av_log(s->avctx, AV_LOG_ERROR, \"unordered slices not supported\\n\");\n                }\n            }\n        }\n\n        s->qscale = get_bits(&s->gb, 5);\n    }\n\n    if (s->width == 0 || s->height == 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"dimensions 0\\n\");\n        return -1;\n    }\n    s->mb_width = (s->width  + 15) / 16;\n    s->mb_height = (s->height  + 15) / 16;\n    s->mb_num = s->mb_width * s->mb_height;\n\n    if (s->pb_frame) {\n        skip_bits(&s->gb, 3); /* Temporal reference for B-pictures */\n        if (s->custom_pcf)\n            skip_bits(&s->gb, 2); //extended Temporal reference\n        skip_bits(&s->gb, 2); /* Quantization information for B-pictures */\n    }\n\n    if (s->pict_type!=AV_PICTURE_TYPE_B) {\n        s->time            = s->picture_number;\n        s->pp_time         = s->time - s->last_non_b_time;\n        s->last_non_b_time = s->time;\n    }else{\n        s->time    = s->picture_number;\n        s->pb_time = s->pp_time - (s->last_non_b_time - s->time);\n        if (s->pp_time <=s->pb_time ||\n            s->pp_time <= s->pp_time - s->pb_time ||\n            s->pp_time <= 0){\n            s->pp_time = 2;\n            s->pb_time = 1;\n        }\n        ff_mpeg4_init_direct_mv(s);\n    }\n\n    /* PEI */\n    if (skip_1stop_8data_bits(&s->gb) < 0)\n        return AVERROR_INVALIDDATA;\n\n    if(s->h263_slice_structured){\n        if (check_marker(&s->gb, \"SEPB1\") != 1) {\n            return -1;\n        }\n\n        ff_h263_decode_mba(s);\n\n        if (check_marker(&s->gb, \"SEPB2\") != 1) {\n            return -1;\n        }\n    }\n    s->f_code = 1;\n\n    if(s->h263_aic){\n         s->y_dc_scale_table=\n         s->c_dc_scale_table= ff_aic_dc_scale_table;\n    }else{\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n    }\n\n        ff_h263_show_pict_info(s);\n    if (s->pict_type == AV_PICTURE_TYPE_I && s->codec_tag == AV_RL32(\"ZYGO\") && get_bits_left(&s->gb) >= 85 + 13*3*16 + 50){\n        int i,j;\n        for(i=0; i<85; i++) av_log(s->avctx, AV_LOG_DEBUG, \"%d\", get_bits1(&s->gb));\n        av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        for(i=0; i<13; i++){\n            for(j=0; j<3; j++){\n                int v= get_bits(&s->gb, 8);\n                v |= get_sbits(&s->gb, 8)<<8;\n                av_log(s->avctx, AV_LOG_DEBUG, \" %5d\", v);\n            }\n            av_log(s->avctx, AV_LOG_DEBUG, \"\\n\");\n        }\n        for(i=0; i<50; i++) av_log(s->avctx, AV_LOG_DEBUG, \"%d\", get_bits1(&s->gb));\n    }\n\n    return 0;\n}", "before_change_lines": [32, 34, 155, 251, 252, 258, 259], "raw_before_change_lines": [32, 33, 34, 155, 251, 252, 258, 259], "after_change_lines": [32, 153, 249, 255], "raw_after_change_lines": [32, 153, 249, 255], "bug_lines": [32, 33, 34, 155, 251, 252, 258, 259], "added": [false, false, false, false, false, false, false, false], "idx": 116}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "1635----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5bce7eb47e85106738dd3a0f4a3e16b90a59b4e0_1.json----new_video_stream", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_5bce7eb47e85106738dd3a0f4a3e16b90a59b4e0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5bce7eb47e85106738dd3a0f4a3e16b90a59b4e0_1.json", "function_name": "new_video_stream", "vul_func_code": "static void new_video_stream(AVFormatContext *oc, int file_idx)\n{\n    AVStream *st;\n    AVOutputStream *ost;\n    AVCodecContext *video_enc;\n    enum CodecID codec_id;\n    AVCodec *codec= NULL;\n\n    st = av_new_stream(oc, oc->nb_streams < nb_streamid_map ? streamid_map[oc->nb_streams] : 0);\n    if (!st) {\n        fprintf(stderr, \"Could not alloc stream\\n\");\n        ffmpeg_exit(1);\n    }\n    ost = new_output_stream(oc, file_idx);\n\n    output_codecs = grow_array(output_codecs, sizeof(*output_codecs), &nb_output_codecs, nb_output_codecs + 1);\n    if(!video_stream_copy){\n        if (video_codec_name) {\n            codec_id = find_codec_or_die(video_codec_name, AVMEDIA_TYPE_VIDEO, 1,\n                                         avcodec_opts[AVMEDIA_TYPE_VIDEO]->strict_std_compliance);\n            codec = avcodec_find_encoder_by_name(video_codec_name);\n            output_codecs[nb_output_codecs-1] = codec;\n        } else {\n            codec_id = av_guess_codec(oc->oformat, NULL, oc->filename, NULL, AVMEDIA_TYPE_VIDEO);\n            codec = avcodec_find_encoder(codec_id);\n        }\n    }\n\n    avcodec_get_context_defaults3(st->codec, codec);\n    ost->bitstream_filters = video_bitstream_filters;\n    video_bitstream_filters= NULL;\n\n    avcodec_thread_init(st->codec, thread_count);\n\n    video_enc = st->codec;\n\n    if(video_codec_tag)\n        video_enc->codec_tag= video_codec_tag;\n\n    if(   (video_global_header&1)\n       || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){\n        video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags|= CODEC_FLAG_GLOBAL_HEADER;\n    }\n    if(video_global_header&2){\n        video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags2|= CODEC_FLAG2_LOCAL_HEADER;\n    }\n\n    if (video_stream_copy) {\n        st->stream_copy = 1;\n        video_enc->codec_type = AVMEDIA_TYPE_VIDEO;\n        video_enc->sample_aspect_ratio =\n        st->sample_aspect_ratio = av_d2q(frame_aspect_ratio*frame_height/frame_width, 255);\n    } else {\n        const char *p;\n        int i;\n        AVRational fps= frame_rate.num ? frame_rate : (AVRational){25,1};\n\n        video_enc->codec_id = codec_id;\n        set_context_opts(video_enc, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM, codec);\n\n        if (codec && codec->supported_framerates && !force_fps)\n            fps = codec->supported_framerates[av_find_nearest_q_idx(fps, codec->supported_framerates)];\n        video_enc->time_base.den = fps.num;\n        video_enc->time_base.num = fps.den;\n\n        video_enc->width = frame_width;\n        video_enc->height = frame_height;\n        video_enc->sample_aspect_ratio = av_d2q(frame_aspect_ratio*video_enc->height/video_enc->width, 255);\n        video_enc->pix_fmt = frame_pix_fmt;\n        st->sample_aspect_ratio = video_enc->sample_aspect_ratio;\n\n        choose_pixel_fmt(st, codec);\n\n        if (intra_only)\n            video_enc->gop_size = 0;\n        if (video_qscale || same_quality) {\n            video_enc->flags |= CODEC_FLAG_QSCALE;\n            video_enc->global_quality=\n                st->quality = FF_QP2LAMBDA * video_qscale;\n        }\n\n        if(intra_matrix)\n            video_enc->intra_matrix = intra_matrix;\n        if(inter_matrix)\n            video_enc->inter_matrix = inter_matrix;\n\n        p= video_rc_override_string;\n        for(i=0; p; i++){\n            int start, end, q;\n            int e=sscanf(p, \"%d,%d,%d\", &start, &end, &q);\n            if(e!=3){\n                fprintf(stderr, \"error parsing rc_override\\n\");\n                ffmpeg_exit(1);\n            }\n            video_enc->rc_override=\n                av_realloc(video_enc->rc_override,\n                           sizeof(RcOverride)*(i+1));\n            video_enc->rc_override[i].start_frame= start;\n            video_enc->rc_override[i].end_frame  = end;\n            if(q>0){\n                video_enc->rc_override[i].qscale= q;\n                video_enc->rc_override[i].quality_factor= 1.0;\n            }\n            else{\n                video_enc->rc_override[i].qscale= 0;\n                video_enc->rc_override[i].quality_factor= -q/100.0;\n            }\n            p= strchr(p, '/');\n            if(p) p++;\n        }\n        video_enc->rc_override_count=i;\n        if (!video_enc->rc_initial_buffer_occupancy)\n            video_enc->rc_initial_buffer_occupancy = video_enc->rc_buffer_size*3/4;\n        video_enc->me_threshold= me_threshold;\n        video_enc->intra_dc_precision= intra_dc_precision - 8;\n\n        if (do_psnr)\n            video_enc->flags|= CODEC_FLAG_PSNR;\n\n        /* two pass mode */\n        if (do_pass) {\n            if (do_pass == 1) {\n                video_enc->flags |= CODEC_FLAG_PASS1;\n            } else {\n                video_enc->flags |= CODEC_FLAG_PASS2;\n            }\n        }\n\n        if (forced_key_frames)\n            parse_forced_key_frames(forced_key_frames, ost, video_enc);\n    }\n    if (video_language) {\n        av_metadata_set2(&st->metadata, \"language\", video_language, 0);\n        av_freep(&video_language);\n    }\n\n    /* reset some key parameters */\n    video_disable = 0;\n    av_freep(&video_codec_name);\n    av_freep(&forced_key_frames);\n    video_stream_copy = 0;\n    frame_pix_fmt = PIX_FMT_NONE;\n}", "patch_func_code": "static void new_video_stream(AVFormatContext *oc, int file_idx)\n{\n    AVStream *st;\n    AVOutputStream *ost;\n    AVCodecContext *video_enc;\n    enum CodecID codec_id = CODEC_ID_NONE;\n    AVCodec *codec= NULL;\n\n    st = av_new_stream(oc, oc->nb_streams < nb_streamid_map ? streamid_map[oc->nb_streams] : 0);\n    if (!st) {\n        fprintf(stderr, \"Could not alloc stream\\n\");\n        ffmpeg_exit(1);\n    }\n    ost = new_output_stream(oc, file_idx);\n\n    output_codecs = grow_array(output_codecs, sizeof(*output_codecs), &nb_output_codecs, nb_output_codecs + 1);\n    if(!video_stream_copy){\n        if (video_codec_name) {\n            codec_id = find_codec_or_die(video_codec_name, AVMEDIA_TYPE_VIDEO, 1,\n                                         avcodec_opts[AVMEDIA_TYPE_VIDEO]->strict_std_compliance);\n            codec = avcodec_find_encoder_by_name(video_codec_name);\n            output_codecs[nb_output_codecs-1] = codec;\n        } else {\n            codec_id = av_guess_codec(oc->oformat, NULL, oc->filename, NULL, AVMEDIA_TYPE_VIDEO);\n            codec = avcodec_find_encoder(codec_id);\n        }\n    }\n\n    avcodec_get_context_defaults3(st->codec, codec);\n    ost->bitstream_filters = video_bitstream_filters;\n    video_bitstream_filters= NULL;\n\n    avcodec_thread_init(st->codec, thread_count);\n\n    video_enc = st->codec;\n\n    if(video_codec_tag)\n        video_enc->codec_tag= video_codec_tag;\n\n    if(   (video_global_header&1)\n       || (video_global_header==0 && (oc->oformat->flags & AVFMT_GLOBALHEADER))){\n        video_enc->flags |= CODEC_FLAG_GLOBAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags|= CODEC_FLAG_GLOBAL_HEADER;\n    }\n    if(video_global_header&2){\n        video_enc->flags2 |= CODEC_FLAG2_LOCAL_HEADER;\n        avcodec_opts[AVMEDIA_TYPE_VIDEO]->flags2|= CODEC_FLAG2_LOCAL_HEADER;\n    }\n\n    if (video_stream_copy) {\n        st->stream_copy = 1;\n        video_enc->codec_type = AVMEDIA_TYPE_VIDEO;\n        video_enc->sample_aspect_ratio =\n        st->sample_aspect_ratio = av_d2q(frame_aspect_ratio*frame_height/frame_width, 255);\n    } else {\n        const char *p;\n        int i;\n        AVRational fps= frame_rate.num ? frame_rate : (AVRational){25,1};\n\n        video_enc->codec_id = codec_id;\n        set_context_opts(video_enc, avcodec_opts[AVMEDIA_TYPE_VIDEO], AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM, codec);\n\n        if (codec && codec->supported_framerates && !force_fps)\n            fps = codec->supported_framerates[av_find_nearest_q_idx(fps, codec->supported_framerates)];\n        video_enc->time_base.den = fps.num;\n        video_enc->time_base.num = fps.den;\n\n        video_enc->width = frame_width;\n        video_enc->height = frame_height;\n        video_enc->sample_aspect_ratio = av_d2q(frame_aspect_ratio*video_enc->height/video_enc->width, 255);\n        video_enc->pix_fmt = frame_pix_fmt;\n        st->sample_aspect_ratio = video_enc->sample_aspect_ratio;\n\n        choose_pixel_fmt(st, codec);\n\n        if (intra_only)\n            video_enc->gop_size = 0;\n        if (video_qscale || same_quality) {\n            video_enc->flags |= CODEC_FLAG_QSCALE;\n            video_enc->global_quality=\n                st->quality = FF_QP2LAMBDA * video_qscale;\n        }\n\n        if(intra_matrix)\n            video_enc->intra_matrix = intra_matrix;\n        if(inter_matrix)\n            video_enc->inter_matrix = inter_matrix;\n\n        p= video_rc_override_string;\n        for(i=0; p; i++){\n            int start, end, q;\n            int e=sscanf(p, \"%d,%d,%d\", &start, &end, &q);\n            if(e!=3){\n                fprintf(stderr, \"error parsing rc_override\\n\");\n                ffmpeg_exit(1);\n            }\n            video_enc->rc_override=\n                av_realloc(video_enc->rc_override,\n                           sizeof(RcOverride)*(i+1));\n            video_enc->rc_override[i].start_frame= start;\n            video_enc->rc_override[i].end_frame  = end;\n            if(q>0){\n                video_enc->rc_override[i].qscale= q;\n                video_enc->rc_override[i].quality_factor= 1.0;\n            }\n            else{\n                video_enc->rc_override[i].qscale= 0;\n                video_enc->rc_override[i].quality_factor= -q/100.0;\n            }\n            p= strchr(p, '/');\n            if(p) p++;\n        }\n        video_enc->rc_override_count=i;\n        if (!video_enc->rc_initial_buffer_occupancy)\n            video_enc->rc_initial_buffer_occupancy = video_enc->rc_buffer_size*3/4;\n        video_enc->me_threshold= me_threshold;\n        video_enc->intra_dc_precision= intra_dc_precision - 8;\n\n        if (do_psnr)\n            video_enc->flags|= CODEC_FLAG_PSNR;\n\n        /* two pass mode */\n        if (do_pass) {\n            if (do_pass == 1) {\n                video_enc->flags |= CODEC_FLAG_PASS1;\n            } else {\n                video_enc->flags |= CODEC_FLAG_PASS2;\n            }\n        }\n\n        if (forced_key_frames)\n            parse_forced_key_frames(forced_key_frames, ost, video_enc);\n    }\n    if (video_language) {\n        av_metadata_set2(&st->metadata, \"language\", video_language, 0);\n        av_freep(&video_language);\n    }\n\n    /* reset some key parameters */\n    video_disable = 0;\n    av_freep(&video_codec_name);\n    av_freep(&forced_key_frames);\n    video_stream_copy = 0;\n    frame_pix_fmt = PIX_FMT_NONE;\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6], "raw_after_change_lines": [6], "bug_lines": [6], "added": [false], "idx": 117}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "1647----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5bffbc64f3203f3ba04f4e0fc87eb3c2d1fa398f_1.json----avfilter_default_get_audio_buffer", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_5bffbc64f3203f3ba04f4e0fc87eb3c2d1fa398f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5bffbc64f3203f3ba04f4e0fc87eb3c2d1fa398f_1.json", "function_name": "avfilter_default_get_audio_buffer", "vul_func_code": "AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n                                                     int nb_samples)\n{\n    AVFilterBufferRef *samplesref = NULL;\n    int linesize[8];\n    uint8_t *data[8];\n    int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);\n\n    /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */\n    if (av_samples_alloc(data, linesize,\n                         nb_channels, nb_samples, link->format,\n                         16) < 0)\n        return NULL;\n\n    samplesref =\n        avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms,\n                                                  nb_samples, link->format,\n                                                  link->channel_layout, link->planar);\n    if (!samplesref) {\n        av_free(data[0]);\n        return NULL;\n    }\n\n    return samplesref;\n}", "patch_func_code": "AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n                                                     int nb_samples)\n{\n    AVFilterBufferRef *samplesref = NULL;\n    int linesize[8] = {0};\n    uint8_t *data[8] = {0};\n    int ch, nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);\n\n    /* right now we don't support more than 8 channels */\n    av_assert0(nb_channels <= 8);\n\n    /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */\n    if (av_samples_alloc(data, linesize,\n                         nb_channels, nb_samples,\n                         av_get_alt_sample_fmt(link->format, link->planar),\n                         16) < 0)\n        return NULL;\n\n    for (ch = 1; link->planar && ch < nb_channels; ch++)\n        linesize[ch] = linesize[0];\n    samplesref =\n        avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms,\n                                                  nb_samples, link->format,\n                                                  link->channel_layout, link->planar);\n    if (!samplesref) {\n        av_free(data[0]);\n        return NULL;\n    }\n\n    return samplesref;\n}", "before_change_lines": [5, 6, 7, 11], "raw_before_change_lines": [5, 6, 7, 11], "after_change_lines": [5, 6, 7, 10, 14, 15, 19, 20], "raw_after_change_lines": [5, 6, 7, 8, 9, 10, 14, 15, 19, 20], "bug_lines": [5, 6, 7, 11], "added": [false, false, false, false], "idx": 118}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "1680----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5d7e3f375adf06f5a67aa71a44a635bdb13feb8e_1.json----av_grow_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_5d7e3f375adf06f5a67aa71a44a635bdb13feb8e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5d7e3f375adf06f5a67aa71a44a635bdb13feb8e_1.json", "function_name": "av_grow_packet", "vul_func_code": "int av_grow_packet(AVPacket *pkt, int grow_by)\n{\n    int new_size;\n    av_assert0((unsigned)pkt->size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE);\n    if ((unsigned)grow_by >\n        INT_MAX - (pkt->size + AV_INPUT_BUFFER_PADDING_SIZE))\n        return -1;\n\n    new_size = pkt->size + grow_by + AV_INPUT_BUFFER_PADDING_SIZE;\n    if (pkt->buf) {\n        size_t data_offset;\n        uint8_t *old_data = pkt->data;\n        if (pkt->data == NULL) {\n            data_offset = 0;\n            pkt->data = pkt->buf->data;\n        } else {\n            data_offset = pkt->data - pkt->buf->data;\n            if (data_offset > INT_MAX - new_size)\n                return -1;\n        }\n\n        if (new_size + data_offset > pkt->buf->size) {\n            int ret = av_buffer_realloc(&pkt->buf, new_size + data_offset);\n            if (ret < 0) {\n                pkt->data = old_data;\n                return ret;\n            }\n            pkt->data = pkt->buf->data + data_offset;\n        }\n    } else {\n        pkt->buf = av_buffer_alloc(new_size);\n        if (!pkt->buf)\n            return AVERROR(ENOMEM);\n        memcpy(pkt->buf->data, pkt->data, pkt->size);\n        pkt->data = pkt->buf->data;\n    }\n    pkt->size += grow_by;\n    memset(pkt->data + pkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n    return 0;\n}", "patch_func_code": "int av_grow_packet(AVPacket *pkt, int grow_by)\n{\n    int new_size;\n    av_assert0((unsigned)pkt->size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE);\n    if ((unsigned)grow_by >\n        INT_MAX - (pkt->size + AV_INPUT_BUFFER_PADDING_SIZE))\n        return -1;\n\n    new_size = pkt->size + grow_by + AV_INPUT_BUFFER_PADDING_SIZE;\n    if (pkt->buf) {\n        size_t data_offset;\n        uint8_t *old_data = pkt->data;\n        if (pkt->data == NULL) {\n            data_offset = 0;\n            pkt->data = pkt->buf->data;\n        } else {\n            data_offset = pkt->data - pkt->buf->data;\n            if (data_offset > INT_MAX - new_size)\n                return -1;\n        }\n\n        if (new_size + data_offset > pkt->buf->size) {\n            int ret = av_buffer_realloc(&pkt->buf, new_size + data_offset);\n            if (ret < 0) {\n                pkt->data = old_data;\n                return ret;\n            }\n            pkt->data = pkt->buf->data + data_offset;\n        }\n    } else {\n        pkt->buf = av_buffer_alloc(new_size);\n        if (!pkt->buf)\n            return AVERROR(ENOMEM);\n        if (pkt->size > 0)\n            memcpy(pkt->buf->data, pkt->data, pkt->size);\n        pkt->data = pkt->buf->data;\n    }\n    pkt->size += grow_by;\n    memset(pkt->data + pkt->size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n    return 0;\n}", "before_change_lines": [34], "raw_before_change_lines": [34], "after_change_lines": [34, 35], "raw_after_change_lines": [34, 35], "bug_lines": [34], "added": [false], "idx": 119}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1722----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5fc0de8b138e8601671930a55393be2887cfccaa_1.json----vp8_mc_luma", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_5fc0de8b138e8601671930a55393be2887cfccaa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_5fc0de8b138e8601671930a55393be2887cfccaa_1.json", "function_name": "vp8_mc_luma", "vul_func_code": "static av_always_inline\nvoid vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,\n                 ThreadFrame *ref, const VP56mv *mv,\n                 int x_off, int y_off, int block_w, int block_h,\n                 int width, int height, int linesize,\n                 vp8_mc_func mc_func[3][3])\n{\n    uint8_t *src = ref->f->data[0];\n\n    if (AV_RN32A(mv)) {\n\n        int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx];\n        int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my];\n\n        x_off += mv->x >> 2;\n        y_off += mv->y >> 2;\n\n        // edge emulation\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0);\n        src += y_off * linesize + x_off;\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n            src = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n        }\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n    } else {\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0);\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n    }\n}", "patch_func_code": "static av_always_inline\nvoid vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,\n                 ThreadFrame *ref, const VP56mv *mv,\n                 int x_off, int y_off, int block_w, int block_h,\n                 int width, int height, ptrdiff_t linesize,\n                 vp8_mc_func mc_func[3][3])\n{\n    uint8_t *src = ref->f->data[0];\n\n    if (AV_RN32A(mv)) {\n\n        int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx];\n        int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my];\n\n        x_off += mv->x >> 2;\n        y_off += mv->y >> 2;\n\n        // edge emulation\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0);\n        src += y_off * linesize + x_off;\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n            src = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n        }\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n    } else {\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0);\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n    }\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5], "added": [false], "idx": 120}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "1755----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6170c67504202ad4b0ef41b35b5fe3064925228a_1.json----save_subtitle_set", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_6170c67504202ad4b0ef41b35b5fe3064925228a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6170c67504202ad4b0ef41b35b5fe3064925228a_1.json", "function_name": "save_subtitle_set", "vul_func_code": "static int save_subtitle_set(AVCodecContext *avctx, AVSubtitle *sub, int *got_output)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n    DVBSubRegionDisplay *display;\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n    DVBSubRegion *region;\n    AVSubtitleRect *rect;\n    DVBSubCLUT *clut;\n    uint32_t *clut_table;\n    int i;\n    int offset_x=0, offset_y=0;\n    int ret = 0;\n\n\n    if (display_def) {\n        offset_x = display_def->x;\n        offset_y = display_def->y;\n    }\n\n    /* Not touching AVSubtitles again*/\n    if(sub->num_rects) {\n        avpriv_request_sample(ctx, \"Different Version of Segment asked Twice\");\n        return AVERROR_PATCHWELCOME;\n    }\n    for (display = ctx->display_list; display; display = display->next) {\n        region = get_region(ctx, display->region_id);\n        if (region && region->dirty)\n            sub->num_rects++;\n    }\n\n    if(ctx->compute_edt == 0) {\n        sub->end_display_time = ctx->time_out * 1000;\n        *got_output = 1;\n    } else if (ctx->prev_start != AV_NOPTS_VALUE) {\n        sub->end_display_time = av_rescale_q((sub->pts - ctx->prev_start ), AV_TIME_BASE_Q, (AVRational){ 1, 1000 }) - 1;\n        *got_output = 1;\n    }\n    if (sub->num_rects > 0) {\n\n        sub->rects = av_mallocz_array(sizeof(*sub->rects), sub->num_rects);\n        if (!sub->rects) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        for (i = 0; i < sub->num_rects; i++) {\n            sub->rects[i] = av_mallocz(sizeof(*sub->rects[i]));\n            if (!sub->rects[i]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n        }\n\n        i = 0;\n\n        for (display = ctx->display_list; display; display = display->next) {\n            region = get_region(ctx, display->region_id);\n\n            if (!region)\n                continue;\n\n            if (!region->dirty)\n                continue;\n\n            rect = sub->rects[i];\n            rect->x = display->x_pos + offset_x;\n            rect->y = display->y_pos + offset_y;\n            rect->w = region->width;\n            rect->h = region->height;\n            rect->nb_colors = (1 << region->depth);\n            rect->type      = SUBTITLE_BITMAP;\n            rect->linesize[0] = region->width;\n\n            clut = get_clut(ctx, region->clut);\n\n            if (!clut)\n                clut = &default_clut;\n\n            switch (region->depth) {\n            case 2:\n                clut_table = clut->clut4;\n                break;\n            case 8:\n                clut_table = clut->clut256;\n                break;\n            case 4:\n            default:\n                clut_table = clut->clut16;\n                break;\n            }\n\n            rect->data[1] = av_mallocz(AVPALETTE_SIZE);\n            if (!rect->data[1]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n            rect->data[0] = av_malloc(region->buf_size);\n            if (!rect->data[0]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            memcpy(rect->data[0], region->pbuf, region->buf_size);\n\n            if ((clut == &default_clut && ctx->compute_clut == -1) || ctx->compute_clut == 1)\n                compute_default_clut(rect, rect->w, rect->h);\n\n#if FF_API_AVPICTURE\nFF_DISABLE_DEPRECATION_WARNINGS\n{\n            int j;\n            for (j = 0; j < 4; j++) {\n                rect->pict.data[j] = rect->data[j];\n                rect->pict.linesize[j] = rect->linesize[j];\n            }\n}\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n            i++;\n        }\n    }\n\n    return 0;\nfail:\n    if (sub->rects) {\n        for(i=0; i<sub->num_rects; i++) {\n            rect = sub->rects[i];\n            if (rect) {\n                av_freep(&rect->data[0]);\n                av_freep(&rect->data[1]);\n            }\n            av_freep(&sub->rects[i]);\n        }\n        av_freep(&sub->rects);\n    }\n    sub->num_rects = 0;\n    return ret;\n}", "patch_func_code": "static int save_subtitle_set(AVCodecContext *avctx, AVSubtitle *sub, int *got_output)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n    DVBSubRegionDisplay *display;\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n    DVBSubRegion *region;\n    AVSubtitleRect *rect;\n    DVBSubCLUT *clut;\n    uint32_t *clut_table;\n    int i;\n    int offset_x=0, offset_y=0;\n    int ret = 0;\n\n\n    if (display_def) {\n        offset_x = display_def->x;\n        offset_y = display_def->y;\n    }\n\n    /* Not touching AVSubtitles again*/\n    if(sub->num_rects) {\n        avpriv_request_sample(ctx, \"Different Version of Segment asked Twice\");\n        return AVERROR_PATCHWELCOME;\n    }\n    for (display = ctx->display_list; display; display = display->next) {\n        region = get_region(ctx, display->region_id);\n        if (region && region->dirty)\n            sub->num_rects++;\n    }\n\n    if(ctx->compute_edt == 0) {\n        sub->end_display_time = ctx->time_out * 1000;\n        *got_output = 1;\n    } else if (ctx->prev_start != AV_NOPTS_VALUE) {\n        sub->end_display_time = av_rescale_q((sub->pts - ctx->prev_start ), AV_TIME_BASE_Q, (AVRational){ 1, 1000 }) - 1;\n        *got_output = 1;\n    }\n    if (sub->num_rects > 0) {\n\n        sub->rects = av_mallocz_array(sizeof(*sub->rects), sub->num_rects);\n        if (!sub->rects) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        for (i = 0; i < sub->num_rects; i++) {\n            sub->rects[i] = av_mallocz(sizeof(*sub->rects[i]));\n            if (!sub->rects[i]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n        }\n\n        i = 0;\n\n        for (display = ctx->display_list; display; display = display->next) {\n            region = get_region(ctx, display->region_id);\n\n            if (!region)\n                continue;\n\n            if (!region->dirty)\n                continue;\n\n            rect = sub->rects[i];\n            rect->x = display->x_pos + offset_x;\n            rect->y = display->y_pos + offset_y;\n            rect->w = region->width;\n            rect->h = region->height;\n            rect->nb_colors = (1 << region->depth);\n            rect->type      = SUBTITLE_BITMAP;\n            rect->linesize[0] = region->width;\n\n            clut = get_clut(ctx, region->clut);\n\n            if (!clut)\n                clut = &default_clut;\n\n            switch (region->depth) {\n            case 2:\n                clut_table = clut->clut4;\n                break;\n            case 8:\n                clut_table = clut->clut256;\n                break;\n            case 4:\n            default:\n                clut_table = clut->clut16;\n                break;\n            }\n\n            rect->data[1] = av_mallocz(AVPALETTE_SIZE);\n            if (!rect->data[1]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n            memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n            rect->data[0] = av_malloc(region->buf_size);\n            if (!rect->data[0]) {\n                ret = AVERROR(ENOMEM);\n                goto fail;\n            }\n\n            memcpy(rect->data[0], region->pbuf, region->buf_size);\n\n            if ((clut == &default_clut && ctx->compute_clut == -1) || ctx->compute_clut == 1) {\n                if (!region->has_computed_clut) {\n                    compute_default_clut(region->computed_clut, rect, rect->w, rect->h);\n                    region->has_computed_clut = 1;\n                }\n\n                memcpy(rect->data[1], region->computed_clut, sizeof(region->computed_clut));\n            }\n\n#if FF_API_AVPICTURE\nFF_DISABLE_DEPRECATION_WARNINGS\n{\n            int j;\n            for (j = 0; j < 4; j++) {\n                rect->pict.data[j] = rect->data[j];\n                rect->pict.linesize[j] = rect->linesize[j];\n            }\n}\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n            i++;\n        }\n    }\n\n    return 0;\nfail:\n    if (sub->rects) {\n        for(i=0; i<sub->num_rects; i++) {\n            rect = sub->rects[i];\n            if (rect) {\n                av_freep(&rect->data[0]);\n                av_freep(&rect->data[1]);\n            }\n            av_freep(&sub->rects[i]);\n        }\n        av_freep(&sub->rects);\n    }\n    sub->num_rects = 0;\n    return ret;\n}", "before_change_lines": [107, 108], "raw_before_change_lines": [107, 108], "after_change_lines": [107, 108, 109, 110, 111, 113, 114], "raw_after_change_lines": [107, 108, 109, 110, 111, 112, 113, 114], "bug_lines": [107, 108], "added": [false, false], "idx": 121}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1781----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_62c8ccbff449aa2b3819ada7ee421012b2e54f9b_1.json----gsm_mult", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_62c8ccbff449aa2b3819ada7ee421012b2e54f9b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_62c8ccbff449aa2b3819ada7ee421012b2e54f9b_1.json", "function_name": "gsm_mult", "vul_func_code": "static inline int gsm_mult(int a, int b)\n{\n    return (a * b + (1 << 14)) >> 15;\n}", "patch_func_code": "static inline int gsm_mult(int a, int b)\n{\n    return (int)(a * (SUINT)b + (1 << 14)) >> 15;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 122}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1806----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_63c477396317b6f2d55264532642d5446000ae35_1.json----set_sps", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_63c477396317b6f2d55264532642d5446000ae35_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_63c477396317b6f2d55264532642d5446000ae35_1.json", "function_name": "set_sps", "vul_func_code": "static int set_sps(HEVCContext *s, const HEVCSPS *sps)\n{\n    #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL)\n    enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;\n    int ret;\n\n    export_stream_params(s->avctx, &s->ps, sps);\n\n    pic_arrays_free(s);\n    ret = pic_arrays_init(s, sps);\n    if (ret < 0)\n        goto fail;\n\n    if (sps->pix_fmt == AV_PIX_FMT_YUV420P || sps->pix_fmt == AV_PIX_FMT_YUVJ420P) {\n#if CONFIG_HEVC_DXVA2_HWACCEL\n        *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n#endif\n#if CONFIG_HEVC_D3D11VA_HWACCEL\n        *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n#endif\n    }\n\n    *fmt++ = sps->pix_fmt;\n    *fmt = AV_PIX_FMT_NONE;\n\n    ret = ff_get_format(s->avctx, pix_fmts);\n    if (ret < 0)\n        goto fail;\n    s->avctx->pix_fmt = ret;\n\n    ff_hevc_pred_init(&s->hpc,     sps->bit_depth);\n    ff_hevc_dsp_init (&s->hevcdsp, sps->bit_depth);\n    ff_videodsp_init (&s->vdsp,    sps->bit_depth);\n\n    if (sps->sao_enabled && !s->avctx->hwaccel) {\n        av_frame_unref(s->tmp_frame);\n        ret = ff_get_buffer(s->avctx, s->tmp_frame, AV_GET_BUFFER_FLAG_REF);\n        if (ret < 0)\n            goto fail;\n        s->frame = s->tmp_frame;\n    }\n\n    s->ps.sps = sps;\n    s->ps.vps = (HEVCVPS*) s->ps.vps_list[s->ps.sps->vps_id]->data;\n\n    return 0;\n\nfail:\n    pic_arrays_free(s);\n    s->ps.sps = NULL;\n    return ret;\n}", "patch_func_code": "static int set_sps(HEVCContext *s, const HEVCSPS *sps)\n{\n    #define HWACCEL_MAX (CONFIG_HEVC_DXVA2_HWACCEL + CONFIG_HEVC_D3D11VA_HWACCEL)\n    enum AVPixelFormat pix_fmts[HWACCEL_MAX + 2], *fmt = pix_fmts;\n    int ret;\n\n    pic_arrays_free(s);\n    s->ps.sps = NULL;\n    s->ps.vps = NULL;\n\n    if (!sps)\n        return 0;\n\n    ret = pic_arrays_init(s, sps);\n    if (ret < 0)\n        goto fail;\n\n    export_stream_params(s->avctx, &s->ps, sps);\n\n    if (sps->pix_fmt == AV_PIX_FMT_YUV420P || sps->pix_fmt == AV_PIX_FMT_YUVJ420P) {\n#if CONFIG_HEVC_DXVA2_HWACCEL\n        *fmt++ = AV_PIX_FMT_DXVA2_VLD;\n#endif\n#if CONFIG_HEVC_D3D11VA_HWACCEL\n        *fmt++ = AV_PIX_FMT_D3D11VA_VLD;\n#endif\n    }\n\n    *fmt++ = sps->pix_fmt;\n    *fmt = AV_PIX_FMT_NONE;\n\n    ret = ff_get_format(s->avctx, pix_fmts);\n    if (ret < 0)\n        goto fail;\n    s->avctx->pix_fmt = ret;\n\n    ff_hevc_pred_init(&s->hpc,     sps->bit_depth);\n    ff_hevc_dsp_init (&s->hevcdsp, sps->bit_depth);\n    ff_videodsp_init (&s->vdsp,    sps->bit_depth);\n\n    if (sps->sao_enabled && !s->avctx->hwaccel) {\n        av_frame_unref(s->tmp_frame);\n        ret = ff_get_buffer(s->avctx, s->tmp_frame, AV_GET_BUFFER_FLAG_REF);\n        if (ret < 0)\n            goto fail;\n        s->frame = s->tmp_frame;\n    }\n\n    s->ps.sps = sps;\n    s->ps.vps = (HEVCVPS*) s->ps.vps_list[s->ps.sps->vps_id]->data;\n\n    return 0;\n\nfail:\n    pic_arrays_free(s);\n    s->ps.sps = NULL;\n    return ret;\n}", "before_change_lines": [7], "raw_before_change_lines": [7, 8], "after_change_lines": [8, 9, 11, 12, 18], "raw_after_change_lines": [8, 9, 10, 11, 12, 13, 18, 19], "bug_lines": [7, 8], "added": [false, false], "idx": 123}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1864----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_665d8476e842a9aa2e3e7125391ccab759863d1b_1.json----hls_read_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_665d8476e842a9aa2e3e7125391ccab759863d1b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_665d8476e842a9aa2e3e7125391ccab759863d1b_1.json", "function_name": "hls_read_header", "vul_func_code": "static int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n    if (u) {\n        // get the previous user agent & set back to null if string size is zero\n        update_options(&c->user_agent, \"user-agent\", u);\n\n        // get the previous cookies & set back to null if string size is zero\n        update_options(&c->cookies, \"cookies\", u);\n\n        // get the previous headers & set back to null if string size is zero\n        update_options(&c->headers, \"headers\", u);\n\n        // get the previous http proxt & set back to null if string size is zero\n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n\n    /* Some HLS servers don't like being sent the range header */\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained playlists (Master Playlist),\n     * parse each individual playlist. */\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n\n    /* Associate renditions with variants */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n\n    /* Create a program for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n\n    /* Select the starting segments */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n\n    /* Open the demuxer for each playlist */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n\n        /*\n         * If this is a live stream and this playlist looks like it is one segment\n         * behind, try to sync it up so that every substream starts at the same\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n         * all active streams within the first few seconds). This is not very generic,\n         * though, as the sequence numbers are technically independent.\n         */\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            /* Free the ctx - it isn't initialized properly at this point,\n             * so avformat_close_input shouldn't be called. If\n             * avformat_open_input fails below, it frees and zeros the\n             * context, so it doesn't need any special treatment like this. */\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n        /*\n         * For ID3 timestamped raw audio streams we need to detect the packet\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n         * on us if they want to.\n         */\n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n        /* Create new AVStreams for each stream in this playlist */\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n\n    update_noheader_flag(s);\n\n    return 0;\nfail:\n    free_playlist_list(c);\n    free_variant_list(c);\n    free_rendition_list(c);\n    return ret;\n}", "patch_func_code": "static int hls_read_header(AVFormatContext *s)\n{\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n    HLSContext *c = s->priv_data;\n    int ret = 0, i;\n    int highest_cur_seq_no = 0;\n\n    c->ctx                = s;\n    c->interrupt_callback = &s->interrupt_callback;\n    c->strict_std_compliance = s->strict_std_compliance;\n\n    c->first_packet = 1;\n    c->first_timestamp = AV_NOPTS_VALUE;\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n    if (u) {\n        // get the previous user agent & set back to null if string size is zero\n        update_options(&c->user_agent, \"user-agent\", u);\n\n        // get the previous cookies & set back to null if string size is zero\n        update_options(&c->cookies, \"cookies\", u);\n\n        // get the previous headers & set back to null if string size is zero\n        update_options(&c->headers, \"headers\", u);\n\n        // get the previous http proxt & set back to null if string size is zero\n        update_options(&c->http_proxy, \"http_proxy\", u);\n    }\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n        goto fail;\n\n    if ((ret = save_avio_options(s)) < 0)\n        goto fail;\n\n    /* Some HLS servers don't like being sent the range header */\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n    if (c->n_variants == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n    /* If the playlist only contained playlists (Master Playlist),\n     * parse each individual playlist. */\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n        for (i = 0; i < c->n_playlists; i++) {\n            struct playlist *pls = c->playlists[i];\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n                goto fail;\n        }\n    }\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n        ret = AVERROR_EOF;\n        goto fail;\n    }\n\n    /* If this isn't a live stream, calculate the total duration of the\n     * stream. */\n    if (c->variants[0]->playlists[0]->finished) {\n        int64_t duration = 0;\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n        s->duration = duration;\n    }\n\n    /* Associate renditions with variants */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n\n        if (var->audio_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n        if (var->video_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n        if (var->subtitles_group[0])\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n    }\n\n    /* Create a program for each variant */\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *v = c->variants[i];\n        AVProgram *program;\n\n        program = av_new_program(s, i);\n        if (!program)\n            goto fail;\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n    }\n\n    /* Select the starting segments */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n    }\n\n    /* Open the demuxer for each playlist */\n    for (i = 0; i < c->n_playlists; i++) {\n        struct playlist *pls = c->playlists[i];\n        AVInputFormat *in_fmt = NULL;\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n\n        if (pls->n_segments == 0)\n            continue;\n\n        pls->index  = i;\n        pls->needed = 1;\n        pls->parent = s;\n\n        /*\n         * If this is a live stream and this playlist looks like it is one segment\n         * behind, try to sync it up so that every substream starts at the same\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n         * all active streams within the first few seconds). This is not very generic,\n         * though, as the sequence numbers are technically independent.\n         */\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n            pls->cur_seq_no = highest_cur_seq_no;\n        }\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n        if (!pls->read_buffer){\n            ret = AVERROR(ENOMEM);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n                          read_data, NULL, NULL);\n        pls->pb.seekable = 0;\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n                                    NULL, 0, 0);\n        if (ret < 0) {\n            /* Free the ctx - it isn't initialized properly at this point,\n             * so avformat_close_input shouldn't be called. If\n             * avformat_open_input fails below, it frees and zeros the\n             * context, so it doesn't need any special treatment like this. */\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n            avformat_free_context(pls->ctx);\n            pls->ctx = NULL;\n            goto fail;\n        }\n        pls->ctx->pb       = &pls->pb;\n        pls->ctx->io_open  = nested_io_open;\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n            goto fail;\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n        if (ret < 0)\n            goto fail;\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n            avformat_queue_attached_pictures(pls->ctx);\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n            pls->id3_deferred_extra = NULL;\n        }\n\n        if (pls->is_id3_timestamped == -1)\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n        /*\n         * For ID3 timestamped raw audio streams we need to detect the packet\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n         * on us if they want to.\n         */\n        if (pls->is_id3_timestamped) {\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n            if (ret < 0)\n                goto fail;\n        }\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n        /* Create new AVStreams for each stream in this playlist */\n        ret = update_streams_from_subdemuxer(s, pls);\n        if (ret < 0)\n            goto fail;\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n    }\n\n    update_noheader_flag(s);\n\n    return 0;\nfail:\n    hls_close(s);\n    return ret;\n}", "before_change_lines": [202, 203, 204], "raw_before_change_lines": [202, 203, 204], "after_change_lines": [202], "raw_after_change_lines": [202], "bug_lines": [202, 203, 204], "added": [false, false, false], "idx": 124}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1890----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_67b81f7026fd23a0f963edaaca8e6be6ddecf2e0_1.json----ff_jpegls_init_state", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_67b81f7026fd23a0f963edaaca8e6be6ddecf2e0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_67b81f7026fd23a0f963edaaca8e6be6ddecf2e0_1.json", "function_name": "ff_jpegls_init_state", "vul_func_code": "void ff_jpegls_init_state(JLSState *state){\n    int i;\n\n    state->twonear = state->near * 2 + 1;\n    state->range = ((state->maxval + state->twonear - 1) / state->twonear) + 1;\n\n    // QBPP = ceil(log2(RANGE))\n    for(state->qbpp = 0; (1 << state->qbpp) < state->range; state->qbpp++);\n\n    if(state->bpp < 8)\n        state->limit = 16 + 2 * state->bpp - state->qbpp;\n    else\n        state->limit = (4 * state->bpp) - state->qbpp;\n\n    for(i = 0; i < 367; i++) {\n        state->A[i] = FFMAX((state->range + 32) >> 6, 2);\n        state->N[i] = 1;\n    }\n\n}", "patch_func_code": "void ff_jpegls_init_state(JLSState *state){\n    int i;\n\n    state->twonear = state->near * 2 + 1;\n    state->range = ((state->maxval + state->twonear - 1) / state->twonear) + 1;\n\n    // QBPP = ceil(log2(RANGE))\n    for(state->qbpp = 0; (1 << state->qbpp) < state->range; state->qbpp++);\n\n    state->bpp = FFMAX(av_log2(state->maxval)+1, 2);\n    state->limit = 2*(state->bpp + FFMAX(state->bpp, 8)) - state->qbpp;\n\n    for(i = 0; i < 367; i++) {\n        state->A[i] = FFMAX((state->range + 32) >> 6, 2);\n        state->N[i] = 1;\n    }\n\n}", "before_change_lines": [10, 11, 12, 13], "raw_before_change_lines": [10, 11, 12, 13], "after_change_lines": [10, 11], "raw_after_change_lines": [10, 11], "bug_lines": [10, 11, 12, 13], "added": [false, false, false, false], "idx": 125}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "1928----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_69ce18f3085fe62e4a3a4bea6a4a7b95958d98a1_1.json----hls_mux_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_69ce18f3085fe62e4a3a4bea6a4a7b95958d98a1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_69ce18f3085fe62e4a3a4bea6a4a7b95958d98a1_1.json", "function_name": "hls_mux_init", "vul_func_code": "static int hls_mux_init(AVFormatContext *s)\n{\n    HLSContext *hls = s->priv_data;\n    AVFormatContext *oc;\n    AVFormatContext *vtt_oc;\n    int i, ret;\n\n    ret = avformat_alloc_output_context2(&hls->avf, hls->oformat, NULL, NULL);\n    if (ret < 0)\n        return ret;\n    oc = hls->avf;\n\n    oc->oformat            = hls->oformat;\n    oc->interrupt_callback = s->interrupt_callback;\n    oc->max_delay          = s->max_delay;\n    av_dict_copy(&oc->metadata, s->metadata, 0);\n\n    if(hls->vtt_oformat) {\n        ret = avformat_alloc_output_context2(&hls->vtt_avf, hls->vtt_oformat, NULL, NULL);\n        if (ret < 0)\n            return ret;\n        vtt_oc          = hls->vtt_avf;\n        vtt_oc->oformat = hls->vtt_oformat;\n        av_dict_copy(&vtt_oc->metadata, s->metadata, 0);\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st;\n        AVFormatContext *loc;\n        if (s->streams[i]->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n            loc = vtt_oc;\n        else\n            loc = oc;\n\n        if (!(st = avformat_new_stream(loc, NULL)))\n            return AVERROR(ENOMEM);\n        avcodec_copy_context(st->codec, s->streams[i]->codec);\n        st->sample_aspect_ratio = s->streams[i]->sample_aspect_ratio;\n        st->time_base = s->streams[i]->time_base;\n    }\n    hls->start_pos = 0;\n\n    return 0;\n}", "patch_func_code": "static int hls_mux_init(AVFormatContext *s)\n{\n    HLSContext *hls = s->priv_data;\n    AVFormatContext *oc;\n    AVFormatContext *vtt_oc = NULL;\n    int i, ret;\n\n    ret = avformat_alloc_output_context2(&hls->avf, hls->oformat, NULL, NULL);\n    if (ret < 0)\n        return ret;\n    oc = hls->avf;\n\n    oc->oformat            = hls->oformat;\n    oc->interrupt_callback = s->interrupt_callback;\n    oc->max_delay          = s->max_delay;\n    av_dict_copy(&oc->metadata, s->metadata, 0);\n\n    if(hls->vtt_oformat) {\n        ret = avformat_alloc_output_context2(&hls->vtt_avf, hls->vtt_oformat, NULL, NULL);\n        if (ret < 0)\n            return ret;\n        vtt_oc          = hls->vtt_avf;\n        vtt_oc->oformat = hls->vtt_oformat;\n        av_dict_copy(&vtt_oc->metadata, s->metadata, 0);\n    }\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st;\n        AVFormatContext *loc;\n        if (s->streams[i]->codec->codec_type == AVMEDIA_TYPE_SUBTITLE)\n            loc = vtt_oc;\n        else\n            loc = oc;\n\n        if (!(st = avformat_new_stream(loc, NULL)))\n            return AVERROR(ENOMEM);\n        avcodec_copy_context(st->codec, s->streams[i]->codec);\n        st->sample_aspect_ratio = s->streams[i]->sample_aspect_ratio;\n        st->time_base = s->streams[i]->time_base;\n    }\n    hls->start_pos = 0;\n\n    return 0;\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5], "added": [false], "idx": 126}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1981----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6c04f54c8361a64fc09b68fd573587a2d0b29327_1.json----mpeg_motion_internal", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_6c04f54c8361a64fc09b68fd573587a2d0b29327_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6c04f54c8361a64fc09b68fd573587a2d0b29327_1.json", "function_name": "mpeg_motion_internal", "vul_func_code": "static av_always_inline\nvoid mpeg_motion_internal(MpegEncContext *s,\n                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                 int field_based, int bottom_field, int field_select,\n                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int dxy, uvdxy, mx, my, src_x, src_y,\n        uvsrc_x, uvsrc_y, v_edge_pos;\n    emuedge_linesize_type uvlinesize, linesize;\n\n#if 0\nif(s->quarter_sample)\n{\n    motion_x>>=1;\n    motion_y>>=1;\n}\n#endif\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n    src_x = s->mb_x* 16               + (motion_x >> 1);\n    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n        if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){\n            mx = (motion_x>>1)|(motion_x&1);\n            my = motion_y >>1;\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n        }else{\n            uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n            uvsrc_x = src_x>>1;\n            uvsrc_y = src_y>>1;\n        }\n    }else if(!is_mpeg12 && s->out_format == FMT_H261){//even chroma mv's are full pel in H261\n        mx = motion_x / 4;\n        my = motion_y / 4;\n        uvdxy = 0;\n        uvsrc_x = s->mb_x*8 + mx;\n        uvsrc_y =    mb_y*8 + my;\n    } else {\n        if(s->chroma_y_shift){\n            mx = motion_x / 2;\n            my = motion_y / 2;\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n        } else {\n            if(s->chroma_x_shift){\n            //Chroma422\n                mx = motion_x / 2;\n                uvdxy = ((motion_y & 1) << 1) | (mx & 1);\n                uvsrc_x = s->mb_x* 8           + (mx >> 1);\n                uvsrc_y = src_y;\n            } else {\n            //Chroma444\n                uvdxy = dxy;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0)\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&1) - h , 0)){\n            if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n               s->codec_id == AV_CODEC_ID_MPEG1VIDEO){\n                av_log(s->avctx,AV_LOG_DEBUG,\n                        \"MPEG motion vector out of boundary (%d %d)\\n\", src_x, src_y);\n                return;\n            }\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n                                17, 17+field_based,\n                                src_x, src_y<<field_based,\n                                s->h_edge_pos, s->v_edge_pos);\n            ptr_y = s->edge_emu_buffer;\n            if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize;\n                s->vdsp.emulated_edge_mc(uvbuf ,\n                                    ptr_cb, s->uvlinesize,\n                                    9, 9+field_based,\n                                    uvsrc_x, uvsrc_y<<field_based,\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n                                    ptr_cr, s->uvlinesize,\n                                    9, 9+field_based,\n                                    uvsrc_x, uvsrc_y<<field_based,\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n                ptr_cb= uvbuf;\n                ptr_cr= uvbuf+16;\n            }\n    }\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n        dest_y += s->linesize;\n        dest_cb+= s->uvlinesize;\n        dest_cr+= s->uvlinesize;\n    }\n\n    if(field_select){\n        ptr_y += s->linesize;\n        ptr_cb+= s->uvlinesize;\n        ptr_cr+= s->uvlinesize;\n    }\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n        pix_op[s->chroma_x_shift][uvdxy]\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n        pix_op[s->chroma_x_shift][uvdxy]\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n    }\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n         s->out_format == FMT_H261){\n        ff_h261_loop_filter(s);\n    }\n}", "patch_func_code": "static av_always_inline\nvoid mpeg_motion_internal(MpegEncContext *s,\n                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,\n                 int field_based, int bottom_field, int field_select,\n                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],\n                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)\n{\n    uint8_t *ptr_y, *ptr_cb, *ptr_cr;\n    int dxy, uvdxy, mx, my, src_x, src_y,\n        uvsrc_x, uvsrc_y, v_edge_pos;\n    ptrdiff_t uvlinesize, linesize;\n\n#if 0\nif(s->quarter_sample)\n{\n    motion_x>>=1;\n    motion_y>>=1;\n}\n#endif\n\n    v_edge_pos = s->v_edge_pos >> field_based;\n    linesize   = s->current_picture.f.linesize[0] << field_based;\n    uvlinesize = s->current_picture.f.linesize[1] << field_based;\n\n    dxy = ((motion_y & 1) << 1) | (motion_x & 1);\n    src_x = s->mb_x* 16               + (motion_x >> 1);\n    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);\n\n    if (!is_mpeg12 && s->out_format == FMT_H263) {\n        if((s->workaround_bugs & FF_BUG_HPEL_CHROMA) && field_based){\n            mx = (motion_x>>1)|(motion_x&1);\n            my = motion_y >>1;\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n        }else{\n            uvdxy = dxy | (motion_y & 2) | ((motion_x & 2) >> 1);\n            uvsrc_x = src_x>>1;\n            uvsrc_y = src_y>>1;\n        }\n    }else if(!is_mpeg12 && s->out_format == FMT_H261){//even chroma mv's are full pel in H261\n        mx = motion_x / 4;\n        my = motion_y / 4;\n        uvdxy = 0;\n        uvsrc_x = s->mb_x*8 + mx;\n        uvsrc_y =    mb_y*8 + my;\n    } else {\n        if(s->chroma_y_shift){\n            mx = motion_x / 2;\n            my = motion_y / 2;\n            uvdxy = ((my & 1) << 1) | (mx & 1);\n            uvsrc_x = s->mb_x* 8               + (mx >> 1);\n            uvsrc_y =(   mb_y<<(3-field_based))+ (my >> 1);\n        } else {\n            if(s->chroma_x_shift){\n            //Chroma422\n                mx = motion_x / 2;\n                uvdxy = ((motion_y & 1) << 1) | (mx & 1);\n                uvsrc_x = s->mb_x* 8           + (mx >> 1);\n                uvsrc_y = src_y;\n            } else {\n            //Chroma444\n                uvdxy = dxy;\n                uvsrc_x = src_x;\n                uvsrc_y = src_y;\n            }\n        }\n    }\n\n    ptr_y  = ref_picture[0] + src_y * linesize + src_x;\n    ptr_cb = ref_picture[1] + uvsrc_y * uvlinesize + uvsrc_x;\n    ptr_cr = ref_picture[2] + uvsrc_y * uvlinesize + uvsrc_x;\n\n    if(   (unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x&1) - 16, 0)\n       || (unsigned)src_y > FFMAX(   v_edge_pos - (motion_y&1) - h , 0)){\n            if(is_mpeg12 || s->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n               s->codec_id == AV_CODEC_ID_MPEG1VIDEO){\n                av_log(s->avctx,AV_LOG_DEBUG,\n                        \"MPEG motion vector out of boundary (%d %d)\\n\", src_x, src_y);\n                return;\n            }\n            s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr_y, s->linesize,\n                                17, 17+field_based,\n                                src_x, src_y<<field_based,\n                                s->h_edge_pos, s->v_edge_pos);\n            ptr_y = s->edge_emu_buffer;\n            if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n                uint8_t *uvbuf= s->edge_emu_buffer+18*s->linesize;\n                s->vdsp.emulated_edge_mc(uvbuf ,\n                                    ptr_cb, s->uvlinesize,\n                                    9, 9+field_based,\n                                    uvsrc_x, uvsrc_y<<field_based,\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n                                    ptr_cr, s->uvlinesize,\n                                    9, 9+field_based,\n                                    uvsrc_x, uvsrc_y<<field_based,\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n                ptr_cb= uvbuf;\n                ptr_cr= uvbuf+16;\n            }\n    }\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n        dest_y += s->linesize;\n        dest_cb+= s->uvlinesize;\n        dest_cr+= s->uvlinesize;\n    }\n\n    if(field_select){\n        ptr_y += s->linesize;\n        ptr_cb+= s->uvlinesize;\n        ptr_cr+= s->uvlinesize;\n    }\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n        pix_op[s->chroma_x_shift][uvdxy]\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n        pix_op[s->chroma_x_shift][uvdxy]\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n    }\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n         s->out_format == FMT_H261){\n        ff_h261_loop_filter(s);\n    }\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [11], "added": [false], "idx": 127}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "1984----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6c342ac045ec74a88111188f8b511527d2119c2f_1.json----decode_sgirle8", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_6c342ac045ec74a88111188f8b511527d2119c2f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6c342ac045ec74a88111188f8b511527d2119c2f_1.json", "function_name": "decode_sgirle8", "vul_func_code": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n{\n    const uint8_t *src_end = src + src_size;\n    int x = 0, y = 0;\n\n#define INC_XY(n) \\\n    x += n; \\\n    if (x >= width) { \\\n        y++; \\\n        if (y >= height) \\\n            return 0; \\\n        x = 0; \\\n    }\n\n    while (src_end - src >= 2) {\n        uint8_t v = *src++;\n        if (v > 0 && v < 0xC0) {\n            do {\n                int length = FFMIN(v, width - x);\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n                INC_XY(length);\n                v   -= length;\n            } while (v > 0);\n            src++;\n        } else if (v >= 0xC1) {\n            v -= 0xC0;\n            do {\n                int length = FFMIN3(v, width - x, src_end - src);\n                if (src_end - src < length)\n                    break;\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n                INC_XY(length);\n                src += length;\n                v   -= length;\n            } while (v > 0);\n        } else {\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n{\n    const uint8_t *src_end = src + src_size;\n    int x = 0, y = 0;\n\n#define INC_XY(n) \\\n    x += n; \\\n    if (x >= width) { \\\n        y++; \\\n        if (y >= height) \\\n            return 0; \\\n        x = 0; \\\n    }\n\n    while (src_end - src >= 2) {\n        uint8_t v = *src++;\n        if (v > 0 && v < 0xC0) {\n            do {\n                int length = FFMIN(v, width - x);\n                if (length <= 0)\n                    break;\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n                INC_XY(length);\n                v   -= length;\n            } while (v > 0);\n            src++;\n        } else if (v >= 0xC1) {\n            v -= 0xC0;\n            do {\n                int length = FFMIN3(v, width - x, src_end - src);\n                if (src_end - src < length || length <= 0)\n                    break;\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n                INC_XY(length);\n                src += length;\n                v   -= length;\n            } while (v > 0);\n        } else {\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n    return 0;\n}", "before_change_lines": [29], "raw_before_change_lines": [29], "after_change_lines": [20, 21, 31], "raw_after_change_lines": [20, 21, 31], "bug_lines": [29], "added": [false], "idx": 128}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "2026----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6ecdedb75308c5ffaa9a1ee5a2676ed8a4e063e5_1.json----probe_file", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_6ecdedb75308c5ffaa9a1ee5a2676ed8a4e063e5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_6ecdedb75308c5ffaa9a1ee5a2676ed8a4e063e5_1.json", "function_name": "probe_file", "vul_func_code": "static int probe_file(WriterContext *wctx, const char *filename)\n{\n    AVFormatContext *fmt_ctx;\n    int ret, i;\n    int section_id;\n\n    do_read_frames = do_show_frames || do_count_frames;\n    do_read_packets = do_show_packets || do_count_packets;\n\n    ret = open_input_file(&fmt_ctx, filename);\n    if (ret < 0)\n        return ret;\n\n#define CHECK_END if (ret < 0) goto end\n\n    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));\n    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));\n    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n        if (stream_specifier) {\n            ret = avformat_match_stream_specifier(fmt_ctx,\n                                                  fmt_ctx->streams[i],\n                                                  stream_specifier);\n            CHECK_END;\n            else\n                selected_streams[i] = ret;\n            ret = 0;\n        } else {\n            selected_streams[i] = 1;\n        }\n    }\n\n    if (do_read_frames || do_read_packets) {\n        if (do_show_frames && do_show_packets &&\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n        else if (do_show_packets && !do_show_frames)\n            section_id = SECTION_ID_PACKETS;\n        else // (!do_show_packets && do_show_frames)\n            section_id = SECTION_ID_FRAMES;\n        if (do_show_frames || do_show_packets)\n            writer_print_section_header(wctx, section_id);\n        ret = read_packets(wctx, fmt_ctx);\n        if (do_show_frames || do_show_packets)\n            writer_print_section_footer(wctx);\n        CHECK_END;\n    }\n\n    if (do_show_programs) {\n        ret = show_programs(wctx, fmt_ctx);\n        CHECK_END;\n    }\n\n    if (do_show_streams) {\n        ret = show_streams(wctx, fmt_ctx);\n        CHECK_END;\n    }\n    if (do_show_chapters) {\n        ret = show_chapters(wctx, fmt_ctx);\n        CHECK_END;\n    }\n    if (do_show_format) {\n        ret = show_format(wctx, fmt_ctx);\n        CHECK_END;\n    }\n\nend:\n    close_input_file(&fmt_ctx);\n    av_freep(&nb_streams_frames);\n    av_freep(&nb_streams_packets);\n    av_freep(&selected_streams);\n\n    return ret;\n}", "patch_func_code": "static int probe_file(WriterContext *wctx, const char *filename)\n{\n    AVFormatContext *fmt_ctx;\n    int ret, i;\n    int section_id;\n\n    do_read_frames = do_show_frames || do_count_frames;\n    do_read_packets = do_show_packets || do_count_packets;\n\n    ret = open_input_file(&fmt_ctx, filename);\n    if (ret < 0)\n        return ret;\n\n#define CHECK_END if (ret < 0) goto end\n\n    nb_streams = fmt_ctx->nb_streams;\n    REALLOCZ_ARRAY_STREAM(nb_streams_frames,0,fmt_ctx->nb_streams);\n    REALLOCZ_ARRAY_STREAM(nb_streams_packets,0,fmt_ctx->nb_streams);\n    REALLOCZ_ARRAY_STREAM(selected_streams,0,fmt_ctx->nb_streams);\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n        if (stream_specifier) {\n            ret = avformat_match_stream_specifier(fmt_ctx,\n                                                  fmt_ctx->streams[i],\n                                                  stream_specifier);\n            CHECK_END;\n            else\n                selected_streams[i] = ret;\n            ret = 0;\n        } else {\n            selected_streams[i] = 1;\n        }\n    }\n\n    if (do_read_frames || do_read_packets) {\n        if (do_show_frames && do_show_packets &&\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n        else if (do_show_packets && !do_show_frames)\n            section_id = SECTION_ID_PACKETS;\n        else // (!do_show_packets && do_show_frames)\n            section_id = SECTION_ID_FRAMES;\n        if (do_show_frames || do_show_packets)\n            writer_print_section_header(wctx, section_id);\n        ret = read_packets(wctx, fmt_ctx);\n        if (do_show_frames || do_show_packets)\n            writer_print_section_footer(wctx);\n        CHECK_END;\n    }\n\n    if (do_show_programs) {\n        ret = show_programs(wctx, fmt_ctx);\n        CHECK_END;\n    }\n\n    if (do_show_streams) {\n        ret = show_streams(wctx, fmt_ctx);\n        CHECK_END;\n    }\n    if (do_show_chapters) {\n        ret = show_chapters(wctx, fmt_ctx);\n        CHECK_END;\n    }\n    if (do_show_format) {\n        ret = show_format(wctx, fmt_ctx);\n        CHECK_END;\n    }\n\nend:\n    close_input_file(&fmt_ctx);\n    av_freep(&nb_streams_frames);\n    av_freep(&nb_streams_packets);\n    av_freep(&selected_streams);\n\n    return ret;\n}", "before_change_lines": [16, 17, 18], "raw_before_change_lines": [16, 17, 18], "after_change_lines": [16, 17, 18, 19], "raw_after_change_lines": [16, 17, 18, 19], "bug_lines": [16, 17, 18], "added": [false, false, false], "idx": 129}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2065----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7129e33db931264ec425cd5e7f43770f36f9e501_1.json----rm_assemble_video_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_7129e33db931264ec425cd5e7f43770f36f9e501_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7129e33db931264ec425cd5e7f43770f36f9e501_1.json", "function_name": "rm_assemble_video_frame", "vul_func_code": "static int rm_assemble_video_frame(AVFormatContext *s, ByteIOContext *pb,\n                                   RMDemuxContext *rm, RMStream *vst,\n                                   AVPacket *pkt, int len)\n{\n    int hdr, seq, pic_num, len2, pos;\n    int type;\n\n    hdr = get_byte(pb); len--;\n    type = hdr >> 6;\n\n    if(type != 3){  // not frame as a part of packet\n        seq = get_byte(pb); len--;\n    }\n    if(type != 1){  // not whole frame\n        len2 = get_num(pb, &len);\n        pos  = get_num(pb, &len);\n        pic_num = get_byte(pb); len--;\n    }\n    if(len<0)\n        return -1;\n    rm->remaining_len = len;\n    if(type&1){     // frame, not slice\n        if(type == 3)  // frame as a part of packet\n            len= len2;\n        if(rm->remaining_len < len)\n            return -1;\n        rm->remaining_len -= len;\n        if(av_new_packet(pkt, len + 9) < 0)\n            return AVERROR(EIO);\n        pkt->data[0] = 0;\n        AV_WL32(pkt->data + 1, 1);\n        AV_WL32(pkt->data + 5, 0);\n        get_buffer(pb, pkt->data + 9, len);\n        return 0;\n    }\n    //now we have to deal with single slice\n\n    if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){\n        vst->slices = ((hdr & 0x3F) << 1) + 1;\n        vst->videobufsize = len2 + 8*vst->slices + 1;\n        av_free_packet(&vst->pkt); //FIXME this should be output.\n        if(av_new_packet(&vst->pkt, vst->videobufsize) < 0)\n            return AVERROR(ENOMEM);\n        vst->videobufpos = 8*vst->slices + 1;\n        vst->cur_slice = 0;\n        vst->curpic_num = pic_num;\n        vst->pktpos = url_ftell(pb);\n    }\n    if(type == 2)\n        len = FFMIN(len, pos);\n\n    if(++vst->cur_slice > vst->slices)\n        return 1;\n    AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1);\n    AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1);\n    if(vst->videobufpos + len > vst->videobufsize)\n        return 1;\n    if (get_buffer(pb, vst->pkt.data + vst->videobufpos, len) != len)\n        return AVERROR(EIO);\n    vst->videobufpos += len;\n    rm->remaining_len-= len;\n\n    if(type == 2 || (vst->videobufpos) == vst->videobufsize){\n        vst->pkt.data[0] = vst->cur_slice-1;\n        *pkt= vst->pkt;\n        vst->pkt.data=\n        vst->pkt.size= 0;\n        if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n            memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n                vst->videobufpos - 1 - 8*vst->slices);\n        pkt->size += 8*(vst->cur_slice - vst->slices);\n        pkt->pts = AV_NOPTS_VALUE;\n        pkt->pos = vst->pktpos;\n        return 0;\n    }\n\n    return 1;\n}", "patch_func_code": "static int rm_assemble_video_frame(AVFormatContext *s, ByteIOContext *pb,\n                                   RMDemuxContext *rm, RMStream *vst,\n                                   AVPacket *pkt, int len)\n{\n    int hdr, seq, pic_num, len2, pos;\n    int type;\n\n    hdr = get_byte(pb); len--;\n    type = hdr >> 6;\n\n    if(type != 3){  // not frame as a part of packet\n        seq = get_byte(pb); len--;\n    }\n    if(type != 1){  // not whole frame\n        len2 = get_num(pb, &len);\n        pos  = get_num(pb, &len);\n        pic_num = get_byte(pb); len--;\n    }\n    if(len<0)\n        return -1;\n    rm->remaining_len = len;\n    if(type&1){     // frame, not slice\n        if(type == 3)  // frame as a part of packet\n            len= len2;\n        if(rm->remaining_len < len)\n            return -1;\n        rm->remaining_len -= len;\n        if(av_new_packet(pkt, len + 9) < 0)\n            return AVERROR(EIO);\n        pkt->data[0] = 0;\n        AV_WL32(pkt->data + 1, 1);\n        AV_WL32(pkt->data + 5, 0);\n        get_buffer(pb, pkt->data + 9, len);\n        return 0;\n    }\n    //now we have to deal with single slice\n\n    if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){\n        vst->slices = ((hdr & 0x3F) << 1) + 1;\n        vst->videobufsize = len2 + 8*vst->slices + 1;\n        av_free_packet(&vst->pkt); //FIXME this should be output.\n        if(av_new_packet(&vst->pkt, vst->videobufsize) < 0)\n            return AVERROR(ENOMEM);\n        vst->videobufpos = 8*vst->slices + 1;\n        vst->cur_slice = 0;\n        vst->curpic_num = pic_num;\n        vst->pktpos = url_ftell(pb);\n    }\n    if(type == 2)\n        len = FFMIN(len, pos);\n\n    if(++vst->cur_slice > vst->slices)\n        return 1;\n    AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1);\n    AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1);\n    if(vst->videobufpos + len > vst->videobufsize)\n        return 1;\n    if (get_buffer(pb, vst->pkt.data + vst->videobufpos, len) != len)\n        return AVERROR(EIO);\n    vst->videobufpos += len;\n    rm->remaining_len-= len;\n\n    if(type == 2 || (vst->videobufpos) == vst->videobufsize){\n        vst->pkt.data[0] = vst->cur_slice-1;\n        *pkt= vst->pkt;\n        vst->pkt.data=\n        vst->pkt.size= 0;\n        if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n            memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n                vst->videobufpos - 1 - 8*vst->slices);\n        pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices);\n        pkt->pts = AV_NOPTS_VALUE;\n        pkt->pos = vst->pktpos;\n        return 0;\n    }\n\n    return 1;\n}", "before_change_lines": [71], "raw_before_change_lines": [71], "after_change_lines": [71], "raw_after_change_lines": [71], "bug_lines": [71], "added": [false], "idx": 130}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2091----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7257f40c6184faac2d93f87214b4b47ed73e0388_1.json----mcdc", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_7257f40c6184faac2d93f87214b4b47ed73e0388_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7257f40c6184faac2d93f87214b4b47ed73e0388_1.json", "function_name": "mcdc", "vul_func_code": "static inline void mcdc(uint16_t *dst, uint16_t *src, int log2w, int h, int stride, int scale, int dc){\n   int i;\n   dc*= 0x10001;\n\n   switch(log2w){\n   case 0:\n        for(i=0; i<h; i++){\n            dst[0] = scale*src[0] + dc;\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    case 1:\n        for(i=0; i<h; i++){\n            LE_CENTRIC_MUL(dst, src, scale, dc);\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    case 2:\n        for(i=0; i<h; i++){\n            LE_CENTRIC_MUL(dst,     src,     scale, dc);\n            LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc);\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    case 3:\n        for(i=0; i<h; i++){\n            LE_CENTRIC_MUL(dst,     src,     scale, dc);\n            LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc);\n            LE_CENTRIC_MUL(dst + 4, src + 4, scale, dc);\n            LE_CENTRIC_MUL(dst + 6, src + 6, scale, dc);\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    default: assert(0);\n    }\n}", "patch_func_code": "static inline void mcdc(uint16_t *dst, uint16_t *src, int log2w, int h, int stride, int scale, unsigned dc){\n   int i;\n   dc*= 0x10001;\n\n   switch(log2w){\n   case 0:\n        for(i=0; i<h; i++){\n            dst[0] = scale*src[0] + dc;\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    case 1:\n        for(i=0; i<h; i++){\n            LE_CENTRIC_MUL(dst, src, scale, dc);\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    case 2:\n        for(i=0; i<h; i++){\n            LE_CENTRIC_MUL(dst,     src,     scale, dc);\n            LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc);\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    case 3:\n        for(i=0; i<h; i++){\n            LE_CENTRIC_MUL(dst,     src,     scale, dc);\n            LE_CENTRIC_MUL(dst + 2, src + 2, scale, dc);\n            LE_CENTRIC_MUL(dst + 4, src + 4, scale, dc);\n            LE_CENTRIC_MUL(dst + 6, src + 6, scale, dc);\n            if(scale) src += stride;\n            dst += stride;\n        }\n        break;\n    default: assert(0);\n    }\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1], "raw_after_change_lines": [1], "bug_lines": [1], "added": [false], "idx": 131}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "2115----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_73af8dd5e5a989a76bbc4e1a3a3f004432576297_1.json----ff_new_chapter", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_73af8dd5e5a989a76bbc4e1a3a3f004432576297_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_73af8dd5e5a989a76bbc4e1a3a3f004432576297_1.json", "function_name": "ff_new_chapter", "vul_func_code": "int ff_new_chapter(AVFormatContext *s, int id, int64_t start, int64_t end, const char *title)\n{\n    AVChapter *chapter = NULL;\n    int i;\n\n    for(i=0; i<s->num_chapters; i++)\n        if(s->chapters[i]->id == id)\n            chapter = s->chapters[i];\n\n    if(!chapter){\n        chapter= av_mallocz(sizeof(AVChapter));\n        if(!chapter)\n            return AVERROR(ENOMEM);\n        dynarray_add(&s->chapters, &s->num_chapters, chapter);\n    }\n    if(chapter->title)\n        av_free(chapter->title);\n    if (title)\n        chapter->title = av_strdup(title);\n    chapter->id    = id;\n    chapter->start = start;\n    chapter->end = end;\n\n    return 0;\n}", "patch_func_code": "int ff_new_chapter(AVFormatContext *s, int id, int64_t start, int64_t end, const char *title)\n{\n    AVChapter *chapter = NULL;\n    int i;\n\n    for(i=0; i<s->num_chapters; i++)\n        if(s->chapters[i]->id == id)\n            chapter = s->chapters[i];\n\n    if(!chapter){\n        chapter= av_mallocz(sizeof(AVChapter));\n        if(!chapter)\n            return AVERROR(ENOMEM);\n        dynarray_add(&s->chapters, &s->num_chapters, chapter);\n    }\n    if(chapter->title)\n        av_free(chapter->title);\n        chapter->title = av_strdup(title);\n    chapter->id    = id;\n    chapter->start = start;\n    chapter->end = end;\n\n    return 0;\n}", "before_change_lines": [18], "raw_before_change_lines": [18], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [18], "added": [false], "idx": 132}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2209----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_79a1fd16656161591ad6a84d66f81bd8d285d365_1.json----matroska_parse_laces", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_79a1fd16656161591ad6a84d66f81bd8d285d365_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_79a1fd16656161591ad6a84d66f81bd8d285d365_1.json", "function_name": "matroska_parse_laces", "vul_func_code": "static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,\n                                int size, int type,\n                                uint32_t **lace_buf, int *laces)\n{\n    int res = 0, n;\n    uint8_t *data = *buf;\n    uint32_t *lace_size;\n\n    if (!type) {\n        *laces = 1;\n        *lace_buf = av_mallocz(sizeof(int));\n        if (!*lace_buf)\n            return AVERROR(ENOMEM);\n\n        *lace_buf[0] = size;\n        return 0;\n    }\n\n    av_assert0(size > 0);\n    *laces = *data + 1;\n    data += 1;\n    size -= 1;\n    lace_size = av_mallocz(*laces * sizeof(int));\n    if (!lace_size)\n        return AVERROR(ENOMEM);\n\n    switch (type) {\n    case 0x1: /* Xiph lacing */ {\n        uint8_t temp;\n        uint32_t total = 0;\n        for (n = 0; res == 0 && n < *laces - 1; n++) {\n            while (1) {\n                if (size == 0) {\n                    res = AVERROR_EOF;\n                    break;\n                }\n                temp = *data;\n                lace_size[n] += temp;\n                data += 1;\n                size -= 1;\n                if (temp != 0xff)\n                    break;\n            }\n            total += lace_size[n];\n        }\n        if (size <= total) {\n            res = AVERROR_INVALIDDATA;\n            break;\n        }\n\n        lace_size[n] = size - total;\n        break;\n    }\n\n    case 0x2: /* fixed-size lacing */\n        if (size % (*laces)) {\n            res = AVERROR_INVALIDDATA;\n            break;\n        }\n        for (n = 0; n < *laces; n++)\n            lace_size[n] = size / *laces;\n        break;\n\n    case 0x3: /* EBML lacing */ {\n        uint64_t num;\n        uint32_t total;\n        n = matroska_ebmlnum_uint(matroska, data, size, &num);\n        if (n < 0) {\n            av_log(matroska->ctx, AV_LOG_INFO,\n                   \"EBML block data error\\n\");\n            res = n;\n            break;\n        }\n        data += n;\n        size -= n;\n        total = lace_size[0] = num;\n        for (n = 1; res == 0 && n < *laces - 1; n++) {\n            int64_t snum;\n            int r;\n            r = matroska_ebmlnum_sint(matroska, data, size, &snum);\n            if (r < 0) {\n                av_log(matroska->ctx, AV_LOG_INFO,\n                       \"EBML block data error\\n\");\n                res = r;\n                break;\n            }\n            data += r;\n            size -= r;\n            lace_size[n] = lace_size[n - 1] + snum;\n            total += lace_size[n];\n        }\n        if (size <= total) {\n            res = AVERROR_INVALIDDATA;\n            break;\n        }\n        lace_size[*laces - 1] = size - total;\n        break;\n    }\n    }\n\n    *buf      = data;\n    *lace_buf = lace_size;\n\n    return res;\n}", "patch_func_code": "static int matroska_parse_laces(MatroskaDemuxContext *matroska, uint8_t **buf,\n                                int* buf_size, int type,\n                                uint32_t **lace_buf, int *laces)\n{\n    int res = 0, n, size = *buf_size;\n    uint8_t *data = *buf;\n    uint32_t *lace_size;\n\n    if (!type) {\n        *laces = 1;\n        *lace_buf = av_mallocz(sizeof(int));\n        if (!*lace_buf)\n            return AVERROR(ENOMEM);\n\n        *lace_buf[0] = size;\n        return 0;\n    }\n\n    av_assert0(size > 0);\n    *laces = *data + 1;\n    data += 1;\n    size -= 1;\n    lace_size = av_mallocz(*laces * sizeof(int));\n    if (!lace_size)\n        return AVERROR(ENOMEM);\n\n    switch (type) {\n    case 0x1: /* Xiph lacing */ {\n        uint8_t temp;\n        uint32_t total = 0;\n        for (n = 0; res == 0 && n < *laces - 1; n++) {\n            while (1) {\n                if (size == 0) {\n                    res = AVERROR_EOF;\n                    break;\n                }\n                temp = *data;\n                lace_size[n] += temp;\n                data += 1;\n                size -= 1;\n                if (temp != 0xff)\n                    break;\n            }\n            total += lace_size[n];\n        }\n        if (size <= total) {\n            res = AVERROR_INVALIDDATA;\n            break;\n        }\n\n        lace_size[n] = size - total;\n        break;\n    }\n\n    case 0x2: /* fixed-size lacing */\n        if (size % (*laces)) {\n            res = AVERROR_INVALIDDATA;\n            break;\n        }\n        for (n = 0; n < *laces; n++)\n            lace_size[n] = size / *laces;\n        break;\n\n    case 0x3: /* EBML lacing */ {\n        uint64_t num;\n        uint32_t total;\n        n = matroska_ebmlnum_uint(matroska, data, size, &num);\n        if (n < 0) {\n            av_log(matroska->ctx, AV_LOG_INFO,\n                   \"EBML block data error\\n\");\n            res = n;\n            break;\n        }\n        data += n;\n        size -= n;\n        total = lace_size[0] = num;\n        for (n = 1; res == 0 && n < *laces - 1; n++) {\n            int64_t snum;\n            int r;\n            r = matroska_ebmlnum_sint(matroska, data, size, &snum);\n            if (r < 0) {\n                av_log(matroska->ctx, AV_LOG_INFO,\n                       \"EBML block data error\\n\");\n                res = r;\n                break;\n            }\n            data += r;\n            size -= r;\n            lace_size[n] = lace_size[n - 1] + snum;\n            total += lace_size[n];\n        }\n        if (size <= total) {\n            res = AVERROR_INVALIDDATA;\n            break;\n        }\n        lace_size[*laces - 1] = size - total;\n        break;\n    }\n    }\n\n    *buf      = data;\n    *lace_buf = lace_size;\n    *buf_size = size;\n\n    return res;\n}", "before_change_lines": [2, 5], "raw_before_change_lines": [2, 5], "after_change_lines": [2, 5, 103], "raw_after_change_lines": [2, 5, 103], "bug_lines": [2, 5], "added": [false, false], "idx": 133}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2221----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7a8d6eb09749cba01ac6dfc7afe8062d7eb83186_1.json----ff_vorbis_floor1_render_list", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_7a8d6eb09749cba01ac6dfc7afe8062d7eb83186_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7a8d6eb09749cba01ac6dfc7afe8062d7eb83186_1.json", "function_name": "ff_vorbis_floor1_render_list", "vul_func_code": "void ff_vorbis_floor1_render_list(vorbis_floor1_entry * list, int values,\n                                  uint16_t *y_list, int *flag,\n                                  int multiplier, float *out, int samples)\n{\n    int lx, i;\n    uint8_t ly;\n    lx = 0;\n    ly = y_list[0] * multiplier;\n    for (i = 1; i < values; i++) {\n        int pos = list[i].sort;\n        if (flag[pos]) {\n            int x1 = list[pos].x;\n            int y1 = y_list[pos] * multiplier;\n            if (lx < samples)\n                render_line(lx, ly, FFMIN(x1,samples), y1, out);\n            lx = x1;\n            ly = y1;\n        }\n        if (lx >= samples)\n            break;\n    }\n    if (lx < samples)\n        render_line(lx, ly, samples, ly, out);\n}", "patch_func_code": "void ff_vorbis_floor1_render_list(vorbis_floor1_entry * list, int values,\n                                  uint16_t *y_list, int *flag,\n                                  int multiplier, float *out, int samples)\n{\n    int lx, ly, i;\n    lx = 0;\n    ly = y_list[0] * multiplier;\n    for (i = 1; i < values; i++) {\n        int pos = list[i].sort;\n        if (flag[pos]) {\n            int x1 = list[pos].x;\n            int y1 = y_list[pos] * multiplier;\n            if (lx < samples)\n                render_line(lx, ly, FFMIN(x1,samples), y1, out);\n            lx = x1;\n            ly = y1;\n        }\n        if (lx >= samples)\n            break;\n    }\n    if (lx < samples)\n        render_line(lx, ly, samples, ly, out);\n}", "before_change_lines": [5, 6], "raw_before_change_lines": [5, 6], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5, 6], "added": [false, false], "idx": 134}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2237----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7b5b33895239e2c60fc450b5dea8b3833d9ade44_1.json----ff_rdft_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_7b5b33895239e2c60fc450b5dea8b3833d9ade44_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7b5b33895239e2c60fc450b5dea8b3833d9ade44_1.json", "function_name": "ff_rdft_init", "vul_func_code": "int ff_rdft_init(RDFTContext *s, int nbits, enum RDFTransformType trans)\n{\n    int n = 1 << nbits;\n    int ret;\n\n    s->nbits           = nbits;\n    s->inverse         = trans == IDFT_C2R || trans == DFT_C2R;\n    s->sign_convention = trans == IDFT_R2C || trans == DFT_C2R ? 1 : -1;\n\n    if (nbits < 4 || nbits > 16)\n        return AVERROR(EINVAL);\n\n    if ((ret = ff_fft_init(&s->fft, nbits-1, trans == IDFT_C2R || trans == IDFT_R2C)) < 0)\n        return ret;\n\n    ff_init_ff_cos_tabs(nbits);\n    s->tcos = ff_cos_tabs[nbits];\n    s->tsin = ff_sin_tabs[nbits]+(trans == DFT_R2C || trans == DFT_C2R)*(n>>2);\n#if !CONFIG_HARDCODED_TABLES\n    {\n        int i;\n        const double theta = (trans == DFT_R2C || trans == DFT_C2R ? -1 : 1) * 2 * M_PI / n;\n        for (i = 0; i < (n >> 2); i++)\n            s->tsin[i] = sin(i * theta);\n    }\n#endif\n    s->rdft_calc   = rdft_calc_c;\n\n    if (ARCH_ARM) ff_rdft_init_arm(s);\n\n    return 0;\n}", "patch_func_code": "int ff_rdft_init(RDFTContext *s, int nbits, enum RDFTransformType trans)\n{\n    int n = 1 << nbits;\n    int ret;\n\n    s->nbits           = nbits;\n    s->inverse         = trans == IDFT_C2R || trans == DFT_C2R;\n    s->sign_convention = trans == IDFT_R2C || trans == DFT_C2R ? 1 : -1;\n    s->negative_sin    = trans == DFT_C2R || trans == DFT_R2C;\n\n    if (nbits < 4 || nbits > 16)\n        return AVERROR(EINVAL);\n\n    if ((ret = ff_fft_init(&s->fft, nbits-1, trans == IDFT_C2R || trans == IDFT_R2C)) < 0)\n        return ret;\n\n    ff_init_ff_cos_tabs(nbits);\n    s->tcos = ff_cos_tabs[nbits];\n    s->tsin = ff_cos_tabs[nbits] + (n >> 2);\n    s->rdft_calc   = rdft_calc_c;\n\n    if (ARCH_ARM) ff_rdft_init_arm(s);\n\n    return 0;\n}", "before_change_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26], "raw_before_change_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26], "after_change_lines": [9, 19], "raw_after_change_lines": [9, 19], "bug_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26], "added": [false, false, false, false, false, false, false, false, false], "idx": 135}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2316----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7ed302c0c8e84065e5348dee4bb67cb534b45b40_1.json----get_ue_code", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_7ed302c0c8e84065e5348dee4bb67cb534b45b40_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7ed302c0c8e84065e5348dee4bb67cb534b45b40_1.json", "function_name": "get_ue_code", "vul_func_code": "static inline int get_ue_code(GetBitContext *gb, int order)\n{\n    if (order) {\n        int ret = get_ue_golomb(gb) << order;\n        return ret + get_bits(gb, order);\n    }\n    return get_ue_golomb(gb);\n}", "patch_func_code": "static inline int get_ue_code(GetBitContext *gb, int order)\n{\n    unsigned ret = get_ue_golomb(gb);\n    if (ret >= ((1U<<31)>>order)) {\n        av_log(NULL, AV_LOG_ERROR, \"get_ue_code: value too larger\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (order) {\n        return (ret<<order) + get_bits(gb, order);\n    }\n    return ret;\n}", "before_change_lines": [4, 5, 7], "raw_before_change_lines": [4, 5, 7], "after_change_lines": [3, 4, 5, 6, 7, 9, 11], "raw_after_change_lines": [3, 4, 5, 6, 7, 9, 11], "bug_lines": [4, 5, 7], "added": [false, false, false], "idx": 136}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2332----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7fc1a41337194f64e17dad00d263c42a3daee8c9_1.json----ff_network_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_7fc1a41337194f64e17dad00d263c42a3daee8c9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_7fc1a41337194f64e17dad00d263c42a3daee8c9_1.json", "function_name": "ff_network_init", "vul_func_code": "int ff_network_init(void)\n{\n#if HAVE_WINSOCK2_H\n    WSADATA wsaData;\n#endif\n\n    if (!ff_network_inited_globally)\n        av_log(NULL, AV_LOG_WARNING, \"Using network protocols without global \"\n                                     \"network initialization. Please use \"\n                                     \"avformat_network_init(), this will \"\n                                     \"become mandatory later.\\n\");\n#if HAVE_WINSOCK2_H\n    if (WSAStartup(MAKEWORD(1,1), &wsaData))\n        return 0;\n#endif\n    return 1;\n}", "patch_func_code": "int ff_network_init(void)\n{\n#if HAVE_WINSOCK2_H\n    WSADATA wsaData;\n\n    if (WSAStartup(MAKEWORD(1,1), &wsaData))\n        return 0;\n#endif\n    return 1;\n}", "before_change_lines": [5, 7, 8, 9, 10, 11, 12], "raw_before_change_lines": [5, 7, 8, 9, 10, 11, 12], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [5, 7, 8, 9, 10, 11, 12], "added": [false, false, false, false, false, false, false], "idx": 137}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "2381----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_830e60e1fa6467b5383f77ad0dfd7c69a29d5300_1.json----swr_convert_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_830e60e1fa6467b5383f77ad0dfd7c69a29d5300_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_830e60e1fa6467b5383f77ad0dfd7c69a29d5300_1.json", "function_name": "swr_convert_frame", "vul_func_code": "int swr_convert_frame(SwrContext *s,\n                      AVFrame *out, const AVFrame *in)\n{\n    int ret, setup = 0;\n\n    if (!swr_is_initialized(s)) {\n        if ((ret = swr_config_frame(s, out, in)) < 0)\n            return ret;\n        if ((ret = swr_init(s)) < 0)\n            return ret;\n        setup = 1;\n    } else {\n        // return as is or reconfigure for input changes?\n        if ((ret = config_changed(s, out, in)))\n            return ret;\n    }\n\n    if (out) {\n        if (!out->linesize[0]) {\n            out->nb_samples =   swr_get_delay(s, s->out_sample_rate)\n                              + in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate\n                              + 3;\n            if ((ret = av_frame_get_buffer(out, 0)) < 0) {\n                if (setup)\n                    swr_close(s);\n                return ret;\n            }\n        } else {\n            if (!out->nb_samples)\n                out->nb_samples = available_samples(out);\n        }\n    }\n\n    return convert_frame(s, out, in);\n}", "patch_func_code": "int swr_convert_frame(SwrContext *s,\n                      AVFrame *out, const AVFrame *in)\n{\n    int ret, setup = 0;\n\n    if (!swr_is_initialized(s)) {\n        if ((ret = swr_config_frame(s, out, in)) < 0)\n            return ret;\n        if ((ret = swr_init(s)) < 0)\n            return ret;\n        setup = 1;\n    } else {\n        // return as is or reconfigure for input changes?\n        if ((ret = config_changed(s, out, in)))\n            return ret;\n    }\n\n    if (out) {\n        if (!out->linesize[0]) {\n            out->nb_samples = swr_get_delay(s, s->out_sample_rate) + 3;\n            if (in) {\n                out->nb_samples += in->nb_samples*(int64_t)s->out_sample_rate / s->in_sample_rate;\n            }\n            if ((ret = av_frame_get_buffer(out, 0)) < 0) {\n                if (setup)\n                    swr_close(s);\n                return ret;\n            }\n        } else {\n            if (!out->nb_samples)\n                out->nb_samples = available_samples(out);\n        }\n    }\n\n    return convert_frame(s, out, in);\n}", "before_change_lines": [20, 21, 22], "raw_before_change_lines": [20, 21, 22], "after_change_lines": [20, 21, 22, 23], "raw_after_change_lines": [20, 21, 22, 23], "bug_lines": [20, 21, 22], "added": [false, false, false], "idx": 138}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2409----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_84997102a67e8c1aa24c8ba3ee798a490b330d2f_1.json----xan_decode_chroma", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_84997102a67e8c1aa24c8ba3ee798a490b330d2f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_84997102a67e8c1aa24c8ba3ee798a490b330d2f_1.json", "function_name": "xan_decode_chroma", "vul_func_code": "static int xan_decode_chroma(AVCodecContext *avctx, unsigned chroma_off)\n{\n    XanContext *s = avctx->priv_data;\n    uint8_t *U, *V;\n    int val, uval, vval;\n    int i, j;\n    const uint8_t *src, *src_end;\n    const uint8_t *table;\n    int mode, offset, dec_size;\n\n    if (!chroma_off)\n        return 0;\n    if (chroma_off + 4 >= bytestream2_get_bytes_left(&s->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid chroma block position\\n\");\n        return -1;\n    }\n    bytestream2_seek(&s->gb, chroma_off + 4, SEEK_SET);\n    mode   = bytestream2_get_le16(&s->gb);\n    table  = s->gb.buffer;\n    offset = bytestream2_get_le16(&s->gb) * 2;\n\n    if (offset >= bytestream2_get_bytes_left(&s->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid chroma block offset\\n\");\n        return -1;\n    }\n\n    bytestream2_skip(&s->gb, offset);\n    memset(s->scratch_buffer, 0, s->buffer_size);\n    dec_size = xan_unpack(s, s->scratch_buffer, s->buffer_size);\n    if (dec_size < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Chroma unpacking failed\\n\");\n        return -1;\n    }\n\n    U = s->pic.data[1];\n    V = s->pic.data[2];\n    src     = s->scratch_buffer;\n    src_end = src + dec_size;\n    if (mode) {\n        for (j = 0; j < avctx->height >> 1; j++) {\n            for (i = 0; i < avctx->width >> 1; i++) {\n                val = *src++;\n                if (val) {\n                    val  = AV_RL16(table + (val << 1));\n                    uval = (val >> 3) & 0xF8;\n                    vval = (val >> 8) & 0xF8;\n                    U[i] = uval | (uval >> 5);\n                    V[i] = vval | (vval >> 5);\n                }\n                if (src == src_end)\n                    return 0;\n            }\n            U += s->pic.linesize[1];\n            V += s->pic.linesize[2];\n        }\n    } else {\n        uint8_t *U2 = U + s->pic.linesize[1];\n        uint8_t *V2 = V + s->pic.linesize[2];\n\n        for (j = 0; j < avctx->height >> 2; j++) {\n            for (i = 0; i < avctx->width >> 1; i += 2) {\n                val = *src++;\n                if (val) {\n                    val  = AV_RL16(table + (val << 1));\n                    uval = (val >> 3) & 0xF8;\n                    vval = (val >> 8) & 0xF8;\n                    U[i] = U[i+1] = U2[i] = U2[i+1] = uval | (uval >> 5);\n                    V[i] = V[i+1] = V2[i] = V2[i+1] = vval | (vval >> 5);\n                }\n            }\n            U  += s->pic.linesize[1] * 2;\n            V  += s->pic.linesize[2] * 2;\n            U2 += s->pic.linesize[1] * 2;\n            V2 += s->pic.linesize[2] * 2;\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int xan_decode_chroma(AVCodecContext *avctx, unsigned chroma_off)\n{\n    XanContext *s = avctx->priv_data;\n    uint8_t *U, *V;\n    int val, uval, vval;\n    int i, j;\n    const uint8_t *src, *src_end;\n    const uint8_t *table;\n    int mode, offset, dec_size, table_size;\n\n    if (!chroma_off)\n        return 0;\n    if (chroma_off + 4 >= bytestream2_get_bytes_left(&s->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid chroma block position\\n\");\n        return -1;\n    }\n    bytestream2_seek(&s->gb, chroma_off + 4, SEEK_SET);\n    mode        = bytestream2_get_le16(&s->gb);\n    table       = s->gb.buffer;\n    table_size  = bytestream2_get_le16(&s->gb);\n    offset      = table_size * 2;\n    table_size += 1;\n\n    if (offset >= bytestream2_get_bytes_left(&s->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid chroma block offset\\n\");\n        return -1;\n    }\n\n    bytestream2_skip(&s->gb, offset);\n    memset(s->scratch_buffer, 0, s->buffer_size);\n    dec_size = xan_unpack(s, s->scratch_buffer, s->buffer_size);\n    if (dec_size < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Chroma unpacking failed\\n\");\n        return -1;\n    }\n\n    U = s->pic.data[1];\n    V = s->pic.data[2];\n    src     = s->scratch_buffer;\n    src_end = src + dec_size;\n    if (mode) {\n        for (j = 0; j < avctx->height >> 1; j++) {\n            for (i = 0; i < avctx->width >> 1; i++) {\n                val = *src++;\n                if (val && val < table_size) {\n                    val  = AV_RL16(table + (val << 1));\n                    uval = (val >> 3) & 0xF8;\n                    vval = (val >> 8) & 0xF8;\n                    U[i] = uval | (uval >> 5);\n                    V[i] = vval | (vval >> 5);\n                }\n                if (src == src_end)\n                    return 0;\n            }\n            U += s->pic.linesize[1];\n            V += s->pic.linesize[2];\n        }\n    } else {\n        uint8_t *U2 = U + s->pic.linesize[1];\n        uint8_t *V2 = V + s->pic.linesize[2];\n\n        for (j = 0; j < avctx->height >> 2; j++) {\n            for (i = 0; i < avctx->width >> 1; i += 2) {\n                val = *src++;\n                if (val && val < table_size) {\n                    val  = AV_RL16(table + (val << 1));\n                    uval = (val >> 3) & 0xF8;\n                    vval = (val >> 8) & 0xF8;\n                    U[i] = U[i+1] = U2[i] = U2[i+1] = uval | (uval >> 5);\n                    V[i] = V[i+1] = V2[i] = V2[i+1] = vval | (vval >> 5);\n                }\n            }\n            U  += s->pic.linesize[1] * 2;\n            V  += s->pic.linesize[2] * 2;\n            U2 += s->pic.linesize[1] * 2;\n            V2 += s->pic.linesize[2] * 2;\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [9, 18, 19, 20, 43, 63], "raw_before_change_lines": [9, 18, 19, 20, 43, 63], "after_change_lines": [9, 18, 19, 20, 21, 22, 45, 65], "raw_after_change_lines": [9, 18, 19, 20, 21, 22, 45, 65], "bug_lines": [9, 18, 19, 20, 43, 63], "added": [false, false, false, false, false, false], "idx": 139}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2454----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_8646ed0f061439ee9b19dcb370d3bab11d889799_1.json----postprocess_chroma", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_8646ed0f061439ee9b19dcb370d3bab11d889799_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_8646ed0f061439ee9b19dcb370d3bab11d889799_1.json", "function_name": "postprocess_chroma", "vul_func_code": "static void postprocess_chroma(AVFrame *frame, int w, int h, int depth)\n{\n    uint16_t *dstu = (uint16_t *)frame->data[1];\n    uint16_t *dstv = (uint16_t *)frame->data[2];\n    int16_t *srcu  = (int16_t *)frame->data[1];\n    int16_t *srcv  = (int16_t *)frame->data[2];\n    ptrdiff_t strideu = frame->linesize[1] / 2;\n    ptrdiff_t stridev = frame->linesize[2] / 2;\n    const int add = 1 << (depth - 1);\n    const int shift = 16 - depth;\n    int i, j;\n\n    for (j = 0; j < h; j++) {\n        for (i = 0; i < w; i++) {\n            dstu[i] = (add + srcu[i]) << shift;\n            dstv[i] = (add + srcv[i]) << shift;\n        }\n        dstu += strideu;\n        dstv += stridev;\n        srcu += strideu;\n        srcv += stridev;\n    }\n}", "patch_func_code": "static void postprocess_chroma(AVFrame *frame, int w, int h, int depth)\n{\n    uint16_t *dstu = (uint16_t *)frame->data[1];\n    uint16_t *dstv = (uint16_t *)frame->data[2];\n    int16_t *srcu  = (int16_t *)frame->data[1];\n    int16_t *srcv  = (int16_t *)frame->data[2];\n    ptrdiff_t strideu = frame->linesize[1] / 2;\n    ptrdiff_t stridev = frame->linesize[2] / 2;\n    const unsigned add = 1 << (depth - 1);\n    const unsigned shift = 16 - depth;\n    int i, j;\n\n    for (j = 0; j < h; j++) {\n        for (i = 0; i < w; i++) {\n            dstu[i] = (add + srcu[i]) << shift;\n            dstv[i] = (add + srcv[i]) << shift;\n        }\n        dstu += strideu;\n        dstv += stridev;\n        srcu += strideu;\n        srcv += stridev;\n    }\n}", "before_change_lines": [9, 10], "raw_before_change_lines": [9, 10], "after_change_lines": [9, 10], "raw_after_change_lines": [9, 10], "bug_lines": [9, 10], "added": [false, false], "idx": 140}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "2627----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_8fdbf9229c9c41870deb575966de3e6367de0c19_1.json----ftp_abort", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_8fdbf9229c9c41870deb575966de3e6367de0c19_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_8fdbf9229c9c41870deb575966de3e6367de0c19_1.json", "function_name": "ftp_abort", "vul_func_code": "static int ftp_abort(URLContext *h)\n{\n    static const char *command = \"ABOR\\r\\n\";\n    int err;\n    static const int abor_codes[] = {225, 226, 0};\n    FTPContext *s = h->priv_data;\n\n    /* According to RCF 959:\n       \"ABOR command tells the server to abort the previous FTP\n       service command and any associated transfer of data.\"\n\n       There are FTP server implementations that don't response\n       to any commands during data transfer in passive mode (including ABOR).\n\n       This implementation closes data connection by force.\n    */\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n        ftp_close_both_connections(s);\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n            return err;\n        }\n    } else {\n        ftp_close_data_connection(s);\n    }\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n        /* wu-ftpd also closes control connection after data connection closing */\n        ffurl_closep(&s->conn_control);\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n            return err;\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int ftp_abort(URLContext *h)\n{\n    static const char *command = \"ABOR\\r\\n\";\n    int err;\n    static const int abor_codes[] = {225, 226, 0};\n    FTPContext *s = h->priv_data;\n\n    /* According to RCF 959:\n       \"ABOR command tells the server to abort the previous FTP\n       service command and any associated transfer of data.\"\n\n       There are FTP server implementations that don't response\n       to any commands during data transfer in passive mode (including ABOR).\n\n       This implementation closes data connection by force.\n    */\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n        ftp_close_both_connections(s);\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n            return err;\n        }\n    } else {\n        ftp_close_data_connection(s);\n        if (ftp_status(s, NULL, abor_codes) < 225) {\n            /* wu-ftpd also closes control connection after data connection closing */\n            ffurl_closep(&s->conn_control);\n            if ((err = ftp_connect_control_connection(h)) < 0) {\n                av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n                return err;\n            }\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [26, 28, 30, 31, 32, 33], "raw_before_change_lines": [26, 27, 28, 29, 30, 31, 32, 33], "after_change_lines": [26, 28, 29, 30, 31, 32], "raw_after_change_lines": [26, 27, 28, 29, 30, 31, 32], "bug_lines": [26, 27, 28, 29, 30, 31, 32, 33], "added": [false, false, false, false, false, false, false, false], "idx": 141}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2643----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_908810897ccfd9cd8c0616e10c40adba93da019d_1.json----pred_weight_table", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_908810897ccfd9cd8c0616e10c40adba93da019d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_908810897ccfd9cd8c0616e10c40adba93da019d_1.json", "function_name": "pred_weight_table", "vul_func_code": "static void pred_weight_table(HEVCContext *s, GetBitContext *gb)\n{\n    int i = 0;\n    int j = 0;\n    uint8_t luma_weight_l0_flag[16];\n    uint8_t chroma_weight_l0_flag[16];\n    uint8_t luma_weight_l1_flag[16];\n    uint8_t chroma_weight_l1_flag[16];\n    int luma_log2_weight_denom;\n\n    luma_log2_weight_denom = get_ue_golomb_long(gb);\n    if (luma_log2_weight_denom < 0 || luma_log2_weight_denom > 7)\n        av_log(s->avctx, AV_LOG_ERROR, \"luma_log2_weight_denom %d is invalid\\n\", luma_log2_weight_denom);\n    s->sh.luma_log2_weight_denom = av_clip_uintp2(luma_log2_weight_denom, 3);\n    if (s->ps.sps->chroma_format_idc != 0) {\n        int delta = get_se_golomb(gb);\n        s->sh.chroma_log2_weight_denom = av_clip_uintp2(s->sh.luma_log2_weight_denom + delta, 3);\n    }\n\n    for (i = 0; i < s->sh.nb_refs[L0]; i++) {\n        luma_weight_l0_flag[i] = get_bits1(gb);\n        if (!luma_weight_l0_flag[i]) {\n            s->sh.luma_weight_l0[i] = 1 << s->sh.luma_log2_weight_denom;\n            s->sh.luma_offset_l0[i] = 0;\n        }\n    }\n    if (s->ps.sps->chroma_format_idc != 0) {\n        for (i = 0; i < s->sh.nb_refs[L0]; i++)\n            chroma_weight_l0_flag[i] = get_bits1(gb);\n    } else {\n        for (i = 0; i < s->sh.nb_refs[L0]; i++)\n            chroma_weight_l0_flag[i] = 0;\n    }\n    for (i = 0; i < s->sh.nb_refs[L0]; i++) {\n        if (luma_weight_l0_flag[i]) {\n            int delta_luma_weight_l0 = get_se_golomb(gb);\n            s->sh.luma_weight_l0[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l0;\n            s->sh.luma_offset_l0[i] = get_se_golomb(gb);\n        }\n        if (chroma_weight_l0_flag[i]) {\n            for (j = 0; j < 2; j++) {\n                int delta_chroma_weight_l0 = get_se_golomb(gb);\n                int delta_chroma_offset_l0 = get_se_golomb(gb);\n                s->sh.chroma_weight_l0[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l0;\n                s->sh.chroma_offset_l0[i][j] = av_clip((delta_chroma_offset_l0 - ((128 * s->sh.chroma_weight_l0[i][j])\n                                                                                    >> s->sh.chroma_log2_weight_denom) + 128), -128, 127);\n            }\n        } else {\n            s->sh.chroma_weight_l0[i][0] = 1 << s->sh.chroma_log2_weight_denom;\n            s->sh.chroma_offset_l0[i][0] = 0;\n            s->sh.chroma_weight_l0[i][1] = 1 << s->sh.chroma_log2_weight_denom;\n            s->sh.chroma_offset_l0[i][1] = 0;\n        }\n    }\n    if (s->sh.slice_type == HEVC_SLICE_B) {\n        for (i = 0; i < s->sh.nb_refs[L1]; i++) {\n            luma_weight_l1_flag[i] = get_bits1(gb);\n            if (!luma_weight_l1_flag[i]) {\n                s->sh.luma_weight_l1[i] = 1 << s->sh.luma_log2_weight_denom;\n                s->sh.luma_offset_l1[i] = 0;\n            }\n        }\n        if (s->ps.sps->chroma_format_idc != 0) {\n            for (i = 0; i < s->sh.nb_refs[L1]; i++)\n                chroma_weight_l1_flag[i] = get_bits1(gb);\n        } else {\n            for (i = 0; i < s->sh.nb_refs[L1]; i++)\n                chroma_weight_l1_flag[i] = 0;\n        }\n        for (i = 0; i < s->sh.nb_refs[L1]; i++) {\n            if (luma_weight_l1_flag[i]) {\n                int delta_luma_weight_l1 = get_se_golomb(gb);\n                s->sh.luma_weight_l1[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l1;\n                s->sh.luma_offset_l1[i] = get_se_golomb(gb);\n            }\n            if (chroma_weight_l1_flag[i]) {\n                for (j = 0; j < 2; j++) {\n                    int delta_chroma_weight_l1 = get_se_golomb(gb);\n                    int delta_chroma_offset_l1 = get_se_golomb(gb);\n                    s->sh.chroma_weight_l1[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l1;\n                    s->sh.chroma_offset_l1[i][j] = av_clip((delta_chroma_offset_l1 - ((128 * s->sh.chroma_weight_l1[i][j])\n                                                                                        >> s->sh.chroma_log2_weight_denom) + 128), -128, 127);\n                }\n            } else {\n                s->sh.chroma_weight_l1[i][0] = 1 << s->sh.chroma_log2_weight_denom;\n                s->sh.chroma_offset_l1[i][0] = 0;\n                s->sh.chroma_weight_l1[i][1] = 1 << s->sh.chroma_log2_weight_denom;\n                s->sh.chroma_offset_l1[i][1] = 0;\n            }\n        }\n    }\n}", "patch_func_code": "static int pred_weight_table(HEVCContext *s, GetBitContext *gb)\n{\n    int i = 0;\n    int j = 0;\n    uint8_t luma_weight_l0_flag[16];\n    uint8_t chroma_weight_l0_flag[16];\n    uint8_t luma_weight_l1_flag[16];\n    uint8_t chroma_weight_l1_flag[16];\n    int luma_log2_weight_denom;\n\n    luma_log2_weight_denom = get_ue_golomb_long(gb);\n    if (luma_log2_weight_denom < 0 || luma_log2_weight_denom > 7)\n        av_log(s->avctx, AV_LOG_ERROR, \"luma_log2_weight_denom %d is invalid\\n\", luma_log2_weight_denom);\n    s->sh.luma_log2_weight_denom = av_clip_uintp2(luma_log2_weight_denom, 3);\n    if (s->ps.sps->chroma_format_idc != 0) {\n        int delta = get_se_golomb(gb);\n        s->sh.chroma_log2_weight_denom = av_clip_uintp2(s->sh.luma_log2_weight_denom + delta, 3);\n    }\n\n    for (i = 0; i < s->sh.nb_refs[L0]; i++) {\n        luma_weight_l0_flag[i] = get_bits1(gb);\n        if (!luma_weight_l0_flag[i]) {\n            s->sh.luma_weight_l0[i] = 1 << s->sh.luma_log2_weight_denom;\n            s->sh.luma_offset_l0[i] = 0;\n        }\n    }\n    if (s->ps.sps->chroma_format_idc != 0) {\n        for (i = 0; i < s->sh.nb_refs[L0]; i++)\n            chroma_weight_l0_flag[i] = get_bits1(gb);\n    } else {\n        for (i = 0; i < s->sh.nb_refs[L0]; i++)\n            chroma_weight_l0_flag[i] = 0;\n    }\n    for (i = 0; i < s->sh.nb_refs[L0]; i++) {\n        if (luma_weight_l0_flag[i]) {\n            int delta_luma_weight_l0 = get_se_golomb(gb);\n            s->sh.luma_weight_l0[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l0;\n            s->sh.luma_offset_l0[i] = get_se_golomb(gb);\n        }\n        if (chroma_weight_l0_flag[i]) {\n            for (j = 0; j < 2; j++) {\n                int delta_chroma_weight_l0 = get_se_golomb(gb);\n                int delta_chroma_offset_l0 = get_se_golomb(gb);\n\n                if (   (int8_t)delta_chroma_weight_l0 != delta_chroma_weight_l0\n                    || delta_chroma_offset_l0 < -(1<<17) || delta_chroma_offset_l0 > (1<<17)) {\n                    return AVERROR_INVALIDDATA;\n                }\n\n                s->sh.chroma_weight_l0[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l0;\n                s->sh.chroma_offset_l0[i][j] = av_clip((delta_chroma_offset_l0 - ((128 * s->sh.chroma_weight_l0[i][j])\n                                                                                    >> s->sh.chroma_log2_weight_denom) + 128), -128, 127);\n            }\n        } else {\n            s->sh.chroma_weight_l0[i][0] = 1 << s->sh.chroma_log2_weight_denom;\n            s->sh.chroma_offset_l0[i][0] = 0;\n            s->sh.chroma_weight_l0[i][1] = 1 << s->sh.chroma_log2_weight_denom;\n            s->sh.chroma_offset_l0[i][1] = 0;\n        }\n    }\n    if (s->sh.slice_type == HEVC_SLICE_B) {\n        for (i = 0; i < s->sh.nb_refs[L1]; i++) {\n            luma_weight_l1_flag[i] = get_bits1(gb);\n            if (!luma_weight_l1_flag[i]) {\n                s->sh.luma_weight_l1[i] = 1 << s->sh.luma_log2_weight_denom;\n                s->sh.luma_offset_l1[i] = 0;\n            }\n        }\n        if (s->ps.sps->chroma_format_idc != 0) {\n            for (i = 0; i < s->sh.nb_refs[L1]; i++)\n                chroma_weight_l1_flag[i] = get_bits1(gb);\n        } else {\n            for (i = 0; i < s->sh.nb_refs[L1]; i++)\n                chroma_weight_l1_flag[i] = 0;\n        }\n        for (i = 0; i < s->sh.nb_refs[L1]; i++) {\n            if (luma_weight_l1_flag[i]) {\n                int delta_luma_weight_l1 = get_se_golomb(gb);\n                s->sh.luma_weight_l1[i] = (1 << s->sh.luma_log2_weight_denom) + delta_luma_weight_l1;\n                s->sh.luma_offset_l1[i] = get_se_golomb(gb);\n            }\n            if (chroma_weight_l1_flag[i]) {\n                for (j = 0; j < 2; j++) {\n                    int delta_chroma_weight_l1 = get_se_golomb(gb);\n                    int delta_chroma_offset_l1 = get_se_golomb(gb);\n\n                    if (   (int8_t)delta_chroma_weight_l1 != delta_chroma_weight_l1\n                        || delta_chroma_offset_l1 < -(1<<17) || delta_chroma_offset_l1 > (1<<17)) {\n                        return AVERROR_INVALIDDATA;\n                    }\n\n                    s->sh.chroma_weight_l1[i][j] = (1 << s->sh.chroma_log2_weight_denom) + delta_chroma_weight_l1;\n                    s->sh.chroma_offset_l1[i][j] = av_clip((delta_chroma_offset_l1 - ((128 * s->sh.chroma_weight_l1[i][j])\n                                                                                        >> s->sh.chroma_log2_weight_denom) + 128), -128, 127);\n                }\n            } else {\n                s->sh.chroma_weight_l1[i][0] = 1 << s->sh.chroma_log2_weight_denom;\n                s->sh.chroma_offset_l1[i][0] = 0;\n                s->sh.chroma_weight_l1[i][1] = 1 << s->sh.chroma_log2_weight_denom;\n                s->sh.chroma_offset_l1[i][1] = 0;\n            }\n        }\n    }\n    return 0;\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1, 45, 46, 47, 48, 87, 88, 89, 90, 104], "raw_after_change_lines": [1, 44, 45, 46, 47, 48, 49, 86, 87, 88, 89, 90, 91, 104], "bug_lines": [1], "added": [false], "idx": 142}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2651----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_90fb6bb9c69c9102306aa06d8e43b3cc669b241e_1.json----dirac_unpack_block_motion_data", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_90fb6bb9c69c9102306aa06d8e43b3cc669b241e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_90fb6bb9c69c9102306aa06d8e43b3cc669b241e_1.json", "function_name": "dirac_unpack_block_motion_data", "vul_func_code": "static void dirac_unpack_block_motion_data(DiracContext *s)\n{\n    GetBitContext *gb = &s->gb;\n    uint8_t *sbsplit = s->sbsplit;\n    int i, x, y, q, p;\n    DiracArith arith[8];\n\n    align_get_bits(gb);\n\n    /* [DIRAC_STD] 11.2.4 and 12.2.1 Number of blocks and superblocks */\n    s->sbwidth  = DIVRNDUP(s->source.width,  4*s->plane[0].xbsep);\n    s->sbheight = DIVRNDUP(s->source.height, 4*s->plane[0].ybsep);\n    s->blwidth  = 4 * s->sbwidth;\n    s->blheight = 4 * s->sbheight;\n\n    /* [DIRAC_STD] 12.3.1 Superblock splitting modes. superblock_split_modes()\n       decode superblock split modes */\n    ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb));     /* svq3_get_ue_golomb(gb) is the length */\n    for (y = 0; y < s->sbheight; y++) {\n        for (x = 0; x < s->sbwidth; x++) {\n            int split  = dirac_get_arith_uint(arith, CTX_SB_F1, CTX_SB_DATA);\n            sbsplit[x] = (split + pred_sbsplit(sbsplit+x, s->sbwidth, x, y)) % 3;\n        }\n        sbsplit += s->sbwidth;\n    }\n\n    /* setup arith decoding */\n    ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb));\n    for (i = 0; i < s->num_refs; i++) {\n        ff_dirac_init_arith_decoder(arith + 4 + 2 * i, gb, svq3_get_ue_golomb(gb));\n        ff_dirac_init_arith_decoder(arith + 5 + 2 * i, gb, svq3_get_ue_golomb(gb));\n    }\n    for (i = 0; i < 3; i++)\n        ff_dirac_init_arith_decoder(arith+1+i, gb, svq3_get_ue_golomb(gb));\n\n    for (y = 0; y < s->sbheight; y++)\n        for (x = 0; x < s->sbwidth; x++) {\n            int blkcnt = 1 << s->sbsplit[y * s->sbwidth + x];\n            int step   = 4 >> s->sbsplit[y * s->sbwidth + x];\n\n            for (q = 0; q < blkcnt; q++)\n                for (p = 0; p < blkcnt; p++) {\n                    int bx = 4 * x + p*step;\n                    int by = 4 * y + q*step;\n                    DiracBlock *block = &s->blmotion[by*s->blwidth + bx];\n                    decode_block_params(s, arith, block, s->blwidth, bx, by);\n                    propagate_block_data(block, s->blwidth, step);\n                }\n        }\n}", "patch_func_code": "static int dirac_unpack_block_motion_data(DiracContext *s)\n{\n    GetBitContext *gb = &s->gb;\n    uint8_t *sbsplit = s->sbsplit;\n    int i, x, y, q, p;\n    DiracArith arith[8];\n\n    align_get_bits(gb);\n\n    /* [DIRAC_STD] 11.2.4 and 12.2.1 Number of blocks and superblocks */\n    s->sbwidth  = DIVRNDUP(s->source.width,  4*s->plane[0].xbsep);\n    s->sbheight = DIVRNDUP(s->source.height, 4*s->plane[0].ybsep);\n    s->blwidth  = 4 * s->sbwidth;\n    s->blheight = 4 * s->sbheight;\n\n    /* [DIRAC_STD] 12.3.1 Superblock splitting modes. superblock_split_modes()\n       decode superblock split modes */\n    ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb));     /* svq3_get_ue_golomb(gb) is the length */\n    for (y = 0; y < s->sbheight; y++) {\n        for (x = 0; x < s->sbwidth; x++) {\n            unsigned int split  = dirac_get_arith_uint(arith, CTX_SB_F1, CTX_SB_DATA);\n            if (split > 2)\n                return -1;\n            sbsplit[x] = (split + pred_sbsplit(sbsplit+x, s->sbwidth, x, y)) % 3;\n        }\n        sbsplit += s->sbwidth;\n    }\n\n    /* setup arith decoding */\n    ff_dirac_init_arith_decoder(arith, gb, svq3_get_ue_golomb(gb));\n    for (i = 0; i < s->num_refs; i++) {\n        ff_dirac_init_arith_decoder(arith + 4 + 2 * i, gb, svq3_get_ue_golomb(gb));\n        ff_dirac_init_arith_decoder(arith + 5 + 2 * i, gb, svq3_get_ue_golomb(gb));\n    }\n    for (i = 0; i < 3; i++)\n        ff_dirac_init_arith_decoder(arith+1+i, gb, svq3_get_ue_golomb(gb));\n\n    for (y = 0; y < s->sbheight; y++)\n        for (x = 0; x < s->sbwidth; x++) {\n            int blkcnt = 1 << s->sbsplit[y * s->sbwidth + x];\n            int step   = 4 >> s->sbsplit[y * s->sbwidth + x];\n\n            for (q = 0; q < blkcnt; q++)\n                for (p = 0; p < blkcnt; p++) {\n                    int bx = 4 * x + p*step;\n                    int by = 4 * y + q*step;\n                    DiracBlock *block = &s->blmotion[by*s->blwidth + bx];\n                    decode_block_params(s, arith, block, s->blwidth, bx, by);\n                    propagate_block_data(block, s->blwidth, step);\n                }\n        }\n\n    return 0;\n}", "before_change_lines": [1, 21], "raw_before_change_lines": [1, 21], "after_change_lines": [1, 21, 22, 23, 53], "raw_after_change_lines": [1, 21, 22, 23, 52, 53], "bug_lines": [1, 21], "added": [false, false], "idx": 143}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2730----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_95c01c5ffa82ba2594534b0753d9db773b594f63_1.json----dnxhd_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_95c01c5ffa82ba2594534b0753d9db773b594f63_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_95c01c5ffa82ba2594534b0753d9db773b594f63_1.json", "function_name": "dnxhd_decode_frame", "vul_func_code": "static int dnxhd_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    DNXHDContext *ctx = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int first_field = 1;\n    int ret, i;\n\n    ff_dlog(avctx, \"frame size %d\\n\", buf_size);\n\ndecode_coding_unit:\n    if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0)\n        return ret;\n\n    if ((avctx->width || avctx->height) &&\n        (ctx->width != avctx->width || ctx->height != avctx->height)) {\n        av_log(avctx, AV_LOG_WARNING, \"frame size changed: %dx%d -> %dx%d\\n\",\n               avctx->width, avctx->height, ctx->width, ctx->height);\n        first_field = 1;\n    }\n    if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) {\n        av_log(avctx, AV_LOG_WARNING, \"pix_fmt changed: %s -> %s\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt));\n        first_field = 1;\n    }\n\n    avctx->pix_fmt = ctx->pix_fmt;\n    ret = ff_set_dimensions(avctx, ctx->width, ctx->height);\n    if (ret < 0)\n        return ret;\n\n    if (first_field) {\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        picture->pict_type = AV_PICTURE_TYPE_I;\n        picture->key_frame = 1;\n    }\n\n    ctx->buf_size = buf_size - 0x280;\n    ctx->buf = buf + 0x280;\n    avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height);\n\n    if (first_field && picture->interlaced_frame) {\n        buf      += ctx->cid_table->coding_unit_size;\n        buf_size -= ctx->cid_table->coding_unit_size;\n        first_field = 0;\n        goto decode_coding_unit;\n    }\n\n    ret = 0;\n    for (i = 0; i < avctx->thread_count; i++) {\n        ret += ctx->rows[i].errors;\n        ctx->rows[i].errors = 0;\n    }\n\n    if (ret) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"%d lines with errors\\n\", ret);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *got_frame = 1;\n    return avpkt->size;\n}", "patch_func_code": "static int dnxhd_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    DNXHDContext *ctx = avctx->priv_data;\n    ThreadFrame frame = { .f = data };\n    AVFrame *picture = data;\n    int first_field = 1;\n    int ret, i;\n\n    ff_dlog(avctx, \"frame size %d\\n\", buf_size);\n\ndecode_coding_unit:\n    if ((ret = dnxhd_decode_header(ctx, picture, buf, buf_size, first_field)) < 0)\n        return ret;\n\n    if ((avctx->width || avctx->height) &&\n        (ctx->width != avctx->width || ctx->height != avctx->height)) {\n        av_log(avctx, AV_LOG_WARNING, \"frame size changed: %dx%d -> %dx%d\\n\",\n               avctx->width, avctx->height, ctx->width, ctx->height);\n        first_field = 1;\n    }\n    if (avctx->pix_fmt != AV_PIX_FMT_NONE && avctx->pix_fmt != ctx->pix_fmt) {\n        av_log(avctx, AV_LOG_WARNING, \"pix_fmt changed: %s -> %s\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt), av_get_pix_fmt_name(ctx->pix_fmt));\n        first_field = 1;\n    }\n\n    avctx->pix_fmt = ctx->pix_fmt;\n    ret = ff_set_dimensions(avctx, ctx->width, ctx->height);\n    if (ret < 0)\n        return ret;\n\n    if (first_field) {\n        if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0)\n            return ret;\n        picture->pict_type = AV_PICTURE_TYPE_I;\n        picture->key_frame = 1;\n    }\n\n    ctx->buf_size = buf_size - ctx->data_offset;\n    ctx->buf = buf + ctx->data_offset;\n    avctx->execute2(avctx, dnxhd_decode_row, picture, NULL, ctx->mb_height);\n\n    if (first_field && picture->interlaced_frame) {\n        buf      += ctx->cid_table->coding_unit_size;\n        buf_size -= ctx->cid_table->coding_unit_size;\n        first_field = 0;\n        goto decode_coding_unit;\n    }\n\n    ret = 0;\n    for (i = 0; i < avctx->thread_count; i++) {\n        ret += ctx->rows[i].errors;\n        ctx->rows[i].errors = 0;\n    }\n\n    if (ret) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"%d lines with errors\\n\", ret);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *got_frame = 1;\n    return avpkt->size;\n}", "before_change_lines": [42, 43], "raw_before_change_lines": [42, 43], "after_change_lines": [42, 43], "raw_after_change_lines": [42, 43], "bug_lines": [42, 43], "added": [false, false], "idx": 144}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2736----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_95fdf3b8e74ed7632fc16e543e0041b3b7a719d9_1.json----RENAME", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_95fdf3b8e74ed7632fc16e543e0041b3b7a719d9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_95fdf3b8e74ed7632fc16e543e0041b3b7a719d9_1.json", "function_name": "RENAME", "vul_func_code": "static int RENAME(resample_common)(ResampleContext *c,\n                                   DELEM *dst, const DELEM *src,\n                                   int n, int update_ctx)\n{\n    int dst_index;\n    int index= c->index;\n    int frac= c->frac;\n    int sample_index = index >> c->phase_shift;\n\n    index &= c->phase_mask;\n    for (dst_index = 0; dst_index < n; dst_index++) {\n        FELEM *filter = ((FELEM *) c->filter_bank) + c->filter_alloc * index;\n\n        FELEM2 val=0;\n        int i;\n        for (i = 0; i < c->filter_length; i++) {\n            val += src[sample_index + i] * (FELEM2)filter[i];\n        }\n        OUT(dst[dst_index], val);\n\n        frac  += c->dst_incr_mod;\n        index += c->dst_incr_div;\n        if (frac >= c->src_incr) {\n            frac -= c->src_incr;\n            index++;\n        }\n        sample_index += index >> c->phase_shift;\n        index &= c->phase_mask;\n    }\n\n    if(update_ctx){\n        c->frac= frac;\n        c->index= index;\n    }\n\n    return sample_index;\n}", "patch_func_code": "static int RENAME(resample_common)(ResampleContext *c,\n                                   void *dest, const void *source,\n                                   int n, int update_ctx)\n{\n    DELEM *dst = dest;\n    const DELEM *src = source;\n    int dst_index;\n    int index= c->index;\n    int frac= c->frac;\n    int sample_index = index >> c->phase_shift;\n\n    index &= c->phase_mask;\n    for (dst_index = 0; dst_index < n; dst_index++) {\n        FELEM *filter = ((FELEM *) c->filter_bank) + c->filter_alloc * index;\n\n        FELEM2 val=0;\n        int i;\n        for (i = 0; i < c->filter_length; i++) {\n            val += src[sample_index + i] * (FELEM2)filter[i];\n        }\n        OUT(dst[dst_index], val);\n\n        frac  += c->dst_incr_mod;\n        index += c->dst_incr_div;\n        if (frac >= c->src_incr) {\n            frac -= c->src_incr;\n            index++;\n        }\n        sample_index += index >> c->phase_shift;\n        index &= c->phase_mask;\n    }\n\n    if(update_ctx){\n        c->frac= frac;\n        c->index= index;\n    }\n\n    return sample_index;\n}", "before_change_lines": [2], "raw_before_change_lines": [2], "after_change_lines": [2, 5, 6], "raw_after_change_lines": [2, 5, 6], "bug_lines": [2], "added": [false], "idx": 145}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2737----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_96277c84464fbadad29cd8f534c3f4aa3b8682d3_1.json----srt_to_ass", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_96277c84464fbadad29cd8f534c3f4aa3b8682d3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_96277c84464fbadad29cd8f534c3f4aa3b8682d3_1.json", "function_name": "srt_to_ass", "vul_func_code": "static void srt_to_ass(AVCodecContext *avctx, AVBPrint *dst,\n                       const char *in, int x1, int y1, int x2, int y2)\n{\n    if (x1 >= 0 && y1 >= 0) {\n        /* XXX: here we rescale coordinate assuming they are in DVD resolution\n         * (720x480) since we don't have anything better */\n\n        if (x2 >= 0 && y2 >= 0 && (x2 != x1 || y2 != y1) && x2 >= x1 && y2 >= y1) {\n            /* text rectangle defined, write the text at the center of the rectangle */\n            const int cx = x1 + (x2 - x1)/2;\n            const int cy = y1 + (y2 - y1)/2;\n            const int scaled_x = cx * ASS_DEFAULT_PLAYRESX / 720;\n            const int scaled_y = cy * ASS_DEFAULT_PLAYRESY / 480;\n            av_bprintf(dst, \"{\\\\an5}{\\\\pos(%d,%d)}\", scaled_x, scaled_y);\n        } else {\n            /* only the top left corner, assume the text starts in that corner */\n            const int scaled_x = x1 * ASS_DEFAULT_PLAYRESX / 720;\n            const int scaled_y = y1 * ASS_DEFAULT_PLAYRESY / 480;\n            av_bprintf(dst, \"{\\\\an1}{\\\\pos(%d,%d)}\", scaled_x, scaled_y);\n        }\n    }\n\n    ff_htmlmarkup_to_ass(avctx, dst, in);\n}", "patch_func_code": "static void srt_to_ass(AVCodecContext *avctx, AVBPrint *dst,\n                       const char *in, int x1, int y1, int x2, int y2)\n{\n    if (x1 >= 0 && y1 >= 0) {\n        /* XXX: here we rescale coordinate assuming they are in DVD resolution\n         * (720x480) since we don't have anything better */\n\n        if (x2 >= 0 && y2 >= 0 && (x2 != x1 || y2 != y1) && x2 >= x1 && y2 >= y1) {\n            /* text rectangle defined, write the text at the center of the rectangle */\n            const int cx = x1 + (x2 - x1)/2;\n            const int cy = y1 + (y2 - y1)/2;\n            const int scaled_x = cx * (int64_t)ASS_DEFAULT_PLAYRESX / 720;\n            const int scaled_y = cy * (int64_t)ASS_DEFAULT_PLAYRESY / 480;\n            av_bprintf(dst, \"{\\\\an5}{\\\\pos(%d,%d)}\", scaled_x, scaled_y);\n        } else {\n            /* only the top left corner, assume the text starts in that corner */\n            const int scaled_x = x1 * (int64_t)ASS_DEFAULT_PLAYRESX / 720;\n            const int scaled_y = y1 * (int64_t)ASS_DEFAULT_PLAYRESY / 480;\n            av_bprintf(dst, \"{\\\\an1}{\\\\pos(%d,%d)}\", scaled_x, scaled_y);\n        }\n    }\n\n    ff_htmlmarkup_to_ass(avctx, dst, in);\n}", "before_change_lines": [12, 13, 17, 18], "raw_before_change_lines": [12, 13, 17, 18], "after_change_lines": [12, 13, 17, 18], "raw_after_change_lines": [12, 13, 17, 18], "bug_lines": [12, 13, 17, 18], "added": [false, false, false, false], "idx": 146}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "2772----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_98c3d061a8d08478686a0ef1520502161474da17_1.json----config_output", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_98c3d061a8d08478686a0ef1520502161474da17_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_98c3d061a8d08478686a0ef1520502161474da17_1.json", "function_name": "config_output", "vul_func_code": "static int config_output(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    AVFilterLink *inlink = ctx->inputs[0];\n    ShowCQTContext *s = ctx->priv;\n    int ret;\n\n    common_uninit(s);\n\n    outlink->w = s->width;\n    outlink->h = s->height;\n    s->format = outlink->format;\n    outlink->sample_aspect_ratio = av_make_q(1, 1);\n    outlink->frame_rate = s->rate;\n    outlink->time_base = av_mul_q(av_inv_q(s->rate), av_make_q(1, PTS_STEP));\n    av_log(ctx, AV_LOG_INFO, \"video: %dx%d %s %d/%d fps, bar_h = %d, axis_h = %d, sono_h = %d.\\n\",\n           s->width, s->height, av_get_pix_fmt_name(s->format), s->rate.num, s->rate.den,\n           s->bar_h, s->axis_h, s->sono_h);\n\n    s->cqt_len = s->width * s->fcount;\n    if (!(s->freq = create_freq_table(s->basefreq, s->endfreq, s->cqt_len)))\n        return AVERROR(ENOMEM);\n\n    if ((ret = init_volume(s)) < 0)\n        return ret;\n\n    s->fft_bits = FFMAX(ceil(log2(inlink->sample_rate * s->timeclamp)), 4);\n    s->fft_len = 1 << s->fft_bits;\n    av_log(ctx, AV_LOG_INFO, \"fft_len = %d, cqt_len = %d.\\n\", s->fft_len, s->cqt_len);\n\n    s->fft_ctx = av_fft_init(s->fft_bits, 0);\n    s->fft_data = av_calloc(s->fft_len, sizeof(*s->fft_data));\n    s->fft_result = av_calloc(s->fft_len + 64, sizeof(*s->fft_result));\n    s->cqt_result = av_malloc_array(s->cqt_len, sizeof(*s->cqt_result));\n    if (!s->fft_ctx || !s->fft_data || !s->fft_result || !s->cqt_result)\n        return AVERROR(ENOMEM);\n\n    s->cqt_align = 1;\n    s->cqt_calc = cqt_calc;\n    s->permute_coeffs = NULL;\n    s->draw_sono = draw_sono;\n    if (s->format == AV_PIX_FMT_RGB24) {\n        s->draw_bar = draw_bar_rgb;\n        s->draw_axis = draw_axis_rgb;\n        s->update_sono = update_sono_rgb;\n    } else {\n        s->draw_bar = draw_bar_yuv;\n        s->draw_axis = draw_axis_yuv;\n        s->update_sono = update_sono_yuv;\n    }\n\n    if (ARCH_X86)\n        ff_showcqt_init_x86(s);\n\n    if ((ret = init_cqt(s)) < 0)\n        return ret;\n\n    if (s->axis_h) {\n        if (!s->axis) {\n            if ((ret = init_axis_empty(s)) < 0)\n                return ret;\n        } else if (s->axisfile) {\n            if (init_axis_from_file(s) < 0) {\n                av_log(ctx, AV_LOG_WARNING, \"loading axis image failed, fallback to font rendering.\\n\");\n                if (init_axis_from_font(s) < 0) {\n                    av_log(ctx, AV_LOG_WARNING, \"loading axis font failed, disable text drawing.\\n\");\n                    if ((ret = init_axis_empty(s)) < 0)\n                        return ret;\n                }\n            }\n        } else {\n            if (init_axis_from_font(s) < 0) {\n                av_log(ctx, AV_LOG_WARNING, \"loading axis font failed, disable text drawing.\\n\");\n                if ((ret = init_axis_empty(s)) < 0)\n                    return ret;\n            }\n        }\n    }\n\n    if (s->sono_h) {\n        s->sono_frame = alloc_frame_empty((outlink->format == AV_PIX_FMT_YUV420P) ?\n                        AV_PIX_FMT_YUV422P : outlink->format, s->width, s->sono_h);\n        if (!s->sono_frame)\n            return AVERROR(ENOMEM);\n    }\n\n    s->h_buf = av_malloc_array(s->cqt_len, sizeof (*s->h_buf));\n    s->rcp_h_buf = av_malloc_array(s->width, sizeof(*s->rcp_h_buf));\n    s->c_buf = av_malloc_array(s->width, sizeof(*s->c_buf));\n    if (!s->h_buf || !s->rcp_h_buf || !s->c_buf)\n        return AVERROR(ENOMEM);\n\n    s->sono_count = 0;\n    s->next_pts = 0;\n    s->sono_idx = 0;\n    s->remaining_fill = s->fft_len / 2;\n    s->remaining_frac = 0;\n    s->step_frac = av_div_q(av_make_q(inlink->sample_rate, s->count) , s->rate);\n    s->step = (int)(s->step_frac.num / s->step_frac.den);\n    s->step_frac.num %= s->step_frac.den;\n    if (s->step_frac.num) {\n        av_log(ctx, AV_LOG_INFO, \"audio: %d Hz, step = %d + %d/%d.\\n\",\n               inlink->sample_rate, s->step, s->step_frac.num, s->step_frac.den);\n        av_log(ctx, AV_LOG_WARNING, \"fractional step.\\n\");\n    } else {\n        av_log(ctx, AV_LOG_INFO, \"audio: %d Hz, step = %d.\\n\",\n               inlink->sample_rate, s->step);\n    }\n\n    return 0;\n}", "patch_func_code": "static int config_output(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    AVFilterLink *inlink = ctx->inputs[0];\n    ShowCQTContext *s = ctx->priv;\n    int ret;\n\n    common_uninit(s);\n\n    outlink->w = s->width;\n    outlink->h = s->height;\n    s->format = outlink->format;\n    outlink->sample_aspect_ratio = av_make_q(1, 1);\n    outlink->frame_rate = s->rate;\n    outlink->time_base = av_mul_q(av_inv_q(s->rate), av_make_q(1, PTS_STEP));\n    av_log(ctx, AV_LOG_INFO, \"video: %dx%d %s %d/%d fps, bar_h = %d, axis_h = %d, sono_h = %d.\\n\",\n           s->width, s->height, av_get_pix_fmt_name(s->format), s->rate.num, s->rate.den,\n           s->bar_h, s->axis_h, s->sono_h);\n\n    s->cqt_len = s->width * s->fcount;\n    if (!(s->freq = create_freq_table(s->basefreq, s->endfreq, s->cqt_len)))\n        return AVERROR(ENOMEM);\n\n    if ((ret = init_volume(s)) < 0)\n        return ret;\n\n    s->fft_bits = FFMAX(ceil(log2(inlink->sample_rate * s->timeclamp)), 4);\n    s->fft_len = 1 << s->fft_bits;\n    av_log(ctx, AV_LOG_INFO, \"fft_len = %d, cqt_len = %d.\\n\", s->fft_len, s->cqt_len);\n\n    s->fft_ctx = av_fft_init(s->fft_bits, 0);\n    s->fft_data = av_calloc(s->fft_len, sizeof(*s->fft_data));\n    s->fft_result = av_calloc(s->fft_len + 64, sizeof(*s->fft_result));\n    s->cqt_result = av_malloc_array(s->cqt_len, sizeof(*s->cqt_result));\n    if (!s->fft_ctx || !s->fft_data || !s->fft_result || !s->cqt_result)\n        return AVERROR(ENOMEM);\n\n    s->remaining_fill_max = s->fft_len / 2;\n    if (s->attack > 0.0) {\n        int k;\n\n        s->remaining_fill_max = FFMIN(s->remaining_fill_max, ceil(inlink->sample_rate * s->attack));\n        s->attack_data = av_malloc_array(s->remaining_fill_max, sizeof(*s->attack_data));\n        if (!s->attack_data)\n            return AVERROR(ENOMEM);\n\n        for (k = 0; k < s->remaining_fill_max; k++) {\n            double y = M_PI * k / (inlink->sample_rate * s->attack);\n            s->attack_data[k] = 0.355768 + 0.487396 * cos(y) + 0.144232 * cos(2*y) + 0.012604 * cos(3*y);\n        }\n    }\n\n    s->cqt_align = 1;\n    s->cqt_calc = cqt_calc;\n    s->permute_coeffs = NULL;\n    s->draw_sono = draw_sono;\n    if (s->format == AV_PIX_FMT_RGB24) {\n        s->draw_bar = draw_bar_rgb;\n        s->draw_axis = draw_axis_rgb;\n        s->update_sono = update_sono_rgb;\n    } else {\n        s->draw_bar = draw_bar_yuv;\n        s->draw_axis = draw_axis_yuv;\n        s->update_sono = update_sono_yuv;\n    }\n\n    if (ARCH_X86)\n        ff_showcqt_init_x86(s);\n\n    if ((ret = init_cqt(s)) < 0)\n        return ret;\n\n    if (s->axis_h) {\n        if (!s->axis) {\n            if ((ret = init_axis_empty(s)) < 0)\n                return ret;\n        } else if (s->axisfile) {\n            if (init_axis_from_file(s) < 0) {\n                av_log(ctx, AV_LOG_WARNING, \"loading axis image failed, fallback to font rendering.\\n\");\n                if (init_axis_from_font(s) < 0) {\n                    av_log(ctx, AV_LOG_WARNING, \"loading axis font failed, disable text drawing.\\n\");\n                    if ((ret = init_axis_empty(s)) < 0)\n                        return ret;\n                }\n            }\n        } else {\n            if (init_axis_from_font(s) < 0) {\n                av_log(ctx, AV_LOG_WARNING, \"loading axis font failed, disable text drawing.\\n\");\n                if ((ret = init_axis_empty(s)) < 0)\n                    return ret;\n            }\n        }\n    }\n\n    if (s->sono_h) {\n        s->sono_frame = alloc_frame_empty((outlink->format == AV_PIX_FMT_YUV420P) ?\n                        AV_PIX_FMT_YUV422P : outlink->format, s->width, s->sono_h);\n        if (!s->sono_frame)\n            return AVERROR(ENOMEM);\n    }\n\n    s->h_buf = av_malloc_array(s->cqt_len, sizeof (*s->h_buf));\n    s->rcp_h_buf = av_malloc_array(s->width, sizeof(*s->rcp_h_buf));\n    s->c_buf = av_malloc_array(s->width, sizeof(*s->c_buf));\n    if (!s->h_buf || !s->rcp_h_buf || !s->c_buf)\n        return AVERROR(ENOMEM);\n\n    s->sono_count = 0;\n    s->next_pts = 0;\n    s->sono_idx = 0;\n    s->remaining_fill = s->remaining_fill_max;\n    s->remaining_frac = 0;\n    s->step_frac = av_div_q(av_make_q(inlink->sample_rate, s->count) , s->rate);\n    s->step = (int)(s->step_frac.num / s->step_frac.den);\n    s->step_frac.num %= s->step_frac.den;\n    if (s->step_frac.num) {\n        av_log(ctx, AV_LOG_INFO, \"audio: %d Hz, step = %d + %d/%d.\\n\",\n               inlink->sample_rate, s->step, s->step_frac.num, s->step_frac.den);\n        av_log(ctx, AV_LOG_WARNING, \"fractional step.\\n\");\n    } else {\n        av_log(ctx, AV_LOG_INFO, \"audio: %d Hz, step = %d.\\n\",\n               inlink->sample_rate, s->step);\n    }\n\n    return 0;\n}", "before_change_lines": [96], "raw_before_change_lines": [96], "after_change_lines": [38, 39, 40, 42, 43, 44, 45, 47, 48, 49, 50, 51, 111], "raw_after_change_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 111], "bug_lines": [96], "added": [false], "idx": 147}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "2774----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_98dc7b0cbdc2e78e710ed020511efd78d0fc4fea_1.json----common_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_98dc7b0cbdc2e78e710ed020511efd78d0fc4fea_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_98dc7b0cbdc2e78e710ed020511efd78d0fc4fea_1.json", "function_name": "common_init", "vul_func_code": "static av_cold int common_init(AVCodecContext *avctx){\n    FFV1Context *s = avctx->priv_data;\n\n    s->avctx= avctx;\n    s->flags= avctx->flags;\n\n    avcodec_get_frame_defaults(&s->picture);\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n    s->width = avctx->width;\n    s->height= avctx->height;\n\n    assert(s->width && s->height);\n    //defaults\n    s->num_h_slices=1;\n    s->num_v_slices=1;\n\n\n    return 0;\n}", "patch_func_code": "static av_cold int common_init(AVCodecContext *avctx){\n    FFV1Context *s = avctx->priv_data;\n\n    if(!avctx->width || !avctx->height)\n        return AVERROR_INVALIDDATA;\n\n    s->avctx= avctx;\n    s->flags= avctx->flags;\n\n    avcodec_get_frame_defaults(&s->picture);\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n    s->width = avctx->width;\n    s->height= avctx->height;\n\n    //defaults\n    s->num_h_slices=1;\n    s->num_v_slices=1;\n\n\n    return 0;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [4, 5], "raw_after_change_lines": [4, 5, 6], "bug_lines": [14], "added": [false], "idx": 148}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "2805----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_99ac503dd75ed857c3b37ee47ae0990dc0bd396b_1.json----find_best_filter", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_99ac503dd75ed857c3b37ee47ae0990dc0bd396b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_99ac503dd75ed857c3b37ee47ae0990dc0bd396b_1.json", "function_name": "find_best_filter", "vul_func_code": "static int64_t find_best_filter(const DCAADPCMEncContext *s, const int32_t *in, int len)\n{\n    const premultiplied_coeffs *precalc_data = s->private_data;\n    int i, j, k = 0;\n    int vq;\n    int64_t err;\n    int64_t min_err = 1ll << 62;\n    int64_t corr[15];\n\n    for (i = 0; i <= DCA_ADPCM_COEFFS; i++)\n        for (j = i; j <= DCA_ADPCM_COEFFS; j++)\n            corr[k++] = calc_corr(in+4, len, i, j);\n\n    for (i = 0; i < DCA_ADPCM_VQCODEBOOK_SZ; i++) {\n        err = apply_filter(ff_dca_adpcm_vb[i], corr, *precalc_data);\n        if (err < min_err) {\n            min_err = err;\n            vq = i;\n        }\n        precalc_data++;\n    }\n\n    return vq;\n}", "patch_func_code": "static int64_t find_best_filter(const DCAADPCMEncContext *s, const int32_t *in, int len)\n{\n    const premultiplied_coeffs *precalc_data = s->private_data;\n    int i, j, k = 0;\n    int vq = -1;\n    int64_t err;\n    int64_t min_err = 1ll << 62;\n    int64_t corr[15];\n\n    for (i = 0; i <= DCA_ADPCM_COEFFS; i++)\n        for (j = i; j <= DCA_ADPCM_COEFFS; j++)\n            corr[k++] = calc_corr(in+4, len, i, j);\n\n    for (i = 0; i < DCA_ADPCM_VQCODEBOOK_SZ; i++) {\n        err = apply_filter(ff_dca_adpcm_vb[i], corr, *precalc_data);\n        if (err < min_err) {\n            min_err = err;\n            vq = i;\n        }\n        precalc_data++;\n    }\n\n    return vq;\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5], "added": [false], "idx": 149}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "2888----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_9d0fbaee58ab21c4bc371b83accb5393fa3d76be_1.json----mxf_decrypt_triplet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_9d0fbaee58ab21c4bc371b83accb5393fa3d76be_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_9d0fbaee58ab21c4bc371b83accb5393fa3d76be_1.json", "function_name": "mxf_decrypt_triplet", "vul_func_code": "static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n{\n    static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n    MXFContext *mxf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t end = avio_tell(pb) + klv->length;\n    uint64_t size;\n    uint64_t orig_size;\n    uint64_t plaintext_size;\n    uint8_t ivec[16];\n    uint8_t tmpbuf[16];\n    int index;\n\n    if (!mxf->aesc && s->key && s->keylen == 16) {\n        mxf->aesc = av_malloc(av_aes_size);\n        if (!mxf->aesc)\n            return -1;\n        av_aes_init(mxf->aesc, s->key, 128, 1);\n    }\n    // crypto context\n    avio_skip(pb, klv_decode_ber_length(pb));\n    // plaintext offset\n    klv_decode_ber_length(pb);\n    plaintext_size = avio_rb64(pb);\n    // source klv key\n    klv_decode_ber_length(pb);\n    avio_read(pb, klv->key, 16);\n    if (!IS_KLV_KEY(klv, mxf_essence_element_key))\n        return -1;\n    index = mxf_get_stream_index(s, klv);\n    if (index < 0)\n        return -1;\n    // source size\n    klv_decode_ber_length(pb);\n    orig_size = avio_rb64(pb);\n    if (orig_size < plaintext_size)\n        return -1;\n    // enc. code\n    size = klv_decode_ber_length(pb);\n    if (size < 32 || size - 32 < orig_size)\n        return -1;\n    avio_read(pb, ivec, 16);\n    avio_read(pb, tmpbuf, 16);\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n    if (memcmp(tmpbuf, checkv, 16))\n        av_log(s, AV_LOG_ERROR, \"probably incorrect decryption key\\n\");\n    size -= 32;\n    av_get_packet(pb, pkt, size);\n    size -= plaintext_size;\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size],\n                     &pkt->data[plaintext_size], size >> 4, ivec, 1);\n    pkt->size = orig_size;\n    pkt->stream_index = index;\n    avio_skip(pb, end - avio_tell(pb));\n    return 0;\n}", "patch_func_code": "static int mxf_decrypt_triplet(AVFormatContext *s, AVPacket *pkt, KLVPacket *klv)\n{\n    static const uint8_t checkv[16] = {0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b, 0x43, 0x48, 0x55, 0x4b};\n    MXFContext *mxf = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int64_t end = avio_tell(pb) + klv->length;\n    uint64_t size;\n    uint64_t orig_size;\n    uint64_t plaintext_size;\n    uint8_t ivec[16];\n    uint8_t tmpbuf[16];\n    int index;\n\n    if (!mxf->aesc && s->key && s->keylen == 16) {\n        mxf->aesc = av_malloc(av_aes_size);\n        if (!mxf->aesc)\n            return -1;\n        av_aes_init(mxf->aesc, s->key, 128, 1);\n    }\n    // crypto context\n    avio_skip(pb, klv_decode_ber_length(pb));\n    // plaintext offset\n    klv_decode_ber_length(pb);\n    plaintext_size = avio_rb64(pb);\n    // source klv key\n    klv_decode_ber_length(pb);\n    avio_read(pb, klv->key, 16);\n    if (!IS_KLV_KEY(klv, mxf_essence_element_key))\n        return -1;\n    index = mxf_get_stream_index(s, klv);\n    if (index < 0)\n        return -1;\n    // source size\n    klv_decode_ber_length(pb);\n    orig_size = avio_rb64(pb);\n    if (orig_size < plaintext_size)\n        return -1;\n    // enc. code\n    size = klv_decode_ber_length(pb);\n    if (size < 32 || size - 32 < orig_size)\n        return -1;\n    avio_read(pb, ivec, 16);\n    avio_read(pb, tmpbuf, 16);\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, tmpbuf, tmpbuf, 1, ivec, 1);\n    if (memcmp(tmpbuf, checkv, 16))\n        av_log(s, AV_LOG_ERROR, \"probably incorrect decryption key\\n\");\n    size -= 32;\n    size = av_get_packet(pb, pkt, size);\n    if (size < 0)\n        return size;\n    else if (size < plaintext_size)\n        return AVERROR_INVALIDDATA;\n    size -= plaintext_size;\n    if (mxf->aesc)\n        av_aes_crypt(mxf->aesc, &pkt->data[plaintext_size],\n                     &pkt->data[plaintext_size], size >> 4, ivec, 1);\n    av_shrink_packet(pkt, orig_size);\n    pkt->stream_index = index;\n    avio_skip(pb, end - avio_tell(pb));\n    return 0;\n}", "before_change_lines": [49, 54], "raw_before_change_lines": [49, 54], "after_change_lines": [49, 50, 51, 52, 53, 58], "raw_after_change_lines": [49, 50, 51, 52, 53, 58], "bug_lines": [49, 54], "added": [false, false], "idx": 150}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "2992----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a2ec20e4c3dda936587c4e45a27ad72e4e7cfb10_1.json----av_vsrc_buffer_add_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_a2ec20e4c3dda936587c4e45a27ad72e4e7cfb10_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a2ec20e4c3dda936587c4e45a27ad72e4e7cfb10_1.json", "function_name": "av_vsrc_buffer_add_frame", "vul_func_code": "int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame,\n                             int64_t pts, AVRational pixel_aspect)\n{\n    BufferSourceContext *c = buffer_filter->priv;\n    AVFilterBufferRef *buf;\n    int ret;\n\n    if (!buf) {\n        c->eof = 1;\n        return 0;\n    } else if (c->eof)\n        return AVERROR(EINVAL);\n\n    if (!av_fifo_space(c->fifo) &&\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n                                         sizeof(buf))) < 0)\n        return ret;\n\n    CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format);\n\n    buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE,\n                                    c->w, c->h);\n    av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize,\n                  c->pix_fmt, c->w, c->h);\n\n    avfilter_copy_frame_props(buf, frame);\n    buf->pts                    = pts;\n    buf->video->pixel_aspect    = pixel_aspect;\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n        avfilter_unref_buffer(buf);\n        return ret;\n    }\n\n    return 0;\n}", "patch_func_code": "int av_vsrc_buffer_add_frame(AVFilterContext *buffer_filter, AVFrame *frame,\n                             int64_t pts, AVRational pixel_aspect)\n{\n    BufferSourceContext *c = buffer_filter->priv;\n    AVFilterBufferRef *buf;\n    int ret;\n\n    if (!frame) {\n        c->eof = 1;\n        return 0;\n    } else if (c->eof)\n        return AVERROR(EINVAL);\n\n    if (!av_fifo_space(c->fifo) &&\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n                                         sizeof(buf))) < 0)\n        return ret;\n\n    CHECK_PARAM_CHANGE(buffer_filter, c, frame->width, frame->height, frame->format);\n\n    buf = avfilter_get_video_buffer(buffer_filter->outputs[0], AV_PERM_WRITE,\n                                    c->w, c->h);\n    av_image_copy(buf->data, buf->linesize, frame->data, frame->linesize,\n                  c->pix_fmt, c->w, c->h);\n\n    avfilter_copy_frame_props(buf, frame);\n    buf->pts                    = pts;\n    buf->video->pixel_aspect    = pixel_aspect;\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n        avfilter_unref_buffer(buf);\n        return ret;\n    }\n\n    return 0;\n}", "before_change_lines": [8], "raw_before_change_lines": [8], "after_change_lines": [8], "raw_after_change_lines": [8], "bug_lines": [8], "added": [false], "idx": 151}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "2994----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a3062896ad56cd4745cb26dec03e2fedc6cc1518_1.json----fill_buffer", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_a3062896ad56cd4745cb26dec03e2fedc6cc1518_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a3062896ad56cd4745cb26dec03e2fedc6cc1518_1.json", "function_name": "fill_buffer", "vul_func_code": "static void fill_buffer(AVIOContext *s)\n{\n    int max_buffer_size = s->max_packet_size ?\n                          s->max_packet_size : IO_BUFFER_SIZE;\n    uint8_t *dst        = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ?\n                          s->buf_end : s->buffer;\n    int len             = s->buffer_size - (dst - s->buffer);\n\n    /* can't fill the buffer without read_packet, just set EOF if appropriate */\n    if (!s->read_packet && s->buf_ptr >= s->buf_end)\n        s->eof_reached = 1;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if (s->update_checksum && dst == s->buffer) {\n        if (s->buf_end > s->checksum_ptr)\n            s->checksum = s->update_checksum(s->checksum, s->checksum_ptr,\n                                             s->buf_end - s->checksum_ptr);\n        s->checksum_ptr = s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) {\n        if (dst == s->buffer) {\n            ffio_set_buf_size(s, s->orig_buffer_size);\n\n            s->checksum_ptr = dst = s->buffer;\n        }\n        av_assert0(len >= s->orig_buffer_size);\n        len = s->orig_buffer_size;\n    }\n\n    if (s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if (len < 0)\n            s->error = len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n        s->bytes_read += len;\n    }\n}", "patch_func_code": "static void fill_buffer(AVIOContext *s)\n{\n    int max_buffer_size = s->max_packet_size ?\n                          s->max_packet_size : IO_BUFFER_SIZE;\n    uint8_t *dst        = s->buf_end - s->buffer + max_buffer_size < s->buffer_size ?\n                          s->buf_end : s->buffer;\n    int len             = s->buffer_size - (dst - s->buffer);\n\n    /* can't fill the buffer without read_packet, just set EOF if appropriate */\n    if (!s->read_packet && s->buf_ptr >= s->buf_end)\n        s->eof_reached = 1;\n\n    /* no need to do anything if EOF already reached */\n    if (s->eof_reached)\n        return;\n\n    if (s->update_checksum && dst == s->buffer) {\n        if (s->buf_end > s->checksum_ptr)\n            s->checksum = s->update_checksum(s->checksum, s->checksum_ptr,\n                                             s->buf_end - s->checksum_ptr);\n        s->checksum_ptr = s->buffer;\n    }\n\n    /* make buffer smaller in case it ended up large after probing */\n    if (s->read_packet && s->orig_buffer_size && s->buffer_size > s->orig_buffer_size) {\n        if (dst == s->buffer) {\n            int ret = ffio_set_buf_size(s, s->orig_buffer_size);\n            if (ret < 0)\n                av_log(s, AV_LOG_WARNING, \"Failed to decrease buffer size\\n\");\n\n            s->checksum_ptr = dst = s->buffer;\n        }\n        av_assert0(len >= s->orig_buffer_size);\n        len = s->orig_buffer_size;\n    }\n\n    if (s->read_packet)\n        len = s->read_packet(s->opaque, dst, len);\n    else\n        len = 0;\n    if (len <= 0) {\n        /* do not modify buffer if EOF reached so that a seek back can\n           be done without rereading data */\n        s->eof_reached = 1;\n        if (len < 0)\n            s->error = len;\n    } else {\n        s->pos += len;\n        s->buf_ptr = dst;\n        s->buf_end = dst + len;\n        s->bytes_read += len;\n    }\n}", "before_change_lines": [27], "raw_before_change_lines": [27], "after_change_lines": [27, 28, 29], "raw_after_change_lines": [27, 28, 29], "bug_lines": [27], "added": [false], "idx": 152}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "3090----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a847043f0b7137103225c1857046046d9ab80e6d_1.json----mov_read_chpl", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_a847043f0b7137103225c1857046046d9ab80e6d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a847043f0b7137103225c1857046046d9ab80e6d_1.json", "function_name": "mov_read_chpl", "vul_func_code": "static int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        avio_read(pb, str, str_len);\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}", "patch_func_code": "static int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n    int ret;\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        ret = ffio_read_size(pb, str, str_len);\n        if (ret < 0)\n            return ret;\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}", "before_change_lines": [26], "raw_before_change_lines": [26], "after_change_lines": [6, 27, 28, 29], "raw_after_change_lines": [6, 27, 28, 29], "bug_lines": [26], "added": [false], "idx": 153}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "3120----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a9d2072a8144aadee65f9e5ca567309b36cf037e_1.json----find_and_decode_index", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_a9d2072a8144aadee65f9e5ca567309b36cf037e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_a9d2072a8144aadee65f9e5ca567309b36cf037e_1.json", "function_name": "find_and_decode_index", "vul_func_code": "static int find_and_decode_index(NUTContext *nut){\n    AVFormatContext *s= nut->avf;\n    ByteIOContext *bc = s->pb;\n    uint64_t tmp, end;\n    int i, j, syncpoint_count;\n    int64_t filesize= url_fsize(bc);\n    int64_t *syncpoints;\n    int8_t *has_keyframe;\n\n    url_fseek(bc, filesize-12, SEEK_SET);\n    url_fseek(bc, filesize-get_be64(bc), SEEK_SET);\n    if(get_be64(bc) != INDEX_STARTCODE){\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n        return -1;\n    }\n\n    end= get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n    end += url_ftell(bc);\n\n    ff_get_v(bc); //max_pts\n    GET_V(syncpoint_count, tmp < INT_MAX/8 && tmp > 0)\n    syncpoints= av_malloc(sizeof(int64_t)*syncpoint_count);\n    has_keyframe= av_malloc(sizeof(int8_t)*(syncpoint_count+1));\n    for(i=0; i<syncpoint_count; i++){\n        GET_V(syncpoints[i], tmp>0)\n        if(i)\n            syncpoints[i] += syncpoints[i-1];\n    }\n\n    for(i=0; i<s->nb_streams; i++){\n        int64_t last_pts= -1;\n        for(j=0; j<syncpoint_count;){\n            uint64_t x= ff_get_v(bc);\n            int type= x&1;\n            int n= j;\n            x>>=1;\n            if(type){\n                int flag= x&1;\n                x>>=1;\n                if(n+x >= syncpoint_count + 1){\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n                    return -1;\n                }\n                while(x--)\n                    has_keyframe[n++]= flag;\n                has_keyframe[n++]= !flag;\n            }else{\n                while(x != 1){\n                    if(n>=syncpoint_count + 1){\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n                        return -1;\n                    }\n                    has_keyframe[n++]= x&1;\n                    x>>=1;\n                }\n            }\n            if(has_keyframe[0]){\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n                return -1;\n            }\n            assert(n<=syncpoint_count+1);\n            for(; j<n; j++){\n                if(has_keyframe[j]){\n                    uint64_t B, A= ff_get_v(bc);\n                    if(!A){\n                        A= ff_get_v(bc);\n                        B= ff_get_v(bc);\n                        //eor_pts[j][i] = last_pts + A + B\n                    }else\n                        B= 0;\n                    av_add_index_entry(\n                        s->streams[i],\n                        16*syncpoints[j-1],\n                        last_pts + A,\n                        0,\n                        0,\n                        AVINDEX_KEYFRAME);\n                    last_pts += A + B;\n                }\n            }\n        }\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n        return -1;\n    }\n    return 0;\n}", "patch_func_code": "static int find_and_decode_index(NUTContext *nut){\n    AVFormatContext *s= nut->avf;\n    ByteIOContext *bc = s->pb;\n    uint64_t tmp, end;\n    int i, j, syncpoint_count;\n    int64_t filesize= url_fsize(bc);\n    int64_t *syncpoints;\n    int8_t *has_keyframe;\n\n    url_fseek(bc, filesize-12, SEEK_SET);\n    url_fseek(bc, filesize-get_be64(bc), SEEK_SET);\n    if(get_be64(bc) != INDEX_STARTCODE){\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n        return -1;\n    }\n\n    end= get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n    end += url_ftell(bc);\n\n    ff_get_v(bc); //max_pts\n    GET_V(syncpoint_count, tmp < INT_MAX/8 && tmp > 0)\n    syncpoints= av_malloc(sizeof(int64_t)*syncpoint_count);\n    has_keyframe= av_malloc(sizeof(int8_t)*(syncpoint_count+1));\n    for(i=0; i<syncpoint_count; i++){\n        GET_V(syncpoints[i], tmp>0)\n        if(i)\n            syncpoints[i] += syncpoints[i-1];\n    }\n\n    for(i=0; i<s->nb_streams; i++){\n        int64_t last_pts= -1;\n        for(j=0; j<syncpoint_count;){\n            uint64_t x= ff_get_v(bc);\n            int type= x&1;\n            int n= j;\n            x>>=1;\n            if(type){\n                int flag= x&1;\n                x>>=1;\n                if(n+x >= syncpoint_count + 1){\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n                    return -1;\n                }\n                while(x--)\n                    has_keyframe[n++]= flag;\n                has_keyframe[n++]= !flag;\n            }else{\n                while(x != 1){\n                    if(n>=syncpoint_count + 1){\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n                        return -1;\n                    }\n                    has_keyframe[n++]= x&1;\n                    x>>=1;\n                }\n            }\n            if(has_keyframe[0]){\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n                return -1;\n            }\n            assert(n<=syncpoint_count+1);\n            for(; j<n && j<syncpoint_count; j++){\n                if(has_keyframe[j]){\n                    uint64_t B, A= ff_get_v(bc);\n                    if(!A){\n                        A= ff_get_v(bc);\n                        B= ff_get_v(bc);\n                        //eor_pts[j][i] = last_pts + A + B\n                    }else\n                        B= 0;\n                    av_add_index_entry(\n                        s->streams[i],\n                        16*syncpoints[j-1],\n                        last_pts + A,\n                        0,\n                        0,\n                        AVINDEX_KEYFRAME);\n                    last_pts += A + B;\n                }\n            }\n        }\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n        return -1;\n    }\n    return 0;\n}", "before_change_lines": [62], "raw_before_change_lines": [62], "after_change_lines": [62], "raw_after_change_lines": [62], "bug_lines": [62], "added": [false], "idx": 154}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3158----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ab81507ea9bb50c6061558765251101735069158_1.json----gxf_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_ab81507ea9bb50c6061558765251101735069158_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ab81507ea9bb50c6061558765251101735069158_1.json", "function_name": "gxf_packet", "vul_func_code": "static int gxf_packet(AVFormatContext *s, AVPacket *pkt) {\n    ByteIOContext *pb = s->pb;\n    pkt_type_t pkt_type;\n    int pkt_len;\n    while (!url_feof(pb)) {\n        int track_type, track_id, ret;\n        int field_nr;\n        int stream_index;\n        if (!parse_packet_header(pb, &pkt_type, &pkt_len)) {\n            if (!url_feof(pb))\n                av_log(s, AV_LOG_ERROR, \"GXF: sync lost\\n\");\n            return -1;\n        }\n        if (pkt_type == PKT_FLT) {\n            gxf_read_index(s, pkt_len);\n            continue;\n        }\n        if (pkt_type != PKT_MEDIA) {\n            url_fskip(pb, pkt_len);\n            continue;\n        }\n        if (pkt_len < 16) {\n            av_log(s, AV_LOG_ERROR, \"GXF: invalid media packet length\\n\");\n            continue;\n        }\n        pkt_len -= 16;\n        track_type = get_byte(pb);\n        track_id = get_byte(pb);\n        stream_index = get_sindex(s, track_id, track_type);\n        if (stream_index < 0)\n            return stream_index;\n        field_nr = get_be32(pb);\n        get_be32(pb); // field information\n        get_be32(pb); // \"timeline\" field number\n        get_byte(pb); // flags\n        get_byte(pb); // reserved\n        // NOTE: there is also data length information in the\n        // field information, it might be better to take this into account\n        // as well.\n        ret = av_get_packet(pb, pkt, pkt_len);\n        pkt->stream_index = stream_index;\n        pkt->dts = field_nr;\n        return ret;\n    }\n    return AVERROR(EIO);\n}", "patch_func_code": "static int gxf_packet(AVFormatContext *s, AVPacket *pkt) {\n    ByteIOContext *pb = s->pb;\n    pkt_type_t pkt_type;\n    int pkt_len;\n    while (!url_feof(pb)) {\n        AVStream *st;\n        int track_type, track_id, ret;\n        int field_nr, field_info, skip = 0;\n        int stream_index;\n        if (!parse_packet_header(pb, &pkt_type, &pkt_len)) {\n            if (!url_feof(pb))\n                av_log(s, AV_LOG_ERROR, \"GXF: sync lost\\n\");\n            return -1;\n        }\n        if (pkt_type == PKT_FLT) {\n            gxf_read_index(s, pkt_len);\n            continue;\n        }\n        if (pkt_type != PKT_MEDIA) {\n            url_fskip(pb, pkt_len);\n            continue;\n        }\n        if (pkt_len < 16) {\n            av_log(s, AV_LOG_ERROR, \"GXF: invalid media packet length\\n\");\n            continue;\n        }\n        pkt_len -= 16;\n        track_type = get_byte(pb);\n        track_id = get_byte(pb);\n        stream_index = get_sindex(s, track_id, track_type);\n        if (stream_index < 0)\n            return stream_index;\n        st = s->streams[stream_index];\n        field_nr = get_be32(pb);\n        field_info = get_be32(pb);\n        get_be32(pb); // \"timeline\" field number\n        get_byte(pb); // flags\n        get_byte(pb); // reserved\n        if (st->codec->codec_id == CODEC_ID_PCM_S24LE ||\n            st->codec->codec_id == CODEC_ID_PCM_S16LE) {\n            int first = field_info >> 16;\n            int last  = field_info & 0xffff; // last is exclusive\n            int bps = av_get_bits_per_sample(st->codec->codec_id)>>3;\n            if (first <= last && last*bps <= pkt_len) {\n                url_fskip(pb, first*bps);\n                skip = pkt_len - last*bps;\n                pkt_len = (last-first)*bps;\n            } else\n                av_log(s, AV_LOG_ERROR, \"invalid first and last sample values\\n\");\n        }\n        ret = av_get_packet(pb, pkt, pkt_len);\n        if (skip)\n            url_fskip(pb, skip);\n        pkt->stream_index = stream_index;\n        pkt->dts = field_nr;\n        return ret;\n    }\n    return AVERROR(EIO);\n}", "before_change_lines": [7, 33], "raw_before_change_lines": [7, 33, 37, 38, 39], "after_change_lines": [6, 8, 33, 35, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 53], "raw_after_change_lines": [6, 8, 33, 35, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 52, 53], "bug_lines": [7, 33, 37, 38, 39], "added": [false, false, false, false, false], "idx": 155}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "3217----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_af19031ee648a35e08f4d4de56b3bf4cc9c5f402_1.json----ass_decode_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_af19031ee648a35e08f4d4de56b3bf4cc9c5f402_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_af19031ee648a35e08f4d4de56b3bf4cc9c5f402_1.json", "function_name": "ass_decode_init", "vul_func_code": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n{\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n    if (!avctx->extradata)\n        return AVERROR(ENOMEM);\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n    avctx->subtitle_header_size = avctx->extradata_size;\n    return 0;\n}", "patch_func_code": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n{\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n    if (!avctx->subtitle_header)\n        return AVERROR(ENOMEM);\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n    avctx->subtitle_header_size = avctx->extradata_size;\n    return 0;\n}", "before_change_lines": [4], "raw_before_change_lines": [4], "after_change_lines": [4], "raw_after_change_lines": [4], "bug_lines": [4], "added": [false], "idx": 156}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "3230----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b04cb870fff926a2f94930338900734da5efd546_1.json----ff_id3v2_free_extra_meta", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_b04cb870fff926a2f94930338900734da5efd546_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b04cb870fff926a2f94930338900734da5efd546_1.json", "function_name": "ff_id3v2_free_extra_meta", "vul_func_code": "void ff_id3v2_free_extra_meta(ID3v2ExtraMeta **extra_meta)\n{\n    ID3v2ExtraMeta *current = *extra_meta, *next;\n    void (*free_func)(ID3v2ExtraMeta*);\n\n    while (current) {\n        if ((free_func = get_extra_meta_func(current->tag, 1)->free))\n            free_func(current->data);\n        next = current->next;\n        av_freep(&current);\n        current = next;\n    }\n}", "patch_func_code": "void ff_id3v2_free_extra_meta(ID3v2ExtraMeta **extra_meta)\n{\n    ID3v2ExtraMeta *current = *extra_meta, *next;\n    const ID3v2EMFunc *extra_func;\n\n    while (current) {\n        if ((extra_func = get_extra_meta_func(current->tag, 1)))\n            extra_func->free(current->data);\n        next = current->next;\n        av_freep(&current);\n        current = next;\n    }\n}", "before_change_lines": [4, 7, 8], "raw_before_change_lines": [4, 7, 8], "after_change_lines": [4, 7, 8], "raw_after_change_lines": [4, 7, 8], "bug_lines": [4, 7, 8], "added": [false, false, false], "idx": 157}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3239----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b0bbc7403896f32ea28c3f0fc87e59a8a4287afa_1.json----truemotion1_decode_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_b0bbc7403896f32ea28c3f0fc87e59a8a4287afa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b0bbc7403896f32ea28c3f0fc87e59a8a4287afa_1.json", "function_name": "truemotion1_decode_header", "vul_func_code": "static int truemotion1_decode_header(TrueMotion1Context *s)\n{\n    int i;\n    int width_shift = 0;\n    int new_pix_fmt;\n    struct frame_header header;\n    uint8_t header_buffer[128];  /* logical maximum size of the header */\n    const uint8_t *sel_vector_table;\n\n    header.header_size = ((s->buf[0] >> 5) | (s->buf[0] << 3)) & 0x7f;\n    if (s->buf[0] < 0x10)\n    {\n        av_log(s->avctx, AV_LOG_ERROR, \"invalid header size (%d)\\n\", s->buf[0]);\n        return -1;\n    }\n\n    /* unscramble the header bytes with a XOR operation */\n    memset(header_buffer, 0, 128);\n    for (i = 1; i < header.header_size; i++)\n        header_buffer[i - 1] = s->buf[i] ^ s->buf[i + 1];\n\n    header.compression = header_buffer[0];\n    header.deltaset = header_buffer[1];\n    header.vectable = header_buffer[2];\n    header.ysize = AV_RL16(&header_buffer[3]);\n    header.xsize = AV_RL16(&header_buffer[5]);\n    header.checksum = AV_RL16(&header_buffer[7]);\n    header.version = header_buffer[9];\n    header.header_type = header_buffer[10];\n    header.flags = header_buffer[11];\n    header.control = header_buffer[12];\n\n    /* Version 2 */\n    if (header.version >= 2)\n    {\n        if (header.header_type > 3)\n        {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid header type (%d)\\n\", header.header_type);\n            return -1;\n        } else if ((header.header_type == 2) || (header.header_type == 3)) {\n            s->flags = header.flags;\n            if (!(s->flags & FLAG_INTERFRAME))\n                s->flags |= FLAG_KEYFRAME;\n        } else\n            s->flags = FLAG_KEYFRAME;\n    } else /* Version 1 */\n        s->flags = FLAG_KEYFRAME;\n\n    if (s->flags & FLAG_SPRITE) {\n        av_log(s->avctx, AV_LOG_INFO, \"SPRITE frame found, please report the sample to the developers\\n\");\n        /* FIXME header.width, height, xoffset and yoffset aren't initialized */\n#if 0\n        s->w = header.width;\n        s->h = header.height;\n        s->x = header.xoffset;\n        s->y = header.yoffset;\n#else\n        return -1;\n#endif\n    } else {\n        s->w = header.xsize;\n        s->h = header.ysize;\n        if (header.header_type < 2) {\n            if ((s->w < 213) && (s->h >= 176))\n            {\n                s->flags |= FLAG_INTERPOLATED;\n                av_log(s->avctx, AV_LOG_INFO, \"INTERPOLATION selected, please report the sample to the developers\\n\");\n            }\n        }\n    }\n\n    if (header.compression >= 17) {\n        av_log(s->avctx, AV_LOG_ERROR, \"invalid compression type (%d)\\n\", header.compression);\n        return -1;\n    }\n\n    if ((header.deltaset != s->last_deltaset) ||\n        (header.vectable != s->last_vectable))\n        select_delta_tables(s, header.deltaset);\n\n    if ((header.compression & 1) && header.header_type)\n        sel_vector_table = pc_tbl2;\n    else {\n        if (header.vectable < 4)\n            sel_vector_table = tables[header.vectable - 1];\n        else {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid vector table id (%d)\\n\", header.vectable);\n            return -1;\n        }\n    }\n\n    if (compression_types[header.compression].algorithm == ALGO_RGB24H) {\n        new_pix_fmt = PIX_FMT_RGB32;\n        width_shift = 1;\n    } else\n        new_pix_fmt = PIX_FMT_RGB555; // RGB565 is supported as well\n\n    s->w >>= width_shift;\n    if (av_image_check_size(s->w, s->h, 0, s->avctx) < 0)\n        return -1;\n\n    if (s->w != s->avctx->width || s->h != s->avctx->height ||\n        new_pix_fmt != s->avctx->pix_fmt) {\n        if (s->frame.data[0])\n            s->avctx->release_buffer(s->avctx, &s->frame);\n        s->avctx->sample_aspect_ratio = (AVRational){ 1 << width_shift, 1 };\n        s->avctx->pix_fmt = new_pix_fmt;\n        avcodec_set_dimensions(s->avctx, s->w, s->h);\n        av_fast_malloc(&s->vert_pred, &s->vert_pred_size, s->avctx->width * sizeof(unsigned int));\n    }\n\n    /* There is 1 change bit per 4 pixels, so each change byte represents\n     * 32 pixels; divide width by 4 to obtain the number of change bits and\n     * then round up to the nearest byte. */\n    s->mb_change_bits_row_size = ((s->avctx->width >> (2 - width_shift)) + 7) >> 3;\n\n    if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable))\n    {\n        if (compression_types[header.compression].algorithm == ALGO_RGB24H)\n            gen_vector_table24(s, sel_vector_table);\n        else\n        if (s->avctx->pix_fmt == PIX_FMT_RGB555)\n            gen_vector_table15(s, sel_vector_table);\n        else\n            gen_vector_table16(s, sel_vector_table);\n    }\n\n    /* set up pointers to the other key data chunks */\n    s->mb_change_bits = s->buf + header.header_size;\n    if (s->flags & FLAG_KEYFRAME) {\n        /* no change bits specified for a keyframe; only index bytes */\n        s->index_stream = s->mb_change_bits;\n    } else {\n        /* one change bit per 4x4 block */\n        s->index_stream = s->mb_change_bits +\n            (s->mb_change_bits_row_size * (s->avctx->height >> 2));\n    }\n    s->index_stream_size = s->size - (s->index_stream - s->buf);\n\n    s->last_deltaset = header.deltaset;\n    s->last_vectable = header.vectable;\n    s->compression = header.compression;\n    s->block_width = compression_types[header.compression].block_width;\n    s->block_height = compression_types[header.compression].block_height;\n    s->block_type = compression_types[header.compression].block_type;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_INFO, \"tables: %d / %d c:%d %dx%d t:%d %s%s%s%s\\n\",\n            s->last_deltaset, s->last_vectable, s->compression, s->block_width,\n            s->block_height, s->block_type,\n            s->flags & FLAG_KEYFRAME ? \" KEY\" : \"\",\n            s->flags & FLAG_INTERFRAME ? \" INTER\" : \"\",\n            s->flags & FLAG_SPRITE ? \" SPRITE\" : \"\",\n            s->flags & FLAG_INTERPOLATED ? \" INTERPOL\" : \"\");\n\n    return header.header_size;\n}", "patch_func_code": "static int truemotion1_decode_header(TrueMotion1Context *s)\n{\n    int i;\n    int width_shift = 0;\n    int new_pix_fmt;\n    struct frame_header header;\n    uint8_t header_buffer[128];  /* logical maximum size of the header */\n    const uint8_t *sel_vector_table;\n\n    header.header_size = ((s->buf[0] >> 5) | (s->buf[0] << 3)) & 0x7f;\n    if (s->buf[0] < 0x10)\n    {\n        av_log(s->avctx, AV_LOG_ERROR, \"invalid header size (%d)\\n\", s->buf[0]);\n        return -1;\n    }\n\n    /* unscramble the header bytes with a XOR operation */\n    memset(header_buffer, 0, 128);\n    for (i = 1; i < header.header_size; i++)\n        header_buffer[i - 1] = s->buf[i] ^ s->buf[i + 1];\n\n    header.compression = header_buffer[0];\n    header.deltaset = header_buffer[1];\n    header.vectable = header_buffer[2];\n    header.ysize = AV_RL16(&header_buffer[3]);\n    header.xsize = AV_RL16(&header_buffer[5]);\n    header.checksum = AV_RL16(&header_buffer[7]);\n    header.version = header_buffer[9];\n    header.header_type = header_buffer[10];\n    header.flags = header_buffer[11];\n    header.control = header_buffer[12];\n\n    /* Version 2 */\n    if (header.version >= 2)\n    {\n        if (header.header_type > 3)\n        {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid header type (%d)\\n\", header.header_type);\n            return -1;\n        } else if ((header.header_type == 2) || (header.header_type == 3)) {\n            s->flags = header.flags;\n            if (!(s->flags & FLAG_INTERFRAME))\n                s->flags |= FLAG_KEYFRAME;\n        } else\n            s->flags = FLAG_KEYFRAME;\n    } else /* Version 1 */\n        s->flags = FLAG_KEYFRAME;\n\n    if (s->flags & FLAG_SPRITE) {\n        av_log(s->avctx, AV_LOG_INFO, \"SPRITE frame found, please report the sample to the developers\\n\");\n        /* FIXME header.width, height, xoffset and yoffset aren't initialized */\n#if 0\n        s->w = header.width;\n        s->h = header.height;\n        s->x = header.xoffset;\n        s->y = header.yoffset;\n#else\n        return -1;\n#endif\n    } else {\n        s->w = header.xsize;\n        s->h = header.ysize;\n        if (header.header_type < 2) {\n            if ((s->w < 213) && (s->h >= 176))\n            {\n                s->flags |= FLAG_INTERPOLATED;\n                av_log(s->avctx, AV_LOG_INFO, \"INTERPOLATION selected, please report the sample to the developers\\n\");\n            }\n        }\n    }\n\n    if (header.compression >= 17) {\n        av_log(s->avctx, AV_LOG_ERROR, \"invalid compression type (%d)\\n\", header.compression);\n        return -1;\n    }\n\n    if ((header.deltaset != s->last_deltaset) ||\n        (header.vectable != s->last_vectable))\n        select_delta_tables(s, header.deltaset);\n\n    if ((header.compression & 1) && header.header_type)\n        sel_vector_table = pc_tbl2;\n    else {\n        if (header.vectable > 0 && header.vectable < 4)\n            sel_vector_table = tables[header.vectable - 1];\n        else {\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid vector table id (%d)\\n\", header.vectable);\n            return -1;\n        }\n    }\n\n    if (compression_types[header.compression].algorithm == ALGO_RGB24H) {\n        new_pix_fmt = PIX_FMT_RGB32;\n        width_shift = 1;\n    } else\n        new_pix_fmt = PIX_FMT_RGB555; // RGB565 is supported as well\n\n    s->w >>= width_shift;\n    if (av_image_check_size(s->w, s->h, 0, s->avctx) < 0)\n        return -1;\n\n    if (s->w != s->avctx->width || s->h != s->avctx->height ||\n        new_pix_fmt != s->avctx->pix_fmt) {\n        if (s->frame.data[0])\n            s->avctx->release_buffer(s->avctx, &s->frame);\n        s->avctx->sample_aspect_ratio = (AVRational){ 1 << width_shift, 1 };\n        s->avctx->pix_fmt = new_pix_fmt;\n        avcodec_set_dimensions(s->avctx, s->w, s->h);\n        av_fast_malloc(&s->vert_pred, &s->vert_pred_size, s->avctx->width * sizeof(unsigned int));\n    }\n\n    /* There is 1 change bit per 4 pixels, so each change byte represents\n     * 32 pixels; divide width by 4 to obtain the number of change bits and\n     * then round up to the nearest byte. */\n    s->mb_change_bits_row_size = ((s->avctx->width >> (2 - width_shift)) + 7) >> 3;\n\n    if ((header.deltaset != s->last_deltaset) || (header.vectable != s->last_vectable))\n    {\n        if (compression_types[header.compression].algorithm == ALGO_RGB24H)\n            gen_vector_table24(s, sel_vector_table);\n        else\n        if (s->avctx->pix_fmt == PIX_FMT_RGB555)\n            gen_vector_table15(s, sel_vector_table);\n        else\n            gen_vector_table16(s, sel_vector_table);\n    }\n\n    /* set up pointers to the other key data chunks */\n    s->mb_change_bits = s->buf + header.header_size;\n    if (s->flags & FLAG_KEYFRAME) {\n        /* no change bits specified for a keyframe; only index bytes */\n        s->index_stream = s->mb_change_bits;\n    } else {\n        /* one change bit per 4x4 block */\n        s->index_stream = s->mb_change_bits +\n            (s->mb_change_bits_row_size * (s->avctx->height >> 2));\n    }\n    s->index_stream_size = s->size - (s->index_stream - s->buf);\n\n    s->last_deltaset = header.deltaset;\n    s->last_vectable = header.vectable;\n    s->compression = header.compression;\n    s->block_width = compression_types[header.compression].block_width;\n    s->block_height = compression_types[header.compression].block_height;\n    s->block_type = compression_types[header.compression].block_type;\n\n    if (s->avctx->debug & FF_DEBUG_PICT_INFO)\n        av_log(s->avctx, AV_LOG_INFO, \"tables: %d / %d c:%d %dx%d t:%d %s%s%s%s\\n\",\n            s->last_deltaset, s->last_vectable, s->compression, s->block_width,\n            s->block_height, s->block_type,\n            s->flags & FLAG_KEYFRAME ? \" KEY\" : \"\",\n            s->flags & FLAG_INTERFRAME ? \" INTER\" : \"\",\n            s->flags & FLAG_SPRITE ? \" SPRITE\" : \"\",\n            s->flags & FLAG_INTERPOLATED ? \" INTERPOL\" : \"\");\n\n    return header.header_size;\n}", "before_change_lines": [84], "raw_before_change_lines": [84], "after_change_lines": [84], "raw_after_change_lines": [84], "bug_lines": [84], "added": [false], "idx": 158}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3246----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b0d7e5309b34ffc0b5acb05763366e2336741928_1.json----wv_unpack_mono", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_b0d7e5309b34ffc0b5acb05763366e2336741928_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b0d7e5309b34ffc0b5acb05763366e2336741928_1.json", "function_name": "wv_unpack_mono", "vul_func_code": "static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb,\n                                 void *dst, const int type)\n{\n    int i, j, count = 0;\n    int last, t;\n    int A, S, T;\n    int pos                  = s->pos;\n    uint32_t crc             = s->sc.crc;\n    uint32_t crc_extra_bits  = s->extra_sc.crc;\n    int16_t *dst16           = dst;\n    int32_t *dst32           = dst;\n    float *dstfl             = dst;\n\n    s->one = s->zero = s->zeroes = 0;\n    do {\n        T = wv_get_value(s, gb, 0, &last);\n        S = 0;\n        if (last)\n            break;\n        for (i = 0; i < s->terms; i++) {\n            t = s->decorr[i].value;\n            if (t > 8) {\n                if (t & 1)\n                    A =  2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1];\n                else\n                    A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1;\n                s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0];\n                j                        = 0;\n            } else {\n                A = s->decorr[i].samplesA[pos];\n                j = (pos + t) & 7;\n            }\n            if (type != AV_SAMPLE_FMT_S16P)\n                S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10);\n            else\n                S = T + ((s->decorr[i].weightA * A + 512) >> 10);\n            if (A && T)\n                s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta;\n            s->decorr[i].samplesA[j] = T = S;\n        }\n        pos = (pos + 1) & 7;\n        crc = crc * 3 + S;\n\n        if (type == AV_SAMPLE_FMT_FLTP) {\n            *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S);\n        } else if (type == AV_SAMPLE_FMT_S32P) {\n            *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        } else {\n            *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        }\n        count++;\n    } while (!last && count < s->samples);\n\n    wv_reset_saved_context(s);\n\n    if (last && count < s->samples) {\n        int size = av_get_bytes_per_sample(type);\n        memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size);\n    }\n\n    if (s->avctx->err_recognition & AV_EF_CRCCHECK) {\n        int ret = wv_check_crc(s, crc, crc_extra_bits);\n        if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE)\n            return ret;\n    }\n\n    return 0;\n}", "patch_func_code": "static inline int wv_unpack_mono(WavpackFrameContext *s, GetBitContext *gb,\n                                 void *dst, const int type)\n{\n    int i, j, count = 0;\n    int last, t;\n    int A, S, T;\n    int pos                  = s->pos;\n    uint32_t crc             = s->sc.crc;\n    uint32_t crc_extra_bits  = s->extra_sc.crc;\n    int16_t *dst16           = dst;\n    int32_t *dst32           = dst;\n    float *dstfl             = dst;\n\n    s->one = s->zero = s->zeroes = 0;\n    do {\n        T = wv_get_value(s, gb, 0, &last);\n        S = 0;\n        if (last)\n            break;\n        for (i = 0; i < s->terms; i++) {\n            t = s->decorr[i].value;\n            if (t > 8) {\n                if (t & 1)\n                    A =  2U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1];\n                else\n                    A = (int)(3U * s->decorr[i].samplesA[0] - s->decorr[i].samplesA[1]) >> 1;\n                s->decorr[i].samplesA[1] = s->decorr[i].samplesA[0];\n                j                        = 0;\n            } else {\n                A = s->decorr[i].samplesA[pos];\n                j = (pos + t) & 7;\n            }\n            if (type != AV_SAMPLE_FMT_S16P)\n                S = T + ((s->decorr[i].weightA * (int64_t)A + 512) >> 10);\n            else\n                S = T + ((int)(s->decorr[i].weightA * (unsigned)A + 512) >> 10);\n            if (A && T)\n                s->decorr[i].weightA -= ((((T ^ A) >> 30) & 2) - 1) * s->decorr[i].delta;\n            s->decorr[i].samplesA[j] = T = S;\n        }\n        pos = (pos + 1) & 7;\n        crc = crc * 3 + S;\n\n        if (type == AV_SAMPLE_FMT_FLTP) {\n            *dstfl++ = wv_get_value_float(s, &crc_extra_bits, S);\n        } else if (type == AV_SAMPLE_FMT_S32P) {\n            *dst32++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        } else {\n            *dst16++ = wv_get_value_integer(s, &crc_extra_bits, S);\n        }\n        count++;\n    } while (!last && count < s->samples);\n\n    wv_reset_saved_context(s);\n\n    if (last && count < s->samples) {\n        int size = av_get_bytes_per_sample(type);\n        memset((uint8_t*)dst + count*size, 0, (s->samples-count)*size);\n    }\n\n    if (s->avctx->err_recognition & AV_EF_CRCCHECK) {\n        int ret = wv_check_crc(s, crc, crc_extra_bits);\n        if (ret < 0 && s->avctx->err_recognition & AV_EF_EXPLODE)\n            return ret;\n    }\n\n    return 0;\n}", "before_change_lines": [36], "raw_before_change_lines": [36], "after_change_lines": [36], "raw_after_change_lines": [36], "bug_lines": [36], "added": [false], "idx": 159}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3260----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b16469e6e157af1fbbc4e6e6fefb856898969227_1.json----jpeg2000_read_main_headers", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_b16469e6e157af1fbbc4e6e6fefb856898969227_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b16469e6e157af1fbbc4e6e6fefb856898969227_1.json", "function_name": "jpeg2000_read_main_headers", "vul_func_code": "static int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)\n{\n    Jpeg2000CodingStyle *codsty = s->codsty;\n    Jpeg2000QuantStyle *qntsty  = s->qntsty;\n    uint8_t *properties         = s->properties;\n\n    for (;;) {\n        int len, ret = 0;\n        uint16_t marker;\n        const uint8_t *oldbuf;\n\n        if (s->buf_end - s->buf < 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n            break;\n        }\n\n        marker = bytestream_get_be16(&s->buf);\n        oldbuf = s->buf;\n\n        if (marker == JPEG2000_EOC)\n            break;\n\n        if (s->buf_end - s->buf < 2)\n            return AVERROR(EINVAL);\n        len = bytestream_get_be16(&s->buf);\n        switch (marker) {\n        case JPEG2000_SIZ:\n            ret = get_siz(s);\n            break;\n        case JPEG2000_COC:\n            ret = get_coc(s, codsty, properties);\n            break;\n        case JPEG2000_COD:\n            ret = get_cod(s, codsty, properties);\n            break;\n        case JPEG2000_QCC:\n            ret = get_qcc(s, len, qntsty, properties);\n            break;\n        case JPEG2000_QCD:\n            ret = get_qcd(s, len, qntsty, properties);\n            break;\n        case JPEG2000_SOT:\n            ret = get_sot(s, len);\n            break;\n        case JPEG2000_COM:\n            // the comment is ignored\n            s->buf += len - 2;\n            break;\n        case JPEG2000_TLM:\n            // Tile-part lengths\n            ret = get_tlm(s, len);\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"unsupported marker 0x%.4X at pos 0x%tX\\n\",\n                   marker, s->buf - s->buf_start - 4);\n            s->buf += len - 2;\n            break;\n        }\n        if (((s->buf - oldbuf != len) && (marker != JPEG2000_SOT)) || ret) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"error during processing marker segment %.4x\\n\", marker);\n            return ret ? ret : -1;\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int jpeg2000_read_main_headers(Jpeg2000DecoderContext *s)\n{\n    Jpeg2000CodingStyle *codsty = s->codsty;\n    Jpeg2000QuantStyle *qntsty  = s->qntsty;\n    uint8_t *properties         = s->properties;\n\n    for (;;) {\n        int len, ret = 0;\n        uint16_t marker;\n        int oldpos;\n\n        if (bytestream2_get_bytes_left(&s->g) < 2) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing EOC\\n\");\n            break;\n        }\n\n        marker = bytestream2_get_be16u(&s->g);\n        oldpos = bytestream2_tell(&s->g);\n\n        if (marker == JPEG2000_EOC)\n            break;\n\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n            return AVERROR(EINVAL);\n        len = bytestream2_get_be16u(&s->g);\n        switch (marker) {\n        case JPEG2000_SIZ:\n            ret = get_siz(s);\n            break;\n        case JPEG2000_COC:\n            ret = get_coc(s, codsty, properties);\n            break;\n        case JPEG2000_COD:\n            ret = get_cod(s, codsty, properties);\n            break;\n        case JPEG2000_QCC:\n            ret = get_qcc(s, len, qntsty, properties);\n            break;\n        case JPEG2000_QCD:\n            ret = get_qcd(s, len, qntsty, properties);\n            break;\n        case JPEG2000_SOT:\n            ret = get_sot(s, len);\n            break;\n        case JPEG2000_COM:\n            // the comment is ignored\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        case JPEG2000_TLM:\n            // Tile-part lengths\n            ret = get_tlm(s, len);\n            break;\n        default:\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"unsupported marker 0x%.4X at pos 0x%tX\\n\",\n                   marker, bytestream2_tell(&s->g) - 4);\n            bytestream2_skip(&s->g, len - 2);\n            break;\n        }\n        if (((bytestream2_tell(&s->g) - oldpos != len) && (marker != JPEG2000_SOT)) || ret) {\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"error during processing marker segment %.4x\\n\", marker);\n            return ret ? ret : -1;\n        }\n    }\n    return 0;\n}", "before_change_lines": [10, 12, 17, 18, 23, 25, 47, 56, 57, 60], "raw_before_change_lines": [10, 12, 17, 18, 23, 25, 47, 56, 57, 60], "after_change_lines": [10, 12, 17, 18, 23, 25, 47, 56, 57, 60], "raw_after_change_lines": [10, 12, 17, 18, 23, 25, 47, 56, 57, 60], "bug_lines": [10, 12, 17, 18, 23, 25, 47, 56, 57, 60], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 160}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3306----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b3845f35227bdba24b41e340b66abaf3d81b336c_1.json----show_stream", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_b3845f35227bdba24b41e340b66abaf3d81b336c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_b3845f35227bdba24b41e340b66abaf3d81b336c_1.json", "function_name": "show_stream", "vul_func_code": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx)\n{\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n    AVCodecContext *dec_ctx;\n    AVCodec *dec;\n    char val_str[128];\n    AVRational display_aspect_ratio;\n    struct print_buf pbuf = {.s = NULL};\n\n    print_section_header(\"stream\");\n\n    print_int(\"index\", stream->index);\n\n    if ((dec_ctx = stream->codec)) {\n        if ((dec = dec_ctx->codec)) {\n            print_str(\"codec_name\",      dec->name);\n            print_str(\"codec_long_name\", dec->long_name);\n        } else {\n            print_str(\"codec_name\",      \"unknown\");\n        }\n\n        print_str(\"codec_type\", av_x_if_null(av_get_media_type_string(dec_ctx->codec_type), \"unknown\"));\n        print_fmt(\"codec_time_base\", \"%d/%d\", dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n        /* print AVI/FourCC tag */\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n        print_str(\"codec_tag_string\",    val_str);\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n        switch (dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            print_int(\"width\",        dec_ctx->width);\n            print_int(\"height\",       dec_ctx->height);\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n            if (dec_ctx->sample_aspect_ratio.num) {\n                print_fmt(\"sample_aspect_ratio\", \"%d:%d\",\n                          dec_ctx->sample_aspect_ratio.num,\n                          dec_ctx->sample_aspect_ratio.den);\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n                          1024*1024);\n                print_fmt(\"display_aspect_ratio\", \"%d:%d\",\n                          display_aspect_ratio.num,\n                          display_aspect_ratio.den);\n            }\n            print_str(\"pix_fmt\", av_x_if_null(av_get_pix_fmt_name(dec_ctx->pix_fmt), \"unknown\"));\n            print_int(\"level\",   dec_ctx->level);\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n            print_str(\"sample_fmt\",\n                      av_x_if_null(av_get_sample_fmt_name(dec_ctx->sample_fmt), \"unknown\"));\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n            print_int(\"channels\",        dec_ctx->channels);\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n            break;\n        }\n    } else {\n        print_str(\"codec_type\", \"unknown\");\n    }\n    if (dec_ctx->codec && dec_ctx->codec->priv_class) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n        print_fmt(\"id\", \"0x%x\", stream->id);\n    print_fmt(\"r_frame_rate\",   \"%d/%d\", stream->r_frame_rate.num,   stream->r_frame_rate.den);\n    print_fmt(\"avg_frame_rate\", \"%d/%d\", stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n    print_fmt(\"time_base\",      \"%d/%d\", stream->time_base.num,      stream->time_base.den);\n    print_time(\"start_time\",    stream->start_time, &stream->time_base);\n    print_time(\"duration\",      stream->duration,   &stream->time_base);\n    if (stream->nb_frames)\n        print_fmt(\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n\n    show_tags(stream->metadata);\n\n    print_section_footer(\"stream\");\n    av_free(pbuf.s);\n    fflush(stdout);\n}", "patch_func_code": "static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx)\n{\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n    AVCodecContext *dec_ctx;\n    AVCodec *dec;\n    char val_str[128];\n    const char *s;\n    AVRational display_aspect_ratio;\n    struct print_buf pbuf = {.s = NULL};\n\n    print_section_header(\"stream\");\n\n    print_int(\"index\", stream->index);\n\n    if ((dec_ctx = stream->codec)) {\n        if ((dec = dec_ctx->codec)) {\n            print_str(\"codec_name\",      dec->name);\n            print_str(\"codec_long_name\", dec->long_name);\n        } else {\n            print_str_opt(\"codec_name\",      \"unknown\");\n            print_str_opt(\"codec_long_name\", \"unknown\");\n        }\n\n        s = av_get_media_type_string(dec_ctx->codec_type);\n        if (s) print_str    (\"codec_type\", s);\n        else   print_str_opt(\"codec_type\", \"unknown\");\n        print_fmt(\"codec_time_base\", \"%d/%d\", dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n        /* print AVI/FourCC tag */\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n        print_str(\"codec_tag_string\",    val_str);\n        print_fmt(\"codec_tag\", \"0x%04x\", dec_ctx->codec_tag);\n\n        switch (dec_ctx->codec_type) {\n        case AVMEDIA_TYPE_VIDEO:\n            print_int(\"width\",        dec_ctx->width);\n            print_int(\"height\",       dec_ctx->height);\n            print_int(\"has_b_frames\", dec_ctx->has_b_frames);\n            if (dec_ctx->sample_aspect_ratio.num) {\n                print_fmt(\"sample_aspect_ratio\", \"%d:%d\",\n                          dec_ctx->sample_aspect_ratio.num,\n                          dec_ctx->sample_aspect_ratio.den);\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n                          1024*1024);\n                print_fmt(\"display_aspect_ratio\", \"%d:%d\",\n                          display_aspect_ratio.num,\n                          display_aspect_ratio.den);\n            } else {\n                print_str_opt(\"sample_aspect_ratio\", \"N/A\");\n                print_str_opt(\"display_aspect_ratio\", \"N/A\");\n            }\n            s = av_get_pix_fmt_name(dec_ctx->pix_fmt);\n            if (s) print_str    (\"pix_fmt\", s);\n            else   print_str_opt(\"pix_fmt\", \"unknown\");\n            print_int(\"level\",   dec_ctx->level);\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n            s = av_get_sample_fmt_name(dec_ctx->sample_fmt);\n            if (s) print_str    (\"sample_fmt\", s);\n            else   print_str_opt(\"sample_fmt\", \"unknown\");\n            print_val(\"sample_rate\",     dec_ctx->sample_rate, unit_hertz_str);\n            print_int(\"channels\",        dec_ctx->channels);\n            print_int(\"bits_per_sample\", av_get_bits_per_sample(dec_ctx->codec_id));\n            break;\n        }\n    } else {\n        print_str_opt(\"codec_type\", \"unknown\");\n    }\n    if (dec_ctx->codec && dec_ctx->codec->priv_class) {\n        const AVOption *opt = NULL;\n        while (opt = av_opt_next(dec_ctx->priv_data,opt)) {\n            uint8_t *str;\n            if (opt->flags) continue;\n            if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) {\n                print_str(opt->name, str);\n                av_free(str);\n            }\n        }\n    }\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt    (\"id\", \"0x%x\", stream->id);\n    else                                          print_str_opt(\"id\", \"N/A\");\n    print_fmt(\"r_frame_rate\",   \"%d/%d\", stream->r_frame_rate.num,   stream->r_frame_rate.den);\n    print_fmt(\"avg_frame_rate\", \"%d/%d\", stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n    print_fmt(\"time_base\",      \"%d/%d\", stream->time_base.num,      stream->time_base.den);\n    print_time(\"start_time\",    stream->start_time, &stream->time_base);\n    print_time(\"duration\",      stream->duration,   &stream->time_base);\n    if (stream->nb_frames) print_fmt    (\"nb_frames\", \"%\"PRId64, stream->nb_frames);\n    else                   print_str_opt(\"nb_frames\", \"N/A\");\n    show_tags(stream->metadata);\n\n    print_section_footer(\"stream\");\n    av_free(pbuf.s);\n    fflush(stdout);\n}", "before_change_lines": [19, 22, 47, 52, 53, 60, 74, 75, 81, 82], "raw_before_change_lines": [19, 22, 47, 52, 53, 60, 74, 75, 81, 82, 83], "after_change_lines": [7, 20, 21, 24, 25, 26, 50, 51, 52, 54, 55, 56, 61, 62, 63, 70, 84, 85, 91, 92], "raw_after_change_lines": [7, 20, 21, 24, 25, 26, 50, 51, 52, 54, 55, 56, 61, 62, 63, 70, 84, 85, 91, 92], "bug_lines": [19, 22, 47, 52, 53, 60, 74, 75, 81, 82, 83], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 161}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "3457----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bab4e5a73df6e769936c7652bbc519f5fba56a36_1.json----avfilter_filter_samples", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_bab4e5a73df6e769936c7652bbc519f5fba56a36_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bab4e5a73df6e769936c7652bbc519f5fba56a36_1.json", "function_name": "avfilter_filter_samples", "vul_func_code": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n{\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n    AVFilterPad *dst = link->dstpad;\n    int i;\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n    if (!(filter_samples = dst->filter_samples))\n        filter_samples = avfilter_default_filter_samples;\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n        dst->rej_perms & samplesref->perms) {\n\n        av_log(link->dst, AV_LOG_DEBUG,\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n                                                          samplesref->audio->nb_samples);\n        link->cur_buf->pts                = samplesref->pts;\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n        /* Copy actual data into new samples buffer */\n        for (i = 0; samplesref->data[i]; i++)\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n        avfilter_unref_buffer(samplesref);\n    } else\n        link->cur_buf = samplesref;\n\n    filter_samples(link, link->cur_buf);\n}", "patch_func_code": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n{\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n    AVFilterPad *dst = link->dstpad;\n    int i;\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n    if (!(filter_samples = dst->filter_samples))\n        filter_samples = avfilter_default_filter_samples;\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n        dst->rej_perms & samplesref->perms) {\n\n        av_log(link->dst, AV_LOG_DEBUG,\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n                                                          samplesref->audio->nb_samples);\n        link->cur_buf->pts                = samplesref->pts;\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n        /* Copy actual data into new samples buffer */\n        for (i = 0; samplesref->data[i] && i < 8; i++)\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n        avfilter_unref_buffer(samplesref);\n    } else\n        link->cur_buf = samplesref;\n\n    filter_samples(link, link->cur_buf);\n}", "before_change_lines": [26], "raw_before_change_lines": [26], "after_change_lines": [26], "raw_after_change_lines": [26], "bug_lines": [26], "added": [false], "idx": 162}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3499----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bd36d3673dbf920e8b3ddd1a1bf01242e23235d1_1.json----decode_coeffs_b_generic", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_bd36d3673dbf920e8b3ddd1a1bf01242e23235d1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bd36d3673dbf920e8b3ddd1a1bf01242e23235d1_1.json", "function_name": "decode_coeffs_b_generic", "vul_func_code": "static av_always_inline int\ndecode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs,\n                        int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3],\n                        unsigned (*eob)[6][2], uint8_t (*p)[6][11],\n                        int nnz, const int16_t *scan, const int16_t (*nb)[2],\n                        const int16_t *band_counts, const int16_t *qmul)\n{\n    int i = 0, band = 0, band_left = band_counts[band];\n    uint8_t *tp = p[0][nnz];\n    uint8_t cache[1024];\n\n    do {\n        int val, rc;\n\n        val = vp56_rac_get_prob_branchy(c, tp[0]); // eob\n        eob[band][nnz][val]++;\n        if (!val)\n            break;\n\nskip_eob:\n        if (!vp56_rac_get_prob_branchy(c, tp[1])) { // zero\n            cnt[band][nnz][0]++;\n            if (!--band_left)\n                band_left = band_counts[++band];\n            cache[scan[i]] = 0;\n            nnz            = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;\n            tp             = p[band][nnz];\n            if (++i == n_coeffs)\n                break;  //invalid input; blocks should end with EOB\n            goto skip_eob;\n        }\n\n        rc = scan[i];\n        if (!vp56_rac_get_prob_branchy(c, tp[2])) { // one\n            cnt[band][nnz][1]++;\n            val       = 1;\n            cache[rc] = 1;\n        } else {\n            // fill in p[3-10] (model fill) - only once per frame for each pos\n            if (!tp[3])\n                memcpy(&tp[3], ff_vp9_model_pareto8[tp[2]], 8);\n\n            cnt[band][nnz][2]++;\n            if (!vp56_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4\n                if (!vp56_rac_get_prob_branchy(c, tp[4])) {\n                    cache[rc] = val = 2;\n                } else {\n                    val       = 3 + vp56_rac_get_prob(c, tp[5]);\n                    cache[rc] = 3;\n                }\n            } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { // cat1/2\n                cache[rc] = 4;\n                if (!vp56_rac_get_prob_branchy(c, tp[7])) {\n                    val  =  vp56_rac_get_prob(c, 159) + 5;\n                } else {\n                    val  = (vp56_rac_get_prob(c, 165) << 1) + 7;\n                    val +=  vp56_rac_get_prob(c, 145);\n                }\n            } else { // cat 3-6\n                cache[rc] = 5;\n                if (!vp56_rac_get_prob_branchy(c, tp[8])) {\n                    if (!vp56_rac_get_prob_branchy(c, tp[9])) {\n                        val  = 11 + (vp56_rac_get_prob(c, 173) << 2);\n                        val +=      (vp56_rac_get_prob(c, 148) << 1);\n                        val +=       vp56_rac_get_prob(c, 140);\n                    } else {\n                        val  = 19 + (vp56_rac_get_prob(c, 176) << 3);\n                        val +=      (vp56_rac_get_prob(c, 155) << 2);\n                        val +=      (vp56_rac_get_prob(c, 140) << 1);\n                        val +=       vp56_rac_get_prob(c, 135);\n                    }\n                } else if (!vp56_rac_get_prob_branchy(c, tp[10])) {\n                    val  = (vp56_rac_get_prob(c, 180) << 4) + 35;\n                    val += (vp56_rac_get_prob(c, 157) << 3);\n                    val += (vp56_rac_get_prob(c, 141) << 2);\n                    val += (vp56_rac_get_prob(c, 134) << 1);\n                    val +=  vp56_rac_get_prob(c, 130);\n                } else {\n                    val = 67;\n                    if (!is8bitsperpixel) {\n                        if (bpp == 12) {\n                            val += vp56_rac_get_prob(c, 255) << 17;\n                            val += vp56_rac_get_prob(c, 255) << 16;\n                        }\n                        val +=  (vp56_rac_get_prob(c, 255) << 15);\n                        val +=  (vp56_rac_get_prob(c, 255) << 14);\n                    }\n                    val += (vp56_rac_get_prob(c, 254) << 13);\n                    val += (vp56_rac_get_prob(c, 254) << 12);\n                    val += (vp56_rac_get_prob(c, 254) << 11);\n                    val += (vp56_rac_get_prob(c, 252) << 10);\n                    val += (vp56_rac_get_prob(c, 249) << 9);\n                    val += (vp56_rac_get_prob(c, 243) << 8);\n                    val += (vp56_rac_get_prob(c, 230) << 7);\n                    val += (vp56_rac_get_prob(c, 196) << 6);\n                    val += (vp56_rac_get_prob(c, 177) << 5);\n                    val += (vp56_rac_get_prob(c, 153) << 4);\n                    val += (vp56_rac_get_prob(c, 140) << 3);\n                    val += (vp56_rac_get_prob(c, 133) << 2);\n                    val += (vp56_rac_get_prob(c, 130) << 1);\n                    val +=  vp56_rac_get_prob(c, 129);\n                }\n            }\n        }\n#define STORE_COEF(c, i, v) do { \\\n    if (is8bitsperpixel) { \\\n        c[i] = v; \\\n    } else { \\\n        AV_WN32A(&c[i * 2], v); \\\n    } \\\n} while (0)\n        if (!--band_left)\n            band_left = band_counts[++band];\n        if (is_tx32x32)\n            STORE_COEF(coef, rc, ((vp8_rac_get(c) ? -val : val) * qmul[!!i]) / 2);\n        else\n            STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * qmul[!!i]);\n        nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;\n        tp = p[band][nnz];\n    } while (++i < n_coeffs);\n\n    return i;\n}", "patch_func_code": "static av_always_inline int\ndecode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs,\n                        int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3],\n                        unsigned (*eob)[6][2], uint8_t (*p)[6][11],\n                        int nnz, const int16_t *scan, const int16_t (*nb)[2],\n                        const int16_t *band_counts, const int16_t *qmul)\n{\n    int i = 0, band = 0, band_left = band_counts[band];\n    uint8_t *tp = p[0][nnz];\n    uint8_t cache[1024];\n\n    do {\n        int val, rc;\n\n        val = vp56_rac_get_prob_branchy(c, tp[0]); // eob\n        eob[band][nnz][val]++;\n        if (!val)\n            break;\n\nskip_eob:\n        if (!vp56_rac_get_prob_branchy(c, tp[1])) { // zero\n            cnt[band][nnz][0]++;\n            if (!--band_left)\n                band_left = band_counts[++band];\n            cache[scan[i]] = 0;\n            nnz            = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;\n            tp             = p[band][nnz];\n            if (++i == n_coeffs)\n                break;  //invalid input; blocks should end with EOB\n            goto skip_eob;\n        }\n\n        rc = scan[i];\n        if (!vp56_rac_get_prob_branchy(c, tp[2])) { // one\n            cnt[band][nnz][1]++;\n            val       = 1;\n            cache[rc] = 1;\n        } else {\n            // fill in p[3-10] (model fill) - only once per frame for each pos\n            if (!tp[3])\n                memcpy(&tp[3], ff_vp9_model_pareto8[tp[2]], 8);\n\n            cnt[band][nnz][2]++;\n            if (!vp56_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4\n                if (!vp56_rac_get_prob_branchy(c, tp[4])) {\n                    cache[rc] = val = 2;\n                } else {\n                    val       = 3 + vp56_rac_get_prob(c, tp[5]);\n                    cache[rc] = 3;\n                }\n            } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { // cat1/2\n                cache[rc] = 4;\n                if (!vp56_rac_get_prob_branchy(c, tp[7])) {\n                    val  =  vp56_rac_get_prob(c, 159) + 5;\n                } else {\n                    val  = (vp56_rac_get_prob(c, 165) << 1) + 7;\n                    val +=  vp56_rac_get_prob(c, 145);\n                }\n            } else { // cat 3-6\n                cache[rc] = 5;\n                if (!vp56_rac_get_prob_branchy(c, tp[8])) {\n                    if (!vp56_rac_get_prob_branchy(c, tp[9])) {\n                        val  = 11 + (vp56_rac_get_prob(c, 173) << 2);\n                        val +=      (vp56_rac_get_prob(c, 148) << 1);\n                        val +=       vp56_rac_get_prob(c, 140);\n                    } else {\n                        val  = 19 + (vp56_rac_get_prob(c, 176) << 3);\n                        val +=      (vp56_rac_get_prob(c, 155) << 2);\n                        val +=      (vp56_rac_get_prob(c, 140) << 1);\n                        val +=       vp56_rac_get_prob(c, 135);\n                    }\n                } else if (!vp56_rac_get_prob_branchy(c, tp[10])) {\n                    val  = (vp56_rac_get_prob(c, 180) << 4) + 35;\n                    val += (vp56_rac_get_prob(c, 157) << 3);\n                    val += (vp56_rac_get_prob(c, 141) << 2);\n                    val += (vp56_rac_get_prob(c, 134) << 1);\n                    val +=  vp56_rac_get_prob(c, 130);\n                } else {\n                    val = 67;\n                    if (!is8bitsperpixel) {\n                        if (bpp == 12) {\n                            val += vp56_rac_get_prob(c, 255) << 17;\n                            val += vp56_rac_get_prob(c, 255) << 16;\n                        }\n                        val +=  (vp56_rac_get_prob(c, 255) << 15);\n                        val +=  (vp56_rac_get_prob(c, 255) << 14);\n                    }\n                    val += (vp56_rac_get_prob(c, 254) << 13);\n                    val += (vp56_rac_get_prob(c, 254) << 12);\n                    val += (vp56_rac_get_prob(c, 254) << 11);\n                    val += (vp56_rac_get_prob(c, 252) << 10);\n                    val += (vp56_rac_get_prob(c, 249) << 9);\n                    val += (vp56_rac_get_prob(c, 243) << 8);\n                    val += (vp56_rac_get_prob(c, 230) << 7);\n                    val += (vp56_rac_get_prob(c, 196) << 6);\n                    val += (vp56_rac_get_prob(c, 177) << 5);\n                    val += (vp56_rac_get_prob(c, 153) << 4);\n                    val += (vp56_rac_get_prob(c, 140) << 3);\n                    val += (vp56_rac_get_prob(c, 133) << 2);\n                    val += (vp56_rac_get_prob(c, 130) << 1);\n                    val +=  vp56_rac_get_prob(c, 129);\n                }\n            }\n        }\n#define STORE_COEF(c, i, v) do { \\\n    if (is8bitsperpixel) { \\\n        c[i] = v; \\\n    } else { \\\n        AV_WN32A(&c[i * 2], v); \\\n    } \\\n} while (0)\n        if (!--band_left)\n            band_left = band_counts[++band];\n        if (is_tx32x32)\n            STORE_COEF(coef, rc, (int)((vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2);\n        else\n            STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]);\n        nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;\n        tp = p[band][nnz];\n    } while (++i < n_coeffs);\n\n    return i;\n}", "before_change_lines": [115, 117], "raw_before_change_lines": [115, 117], "after_change_lines": [115, 117], "raw_after_change_lines": [115, 117], "bug_lines": [115, 117], "added": [false, false], "idx": 163}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "3502----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bd3f9eeb97a5d4772ceb58075189093cff823a4b_1.json----mxf_write_header_metadata_sets", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_bd3f9eeb97a5d4772ceb58075189093cff823a4b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_bd3f9eeb97a5d4772ceb58075189093cff823a4b_1.json", "function_name": "mxf_write_header_metadata_sets", "vul_func_code": "static int mxf_write_header_metadata_sets(AVFormatContext *s)\n{\n    AVStream *st;\n    MXFStreamContext *sc = NULL;\n    int i;\n\n    mxf_write_preface(s);\n    mxf_write_identification(s);\n    mxf_write_content_storage(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        st = s->streams[i];\n        sc = av_mallocz(sizeof(MXFStreamContext));\n        if (!sc)\n            return AVERROR(ENOMEM);\n        st->priv_data = sc;\n        // set pts information\n        if (st->codec->codec_type == CODEC_TYPE_VIDEO)\n            av_set_pts_info(st, 64, 1, st->codec->time_base.den);\n        else if (st->codec->codec_type == CODEC_TYPE_AUDIO)\n            av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n    }\n\n    mxf_build_structural_metadata(s, MaterialPackage);\n    mxf_build_structural_metadata(s, SourcePackage);\n    return 0;\n}", "patch_func_code": "static int mxf_write_header_metadata_sets(AVFormatContext *s)\n{\n    mxf_write_preface(s);\n    mxf_write_identification(s);\n    mxf_write_content_storage(s);\n    mxf_build_structural_metadata(s, MaterialPackage);\n    mxf_build_structural_metadata(s, SourcePackage);\n    return 0;\n}", "before_change_lines": [3, 4, 5, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22], "raw_before_change_lines": [3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 164}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3724----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_c8509f2b90f9aa8861a18c05e97f2bab35d68024_1.json----calculate_bitrate", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_c8509f2b90f9aa8861a18c05e97f2bab35d68024_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_c8509f2b90f9aa8861a18c05e97f2bab35d68024_1.json", "function_name": "calculate_bitrate", "vul_func_code": "static int calculate_bitrate(AVFormatContext *s)\n{\n    AVIContext *avi = s->priv_data;\n    int i, j;\n    int64_t lensum = 0;\n    int64_t maxpos = 0;\n\n    for (i = 0; i<s->nb_streams; i++) {\n        int64_t len = 0;\n        AVStream *st = s->streams[i];\n\n        if (!st->nb_index_entries)\n            continue;\n\n        for (j = 0; j < st->nb_index_entries; j++)\n            len += st->index_entries[j].size;\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n        lensum += len;\n    }\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n        return 0;\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n        return 0;\n\n    for (i = 0; i<s->nb_streams; i++) {\n        int64_t len = 0;\n        AVStream *st = s->streams[i];\n        int64_t duration;\n\n        for (j = 0; j < st->nb_index_entries; j++)\n            len += st->index_entries[j].size;\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n            continue;\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n    }\n    return 1;\n}", "patch_func_code": "static int calculate_bitrate(AVFormatContext *s)\n{\n    AVIContext *avi = s->priv_data;\n    int i, j;\n    int64_t lensum = 0;\n    int64_t maxpos = 0;\n\n    for (i = 0; i<s->nb_streams; i++) {\n        int64_t len = 0;\n        AVStream *st = s->streams[i];\n\n        if (!st->nb_index_entries)\n            continue;\n\n        for (j = 0; j < st->nb_index_entries; j++)\n            len += st->index_entries[j].size;\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n        lensum += len;\n    }\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n        return 0;\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n        return 0;\n\n    for (i = 0; i<s->nb_streams; i++) {\n        int64_t len = 0;\n        AVStream *st = s->streams[i];\n        int64_t duration;\n        int64_t bitrate;\n\n        for (j = 0; j < st->nb_index_entries; j++)\n            len += st->index_entries[j].size;\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n            continue;\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n        bitrate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n        if (bitrate <= INT_MAX && bitrate > 0) {\n            st->codec->bit_rate = bitrate;\n        }\n    }\n    return 1;\n}", "before_change_lines": [36], "raw_before_change_lines": [36], "after_change_lines": [29, 37, 38, 39, 40], "raw_after_change_lines": [29, 37, 38, 39, 40], "bug_lines": [36], "added": [false], "idx": 165}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "3749----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_c9c38ef562721b38c036c4419a4a08588e9cb77b_1.json----configure_video_filters", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_c9c38ef562721b38c036c4419a4a08588e9cb77b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_c9c38ef562721b38c036c4419a4a08588e9cb77b_1.json", "function_name": "configure_video_filters", "vul_func_code": "static int configure_video_filters(FilterGraph *fg)\n{\n    InputStream  *ist = fg->inputs[0]->ist;\n    OutputStream *ost = fg->outputs[0]->ost;\n    AVFilterContext *in_filter, *out_filter, *filter;\n    AVCodecContext *codec = ost->st->codec;\n    char *pix_fmts;\n    AVRational sample_aspect_ratio;\n    char args[255];\n    int ret;\n\n    avfilter_graph_free(&fg->graph);\n    fg->graph = avfilter_graph_alloc();\n\n    if (ist->st->sample_aspect_ratio.num) {\n        sample_aspect_ratio = ist->st->sample_aspect_ratio;\n    } else\n        sample_aspect_ratio = ist->st->codec->sample_aspect_ratio;\n\n    snprintf(args, 255, \"%d:%d:%d:%d:%d:%d:%d\", ist->st->codec->width,\n             ist->st->codec->height, ist->st->codec->pix_fmt, 1, AV_TIME_BASE,\n             sample_aspect_ratio.num, sample_aspect_ratio.den);\n\n    ret = avfilter_graph_create_filter(&fg->inputs[0]->filter,\n                                       avfilter_get_by_name(\"buffer\"),\n                                       \"src\", args, NULL, fg->graph);\n    if (ret < 0)\n        return ret;\n    ret = avfilter_graph_create_filter(&fg->outputs[0]->filter,\n                                       avfilter_get_by_name(\"buffersink\"),\n                                       \"out\", NULL, NULL, fg->graph);\n    if (ret < 0)\n        return ret;\n    in_filter  = fg->inputs[0]->filter;\n    out_filter = fg->outputs[0]->filter;\n\n    if (codec->width || codec->height) {\n        snprintf(args, 255, \"%d:%d:flags=0x%X\",\n                 codec->width,\n                 codec->height,\n                 (unsigned)ost->sws_flags);\n        if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name(\"scale\"),\n                                                NULL, args, NULL, fg->graph)) < 0)\n            return ret;\n        if ((ret = avfilter_link(in_filter, 0, filter, 0)) < 0)\n            return ret;\n        in_filter = filter;\n    }\n\n    if ((pix_fmts = choose_pixel_fmts(ost))) {\n        if ((ret = avfilter_graph_create_filter(&filter,\n                                                avfilter_get_by_name(\"format\"),\n                                                \"format\", pix_fmts, NULL,\n                                                fg->graph)) < 0)\n            return ret;\n        if ((ret = avfilter_link(filter, 0, out_filter, 0)) < 0)\n            return ret;\n\n        out_filter = filter;\n        av_freep(&pix_fmts);\n    }\n\n    snprintf(args, sizeof(args), \"flags=0x%X\", (unsigned)ost->sws_flags);\n    fg->graph->scale_sws_opts = av_strdup(args);\n\n    if (ost->avfilter) {\n        AVFilterInOut *outputs = avfilter_inout_alloc();\n        AVFilterInOut *inputs  = avfilter_inout_alloc();\n\n        outputs->name    = av_strdup(\"in\");\n        outputs->filter_ctx = in_filter;\n        outputs->pad_idx = 0;\n        outputs->next    = NULL;\n\n        inputs->name    = av_strdup(\"out\");\n        inputs->filter_ctx = out_filter;\n        inputs->pad_idx = 0;\n        inputs->next    = NULL;\n\n        if ((ret = avfilter_graph_parse(fg->graph, ost->avfilter, inputs, outputs, NULL)) < 0)\n            return ret;\n    } else {\n        if ((ret = avfilter_link(in_filter, 0, out_filter, 0)) < 0)\n            return ret;\n    }\n\n    if ((ret = avfilter_graph_config(fg->graph, NULL)) < 0)\n        return ret;\n\n    ost->filter = fg->outputs[0];\n\n    return 0;\n}", "patch_func_code": "static int configure_video_filters(FilterGraph *fg, AVFilterContext **in_filter,\n                                   AVFilterContext **out_filter)\n{\n    InputStream  *ist = fg->inputs[0]->ist;\n    OutputStream *ost = fg->outputs[0]->ost;\n    AVFilterContext *filter;\n    AVCodecContext *codec = ost->st->codec;\n    char *pix_fmts;\n    AVRational sample_aspect_ratio;\n    char args[255];\n    int ret;\n\n    if (ist->st->sample_aspect_ratio.num) {\n        sample_aspect_ratio = ist->st->sample_aspect_ratio;\n    } else\n        sample_aspect_ratio = ist->st->codec->sample_aspect_ratio;\n\n    snprintf(args, 255, \"%d:%d:%d:%d:%d:%d:%d\", ist->st->codec->width,\n             ist->st->codec->height, ist->st->codec->pix_fmt, 1, AV_TIME_BASE,\n             sample_aspect_ratio.num, sample_aspect_ratio.den);\n\n    ret = avfilter_graph_create_filter(&fg->inputs[0]->filter,\n                                       avfilter_get_by_name(\"buffer\"),\n                                       \"src\", args, NULL, fg->graph);\n    if (ret < 0)\n        return ret;\n    ret = avfilter_graph_create_filter(&fg->outputs[0]->filter,\n                                       avfilter_get_by_name(\"buffersink\"),\n                                       \"out\", NULL, NULL, fg->graph);\n    if (ret < 0)\n        return ret;\n    *in_filter  = fg->inputs[0]->filter;\n    *out_filter = fg->outputs[0]->filter;\n\n    if (codec->width || codec->height) {\n        snprintf(args, 255, \"%d:%d:flags=0x%X\",\n                 codec->width,\n                 codec->height,\n                 (unsigned)ost->sws_flags);\n        if ((ret = avfilter_graph_create_filter(&filter, avfilter_get_by_name(\"scale\"),\n                                                NULL, args, NULL, fg->graph)) < 0)\n            return ret;\n        if ((ret = avfilter_link(*in_filter, 0, filter, 0)) < 0)\n            return ret;\n        *in_filter = filter;\n    }\n\n    if ((pix_fmts = choose_pix_fmts(ost))) {\n        if ((ret = avfilter_graph_create_filter(&filter,\n                                                avfilter_get_by_name(\"format\"),\n                                                \"format\", pix_fmts, NULL,\n                                                fg->graph)) < 0)\n            return ret;\n        if ((ret = avfilter_link(filter, 0, *out_filter, 0)) < 0)\n            return ret;\n\n        *out_filter = filter;\n        av_freep(&pix_fmts);\n    }\n\n    snprintf(args, sizeof(args), \"flags=0x%X\", (unsigned)ost->sws_flags);\n    fg->graph->scale_sws_opts = av_strdup(args);\n\n    return 0;\n}", "before_change_lines": [1, 5, 12, 13, 34, 35, 45, 47, 50, 56, 59], "raw_before_change_lines": [1, 5, 12, 13, 14, 34, 35, 45, 47, 50, 56, 59], "after_change_lines": [1, 2, 6, 32, 33, 43, 45, 48, 54, 57, 64, 65], "raw_after_change_lines": [1, 2, 6, 32, 33, 43, 45, 48, 54, 57, 64, 65], "bug_lines": [1, 5, 12, 13, 14, 34, 35, 45, 47, 50, 56, 59], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 166}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3761----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ca0c9794c109ad6e45be52fd3eaa158b420d6542_1.json----unpack_codebook", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_ca0c9794c109ad6e45be52fd3eaa158b420d6542_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ca0c9794c109ad6e45be52fd3eaa158b420d6542_1.json", "function_name": "unpack_codebook", "vul_func_code": "static CodeBook unpack_codebook(GetBitContext* gb, unsigned depth,\n                                 unsigned size)\n{\n    unsigned i, j;\n    CodeBook cb = { 0 };\n\n    if (!can_safely_read(gb, (uint64_t)size * 34))\n        return cb;\n\n    if (size >= INT_MAX / sizeof(MacroBlock))\n        return cb;\n    cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1);\n    if (!cb.blocks)\n        return cb;\n\n    cb.depth = depth;\n    cb.size = size;\n    for (i = 0; i < size; i++) {\n        unsigned mask_bits = get_bits(gb, 4);\n        unsigned color0 = get_bits(gb, 15);\n        unsigned color1 = get_bits(gb, 15);\n\n        for (j = 0; j < 4; j++) {\n            if (mask_bits & (1 << j))\n                cb.blocks[i].pixels[j] = color1;\n            else\n                cb.blocks[i].pixels[j] = color0;\n        }\n    }\n    return cb;\n}", "patch_func_code": "static CodeBook unpack_codebook(GetBitContext* gb, unsigned depth,\n                                 unsigned size)\n{\n    unsigned i, j;\n    CodeBook cb = { 0 };\n\n    if (size >= INT_MAX / 34 || get_bits_left(gb) < size * 34)\n        return cb;\n\n    if (size >= INT_MAX / sizeof(MacroBlock))\n        return cb;\n    cb.blocks = av_malloc(size ? size * sizeof(MacroBlock) : 1);\n    if (!cb.blocks)\n        return cb;\n\n    cb.depth = depth;\n    cb.size = size;\n    for (i = 0; i < size; i++) {\n        unsigned mask_bits = get_bits(gb, 4);\n        unsigned color0 = get_bits(gb, 15);\n        unsigned color1 = get_bits(gb, 15);\n\n        for (j = 0; j < 4; j++) {\n            if (mask_bits & (1 << j))\n                cb.blocks[i].pixels[j] = color1;\n            else\n                cb.blocks[i].pixels[j] = color0;\n        }\n    }\n    return cb;\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 167}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "3776----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cb0d6c58602cc9ed3e5b5133cae21dd6a42defcb_1.json----dnxhd_decode_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_cb0d6c58602cc9ed3e5b5133cae21dd6a42defcb_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cb0d6c58602cc9ed3e5b5133cae21dd6a42defcb_1.json", "function_name": "dnxhd_decode_header", "vul_func_code": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n    static const uint8_t header_prefixhr1[] = { 0x00, 0x00, 0x02, 0x80, 0x03 };\n    static const uint8_t header_prefixhr2[] = { 0x00, 0x00, 0x03, 0x8C, 0x03 };\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth, bitdepth;\n    int old_mb_height = ctx->mb_height;\n\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) &&\n        memcmp(buf, header_prefixhr1, 5) && memcmp(buf, header_prefixhr2, 5)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: bitdepth = 8; break;\n    case 2: bitdepth = 10; break;\n    case 3: bitdepth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n\n    cid = AV_RB32(buf + 0x28);\n    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (bitdepth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (bitdepth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10\n                                    : AV_PIX_FMT_GBRP10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12\n                                    : AV_PIX_FMT_GBRP12;\n        }\n    } else if (bitdepth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (bitdepth == 10) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    // make sure profile size constraints are respected\n    // DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %d).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = buf[0x16d];\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    // Newer format supports variable mb_scan_index sizes\n    if (!memcmp(buf, header_prefixhr2, 5)) {\n        ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n    } else {\n        if (ctx->mb_height > 68 ||\n            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"mb height too big: %d\\n\", ctx->mb_height);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->data_offset = 0x280;\n    }\n\n    if (buf_size < ctx->data_offset) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->mb_height != old_mb_height) {\n        av_freep(&ctx->mb_scan_index);\n\n        ctx->mb_scan_index = av_mallocz_array(ctx->mb_height, sizeof(uint32_t));\n        if (!ctx->mb_scan_index)\n            return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %u\\n\", i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%u vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n                               const uint8_t *buf, int buf_size,\n                               int first_field)\n{\n    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };\n    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };\n    static const uint8_t header_prefixhr1[] = { 0x00, 0x00, 0x02, 0x80, 0x03 };\n    static const uint8_t header_prefixhr2[] = { 0x00, 0x00, 0x03, 0x8C, 0x03 };\n    int i, cid, ret;\n    int old_bit_depth = ctx->bit_depth, bitdepth;\n\n    if (buf_size < 0x280) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < 640).\\n\", buf_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5) &&\n        memcmp(buf, header_prefixhr1, 5) && memcmp(buf, header_prefixhr2, 5)) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n               buf[0], buf[1], buf[2], buf[3], buf[4]);\n        return AVERROR_INVALIDDATA;\n    }\n    if (buf[5] & 2) { /* interlaced */\n        ctx->cur_field = buf[5] & 1;\n        frame->interlaced_frame = 1;\n        frame->top_field_first  = first_field ^ ctx->cur_field;\n        av_log(ctx->avctx, AV_LOG_DEBUG,\n               \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->cur_field);\n    } else {\n        ctx->cur_field = 0;\n    }\n    ctx->mbaff = (buf[0x6] >> 5) & 1;\n\n    ctx->height = AV_RB16(buf + 0x18);\n    ctx->width  = AV_RB16(buf + 0x1a);\n\n    switch(buf[0x21] >> 5) {\n    case 1: bitdepth = 8; break;\n    case 2: bitdepth = 10; break;\n    case 3: bitdepth = 12; break;\n    default:\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"Unknown bitdepth indicator (%d)\\n\", buf[0x21] >> 5);\n        return AVERROR_INVALIDDATA;\n    }\n\n    cid = AV_RB32(buf + 0x28);\n    if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0)\n        return ret;\n    if (ctx->mbaff && ctx->cid_table->cid != 1260)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive MB interlace flag in an unsupported profile.\\n\");\n\n    ctx->act = buf[0x2C] & 7;\n    if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270)\n        av_log(ctx->avctx, AV_LOG_WARNING,\n               \"Adaptive color transform in an unsupported profile.\\n\");\n\n    ctx->is_444 = (buf[0x2C] >> 6) & 1;\n    if (ctx->is_444) {\n        if (bitdepth == 8) {\n            avpriv_request_sample(ctx->avctx, \"4:4:4 8 bits\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (bitdepth == 10) {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_10_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10\n                                    : AV_PIX_FMT_GBRP10;\n        } else {\n            ctx->decode_dct_block = dnxhd_decode_dct_block_12_444;\n            ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12\n                                    : AV_PIX_FMT_GBRP12;\n        }\n    } else if (bitdepth == 12) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_12;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P12;\n    } else if (bitdepth == 10) {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_10;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n    } else {\n        ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n        ctx->pix_fmt = AV_PIX_FMT_YUV422P;\n    }\n\n    ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth;\n    if (ctx->bit_depth != old_bit_depth) {\n        ff_blockdsp_init(&ctx->bdsp, ctx->avctx);\n        ff_idctdsp_init(&ctx->idsp, ctx->avctx);\n        ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable,\n                          ff_zigzag_direct);\n    }\n\n    // make sure profile size constraints are respected\n    // DNx100 allows 1920->1440 and 1280->960 subsampling\n    if (ctx->width != ctx->cid_table->width &&\n        ctx->cid_table->width != DNXHD_VARIABLE) {\n        av_reduce(&ctx->avctx->sample_aspect_ratio.num,\n                  &ctx->avctx->sample_aspect_ratio.den,\n                  ctx->width, ctx->cid_table->width, 255);\n        ctx->width = ctx->cid_table->width;\n    }\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size (%d < %d).\\n\",\n               buf_size, ctx->cid_table->coding_unit_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    ctx->mb_width  = (ctx->width + 15)>> 4;\n    ctx->mb_height = buf[0x16d];\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n        ctx->height <<= 1;\n\n    av_log(ctx->avctx, AV_LOG_VERBOSE, \"%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\\n\",\n           ctx->width, ctx->height, ctx->is_444 ? \"4:4\" : \"2:2\",\n           ctx->bit_depth, ctx->mbaff, ctx->act);\n\n    // Newer format supports variable mb_scan_index sizes\n    if (!memcmp(buf, header_prefixhr2, 5)) {\n        ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n    } else {\n        if (ctx->mb_height > 68 ||\n            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"mb height too big: %d\\n\", ctx->mb_height);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->data_offset = 0x280;\n    }\n\n    if (buf_size < ctx->data_offset) {\n        av_log(ctx->avctx, AV_LOG_ERROR,\n               \"buffer too small (%d < %d).\\n\", buf_size, ctx->data_offset);\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_assert0((unsigned)ctx->mb_height <= FF_ARRAY_ELEMS(ctx->mb_scan_index));\n\n    for (i = 0; i < ctx->mb_height; i++) {\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n        ff_dlog(ctx->avctx, \"mb scan index %d, pos %d: %u\\n\", i, 0x170 + (i << 2), ctx->mb_scan_index[i]);\n        if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"invalid mb scan index (%u vs %u).\\n\",\n                   ctx->mb_scan_index[i], buf_size - ctx->data_offset);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [11, 140, 141, 143, 144, 145, 146], "raw_before_change_lines": [11, 140, 141, 142, 143, 144, 145, 146], "after_change_lines": [139], "raw_after_change_lines": [139], "bug_lines": [11, 140, 141, 142, 143, 144, 145, 146], "added": [false, false, false, false, false, false, false, false], "idx": 168}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3778----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cb19c6b56b75a29dbb27a18e7101b58840683d35_1.json----mkv_write_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_cb19c6b56b75a29dbb27a18e7101b58840683d35_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cb19c6b56b75a29dbb27a18e7101b58840683d35_1.json", "function_name": "mkv_write_header", "vul_func_code": "static int mkv_write_header(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ebml_master ebml_header, segment_info;\n    AVDictionaryEntry *tag;\n    int ret, i, version = 2;\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n        mkv->mode = MODE_WEBM;\n    else\n        mkv->mode = MODE_MATROSKAv2;\n\n    if (s->avoid_negative_ts < 0) {\n        s->avoid_negative_ts = 1;\n        s->internal->avoid_negative_ts_use_pts = 1;\n    }\n\n    if (mkv->mode != MODE_WEBM ||\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n        version = 4;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        if (s->streams[i]->codec->codec_id == AV_CODEC_ID_ATRAC3 ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_COOK ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_RA_288 ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_SIPR ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_RV10 ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_RV20) {\n            av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codec->codec_id));\n            return AVERROR_PATCHWELCOME;\n        }\n        if (s->streams[i]->codec->codec_id == AV_CODEC_ID_OPUS ||\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n            version = 4;\n    }\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n    if (!mkv->tracks)\n        return AVERROR(ENOMEM);\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n    end_ebml_master(pb, ebml_header);\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n    mkv->segment_offset = avio_tell(pb);\n\n    // we write 2 seek heads - one at the end of the file to point to each\n    // cluster, and one at the beginning to point to all other level one\n    // elements (including the seek head at the end of the file), which\n    // isn't more than 10 elements if we only write one of each other\n    // currently defined level 1 element\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n    if (!mkv->main_seekhead)\n        return AVERROR(ENOMEM);\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n    if (ret < 0) return ret;\n\n    segment_info = start_ebml_master(pb, MATROSKA_ID_INFO, 0);\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n        uint32_t segment_uid[4];\n        AVLFG lfg;\n\n        av_lfg_init(&lfg, av_get_random_seed());\n\n        for (i = 0; i < 4; i++)\n            segment_uid[i] = av_lfg_get(&lfg);\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n        else\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n        put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n    } else {\n        const char *ident = \"Lavf\";\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n    }\n\n    if (tag = av_dict_get(s->metadata, \"creation_time\", NULL, 0)) {\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n        int64_t date_utc = (ff_iso8601_to_unix_time(tag->value) - 978307200) * 1000000000;\n        uint8_t date_utc_buf[8];\n        AV_WB64(date_utc_buf, date_utc);\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n    }\n\n    // reserve space for the duration\n    mkv->duration = 0;\n    mkv->duration_offset = avio_tell(pb);\n    if (!mkv->is_live) {\n        put_ebml_void(pb, 11);              // assumes double-precision float to be written\n    }\n    end_ebml_master(pb, segment_info);\n\n    // initialize stream_duration fields\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    ret = mkv_write_tracks(s);\n    if (ret < 0)\n        return ret;\n\n    for (i = 0; i < s->nb_chapters; i++)\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n    if (mkv->mode != MODE_WEBM) {\n        ret = mkv_write_chapters(s);\n        if (ret < 0)\n            return ret;\n\n        ret = mkv_write_tags(s);\n        if (ret < 0)\n            return ret;\n\n        ret = mkv_write_attachments(s);\n        if (ret < 0)\n            return ret;\n    }\n\n    if (!s->pb->seekable && !mkv->is_live)\n        mkv_write_seekhead(pb, mkv->main_seekhead);\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n    if (!mkv->cues)\n        return AVERROR(ENOMEM);\n\n    if (pb->seekable && mkv->reserve_cues_space) {\n        mkv->cues_pos = avio_tell(pb);\n        put_ebml_void(pb, mkv->reserve_cues_space);\n    }\n\n    av_init_packet(&mkv->cur_audio_pkt);\n    mkv->cur_audio_pkt.size = 0;\n    mkv->cluster_pos = -1;\n\n    avio_flush(pb);\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n    // after 4k and on a keyframe\n    if (pb->seekable) {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 5000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n    } else {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 1000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 32 * 1024;\n    }\n\n    return 0;\n}", "patch_func_code": "static int mkv_write_header(AVFormatContext *s)\n{\n    MatroskaMuxContext *mkv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    ebml_master ebml_header, segment_info;\n    AVDictionaryEntry *tag;\n    int ret, i, version = 2;\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n        mkv->mode = MODE_WEBM;\n    else\n        mkv->mode = MODE_MATROSKAv2;\n\n    if (s->avoid_negative_ts < 0) {\n        s->avoid_negative_ts = 1;\n        s->internal->avoid_negative_ts_use_pts = 1;\n    }\n\n    if (mkv->mode != MODE_WEBM ||\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n        version = 4;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        if (s->streams[i]->codec->codec_id == AV_CODEC_ID_ATRAC3 ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_COOK ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_RA_288 ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_SIPR ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_RV10 ||\n            s->streams[i]->codec->codec_id == AV_CODEC_ID_RV20) {\n            av_log(s, AV_LOG_ERROR,\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n                   avcodec_get_name(s->streams[i]->codec->codec_id));\n            return AVERROR_PATCHWELCOME;\n        }\n        if (s->streams[i]->codec->codec_id == AV_CODEC_ID_OPUS ||\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n            version = 4;\n    }\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n    if (!mkv->tracks) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n    end_ebml_master(pb, ebml_header);\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n    mkv->segment_offset = avio_tell(pb);\n\n    // we write 2 seek heads - one at the end of the file to point to each\n    // cluster, and one at the beginning to point to all other level one\n    // elements (including the seek head at the end of the file), which\n    // isn't more than 10 elements if we only write one of each other\n    // currently defined level 1 element\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n    if (!mkv->main_seekhead) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n    if (ret < 0) goto fail;\n\n    segment_info = start_ebml_master(pb, MATROSKA_ID_INFO, 0);\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n        uint32_t segment_uid[4];\n        AVLFG lfg;\n\n        av_lfg_init(&lfg, av_get_random_seed());\n\n        for (i = 0; i < 4; i++)\n            segment_uid[i] = av_lfg_get(&lfg);\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n        else\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n        put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n    } else {\n        const char *ident = \"Lavf\";\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n    }\n\n    if (tag = av_dict_get(s->metadata, \"creation_time\", NULL, 0)) {\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n        int64_t date_utc = (ff_iso8601_to_unix_time(tag->value) - 978307200) * 1000000000;\n        uint8_t date_utc_buf[8];\n        AV_WB64(date_utc_buf, date_utc);\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n    }\n\n    // reserve space for the duration\n    mkv->duration = 0;\n    mkv->duration_offset = avio_tell(pb);\n    if (!mkv->is_live) {\n        put_ebml_void(pb, 11);              // assumes double-precision float to be written\n    }\n    end_ebml_master(pb, segment_info);\n\n    // initialize stream_duration fields\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    ret = mkv_write_tracks(s);\n    if (ret < 0)\n        goto fail;\n\n    for (i = 0; i < s->nb_chapters; i++)\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n    if (mkv->mode != MODE_WEBM) {\n        ret = mkv_write_chapters(s);\n        if (ret < 0)\n            goto fail;\n\n        ret = mkv_write_tags(s);\n        if (ret < 0)\n            goto fail;\n\n        ret = mkv_write_attachments(s);\n        if (ret < 0)\n            goto fail;\n    }\n\n    if (!s->pb->seekable && !mkv->is_live)\n        mkv_write_seekhead(pb, mkv);\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n    if (!mkv->cues) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n    if (pb->seekable && mkv->reserve_cues_space) {\n        mkv->cues_pos = avio_tell(pb);\n        put_ebml_void(pb, mkv->reserve_cues_space);\n    }\n\n    av_init_packet(&mkv->cur_audio_pkt);\n    mkv->cur_audio_pkt.size = 0;\n    mkv->cluster_pos = -1;\n\n    avio_flush(pb);\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n    // after 4k and on a keyframe\n    if (pb->seekable) {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 5000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n    } else {\n        if (mkv->cluster_time_limit < 0)\n            mkv->cluster_time_limit = 1000;\n        if (mkv->cluster_size_limit < 0)\n            mkv->cluster_size_limit = 32 * 1024;\n    }\n\n    return 0;\nfail:\n    mkv_free(mkv);\n    return ret;\n}", "before_change_lines": [43, 44, 65, 66, 69, 118, 126, 130, 134, 138, 141, 142], "raw_before_change_lines": [43, 44, 45, 65, 66, 69, 118, 126, 130, 134, 138, 141, 142, 143], "after_change_lines": [43, 44, 45, 46, 66, 67, 68, 69, 72, 121, 129, 133, 137, 141, 144, 145, 146, 147, 174, 175, 176], "raw_after_change_lines": [43, 44, 45, 46, 66, 67, 68, 69, 72, 121, 129, 133, 137, 141, 144, 145, 146, 147, 174, 175, 176], "bug_lines": [43, 44, 45, 65, 66, 69, 118, 126, 130, 134, 138, 141, 142, 143], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 169}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "3824----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cd6ff752e16dce268ef8ce9a7eaeb9f7248b6fe6_1.json----huf_uncompress", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_cd6ff752e16dce268ef8ce9a7eaeb9f7248b6fe6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_cd6ff752e16dce268ef8ce9a7eaeb9f7248b6fe6_1.json", "function_name": "huf_uncompress", "vul_func_code": "static int huf_uncompress(GetByteContext *gb,\n                          uint16_t *dst, int dst_size)\n{\n    int32_t src_size, im, iM;\n    uint32_t nBits;\n    uint64_t *freq;\n    HufDec *hdec;\n    int ret, i;\n\n    src_size = bytestream2_get_le32(gb);\n    im = bytestream2_get_le32(gb);\n    iM = bytestream2_get_le32(gb);\n    bytestream2_skip(gb, 4);\n    nBits = bytestream2_get_le32(gb);\n    if (im < 0 || im >= HUF_ENCSIZE ||\n        iM < 0 || iM >= HUF_ENCSIZE ||\n        src_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(gb, 4);\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n    if (!freq || !hdec) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n        goto fail;\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n        goto fail;\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\nfail:\n    for (i = 0; i < HUF_DECSIZE; i++) {\n        if (hdec[i].p)\n            av_freep(&hdec[i].p);\n    }\n\n    av_free(freq);\n    av_free(hdec);\n\n    return ret;\n}", "patch_func_code": "static int huf_uncompress(GetByteContext *gb,\n                          uint16_t *dst, int dst_size)\n{\n    int32_t src_size, im, iM;\n    uint32_t nBits;\n    uint64_t *freq;\n    HufDec *hdec;\n    int ret, i;\n\n    src_size = bytestream2_get_le32(gb);\n    im = bytestream2_get_le32(gb);\n    iM = bytestream2_get_le32(gb);\n    bytestream2_skip(gb, 4);\n    nBits = bytestream2_get_le32(gb);\n    if (im < 0 || im >= HUF_ENCSIZE ||\n        iM < 0 || iM >= HUF_ENCSIZE ||\n        src_size < 0)\n        return AVERROR_INVALIDDATA;\n\n    bytestream2_skip(gb, 4);\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n    if (!freq || !hdec) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n        goto fail;\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n        goto fail;\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\nfail:\n    for (i = 0; i < HUF_DECSIZE; i++) {\n        if (hdec)\n            av_freep(&hdec[i].p);\n    }\n\n    av_free(freq);\n    av_free(hdec);\n\n    return ret;\n}", "before_change_lines": [43], "raw_before_change_lines": [43], "after_change_lines": [43], "raw_after_change_lines": [43], "bug_lines": [43], "added": [false], "idx": 170}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3855----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ceb64ee8c1d5782b50f151565d10a03e544c3483_1.json----mxf_set_audio_pts", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_ceb64ee8c1d5782b50f151565d10a03e544c3483_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ceb64ee8c1d5782b50f151565d10a03e544c3483_1.json", "function_name": "mxf_set_audio_pts", "vul_func_code": "static int mxf_set_audio_pts(MXFContext *mxf, AVCodecContext *codec, AVPacket *pkt)\n{\n    MXFTrack *track = mxf->fc->streams[pkt->stream_index]->priv_data;\n    pkt->pts = track->sample_count;\n    if (codec->channels <= 0 || av_get_bits_per_sample(codec->codec_id) <= 0)\n        return AVERROR(EINVAL);\n    track->sample_count += pkt->size / (codec->channels * av_get_bits_per_sample(codec->codec_id) / 8);\n    return 0;\n}", "patch_func_code": "static int mxf_set_audio_pts(MXFContext *mxf, AVCodecContext *codec, AVPacket *pkt)\n{\n    MXFTrack *track = mxf->fc->streams[pkt->stream_index]->priv_data;\n    pkt->pts = track->sample_count;\n    if (codec->channels <= 0 || av_get_bits_per_sample(codec->codec_id) <= 0)\n        return AVERROR(EINVAL);\n    track->sample_count += pkt->size / (codec->channels * (int64_t)av_get_bits_per_sample(codec->codec_id) / 8);\n    return 0;\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 171}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3928----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d34aa4d25452c55751ac9affd6f6add3b74d0654_1.json----ff_riff_write_info_tag", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_d34aa4d25452c55751ac9affd6f6add3b74d0654_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d34aa4d25452c55751ac9affd6f6add3b74d0654_1.json", "function_name": "ff_riff_write_info_tag", "vul_func_code": "void ff_riff_write_info_tag(AVIOContext *pb, const char *tag, const char *str)\n{\n    int len = strlen(str);\n    if (len > 0) {\n        len++;\n        ffio_wfourcc(pb, tag);\n        avio_wl32(pb, len);\n        avio_put_str(pb, str);\n        if (len & 1)\n            avio_w8(pb, 0);\n    }\n}", "patch_func_code": "void ff_riff_write_info_tag(AVIOContext *pb, const char *tag, const char *str)\n{\n    size_t len = strlen(str);\n    if (len > 0 && len < UINT32_MAX) {\n        len++;\n        ffio_wfourcc(pb, tag);\n        avio_wl32(pb, len);\n        avio_put_str(pb, str);\n        if (len & 1)\n            avio_w8(pb, 0);\n    }\n}", "before_change_lines": [3, 4], "raw_before_change_lines": [3, 4], "after_change_lines": [3, 4], "raw_after_change_lines": [3, 4], "bug_lines": [3, 4], "added": [false, false], "idx": 172}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "3931----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d3ad1ae0dc6d144e0308e3bf6754ff5c79e034ae_1.json----ff_rm_parse_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_d3ad1ae0dc6d144e0308e3bf6754ff5c79e034ae_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d3ad1ae0dc6d144e0308e3bf6754ff5c79e034ae_1.json", "function_name": "ff_rm_parse_packet", "vul_func_code": "int\nff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n                    int *seq, int flags, int64_t timestamp)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        rm->current_stream= st->id;\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n        if(ret)\n            return ret < 0 ? ret : -1; //got partial frame or error\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n            (ast->deint_id == DEINT_ID_INT4) ||\n            (ast->deint_id == DEINT_ID_SIPR)) {\n            int x;\n            int sps = ast->sub_packet_size;\n            int cfs = ast->coded_framesize;\n            int h = ast->sub_packet_h;\n            int y = ast->sub_packet_cnt;\n            int w = ast->audio_framesize;\n\n            if (flags & 2)\n                y = ast->sub_packet_cnt = 0;\n            if (!y)\n                ast->audiotimestamp = timestamp;\n\n            switch (ast->deint_id) {\n                case DEINT_ID_INT4:\n                    for (x = 0; x < h/2; x++)\n                        avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n                    break;\n                case DEINT_ID_GENR:\n                    for (x = 0; x < w/sps; x++)\n                        avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n                    break;\n                case DEINT_ID_SIPR:\n                    avio_read(pb, ast->pkt.data + y * w, w);\n                    break;\n            }\n\n            if (++(ast->sub_packet_cnt) < h)\n                return -1;\n            if (ast->deint_id == DEINT_ID_SIPR)\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n             ast->sub_packet_cnt = 0;\n             rm->audio_stream_num = st->index;\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n            int x;\n            rm->audio_stream_num = st->index;\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n            if (ast->sub_packet_cnt) {\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n                ast->audiotimestamp = timestamp;\n            } else\n                return -1;\n        } else {\n            av_get_packet(pb, pkt, len);\n            rm_ac3_swap_bytes(st, pkt);\n        }\n    } else\n        av_get_packet(pb, pkt, len);\n\n    pkt->stream_index = st->index;\n\n#if 0\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n            seq |= (timestamp&~0x3FFF);\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n        }\n    }\n#endif\n\n    pkt->pts = timestamp;\n    if (flags & 2)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n}", "patch_func_code": "int\nff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n                    int *seq, int flags, int64_t timestamp)\n{\n    RMDemuxContext *rm = s->priv_data;\n    int ret;\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        rm->current_stream= st->id;\n        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);\n        if(ret)\n            return ret < 0 ? ret : -1; //got partial frame or error\n    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n        if ((ast->deint_id == DEINT_ID_GENR) ||\n            (ast->deint_id == DEINT_ID_INT4) ||\n            (ast->deint_id == DEINT_ID_SIPR)) {\n            int x;\n            int sps = ast->sub_packet_size;\n            int cfs = ast->coded_framesize;\n            int h = ast->sub_packet_h;\n            int y = ast->sub_packet_cnt;\n            int w = ast->audio_framesize;\n\n            if (flags & 2)\n                y = ast->sub_packet_cnt = 0;\n            if (!y)\n                ast->audiotimestamp = timestamp;\n\n            switch (ast->deint_id) {\n                case DEINT_ID_INT4:\n                    for (x = 0; x < h/2; x++)\n                        readfull(s, pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n                    break;\n                case DEINT_ID_GENR:\n                    for (x = 0; x < w/sps; x++)\n                        readfull(s, pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n                    break;\n                case DEINT_ID_SIPR:\n                    readfull(s, pb, ast->pkt.data + y * w, w);\n                    break;\n            }\n\n            if (++(ast->sub_packet_cnt) < h)\n                return -1;\n            if (ast->deint_id == DEINT_ID_SIPR)\n                ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n\n             ast->sub_packet_cnt = 0;\n             rm->audio_stream_num = st->index;\n             rm->audio_pkt_cnt = h * w / st->codec->block_align;\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n            int x;\n            rm->audio_stream_num = st->index;\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n            if (ast->sub_packet_cnt) {\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n                ast->audiotimestamp = timestamp;\n            } else\n                return -1;\n        } else {\n            av_get_packet(pb, pkt, len);\n            rm_ac3_swap_bytes(st, pkt);\n        }\n    } else\n        av_get_packet(pb, pkt, len);\n\n    pkt->stream_index = st->index;\n\n#if 0\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n            seq |= (timestamp&~0x3FFF);\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n        }\n    }\n#endif\n\n    pkt->pts = timestamp;\n    if (flags & 2)\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n}", "before_change_lines": [33, 37, 40], "raw_before_change_lines": [33, 37, 40], "after_change_lines": [33, 37, 40], "raw_after_change_lines": [33, 37, 40], "bug_lines": [33, 37, 40], "added": [false, false, false], "idx": 173}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4001----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d7efa41399c2c30a7c70486183a0d41e83641985_1.json----get_scene_score", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_d7efa41399c2c30a7c70486183a0d41e83641985_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d7efa41399c2c30a7c70486183a0d41e83641985_1.json", "function_name": "get_scene_score", "vul_func_code": "static double get_scene_score(AVFilterContext *ctx, AVFilterBufferRef *picref)\n{\n    double ret = 0;\n    SelectContext *select = ctx->priv;\n    AVFilterBufferRef *prev_picref = select->prev_picref;\n\n    if (prev_picref &&\n        picref->video->h    == prev_picref->video->h &&\n        picref->video->w    == prev_picref->video->w &&\n        picref->linesize[0] == prev_picref->linesize[0]) {\n        int x, y;\n        int64_t sad = 0;\n        double mafd, diff;\n        uint8_t *p1 =      picref->data[0];\n        uint8_t *p2 = prev_picref->data[0];\n        const int linesize = picref->linesize[0];\n\n        for (y = 0; y < picref->video->h; y += 8)\n            for (x = 0; x < linesize; x += 8)\n                sad += select->c.sad[1](select,\n                                        p1 + y * linesize + x,\n                                        p2 + y * linesize + x,\n                                        linesize, 8);\n        emms_c();\n        mafd = sad / (picref->video->h * picref->video->w * 3);\n        diff = fabs(mafd - select->prev_mafd);\n        ret  = av_clipf(FFMIN(mafd, diff) / 100., 0, 1);\n        select->prev_mafd = mafd;\n        avfilter_unref_buffer(prev_picref);\n    }\n    select->prev_picref = avfilter_ref_buffer(picref, ~0);\n    return ret;\n}", "patch_func_code": "static double get_scene_score(AVFilterContext *ctx, AVFilterBufferRef *picref)\n{\n    double ret = 0;\n    SelectContext *select = ctx->priv;\n    AVFilterBufferRef *prev_picref = select->prev_picref;\n\n    if (prev_picref &&\n        picref->video->h    == prev_picref->video->h &&\n        picref->video->w    == prev_picref->video->w &&\n        picref->linesize[0] == prev_picref->linesize[0]) {\n        int x, y, nb_sad = 0;\n        int64_t sad = 0;\n        double mafd, diff;\n        uint8_t *p1 =      picref->data[0];\n        uint8_t *p2 = prev_picref->data[0];\n        const int linesize = picref->linesize[0];\n\n        for (y = 0; y < picref->video->h - 8; y += 8) {\n            for (x = 0; x < picref->video->w*3 - 8; x += 8) {\n                sad += select->c.sad[1](select,\n                                        p1 + y * linesize + x,\n                                        p2 + y * linesize + x,\n                                        linesize, 8);\n                nb_sad += 8 * 8;\n            }\n        }\n        emms_c();\n        mafd = nb_sad ? sad / nb_sad : 0;\n        diff = fabs(mafd - select->prev_mafd);\n        ret  = av_clipf(FFMIN(mafd, diff) / 100., 0, 1);\n        select->prev_mafd = mafd;\n        avfilter_unref_buffer(prev_picref);\n    }\n    select->prev_picref = avfilter_ref_buffer(picref, ~0);\n    return ret;\n}", "before_change_lines": [11, 18, 19, 25], "raw_before_change_lines": [11, 18, 19, 25], "after_change_lines": [11, 18, 19, 24, 25, 26, 28], "raw_after_change_lines": [11, 18, 19, 24, 25, 26, 28], "bug_lines": [11, 18, 19, 25], "added": [false, false, false, false], "idx": 174}
{"project": "ffmpeg", "vul_type": "NULL_DEREFERENCE", "filepath_func": "4020----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d8a457b5d9749d9b0b92cd0f442e628c580ca887_1.json----copy_parameter_set", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_d8a457b5d9749d9b0b92cd0f442e628c580ca887_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_d8a457b5d9749d9b0b92cd0f442e628c580ca887_1.json", "function_name": "copy_parameter_set", "vul_func_code": "static void copy_parameter_set(void **to, void **from, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        if (to[i] && !from[i])\n            av_freep(&to[i]);\n        else if (from[i] && !to[i])\n            to[i] = av_malloc(size);\n\n        if (from[i])\n            memcpy(to[i], from[i], size);\n    }\n}", "patch_func_code": "static int copy_parameter_set(void **to, void **from, int count, int size)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        if (to[i] && !from[i]) {\n            av_freep(&to[i]);\n        } else if (from[i] && !to[i]) {\n            to[i] = av_malloc(size);\n            if (!to[i])\n                return AVERROR(ENOMEM);\n        }\n\n        if (from[i])\n            memcpy(to[i], from[i], size);\n    }\n\n    return 0;\n}", "before_change_lines": [1, 6, 8], "raw_before_change_lines": [1, 6, 8], "after_change_lines": [1, 6, 8, 10, 11, 12, 18], "raw_after_change_lines": [1, 6, 8, 10, 11, 12, 17, 18], "bug_lines": [1, 6, 8], "added": [false, false, false], "idx": 175}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4118----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_de14db683bc62be7975ac12142a5c44ceda6e293_1.json----av_image_fill_arrays", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_de14db683bc62be7975ac12142a5c44ceda6e293_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_de14db683bc62be7975ac12142a5c44ceda6e293_1.json", "function_name": "av_image_fill_arrays", "vul_func_code": "int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],\n                         const uint8_t *src,\n                         enum AVPixelFormat pix_fmt, int width, int height, int align)\n{\n    int ret, i;\n\n    if ((ret = av_image_check_size(width, height, 0, NULL)) < 0)\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) < 0)\n        return ret;\n\n    for (i = 0; i < 4; i++)\n        dst_linesize[i] = FFALIGN(dst_linesize[i], align);\n\n    if ((ret = av_image_fill_pointers(dst_data, pix_fmt, width, NULL, dst_linesize)) < 0)\n        return ret;\n\n    return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize);\n}", "patch_func_code": "int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],\n                         const uint8_t *src,\n                         enum AVPixelFormat pix_fmt, int width, int height, int align)\n{\n    int ret, i;\n\n    if ((ret = av_image_check_size(width, height, 0, NULL)) < 0)\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) < 0)\n        return ret;\n\n    for (i = 0; i < 4; i++)\n        dst_linesize[i] = FFALIGN(dst_linesize[i], align);\n\n    return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize);\n}", "before_change_lines": [16, 17], "raw_before_change_lines": [16, 17, 18], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [16, 17, 18], "added": [false, false, false], "idx": 176}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "4168----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e1848949c861cbd23542c4fc91678057ccfa89a6_1.json----request_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_e1848949c861cbd23542c4fc91678057ccfa89a6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e1848949c861cbd23542c4fc91678057ccfa89a6_1.json", "function_name": "request_frame", "vul_func_code": "static int request_frame(AVFilterLink *outlink)\n{\n    ShowWavesContext *showwaves = outlink->src->priv;\n    AVFilterLink *inlink = outlink->src->inputs[0];\n    int ret;\n\n    showwaves->req_fullfilled = 0;\n    do {\n        ret = ff_request_frame(inlink);\n    } while (!showwaves->req_fullfilled && ret >= 0);\n\n    if (ret == AVERROR_EOF && showwaves->outpicref) {\n        if (showwaves->single_pic)\n            push_single_pic(outlink);\n        else\n            push_frame(outlink);\n    }\n\n    return ret;\n}", "patch_func_code": "static int request_frame(AVFilterLink *outlink)\n{\n    ShowWavesContext *showwaves = outlink->src->priv;\n    AVFilterLink *inlink = outlink->src->inputs[0];\n    int ret;\n\n    ret = ff_request_frame(inlink);\n    if (ret == AVERROR_EOF && showwaves->outpicref) {\n        if (showwaves->single_pic)\n            push_single_pic(outlink);\n        else\n            push_frame(outlink);\n    }\n\n    return ret;\n}", "before_change_lines": [7, 8, 9, 10], "raw_before_change_lines": [7, 8, 9, 10, 11], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7, 8, 9, 10, 11], "added": [false, false, false, false, false], "idx": 177}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4228----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e4755f22e728c6b8770b4645fe850991046a30d0_1.json----set_palette", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_e4755f22e728c6b8770b4645fe850991046a30d0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e4755f22e728c6b8770b4645fe850991046a30d0_1.json", "function_name": "set_palette", "vul_func_code": "static int set_palette(AVFrame * frame, const uint8_t * palette_buffer, int buf_size)\n{\n    uint32_t * palette = (uint32_t *)frame->data[1];\n    int a;\n\n    if (buf_size < 256*3)\n        return AVERROR_INVALIDDATA;\n\n    for(a = 0; a < 256; a++){\n        palette[a] = AV_RB24(&palette_buffer[a * 3]) * 4;\n    }\n    frame->palette_has_changed = 1;\n    return 256*3;\n}", "patch_func_code": "static int set_palette(BethsoftvidContext *ctx)\n{\n    uint32_t *palette = (uint32_t *)ctx->frame.data[1];\n    int a;\n\n    if (bytestream2_get_bytes_left(&ctx->g) < 256*3)\n        return AVERROR_INVALIDDATA;\n\n    for(a = 0; a < 256; a++){\n        palette[a] = bytestream2_get_be24u(&ctx->g) * 4;\n    }\n    ctx->frame.palette_has_changed = 1;\n    return 256*3;\n}", "before_change_lines": [1, 3, 6, 10, 12], "raw_before_change_lines": [1, 3, 6, 10, 12], "after_change_lines": [1, 3, 6, 10, 12], "raw_after_change_lines": [1, 3, 6, 10, 12], "bug_lines": [1, 3, 6, 10, 12], "added": [false, false, false, false, false], "idx": 178}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "4252----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e61f6c53b7442b55788b83905110430f8205703f_1.json----real_parse_asm_rulebook", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_e61f6c53b7442b55788b83905110430f8205703f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e61f6c53b7442b55788b83905110430f8205703f_1.json", "function_name": "real_parse_asm_rulebook", "vul_func_code": "static void\nreal_parse_asm_rulebook(AVFormatContext *s, AVStream *orig_st,\n                        const char *p)\n{\n    const char *end;\n    int n_rules, odd = 0;\n    AVStream *st;\n\n    /**\n     * The ASMRuleBook contains a list of comma-separated strings per rule,\n     * and each rule is separated by a ;. The last one also has a ; at the\n     * end so we can use it as delimiter.\n     * Every rule occurs twice, once for when the RTSP packet header marker\n     * is set and once for if it isn't. We only read the first because we\n     * don't care much (that's what the \"odd\" variable is for).\n     * Each rule contains a set of one or more statements, optionally\n     * preceeded by a single condition. If there's a condition, the rule\n     * starts with a '#'. Multiple conditions are merged between brackets,\n     * so there are never multiple conditions spread out over separate\n     * statements. Generally, these conditions are bitrate limits (min/max)\n     * for multi-bitrate streams.\n     */\n    if (*p == '\\\"') p++;\n    for (n_rules = 0; s->nb_streams < MAX_STREAMS;) {\n        if (!(end = strchr(p, ';')))\n            break;\n        if (!odd && end != p) {\n            if (n_rules > 0)\n                st = add_dstream(s, orig_st);\n            else\n                st = orig_st;\n            real_parse_asm_rule(st, p, end);\n            n_rules++;\n        }\n        p = end + 1;\n        odd ^= 1;\n    }\n}", "patch_func_code": "static void\nreal_parse_asm_rulebook(AVFormatContext *s, AVStream *orig_st,\n                        const char *p)\n{\n    const char *end;\n    int n_rules = 0, odd = 0;\n    AVStream *st;\n\n    /**\n     * The ASMRuleBook contains a list of comma-separated strings per rule,\n     * and each rule is separated by a ;. The last one also has a ; at the\n     * end so we can use it as delimiter.\n     * Every rule occurs twice, once for when the RTSP packet header marker\n     * is set and once for if it isn't. We only read the first because we\n     * don't care much (that's what the \"odd\" variable is for).\n     * Each rule contains a set of one or more statements, optionally\n     * preceeded by a single condition. If there's a condition, the rule\n     * starts with a '#'. Multiple conditions are merged between brackets,\n     * so there are never multiple conditions spread out over separate\n     * statements. Generally, these conditions are bitrate limits (min/max)\n     * for multi-bitrate streams.\n     */\n    if (*p == '\\\"') p++;\n    while (1) {\n        if (!(end = strchr(p, ';')))\n            break;\n        if (!odd && end != p) {\n            if (n_rules > 0)\n                st = add_dstream(s, orig_st);\n            else\n                st = orig_st;\n            if (!st)\n                break;\n            real_parse_asm_rule(st, p, end);\n            n_rules++;\n        }\n        p = end + 1;\n        odd ^= 1;\n    }\n}", "before_change_lines": [6, 24], "raw_before_change_lines": [6, 24], "after_change_lines": [6, 24, 32, 33], "raw_after_change_lines": [6, 24, 32, 33], "bug_lines": [6, 24], "added": [false, false], "idx": 179}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4277----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e789a23d43a1d467d3abf85a8ac290f7ea22d9c1_1.json----bs_get_v", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_e789a23d43a1d467d3abf85a8ac290f7ea22d9c1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e789a23d43a1d467d3abf85a8ac290f7ea22d9c1_1.json", "function_name": "bs_get_v", "vul_func_code": "static inline int64_t bs_get_v(const uint8_t **bs)\n{\n    int64_t v = 0;\n    int br = 0;\n    int c;\n\n    do {\n        c = **bs; (*bs)++;\n        v <<= 7;\n        v |= c & 0x7F;\n        br++;\n        if (br > 10)\n            return -1;\n    } while (c & 0x80);\n\n    return v - br;\n}", "patch_func_code": "static inline int64_t bs_get_v(const uint8_t **bs)\n{\n    uint64_t v = 0;\n    int br = 0;\n    int c;\n\n    do {\n        c = **bs; (*bs)++;\n        v <<= 7;\n        v |= c & 0x7F;\n        br++;\n        if (br > 10)\n            return -1;\n    } while (c & 0x80);\n\n    return v - br;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 180}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4292----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e8821820c3fc981f317f2b4d41d3c3723df8c187_1.json----transcode_subtitles", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_e8821820c3fc981f317f2b4d41d3c3723df8c187_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e8821820c3fc981f317f2b4d41d3c3723df8c187_1.json", "function_name": "transcode_subtitles", "vul_func_code": "static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output)\n{\n    AVSubtitle subtitle;\n    int i, ret = avcodec_decode_subtitle2(ist->dec_ctx,\n                                          &subtitle, got_output, pkt);\n\n    if (*got_output || ret<0)\n        decode_error_stat[ret<0] ++;\n\n    if (ret < 0 && exit_on_error)\n        exit_program(1);\n\n    if (ret < 0 || !*got_output) {\n        if (!pkt->size)\n            sub2video_flush(ist);\n        return ret;\n    }\n\n    if (ist->fix_sub_duration) {\n        int end = 1;\n        if (ist->prev_sub.got_output) {\n            end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts,\n                             1000, AV_TIME_BASE);\n            if (end < ist->prev_sub.subtitle.end_display_time) {\n                av_log(ist->dec_ctx, AV_LOG_DEBUG,\n                       \"Subtitle duration reduced from %d to %d%s\\n\",\n                       ist->prev_sub.subtitle.end_display_time, end,\n                       end <= 0 ? \", dropping it\" : \"\");\n                ist->prev_sub.subtitle.end_display_time = end;\n            }\n        }\n        FFSWAP(int,        *got_output, ist->prev_sub.got_output);\n        FFSWAP(int,        ret,         ist->prev_sub.ret);\n        FFSWAP(AVSubtitle, subtitle,    ist->prev_sub.subtitle);\n        if (end <= 0)\n            goto out;\n    }\n\n    if (!*got_output)\n        return ret;\n\n    sub2video_update(ist, &subtitle);\n\n    if (!subtitle.num_rects)\n        goto out;\n\n    ist->frames_decoded++;\n\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n\n        if (!check_output_constraints(ist, ost) || !ost->encoding_needed\n            || ost->enc->type != AVMEDIA_TYPE_SUBTITLE)\n            continue;\n\n        do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle);\n    }\n\nout:\n    avsubtitle_free(&subtitle);\n    return ret;\n}", "patch_func_code": "static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output)\n{\n    AVSubtitle subtitle;\n    int i, ret = avcodec_decode_subtitle2(ist->dec_ctx,\n                                          &subtitle, got_output, pkt);\n\n    check_decode_result(got_output, ret);\n\n    if (ret < 0 || !*got_output) {\n        if (!pkt->size)\n            sub2video_flush(ist);\n        return ret;\n    }\n\n    if (ist->fix_sub_duration) {\n        int end = 1;\n        if (ist->prev_sub.got_output) {\n            end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts,\n                             1000, AV_TIME_BASE);\n            if (end < ist->prev_sub.subtitle.end_display_time) {\n                av_log(ist->dec_ctx, AV_LOG_DEBUG,\n                       \"Subtitle duration reduced from %d to %d%s\\n\",\n                       ist->prev_sub.subtitle.end_display_time, end,\n                       end <= 0 ? \", dropping it\" : \"\");\n                ist->prev_sub.subtitle.end_display_time = end;\n            }\n        }\n        FFSWAP(int,        *got_output, ist->prev_sub.got_output);\n        FFSWAP(int,        ret,         ist->prev_sub.ret);\n        FFSWAP(AVSubtitle, subtitle,    ist->prev_sub.subtitle);\n        if (end <= 0)\n            goto out;\n    }\n\n    if (!*got_output)\n        return ret;\n\n    sub2video_update(ist, &subtitle);\n\n    if (!subtitle.num_rects)\n        goto out;\n\n    ist->frames_decoded++;\n\n    for (i = 0; i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n\n        if (!check_output_constraints(ist, ost) || !ost->encoding_needed\n            || ost->enc->type != AVMEDIA_TYPE_SUBTITLE)\n            continue;\n\n        do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle);\n    }\n\nout:\n    avsubtitle_free(&subtitle);\n    return ret;\n}", "before_change_lines": [7, 8, 10, 11], "raw_before_change_lines": [7, 8, 9, 10, 11], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7, 8, 9, 10, 11], "added": [false, false, false, false, false], "idx": 181}
{"project": "ffmpeg", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "4313----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e9da91c96aa2af7e924fa11b853201744eeec747_1.json----ff_slice_buffer_init", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_e9da91c96aa2af7e924fa11b853201744eeec747_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_e9da91c96aa2af7e924fa11b853201744eeec747_1.json", "function_name": "ff_slice_buffer_init", "vul_func_code": "void ff_slice_buffer_init(slice_buffer *buf, int line_count,\n                          int max_allocated_lines, int line_width,\n                          IDWTELEM *base_buffer)\n{\n    int i;\n\n    buf->base_buffer = base_buffer;\n    buf->line_count  = line_count;\n    buf->line_width  = line_width;\n    buf->data_count  = max_allocated_lines;\n    buf->line        = av_mallocz(sizeof(IDWTELEM *) * line_count);\n    buf->data_stack  = av_malloc(sizeof(IDWTELEM *) * max_allocated_lines);\n\n    for (i = 0; i < max_allocated_lines; i++)\n        buf->data_stack[i] = av_malloc(sizeof(IDWTELEM) * line_width);\n\n    buf->data_stack_top = max_allocated_lines - 1;\n}", "patch_func_code": "void ff_slice_buffer_init(slice_buffer *buf, int line_count,\n                          int max_allocated_lines, int line_width,\n                          IDWTELEM *base_buffer)\n{\n    int i;\n\n    buf->base_buffer = base_buffer;\n    buf->line_count  = line_count;\n    buf->line_width  = line_width;\n    buf->data_count  = max_allocated_lines;\n    buf->line        = av_mallocz(sizeof(IDWTELEM *) * line_count);\n    if (!buf->line)\n        return AVERROR(ENOMEM);\n    buf->data_stack  = av_malloc(sizeof(IDWTELEM *) * max_allocated_lines);\n    if (!buf->data_stack) {\n        av_free(buf->line);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < max_allocated_lines; i++) {\n        buf->data_stack[i] = av_malloc(sizeof(IDWTELEM) * line_width);\n        if (!buf->data_stack[i]) {\n            for (i--; i >=0; i--)\n                av_free(buf->data_stack[i]);\n            av_free(buf->data_stack);\n            av_free(buf->line);\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    buf->data_stack_top = max_allocated_lines - 1;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [12, 13, 15, 16, 17, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29], "raw_after_change_lines": [12, 13, 15, 16, 17, 18, 20, 22, 23, 24, 25, 26, 27, 28, 29], "bug_lines": [14], "added": [false], "idx": 182}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4334----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_eab90bb15321424ab777faaeb826e21fef67b387_1.json----filter_mb_edgecv", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_eab90bb15321424ab777faaeb826e21fef67b387_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_eab90bb15321424ab777faaeb826e21fef67b387_1.json", "function_name": "filter_mb_edgecv", "vul_func_code": "static void av_noinline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n    const int alpha = alpha_table[index_a];\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n    if (alpha ==0 || beta == 0) return;\n\n    if( bS[0] < 4 ) {\n        int8_t tc[4];\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n        h->s.dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n    } else {\n        h->s.dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n    }\n}", "patch_func_code": "static void av_noinline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n    const unsigned int index_a = qp + h->slice_alpha_c0_offset;\n    const int alpha = alpha_table[index_a];\n    const int beta  = beta_table[qp + h->slice_beta_offset];\n    if (alpha ==0 || beta == 0) return;\n\n    if( bS[0] < 4 ) {\n        int8_t tc[4];\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n        h->s.dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n    } else {\n        h->s.dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n    }\n}", "before_change_lines": [2, 4], "raw_before_change_lines": [2, 4], "after_change_lines": [2, 4], "raw_after_change_lines": [2, 4], "bug_lines": [2, 4], "added": [false, false], "idx": 183}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4356----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ebd388d38fb8ade2e3444ee6c5a66b9a190f2475_1.json----oma_read_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_ebd388d38fb8ade2e3444ee6c5a66b9a190f2475_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_ebd388d38fb8ade2e3444ee6c5a66b9a190f2475_1.json", "function_name": "oma_read_packet", "vul_func_code": "static int oma_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    OMAContext *oc  = s->priv_data;\n    AVStream *st    = s->streams[0];\n    int packet_size = st->codec->block_align;\n    int byte_rate   = st->codec->bit_rate >> 3;\n    int64_t pos     = avio_tell(s->pb);\n    int ret         = av_get_packet(s->pb, pkt, packet_size);\n\n    if (ret < packet_size)\n        pkt->flags |= AV_PKT_FLAG_CORRUPT;\n\n    if (ret < 0)\n        return ret;\n    if (!ret)\n        return AVERROR_EOF;\n\n    pkt->stream_index = 0;\n\n    if (pos > 0) {\n        pkt->pts =\n        pkt->dts = av_rescale(pos, st->time_base.den,\n                              byte_rate * (int64_t)st->time_base.num);\n    }\n\n    if (oc->encrypted) {\n        /* previous unencrypted block saved in IV for\n         * the next packet (CBC mode) */\n        if (ret == packet_size)\n            av_des_crypt(&oc->av_des, pkt->data, pkt->data,\n                         (packet_size >> 3), oc->iv, 1);\n        else\n            memset(oc->iv, 0, 8);\n    }\n\n    return ret;\n}", "patch_func_code": "static int oma_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    OMAContext *oc  = s->priv_data;\n    AVStream *st    = s->streams[0];\n    int packet_size = st->codec->block_align;\n    int byte_rate   = st->codec->bit_rate >> 3;\n    int64_t pos     = avio_tell(s->pb);\n    int ret         = av_get_packet(s->pb, pkt, packet_size);\n\n    if (ret < packet_size)\n        pkt->flags |= AV_PKT_FLAG_CORRUPT;\n\n    if (ret < 0)\n        return ret;\n    if (!ret)\n        return AVERROR_EOF;\n\n    pkt->stream_index = 0;\n\n    if (pos > 0 && byte_rate > 0) {\n        pkt->pts =\n        pkt->dts = av_rescale(pos, st->time_base.den,\n                              byte_rate * (int64_t)st->time_base.num);\n    }\n\n    if (oc->encrypted) {\n        /* previous unencrypted block saved in IV for\n         * the next packet (CBC mode) */\n        if (ret == packet_size)\n            av_des_crypt(&oc->av_des, pkt->data, pkt->data,\n                         (packet_size >> 3), oc->iv, 1);\n        else\n            memset(oc->iv, 0, 8);\n    }\n\n    return ret;\n}", "before_change_lines": [20], "raw_before_change_lines": [20], "after_change_lines": [20], "raw_after_change_lines": [20], "bug_lines": [20], "added": [false], "idx": 184}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "4418----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_eefdd9cc950a8a8ccece93135830a743a8d1c3ef_1.json----encode_picture", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_eefdd9cc950a8a8ccece93135830a743a8d1c3ef_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_eefdd9cc950a8a8ccece93135830a743a8d1c3ef_1.json", "function_name": "encode_picture", "vul_func_code": "static int encode_picture(MpegEncContext *s, int picture_number)\n{\n    int i, ret;\n    int bits;\n    int context_count = s->slice_context_count;\n\n    s->picture_number = picture_number;\n\n    /* Reset the average MB variance */\n    s->me.mb_var_sum_temp    =\n    s->me.mc_mb_var_sum_temp = 0;\n\n    /* we need to initialize some time vars before we can encode b-frames */\n    // RAL: Condition added for MPEG1VIDEO\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || (s->h263_pred && !s->msmpeg4_version))\n        set_frame_distances(s);\n    if(CONFIG_MPEG4_ENCODER && s->codec_id == AV_CODEC_ID_MPEG4)\n        ff_set_mpeg4_time(s);\n\n    s->me.scene_change_score=0;\n\n//    s->lambda= s->current_picture_ptr->quality; //FIXME qscale / ... stuff for ME rate distortion\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n        if(s->msmpeg4_version >= 3) s->no_rounding=1;\n        else                        s->no_rounding=0;\n    }else if(s->pict_type!=AV_PICTURE_TYPE_B){\n        if(s->flipflop_rounding || s->codec_id == AV_CODEC_ID_H263P || s->codec_id == AV_CODEC_ID_MPEG4)\n            s->no_rounding ^= 1;\n    }\n\n    if(s->flags & CODEC_FLAG_PASS2){\n        if (estimate_qp(s,1) < 0)\n            return -1;\n        ff_get_2pass_fcode(s);\n    }else if(!(s->flags & CODEC_FLAG_QSCALE)){\n        if(s->pict_type==AV_PICTURE_TYPE_B)\n            s->lambda= s->last_lambda_for[s->pict_type];\n        else\n            s->lambda= s->last_lambda_for[s->last_non_b_pict_type];\n        update_qscale(s);\n    }\n\n    if(s->codec_id != AV_CODEC_ID_AMV && s->codec_id != AV_CODEC_ID_MJPEG){\n        if(s->q_chroma_intra_matrix   != s->q_intra_matrix  ) av_freep(&s->q_chroma_intra_matrix);\n        if(s->q_chroma_intra_matrix16 != s->q_intra_matrix16) av_freep(&s->q_chroma_intra_matrix16);\n        s->q_chroma_intra_matrix   = s->q_intra_matrix;\n        s->q_chroma_intra_matrix16 = s->q_intra_matrix16;\n    }\n\n    s->mb_intra=0; //for the rate distortion & bit compare functions\n    for(i=1; i<context_count; i++){\n        ret = ff_update_duplicate_context(s->thread_context[i], s);\n        if (ret < 0)\n            return ret;\n    }\n\n    if(ff_init_me(s)<0)\n        return -1;\n\n    /* Estimate motion for every MB */\n    if(s->pict_type != AV_PICTURE_TYPE_I){\n        s->lambda = (s->lambda * s->avctx->me_penalty_compensation + 128)>>8;\n        s->lambda2= (s->lambda2* (int64_t)s->avctx->me_penalty_compensation + 128)>>8;\n        if (s->pict_type != AV_PICTURE_TYPE_B) {\n            if((s->avctx->pre_me && s->last_non_b_pict_type==AV_PICTURE_TYPE_I) || s->avctx->pre_me==2){\n                s->avctx->execute(s->avctx, pre_estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n            }\n        }\n\n        s->avctx->execute(s->avctx, estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n    }else /* if(s->pict_type == AV_PICTURE_TYPE_I) */{\n        /* I-Frame */\n        for(i=0; i<s->mb_stride*s->mb_height; i++)\n            s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA;\n\n        if(!s->fixed_qscale){\n            /* finding spatial complexity for I-frame rate control */\n            s->avctx->execute(s->avctx, mb_var_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n        }\n    }\n    for(i=1; i<context_count; i++){\n        merge_context_after_me(s, s->thread_context[i]);\n    }\n    s->current_picture.mc_mb_var_sum= s->current_picture_ptr->mc_mb_var_sum= s->me.mc_mb_var_sum_temp;\n    s->current_picture.   mb_var_sum= s->current_picture_ptr->   mb_var_sum= s->me.   mb_var_sum_temp;\n    emms_c();\n\n    if(s->me.scene_change_score > s->avctx->scenechange_threshold && s->pict_type == AV_PICTURE_TYPE_P){\n        s->pict_type= AV_PICTURE_TYPE_I;\n        for(i=0; i<s->mb_stride*s->mb_height; i++)\n            s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA;\n        if(s->msmpeg4_version >= 3)\n            s->no_rounding=1;\n        av_dlog(s, \"Scene change detected, encoding as I Frame %d %d\\n\",\n                s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum);\n    }\n\n    if(!s->umvplus){\n        if(s->pict_type==AV_PICTURE_TYPE_P || s->pict_type==AV_PICTURE_TYPE_S) {\n            s->f_code= ff_get_best_fcode(s, s->p_mv_table, CANDIDATE_MB_TYPE_INTER);\n\n            if(s->flags & CODEC_FLAG_INTERLACED_ME){\n                int a,b;\n                a= ff_get_best_fcode(s, s->p_field_mv_table[0][0], CANDIDATE_MB_TYPE_INTER_I); //FIXME field_select\n                b= ff_get_best_fcode(s, s->p_field_mv_table[1][1], CANDIDATE_MB_TYPE_INTER_I);\n                s->f_code= FFMAX3(s->f_code, a, b);\n            }\n\n            ff_fix_long_p_mvs(s);\n            ff_fix_long_mvs(s, NULL, 0, s->p_mv_table, s->f_code, CANDIDATE_MB_TYPE_INTER, 0);\n            if(s->flags & CODEC_FLAG_INTERLACED_ME){\n                int j;\n                for(i=0; i<2; i++){\n                    for(j=0; j<2; j++)\n                        ff_fix_long_mvs(s, s->p_field_select_table[i], j,\n                                        s->p_field_mv_table[i][j], s->f_code, CANDIDATE_MB_TYPE_INTER_I, 0);\n                }\n            }\n        }\n\n        if(s->pict_type==AV_PICTURE_TYPE_B){\n            int a, b;\n\n            a = ff_get_best_fcode(s, s->b_forw_mv_table, CANDIDATE_MB_TYPE_FORWARD);\n            b = ff_get_best_fcode(s, s->b_bidir_forw_mv_table, CANDIDATE_MB_TYPE_BIDIR);\n            s->f_code = FFMAX(a, b);\n\n            a = ff_get_best_fcode(s, s->b_back_mv_table, CANDIDATE_MB_TYPE_BACKWARD);\n            b = ff_get_best_fcode(s, s->b_bidir_back_mv_table, CANDIDATE_MB_TYPE_BIDIR);\n            s->b_code = FFMAX(a, b);\n\n            ff_fix_long_mvs(s, NULL, 0, s->b_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_FORWARD, 1);\n            ff_fix_long_mvs(s, NULL, 0, s->b_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BACKWARD, 1);\n            ff_fix_long_mvs(s, NULL, 0, s->b_bidir_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_BIDIR, 1);\n            ff_fix_long_mvs(s, NULL, 0, s->b_bidir_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BIDIR, 1);\n            if(s->flags & CODEC_FLAG_INTERLACED_ME){\n                int dir, j;\n                for(dir=0; dir<2; dir++){\n                    for(i=0; i<2; i++){\n                        for(j=0; j<2; j++){\n                            int type= dir ? (CANDIDATE_MB_TYPE_BACKWARD_I|CANDIDATE_MB_TYPE_BIDIR_I)\n                                          : (CANDIDATE_MB_TYPE_FORWARD_I |CANDIDATE_MB_TYPE_BIDIR_I);\n                            ff_fix_long_mvs(s, s->b_field_select_table[dir][i], j,\n                                            s->b_field_mv_table[dir][i][j], dir ? s->b_code : s->f_code, type, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (estimate_qp(s, 0) < 0)\n        return -1;\n\n    if(s->qscale < 3 && s->max_qcoeff<=128 && s->pict_type==AV_PICTURE_TYPE_I && !(s->flags & CODEC_FLAG_QSCALE))\n        s->qscale= 3; //reduce clipping problems\n\n    if (s->out_format == FMT_MJPEG) {\n        const uint16_t *  luma_matrix = ff_mpeg1_default_intra_matrix;\n        const uint16_t *chroma_matrix = ff_mpeg1_default_intra_matrix;\n\n        if (s->avctx->intra_matrix) {\n            chroma_matrix =\n            luma_matrix = s->avctx->intra_matrix;\n        }\n        if (s->avctx->chroma_intra_matrix)\n            chroma_matrix = s->avctx->chroma_intra_matrix;\n\n        /* for mjpeg, we do include qscale in the matrix */\n        for(i=1;i<64;i++){\n            int j= s->dsp.idct_permutation[i];\n\n            s->chroma_intra_matrix[j] = av_clip_uint8((chroma_matrix[i] * s->qscale) >> 3);\n            s->       intra_matrix[j] = av_clip_uint8((  luma_matrix[i] * s->qscale) >> 3);\n        }\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_mpeg2_dc_scale_table[s->intra_dc_precision];\n        s->chroma_intra_matrix[0] =\n        s->intra_matrix[0] = ff_mpeg2_dc_scale_table[s->intra_dc_precision][8];\n        ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,\n                       s->intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16,\n                       s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        s->qscale= 8;\n    }\n    if(s->codec_id == AV_CODEC_ID_AMV){\n        static const uint8_t y[32]={13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13};\n        static const uint8_t c[32]={14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14};\n        for(i=1;i<64;i++){\n            int j= s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n            s->intra_matrix[j] = sp5x_quant_table[5*2+0][i];\n            s->chroma_intra_matrix[j] = sp5x_quant_table[5*2+1][i];\n        }\n        s->y_dc_scale_table= y;\n        s->c_dc_scale_table= c;\n        s->intra_matrix[0] = 13;\n        s->chroma_intra_matrix[0] = 14;\n        ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,\n                       s->intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16,\n                       s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        s->qscale= 8;\n    }\n\n    //FIXME var duplication\n    s->current_picture_ptr->f.key_frame =\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; //FIXME pic_ptr\n    s->current_picture_ptr->f.pict_type =\n    s->current_picture.f.pict_type = s->pict_type;\n\n    if (s->current_picture.f.key_frame)\n        s->picture_in_gop_number=0;\n\n    s->mb_x = s->mb_y = 0;\n    s->last_bits= put_bits_count(&s->pb);\n    switch(s->out_format) {\n    case FMT_MJPEG:\n        if (CONFIG_MJPEG_ENCODER)\n            ff_mjpeg_encode_picture_header(s->avctx, &s->pb, &s->intra_scantable,\n                                           s->intra_matrix, s->chroma_intra_matrix);\n        break;\n    case FMT_H261:\n        if (CONFIG_H261_ENCODER)\n            ff_h261_encode_picture_header(s, picture_number);\n        break;\n    case FMT_H263:\n        if (CONFIG_WMV2_ENCODER && s->codec_id == AV_CODEC_ID_WMV2)\n            ff_wmv2_encode_picture_header(s, picture_number);\n        else if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version)\n            ff_msmpeg4_encode_picture_header(s, picture_number);\n        else if (CONFIG_MPEG4_ENCODER && s->h263_pred)\n            ff_mpeg4_encode_picture_header(s, picture_number);\n        else if (CONFIG_RV10_ENCODER && s->codec_id == AV_CODEC_ID_RV10)\n            ff_rv10_encode_picture_header(s, picture_number);\n        else if (CONFIG_RV20_ENCODER && s->codec_id == AV_CODEC_ID_RV20)\n            ff_rv20_encode_picture_header(s, picture_number);\n        else if (CONFIG_FLV_ENCODER && s->codec_id == AV_CODEC_ID_FLV1)\n            ff_flv_encode_picture_header(s, picture_number);\n        else if (CONFIG_H263_ENCODER)\n            ff_h263_encode_picture_header(s, picture_number);\n        break;\n    case FMT_MPEG1:\n        if (CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER)\n            ff_mpeg1_encode_picture_header(s, picture_number);\n        break;\n    default:\n        av_assert0(0);\n    }\n    bits= put_bits_count(&s->pb);\n    s->header_bits= bits - s->last_bits;\n\n    for(i=1; i<context_count; i++){\n        update_duplicate_context_after_me(s->thread_context[i], s);\n    }\n    s->avctx->execute(s->avctx, encode_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n    for(i=1; i<context_count; i++){\n        merge_context_after_encode(s, s->thread_context[i]);\n    }\n    emms_c();\n    return 0;\n}", "patch_func_code": "static int encode_picture(MpegEncContext *s, int picture_number)\n{\n    int i, ret;\n    int bits;\n    int context_count = s->slice_context_count;\n\n    s->picture_number = picture_number;\n\n    /* Reset the average MB variance */\n    s->me.mb_var_sum_temp    =\n    s->me.mc_mb_var_sum_temp = 0;\n\n    /* we need to initialize some time vars before we can encode b-frames */\n    // RAL: Condition added for MPEG1VIDEO\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO || s->codec_id == AV_CODEC_ID_MPEG2VIDEO || (s->h263_pred && !s->msmpeg4_version))\n        set_frame_distances(s);\n    if(CONFIG_MPEG4_ENCODER && s->codec_id == AV_CODEC_ID_MPEG4)\n        ff_set_mpeg4_time(s);\n\n    s->me.scene_change_score=0;\n\n//    s->lambda= s->current_picture_ptr->quality; //FIXME qscale / ... stuff for ME rate distortion\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n        if(s->msmpeg4_version >= 3) s->no_rounding=1;\n        else                        s->no_rounding=0;\n    }else if(s->pict_type!=AV_PICTURE_TYPE_B){\n        if(s->flipflop_rounding || s->codec_id == AV_CODEC_ID_H263P || s->codec_id == AV_CODEC_ID_MPEG4)\n            s->no_rounding ^= 1;\n    }\n\n    if(s->flags & CODEC_FLAG_PASS2){\n        if (estimate_qp(s,1) < 0)\n            return -1;\n        ff_get_2pass_fcode(s);\n    }else if(!(s->flags & CODEC_FLAG_QSCALE)){\n        if(s->pict_type==AV_PICTURE_TYPE_B)\n            s->lambda= s->last_lambda_for[s->pict_type];\n        else\n            s->lambda= s->last_lambda_for[s->last_non_b_pict_type];\n        update_qscale(s);\n    }\n\n    if(s->codec_id != AV_CODEC_ID_AMV && s->codec_id != AV_CODEC_ID_MJPEG){\n        if(s->q_chroma_intra_matrix   != s->q_intra_matrix  ) av_freep(&s->q_chroma_intra_matrix);\n        if(s->q_chroma_intra_matrix16 != s->q_intra_matrix16) av_freep(&s->q_chroma_intra_matrix16);\n        s->q_chroma_intra_matrix   = s->q_intra_matrix;\n        s->q_chroma_intra_matrix16 = s->q_intra_matrix16;\n    }\n\n    s->mb_intra=0; //for the rate distortion & bit compare functions\n    for(i=1; i<context_count; i++){\n        ret = ff_update_duplicate_context(s->thread_context[i], s);\n        if (ret < 0)\n            return ret;\n    }\n\n    if(ff_init_me(s)<0)\n        return -1;\n\n    /* Estimate motion for every MB */\n    if(s->pict_type != AV_PICTURE_TYPE_I){\n        s->lambda = (s->lambda * s->avctx->me_penalty_compensation + 128)>>8;\n        s->lambda2= (s->lambda2* (int64_t)s->avctx->me_penalty_compensation + 128)>>8;\n        if (s->pict_type != AV_PICTURE_TYPE_B) {\n            if((s->avctx->pre_me && s->last_non_b_pict_type==AV_PICTURE_TYPE_I) || s->avctx->pre_me==2){\n                s->avctx->execute(s->avctx, pre_estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n            }\n        }\n\n        s->avctx->execute(s->avctx, estimate_motion_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n    }else /* if(s->pict_type == AV_PICTURE_TYPE_I) */{\n        /* I-Frame */\n        for(i=0; i<s->mb_stride*s->mb_height; i++)\n            s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA;\n\n        if(!s->fixed_qscale){\n            /* finding spatial complexity for I-frame rate control */\n            s->avctx->execute(s->avctx, mb_var_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n        }\n    }\n    for(i=1; i<context_count; i++){\n        merge_context_after_me(s, s->thread_context[i]);\n    }\n    s->current_picture.mc_mb_var_sum= s->current_picture_ptr->mc_mb_var_sum= s->me.mc_mb_var_sum_temp;\n    s->current_picture.   mb_var_sum= s->current_picture_ptr->   mb_var_sum= s->me.   mb_var_sum_temp;\n    emms_c();\n\n    if(s->me.scene_change_score > s->avctx->scenechange_threshold && s->pict_type == AV_PICTURE_TYPE_P){\n        s->pict_type= AV_PICTURE_TYPE_I;\n        for(i=0; i<s->mb_stride*s->mb_height; i++)\n            s->mb_type[i]= CANDIDATE_MB_TYPE_INTRA;\n        if(s->msmpeg4_version >= 3)\n            s->no_rounding=1;\n        av_dlog(s, \"Scene change detected, encoding as I Frame %\"PRId64\" %\"PRId64\"\\n\",\n                s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum);\n    }\n\n    if(!s->umvplus){\n        if(s->pict_type==AV_PICTURE_TYPE_P || s->pict_type==AV_PICTURE_TYPE_S) {\n            s->f_code= ff_get_best_fcode(s, s->p_mv_table, CANDIDATE_MB_TYPE_INTER);\n\n            if(s->flags & CODEC_FLAG_INTERLACED_ME){\n                int a,b;\n                a= ff_get_best_fcode(s, s->p_field_mv_table[0][0], CANDIDATE_MB_TYPE_INTER_I); //FIXME field_select\n                b= ff_get_best_fcode(s, s->p_field_mv_table[1][1], CANDIDATE_MB_TYPE_INTER_I);\n                s->f_code= FFMAX3(s->f_code, a, b);\n            }\n\n            ff_fix_long_p_mvs(s);\n            ff_fix_long_mvs(s, NULL, 0, s->p_mv_table, s->f_code, CANDIDATE_MB_TYPE_INTER, 0);\n            if(s->flags & CODEC_FLAG_INTERLACED_ME){\n                int j;\n                for(i=0; i<2; i++){\n                    for(j=0; j<2; j++)\n                        ff_fix_long_mvs(s, s->p_field_select_table[i], j,\n                                        s->p_field_mv_table[i][j], s->f_code, CANDIDATE_MB_TYPE_INTER_I, 0);\n                }\n            }\n        }\n\n        if(s->pict_type==AV_PICTURE_TYPE_B){\n            int a, b;\n\n            a = ff_get_best_fcode(s, s->b_forw_mv_table, CANDIDATE_MB_TYPE_FORWARD);\n            b = ff_get_best_fcode(s, s->b_bidir_forw_mv_table, CANDIDATE_MB_TYPE_BIDIR);\n            s->f_code = FFMAX(a, b);\n\n            a = ff_get_best_fcode(s, s->b_back_mv_table, CANDIDATE_MB_TYPE_BACKWARD);\n            b = ff_get_best_fcode(s, s->b_bidir_back_mv_table, CANDIDATE_MB_TYPE_BIDIR);\n            s->b_code = FFMAX(a, b);\n\n            ff_fix_long_mvs(s, NULL, 0, s->b_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_FORWARD, 1);\n            ff_fix_long_mvs(s, NULL, 0, s->b_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BACKWARD, 1);\n            ff_fix_long_mvs(s, NULL, 0, s->b_bidir_forw_mv_table, s->f_code, CANDIDATE_MB_TYPE_BIDIR, 1);\n            ff_fix_long_mvs(s, NULL, 0, s->b_bidir_back_mv_table, s->b_code, CANDIDATE_MB_TYPE_BIDIR, 1);\n            if(s->flags & CODEC_FLAG_INTERLACED_ME){\n                int dir, j;\n                for(dir=0; dir<2; dir++){\n                    for(i=0; i<2; i++){\n                        for(j=0; j<2; j++){\n                            int type= dir ? (CANDIDATE_MB_TYPE_BACKWARD_I|CANDIDATE_MB_TYPE_BIDIR_I)\n                                          : (CANDIDATE_MB_TYPE_FORWARD_I |CANDIDATE_MB_TYPE_BIDIR_I);\n                            ff_fix_long_mvs(s, s->b_field_select_table[dir][i], j,\n                                            s->b_field_mv_table[dir][i][j], dir ? s->b_code : s->f_code, type, 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (estimate_qp(s, 0) < 0)\n        return -1;\n\n    if(s->qscale < 3 && s->max_qcoeff<=128 && s->pict_type==AV_PICTURE_TYPE_I && !(s->flags & CODEC_FLAG_QSCALE))\n        s->qscale= 3; //reduce clipping problems\n\n    if (s->out_format == FMT_MJPEG) {\n        const uint16_t *  luma_matrix = ff_mpeg1_default_intra_matrix;\n        const uint16_t *chroma_matrix = ff_mpeg1_default_intra_matrix;\n\n        if (s->avctx->intra_matrix) {\n            chroma_matrix =\n            luma_matrix = s->avctx->intra_matrix;\n        }\n        if (s->avctx->chroma_intra_matrix)\n            chroma_matrix = s->avctx->chroma_intra_matrix;\n\n        /* for mjpeg, we do include qscale in the matrix */\n        for(i=1;i<64;i++){\n            int j= s->dsp.idct_permutation[i];\n\n            s->chroma_intra_matrix[j] = av_clip_uint8((chroma_matrix[i] * s->qscale) >> 3);\n            s->       intra_matrix[j] = av_clip_uint8((  luma_matrix[i] * s->qscale) >> 3);\n        }\n        s->y_dc_scale_table=\n        s->c_dc_scale_table= ff_mpeg2_dc_scale_table[s->intra_dc_precision];\n        s->chroma_intra_matrix[0] =\n        s->intra_matrix[0] = ff_mpeg2_dc_scale_table[s->intra_dc_precision][8];\n        ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,\n                       s->intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16,\n                       s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        s->qscale= 8;\n    }\n    if(s->codec_id == AV_CODEC_ID_AMV){\n        static const uint8_t y[32]={13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13};\n        static const uint8_t c[32]={14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14};\n        for(i=1;i<64;i++){\n            int j= s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n            s->intra_matrix[j] = sp5x_quant_table[5*2+0][i];\n            s->chroma_intra_matrix[j] = sp5x_quant_table[5*2+1][i];\n        }\n        s->y_dc_scale_table= y;\n        s->c_dc_scale_table= c;\n        s->intra_matrix[0] = 13;\n        s->chroma_intra_matrix[0] = 14;\n        ff_convert_matrix(&s->dsp, s->q_intra_matrix, s->q_intra_matrix16,\n                       s->intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        ff_convert_matrix(&s->dsp, s->q_chroma_intra_matrix, s->q_chroma_intra_matrix16,\n                       s->chroma_intra_matrix, s->intra_quant_bias, 8, 8, 1);\n        s->qscale= 8;\n    }\n\n    //FIXME var duplication\n    s->current_picture_ptr->f.key_frame =\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I; //FIXME pic_ptr\n    s->current_picture_ptr->f.pict_type =\n    s->current_picture.f.pict_type = s->pict_type;\n\n    if (s->current_picture.f.key_frame)\n        s->picture_in_gop_number=0;\n\n    s->mb_x = s->mb_y = 0;\n    s->last_bits= put_bits_count(&s->pb);\n    switch(s->out_format) {\n    case FMT_MJPEG:\n        if (CONFIG_MJPEG_ENCODER)\n            ff_mjpeg_encode_picture_header(s->avctx, &s->pb, &s->intra_scantable,\n                                           s->intra_matrix, s->chroma_intra_matrix);\n        break;\n    case FMT_H261:\n        if (CONFIG_H261_ENCODER)\n            ff_h261_encode_picture_header(s, picture_number);\n        break;\n    case FMT_H263:\n        if (CONFIG_WMV2_ENCODER && s->codec_id == AV_CODEC_ID_WMV2)\n            ff_wmv2_encode_picture_header(s, picture_number);\n        else if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version)\n            ff_msmpeg4_encode_picture_header(s, picture_number);\n        else if (CONFIG_MPEG4_ENCODER && s->h263_pred)\n            ff_mpeg4_encode_picture_header(s, picture_number);\n        else if (CONFIG_RV10_ENCODER && s->codec_id == AV_CODEC_ID_RV10)\n            ff_rv10_encode_picture_header(s, picture_number);\n        else if (CONFIG_RV20_ENCODER && s->codec_id == AV_CODEC_ID_RV20)\n            ff_rv20_encode_picture_header(s, picture_number);\n        else if (CONFIG_FLV_ENCODER && s->codec_id == AV_CODEC_ID_FLV1)\n            ff_flv_encode_picture_header(s, picture_number);\n        else if (CONFIG_H263_ENCODER)\n            ff_h263_encode_picture_header(s, picture_number);\n        break;\n    case FMT_MPEG1:\n        if (CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER)\n            ff_mpeg1_encode_picture_header(s, picture_number);\n        break;\n    default:\n        av_assert0(0);\n    }\n    bits= put_bits_count(&s->pb);\n    s->header_bits= bits - s->last_bits;\n\n    for(i=1; i<context_count; i++){\n        update_duplicate_context_after_me(s->thread_context[i], s);\n    }\n    s->avctx->execute(s->avctx, encode_thread, &s->thread_context[0], NULL, context_count, sizeof(void*));\n    for(i=1; i<context_count; i++){\n        merge_context_after_encode(s, s->thread_context[i]);\n    }\n    emms_c();\n    return 0;\n}", "before_change_lines": [95], "raw_before_change_lines": [95], "after_change_lines": [95], "raw_after_change_lines": [95], "bug_lines": [95], "added": [false], "idx": 185}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "4467----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f1ffdda6fe17c266c75a1b433d27874745eb9463_1.json----filter_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_f1ffdda6fe17c266c75a1b433d27874745eb9463_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f1ffdda6fe17c266c75a1b433d27874745eb9463_1.json", "function_name": "filter_frame", "vul_func_code": "static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *buf)\n{\n    AVFilterContext *ctx = inlink->dst;\n    AlphaMergeContext *merge = ctx->priv;\n\n    int is_alpha = (inlink == ctx->inputs[1]);\n    struct FFBufQueue *queue =\n        (is_alpha ? &merge->queue_alpha : &merge->queue_main);\n    ff_bufqueue_add(ctx, queue, buf);\n\n    while (1) {\n        AVFilterBufferRef *main_buf, *alpha_buf;\n\n        if (!ff_bufqueue_peek(&merge->queue_main, 0) ||\n            !ff_bufqueue_peek(&merge->queue_alpha, 0)) break;\n\n        main_buf = ff_bufqueue_get(&merge->queue_main);\n        alpha_buf = ff_bufqueue_get(&merge->queue_alpha);\n\n        merge->frame_requested = 0;\n        draw_frame(ctx, main_buf, alpha_buf);\n        ff_filter_frame(ctx->outputs[0], avfilter_ref_buffer(main_buf, ~0));\n        avfilter_unref_buffer(alpha_buf);\n    }\n    return 0;\n}", "patch_func_code": "static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *buf)\n{\n    AVFilterContext *ctx = inlink->dst;\n    AlphaMergeContext *merge = ctx->priv;\n\n    int is_alpha = (inlink == ctx->inputs[1]);\n    struct FFBufQueue *queue =\n        (is_alpha ? &merge->queue_alpha : &merge->queue_main);\n    ff_bufqueue_add(ctx, queue, buf);\n\n    while (1) {\n        AVFilterBufferRef *main_buf, *alpha_buf;\n\n        if (!ff_bufqueue_peek(&merge->queue_main, 0) ||\n            !ff_bufqueue_peek(&merge->queue_alpha, 0)) break;\n\n        main_buf = ff_bufqueue_get(&merge->queue_main);\n        alpha_buf = ff_bufqueue_get(&merge->queue_alpha);\n\n        merge->frame_requested = 0;\n        draw_frame(ctx, main_buf, alpha_buf);\n        ff_filter_frame(ctx->outputs[0], main_buf);\n        avfilter_unref_buffer(alpha_buf);\n    }\n    return 0;\n}", "before_change_lines": [22], "raw_before_change_lines": [22], "after_change_lines": [22], "raw_after_change_lines": [22], "bug_lines": [22], "added": [false], "idx": 186}
{"project": "ffmpeg", "vul_type": "INFERBO_ALLOC_MAY_BE_BIG", "filepath_func": "4478----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f29c31e72d03faeb12180d3ab697035441214e66_1.json----ff_rv34_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_f29c31e72d03faeb12180d3ab697035441214e66_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f29c31e72d03faeb12180d3ab697035441214e66_1.json", "function_name": "ff_rv34_decode_frame", "vul_func_code": "int ff_rv34_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_picture_ptr,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    RV34DecContext *r = avctx->priv_data;\n    MpegEncContext *s = &r->s;\n    AVFrame *pict = data;\n    SliceInfo si;\n    int i, ret;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n    int last = 0;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            if ((ret = av_frame_ref(pict, &s->next_picture_ptr->f)) < 0)\n                return ret;\n            s->next_picture_ptr = NULL;\n\n            *got_picture_ptr = 1;\n        }\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n        buf_size -= 1 + 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    //parse first slice header to check whether this frame can be decoded\n    if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n       get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n        av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n    if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n        av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if ((!s->last_picture_ptr || !s->last_picture_ptr->f.data[0]) &&\n        si.type == AV_PICTURE_TYPE_B) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n               \"reference data.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n       || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n       ||  avctx->skip_frame >= AVDISCARD_ALL)\n        return avpkt->size;\n\n    /* first slice */\n    if (si.start == 0) {\n        if (s->mb_num_left > 0) {\n            av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n                   s->mb_num_left);\n            ff_er_frame_end(&s->er);\n            ff_MPV_frame_end(s);\n        }\n\n        if (s->width != si.width || s->height != si.height) {\n            int err;\n\n            av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n                   si.width, si.height);\n\n            s->width  = si.width;\n            s->height = si.height;\n\n            err = ff_set_dimensions(s->avctx, s->width, s->height);\n            if (err < 0)\n                return err;\n\n            if ((err = ff_MPV_common_frame_size_change(s)) < 0)\n                return err;\n            if ((err = rv34_decoder_realloc(r)) < 0)\n                return err;\n        }\n        s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n        if (ff_MPV_frame_start(s, s->avctx) < 0)\n            return -1;\n        ff_mpeg_er_frame_start(s);\n        if (!r->tmp_b_block_base) {\n            int i;\n\n            r->tmp_b_block_base = av_malloc(s->linesize * 48);\n            for (i = 0; i < 2; i++)\n                r->tmp_b_block_y[i] = r->tmp_b_block_base\n                                      + i * 16 * s->linesize;\n            for (i = 0; i < 4; i++)\n                r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n                                       + (i >> 1) * 8 * s->uvlinesize\n                                       + (i &  1) * 16;\n        }\n        r->cur_pts = si.pts;\n        if (s->pict_type != AV_PICTURE_TYPE_B) {\n            r->last_pts = r->next_pts;\n            r->next_pts = r->cur_pts;\n        } else {\n            int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n            int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n            int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n\n            if(!refdist){\n                r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n                r->scaled_weight = 0;\n            }else{\n                r->mv_weight1 = (dist0 << 14) / refdist;\n                r->mv_weight2 = (dist1 << 14) / refdist;\n                if((r->mv_weight1|r->mv_weight2) & 511){\n                    r->weight1 = r->mv_weight1;\n                    r->weight2 = r->mv_weight2;\n                    r->scaled_weight = 0;\n                }else{\n                    r->weight1 = r->mv_weight1 >> 9;\n                    r->weight2 = r->mv_weight2 >> 9;\n                    r->scaled_weight = 1;\n                }\n            }\n        }\n        s->mb_x = s->mb_y = 0;\n        ff_thread_finish_setup(s->avctx);\n    } else if (HAVE_THREADS &&\n               (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n               \"multithreading mode (start MB is %d).\\n\", si.start);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for(i = 0; i < slice_count; i++){\n        int offset = get_slice_offset(avctx, slices_hdr, i);\n        int size;\n        if(i+1 == slice_count)\n            size = buf_size - offset;\n        else\n            size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(offset < 0 || offset > buf_size){\n            av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n            break;\n        }\n\n        r->si.end = s->mb_width * s->mb_height;\n        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n\n        if(i+1 < slice_count){\n            if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n                get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n                av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n                break;\n            }\n            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n                if(i+2 < slice_count)\n                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n                else\n                    size = buf_size - offset;\n            }else\n                r->si.end = si.start;\n        }\n        if (size < 0 || size > buf_size - offset) {\n            av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n            break;\n        }\n        last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n        if(last)\n            break;\n    }\n\n    if (s->current_picture_ptr) {\n        if (last) {\n            if(r->loop_filter)\n                r->loop_filter(r, s->mb_height - 1);\n\n            ret = finish_frame(avctx, pict);\n            if (ret < 0)\n                return ret;\n            *got_picture_ptr = ret;\n        } else if (HAVE_THREADS &&\n                   (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n            av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n            /* always mark the current frame as finished, frame-mt supports\n             * only complete frames */\n            ff_er_frame_end(&s->er);\n            ff_MPV_frame_end(s);\n            s->mb_num_left = 0;\n            ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return avpkt->size;\n}", "patch_func_code": "int ff_rv34_decode_frame(AVCodecContext *avctx,\n                            void *data, int *got_picture_ptr,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    RV34DecContext *r = avctx->priv_data;\n    MpegEncContext *s = &r->s;\n    AVFrame *pict = data;\n    SliceInfo si;\n    int i, ret;\n    int slice_count;\n    const uint8_t *slices_hdr = NULL;\n    int last = 0;\n\n    /* no supplementary picture */\n    if (buf_size == 0) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n                return ret;\n            s->next_picture_ptr = NULL;\n\n            *got_picture_ptr = 1;\n        }\n        return 0;\n    }\n\n    if(!avctx->slice_count){\n        slice_count = (*buf++) + 1;\n        slices_hdr = buf + 4;\n        buf += 8 * slice_count;\n        buf_size -= 1 + 8 * slice_count;\n    }else\n        slice_count = avctx->slice_count;\n\n    //parse first slice header to check whether this frame can be decoded\n    if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n       get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n        av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n    if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n        av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n        si.type == AV_PICTURE_TYPE_B) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n               \"reference data.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n       || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n       ||  avctx->skip_frame >= AVDISCARD_ALL)\n        return avpkt->size;\n\n    /* first slice */\n    if (si.start == 0) {\n        if (s->mb_num_left > 0) {\n            av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n                   s->mb_num_left);\n            ff_er_frame_end(&s->er);\n            ff_MPV_frame_end(s);\n        }\n\n        if (s->width != si.width || s->height != si.height) {\n            int err;\n\n            av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n                   si.width, si.height);\n\n            s->width  = si.width;\n            s->height = si.height;\n\n            err = ff_set_dimensions(s->avctx, s->width, s->height);\n            if (err < 0)\n                return err;\n\n            if ((err = ff_MPV_common_frame_size_change(s)) < 0)\n                return err;\n            if ((err = rv34_decoder_realloc(r)) < 0)\n                return err;\n        }\n        s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n        if (ff_MPV_frame_start(s, s->avctx) < 0)\n            return -1;\n        ff_mpeg_er_frame_start(s);\n        if (!r->tmp_b_block_base) {\n            int i;\n\n            r->tmp_b_block_base = av_malloc(s->linesize * 48);\n            for (i = 0; i < 2; i++)\n                r->tmp_b_block_y[i] = r->tmp_b_block_base\n                                      + i * 16 * s->linesize;\n            for (i = 0; i < 4; i++)\n                r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n                                       + (i >> 1) * 8 * s->uvlinesize\n                                       + (i &  1) * 16;\n        }\n        r->cur_pts = si.pts;\n        if (s->pict_type != AV_PICTURE_TYPE_B) {\n            r->last_pts = r->next_pts;\n            r->next_pts = r->cur_pts;\n        } else {\n            int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n            int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n            int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n\n            if(!refdist){\n                r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n                r->scaled_weight = 0;\n            }else{\n                r->mv_weight1 = (dist0 << 14) / refdist;\n                r->mv_weight2 = (dist1 << 14) / refdist;\n                if((r->mv_weight1|r->mv_weight2) & 511){\n                    r->weight1 = r->mv_weight1;\n                    r->weight2 = r->mv_weight2;\n                    r->scaled_weight = 0;\n                }else{\n                    r->weight1 = r->mv_weight1 >> 9;\n                    r->weight2 = r->mv_weight2 >> 9;\n                    r->scaled_weight = 1;\n                }\n            }\n        }\n        s->mb_x = s->mb_y = 0;\n        ff_thread_finish_setup(s->avctx);\n    } else if (HAVE_THREADS &&\n               (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n               \"multithreading mode (start MB is %d).\\n\", si.start);\n        return AVERROR_INVALIDDATA;\n    }\n\n    for(i = 0; i < slice_count; i++){\n        int offset = get_slice_offset(avctx, slices_hdr, i);\n        int size;\n        if(i+1 == slice_count)\n            size = buf_size - offset;\n        else\n            size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n\n        if(offset < 0 || offset > buf_size){\n            av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n            break;\n        }\n\n        r->si.end = s->mb_width * s->mb_height;\n        s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n\n        if(i+1 < slice_count){\n            if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n                get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n                av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n                break;\n            }\n            init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n            if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n                if(i+2 < slice_count)\n                    size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n                else\n                    size = buf_size - offset;\n            }else\n                r->si.end = si.start;\n        }\n        if (size < 0 || size > buf_size - offset) {\n            av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n            break;\n        }\n        last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n        if(last)\n            break;\n    }\n\n    if (s->current_picture_ptr) {\n        if (last) {\n            if(r->loop_filter)\n                r->loop_filter(r, s->mb_height - 1);\n\n            ret = finish_frame(avctx, pict);\n            if (ret < 0)\n                return ret;\n            *got_picture_ptr = ret;\n        } else if (HAVE_THREADS &&\n                   (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n            av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n            /* always mark the current frame as finished, frame-mt supports\n             * only complete frames */\n            ff_er_frame_end(&s->er);\n            ff_MPV_frame_end(s);\n            s->mb_num_left = 0;\n            ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n\n    return avpkt->size;\n}", "before_change_lines": [20, 48], "raw_before_change_lines": [20, 48], "after_change_lines": [20, 48], "raw_after_change_lines": [20, 48], "bug_lines": [20, 48], "added": [false, false], "idx": 187}
{"project": "ffmpeg", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "4485----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f30306ca4990ce174a45a9ffebb29747a47cb19c_1.json----decode_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_f30306ca4990ce174a45a9ffebb29747a47cb19c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f30306ca4990ce174a45a9ffebb29747a47cb19c_1.json", "function_name": "decode_header", "vul_func_code": "static int decode_header(PSDContext * s)\n{\n    int signature, version, color_mode, compression;\n    int64_t len_section;\n    int ret = 0;\n\n    if (bytestream2_get_bytes_left(&s->gb) < 30) {/* File header section + color map data section length */\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    signature = bytestream2_get_le32(&s->gb);\n    if (signature != MKTAG('8','B','P','S')) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong signature %d.\\n\", signature);\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = bytestream2_get_be16(&s->gb);\n    if (version != 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong version %d.\\n\", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_skip(&s->gb, 6);/* reserved */\n\n    s->channel_count = bytestream2_get_be16(&s->gb);\n    if ((s->channel_count < 1) || (s->channel_count > 56)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid channel count %d.\\n\", s->channel_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->height = bytestream2_get_be32(&s->gb);\n\n    if ((s->height > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Height > 30000 is experimental, add \"\n               \"'-strict %d' if you want to try to decode the picture.\\n\",\n               FF_COMPLIANCE_EXPERIMENTAL);\n        return AVERROR_EXPERIMENTAL;\n    }\n\n    s->width = bytestream2_get_be32(&s->gb);\n    if ((s->width > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Width > 30000 is experimental, add \"\n               \"'-strict %d' if you want to try to decode the picture.\\n\",\n               FF_COMPLIANCE_EXPERIMENTAL);\n        return AVERROR_EXPERIMENTAL;\n    }\n\n    if ((ret = ff_set_dimensions(s->avctx, s->width, s->height)) < 0)\n        return ret;\n\n    s->channel_depth = bytestream2_get_be16(&s->gb);\n\n    color_mode = bytestream2_get_be16(&s->gb);\n    switch (color_mode) {\n    case 0:\n        s->color_mode = PSD_BITMAP;\n        break;\n    case 1:\n        s->color_mode = PSD_GRAYSCALE;\n        break;\n    case 2:\n        s->color_mode = PSD_INDEXED;\n        break;\n    case 3:\n        s->color_mode = PSD_RGB;\n        break;\n    case 4:\n        s->color_mode = PSD_CMYK;\n        break;\n    case 7:\n        s->color_mode = PSD_MULTICHANNEL;\n        break;\n    case 8:\n        s->color_mode = PSD_DUOTONE;\n        break;\n    case 9:\n        s->color_mode = PSD_LAB;\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR, \"Unknown color mode %d.\\n\", color_mode);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* color map data */\n    len_section = bytestream2_get_be32(&s->gb);\n    if (len_section < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Negative size for color map data section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { /* section and len next section */\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete file.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, len_section);\n\n    /* image ressources */\n    len_section = bytestream2_get_be32(&s->gb);\n    if (len_section < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Negative size for image ressources section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { /* section and len next section */\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete file.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, len_section);\n\n    /* layers and masks */\n    len_section = bytestream2_get_be32(&s->gb);\n    if (len_section < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Negative size for layers and masks data section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) < len_section) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete file.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, len_section);\n\n    /* image section */\n    if (bytestream2_get_bytes_left(&s->gb) < 2) {\n        av_log(s->avctx, AV_LOG_ERROR, \"File without image data section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->compression = bytestream2_get_be16(&s->gb);\n    switch (s->compression) {\n    case 0:\n    case 1:\n        break;\n    case 2:\n        avpriv_request_sample(s->avctx, \"ZIP without predictor compression\");\n        return AVERROR_PATCHWELCOME;\n        break;\n    case 3:\n        avpriv_request_sample(s->avctx, \"ZIP with predictor compression\");\n        return AVERROR_PATCHWELCOME;\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR, \"Unknown compression %d.\\n\", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return ret;\n}", "patch_func_code": "static int decode_header(PSDContext * s)\n{\n    int signature, version, color_mode;\n    int64_t len_section;\n    int ret = 0;\n\n    if (bytestream2_get_bytes_left(&s->gb) < 30) {/* File header section + color map data section length */\n        av_log(s->avctx, AV_LOG_ERROR, \"Header too short to parse.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    signature = bytestream2_get_le32(&s->gb);\n    if (signature != MKTAG('8','B','P','S')) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong signature %d.\\n\", signature);\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = bytestream2_get_be16(&s->gb);\n    if (version != 1) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Wrong version %d.\\n\", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    bytestream2_skip(&s->gb, 6);/* reserved */\n\n    s->channel_count = bytestream2_get_be16(&s->gb);\n    if ((s->channel_count < 1) || (s->channel_count > 56)) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid channel count %d.\\n\", s->channel_count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->height = bytestream2_get_be32(&s->gb);\n\n    if ((s->height > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Height > 30000 is experimental, add \"\n               \"'-strict %d' if you want to try to decode the picture.\\n\",\n               FF_COMPLIANCE_EXPERIMENTAL);\n        return AVERROR_EXPERIMENTAL;\n    }\n\n    s->width = bytestream2_get_be32(&s->gb);\n    if ((s->width > 30000) && (s->avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL)) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Width > 30000 is experimental, add \"\n               \"'-strict %d' if you want to try to decode the picture.\\n\",\n               FF_COMPLIANCE_EXPERIMENTAL);\n        return AVERROR_EXPERIMENTAL;\n    }\n\n    if ((ret = ff_set_dimensions(s->avctx, s->width, s->height)) < 0)\n        return ret;\n\n    s->channel_depth = bytestream2_get_be16(&s->gb);\n\n    color_mode = bytestream2_get_be16(&s->gb);\n    switch (color_mode) {\n    case 0:\n        s->color_mode = PSD_BITMAP;\n        break;\n    case 1:\n        s->color_mode = PSD_GRAYSCALE;\n        break;\n    case 2:\n        s->color_mode = PSD_INDEXED;\n        break;\n    case 3:\n        s->color_mode = PSD_RGB;\n        break;\n    case 4:\n        s->color_mode = PSD_CMYK;\n        break;\n    case 7:\n        s->color_mode = PSD_MULTICHANNEL;\n        break;\n    case 8:\n        s->color_mode = PSD_DUOTONE;\n        break;\n    case 9:\n        s->color_mode = PSD_LAB;\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR, \"Unknown color mode %d.\\n\", color_mode);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* color map data */\n    len_section = bytestream2_get_be32(&s->gb);\n    if (len_section < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Negative size for color map data section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { /* section and len next section */\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete file.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, len_section);\n\n    /* image ressources */\n    len_section = bytestream2_get_be32(&s->gb);\n    if (len_section < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Negative size for image ressources section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) < (len_section + 4)) { /* section and len next section */\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete file.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, len_section);\n\n    /* layers and masks */\n    len_section = bytestream2_get_be32(&s->gb);\n    if (len_section < 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Negative size for layers and masks data section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (bytestream2_get_bytes_left(&s->gb) < len_section) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Incomplete file.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, len_section);\n\n    /* image section */\n    if (bytestream2_get_bytes_left(&s->gb) < 2) {\n        av_log(s->avctx, AV_LOG_ERROR, \"File without image data section.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->compression = bytestream2_get_be16(&s->gb);\n    switch (s->compression) {\n    case 0:\n    case 1:\n        break;\n    case 2:\n        avpriv_request_sample(s->avctx, \"ZIP without predictor compression\");\n        return AVERROR_PATCHWELCOME;\n        break;\n    case 3:\n        avpriv_request_sample(s->avctx, \"ZIP with predictor compression\");\n        return AVERROR_PATCHWELCOME;\n        break;\n    default:\n        av_log(s->avctx, AV_LOG_ERROR, \"Unknown compression %d.\\n\", s->compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return ret;\n}", "before_change_lines": [3, 146], "raw_before_change_lines": [3, 146], "after_change_lines": [3, 146], "raw_after_change_lines": [3, 146], "bug_lines": [3, 146], "added": [false, false], "idx": 188}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4564----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f6853f0cc22f3c6129d729ca46630f7caf0f37f1_1.json----sap_fetch_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_f6853f0cc22f3c6129d729ca46630f7caf0f37f1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f6853f0cc22f3c6129d729ca46630f7caf0f37f1_1.json", "function_name": "sap_fetch_packet", "vul_func_code": "static int sap_fetch_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    struct SAPState *sap = s->priv_data;\n    int fd = url_get_file_handle(sap->ann_fd);\n    int n, ret;\n    fd_set rfds;\n    struct timeval tv;\n    uint8_t recvbuf[1500];\n\n    if (sap->eof)\n        return AVERROR_EOF;\n\n    while (1) {\n        FD_ZERO(&rfds);\n        FD_SET(fd, &rfds);\n        tv.tv_sec = tv.tv_usec = 0;\n        n = select(fd + 1, &rfds, NULL, NULL, &tv);\n        if (n <= 0 || !FD_ISSET(fd, &rfds))\n            break;\n        ret = url_read(sap->ann_fd, recvbuf, sizeof(recvbuf));\n        if (ret >= 8) {\n            uint16_t hash = AV_RB16(&recvbuf[2]);\n            /* Should ideally check the source IP address, too */\n            if (recvbuf[0] & 0x04 && hash == sap->hash) {\n                /* Stream deletion */\n                sap->eof = 1;\n                return AVERROR_EOF;\n            }\n        }\n    }\n    ret = av_read_frame(sap->sdp_ctx, pkt);\n    if (ret < 0)\n        return ret;\n    if (s->ctx_flags & AVFMTCTX_NOHEADER) {\n        while (sap->sdp_ctx->nb_streams > s->nb_streams) {\n            int i = s->nb_streams;\n            AVStream *st = av_new_stream(s, i);\n            if (!st) {\n                av_free_packet(pkt);\n                return AVERROR(ENOMEM);\n            }\n            avcodec_copy_context(st->codec, sap->sdp_ctx->streams[i]->codec);\n            st->time_base = sap->sdp_ctx->streams[i]->time_base;\n        }\n    }\n    return ret;\n}", "patch_func_code": "static int sap_fetch_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    struct SAPState *sap = s->priv_data;\n    int fd = url_get_file_handle(sap->ann_fd);\n    int n, ret;\n    struct pollfd p = {fd, POLLIN, 0};\n    uint8_t recvbuf[1500];\n\n    if (sap->eof)\n        return AVERROR_EOF;\n\n    while (1) {\n        n = poll(&p, 1, 0);\n        if (n <= 0 || !(p.revents & POLLIN))\n            break;\n        ret = url_read(sap->ann_fd, recvbuf, sizeof(recvbuf));\n        if (ret >= 8) {\n            uint16_t hash = AV_RB16(&recvbuf[2]);\n            /* Should ideally check the source IP address, too */\n            if (recvbuf[0] & 0x04 && hash == sap->hash) {\n                /* Stream deletion */\n                sap->eof = 1;\n                return AVERROR_EOF;\n            }\n        }\n    }\n    ret = av_read_frame(sap->sdp_ctx, pkt);\n    if (ret < 0)\n        return ret;\n    if (s->ctx_flags & AVFMTCTX_NOHEADER) {\n        while (sap->sdp_ctx->nb_streams > s->nb_streams) {\n            int i = s->nb_streams;\n            AVStream *st = av_new_stream(s, i);\n            if (!st) {\n                av_free_packet(pkt);\n                return AVERROR(ENOMEM);\n            }\n            avcodec_copy_context(st->codec, sap->sdp_ctx->streams[i]->codec);\n            st->time_base = sap->sdp_ctx->streams[i]->time_base;\n        }\n    }\n    return ret;\n}", "before_change_lines": [6, 7, 14, 15, 16, 17, 18], "raw_before_change_lines": [6, 7, 14, 15, 16, 17, 18], "after_change_lines": [6, 13, 14], "raw_after_change_lines": [6, 13, 14], "bug_lines": [6, 7, 14, 15, 16, 17, 18], "added": [false, false, false, false, false, false, false], "idx": 189}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4614----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f84d1763a5fbbc52eae32da2599efdbc2ef5302f_1.json----filter_frame", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_f84d1763a5fbbc52eae32da2599efdbc2ef5302f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f84d1763a5fbbc52eae32da2599efdbc2ef5302f_1.json", "function_name": "filter_frame", "vul_func_code": "static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *cur_buf)\n{\n    AlphaExtractContext *extract = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFilterBufferRef *out_buf =\n        ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);\n    int ret;\n\n    if (!out_buf) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    avfilter_copy_buffer_ref_props(out_buf, cur_buf);\n\n    if (extract->is_packed_rgb) {\n        int x, y;\n        uint8_t *pin, *pout;\n        for (y = 0; y < out_buf->video->h; y++) {\n            pin = cur_buf->data[0] + y * cur_buf->linesize[0] + extract->rgba_map[A];\n            pout = out_buf->data[0] + y * out_buf->linesize[0];\n            for (x = 0; x < out_buf->video->w; x++) {\n                *pout = *pin;\n                pout += 1;\n                pin += 4;\n            }\n        }\n    } else {\n        const int linesize = FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]);\n        int y;\n        for (y = 0; y < out_buf->video->h; y++) {\n            memcpy(out_buf->data[Y] + y * out_buf->linesize[Y],\n                   cur_buf->data[A] + y * cur_buf->linesize[A],\n                   linesize);\n        }\n    }\n\n    ret = ff_filter_frame(outlink, out_buf);\n\nend:\n    avfilter_unref_buffer(cur_buf);\n    return ret;\n}", "patch_func_code": "static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *cur_buf)\n{\n    AlphaExtractContext *extract = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFilterBufferRef *out_buf =\n        ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);\n    int ret;\n\n    if (!out_buf) {\n        ret = AVERROR(ENOMEM);\n        goto end;\n    }\n    avfilter_copy_buffer_ref_props(out_buf, cur_buf);\n\n    if (extract->is_packed_rgb) {\n        int x, y;\n        uint8_t *pin, *pout;\n        for (y = 0; y < out_buf->video->h; y++) {\n            pin = cur_buf->data[0] + y * cur_buf->linesize[0] + extract->rgba_map[A];\n            pout = out_buf->data[0] + y * out_buf->linesize[0];\n            for (x = 0; x < out_buf->video->w; x++) {\n                *pout = *pin;\n                pout += 1;\n                pin += 4;\n            }\n        }\n    } else {\n        const int linesize = abs(FFMIN(out_buf->linesize[Y], cur_buf->linesize[A]));\n        int y;\n        for (y = 0; y < out_buf->video->h; y++) {\n            memcpy(out_buf->data[Y] + y * out_buf->linesize[Y],\n                   cur_buf->data[A] + y * cur_buf->linesize[A],\n                   linesize);\n        }\n    }\n\n    ret = ff_filter_frame(outlink, out_buf);\n\nend:\n    avfilter_unref_buffer(cur_buf);\n    return ret;\n}", "before_change_lines": [28], "raw_before_change_lines": [28], "after_change_lines": [28], "raw_after_change_lines": [28], "bug_lines": [28], "added": [false], "idx": 190}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4621----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f8bb12758b05c7b93430b2df420ea3239e27d218_1.json----theora_packet", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_f8bb12758b05c7b93430b2df420ea3239e27d218_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_f8bb12758b05c7b93430b2df420ea3239e27d218_1.json", "function_name": "theora_packet", "vul_func_code": "static int theora_packet(AVFormatContext *s, int idx)\n{\n    struct ogg *ogg = s->priv_data;\n    struct ogg_stream *os = ogg->streams + idx;\n    int duration;\n\n    /* first packet handling\n       here we parse the duration of each packet in the first page and compare\n       the total duration to the page granule to find the encoder delay and\n       set the first timestamp */\n\n    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) {\n        int seg;\n\n        duration = 1;\n        for (seg = os->segp; seg < os->nsegs; seg++) {\n            if (os->segments[seg] < 255)\n                duration ++;\n        }\n\n        os->lastpts = os->lastdts   = theora_gptopts(s, idx, os->granule, NULL) - duration;\n        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {\n            s->streams[idx]->start_time = os->lastpts;\n            if (s->streams[idx]->duration)\n                s->streams[idx]->duration -= s->streams[idx]->start_time;\n        }\n    }\n\n    /* parse packet duration */\n    if (os->psize > 0) {\n        os->pduration = 1;\n    }\n\n    return 0;\n}", "patch_func_code": "static int theora_packet(AVFormatContext *s, int idx)\n{\n    struct ogg *ogg = s->priv_data;\n    struct ogg_stream *os = ogg->streams + idx;\n    int duration;\n\n    /* first packet handling\n       here we parse the duration of each packet in the first page and compare\n       the total duration to the page granule to find the encoder delay and\n       set the first timestamp */\n\n    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) {\n        int seg;\n\n        duration = 1;\n        for (seg = os->segp; seg < os->nsegs; seg++) {\n            if (os->segments[seg] < 255)\n                duration ++;\n        }\n\n        os->lastpts = os->lastdts   = theora_gptopts(s, idx, os->granule, NULL) - duration;\n        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {\n            s->streams[idx]->start_time = os->lastpts;\n            if (s->streams[idx]->duration > 0)\n                s->streams[idx]->duration -= s->streams[idx]->start_time;\n        }\n    }\n\n    /* parse packet duration */\n    if (os->psize > 0) {\n        os->pduration = 1;\n    }\n\n    return 0;\n}", "before_change_lines": [24], "raw_before_change_lines": [24], "after_change_lines": [24], "raw_after_change_lines": [24], "bug_lines": [24], "added": [false], "idx": 191}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4644----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fa3fa6951f7fc4271429b9486f86c192b01c3118_1.json----decode_audio_specific_config", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_fa3fa6951f7fc4271429b9486f86c192b01c3118_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fa3fa6951f7fc4271429b9486f86c192b01c3118_1.json", "function_name": "decode_audio_specific_config", "vul_func_code": "static int decode_audio_specific_config(AACContext *ac,\n                                        AVCodecContext *avctx,\n                                        MPEG4AudioConfig *m4ac,\n                                        const uint8_t *data, int bit_size,\n                                        int sync_extension)\n{\n    GetBitContext gb;\n    int i, ret;\n\n    ff_dlog(avctx, \"audio specific config size %d\\n\", bit_size >> 3);\n    for (i = 0; i < bit_size >> 3; i++)\n        ff_dlog(avctx, \"%02x \", data[i]);\n    ff_dlog(avctx, \"\\n\");\n\n    if ((ret = init_get_bits(&gb, data, bit_size)) < 0)\n        return ret;\n\n    if ((i = avpriv_mpeg4audio_get_config(m4ac, data, bit_size,\n                                          sync_extension)) < 0)\n        return AVERROR_INVALIDDATA;\n    if (m4ac->sampling_index > 12) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"invalid sampling rate index %d\\n\",\n               m4ac->sampling_index);\n        return AVERROR_INVALIDDATA;\n    }\n    if (m4ac->object_type == AOT_ER_AAC_LD &&\n        (m4ac->sampling_index < 3 || m4ac->sampling_index > 7)) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"invalid low delay sampling rate index %d\\n\",\n               m4ac->sampling_index);\n        return AVERROR_INVALIDDATA;\n    }\n\n    skip_bits_long(&gb, i);\n\n    switch (m4ac->object_type) {\n    case AOT_AAC_MAIN:\n    case AOT_AAC_LC:\n    case AOT_AAC_LTP:\n    case AOT_ER_AAC_LC:\n    case AOT_ER_AAC_LD:\n        if ((ret = decode_ga_specific_config(ac, avctx, &gb,\n                                            m4ac, m4ac->chan_config)) < 0)\n            return ret;\n        break;\n    case AOT_ER_AAC_ELD:\n        if ((ret = decode_eld_specific_config(ac, avctx, &gb,\n                                              m4ac, m4ac->chan_config)) < 0)\n            return ret;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx,\n                                      \"Audio object type %s%d\",\n                                      m4ac->sbr == 1 ? \"SBR+\" : \"\",\n                                      m4ac->object_type);\n        return AVERROR(ENOSYS);\n    }\n\n    ff_dlog(avctx,\n            \"AOT %d chan config %d sampling index %d (%d) SBR %d PS %d\\n\",\n            m4ac->object_type, m4ac->chan_config, m4ac->sampling_index,\n            m4ac->sample_rate, m4ac->sbr,\n            m4ac->ps);\n\n    return get_bits_count(&gb);\n}", "patch_func_code": "static int decode_audio_specific_config(AACContext *ac,\n                                        AVCodecContext *avctx,\n                                        MPEG4AudioConfig *m4ac,\n                                        const uint8_t *data, int64_t bit_size,\n                                        int sync_extension)\n{\n    GetBitContext gb;\n    int i, ret;\n\n    if (bit_size < 0 || bit_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"Audio specific config size is invalid\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ff_dlog(avctx, \"audio specific config size %d\\n\", (int)bit_size >> 3);\n    for (i = 0; i < bit_size >> 3; i++)\n        ff_dlog(avctx, \"%02x \", data[i]);\n    ff_dlog(avctx, \"\\n\");\n\n    if ((ret = init_get_bits(&gb, data, bit_size)) < 0)\n        return ret;\n\n    if ((i = avpriv_mpeg4audio_get_config(m4ac, data, bit_size,\n                                          sync_extension)) < 0)\n        return AVERROR_INVALIDDATA;\n    if (m4ac->sampling_index > 12) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"invalid sampling rate index %d\\n\",\n               m4ac->sampling_index);\n        return AVERROR_INVALIDDATA;\n    }\n    if (m4ac->object_type == AOT_ER_AAC_LD &&\n        (m4ac->sampling_index < 3 || m4ac->sampling_index > 7)) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"invalid low delay sampling rate index %d\\n\",\n               m4ac->sampling_index);\n        return AVERROR_INVALIDDATA;\n    }\n\n    skip_bits_long(&gb, i);\n\n    switch (m4ac->object_type) {\n    case AOT_AAC_MAIN:\n    case AOT_AAC_LC:\n    case AOT_AAC_LTP:\n    case AOT_ER_AAC_LC:\n    case AOT_ER_AAC_LD:\n        if ((ret = decode_ga_specific_config(ac, avctx, &gb,\n                                            m4ac, m4ac->chan_config)) < 0)\n            return ret;\n        break;\n    case AOT_ER_AAC_ELD:\n        if ((ret = decode_eld_specific_config(ac, avctx, &gb,\n                                              m4ac, m4ac->chan_config)) < 0)\n            return ret;\n        break;\n    default:\n        avpriv_report_missing_feature(avctx,\n                                      \"Audio object type %s%d\",\n                                      m4ac->sbr == 1 ? \"SBR+\" : \"\",\n                                      m4ac->object_type);\n        return AVERROR(ENOSYS);\n    }\n\n    ff_dlog(avctx,\n            \"AOT %d chan config %d sampling index %d (%d) SBR %d PS %d\\n\",\n            m4ac->object_type, m4ac->chan_config, m4ac->sampling_index,\n            m4ac->sample_rate, m4ac->sbr,\n            m4ac->ps);\n\n    return get_bits_count(&gb);\n}", "before_change_lines": [4, 10], "raw_before_change_lines": [4, 10], "after_change_lines": [4, 10, 11, 12, 13, 15], "raw_after_change_lines": [4, 10, 11, 12, 13, 14, 15], "bug_lines": [4, 10], "added": [false, false], "idx": 192}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4650----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fa7b664b292143c2e4ddf6d6c606cf7e4d458b8a_1.json----add_shorts_metadata", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_fa7b664b292143c2e4ddf6d6c606cf7e4d458b8a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fa7b664b292143c2e4ddf6d6c606cf7e4d458b8a_1.json", "function_name": "add_shorts_metadata", "vul_func_code": "static int add_shorts_metadata(int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int16_t *sp;\n\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n        return -1;\n\n    sp = av_malloc(count * sizeof(int16_t));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(&s->gb, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}", "patch_func_code": "static int add_shorts_metadata(int count, const char *name,\n                               const char *sep, TiffContext *s)\n{\n    char *ap;\n    int i;\n    int16_t *sp;\n\n    if (count >= INT_MAX / sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n    if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n        return AVERROR_INVALIDDATA;\n\n    sp = av_malloc(count * sizeof(int16_t));\n    if (!sp)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < count; i++)\n        sp[i] = tget_short(&s->gb, s->le);\n    ap = shorts2str(sp, count, sep);\n    av_freep(&sp);\n    if (!ap)\n        return AVERROR(ENOMEM);\n    av_dict_set(&s->picture.metadata, name, ap, AV_DICT_DONT_STRDUP_VAL);\n    return 0;\n}", "before_change_lines": [9], "raw_before_change_lines": [9], "after_change_lines": [8, 9, 11], "raw_after_change_lines": [8, 9, 11], "bug_lines": [9], "added": [false], "idx": 193}
{"project": "ffmpeg", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4663----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fb37c3e2bbabea7f396fdfca174c6922a1d7e3fb_1.json----new_audio_stream", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_fb37c3e2bbabea7f396fdfca174c6922a1d7e3fb_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fb37c3e2bbabea7f396fdfca174c6922a1d7e3fb_1.json", "function_name": "new_audio_stream", "vul_func_code": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, int source_index)\n{\n    int n;\n    AVStream *st;\n    OutputStream *ost;\n    AVCodecContext *audio_enc;\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO, source_index);\n    st  = ost->st;\n\n    audio_enc = st->codec;\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n    if (!ost->stream_copy) {\n        char *sample_fmt = NULL;\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n        if (sample_fmt &&\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n            exit_program(1);\n        }\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n        ost->rematrix_volume=1.0;\n        MATCH_PER_STREAM_OPT(rematrix_volume, f, ost->rematrix_volume, oc, st);\n    }\n\n    /* check for channel mapping for this audio stream */\n    for (n = 0; n < o->nb_audio_channel_maps; n++) {\n        AudioChannelMap *map = &o->audio_channel_maps[n];\n        InputStream *ist = input_streams[ost->source_index];\n        if ((map->channel_idx == -1 || (ist->file_index == map->file_idx && ist->st->index == map->stream_idx)) &&\n            (map->ofile_idx   == -1 || ost->file_index == map->ofile_idx) &&\n            (map->ostream_idx == -1 || ost->st->index  == map->ostream_idx)) {\n            if (ost->audio_channels_mapped < FF_ARRAY_ELEMS(ost->audio_channels_map))\n                ost->audio_channels_map[ost->audio_channels_mapped++] = map->channel_idx;\n            else\n                av_log(NULL, AV_LOG_FATAL, \"Max channel mapping for output %d.%d reached\\n\",\n                       ost->file_index, ost->st->index);\n        }\n    }\n\n    return ost;\n}", "patch_func_code": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, int source_index)\n{\n    int n;\n    AVStream *st;\n    OutputStream *ost;\n    AVCodecContext *audio_enc;\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO, source_index);\n    st  = ost->st;\n\n    audio_enc = st->codec;\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n    if (!ost->stream_copy) {\n        char *sample_fmt = NULL, *filters = NULL;;\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n        if (sample_fmt &&\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n            exit_program(1);\n        }\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n        MATCH_PER_STREAM_OPT(filters, str, filters, oc, st);\n        if (filters)\n            ost->avfilter = av_strdup(filters);\n    }\n\n    return ost;\n}", "before_change_lines": [15, 28, 29, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "raw_before_change_lines": [15, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "after_change_lines": [15, 28, 29, 30], "raw_after_change_lines": [15, 28, 29, 30], "bug_lines": [15, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 194}
{"project": "ffmpeg", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "4667----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fb8e9e6b8f377af308bc40a9f3025fe9aa2b06b9_1.json----matroska_read_header", "patch_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/after_fix/ffmpeg_fb8e9e6b8f377af308bc40a9f3025fe9aa2b06b9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/ffmpeg/d2a/before_fix/ffmpeg_fb8e9e6b8f377af308bc40a9f3025fe9aa2b06b9_1.json", "function_name": "matroska_read_header", "vul_func_code": "static int\nmatroska_read_header (AVFormatContext    *s,\n                      AVFormatParameters *ap)\n{\n    MatroskaDemuxContext *matroska = s->priv_data;\n    char *doctype;\n    int version, last_level, res = 0;\n    uint32_t id;\n\n    matroska->ctx = s;\n\n    /* First read the EBML header. */\n    doctype = NULL;\n    if ((res = ebml_read_header(matroska, &doctype, &version)) < 0)\n        return res;\n    if ((doctype == NULL) || strcmp(doctype, \"matroska\")) {\n        av_log(matroska->ctx, AV_LOG_ERROR,\n               \"Wrong EBML doctype ('%s' != 'matroska').\\n\",\n               doctype ? doctype : \"(none)\");\n        if (doctype)\n            av_free(doctype);\n        return AVERROR_NOFMT;\n    }\n    av_free(doctype);\n    if (version > 2) {\n        av_log(matroska->ctx, AV_LOG_ERROR,\n               \"Matroska demuxer version 2 too old for file version %d\\n\",\n               version);\n        return AVERROR_NOFMT;\n    }\n\n    /* The next thing is a segment. */\n    while (1) {\n        if (!(id = ebml_peek_id(matroska, &last_level)))\n            return AVERROR(EIO);\n        if (id == MATROSKA_ID_SEGMENT)\n            break;\n\n        /* oi! */\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Expected a Segment ID (0x%x), but received 0x%x!\\n\",\n               MATROSKA_ID_SEGMENT, id);\n        if ((res = ebml_read_skip(matroska)) < 0)\n            return res;\n    }\n\n    /* We now have a Matroska segment.\n     * Seeks are from the beginning of the segment,\n     * after the segment ID/length. */\n    if ((res = ebml_read_master(matroska, &id)) < 0)\n        return res;\n    matroska->segment_start = url_ftell(s->pb);\n\n    matroska->time_scale = 1000000;\n    /* we've found our segment, start reading the different contents in here */\n    while (res == 0) {\n        if (!(id = ebml_peek_id(matroska, &matroska->level_up))) {\n            res = AVERROR(EIO);\n            break;\n        } else if (matroska->level_up) {\n            matroska->level_up--;\n            break;\n        }\n\n        switch (id) {\n            /* stream info */\n            case MATROSKA_ID_INFO: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_info(matroska);\n                break;\n            }\n\n            /* track info headers */\n            case MATROSKA_ID_TRACKS: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_tracks(matroska);\n                break;\n            }\n\n            /* stream index */\n            case MATROSKA_ID_CUES: {\n                if (!matroska->index_parsed) {\n                    if ((res = ebml_read_master(matroska, &id)) < 0)\n                        break;\n                    res = matroska_parse_index(matroska);\n                } else\n                    res = ebml_read_skip(matroska);\n                break;\n            }\n\n            /* metadata */\n            case MATROSKA_ID_TAGS: {\n                if (!matroska->metadata_parsed) {\n                    if ((res = ebml_read_master(matroska, &id)) < 0)\n                        break;\n                    res = matroska_parse_metadata(matroska);\n                } else\n                    res = ebml_read_skip(matroska);\n                break;\n            }\n\n            /* file index (if seekable, seek to Cues/Tags to parse it) */\n            case MATROSKA_ID_SEEKHEAD: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_seekhead(matroska);\n                break;\n            }\n\n            case MATROSKA_ID_ATTACHMENTS: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_attachments(s);\n                break;\n            }\n\n            case MATROSKA_ID_CLUSTER: {\n                /* Do not read the master - this will be done in the next\n                 * call to matroska_read_packet. */\n                res = 1;\n                break;\n            }\n\n            default:\n                av_log(matroska->ctx, AV_LOG_INFO,\n                       \"Unknown matroska file header ID 0x%x\\n\", id);\n            /* fall-through */\n\n            case EBML_ID_VOID:\n                res = ebml_read_skip(matroska);\n                break;\n        }\n\n        if (matroska->level_up) {\n            matroska->level_up--;\n            break;\n        }\n    }\n\n    /* Have we found a cluster? */\n    if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) {\n        int i, j;\n        MatroskaTrack *track;\n        AVStream *st;\n\n        for (i = 0; i < matroska->num_tracks; i++) {\n            enum CodecID codec_id = CODEC_ID_NONE;\n            uint8_t *extradata = NULL;\n            int extradata_size = 0;\n            int extradata_offset = 0;\n            track = matroska->tracks[i];\n            track->stream_index = -1;\n\n            /* Apply some sanity checks. */\n            if (track->codec_id == NULL)\n                continue;\n\n            for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n                if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n                            strlen(ff_mkv_codec_tags[j].str))){\n                    codec_id= ff_mkv_codec_tags[j].id;\n                    break;\n                }\n            }\n\n            /* Set the FourCC from the CodecID. */\n            /* This is the MS compatibility mode which stores a\n             * BITMAPINFOHEADER in the CodecPrivate. */\n            if (!strcmp(track->codec_id,\n                        MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC) &&\n                (track->codec_priv_size >= 40) &&\n                (track->codec_priv != NULL)) {\n                MatroskaVideoTrack *vtrack = (MatroskaVideoTrack *) track;\n\n                /* Offset of biCompression. Stored in LE. */\n                vtrack->fourcc = AV_RL32(track->codec_priv + 16);\n                codec_id = codec_get_id(codec_bmp_tags, vtrack->fourcc);\n\n            }\n\n            /* This is the MS compatibility mode which stores a\n             * WAVEFORMATEX in the CodecPrivate. */\n            else if (!strcmp(track->codec_id,\n                             MATROSKA_CODEC_ID_AUDIO_ACM) &&\n                (track->codec_priv_size >= 18) &&\n                (track->codec_priv != NULL)) {\n                uint16_t tag;\n\n                /* Offset of wFormatTag. Stored in LE. */\n                tag = AV_RL16(track->codec_priv);\n                codec_id = codec_get_id(codec_wav_tags, tag);\n\n            }\n\n            else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n                int profile = matroska_aac_profile(track->codec_id);\n                int sri = matroska_aac_sri(audiotrack->internal_samplerate);\n                extradata = av_malloc(5);\n                if (extradata == NULL)\n                    return AVERROR(ENOMEM);\n                extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n                extradata[1] = ((sri&0x01) << 7) | (audiotrack->channels<<3);\n                if (strstr(track->codec_id, \"SBR\")) {\n                    sri = matroska_aac_sri(audiotrack->samplerate);\n                    extradata[2] = 0x56;\n                    extradata[3] = 0xE5;\n                    extradata[4] = 0x80 | (sri<<3);\n                    extradata_size = 5;\n                } else {\n                    extradata_size = 2;\n                }\n            }\n\n            else if (codec_id == CODEC_ID_TTA) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n                ByteIOContext b;\n                extradata_size = 30;\n                extradata = av_mallocz(extradata_size);\n                if (extradata == NULL)\n                    return AVERROR(ENOMEM);\n                init_put_byte(&b, extradata, extradata_size, 1,\n                              NULL, NULL, NULL, NULL);\n                put_buffer(&b, \"TTA1\", 4);\n                put_le16(&b, 1);\n                put_le16(&b, audiotrack->channels);\n                put_le16(&b, audiotrack->bitdepth);\n                put_le32(&b, audiotrack->samplerate);\n                put_le32(&b, matroska->ctx->duration * audiotrack->samplerate);\n            }\n\n            else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n                     codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n                extradata_offset = 26;\n                track->codec_priv_size -= extradata_offset;\n            }\n\n            else if (codec_id == CODEC_ID_RA_144) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n                audiotrack->samplerate = 8000;\n                audiotrack->channels = 1;\n            }\n\n            else if (codec_id == CODEC_ID_RA_288 ||\n                     codec_id == CODEC_ID_COOK ||\n                     codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n                ByteIOContext b;\n\n                init_put_byte(&b, track->codec_priv, track->codec_priv_size, 0,\n                              NULL, NULL, NULL, NULL);\n                url_fskip(&b, 24);\n                audiotrack->coded_framesize = get_be32(&b);\n                url_fskip(&b, 12);\n                audiotrack->sub_packet_h    = get_be16(&b);\n                audiotrack->frame_size      = get_be16(&b);\n                audiotrack->sub_packet_size = get_be16(&b);\n                audiotrack->buf = av_malloc(audiotrack->frame_size * audiotrack->sub_packet_h);\n                if (codec_id == CODEC_ID_RA_288) {\n                    audiotrack->block_align = audiotrack->coded_framesize;\n                    track->codec_priv_size = 0;\n                } else {\n                    audiotrack->block_align = audiotrack->sub_packet_size;\n                    extradata_offset = 78;\n                    track->codec_priv_size -= extradata_offset;\n                }\n            }\n\n            if (codec_id == CODEC_ID_NONE) {\n                av_log(matroska->ctx, AV_LOG_INFO,\n                       \"Unknown/unsupported CodecID %s.\\n\",\n                       track->codec_id);\n            }\n\n            track->stream_index = matroska->num_streams;\n\n            matroska->num_streams++;\n            st = av_new_stream(s, track->stream_index);\n            if (st == NULL)\n                return AVERROR(ENOMEM);\n            av_set_pts_info(st, 64, matroska->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n            st->codec->codec_id = codec_id;\n            st->start_time = 0;\n            if (strcmp(track->language, \"und\"))\n                strcpy(st->language, track->language);\n\n            if (track->flags & MATROSKA_TRACK_DEFAULT)\n                st->disposition |= AV_DISPOSITION_DEFAULT;\n\n            if (track->default_duration)\n                av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,\n                          track->default_duration, 1000000000, 30000);\n\n            if(extradata){\n                st->codec->extradata = extradata;\n                st->codec->extradata_size = extradata_size;\n            } else if(track->codec_priv && track->codec_priv_size > 0){\n                st->codec->extradata = av_malloc(track->codec_priv_size);\n                if(st->codec->extradata == NULL)\n                    return AVERROR(ENOMEM);\n                st->codec->extradata_size = track->codec_priv_size;\n                memcpy(st->codec->extradata,track->codec_priv+extradata_offset,\n                       track->codec_priv_size);\n            }\n\n            if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n                MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track;\n\n                st->codec->codec_type = CODEC_TYPE_VIDEO;\n                st->codec->codec_tag = videotrack->fourcc;\n                st->codec->width = videotrack->pixel_width;\n                st->codec->height = videotrack->pixel_height;\n                if (videotrack->display_width == 0)\n                    videotrack->display_width= videotrack->pixel_width;\n                if (videotrack->display_height == 0)\n                    videotrack->display_height= videotrack->pixel_height;\n                av_reduce(&st->codec->sample_aspect_ratio.num,\n                          &st->codec->sample_aspect_ratio.den,\n                          st->codec->height * videotrack->display_width,\n                          st->codec-> width * videotrack->display_height,\n                          255);\n                st->need_parsing = AVSTREAM_PARSE_HEADERS;\n            } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n\n                st->codec->codec_type = CODEC_TYPE_AUDIO;\n                st->codec->sample_rate = audiotrack->samplerate;\n                st->codec->channels = audiotrack->channels;\n                st->codec->block_align = audiotrack->block_align;\n            } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n                st->codec->codec_type = CODEC_TYPE_SUBTITLE;\n            }\n\n            /* What do we do with private data? E.g. for Vorbis. */\n        }\n        res = 0;\n    }\n\n    if (matroska->index_parsed) {\n        int i, track, stream;\n        for (i=0; i<matroska->num_indexes; i++) {\n            MatroskaDemuxIndex *idx = &matroska->index[i];\n            track = matroska_find_track_by_num(matroska, idx->track);\n            stream = matroska->tracks[track]->stream_index;\n            if (stream >= 0)\n                av_add_index_entry(matroska->ctx->streams[stream],\n                                   idx->pos, idx->time/matroska->time_scale,\n                                   0, 0, AVINDEX_KEYFRAME);\n        }\n    }\n\n    return res;\n}", "patch_func_code": "static int\nmatroska_read_header (AVFormatContext    *s,\n                      AVFormatParameters *ap)\n{\n    MatroskaDemuxContext *matroska = s->priv_data;\n    char *doctype;\n    int version, last_level, res = 0;\n    uint32_t id;\n\n    matroska->ctx = s;\n\n    /* First read the EBML header. */\n    doctype = NULL;\n    if ((res = ebml_read_header(matroska, &doctype, &version)) < 0)\n        return res;\n    if ((doctype == NULL) || strcmp(doctype, \"matroska\")) {\n        av_log(matroska->ctx, AV_LOG_ERROR,\n               \"Wrong EBML doctype ('%s' != 'matroska').\\n\",\n               doctype ? doctype : \"(none)\");\n        if (doctype)\n            av_free(doctype);\n        return AVERROR_NOFMT;\n    }\n    av_free(doctype);\n    if (version > 2) {\n        av_log(matroska->ctx, AV_LOG_ERROR,\n               \"Matroska demuxer version 2 too old for file version %d\\n\",\n               version);\n        return AVERROR_NOFMT;\n    }\n\n    /* The next thing is a segment. */\n    while (1) {\n        if (!(id = ebml_peek_id(matroska, &last_level)))\n            return AVERROR(EIO);\n        if (id == MATROSKA_ID_SEGMENT)\n            break;\n\n        /* oi! */\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Expected a Segment ID (0x%x), but received 0x%x!\\n\",\n               MATROSKA_ID_SEGMENT, id);\n        if ((res = ebml_read_skip(matroska)) < 0)\n            return res;\n    }\n\n    /* We now have a Matroska segment.\n     * Seeks are from the beginning of the segment,\n     * after the segment ID/length. */\n    if ((res = ebml_read_master(matroska, &id)) < 0)\n        return res;\n    matroska->segment_start = url_ftell(s->pb);\n\n    matroska->time_scale = 1000000;\n    /* we've found our segment, start reading the different contents in here */\n    while (res == 0) {\n        if (!(id = ebml_peek_id(matroska, &matroska->level_up))) {\n            res = AVERROR(EIO);\n            break;\n        } else if (matroska->level_up) {\n            matroska->level_up--;\n            break;\n        }\n\n        switch (id) {\n            /* stream info */\n            case MATROSKA_ID_INFO: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_info(matroska);\n                break;\n            }\n\n            /* track info headers */\n            case MATROSKA_ID_TRACKS: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_tracks(matroska);\n                break;\n            }\n\n            /* stream index */\n            case MATROSKA_ID_CUES: {\n                if (!matroska->index_parsed) {\n                    if ((res = ebml_read_master(matroska, &id)) < 0)\n                        break;\n                    res = matroska_parse_index(matroska);\n                } else\n                    res = ebml_read_skip(matroska);\n                break;\n            }\n\n            /* metadata */\n            case MATROSKA_ID_TAGS: {\n                if (!matroska->metadata_parsed) {\n                    if ((res = ebml_read_master(matroska, &id)) < 0)\n                        break;\n                    res = matroska_parse_metadata(matroska);\n                } else\n                    res = ebml_read_skip(matroska);\n                break;\n            }\n\n            /* file index (if seekable, seek to Cues/Tags to parse it) */\n            case MATROSKA_ID_SEEKHEAD: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_seekhead(matroska);\n                break;\n            }\n\n            case MATROSKA_ID_ATTACHMENTS: {\n                if ((res = ebml_read_master(matroska, &id)) < 0)\n                    break;\n                res = matroska_parse_attachments(s);\n                break;\n            }\n\n            case MATROSKA_ID_CLUSTER: {\n                /* Do not read the master - this will be done in the next\n                 * call to matroska_read_packet. */\n                res = 1;\n                break;\n            }\n\n            default:\n                av_log(matroska->ctx, AV_LOG_INFO,\n                       \"Unknown matroska file header ID 0x%x\\n\", id);\n            /* fall-through */\n\n            case EBML_ID_VOID:\n                res = ebml_read_skip(matroska);\n                break;\n        }\n\n        if (matroska->level_up) {\n            matroska->level_up--;\n            break;\n        }\n    }\n\n    /* Have we found a cluster? */\n    if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) {\n        int i, j;\n        MatroskaTrack *track;\n        AVStream *st;\n\n        for (i = 0; i < matroska->num_tracks; i++) {\n            enum CodecID codec_id = CODEC_ID_NONE;\n            uint8_t *extradata = NULL;\n            int extradata_size = 0;\n            int extradata_offset = 0;\n            track = matroska->tracks[i];\n            track->stream_index = -1;\n\n            /* Apply some sanity checks. */\n            if (track->codec_id == NULL)\n                continue;\n\n            for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n                if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n                            strlen(ff_mkv_codec_tags[j].str))){\n                    codec_id= ff_mkv_codec_tags[j].id;\n                    break;\n                }\n            }\n\n            /* Set the FourCC from the CodecID. */\n            /* This is the MS compatibility mode which stores a\n             * BITMAPINFOHEADER in the CodecPrivate. */\n            if (!strcmp(track->codec_id,\n                        MATROSKA_CODEC_ID_VIDEO_VFW_FOURCC) &&\n                (track->codec_priv_size >= 40) &&\n                (track->codec_priv != NULL)) {\n                MatroskaVideoTrack *vtrack = (MatroskaVideoTrack *) track;\n\n                /* Offset of biCompression. Stored in LE. */\n                vtrack->fourcc = AV_RL32(track->codec_priv + 16);\n                codec_id = codec_get_id(codec_bmp_tags, vtrack->fourcc);\n\n            }\n\n            /* This is the MS compatibility mode which stores a\n             * WAVEFORMATEX in the CodecPrivate. */\n            else if (!strcmp(track->codec_id,\n                             MATROSKA_CODEC_ID_AUDIO_ACM) &&\n                (track->codec_priv_size >= 18) &&\n                (track->codec_priv != NULL)) {\n                uint16_t tag;\n\n                /* Offset of wFormatTag. Stored in LE. */\n                tag = AV_RL16(track->codec_priv);\n                codec_id = codec_get_id(codec_wav_tags, tag);\n\n            }\n\n            else if (codec_id == CODEC_ID_AAC && !track->codec_priv_size) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n                int profile = matroska_aac_profile(track->codec_id);\n                int sri = matroska_aac_sri(audiotrack->internal_samplerate);\n                extradata = av_malloc(5);\n                if (extradata == NULL)\n                    return AVERROR(ENOMEM);\n                extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n                extradata[1] = ((sri&0x01) << 7) | (audiotrack->channels<<3);\n                if (strstr(track->codec_id, \"SBR\")) {\n                    sri = matroska_aac_sri(audiotrack->samplerate);\n                    extradata[2] = 0x56;\n                    extradata[3] = 0xE5;\n                    extradata[4] = 0x80 | (sri<<3);\n                    extradata_size = 5;\n                } else {\n                    extradata_size = 2;\n                }\n            }\n\n            else if (codec_id == CODEC_ID_TTA) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;\n                ByteIOContext b;\n                extradata_size = 30;\n                extradata = av_mallocz(extradata_size);\n                if (extradata == NULL)\n                    return AVERROR(ENOMEM);\n                init_put_byte(&b, extradata, extradata_size, 1,\n                              NULL, NULL, NULL, NULL);\n                put_buffer(&b, \"TTA1\", 4);\n                put_le16(&b, 1);\n                put_le16(&b, audiotrack->channels);\n                put_le16(&b, audiotrack->bitdepth);\n                put_le32(&b, audiotrack->samplerate);\n                put_le32(&b, matroska->ctx->duration * audiotrack->samplerate);\n            }\n\n            else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n                     codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n                extradata_offset = 26;\n                track->codec_priv_size -= extradata_offset;\n            }\n\n            else if (codec_id == CODEC_ID_RA_144) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n                audiotrack->samplerate = 8000;\n                audiotrack->channels = 1;\n            }\n\n            else if (codec_id == CODEC_ID_RA_288 ||\n                     codec_id == CODEC_ID_COOK ||\n                     codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n                ByteIOContext b;\n\n                init_put_byte(&b, track->codec_priv, track->codec_priv_size, 0,\n                              NULL, NULL, NULL, NULL);\n                url_fskip(&b, 24);\n                audiotrack->coded_framesize = get_be32(&b);\n                url_fskip(&b, 12);\n                audiotrack->sub_packet_h    = get_be16(&b);\n                audiotrack->frame_size      = get_be16(&b);\n                audiotrack->sub_packet_size = get_be16(&b);\n                audiotrack->buf = av_malloc(audiotrack->frame_size * audiotrack->sub_packet_h);\n                if (codec_id == CODEC_ID_RA_288) {\n                    audiotrack->block_align = audiotrack->coded_framesize;\n                    track->codec_priv_size = 0;\n                } else {\n                    audiotrack->block_align = audiotrack->sub_packet_size;\n                    extradata_offset = 78;\n                    track->codec_priv_size -= extradata_offset;\n                }\n            }\n\n            if (codec_id == CODEC_ID_NONE) {\n                av_log(matroska->ctx, AV_LOG_INFO,\n                       \"Unknown/unsupported CodecID %s.\\n\",\n                       track->codec_id);\n            }\n\n            track->stream_index = matroska->num_streams;\n\n            matroska->num_streams++;\n            st = av_new_stream(s, track->stream_index);\n            if (st == NULL)\n                return AVERROR(ENOMEM);\n            av_set_pts_info(st, 64, matroska->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n            st->codec->codec_id = codec_id;\n            st->start_time = 0;\n            if (strcmp(track->language, \"und\"))\n                strcpy(st->language, track->language);\n\n            if (track->flags & MATROSKA_TRACK_DEFAULT)\n                st->disposition |= AV_DISPOSITION_DEFAULT;\n\n            if (track->default_duration)\n                av_reduce(&st->codec->time_base.num, &st->codec->time_base.den,\n                          track->default_duration, 1000000000, 30000);\n\n            if(extradata){\n                st->codec->extradata = extradata;\n                st->codec->extradata_size = extradata_size;\n            } else if(track->codec_priv && track->codec_priv_size > 0){\n                st->codec->extradata = av_malloc(track->codec_priv_size);\n                if(st->codec->extradata == NULL)\n                    return AVERROR(ENOMEM);\n                st->codec->extradata_size = track->codec_priv_size;\n                memcpy(st->codec->extradata,track->codec_priv+extradata_offset,\n                       track->codec_priv_size);\n            }\n\n            if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n                MatroskaVideoTrack *videotrack = (MatroskaVideoTrack *)track;\n\n                st->codec->codec_type = CODEC_TYPE_VIDEO;\n                st->codec->codec_tag = videotrack->fourcc;\n                st->codec->width = videotrack->pixel_width;\n                st->codec->height = videotrack->pixel_height;\n                if (videotrack->display_width == 0)\n                    videotrack->display_width= videotrack->pixel_width;\n                if (videotrack->display_height == 0)\n                    videotrack->display_height= videotrack->pixel_height;\n                av_reduce(&st->codec->sample_aspect_ratio.num,\n                          &st->codec->sample_aspect_ratio.den,\n                          st->codec->height * videotrack->display_width,\n                          st->codec-> width * videotrack->display_height,\n                          255);\n                st->need_parsing = AVSTREAM_PARSE_HEADERS;\n            } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)track;\n\n                st->codec->codec_type = CODEC_TYPE_AUDIO;\n                st->codec->sample_rate = audiotrack->samplerate;\n                st->codec->channels = audiotrack->channels;\n                st->codec->block_align = audiotrack->block_align;\n            } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n                st->codec->codec_type = CODEC_TYPE_SUBTITLE;\n            }\n\n            /* What do we do with private data? E.g. for Vorbis. */\n        }\n        res = 0;\n    }\n\n    if (matroska->index_parsed) {\n        int i, track, stream;\n        for (i=0; i<matroska->num_indexes; i++) {\n            MatroskaDemuxIndex *idx = &matroska->index[i];\n            track = matroska_find_track_by_num(matroska, idx->track);\n            stream = matroska->tracks[track]->stream_index;\n            if (stream >= 0 && stream < matroska->ctx->nb_streams)\n                av_add_index_entry(matroska->ctx->streams[stream],\n                                   idx->pos, idx->time/matroska->time_scale,\n                                   0, 0, AVINDEX_KEYFRAME);\n        }\n    }\n\n    return res;\n}", "before_change_lines": [348], "raw_before_change_lines": [348], "after_change_lines": [348], "raw_after_change_lines": [348], "bug_lines": [348], "added": [false], "idx": 195}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "4750----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_11057f2e6181938df1381676fddec3806d28be7e_1.json----mkhash", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_11057f2e6181938df1381676fddec3806d28be7e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_11057f2e6181938df1381676fddec3806d28be7e_1.json", "function_name": "mkhash", "vul_func_code": "int mkhash(struct passwd_ctx *ctx)\n{\n    char *pw;\n    char pwin[MAX_STRING_LEN];\n    char salt[16];\n    apr_status_t rv;\n    int ret = 0;\n#if CRYPT_ALGO_SUPPORTED\n    char *cbuf;\n#endif\n\n    if (ctx->cost != 0 && ctx->alg != ALG_BCRYPT) {\n        apr_file_printf(errfile,\n                        \"Warning: Ignoring -C argument for this algorithm.\" NL);\n    }\n\n    if (ctx->passwd != NULL) {\n        pw = ctx->passwd;\n    }\n    else {\n        if ((ret = get_password(ctx)) != 0)\n            return ret;\n        pw = pwin;\n    }\n\n    switch (ctx->alg) {\n    case ALG_APSHA:\n        /* XXX out >= 28 + strlen(sha1) chars - fixed len SHA */\n        apr_sha1_base64(pw, strlen(pw), ctx->out);\n        break;\n\n    case ALG_APMD5:\n        ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool);\n        if (ret != 0)\n            break;\n        rv = apr_md5_encode(pw, salt, ctx->out, ctx->out_len);\n        if (rv != APR_SUCCESS) {\n            ctx->errstr = apr_psprintf(ctx->pool,\n                                       \"could not encode password: %pm\", &rv);\n            ret = ERR_GENERAL;\n        }\n        break;\n\n    case ALG_PLAIN:\n        /* XXX this len limitation is not in sync with any HTTPd len. */\n        apr_cpystrn(ctx->out, pw, ctx->out_len);\n        break;\n\n#if CRYPT_ALGO_SUPPORTED\n    case ALG_CRYPT:\n        ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool);\n        if (ret != 0)\n            break;\n        cbuf = crypt(pw, salt);\n        if (cbuf == NULL) {\n            rv = APR_FROM_OS_ERROR(errno);\n            ctx->errstr = apr_psprintf(ctx->pool, \"crypt() failed: %pm\", &rv);\n            ret = ERR_PWMISMATCH;\n            break;\n        }\n\n        apr_cpystrn(ctx->out, cbuf, ctx->out_len - 1);\n        if (strlen(pw) > 8) {\n            char *truncpw = strdup(pw);\n            if (truncpw == NULL)\n                abort_on_oom(0);\n            truncpw[8] = '\\0';\n            if (!strcmp(ctx->out, crypt(truncpw, salt))) {\n                apr_file_printf(errfile, \"Warning: Password truncated to 8 \"\n                                \"characters by CRYPT algorithm.\" NL);\n            }\n            memset(truncpw, '\\0', strlen(pw));\n            free(truncpw);\n        }\n        break;\n#endif /* CRYPT_ALGO_SUPPORTED */\n\n#if BCRYPT_ALGO_SUPPORTED\n    case ALG_BCRYPT:\n        rv = apr_generate_random_bytes((unsigned char*)salt, 16);\n        if (rv != APR_SUCCESS) {\n            ctx->errstr = apr_psprintf(ctx->pool, \"Unable to generate random \"\n                                       \"bytes: %pm\", &rv);\n            ret = ERR_RANDOM;\n            break;\n        }\n\n        if (ctx->cost == 0)\n            ctx->cost = BCRYPT_DEFAULT_COST;\n        rv = apr_bcrypt_encode(pw, ctx->cost, (unsigned char*)salt, 16,\n                               ctx->out, ctx->out_len);\n        if (rv != APR_SUCCESS) {\n            ctx->errstr = apr_psprintf(ctx->pool, \"Unable to encode with \"\n                                       \"bcrypt: %pm\", &rv);\n            ret = ERR_PWMISMATCH;\n            break;\n        }\n        break;\n#endif /* BCRYPT_ALGO_SUPPORTED */\n\n    default:\n        apr_file_printf(errfile, \"mkhash(): BUG: invalid algorithm %d\",\n                        ctx->alg);\n        abort();\n    }\n    memset(pw, '\\0', strlen(pw));\n    return ret;\n}", "patch_func_code": "int mkhash(struct passwd_ctx *ctx)\n{\n    char *pw;\n    char salt[16];\n    apr_status_t rv;\n    int ret = 0;\n#if CRYPT_ALGO_SUPPORTED\n    char *cbuf;\n#endif\n\n    if (ctx->cost != 0 && ctx->alg != ALG_BCRYPT) {\n        apr_file_printf(errfile,\n                        \"Warning: Ignoring -C argument for this algorithm.\" NL);\n    }\n\n    if (ctx->passwd == NULL) {\n        if ((ret = get_password(ctx)) != 0)\n            return ret;\n    }\n    pw = ctx->passwd;\n\n    switch (ctx->alg) {\n    case ALG_APSHA:\n        /* XXX out >= 28 + strlen(sha1) chars - fixed len SHA */\n        apr_sha1_base64(pw, strlen(pw), ctx->out);\n        break;\n\n    case ALG_APMD5:\n        ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool);\n        if (ret != 0)\n            break;\n        rv = apr_md5_encode(pw, salt, ctx->out, ctx->out_len);\n        if (rv != APR_SUCCESS) {\n            ctx->errstr = apr_psprintf(ctx->pool,\n                                       \"could not encode password: %pm\", &rv);\n            ret = ERR_GENERAL;\n        }\n        break;\n\n    case ALG_PLAIN:\n        /* XXX this len limitation is not in sync with any HTTPd len. */\n        apr_cpystrn(ctx->out, pw, ctx->out_len);\n        break;\n\n#if CRYPT_ALGO_SUPPORTED\n    case ALG_CRYPT:\n        ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool);\n        if (ret != 0)\n            break;\n        cbuf = crypt(pw, salt);\n        if (cbuf == NULL) {\n            rv = APR_FROM_OS_ERROR(errno);\n            ctx->errstr = apr_psprintf(ctx->pool, \"crypt() failed: %pm\", &rv);\n            ret = ERR_PWMISMATCH;\n            break;\n        }\n\n        apr_cpystrn(ctx->out, cbuf, ctx->out_len - 1);\n        if (strlen(pw) > 8) {\n            char *truncpw = apr_pstrdup(ctx->pool, pw);\n            truncpw[8] = '\\0';\n            if (!strcmp(ctx->out, crypt(truncpw, salt))) {\n                apr_file_printf(errfile, \"Warning: Password truncated to 8 \"\n                                \"characters by CRYPT algorithm.\" NL);\n            }\n            memset(truncpw, '\\0', strlen(pw));\n            free(truncpw);\n        }\n        break;\n#endif /* CRYPT_ALGO_SUPPORTED */\n\n#if BCRYPT_ALGO_SUPPORTED\n    case ALG_BCRYPT:\n        rv = apr_generate_random_bytes((unsigned char*)salt, 16);\n        if (rv != APR_SUCCESS) {\n            ctx->errstr = apr_psprintf(ctx->pool, \"Unable to generate random \"\n                                       \"bytes: %pm\", &rv);\n            ret = ERR_RANDOM;\n            break;\n        }\n\n        if (ctx->cost == 0)\n            ctx->cost = BCRYPT_DEFAULT_COST;\n        rv = apr_bcrypt_encode(pw, ctx->cost, (unsigned char*)salt, 16,\n                               ctx->out, ctx->out_len);\n        if (rv != APR_SUCCESS) {\n            ctx->errstr = apr_psprintf(ctx->pool, \"Unable to encode with \"\n                                       \"bcrypt: %pm\", &rv);\n            ret = ERR_PWMISMATCH;\n            break;\n        }\n        break;\n#endif /* BCRYPT_ALGO_SUPPORTED */\n\n    default:\n        apr_file_printf(errfile, \"mkhash(): BUG: invalid algorithm %d\",\n                        ctx->alg);\n        abort();\n    }\n    memset(pw, '\\0', strlen(pw));\n    return ret;\n}", "before_change_lines": [4, 17, 18, 19, 20, 23, 64, 65, 66], "raw_before_change_lines": [4, 17, 18, 19, 20, 23, 64, 65, 66], "after_change_lines": [16, 20, 60], "raw_after_change_lines": [16, 20, 60], "bug_lines": [4, 17, 18, 19, 20, 23, 64, 65, 66], "added": [false, false, false, false, false, false, false, false, false], "idx": 196}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "4768----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_1dd753b9ef6163f85ec8b70eb1067df599e212ba_1.json----remove_any_filter", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_1dd753b9ef6163f85ec8b70eb1067df599e212ba_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_1dd753b9ef6163f85ec8b70eb1067df599e212ba_1.json", "function_name": "remove_any_filter", "vul_func_code": "static void remove_any_filter(ap_filter_t *f, ap_filter_t **r_filt, ap_filter_t **p_filt,\n                              ap_filter_t **c_filt)\n{\n    ap_filter_t **curr = r_filt ? r_filt : c_filt;\n    ap_filter_t *fscan = *curr;\n\n    if (is_pending_filter(f)) {\n        apr_pool_cleanup_run(f->r ? f->r->pool : f->c->pool,\n                             f, pending_filter_cleanup);\n    }\n\n    if (p_filt && *p_filt == f)\n        *p_filt = (*p_filt)->next;\n\n    if (*curr == f) {\n        *curr = (*curr)->next;\n        return;\n    }\n\n    while (fscan->next != f) {\n        if (!(fscan = fscan->next)) {\n            return;\n        }\n    }\n\n    fscan->next = f->next;\n}", "patch_func_code": "static void remove_any_filter(ap_filter_t *f, ap_filter_t **r_filt, ap_filter_t **p_filt,\n                              ap_filter_t **c_filt)\n{\n    ap_filter_t **curr = r_filt ? r_filt : c_filt;\n    ap_filter_t *fscan = *curr;\n\n    pending_filter_cleanup(f);\n\n    if (p_filt && *p_filt == f)\n        *p_filt = (*p_filt)->next;\n\n    if (*curr == f) {\n        *curr = (*curr)->next;\n        return;\n    }\n\n    while (fscan->next != f) {\n        if (!(fscan = fscan->next)) {\n            return;\n        }\n    }\n\n    fscan->next = f->next;\n}", "before_change_lines": [7, 8, 9, 10], "raw_before_change_lines": [7, 8, 9, 10], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7, 8, 9, 10], "added": [false, false, false, false], "idx": 197}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "4794----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_3a21065b68f4a4dbb3f45c35d3bd287381a03357_1.json----start_threads", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_3a21065b68f4a4dbb3f45c35d3bd287381a03357_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_3a21065b68f4a4dbb3f45c35d3bd287381a03357_1.json", "function_name": "start_threads", "vul_func_code": "static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void *dummy)\n{\n    thread_starter *ts = dummy;\n    apr_thread_t **threads = ts->threads;\n    apr_threadattr_t *thread_attr = ts->threadattr;\n    int child_num_arg = ts->child_num_arg;\n    int my_child_num = child_num_arg;\n    proc_info *my_info;\n    apr_status_t rv;\n    int i;\n    int threads_created = 0;\n    int listener_started = 0;\n    int loops;\n    int prev_threads_created;\n    int max_recycled_pools = -1;\n\n    /* We must create the fd queues before we start up the listener\n     * and worker threads. */\n    worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue));\n    rv = ap_queue_init(worker_queue, threads_per_child, pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                     \"ap_queue_init() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) {\n        /* If we want to conserve memory, let's not keep an unlimited number of\n         * pools & allocators.\n         * XXX: This should probably be a separate config directive\n         */\n        max_recycled_pools = threads_per_child * 3 / 4 ;\n    }\n    rv = ap_queue_info_create(&worker_queue_info, pchild,\n                              threads_per_child, max_recycled_pools);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                     \"ap_queue_info_create() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    /* Create the main pollset */\n    rv = apr_pollset_create(&event_pollset,\n                            threads_per_child, /* XXX don't we need more, to handle\n                                                * connections in K-A or lingering\n                                                * close?\n                                                */\n                            pchild, APR_POLLSET_WAKEABLE|APR_POLLSET_NOCOPY);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,\n                     \"apr_pollset_create failed; check system or user limits\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    worker_sockets = apr_pcalloc(pchild, threads_per_child\n                                 * sizeof(apr_socket_t *));\n\n    worker_equeues = apr_palloc(pchild, threads_per_child * sizeof(ap_equeue_t*));\n\n    for (i = 0; i < threads_per_child; i++) {\n        ap_equeue_t* eq = NULL;\n        /* TODO: research/test optimal size of queue here */\n        ap_equeue_create(pchild, 16, sizeof(pollset_op_t), &eq);\n        /* same as thread ID */\n        worker_equeues[i] = eq;\n    }\n\n    loops = prev_threads_created = 0;\n    while (1) {\n        /* threads_per_child does not include the listener thread */\n        for (i = 0; i < threads_per_child; i++) {\n            int status =\n                ap_scoreboard_image->servers[child_num_arg][i].status;\n\n            if (status != SERVER_GRACEFUL && status != SERVER_DEAD) {\n                continue;\n            }\n\n            my_info = (proc_info *) ap_malloc(sizeof(proc_info));\n            my_info->pid = my_child_num;\n            my_info->tid = i;\n            my_info->sd = 0;\n\n            /* We are creating threads right now */\n            ap_update_child_status_from_indexes(my_child_num, i,\n                                                SERVER_STARTING, NULL);\n            /* We let each thread update its own scoreboard entry.  This is\n             * done because it lets us deal with tid better.\n             */\n            rv = apr_thread_create(&threads[i], thread_attr,\n                                   worker_thread, my_info, pchild);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                             \"apr_thread_create: unable to create worker thread\");\n                /* let the parent decide how bad this really is */\n                clean_child_exit(APEXIT_CHILDSICK);\n            }\n            threads_created++;\n        }\n\n        /* Start the listener only when there are workers available */\n        if (!listener_started && threads_created) {\n            create_listener_thread(ts);\n            listener_started = 1;\n        }\n\n\n        if (start_thread_may_exit || threads_created == threads_per_child) {\n            break;\n        }\n        /* wait for previous generation to clean up an entry */\n        apr_sleep(apr_time_from_sec(1));\n        ++loops;\n        if (loops % 120 == 0) { /* every couple of minutes */\n            if (prev_threads_created == threads_created) {\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                             \"child %\" APR_PID_T_FMT \" isn't taking over \"\n                             \"slots very quickly (%d of %d)\",\n                             ap_my_pid, threads_created,\n                             threads_per_child);\n            }\n            prev_threads_created = threads_created;\n        }\n    }\n\n    /* What state should this child_main process be listed as in the\n     * scoreboard...?\n     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,\n     *                                      (request_rec *) NULL);\n     *\n     *  This state should be listed separately in the scoreboard, in some kind\n     *  of process_status, not mixed in with the worker threads' status.\n     *  \"life_status\" is almost right, but it's in the worker's structure, and\n     *  the name could be clearer.   gla\n     */\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}", "patch_func_code": "static void *APR_THREAD_FUNC start_threads(apr_thread_t * thd, void *dummy)\n{\n    thread_starter *ts = dummy;\n    apr_thread_t **threads = ts->threads;\n    apr_threadattr_t *thread_attr = ts->threadattr;\n    int child_num_arg = ts->child_num_arg;\n    int my_child_num = child_num_arg;\n    proc_info *my_info;\n    apr_status_t rv;\n    int i;\n    int threads_created = 0;\n    int listener_started = 0;\n    int loops;\n    int prev_threads_created;\n    int max_recycled_pools = -1;\n\n    /* We must create the fd queues before we start up the listener\n     * and worker threads. */\n    worker_queue = apr_pcalloc(pchild, sizeof(*worker_queue));\n    rv = ap_queue_init(worker_queue, threads_per_child, pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                     \"ap_queue_init() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    if (ap_max_mem_free != APR_ALLOCATOR_MAX_FREE_UNLIMITED) {\n        /* If we want to conserve memory, let's not keep an unlimited number of\n         * pools & allocators.\n         * XXX: This should probably be a separate config directive\n         */\n        max_recycled_pools = threads_per_child * 3 / 4 ;\n    }\n    rv = ap_queue_info_create(&worker_queue_info, pchild,\n                              threads_per_child, max_recycled_pools);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                     \"ap_queue_info_create() failed\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    /* Create the timeout mutex and main pollset before the listener\n     * thread starts.\n     */\n    rv = apr_thread_mutex_create(&timeout_mutex, APR_THREAD_MUTEX_DEFAULT,\n                                 pchild);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,\n                     \"creation of the timeout mutex failed.\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    /* Create the main pollset */\n    rv = apr_pollset_create(&event_pollset,\n                            threads_per_child, /* XXX don't we need more, to handle\n                                                * connections in K-A or lingering\n                                                * close?\n                                                */\n                            pchild, APR_POLLSET_THREADSAFE | APR_POLLSET_NOCOPY);\n    if (rv != APR_SUCCESS) {\n        ap_log_error(APLOG_MARK, APLOG_ERR, rv, ap_server_conf,\n                     \"apr_pollset_create with Thread Safety failed.\");\n        clean_child_exit(APEXIT_CHILDFATAL);\n    }\n\n    worker_sockets = apr_pcalloc(pchild, threads_per_child\n                                 * sizeof(apr_socket_t *));\n\n    loops = prev_threads_created = 0;\n    while (1) {\n        /* threads_per_child does not include the listener thread */\n        for (i = 0; i < threads_per_child; i++) {\n            int status =\n                ap_scoreboard_image->servers[child_num_arg][i].status;\n\n            if (status != SERVER_GRACEFUL && status != SERVER_DEAD) {\n                continue;\n            }\n\n            my_info = (proc_info *) ap_malloc(sizeof(proc_info));\n            my_info->pid = my_child_num;\n            my_info->tid = i;\n            my_info->sd = 0;\n\n            /* We are creating threads right now */\n            ap_update_child_status_from_indexes(my_child_num, i,\n                                                SERVER_STARTING, NULL);\n            /* We let each thread update its own scoreboard entry.  This is\n             * done because it lets us deal with tid better.\n             */\n            rv = apr_thread_create(&threads[i], thread_attr,\n                                   worker_thread, my_info, pchild);\n            if (rv != APR_SUCCESS) {\n                ap_log_error(APLOG_MARK, APLOG_ALERT, rv, ap_server_conf,\n                             \"apr_thread_create: unable to create worker thread\");\n                /* let the parent decide how bad this really is */\n                clean_child_exit(APEXIT_CHILDSICK);\n            }\n            threads_created++;\n        }\n\n        /* Start the listener only when there are workers available */\n        if (!listener_started && threads_created) {\n            create_listener_thread(ts);\n            listener_started = 1;\n        }\n\n\n        if (start_thread_may_exit || threads_created == threads_per_child) {\n            break;\n        }\n        /* wait for previous generation to clean up an entry */\n        apr_sleep(apr_time_from_sec(1));\n        ++loops;\n        if (loops % 120 == 0) { /* every couple of minutes */\n            if (prev_threads_created == threads_created) {\n                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,\n                             \"child %\" APR_PID_T_FMT \" isn't taking over \"\n                             \"slots very quickly (%d of %d)\",\n                             ap_my_pid, threads_created,\n                             threads_per_child);\n            }\n            prev_threads_created = threads_created;\n        }\n    }\n\n    /* What state should this child_main process be listed as in the\n     * scoreboard...?\n     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,\n     *                                      (request_rec *) NULL);\n     *\n     *  This state should be listed separately in the scoreboard, in some kind\n     *  of process_status, not mixed in with the worker threads' status.\n     *  \"life_status\" is almost right, but it's in the worker's structure, and\n     *  the name could be clearer.   gla\n     */\n    apr_thread_exit(thd, APR_SUCCESS);\n    return NULL;\n}", "before_change_lines": [48, 51, 58, 60, 61, 63, 65, 66], "raw_before_change_lines": [48, 51, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67], "after_change_lines": [43, 44, 45, 46, 47, 48, 49, 50, 51, 59, 62], "raw_after_change_lines": [42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 59, 62], "bug_lines": [48, 51, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 198}
{"project": "httpd", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4810----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_4ab9ec895c0e9fc23db97c4ee05c5a90aea7d53c_1.json----close_connection", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_4ab9ec895c0e9fc23db97c4ee05c5a90aea7d53c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_4ab9ec895c0e9fc23db97c4ee05c5a90aea7d53c_1.json", "function_name": "close_connection", "vul_func_code": "static void close_connection(struct connection * c)\n{\n    if (c->read == 0 && c->keepalive) {\n        /*\n         * server has legitimately shut down an idle keep alive request\n         */\n        if (good)\n            good--;     /* connection never happened */\n    }\n    else {\n        if (good == 1) {\n            /* first time here */\n            doclen = c->bread;\n        }\n        else if (c->bread != doclen) {\n            bad++;\n            err_length++;\n        }\n        /* save out time */\n        if (done < requests) {\n            struct data s;\n            if ((done) && heartbeatres && !(done % heartbeatres)) {\n                fprintf(stderr, \"Completed %ld requests\\n\", done);\n                fflush(stderr);\n            }\n            c->done = apr_time_now();\n            s.read = c->read;\n            s.starttime = c->start;\n            s.ctime = ap_max(0, (c->connect - c->start) / 1000);\n            s.time = ap_max(0, (c->done - c->start) / 1000);\n            s.waittime = ap_max(0, (c->beginread - c->endwrite) / 1000);\n            stats[done++] = s;\n        }\n    }\n\n    {\n        apr_pollfd_t remove_pollfd;\n        remove_pollfd.desc_type = APR_POLL_SOCKET;\n        remove_pollfd.desc.s = c->aprsock;\n        apr_pollset_remove(readbits, &remove_pollfd);\n#ifdef USE_SSL\n        if (c->ssl) {\n            SSL_shutdown(c->ssl);\n            SSL_free(c->ssl);\n            c->ssl = NULL;\n        }\n#endif\n        apr_socket_close(c->aprsock);\n    }\n    c->state = STATE_UNCONNECTED;\n\n    /* connect again */\n    start_connect(c);\n    return;\n}", "patch_func_code": "static void close_connection(struct connection * c)\n{\n    if (c->read == 0 && c->keepalive) {\n        /*\n         * server has legitimately shut down an idle keep alive request\n         */\n        if (good)\n            good--;     /* connection never happened */\n    }\n    else {\n        if (good == 1) {\n            /* first time here */\n            doclen = c->bread;\n        }\n        else if (c->bread != doclen) {\n            bad++;\n            err_length++;\n        }\n        /* save out time */\n        if (done < requests) {\n            struct data *s = &stats[done++];\n            c->done      = lasttime = apr_time_now();\n            s->starttime = c->start;\n            s->ctime     = ap_max(0, c->connect - c->start);\n            s->time      = ap_max(0, c->done - c->start);\n            s->waittime  = ap_max(0, c->beginread - c->endwrite);\n            if (heartbeatres && !(done % heartbeatres)) {\n                fprintf(stderr, \"Completed %d requests\\n\", done);\n                fflush(stderr);\n            }\n        }\n    }\n\n    {\n        apr_pollfd_t remove_pollfd;\n        remove_pollfd.desc_type = APR_POLL_SOCKET;\n        remove_pollfd.desc.s = c->aprsock;\n        apr_pollset_remove(readbits, &remove_pollfd);\n#ifdef USE_SSL\n        if (c->ssl) {\n            SSL_shutdown(c->ssl);\n            SSL_free(c->ssl);\n            c->ssl = NULL;\n        }\n#endif\n        apr_socket_close(c->aprsock);\n    }\n    c->state = STATE_UNCONNECTED;\n\n    /* connect again */\n    start_connect(c);\n    return;\n}", "before_change_lines": [21, 22, 23, 26, 27, 28, 29, 30, 31, 32], "raw_before_change_lines": [21, 22, 23, 26, 27, 28, 29, 30, 31, 32], "after_change_lines": [21, 22, 23, 24, 25, 26, 27, 28], "raw_after_change_lines": [21, 22, 23, 24, 25, 26, 27, 28], "bug_lines": [21, 22, 23, 26, 27, 28, 29, 30, 31, 32], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 199}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "4855----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_862c138fb262c4729661ef8db4144b5411ac1321_1.json----ap_get_mime_headers_core", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_862c138fb262c4729661ef8db4144b5411ac1321_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_862c138fb262c4729661ef8db4144b5411ac1321_1.json", "function_name": "ap_get_mime_headers_core", "vul_func_code": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb)\n{\n    char *last_field = NULL;\n    apr_size_t last_len = 0;\n    apr_size_t alloc_len = 0;\n    char *field;\n    char *value;\n    apr_size_t len;\n    int fields_read = 0;\n    char *tmp_field;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else {\n                r->status = HTTP_BAD_REQUEST;\n            }\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC) {\n                const char *field_escaped;\n                if (field && len) {\n                    /* ensure ap_escape_html will terminate correctly */\n                    field[len - 1] = '\\0';\n                    field_escaped = ap_escape_html(r->pool, field);\n                }\n                else {\n                    field_escaped = field = \"\";\n                }\n\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_psprintf(r->pool,\n                                           \"Size of a request header field \"\n                                           \"exceeds server limit.<br />\\n\"\n                                           \"<pre>\\n%.*s\\n</pre>\\n\", \n                                           field_name_len(field_escaped),\n                                           field_escaped));\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)\n                              \"Request header exceeds LimitRequestFieldSize%s\"\n                              \"%.*s\",\n                              *field ? \": \" : \"\",\n                              field_name_len(field), field);\n            }\n            return;\n        }\n\n        if ((*field == '\\t') || *field == ' ') {\n\n            /* Append any newly-read obs-fold line onto the preceding\n             * last_field line we are processing\n             */\n            apr_size_t fold_len;\n\n            if (last_field == NULL) {\n                r->status = HTTP_BAD_REQUEST;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03442)\n                              \"Line folding encounterd before first\"\n                              \" header line\");\n                return;\n            }\n\n            /* This line is a continuation of the preceding line(s),\n             * so append it to the line that we've set aside.\n             * Note: this uses a power-of-two allocator to avoid\n             * doing O(n) allocs and using O(n^2) space for\n             * continuations that span many many lines.\n             */\n            fold_len = last_len + len + 1; /* trailing null */\n\n            if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n                const char *field_escaped;\n\n                r->status = HTTP_BAD_REQUEST;\n                /* report what we have accumulated so far before the\n                 * overflow (last_field) as the field with the problem\n                 */\n                field_escaped = ap_escape_html(r->pool, last_field);\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_psprintf(r->pool,\n                                            \"Size of a request header field \"\n                                            \"after folding \"\n                                            \"exceeds server limit.<br />\\n\"\n                                            \"<pre>\\n%.*s\\n</pre>\\n\", \n                                            field_name_len(field_escaped), \n                                            field_escaped));\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562)\n                              \"Request header exceeds LimitRequestFieldSize \"\n                              \"after folding: %.*s\",\n                              field_name_len(last_field), last_field);\n                return;\n            }\n\n            if (fold_len > alloc_len) {\n                char *fold_buf;\n                alloc_len += alloc_len;\n                if (fold_len > alloc_len) {\n                    alloc_len = fold_len;\n                }\n                fold_buf = (char *)apr_palloc(r->pool, alloc_len);\n                memcpy(fold_buf, last_field, last_len);\n                last_field = fold_buf;\n            }\n            memcpy(last_field + last_len, field, len +1); /* +1 for nul */\n            /* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n            if (conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT) {\n                last_field[last_len] = ' ';\n            }\n            last_len += len;\n\n            /* We've appended this obs-fold line to last_len, proceed to\n             * read the next input line\n             */\n            continue;\n        }\n        else if (last_field != NULL) {\n\n            /* Process the previous last_field header line with all obs-folded\n             * segments already concatinated (this is not operating on the\n             * most recently read input line).\n             */\n\n            if (r->server->limit_req_fields\n                    && (++fields_read > r->server->limit_req_fields)) {\n                r->status = HTTP_BAD_REQUEST;\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"The number of request header fields \"\n                               \"exceeds this server's limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563)\n                              \"Number of request headers exceeds \"\n                              \"LimitRequestFields\");\n                return;\n            }\n\n            if (!(conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT))\n            {\n                /* Not Strict, using the legacy parser */\n\n                if (!(value = strchr(last_field, ':'))) { /* Find ':' or */\n                    r->status = HTTP_BAD_REQUEST;   /* abort bad request */\n                    apr_table_setn(r->notes, \"error-notes\",\n                        apr_psprintf(r->pool,\n                                     \"Request header field is \"\n                                     \"missing ':' separator.<br />\\n\"\n                                     \"<pre>\\n%.*s</pre>\\n\", \n                                     (int)LOG_NAME_MAX_LEN,\n                                     ap_escape_html(r->pool, last_field)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564)\n                                  \"Request header field is missing ':' \"\n                                  \"separator: %.*s\", (int)LOG_NAME_MAX_LEN,\n                                  last_field);\n                    return;\n                }\n\n                tmp_field = value - 1; /* last character of field-name */\n\n                *value++ = '\\0'; /* NUL-terminate at colon */\n\n                while (*value == ' ' || *value == '\\t') {\n                     ++value;            /* Skip to start of value   */\n                }\n\n                /* Strip LWS after field-name: */\n                while (tmp_field > last_field\n                           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n\n                /* Strip LWS after field-value: */\n                tmp_field = last_field + last_len - 1;\n                while (tmp_field > value\n                           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n            }\n            else /* Using strict RFC7230 parsing */\n            {\n                /* Ensure valid token chars before ':' per RFC 7230 3.2.4 */\n                value = (char *)ap_scan_http_token(last_field);\n                if ((value == last_field) || *value != ':') {\n                    r->status = HTTP_BAD_REQUEST;\n                    apr_table_setn(r->notes, \"error-notes\",\n                        apr_psprintf(r->pool,\n                                     \"Request header field name \"\n                                     \"is malformed.<br />\\n\"\n                                     \"<pre>\\n%.*s</pre>\\n\", \n                                     (int)LOG_NAME_MAX_LEN,\n                                     ap_escape_html(r->pool, last_field)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02426)\n                                  \"Request header field name is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, last_field);\n                    return;\n                }\n\n                *value++ = '\\0'; /* NUL-terminate last_field name at ':' */\n\n                while (*value == ' ' || *value == '\\t') {\n                    ++value;     /* Skip LWS of value */\n                }\n\n                /* Find invalid, non-HT ctrl char, or the trailing NULL */\n                tmp_field = (char *)ap_scan_http_field_content(value);\n\n                /* Strip LWS after field-value, if string not empty */\n                if (*value && (*tmp_field == '\\0')) {\n                    tmp_field--;\n                    while (*tmp_field == ' ' || *tmp_field == '\\t') {\n                        *tmp_field-- = '\\0';\n                    }\n                    ++tmp_field;\n                }\n\n                /* Reject value for all garbage input (CTRLs excluding HT)\n                 * e.g. only VCHAR / SP / HT / obs-text are allowed per\n                 * RFC7230 3.2.6 - leave all more explicit rule enforcement\n                 * for specific header handler logic later in the cycle\n                 */\n                if (*tmp_field != '\\0') {\n                    r->status = HTTP_BAD_REQUEST;\n                    apr_table_setn(r->notes, \"error-notes\",\n                        apr_psprintf(r->pool,\n                                     \"Request header value \"\n                                     \"is malformed.<br />\\n\"\n                                     \"<pre>\\n%.*s</pre>\\n\", \n                                     (int)LOG_NAME_MAX_LEN,\n                                     ap_escape_html(r->pool, value)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02427)\n                                  \"Request header value is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, value);\n                    return;\n                }\n            }\n\n            apr_table_addn(r->headers_in, last_field, value);\n\n            /* This last_field header is now stored in headers_in,\n             * resume processing of the current input line.\n             */\n        }\n\n        /* Found the terminating empty end-of-headers line, stop. */\n        if (len == 0) {\n            break;\n        }\n\n        /* Keep track of this new header line so that we can extend it across\n         * any obs-fold or parse it on the next loop iteration. We referenced\n         * our previously allocated buffer in r->headers_in,\n         * so allocate a fresh buffer if required.\n         */\n        alloc_len = 0;\n        last_field = field;\n        last_len = len;\n    }\n\n    /* Combine multiple message-header fields with the same\n     * field-name, following RFC 2616, 4.2.\n     */\n    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n\n    /* enforce LimitRequestFieldSize for merged headers */\n    apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL);\n}", "patch_func_code": "AP_DECLARE(void) ap_get_mime_headers_core(request_rec *r, apr_bucket_brigade *bb)\n{\n    char *last_field = NULL;\n    apr_size_t last_len = 0;\n    apr_size_t alloc_len = 0;\n    char *field;\n    char *value;\n    apr_size_t len;\n    int fields_read = 0;\n    char *tmp_field;\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n\n    /*\n     * Read header lines until we get the empty separator line, a read error,\n     * the connection closes (EOF), reach the server limit, or we timeout.\n     */\n    while(1) {\n        apr_status_t rv;\n\n        field = NULL;\n        rv = ap_rgetline(&field, r->server->limit_req_fieldsize + 2,\n                         &len, r, 0, bb);\n\n        if (rv != APR_SUCCESS) {\n            if (APR_STATUS_IS_TIMEUP(rv)) {\n                r->status = HTTP_REQUEST_TIME_OUT;\n            }\n            else {\n                r->status = HTTP_BAD_REQUEST;\n            }\n\n            /* ap_rgetline returns APR_ENOSPC if it fills up the buffer before\n             * finding the end-of-line.  This is only going to happen if it\n             * exceeds the configured limit for a field size.\n             */\n            if (rv == APR_ENOSPC) {\n                const char *field_escaped;\n                if (field && len) {\n                    /* ensure ap_escape_html will terminate correctly */\n                    field[len - 1] = '\\0';\n                    field_escaped = ap_escape_html(r->pool, field);\n                }\n                else {\n                    field_escaped = field = \"\";\n                }\n\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_psprintf(r->pool,\n                                           \"Size of a request header field \"\n                                           \"exceeds server limit.<br />\\n\"\n                                           \"<pre>\\n%.*s\\n</pre>\\n\", \n                                           field_name_len(field_escaped),\n                                           field_escaped));\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00561)\n                              \"Request header exceeds LimitRequestFieldSize%s\"\n                              \"%.*s\",\n                              *field ? \": \" : \"\",\n                              field_name_len(field), field);\n            }\n            return;\n        }\n\n        /* For all header values, and all obs-fold lines, the presence of\n         * additional whitespace is a no-op, so collapse trailing whitespace\n         * to save buffer allocation and optimize copy operations.\n         * Do not remove the last single whitespace under any condition.\n         */\n        while (len > 1 && (field[len-1] == '\\t' || field[len-1] == ' ')) {\n            field[--len] = '\\0';\n        } \n\n        if (*field == '\\t' || *field == ' ') {\n\n            /* Append any newly-read obs-fold line onto the preceding\n             * last_field line we are processing\n             */\n            apr_size_t fold_len;\n\n            if (last_field == NULL) {\n                r->status = HTTP_BAD_REQUEST;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(03442)\n                              \"Line folding encounterd before first\"\n                              \" header line\");\n                return;\n            }\n\n            /* This line is a continuation of the preceding line(s),\n             * so append it to the line that we've set aside.\n             * Note: this uses a power-of-two allocator to avoid\n             * doing O(n) allocs and using O(n^2) space for\n             * continuations that span many many lines.\n             */\n            fold_len = last_len + len + 1; /* trailing null */\n\n            if (fold_len >= (apr_size_t)(r->server->limit_req_fieldsize)) {\n                const char *field_escaped;\n\n                r->status = HTTP_BAD_REQUEST;\n                /* report what we have accumulated so far before the\n                 * overflow (last_field) as the field with the problem\n                 */\n                field_escaped = ap_escape_html(r->pool, last_field);\n                apr_table_setn(r->notes, \"error-notes\",\n                               apr_psprintf(r->pool,\n                                            \"Size of a request header field \"\n                                            \"after folding \"\n                                            \"exceeds server limit.<br />\\n\"\n                                            \"<pre>\\n%.*s\\n</pre>\\n\", \n                                            field_name_len(field_escaped), \n                                            field_escaped));\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00562)\n                              \"Request header exceeds LimitRequestFieldSize \"\n                              \"after folding: %.*s\",\n                              field_name_len(last_field), last_field);\n                return;\n            }\n\n            if (fold_len > alloc_len) {\n                char *fold_buf;\n                alloc_len += alloc_len;\n                if (fold_len > alloc_len) {\n                    alloc_len = fold_len;\n                }\n                fold_buf = (char *)apr_palloc(r->pool, alloc_len);\n                memcpy(fold_buf, last_field, last_len);\n                last_field = fold_buf;\n            }\n            memcpy(last_field + last_len, field, len +1); /* +1 for nul */\n            /* Replace obs-fold w/ SP per RFC 7230 3.2.4 */\n            if (conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT) {\n                last_field[last_len] = ' ';\n            }\n            last_len += len;\n\n            /* We've appended this obs-fold line to last_len, proceed to\n             * read the next input line\n             */\n            continue;\n        }\n        else if (last_field != NULL) {\n\n            /* Process the previous last_field header line with all obs-folded\n             * segments already concatinated (this is not operating on the\n             * most recently read input line).\n             */\n\n            if (r->server->limit_req_fields\n                    && (++fields_read > r->server->limit_req_fields)) {\n                r->status = HTTP_BAD_REQUEST;\n                apr_table_setn(r->notes, \"error-notes\",\n                               \"The number of request header fields \"\n                               \"exceeds this server's limit.\");\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00563)\n                              \"Number of request headers exceeds \"\n                              \"LimitRequestFields\");\n                return;\n            }\n\n            if (!(conf->http_conformance & AP_HTTP_CONFORMANCE_STRICT))\n            {\n                /* Not Strict, using the legacy parser */\n\n                if (!(value = strchr(last_field, ':'))) { /* Find ':' or */\n                    r->status = HTTP_BAD_REQUEST;   /* abort bad request */\n                    apr_table_setn(r->notes, \"error-notes\",\n                        apr_psprintf(r->pool,\n                                     \"Request header field is \"\n                                     \"missing ':' separator.<br />\\n\"\n                                     \"<pre>\\n%.*s</pre>\\n\", \n                                     (int)LOG_NAME_MAX_LEN,\n                                     ap_escape_html(r->pool, last_field)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00564)\n                                  \"Request header field is missing ':' \"\n                                  \"separator: %.*s\", (int)LOG_NAME_MAX_LEN,\n                                  last_field);\n                    return;\n                }\n\n                tmp_field = value - 1; /* last character of field-name */\n\n                *value++ = '\\0'; /* NUL-terminate at colon */\n\n                while (*value == ' ' || *value == '\\t') {\n                     ++value;            /* Skip to start of value   */\n                }\n\n                /* Strip LWS after field-name: */\n                while (tmp_field > last_field\n                           && (*tmp_field == ' ' || *tmp_field == '\\t')) {\n                    *tmp_field-- = '\\0';\n                }\n            }\n            else /* Using strict RFC7230 parsing */\n            {\n                /* Ensure valid token chars before ':' per RFC 7230 3.2.4 */\n                value = (char *)ap_scan_http_token(last_field);\n                if ((value == last_field) || *value != ':') {\n                    r->status = HTTP_BAD_REQUEST;\n                    apr_table_setn(r->notes, \"error-notes\",\n                        apr_psprintf(r->pool,\n                                     \"Request header field name \"\n                                     \"is malformed.<br />\\n\"\n                                     \"<pre>\\n%.*s</pre>\\n\", \n                                     (int)LOG_NAME_MAX_LEN,\n                                     ap_escape_html(r->pool, last_field)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02426)\n                                  \"Request header field name is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, last_field);\n                    return;\n                }\n\n                *value++ = '\\0'; /* NUL-terminate last_field name at ':' */\n\n                while (*value == ' ' || *value == '\\t') {\n                    ++value;     /* Skip LWS of value */\n                }\n\n                /* Find invalid, non-HT ctrl char, or the trailing NULL */\n                tmp_field = (char *)ap_scan_http_field_content(value);\n\n                /* Reject value for all garbage input (CTRLs excluding HT)\n                 * e.g. only VCHAR / SP / HT / obs-text are allowed per\n                 * RFC7230 3.2.6 - leave all more explicit rule enforcement\n                 * for specific header handler logic later in the cycle\n                 */\n                if (*tmp_field != '\\0') {\n                    r->status = HTTP_BAD_REQUEST;\n                    apr_table_setn(r->notes, \"error-notes\",\n                        apr_psprintf(r->pool,\n                                     \"Request header value \"\n                                     \"is malformed.<br />\\n\"\n                                     \"<pre>\\n%.*s</pre>\\n\", \n                                     (int)LOG_NAME_MAX_LEN,\n                                     ap_escape_html(r->pool, value)));\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02427)\n                                  \"Request header value is malformed: \"\n                                  \"%.*s\", (int)LOG_NAME_MAX_LEN, value);\n                    return;\n                }\n            }\n\n            apr_table_addn(r->headers_in, last_field, value);\n\n            /* This last_field header is now stored in headers_in,\n             * resume processing of the current input line.\n             */\n        }\n\n        /* Found the terminating empty end-of-headers line, stop. */\n        if (len == 0) {\n            break;\n        }\n\n        /* Keep track of this new header line so that we can extend it across\n         * any obs-fold or parse it on the next loop iteration. We referenced\n         * our previously allocated buffer in r->headers_in,\n         * so allocate a fresh buffer if required.\n         */\n        alloc_len = 0;\n        last_field = field;\n        last_len = len;\n    }\n\n    /* Combine multiple message-header fields with the same\n     * field-name, following RFC 2616, 4.2.\n     */\n    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);\n\n    /* enforce LimitRequestFieldSize for merged headers */\n    apr_table_do(table_do_fn_check_lengths, r, r->headers_in, NULL);\n}", "before_change_lines": [63, 185, 186, 187, 188, 189, 220, 221, 222, 223, 224, 225, 226], "raw_before_change_lines": [63, 183, 184, 185, 186, 187, 188, 189, 219, 220, 221, 222, 223, 224, 225, 226, 227], "after_change_lines": [64, 65, 66, 67, 68, 69, 70, 72], "raw_after_change_lines": [63, 64, 65, 66, 67, 68, 69, 70, 71, 72], "bug_lines": [63, 183, 184, 185, 186, 187, 188, 189, 219, 220, 221, 222, 223, 224, 225, 226, 227], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 200}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "4873----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_9e38c15ecc5080516b876f1b81a3655b27f7ebf2_1.json----log_cookie", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_9e38c15ecc5080516b876f1b81a3655b27f7ebf2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_9e38c15ecc5080516b876f1b81a3655b27f7ebf2_1.json", "function_name": "log_cookie", "vul_func_code": "static const char *log_cookie(request_rec *r, char *a)\n{\n    const char *cookies_entry;\n\n    /*\n     * This supports Netscape version 0 cookies while being tolerant to\n     * some properties of RFC2109/2965 version 1 cookies:\n     * - case-insensitive match of cookie names\n     * - white space between the tokens\n     * It does not support the following version 1 features:\n     * - quoted strings as cookie values\n     * - commas to separate cookies\n     */\n\n    if ((cookies_entry = apr_table_get(r->headers_in, \"Cookie\"))) {\n        char *cookie, *last1, *last2;\n        char *cookies = apr_pstrdup(r->pool, cookies_entry);\n\n        while ((cookie = apr_strtok(cookies, \";\", &last1))) {\n            char *name = apr_strtok(cookie, \"=\", &last2);\n            if (name) {\n                char *value = name + strlen(name) + 1;\n                apr_collapse_spaces(name, name);\n\n                if (!strcasecmp(name, a)) {\n                    char *last;\n                    value += strspn(value, \" \\t\");  /* Move past leading WS */\n                    last = value + strlen(value) - 1;\n                    while (last >= value && apr_isspace(*last)) {\n                       *last = '\\0';\n                       --last;\n                    }\n\n                    return ap_escape_logitem(r->pool, value);\n                }\n            }\n            cookies = NULL;\n        }\n    }\n    return NULL;\n}", "patch_func_code": "static const char *log_cookie(request_rec *r, char *a)\n{\n    const char *cookies_entry;\n\n    /*\n     * This supports Netscape version 0 cookies while being tolerant to\n     * some properties of RFC2109/2965 version 1 cookies:\n     * - case-insensitive match of cookie names\n     * - white space between the tokens\n     * It does not support the following version 1 features:\n     * - quoted strings as cookie values\n     * - commas to separate cookies\n     */\n\n    if ((cookies_entry = apr_table_get(r->headers_in, \"Cookie\"))) {\n        char *cookie, *last1, *last2;\n        char *cookies = apr_pstrdup(r->pool, cookies_entry);\n\n        while ((cookie = apr_strtok(cookies, \";\", &last1))) {\n            char *name = apr_strtok(cookie, \"=\", &last2);\n            /* last2 points to the next char following an '=' delim,\n               or the trailing NUL char of the string */\n            char *value = last2;\n            if (name && *name &&  value && *value) {\n                char *last = value - 2;\n                /* Move past leading WS */\n                name += strspn(name, \" \\t\");\n                while (last >= name && apr_isspace(*last)) {\n                    *last = '\\0';\n                    --last;\n                }\n\n                if (!strcasecmp(name, a)) {\n                    /* last1 points to the next char following the ';' delim,\n                       or the trailing NUL char of the string */\n                    last = last1 - (*last1 ? 2 : 1);\n                    /* Move past leading WS */\n                    value += strspn(value, \" \\t\");\n                    while (last >= value && apr_isspace(*last)) {\n                       *last = '\\0';\n                       --last;\n                    }\n\n                    return ap_escape_logitem(r->pool, value);\n                }\n            }\n            /* Iterate the remaining tokens using apr_strtok(NULL, ...) */\n            cookies = NULL;\n        }\n    }\n    return NULL;\n}", "before_change_lines": [21, 22, 23, 26, 27, 28], "raw_before_change_lines": [21, 22, 23, 26, 27, 28], "after_change_lines": [22, 23, 24, 25, 27, 28, 29, 30, 31, 35, 36, 38], "raw_after_change_lines": [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 34, 35, 36, 37, 38, 47], "bug_lines": [21, 22, 23, 26, 27, 28], "added": [false, false, false, false, false, false], "idx": 201}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "4937----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_e9b090a200a4523a0ce93365741a7d5f68f49b30_1.json----proxy_wstunnel_pump", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_e9b090a200a4523a0ce93365741a7d5f68f49b30_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_e9b090a200a4523a0ce93365741a7d5f68f49b30_1.json", "function_name": "proxy_wstunnel_pump", "vul_func_code": "static int proxy_wstunnel_pump(ws_baton_t *baton, apr_time_t timeout, int try_async) {\n    request_rec *r = baton->r;\n    conn_rec *c = r->connection;\n    proxy_conn_rec *conn = baton->proxy_connrec;\n    apr_socket_t *sock = conn->sock;\n    conn_rec *backconn = conn->connection;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    apr_int16_t pollevent;\n    apr_pollset_t *pollset = baton->pollset;\n    apr_socket_t *client_socket = baton->client_soc;\n    apr_status_t rv;\n    apr_bucket_brigade *bb = baton->bb;\n\n    while(1) { \n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r, \"poll timeout is %\"APR_TIME_T_FMT\"ms %s\", apr_time_as_msec(timeout), try_async ? \"async\" : \"sync\");\n        if ((rv = apr_pollset_poll(pollset, timeout, &pollcnt, &signalled))\n                != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) { \n                if (try_async) { \n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02542) \"Attempting to go async\");\n                    return SUSPENDED;\n                }\n                else { \n                    return HTTP_REQUEST_TIME_OUT;\n                }\n            }\n            else { \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) \"error apr_poll()\");\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02445)\n                \"woke from poll(), i=%d\", pollcnt);\n\n        for (pi = 0; pi < pollcnt; pi++) {\n            const apr_pollfd_t *cur = &signalled[pi];\n\n            if (cur->desc.s == sock) {\n                pollevent = cur->rtnevents;\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02446)\n                            \"sock was readable\");\n                    rv = proxy_wstunnel_transfer(r, backconn, c, bb, \"sock\");\n                }\n                else if (pollevent & APR_POLLERR) {\n                    rv = APR_EPIPE;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447)\n                            \"error on backconn\");\n                }\n                else { \n                    rv = APR_EGENERAL;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02605)\n                            \"unknown event on backconn %d\", pollevent);\n                }\n            }\n            else if (cur->desc.s == client_socket) {\n                pollevent = cur->rtnevents;\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02448)\n                            \"client was readable\");\n                    rv = proxy_wstunnel_transfer(r, c, backconn, bb, \"client\");\n                }\n                else if (pollevent & APR_POLLERR) {\n                    rv = APR_EPIPE;\n                    c->aborted = 1;\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02607)\n                            \"error on client conn\");\n                }\n                else { \n                    rv = APR_EGENERAL;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02606)\n                            \"unknown event on client conn %d\", pollevent);\n                }\n            }\n            else {\n                rv = APR_EBADF;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449)\n                        \"unknown socket in pollset\");\n            }\n\n        }\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n            \"finished with poll() - cleaning up\");\n\n    return OK;\n}", "patch_func_code": "static int proxy_wstunnel_pump(ws_baton_t *baton, apr_time_t timeout, int try_async) {\n    request_rec *r = baton->r;\n    conn_rec *c = r->connection;\n    proxy_conn_rec *conn = baton->proxy_connrec;\n    apr_socket_t *sock = conn->sock;\n    conn_rec *backconn = conn->connection;\n    const apr_pollfd_t *signalled;\n    apr_int32_t pollcnt, pi;\n    apr_int16_t pollevent;\n    apr_pollset_t *pollset = baton->pollset;\n    apr_socket_t *client_socket = baton->client_soc;\n    apr_status_t rv;\n    apr_bucket_brigade *bb = baton->bb;\n\n    while(1) { \n        if ((rv = apr_pollset_poll(pollset, timeout, &pollcnt, &signalled))\n                != APR_SUCCESS) {\n            if (APR_STATUS_IS_EINTR(rv)) {\n                continue;\n            }\n            else if (APR_STATUS_IS_TIMEUP(rv)) { \n                if (try_async) { \n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02542) \"Attempting to go async\");\n                    return SUSPENDED;\n                }\n                else { \n                    return HTTP_REQUEST_TIME_OUT;\n                }\n            }\n            else { \n                ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02444) \"error apr_poll()\");\n                return HTTP_INTERNAL_SERVER_ERROR;\n            }\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02445)\n                \"woke from poll(), i=%d\", pollcnt);\n\n        for (pi = 0; pi < pollcnt; pi++) {\n            const apr_pollfd_t *cur = &signalled[pi];\n\n            if (cur->desc.s == sock) {\n                pollevent = cur->rtnevents;\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02446)\n                            \"sock was readable\");\n                    rv = proxy_wstunnel_transfer(r, backconn, c, bb, \"sock\");\n                }\n                else if (pollevent & APR_POLLERR) {\n                    rv = APR_EPIPE;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02447)\n                            \"error on backconn\");\n                }\n                else { \n                    rv = APR_EGENERAL;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02605)\n                            \"unknown event on backconn %d\", pollevent);\n                }\n            }\n            else if (cur->desc.s == client_socket) {\n                pollevent = cur->rtnevents;\n                if (pollevent & (APR_POLLIN | APR_POLLHUP)) {\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02448)\n                            \"client was readable\");\n                    rv = proxy_wstunnel_transfer(r, c, backconn, bb, \"client\");\n                }\n                else if (pollevent & APR_POLLERR) {\n                    rv = APR_EPIPE;\n                    c->aborted = 1;\n                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, APLOGNO(02607)\n                            \"error on client conn\");\n                }\n                else { \n                    rv = APR_EGENERAL;\n                    ap_log_rerror(APLOG_MARK, APLOG_NOTICE, 0, r, APLOGNO(02606)\n                            \"unknown event on client conn %d\", pollevent);\n                }\n            }\n            else {\n                rv = APR_EBADF;\n                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02449)\n                        \"unknown socket in pollset\");\n            }\n\n        }\n        if (rv != APR_SUCCESS) {\n            break;\n        }\n\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n            \"finished with poll() - cleaning up\");\n\n    return OK;\n}", "before_change_lines": [16, 24], "raw_before_change_lines": [16, 24], "after_change_lines": [23], "raw_after_change_lines": [23], "bug_lines": [16, 24], "added": [false, false], "idx": 202}
{"project": "httpd", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "4948----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_f2c99cd60672ee9be2773e0767b028a2ccac7dba_1.json----proxy_connect_handler", "patch_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/after_fix/httpd_f2c99cd60672ee9be2773e0767b028a2ccac7dba_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/httpd/d2a/before_fix/httpd_f2c99cd60672ee9be2773e0767b028a2ccac7dba_1.json", "function_name": "proxy_connect_handler", "vul_func_code": "static int proxy_connect_handler(request_rec *r, proxy_worker *worker,\n                                 proxy_server_conf *conf,\n                                 char *url, const char *proxyname,\n                                 apr_port_t proxyport)\n{\n    connect_conf *c_conf =\n        ap_get_module_config(r->server->module_config, &proxy_connect_module);\n\n    apr_pool_t *p = r->pool;\n    apr_socket_t *sock;\n    conn_rec *c = r->connection;\n    conn_rec *backconn;\n\n    apr_status_t rv;\n    apr_size_t nbytes;\n    char buffer[HUGE_STRING_LEN];\n\n    apr_bucket_brigade *bb;\n    proxy_tunnel_rec *tunnel;\n    int failed, rc;\n\n    apr_uri_t uri;\n    const char *connectname;\n    apr_port_t connectport = 0;\n    apr_sockaddr_t *nexthop;\n\n    /* is this for us? */\n    if (r->method_number != M_CONNECT) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"declining URL %s\", url);\n        return DECLINED;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"serving URL %s\", url);\n\n\n    /*\n     * Step One: Determine Who To Connect To\n     *\n     * Break up the URL to determine the host to connect to\n     */\n\n    /* we break the URL into host, port, uri */\n    if (APR_SUCCESS != apr_uri_parse_hostinfo(p, url, &uri)) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                             apr_pstrcat(p, \"URI cannot be parsed: \", url,\n                                         NULL));\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01019)\n                  \"connecting %s to %s:%d\", url, uri.hostname, uri.port);\n\n    /* Determine host/port of next hop; from request URI or of a proxy. */\n    connectname = proxyname ? proxyname : uri.hostname;\n    connectport = proxyname ? proxyport : uri.port;\n\n    /* Do a DNS lookup for the next hop */\n    rv = apr_sockaddr_info_get(&nexthop, connectname, APR_UNSPEC, \n                               connectport, 0, p);\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02327)\n                      \"failed to resolve hostname '%s'\", connectname);\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, \"DNS lookup failure for: \",\n                                         connectname, NULL));\n    }\n\n    /* Check ProxyBlock directive on the hostname/address.  */\n    if (ap_proxy_checkproxyblock(r, conf, uri.hostname, \n                                 proxyname ? NULL : nexthop) != OK) {\n        return ap_proxyerror(r, HTTP_FORBIDDEN,\n                             \"Connect to remote machine blocked\");\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                  \"connecting to remote proxy %s on port %d\",\n                  connectname, connectport);\n\n    /* Check if it is an allowed port */\n    if (!allowed_port(c_conf, uri.port)) {\n        return ap_proxyerror(r, HTTP_FORBIDDEN,\n                             \"Connect to remote machine blocked\");\n    }\n\n    /*\n     * Step Two: Make the Connection\n     *\n     * We have determined who to connect to. Now make the connection.\n     */\n\n    /*\n     * At this point we have a list of one or more IP addresses of\n     * the machine to connect to. If configured, reorder this\n     * list so that the \"best candidate\" is first try. \"best\n     * candidate\" could mean the least loaded server, the fastest\n     * responding server, whatever.\n     *\n     * For now we do nothing, ie we get DNS round robin.\n     * XXX FIXME\n     */\n    failed = ap_proxy_connect_to_backend(&sock, \"CONNECT\", nexthop,\n                                         connectname, conf, r);\n\n    /* handle a permanent error from the above loop */\n    if (failed) {\n        if (proxyname) {\n            return DECLINED;\n        }\n        else {\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n    }\n\n    /*\n     * Step Three: Send the Request\n     *\n     * Send the HTTP/1.1 CONNECT request to the remote server\n     */\n\n    backconn = ap_run_create_connection(c->pool, r->server, sock,\n                                        c->id, c->sbh, c->bucket_alloc);\n    if (!backconn) {\n        /* peer reset */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01021)\n                      \"an error occurred creating a new connection \"\n                      \"to %pI (%s)\", nexthop, connectname);\n        apr_socket_close(sock);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    ap_proxy_ssl_engine(backconn, r->per_dir_config, 0);\n    rc = ap_run_pre_connection(backconn, sock);\n    if (rc != OK && rc != DONE) {\n        backconn->aborted = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01022)\n                      \"pre_connection setup failed (%d)\", rc);\n        apr_socket_close(sock);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                  \"connection complete to %pI (%s)\",\n                  nexthop, connectname);\n    apr_table_setn(r->notes, \"proxy-source-port\", apr_psprintf(r->pool, \"%hu\",\n                   backconn->local_addr->port));\n\n    bb = apr_brigade_create(p, c->bucket_alloc);\n\n    /* If we are connecting through a remote proxy, we need to pass\n     * the CONNECT request on to it.\n     */\n    if (proxyport) {\n    /* FIXME: Error checking ignored.\n     */\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"sending the CONNECT request to the remote proxy\");\n        ap_fprintf(backconn->output_filters, bb,\n                   \"CONNECT %s HTTP/1.0\" CRLF, r->uri);\n        ap_fprintf(backconn->output_filters, bb,\n                   \"Proxy-agent: %s\" CRLF CRLF, ap_get_server_banner());\n        ap_fflush(backconn->output_filters, bb);\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"Returning 200 OK\");\n        nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              \"HTTP/1.0 200 Connection Established\" CRLF);\n        ap_xlate_proto_to_ascii(buffer, nbytes);\n        ap_fwrite(c->output_filters, bb, buffer, nbytes);\n        nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              \"Proxy-agent: %s\" CRLF CRLF,\n                              ap_get_server_banner());\n        ap_xlate_proto_to_ascii(buffer, nbytes);\n        ap_fwrite(c->output_filters, bb, buffer, nbytes);\n        ap_fflush(c->output_filters, bb);\n#if 0\n        /* This is safer code, but it doesn't work yet.  I'm leaving it\n         * here so that I can fix it later.\n         */\n        r->status = HTTP_OK;\n        r->header_only = 1;\n        apr_table_set(r->headers_out, \"Proxy-agent: %s\", ap_get_server_banner());\n        ap_rflush(r);\n#endif\n    }\n    apr_brigade_cleanup(bb);\n\n    /*\n     * Step Four: Handle Data Transfer\n     *\n     * Handle two way transfer of data over the socket (this is a tunnel).\n     */\n\n    /* r->sent_bodyct = 1; */\n\n    rv = ap_proxy_tunnel_create(&tunnel, r, backconn);\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10208)\n                      \"can't create tunnel for %pI (%s)\",\n                      nexthop, connectname);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    rc = ap_proxy_tunnel_run(tunnel);\n    if (ap_is_HTTP_ERROR(rc)) {\n        /* Don't send an error page if we sent data already */\n        if (proxyport && !tunnel->replied) {\n            return rc;\n        }\n        /* Custom log may need this, still */\n        r->status = rc;\n    }\n\n    /*\n     * Step Five: Clean Up\n     *\n     * Close the socket and clean up\n     */\n\n    if (backconn->aborted)\n        apr_socket_close(sock);\n    else\n        ap_lingering_close(backconn);\n\n    return OK;\n}", "patch_func_code": "static int proxy_connect_handler(request_rec *r, proxy_worker *worker,\n                                 proxy_server_conf *conf,\n                                 char *url, const char *proxyname,\n                                 apr_port_t proxyport)\n{\n    connect_conf *c_conf =\n        ap_get_module_config(r->server->module_config, &proxy_connect_module);\n\n    apr_pool_t *p = r->pool;\n    apr_socket_t *sock;\n    conn_rec *c = r->connection;\n    conn_rec *backconn;\n\n    apr_status_t rv;\n    apr_size_t nbytes;\n    char buffer[HUGE_STRING_LEN];\n\n    apr_bucket_brigade *bb;\n    proxy_tunnel_rec *tunnel;\n    int failed, rc;\n\n    apr_uri_t uri;\n    const char *connectname;\n    apr_port_t connectport = 0;\n    apr_sockaddr_t *nexthop;\n\n    /* is this for us? */\n    if (r->method_number != M_CONNECT) {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"declining URL %s\", url);\n        return DECLINED;\n    }\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"serving URL %s\", url);\n\n\n    /*\n     * Step One: Determine Who To Connect To\n     *\n     * Break up the URL to determine the host to connect to\n     */\n\n    /* we break the URL into host, port, uri */\n    if (APR_SUCCESS != apr_uri_parse_hostinfo(p, url, &uri)) {\n        return ap_proxyerror(r, HTTP_BAD_REQUEST,\n                             apr_pstrcat(p, \"URI cannot be parsed: \", url,\n                                         NULL));\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01019)\n                  \"connecting %s to %s:%d\", url, uri.hostname, uri.port);\n\n    /* Determine host/port of next hop; from request URI or of a proxy. */\n    connectname = proxyname ? proxyname : uri.hostname;\n    connectport = proxyname ? proxyport : uri.port;\n\n    /* Do a DNS lookup for the next hop */\n    rv = apr_sockaddr_info_get(&nexthop, connectname, APR_UNSPEC, \n                               connectport, 0, p);\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(02327)\n                      \"failed to resolve hostname '%s'\", connectname);\n        return ap_proxyerror(r, HTTP_BAD_GATEWAY,\n                             apr_pstrcat(p, \"DNS lookup failure for: \",\n                                         connectname, NULL));\n    }\n\n    /* Check ProxyBlock directive on the hostname/address.  */\n    if (ap_proxy_checkproxyblock(r, conf, uri.hostname, \n                                 proxyname ? NULL : nexthop) != OK) {\n        return ap_proxyerror(r, HTTP_FORBIDDEN,\n                             \"Connect to remote machine blocked\");\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,\n                  \"connecting to remote proxy %s on port %d\",\n                  connectname, connectport);\n\n    /* Check if it is an allowed port */\n    if (!allowed_port(c_conf, uri.port)) {\n        return ap_proxyerror(r, HTTP_FORBIDDEN,\n                             \"Connect to remote machine blocked\");\n    }\n\n    /*\n     * Step Two: Make the Connection\n     *\n     * We have determined who to connect to. Now make the connection.\n     */\n\n    /*\n     * At this point we have a list of one or more IP addresses of\n     * the machine to connect to. If configured, reorder this\n     * list so that the \"best candidate\" is first try. \"best\n     * candidate\" could mean the least loaded server, the fastest\n     * responding server, whatever.\n     *\n     * For now we do nothing, ie we get DNS round robin.\n     * XXX FIXME\n     */\n    failed = ap_proxy_connect_to_backend(&sock, \"CONNECT\", nexthop,\n                                         connectname, conf, r);\n\n    /* handle a permanent error from the above loop */\n    if (failed) {\n        if (proxyname) {\n            return DECLINED;\n        }\n        else {\n            return HTTP_SERVICE_UNAVAILABLE;\n        }\n    }\n\n    /*\n     * Step Three: Send the Request\n     *\n     * Send the HTTP/1.1 CONNECT request to the remote server\n     */\n\n    backconn = ap_run_create_connection(c->pool, r->server, sock,\n                                        c->id, c->sbh, c->bucket_alloc);\n    if (!backconn) {\n        /* peer reset */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(01021)\n                      \"an error occurred creating a new connection \"\n                      \"to %pI (%s)\", nexthop, connectname);\n        apr_socket_close(sock);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    ap_proxy_ssl_engine(backconn, r->per_dir_config, 0);\n    rc = ap_run_pre_connection(backconn, sock);\n    if (rc != OK && rc != DONE) {\n        backconn->aborted = 1;\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01022)\n                      \"pre_connection setup failed (%d)\", rc);\n        apr_socket_close(sock);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n                  \"connection complete to %pI (%s)\",\n                  nexthop, connectname);\n    apr_table_setn(r->notes, \"proxy-source-port\", apr_psprintf(r->pool, \"%hu\",\n                   backconn->local_addr->port));\n\n    bb = apr_brigade_create(p, c->bucket_alloc);\n\n    /* If we are connecting through a remote proxy, we need to pass\n     * the CONNECT request on to it.\n     */\n    if (proxyport) {\n    /* FIXME: Error checking ignored.\n     */\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE2, 0, r,\n                      \"sending the CONNECT request to the remote proxy\");\n        ap_fprintf(backconn->output_filters, bb,\n                   \"CONNECT %s HTTP/1.0\" CRLF, r->uri);\n        ap_fprintf(backconn->output_filters, bb,\n                   \"Proxy-agent: %s\" CRLF CRLF, ap_get_server_banner());\n        ap_fflush(backconn->output_filters, bb);\n    }\n    else {\n        ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, \"Returning 200 OK\");\n        nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              \"HTTP/1.0 200 Connection Established\" CRLF);\n        ap_xlate_proto_to_ascii(buffer, nbytes);\n        ap_fwrite(c->output_filters, bb, buffer, nbytes);\n        nbytes = apr_snprintf(buffer, sizeof(buffer),\n                              \"Proxy-agent: %s\" CRLF CRLF,\n                              ap_get_server_banner());\n        ap_xlate_proto_to_ascii(buffer, nbytes);\n        ap_fwrite(c->output_filters, bb, buffer, nbytes);\n        ap_fflush(c->output_filters, bb);\n#if 0\n        /* This is safer code, but it doesn't work yet.  I'm leaving it\n         * here so that I can fix it later.\n         */\n        r->status = HTTP_OK;\n        r->header_only = 1;\n        apr_table_set(r->headers_out, \"Proxy-agent: %s\", ap_get_server_banner());\n        ap_rflush(r);\n#endif\n    }\n    apr_brigade_cleanup(bb);\n\n    /*\n     * Step Four: Handle Data Transfer\n     *\n     * Handle two way transfer of data over the socket (this is a tunnel).\n     */\n\n    /* r->sent_bodyct = 1; */\n\n    rv = ap_proxy_tunnel_create(&tunnel, r, backconn, \"CONNECT\");\n    if (rv != APR_SUCCESS) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(10208)\n                      \"can't create tunnel for %pI (%s)\",\n                      nexthop, connectname);\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    rc = ap_proxy_tunnel_run(tunnel);\n    if (ap_is_HTTP_ERROR(rc)) {\n        if (rc == HTTP_GATEWAY_TIME_OUT) {\n            /* ap_proxy_tunnel_run() didn't log this */\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(10224)\n                          \"tunnel timed out\");\n        }\n        /* Don't send an error page if we sent data already */\n        if (proxyport && !tunnel->replied) {\n            return rc;\n        }\n        /* Custom log may need this, still */\n        r->status = rc;\n    }\n\n    /*\n     * Step Five: Clean Up\n     *\n     * Close the socket and clean up\n     */\n\n    if (backconn->aborted)\n        apr_socket_close(sock);\n    else\n        ap_lingering_close(backconn);\n\n    return OK;\n}", "before_change_lines": [192], "raw_before_change_lines": [192], "after_change_lines": [192, 202, 204, 205, 206], "raw_after_change_lines": [192, 202, 203, 204, 205, 206], "bug_lines": [192], "added": [false], "idx": 203}
{"project": "libav", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "4967----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_00fa8842d2ec3728ce09a84f18d5465d8b424853_1.json----av_reallocp", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_00fa8842d2ec3728ce09a84f18d5465d8b424853_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_00fa8842d2ec3728ce09a84f18d5465d8b424853_1.json", "function_name": "av_reallocp", "vul_func_code": "int av_reallocp(void *ptr, size_t size)\n{\n    void **ptrptr = ptr;\n    void *ret;\n\n    if (!size) {\n        av_freep(ptr);\n        return 0;\n    }\n    ret = av_realloc(*ptrptr, size);\n\n    if (!ret) {\n        av_freep(ptr);\n        return AVERROR(ENOMEM);\n    }\n\n    *ptrptr = ret;\n    return 0;\n}", "patch_func_code": "int av_reallocp(void *ptr, size_t size)\n{\n    void *val;\n\n    if (!size) {\n        av_freep(ptr);\n        return 0;\n    }\n\n    memcpy(&val, ptr, sizeof(val));\n    val = av_realloc(val, size);\n\n    if (!val) {\n        av_freep(ptr);\n        return AVERROR(ENOMEM);\n    }\n\n    memcpy(ptr, &val, sizeof(val));\n    return 0;\n}", "before_change_lines": [3, 4, 10, 12, 17], "raw_before_change_lines": [3, 4, 10, 12, 17], "after_change_lines": [3, 10, 11, 13, 18], "raw_after_change_lines": [3, 10, 11, 12, 13, 18], "bug_lines": [3, 4, 10, 12, 17], "added": [false, false, false, false, false], "idx": 204}
{"project": "libav", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "4973----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_019fe0c439f0703d9374b6decee7173190057fa5_1.json----gen_check_bw", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_019fe0c439f0703d9374b6decee7173190057fa5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_019fe0c439f0703d9374b6decee7173190057fa5_1.json", "function_name": "gen_check_bw", "vul_func_code": "static void gen_check_bw(URLContext *s, RTMPContext *rt)\n{\n    RTMPPacket pkt;\n    uint8_t *p;\n\n    ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0, 21);\n\n    p = pkt.data;\n    ff_amf_write_string(&p, \"_checkbw\");\n    ff_amf_write_number(&p, ++rt->nb_invokes);\n    ff_amf_write_null(&p);\n\n    ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]);\n    ff_rtmp_packet_destroy(&pkt);\n}", "patch_func_code": "static int gen_check_bw(URLContext *s, RTMPContext *rt)\n{\n    RTMPPacket pkt;\n    uint8_t *p;\n    int ret;\n\n    if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,\n                                     0, 21)) < 0)\n        return ret;\n\n    p = pkt.data;\n    ff_amf_write_string(&p, \"_checkbw\");\n    ff_amf_write_number(&p, ++rt->nb_invokes);\n    ff_amf_write_null(&p);\n\n    ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]);\n    ff_rtmp_packet_destroy(&pkt);\n\n    return ret;\n}", "before_change_lines": [1, 6], "raw_before_change_lines": [1, 6], "after_change_lines": [1, 5, 7, 8, 9, 19], "raw_after_change_lines": [1, 5, 7, 8, 9, 18, 19], "bug_lines": [1, 6], "added": [false, false], "idx": 205}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4990----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_02d945294ff3b6fe4156603181976a5f86d6d733_1.json----ff_id3v2_parse", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_02d945294ff3b6fe4156603181976a5f86d6d733_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_02d945294ff3b6fe4156603181976a5f86d6d733_1.json", "function_name": "ff_id3v2_parse", "vul_func_code": "static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags)\n{\n    int isv34, tlen, unsync;\n    char tag[5];\n    int64_t next, end = avio_tell(s->pb) + len;\n    int taghdrlen;\n    const char *reason = NULL;\n    AVIOContext pb;\n    unsigned char *buffer = NULL;\n    int buffer_size = 0;\n\n    switch (version) {\n    case 2:\n        if (flags & 0x40) {\n            reason = \"compression\";\n            goto error;\n        }\n        isv34 = 0;\n        taghdrlen = 6;\n        break;\n\n    case 3:\n    case 4:\n        isv34 = 1;\n        taghdrlen = 10;\n        break;\n\n    default:\n        reason = \"version\";\n        goto error;\n    }\n\n    unsync = flags & 0x80;\n\n    if (isv34 && flags & 0x40) /* Extended header present, just skip over it */\n        avio_skip(s->pb, get_size(s->pb, 4));\n\n    while (len >= taghdrlen) {\n        unsigned int tflags = 0;\n        int tunsync = 0;\n\n        if (isv34) {\n            avio_read(s->pb, tag, 4);\n            tag[4] = 0;\n            if(version==3){\n                tlen = avio_rb32(s->pb);\n            }else\n                tlen = get_size(s->pb, 4);\n            tflags = avio_rb16(s->pb);\n            tunsync = tflags & ID3v2_FLAG_UNSYNCH;\n        } else {\n            avio_read(s->pb, tag, 3);\n            tag[3] = 0;\n            tlen = avio_rb24(s->pb);\n        }\n        if (tlen <= 0 || tlen > len - taghdrlen) {\n            av_log(s, AV_LOG_WARNING, \"Invalid size in frame %s, skipping the rest of tag.\\n\", tag);\n            break;\n        }\n        len -= taghdrlen + tlen;\n        next = avio_tell(s->pb) + tlen;\n\n        if (tflags & ID3v2_FLAG_DATALEN) {\n            avio_rb32(s->pb);\n            tlen -= 4;\n        }\n\n        if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) {\n            av_log(s, AV_LOG_WARNING, \"Skipping encrypted/compressed ID3v2 frame %s.\\n\", tag);\n            avio_skip(s->pb, tlen);\n        } else if (tag[0] == 'T') {\n            if (unsync || tunsync) {\n                int i, j;\n                av_fast_malloc(&buffer, &buffer_size, tlen);\n                if (!buffer) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to alloc %d bytes\\n\", tlen);\n                    goto seek;\n                }\n                for (i = 0, j = 0; i < tlen; i++, j++) {\n                    buffer[j] = avio_r8(s->pb);\n                    if (j > 0 && !buffer[j] && buffer[j - 1] == 0xff) {\n                        /* Unsynchronised byte, skip it */\n                        j--;\n                    }\n                }\n                ffio_init_context(&pb, buffer, j, 0, NULL, NULL, NULL, NULL);\n                read_ttag(s, &pb, j, tag);\n            } else {\n                read_ttag(s, s->pb, tlen, tag);\n            }\n        }\n        else if (!tag[0]) {\n            if (tag[1])\n                av_log(s, AV_LOG_WARNING, \"invalid frame id, assuming padding\");\n            avio_skip(s->pb, tlen);\n            break;\n        }\n        /* Skip to end of tag */\nseek:\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n\n    if (version == 4 && flags & 0x10) /* Footer preset, always 10 bytes, skip over it */\n        end += 10;\n\n  error:\n    if (reason)\n        av_log(s, AV_LOG_INFO, \"ID3v2.%d tag skipped, cannot handle %s\\n\", version, reason);\n    avio_seek(s->pb, end, SEEK_SET);\n    av_free(buffer);\n    return;\n}", "patch_func_code": "static void ff_id3v2_parse(AVFormatContext *s, int len, uint8_t version, uint8_t flags, ID3v2ExtraMeta **extra_meta)\n{\n    int isv34, tlen, unsync;\n    char tag[5];\n    int64_t next, end = avio_tell(s->pb) + len;\n    int taghdrlen;\n    const char *reason = NULL;\n    AVIOContext pb;\n    AVIOContext *pbx;\n    unsigned char *buffer = NULL;\n    int buffer_size = 0;\n    void (*extra_func)(AVFormatContext*, AVIOContext*, int, char*, ID3v2ExtraMeta**) = NULL;\n\n    switch (version) {\n    case 2:\n        if (flags & 0x40) {\n            reason = \"compression\";\n            goto error;\n        }\n        isv34 = 0;\n        taghdrlen = 6;\n        break;\n\n    case 3:\n    case 4:\n        isv34 = 1;\n        taghdrlen = 10;\n        break;\n\n    default:\n        reason = \"version\";\n        goto error;\n    }\n\n    unsync = flags & 0x80;\n\n    if (isv34 && flags & 0x40) /* Extended header present, just skip over it */\n        avio_skip(s->pb, get_size(s->pb, 4));\n\n    while (len >= taghdrlen) {\n        unsigned int tflags = 0;\n        int tunsync = 0;\n\n        if (isv34) {\n            avio_read(s->pb, tag, 4);\n            tag[4] = 0;\n            if(version==3){\n                tlen = avio_rb32(s->pb);\n            }else\n                tlen = get_size(s->pb, 4);\n            tflags = avio_rb16(s->pb);\n            tunsync = tflags & ID3v2_FLAG_UNSYNCH;\n        } else {\n            avio_read(s->pb, tag, 3);\n            tag[3] = 0;\n            tlen = avio_rb24(s->pb);\n        }\n        if (tlen <= 0 || tlen > len - taghdrlen) {\n            av_log(s, AV_LOG_WARNING, \"Invalid size in frame %s, skipping the rest of tag.\\n\", tag);\n            break;\n        }\n        len -= taghdrlen + tlen;\n        next = avio_tell(s->pb) + tlen;\n\n        if (tflags & ID3v2_FLAG_DATALEN) {\n            avio_rb32(s->pb);\n            tlen -= 4;\n        }\n\n        if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) {\n            av_log(s, AV_LOG_WARNING, \"Skipping encrypted/compressed ID3v2 frame %s.\\n\", tag);\n            avio_skip(s->pb, tlen);\n        /* check for text tag or supported special meta tag */\n        } else if (tag[0] == 'T' || (extra_meta && (extra_func = get_extra_meta_func(tag, isv34)->read))) {\n            if (unsync || tunsync) {\n                int i, j;\n                av_fast_malloc(&buffer, &buffer_size, tlen);\n                if (!buffer) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to alloc %d bytes\\n\", tlen);\n                    goto seek;\n                }\n                for (i = 0, j = 0; i < tlen; i++, j++) {\n                    buffer[j] = avio_r8(s->pb);\n                    if (j > 0 && !buffer[j] && buffer[j - 1] == 0xff) {\n                        /* Unsynchronised byte, skip it */\n                        j--;\n                    }\n                }\n                ffio_init_context(&pb, buffer, j, 0, NULL, NULL, NULL, NULL);\n                tlen = j;\n                pbx = &pb; // read from sync buffer\n            } else {\n                pbx = s->pb; // read straight from input\n            }\n            if (tag[0] == 'T')\n                /* parse text tag */\n                read_ttag(s, pbx, tlen, tag);\n            else\n                /* parse special meta tag */\n                extra_func(s, pbx, tlen, tag, extra_meta);\n        }\n        else if (!tag[0]) {\n            if (tag[1])\n                av_log(s, AV_LOG_WARNING, \"invalid frame id, assuming padding\");\n            avio_skip(s->pb, tlen);\n            break;\n        }\n        /* Skip to end of tag */\nseek:\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n\n    if (version == 4 && flags & 0x10) /* Footer preset, always 10 bytes, skip over it */\n        end += 10;\n\n  error:\n    if (reason)\n        av_log(s, AV_LOG_INFO, \"ID3v2.%d tag skipped, cannot handle %s\\n\", version, reason);\n    avio_seek(s->pb, end, SEEK_SET);\n    av_free(buffer);\n    return;\n}", "before_change_lines": [1, 71, 87, 89], "raw_before_change_lines": [1, 71, 87, 89], "after_change_lines": [1, 9, 12, 74, 90, 91, 93, 95, 97, 98, 100], "raw_after_change_lines": [1, 9, 12, 73, 74, 90, 91, 93, 95, 96, 97, 98, 99, 100], "bug_lines": [1, 71, 87, 89], "added": [false, false, false, false], "idx": 206}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "4994----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0344226d61c1d2ab7d39d488ef2e930f06489821_1.json----aac_encode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_0344226d61c1d2ab7d39d488ef2e930f06489821_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0344226d61c1d2ab7d39d488ef2e930f06489821_1.json", "function_name": "aac_encode_frame", "vul_func_code": "static int aac_encode_frame(AVCodecContext *avctx,\n                            uint8_t *frame, int buf_size, void *data)\n{\n    AACEncContext *s = avctx->priv_data;\n    int16_t *samples = s->samples, *samples2, *la;\n    ChannelElement *cpe;\n    int i, ch, w, chans, tag, start_ch;\n    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];\n    int chan_el_counter[4];\n    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];\n\n    if (s->last_frame)\n        return 0;\n    if (data) {\n        if (!s->psypp) {\n            memcpy(s->samples + 1024 * avctx->channels, data,\n                   1024 * avctx->channels * sizeof(s->samples[0]));\n        } else {\n            start_ch = 0;\n            samples2 = s->samples + 1024 * avctx->channels;\n            for (i = 0; i < chan_map[0]; i++) {\n                tag = chan_map[i+1];\n                chans = tag == TYPE_CPE ? 2 : 1;\n                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,\n                                  samples2 + start_ch, start_ch, chans);\n                start_ch += chans;\n            }\n        }\n    }\n    if (!avctx->frame_number) {\n        memcpy(s->samples, s->samples + 1024 * avctx->channels,\n               1024 * avctx->channels * sizeof(s->samples[0]));\n        return 0;\n    }\n\n    start_ch = 0;\n    for (i = 0; i < chan_map[0]; i++) {\n        FFPsyWindowInfo* wi = windows + start_ch;\n        tag      = chan_map[i+1];\n        chans    = tag == TYPE_CPE ? 2 : 1;\n        cpe      = &s->cpe[i];\n        for (ch = 0; ch < chans; ch++) {\n            IndividualChannelStream *ics = &cpe->ch[ch].ics;\n            int cur_channel = start_ch + ch;\n            samples2 = samples + cur_channel;\n            la       = samples2 + (448+64) * avctx->channels;\n            if (!data)\n                la = NULL;\n            if (tag == TYPE_LFE) {\n                wi[ch].window_type[0] = ONLY_LONG_SEQUENCE;\n                wi[ch].window_shape   = 0;\n                wi[ch].num_windows    = 1;\n                wi[ch].grouping[0]    = 1;\n            } else {\n                wi[ch] = s->psy.model->window(&s->psy, samples2, la, cur_channel,\n                                              ics->window_sequence[0]);\n            }\n            ics->window_sequence[1] = ics->window_sequence[0];\n            ics->window_sequence[0] = wi[ch].window_type[0];\n            ics->use_kb_window[1]   = ics->use_kb_window[0];\n            ics->use_kb_window[0]   = wi[ch].window_shape;\n            ics->num_windows        = wi[ch].num_windows;\n            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];\n            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];\n            for (w = 0; w < ics->num_windows; w++)\n                ics->group_len[w] = wi[ch].grouping[w];\n\n            apply_window_and_mdct(avctx, s, &cpe->ch[ch], samples2);\n        }\n        start_ch += chans;\n    }\n    do {\n        int frame_bits;\n        init_put_bits(&s->pb, frame, buf_size*8);\n        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))\n            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n        start_ch = 0;\n        memset(chan_el_counter, 0, sizeof(chan_el_counter));\n        for (i = 0; i < chan_map[0]; i++) {\n            FFPsyWindowInfo* wi = windows + start_ch;\n            tag      = chan_map[i+1];\n            chans    = tag == TYPE_CPE ? 2 : 1;\n            cpe      = &s->cpe[i];\n            put_bits(&s->pb, 3, tag);\n            put_bits(&s->pb, 4, chan_el_counter[tag]++);\n            for (ch = 0; ch < chans; ch++) {\n                s->cur_channel = start_ch + ch;\n                s->psy.model->analyze(&s->psy, s->cur_channel, cpe->ch[ch].coeffs, &wi[ch]);\n                s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda);\n            }\n            cpe->common_window = 0;\n            if (chans > 1\n                && wi[0].window_type[0] == wi[1].window_type[0]\n                && wi[0].window_shape   == wi[1].window_shape) {\n\n                cpe->common_window = 1;\n                for (w = 0; w < wi[0].num_windows; w++) {\n                    if (wi[0].grouping[w] != wi[1].grouping[w]) {\n                        cpe->common_window = 0;\n                        break;\n                    }\n                }\n            }\n            s->cur_channel = start_ch;\n            if (cpe->common_window && s->coder->search_for_ms)\n                s->coder->search_for_ms(s, cpe, s->lambda);\n            adjust_frame_information(s, cpe, chans);\n            if (chans == 2) {\n                put_bits(&s->pb, 1, cpe->common_window);\n                if (cpe->common_window) {\n                    put_ics_info(s, &cpe->ch[0].ics);\n                    encode_ms_info(&s->pb, cpe);\n                }\n            }\n            for (ch = 0; ch < chans; ch++) {\n                s->cur_channel = start_ch + ch;\n                encode_individual_channel(avctx, s, &cpe->ch[ch], cpe->common_window);\n            }\n            start_ch += chans;\n        }\n\n        frame_bits = put_bits_count(&s->pb);\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n            break;\n        }\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n    } while (1);\n\n    put_bits(&s->pb, 3, TYPE_END);\n    flush_put_bits(&s->pb);\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n    // rate control stuff\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n        s->lambda *= ratio;\n        s->lambda = FFMIN(s->lambda, 65536.f);\n    }\n\n    if (!data)\n        s->last_frame = 1;\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n           1024 * avctx->channels * sizeof(s->samples[0]));\n    return put_bits_count(&s->pb)>>3;\n}", "patch_func_code": "static int aac_encode_frame(AVCodecContext *avctx,\n                            uint8_t *frame, int buf_size, void *data)\n{\n    AACEncContext *s = avctx->priv_data;\n    int16_t *samples = s->samples, *samples2, *la;\n    ChannelElement *cpe;\n    int i, ch, w, g, chans, tag, start_ch;\n    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];\n    int chan_el_counter[4];\n    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];\n\n    if (s->last_frame)\n        return 0;\n    if (data) {\n        if (!s->psypp) {\n            memcpy(s->samples + 1024 * avctx->channels, data,\n                   1024 * avctx->channels * sizeof(s->samples[0]));\n        } else {\n            start_ch = 0;\n            samples2 = s->samples + 1024 * avctx->channels;\n            for (i = 0; i < chan_map[0]; i++) {\n                tag = chan_map[i+1];\n                chans = tag == TYPE_CPE ? 2 : 1;\n                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,\n                                  samples2 + start_ch, start_ch, chans);\n                start_ch += chans;\n            }\n        }\n    }\n    if (!avctx->frame_number) {\n        memcpy(s->samples, s->samples + 1024 * avctx->channels,\n               1024 * avctx->channels * sizeof(s->samples[0]));\n        return 0;\n    }\n\n    start_ch = 0;\n    for (i = 0; i < chan_map[0]; i++) {\n        FFPsyWindowInfo* wi = windows + start_ch;\n        tag      = chan_map[i+1];\n        chans    = tag == TYPE_CPE ? 2 : 1;\n        cpe      = &s->cpe[i];\n        for (ch = 0; ch < chans; ch++) {\n            IndividualChannelStream *ics = &cpe->ch[ch].ics;\n            int cur_channel = start_ch + ch;\n            samples2 = samples + cur_channel;\n            la       = samples2 + (448+64) * avctx->channels;\n            if (!data)\n                la = NULL;\n            if (tag == TYPE_LFE) {\n                wi[ch].window_type[0] = ONLY_LONG_SEQUENCE;\n                wi[ch].window_shape   = 0;\n                wi[ch].num_windows    = 1;\n                wi[ch].grouping[0]    = 1;\n            } else {\n                wi[ch] = s->psy.model->window(&s->psy, samples2, la, cur_channel,\n                                              ics->window_sequence[0]);\n            }\n            ics->window_sequence[1] = ics->window_sequence[0];\n            ics->window_sequence[0] = wi[ch].window_type[0];\n            ics->use_kb_window[1]   = ics->use_kb_window[0];\n            ics->use_kb_window[0]   = wi[ch].window_shape;\n            ics->num_windows        = wi[ch].num_windows;\n            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];\n            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];\n            for (w = 0; w < ics->num_windows; w++)\n                ics->group_len[w] = wi[ch].grouping[w];\n\n            apply_window_and_mdct(avctx, s, &cpe->ch[ch], samples2);\n        }\n        start_ch += chans;\n    }\n    do {\n        int frame_bits;\n        init_put_bits(&s->pb, frame, buf_size*8);\n        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))\n            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n        start_ch = 0;\n        memset(chan_el_counter, 0, sizeof(chan_el_counter));\n        for (i = 0; i < chan_map[0]; i++) {\n            FFPsyWindowInfo* wi = windows + start_ch;\n            tag      = chan_map[i+1];\n            chans    = tag == TYPE_CPE ? 2 : 1;\n            cpe      = &s->cpe[i];\n            put_bits(&s->pb, 3, tag);\n            put_bits(&s->pb, 4, chan_el_counter[tag]++);\n            for (ch = 0; ch < chans; ch++) {\n                s->cur_channel = start_ch + ch;\n                s->psy.model->analyze(&s->psy, s->cur_channel, cpe->ch[ch].coeffs, &wi[ch]);\n                s->coder->search_for_quantizers(avctx, s, &cpe->ch[ch], s->lambda);\n            }\n            cpe->common_window = 0;\n            if (chans > 1\n                && wi[0].window_type[0] == wi[1].window_type[0]\n                && wi[0].window_shape   == wi[1].window_shape) {\n\n                cpe->common_window = 1;\n                for (w = 0; w < wi[0].num_windows; w++) {\n                    if (wi[0].grouping[w] != wi[1].grouping[w]) {\n                        cpe->common_window = 0;\n                        break;\n                    }\n                }\n            }\n            s->cur_channel = start_ch;\n            if (s->options.stereo_mode && cpe->common_window) {\n                if (s->options.stereo_mode > 0) {\n                    IndividualChannelStream *ics = &cpe->ch[0].ics;\n                    for (w = 0; w < ics->num_windows; w += ics->group_len[w])\n                        for (g = 0;  g < ics->num_swb; g++)\n                            cpe->ms_mask[w*16+g] = 1;\n                } else if (s->coder->search_for_ms) {\n                    s->coder->search_for_ms(s, cpe, s->lambda);\n                }\n            }\n            adjust_frame_information(s, cpe, chans);\n            if (chans == 2) {\n                put_bits(&s->pb, 1, cpe->common_window);\n                if (cpe->common_window) {\n                    put_ics_info(s, &cpe->ch[0].ics);\n                    encode_ms_info(&s->pb, cpe);\n                }\n            }\n            for (ch = 0; ch < chans; ch++) {\n                s->cur_channel = start_ch + ch;\n                encode_individual_channel(avctx, s, &cpe->ch[ch], cpe->common_window);\n            }\n            start_ch += chans;\n        }\n\n        frame_bits = put_bits_count(&s->pb);\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n            break;\n        }\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n    } while (1);\n\n    put_bits(&s->pb, 3, TYPE_END);\n    flush_put_bits(&s->pb);\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n    // rate control stuff\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n        s->lambda *= ratio;\n        s->lambda = FFMIN(s->lambda, 65536.f);\n    }\n\n    if (!data)\n        s->last_frame = 1;\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n           1024 * avctx->channels * sizeof(s->samples[0]));\n    return put_bits_count(&s->pb)>>3;\n}", "before_change_lines": [7, 105, 106], "raw_before_change_lines": [7, 105, 106], "after_change_lines": [7, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114], "raw_after_change_lines": [7, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114], "bug_lines": [7, 105, 106], "added": [false, false, false], "idx": 207}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "4996----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_034702df8e1951f18d998cc657c2330c1a86ed98_1.json----has_decode_delay_been_guessed", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_034702df8e1951f18d998cc657c2330c1a86ed98_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_034702df8e1951f18d998cc657c2330c1a86ed98_1.json", "function_name": "has_decode_delay_been_guessed", "vul_func_code": "static int has_decode_delay_been_guessed(AVStream *st)\n{\n    return st->codec->codec_id != CODEC_ID_H264 ||\n        st->codec_info_nb_frames >= 6 + st->codec->has_b_frames;\n}", "patch_func_code": "static int has_decode_delay_been_guessed(AVStream *st)\n{\n    return st->codec->codec_id != CODEC_ID_H264 ||\n        st->info->nb_decoded_frames >= 6;\n}", "before_change_lines": [4], "raw_before_change_lines": [4], "after_change_lines": [4], "raw_after_change_lines": [4], "bug_lines": [4], "added": [false], "idx": 208}
{"project": "libav", "vul_type": "INFERBO_ALLOC_MAY_BE_BIG", "filepath_func": "5000----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_037cbeda19bd56768caa2288d452b634d6b6a78e_1.json----av_buffer_realloc", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_037cbeda19bd56768caa2288d452b634d6b6a78e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_037cbeda19bd56768caa2288d452b634d6b6a78e_1.json", "function_name": "av_buffer_realloc", "vul_func_code": "int av_buffer_realloc(AVBufferRef **pbuf, int size)\n{\n    AVBufferRef *buf = *pbuf;\n    uint8_t *tmp;\n\n    if (!buf) {\n        /* allocate a new buffer with av_realloc(), so it will be reallocatable\n         * later */\n        uint8_t *data = av_realloc(NULL, size);\n        if (!data)\n            return AVERROR(ENOMEM);\n\n        buf = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);\n        if (!buf) {\n            av_freep(&data);\n            return AVERROR(ENOMEM);\n        }\n\n        buf->buffer->flags |= BUFFER_FLAG_REALLOCATABLE;\n        *pbuf = buf;\n\n        return 0;\n    } else if (buf->size == size)\n        return 0;\n\n    if (!(buf->buffer->flags & BUFFER_FLAG_REALLOCATABLE) ||\n        !av_buffer_is_writable(buf)) {\n        /* cannot realloc, allocate a new reallocable buffer and copy data */\n        AVBufferRef *new = NULL;\n\n        av_buffer_realloc(&new, size);\n        if (!new)\n            return AVERROR(ENOMEM);\n\n        memcpy(new->data, buf->data, FFMIN(size, buf->size));\n\n        av_buffer_unref(pbuf);\n        *pbuf = new;\n        return 0;\n    }\n\n    tmp = av_realloc(buf->buffer->data, size);\n    if (!tmp)\n        return AVERROR(ENOMEM);\n\n    buf->buffer->data = buf->data = tmp;\n    buf->buffer->size = buf->size = size;\n    return 0;\n}", "patch_func_code": "int av_buffer_realloc(AVBufferRef **pbuf, int size)\n{\n    AVBufferRef *buf = *pbuf;\n    uint8_t *tmp;\n\n    if (!buf) {\n        /* allocate a new buffer with av_realloc(), so it will be reallocatable\n         * later */\n        uint8_t *data = av_realloc(NULL, size);\n        if (!data)\n            return AVERROR(ENOMEM);\n\n        buf = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);\n        if (!buf) {\n            av_freep(&data);\n            return AVERROR(ENOMEM);\n        }\n\n        buf->buffer->flags |= BUFFER_FLAG_REALLOCATABLE;\n        *pbuf = buf;\n\n        return 0;\n    } else if (buf->size == size)\n        return 0;\n\n    if (!(buf->buffer->flags & BUFFER_FLAG_REALLOCATABLE) ||\n        !av_buffer_is_writable(buf) || buf->data != buf->buffer->data) {\n        /* cannot realloc, allocate a new reallocable buffer and copy data */\n        AVBufferRef *new = NULL;\n\n        av_buffer_realloc(&new, size);\n        if (!new)\n            return AVERROR(ENOMEM);\n\n        memcpy(new->data, buf->data, FFMIN(size, buf->size));\n\n        av_buffer_unref(pbuf);\n        *pbuf = new;\n        return 0;\n    }\n\n    tmp = av_realloc(buf->buffer->data, size);\n    if (!tmp)\n        return AVERROR(ENOMEM);\n\n    buf->buffer->data = buf->data = tmp;\n    buf->buffer->size = buf->size = size;\n    return 0;\n}", "before_change_lines": [27], "raw_before_change_lines": [27], "after_change_lines": [27], "raw_after_change_lines": [27], "bug_lines": [27], "added": [false], "idx": 209}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "5018----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_04c5b308e7eb4a6fc1eba7d7e5dc5b136ec5c13e_1.json----sao_band_filter_8", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_04c5b308e7eb4a6fc1eba7d7e5dc5b136ec5c13e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_04c5b308e7eb4a6fc1eba7d7e5dc5b136ec5c13e_1.json", "function_name": "sao_band_filter_8", "vul_func_code": "static void FUNC(sao_band_filter)(uint8_t *_dst, uint8_t *_src,\n                                  ptrdiff_t stride, SAOParams *sao,\n                                  int *borders, int width, int height,\n                                  int c_idx, int class)\n{\n    pixel *dst = (pixel *)_dst;\n    pixel *src = (pixel *)_src;\n    int offset_table[32] = { 0 };\n    int k, y, x;\n    int chroma = !!c_idx;\n    int shift  = BIT_DEPTH - 5;\n    int *sao_offset_val = sao->offset_val[c_idx];\n    int sao_left_class  = sao->band_position[c_idx];\n    int init_y = 0, init_x = 0;\n\n    stride /= sizeof(pixel);\n\n    switch (class) {\n    case 0:\n        if (!borders[2])\n            width -= (8 >> chroma) + 2;\n        if (!borders[3])\n            height -= (4 >> chroma) + 2;\n        break;\n    case 1:\n        init_y = -(4 >> chroma) - 2;\n        if (!borders[2])\n            width -= (8 >> chroma) + 2;\n        height = (4 >> chroma) + 2;\n        break;\n    case 2:\n        init_x = -(8 >> chroma) - 2;\n        width  =  (8 >> chroma) + 2;\n        if (!borders[3])\n            height -= (4 >> chroma) + 2;\n        break;\n    case 3:\n        init_y = -(4 >> chroma) - 2;\n        init_x = -(8 >> chroma) - 2;\n        width  =  (8 >> chroma) + 2;\n        height =  (4 >> chroma) + 2;\n        break;\n    }\n\n    dst = dst + (init_y * stride + init_x);\n    src = src + (init_y * stride + init_x);\n    for (k = 0; k < 4; k++)\n        offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1];\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++)\n            dst[x] = av_clip_pixel(src[x] + offset_table[av_clip_pixel(src[x] >> shift)]);\n        dst += stride;\n        src += stride;\n    }\n}", "patch_func_code": "static void FUNC(sao_band_filter)(uint8_t *_dst, uint8_t *_src,\n                                  ptrdiff_t stride, SAOParams *sao,\n                                  int *borders, int width, int height,\n                                  int c_idx, int class)\n{\n    pixel *dst = (pixel *)_dst;\n    pixel *src = (pixel *)_src;\n    int offset_table[32] = { 0 };\n    int k, y, x;\n    int chroma = !!c_idx;\n    int shift  = BIT_DEPTH - 5;\n    int *sao_offset_val = sao->offset_val[c_idx];\n    int sao_left_class  = sao->band_position[c_idx];\n    int init_y = 0, init_x = 0;\n\n    stride /= sizeof(pixel);\n\n    switch (class) {\n    case 0:\n        if (!borders[2])\n            width -= (8 >> chroma) + 2;\n        if (!borders[3])\n            height -= (4 >> chroma) + 2;\n        break;\n    case 1:\n        init_y = -(4 >> chroma) - 2;\n        if (!borders[2])\n            width -= (8 >> chroma) + 2;\n        height = (4 >> chroma) + 2;\n        break;\n    case 2:\n        init_x = -(8 >> chroma) - 2;\n        width  =  (8 >> chroma) + 2;\n        if (!borders[3])\n            height -= (4 >> chroma) + 2;\n        break;\n    case 3:\n        init_y = -(4 >> chroma) - 2;\n        init_x = -(8 >> chroma) - 2;\n        width  =  (8 >> chroma) + 2;\n        height =  (4 >> chroma) + 2;\n        break;\n    }\n\n    dst = dst + (init_y * stride + init_x);\n    src = src + (init_y * stride + init_x);\n    for (k = 0; k < 4; k++)\n        offset_table[(k + sao_left_class) & 31] = sao_offset_val[k + 1];\n    for (y = 0; y < height; y++) {\n        for (x = 0; x < width; x++)\n            dst[x] = av_clip_pixel(src[x] + offset_table[src[x] >> shift]);\n        dst += stride;\n        src += stride;\n    }\n}", "before_change_lines": [51], "raw_before_change_lines": [51], "after_change_lines": [51], "raw_after_change_lines": [51], "bug_lines": [51], "added": [false], "idx": 210}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5031----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_059049eb868293b44d1fb21a64ff34e03a27278d_1.json----start_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_059049eb868293b44d1fb21a64ff34e03a27278d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_059049eb868293b44d1fb21a64ff34e03a27278d_1.json", "function_name": "start_frame", "vul_func_code": "static void start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n{\n    ScaleContext *scale = link->dst->priv;\n    AVFilterLink *outlink = link->dst->outputs[0];\n    AVFilterBufferRef *outpicref;\n\n    scale->hsub = av_pix_fmt_descriptors[link->format].log2_chroma_w;\n    scale->vsub = av_pix_fmt_descriptors[link->format].log2_chroma_h;\n\n    outpicref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);\n    avfilter_copy_buffer_ref_props(outpicref, picref);\n\n    outlink->out_buf = outpicref;\n\n    av_reduce(&outpicref->pixel_aspect.num, &outpicref->pixel_aspect.den,\n              (int64_t)picref->pixel_aspect.num * outlink->h * link->w,\n              (int64_t)picref->pixel_aspect.den * outlink->w * link->h,\n              INT_MAX);\n\n    scale->slice_y = 0;\n    avfilter_start_frame(outlink, avfilter_ref_buffer(outpicref, ~0));\n}", "patch_func_code": "static void start_frame(AVFilterLink *link, AVFilterBufferRef *picref)\n{\n    ScaleContext *scale = link->dst->priv;\n    AVFilterLink *outlink = link->dst->outputs[0];\n    AVFilterBufferRef *outpicref;\n\n    scale->hsub = av_pix_fmt_descriptors[link->format].log2_chroma_w;\n    scale->vsub = av_pix_fmt_descriptors[link->format].log2_chroma_h;\n\n    outpicref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);\n    avfilter_copy_buffer_ref_props(outpicref, picref);\n\n    outlink->out_buf = outpicref;\n\n    av_reduce(&outpicref->video->pixel_aspect.num, &outpicref->video->pixel_aspect.den,\n              (int64_t)picref->video->pixel_aspect.num * outlink->h * link->w,\n              (int64_t)picref->video->pixel_aspect.den * outlink->w * link->h,\n              INT_MAX);\n\n    scale->slice_y = 0;\n    avfilter_start_frame(outlink, avfilter_ref_buffer(outpicref, ~0));\n}", "before_change_lines": [15, 16, 17], "raw_before_change_lines": [15, 16, 17], "after_change_lines": [15, 16, 17], "raw_after_change_lines": [15, 16, 17], "bug_lines": [15, 16, 17], "added": [false, false, false], "idx": 211}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5043----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_05ee2642682a2b1a2624ee29223824a2a588fa74_1.json----get_bits", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_05ee2642682a2b1a2624ee29223824a2a588fa74_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_05ee2642682a2b1a2624ee29223824a2a588fa74_1.json", "function_name": "get_bits", "vul_func_code": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n{\n    int res = 0;\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n        return AVERROR_INVALIDDATA;\n    while (--n >= 0) {\n        res <<= 1;\n        if (s->bit_index == 0) {\n            s->bit_index = 7 + (*s->buf != 0xff);\n            s->buf++;\n        }\n        s->bit_index--;\n        res |= (*s->buf >> s->bit_index) & 1;\n    }\n    return res;\n}", "patch_func_code": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n{\n    int res = 0;\n    while (--n >= 0) {\n        res <<= 1;\n        if (s->bit_index == 0) {\n            s->bit_index = 7 + (bytestream2_get_byte(&s->g) != 0xFFu);\n        }\n        s->bit_index--;\n        res |= (bytestream2_peek_byte(&s->g) >> s->bit_index) & 1;\n    }\n    return res;\n}", "before_change_lines": [4, 5, 9, 10, 13], "raw_before_change_lines": [4, 5, 9, 10, 13], "after_change_lines": [7, 10], "raw_after_change_lines": [7, 10], "bug_lines": [4, 5, 9, 10, 13], "added": [false, false, false, false, false], "idx": 212}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5069----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0729d81ee685e03e069781e830a733a372b6b4d7_1.json----pred8x8_left_dc_8_c", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_0729d81ee685e03e069781e830a733a372b6b4d7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0729d81ee685e03e069781e830a733a372b6b4d7_1.json", "function_name": "pred8x8_left_dc_8_c", "vul_func_code": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n    int i;\n    int dc0, dc2;\n    pixel4 dc0splat, dc2splat;\n    pixel *src = (pixel*)_src;\n    stride /= sizeof(pixel);\n\n    dc0=dc2=0;\n    for(i=0;i<4; i++){\n        dc0+= src[-1+i*stride];\n        dc2+= src[-1+(i+4)*stride];\n    }\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n    for(i=0; i<4; i++){\n        AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat);\n        AV_WN4PA(((pixel4*)(src+i*stride))+1, dc0splat);\n    }\n    for(i=4; i<8; i++){\n        AV_WN4PA(((pixel4*)(src+i*stride))+0, dc2splat);\n        AV_WN4PA(((pixel4*)(src+i*stride))+1, dc2splat);\n    }\n}", "patch_func_code": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, ptrdiff_t stride)\n{\n    int i;\n    int dc0, dc2;\n    pixel4 dc0splat, dc2splat;\n    pixel *src = (pixel*)_src;\n    stride /= sizeof(pixel);\n\n    dc0=dc2=0;\n    for(i=0;i<4; i++){\n        dc0+= src[-1+i*stride];\n        dc2+= src[-1+(i+4)*stride];\n    }\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n    for(i=0; i<4; i++){\n        AV_WN4PA(((pixel4*)(src+i*stride))+0, dc0splat);\n        AV_WN4PA(((pixel4*)(src+i*stride))+1, dc0splat);\n    }\n    for(i=4; i<8; i++){\n        AV_WN4PA(((pixel4*)(src+i*stride))+0, dc2splat);\n        AV_WN4PA(((pixel4*)(src+i*stride))+1, dc2splat);\n    }\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1, 2], "raw_after_change_lines": [1, 2], "bug_lines": [1], "added": [false], "idx": 213}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "5173----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0d15a1ee8f7b34c7e645d3097ac827a49b7d4ad9_1.json----adpcm_compress_trellis", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_0d15a1ee8f7b34c7e645d3097ac827a49b7d4ad9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_0d15a1ee8f7b34c7e645d3097ac827a49b7d4ad9_1.json", "function_name": "adpcm_compress_trellis", "vul_func_code": "static void adpcm_compress_trellis(AVCodecContext *avctx, const short *samples,\n                                   uint8_t *dst, ADPCMChannelStatus *c, int n)\n{\n    //FIXME 6% faster if frontier is a compile-time constant\n    ADPCMContext *s = avctx->priv_data;\n    const int frontier = 1 << avctx->trellis;\n    const int stride = avctx->channels;\n    const int version = avctx->codec->id;\n    TrellisPath *paths = s->paths, *p;\n    TrellisNode *node_buf = s->node_buf;\n    TrellisNode **nodep_buf = s->nodep_buf;\n    TrellisNode **nodes = nodep_buf; // nodes[] is always sorted by .ssd\n    TrellisNode **nodes_next = nodep_buf + frontier;\n    int pathn = 0, froze = -1, i, j, k;\n\n    memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf));\n    nodes[0] = node_buf + frontier;\n    nodes[0]->ssd = 0;\n    nodes[0]->path = 0;\n    nodes[0]->step = c->step_index;\n    nodes[0]->sample1 = c->sample1;\n    nodes[0]->sample2 = c->sample2;\n    if((version == CODEC_ID_ADPCM_IMA_WAV) || (version == CODEC_ID_ADPCM_IMA_QT) || (version == CODEC_ID_ADPCM_SWF))\n        nodes[0]->sample1 = c->prev_sample;\n    if(version == CODEC_ID_ADPCM_MS)\n        nodes[0]->step = c->idelta;\n    if(version == CODEC_ID_ADPCM_YAMAHA) {\n        if(c->step == 0) {\n            nodes[0]->step = 127;\n            nodes[0]->sample1 = 0;\n        } else {\n            nodes[0]->step = c->step;\n            nodes[0]->sample1 = c->predictor;\n        }\n    }\n\n    for(i=0; i<n; i++) {\n        TrellisNode *t = node_buf + frontier*(i&1);\n        TrellisNode **u;\n        int sample = samples[i*stride];\n        int heap_pos = 0;\n        memset(nodes_next, 0, frontier*sizeof(TrellisNode*));\n        for(j=0; j<frontier && nodes[j]; j++) {\n            // higher j have higher ssd already, so they're likely to yield a suboptimal next sample too\n            const int range = (j < frontier/2) ? 1 : 0;\n            const int step = nodes[j]->step;\n            int nidx;\n            if(version == CODEC_ID_ADPCM_MS) {\n                const int predictor = ((nodes[j]->sample1 * c->coeff1) + (nodes[j]->sample2 * c->coeff2)) / 64;\n                const int div = (sample - predictor) / step;\n                const int nmin = av_clip(div-range, -8, 6);\n                const int nmax = av_clip(div+range, -7, 7);\n                for(nidx=nmin; nidx<=nmax; nidx++) {\n                    const int nibble = nidx & 0xf;\n                    int dec_sample = predictor + nidx * step;\n#define STORE_NODE(NAME, STEP_INDEX)\\\n                    int d;\\\n                    uint32_t ssd;\\\n                    int pos;\\\n                    TrellisNode *u;\\\n                    dec_sample = av_clip_int16(dec_sample);\\\n                    d = sample - dec_sample;\\\n                    ssd = nodes[j]->ssd + d*d;\\\n                    /* Collapse any two states with the same previous sample value. \\\n                     * One could also distinguish states by step and by 2nd to last\n                     * sample, but the effects of that are negligible. */\\\n                    for(k=0; k<frontier && nodes_next[k]; k++) {\\\n                        if(dec_sample == nodes_next[k]->sample1) {\\\n                            assert(ssd >= nodes_next[k]->ssd);\\\n                            goto next_##NAME;\\\n                        }\\\n                    }\\\n                    if (heap_pos < frontier) {\\\n                        pos = heap_pos++;\\\n                    } else {\\\n                        /* Try to replace one of the leaf nodes with the new \\\n                         * one, but try a different slot each time. */\\\n                        pos = (frontier >> 1) + (heap_pos++ & ((frontier >> 1) - 1));\\\n                        if (ssd > nodes_next[pos]->ssd)\\\n                            goto next_##NAME;\\\n                    }\\\n                    u = nodes_next[pos];\\\n                    if(!u) {\\\n                        assert(pathn < FREEZE_INTERVAL<<avctx->trellis);\\\n                        u = t++;\\\n                        nodes_next[pos] = u;\\\n                        u->path = pathn++;\\\n                    }\\\n                    u->ssd = ssd;\\\n                    u->step = STEP_INDEX;\\\n                    u->sample2 = nodes[j]->sample1;\\\n                    u->sample1 = dec_sample;\\\n                    paths[u->path].nibble = nibble;\\\n                    paths[u->path].prev = nodes[j]->path;\\\n                    /* Sift the newly inserted node down in the heap to \\\n                     * restore the heap property. */\\\n                    while (pos > 0) {\\\n                        int parent = (pos - 1) >> 1;\\\n                        if (nodes_next[parent]->ssd <= ssd)\\\n                            break;\\\n                        FFSWAP(TrellisNode*, nodes_next[parent], nodes_next[pos]);\\\n                        pos = parent;\\\n                    }\\\n                    next_##NAME:;\n                    STORE_NODE(ms, FFMAX(16, (AdaptationTable[nibble] * step) >> 8));\n                }\n            } else if((version == CODEC_ID_ADPCM_IMA_WAV)|| (version == CODEC_ID_ADPCM_IMA_QT)|| (version == CODEC_ID_ADPCM_SWF)) {\n#define LOOP_NODES(NAME, STEP_TABLE, STEP_INDEX)\\\n                const int predictor = nodes[j]->sample1;\\\n                const int div = (sample - predictor) * 4 / STEP_TABLE;\\\n                int nmin = av_clip(div-range, -7, 6);\\\n                int nmax = av_clip(div+range, -6, 7);\\\n                if(nmin<=0) nmin--; /* distinguish -0 from +0 */\\\n                if(nmax<0) nmax--;\\\n                for(nidx=nmin; nidx<=nmax; nidx++) {\\\n                    const int nibble = nidx<0 ? 7-nidx : nidx;\\\n                    int dec_sample = predictor + (STEP_TABLE * yamaha_difflookup[nibble]) / 8;\\\n                    STORE_NODE(NAME, STEP_INDEX);\\\n                }\n                LOOP_NODES(ima, step_table[step], av_clip(step + index_table[nibble], 0, 88));\n            } else { //CODEC_ID_ADPCM_YAMAHA\n                LOOP_NODES(yamaha, step, av_clip((step * yamaha_indexscale[nibble]) >> 8, 127, 24567));\n#undef LOOP_NODES\n#undef STORE_NODE\n            }\n        }\n\n        u = nodes;\n        nodes = nodes_next;\n        nodes_next = u;\n\n        // prevent overflow\n        if(nodes[0]->ssd > (1<<28)) {\n            for(j=1; j<frontier && nodes[j]; j++)\n                nodes[j]->ssd -= nodes[0]->ssd;\n            nodes[0]->ssd = 0;\n        }\n\n        // merge old paths to save memory\n        if(i == froze + FREEZE_INTERVAL) {\n            p = &paths[nodes[0]->path];\n            for(k=i; k>froze; k--) {\n                dst[k] = p->nibble;\n                p = &paths[p->prev];\n            }\n            froze = i;\n            pathn = 0;\n            // other nodes might use paths that don't coincide with the frozen one.\n            // checking which nodes do so is too slow, so just kill them all.\n            // this also slightly improves quality, but I don't know why.\n            memset(nodes+1, 0, (frontier-1)*sizeof(TrellisNode*));\n        }\n    }\n\n    p = &paths[nodes[0]->path];\n    for(i=n-1; i>froze; i--) {\n        dst[i] = p->nibble;\n        p = &paths[p->prev];\n    }\n\n    c->predictor = nodes[0]->sample1;\n    c->sample1 = nodes[0]->sample1;\n    c->sample2 = nodes[0]->sample2;\n    c->step_index = nodes[0]->step;\n    c->step = nodes[0]->step;\n    c->idelta = nodes[0]->step;\n}", "patch_func_code": "static void adpcm_compress_trellis(AVCodecContext *avctx, const short *samples,\n                                   uint8_t *dst, ADPCMChannelStatus *c, int n)\n{\n    //FIXME 6% faster if frontier is a compile-time constant\n    ADPCMContext *s = avctx->priv_data;\n    const int frontier = 1 << avctx->trellis;\n    const int stride = avctx->channels;\n    const int version = avctx->codec->id;\n    TrellisPath *paths = s->paths, *p;\n    TrellisNode *node_buf = s->node_buf;\n    TrellisNode **nodep_buf = s->nodep_buf;\n    TrellisNode **nodes = nodep_buf; // nodes[] is always sorted by .ssd\n    TrellisNode **nodes_next = nodep_buf + frontier;\n    int pathn = 0, froze = -1, i, j, k, generation = 0;\n    uint8_t *hash = s->trellis_hash;\n    memset(hash, 0xff, 65536 * sizeof(*hash));\n\n    memset(nodep_buf, 0, 2 * frontier * sizeof(*nodep_buf));\n    nodes[0] = node_buf + frontier;\n    nodes[0]->ssd = 0;\n    nodes[0]->path = 0;\n    nodes[0]->step = c->step_index;\n    nodes[0]->sample1 = c->sample1;\n    nodes[0]->sample2 = c->sample2;\n    if((version == CODEC_ID_ADPCM_IMA_WAV) || (version == CODEC_ID_ADPCM_IMA_QT) || (version == CODEC_ID_ADPCM_SWF))\n        nodes[0]->sample1 = c->prev_sample;\n    if(version == CODEC_ID_ADPCM_MS)\n        nodes[0]->step = c->idelta;\n    if(version == CODEC_ID_ADPCM_YAMAHA) {\n        if(c->step == 0) {\n            nodes[0]->step = 127;\n            nodes[0]->sample1 = 0;\n        } else {\n            nodes[0]->step = c->step;\n            nodes[0]->sample1 = c->predictor;\n        }\n    }\n\n    for(i=0; i<n; i++) {\n        TrellisNode *t = node_buf + frontier*(i&1);\n        TrellisNode **u;\n        int sample = samples[i*stride];\n        int heap_pos = 0;\n        memset(nodes_next, 0, frontier*sizeof(TrellisNode*));\n        for(j=0; j<frontier && nodes[j]; j++) {\n            // higher j have higher ssd already, so they're likely to yield a suboptimal next sample too\n            const int range = (j < frontier/2) ? 1 : 0;\n            const int step = nodes[j]->step;\n            int nidx;\n            if(version == CODEC_ID_ADPCM_MS) {\n                const int predictor = ((nodes[j]->sample1 * c->coeff1) + (nodes[j]->sample2 * c->coeff2)) / 64;\n                const int div = (sample - predictor) / step;\n                const int nmin = av_clip(div-range, -8, 6);\n                const int nmax = av_clip(div+range, -7, 7);\n                for(nidx=nmin; nidx<=nmax; nidx++) {\n                    const int nibble = nidx & 0xf;\n                    int dec_sample = predictor + nidx * step;\n#define STORE_NODE(NAME, STEP_INDEX)\\\n                    int d;\\\n                    uint32_t ssd;\\\n                    int pos;\\\n                    TrellisNode *u;\\\n                    uint8_t *h;\\\n                    dec_sample = av_clip_int16(dec_sample);\\\n                    d = sample - dec_sample;\\\n                    ssd = nodes[j]->ssd + d*d;\\\n                    /* Collapse any two states with the same previous sample value. \\\n                     * One could also distinguish states by step and by 2nd to last\n                     * sample, but the effects of that are negligible.\n                     * Since nodes in the previous generation are iterated\n                     * through a heap, they're roughly ordered from better to\n                     * worse, but not strictly ordered. Therefore, an earlier\n                     * node with the same sample value is better in most cases\n                     * (and thus the current is skipped), but not strictly\n                     * in all cases. Only skipping samples where ssd >=\n                     * ssd of the earlier node with the same sample gives\n                     * slightly worse quality, though, for some reason. */ \\\n                    h = &hash[(uint16_t) dec_sample];\\\n                    if (*h == generation)\\\n                        goto next_##NAME;\\\n                    if (heap_pos < frontier) {\\\n                        pos = heap_pos++;\\\n                    } else {\\\n                        /* Try to replace one of the leaf nodes with the new \\\n                         * one, but try a different slot each time. */\\\n                        pos = (frontier >> 1) + (heap_pos++ & ((frontier >> 1) - 1));\\\n                        if (ssd > nodes_next[pos]->ssd)\\\n                            goto next_##NAME;\\\n                    }\\\n                    *h = generation;\\\n                    u = nodes_next[pos];\\\n                    if(!u) {\\\n                        assert(pathn < FREEZE_INTERVAL<<avctx->trellis);\\\n                        u = t++;\\\n                        nodes_next[pos] = u;\\\n                        u->path = pathn++;\\\n                    }\\\n                    u->ssd = ssd;\\\n                    u->step = STEP_INDEX;\\\n                    u->sample2 = nodes[j]->sample1;\\\n                    u->sample1 = dec_sample;\\\n                    paths[u->path].nibble = nibble;\\\n                    paths[u->path].prev = nodes[j]->path;\\\n                    /* Sift the newly inserted node down in the heap to \\\n                     * restore the heap property. */\\\n                    while (pos > 0) {\\\n                        int parent = (pos - 1) >> 1;\\\n                        if (nodes_next[parent]->ssd <= ssd)\\\n                            break;\\\n                        FFSWAP(TrellisNode*, nodes_next[parent], nodes_next[pos]);\\\n                        pos = parent;\\\n                    }\\\n                    next_##NAME:;\n                    STORE_NODE(ms, FFMAX(16, (AdaptationTable[nibble] * step) >> 8));\n                }\n            } else if((version == CODEC_ID_ADPCM_IMA_WAV)|| (version == CODEC_ID_ADPCM_IMA_QT)|| (version == CODEC_ID_ADPCM_SWF)) {\n#define LOOP_NODES(NAME, STEP_TABLE, STEP_INDEX)\\\n                const int predictor = nodes[j]->sample1;\\\n                const int div = (sample - predictor) * 4 / STEP_TABLE;\\\n                int nmin = av_clip(div-range, -7, 6);\\\n                int nmax = av_clip(div+range, -6, 7);\\\n                if(nmin<=0) nmin--; /* distinguish -0 from +0 */\\\n                if(nmax<0) nmax--;\\\n                for(nidx=nmin; nidx<=nmax; nidx++) {\\\n                    const int nibble = nidx<0 ? 7-nidx : nidx;\\\n                    int dec_sample = predictor + (STEP_TABLE * yamaha_difflookup[nibble]) / 8;\\\n                    STORE_NODE(NAME, STEP_INDEX);\\\n                }\n                LOOP_NODES(ima, step_table[step], av_clip(step + index_table[nibble], 0, 88));\n            } else { //CODEC_ID_ADPCM_YAMAHA\n                LOOP_NODES(yamaha, step, av_clip((step * yamaha_indexscale[nibble]) >> 8, 127, 24567));\n#undef LOOP_NODES\n#undef STORE_NODE\n            }\n        }\n\n        u = nodes;\n        nodes = nodes_next;\n        nodes_next = u;\n\n        generation++;\n        if (generation == 255) {\n            memset(hash, 0xff, 65536 * sizeof(*hash));\n            generation = 0;\n        }\n\n        // prevent overflow\n        if(nodes[0]->ssd > (1<<28)) {\n            for(j=1; j<frontier && nodes[j]; j++)\n                nodes[j]->ssd -= nodes[0]->ssd;\n            nodes[0]->ssd = 0;\n        }\n\n        // merge old paths to save memory\n        if(i == froze + FREEZE_INTERVAL) {\n            p = &paths[nodes[0]->path];\n            for(k=i; k>froze; k--) {\n                dst[k] = p->nibble;\n                p = &paths[p->prev];\n            }\n            froze = i;\n            pathn = 0;\n            // other nodes might use paths that don't coincide with the frozen one.\n            // checking which nodes do so is too slow, so just kill them all.\n            // this also slightly improves quality, but I don't know why.\n            memset(nodes+1, 0, (frontier-1)*sizeof(TrellisNode*));\n        }\n    }\n\n    p = &paths[nodes[0]->path];\n    for(i=n-1; i>froze; i--) {\n        dst[i] = p->nibble;\n        p = &paths[p->prev];\n    }\n\n    c->predictor = nodes[0]->sample1;\n    c->sample1 = nodes[0]->sample1;\n    c->sample2 = nodes[0]->sample2;\n    c->step_index = nodes[0]->step;\n    c->step = nodes[0]->step;\n    c->idelta = nodes[0]->step;\n}", "before_change_lines": [14, 66, 67, 68, 69, 70, 71, 72], "raw_before_change_lines": [14, 66, 67, 68, 69, 70, 71, 72], "after_change_lines": [14, 15, 16, 63, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 90, 141, 142, 143, 144, 145], "raw_after_change_lines": [14, 15, 16, 63, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 90, 141, 142, 143, 144, 145, 146], "bug_lines": [14, 66, 67, 68, 69, 70, 71, 72], "added": [false, false, false, false, false, false, false, false], "idx": 214}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "5213----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1042d8f583d04cb2c1ec54f2d31e184574c165eb_1.json----MPV_encode_picture", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1042d8f583d04cb2c1ec54f2d31e184574c165eb_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1042d8f583d04cb2c1ec54f2d31e184574c165eb_1.json", "function_name": "MPV_encode_picture", "vul_func_code": "int MPV_encode_picture(AVCodecContext *avctx,\n                       unsigned char *buf, int buf_size, void *data)\n{\n    MpegEncContext *s = avctx->priv_data;\n    AVFrame *pic_arg  = data;\n    int i, stuffing_count, context_count = avctx->thread_count;\n\n    for (i = 0; i < context_count; i++) {\n        int start_y = s->thread_context[i]->start_mb_y;\n        int   end_y = s->thread_context[i]->  end_mb_y;\n        int h       = s->mb_height;\n        uint8_t *start = buf + (size_t)(((int64_t) buf_size) * start_y / h);\n        uint8_t *end   = buf + (size_t)(((int64_t) buf_size) *   end_y / h);\n\n        init_put_bits(&s->thread_context[i]->pb, start, end - start);\n    }\n\n    s->picture_in_gop_number++;\n\n    if (load_input_picture(s, pic_arg) < 0)\n        return -1;\n\n    if (select_input_picture(s) < 0) {\n        return -1;\n    }\n\n    /* output? */\n    if (s->new_picture.f.data[0]) {\n        s->pict_type = s->new_picture.f.pict_type;\n        //emms_c();\n        //printf(\"qs:%f %f %d\\n\", s->new_picture.quality,\n        //       s->current_picture.quality, s->qscale);\n        MPV_frame_start(s, avctx);\nvbv_retry:\n        if (encode_picture(s, s->picture_number) < 0)\n            return -1;\n\n        avctx->header_bits = s->header_bits;\n        avctx->mv_bits     = s->mv_bits;\n        avctx->misc_bits   = s->misc_bits;\n        avctx->i_tex_bits  = s->i_tex_bits;\n        avctx->p_tex_bits  = s->p_tex_bits;\n        avctx->i_count     = s->i_count;\n        // FIXME f/b_count in avctx\n        avctx->p_count     = s->mb_num - s->i_count - s->skip_count;\n        avctx->skip_count  = s->skip_count;\n\n        MPV_frame_end(s);\n\n        if (CONFIG_MJPEG_ENCODER && s->out_format == FMT_MJPEG)\n            ff_mjpeg_encode_picture_trailer(s);\n\n        if (avctx->rc_buffer_size) {\n            RateControlContext *rcc = &s->rc_context;\n            int max_size = rcc->buffer_index * avctx->rc_max_available_vbv_use;\n\n            if (put_bits_count(&s->pb) > max_size &&\n                s->lambda < s->avctx->lmax) {\n                s->next_lambda = FFMAX(s->lambda + 1, s->lambda *\n                                       (s->qscale + 1) / s->qscale);\n                if (s->adaptive_quant) {\n                    int i;\n                    for (i = 0; i < s->mb_height * s->mb_stride; i++)\n                        s->lambda_table[i] =\n                            FFMAX(s->lambda_table[i] + 1,\n                                  s->lambda_table[i] * (s->qscale + 1) /\n                                  s->qscale);\n                }\n                s->mb_skipped = 0;        // done in MPV_frame_start()\n                // done in encode_picture() so we must undo it\n                if (s->pict_type == AV_PICTURE_TYPE_P) {\n                    if (s->flipflop_rounding          ||\n                        s->codec_id == CODEC_ID_H263P ||\n                        s->codec_id == CODEC_ID_MPEG4)\n                        s->no_rounding ^= 1;\n                }\n                if (s->pict_type != AV_PICTURE_TYPE_B) {\n                    s->time_base       = s->last_time_base;\n                    s->last_non_b_time = s->time - s->pp_time;\n                }\n                //av_log(NULL, AV_LOG_ERROR, \"R:%d \", s->next_lambda);\n                for (i = 0; i < context_count; i++) {\n                    PutBitContext *pb = &s->thread_context[i]->pb;\n                    init_put_bits(pb, pb->buf, pb->buf_end - pb->buf);\n                }\n                goto vbv_retry;\n            }\n\n            assert(s->avctx->rc_max_rate);\n        }\n\n        if (s->flags & CODEC_FLAG_PASS1)\n            ff_write_pass1_stats(s);\n\n        for (i = 0; i < 4; i++) {\n            s->current_picture_ptr->f.error[i] = s->current_picture.f.error[i];\n            avctx->error[i] += s->current_picture_ptr->f.error[i];\n        }\n\n        if (s->flags & CODEC_FLAG_PASS1)\n            assert(avctx->header_bits + avctx->mv_bits + avctx->misc_bits +\n                   avctx->i_tex_bits + avctx->p_tex_bits ==\n                       put_bits_count(&s->pb));\n        flush_put_bits(&s->pb);\n        s->frame_bits  = put_bits_count(&s->pb);\n\n        stuffing_count = ff_vbv_update(s, s->frame_bits);\n        if (stuffing_count) {\n            if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) <\n                    stuffing_count + 50) {\n                av_log(s->avctx, AV_LOG_ERROR, \"stuffing too large\\n\");\n                return -1;\n            }\n\n            switch (s->codec_id) {\n            case CODEC_ID_MPEG1VIDEO:\n            case CODEC_ID_MPEG2VIDEO:\n                while (stuffing_count--) {\n                    put_bits(&s->pb, 8, 0);\n                }\n            break;\n            case CODEC_ID_MPEG4:\n                put_bits(&s->pb, 16, 0);\n                put_bits(&s->pb, 16, 0x1C3);\n                stuffing_count -= 4;\n                while (stuffing_count--) {\n                    put_bits(&s->pb, 8, 0xFF);\n                }\n            break;\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"vbv buffer overflow\\n\");\n            }\n            flush_put_bits(&s->pb);\n            s->frame_bits  = put_bits_count(&s->pb);\n        }\n\n        /* update mpeg1/2 vbv_delay for CBR */\n        if (s->avctx->rc_max_rate                          &&\n            s->avctx->rc_min_rate == s->avctx->rc_max_rate &&\n            s->out_format == FMT_MPEG1                     &&\n            90000LL * (avctx->rc_buffer_size - 1) <=\n                s->avctx->rc_max_rate * 0xFFFFLL) {\n            int vbv_delay, min_delay;\n            double inbits  = s->avctx->rc_max_rate *\n                             av_q2d(s->avctx->time_base);\n            int    minbits = s->frame_bits - 8 *\n                             (s->vbv_delay_ptr - s->pb.buf - 1);\n            double bits    = s->rc_context.buffer_index + minbits - inbits;\n\n            if (bits < 0)\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Internal error, negative bits\\n\");\n\n            assert(s->repeat_first_field == 0);\n\n            vbv_delay = bits * 90000 / s->avctx->rc_max_rate;\n            min_delay = (minbits * 90000LL + s->avctx->rc_max_rate - 1) /\n                        s->avctx->rc_max_rate;\n\n            vbv_delay = FFMAX(vbv_delay, min_delay);\n\n            assert(vbv_delay < 0xFFFF);\n\n            s->vbv_delay_ptr[0] &= 0xF8;\n            s->vbv_delay_ptr[0] |= vbv_delay >> 13;\n            s->vbv_delay_ptr[1]  = vbv_delay >> 5;\n            s->vbv_delay_ptr[2] &= 0x07;\n            s->vbv_delay_ptr[2] |= vbv_delay << 3;\n            avctx->vbv_delay     = vbv_delay * 300;\n        }\n        s->total_bits     += s->frame_bits;\n        avctx->frame_bits  = s->frame_bits;\n    } else {\n        assert((put_bits_ptr(&s->pb) == s->pb.buf));\n        s->frame_bits = 0;\n    }\n    assert((s->frame_bits & 7) == 0);\n\n    return s->frame_bits / 8;\n}", "patch_func_code": "int MPV_encode_picture(AVCodecContext *avctx,\n                       unsigned char *buf, int buf_size, void *data)\n{\n    MpegEncContext *s = avctx->priv_data;\n    AVFrame *pic_arg  = data;\n    int i, stuffing_count;\n    int context_count = s->slice_context_count;\n\n    for (i = 0; i < context_count; i++) {\n        int start_y = s->thread_context[i]->start_mb_y;\n        int   end_y = s->thread_context[i]->  end_mb_y;\n        int h       = s->mb_height;\n        uint8_t *start = buf + (size_t)(((int64_t) buf_size) * start_y / h);\n        uint8_t *end   = buf + (size_t)(((int64_t) buf_size) *   end_y / h);\n\n        init_put_bits(&s->thread_context[i]->pb, start, end - start);\n    }\n\n    s->picture_in_gop_number++;\n\n    if (load_input_picture(s, pic_arg) < 0)\n        return -1;\n\n    if (select_input_picture(s) < 0) {\n        return -1;\n    }\n\n    /* output? */\n    if (s->new_picture.f.data[0]) {\n        s->pict_type = s->new_picture.f.pict_type;\n        //emms_c();\n        //printf(\"qs:%f %f %d\\n\", s->new_picture.quality,\n        //       s->current_picture.quality, s->qscale);\n        MPV_frame_start(s, avctx);\nvbv_retry:\n        if (encode_picture(s, s->picture_number) < 0)\n            return -1;\n\n        avctx->header_bits = s->header_bits;\n        avctx->mv_bits     = s->mv_bits;\n        avctx->misc_bits   = s->misc_bits;\n        avctx->i_tex_bits  = s->i_tex_bits;\n        avctx->p_tex_bits  = s->p_tex_bits;\n        avctx->i_count     = s->i_count;\n        // FIXME f/b_count in avctx\n        avctx->p_count     = s->mb_num - s->i_count - s->skip_count;\n        avctx->skip_count  = s->skip_count;\n\n        MPV_frame_end(s);\n\n        if (CONFIG_MJPEG_ENCODER && s->out_format == FMT_MJPEG)\n            ff_mjpeg_encode_picture_trailer(s);\n\n        if (avctx->rc_buffer_size) {\n            RateControlContext *rcc = &s->rc_context;\n            int max_size = rcc->buffer_index * avctx->rc_max_available_vbv_use;\n\n            if (put_bits_count(&s->pb) > max_size &&\n                s->lambda < s->avctx->lmax) {\n                s->next_lambda = FFMAX(s->lambda + 1, s->lambda *\n                                       (s->qscale + 1) / s->qscale);\n                if (s->adaptive_quant) {\n                    int i;\n                    for (i = 0; i < s->mb_height * s->mb_stride; i++)\n                        s->lambda_table[i] =\n                            FFMAX(s->lambda_table[i] + 1,\n                                  s->lambda_table[i] * (s->qscale + 1) /\n                                  s->qscale);\n                }\n                s->mb_skipped = 0;        // done in MPV_frame_start()\n                // done in encode_picture() so we must undo it\n                if (s->pict_type == AV_PICTURE_TYPE_P) {\n                    if (s->flipflop_rounding          ||\n                        s->codec_id == CODEC_ID_H263P ||\n                        s->codec_id == CODEC_ID_MPEG4)\n                        s->no_rounding ^= 1;\n                }\n                if (s->pict_type != AV_PICTURE_TYPE_B) {\n                    s->time_base       = s->last_time_base;\n                    s->last_non_b_time = s->time - s->pp_time;\n                }\n                //av_log(NULL, AV_LOG_ERROR, \"R:%d \", s->next_lambda);\n                for (i = 0; i < context_count; i++) {\n                    PutBitContext *pb = &s->thread_context[i]->pb;\n                    init_put_bits(pb, pb->buf, pb->buf_end - pb->buf);\n                }\n                goto vbv_retry;\n            }\n\n            assert(s->avctx->rc_max_rate);\n        }\n\n        if (s->flags & CODEC_FLAG_PASS1)\n            ff_write_pass1_stats(s);\n\n        for (i = 0; i < 4; i++) {\n            s->current_picture_ptr->f.error[i] = s->current_picture.f.error[i];\n            avctx->error[i] += s->current_picture_ptr->f.error[i];\n        }\n\n        if (s->flags & CODEC_FLAG_PASS1)\n            assert(avctx->header_bits + avctx->mv_bits + avctx->misc_bits +\n                   avctx->i_tex_bits + avctx->p_tex_bits ==\n                       put_bits_count(&s->pb));\n        flush_put_bits(&s->pb);\n        s->frame_bits  = put_bits_count(&s->pb);\n\n        stuffing_count = ff_vbv_update(s, s->frame_bits);\n        if (stuffing_count) {\n            if (s->pb.buf_end - s->pb.buf - (put_bits_count(&s->pb) >> 3) <\n                    stuffing_count + 50) {\n                av_log(s->avctx, AV_LOG_ERROR, \"stuffing too large\\n\");\n                return -1;\n            }\n\n            switch (s->codec_id) {\n            case CODEC_ID_MPEG1VIDEO:\n            case CODEC_ID_MPEG2VIDEO:\n                while (stuffing_count--) {\n                    put_bits(&s->pb, 8, 0);\n                }\n            break;\n            case CODEC_ID_MPEG4:\n                put_bits(&s->pb, 16, 0);\n                put_bits(&s->pb, 16, 0x1C3);\n                stuffing_count -= 4;\n                while (stuffing_count--) {\n                    put_bits(&s->pb, 8, 0xFF);\n                }\n            break;\n            default:\n                av_log(s->avctx, AV_LOG_ERROR, \"vbv buffer overflow\\n\");\n            }\n            flush_put_bits(&s->pb);\n            s->frame_bits  = put_bits_count(&s->pb);\n        }\n\n        /* update mpeg1/2 vbv_delay for CBR */\n        if (s->avctx->rc_max_rate                          &&\n            s->avctx->rc_min_rate == s->avctx->rc_max_rate &&\n            s->out_format == FMT_MPEG1                     &&\n            90000LL * (avctx->rc_buffer_size - 1) <=\n                s->avctx->rc_max_rate * 0xFFFFLL) {\n            int vbv_delay, min_delay;\n            double inbits  = s->avctx->rc_max_rate *\n                             av_q2d(s->avctx->time_base);\n            int    minbits = s->frame_bits - 8 *\n                             (s->vbv_delay_ptr - s->pb.buf - 1);\n            double bits    = s->rc_context.buffer_index + minbits - inbits;\n\n            if (bits < 0)\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"Internal error, negative bits\\n\");\n\n            assert(s->repeat_first_field == 0);\n\n            vbv_delay = bits * 90000 / s->avctx->rc_max_rate;\n            min_delay = (minbits * 90000LL + s->avctx->rc_max_rate - 1) /\n                        s->avctx->rc_max_rate;\n\n            vbv_delay = FFMAX(vbv_delay, min_delay);\n\n            assert(vbv_delay < 0xFFFF);\n\n            s->vbv_delay_ptr[0] &= 0xF8;\n            s->vbv_delay_ptr[0] |= vbv_delay >> 13;\n            s->vbv_delay_ptr[1]  = vbv_delay >> 5;\n            s->vbv_delay_ptr[2] &= 0x07;\n            s->vbv_delay_ptr[2] |= vbv_delay << 3;\n            avctx->vbv_delay     = vbv_delay * 300;\n        }\n        s->total_bits     += s->frame_bits;\n        avctx->frame_bits  = s->frame_bits;\n    } else {\n        assert((put_bits_ptr(&s->pb) == s->pb.buf));\n        s->frame_bits = 0;\n    }\n    assert((s->frame_bits & 7) == 0);\n\n    return s->frame_bits / 8;\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6, 7], "raw_after_change_lines": [6, 7], "bug_lines": [6], "added": [false], "idx": 215}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5255----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_12090119c14a576beafb6052ae8f35a0f12b803a_1.json----pred8x8l_vertical_add_8_c", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_12090119c14a576beafb6052ae8f35a0f12b803a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_12090119c14a576beafb6052ae8f35a0f12b803a_1.json", "function_name": "pred8x8l_vertical_add_8_c", "vul_func_code": "static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const DCTELEM *_block, int stride){\n    int i;\n    pixel *pix = (pixel*)_pix;\n    const dctcoef *block = (const dctcoef*)_block;\n    stride /= sizeof(pixel);\n    pix -= stride;\n    for(i=0; i<8; i++){\n        pixel v = pix[0];\n        pix[1*stride]= v += block[0];\n        pix[2*stride]= v += block[8];\n        pix[3*stride]= v += block[16];\n        pix[4*stride]= v += block[24];\n        pix[5*stride]= v += block[32];\n        pix[6*stride]= v += block[40];\n        pix[7*stride]= v += block[48];\n        pix[8*stride]= v +  block[56];\n        pix++;\n        block++;\n    }\n}", "patch_func_code": "static void FUNCC(pred8x8l_vertical_add)(uint8_t *_pix, const DCTELEM *_block,\n                                         ptrdiff_t stride)\n{\n    int i;\n    pixel *pix = (pixel*)_pix;\n    const dctcoef *block = (const dctcoef*)_block;\n    stride /= sizeof(pixel);\n    pix -= stride;\n    for(i=0; i<8; i++){\n        pixel v = pix[0];\n        pix[1*stride]= v += block[0];\n        pix[2*stride]= v += block[8];\n        pix[3*stride]= v += block[16];\n        pix[4*stride]= v += block[24];\n        pix[5*stride]= v += block[32];\n        pix[6*stride]= v += block[40];\n        pix[7*stride]= v += block[48];\n        pix[8*stride]= v +  block[56];\n        pix++;\n        block++;\n    }\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1, 2, 3], "raw_after_change_lines": [1, 2, 3], "bug_lines": [1], "added": [false], "idx": 216}
{"project": "libav", "vul_type": "INFERBO_ALLOC_MAY_BE_BIG", "filepath_func": "5266----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1233805ab017e35822814c4434650d3dd06a45de_1.json----select_input_picture", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1233805ab017e35822814c4434650d3dd06a45de_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1233805ab017e35822814c4434650d3dd06a45de_1.json", "function_name": "select_input_picture", "vul_func_code": "static int select_input_picture(MpegEncContext *s)\n{\n    int i, ret;\n\n    for (i = 1; i < MAX_PICTURE_COUNT; i++)\n        s->reordered_input_picture[i - 1] = s->reordered_input_picture[i];\n    s->reordered_input_picture[MAX_PICTURE_COUNT - 1] = NULL;\n\n    /* set next picture type & ordering */\n    if (!s->reordered_input_picture[0] && s->input_picture[0]) {\n        if (/*s->picture_in_gop_number >= s->gop_size ||*/\n            !s->next_picture_ptr || s->intra_only) {\n            s->reordered_input_picture[0] = s->input_picture[0];\n            s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_I;\n            s->reordered_input_picture[0]->f->coded_picture_number =\n                s->coded_picture_number++;\n        } else {\n            int b_frames;\n\n            if (s->avctx->frame_skip_threshold || s->avctx->frame_skip_factor) {\n                if (s->picture_in_gop_number < s->gop_size &&\n                    skip_check(s, s->input_picture[0], s->next_picture_ptr)) {\n                    // FIXME check that te gop check above is +-1 correct\n                    av_frame_unref(s->input_picture[0]->f);\n\n                    emms_c();\n                    ff_vbv_update(s, 0);\n\n                    goto no_output_pic;\n                }\n            }\n\n            if (s->avctx->flags & CODEC_FLAG_PASS2) {\n                for (i = 0; i < s->max_b_frames + 1; i++) {\n                    int pict_num = s->input_picture[0]->f->display_picture_number + i;\n\n                    if (pict_num >= s->rc_context.num_entries)\n                        break;\n                    if (!s->input_picture[i]) {\n                        s->rc_context.entry[pict_num - 1].new_pict_type = AV_PICTURE_TYPE_P;\n                        break;\n                    }\n\n                    s->input_picture[i]->f->pict_type =\n                        s->rc_context.entry[pict_num].new_pict_type;\n                }\n            }\n\n            if (s->avctx->b_frame_strategy == 0) {\n                b_frames = s->max_b_frames;\n                while (b_frames && !s->input_picture[b_frames])\n                    b_frames--;\n            } else if (s->avctx->b_frame_strategy == 1) {\n                for (i = 1; i < s->max_b_frames + 1; i++) {\n                    if (s->input_picture[i] &&\n                        s->input_picture[i]->b_frame_score == 0) {\n                        s->input_picture[i]->b_frame_score =\n                            get_intra_count(s,\n                                            s->input_picture[i    ]->f->data[0],\n                                            s->input_picture[i - 1]->f->data[0],\n                                            s->linesize) + 1;\n                    }\n                }\n                for (i = 0; i < s->max_b_frames + 1; i++) {\n                    if (!s->input_picture[i] ||\n                        s->input_picture[i]->b_frame_score - 1 >\n                            s->mb_num / s->avctx->b_sensitivity)\n                        break;\n                }\n\n                b_frames = FFMAX(0, i - 1);\n\n                /* reset scores */\n                for (i = 0; i < b_frames + 1; i++) {\n                    s->input_picture[i]->b_frame_score = 0;\n                }\n            } else if (s->avctx->b_frame_strategy == 2) {\n                b_frames = estimate_best_b_count(s);\n            } else {\n                av_log(s->avctx, AV_LOG_ERROR, \"illegal b frame strategy\\n\");\n                b_frames = 0;\n            }\n\n            emms_c();\n\n            for (i = b_frames - 1; i >= 0; i--) {\n                int type = s->input_picture[i]->f->pict_type;\n                if (type && type != AV_PICTURE_TYPE_B)\n                    b_frames = i;\n            }\n            if (s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_B &&\n                b_frames == s->max_b_frames) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"warning, too many b frames in a row\\n\");\n            }\n\n            if (s->picture_in_gop_number + b_frames >= s->gop_size) {\n                if ((s->mpv_flags & FF_MPV_FLAG_STRICT_GOP) &&\n                    s->gop_size > s->picture_in_gop_number) {\n                    b_frames = s->gop_size - s->picture_in_gop_number - 1;\n                } else {\n                    if (s->avctx->flags & CODEC_FLAG_CLOSED_GOP)\n                        b_frames = 0;\n                    s->input_picture[b_frames]->f->pict_type = AV_PICTURE_TYPE_I;\n                }\n            }\n\n            if ((s->avctx->flags & CODEC_FLAG_CLOSED_GOP) && b_frames &&\n                s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_I)\n                b_frames--;\n\n            s->reordered_input_picture[0] = s->input_picture[b_frames];\n            if (s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_I)\n                s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_P;\n            s->reordered_input_picture[0]->f->coded_picture_number =\n                s->coded_picture_number++;\n            for (i = 0; i < b_frames; i++) {\n                s->reordered_input_picture[i + 1] = s->input_picture[i];\n                s->reordered_input_picture[i + 1]->f->pict_type =\n                    AV_PICTURE_TYPE_B;\n                s->reordered_input_picture[i + 1]->f->coded_picture_number =\n                    s->coded_picture_number++;\n            }\n        }\n    }\nno_output_pic:\n    if (s->reordered_input_picture[0]) {\n        s->reordered_input_picture[0]->reference =\n           s->reordered_input_picture[0]->f->pict_type !=\n               AV_PICTURE_TYPE_B ? 3 : 0;\n\n        ff_mpeg_unref_picture(s, &s->new_picture);\n        if ((ret = ff_mpeg_ref_picture(s, &s->new_picture, s->reordered_input_picture[0])))\n            return ret;\n\n        if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) {\n            // input is a shared pix, so we can't modifiy it -> alloc a new\n            // one & ensure that the shared one is reuseable\n\n            Picture *pic;\n            int i = ff_find_unused_picture(s, 0);\n            if (i < 0)\n                return i;\n            pic = &s->picture[i];\n\n            pic->reference = s->reordered_input_picture[0]->reference;\n            if (ff_alloc_picture(s, pic, 0) < 0) {\n                return -1;\n            }\n\n            ret = av_frame_copy_props(pic->f, s->reordered_input_picture[0]->f);\n            if (ret < 0)\n                return ret;\n\n            /* mark us unused / free shared pic */\n            av_frame_unref(s->reordered_input_picture[0]->f);\n            s->reordered_input_picture[0]->shared = 0;\n\n            s->current_picture_ptr = pic;\n        } else {\n            // input is not a shared pix -> reuse buffer for current_pix\n            s->current_picture_ptr = s->reordered_input_picture[0];\n            for (i = 0; i < 4; i++) {\n                s->new_picture.f->data[i] += INPLACE_OFFSET;\n            }\n        }\n        ff_mpeg_unref_picture(s, &s->current_picture);\n        if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n                                       s->current_picture_ptr)) < 0)\n            return ret;\n\n        s->picture_number = s->new_picture.f->display_picture_number;\n    } else {\n        ff_mpeg_unref_picture(s, &s->new_picture);\n    }\n    return 0;\n}", "patch_func_code": "static int select_input_picture(MpegEncContext *s)\n{\n    int i, ret;\n\n    for (i = 1; i < MAX_PICTURE_COUNT; i++)\n        s->reordered_input_picture[i - 1] = s->reordered_input_picture[i];\n    s->reordered_input_picture[MAX_PICTURE_COUNT - 1] = NULL;\n\n    /* set next picture type & ordering */\n    if (!s->reordered_input_picture[0] && s->input_picture[0]) {\n        if (/*s->picture_in_gop_number >= s->gop_size ||*/\n            !s->next_picture_ptr || s->intra_only) {\n            s->reordered_input_picture[0] = s->input_picture[0];\n            s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_I;\n            s->reordered_input_picture[0]->f->coded_picture_number =\n                s->coded_picture_number++;\n        } else {\n            int b_frames;\n\n            if (s->avctx->frame_skip_threshold || s->avctx->frame_skip_factor) {\n                if (s->picture_in_gop_number < s->gop_size &&\n                    skip_check(s, s->input_picture[0], s->next_picture_ptr)) {\n                    // FIXME check that te gop check above is +-1 correct\n                    av_frame_unref(s->input_picture[0]->f);\n\n                    emms_c();\n                    ff_vbv_update(s, 0);\n\n                    goto no_output_pic;\n                }\n            }\n\n            if (s->avctx->flags & CODEC_FLAG_PASS2) {\n                for (i = 0; i < s->max_b_frames + 1; i++) {\n                    int pict_num = s->input_picture[0]->f->display_picture_number + i;\n\n                    if (pict_num >= s->rc_context.num_entries)\n                        break;\n                    if (!s->input_picture[i]) {\n                        s->rc_context.entry[pict_num - 1].new_pict_type = AV_PICTURE_TYPE_P;\n                        break;\n                    }\n\n                    s->input_picture[i]->f->pict_type =\n                        s->rc_context.entry[pict_num].new_pict_type;\n                }\n            }\n\n            if (s->avctx->b_frame_strategy == 0) {\n                b_frames = s->max_b_frames;\n                while (b_frames && !s->input_picture[b_frames])\n                    b_frames--;\n            } else if (s->avctx->b_frame_strategy == 1) {\n                for (i = 1; i < s->max_b_frames + 1; i++) {\n                    if (s->input_picture[i] &&\n                        s->input_picture[i]->b_frame_score == 0) {\n                        s->input_picture[i]->b_frame_score =\n                            get_intra_count(s,\n                                            s->input_picture[i    ]->f->data[0],\n                                            s->input_picture[i - 1]->f->data[0],\n                                            s->linesize) + 1;\n                    }\n                }\n                for (i = 0; i < s->max_b_frames + 1; i++) {\n                    if (!s->input_picture[i] ||\n                        s->input_picture[i]->b_frame_score - 1 >\n                            s->mb_num / s->avctx->b_sensitivity)\n                        break;\n                }\n\n                b_frames = FFMAX(0, i - 1);\n\n                /* reset scores */\n                for (i = 0; i < b_frames + 1; i++) {\n                    s->input_picture[i]->b_frame_score = 0;\n                }\n            } else if (s->avctx->b_frame_strategy == 2) {\n                b_frames = estimate_best_b_count(s);\n            } else {\n                av_log(s->avctx, AV_LOG_ERROR, \"illegal b frame strategy\\n\");\n                b_frames = 0;\n            }\n\n            emms_c();\n\n            for (i = b_frames - 1; i >= 0; i--) {\n                int type = s->input_picture[i]->f->pict_type;\n                if (type && type != AV_PICTURE_TYPE_B)\n                    b_frames = i;\n            }\n            if (s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_B &&\n                b_frames == s->max_b_frames) {\n                av_log(s->avctx, AV_LOG_ERROR,\n                       \"warning, too many b frames in a row\\n\");\n            }\n\n            if (s->picture_in_gop_number + b_frames >= s->gop_size) {\n                if ((s->mpv_flags & FF_MPV_FLAG_STRICT_GOP) &&\n                    s->gop_size > s->picture_in_gop_number) {\n                    b_frames = s->gop_size - s->picture_in_gop_number - 1;\n                } else {\n                    if (s->avctx->flags & CODEC_FLAG_CLOSED_GOP)\n                        b_frames = 0;\n                    s->input_picture[b_frames]->f->pict_type = AV_PICTURE_TYPE_I;\n                }\n            }\n\n            if ((s->avctx->flags & CODEC_FLAG_CLOSED_GOP) && b_frames &&\n                s->input_picture[b_frames]->f->pict_type == AV_PICTURE_TYPE_I)\n                b_frames--;\n\n            s->reordered_input_picture[0] = s->input_picture[b_frames];\n            if (s->reordered_input_picture[0]->f->pict_type != AV_PICTURE_TYPE_I)\n                s->reordered_input_picture[0]->f->pict_type = AV_PICTURE_TYPE_P;\n            s->reordered_input_picture[0]->f->coded_picture_number =\n                s->coded_picture_number++;\n            for (i = 0; i < b_frames; i++) {\n                s->reordered_input_picture[i + 1] = s->input_picture[i];\n                s->reordered_input_picture[i + 1]->f->pict_type =\n                    AV_PICTURE_TYPE_B;\n                s->reordered_input_picture[i + 1]->f->coded_picture_number =\n                    s->coded_picture_number++;\n            }\n        }\n    }\nno_output_pic:\n    if (s->reordered_input_picture[0]) {\n        s->reordered_input_picture[0]->reference =\n           s->reordered_input_picture[0]->f->pict_type !=\n               AV_PICTURE_TYPE_B ? 3 : 0;\n\n        ff_mpeg_unref_picture(s->avctx, &s->new_picture);\n        if ((ret = ff_mpeg_ref_picture(s, &s->new_picture, s->reordered_input_picture[0])))\n            return ret;\n\n        if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) {\n            // input is a shared pix, so we can't modifiy it -> alloc a new\n            // one & ensure that the shared one is reuseable\n\n            Picture *pic;\n            int i = ff_find_unused_picture(s, 0);\n            if (i < 0)\n                return i;\n            pic = &s->picture[i];\n\n            pic->reference = s->reordered_input_picture[0]->reference;\n            if (ff_alloc_picture(s, pic, 0) < 0) {\n                return -1;\n            }\n\n            ret = av_frame_copy_props(pic->f, s->reordered_input_picture[0]->f);\n            if (ret < 0)\n                return ret;\n\n            /* mark us unused / free shared pic */\n            av_frame_unref(s->reordered_input_picture[0]->f);\n            s->reordered_input_picture[0]->shared = 0;\n\n            s->current_picture_ptr = pic;\n        } else {\n            // input is not a shared pix -> reuse buffer for current_pix\n            s->current_picture_ptr = s->reordered_input_picture[0];\n            for (i = 0; i < 4; i++) {\n                s->new_picture.f->data[i] += INPLACE_OFFSET;\n            }\n        }\n        ff_mpeg_unref_picture(s->avctx, &s->current_picture);\n        if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n                                       s->current_picture_ptr)) < 0)\n            return ret;\n\n        s->picture_number = s->new_picture.f->display_picture_number;\n    } else {\n        ff_mpeg_unref_picture(s->avctx, &s->new_picture);\n    }\n    return 0;\n}", "before_change_lines": [132, 167, 174], "raw_before_change_lines": [132, 167, 174], "after_change_lines": [132, 167, 174], "raw_after_change_lines": [132, 167, 174], "bug_lines": [132, 167, 174], "added": [false, false, false], "idx": 217}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5299----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_13d8eb80257c7c69c45016a685163b48b587b9ed_1.json----mov_write_mdia_tag", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_13d8eb80257c7c69c45016a685163b48b587b9ed_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_13d8eb80257c7c69c45016a685163b48b587b9ed_1.json", "function_name": "mov_write_mdia_tag", "vul_func_code": "static int mov_write_mdia_tag(AVIOContext *pb, MOVMuxContext *mov,\n                              MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"mdia\");\n    mov_write_mdhd_tag(pb, mov, track);\n    mov_write_hdlr_tag(pb, track);\n    mov_write_minf_tag(pb, track);\n    return update_size(pb, pos);\n}", "patch_func_code": "static int mov_write_mdia_tag(AVFormatContext *s, AVIOContext *pb,\n                              MOVMuxContext *mov, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"mdia\");\n    mov_write_mdhd_tag(pb, mov, track);\n    mov_write_hdlr_tag(s, pb, track);\n    mov_write_minf_tag(s, pb, track);\n    return update_size(pb, pos);\n}", "before_change_lines": [1, 2, 8, 9], "raw_before_change_lines": [1, 2, 8, 9], "after_change_lines": [1, 2, 8, 9], "raw_after_change_lines": [1, 2, 8, 9], "bug_lines": [1, 2, 8, 9], "added": [false, false, false, false], "idx": 218}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5326----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1612cfa9a598d8f3bd2a3e29f7e6d0bad32752c4_1.json----svq3_decode_end", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1612cfa9a598d8f3bd2a3e29f7e6d0bad32752c4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1612cfa9a598d8f3bd2a3e29f7e6d0bad32752c4_1.json", "function_name": "svq3_decode_end", "vul_func_code": "static int svq3_decode_end(AVCodecContext *avctx)\n{\n    SVQ3Context *svq3 = avctx->priv_data;\n    H264Context *h    = &svq3->h;\n    MpegEncContext *s = &h->s;\n\n    ff_h264_free_context(h);\n\n    ff_MPV_common_end(s);\n\n    return 0;\n}", "patch_func_code": "static int svq3_decode_end(AVCodecContext *avctx)\n{\n    SVQ3Context *s = avctx->priv_data;\n    H264Context *h = &s->h;\n\n    free_picture(avctx, s->cur_pic);\n    free_picture(avctx, s->next_pic);\n    free_picture(avctx, s->last_pic);\n\n    ff_h264_free_context(h);\n\n    return 0;\n}", "before_change_lines": [3, 4, 5, 7, 9], "raw_before_change_lines": [3, 4, 5, 7, 9], "after_change_lines": [3, 4, 6, 7, 8, 10], "raw_after_change_lines": [3, 4, 6, 7, 8, 10], "bug_lines": [3, 4, 5, 7, 9], "added": [false, false, false, false, false], "idx": 219}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5357----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_189515a40204c431d8255dc93c743c5dc0c1887f_1.json----seg_write_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_189515a40204c431d8255dc93c743c5dc0c1887f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_189515a40204c431d8255dc93c743c5dc0c1887f_1.json", "function_name": "seg_write_packet", "vul_func_code": "static int seg_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    SegmentContext *seg = s->priv_data;\n    AVFormatContext *oc = seg->avf;\n    AVStream *st = s->streams[pkt->stream_index];\n    int64_t end_pts = seg->recording_time * seg->number;\n    int ret, can_split = 1;\n\n    if (!oc)\n        return AVERROR(EINVAL);\n\n    if (seg->has_video) {\n        can_split = st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    pkt->flags & AV_PKT_FLAG_KEY;\n    }\n\n    if (can_split && av_compare_ts(pkt->pts, st->time_base, end_pts,\n                                   AV_TIME_BASE_Q) >= 0) {\n        av_log(s, AV_LOG_DEBUG, \"Next segment starts at %d %\"PRId64\"\\n\",\n               pkt->stream_index, pkt->pts);\n\n        ret = segment_end(oc, seg->individual_header_trailer);\n\n        if (!ret)\n            ret = segment_start(s, seg->individual_header_trailer);\n\n        if (ret)\n            goto fail;\n\n        oc = seg->avf;\n\n        if (seg->list) {\n            if (seg->list_type == LIST_HLS) {\n                if ((ret = segment_hls_window(s, 0)) < 0)\n                    goto fail;\n            } else {\n                avio_printf(seg->pb, \"%s\\n\", oc->filename);\n                avio_flush(seg->pb);\n                if (seg->size && !(seg->number % seg->size)) {\n                    avio_closep(&seg->pb);\n                    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n                                          &s->interrupt_callback, NULL)) < 0)\n                        goto fail;\n                }\n            }\n        }\n    }\n\n    ret = ff_write_chained(oc, pkt->stream_index, pkt, s);\n\nfail:\n    if (ret < 0)\n        seg_free_context(seg);\n\n    return ret;\n}", "patch_func_code": "static int seg_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    SegmentContext *seg = s->priv_data;\n    AVFormatContext *oc = seg->avf;\n    AVStream *st = s->streams[pkt->stream_index];\n    int64_t end_pts = seg->recording_time * seg->number;\n    int ret, can_split = 1;\n\n    if (!oc)\n        return AVERROR(EINVAL);\n\n    if (seg->has_video) {\n        can_split = st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n                    pkt->flags & AV_PKT_FLAG_KEY;\n    }\n\n    if (can_split && av_compare_ts(pkt->pts, st->time_base, end_pts,\n                                   AV_TIME_BASE_Q) >= 0) {\n        av_log(s, AV_LOG_DEBUG, \"Next segment starts at %d %\"PRId64\"\\n\",\n               pkt->stream_index, pkt->pts);\n\n        ret = segment_end(oc, seg->individual_header_trailer);\n\n        if (!ret)\n            ret = segment_start(s, seg->individual_header_trailer);\n\n        if (ret)\n            goto fail;\n\n        oc = seg->avf;\n\n        if (seg->list) {\n            if (seg->list_type == LIST_HLS) {\n                if ((ret = segment_hls_window(s, 0)) < 0)\n                    goto fail;\n            } else {\n                avio_printf(seg->pb, \"%s\\n\", oc->filename);\n                avio_flush(seg->pb);\n                if (seg->size && !(seg->number % seg->size)) {\n                    ff_format_io_close(s, &seg->pb);\n                    if ((ret = s->io_open(s, &seg->pb, seg->list,\n                                          AVIO_FLAG_WRITE, NULL)) < 0)\n                        goto fail;\n                }\n            }\n        }\n    }\n\n    ret = ff_write_chained(oc, pkt->stream_index, pkt, s);\n\nfail:\n    if (ret < 0)\n        seg_free_context(seg);\n\n    return ret;\n}", "before_change_lines": [40, 41, 42], "raw_before_change_lines": [40, 41, 42], "after_change_lines": [40, 41, 42], "raw_after_change_lines": [40, 41, 42], "bug_lines": [40, 41, 42], "added": [false, false, false], "idx": 220}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5376----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_19a4adaa3985d39b724942b7121dd7beab666c5b_1.json----dash_write_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_19a4adaa3985d39b724942b7121dd7beab666c5b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_19a4adaa3985d39b724942b7121dd7beab666c5b_1.json", "function_name": "dash_write_packet", "vul_func_code": "static int dash_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    DASHContext *c = s->priv_data;\n    AVStream *st = s->streams[pkt->stream_index];\n    OutputStream *os = &c->streams[pkt->stream_index];\n    int64_t seg_end_duration = (os->segment_index) * (int64_t) c->min_seg_duration;\n    int ret;\n\n    // If forcing the stream to start at 0, the mp4 muxer will set the start\n    // timestamps to 0. Do the same here, to avoid mismatches in duration/timestamps.\n    if (os->first_dts == AV_NOPTS_VALUE &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        pkt->pts -= pkt->dts;\n        pkt->dts  = 0;\n    }\n\n    if (os->first_dts == AV_NOPTS_VALUE)\n        os->first_dts = pkt->dts;\n\n    if ((!c->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n        pkt->flags & AV_PKT_FLAG_KEY && os->packets_written &&\n        av_compare_ts(pkt->dts - os->first_dts, st->time_base,\n                      seg_end_duration, AV_TIME_BASE_Q) >= 0) {\n        int64_t prev_duration = c->last_duration;\n\n        c->last_duration = av_rescale_q(pkt->dts - os->start_dts,\n                                        st->time_base,\n                                        AV_TIME_BASE_Q);\n        c->total_duration = av_rescale_q(pkt->dts - os->first_dts,\n                                         st->time_base,\n                                         AV_TIME_BASE_Q);\n\n        if ((!c->use_timeline || !c->use_template) && prev_duration) {\n            if (c->last_duration < prev_duration*9/10 ||\n                c->last_duration > prev_duration*11/10) {\n                av_log(s, AV_LOG_WARNING,\n                       \"Segment durations differ too much, enable use_timeline \"\n                       \"and use_template, or keep a stricter keyframe interval\\n\");\n            }\n        }\n\n        if ((ret = dash_flush(s, 0, pkt->stream_index)) < 0)\n            return ret;\n    }\n\n    if (!os->packets_written) {\n        // If we wrote a previous segment, adjust the start time of the segment\n        // to the end of the previous one (which is the same as the mp4 muxer\n        // does). This avoids gaps in the timeline.\n        if (os->end_dts != AV_NOPTS_VALUE)\n            os->start_dts = os->end_dts;\n        else\n            os->start_dts = pkt->dts;\n    }\n    os->end_dts = pkt->dts + pkt->duration;\n    os->packets_written++;\n    return ff_write_chained(os->ctx, 0, pkt, s);\n}", "patch_func_code": "static int dash_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    DASHContext *c = s->priv_data;\n    AVStream *st = s->streams[pkt->stream_index];\n    OutputStream *os = &c->streams[pkt->stream_index];\n    int64_t seg_end_duration = (os->segment_index) * (int64_t) c->min_seg_duration;\n    int ret;\n\n    // If forcing the stream to start at 0, the mp4 muxer will set the start\n    // timestamps to 0. Do the same here, to avoid mismatches in duration/timestamps.\n    if (os->first_pts == AV_NOPTS_VALUE &&\n        s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO) {\n        pkt->pts -= pkt->dts;\n        pkt->dts  = 0;\n    }\n\n    if (os->first_pts == AV_NOPTS_VALUE)\n        os->first_pts = pkt->pts;\n\n    if ((!c->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n        pkt->flags & AV_PKT_FLAG_KEY && os->packets_written &&\n        av_compare_ts(pkt->pts - os->first_pts, st->time_base,\n                      seg_end_duration, AV_TIME_BASE_Q) >= 0) {\n        int64_t prev_duration = c->last_duration;\n\n        c->last_duration = av_rescale_q(pkt->pts - os->start_pts,\n                                        st->time_base,\n                                        AV_TIME_BASE_Q);\n        c->total_duration = av_rescale_q(pkt->pts - os->first_pts,\n                                         st->time_base,\n                                         AV_TIME_BASE_Q);\n\n        if ((!c->use_timeline || !c->use_template) && prev_duration) {\n            if (c->last_duration < prev_duration*9/10 ||\n                c->last_duration > prev_duration*11/10) {\n                av_log(s, AV_LOG_WARNING,\n                       \"Segment durations differ too much, enable use_timeline \"\n                       \"and use_template, or keep a stricter keyframe interval\\n\");\n            }\n        }\n\n        if ((ret = dash_flush(s, 0, pkt->stream_index)) < 0)\n            return ret;\n    }\n\n    if (!os->packets_written) {\n        // If we wrote a previous segment, adjust the start time of the segment\n        // to the end of the previous one (which is the same as the mp4 muxer\n        // does). This avoids gaps in the timeline.\n        if (os->max_pts != AV_NOPTS_VALUE)\n            os->start_pts = os->max_pts;\n        else\n            os->start_pts = pkt->pts;\n    }\n    if (os->max_pts == AV_NOPTS_VALUE)\n        os->max_pts = pkt->pts + pkt->duration;\n    else\n        os->max_pts = FFMAX(os->max_pts, pkt->pts + pkt->duration);\n    os->packets_written++;\n    return ff_write_chained(os->ctx, 0, pkt, s);\n}", "before_change_lines": [11, 17, 18, 22, 26, 29, 50, 51, 53, 55], "raw_before_change_lines": [11, 17, 18, 22, 26, 29, 50, 51, 53, 55], "after_change_lines": [11, 17, 18, 22, 26, 29, 50, 51, 53, 55, 56, 57, 58], "raw_after_change_lines": [11, 17, 18, 22, 26, 29, 50, 51, 53, 55, 56, 57, 58], "bug_lines": [11, 17, 18, 22, 26, 29, 50, 51, 53, 55], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 221}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L3", "filepath_func": "5388----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_19f33380a351fd13dae9d2b1716737459927825b_1.json----decode_nal_units", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_19f33380a351fd13dae9d2b1716737459927825b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_19f33380a351fd13dae9d2b1716737459927825b_1.json", "function_name": "decode_nal_units", "vul_func_code": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n    MpegEncContext * const s = &h->s;\n    AVCodecContext * const avctx= s->avctx;\n    H264Context *hx; ///< thread context\n    int buf_index;\n    int context_count;\n    int next_avc;\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n    int nal_index;\n\n    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n        h->current_slice = 0;\n        if (!s->first_field)\n            s->current_picture_ptr= NULL;\n        ff_h264_reset_sei(h);\n    }\n\n    for(;pass <= 1;pass++){\n        buf_index = 0;\n        context_count = 0;\n        next_avc = h->is_avc ? 0 : buf_size;\n        nal_index = 0;\n    for(;;){\n        int consumed;\n        int dst_length;\n        int bit_length;\n        uint8_t *ptr;\n        int i, nalsize = 0;\n        int err;\n\n        if(buf_index >= next_avc) {\n            if (buf_index >= buf_size - h->nal_length_size) break;\n            nalsize = 0;\n            for(i = 0; i < h->nal_length_size; i++)\n                nalsize = (nalsize << 8) | buf[buf_index++];\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n                break;\n            }\n            next_avc= buf_index + nalsize;\n        } else {\n            // start code prefix search\n            for(; buf_index + 3 < next_avc; buf_index++){\n                // This should always succeed in the first iteration.\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n                    break;\n            }\n\n            if(buf_index+3 >= buf_size) break;\n\n            buf_index+=3;\n            if(buf_index >= next_avc) continue;\n        }\n\n        hx = h->thread_context[context_count];\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n        if (ptr==NULL || dst_length < 0){\n            return -1;\n        }\n        i= buf_index + consumed;\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n        while(ptr[dst_length - 1] == 0 && dst_length > 0)\n            dst_length--;\n        }\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d at %d/%d length %d\\n\", hx->nal_unit_type, buf_index, buf_size, dst_length);\n        }\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n            // set trailing bits in the last partial byte to zero\n            if (bit_length & 7)\n                ptr[bit_length >> 3] = ptr[bit_length >> 3] & (0xff << 8 - (bit_length & 7));\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n        }\n\n        buf_index += consumed;\n        nal_index++;\n\n        if(pass == 0) {\n            // packets can sometimes contain multiple PPS/SPS\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n            // if so, when frame threading we can't start the next thread until we've read all of them\n            switch (hx->nal_unit_type) {\n                case NAL_SPS:\n                case NAL_PPS:\n                    nals_needed = nal_index;\n                    break;\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n                    if (!get_ue_golomb(&hx->s.gb))\n                        nals_needed = nal_index;\n            }\n            continue;\n        }\n\n        //FIXME do not discard SEI id\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n            continue;\n\n      again:\n        err = 0;\n        switch(hx->nal_unit_type){\n        case NAL_IDR_SLICE:\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n                return -1;\n            }\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n        case NAL_SLICE:\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n            hx->intra_gb_ptr=\n            hx->inter_gb_ptr= &hx->s.gb;\n            hx->s.data_partitioning = 0;\n\n            if((err = decode_slice_header(hx, h)))\n               break;\n\n            s->current_picture_ptr->f.key_frame |=\n                    (hx->nal_unit_type == NAL_IDR_SLICE) ||\n                    (h->sei_recovery_frame_cnt >= 0);\n\n            if (h->current_slice == 1) {\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n                    decode_postinit(h, nal_index >= nals_needed);\n                }\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n                    return -1;\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n                    ff_vdpau_h264_picture_start(s);\n            }\n\n            if(hx->redundant_pic_count==0\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n               && avctx->skip_frame < AVDISCARD_ALL){\n                if(avctx->hwaccel) {\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n                        return -1;\n                }else\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n                }else\n                    context_count++;\n            }\n            break;\n        case NAL_DPA:\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n            hx->intra_gb_ptr=\n            hx->inter_gb_ptr= NULL;\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n                break;\n\n            hx->s.data_partitioning = 1;\n\n            break;\n        case NAL_DPB:\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n            hx->intra_gb_ptr= &hx->intra_gb;\n            break;\n        case NAL_DPC:\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n               && s->context_initialized\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n               && avctx->skip_frame < AVDISCARD_ALL)\n                context_count++;\n            break;\n        case NAL_SEI:\n            init_get_bits(&s->gb, ptr, bit_length);\n            ff_h264_decode_sei(h);\n            break;\n        case NAL_SPS:\n            init_get_bits(&s->gb, ptr, bit_length);\n            ff_h264_decode_seq_parameter_set(h);\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n                s->low_delay=1;\n\n            if(avctx->has_b_frames < 2)\n                avctx->has_b_frames= !s->low_delay;\n\n            if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n                h->cur_chroma_format_idc != h->sps.chroma_format_idc) {\n                if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {\n                    avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n                    h->cur_chroma_format_idc = h->sps.chroma_format_idc;\n                    h->pixel_shift = h->sps.bit_depth_luma > 8;\n\n                    ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc);\n                    ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc);\n                    s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;\n                    dsputil_init(&s->dsp, s->avctx);\n                } else {\n                    av_log(avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);\n                    return -1;\n                }\n            }\n            break;\n        case NAL_PPS:\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n            break;\n        case NAL_AUD:\n        case NAL_END_SEQUENCE:\n        case NAL_END_STREAM:\n        case NAL_FILLER_DATA:\n        case NAL_SPS_EXT:\n        case NAL_AUXILIARY_SLICE:\n            break;\n        default:\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n        }\n\n        if(context_count == h->max_contexts) {\n            execute_decode_slices(h, context_count);\n            context_count = 0;\n        }\n\n        if (err < 0)\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n        else if(err == 1) {\n            /* Slice could not be decoded in parallel mode, copy down\n             * NAL unit stuff to context 0 and restart. Note that\n             * rbsp_buffer is not transferred, but since we no longer\n             * run in parallel mode this should not be an issue. */\n            h->nal_unit_type = hx->nal_unit_type;\n            h->nal_ref_idc   = hx->nal_ref_idc;\n            hx = h;\n            goto again;\n        }\n    }\n    }\n    if(context_count)\n        execute_decode_slices(h, context_count);\n    return buf_index;\n}", "patch_func_code": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n    MpegEncContext * const s = &h->s;\n    AVCodecContext * const avctx= s->avctx;\n    H264Context *hx; ///< thread context\n    int buf_index;\n    int context_count;\n    int next_avc;\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n    int nal_index;\n\n    h->max_contexts = s->slice_context_count;\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n        h->current_slice = 0;\n        if (!s->first_field)\n            s->current_picture_ptr= NULL;\n        ff_h264_reset_sei(h);\n    }\n\n    for(;pass <= 1;pass++){\n        buf_index = 0;\n        context_count = 0;\n        next_avc = h->is_avc ? 0 : buf_size;\n        nal_index = 0;\n    for(;;){\n        int consumed;\n        int dst_length;\n        int bit_length;\n        uint8_t *ptr;\n        int i, nalsize = 0;\n        int err;\n\n        if(buf_index >= next_avc) {\n            if (buf_index >= buf_size - h->nal_length_size) break;\n            nalsize = 0;\n            for(i = 0; i < h->nal_length_size; i++)\n                nalsize = (nalsize << 8) | buf[buf_index++];\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n                break;\n            }\n            next_avc= buf_index + nalsize;\n        } else {\n            // start code prefix search\n            for(; buf_index + 3 < next_avc; buf_index++){\n                // This should always succeed in the first iteration.\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n                    break;\n            }\n\n            if(buf_index+3 >= buf_size) break;\n\n            buf_index+=3;\n            if(buf_index >= next_avc) continue;\n        }\n\n        hx = h->thread_context[context_count];\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n        if (ptr==NULL || dst_length < 0){\n            return -1;\n        }\n        i= buf_index + consumed;\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n        while(ptr[dst_length - 1] == 0 && dst_length > 0)\n            dst_length--;\n        }\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d at %d/%d length %d\\n\", hx->nal_unit_type, buf_index, buf_size, dst_length);\n        }\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n            // set trailing bits in the last partial byte to zero\n            if (bit_length & 7)\n                ptr[bit_length >> 3] = ptr[bit_length >> 3] & (0xff << 8 - (bit_length & 7));\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n        }\n\n        buf_index += consumed;\n        nal_index++;\n\n        if(pass == 0) {\n            // packets can sometimes contain multiple PPS/SPS\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n            // if so, when frame threading we can't start the next thread until we've read all of them\n            switch (hx->nal_unit_type) {\n                case NAL_SPS:\n                case NAL_PPS:\n                    nals_needed = nal_index;\n                    break;\n                case NAL_IDR_SLICE:\n                case NAL_SLICE:\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n                    if (!get_ue_golomb(&hx->s.gb))\n                        nals_needed = nal_index;\n            }\n            continue;\n        }\n\n        //FIXME do not discard SEI id\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n            continue;\n\n      again:\n        err = 0;\n        switch(hx->nal_unit_type){\n        case NAL_IDR_SLICE:\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n                return -1;\n            }\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n        case NAL_SLICE:\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n            hx->intra_gb_ptr=\n            hx->inter_gb_ptr= &hx->s.gb;\n            hx->s.data_partitioning = 0;\n\n            if((err = decode_slice_header(hx, h)))\n               break;\n\n            s->current_picture_ptr->f.key_frame |=\n                    (hx->nal_unit_type == NAL_IDR_SLICE) ||\n                    (h->sei_recovery_frame_cnt >= 0);\n\n            if (h->current_slice == 1) {\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n                    decode_postinit(h, nal_index >= nals_needed);\n                }\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n                    return -1;\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n                    ff_vdpau_h264_picture_start(s);\n            }\n\n            if(hx->redundant_pic_count==0\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n               && avctx->skip_frame < AVDISCARD_ALL){\n                if(avctx->hwaccel) {\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n                        return -1;\n                }else\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n                }else\n                    context_count++;\n            }\n            break;\n        case NAL_DPA:\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n            hx->intra_gb_ptr=\n            hx->inter_gb_ptr= NULL;\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n                break;\n\n            hx->s.data_partitioning = 1;\n\n            break;\n        case NAL_DPB:\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n            hx->intra_gb_ptr= &hx->intra_gb;\n            break;\n        case NAL_DPC:\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n               && s->context_initialized\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n               && avctx->skip_frame < AVDISCARD_ALL)\n                context_count++;\n            break;\n        case NAL_SEI:\n            init_get_bits(&s->gb, ptr, bit_length);\n            ff_h264_decode_sei(h);\n            break;\n        case NAL_SPS:\n            init_get_bits(&s->gb, ptr, bit_length);\n            ff_h264_decode_seq_parameter_set(h);\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n                s->low_delay=1;\n\n            if(avctx->has_b_frames < 2)\n                avctx->has_b_frames= !s->low_delay;\n\n            if (avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n                h->cur_chroma_format_idc != h->sps.chroma_format_idc) {\n                if (h->sps.bit_depth_luma >= 8 && h->sps.bit_depth_luma <= 10) {\n                    avctx->bits_per_raw_sample = h->sps.bit_depth_luma;\n                    h->cur_chroma_format_idc = h->sps.chroma_format_idc;\n                    h->pixel_shift = h->sps.bit_depth_luma > 8;\n\n                    ff_h264dsp_init(&h->h264dsp, h->sps.bit_depth_luma, h->sps.chroma_format_idc);\n                    ff_h264_pred_init(&h->hpc, s->codec_id, h->sps.bit_depth_luma, h->sps.chroma_format_idc);\n                    s->dsp.dct_bits = h->sps.bit_depth_luma > 8 ? 32 : 16;\n                    dsputil_init(&s->dsp, s->avctx);\n                } else {\n                    av_log(avctx, AV_LOG_ERROR, \"Unsupported bit depth: %d\\n\", h->sps.bit_depth_luma);\n                    return -1;\n                }\n            }\n            break;\n        case NAL_PPS:\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n            break;\n        case NAL_AUD:\n        case NAL_END_SEQUENCE:\n        case NAL_END_STREAM:\n        case NAL_FILLER_DATA:\n        case NAL_SPS_EXT:\n        case NAL_AUXILIARY_SLICE:\n            break;\n        default:\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n        }\n\n        if(context_count == h->max_contexts) {\n            execute_decode_slices(h, context_count);\n            context_count = 0;\n        }\n\n        if (err < 0)\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n        else if(err == 1) {\n            /* Slice could not be decoded in parallel mode, copy down\n             * NAL unit stuff to context 0 and restart. Note that\n             * rbsp_buffer is not transferred, but since we no longer\n             * run in parallel mode this should not be an issue. */\n            h->nal_unit_type = hx->nal_unit_type;\n            h->nal_ref_idc   = hx->nal_ref_idc;\n            hx = h;\n            goto again;\n        }\n    }\n    }\n    if(context_count)\n        execute_decode_slices(h, context_count);\n    return buf_index;\n}", "before_change_lines": [12], "raw_before_change_lines": [12], "after_change_lines": [12], "raw_after_change_lines": [12], "bug_lines": [12], "added": [false], "idx": 222}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5426----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1c0af0eb99b9faf4841d053603f5057e57329942_1.json----ff_h264_decode_extradata", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1c0af0eb99b9faf4841d053603f5057e57329942_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1c0af0eb99b9faf4841d053603f5057e57329942_1.json", "function_name": "ff_h264_decode_extradata", "vul_func_code": "int ff_h264_decode_extradata(H264Context *h)\n{\n    AVCodecContext *avctx = h->s.avctx;\n\n    if (avctx->extradata[0] == 1) {\n        int i, cnt, nalsize;\n        unsigned char *p = avctx->extradata;\n\n        h->is_avc = 1;\n\n        if (avctx->extradata_size < 7) {\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n            return -1;\n        }\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n         * so put a fake nal_length_size = 2 while parsing them */\n        h->nal_length_size = 2;\n        // Decode sps from avcC\n        cnt = *(p + 5) & 0x1f; // Number of sps\n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if (p - avctx->extradata + nalsize > avctx->extradata_size)\n                return -1;\n            if (decode_nal_units(h, p, nalsize, 1) < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return -1;\n            }\n            p += nalsize;\n        }\n        // Decode pps from avcC\n        cnt = *(p++); // Number of pps\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if (p - avctx->extradata + nalsize > avctx->extradata_size)\n                return -1;\n            if (decode_nal_units(h, p, nalsize, 1) < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return -1;\n            }\n            p += nalsize;\n        }\n        // Now store right nal length size, that will be used to parse all other nals\n        h->nal_length_size = (avctx->extradata[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        if (decode_nal_units(h, avctx->extradata, avctx->extradata_size, 1) < 0)\n            return -1;\n    }\n    return 0;\n}", "patch_func_code": "int ff_h264_decode_extradata(H264Context *h)\n{\n    AVCodecContext *avctx = h->avctx;\n\n    if (avctx->extradata[0] == 1) {\n        int i, cnt, nalsize;\n        unsigned char *p = avctx->extradata;\n\n        h->is_avc = 1;\n\n        if (avctx->extradata_size < 7) {\n            av_log(avctx, AV_LOG_ERROR, \"avcC too short\\n\");\n            return -1;\n        }\n        /* sps and pps in the avcC always have length coded with 2 bytes,\n         * so put a fake nal_length_size = 2 while parsing them */\n        h->nal_length_size = 2;\n        // Decode sps from avcC\n        cnt = *(p + 5) & 0x1f; // Number of sps\n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if (p - avctx->extradata + nalsize > avctx->extradata_size)\n                return -1;\n            if (decode_nal_units(h, p, nalsize, 1) < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return -1;\n            }\n            p += nalsize;\n        }\n        // Decode pps from avcC\n        cnt = *(p++); // Number of pps\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if (p - avctx->extradata + nalsize > avctx->extradata_size)\n                return -1;\n            if (decode_nal_units(h, p, nalsize, 1) < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return -1;\n            }\n            p += nalsize;\n        }\n        // Now store right nal length size, that will be used to parse all other nals\n        h->nal_length_size = (avctx->extradata[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        if (decode_nal_units(h, avctx->extradata, avctx->extradata_size, 1) < 0)\n            return -1;\n    }\n    return 0;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 223}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5442----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1cd63c8a590158e29beb847acc3ea6f907f48efa_1.json----decode_cabac_residual_internal", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1cd63c8a590158e29beb847acc3ea6f907f48efa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1cd63c8a590158e29beb847acc3ea6f907f48efa_1.json", "function_name": "decode_cabac_residual_internal", "vul_func_code": "static av_always_inline void\ndecode_cabac_residual_internal(H264Context *h, DCTELEM *block,\n                               int cat, int n, const uint8_t *scantable,\n                               const uint32_t *qmul, int max_coeff,\n                               int is_dc, int chroma422)\n{\n    static const int significant_coeff_flag_offset[2][14] = {\n      { 105+0, 105+15, 105+29, 105+44, 105+47, 402, 484+0, 484+15, 484+29, 660, 528+0, 528+15, 528+29, 718 },\n      { 277+0, 277+15, 277+29, 277+44, 277+47, 436, 776+0, 776+15, 776+29, 675, 820+0, 820+15, 820+29, 733 }\n    };\n    static const int last_coeff_flag_offset[2][14] = {\n      { 166+0, 166+15, 166+29, 166+44, 166+47, 417, 572+0, 572+15, 572+29, 690, 616+0, 616+15, 616+29, 748 },\n      { 338+0, 338+15, 338+29, 338+44, 338+47, 451, 864+0, 864+15, 864+29, 699, 908+0, 908+15, 908+29, 757 }\n    };\n    static const int coeff_abs_level_m1_offset[14] = {\n        227+0, 227+10, 227+20, 227+30, 227+39, 426, 952+0, 952+10, 952+20, 708, 982+0, 982+10, 982+20, 766\n    };\n    static const uint8_t significant_coeff_flag_offset_8x8[2][63] = {\n      { 0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5,\n        4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7,\n        7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11,\n       12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12 },\n      { 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5,\n        6, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11,\n        9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9,\n        9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 }\n    };\n    static const uint8_t sig_coeff_offset_dc[7] = { 0, 0, 1, 1, 2, 2, 2 };\n    /* node ctx: 0..3: abslevel1 (with abslevelgt1 == 0).\n     * 4..7: abslevelgt1 + 3 (and abslevel1 doesn't matter).\n     * map node ctx => cabac ctx for level=1 */\n    static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };\n    /* map node ctx => cabac ctx for level>1 */\n    static const uint8_t coeff_abs_levelgt1_ctx[2][8] = {\n        { 5, 5, 5, 5, 6, 7, 8, 9 },\n        { 5, 5, 5, 5, 6, 7, 8, 8 }, // 422/dc case\n    };\n    static const uint8_t coeff_abs_level_transition[2][8] = {\n    /* update node ctx after decoding a level=1 */\n        { 1, 2, 3, 3, 4, 5, 6, 7 },\n    /* update node ctx after decoding a level>1 */\n        { 4, 4, 4, 4, 5, 6, 7, 7 }\n    };\n\n    int index[64];\n\n    int av_unused last;\n    int coeff_count = 0;\n    int node_ctx = 0;\n\n    uint8_t *significant_coeff_ctx_base;\n    uint8_t *last_coeff_ctx_base;\n    uint8_t *abs_level_m1_ctx_base;\n\n#if !ARCH_X86\n#define CABAC_ON_STACK\n#endif\n#ifdef CABAC_ON_STACK\n#define CC &cc\n    CABACContext cc;\n    cc.range     = h->cabac.range;\n    cc.low       = h->cabac.low;\n    cc.bytestream= h->cabac.bytestream;\n    cc.bytestream_end = h->cabac.bytestream_end;\n#else\n#define CC &h->cabac\n#endif\n\n    significant_coeff_ctx_base = h->cabac_state\n        + significant_coeff_flag_offset[MB_FIELD][cat];\n    last_coeff_ctx_base = h->cabac_state\n        + last_coeff_flag_offset[MB_FIELD][cat];\n    abs_level_m1_ctx_base = h->cabac_state\n        + coeff_abs_level_m1_offset[cat];\n\n    if( !is_dc && max_coeff == 64 ) {\n#define DECODE_SIGNIFICANCE( coefs, sig_off, last_off ) \\\n        for(last= 0; last < coefs; last++) { \\\n            uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \\\n            if( get_cabac( CC, sig_ctx )) { \\\n                uint8_t *last_ctx = last_coeff_ctx_base + last_off; \\\n                index[coeff_count++] = last; \\\n                if( get_cabac( CC, last_ctx ) ) { \\\n                    last= max_coeff; \\\n                    break; \\\n                } \\\n            } \\\n        }\\\n        if( last == max_coeff -1 ) {\\\n            index[coeff_count++] = last;\\\n        }\n        const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD];\n#if ARCH_X86 && HAVE_7REGS && !defined(BROKEN_RELOCATIONS)\n        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index,\n                                                 last_coeff_ctx_base, sig_off);\n    } else {\n        if (is_dc && chroma422) { // dc 422\n            DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]);\n        } else {\n            coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index,\n                                                 last_coeff_ctx_base-significant_coeff_ctx_base);\n        }\n#else\n        DECODE_SIGNIFICANCE( 63, sig_off[last], last_coeff_flag_offset_8x8[last] );\n    } else {\n        if (is_dc && chroma422) { // dc 422\n            DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]);\n        } else {\n            DECODE_SIGNIFICANCE(max_coeff - 1, last, last);\n        }\n#endif\n    }\n    assert(coeff_count > 0);\n\n    if( is_dc ) {\n        if( cat == 3 )\n            h->cbp_table[h->mb_xy] |= 0x40 << (n - CHROMA_DC_BLOCK_INDEX);\n        else\n            h->cbp_table[h->mb_xy] |= 0x100 << (n - LUMA_DC_BLOCK_INDEX);\n        h->non_zero_count_cache[scan8[n]] = coeff_count;\n    } else {\n        if( max_coeff == 64 )\n            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);\n        else {\n            assert( cat == 1 || cat ==  2 || cat ==  4 || cat == 7 || cat == 8 || cat == 11 || cat == 12 );\n            h->non_zero_count_cache[scan8[n]] = coeff_count;\n        }\n    }\n\n#define STORE_BLOCK(type) \\\n    do { \\\n        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base; \\\n \\\n        int j= scantable[index[--coeff_count]]; \\\n \\\n        if( get_cabac( CC, ctx ) == 0 ) { \\\n            node_ctx = coeff_abs_level_transition[0][node_ctx]; \\\n            if( is_dc ) { \\\n                ((type*)block)[j] = get_cabac_bypass_sign( CC, -1); \\\n            }else{ \\\n                ((type*)block)[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6; \\\n            } \\\n        } else { \\\n            int coeff_abs = 2; \\\n            ctx = coeff_abs_levelgt1_ctx[is_dc && chroma422][node_ctx] + abs_level_m1_ctx_base; \\\n            node_ctx = coeff_abs_level_transition[1][node_ctx]; \\\n\\\n            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) { \\\n                coeff_abs++; \\\n            } \\\n\\\n            if( coeff_abs >= 15 ) { \\\n                int j = 0; \\\n                while( get_cabac_bypass( CC ) ) { \\\n                    j++; \\\n                } \\\n\\\n                coeff_abs=1; \\\n                while( j-- ) { \\\n                    coeff_abs += coeff_abs + get_cabac_bypass( CC ); \\\n                } \\\n                coeff_abs+= 14; \\\n            } \\\n\\\n            if( is_dc ) { \\\n                ((type*)block)[j] = get_cabac_bypass_sign( CC, -coeff_abs ); \\\n            }else{ \\\n                ((type*)block)[j] = ((int)(get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32)) >> 6; \\\n            } \\\n        } \\\n    } while ( coeff_count );\n\n    if (h->pixel_shift) {\n        STORE_BLOCK(int32_t)\n    } else {\n        STORE_BLOCK(int16_t)\n    }\n#ifdef CABAC_ON_STACK\n            h->cabac.range     = cc.range     ;\n            h->cabac.low       = cc.low       ;\n            h->cabac.bytestream= cc.bytestream;\n#endif\n\n}", "patch_func_code": "static av_always_inline void\ndecode_cabac_residual_internal(H264Context *h, DCTELEM *block,\n                               int cat, int n, const uint8_t *scantable,\n                               const uint32_t *qmul, int max_coeff,\n                               int is_dc, int chroma422)\n{\n    static const int significant_coeff_flag_offset[2][14] = {\n      { 105+0, 105+15, 105+29, 105+44, 105+47, 402, 484+0, 484+15, 484+29, 660, 528+0, 528+15, 528+29, 718 },\n      { 277+0, 277+15, 277+29, 277+44, 277+47, 436, 776+0, 776+15, 776+29, 675, 820+0, 820+15, 820+29, 733 }\n    };\n    static const int last_coeff_flag_offset[2][14] = {\n      { 166+0, 166+15, 166+29, 166+44, 166+47, 417, 572+0, 572+15, 572+29, 690, 616+0, 616+15, 616+29, 748 },\n      { 338+0, 338+15, 338+29, 338+44, 338+47, 451, 864+0, 864+15, 864+29, 699, 908+0, 908+15, 908+29, 757 }\n    };\n    static const int coeff_abs_level_m1_offset[14] = {\n        227+0, 227+10, 227+20, 227+30, 227+39, 426, 952+0, 952+10, 952+20, 708, 982+0, 982+10, 982+20, 766\n    };\n    static const uint8_t significant_coeff_flag_offset_8x8[2][63] = {\n      { 0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5,\n        4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7,\n        7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11,\n       12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12 },\n      { 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5,\n        6, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11,\n        9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9,\n        9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 }\n    };\n    static const uint8_t sig_coeff_offset_dc[7] = { 0, 0, 1, 1, 2, 2, 2 };\n    /* node ctx: 0..3: abslevel1 (with abslevelgt1 == 0).\n     * 4..7: abslevelgt1 + 3 (and abslevel1 doesn't matter).\n     * map node ctx => cabac ctx for level=1 */\n    static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };\n    /* map node ctx => cabac ctx for level>1 */\n    static const uint8_t coeff_abs_levelgt1_ctx[2][8] = {\n        { 5, 5, 5, 5, 6, 7, 8, 9 },\n        { 5, 5, 5, 5, 6, 7, 8, 8 }, // 422/dc case\n    };\n    static const uint8_t coeff_abs_level_transition[2][8] = {\n    /* update node ctx after decoding a level=1 */\n        { 1, 2, 3, 3, 4, 5, 6, 7 },\n    /* update node ctx after decoding a level>1 */\n        { 4, 4, 4, 4, 5, 6, 7, 7 }\n    };\n\n    int index[64];\n\n    int av_unused last;\n    int coeff_count = 0;\n    int node_ctx = 0;\n\n    uint8_t *significant_coeff_ctx_base;\n    uint8_t *last_coeff_ctx_base;\n    uint8_t *abs_level_m1_ctx_base;\n\n#if !ARCH_X86\n#define CABAC_ON_STACK\n#endif\n#ifdef CABAC_ON_STACK\n#define CC &cc\n    CABACContext cc;\n    cc.range     = h->cabac.range;\n    cc.low       = h->cabac.low;\n    cc.bytestream= h->cabac.bytestream;\n    cc.bytestream_end = h->cabac.bytestream_end;\n#else\n#define CC &h->cabac\n#endif\n\n    significant_coeff_ctx_base = h->cabac_state\n        + significant_coeff_flag_offset[MB_FIELD][cat];\n    last_coeff_ctx_base = h->cabac_state\n        + last_coeff_flag_offset[MB_FIELD][cat];\n    abs_level_m1_ctx_base = h->cabac_state\n        + coeff_abs_level_m1_offset[cat];\n\n    if( !is_dc && max_coeff == 64 ) {\n#define DECODE_SIGNIFICANCE( coefs, sig_off, last_off ) \\\n        for(last= 0; last < coefs; last++) { \\\n            uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \\\n            if( get_cabac( CC, sig_ctx )) { \\\n                uint8_t *last_ctx = last_coeff_ctx_base + last_off; \\\n                index[coeff_count++] = last; \\\n                if( get_cabac( CC, last_ctx ) ) { \\\n                    last= max_coeff; \\\n                    break; \\\n                } \\\n            } \\\n        }\\\n        if( last == max_coeff -1 ) {\\\n            index[coeff_count++] = last;\\\n        }\n        const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD];\n#if ARCH_X86 && HAVE_7REGS && !defined(BROKEN_RELOCATIONS)\n        coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index,\n                                                 last_coeff_ctx_base, sig_off);\n    } else {\n        if (is_dc && chroma422) { // dc 422\n            DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]);\n        } else {\n            coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index,\n                                                 last_coeff_ctx_base-significant_coeff_ctx_base);\n        }\n#else\n        DECODE_SIGNIFICANCE( 63, sig_off[last], ff_h264_last_coeff_flag_offset_8x8[last] );\n    } else {\n        if (is_dc && chroma422) { // dc 422\n            DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]);\n        } else {\n            DECODE_SIGNIFICANCE(max_coeff - 1, last, last);\n        }\n#endif\n    }\n    assert(coeff_count > 0);\n\n    if( is_dc ) {\n        if( cat == 3 )\n            h->cbp_table[h->mb_xy] |= 0x40 << (n - CHROMA_DC_BLOCK_INDEX);\n        else\n            h->cbp_table[h->mb_xy] |= 0x100 << (n - LUMA_DC_BLOCK_INDEX);\n        h->non_zero_count_cache[scan8[n]] = coeff_count;\n    } else {\n        if( max_coeff == 64 )\n            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);\n        else {\n            assert( cat == 1 || cat ==  2 || cat ==  4 || cat == 7 || cat == 8 || cat == 11 || cat == 12 );\n            h->non_zero_count_cache[scan8[n]] = coeff_count;\n        }\n    }\n\n#define STORE_BLOCK(type) \\\n    do { \\\n        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base; \\\n \\\n        int j= scantable[index[--coeff_count]]; \\\n \\\n        if( get_cabac( CC, ctx ) == 0 ) { \\\n            node_ctx = coeff_abs_level_transition[0][node_ctx]; \\\n            if( is_dc ) { \\\n                ((type*)block)[j] = get_cabac_bypass_sign( CC, -1); \\\n            }else{ \\\n                ((type*)block)[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6; \\\n            } \\\n        } else { \\\n            int coeff_abs = 2; \\\n            ctx = coeff_abs_levelgt1_ctx[is_dc && chroma422][node_ctx] + abs_level_m1_ctx_base; \\\n            node_ctx = coeff_abs_level_transition[1][node_ctx]; \\\n\\\n            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) { \\\n                coeff_abs++; \\\n            } \\\n\\\n            if( coeff_abs >= 15 ) { \\\n                int j = 0; \\\n                while( get_cabac_bypass( CC ) ) { \\\n                    j++; \\\n                } \\\n\\\n                coeff_abs=1; \\\n                while( j-- ) { \\\n                    coeff_abs += coeff_abs + get_cabac_bypass( CC ); \\\n                } \\\n                coeff_abs+= 14; \\\n            } \\\n\\\n            if( is_dc ) { \\\n                ((type*)block)[j] = get_cabac_bypass_sign( CC, -coeff_abs ); \\\n            }else{ \\\n                ((type*)block)[j] = ((int)(get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32)) >> 6; \\\n            } \\\n        } \\\n    } while ( coeff_count );\n\n    if (h->pixel_shift) {\n        STORE_BLOCK(int32_t)\n    } else {\n        STORE_BLOCK(int16_t)\n    }\n#ifdef CABAC_ON_STACK\n            h->cabac.range     = cc.range     ;\n            h->cabac.low       = cc.low       ;\n            h->cabac.bytestream= cc.bytestream;\n#endif\n\n}", "before_change_lines": [104], "raw_before_change_lines": [104], "after_change_lines": [104], "raw_after_change_lines": [104], "bug_lines": [104], "added": [false], "idx": 224}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "5482----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1f943e31df31da7b831e17af6a068c837eb146c5_1.json----ff_intrax8_decode_picture", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1f943e31df31da7b831e17af6a068c837eb146c5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1f943e31df31da7b831e17af6a068c837eb146c5_1.json", "function_name": "ff_intrax8_decode_picture", "vul_func_code": "int ff_intrax8_decode_picture(IntraX8Context * const w, int dquant, int quant_offset){\n    MpegEncContext * const s= w->s;\n    int mb_xy;\n    assert(s);\n    w->use_quant_matrix = get_bits1(&s->gb);\n\n    w->dquant = dquant;\n    w->quant  = dquant >> 1;\n    w->qsum   = quant_offset;\n\n    w->divide_quant_dc_luma = ((1<<16) + (w->quant>>1)) / w->quant;\n    if(w->quant < 5){\n        w->quant_dc_chroma =  w->quant;\n        w->divide_quant_dc_chroma = w->divide_quant_dc_luma;\n    }else{\n        w->quant_dc_chroma =  w->quant+((w->quant+3)>>3);\n        w->divide_quant_dc_chroma = ((1<<16) + (w->quant_dc_chroma>>1)) / w->quant_dc_chroma;\n    }\n    x8_reset_vlc_tables(w);\n\n    s->resync_mb_x=0;\n    s->resync_mb_y=0;\n\n    for(s->mb_y=0; s->mb_y < s->mb_height*2; s->mb_y++){\n        x8_init_block_index(s);\n        mb_xy=(s->mb_y>>1)*s->mb_stride;\n\n        for(s->mb_x=0; s->mb_x < s->mb_width*2; s->mb_x++){\n            x8_get_prediction(w);\n            if(x8_setup_spatial_predictor(w,0)) goto error;\n            if(x8_decode_intra_mb(w,0)) goto error;\n\n            if( s->mb_x & s->mb_y & 1 ){\n                x8_get_prediction_chroma(w);\n\n                /*when setting up chroma, no vlc is read,\n                so no error condition can be reached*/\n                x8_setup_spatial_predictor(w,1);\n                if(x8_decode_intra_mb(w,1)) goto error;\n\n                x8_setup_spatial_predictor(w,2);\n                if(x8_decode_intra_mb(w,2)) goto error;\n\n                s->dest[1]+= 8;\n                s->dest[2]+= 8;\n\n                /*emulate MB info in the relevant tables*/\n                s->mbskip_table [mb_xy]=0;\n                s->mbintra_table[mb_xy]=1;\n                s->current_picture.qscale_table[mb_xy] = w->quant;\n                mb_xy++;\n            }\n            s->dest[0]+= 8;\n        }\n        if(s->mb_y&1){\n            ff_mpeg_draw_horiz_band(s, (s->mb_y-1)*8, 16);\n        }\n    }\n\nerror:\n    ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y,\n                        (s->mb_x>>1)-1, (s->mb_y>>1)-1,\n                        ER_MB_END );\n    return 0;\n}", "patch_func_code": "int ff_intrax8_decode_picture(IntraX8Context * const w, int dquant, int quant_offset){\n    MpegEncContext * const s= w->s;\n    int mb_xy;\n    assert(s);\n    w->use_quant_matrix = get_bits1(&s->gb);\n\n    w->dquant = dquant;\n    w->quant  = dquant >> 1;\n    w->qsum   = quant_offset;\n\n    w->divide_quant_dc_luma = ((1<<16) + (w->quant>>1)) / w->quant;\n    if(w->quant < 5){\n        w->quant_dc_chroma =  w->quant;\n        w->divide_quant_dc_chroma = w->divide_quant_dc_luma;\n    }else{\n        w->quant_dc_chroma =  w->quant+((w->quant+3)>>3);\n        w->divide_quant_dc_chroma = ((1<<16) + (w->quant_dc_chroma>>1)) / w->quant_dc_chroma;\n    }\n    x8_reset_vlc_tables(w);\n\n\n    for(s->mb_y=0; s->mb_y < s->mb_height*2; s->mb_y++){\n        x8_init_block_index(s);\n        mb_xy=(s->mb_y>>1)*s->mb_stride;\n\n        for(s->mb_x=0; s->mb_x < s->mb_width*2; s->mb_x++){\n            x8_get_prediction(w);\n            if(x8_setup_spatial_predictor(w,0)) goto error;\n            if(x8_decode_intra_mb(w,0)) goto error;\n\n            if( s->mb_x & s->mb_y & 1 ){\n                x8_get_prediction_chroma(w);\n\n                /*when setting up chroma, no vlc is read,\n                so no error condition can be reached*/\n                x8_setup_spatial_predictor(w,1);\n                if(x8_decode_intra_mb(w,1)) goto error;\n\n                x8_setup_spatial_predictor(w,2);\n                if(x8_decode_intra_mb(w,2)) goto error;\n\n                s->dest[1]+= 8;\n                s->dest[2]+= 8;\n\n                /*emulate MB info in the relevant tables*/\n                s->mbskip_table [mb_xy]=0;\n                s->mbintra_table[mb_xy]=1;\n                s->current_picture.qscale_table[mb_xy] = w->quant;\n                mb_xy++;\n            }\n            s->dest[0]+= 8;\n        }\n        if(s->mb_y&1){\n            ff_mpeg_draw_horiz_band(s, (s->mb_y-1)*8, 16);\n        }\n    }\n\nerror:\n    return 0;\n}", "before_change_lines": [21, 22, 61, 62, 63], "raw_before_change_lines": [21, 22, 61, 62, 63], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [21, 22, 61, 62, 63], "added": [false, false, false, false, false], "idx": 225}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "5487----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1ff6f9bb238d5f71ea34c8f191144d09de051c6c_1.json----av_fill_image_linesizes", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_1ff6f9bb238d5f71ea34c8f191144d09de051c6c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_1ff6f9bb238d5f71ea34c8f191144d09de051c6c_1.json", "function_name": "av_fill_image_linesizes", "vul_func_code": "int av_fill_image_linesizes(int linesizes[4], enum PixelFormat pix_fmt, int width)\n{\n    int i;\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n\n    memset(linesizes, 0, 4*sizeof(linesizes[0]));\n\n    if (desc->flags & PIX_FMT_HWACCEL)\n        return AVERROR(EINVAL);\n\n    if (desc->flags & PIX_FMT_BITSTREAM) {\n        linesizes[0] = (width * (desc->comp[0].step_minus1+1) + 7) >> 3;\n        return 0;\n    }\n\n    av_fill_image_max_pixstep(max_step, max_step_comp, desc);\n    for (i = 0; i < 4; i++) {\n        int s = (max_step_comp[i] == 1 || max_step_comp[i] == 2) ? desc->log2_chroma_w : 0;\n        linesizes[i] = max_step[i] * (((width + (1 << s) - 1)) >> s);\n    }\n\n    return 0;\n}", "patch_func_code": "int av_fill_image_linesizes(int linesizes[4], enum PixelFormat pix_fmt, int width)\n{\n    int i;\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n\n    memset(linesizes, 0, 4*sizeof(linesizes[0]));\n\n    if (desc->flags & PIX_FMT_HWACCEL)\n        return AVERROR(EINVAL);\n\n    if (desc->flags & PIX_FMT_BITSTREAM) {\n        linesizes[0] = (width * (desc->comp[0].step_minus1+1) + 7) >> 3;\n        return 0;\n    }\n\n    av_fill_image_max_pixsteps(max_step, max_step_comp, desc);\n    for (i = 0; i < 4; i++) {\n        int s = (max_step_comp[i] == 1 || max_step_comp[i] == 2) ? desc->log2_chroma_w : 0;\n        linesizes[i] = max_step[i] * (((width + (1 << s) - 1)) >> s);\n    }\n\n    return 0;\n}", "before_change_lines": [18], "raw_before_change_lines": [18], "after_change_lines": [18], "raw_after_change_lines": [18], "bug_lines": [18], "added": [false], "idx": 226}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5552----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_23faa44b6df1acfa5b3e8b04b5ac725cd86798d9_1.json----encode_residual_ch", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_23faa44b6df1acfa5b3e8b04b5ac725cd86798d9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_23faa44b6df1acfa5b3e8b04b5ac725cd86798d9_1.json", "function_name": "encode_residual_ch", "vul_func_code": "static int encode_residual_ch(FlacEncodeContext *s, int ch)\n{\n    int i, n;\n    int min_order, max_order, opt_order, omethod;\n    FlacFrame *frame;\n    FlacSubframe *sub;\n    int32_t coefs[MAX_LPC_ORDER][MAX_LPC_ORDER];\n    int shift[MAX_LPC_ORDER];\n    int32_t *res, *smp;\n\n    frame = &s->frame;\n    sub   = &frame->subframes[ch];\n    res   = sub->residual;\n    smp   = sub->samples;\n    n     = frame->blocksize;\n\n    /* CONSTANT */\n    for (i = 1; i < n; i++)\n        if(smp[i] != smp[0])\n            break;\n    if (i == n) {\n        sub->type = sub->type_code = FLAC_SUBFRAME_CONSTANT;\n        res[0] = smp[0];\n        return subframe_count_exact(s, sub, 0);\n    }\n\n    /* VERBATIM */\n    if (frame->verbatim_only || n < 5) {\n        sub->type = sub->type_code = FLAC_SUBFRAME_VERBATIM;\n        memcpy(res, smp, n * sizeof(int32_t));\n        return subframe_count_exact(s, sub, 0);\n    }\n\n    min_order  = s->options.min_prediction_order;\n    max_order  = s->options.max_prediction_order;\n    omethod    = s->options.prediction_order_method;\n\n    /* FIXED */\n    sub->type = FLAC_SUBFRAME_FIXED;\n    if (s->options.lpc_type == FF_LPC_TYPE_NONE  ||\n        s->options.lpc_type == FF_LPC_TYPE_FIXED || n <= max_order) {\n        uint32_t bits[MAX_FIXED_ORDER+1];\n        if (max_order > MAX_FIXED_ORDER)\n            max_order = MAX_FIXED_ORDER;\n        opt_order = 0;\n        bits[0]   = UINT32_MAX;\n        for (i = min_order; i <= max_order; i++) {\n            encode_residual_fixed(res, smp, n, i);\n            bits[i] = find_subframe_rice_params(s, sub, i);\n            if (bits[i] < bits[opt_order])\n                opt_order = i;\n        }\n        sub->order     = opt_order;\n        sub->type_code = sub->type | sub->order;\n        if (sub->order != max_order) {\n            encode_residual_fixed(res, smp, n, sub->order);\n            find_subframe_rice_params(s, sub, sub->order);\n        }\n        return subframe_count_exact(s, sub, sub->order);\n    }\n\n    /* LPC */\n    sub->type = FLAC_SUBFRAME_LPC;\n    opt_order = ff_lpc_calc_coefs(&s->lpc_ctx, smp, n, min_order, max_order,\n                                  s->options.lpc_coeff_precision, coefs, shift, s->options.lpc_type,\n                                  s->options.lpc_passes, omethod,\n                                  MAX_LPC_SHIFT, 0);\n\n    if (omethod == ORDER_METHOD_2LEVEL ||\n        omethod == ORDER_METHOD_4LEVEL ||\n        omethod == ORDER_METHOD_8LEVEL) {\n        int levels = 1 << omethod;\n        uint32_t bits[1 << ORDER_METHOD_8LEVEL];\n        int order;\n        int opt_index   = levels-1;\n        opt_order       = max_order-1;\n        bits[opt_index] = UINT32_MAX;\n        for (i = levels-1; i >= 0; i--) {\n            order = min_order + (((max_order-min_order+1) * (i+1)) / levels)-1;\n            if (order < 0)\n                order = 0;\n            encode_residual_lpc(res, smp, n, order+1, coefs[order], shift[order]);\n            bits[i] = find_subframe_rice_params(s, sub, order+1);\n            if (bits[i] < bits[opt_index]) {\n                opt_index = i;\n                opt_order = order;\n            }\n        }\n        opt_order++;\n    } else if (omethod == ORDER_METHOD_SEARCH) {\n        // brute-force optimal order search\n        uint32_t bits[MAX_LPC_ORDER];\n        opt_order = 0;\n        bits[0]   = UINT32_MAX;\n        for (i = min_order-1; i < max_order; i++) {\n            encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n            bits[i] = find_subframe_rice_params(s, sub, i+1);\n            if (bits[i] < bits[opt_order])\n                opt_order = i;\n        }\n        opt_order++;\n    } else if (omethod == ORDER_METHOD_LOG) {\n        uint32_t bits[MAX_LPC_ORDER];\n        int step;\n\n        opt_order = min_order - 1 + (max_order-min_order)/3;\n        memset(bits, -1, sizeof(bits));\n\n        for (step = 16; step; step >>= 1) {\n            int last = opt_order;\n            for (i = last-step; i <= last+step; i += step) {\n                if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX)\n                    continue;\n                encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n                bits[i] = find_subframe_rice_params(s, sub, i+1);\n                if (bits[i] < bits[opt_order])\n                    opt_order = i;\n            }\n        }\n        opt_order++;\n    }\n\n    sub->order     = opt_order;\n    sub->type_code = sub->type | (sub->order-1);\n    sub->shift     = shift[sub->order-1];\n    for (i = 0; i < sub->order; i++)\n        sub->coefs[i] = coefs[sub->order-1][i];\n\n    encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift);\n\n    find_subframe_rice_params(s, sub, sub->order);\n\n    return subframe_count_exact(s, sub, sub->order);\n}", "patch_func_code": "static int encode_residual_ch(FlacEncodeContext *s, int ch)\n{\n    int i, n;\n    int min_order, max_order, opt_order, omethod;\n    FlacFrame *frame;\n    FlacSubframe *sub;\n    int32_t coefs[MAX_LPC_ORDER][MAX_LPC_ORDER];\n    int shift[MAX_LPC_ORDER];\n    int32_t *res, *smp;\n\n    frame = &s->frame;\n    sub   = &frame->subframes[ch];\n    res   = sub->residual;\n    smp   = sub->samples;\n    n     = frame->blocksize;\n\n    /* CONSTANT */\n    for (i = 1; i < n; i++)\n        if(smp[i] != smp[0])\n            break;\n    if (i == n) {\n        sub->type = sub->type_code = FLAC_SUBFRAME_CONSTANT;\n        res[0] = smp[0];\n        return subframe_count_exact(s, sub, 0);\n    }\n\n    /* VERBATIM */\n    if (frame->verbatim_only || n < 5) {\n        sub->type = sub->type_code = FLAC_SUBFRAME_VERBATIM;\n        memcpy(res, smp, n * sizeof(int32_t));\n        return subframe_count_exact(s, sub, 0);\n    }\n\n    min_order  = s->options.min_prediction_order;\n    max_order  = s->options.max_prediction_order;\n    omethod    = s->options.prediction_order_method;\n\n    /* FIXED */\n    sub->type = FLAC_SUBFRAME_FIXED;\n    if (s->options.lpc_type == FF_LPC_TYPE_NONE  ||\n        s->options.lpc_type == FF_LPC_TYPE_FIXED || n <= max_order) {\n        uint64_t bits[MAX_FIXED_ORDER+1];\n        if (max_order > MAX_FIXED_ORDER)\n            max_order = MAX_FIXED_ORDER;\n        opt_order = 0;\n        bits[0]   = UINT32_MAX;\n        for (i = min_order; i <= max_order; i++) {\n            encode_residual_fixed(res, smp, n, i);\n            bits[i] = find_subframe_rice_params(s, sub, i);\n            if (bits[i] < bits[opt_order])\n                opt_order = i;\n        }\n        sub->order     = opt_order;\n        sub->type_code = sub->type | sub->order;\n        if (sub->order != max_order) {\n            encode_residual_fixed(res, smp, n, sub->order);\n            find_subframe_rice_params(s, sub, sub->order);\n        }\n        return subframe_count_exact(s, sub, sub->order);\n    }\n\n    /* LPC */\n    sub->type = FLAC_SUBFRAME_LPC;\n    opt_order = ff_lpc_calc_coefs(&s->lpc_ctx, smp, n, min_order, max_order,\n                                  s->options.lpc_coeff_precision, coefs, shift, s->options.lpc_type,\n                                  s->options.lpc_passes, omethod,\n                                  MAX_LPC_SHIFT, 0);\n\n    if (omethod == ORDER_METHOD_2LEVEL ||\n        omethod == ORDER_METHOD_4LEVEL ||\n        omethod == ORDER_METHOD_8LEVEL) {\n        int levels = 1 << omethod;\n        uint64_t bits[1 << ORDER_METHOD_8LEVEL];\n        int order;\n        int opt_index   = levels-1;\n        opt_order       = max_order-1;\n        bits[opt_index] = UINT32_MAX;\n        for (i = levels-1; i >= 0; i--) {\n            order = min_order + (((max_order-min_order+1) * (i+1)) / levels)-1;\n            if (order < 0)\n                order = 0;\n            encode_residual_lpc(res, smp, n, order+1, coefs[order], shift[order]);\n            bits[i] = find_subframe_rice_params(s, sub, order+1);\n            if (bits[i] < bits[opt_index]) {\n                opt_index = i;\n                opt_order = order;\n            }\n        }\n        opt_order++;\n    } else if (omethod == ORDER_METHOD_SEARCH) {\n        // brute-force optimal order search\n        uint64_t bits[MAX_LPC_ORDER];\n        opt_order = 0;\n        bits[0]   = UINT32_MAX;\n        for (i = min_order-1; i < max_order; i++) {\n            encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n            bits[i] = find_subframe_rice_params(s, sub, i+1);\n            if (bits[i] < bits[opt_order])\n                opt_order = i;\n        }\n        opt_order++;\n    } else if (omethod == ORDER_METHOD_LOG) {\n        uint64_t bits[MAX_LPC_ORDER];\n        int step;\n\n        opt_order = min_order - 1 + (max_order-min_order)/3;\n        memset(bits, -1, sizeof(bits));\n\n        for (step = 16; step; step >>= 1) {\n            int last = opt_order;\n            for (i = last-step; i <= last+step; i += step) {\n                if (i < min_order-1 || i >= max_order || bits[i] < UINT32_MAX)\n                    continue;\n                encode_residual_lpc(res, smp, n, i+1, coefs[i], shift[i]);\n                bits[i] = find_subframe_rice_params(s, sub, i+1);\n                if (bits[i] < bits[opt_order])\n                    opt_order = i;\n            }\n        }\n        opt_order++;\n    }\n\n    sub->order     = opt_order;\n    sub->type_code = sub->type | (sub->order-1);\n    sub->shift     = shift[sub->order-1];\n    for (i = 0; i < sub->order; i++)\n        sub->coefs[i] = coefs[sub->order-1][i];\n\n    encode_residual_lpc(res, smp, n, sub->order, sub->coefs, sub->shift);\n\n    find_subframe_rice_params(s, sub, sub->order);\n\n    return subframe_count_exact(s, sub, sub->order);\n}", "before_change_lines": [42, 73, 92, 103], "raw_before_change_lines": [42, 73, 92, 103], "after_change_lines": [42, 73, 92, 103], "raw_after_change_lines": [42, 73, 92, 103], "bug_lines": [42, 73, 92, 103], "added": [false, false, false, false], "idx": 227}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L2", "filepath_func": "5560----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2426c2a46601c19460da0a1fab3b7012ed9deff1_1.json----decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_2426c2a46601c19460da0a1fab3b7012ed9deff1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2426c2a46601c19460da0a1fab3b7012ed9deff1_1.json", "function_name": "decode_frame", "vul_func_code": "static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    const uint8_t *buf_end = buf + avpkt->size;\n    KgvContext * const c = avctx->priv_data;\n    int offsets[7];\n    uint16_t *out, *prev;\n    int outcnt = 0, maxcnt;\n    int w, h, i;\n\n    if (avpkt->size < 2)\n        return -1;\n\n    w = (buf[0] + 1) * 8;\n    h = (buf[1] + 1) * 8;\n    buf += 2;\n\n    if (av_image_check_size(w, h, 0, avctx))\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n        avcodec_set_dimensions(avctx, w, h);\n\n    maxcnt = w * h;\n\n    out = av_realloc(c->cur, w * h * 2);\n    if (!out)\n        return -1;\n    c->cur = out;\n\n    prev = av_realloc(c->prev, w * h * 2);\n    if (!prev)\n        return -1;\n    c->prev = prev;\n\n    for (i = 0; i < 7; i++)\n        offsets[i] = -1;\n\n    while (outcnt < maxcnt && buf_end - 2 > buf) {\n        int code = AV_RL16(buf);\n        buf += 2;\n\n        if (!(code & 0x8000)) {\n            out[outcnt++] = code; // rgb555 pixel coded directly\n        } else {\n            int count;\n            uint16_t *inp;\n\n            if ((code & 0x6000) == 0x6000) {\n                // copy from previous frame\n                int oidx = (code >> 10) & 7;\n                int start;\n\n                count = (code & 0x3FF) + 3;\n\n                if (offsets[oidx] < 0) {\n                    if (buf_end - 3 < buf)\n                        break;\n                    offsets[oidx] = AV_RL24(buf);\n                    buf += 3;\n                }\n\n                start = (outcnt + offsets[oidx]) % maxcnt;\n\n                if (maxcnt - start < count)\n                    break;\n\n                inp = prev + start;\n            } else {\n                // copy from earlier in this frame\n                int offset = (code & 0x1FFF) + 1;\n\n                if (!(code & 0x6000)) {\n                    count = 2;\n                } else if ((code & 0x6000) == 0x2000) {\n                    count = 3;\n                } else {\n                    if (buf_end - 1 < buf)\n                        break;\n                    count = 4 + *buf++;\n                }\n\n                if (outcnt < offset)\n                    break;\n\n                inp = out + outcnt - offset;\n            }\n\n            if (maxcnt - outcnt < count)\n                break;\n\n            for (i = 0; i < count; i++)\n                out[outcnt++] = inp[i];\n        }\n    }\n\n    if (outcnt - maxcnt)\n        av_log(avctx, AV_LOG_DEBUG, \"frame finished with %d diff\\n\", outcnt - maxcnt);\n\n    c->pic.data[0]     = (uint8_t *)c->cur;\n    c->pic.linesize[0] = w * 2;\n\n    *data_size = sizeof(AVFrame);\n    *(AVFrame*)data = c->pic;\n\n    FFSWAP(uint16_t *, c->cur, c->prev);\n\n    return avpkt->size;\n}", "patch_func_code": "static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    const uint8_t *buf_end = buf + avpkt->size;\n    KgvContext * const c = avctx->priv_data;\n    int offsets[8];\n    uint16_t *out, *prev;\n    int outcnt = 0, maxcnt;\n    int w, h, i;\n\n    if (avpkt->size < 2)\n        return -1;\n\n    w = (buf[0] + 1) * 8;\n    h = (buf[1] + 1) * 8;\n    buf += 2;\n\n    if (av_image_check_size(w, h, 0, avctx))\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n        avcodec_set_dimensions(avctx, w, h);\n\n    maxcnt = w * h;\n\n    out = av_realloc(c->cur, w * h * 2);\n    if (!out)\n        return -1;\n    c->cur = out;\n\n    prev = av_realloc(c->prev, w * h * 2);\n    if (!prev)\n        return -1;\n    c->prev = prev;\n\n    for (i = 0; i < 8; i++)\n        offsets[i] = -1;\n\n    while (outcnt < maxcnt && buf_end - 2 > buf) {\n        int code = AV_RL16(buf);\n        buf += 2;\n\n        if (!(code & 0x8000)) {\n            out[outcnt++] = code; // rgb555 pixel coded directly\n        } else {\n            int count;\n            uint16_t *inp;\n\n            if ((code & 0x6000) == 0x6000) {\n                // copy from previous frame\n                int oidx = (code >> 10) & 7;\n                int start;\n\n                count = (code & 0x3FF) + 3;\n\n                if (offsets[oidx] < 0) {\n                    if (buf_end - 3 < buf)\n                        break;\n                    offsets[oidx] = AV_RL24(buf);\n                    buf += 3;\n                }\n\n                start = (outcnt + offsets[oidx]) % maxcnt;\n\n                if (maxcnt - start < count)\n                    break;\n\n                inp = prev + start;\n            } else {\n                // copy from earlier in this frame\n                int offset = (code & 0x1FFF) + 1;\n\n                if (!(code & 0x6000)) {\n                    count = 2;\n                } else if ((code & 0x6000) == 0x2000) {\n                    count = 3;\n                } else {\n                    if (buf_end - 1 < buf)\n                        break;\n                    count = 4 + *buf++;\n                }\n\n                if (outcnt < offset)\n                    break;\n\n                inp = out + outcnt - offset;\n            }\n\n            if (maxcnt - outcnt < count)\n                break;\n\n            for (i = 0; i < count; i++)\n                out[outcnt++] = inp[i];\n        }\n    }\n\n    if (outcnt - maxcnt)\n        av_log(avctx, AV_LOG_DEBUG, \"frame finished with %d diff\\n\", outcnt - maxcnt);\n\n    c->pic.data[0]     = (uint8_t *)c->cur;\n    c->pic.linesize[0] = w * 2;\n\n    *data_size = sizeof(AVFrame);\n    *(AVFrame*)data = c->pic;\n\n    FFSWAP(uint16_t *, c->cur, c->prev);\n\n    return avpkt->size;\n}", "before_change_lines": [6, 36], "raw_before_change_lines": [6, 36], "after_change_lines": [6, 36], "raw_after_change_lines": [6, 36], "bug_lines": [6, 36], "added": [false, false], "idx": 228}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "5581----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_258d6511c89bd5ab657507bf839affdac60cdbde_1.json----vorbisfloat2float", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_258d6511c89bd5ab657507bf839affdac60cdbde_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_258d6511c89bd5ab657507bf839affdac60cdbde_1.json", "function_name": "vorbisfloat2float", "vul_func_code": "static float vorbisfloat2float(uint_fast32_t val)\n{\n    double mant = val & 0x1fffff;\n    long exp    = (val & 0x7fe00000L) >> 21;\n    if (val & 0x80000000)\n        mant = -mant;\n    return ldexp(mant, exp - 20 - 768);\n}", "patch_func_code": "static float vorbisfloat2float(unsigned val)\n{\n    double mant = val & 0x1fffff;\n    long exp    = (val & 0x7fe00000L) >> 21;\n    if (val & 0x80000000)\n        mant = -mant;\n    return ldexp(mant, exp - 20 - 768);\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1], "raw_after_change_lines": [1], "bug_lines": [1], "added": [false], "idx": 229}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "5584----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25b274a85d250156fa649dc424cb0305f35fd9ed_1.json----decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_25b274a85d250156fa649dc424cb0305f35fd9ed_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25b274a85d250156fa649dc424cb0305f35fd9ed_1.json", "function_name": "decode_frame", "vul_func_code": "static int decode_frame(WmallDecodeCtx *s)\n{\n    GetBitContext* gb = &s->gb;\n    int more_frames = 0, len = 0, i, ret;\n\n    s->frame.nb_samples = s->samples_per_frame;\n    if ((ret = ff_get_buffer(s->avctx, &s->frame, 0)) < 0) {\n        /* return an error if no frame could be decoded at all */\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"not enough space for the output samples\\n\");\n        s->packet_loss = 1;\n        return ret;\n    }\n    for (i = 0; i < s->num_channels; i++) {\n        s->samples_16[i] = (int16_t *)s->frame.extended_data[i];\n        s->samples_32[i] = (int32_t *)s->frame.extended_data[i];\n    }\n\n    /* get frame length */\n    if (s->len_prefix)\n        len = get_bits(gb, s->log2_frame_size);\n\n    /* decode tile information */\n    if (decode_tilehdr(s)) {\n        s->packet_loss = 1;\n        return 0;\n    }\n\n    /* read drc info */\n    if (s->dynamic_range_compression)\n        s->drc_gain = get_bits(gb, 8);\n\n    /* no idea what these are for, might be the number of samples\n       that need to be skipped at the beginning or end of a stream */\n    if (get_bits1(gb)) {\n        int av_unused skip;\n\n        /* usually true for the first frame */\n        if (get_bits1(gb)) {\n            skip = get_bits(gb, av_log2(s->samples_per_frame * 2));\n            av_dlog(s->avctx, \"start skip: %i\\n\", skip);\n        }\n\n        /* sometimes true for the last frame */\n        if (get_bits1(gb)) {\n            skip = get_bits(gb, av_log2(s->samples_per_frame * 2));\n            av_dlog(s->avctx, \"end skip: %i\\n\", skip);\n        }\n\n    }\n\n    /* reset subframe states */\n    s->parsed_all_subframes = 0;\n    for (i = 0; i < s->num_channels; i++) {\n        s->channel[i].decoded_samples = 0;\n        s->channel[i].cur_subframe    = 0;\n    }\n\n    /* decode all subframes */\n    while (!s->parsed_all_subframes) {\n        if (decode_subframe(s) < 0) {\n            s->packet_loss = 1;\n            return 0;\n        }\n    }\n\n    av_dlog(s->avctx, \"Frame done\\n\");\n\n    if (s->skip_frame)\n        s->skip_frame = 0;\n\n    if (s->len_prefix) {\n        if (len != (get_bits_count(gb) - s->frame_offset) + 2) {\n            /* FIXME: not sure if this is always an error */\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"frame[%i] would have to skip %i bits\\n\", s->frame_num,\n                   len - (get_bits_count(gb) - s->frame_offset) - 1);\n            s->packet_loss = 1;\n            return 0;\n        }\n\n        /* skip the rest of the frame data */\n        skip_bits_long(gb, len - (get_bits_count(gb) - s->frame_offset) - 1);\n    }\n\n    /* decode trailer bit */\n    more_frames = get_bits1(gb);\n    ++s->frame_num;\n    return more_frames;\n}", "patch_func_code": "static int decode_frame(WmallDecodeCtx *s)\n{\n    GetBitContext* gb = &s->gb;\n    int more_frames = 0, len = 0, i, ret;\n\n    s->frame->nb_samples = s->samples_per_frame;\n    if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {\n        /* return an error if no frame could be decoded at all */\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"not enough space for the output samples\\n\");\n        s->packet_loss = 1;\n        return ret;\n    }\n    for (i = 0; i < s->num_channels; i++) {\n        s->samples_16[i] = (int16_t *)s->frame->extended_data[i];\n        s->samples_32[i] = (int32_t *)s->frame->extended_data[i];\n    }\n\n    /* get frame length */\n    if (s->len_prefix)\n        len = get_bits(gb, s->log2_frame_size);\n\n    /* decode tile information */\n    if (decode_tilehdr(s)) {\n        s->packet_loss = 1;\n        return 0;\n    }\n\n    /* read drc info */\n    if (s->dynamic_range_compression)\n        s->drc_gain = get_bits(gb, 8);\n\n    /* no idea what these are for, might be the number of samples\n       that need to be skipped at the beginning or end of a stream */\n    if (get_bits1(gb)) {\n        int av_unused skip;\n\n        /* usually true for the first frame */\n        if (get_bits1(gb)) {\n            skip = get_bits(gb, av_log2(s->samples_per_frame * 2));\n            av_dlog(s->avctx, \"start skip: %i\\n\", skip);\n        }\n\n        /* sometimes true for the last frame */\n        if (get_bits1(gb)) {\n            skip = get_bits(gb, av_log2(s->samples_per_frame * 2));\n            av_dlog(s->avctx, \"end skip: %i\\n\", skip);\n        }\n\n    }\n\n    /* reset subframe states */\n    s->parsed_all_subframes = 0;\n    for (i = 0; i < s->num_channels; i++) {\n        s->channel[i].decoded_samples = 0;\n        s->channel[i].cur_subframe    = 0;\n    }\n\n    /* decode all subframes */\n    while (!s->parsed_all_subframes) {\n        if (decode_subframe(s) < 0) {\n            s->packet_loss = 1;\n            return 0;\n        }\n    }\n\n    av_dlog(s->avctx, \"Frame done\\n\");\n\n    if (s->skip_frame)\n        s->skip_frame = 0;\n\n    if (s->len_prefix) {\n        if (len != (get_bits_count(gb) - s->frame_offset) + 2) {\n            /* FIXME: not sure if this is always an error */\n            av_log(s->avctx, AV_LOG_ERROR,\n                   \"frame[%i] would have to skip %i bits\\n\", s->frame_num,\n                   len - (get_bits_count(gb) - s->frame_offset) - 1);\n            s->packet_loss = 1;\n            return 0;\n        }\n\n        /* skip the rest of the frame data */\n        skip_bits_long(gb, len - (get_bits_count(gb) - s->frame_offset) - 1);\n    }\n\n    /* decode trailer bit */\n    more_frames = get_bits1(gb);\n    ++s->frame_num;\n    return more_frames;\n}", "before_change_lines": [6, 7, 15, 16], "raw_before_change_lines": [6, 7, 15, 16], "after_change_lines": [6, 7, 15, 16], "raw_after_change_lines": [6, 7, 15, 16], "bug_lines": [6, 7, 15, 16], "added": [false, false, false, false], "idx": 230}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5586----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_1.json----vp8_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_1.json", "function_name": "vp8_decode_frame", "vul_func_code": "static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    VP8Context *s = avctx->priv_data;\n    int ret, mb_x, mb_y, i, y, referenced;\n    enum AVDiscard skip_thresh;\n    AVFrame *av_uninit(curframe), *prev_frame = s->framep[VP56_FRAME_CURRENT];\n\n    if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0)\n        return ret;\n\n    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT\n                                || s->update_altref == VP56_FRAME_CURRENT;\n\n    skip_thresh = !referenced ? AVDISCARD_NONREF :\n                    !s->keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL;\n\n    if (avctx->skip_frame >= skip_thresh) {\n        s->invisible = 1;\n        goto skip_decode;\n    }\n    s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;\n\n    // release no longer referenced frames\n    for (i = 0; i < 5; i++)\n        if (s->frames[i].data[0] &&\n            &s->frames[i] != prev_frame &&\n            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])\n            ff_thread_release_buffer(avctx, &s->frames[i]);\n\n    // find a free buffer\n    for (i = 0; i < 5; i++)\n        if (&s->frames[i] != prev_frame &&\n            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) {\n            curframe = s->framep[VP56_FRAME_CURRENT] = &s->frames[i];\n            break;\n        }\n    if (i == 5) {\n        av_log(avctx, AV_LOG_FATAL, \"Ran out of free frames!\\n\");\n        abort();\n    }\n    if (curframe->data[0])\n        ff_thread_release_buffer(avctx, curframe);\n\n    curframe->key_frame = s->keyframe;\n    curframe->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n    curframe->reference = referenced ? 3 : 0;\n    curframe->ref_index[0] = s->segmentation_map;\n    if ((ret = ff_thread_get_buffer(avctx, curframe))) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed!\\n\");\n        return ret;\n    }\n\n    // check if golden and altref are swapped\n    if (s->update_altref != VP56_FRAME_NONE) {\n        s->next_framep[VP56_FRAME_GOLDEN2]  = s->framep[s->update_altref];\n    } else {\n        s->next_framep[VP56_FRAME_GOLDEN2]  = s->framep[VP56_FRAME_GOLDEN2];\n    }\n    if (s->update_golden != VP56_FRAME_NONE) {\n        s->next_framep[VP56_FRAME_GOLDEN]   = s->framep[s->update_golden];\n    } else {\n        s->next_framep[VP56_FRAME_GOLDEN]   = s->framep[VP56_FRAME_GOLDEN];\n    }\n    if (s->update_last) {\n        s->next_framep[VP56_FRAME_PREVIOUS] = curframe;\n    } else {\n        s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];\n    }\n    s->next_framep[VP56_FRAME_CURRENT]      = curframe;\n\n    ff_thread_finish_setup(avctx);\n\n    // Given that arithmetic probabilities are updated every frame, it's quite likely\n    // that the values we have on a random interframe are complete junk if we didn't\n    // start decode on a keyframe. So just don't display anything rather than junk.\n    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n                         !s->framep[VP56_FRAME_GOLDEN] ||\n                         !s->framep[VP56_FRAME_GOLDEN2])) {\n        av_log(avctx, AV_LOG_WARNING, \"Discarding interframe without a prior keyframe!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->linesize   = curframe->linesize[0];\n    s->uvlinesize = curframe->linesize[1];\n\n    if (!s->edge_emu_buffer)\n        s->edge_emu_buffer = av_malloc(21*s->linesize);\n\n    memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz));\n\n    /* Zero macroblock structures for top/top-left prediction from outside the frame. */\n    memset(s->macroblocks + s->mb_height*2 - 1, 0, (s->mb_width+1)*sizeof(*s->macroblocks));\n\n    // top edge of 127 for intra prediction\n    if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {\n        s->top_border[0][15] = s->top_border[0][23] = 127;\n        memset(s->top_border[1]-1, 127, s->mb_width*sizeof(*s->top_border)+1);\n    }\n    memset(s->ref_count, 0, sizeof(s->ref_count));\n    if (s->keyframe)\n        memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width*4);\n\n#define MARGIN (16 << 2)\n    s->mv_min.y = -MARGIN;\n    s->mv_max.y = ((s->mb_height - 1) << 6) + MARGIN;\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions-1)];\n        VP8Macroblock *mb = s->macroblocks + (s->mb_height - mb_y - 1)*2;\n        int mb_xy = mb_y*s->mb_width;\n        uint8_t *dst[3] = {\n            curframe->data[0] + 16*mb_y*s->linesize,\n            curframe->data[1] +  8*mb_y*s->uvlinesize,\n            curframe->data[2] +  8*mb_y*s->uvlinesize\n        };\n\n        memset(mb - 1, 0, sizeof(*mb));   // zero left macroblock\n        memset(s->left_nnz, 0, sizeof(s->left_nnz));\n        AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED*0x01010101);\n\n        // left edge of 129 for intra prediction\n        if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {\n            for (i = 0; i < 3; i++)\n                for (y = 0; y < 16>>!!i; y++)\n                    dst[i][y*curframe->linesize[i]-1] = 129;\n            if (mb_y == 1) // top left edge is also 129\n                s->top_border[0][15] = s->top_border[0][23] = s->top_border[0][31] = 129;\n        }\n\n        s->mv_min.x = -MARGIN;\n        s->mv_max.x = ((s->mb_width  - 1) << 6) + MARGIN;\n        if (prev_frame && s->segmentation.enabled && !s->segmentation.update_map)\n            ff_thread_await_progress(prev_frame, mb_y, 0);\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {\n            /* Prefetch the current frame, 4 MBs ahead */\n            s->dsp.prefetch(dst[0] + (mb_x&3)*4*s->linesize + 64, s->linesize, 4);\n            s->dsp.prefetch(dst[1] + (mb_x&7)*s->uvlinesize + 64, dst[2] - dst[1], 2);\n\n            decode_mb_mode(s, mb, mb_x, mb_y, s->segmentation_map + mb_xy,\n                           prev_frame ? prev_frame->ref_index[0] + mb_xy : NULL);\n\n            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);\n\n            if (!mb->skip)\n                decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz);\n\n            if (mb->mode <= MODE_I4x4)\n                intra_predict(s, dst, mb, mb_x, mb_y);\n            else\n                inter_predict(s, dst, mb, mb_x, mb_y);\n\n            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);\n\n            if (!mb->skip) {\n                idct_mb(s, dst, mb);\n            } else {\n                AV_ZERO64(s->left_nnz);\n                AV_WN64(s->top_nnz[mb_x], 0);   // array of 9, so unaligned\n\n                // Reset DC block predictors if they would exist if the mb had coefficients\n                if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {\n                    s->left_nnz[8]      = 0;\n                    s->top_nnz[mb_x][8] = 0;\n                }\n            }\n\n            if (s->deblock_filter)\n                filter_level_for_mb(s, mb, &s->filter_strength[mb_x]);\n\n            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);\n\n            dst[0] += 16;\n            dst[1] += 8;\n            dst[2] += 8;\n            s->mv_min.x -= 64;\n            s->mv_max.x -= 64;\n        }\n        if (s->deblock_filter) {\n            if (s->filter.simple)\n                filter_mb_row_simple(s, curframe, mb_y);\n            else\n                filter_mb_row(s, curframe, mb_y);\n        }\n        s->mv_min.y -= 64;\n        s->mv_max.y -= 64;\n\n        ff_thread_report_progress(curframe, mb_y, 0);\n    }\n\n    ff_thread_report_progress(curframe, INT_MAX, 0);\nskip_decode:\n    // if future frames don't use the updated probabilities,\n    // reset them to the values we saved\n    if (!s->update_probabilities)\n        s->prob[0] = s->prob[1];\n\n    memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n\n    if (!s->invisible) {\n        *(AVFrame*)data = *curframe;\n        *data_size = sizeof(AVFrame);\n    }\n\n    return avpkt->size;\n}", "patch_func_code": "static int vp8_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    VP8Context *s = avctx->priv_data;\n    int ret, mb_x, mb_y, i, y, referenced;\n    enum AVDiscard skip_thresh;\n    AVFrame *av_uninit(curframe), *prev_frame = s->framep[VP56_FRAME_CURRENT];\n\n    release_queued_segmaps(s, 0);\n\n    if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0)\n        return ret;\n\n    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT\n                                || s->update_altref == VP56_FRAME_CURRENT;\n\n    skip_thresh = !referenced ? AVDISCARD_NONREF :\n                    !s->keyframe ? AVDISCARD_NONKEY : AVDISCARD_ALL;\n\n    if (avctx->skip_frame >= skip_thresh) {\n        s->invisible = 1;\n        goto skip_decode;\n    }\n    s->deblock_filter = s->filter.level && avctx->skip_loop_filter < skip_thresh;\n\n    // release no longer referenced frames\n    for (i = 0; i < 5; i++)\n        if (s->frames[i].data[0] &&\n            &s->frames[i] != prev_frame &&\n            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])\n            vp8_release_frame(s, &s->frames[i], 0);\n\n    // find a free buffer\n    for (i = 0; i < 5; i++)\n        if (&s->frames[i] != prev_frame &&\n            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN] &&\n            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) {\n            curframe = s->framep[VP56_FRAME_CURRENT] = &s->frames[i];\n            break;\n        }\n    if (i == 5) {\n        av_log(avctx, AV_LOG_FATAL, \"Ran out of free frames!\\n\");\n        abort();\n    }\n    if (curframe->data[0])\n        ff_thread_release_buffer(avctx, curframe);\n\n    curframe->key_frame = s->keyframe;\n    curframe->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n    curframe->reference = referenced ? 3 : 0;\n    if ((ret = vp8_alloc_frame(s, curframe))) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed!\\n\");\n        return ret;\n    }\n\n    // check if golden and altref are swapped\n    if (s->update_altref != VP56_FRAME_NONE) {\n        s->next_framep[VP56_FRAME_GOLDEN2]  = s->framep[s->update_altref];\n    } else {\n        s->next_framep[VP56_FRAME_GOLDEN2]  = s->framep[VP56_FRAME_GOLDEN2];\n    }\n    if (s->update_golden != VP56_FRAME_NONE) {\n        s->next_framep[VP56_FRAME_GOLDEN]   = s->framep[s->update_golden];\n    } else {\n        s->next_framep[VP56_FRAME_GOLDEN]   = s->framep[VP56_FRAME_GOLDEN];\n    }\n    if (s->update_last) {\n        s->next_framep[VP56_FRAME_PREVIOUS] = curframe;\n    } else {\n        s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];\n    }\n    s->next_framep[VP56_FRAME_CURRENT]      = curframe;\n\n    ff_thread_finish_setup(avctx);\n\n    // Given that arithmetic probabilities are updated every frame, it's quite likely\n    // that the values we have on a random interframe are complete junk if we didn't\n    // start decode on a keyframe. So just don't display anything rather than junk.\n    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n                         !s->framep[VP56_FRAME_GOLDEN] ||\n                         !s->framep[VP56_FRAME_GOLDEN2])) {\n        av_log(avctx, AV_LOG_WARNING, \"Discarding interframe without a prior keyframe!\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->linesize   = curframe->linesize[0];\n    s->uvlinesize = curframe->linesize[1];\n\n    if (!s->edge_emu_buffer)\n        s->edge_emu_buffer = av_malloc(21*s->linesize);\n\n    memset(s->top_nnz, 0, s->mb_width*sizeof(*s->top_nnz));\n\n    /* Zero macroblock structures for top/top-left prediction from outside the frame. */\n    memset(s->macroblocks + s->mb_height*2 - 1, 0, (s->mb_width+1)*sizeof(*s->macroblocks));\n\n    // top edge of 127 for intra prediction\n    if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {\n        s->top_border[0][15] = s->top_border[0][23] = 127;\n        memset(s->top_border[1]-1, 127, s->mb_width*sizeof(*s->top_border)+1);\n    }\n    memset(s->ref_count, 0, sizeof(s->ref_count));\n    if (s->keyframe)\n        memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width*4);\n\n#define MARGIN (16 << 2)\n    s->mv_min.y = -MARGIN;\n    s->mv_max.y = ((s->mb_height - 1) << 6) + MARGIN;\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n        VP56RangeCoder *c = &s->coeff_partition[mb_y & (s->num_coeff_partitions-1)];\n        VP8Macroblock *mb = s->macroblocks + (s->mb_height - mb_y - 1)*2;\n        int mb_xy = mb_y*s->mb_width;\n        uint8_t *dst[3] = {\n            curframe->data[0] + 16*mb_y*s->linesize,\n            curframe->data[1] +  8*mb_y*s->uvlinesize,\n            curframe->data[2] +  8*mb_y*s->uvlinesize\n        };\n\n        memset(mb - 1, 0, sizeof(*mb));   // zero left macroblock\n        memset(s->left_nnz, 0, sizeof(s->left_nnz));\n        AV_WN32A(s->intra4x4_pred_mode_left, DC_PRED*0x01010101);\n\n        // left edge of 129 for intra prediction\n        if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {\n            for (i = 0; i < 3; i++)\n                for (y = 0; y < 16>>!!i; y++)\n                    dst[i][y*curframe->linesize[i]-1] = 129;\n            if (mb_y == 1) // top left edge is also 129\n                s->top_border[0][15] = s->top_border[0][23] = s->top_border[0][31] = 129;\n        }\n\n        s->mv_min.x = -MARGIN;\n        s->mv_max.x = ((s->mb_width  - 1) << 6) + MARGIN;\n        if (prev_frame && s->segmentation.enabled && !s->segmentation.update_map)\n            ff_thread_await_progress(prev_frame, mb_y, 0);\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {\n            /* Prefetch the current frame, 4 MBs ahead */\n            s->dsp.prefetch(dst[0] + (mb_x&3)*4*s->linesize + 64, s->linesize, 4);\n            s->dsp.prefetch(dst[1] + (mb_x&7)*s->uvlinesize + 64, dst[2] - dst[1], 2);\n\n            decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,\n                           prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL);\n\n            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);\n\n            if (!mb->skip)\n                decode_mb_coeffs(s, c, mb, s->top_nnz[mb_x], s->left_nnz);\n\n            if (mb->mode <= MODE_I4x4)\n                intra_predict(s, dst, mb, mb_x, mb_y);\n            else\n                inter_predict(s, dst, mb, mb_x, mb_y);\n\n            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);\n\n            if (!mb->skip) {\n                idct_mb(s, dst, mb);\n            } else {\n                AV_ZERO64(s->left_nnz);\n                AV_WN64(s->top_nnz[mb_x], 0);   // array of 9, so unaligned\n\n                // Reset DC block predictors if they would exist if the mb had coefficients\n                if (mb->mode != MODE_I4x4 && mb->mode != VP8_MVMODE_SPLIT) {\n                    s->left_nnz[8]      = 0;\n                    s->top_nnz[mb_x][8] = 0;\n                }\n            }\n\n            if (s->deblock_filter)\n                filter_level_for_mb(s, mb, &s->filter_strength[mb_x]);\n\n            prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);\n\n            dst[0] += 16;\n            dst[1] += 8;\n            dst[2] += 8;\n            s->mv_min.x -= 64;\n            s->mv_max.x -= 64;\n        }\n        if (s->deblock_filter) {\n            if (s->filter.simple)\n                filter_mb_row_simple(s, curframe, mb_y);\n            else\n                filter_mb_row(s, curframe, mb_y);\n        }\n        s->mv_min.y -= 64;\n        s->mv_max.y -= 64;\n\n        ff_thread_report_progress(curframe, mb_y, 0);\n    }\n\n    ff_thread_report_progress(curframe, INT_MAX, 0);\nskip_decode:\n    // if future frames don't use the updated probabilities,\n    // reset them to the values we saved\n    if (!s->update_probabilities)\n        s->prob[0] = s->prob[1];\n\n    memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n\n    if (!s->invisible) {\n        *(AVFrame*)data = *curframe;\n        *data_size = sizeof(AVFrame);\n    }\n\n    return avpkt->size;\n}", "before_change_lines": [31, 52, 53, 145, 146], "raw_before_change_lines": [31, 52, 53, 145, 146], "after_change_lines": [9, 33, 54, 146, 147], "raw_after_change_lines": [9, 10, 33, 54, 146, 147], "bug_lines": [31, 52, 53, 145, 146], "added": [false, false, false, false, false], "idx": 231}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5587----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_1.json----update_dimensions", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_25c235c5ea857ef81f077c11e10859735096a4c3_1.json", "function_name": "update_dimensions", "vul_func_code": "static int update_dimensions(VP8Context *s, int width, int height)\n{\n    if (width  != s->avctx->width ||\n        height != s->avctx->height) {\n        if (av_image_check_size(width, height, 0, s->avctx))\n            return AVERROR_INVALIDDATA;\n\n        vp8_decode_flush(s->avctx);\n\n        avcodec_set_dimensions(s->avctx, width, height);\n    }\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n    s->segmentation_map        = av_mallocz(s->mb_width*s->mb_height);\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n        !s->top_nnz || !s->top_border || !s->segmentation_map)\n        return AVERROR(ENOMEM);\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n    return 0;\n}", "patch_func_code": "static int update_dimensions(VP8Context *s, int width, int height)\n{\n    if (width  != s->avctx->width ||\n        height != s->avctx->height) {\n        if (av_image_check_size(width, height, 0, s->avctx))\n            return AVERROR_INVALIDDATA;\n\n        vp8_decode_flush_impl(s->avctx, 1, 0);\n\n        avcodec_set_dimensions(s->avctx, width, height);\n    }\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n        !s->top_nnz || !s->top_border)\n        return AVERROR(ENOMEM);\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n    return 0;\n}", "before_change_lines": [8, 21, 24], "raw_before_change_lines": [8, 21, 24], "after_change_lines": [8, 23], "raw_after_change_lines": [8, 23], "bug_lines": [8, 21, 24], "added": [false, false, false], "idx": 232}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5604----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2672936e870e0dc6d087920fbb7f1b9639770e4c_1.json----ff_fdct248_islow", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_2672936e870e0dc6d087920fbb7f1b9639770e4c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2672936e870e0dc6d087920fbb7f1b9639770e4c_1.json", "function_name": "ff_fdct248_islow", "vul_func_code": "GLOBAL(void)\nff_fdct248_islow (DCTELEM * data)\n{\n  int_fast32_t tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  int_fast32_t tmp10, tmp11, tmp12, tmp13;\n  int_fast32_t z1;\n  DCTELEM *dataptr;\n  int ctr;\n\n  row_fdct(data);\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n     tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*1];\n     tmp1 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3];\n     tmp2 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*5];\n     tmp3 = dataptr[DCTSIZE*6] + dataptr[DCTSIZE*7];\n     tmp4 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*1];\n     tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3];\n     tmp6 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*5];\n     tmp7 = dataptr[DCTSIZE*6] - dataptr[DCTSIZE*7];\n\n     tmp10 = tmp0 + tmp3;\n     tmp11 = tmp1 + tmp2;\n     tmp12 = tmp1 - tmp2;\n     tmp13 = tmp0 - tmp3;\n\n     dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);\n     dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);\n\n     z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n     dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                                            CONST_BITS+PASS1_BITS);\n     dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),\n                                            CONST_BITS+PASS1_BITS);\n\n     tmp10 = tmp4 + tmp7;\n     tmp11 = tmp5 + tmp6;\n     tmp12 = tmp5 - tmp6;\n     tmp13 = tmp4 - tmp7;\n\n     dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);\n     dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);\n\n     z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n     dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                                            CONST_BITS+PASS1_BITS);\n     dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),\n                                            CONST_BITS+PASS1_BITS);\n\n     dataptr++;                 /* advance pointer to next column */\n  }\n}", "patch_func_code": "GLOBAL(void)\nff_fdct248_islow (DCTELEM * data)\n{\n  int tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;\n  int tmp10, tmp11, tmp12, tmp13;\n  int z1;\n  DCTELEM *dataptr;\n  int ctr;\n\n  row_fdct(data);\n\n  /* Pass 2: process columns.\n   * We remove the PASS1_BITS scaling, but leave the results scaled up\n   * by an overall factor of 8.\n   */\n\n  dataptr = data;\n  for (ctr = DCTSIZE-1; ctr >= 0; ctr--) {\n     tmp0 = dataptr[DCTSIZE*0] + dataptr[DCTSIZE*1];\n     tmp1 = dataptr[DCTSIZE*2] + dataptr[DCTSIZE*3];\n     tmp2 = dataptr[DCTSIZE*4] + dataptr[DCTSIZE*5];\n     tmp3 = dataptr[DCTSIZE*6] + dataptr[DCTSIZE*7];\n     tmp4 = dataptr[DCTSIZE*0] - dataptr[DCTSIZE*1];\n     tmp5 = dataptr[DCTSIZE*2] - dataptr[DCTSIZE*3];\n     tmp6 = dataptr[DCTSIZE*4] - dataptr[DCTSIZE*5];\n     tmp7 = dataptr[DCTSIZE*6] - dataptr[DCTSIZE*7];\n\n     tmp10 = tmp0 + tmp3;\n     tmp11 = tmp1 + tmp2;\n     tmp12 = tmp1 - tmp2;\n     tmp13 = tmp0 - tmp3;\n\n     dataptr[DCTSIZE*0] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);\n     dataptr[DCTSIZE*4] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);\n\n     z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n     dataptr[DCTSIZE*2] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                                            CONST_BITS+PASS1_BITS);\n     dataptr[DCTSIZE*6] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),\n                                            CONST_BITS+PASS1_BITS);\n\n     tmp10 = tmp4 + tmp7;\n     tmp11 = tmp5 + tmp6;\n     tmp12 = tmp5 - tmp6;\n     tmp13 = tmp4 - tmp7;\n\n     dataptr[DCTSIZE*1] = (DCTELEM) DESCALE(tmp10 + tmp11, PASS1_BITS);\n     dataptr[DCTSIZE*5] = (DCTELEM) DESCALE(tmp10 - tmp11, PASS1_BITS);\n\n     z1 = MULTIPLY(tmp12 + tmp13, FIX_0_541196100);\n     dataptr[DCTSIZE*3] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp13, FIX_0_765366865),\n                                            CONST_BITS+PASS1_BITS);\n     dataptr[DCTSIZE*7] = (DCTELEM) DESCALE(z1 + MULTIPLY(tmp12, - FIX_1_847759065),\n                                            CONST_BITS+PASS1_BITS);\n\n     dataptr++;                 /* advance pointer to next column */\n  }\n}", "before_change_lines": [4, 5, 6], "raw_before_change_lines": [4, 5, 6], "after_change_lines": [4, 5, 6], "raw_after_change_lines": [4, 5, 6], "bug_lines": [4, 5, 6], "added": [false, false, false], "idx": 233}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "5611----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_1.json----decode_ics_info", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_1.json", "function_name": "decode_ics_info", "vul_func_code": "static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,\n                           GetBitContext *gb)\n{\n    if (get_bits1(gb)) {\n        av_log(ac->avctx, AV_LOG_ERROR, \"Reserved bit set.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ics->window_sequence[1] = ics->window_sequence[0];\n    ics->window_sequence[0] = get_bits(gb, 2);\n    ics->use_kb_window[1]   = ics->use_kb_window[0];\n    ics->use_kb_window[0]   = get_bits1(gb);\n    ics->num_window_groups  = 1;\n    ics->group_len[0]       = 1;\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n        int i;\n        ics->max_sfb = get_bits(gb, 4);\n        for (i = 0; i < 7; i++) {\n            if (get_bits1(gb)) {\n                ics->group_len[ics->num_window_groups - 1]++;\n            } else {\n                ics->num_window_groups++;\n                ics->group_len[ics->num_window_groups - 1] = 1;\n            }\n        }\n        ics->num_windows       = 8;\n        ics->swb_offset        =    ff_swb_offset_128[ac->m4ac.sampling_index];\n        ics->num_swb           =   ff_aac_num_swb_128[ac->m4ac.sampling_index];\n        ics->tns_max_bands     = ff_tns_max_bands_128[ac->m4ac.sampling_index];\n        ics->predictor_present = 0;\n    } else {\n        ics->max_sfb               = get_bits(gb, 6);\n        ics->num_windows           = 1;\n        ics->swb_offset            =    ff_swb_offset_1024[ac->m4ac.sampling_index];\n        ics->num_swb               =   ff_aac_num_swb_1024[ac->m4ac.sampling_index];\n        ics->tns_max_bands         = ff_tns_max_bands_1024[ac->m4ac.sampling_index];\n        ics->predictor_present     = get_bits1(gb);\n        ics->predictor_reset_group = 0;\n        if (ics->predictor_present) {\n            if (ac->m4ac.object_type == AOT_AAC_MAIN) {\n                if (decode_prediction(ac, ics, gb)) {\n                    return AVERROR_INVALIDDATA;\n                }\n            } else if (ac->m4ac.object_type == AOT_AAC_LC) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"Prediction is not allowed in AAC-LC.\\n\");\n                return AVERROR_INVALIDDATA;\n            } else {\n                if ((ics->ltp.present = get_bits(gb, 1)))\n                    decode_ltp(ac, &ics->ltp, gb, ics->max_sfb);\n            }\n        }\n    }\n\n    if (ics->max_sfb > ics->num_swb) {\n        av_log(ac->avctx, AV_LOG_ERROR,\n               \"Number of scalefactor bands in group (%d) exceeds limit (%d).\\n\",\n               ics->max_sfb, ics->num_swb);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "patch_func_code": "static int decode_ics_info(AACContext *ac, IndividualChannelStream *ics,\n                           GetBitContext *gb)\n{\n    if (get_bits1(gb)) {\n        av_log(ac->avctx, AV_LOG_ERROR, \"Reserved bit set.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    ics->window_sequence[1] = ics->window_sequence[0];\n    ics->window_sequence[0] = get_bits(gb, 2);\n    ics->use_kb_window[1]   = ics->use_kb_window[0];\n    ics->use_kb_window[0]   = get_bits1(gb);\n    ics->num_window_groups  = 1;\n    ics->group_len[0]       = 1;\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n        int i;\n        ics->max_sfb = get_bits(gb, 4);\n        for (i = 0; i < 7; i++) {\n            if (get_bits1(gb)) {\n                ics->group_len[ics->num_window_groups - 1]++;\n            } else {\n                ics->num_window_groups++;\n                ics->group_len[ics->num_window_groups - 1] = 1;\n            }\n        }\n        ics->num_windows       = 8;\n        ics->swb_offset        =    ff_swb_offset_128[ac->oc[1].m4ac.sampling_index];\n        ics->num_swb           =   ff_aac_num_swb_128[ac->oc[1].m4ac.sampling_index];\n        ics->tns_max_bands     = ff_tns_max_bands_128[ac->oc[1].m4ac.sampling_index];\n        ics->predictor_present = 0;\n    } else {\n        ics->max_sfb               = get_bits(gb, 6);\n        ics->num_windows           = 1;\n        ics->swb_offset            =    ff_swb_offset_1024[ac->oc[1].m4ac.sampling_index];\n        ics->num_swb               =   ff_aac_num_swb_1024[ac->oc[1].m4ac.sampling_index];\n        ics->tns_max_bands         = ff_tns_max_bands_1024[ac->oc[1].m4ac.sampling_index];\n        ics->predictor_present     = get_bits1(gb);\n        ics->predictor_reset_group = 0;\n        if (ics->predictor_present) {\n            if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN) {\n                if (decode_prediction(ac, ics, gb)) {\n                    return AVERROR_INVALIDDATA;\n                }\n            } else if (ac->oc[1].m4ac.object_type == AOT_AAC_LC) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"Prediction is not allowed in AAC-LC.\\n\");\n                return AVERROR_INVALIDDATA;\n            } else {\n                if ((ics->ltp.present = get_bits(gb, 1)))\n                    decode_ltp(ac, &ics->ltp, gb, ics->max_sfb);\n            }\n        }\n    }\n\n    if (ics->max_sfb > ics->num_swb) {\n        av_log(ac->avctx, AV_LOG_ERROR,\n               \"Number of scalefactor bands in group (%d) exceeds limit (%d).\\n\",\n               ics->max_sfb, ics->num_swb);\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}", "before_change_lines": [26, 27, 28, 33, 34, 35, 39, 43], "raw_before_change_lines": [26, 27, 28, 33, 34, 35, 39, 43], "after_change_lines": [26, 27, 28, 33, 34, 35, 39, 43], "raw_after_change_lines": [26, 27, 28, 33, 34, 35, 39, 43], "bug_lines": [26, 27, 28, 33, 34, 35, 39, 43], "added": [false, false, false, false, false, false, false, false], "idx": 234}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "5612----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_1.json----decode_ics", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26a4f9b406be89e1a552baf604b41c6480966c1d_1.json", "function_name": "decode_ics", "vul_func_code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce,\n                      GetBitContext *gb, int common_window, int scale_flag)\n{\n    Pulse pulse;\n    TemporalNoiseShaping    *tns = &sce->tns;\n    IndividualChannelStream *ics = &sce->ics;\n    float *out = sce->coeffs;\n    int global_gain, pulse_present = 0;\n\n    /* This assignment is to silence a GCC warning about the variable being used\n     * uninitialized when in fact it always is.\n     */\n    pulse.num_pulse = 0;\n\n    global_gain = get_bits(gb, 8);\n\n    if (!common_window && !scale_flag) {\n        if (decode_ics_info(ac, ics, gb) < 0)\n            return AVERROR_INVALIDDATA;\n    }\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n        return -1;\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n        return -1;\n\n    pulse_present = 0;\n    if (!scale_flag) {\n        if ((pulse_present = get_bits1(gb))) {\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n                return -1;\n            }\n            if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"Pulse data corrupt or invalid.\\n\");\n                return -1;\n            }\n        }\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n            return -1;\n        if (get_bits1(gb)) {\n            av_log_missing_feature(ac->avctx, \"SSR\", 1);\n            return -1;\n        }\n    }\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n        return -1;\n\n    if (ac->m4ac.object_type == AOT_AAC_MAIN && !common_window)\n        apply_prediction(ac, sce);\n\n    return 0;\n}", "patch_func_code": "static int decode_ics(AACContext *ac, SingleChannelElement *sce,\n                      GetBitContext *gb, int common_window, int scale_flag)\n{\n    Pulse pulse;\n    TemporalNoiseShaping    *tns = &sce->tns;\n    IndividualChannelStream *ics = &sce->ics;\n    float *out = sce->coeffs;\n    int global_gain, pulse_present = 0;\n\n    /* This assignment is to silence a GCC warning about the variable being used\n     * uninitialized when in fact it always is.\n     */\n    pulse.num_pulse = 0;\n\n    global_gain = get_bits(gb, 8);\n\n    if (!common_window && !scale_flag) {\n        if (decode_ics_info(ac, ics, gb) < 0)\n            return AVERROR_INVALIDDATA;\n    }\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n        return -1;\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n        return -1;\n\n    pulse_present = 0;\n    if (!scale_flag) {\n        if ((pulse_present = get_bits1(gb))) {\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n                return -1;\n            }\n            if (decode_pulses(&pulse, gb, ics->swb_offset, ics->num_swb)) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"Pulse data corrupt or invalid.\\n\");\n                return -1;\n            }\n        }\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n            return -1;\n        if (get_bits1(gb)) {\n            av_log_missing_feature(ac->avctx, \"SSR\", 1);\n            return -1;\n        }\n    }\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n        return -1;\n\n    if (ac->oc[1].m4ac.object_type == AOT_AAC_MAIN && !common_window)\n        apply_prediction(ac, sce);\n\n    return 0;\n}", "before_change_lines": [50], "raw_before_change_lines": [50], "after_change_lines": [50], "raw_after_change_lines": [50], "bug_lines": [50], "added": [false], "idx": 235}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5619----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26c345d5e1490ea3c0739e1d13190ea184c0c2a6_1.json----decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_26c345d5e1490ea3c0739e1d13190ea184c0c2a6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_26c345d5e1490ea3c0739e1d13190ea184c0c2a6_1.json", "function_name": "decode_frame", "vul_func_code": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    H264Context *h     = avctx->priv_data;\n    MpegEncContext *s  = &h->s;\n    AVFrame *pict      = data;\n    int buf_index      = 0;\n\n    s->flags  = avctx->flags;\n    s->flags2 = avctx->flags2;\n\n    /* end of stream, output what is still in the buffers */\nout:\n    if (buf_size == 0) {\n        Picture *out;\n        int i, out_idx;\n\n        s->current_picture_ptr = NULL;\n\n        // FIXME factorize this with the output code below\n        out     = h->delayed_pic[0];\n        out_idx = 0;\n        for (i = 1;\n             h->delayed_pic[i] &&\n             !h->delayed_pic[i]->f.key_frame &&\n             !h->delayed_pic[i]->mmco_reset;\n             i++)\n            if (h->delayed_pic[i]->poc < out->poc) {\n                out     = h->delayed_pic[i];\n                out_idx = i;\n            }\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n        if (out) {\n            *got_frame = 1;\n            *pict      = out->f;\n        }\n\n        return buf_index;\n    }\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n    if (buf_index < 0)\n        return -1;\n\n    if (!s->current_picture_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n        buf_size = 0;\n        goto out;\n    }\n\n    if (!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr) {\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n            return 0;\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n        return -1;\n    }\n\n    if (!(s->flags2 & CODEC_FLAG2_CHUNKS) ||\n        (s->mb_y >= s->mb_height && s->mb_height)) {\n        if (s->flags2 & CODEC_FLAG2_CHUNKS)\n            decode_postinit(h, 1);\n\n        field_end(h, 0);\n        h->context_reinitialized = 0;\n\n        if (!h->next_output_pic) {\n            /* Wait for second field. */\n            *got_frame = 0;\n        } else {\n            *got_frame = 1;\n            *pict      = h->next_output_pic->f;\n        }\n    }\n\n    assert(pict->data[0] || !*got_frame);\n    ff_print_debug_info(s, pict);\n\n    return get_consumed_bytes(s, buf_index, buf_size);\n}", "patch_func_code": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    H264Context *h     = avctx->priv_data;\n    AVFrame *pict      = data;\n    int buf_index      = 0;\n\n    h->flags  = avctx->flags;\n\n    /* end of stream, output what is still in the buffers */\nout:\n    if (buf_size == 0) {\n        Picture *out;\n        int i, out_idx;\n\n        h->cur_pic_ptr = NULL;\n\n        // FIXME factorize this with the output code below\n        out     = h->delayed_pic[0];\n        out_idx = 0;\n        for (i = 1;\n             h->delayed_pic[i] &&\n             !h->delayed_pic[i]->f.key_frame &&\n             !h->delayed_pic[i]->mmco_reset;\n             i++)\n            if (h->delayed_pic[i]->poc < out->poc) {\n                out     = h->delayed_pic[i];\n                out_idx = i;\n            }\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n        if (out) {\n            *got_frame = 1;\n            *pict      = out->f;\n        }\n\n        return buf_index;\n    }\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n    if (buf_index < 0)\n        return -1;\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n        buf_size = 0;\n        goto out;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n            return 0;\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n        return -1;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n            decode_postinit(h, 1);\n\n        field_end(h, 0);\n\n        if (!h->next_output_pic) {\n            /* Wait for second field. */\n            *got_frame = 0;\n        } else {\n            *got_frame = 1;\n            *pict      = h->next_output_pic->f;\n        }\n    }\n\n    assert(pict->data[0] || !*got_frame);\n\n    return get_consumed_bytes(buf_index, buf_size);\n}", "before_change_lines": [7, 11, 12, 20, 50, 55, 62, 63, 64, 68, 80, 82], "raw_before_change_lines": [7, 11, 12, 20, 50, 55, 62, 63, 64, 68, 80, 82], "after_change_lines": [10, 18, 48, 53, 60, 61, 62, 78], "raw_after_change_lines": [10, 18, 48, 53, 60, 61, 62, 78], "bug_lines": [7, 11, 12, 20, 50, 55, 62, 63, 64, 68, 80, 82], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 236}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5646----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2830ca2e8801de1751491b14a282fa0e72b879dc_1.json----write_back_motion", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_2830ca2e8801de1751491b14a282fa0e72b879dc_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2830ca2e8801de1751491b14a282fa0e72b879dc_1.json", "function_name": "write_back_motion", "vul_func_code": "static av_always_inline void write_back_motion(H264Context *h, int mb_type)\n{\n    MpegEncContext *const s = &h->s;\n    const int b_stride      = h->b_stride;\n    const int b_xy  = 4 * s->mb_x + 4 * s->mb_y * h->b_stride; // try mb2b(8)_xy\n    const int b8_xy = 4 * h->mb_xy;\n\n    if (USES_LIST(mb_type, 0)) {\n        write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 0);\n    } else {\n        fill_rectangle(&s->current_picture.f.ref_index[0][b8_xy],\n                       2, 2, 2, (uint8_t)LIST_NOT_USED, 1);\n    }\n    if (USES_LIST(mb_type, 1))\n        write_back_motion_list(h, s, b_stride, b_xy, b8_xy, mb_type, 1);\n\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B && CABAC) {\n        if (IS_8X8(mb_type)) {\n            uint8_t *direct_table = &h->direct_table[4 * h->mb_xy];\n            direct_table[1] = h->sub_mb_type[1] >> 1;\n            direct_table[2] = h->sub_mb_type[2] >> 1;\n            direct_table[3] = h->sub_mb_type[3] >> 1;\n        }\n    }\n}", "patch_func_code": "static av_always_inline void write_back_motion(H264Context *h, int mb_type)\n{\n    const int b_stride      = h->b_stride;\n    const int b_xy  = 4 * h->mb_x + 4 * h->mb_y * h->b_stride; // try mb2b(8)_xy\n    const int b8_xy = 4 * h->mb_xy;\n\n    if (USES_LIST(mb_type, 0)) {\n        write_back_motion_list(h, b_stride, b_xy, b8_xy, mb_type, 0);\n    } else {\n        fill_rectangle(&h->cur_pic.f.ref_index[0][b8_xy],\n                       2, 2, 2, (uint8_t)LIST_NOT_USED, 1);\n    }\n    if (USES_LIST(mb_type, 1))\n        write_back_motion_list(h, b_stride, b_xy, b8_xy, mb_type, 1);\n\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B && CABAC) {\n        if (IS_8X8(mb_type)) {\n            uint8_t *direct_table = &h->direct_table[4 * h->mb_xy];\n            direct_table[1] = h->sub_mb_type[1] >> 1;\n            direct_table[2] = h->sub_mb_type[2] >> 1;\n            direct_table[3] = h->sub_mb_type[3] >> 1;\n        }\n    }\n}", "before_change_lines": [3, 5, 9, 11, 15], "raw_before_change_lines": [3, 5, 9, 11, 15], "after_change_lines": [4, 8, 10, 14], "raw_after_change_lines": [4, 8, 10, 14], "bug_lines": [3, 5, 9, 11, 15], "added": [false, false, false, false, false], "idx": 237}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "5665----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_291c1b07455b08bcabf8dd217db79a81abc6e67d_1.json----ogg_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_291c1b07455b08bcabf8dd217db79a81abc6e67d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_291c1b07455b08bcabf8dd217db79a81abc6e67d_1.json", "function_name": "ogg_packet", "vul_func_code": "static int\nogg_packet (AVFormatContext * s, int *str, int *dstart, int *dsize, int64_t *fpos)\n{\n    struct ogg *ogg = s->priv_data;\n    int idx, i;\n    struct ogg_stream *os;\n    int complete = 0;\n    int segp = 0, psize = 0;\n\n#if 0\n    av_log (s, AV_LOG_DEBUG, \"ogg_packet: curidx=%i\\n\", ogg->curidx);\n#endif\n\n    do{\n        idx = ogg->curidx;\n\n        while (idx < 0){\n            if (ogg_read_page (s, &idx) < 0)\n                return -1;\n        }\n\n        os = ogg->streams + idx;\n\n#if 0\n        av_log (s, AV_LOG_DEBUG,\n                \"ogg_packet: idx=%d pstart=%d psize=%d segp=%d nsegs=%d\\n\",\n                idx, os->pstart, os->psize, os->segp, os->nsegs);\n#endif\n\n        if (!os->codec){\n            if (os->header < 0){\n                os->codec = ogg_find_codec (os->buf, os->bufpos);\n                if (!os->codec){\n                    os->header = 0;\n                    return 0;\n                }\n            }else{\n                return 0;\n            }\n        }\n\n        segp = os->segp;\n        psize = os->psize;\n\n        while (os->segp < os->nsegs){\n            int ss = os->segments[os->segp++];\n            os->psize += ss;\n            if (ss < 255){\n                complete = 1;\n                break;\n            }\n        }\n\n        if (!complete && os->segp == os->nsegs){\n            ogg->curidx = -1;\n            os->incomplete = 1;\n        }\n    }while (!complete);\n\n#if 0\n    av_log (s, AV_LOG_DEBUG,\n            \"ogg_packet: idx %i, frame size %i, start %i\\n\",\n            idx, os->psize, os->pstart);\n#endif\n\n    ogg->curidx = idx;\n    os->incomplete = 0;\n\n    if (!ogg->headers){\n        int hdr = os->codec->header (s, idx);\n        os->header = os->seq;\n        if (!hdr){\n            os->segp = segp;\n            os->psize = psize;\n            ogg->headers = 1;\n            s->data_offset = os->sync_pos;\n        }else{\n            os->pstart += os->psize;\n            os->psize = 0;\n        }\n    }\n\n    if (os->header > -1 && os->seq > os->header){\n        os->pflags = 0;\n        os->pduration = 0;\n        if (os->codec && os->codec->packet)\n            os->codec->packet (s, idx);\n        if (str)\n            *str = idx;\n        if (dstart)\n            *dstart = os->pstart;\n        if (dsize)\n            *dsize = os->psize;\n        if (fpos)\n            *fpos = os->sync_pos;\n        os->pstart += os->psize;\n        os->psize = 0;\n        os->sync_pos = os->page_pos;\n    }\n\n    // determine whether there are more complete packets in this page\n    // if not, the page's granule will apply to this packet\n    os->page_end = 1;\n    for (i = os->segp; i < os->nsegs; i++)\n        if (os->segments[i] < 255) {\n            os->page_end = 0;\n            break;\n        }\n\n    os->seq++;\n    if (os->segp == os->nsegs)\n        ogg->curidx = -1;\n\n    return 0;\n}", "patch_func_code": "static int\nogg_packet (AVFormatContext * s, int *str, int *dstart, int *dsize, int64_t *fpos)\n{\n    struct ogg *ogg = s->priv_data;\n    int idx, i;\n    struct ogg_stream *os;\n    int complete = 0;\n    int segp = 0, psize = 0;\n\n#if 0\n    av_log (s, AV_LOG_DEBUG, \"ogg_packet: curidx=%i\\n\", ogg->curidx);\n#endif\n\n    do{\n        idx = ogg->curidx;\n\n        while (idx < 0){\n            if (ogg_read_page (s, &idx) < 0)\n                return -1;\n        }\n\n        os = ogg->streams + idx;\n\n#if 0\n        av_log (s, AV_LOG_DEBUG,\n                \"ogg_packet: idx=%d pstart=%d psize=%d segp=%d nsegs=%d\\n\",\n                idx, os->pstart, os->psize, os->segp, os->nsegs);\n#endif\n\n        if (!os->codec){\n            if (os->header < 0){\n                os->codec = ogg_find_codec (os->buf, os->bufpos);\n                if (!os->codec){\n                    os->header = 0;\n                    return 0;\n                }\n            }else{\n                return 0;\n            }\n        }\n\n        segp = os->segp;\n        psize = os->psize;\n\n        while (os->segp < os->nsegs){\n            int ss = os->segments[os->segp++];\n            os->psize += ss;\n            if (ss < 255){\n                complete = 1;\n                break;\n            }\n        }\n\n        if (!complete && os->segp == os->nsegs){\n            ogg->curidx = -1;\n            os->incomplete = 1;\n        }\n    }while (!complete);\n\n#if 0\n    av_log (s, AV_LOG_DEBUG,\n            \"ogg_packet: idx %i, frame size %i, start %i\\n\",\n            idx, os->psize, os->pstart);\n#endif\n\n    ogg->curidx = idx;\n    os->incomplete = 0;\n\n    if (os->header) {\n        os->header = os->codec->header (s, idx);\n        if (!os->header){\n            os->segp = segp;\n            os->psize = psize;\n            if (!ogg->headers)\n                s->data_offset = os->sync_pos;\n            ogg->headers = 1;\n        }else{\n            os->pstart += os->psize;\n            os->psize = 0;\n        }\n    } else {\n        os->pflags = 0;\n        os->pduration = 0;\n        if (os->codec && os->codec->packet)\n            os->codec->packet (s, idx);\n        if (str)\n            *str = idx;\n        if (dstart)\n            *dstart = os->pstart;\n        if (dsize)\n            *dsize = os->psize;\n        if (fpos)\n            *fpos = os->sync_pos;\n        os->pstart += os->psize;\n        os->psize = 0;\n        os->sync_pos = os->page_pos;\n    }\n\n    // determine whether there are more complete packets in this page\n    // if not, the page's granule will apply to this packet\n    os->page_end = 1;\n    for (i = os->segp; i < os->nsegs; i++)\n        if (os->segments[i] < 255) {\n            os->page_end = 0;\n            break;\n        }\n\n    if (os->segp == os->nsegs)\n        ogg->curidx = -1;\n\n    return 0;\n}", "before_change_lines": [69, 70, 71, 72, 76, 81, 83, 110], "raw_before_change_lines": [69, 70, 71, 72, 76, 81, 82, 83, 110], "after_change_lines": [69, 70, 71, 74, 75, 81], "raw_after_change_lines": [69, 70, 71, 74, 75, 81], "bug_lines": [69, 70, 71, 72, 76, 81, 82, 83, 110], "added": [false, false, false, false, false, false, false, false, false], "idx": 238}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5677----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_29d7d6dfec445d962ee7f5280cee20554a726785_1.json----vp8_mc_luma", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_29d7d6dfec445d962ee7f5280cee20554a726785_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_29d7d6dfec445d962ee7f5280cee20554a726785_1.json", "function_name": "vp8_mc_luma", "vul_func_code": "static av_always_inline\nvoid vp8_mc_luma(VP8Context *s, uint8_t *dst, AVFrame *ref, const VP56mv *mv,\n                 int x_off, int y_off, int block_w, int block_h,\n                 int width, int height, int linesize,\n                 vp8_mc_func mc_func[3][3])\n{\n    uint8_t *src = ref->data[0];\n\n    if (AV_RN32A(mv)) {\n\n        int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx];\n        int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my];\n\n        x_off += mv->x >> 2;\n        y_off += mv->y >> 2;\n\n        // edge emulation\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0);\n        src += y_off * linesize + x_off;\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n                                    block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n                                    x_off - mx_idx, y_off - my_idx, width, height);\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n        }\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n    } else {\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0);\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n    }\n}", "patch_func_code": "static av_always_inline\nvoid vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,\n                 AVFrame *ref, const VP56mv *mv,\n                 int x_off, int y_off, int block_w, int block_h,\n                 int width, int height, int linesize,\n                 vp8_mc_func mc_func[3][3])\n{\n    uint8_t *src = ref->data[0];\n\n    if (AV_RN32A(mv)) {\n\n        int mx = (mv->x << 1)&7, mx_idx = subpel_idx[0][mx];\n        int my = (mv->y << 1)&7, my_idx = subpel_idx[0][my];\n\n        x_off += mv->x >> 2;\n        y_off += mv->y >> 2;\n\n        // edge emulation\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 4, 0);\n        src += y_off * linesize + x_off;\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n            s->dsp.emulated_edge_mc(td->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n                                    block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n                                    x_off - mx_idx, y_off - my_idx, width, height);\n            src = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n        }\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n    } else {\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 4, 0);\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n    }\n}", "before_change_lines": [2, 22, 25], "raw_before_change_lines": [2, 22, 25], "after_change_lines": [2, 3, 23, 26], "raw_after_change_lines": [2, 3, 23, 26], "bug_lines": [2, 22, 25], "added": [false, false, false], "idx": 239}
{"project": "libav", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "5700----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2b658d9bdc55ecf08ba4d84b8f02b1f5b663b0b2_1.json----gen_fcpublish_stream", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_2b658d9bdc55ecf08ba4d84b8f02b1f5b663b0b2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2b658d9bdc55ecf08ba4d84b8f02b1f5b663b0b2_1.json", "function_name": "gen_fcpublish_stream", "vul_func_code": "static void gen_fcpublish_stream(URLContext *s, RTMPContext *rt)\n{\n    RTMPPacket pkt;\n    uint8_t *p;\n\n    ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE, 0,\n                          25 + strlen(rt->playpath));\n\n    av_log(s, AV_LOG_DEBUG, \"FCPublish stream...\\n\");\n    p = pkt.data;\n    ff_amf_write_string(&p, \"FCPublish\");\n    ff_amf_write_number(&p, ++rt->nb_invokes);\n    ff_amf_write_null(&p);\n    ff_amf_write_string(&p, rt->playpath);\n\n    ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]);\n    ff_rtmp_packet_destroy(&pkt);\n}", "patch_func_code": "static int gen_fcpublish_stream(URLContext *s, RTMPContext *rt)\n{\n    RTMPPacket pkt;\n    uint8_t *p;\n    int ret;\n\n    if ((ret = ff_rtmp_packet_create(&pkt, RTMP_SYSTEM_CHANNEL, RTMP_PT_INVOKE,\n                                     0, 25 + strlen(rt->playpath))) < 0)\n        return ret;\n\n    av_log(s, AV_LOG_DEBUG, \"FCPublish stream...\\n\");\n    p = pkt.data;\n    ff_amf_write_string(&p, \"FCPublish\");\n    ff_amf_write_number(&p, ++rt->nb_invokes);\n    ff_amf_write_null(&p);\n    ff_amf_write_string(&p, rt->playpath);\n\n    ff_rtmp_packet_write(rt->stream, &pkt, rt->chunk_size, rt->prev_pkt[1]);\n    ff_rtmp_packet_destroy(&pkt);\n\n    return 0;\n}", "before_change_lines": [1, 6, 7], "raw_before_change_lines": [1, 6, 7], "after_change_lines": [1, 5, 7, 8, 9, 21], "raw_after_change_lines": [1, 5, 7, 8, 9, 20, 21], "bug_lines": [1, 6, 7], "added": [false, false, false], "idx": 240}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "5716----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2c97ee8af248a7efd522edfa7c8bc9b8ba80cb0f_1.json----decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_2c97ee8af248a7efd522edfa7c8bc9b8ba80cb0f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_2c97ee8af248a7efd522edfa7c8bc9b8ba80cb0f_1.json", "function_name": "decode_frame", "vul_func_code": "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    AVFrame *frame = data;\n    const uint8_t *buf = avpkt->data;\n    const uint8_t *buf_end = buf + avpkt->size;\n    KgvContext * const c = avctx->priv_data;\n    int offsets[8];\n    uint16_t *out, *prev;\n    int outcnt = 0, maxcnt;\n    int w, h, i, res;\n\n    if (avpkt->size < 2)\n        return AVERROR_INVALIDDATA;\n\n    w = (buf[0] + 1) * 8;\n    h = (buf[1] + 1) * 8;\n    buf += 2;\n\n    if (w != avctx->width || h != avctx->height) {\n        av_frame_unref(c->prev);\n        if ((res = ff_set_dimensions(avctx, w, h)) < 0)\n            return res;\n    }\n\n    maxcnt = w * h;\n\n    if ((res = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n        return res;\n    out  = (uint16_t *) frame->data[0];\n    if (c->prev->data[0]) {\n        prev = (uint16_t *) c->prev->data[0];\n    } else {\n        prev = NULL;\n    }\n\n    for (i = 0; i < 8; i++)\n        offsets[i] = -1;\n\n    while (outcnt < maxcnt && buf_end - 2 > buf) {\n        int code = AV_RL16(buf);\n        buf += 2;\n\n        if (!(code & 0x8000)) {\n            out[outcnt++] = code; // rgb555 pixel coded directly\n        } else {\n            int count;\n            int inp_off;\n            uint16_t *inp;\n\n            if ((code & 0x6000) == 0x6000) {\n                // copy from previous frame\n                int oidx = (code >> 10) & 7;\n                int start;\n\n                count = (code & 0x3FF) + 3;\n\n                if (offsets[oidx] < 0) {\n                    if (buf_end - 3 < buf)\n                        break;\n                    offsets[oidx] = AV_RL24(buf);\n                    buf += 3;\n                }\n\n                start = (outcnt + offsets[oidx]) % maxcnt;\n\n                if (maxcnt - start < count)\n                    break;\n\n                if (!prev) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Frame reference does not exist\\n\");\n                    break;\n                }\n\n                inp = prev;\n                inp_off = start;\n            } else {\n                // copy from earlier in this frame\n                int offset = (code & 0x1FFF) + 1;\n\n                if (!(code & 0x6000)) {\n                    count = 2;\n                } else if ((code & 0x6000) == 0x2000) {\n                    count = 3;\n                } else {\n                    if (buf_end - 1 < buf)\n                        break;\n                    count = 4 + *buf++;\n                }\n\n                if (outcnt < offset)\n                    break;\n\n                inp = out;\n                inp_off = outcnt - offset;\n            }\n\n            if (maxcnt - outcnt < count)\n                break;\n\n            for (i = inp_off; i < count + inp_off; i++) {\n                out[outcnt++] = inp[i];\n            }\n        }\n    }\n\n    if (outcnt - maxcnt)\n        av_log(avctx, AV_LOG_DEBUG, \"frame finished with %d diff\\n\", outcnt - maxcnt);\n\n    av_frame_unref(c->prev);\n    if ((res = av_frame_ref(c->prev, frame)) < 0)\n        return res;\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}", "patch_func_code": "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    AVFrame *frame = data;\n    const uint8_t *buf = avpkt->data;\n    const uint8_t *buf_end = buf + avpkt->size;\n    KgvContext * const c = avctx->priv_data;\n    int offsets[8];\n    uint16_t *out, *prev;\n    int outcnt = 0, maxcnt;\n    int w, h, i, res;\n\n    if (avpkt->size < 2)\n        return AVERROR_INVALIDDATA;\n\n    w = (buf[0] + 1) * 8;\n    h = (buf[1] + 1) * 8;\n    buf += 2;\n\n    if (w != avctx->width || h != avctx->height) {\n        av_freep(&c->frame_buffer);\n        av_freep(&c->last_frame_buffer);\n        if ((res = ff_set_dimensions(avctx, w, h)) < 0)\n            return res;\n    }\n\n    if (!c->frame_buffer) {\n        c->frame_buffer      = av_mallocz(avctx->width * avctx->height * 2);\n        c->last_frame_buffer = av_mallocz(avctx->width * avctx->height * 2);\n        if (!c->frame_buffer || !c->last_frame_buffer) {\n            decode_flush(avctx);\n            return AVERROR(ENOMEM);\n        }\n    }\n\n    maxcnt = w * h;\n\n    if ((res = ff_get_buffer(avctx, frame, 0)) < 0)\n        return res;\n    out  = c->frame_buffer;\n    prev = c->last_frame_buffer;\n\n    for (i = 0; i < 8; i++)\n        offsets[i] = -1;\n\n    while (outcnt < maxcnt && buf_end - 2 > buf) {\n        int code = AV_RL16(buf);\n        buf += 2;\n\n        if (!(code & 0x8000)) {\n            out[outcnt++] = code; // rgb555 pixel coded directly\n        } else {\n            int count;\n            int inp_off;\n            uint16_t *inp;\n\n            if ((code & 0x6000) == 0x6000) {\n                // copy from previous frame\n                int oidx = (code >> 10) & 7;\n                int start;\n\n                count = (code & 0x3FF) + 3;\n\n                if (offsets[oidx] < 0) {\n                    if (buf_end - 3 < buf)\n                        break;\n                    offsets[oidx] = AV_RL24(buf);\n                    buf += 3;\n                }\n\n                start = (outcnt + offsets[oidx]) % maxcnt;\n\n                if (maxcnt - start < count)\n                    break;\n\n                if (!prev) {\n                    av_log(avctx, AV_LOG_ERROR,\n                           \"Frame reference does not exist\\n\");\n                    break;\n                }\n\n                inp = prev;\n                inp_off = start;\n            } else {\n                // copy from earlier in this frame\n                int offset = (code & 0x1FFF) + 1;\n\n                if (!(code & 0x6000)) {\n                    count = 2;\n                } else if ((code & 0x6000) == 0x2000) {\n                    count = 3;\n                } else {\n                    if (buf_end - 1 < buf)\n                        break;\n                    count = 4 + *buf++;\n                }\n\n                if (outcnt < offset)\n                    break;\n\n                inp = out;\n                inp_off = outcnt - offset;\n            }\n\n            if (maxcnt - outcnt < count)\n                break;\n\n            for (i = inp_off; i < count + inp_off; i++) {\n                out[outcnt++] = inp[i];\n            }\n        }\n    }\n\n    if (outcnt - maxcnt)\n        av_log(avctx, AV_LOG_DEBUG, \"frame finished with %d diff\\n\", outcnt - maxcnt);\n\n    av_image_copy_plane(frame->data[0], frame->linesize[0],\n                        (const uint8_t*)c->frame_buffer,  avctx->width * 2,\n                        avctx->width * 2, avctx->height);\n    FFSWAP(uint16_t *, c->frame_buffer, c->last_frame_buffer);\n\n    *got_frame = 1;\n\n    return avpkt->size;\n}", "before_change_lines": [21, 28, 30, 31, 32, 33, 34, 35, 111, 112, 113], "raw_before_change_lines": [21, 28, 30, 31, 32, 33, 34, 35, 111, 112, 113], "after_change_lines": [21, 22, 27, 28, 29, 30, 31, 32, 33, 34, 38, 40, 41, 117, 118, 119, 120], "raw_after_change_lines": [21, 22, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 40, 41, 117, 118, 119, 120], "bug_lines": [21, 28, 30, 31, 32, 33, 34, 35, 111, 112, 113], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 241}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5796----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_30c75cc2ced6ae9753c3bd8522f68123b1439a3d_1.json----twin_decode_init", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_30c75cc2ced6ae9753c3bd8522f68123b1439a3d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_30c75cc2ced6ae9753c3bd8522f68123b1439a3d_1.json", "function_name": "twin_decode_init", "vul_func_code": "static av_cold int twin_decode_init(AVCodecContext *avctx)\n{\n    int ret;\n    TwinContext *tctx = avctx->priv_data;\n    int isampf, ibps;\n\n    tctx->avctx       = avctx;\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n    if (!avctx->extradata || avctx->extradata_size < 12) {\n        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avctx->channels = AV_RB32(avctx->extradata    ) + 1;\n    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;\n    isampf          = AV_RB32(avctx->extradata + 8);\n    switch (isampf) {\n    case 44: avctx->sample_rate = 44100;         break;\n    case 22: avctx->sample_rate = 22050;         break;\n    case 11: avctx->sample_rate = 11025;         break;\n    default: avctx->sample_rate = isampf * 1000; break;\n    }\n\n    if (avctx->channels > CHANNELS_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",\n               avctx->channels);\n        return -1;\n    }\n    ibps = avctx->bit_rate / (1000 * avctx->channels);\n\n    switch ((isampf << 8) +  ibps) {\n    case (8 <<8) +  8: tctx->mtab = &mode_08_08; break;\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n        return -1;\n    }\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n    if ((ret = init_mdct_win(tctx))) {\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n        twin_decode_close(avctx);\n        return ret;\n    }\n    init_bitstream_params(tctx);\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n    avcodec_get_frame_defaults(&tctx->frame);\n    avctx->coded_frame = &tctx->frame;\n\n    return 0;\n}", "patch_func_code": "static av_cold int twin_decode_init(AVCodecContext *avctx)\n{\n    int ret;\n    TwinContext *tctx = avctx->priv_data;\n    int isampf, ibps;\n\n    tctx->avctx       = avctx;\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n    if (!avctx->extradata || avctx->extradata_size < 12) {\n        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avctx->channels = AV_RB32(avctx->extradata    ) + 1;\n    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;\n    isampf          = AV_RB32(avctx->extradata + 8);\n    switch (isampf) {\n    case 44: avctx->sample_rate = 44100;         break;\n    case 22: avctx->sample_rate = 22050;         break;\n    case 11: avctx->sample_rate = 11025;         break;\n    default: avctx->sample_rate = isampf * 1000; break;\n    }\n\n    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",\n               avctx->channels);\n        return -1;\n    }\n    ibps = avctx->bit_rate / (1000 * avctx->channels);\n\n    switch ((isampf << 8) +  ibps) {\n    case (8 <<8) +  8: tctx->mtab = &mode_08_08; break;\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n        return -1;\n    }\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n    if ((ret = init_mdct_win(tctx))) {\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n        twin_decode_close(avctx);\n        return ret;\n    }\n    init_bitstream_params(tctx);\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n    avcodec_get_frame_defaults(&tctx->frame);\n    avctx->coded_frame = &tctx->frame;\n\n    return 0;\n}", "before_change_lines": [24], "raw_before_change_lines": [24], "after_change_lines": [24], "raw_after_change_lines": [24], "bug_lines": [24], "added": [false], "idx": 242}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5846----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_331fff10f3cc255d28117d2f0d513af06855ac63_1.json----film_read_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_331fff10f3cc255d28117d2f0d513af06855ac63_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_331fff10f3cc255d28117d2f0d513af06855ac63_1.json", "function_name": "film_read_packet", "vul_func_code": "static int film_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    FilmDemuxContext *film = s->priv_data;\n    AVIOContext *pb = s->pb;\n    film_sample *sample;\n    int ret = 0;\n\n    if (film->current_sample >= film->sample_count)\n        return AVERROR(EIO);\n\n    sample = &film->sample_table[film->current_sample];\n\n    /* position the stream (will probably be there anyway) */\n    avio_seek(pb, sample->sample_offset, SEEK_SET);\n\n    /* do a special song and dance when loading FILM Cinepak chunks */\n    if ((sample->stream == film->video_stream_index) &&\n        (film->video_type == AV_CODEC_ID_CINEPAK)) {\n        pkt->pos= avio_tell(pb);\n        if (av_new_packet(pkt, sample->sample_size))\n            return AVERROR(ENOMEM);\n        avio_read(pb, pkt->data, sample->sample_size);\n    } else {\n        ret= av_get_packet(pb, pkt, sample->sample_size);\n        if (ret != sample->sample_size)\n            ret = AVERROR(EIO);\n    }\n\n    pkt->stream_index = sample->stream;\n    pkt->pts = sample->pts;\n\n    film->current_sample++;\n\n    return ret;\n}", "patch_func_code": "static int film_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    FilmDemuxContext *film = s->priv_data;\n    AVIOContext *pb = s->pb;\n    film_sample *sample;\n    int ret = 0;\n\n    if (film->current_sample >= film->sample_count)\n        return AVERROR(EIO);\n\n    sample = &film->sample_table[film->current_sample];\n\n    /* position the stream (will probably be there anyway) */\n    avio_seek(pb, sample->sample_offset, SEEK_SET);\n\n    ret = av_get_packet(pb, pkt, sample->sample_size);\n    if (ret < 0)\n        return ret;\n\n    pkt->stream_index = sample->stream;\n    pkt->pts = sample->pts;\n\n    film->current_sample++;\n\n    return ret;\n}", "before_change_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], "raw_before_change_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], "after_change_lines": [17, 18, 19], "raw_after_change_lines": [17, 18, 19], "bug_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 243}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L1", "filepath_func": "5897----INTEGER_OVERFLOW_L1----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3644247598a032833b6daee2c2f78f5ba73d7d0d_1.json----ff_mov_close_hinting", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_3644247598a032833b6daee2c2f78f5ba73d7d0d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3644247598a032833b6daee2c2f78f5ba73d7d0d_1.json", "function_name": "ff_mov_close_hinting", "vul_func_code": "void ff_mov_close_hinting(MOVTrack *track)\n{\n    AVFormatContext *rtp_ctx = track->rtp_ctx;\n\n    av_freep(&track->enc);\n    sample_queue_free(&track->sample_queue);\n    if (!rtp_ctx)\n        return;\n    if (rtp_ctx->pb) {\n        av_write_trailer(rtp_ctx);\n        ffio_free_dyn_buf(&rtp_ctx->pb);\n    }\n    avformat_free_context(rtp_ctx);\n}", "patch_func_code": "void ff_mov_close_hinting(MOVTrack *track)\n{\n    AVFormatContext *rtp_ctx = track->rtp_ctx;\n\n    avcodec_parameters_free(&track->par);\n    sample_queue_free(&track->sample_queue);\n    if (!rtp_ctx)\n        return;\n    if (rtp_ctx->pb) {\n        av_write_trailer(rtp_ctx);\n        ffio_free_dyn_buf(&rtp_ctx->pb);\n    }\n    avformat_free_context(rtp_ctx);\n}", "before_change_lines": [5], "raw_before_change_lines": [5], "after_change_lines": [5], "raw_after_change_lines": [5], "bug_lines": [5], "added": [false], "idx": 244}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5898----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3659127dd05895ee8870adefc5c4f47c40fd7d8e_1.json----ff_vc1_decode_blocks", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_3659127dd05895ee8870adefc5c4f47c40fd7d8e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3659127dd05895ee8870adefc5c4f47c40fd7d8e_1.json", "function_name": "ff_vc1_decode_blocks", "vul_func_code": "void ff_vc1_decode_blocks(VC1Context *v)\n{\n\n    v->s.esc3_level_length = 0;\n    if (v->x8_type) {\n        ff_intrax8_decode_picture(&v->x8, &v->s.current_picture, &v->s.gb,\n                                  2 * v->pq + v->halfpq, v->pq * !v->pquantizer,\n                                  v->s.loop_filter);\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n                        ER_MB_END);\n    } else {\n        v->cur_blk_idx     =  0;\n        v->left_blk_idx    = -1;\n        v->topleft_blk_idx =  1;\n        v->top_blk_idx     =  2;\n        switch (v->s.pict_type) {\n        case AV_PICTURE_TYPE_I:\n            if (v->profile == PROFILE_ADVANCED)\n                vc1_decode_i_blocks_adv(v);\n            else\n                vc1_decode_i_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_P:\n            if (v->p_frame_skipped)\n                vc1_decode_skip_blocks(v);\n            else\n                vc1_decode_p_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_B:\n            if (v->bi_type) {\n                if (v->profile == PROFILE_ADVANCED)\n                    vc1_decode_i_blocks_adv(v);\n                else\n                    vc1_decode_i_blocks(v);\n            } else\n                vc1_decode_b_blocks(v);\n            break;\n        }\n    }\n}", "patch_func_code": "void ff_vc1_decode_blocks(VC1Context *v)\n{\n\n    v->s.esc3_level_length = 0;\n    if (v->x8_type) {\n        ff_intrax8_decode_picture(&v->x8, &v->s.current_picture,\n                                  &v->s.gb, &v->s.mb_x, &v->s.mb_y,\n                                  2 * v->pq + v->halfpq, v->pq * !v->pquantizer,\n                                  v->s.loop_filter);\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n                        ER_MB_END);\n    } else {\n        v->cur_blk_idx     =  0;\n        v->left_blk_idx    = -1;\n        v->topleft_blk_idx =  1;\n        v->top_blk_idx     =  2;\n        switch (v->s.pict_type) {\n        case AV_PICTURE_TYPE_I:\n            if (v->profile == PROFILE_ADVANCED)\n                vc1_decode_i_blocks_adv(v);\n            else\n                vc1_decode_i_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_P:\n            if (v->p_frame_skipped)\n                vc1_decode_skip_blocks(v);\n            else\n                vc1_decode_p_blocks(v);\n            break;\n        case AV_PICTURE_TYPE_B:\n            if (v->bi_type) {\n                if (v->profile == PROFILE_ADVANCED)\n                    vc1_decode_i_blocks_adv(v);\n                else\n                    vc1_decode_i_blocks(v);\n            } else\n                vc1_decode_b_blocks(v);\n            break;\n        }\n    }\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6, 7], "raw_after_change_lines": [6, 7], "bug_lines": [6], "added": [false], "idx": 245}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5901----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_367e944e9dc15b0891a9f580acab147d13719f82_1.json----vc1_decode_blocks", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_367e944e9dc15b0891a9f580acab147d13719f82_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_367e944e9dc15b0891a9f580acab147d13719f82_1.json", "function_name": "vc1_decode_blocks", "vul_func_code": "static void vc1_decode_blocks(VC1Context *v)\n{\n\n    v->s.esc3_level_length = 0;\n    if(v->x8_type){\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq+v->halfpq, v->pq*(!v->pquantizer) );\n    }else{\n\n        switch(v->s.pict_type) {\n        case FF_I_TYPE:\n            if(v->profile == PROFILE_ADVANCED)\n                vc1_decode_i_blocks_adv(v);\n            else\n                vc1_decode_i_blocks(v);\n            break;\n        case FF_P_TYPE:\n            if(v->p_frame_skipped)\n                vc1_decode_skip_blocks(v);\n            else\n                vc1_decode_p_blocks(v);\n            break;\n        case FF_B_TYPE:\n            if(v->bi_type){\n                if(v->profile == PROFILE_ADVANCED)\n                    vc1_decode_i_blocks_adv(v);\n                else\n                    vc1_decode_i_blocks(v);\n            }else\n                vc1_decode_b_blocks(v);\n            break;\n        }\n    }\n}", "patch_func_code": "static void vc1_decode_blocks(VC1Context *v, int mby_start, int mby_end)\n{\n\n    v->s.esc3_level_length = 0;\n    if(v->x8_type){\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq+v->halfpq, v->pq*(!v->pquantizer) );\n    }else{\n        switch(v->s.pict_type) {\n        case FF_I_TYPE:\n            if(v->profile == PROFILE_ADVANCED)\n                vc1_decode_i_blocks_adv(v, mby_start, mby_end);\n            else\n                vc1_decode_i_blocks(v);\n            break;\n        case FF_P_TYPE:\n            if(v->p_frame_skipped)\n                vc1_decode_skip_blocks(v);\n            else\n                vc1_decode_p_blocks(v, mby_start, mby_end);\n            break;\n        case FF_B_TYPE:\n            if(v->bi_type){\n                if(v->profile == PROFILE_ADVANCED)\n                    vc1_decode_i_blocks_adv(v, mby_start, mby_end);\n                else\n                    vc1_decode_i_blocks(v);\n            }else\n                vc1_decode_b_blocks(v, mby_start, mby_end);\n            break;\n        }\n    }\n}", "before_change_lines": [1, 12, 20, 25, 29], "raw_before_change_lines": [1, 8, 12, 20, 25, 29], "after_change_lines": [1, 11, 19, 24, 28], "raw_after_change_lines": [1, 11, 19, 24, 28], "bug_lines": [1, 8, 12, 20, 25, 29], "added": [false, false, false, false, false, false], "idx": 246}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5939----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_391fa935185daac5a15109b1ce2c5f308a837ca7_1.json----smka_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_391fa935185daac5a15109b1ce2c5f308a837ca7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_391fa935185daac5a15109b1ce2c5f308a837ca7_1.json", "function_name": "smka_decode_frame", "vul_func_code": "static int smka_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    GetBitContext gb;\n    HuffContext h[4] = { { 0 } };\n    VLC vlc[4]       = { { 0 } };\n    int16_t *samples;\n    uint8_t *samples8;\n    int val;\n    int i, res, ret;\n    int unp_size;\n    int bits, stereo;\n    int pred[2] = {0, 0};\n\n    if (buf_size <= 4) {\n        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    unp_size = AV_RL32(buf);\n\n    init_get_bits(&gb, buf + 4, (buf_size - 4) * 8);\n\n    if(!get_bits1(&gb)){\n        av_log(avctx, AV_LOG_INFO, \"Sound: no data\\n\");\n        *got_frame_ptr = 0;\n        return 1;\n    }\n    stereo = get_bits1(&gb);\n    bits = get_bits1(&gb);\n    if (stereo ^ (avctx->channels != 1)) {\n        av_log(avctx, AV_LOG_ERROR, \"channels mismatch\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (bits && avctx->sample_fmt == AV_SAMPLE_FMT_U8) {\n        av_log(avctx, AV_LOG_ERROR, \"sample format mismatch\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* get output buffer */\n    frame->nb_samples = unp_size / (avctx->channels * (bits + 1));\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples  = (int16_t *)frame->data[0];\n    samples8 =            frame->data[0];\n\n    // Initialize\n    for(i = 0; i < (1 << (bits + stereo)); i++) {\n        h[i].length = 256;\n        h[i].maxlength = 0;\n        h[i].current = 0;\n        h[i].bits = av_mallocz(256 * 4);\n        h[i].lengths = av_mallocz(256 * sizeof(int));\n        h[i].values = av_mallocz(256 * sizeof(int));\n        skip_bits1(&gb);\n        if (smacker_decode_tree(&gb, &h[i], 0, 0) < 0) {\n            for (; i >= 0; i--) {\n                if (vlc[i].table)\n                    ff_free_vlc(&vlc[i]);\n                av_free(h[i].bits);\n                av_free(h[i].lengths);\n                av_free(h[i].values);\n            }\n            return AVERROR_INVALIDDATA;\n        }\n        skip_bits1(&gb);\n        if(h[i].current > 1) {\n            res = init_vlc(&vlc[i], SMKTREE_BITS, h[i].length,\n                    h[i].lengths, sizeof(int), sizeof(int),\n                    h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n            if(res < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n                return -1;\n            }\n        }\n    }\n    /* this codec relies on wraparound instead of clipping audio */\n    if(bits) { //decode 16-bit data\n        for(i = stereo; i >= 0; i--)\n            pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16);\n        for(i = 0; i <= stereo; i++)\n            *samples++ = pred[i];\n        for(; i < unp_size / 2; i++) {\n            if(i & stereo) {\n                if(vlc[2].table)\n                    res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val  = h[2].values[res];\n                if(vlc[3].table)\n                    res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val |= h[3].values[res] << 8;\n                pred[1] += sign_extend(val, 16);\n                *samples++ = pred[1];\n            } else {\n                if(vlc[0].table)\n                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val  = h[0].values[res];\n                if(vlc[1].table)\n                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val |= h[1].values[res] << 8;\n                pred[0] += sign_extend(val, 16);\n                *samples++ = pred[0];\n            }\n        }\n    } else { //8-bit data\n        for(i = stereo; i >= 0; i--)\n            pred[i] = get_bits(&gb, 8);\n        for(i = 0; i <= stereo; i++)\n            *samples8++ = pred[i];\n        for(; i < unp_size; i++) {\n            if(i & stereo){\n                if(vlc[1].table)\n                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                pred[1] += sign_extend(h[1].values[res], 8);\n                *samples8++ = pred[1];\n            } else {\n                if(vlc[0].table)\n                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                pred[0] += sign_extend(h[0].values[res], 8);\n                *samples8++ = pred[0];\n            }\n        }\n    }\n\n    for(i = 0; i < 4; i++) {\n        if(vlc[i].table)\n            ff_free_vlc(&vlc[i]);\n        av_free(h[i].bits);\n        av_free(h[i].lengths);\n        av_free(h[i].values);\n    }\n\n    *got_frame_ptr = 1;\n\n    return buf_size;\n}", "patch_func_code": "static int smka_decode_frame(AVCodecContext *avctx, void *data,\n                             int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    GetBitContext gb;\n    HuffContext h[4] = { { 0 } };\n    VLC vlc[4]       = { { 0 } };\n    int16_t *samples;\n    uint8_t *samples8;\n    int val;\n    int i, res, ret;\n    int unp_size;\n    int bits, stereo;\n    int pred[2] = {0, 0};\n\n    if (buf_size <= 4) {\n        av_log(avctx, AV_LOG_ERROR, \"packet is too small\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    unp_size = AV_RL32(buf);\n\n    init_get_bits(&gb, buf + 4, (buf_size - 4) * 8);\n\n    if(!get_bits1(&gb)){\n        av_log(avctx, AV_LOG_INFO, \"Sound: no data\\n\");\n        *got_frame_ptr = 0;\n        return 1;\n    }\n    stereo = get_bits1(&gb);\n    bits = get_bits1(&gb);\n    if (stereo ^ (avctx->channels != 1)) {\n        av_log(avctx, AV_LOG_ERROR, \"channels mismatch\\n\");\n        return AVERROR(EINVAL);\n    }\n    if (bits && avctx->sample_fmt == AV_SAMPLE_FMT_U8) {\n        av_log(avctx, AV_LOG_ERROR, \"sample format mismatch\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    /* get output buffer */\n    frame->nb_samples = unp_size / (avctx->channels * (bits + 1));\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples  = (int16_t *)frame->data[0];\n    samples8 =            frame->data[0];\n\n    // Initialize\n    for(i = 0; i < (1 << (bits + stereo)); i++) {\n        h[i].length = 256;\n        h[i].maxlength = 0;\n        h[i].current = 0;\n        h[i].bits = av_mallocz(256 * 4);\n        h[i].lengths = av_mallocz(256 * sizeof(int));\n        h[i].values = av_mallocz(256 * sizeof(int));\n        if (!h[i].bits || !h[i].lengths || !h[i].values) {\n            ret = AVERROR(ENOMEM);\n            goto error;\n        }\n        skip_bits1(&gb);\n        if (smacker_decode_tree(&gb, &h[i], 0, 0) < 0) {\n            ret = AVERROR_INVALIDDATA;\n            goto error;\n        }\n        skip_bits1(&gb);\n        if(h[i].current > 1) {\n            res = init_vlc(&vlc[i], SMKTREE_BITS, h[i].length,\n                    h[i].lengths, sizeof(int), sizeof(int),\n                    h[i].bits, sizeof(uint32_t), sizeof(uint32_t), INIT_VLC_LE);\n            if(res < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"Cannot build VLC table\\n\");\n                ret = AVERROR_INVALIDDATA;\n                goto error;\n            }\n        }\n    }\n    /* this codec relies on wraparound instead of clipping audio */\n    if(bits) { //decode 16-bit data\n        for(i = stereo; i >= 0; i--)\n            pred[i] = sign_extend(av_bswap16(get_bits(&gb, 16)), 16);\n        for(i = 0; i <= stereo; i++)\n            *samples++ = pred[i];\n        for(; i < unp_size / 2; i++) {\n            if(i & stereo) {\n                if(vlc[2].table)\n                    res = get_vlc2(&gb, vlc[2].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val  = h[2].values[res];\n                if(vlc[3].table)\n                    res = get_vlc2(&gb, vlc[3].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val |= h[3].values[res] << 8;\n                pred[1] += sign_extend(val, 16);\n                *samples++ = pred[1];\n            } else {\n                if(vlc[0].table)\n                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val  = h[0].values[res];\n                if(vlc[1].table)\n                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                val |= h[1].values[res] << 8;\n                pred[0] += sign_extend(val, 16);\n                *samples++ = pred[0];\n            }\n        }\n    } else { //8-bit data\n        for(i = stereo; i >= 0; i--)\n            pred[i] = get_bits(&gb, 8);\n        for(i = 0; i <= stereo; i++)\n            *samples8++ = pred[i];\n        for(; i < unp_size; i++) {\n            if(i & stereo){\n                if(vlc[1].table)\n                    res = get_vlc2(&gb, vlc[1].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                pred[1] += sign_extend(h[1].values[res], 8);\n                *samples8++ = pred[1];\n            } else {\n                if(vlc[0].table)\n                    res = get_vlc2(&gb, vlc[0].table, SMKTREE_BITS, 3);\n                else\n                    res = 0;\n                pred[0] += sign_extend(h[0].values[res], 8);\n                *samples8++ = pred[0];\n            }\n        }\n    }\n\n    *got_frame_ptr = 1;\n    ret = buf_size;\n\nerror:\n    for(i = 0; i < 4; i++) {\n        if(vlc[i].table)\n            ff_free_vlc(&vlc[i]);\n        av_free(h[i].bits);\n        av_free(h[i].lengths);\n        av_free(h[i].values);\n    }\n\n    return ret;\n}", "before_change_lines": [62, 63, 64, 65, 66, 67, 68, 69, 78, 149, 151], "raw_before_change_lines": [62, 63, 64, 65, 66, 67, 68, 69, 78, 149, 150, 151], "after_change_lines": [60, 61, 62, 63, 66, 67, 76, 77, 140, 141, 143, 152], "raw_after_change_lines": [60, 61, 62, 63, 66, 67, 76, 77, 140, 141, 142, 143, 152], "bug_lines": [62, 63, 64, 65, 66, 67, 68, 69, 78, 149, 150, 151], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 247}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "5960----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3b8a2c0f6ec12337ac0af726a7493247187134ad_1.json----ff_rtp_check_and_send_back_rr", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_3b8a2c0f6ec12337ac0af726a7493247187134ad_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3b8a2c0f6ec12337ac0af726a7493247187134ad_1.json", "function_name": "ff_rtp_check_and_send_back_rr", "vul_func_code": "int ff_rtp_check_and_send_back_rr(RTPDemuxContext *s, URLContext *fd,\n                                  AVIOContext *avio, int count)\n{\n    AVIOContext *pb;\n    uint8_t *buf;\n    int len;\n    int rtcp_bytes;\n    RTPStatistics *stats = &s->statistics;\n    uint32_t lost;\n    uint32_t extended_max;\n    uint32_t expected_interval;\n    uint32_t received_interval;\n    uint32_t lost_interval;\n    uint32_t expected;\n    uint32_t fraction;\n    uint64_t ntp_time = s->last_rtcp_ntp_time; // TODO: Get local ntp time?\n\n    if ((!fd && !avio) || (count < 1))\n        return -1;\n\n    /* TODO: I think this is way too often; RFC 1889 has algorithm for this */\n    /* XXX: MPEG pts hardcoded. RTCP send every 0.5 seconds */\n    s->octet_count += count;\n    rtcp_bytes = ((s->octet_count - s->last_octet_count) * RTCP_TX_RATIO_NUM) /\n        RTCP_TX_RATIO_DEN;\n    rtcp_bytes /= 50; // mmu_man: that's enough for me... VLC sends much less btw !?\n    if (rtcp_bytes < 28)\n        return -1;\n    s->last_octet_count = s->octet_count;\n\n    if (!fd)\n        pb = avio;\n    else if (avio_open_dyn_buf(&pb) < 0)\n        return -1;\n\n    // Receiver Report\n    avio_w8(pb, (RTP_VERSION << 6) + 1); /* 1 report block */\n    avio_w8(pb, RTCP_RR);\n    avio_wb16(pb, 7); /* length in words - 1 */\n    // our own SSRC: we use the server's SSRC + 1 to avoid conflicts\n    avio_wb32(pb, s->ssrc + 1);\n    avio_wb32(pb, s->ssrc); // server SSRC\n    // some placeholders we should really fill...\n    // RFC 1889/p64\n    extended_max          = stats->cycles + stats->max_seq;\n    expected              = extended_max - stats->base_seq;\n    lost                  = expected - stats->received;\n    lost                  = FFMIN(lost, 0xffffff); // clamp it since it's only 24 bits...\n    expected_interval     = expected - stats->expected_prior;\n    stats->expected_prior = expected;\n    received_interval     = stats->received - stats->received_prior;\n    stats->received_prior = stats->received;\n    lost_interval         = expected_interval - received_interval;\n    if (expected_interval == 0 || lost_interval <= 0)\n        fraction = 0;\n    else\n        fraction = (lost_interval << 8) / expected_interval;\n\n    fraction = (fraction << 24) | lost;\n\n    avio_wb32(pb, fraction); /* 8 bits of fraction, 24 bits of total packets lost */\n    avio_wb32(pb, extended_max); /* max sequence received */\n    avio_wb32(pb, stats->jitter >> 4); /* jitter */\n\n    if (s->last_rtcp_ntp_time == AV_NOPTS_VALUE) {\n        avio_wb32(pb, 0); /* last SR timestamp */\n        avio_wb32(pb, 0); /* delay since last SR */\n    } else {\n        uint32_t middle_32_bits   = s->last_rtcp_ntp_time >> 16; // this is valid, right? do we need to handle 64 bit values special?\n        uint32_t delay_since_last = ntp_time - s->last_rtcp_ntp_time;\n\n        avio_wb32(pb, middle_32_bits); /* last SR timestamp */\n        avio_wb32(pb, delay_since_last); /* delay since last SR */\n    }\n\n    // CNAME\n    avio_w8(pb, (RTP_VERSION << 6) + 1); /* 1 report block */\n    avio_w8(pb, RTCP_SDES);\n    len = strlen(s->hostname);\n    avio_wb16(pb, (7 + len + 3) / 4); /* length in words - 1 */\n    avio_wb32(pb, s->ssrc + 1);\n    avio_w8(pb, 0x01);\n    avio_w8(pb, len);\n    avio_write(pb, s->hostname, len);\n    avio_w8(pb, 0); /* END */\n    // padding\n    for (len = (7 + len) % 4; len % 4; len++)\n        avio_w8(pb, 0);\n\n    avio_flush(pb);\n    if (!fd)\n        return 0;\n    len = avio_close_dyn_buf(pb, &buf);\n    if ((len > 0) && buf) {\n        int av_unused result;\n        av_dlog(s->ic, \"sending %d bytes of RR\\n\", len);\n        result = ffurl_write(fd, buf, len);\n        av_dlog(s->ic, \"result from ffurl_write: %d\\n\", result);\n        av_free(buf);\n    }\n    return 0;\n}", "patch_func_code": "int ff_rtp_check_and_send_back_rr(RTPDemuxContext *s, URLContext *fd,\n                                  AVIOContext *avio, int count)\n{\n    AVIOContext *pb;\n    uint8_t *buf;\n    int len;\n    int rtcp_bytes;\n    RTPStatistics *stats = &s->statistics;\n    uint32_t lost;\n    uint32_t extended_max;\n    uint32_t expected_interval;\n    uint32_t received_interval;\n    uint32_t lost_interval;\n    uint32_t expected;\n    uint32_t fraction;\n\n    if ((!fd && !avio) || (count < 1))\n        return -1;\n\n    /* TODO: I think this is way too often; RFC 1889 has algorithm for this */\n    /* XXX: MPEG pts hardcoded. RTCP send every 0.5 seconds */\n    s->octet_count += count;\n    rtcp_bytes = ((s->octet_count - s->last_octet_count) * RTCP_TX_RATIO_NUM) /\n        RTCP_TX_RATIO_DEN;\n    rtcp_bytes /= 50; // mmu_man: that's enough for me... VLC sends much less btw !?\n    if (rtcp_bytes < 28)\n        return -1;\n    s->last_octet_count = s->octet_count;\n\n    if (!fd)\n        pb = avio;\n    else if (avio_open_dyn_buf(&pb) < 0)\n        return -1;\n\n    // Receiver Report\n    avio_w8(pb, (RTP_VERSION << 6) + 1); /* 1 report block */\n    avio_w8(pb, RTCP_RR);\n    avio_wb16(pb, 7); /* length in words - 1 */\n    // our own SSRC: we use the server's SSRC + 1 to avoid conflicts\n    avio_wb32(pb, s->ssrc + 1);\n    avio_wb32(pb, s->ssrc); // server SSRC\n    // some placeholders we should really fill...\n    // RFC 1889/p64\n    extended_max          = stats->cycles + stats->max_seq;\n    expected              = extended_max - stats->base_seq;\n    lost                  = expected - stats->received;\n    lost                  = FFMIN(lost, 0xffffff); // clamp it since it's only 24 bits...\n    expected_interval     = expected - stats->expected_prior;\n    stats->expected_prior = expected;\n    received_interval     = stats->received - stats->received_prior;\n    stats->received_prior = stats->received;\n    lost_interval         = expected_interval - received_interval;\n    if (expected_interval == 0 || lost_interval <= 0)\n        fraction = 0;\n    else\n        fraction = (lost_interval << 8) / expected_interval;\n\n    fraction = (fraction << 24) | lost;\n\n    avio_wb32(pb, fraction); /* 8 bits of fraction, 24 bits of total packets lost */\n    avio_wb32(pb, extended_max); /* max sequence received */\n    avio_wb32(pb, stats->jitter >> 4); /* jitter */\n\n    if (s->last_rtcp_ntp_time == AV_NOPTS_VALUE) {\n        avio_wb32(pb, 0); /* last SR timestamp */\n        avio_wb32(pb, 0); /* delay since last SR */\n    } else {\n        uint32_t middle_32_bits   = s->last_rtcp_ntp_time >> 16; // this is valid, right? do we need to handle 64 bit values special?\n        uint32_t delay_since_last = av_rescale(av_gettime() - s->last_rtcp_reception_time,\n                                               65536, AV_TIME_BASE);\n\n        avio_wb32(pb, middle_32_bits); /* last SR timestamp */\n        avio_wb32(pb, delay_since_last); /* delay since last SR */\n    }\n\n    // CNAME\n    avio_w8(pb, (RTP_VERSION << 6) + 1); /* 1 report block */\n    avio_w8(pb, RTCP_SDES);\n    len = strlen(s->hostname);\n    avio_wb16(pb, (7 + len + 3) / 4); /* length in words - 1 */\n    avio_wb32(pb, s->ssrc + 1);\n    avio_w8(pb, 0x01);\n    avio_w8(pb, len);\n    avio_write(pb, s->hostname, len);\n    avio_w8(pb, 0); /* END */\n    // padding\n    for (len = (7 + len) % 4; len % 4; len++)\n        avio_w8(pb, 0);\n\n    avio_flush(pb);\n    if (!fd)\n        return 0;\n    len = avio_close_dyn_buf(pb, &buf);\n    if ((len > 0) && buf) {\n        int av_unused result;\n        av_dlog(s->ic, \"sending %d bytes of RR\\n\", len);\n        result = ffurl_write(fd, buf, len);\n        av_dlog(s->ic, \"result from ffurl_write: %d\\n\", result);\n        av_free(buf);\n    }\n    return 0;\n}", "before_change_lines": [16, 70], "raw_before_change_lines": [16, 70], "after_change_lines": [69, 70], "raw_after_change_lines": [69, 70], "bug_lines": [16, 70], "added": [false, false], "idx": 248}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "5982----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3d1d64a3e6dc24acb0f694925d064068fa3bbfca_1.json----mov_read_sv3d", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_3d1d64a3e6dc24acb0f694925d064068fa3bbfca_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_3d1d64a3e6dc24acb0f694925d064068fa3bbfca_1.json", "function_name": "mov_read_sv3d", "vul_func_code": "static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int size, version, layout;\n    int32_t yaw, pitch, roll;\n    size_t l = 0, t = 0, r = 0, b = 0;\n    size_t padding = 0;\n    uint32_t tag;\n    enum AVSphericalProjection projection;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 8) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty spherical video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = avio_rb32(pb);\n    if (size <= 12 || size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('s','v','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing spherical video header\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    avio_skip(pb, size - 12); /* metadata_source */\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','o','j')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection box\\n\");\n        return 0;\n    }\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection header box\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    /* 16.16 fixed point */\n    yaw   = avio_rb32(pb);\n    pitch = avio_rb32(pb);\n    roll  = avio_rb32(pb);\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    switch (tag) {\n    case MKTAG('c','b','m','p'):\n        layout = avio_rb32(pb);\n        if (layout) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Unsupported cubemap layout %d\\n\", layout);\n            return 0;\n        }\n        projection = AV_SPHERICAL_CUBEMAP;\n        padding = avio_rb32(pb);\n        break;\n    case MKTAG('e','q','u','i'):\n        t = avio_rb32(pb);\n        b = avio_rb32(pb);\n        l = avio_rb32(pb);\n        r = avio_rb32(pb);\n\n        if (b >= UINT_MAX - t || r >= UINT_MAX - l) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"Invalid bounding rectangle coordinates \"\n                   \"%zu,%zu,%zu,%zu\\n\", l, t, r, b);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (l || t || r || b)\n            projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE;\n        else\n            projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown projection type\\n\");\n        return 0;\n    }\n\n    sc->spherical = av_spherical_alloc(&sc->spherical_size);\n    if (!sc->spherical)\n        return AVERROR(ENOMEM);\n\n    sc->spherical->projection = projection;\n\n    sc->spherical->yaw   = yaw;\n    sc->spherical->pitch = pitch;\n    sc->spherical->roll  = roll;\n\n    sc->spherical->padding = padding;\n\n    sc->spherical->bound_left   = l;\n    sc->spherical->bound_top    = t;\n    sc->spherical->bound_right  = r;\n    sc->spherical->bound_bottom = b;\n\n    return 0;\n}", "patch_func_code": "static int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int size, version, layout;\n    int32_t yaw, pitch, roll;\n    uint32_t l = 0, t = 0, r = 0, b = 0;\n    uint32_t tag, padding = 0;\n    enum AVSphericalProjection projection;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 8) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty spherical video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = avio_rb32(pb);\n    if (size <= 12 || size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('s','v','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing spherical video header\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    avio_skip(pb, size - 12); /* metadata_source */\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','o','j')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection box\\n\");\n        return 0;\n    }\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection header box\\n\");\n        return 0;\n    }\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    /* 16.16 fixed point */\n    yaw   = avio_rb32(pb);\n    pitch = avio_rb32(pb);\n    roll  = avio_rb32(pb);\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    version = avio_r8(pb);\n    if (version != 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown spherical version %d\\n\",\n               version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n    switch (tag) {\n    case MKTAG('c','b','m','p'):\n        layout = avio_rb32(pb);\n        if (layout) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Unsupported cubemap layout %d\\n\", layout);\n            return 0;\n        }\n        projection = AV_SPHERICAL_CUBEMAP;\n        padding = avio_rb32(pb);\n        break;\n    case MKTAG('e','q','u','i'):\n        t = avio_rb32(pb);\n        b = avio_rb32(pb);\n        l = avio_rb32(pb);\n        r = avio_rb32(pb);\n\n        if (b >= UINT_MAX - t || r >= UINT_MAX - l) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"Invalid bounding rectangle coordinates \"\n                   \"%\"PRIu32\",%\"PRIu32\",%\"PRIu32\",%\"PRIu32\"\\n\", l, t, r, b);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (l || t || r || b)\n            projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE;\n        else\n            projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown projection type\\n\");\n        return 0;\n    }\n\n    sc->spherical = av_spherical_alloc(&sc->spherical_size);\n    if (!sc->spherical)\n        return AVERROR(ENOMEM);\n\n    sc->spherical->projection = projection;\n\n    sc->spherical->yaw   = yaw;\n    sc->spherical->pitch = pitch;\n    sc->spherical->roll  = roll;\n\n    sc->spherical->padding = padding;\n\n    sc->spherical->bound_left   = l;\n    sc->spherical->bound_top    = t;\n    sc->spherical->bound_right  = r;\n    sc->spherical->bound_bottom = b;\n\n    return 0;\n}", "before_change_lines": [7, 8, 9, 105], "raw_before_change_lines": [7, 8, 9, 105], "after_change_lines": [7, 8, 104], "raw_after_change_lines": [7, 8, 104], "bug_lines": [7, 8, 9, 105], "added": [false, false, false, false], "idx": 249}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6048----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4041de4d6003f73a707bcdbb498cbbce705d4a40_1.json----ff_snappy_uncompress", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4041de4d6003f73a707bcdbb498cbbce705d4a40_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4041de4d6003f73a707bcdbb498cbbce705d4a40_1.json", "function_name": "ff_snappy_uncompress", "vul_func_code": "int ff_snappy_uncompress(GetByteContext *gb, uint8_t **buf, int64_t *size)\n{\n    int64_t len = decode_len(gb);\n    int ret     = 0;\n    uint8_t *p;\n\n    if (len < 0)\n        return len;\n\n    if ((ret = av_reallocp(buf, len)) < 0)\n        return AVERROR(ENOMEM);\n\n    *size = len;\n    p     = *buf;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        uint8_t s = bytestream2_get_byte(gb);\n        int val   = s >> 2;\n\n        switch (s & 0x03) {\n        case SNAPPY_LITERAL:\n            ret = snappy_literal(gb, p, len, val);\n            break;\n        case SNAPPY_COPY_1:\n            ret = snappy_copy1(gb, *buf, p, len, val);\n            break;\n        case SNAPPY_COPY_2:\n            ret = snappy_copy2(gb, *buf, p, len, val);\n            break;\n        case SNAPPY_COPY_4:\n            ret = snappy_copy4(gb, *buf, p, len, val);\n            break;\n        }\n\n        if (ret < 0)\n            return ret;\n\n        p   += ret;\n        len -= ret;\n    }\n\n    return 0;\n}", "patch_func_code": "int ff_snappy_uncompress(GetByteContext *gb, uint8_t *buf, int64_t *size)\n{\n    int64_t len = decode_len(gb);\n    int ret     = 0;\n    uint8_t *p;\n\n    if (len < 0)\n        return len;\n\n    if (len > *size)\n        return AVERROR_BUG;\n\n    *size = len;\n    p     = buf;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        uint8_t s = bytestream2_get_byte(gb);\n        int val   = s >> 2;\n\n        switch (s & 0x03) {\n        case SNAPPY_LITERAL:\n            ret = snappy_literal(gb, p, len, val);\n            break;\n        case SNAPPY_COPY_1:\n            ret = snappy_copy1(gb, buf, p, len, val);\n            break;\n        case SNAPPY_COPY_2:\n            ret = snappy_copy2(gb, buf, p, len, val);\n            break;\n        case SNAPPY_COPY_4:\n            ret = snappy_copy4(gb, buf, p, len, val);\n            break;\n        }\n\n        if (ret < 0)\n            return ret;\n\n        p   += ret;\n        len -= ret;\n    }\n\n    return 0;\n}", "before_change_lines": [1, 10, 11, 14, 25, 28, 31], "raw_before_change_lines": [1, 10, 11, 14, 25, 28, 31], "after_change_lines": [1, 10, 11, 14, 25, 28, 31], "raw_after_change_lines": [1, 10, 11, 14, 25, 28, 31], "bug_lines": [1, 10, 11, 14, 25, 28, 31], "added": [false, false, false, false, false, false, false], "idx": 250}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6053----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_40c55758b2fa171cb0d0b7e519ca75e01d62b1df_1.json----ff_vorbis_len2vlc", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_40c55758b2fa171cb0d0b7e519ca75e01d62b1df_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_40c55758b2fa171cb0d0b7e519ca75e01d62b1df_1.json", "function_name": "ff_vorbis_len2vlc", "vul_func_code": "int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, uint_fast32_t num)\n{\n    uint_fast32_t exit_at_level[33] = {\n        404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n    uint_fast8_t i, j;\n    uint_fast32_t code, p;\n\n#ifdef V_DEBUG\n    GetBitContext gb;\n#endif\n\n    for (p = 0; (bits[p] == 0) && (p < num); ++p)\n        ;\n    if (p == num) {\n//        av_log(vc->avccontext, AV_LOG_INFO, \"An empty codebook. Heh?! \\n\");\n        return 0;\n    }\n\n    codes[p] = 0;\n    if (bits[p] > 32)\n        return 1;\n    for (i = 0; i < bits[p]; ++i)\n        exit_at_level[i+1] = 1 << i;\n\n#ifdef V_DEBUG\n    av_log(NULL, AV_LOG_INFO, \" %d. of %d code len %d code %d - \", p, num, bits[p], codes[p]);\n    init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]);\n    for (i = 0; i < bits[p]; ++i)\n        av_log(NULL, AV_LOG_INFO, \"%s\", get_bits1(&gb) ? \"1\" : \"0\");\n    av_log(NULL, AV_LOG_INFO, \"\\n\");\n#endif\n\n    ++p;\n\n    for (; p < num; ++p) {\n        if (bits[p] > 32)\n             return 1;\n        if (bits[p] == 0)\n             continue;\n        // find corresponding exit(node which the tree can grow further from)\n        for (i = bits[p]; i > 0; --i)\n            if (exit_at_level[i])\n                break;\n        if (!i) // overspecified tree\n             return 1;\n        code = exit_at_level[i];\n        exit_at_level[i] = 0;\n        // construct code (append 0s to end) and introduce new exits\n        for (j = i + 1 ;j <= bits[p]; ++j)\n            exit_at_level[j] = code + (1 << (j - 1));\n        codes[p] = code;\n\n#ifdef V_DEBUG\n        av_log(NULL, AV_LOG_INFO, \" %d. code len %d code %d - \", p, bits[p], codes[p]);\n        init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]);\n        for (i = 0; i < bits[p]; ++i)\n            av_log(NULL, AV_LOG_INFO, \"%s\", get_bits1(&gb) ? \"1\" : \"0\");\n        av_log(NULL, AV_LOG_INFO, \"\\n\");\n#endif\n\n    }\n\n    //no exits should be left (underspecified tree - ie. unused valid vlcs - not allowed by SPEC)\n    for (p = 1; p < 33; p++)\n        if (exit_at_level[p])\n            return 1;\n\n    return 0;\n}", "patch_func_code": "int ff_vorbis_len2vlc(uint8_t *bits, uint32_t *codes, unsigned num)\n{\n    uint_fast32_t exit_at_level[33] = {\n        404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n    unsigned i, j, p, code;\n\n#ifdef V_DEBUG\n    GetBitContext gb;\n#endif\n\n    for (p = 0; (bits[p] == 0) && (p < num); ++p)\n        ;\n    if (p == num) {\n//        av_log(vc->avccontext, AV_LOG_INFO, \"An empty codebook. Heh?! \\n\");\n        return 0;\n    }\n\n    codes[p] = 0;\n    if (bits[p] > 32)\n        return 1;\n    for (i = 0; i < bits[p]; ++i)\n        exit_at_level[i+1] = 1 << i;\n\n#ifdef V_DEBUG\n    av_log(NULL, AV_LOG_INFO, \" %u. of %u code len %d code %d - \", p, num, bits[p], codes[p]);\n    init_get_bits(&gb, (uint8_t *)&codes[p], bits[p]);\n    for (i = 0; i < bits[p]; ++i)\n        av_log(NULL, AV_LOG_INFO, \"%s\", get_bits1(&gb) ? \"1\" : \"0\");\n    av_log(NULL, AV_LOG_INFO, \"\\n\");\n#endif\n\n    ++p;\n\n    for (; p < num; ++p) {\n        if (bits[p] > 32)\n             return 1;\n        if (bits[p] == 0)\n             continue;\n        // find corresponding exit(node which the tree can grow further from)\n        for (i = bits[p]; i > 0; --i)\n            if (exit_at_level[i])\n                break;\n        if (!i) // overspecified tree\n             return 1;\n        code = exit_at_level[i];\n        exit_at_level[i] = 0;\n        // construct code (append 0s to end) and introduce new exits\n        for (j = i + 1 ;j <= bits[p]; ++j)\n            exit_at_level[j] = code + (1 << (j - 1));\n        codes[p] = code;\n\n#ifdef V_DEBUG\n        av_log(NULL, AV_LOG_INFO, \" %d. code len %d code %d - \", p, bits[p], codes[p]);\n        init_get_bits(&gb, (uint_fast8_t *)&codes[p], bits[p]);\n        for (i = 0; i < bits[p]; ++i)\n            av_log(NULL, AV_LOG_INFO, \"%s\", get_bits1(&gb) ? \"1\" : \"0\");\n        av_log(NULL, AV_LOG_INFO, \"\\n\");\n#endif\n\n    }\n\n    //no exits should be left (underspecified tree - ie. unused valid vlcs - not allowed by SPEC)\n    for (p = 1; p < 33; p++)\n        if (exit_at_level[p])\n            return 1;\n\n    return 0;\n}", "before_change_lines": [1, 7, 8, 28, 29], "raw_before_change_lines": [1, 7, 8, 28, 29], "after_change_lines": [1, 7, 27, 28], "raw_after_change_lines": [1, 7, 27, 28], "bug_lines": [1, 7, 8, 28, 29], "added": [false, false, false, false, false], "idx": 251}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6076----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_1.json----output_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_1.json", "function_name": "output_packet", "vul_func_code": "static int output_packet(InputStream *ist, const AVPacket *pkt)\n{\n    int i;\n    int got_output;\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n    AVPacket avpkt;\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts;\n\n    if (pkt == NULL) {\n        /* EOF handling */\n        av_init_packet(&avpkt);\n        avpkt.data = NULL;\n        avpkt.size = 0;\n        goto handle_eof;\n    } else {\n        avpkt = *pkt;\n    }\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n    if (pkt->pts != AV_NOPTS_VALUE)\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int ret = 0;\n    handle_eof:\n\n        ist->last_dts = ist->next_dts;\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n            ist->showed_multi_packet_warning = 1;\n        }\n\n        switch (ist->st->codec->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n            if (avpkt.duration)\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            else if (ist->st->r_frame_rate.num)\n                ist->next_dts += av_rescale_q(1, (AVRational){ist->st->r_frame_rate.den,\n                                                              ist->st->r_frame_rate.num},\n                                              AV_TIME_BASE_Q);\n            else if (ist->st->codec->time_base.num != 0) {\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n                                                   ist->st->codec->ticks_per_frame;\n                ist->next_dts += av_rescale_q(ticks, ist->st->codec->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pkt) {\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n    }\n\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        rate_emu_sleep(ist);\n        ist->last_dts = ist->next_dts;\n        switch (ist->st->codec->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n                             ist->st->codec->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->st->codec->time_base.num != 0) {\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->st->codec->time_base.num * ticks) /\n                                  ist->st->codec->time_base.den;\n            }\n            break;\n        }\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = &output_streams[i];\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n\n        do_streamcopy(ist, ost, pkt);\n    }\n\n    return 0;\n}", "patch_func_code": "static int output_packet(InputStream *ist, const AVPacket *pkt)\n{\n    int i;\n    int got_output;\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n    AVPacket avpkt;\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts;\n\n    if (pkt == NULL) {\n        /* EOF handling */\n        av_init_packet(&avpkt);\n        avpkt.data = NULL;\n        avpkt.size = 0;\n        goto handle_eof;\n    } else {\n        avpkt = *pkt;\n    }\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n    if (pkt->pts != AV_NOPTS_VALUE)\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    // while we have more to decode or while the decoder did output something on EOF\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n        int ret = 0;\n    handle_eof:\n\n        ist->last_dts = ist->next_dts;\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n            ist->showed_multi_packet_warning = 1;\n        }\n\n        switch (ist->st->codec->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n            if (avpkt.duration)\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n            else if (ist->st->r_frame_rate.num)\n                ist->next_dts += av_rescale_q(1, (AVRational){ist->st->r_frame_rate.den,\n                                                              ist->st->r_frame_rate.num},\n                                              AV_TIME_BASE_Q);\n            else if (ist->st->codec->time_base.num != 0) {\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n                                                   ist->st->codec->ticks_per_frame;\n                ist->next_dts += av_rescale_q(ticks, ist->st->codec->time_base, AV_TIME_BASE_Q);\n            }\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n            break;\n        default:\n            return -1;\n        }\n\n        if (ret < 0)\n            return ret;\n        // touch data and size only if not EOF\n        if (pkt) {\n            avpkt.data += ret;\n            avpkt.size -= ret;\n        }\n        if (!got_output) {\n            continue;\n        }\n    }\n\n    /* handle stream copy */\n    if (!ist->decoding_needed) {\n        rate_emu_sleep(ist);\n        ist->last_dts = ist->next_dts;\n        switch (ist->st->codec->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n                             ist->st->codec->sample_rate;\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (ist->st->codec->time_base.num != 0) {\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n                                  ist->st->codec->time_base.num * ticks) /\n                                  ist->st->codec->time_base.den;\n            }\n            break;\n        }\n    }\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n\n        do_streamcopy(ist, ost, pkt);\n    }\n\n    return 0;\n}", "before_change_lines": [96], "raw_before_change_lines": [96], "after_change_lines": [96], "raw_after_change_lines": [96], "bug_lines": [96], "added": [false], "idx": 252}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6078----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_1.json----check_output_constraints", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_42e44d4b81f3b23f2c81218fbbcad84105864530_1.json", "function_name": "check_output_constraints", "vul_func_code": "static int check_output_constraints(InputStream *ist, OutputStream *ost)\n{\n    OutputFile *of = &output_files[ost->file_index];\n    int ist_index  = ist - input_streams;\n\n    if (ost->source_index != ist_index)\n        return 0;\n\n    if (of->start_time && ist->last_dts < of->start_time)\n        return 0;\n\n    return 1;\n}", "patch_func_code": "static int check_output_constraints(InputStream *ist, OutputStream *ost)\n{\n    OutputFile *of = output_files[ost->file_index];\n    int ist_index  = input_files[ist->file_index]->ist_index + ist->st->index;\n\n    if (ost->source_index != ist_index)\n        return 0;\n\n    if (of->start_time && ist->last_dts < of->start_time)\n        return 0;\n\n    return 1;\n}", "before_change_lines": [3, 4], "raw_before_change_lines": [3, 4], "after_change_lines": [3, 4], "raw_after_change_lines": [3, 4], "bug_lines": [3, 4], "added": [false, false], "idx": 253}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6209----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4b59e22c12bf32306df4182118b6c4ad571a241e_1.json----formant_postfilter", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4b59e22c12bf32306df4182118b6c4ad571a241e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4b59e22c12bf32306df4182118b6c4ad571a241e_1.json", "function_name": "formant_postfilter", "vul_func_code": "static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf)\n{\n    int16_t filter_coef[2][LPC_ORDER], *buf_ptr;\n    int filter_signal[LPC_ORDER + FRAME_LEN], *signal_ptr;\n    int i, j, k;\n\n    memcpy(buf, p->fir_mem, LPC_ORDER * sizeof(*buf));\n    memcpy(filter_signal, p->iir_mem, LPC_ORDER * sizeof(*filter_signal));\n\n    for (i = LPC_ORDER, j = 0; j < SUBFRAMES; i += SUBFRAME_LEN, j++) {\n        for (k = 0; k < LPC_ORDER; k++) {\n            filter_coef[0][k] = (-lpc[k] * postfilter_tbl[0][k] +\n                                 (1 << 14)) >> 15;\n            filter_coef[1][k] = (-lpc[k] * postfilter_tbl[1][k] +\n                                 (1 << 14)) >> 15;\n        }\n        iir_filter(filter_coef[0], filter_coef[1], buf + i,\n                   filter_signal + i);\n        lpc += LPC_ORDER;\n    }\n\n    memcpy(p->fir_mem, buf + FRAME_LEN, LPC_ORDER * sizeof(*p->fir_mem));\n    memcpy(p->iir_mem, filter_signal + FRAME_LEN,\n           LPC_ORDER * sizeof(*p->iir_mem));\n\n    buf_ptr    = buf + LPC_ORDER;\n    signal_ptr = filter_signal + LPC_ORDER;\n    for (i = 0; i < SUBFRAMES; i++) {\n        int16_t temp_vector[SUBFRAME_LEN];\n        int16_t temp;\n        int auto_corr[2];\n        int scale, energy;\n\n        /* Normalize */\n        memcpy(temp_vector, buf_ptr, SUBFRAME_LEN * sizeof(*temp_vector));\n        scale = scale_vector(temp_vector, SUBFRAME_LEN);\n\n        /* Compute auto correlation coefficients */\n        auto_corr[0] = dot_product(temp_vector, temp_vector + 1,\n                                   SUBFRAME_LEN - 1, 1);\n        auto_corr[1] = dot_product(temp_vector, temp_vector, SUBFRAME_LEN, 1);\n\n        /* Compute reflection coefficient */\n        temp = auto_corr[1] >> 16;\n        if (temp) {\n            temp = (auto_corr[0] >> 2) / temp;\n        }\n        p->reflection_coef = (3 * p->reflection_coef + temp + 2) >> 2;\n        temp = (p->reflection_coef * 0xffffc >> 3) & 0xfffc;\n\n        /* Compensation filter */\n        for (j = 0; j < SUBFRAME_LEN; j++) {\n            buf_ptr[j] = av_clipl_int32(signal_ptr[j] +\n                                        ((signal_ptr[j - 1] >> 16) *\n                                         temp << 1)) >> 16;\n        }\n\n        /* Compute normalized signal energy */\n        temp = 2 * scale + 4;\n        if (temp < 0) {\n            energy = av_clipl_int32((int64_t)auto_corr[1] << -temp);\n        } else\n            energy = auto_corr[1] >> temp;\n\n        gain_scale(p, buf_ptr, energy);\n\n        buf_ptr    += SUBFRAME_LEN;\n        signal_ptr += SUBFRAME_LEN;\n    }\n}", "patch_func_code": "static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf)\n{\n    int16_t filter_coef[2][LPC_ORDER], *buf_ptr;\n    int filter_signal[LPC_ORDER + FRAME_LEN], *signal_ptr;\n    int i, j, k;\n\n    memcpy(buf, p->fir_mem, LPC_ORDER * sizeof(*buf));\n    memcpy(filter_signal, p->iir_mem, LPC_ORDER * sizeof(*filter_signal));\n\n    for (i = LPC_ORDER, j = 0; j < SUBFRAMES; i += SUBFRAME_LEN, j++) {\n        for (k = 0; k < LPC_ORDER; k++) {\n            filter_coef[0][k] = (-lpc[k] * postfilter_tbl[0][k] +\n                                 (1 << 14)) >> 15;\n            filter_coef[1][k] = (-lpc[k] * postfilter_tbl[1][k] +\n                                 (1 << 14)) >> 15;\n        }\n        iir_filter(filter_coef[0], filter_coef[1], buf + i,\n                   filter_signal + i);\n        lpc += LPC_ORDER;\n    }\n\n    memcpy(p->fir_mem, buf + FRAME_LEN, LPC_ORDER * sizeof(*p->fir_mem));\n    memcpy(p->iir_mem, filter_signal + FRAME_LEN,\n           LPC_ORDER * sizeof(*p->iir_mem));\n\n    buf_ptr    = buf + LPC_ORDER;\n    signal_ptr = filter_signal + LPC_ORDER;\n    for (i = 0; i < SUBFRAMES; i++) {\n        int16_t temp_vector[SUBFRAME_LEN];\n        int temp;\n        int auto_corr[2];\n        int scale, energy;\n\n        /* Normalize */\n        memcpy(temp_vector, buf_ptr, SUBFRAME_LEN * sizeof(*temp_vector));\n        scale = scale_vector(temp_vector, SUBFRAME_LEN);\n\n        /* Compute auto correlation coefficients */\n        auto_corr[0] = dot_product(temp_vector, temp_vector + 1,\n                                   SUBFRAME_LEN - 1, 1);\n        auto_corr[1] = dot_product(temp_vector, temp_vector, SUBFRAME_LEN, 1);\n\n        /* Compute reflection coefficient */\n        temp = auto_corr[1] >> 16;\n        if (temp) {\n            temp = (auto_corr[0] >> 2) / temp;\n        }\n        p->reflection_coef = (3 * p->reflection_coef + temp + 2) >> 2;\n        temp = -p->reflection_coef >> 1 & ~3;\n\n        /* Compensation filter */\n        for (j = 0; j < SUBFRAME_LEN; j++) {\n            buf_ptr[j] = av_clipl_int32(signal_ptr[j] +\n                                        ((signal_ptr[j - 1] >> 16) *\n                                         temp << 1)) >> 16;\n        }\n\n        /* Compute normalized signal energy */\n        temp = 2 * scale + 4;\n        if (temp < 0) {\n            energy = av_clipl_int32((int64_t)auto_corr[1] << -temp);\n        } else\n            energy = auto_corr[1] >> temp;\n\n        gain_scale(p, buf_ptr, energy);\n\n        buf_ptr    += SUBFRAME_LEN;\n        signal_ptr += SUBFRAME_LEN;\n    }\n}", "before_change_lines": [30, 49], "raw_before_change_lines": [30, 49], "after_change_lines": [30, 49], "raw_after_change_lines": [30, 49], "bug_lines": [30, 49], "added": [false, false], "idx": 254}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "6219----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c0cdd7f37dd9dd4dc0e0b5e0ad2d16f7052cd85_1.json----ff_mjpeg_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4c0cdd7f37dd9dd4dc0e0b5e0ad2d16f7052cd85_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c0cdd7f37dd9dd4dc0e0b5e0ad2d16f7052cd85_1.json", "function_name": "ff_mjpeg_decode_frame", "vul_func_code": "int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                          AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    MJpegDecodeContext *s = avctx->priv_data;\n    const uint8_t *buf_end, *buf_ptr;\n    const uint8_t *unescaped_buf_ptr;\n    int unescaped_buf_size;\n    int start_code;\n    int ret = 0;\n\n    s->got_picture = 0; // picture from previous image can not be reused\n    buf_ptr = buf;\n    buf_end = buf + buf_size;\n    while (buf_ptr < buf_end) {\n        /* find start next marker */\n        start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end,\n                                          &unescaped_buf_ptr,\n                                          &unescaped_buf_size);\n        /* EOF */\n        if (start_code < 0) {\n            goto the_end;\n        } else if (unescaped_buf_size > (1U<<29)) {\n            av_log(avctx, AV_LOG_ERROR, \"MJPEG packet 0x%x too big (0x%x/0x%x), corrupt data?\\n\",\n                   start_code, unescaped_buf_size, buf_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%td\\n\",\n               start_code, buf_end - buf_ptr);\n\n        init_get_bits(&s->gb, unescaped_buf_ptr, unescaped_buf_size * 8);\n\n        s->start_code = start_code;\n        if (s->avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);\n\n        /* process markers */\n        if (start_code >= 0xd0 && start_code <= 0xd7)\n            av_log(avctx, AV_LOG_DEBUG,\n                   \"restart marker: %d\\n\", start_code & 0x0f);\n            /* APP fields */\n        else if (start_code >= APP0 && start_code <= APP15)\n            mjpeg_decode_app(s);\n            /* Comment */\n        else if (start_code == COM)\n            mjpeg_decode_com(s);\n\n        if (!CONFIG_JPEGLS_DECODER &&\n            (start_code == SOF48 || start_code == LSE)) {\n            av_log(avctx, AV_LOG_ERROR, \"JPEG-LS support not enabled.\\n\");\n            return AVERROR(ENOSYS);\n        }\n\n        switch (start_code) {\n        case SOI:\n            s->restart_interval = 0;\n            s->restart_count    = 0;\n            /* nothing to do on SOI */\n            break;\n        case DQT:\n            ff_mjpeg_decode_dqt(s);\n            break;\n        case DHT:\n            if ((ret = ff_mjpeg_decode_dht(s)) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");\n                return ret;\n            }\n            break;\n        case SOF0:\n        case SOF1:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case SOF2:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 1;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case SOF3:\n            s->lossless    = 1;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case SOF48:\n            s->lossless    = 1;\n            s->ls          = 1;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case LSE:\n            if (!CONFIG_JPEGLS_DECODER ||\n                (ret = ff_jpegls_decode_lse(s)) < 0)\n                return ret;\n            break;\n        case EOI:\n            s->cur_scan = 0;\n            if ((s->buggy_avid && !s->interlaced) || s->restart_interval)\n                break;\neoi_parser:\n            if (!s->got_picture) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Found EOI before any SOF, ignoring\\n\");\n                break;\n            }\n            if (s->interlaced) {\n                s->bottom_field ^= 1;\n                /* if not bottom field, do not output image yet */\n                if (s->bottom_field == !s->interlace_polarity)\n                    goto not_the_end;\n            }\n            if ((ret = av_frame_ref(data, s->picture_ptr)) < 0)\n                return ret;\n            *got_frame = 1;\n\n            if (!s->lossless &&\n                avctx->debug & FF_DEBUG_QP) {\n                av_log(avctx, AV_LOG_DEBUG,\n                       \"QP: %d\\n\", FFMAX3(s->qscale[0],\n                                          s->qscale[1],\n                                          s->qscale[2]));\n            }\n\n            goto the_end;\n        case SOS:\n            if (!s->got_picture) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Can not process SOS before SOF, skipping\\n\");\n                break;\n                }\n            if ((ret = ff_mjpeg_decode_sos(s, NULL, NULL)) < 0 &&\n                (avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            /* buggy avid puts EOI every 10-20th frame */\n            /* if restart period is over process EOI */\n            if ((s->buggy_avid && !s->interlaced) || s->restart_interval)\n                goto eoi_parser;\n            break;\n        case DRI:\n            mjpeg_decode_dri(s);\n            break;\n        case SOF5:\n        case SOF6:\n        case SOF7:\n        case SOF9:\n        case SOF10:\n        case SOF11:\n        case SOF13:\n        case SOF14:\n        case SOF15:\n        case JPG:\n            av_log(avctx, AV_LOG_ERROR,\n                   \"mjpeg: unsupported coding type (%x)\\n\", start_code);\n            break;\n        }\n\nnot_the_end:\n        /* eof process start code */\n        buf_ptr += (get_bits_count(&s->gb) + 7) / 8;\n        av_log(avctx, AV_LOG_DEBUG,\n               \"marker parser used %d bytes (%d bits)\\n\",\n               (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb));\n    }\n    if (s->got_picture) {\n        av_log(avctx, AV_LOG_WARNING, \"EOI missing, emulating\\n\");\n        goto eoi_parser;\n    }\n    av_log(avctx, AV_LOG_FATAL, \"No JPEG data found in image\\n\");\n    return AVERROR_INVALIDDATA;\nthe_end:\n    av_log(avctx, AV_LOG_DEBUG, \"mjpeg decode frame unused %td bytes\\n\",\n           buf_end - buf_ptr);\n//  return buf_end - buf_ptr;\n    return buf_ptr - buf;\n}", "patch_func_code": "int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                          AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    MJpegDecodeContext *s = avctx->priv_data;\n    const uint8_t *buf_end, *buf_ptr;\n    const uint8_t *unescaped_buf_ptr;\n    int unescaped_buf_size;\n    int start_code;\n    int ret = 0;\n\n    s->got_picture = 0; // picture from previous image can not be reused\n    buf_ptr = buf;\n    buf_end = buf + buf_size;\n    while (buf_ptr < buf_end) {\n        /* find start next marker */\n        start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end,\n                                          &unescaped_buf_ptr,\n                                          &unescaped_buf_size);\n        /* EOF */\n        if (start_code < 0) {\n            goto the_end;\n        } else if (unescaped_buf_size > INT_MAX / 8) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"MJPEG packet 0x%x too big (%d/%d), corrupt data?\\n\",\n                   start_code, unescaped_buf_size, buf_size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%td\\n\",\n               start_code, buf_end - buf_ptr);\n\n        ret = init_get_bits(&s->gb, unescaped_buf_ptr,\n                            unescaped_buf_size * 8);\n        if (ret < 0)\n            return ret;\n\n        s->start_code = start_code;\n        if (s->avctx->debug & FF_DEBUG_STARTCODE)\n            av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);\n\n        /* process markers */\n        if (start_code >= 0xd0 && start_code <= 0xd7)\n            av_log(avctx, AV_LOG_DEBUG,\n                   \"restart marker: %d\\n\", start_code & 0x0f);\n            /* APP fields */\n        else if (start_code >= APP0 && start_code <= APP15)\n            mjpeg_decode_app(s);\n            /* Comment */\n        else if (start_code == COM)\n            mjpeg_decode_com(s);\n\n        if (!CONFIG_JPEGLS_DECODER &&\n            (start_code == SOF48 || start_code == LSE)) {\n            av_log(avctx, AV_LOG_ERROR, \"JPEG-LS support not enabled.\\n\");\n            return AVERROR(ENOSYS);\n        }\n\n        switch (start_code) {\n        case SOI:\n            s->restart_interval = 0;\n            s->restart_count    = 0;\n            /* nothing to do on SOI */\n            break;\n        case DQT:\n            ff_mjpeg_decode_dqt(s);\n            break;\n        case DHT:\n            if ((ret = ff_mjpeg_decode_dht(s)) < 0) {\n                av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");\n                return ret;\n            }\n            break;\n        case SOF0:\n        case SOF1:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case SOF2:\n            s->lossless    = 0;\n            s->ls          = 0;\n            s->progressive = 1;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case SOF3:\n            s->lossless    = 1;\n            s->ls          = 0;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case SOF48:\n            s->lossless    = 1;\n            s->ls          = 1;\n            s->progressive = 0;\n            if ((ret = ff_mjpeg_decode_sof(s)) < 0)\n                return ret;\n            break;\n        case LSE:\n            if (!CONFIG_JPEGLS_DECODER ||\n                (ret = ff_jpegls_decode_lse(s)) < 0)\n                return ret;\n            break;\n        case EOI:\n            s->cur_scan = 0;\n            if ((s->buggy_avid && !s->interlaced) || s->restart_interval)\n                break;\neoi_parser:\n            if (!s->got_picture) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Found EOI before any SOF, ignoring\\n\");\n                break;\n            }\n            if (s->interlaced) {\n                s->bottom_field ^= 1;\n                /* if not bottom field, do not output image yet */\n                if (s->bottom_field == !s->interlace_polarity)\n                    goto not_the_end;\n            }\n            if ((ret = av_frame_ref(data, s->picture_ptr)) < 0)\n                return ret;\n            *got_frame = 1;\n\n            if (!s->lossless &&\n                avctx->debug & FF_DEBUG_QP) {\n                av_log(avctx, AV_LOG_DEBUG,\n                       \"QP: %d\\n\", FFMAX3(s->qscale[0],\n                                          s->qscale[1],\n                                          s->qscale[2]));\n            }\n\n            goto the_end;\n        case SOS:\n            if (!s->got_picture) {\n                av_log(avctx, AV_LOG_WARNING,\n                       \"Can not process SOS before SOF, skipping\\n\");\n                break;\n                }\n            if ((ret = ff_mjpeg_decode_sos(s, NULL, NULL)) < 0 &&\n                (avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            /* buggy avid puts EOI every 10-20th frame */\n            /* if restart period is over process EOI */\n            if ((s->buggy_avid && !s->interlaced) || s->restart_interval)\n                goto eoi_parser;\n            break;\n        case DRI:\n            mjpeg_decode_dri(s);\n            break;\n        case SOF5:\n        case SOF6:\n        case SOF7:\n        case SOF9:\n        case SOF10:\n        case SOF11:\n        case SOF13:\n        case SOF14:\n        case SOF15:\n        case JPG:\n            av_log(avctx, AV_LOG_ERROR,\n                   \"mjpeg: unsupported coding type (%x)\\n\", start_code);\n            break;\n        }\n\nnot_the_end:\n        /* eof process start code */\n        buf_ptr += (get_bits_count(&s->gb) + 7) / 8;\n        av_log(avctx, AV_LOG_DEBUG,\n               \"marker parser used %d bytes (%d bits)\\n\",\n               (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb));\n    }\n    if (s->got_picture) {\n        av_log(avctx, AV_LOG_WARNING, \"EOI missing, emulating\\n\");\n        goto eoi_parser;\n    }\n    av_log(avctx, AV_LOG_FATAL, \"No JPEG data found in image\\n\");\n    return AVERROR_INVALIDDATA;\nthe_end:\n    av_log(avctx, AV_LOG_DEBUG, \"mjpeg decode frame unused %td bytes\\n\",\n           buf_end - buf_ptr);\n//  return buf_end - buf_ptr;\n    return buf_ptr - buf;\n}", "before_change_lines": [24, 25, 33], "raw_before_change_lines": [24, 25, 33], "after_change_lines": [24, 25, 26, 34, 35, 36, 37], "raw_after_change_lines": [24, 25, 26, 34, 35, 36, 37], "bug_lines": [24, 25, 33], "added": [false, false, false], "idx": 255}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6221----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c4c31edfd61c8b55ddf405d6003d936af88d5c8_1.json----vc1_decode_p_blocks", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4c4c31edfd61c8b55ddf405d6003d936af88d5c8_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c4c31edfd61c8b55ddf405d6003d936af88d5c8_1.json", "function_name": "vc1_decode_p_blocks", "vul_func_code": "static void vc1_decode_p_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    int apply_loop_filter;\n\n    /* select codingmode used for VLC tables selection */\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    apply_loop_filter   = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY);\n    s->first_slice_line = 1;\n    memset(v->cbp_base, 0, sizeof(v->cbp_base[0])*2*s->mb_stride);\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n\n            if (v->fcm == ILACE_FIELD)\n                vc1_decode_p_mb_intfi(v);\n            else if (v->fcm == ILACE_FRAME)\n                vc1_decode_p_mb_intfr(v);\n            else vc1_decode_p_mb(v);\n            if (s->mb_y != s->start_mb_y && apply_loop_filter && v->fcm == PROGRESSIVE)\n                vc1_apply_p_loop_filter(v);\n            if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n                       get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n        }\n        memmove(v->cbp_base,      v->cbp,      sizeof(v->cbp_base[0])      * s->mb_stride);\n        memmove(v->ttblk_base,    v->ttblk,    sizeof(v->ttblk_base[0])    * s->mb_stride);\n        memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);\n        memmove(v->luma_mv_base,  v->luma_mv,  sizeof(v->luma_mv_base[0])  * s->mb_stride);\n        if (s->mb_y != s->start_mb_y) ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n    if (apply_loop_filter) {\n        s->mb_x = 0;\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n            vc1_apply_p_loop_filter(v);\n        }\n    }\n    if (s->end_mb_y >= s->start_mb_y)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}", "patch_func_code": "static void vc1_decode_p_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    int apply_loop_filter;\n\n    /* select codingmode used for VLC tables selection */\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n        break;\n    case 1:\n        v->codingset = CS_HIGH_MOT_INTRA;\n        break;\n    case 2:\n        v->codingset = CS_MID_RATE_INTRA;\n        break;\n    }\n\n    switch (v->c_ac_table_index) {\n    case 0:\n        v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n        break;\n    case 1:\n        v->codingset2 = CS_HIGH_MOT_INTER;\n        break;\n    case 2:\n        v->codingset2 = CS_MID_RATE_INTER;\n        break;\n    }\n\n    apply_loop_filter   = s->loop_filter && !(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY) &&\n                          v->fcm == PROGRESSIVE;\n    s->first_slice_line = 1;\n    memset(v->cbp_base, 0, sizeof(v->cbp_base[0])*2*s->mb_stride);\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n\n            if (v->fcm == ILACE_FIELD)\n                vc1_decode_p_mb_intfi(v);\n            else if (v->fcm == ILACE_FRAME)\n                vc1_decode_p_mb_intfr(v);\n            else vc1_decode_p_mb(v);\n            if (s->mb_y != s->start_mb_y && apply_loop_filter)\n                vc1_apply_p_loop_filter(v);\n            if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n                // TODO: may need modification to handle slice coding\n                ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n                av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n                       get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n                return;\n            }\n        }\n        memmove(v->cbp_base,      v->cbp,      sizeof(v->cbp_base[0])      * s->mb_stride);\n        memmove(v->ttblk_base,    v->ttblk,    sizeof(v->ttblk_base[0])    * s->mb_stride);\n        memmove(v->is_intra_base, v->is_intra, sizeof(v->is_intra_base[0]) * s->mb_stride);\n        memmove(v->luma_mv_base,  v->luma_mv,  sizeof(v->luma_mv_base[0])  * s->mb_stride);\n        if (s->mb_y != s->start_mb_y) ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n        s->first_slice_line = 0;\n    }\n    if (apply_loop_filter) {\n        s->mb_x = 0;\n        ff_init_block_index(s);\n        for (; s->mb_x < s->mb_width; s->mb_x++) {\n            ff_update_block_index(s);\n            vc1_apply_p_loop_filter(v);\n        }\n    }\n    if (s->end_mb_y >= s->start_mb_y)\n        ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n    ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n                    (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n}", "before_change_lines": [31, 45], "raw_before_change_lines": [31, 45], "after_change_lines": [31, 32, 46], "raw_after_change_lines": [31, 32, 46], "bug_lines": [31, 45], "added": [false, false], "idx": 256}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6226----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c9aaafc67ab78d51bc442576f908e297cb70ca8_1.json----vc1_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4c9aaafc67ab78d51bc442576f908e297cb70ca8_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4c9aaafc67ab78d51bc442576f908e297cb70ca8_1.json", "function_name": "vc1_decode_frame", "vul_func_code": "static int vc1_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size, n_slices = 0, i;\n    VC1Context *v = avctx->priv_data;\n    MpegEncContext *s = &v->s;\n    AVFrame *pict = data;\n    uint8_t *buf2 = NULL;\n    const uint8_t *buf_start = buf;\n    struct {\n        uint8_t *buf;\n        GetBitContext gb;\n        int mby_start;\n    } *slices = NULL;\n\n    /* no supplementary picture */\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            *pict= *(AVFrame*)s->next_picture_ptr;\n            s->next_picture_ptr= NULL;\n\n            *data_size = sizeof(AVFrame);\n        }\n\n        return 0;\n    }\n\n    /* We need to set current_picture_ptr before reading the header,\n     * otherwise we cannot store anything in there. */\n    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {\n        int i= ff_find_unused_picture(s, 0);\n        s->current_picture_ptr= &s->picture[i];\n    }\n\n    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n        if (v->profile < PROFILE_ADVANCED)\n            avctx->pix_fmt = PIX_FMT_VDPAU_WMV3;\n        else\n            avctx->pix_fmt = PIX_FMT_VDPAU_VC1;\n    }\n\n    //for advanced profile we may need to parse and unescape data\n    if (avctx->codec_id == CODEC_ID_VC1 || avctx->codec_id == CODEC_ID_VC1IMAGE) {\n        int buf_size2 = 0;\n        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if(IS_MARKER(AV_RB32(buf))){ /* frame starts with marker and needs to be parsed */\n            const uint8_t *start, *end, *next;\n            int size;\n\n            next = buf;\n            for(start = buf, end = buf + buf_size; next < end; start = next){\n                next = find_next_marker(start + 4, end);\n                size = next - start - 4;\n                if(size <= 0) continue;\n                switch(AV_RB32(start)){\n                case VC1_CODE_FRAME:\n                    if (avctx->hwaccel ||\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n                        buf_start = start;\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n                    break;\n                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n                    init_get_bits(&s->gb, buf2, buf_size2*8);\n                    vc1_decode_entry_point(avctx, v, &s->gb);\n                    break;\n                case VC1_CODE_SLICE: {\n                    int buf_size3;\n                    slices = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n                    if (!slices) goto err;\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n                    if (!slices[n_slices].buf) goto err;\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n                                                    slices[n_slices].buf);\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n                                  buf_size3 << 3);\n                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);\n                    n_slices++;\n                    break;\n                }\n                }\n            }\n        }else if(v->interlace && ((buf[0] & 0xC0) == 0xC0)){ /* WVC1 interlaced stores both fields divided by marker */\n            const uint8_t *divider;\n\n            divider = find_next_marker(buf, buf + buf_size);\n            if((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD){\n                av_log(avctx, AV_LOG_ERROR, \"Error in WVC1 interlaced frame\\n\");\n                goto err;\n            }\n\n            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);\n            // TODO\n            if(!v->warn_interlaced++)\n                av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced WVC1 support is not implemented\\n\");\n            goto err;\n        }else{\n            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);\n        }\n        init_get_bits(&s->gb, buf2, buf_size2*8);\n    } else\n        init_get_bits(&s->gb, buf, buf_size*8);\n\n    if (v->res_sprite) {\n        v->new_sprite = !get_bits1(&s->gb);\n        v->two_sprites = get_bits1(&s->gb);\n        /* res_sprite means a Windows Media Image stream, CODEC_ID_*IMAGE means\n           we're using the sprite compositor. These are intentionally kept separate\n           so you can get the raw sprites by using the wmv3 decoder for WMVP or\n           the vc1 one for WVP2 */\n        if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) {\n            if (v->new_sprite) {\n                // switch AVCodecContext parameters to those of the sprites\n                avctx->width  = avctx->coded_width  = v->sprite_width;\n                avctx->height = avctx->coded_height = v->sprite_height;\n            } else {\n                goto image;\n            }\n        }\n    }\n\n    // do parse frame header\n    if(v->profile < PROFILE_ADVANCED) {\n        if(vc1_parse_frame_header(v, &s->gb) == -1) {\n            goto err;\n        }\n    } else {\n        if(vc1_parse_frame_header_adv(v, &s->gb) == -1) {\n            goto err;\n        }\n    }\n\n    if ((avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE)\n        && s->pict_type!=AV_PICTURE_TYPE_I) {\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Sprite decoder: expected I-frame\\n\");\n        goto err;\n    }\n\n    // process pulldown flags\n    s->current_picture_ptr->f.repeat_pict = 0;\n    // Pulldown flags are only valid when 'broadcast' has been set.\n    // So ticks_per_frame will be 2\n    if (v->rff){\n        // repeat field\n        s->current_picture_ptr->f.repeat_pict = 1;\n    }else if (v->rptfrm){\n        // repeat frames\n        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;\n    }\n\n    // for skipping the frame\n    s->current_picture.f.pict_type = s->pict_type;\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    /* skip B-frames if we don't have reference frames */\n    if(s->last_picture_ptr==NULL && (s->pict_type==AV_PICTURE_TYPE_B || s->dropable)){\n        goto err;\n    }\n    if(   (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==AV_PICTURE_TYPE_B)\n       || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=AV_PICTURE_TYPE_I)\n       ||  avctx->skip_frame >= AVDISCARD_ALL) {\n        goto end;\n    }\n\n    if(s->next_p_frame_damaged){\n        if(s->pict_type==AV_PICTURE_TYPE_B)\n            goto end;\n        else\n            s->next_p_frame_damaged=0;\n    }\n\n    if(MPV_frame_start(s, avctx) < 0) {\n        goto err;\n    }\n\n    s->me.qpel_put= s->dsp.put_qpel_pixels_tab;\n    s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab;\n\n    if ((CONFIG_VC1_VDPAU_DECODER)\n        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);\n    else if (avctx->hwaccel) {\n        if (avctx->hwaccel->start_frame(avctx, buf, buf_size) < 0)\n            goto err;\n        if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n            goto err;\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            goto err;\n    } else {\n        ff_er_frame_start(s);\n\n        v->bits = buf_size * 8;\n        for (i = 0; i <= n_slices; i++) {\n            if (i && get_bits1(&s->gb))\n                vc1_parse_frame_header_adv(v, &s->gb);\n            s->start_mb_y = (i == 0)        ? 0 : FFMAX(0, slices[i-1].mby_start);\n            s->end_mb_y   = (i == n_slices) ? s->mb_height : FFMIN(s->mb_height, slices[i].mby_start);\n            vc1_decode_blocks(v);\n            if (i != n_slices) s->gb = slices[i].gb;\n        }\n//av_log(s->avctx, AV_LOG_INFO, \"Consumed %i/%i bits\\n\", get_bits_count(&s->gb), s->gb.size_in_bits);\n//  if(get_bits_count(&s->gb) > buf_size * 8)\n//      return -1;\n        ff_er_frame_end(s);\n    }\n\n    MPV_frame_end(s);\n\nassert(s->current_picture.f.pict_type == s->current_picture_ptr->f.pict_type);\nassert(s->current_picture.f.pict_type == s->pict_type);\n\n    if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) {\nimage:\n        avctx->width  = avctx->coded_width  = v->output_width;\n        avctx->height = avctx->coded_height = v->output_height;\n        if (avctx->skip_frame >= AVDISCARD_NONREF) goto end;\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n        if (vc1_decode_sprites(v, &s->gb)) goto err;\n#endif\n        *pict = v->sprite_output_frame;\n        *data_size = sizeof(AVFrame);\n    } else {\n\n    if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n        *pict= *(AVFrame*)s->current_picture_ptr;\n    } else if (s->last_picture_ptr != NULL) {\n        *pict= *(AVFrame*)s->last_picture_ptr;\n    }\n\n    if(s->last_picture_ptr || s->low_delay){\n        *data_size = sizeof(AVFrame);\n        ff_print_debug_info(s, pict);\n    }\n\n    }\n\nend:\n    av_free(buf2);\n    for (i = 0; i < n_slices; i++)\n        av_free(slices[i].buf);\n    av_free(slices);\n    return buf_size;\n\nerr:\n    av_free(buf2);\n    for (i = 0; i < n_slices; i++)\n        av_free(slices[i].buf);\n    av_free(slices);\n    return -1;\n}", "patch_func_code": "static int vc1_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size, n_slices = 0, i;\n    VC1Context *v = avctx->priv_data;\n    MpegEncContext *s = &v->s;\n    AVFrame *pict = data;\n    uint8_t *buf2 = NULL;\n    const uint8_t *buf_start = buf;\n    struct {\n        uint8_t *buf;\n        GetBitContext gb;\n        int mby_start;\n    } *slices = NULL;\n\n    /* no supplementary picture */\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {\n        /* special case for last picture */\n        if (s->low_delay==0 && s->next_picture_ptr) {\n            *pict= *(AVFrame*)s->next_picture_ptr;\n            s->next_picture_ptr= NULL;\n\n            *data_size = sizeof(AVFrame);\n        }\n\n        return 0;\n    }\n\n    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n        if (v->profile < PROFILE_ADVANCED)\n            avctx->pix_fmt = PIX_FMT_VDPAU_WMV3;\n        else\n            avctx->pix_fmt = PIX_FMT_VDPAU_VC1;\n    }\n\n    //for advanced profile we may need to parse and unescape data\n    if (avctx->codec_id == CODEC_ID_VC1 || avctx->codec_id == CODEC_ID_VC1IMAGE) {\n        int buf_size2 = 0;\n        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if(IS_MARKER(AV_RB32(buf))){ /* frame starts with marker and needs to be parsed */\n            const uint8_t *start, *end, *next;\n            int size;\n\n            next = buf;\n            for(start = buf, end = buf + buf_size; next < end; start = next){\n                next = find_next_marker(start + 4, end);\n                size = next - start - 4;\n                if(size <= 0) continue;\n                switch(AV_RB32(start)){\n                case VC1_CODE_FRAME:\n                    if (avctx->hwaccel ||\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n                        buf_start = start;\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n                    break;\n                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n                    init_get_bits(&s->gb, buf2, buf_size2*8);\n                    vc1_decode_entry_point(avctx, v, &s->gb);\n                    break;\n                case VC1_CODE_SLICE: {\n                    int buf_size3;\n                    slices = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n                    if (!slices) goto err;\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n                    if (!slices[n_slices].buf) goto err;\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n                                                    slices[n_slices].buf);\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n                                  buf_size3 << 3);\n                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);\n                    n_slices++;\n                    break;\n                }\n                }\n            }\n        }else if(v->interlace && ((buf[0] & 0xC0) == 0xC0)){ /* WVC1 interlaced stores both fields divided by marker */\n            const uint8_t *divider;\n\n            divider = find_next_marker(buf, buf + buf_size);\n            if((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD){\n                av_log(avctx, AV_LOG_ERROR, \"Error in WVC1 interlaced frame\\n\");\n                goto err;\n            }\n\n            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);\n            // TODO\n            if(!v->warn_interlaced++)\n                av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced WVC1 support is not implemented\\n\");\n            goto err;\n        }else{\n            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);\n        }\n        init_get_bits(&s->gb, buf2, buf_size2*8);\n    } else\n        init_get_bits(&s->gb, buf, buf_size*8);\n\n    if (v->res_sprite) {\n        v->new_sprite = !get_bits1(&s->gb);\n        v->two_sprites = get_bits1(&s->gb);\n        /* res_sprite means a Windows Media Image stream, CODEC_ID_*IMAGE means\n           we're using the sprite compositor. These are intentionally kept separate\n           so you can get the raw sprites by using the wmv3 decoder for WMVP or\n           the vc1 one for WVP2 */\n        if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) {\n            if (v->new_sprite) {\n                // switch AVCodecContext parameters to those of the sprites\n                avctx->width  = avctx->coded_width  = v->sprite_width;\n                avctx->height = avctx->coded_height = v->sprite_height;\n            } else {\n                goto image;\n            }\n        }\n    }\n\n    if (s->context_initialized &&\n        (s->width  != avctx->coded_width ||\n         s->height != avctx->coded_height)) {\n        vc1_decode_end(avctx);\n    }\n\n    if (!s->context_initialized) {\n        if (ff_msmpeg4_decode_init(avctx) < 0 || vc1_decode_init_alloc_tables(v) < 0)\n            return -1;\n\n        s->low_delay = !avctx->has_b_frames || v->res_sprite;\n\n        if (v->profile == PROFILE_ADVANCED) {\n            s->h_edge_pos = avctx->coded_width;\n            s->v_edge_pos = avctx->coded_height;\n        }\n    }\n\n    /* We need to set current_picture_ptr before reading the header,\n     * otherwise we cannot store anything in there. */\n    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {\n        int i= ff_find_unused_picture(s, 0);\n        s->current_picture_ptr= &s->picture[i];\n    }\n\n    // do parse frame header\n    if(v->profile < PROFILE_ADVANCED) {\n        if(vc1_parse_frame_header(v, &s->gb) == -1) {\n            goto err;\n        }\n    } else {\n        if(vc1_parse_frame_header_adv(v, &s->gb) == -1) {\n            goto err;\n        }\n    }\n\n    if ((avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE)\n        && s->pict_type!=AV_PICTURE_TYPE_I) {\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Sprite decoder: expected I-frame\\n\");\n        goto err;\n    }\n\n    // process pulldown flags\n    s->current_picture_ptr->f.repeat_pict = 0;\n    // Pulldown flags are only valid when 'broadcast' has been set.\n    // So ticks_per_frame will be 2\n    if (v->rff){\n        // repeat field\n        s->current_picture_ptr->f.repeat_pict = 1;\n    }else if (v->rptfrm){\n        // repeat frames\n        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;\n    }\n\n    // for skipping the frame\n    s->current_picture.f.pict_type = s->pict_type;\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n    /* skip B-frames if we don't have reference frames */\n    if(s->last_picture_ptr==NULL && (s->pict_type==AV_PICTURE_TYPE_B || s->dropable)){\n        goto err;\n    }\n    if(   (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==AV_PICTURE_TYPE_B)\n       || (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=AV_PICTURE_TYPE_I)\n       ||  avctx->skip_frame >= AVDISCARD_ALL) {\n        goto end;\n    }\n\n    if(s->next_p_frame_damaged){\n        if(s->pict_type==AV_PICTURE_TYPE_B)\n            goto end;\n        else\n            s->next_p_frame_damaged=0;\n    }\n\n    if(MPV_frame_start(s, avctx) < 0) {\n        goto err;\n    }\n\n    s->me.qpel_put= s->dsp.put_qpel_pixels_tab;\n    s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab;\n\n    if ((CONFIG_VC1_VDPAU_DECODER)\n        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);\n    else if (avctx->hwaccel) {\n        if (avctx->hwaccel->start_frame(avctx, buf, buf_size) < 0)\n            goto err;\n        if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n            goto err;\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            goto err;\n    } else {\n        ff_er_frame_start(s);\n\n        v->bits = buf_size * 8;\n        for (i = 0; i <= n_slices; i++) {\n            if (i && get_bits1(&s->gb))\n                vc1_parse_frame_header_adv(v, &s->gb);\n            s->start_mb_y = (i == 0)        ? 0 : FFMAX(0, slices[i-1].mby_start);\n            s->end_mb_y   = (i == n_slices) ? s->mb_height : FFMIN(s->mb_height, slices[i].mby_start);\n            vc1_decode_blocks(v);\n            if (i != n_slices) s->gb = slices[i].gb;\n        }\n//av_log(s->avctx, AV_LOG_INFO, \"Consumed %i/%i bits\\n\", get_bits_count(&s->gb), s->gb.size_in_bits);\n//  if(get_bits_count(&s->gb) > buf_size * 8)\n//      return -1;\n        ff_er_frame_end(s);\n    }\n\n    MPV_frame_end(s);\n\nassert(s->current_picture.f.pict_type == s->current_picture_ptr->f.pict_type);\nassert(s->current_picture.f.pict_type == s->pict_type);\n\n    if (avctx->codec_id == CODEC_ID_WMV3IMAGE || avctx->codec_id == CODEC_ID_VC1IMAGE) {\nimage:\n        avctx->width  = avctx->coded_width  = v->output_width;\n        avctx->height = avctx->coded_height = v->output_height;\n        if (avctx->skip_frame >= AVDISCARD_NONREF) goto end;\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n        if (vc1_decode_sprites(v, &s->gb)) goto err;\n#endif\n        *pict = v->sprite_output_frame;\n        *data_size = sizeof(AVFrame);\n    } else {\n\n    if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n        *pict= *(AVFrame*)s->current_picture_ptr;\n    } else if (s->last_picture_ptr != NULL) {\n        *pict= *(AVFrame*)s->last_picture_ptr;\n    }\n\n    if(s->last_picture_ptr || s->low_delay){\n        *data_size = sizeof(AVFrame);\n        ff_print_debug_info(s, pict);\n    }\n\n    }\n\nend:\n    av_free(buf2);\n    for (i = 0; i < n_slices; i++)\n        av_free(slices[i].buf);\n    av_free(slices);\n    return buf_size;\n\nerr:\n    av_free(buf2);\n    for (i = 0; i < n_slices; i++)\n        av_free(slices[i].buf);\n    av_free(slices);\n    return -1;\n}", "before_change_lines": [32, 33, 34, 35, 36], "raw_before_change_lines": [31, 32, 33, 34, 35, 36, 37], "after_change_lines": [119, 120, 121, 122, 123, 125, 126, 127, 129, 131, 132, 133, 134, 135, 138, 139, 140, 141, 142], "raw_after_change_lines": [119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143], "bug_lines": [31, 32, 33, 34, 35, 36, 37], "added": [false, false, false, false, false, false, false], "idx": 257}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6243----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4d7ad59a43f9c77d269708749d9cffbf15147492_1.json----h264_filter_mb_fast_internal", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4d7ad59a43f9c77d269708749d9cffbf15147492_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4d7ad59a43f9c77d269708749d9cffbf15147492_1.json", "function_name": "h264_filter_mb_fast_internal", "vul_func_code": "static av_always_inline void h264_filter_mb_fast_internal(H264Context *h,\n                                                          int mb_x, int mb_y,\n                                                          uint8_t *img_y,\n                                                          uint8_t *img_cb,\n                                                          uint8_t *img_cr,\n                                                          unsigned int linesize,\n                                                          unsigned int uvlinesize,\n                                                          int pixel_shift)\n{\n    MpegEncContext * const s = &h->s;\n    int chroma = !(CONFIG_GRAY && (s->flags&CODEC_FLAG_GRAY));\n    int chroma444 = CHROMA444;\n    int chroma422 = CHROMA422;\n\n    int mb_xy = h->mb_xy;\n    int left_type= h->left_type[LTOP];\n    int top_type= h->top_type;\n\n    int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n    int a = h->slice_alpha_c0_offset - qp_bd_offset;\n    int b = h->slice_beta_offset - qp_bd_offset;\n\n    int mb_type = s->current_picture.f.mb_type[mb_xy];\n    int qp      = s->current_picture.f.qscale_table[mb_xy];\n    int qp0     = s->current_picture.f.qscale_table[mb_xy - 1];\n    int qp1     = s->current_picture.f.qscale_table[h->top_mb_xy];\n    int qpc = get_chroma_qp( h, 0, qp );\n    int qpc0 = get_chroma_qp( h, 0, qp0 );\n    int qpc1 = get_chroma_qp( h, 0, qp1 );\n    qp0 = (qp + qp0 + 1) >> 1;\n    qp1 = (qp + qp1 + 1) >> 1;\n    qpc0 = (qpc + qpc0 + 1) >> 1;\n    qpc1 = (qpc + qpc1 + 1) >> 1;\n\n    if( IS_INTRA(mb_type) ) {\n        static const int16_t bS4[4] = {4,4,4,4};\n        static const int16_t bS3[4] = {3,3,3,3};\n        const int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;\n        if(left_type)\n            filter_mb_edgev( &img_y[4*0<<pixel_shift], linesize, bS4, qp0, a, b, h, 1);\n        if( IS_8x8DCT(mb_type) ) {\n            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            if(top_type){\n                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);\n            }\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);\n        } else {\n            filter_mb_edgev( &img_y[4*1<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgev( &img_y[4*3<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            if(top_type){\n                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);\n            }\n            filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, a, b, h, 0);\n        }\n        if(chroma){\n            if(chroma444){\n                if(left_type){\n                    filter_mb_edgev( &img_cb[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);\n                    filter_mb_edgev( &img_cr[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);\n                }\n                if( IS_8x8DCT(mb_type) ) {\n                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    if(top_type){\n                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );\n                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );\n                    }\n                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                } else {\n                    filter_mb_edgev( &img_cb[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cb[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    if(top_type){\n                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);\n                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);\n                    }\n                    filter_mb_edgeh( &img_cb[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cb[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);\n                }\n            }else if(chroma422){\n                if(left_type){\n                    filter_mb_edgecv(&img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                    filter_mb_edgecv(&img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                }\n                filter_mb_edgecv(&img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgecv(&img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                if(top_type){\n                    filter_mb_edgech(&img_cb[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                    filter_mb_edgech(&img_cr[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                }\n                filter_mb_edgech(&img_cb[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cr[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cb[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cr[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cb[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cr[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n            }else{\n                if(left_type){\n                    filter_mb_edgecv( &img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                    filter_mb_edgecv( &img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                }\n                filter_mb_edgecv( &img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgecv( &img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                if(top_type){\n                    filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                    filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                }\n                filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n            }\n        }\n        return;\n    } else {\n        LOCAL_ALIGNED_8(int16_t, bS, [2], [4][4]);\n        int edges;\n        if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 && !chroma444 ) {\n            edges = 4;\n            AV_WN64A(bS[0][0], 0x0002000200020002ULL);\n            AV_WN64A(bS[0][2], 0x0002000200020002ULL);\n            AV_WN64A(bS[1][0], 0x0002000200020002ULL);\n            AV_WN64A(bS[1][2], 0x0002000200020002ULL);\n        } else {\n            int mask_edge1 = (3*(((5*mb_type)>>5)&1)) | (mb_type>>4); //(mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : (mb_type & MB_TYPE_16x8) ? 1 : 0;\n            int mask_edge0 = 3*((mask_edge1>>1) & ((5*left_type)>>5)&1); // (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) && (h->left_type[LTOP] & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : 0;\n            int step =  1+(mb_type>>24); //IS_8x8DCT(mb_type) ? 2 : 1;\n            edges = 4 - 3*((mb_type>>3) & !(h->cbp & 15)); //(mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;\n            h->h264dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,\n                                              h->list_count==2, edges, step, mask_edge0, mask_edge1, FIELD_PICTURE);\n        }\n        if( IS_INTRA(left_type) )\n            AV_WN64A(bS[0][0], 0x0004000400040004ULL);\n        if( IS_INTRA(top_type) )\n            AV_WN64A(bS[1][0], FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL);\n\n#define FILTER(hv,dir,edge,intra)\\\n        if(AV_RN64A(bS[dir][edge])) {                                   \\\n            filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qp : qp##dir, a, b, h, intra );\\\n            if(chroma){\\\n                if(chroma444){\\\n                    filter_mb_edge##hv( &img_cb[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                    filter_mb_edge##hv( &img_cr[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                } else if(!(edge&1)) {\\\n                    filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                    filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                }\\\n            }\\\n        }\n        if(left_type)\n            FILTER(v,0,0,1);\n        if( edges == 1 ) {\n            if(top_type)\n                FILTER(h,1,0,1);\n        } else if( IS_8x8DCT(mb_type) ) {\n            FILTER(v,0,2,0);\n            if(top_type)\n                FILTER(h,1,0,1);\n            FILTER(h,1,2,0);\n        } else {\n            FILTER(v,0,1,0);\n            FILTER(v,0,2,0);\n            FILTER(v,0,3,0);\n            if(top_type)\n                FILTER(h,1,0,1);\n            FILTER(h,1,1,0);\n            FILTER(h,1,2,0);\n            FILTER(h,1,3,0);\n        }\n#undef FILTER\n    }\n}", "patch_func_code": "static av_always_inline void h264_filter_mb_fast_internal(H264Context *h,\n                                                          int mb_x, int mb_y,\n                                                          uint8_t *img_y,\n                                                          uint8_t *img_cb,\n                                                          uint8_t *img_cr,\n                                                          unsigned int linesize,\n                                                          unsigned int uvlinesize,\n                                                          int pixel_shift)\n{\n    int chroma = !(CONFIG_GRAY && (h->flags&CODEC_FLAG_GRAY));\n    int chroma444 = CHROMA444;\n    int chroma422 = CHROMA422;\n\n    int mb_xy = h->mb_xy;\n    int left_type= h->left_type[LTOP];\n    int top_type= h->top_type;\n\n    int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n    int a = h->slice_alpha_c0_offset - qp_bd_offset;\n    int b = h->slice_beta_offset - qp_bd_offset;\n\n    int mb_type = h->cur_pic.f.mb_type[mb_xy];\n    int qp      = h->cur_pic.f.qscale_table[mb_xy];\n    int qp0     = h->cur_pic.f.qscale_table[mb_xy - 1];\n    int qp1     = h->cur_pic.f.qscale_table[h->top_mb_xy];\n    int qpc = get_chroma_qp( h, 0, qp );\n    int qpc0 = get_chroma_qp( h, 0, qp0 );\n    int qpc1 = get_chroma_qp( h, 0, qp1 );\n    qp0 = (qp + qp0 + 1) >> 1;\n    qp1 = (qp + qp1 + 1) >> 1;\n    qpc0 = (qpc + qpc0 + 1) >> 1;\n    qpc1 = (qpc + qpc1 + 1) >> 1;\n\n    if( IS_INTRA(mb_type) ) {\n        static const int16_t bS4[4] = {4,4,4,4};\n        static const int16_t bS3[4] = {3,3,3,3};\n        const int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;\n        if(left_type)\n            filter_mb_edgev( &img_y[4*0<<pixel_shift], linesize, bS4, qp0, a, b, h, 1);\n        if( IS_8x8DCT(mb_type) ) {\n            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            if(top_type){\n                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);\n            }\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);\n        } else {\n            filter_mb_edgev( &img_y[4*1<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgev( &img_y[4*2<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgev( &img_y[4*3<<pixel_shift], linesize, bS3, qp, a, b, h, 0);\n            if(top_type){\n                filter_mb_edgeh( &img_y[4*0*linesize], linesize, bSH, qp1, a, b, h, 1);\n            }\n            filter_mb_edgeh( &img_y[4*1*linesize], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgeh( &img_y[4*2*linesize], linesize, bS3, qp, a, b, h, 0);\n            filter_mb_edgeh( &img_y[4*3*linesize], linesize, bS3, qp, a, b, h, 0);\n        }\n        if(chroma){\n            if(chroma444){\n                if(left_type){\n                    filter_mb_edgev( &img_cb[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);\n                    filter_mb_edgev( &img_cr[4*0<<pixel_shift], linesize, bS4, qpc0, a, b, h, 1);\n                }\n                if( IS_8x8DCT(mb_type) ) {\n                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    if(top_type){\n                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );\n                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1 );\n                    }\n                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                } else {\n                    filter_mb_edgev( &img_cb[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*1<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cb[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*2<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cb[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgev( &img_cr[4*3<<pixel_shift], linesize, bS3, qpc, a, b, h, 0);\n                    if(top_type){\n                        filter_mb_edgeh( &img_cb[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);\n                        filter_mb_edgeh( &img_cr[4*0*linesize], linesize, bSH, qpc1, a, b, h, 1);\n                    }\n                    filter_mb_edgeh( &img_cb[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*1*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cb[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*2*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cb[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);\n                    filter_mb_edgeh( &img_cr[4*3*linesize], linesize, bS3, qpc, a, b, h, 0);\n                }\n            }else if(chroma422){\n                if(left_type){\n                    filter_mb_edgecv(&img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                    filter_mb_edgecv(&img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                }\n                filter_mb_edgecv(&img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgecv(&img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                if(top_type){\n                    filter_mb_edgech(&img_cb[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                    filter_mb_edgech(&img_cr[4*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                }\n                filter_mb_edgech(&img_cb[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cr[4*1*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cb[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cr[4*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cb[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech(&img_cr[4*3*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n            }else{\n                if(left_type){\n                    filter_mb_edgecv( &img_cb[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                    filter_mb_edgecv( &img_cr[2*0<<pixel_shift], uvlinesize, bS4, qpc0, a, b, h, 1);\n                }\n                filter_mb_edgecv( &img_cb[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgecv( &img_cr[2*2<<pixel_shift], uvlinesize, bS3, qpc, a, b, h, 0);\n                if(top_type){\n                    filter_mb_edgech( &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                    filter_mb_edgech( &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1, a, b, h, 1);\n                }\n                filter_mb_edgech( &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n                filter_mb_edgech( &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc, a, b, h, 0);\n            }\n        }\n        return;\n    } else {\n        LOCAL_ALIGNED_8(int16_t, bS, [2], [4][4]);\n        int edges;\n        if( IS_8x8DCT(mb_type) && (h->cbp&7) == 7 && !chroma444 ) {\n            edges = 4;\n            AV_WN64A(bS[0][0], 0x0002000200020002ULL);\n            AV_WN64A(bS[0][2], 0x0002000200020002ULL);\n            AV_WN64A(bS[1][0], 0x0002000200020002ULL);\n            AV_WN64A(bS[1][2], 0x0002000200020002ULL);\n        } else {\n            int mask_edge1 = (3*(((5*mb_type)>>5)&1)) | (mb_type>>4); //(mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : (mb_type & MB_TYPE_16x8) ? 1 : 0;\n            int mask_edge0 = 3*((mask_edge1>>1) & ((5*left_type)>>5)&1); // (mb_type & (MB_TYPE_16x16 | MB_TYPE_8x16)) && (h->left_type[LTOP] & (MB_TYPE_16x16 | MB_TYPE_8x16)) ? 3 : 0;\n            int step =  1+(mb_type>>24); //IS_8x8DCT(mb_type) ? 2 : 1;\n            edges = 4 - 3*((mb_type>>3) & !(h->cbp & 15)); //(mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;\n            h->h264dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,\n                                              h->list_count==2, edges, step, mask_edge0, mask_edge1, FIELD_PICTURE);\n        }\n        if( IS_INTRA(left_type) )\n            AV_WN64A(bS[0][0], 0x0004000400040004ULL);\n        if( IS_INTRA(top_type) )\n            AV_WN64A(bS[1][0], FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL);\n\n#define FILTER(hv,dir,edge,intra)\\\n        if(AV_RN64A(bS[dir][edge])) {                                   \\\n            filter_mb_edge##hv( &img_y[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qp : qp##dir, a, b, h, intra );\\\n            if(chroma){\\\n                if(chroma444){\\\n                    filter_mb_edge##hv( &img_cb[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                    filter_mb_edge##hv( &img_cr[4*edge*(dir?linesize:1<<pixel_shift)], linesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                } else if(!(edge&1)) {\\\n                    filter_mb_edgec##hv( &img_cb[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                    filter_mb_edgec##hv( &img_cr[2*edge*(dir?uvlinesize:1<<pixel_shift)], uvlinesize, bS[dir][edge], edge ? qpc : qpc##dir, a, b, h, intra );\\\n                }\\\n            }\\\n        }\n        if(left_type)\n            FILTER(v,0,0,1);\n        if( edges == 1 ) {\n            if(top_type)\n                FILTER(h,1,0,1);\n        } else if( IS_8x8DCT(mb_type) ) {\n            FILTER(v,0,2,0);\n            if(top_type)\n                FILTER(h,1,0,1);\n            FILTER(h,1,2,0);\n        } else {\n            FILTER(v,0,1,0);\n            FILTER(v,0,2,0);\n            FILTER(v,0,3,0);\n            if(top_type)\n                FILTER(h,1,0,1);\n            FILTER(h,1,1,0);\n            FILTER(h,1,2,0);\n            FILTER(h,1,3,0);\n        }\n#undef FILTER\n    }\n}", "before_change_lines": [10, 11, 23, 24, 25, 26], "raw_before_change_lines": [10, 11, 23, 24, 25, 26], "after_change_lines": [10, 22, 23, 24, 25], "raw_after_change_lines": [10, 22, 23, 24, 25], "bug_lines": [10, 11, 23, 24, 25, 26], "added": [false, false, false, false, false, false], "idx": 258}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6248----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4ddb9614b2eabf855f065fd3ce2ebbb65a8a910c_1.json----mxf_edit_unit_absolute_offset", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_4ddb9614b2eabf855f065fd3ce2ebbb65a8a910c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_4ddb9614b2eabf855f065fd3ce2ebbb65a8a910c_1.json", "function_name": "mxf_edit_unit_absolute_offset", "vul_func_code": "static int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag)\n{\n    int i;\n    int offset_temp = 0;\n\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        edit_unit = FFMAX(edit_unit, s->index_start_position);  /* clamp if trying to seek before start */\n\n        if (edit_unit < s->index_start_position + s->index_duration) {\n            int64_t index = edit_unit - s->index_start_position;\n\n            if (s->edit_unit_byte_count)\n                offset_temp += s->edit_unit_byte_count * index;\n            else if (s->nb_index_entries) {\n                if (s->nb_index_entries == 2 * s->index_duration + 1)\n                    index *= 2;     /* Avid index */\n\n                if (index < 0 || index > s->nb_index_entries) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" IndexEntryArray too small\\n\",\n                           index_table->index_sid, s->index_start_position);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                offset_temp = s->stream_offset_entries[index];\n            } else {\n                av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" missing EditUnitByteCount and IndexEntryArray\\n\",\n                       index_table->index_sid, s->index_start_position);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (edit_unit_out)\n                *edit_unit_out = edit_unit;\n\n            return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out);\n        } else {\n            /* EditUnitByteCount == 0 for VBR indexes, which is fine since they use explicit StreamOffsets */\n            offset_temp += s->edit_unit_byte_count * s->index_duration;\n        }\n    }\n\n    if (nag)\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to map EditUnit %\"PRId64\" in IndexSID %i to an offset\\n\", edit_unit, index_table->index_sid);\n\n    return AVERROR_INVALIDDATA;\n}", "patch_func_code": "static int mxf_edit_unit_absolute_offset(MXFContext *mxf, MXFIndexTable *index_table, int64_t edit_unit, int64_t *edit_unit_out, int64_t *offset_out, int nag)\n{\n    int i;\n    int64_t offset_temp = 0;\n\n    for (i = 0; i < index_table->nb_segments; i++) {\n        MXFIndexTableSegment *s = index_table->segments[i];\n\n        edit_unit = FFMAX(edit_unit, s->index_start_position);  /* clamp if trying to seek before start */\n\n        if (edit_unit < s->index_start_position + s->index_duration) {\n            int64_t index = edit_unit - s->index_start_position;\n\n            if (s->edit_unit_byte_count)\n                offset_temp += s->edit_unit_byte_count * index;\n            else if (s->nb_index_entries) {\n                if (s->nb_index_entries == 2 * s->index_duration + 1)\n                    index *= 2;     /* Avid index */\n\n                if (index < 0 || index > s->nb_index_entries) {\n                    av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" IndexEntryArray too small\\n\",\n                           index_table->index_sid, s->index_start_position);\n                    return AVERROR_INVALIDDATA;\n                }\n\n                offset_temp = s->stream_offset_entries[index];\n            } else {\n                av_log(mxf->fc, AV_LOG_ERROR, \"IndexSID %i segment at %\"PRId64\" missing EditUnitByteCount and IndexEntryArray\\n\",\n                       index_table->index_sid, s->index_start_position);\n                return AVERROR_INVALIDDATA;\n            }\n\n            if (edit_unit_out)\n                *edit_unit_out = edit_unit;\n\n            return mxf_absolute_bodysid_offset(mxf, index_table->body_sid, offset_temp, offset_out);\n        } else {\n            /* EditUnitByteCount == 0 for VBR indexes, which is fine since they use explicit StreamOffsets */\n            offset_temp += s->edit_unit_byte_count * s->index_duration;\n        }\n    }\n\n    if (nag)\n        av_log(mxf->fc, AV_LOG_ERROR, \"failed to map EditUnit %\"PRId64\" in IndexSID %i to an offset\\n\", edit_unit, index_table->index_sid);\n\n    return AVERROR_INVALIDDATA;\n}", "before_change_lines": [4], "raw_before_change_lines": [4], "after_change_lines": [4], "raw_after_change_lines": [4], "bug_lines": [4], "added": [false], "idx": 259}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6322----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_52d8fffb6087291873f3beed41d40905d3bbed6c_1.json----render_line_unrolled", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_52d8fffb6087291873f3beed41d40905d3bbed6c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_52d8fffb6087291873f3beed41d40905d3bbed6c_1.json", "function_name": "render_line_unrolled", "vul_func_code": "static inline void render_line_unrolled(intptr_t x, intptr_t y, int x1,\n                                        intptr_t sy, int ady, int adx,\n                                        float *buf)\n{\n    int err = -adx;\n    x -= x1 - 1;\n    buf += x1 - 1;\n    while (++x < 0) {\n        err += ady;\n        if (err >= 0) {\n            err += ady - adx;\n            y   += sy;\n            buf[x++] = ff_vorbis_floor1_inverse_db_table[y];\n        }\n        buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n    }\n    if (x <= 0) {\n        if (err + ady >= 0)\n            y += sy;\n        buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n    }\n}", "patch_func_code": "static inline void render_line_unrolled(intptr_t x, uint8_t y, int x1,\n                                        intptr_t sy, int ady, int adx,\n                                        float *buf)\n{\n    int err = -adx;\n    x -= x1 - 1;\n    buf += x1 - 1;\n    while (++x < 0) {\n        err += ady;\n        if (err >= 0) {\n            err += ady - adx;\n            y   += sy;\n            buf[x++] = ff_vorbis_floor1_inverse_db_table[y];\n        }\n        buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n    }\n    if (x <= 0) {\n        if (err + ady >= 0)\n            y += sy;\n        buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n    }\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1], "raw_after_change_lines": [1], "bug_lines": [1], "added": [false], "idx": 260}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6373----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5554557039ad9bee0d2960b94281a2380cf2c734_1.json----read_sbr_extension", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_5554557039ad9bee0d2960b94281a2380cf2c734_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5554557039ad9bee0d2960b94281a2380cf2c734_1.json", "function_name": "read_sbr_extension", "vul_func_code": "static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,\n                               GetBitContext *gb,\n                               int bs_extension_id, int *num_bits_left)\n{\n    switch (bs_extension_id) {\n    case EXTENSION_ID_PS:\n        if (!ac->m4ac.ps) {\n            av_log(ac->avctx, AV_LOG_ERROR, \"Parametric Stereo signaled to be not-present but was found in the bitstream.\\n\");\n            skip_bits_long(gb, *num_bits_left); // bs_fill_bits\n            *num_bits_left = 0;\n        } else {\n#if 1\n            *num_bits_left -= ff_ps_read_data(ac->avctx, gb, &sbr->ps, *num_bits_left);\n#else\n            av_log_missing_feature(ac->avctx, \"Parametric Stereo is\", 0);\n            skip_bits_long(gb, *num_bits_left); // bs_fill_bits\n            *num_bits_left = 0;\n#endif\n        }\n        break;\n    default:\n        av_log_missing_feature(ac->avctx, \"Reserved SBR extensions are\", 1);\n        skip_bits_long(gb, *num_bits_left); // bs_fill_bits\n        *num_bits_left = 0;\n        break;\n    }\n}", "patch_func_code": "static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,\n                               GetBitContext *gb,\n                               int bs_extension_id, int *num_bits_left)\n{\n    switch (bs_extension_id) {\n    case EXTENSION_ID_PS:\n        if (!ac->oc[1].m4ac.ps) {\n            av_log(ac->avctx, AV_LOG_ERROR, \"Parametric Stereo signaled to be not-present but was found in the bitstream.\\n\");\n            skip_bits_long(gb, *num_bits_left); // bs_fill_bits\n            *num_bits_left = 0;\n        } else {\n#if 1\n            *num_bits_left -= ff_ps_read_data(ac->avctx, gb, &sbr->ps, *num_bits_left);\n#else\n            av_log_missing_feature(ac->avctx, \"Parametric Stereo is\", 0);\n            skip_bits_long(gb, *num_bits_left); // bs_fill_bits\n            *num_bits_left = 0;\n#endif\n        }\n        break;\n    default:\n        av_log_missing_feature(ac->avctx, \"Reserved SBR extensions are\", 1);\n        skip_bits_long(gb, *num_bits_left); // bs_fill_bits\n        *num_bits_left = 0;\n        break;\n    }\n}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 261}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6477----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5bdac01f9e24b0d4f53250a3f9baba6813be2f1e_1.json----vorbis_parse_setup_hdr_floors", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_5bdac01f9e24b0d4f53250a3f9baba6813be2f1e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5bdac01f9e24b0d4f53250a3f9baba6813be2f1e_1.json", "function_name": "vorbis_parse_setup_hdr_floors", "vul_func_code": "static int vorbis_parse_setup_hdr_floors(vorbis_context *vc)\n{\n    GetBitContext *gb = &vc->gb;\n    int i,j,k;\n\n    vc->floor_count = get_bits(gb, 6) + 1;\n\n    vc->floors = av_mallocz(vc->floor_count * sizeof(*vc->floors));\n\n    for (i = 0; i < vc->floor_count; ++i) {\n        vorbis_floor *floor_setup = &vc->floors[i];\n\n        floor_setup->floor_type = get_bits(gb, 16);\n\n        AV_DEBUG(\" %d. floor type %d \\n\", i, floor_setup->floor_type);\n\n        if (floor_setup->floor_type == 1) {\n            int maximum_class = -1;\n            uint_fast8_t  rangebits;\n            uint_fast32_t rangemax;\n            uint_fast16_t floor1_values = 2;\n\n            floor_setup->decode = vorbis_floor1_decode;\n\n            floor_setup->data.t1.partitions = get_bits(gb, 5);\n\n            AV_DEBUG(\" %d.floor: %d partitions \\n\", i, floor_setup->data.t1.partitions);\n\n            for (j = 0; j < floor_setup->data.t1.partitions; ++j) {\n                floor_setup->data.t1.partition_class[j] = get_bits(gb, 4);\n                if (floor_setup->data.t1.partition_class[j] > maximum_class)\n                    maximum_class = floor_setup->data.t1.partition_class[j];\n\n                AV_DEBUG(\" %d. floor %d partition class %d \\n\", i, j, floor_setup->data.t1.partition_class[j]);\n\n            }\n\n            AV_DEBUG(\" maximum class %d \\n\", maximum_class);\n\n            for (j = 0; j <= maximum_class; ++j) {\n                floor_setup->data.t1.class_dimensions[j] = get_bits(gb, 3) + 1;\n                floor_setup->data.t1.class_subclasses[j] = get_bits(gb, 2);\n\n                AV_DEBUG(\" %d floor %d class dim: %d subclasses %d \\n\", i, j, floor_setup->data.t1.class_dimensions[j], floor_setup->data.t1.class_subclasses[j]);\n\n                if (floor_setup->data.t1.class_subclasses[j]) {\n                    GET_VALIDATED_INDEX(floor_setup->data.t1.class_masterbook[j], 8, vc->codebook_count)\n\n                    AV_DEBUG(\"   masterbook: %d \\n\", floor_setup->data.t1.class_masterbook[j]);\n                }\n\n                for (k = 0; k < (1 << floor_setup->data.t1.class_subclasses[j]); ++k) {\n                    int16_t bits = get_bits(gb, 8) - 1;\n                    if (bits != -1)\n                        VALIDATE_INDEX(bits, vc->codebook_count)\n                    floor_setup->data.t1.subclass_books[j][k] = bits;\n\n                    AV_DEBUG(\"    book %d. : %d \\n\", k, floor_setup->data.t1.subclass_books[j][k]);\n                }\n            }\n\n            floor_setup->data.t1.multiplier = get_bits(gb, 2) + 1;\n            floor_setup->data.t1.x_list_dim = 2;\n\n            for (j = 0; j < floor_setup->data.t1.partitions; ++j)\n                floor_setup->data.t1.x_list_dim+=floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]];\n\n            floor_setup->data.t1.list = av_mallocz(floor_setup->data.t1.x_list_dim *\n                                                   sizeof(*floor_setup->data.t1.list));\n\n\n            rangebits = get_bits(gb, 4);\n            rangemax = (1 << rangebits);\n            if (rangemax > vc->blocksize[1] / 2) {\n                av_log(vc->avccontext, AV_LOG_ERROR,\n                       \"Floor value is too large for blocksize: %\"PRIuFAST32\" (%\"PRIuFAST32\")\\n\",\n                       rangemax, vc->blocksize[1] / 2);\n                return -1;\n            }\n            floor_setup->data.t1.list[0].x = 0;\n            floor_setup->data.t1.list[1].x = rangemax;\n\n            for (j = 0; j < floor_setup->data.t1.partitions; ++j) {\n                for (k = 0; k < floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; ++k, ++floor1_values) {\n                    floor_setup->data.t1.list[floor1_values].x = get_bits(gb, rangebits);\n\n                    AV_DEBUG(\" %d. floor1 Y coord. %d \\n\", floor1_values, floor_setup->data.t1.list[floor1_values].x);\n                }\n            }\n\n// Precalculate order of x coordinates - needed for decode\n            ff_vorbis_ready_floor1_list(floor_setup->data.t1.list, floor_setup->data.t1.x_list_dim);\n        } else if (floor_setup->floor_type == 0) {\n            uint_fast8_t max_codebook_dim = 0;\n\n            floor_setup->decode = vorbis_floor0_decode;\n\n            floor_setup->data.t0.order          = get_bits(gb,  8);\n            floor_setup->data.t0.rate           = get_bits(gb, 16);\n            floor_setup->data.t0.bark_map_size  = get_bits(gb, 16);\n            floor_setup->data.t0.amplitude_bits = get_bits(gb,  6);\n            /* zero would result in a div by zero later *\n             * 2^0 - 1 == 0                             */\n            if (floor_setup->data.t0.amplitude_bits == 0) {\n                av_log(vc->avccontext, AV_LOG_ERROR,\n                       \"Floor 0 amplitude bits is 0.\\n\");\n                return -1;\n            }\n            floor_setup->data.t0.amplitude_offset = get_bits(gb, 8);\n            floor_setup->data.t0.num_books        = get_bits(gb, 4) + 1;\n\n            /* allocate mem for booklist */\n            floor_setup->data.t0.book_list =\n                av_malloc(floor_setup->data.t0.num_books);\n            if (!floor_setup->data.t0.book_list)\n                return -1;\n            /* read book indexes */\n            {\n                int idx;\n                uint_fast8_t book_idx;\n                for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) {\n                    GET_VALIDATED_INDEX(book_idx, 8, vc->codebook_count)\n                    floor_setup->data.t0.book_list[idx] = book_idx;\n                    if (vc->codebooks[book_idx].dimensions > max_codebook_dim)\n                        max_codebook_dim = vc->codebooks[book_idx].dimensions;\n                }\n            }\n\n            create_map(vc, i);\n\n            /* codebook dim is for padding if codebook dim doesn't *\n             * divide order+1 then we need to read more data       */\n            floor_setup->data.t0.lsp =\n                av_malloc((floor_setup->data.t0.order + 1 + max_codebook_dim)\n                          * sizeof(*floor_setup->data.t0.lsp));\n            if (!floor_setup->data.t0.lsp)\n                return -1;\n\n#ifdef V_DEBUG /* debug output parsed headers */\n            AV_DEBUG(\"floor0 order: %u\\n\", floor_setup->data.t0.order);\n            AV_DEBUG(\"floor0 rate: %u\\n\", floor_setup->data.t0.rate);\n            AV_DEBUG(\"floor0 bark map size: %u\\n\",\n                     floor_setup->data.t0.bark_map_size);\n            AV_DEBUG(\"floor0 amplitude bits: %u\\n\",\n                     floor_setup->data.t0.amplitude_bits);\n            AV_DEBUG(\"floor0 amplitude offset: %u\\n\",\n                     floor_setup->data.t0.amplitude_offset);\n            AV_DEBUG(\"floor0 number of books: %u\\n\",\n                     floor_setup->data.t0.num_books);\n            AV_DEBUG(\"floor0 book list pointer: %p\\n\",\n                     floor_setup->data.t0.book_list);\n            {\n                int idx;\n                for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) {\n                    AV_DEBUG(\"  Book %d: %u\\n\",\n                             idx+1,\n                             floor_setup->data.t0.book_list[idx]);\n                }\n            }\n#endif\n        } else {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Invalid floor type!\\n\");\n            return -1;\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int vorbis_parse_setup_hdr_floors(vorbis_context *vc)\n{\n    GetBitContext *gb = &vc->gb;\n    int i,j,k;\n\n    vc->floor_count = get_bits(gb, 6) + 1;\n\n    vc->floors = av_mallocz(vc->floor_count * sizeof(*vc->floors));\n\n    for (i = 0; i < vc->floor_count; ++i) {\n        vorbis_floor *floor_setup = &vc->floors[i];\n\n        floor_setup->floor_type = get_bits(gb, 16);\n\n        AV_DEBUG(\" %d. floor type %d \\n\", i, floor_setup->floor_type);\n\n        if (floor_setup->floor_type == 1) {\n            int maximum_class = -1;\n            unsigned rangebits, rangemax, floor1_values = 2;\n\n            floor_setup->decode = vorbis_floor1_decode;\n\n            floor_setup->data.t1.partitions = get_bits(gb, 5);\n\n            AV_DEBUG(\" %d.floor: %d partitions \\n\", i, floor_setup->data.t1.partitions);\n\n            for (j = 0; j < floor_setup->data.t1.partitions; ++j) {\n                floor_setup->data.t1.partition_class[j] = get_bits(gb, 4);\n                if (floor_setup->data.t1.partition_class[j] > maximum_class)\n                    maximum_class = floor_setup->data.t1.partition_class[j];\n\n                AV_DEBUG(\" %d. floor %d partition class %d \\n\", i, j, floor_setup->data.t1.partition_class[j]);\n\n            }\n\n            AV_DEBUG(\" maximum class %d \\n\", maximum_class);\n\n            for (j = 0; j <= maximum_class; ++j) {\n                floor_setup->data.t1.class_dimensions[j] = get_bits(gb, 3) + 1;\n                floor_setup->data.t1.class_subclasses[j] = get_bits(gb, 2);\n\n                AV_DEBUG(\" %d floor %d class dim: %d subclasses %d \\n\", i, j, floor_setup->data.t1.class_dimensions[j], floor_setup->data.t1.class_subclasses[j]);\n\n                if (floor_setup->data.t1.class_subclasses[j]) {\n                    GET_VALIDATED_INDEX(floor_setup->data.t1.class_masterbook[j], 8, vc->codebook_count)\n\n                    AV_DEBUG(\"   masterbook: %d \\n\", floor_setup->data.t1.class_masterbook[j]);\n                }\n\n                for (k = 0; k < (1 << floor_setup->data.t1.class_subclasses[j]); ++k) {\n                    int16_t bits = get_bits(gb, 8) - 1;\n                    if (bits != -1)\n                        VALIDATE_INDEX(bits, vc->codebook_count)\n                    floor_setup->data.t1.subclass_books[j][k] = bits;\n\n                    AV_DEBUG(\"    book %d. : %d \\n\", k, floor_setup->data.t1.subclass_books[j][k]);\n                }\n            }\n\n            floor_setup->data.t1.multiplier = get_bits(gb, 2) + 1;\n            floor_setup->data.t1.x_list_dim = 2;\n\n            for (j = 0; j < floor_setup->data.t1.partitions; ++j)\n                floor_setup->data.t1.x_list_dim+=floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]];\n\n            floor_setup->data.t1.list = av_mallocz(floor_setup->data.t1.x_list_dim *\n                                                   sizeof(*floor_setup->data.t1.list));\n\n\n            rangebits = get_bits(gb, 4);\n            rangemax = (1 << rangebits);\n            if (rangemax > vc->blocksize[1] / 2) {\n                av_log(vc->avccontext, AV_LOG_ERROR,\n                       \"Floor value is too large for blocksize: %u (%\"PRIuFAST32\")\\n\",\n                       rangemax, vc->blocksize[1] / 2);\n                return -1;\n            }\n            floor_setup->data.t1.list[0].x = 0;\n            floor_setup->data.t1.list[1].x = rangemax;\n\n            for (j = 0; j < floor_setup->data.t1.partitions; ++j) {\n                for (k = 0; k < floor_setup->data.t1.class_dimensions[floor_setup->data.t1.partition_class[j]]; ++k, ++floor1_values) {\n                    floor_setup->data.t1.list[floor1_values].x = get_bits(gb, rangebits);\n\n                    AV_DEBUG(\" %u. floor1 Y coord. %d\\n\", floor1_values,\n                             floor_setup->data.t1.list[floor1_values].x);\n                }\n            }\n\n// Precalculate order of x coordinates - needed for decode\n            ff_vorbis_ready_floor1_list(floor_setup->data.t1.list, floor_setup->data.t1.x_list_dim);\n        } else if (floor_setup->floor_type == 0) {\n            unsigned max_codebook_dim = 0;\n\n            floor_setup->decode = vorbis_floor0_decode;\n\n            floor_setup->data.t0.order          = get_bits(gb,  8);\n            floor_setup->data.t0.rate           = get_bits(gb, 16);\n            floor_setup->data.t0.bark_map_size  = get_bits(gb, 16);\n            floor_setup->data.t0.amplitude_bits = get_bits(gb,  6);\n            /* zero would result in a div by zero later *\n             * 2^0 - 1 == 0                             */\n            if (floor_setup->data.t0.amplitude_bits == 0) {\n                av_log(vc->avccontext, AV_LOG_ERROR,\n                       \"Floor 0 amplitude bits is 0.\\n\");\n                return -1;\n            }\n            floor_setup->data.t0.amplitude_offset = get_bits(gb, 8);\n            floor_setup->data.t0.num_books        = get_bits(gb, 4) + 1;\n\n            /* allocate mem for booklist */\n            floor_setup->data.t0.book_list =\n                av_malloc(floor_setup->data.t0.num_books);\n            if (!floor_setup->data.t0.book_list)\n                return -1;\n            /* read book indexes */\n            {\n                int idx;\n                unsigned book_idx;\n                for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) {\n                    GET_VALIDATED_INDEX(book_idx, 8, vc->codebook_count)\n                    floor_setup->data.t0.book_list[idx] = book_idx;\n                    if (vc->codebooks[book_idx].dimensions > max_codebook_dim)\n                        max_codebook_dim = vc->codebooks[book_idx].dimensions;\n                }\n            }\n\n            create_map(vc, i);\n\n            /* codebook dim is for padding if codebook dim doesn't *\n             * divide order+1 then we need to read more data       */\n            floor_setup->data.t0.lsp =\n                av_malloc((floor_setup->data.t0.order + 1 + max_codebook_dim)\n                          * sizeof(*floor_setup->data.t0.lsp));\n            if (!floor_setup->data.t0.lsp)\n                return -1;\n\n#ifdef V_DEBUG /* debug output parsed headers */\n            AV_DEBUG(\"floor0 order: %u\\n\", floor_setup->data.t0.order);\n            AV_DEBUG(\"floor0 rate: %u\\n\", floor_setup->data.t0.rate);\n            AV_DEBUG(\"floor0 bark map size: %u\\n\",\n                     floor_setup->data.t0.bark_map_size);\n            AV_DEBUG(\"floor0 amplitude bits: %u\\n\",\n                     floor_setup->data.t0.amplitude_bits);\n            AV_DEBUG(\"floor0 amplitude offset: %u\\n\",\n                     floor_setup->data.t0.amplitude_offset);\n            AV_DEBUG(\"floor0 number of books: %u\\n\",\n                     floor_setup->data.t0.num_books);\n            AV_DEBUG(\"floor0 book list pointer: %p\\n\",\n                     floor_setup->data.t0.book_list);\n            {\n                int idx;\n                for (idx = 0; idx < floor_setup->data.t0.num_books; ++idx) {\n                    AV_DEBUG(\"  Book %d: %u\\n\",\n                             idx+1,\n                             floor_setup->data.t0.book_list[idx]);\n                }\n            }\n#endif\n        } else {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Invalid floor type!\\n\");\n            return -1;\n        }\n    }\n    return 0;\n}", "before_change_lines": [19, 20, 21, 76, 87, 94, 120], "raw_before_change_lines": [19, 20, 21, 76, 87, 94, 120], "after_change_lines": [19, 74, 85, 86, 93, 119], "raw_after_change_lines": [19, 74, 85, 86, 93, 119], "bug_lines": [19, 20, 21, 76, 87, 94, 120], "added": [false, false, false, false, false, false, false], "idx": 262}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "6478----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5c056afc005e2e5d923ba6e09c235653d6efc1a6_1.json----sdp_parse_line", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_5c056afc005e2e5d923ba6e09c235653d6efc1a6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5c056afc005e2e5d923ba6e09c235653d6efc1a6_1.json", "function_name": "sdp_parse_line", "vul_func_code": "static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1,\n                           int letter, const char *buf)\n{\n    RTSPState *rt = s->priv_data;\n    char buf1[64], st_type[64];\n    const char *p;\n    enum CodecType codec_type;\n    int payload_type, i;\n    AVStream *st;\n    RTSPStream *rtsp_st;\n    struct in_addr sdp_ip;\n    int ttl;\n\n    dprintf(s, \"sdp: %c='%s'\\n\", letter, buf);\n\n    p = buf;\n    if (s1->skip_media && letter != 'm')\n        return;\n    switch (letter) {\n    case 'c':\n        get_word(buf1, sizeof(buf1), &p);\n        if (strcmp(buf1, \"IN\") != 0)\n            return;\n        get_word(buf1, sizeof(buf1), &p);\n        if (strcmp(buf1, \"IP4\") != 0)\n            return;\n        get_word_sep(buf1, sizeof(buf1), \"/\", &p);\n        if (ff_inet_aton(buf1, &sdp_ip) == 0)\n            return;\n        ttl = 16;\n        if (*p == '/') {\n            p++;\n            get_word_sep(buf1, sizeof(buf1), \"/\", &p);\n            ttl = atoi(buf1);\n        }\n        if (s->nb_streams == 0) {\n            s1->default_ip = sdp_ip;\n            s1->default_ttl = ttl;\n        } else {\n            st = s->streams[s->nb_streams - 1];\n            rtsp_st = st->priv_data;\n            rtsp_st->sdp_ip = sdp_ip;\n            rtsp_st->sdp_ttl = ttl;\n        }\n        break;\n    case 's':\n        av_metadata_set(&s->metadata, \"title\", p);\n        break;\n    case 'i':\n        if (s->nb_streams == 0) {\n            av_metadata_set(&s->metadata, \"comment\", p);\n            break;\n        }\n        break;\n    case 'm':\n        /* new stream */\n        s1->skip_media = 0;\n        get_word(st_type, sizeof(st_type), &p);\n        if (!strcmp(st_type, \"audio\")) {\n            codec_type = CODEC_TYPE_AUDIO;\n        } else if (!strcmp(st_type, \"video\")) {\n            codec_type = CODEC_TYPE_VIDEO;\n        } else if (!strcmp(st_type, \"application\")) {\n            codec_type = CODEC_TYPE_DATA;\n        } else {\n            s1->skip_media = 1;\n            return;\n        }\n        rtsp_st = av_mallocz(sizeof(RTSPStream));\n        if (!rtsp_st)\n            return;\n        rtsp_st->stream_index = -1;\n        dynarray_add(&rt->rtsp_streams, &rt->nb_rtsp_streams, rtsp_st);\n\n        rtsp_st->sdp_ip = s1->default_ip;\n        rtsp_st->sdp_ttl = s1->default_ttl;\n\n        get_word(buf1, sizeof(buf1), &p); /* port */\n        rtsp_st->sdp_port = atoi(buf1);\n\n        get_word(buf1, sizeof(buf1), &p); /* protocol (ignored) */\n\n        /* XXX: handle list of formats */\n        get_word(buf1, sizeof(buf1), &p); /* format list */\n        rtsp_st->sdp_payload_type = atoi(buf1);\n\n        if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), \"MP2T\")) {\n            /* no corresponding stream */\n        } else {\n            st = av_new_stream(s, 0);\n            if (!st)\n                return;\n            st->priv_data = rtsp_st;\n            rtsp_st->stream_index = st->index;\n            st->codec->codec_type = codec_type;\n            if (rtsp_st->sdp_payload_type < RTP_PT_PRIVATE) {\n                /* if standard payload type, we can find the codec right now */\n                ff_rtp_get_codec_info(st->codec, rtsp_st->sdp_payload_type);\n            }\n        }\n        /* put a default control url */\n        av_strlcpy(rtsp_st->control_url, rt->control_uri,\n                   sizeof(rtsp_st->control_url));\n        break;\n    case 'a':\n        if (av_strstart(p, \"control:\", &p)) {\n            if (s->nb_streams == 0) {\n                if (!strncmp(p, \"rtsp://\", 7))\n                    av_strlcpy(rt->control_uri, p,\n                               sizeof(rt->control_uri));\n            } else {\n            char proto[32];\n            /* get the control url */\n            st = s->streams[s->nb_streams - 1];\n            rtsp_st = st->priv_data;\n\n            /* XXX: may need to add full url resolution */\n            url_split(proto, sizeof(proto), NULL, 0, NULL, 0,\n                      NULL, NULL, 0, p);\n            if (proto[0] == '\\0') {\n                /* relative control URL */\n                if (rtsp_st->control_url[strlen(rtsp_st->control_url)-1]!='/')\n                av_strlcat(rtsp_st->control_url, \"/\",\n                           sizeof(rtsp_st->control_url));\n                av_strlcat(rtsp_st->control_url, p,\n                           sizeof(rtsp_st->control_url));\n            } else\n                av_strlcpy(rtsp_st->control_url, p,\n                           sizeof(rtsp_st->control_url));\n            }\n        } else if (av_strstart(p, \"rtpmap:\", &p) && s->nb_streams > 0) {\n            /* NOTE: rtpmap is only supported AFTER the 'm=' tag */\n            get_word(buf1, sizeof(buf1), &p);\n            payload_type = atoi(buf1);\n            st = s->streams[s->nb_streams - 1];\n            rtsp_st = st->priv_data;\n            sdp_parse_rtpmap(s, st->codec, rtsp_st, payload_type, p);\n        } else if (av_strstart(p, \"fmtp:\", &p)) {\n            /* NOTE: fmtp is only supported AFTER the 'a=rtpmap:xxx' tag */\n            get_word(buf1, sizeof(buf1), &p);\n            payload_type = atoi(buf1);\n            for (i = 0; i < s->nb_streams; i++) {\n                st      = s->streams[i];\n                rtsp_st = st->priv_data;\n                if (rtsp_st->sdp_payload_type == payload_type) {\n                    if (!(rtsp_st->dynamic_handler &&\n                          rtsp_st->dynamic_handler->parse_sdp_a_line &&\n                          rtsp_st->dynamic_handler->parse_sdp_a_line(s,\n                              i, rtsp_st->dynamic_protocol_context, buf)))\n                        sdp_parse_fmtp(st, p);\n                }\n            }\n        } else if (av_strstart(p, \"framesize:\", &p)) {\n            // let dynamic protocol handlers have a stab at the line.\n            get_word(buf1, sizeof(buf1), &p);\n            payload_type = atoi(buf1);\n            for (i = 0; i < s->nb_streams; i++) {\n                st      = s->streams[i];\n                rtsp_st = st->priv_data;\n                if (rtsp_st->sdp_payload_type == payload_type &&\n                    rtsp_st->dynamic_handler &&\n                    rtsp_st->dynamic_handler->parse_sdp_a_line)\n                    rtsp_st->dynamic_handler->parse_sdp_a_line(s, i,\n                        rtsp_st->dynamic_protocol_context, buf);\n            }\n        } else if (av_strstart(p, \"range:\", &p)) {\n            int64_t start, end;\n\n            // this is so that seeking on a streamed file can work.\n            rtsp_parse_range_npt(p, &start, &end);\n            s->start_time = start;\n            /* AV_NOPTS_VALUE means live broadcast (and can't seek) */\n            s->duration   = (end == AV_NOPTS_VALUE) ?\n                            AV_NOPTS_VALUE : end - start;\n        } else if (av_strstart(p, \"IsRealDataType:integer;\",&p)) {\n            if (atoi(p) == 1)\n                rt->transport = RTSP_TRANSPORT_RDT;\n        } else {\n            if (rt->server_type == RTSP_SERVER_WMS)\n                ff_wms_parse_sdp_a_line(s, p);\n            if (s->nb_streams > 0) {\n                if (rt->server_type == RTSP_SERVER_REAL)\n                    ff_real_parse_sdp_a_line(s, s->nb_streams - 1, p);\n\n                rtsp_st = s->streams[s->nb_streams - 1]->priv_data;\n                if (rtsp_st->dynamic_handler &&\n                    rtsp_st->dynamic_handler->parse_sdp_a_line)\n                    rtsp_st->dynamic_handler->parse_sdp_a_line(s,\n                        s->nb_streams - 1,\n                        rtsp_st->dynamic_protocol_context, buf);\n            }\n        }\n        break;\n    }\n}", "patch_func_code": "static void sdp_parse_line(AVFormatContext *s, SDPParseState *s1,\n                           int letter, const char *buf)\n{\n    RTSPState *rt = s->priv_data;\n    char buf1[64], st_type[64];\n    const char *p;\n    enum CodecType codec_type;\n    int payload_type, i;\n    AVStream *st;\n    RTSPStream *rtsp_st;\n    struct in_addr sdp_ip;\n    int ttl;\n\n    dprintf(s, \"sdp: %c='%s'\\n\", letter, buf);\n\n    p = buf;\n    if (s1->skip_media && letter != 'm')\n        return;\n    switch (letter) {\n    case 'c':\n        get_word(buf1, sizeof(buf1), &p);\n        if (strcmp(buf1, \"IN\") != 0)\n            return;\n        get_word(buf1, sizeof(buf1), &p);\n        if (strcmp(buf1, \"IP4\") != 0)\n            return;\n        get_word_sep(buf1, sizeof(buf1), \"/\", &p);\n        if (ff_inet_aton(buf1, &sdp_ip) == 0)\n            return;\n        ttl = 16;\n        if (*p == '/') {\n            p++;\n            get_word_sep(buf1, sizeof(buf1), \"/\", &p);\n            ttl = atoi(buf1);\n        }\n        if (s->nb_streams == 0) {\n            s1->default_ip = sdp_ip;\n            s1->default_ttl = ttl;\n        } else {\n            st = s->streams[s->nb_streams - 1];\n            rtsp_st = st->priv_data;\n            rtsp_st->sdp_ip = sdp_ip;\n            rtsp_st->sdp_ttl = ttl;\n        }\n        break;\n    case 's':\n        av_metadata_set(&s->metadata, \"title\", p);\n        break;\n    case 'i':\n        if (s->nb_streams == 0) {\n            av_metadata_set(&s->metadata, \"comment\", p);\n            break;\n        }\n        break;\n    case 'm':\n        /* new stream */\n        s1->skip_media = 0;\n        get_word(st_type, sizeof(st_type), &p);\n        if (!strcmp(st_type, \"audio\")) {\n            codec_type = CODEC_TYPE_AUDIO;\n        } else if (!strcmp(st_type, \"video\")) {\n            codec_type = CODEC_TYPE_VIDEO;\n        } else if (!strcmp(st_type, \"application\")) {\n            codec_type = CODEC_TYPE_DATA;\n        } else {\n            s1->skip_media = 1;\n            return;\n        }\n        rtsp_st = av_mallocz(sizeof(RTSPStream));\n        if (!rtsp_st)\n            return;\n        rtsp_st->stream_index = -1;\n        dynarray_add(&rt->rtsp_streams, &rt->nb_rtsp_streams, rtsp_st);\n\n        rtsp_st->sdp_ip = s1->default_ip;\n        rtsp_st->sdp_ttl = s1->default_ttl;\n\n        get_word(buf1, sizeof(buf1), &p); /* port */\n        rtsp_st->sdp_port = atoi(buf1);\n\n        get_word(buf1, sizeof(buf1), &p); /* protocol (ignored) */\n\n        /* XXX: handle list of formats */\n        get_word(buf1, sizeof(buf1), &p); /* format list */\n        rtsp_st->sdp_payload_type = atoi(buf1);\n\n        if (!strcmp(ff_rtp_enc_name(rtsp_st->sdp_payload_type), \"MP2T\")) {\n            /* no corresponding stream */\n        } else {\n            st = av_new_stream(s, 0);\n            if (!st)\n                return;\n            st->priv_data = rtsp_st;\n            rtsp_st->stream_index = st->index;\n            st->codec->codec_type = codec_type;\n            if (rtsp_st->sdp_payload_type < RTP_PT_PRIVATE) {\n                /* if standard payload type, we can find the codec right now */\n                ff_rtp_get_codec_info(st->codec, rtsp_st->sdp_payload_type);\n            }\n        }\n        /* put a default control url */\n        av_strlcpy(rtsp_st->control_url, rt->control_uri,\n                   sizeof(rtsp_st->control_url));\n        break;\n    case 'a':\n        if (av_strstart(p, \"control:\", &p)) {\n            if (s->nb_streams == 0) {\n                if (!strncmp(p, \"rtsp://\", 7))\n                    av_strlcpy(rt->control_uri, p,\n                               sizeof(rt->control_uri));\n            } else {\n            char proto[32];\n            /* get the control url */\n            st = s->streams[s->nb_streams - 1];\n            rtsp_st = st->priv_data;\n\n            /* XXX: may need to add full url resolution */\n            ff_url_split(proto, sizeof(proto), NULL, 0, NULL, 0,\n                      NULL, NULL, 0, p);\n            if (proto[0] == '\\0') {\n                /* relative control URL */\n                if (rtsp_st->control_url[strlen(rtsp_st->control_url)-1]!='/')\n                av_strlcat(rtsp_st->control_url, \"/\",\n                           sizeof(rtsp_st->control_url));\n                av_strlcat(rtsp_st->control_url, p,\n                           sizeof(rtsp_st->control_url));\n            } else\n                av_strlcpy(rtsp_st->control_url, p,\n                           sizeof(rtsp_st->control_url));\n            }\n        } else if (av_strstart(p, \"rtpmap:\", &p) && s->nb_streams > 0) {\n            /* NOTE: rtpmap is only supported AFTER the 'm=' tag */\n            get_word(buf1, sizeof(buf1), &p);\n            payload_type = atoi(buf1);\n            st = s->streams[s->nb_streams - 1];\n            rtsp_st = st->priv_data;\n            sdp_parse_rtpmap(s, st->codec, rtsp_st, payload_type, p);\n        } else if (av_strstart(p, \"fmtp:\", &p)) {\n            /* NOTE: fmtp is only supported AFTER the 'a=rtpmap:xxx' tag */\n            get_word(buf1, sizeof(buf1), &p);\n            payload_type = atoi(buf1);\n            for (i = 0; i < s->nb_streams; i++) {\n                st      = s->streams[i];\n                rtsp_st = st->priv_data;\n                if (rtsp_st->sdp_payload_type == payload_type) {\n                    if (!(rtsp_st->dynamic_handler &&\n                          rtsp_st->dynamic_handler->parse_sdp_a_line &&\n                          rtsp_st->dynamic_handler->parse_sdp_a_line(s,\n                              i, rtsp_st->dynamic_protocol_context, buf)))\n                        sdp_parse_fmtp(st, p);\n                }\n            }\n        } else if (av_strstart(p, \"framesize:\", &p)) {\n            // let dynamic protocol handlers have a stab at the line.\n            get_word(buf1, sizeof(buf1), &p);\n            payload_type = atoi(buf1);\n            for (i = 0; i < s->nb_streams; i++) {\n                st      = s->streams[i];\n                rtsp_st = st->priv_data;\n                if (rtsp_st->sdp_payload_type == payload_type &&\n                    rtsp_st->dynamic_handler &&\n                    rtsp_st->dynamic_handler->parse_sdp_a_line)\n                    rtsp_st->dynamic_handler->parse_sdp_a_line(s, i,\n                        rtsp_st->dynamic_protocol_context, buf);\n            }\n        } else if (av_strstart(p, \"range:\", &p)) {\n            int64_t start, end;\n\n            // this is so that seeking on a streamed file can work.\n            rtsp_parse_range_npt(p, &start, &end);\n            s->start_time = start;\n            /* AV_NOPTS_VALUE means live broadcast (and can't seek) */\n            s->duration   = (end == AV_NOPTS_VALUE) ?\n                            AV_NOPTS_VALUE : end - start;\n        } else if (av_strstart(p, \"IsRealDataType:integer;\",&p)) {\n            if (atoi(p) == 1)\n                rt->transport = RTSP_TRANSPORT_RDT;\n        } else {\n            if (rt->server_type == RTSP_SERVER_WMS)\n                ff_wms_parse_sdp_a_line(s, p);\n            if (s->nb_streams > 0) {\n                if (rt->server_type == RTSP_SERVER_REAL)\n                    ff_real_parse_sdp_a_line(s, s->nb_streams - 1, p);\n\n                rtsp_st = s->streams[s->nb_streams - 1]->priv_data;\n                if (rtsp_st->dynamic_handler &&\n                    rtsp_st->dynamic_handler->parse_sdp_a_line)\n                    rtsp_st->dynamic_handler->parse_sdp_a_line(s,\n                        s->nb_streams - 1,\n                        rtsp_st->dynamic_protocol_context, buf);\n            }\n        }\n        break;\n    }\n}", "before_change_lines": [118], "raw_before_change_lines": [118], "after_change_lines": [118], "raw_after_change_lines": [118], "bug_lines": [118], "added": [false], "idx": 263}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6483----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5c2b17f99277f0db83d38972b59e254dfa8834dd_1.json----rtp_send_ilbc", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_5c2b17f99277f0db83d38972b59e254dfa8834dd_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5c2b17f99277f0db83d38972b59e254dfa8834dd_1.json", "function_name": "rtp_send_ilbc", "vul_func_code": "static int rtp_send_ilbc(AVFormatContext *s1, const uint8_t *buf, int size)\n{\n    RTPMuxContext *s = s1->priv_data;\n    AVStream *st = s1->streams[0];\n    int frame_duration = av_get_audio_frame_duration(st->codec, 0);\n    int frame_size = st->codec->block_align;\n    int frames = size / frame_size;\n\n    while (frames > 0) {\n        if (s->num_frames > 0 &&\n            av_compare_ts(s->cur_timestamp - s->timestamp, st->time_base,\n                          s1->max_delay, AV_TIME_BASE_Q) >= 0) {\n            ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1);\n            s->num_frames = 0;\n        }\n\n        if (!s->num_frames) {\n            s->buf_ptr = s->buf;\n            s->timestamp = s->cur_timestamp;\n        }\n        memcpy(s->buf_ptr, buf, frame_size);\n        frames--;\n        s->num_frames++;\n        s->buf_ptr       += frame_size;\n        buf              += frame_size;\n        s->cur_timestamp += frame_duration;\n\n        if (s->num_frames == s->max_frames_per_packet) {\n            ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1);\n            s->num_frames = 0;\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int rtp_send_ilbc(AVFormatContext *s1, const uint8_t *buf, int size)\n{\n    RTPMuxContext *s = s1->priv_data;\n    AVStream *st = s1->streams[0];\n    int frame_duration = av_get_audio_frame_duration2(st->codecpar, 0);\n    int frame_size = st->codecpar->block_align;\n    int frames = size / frame_size;\n\n    while (frames > 0) {\n        if (s->num_frames > 0 &&\n            av_compare_ts(s->cur_timestamp - s->timestamp, st->time_base,\n                          s1->max_delay, AV_TIME_BASE_Q) >= 0) {\n            ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1);\n            s->num_frames = 0;\n        }\n\n        if (!s->num_frames) {\n            s->buf_ptr = s->buf;\n            s->timestamp = s->cur_timestamp;\n        }\n        memcpy(s->buf_ptr, buf, frame_size);\n        frames--;\n        s->num_frames++;\n        s->buf_ptr       += frame_size;\n        buf              += frame_size;\n        s->cur_timestamp += frame_duration;\n\n        if (s->num_frames == s->max_frames_per_packet) {\n            ff_rtp_send_data(s1, s->buf, s->buf_ptr - s->buf, 1);\n            s->num_frames = 0;\n        }\n    }\n    return 0;\n}", "before_change_lines": [5, 6], "raw_before_change_lines": [5, 6], "after_change_lines": [5, 6], "raw_after_change_lines": [5, 6], "bug_lines": [5, 6], "added": [false, false], "idx": 264}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "6542----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5fe5efc51de215caf36bf667e30bc27cd48df490_1.json----udp_leave_multicast_group", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_5fe5efc51de215caf36bf667e30bc27cd48df490_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_5fe5efc51de215caf36bf667e30bc27cd48df490_1.json", "function_name": "udp_leave_multicast_group", "vul_func_code": "static int udp_leave_multicast_group(int sockfd, struct sockaddr *addr)\n{\n#ifdef IP_DROP_MEMBERSHIP\n    if (addr->sa_family == AF_INET) {\n        struct ip_mreq mreq;\n\n        mreq.imr_multiaddr.s_addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;\n        mreq.imr_interface.s_addr= INADDR_ANY;\n        if (setsockopt(sockfd, IPPROTO_IP, IP_DROP_MEMBERSHIP, (const void *)&mreq, sizeof(mreq)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"setsockopt(IP_DROP_MEMBERSHIP): %s\\n\", strerror(errno));\n            return -1;\n        }\n    }\n#endif\n#if HAVE_STRUCT_IPV6_MREQ && defined(IPPROTO_IPV6)\n    if (addr->sa_family == AF_INET6) {\n        struct ipv6_mreq mreq6;\n\n        memcpy(&mreq6.ipv6mr_multiaddr, &(((struct sockaddr_in6 *)addr)->sin6_addr), sizeof(struct in6_addr));\n        mreq6.ipv6mr_interface= 0;\n        if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq6, sizeof(mreq6)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"setsockopt(IPV6_DROP_MEMBERSHIP): %s\\n\", strerror(errno));\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}", "patch_func_code": "static int udp_leave_multicast_group(int sockfd, struct sockaddr *addr)\n{\n#ifdef IP_DROP_MEMBERSHIP\n    if (addr->sa_family == AF_INET) {\n        struct ip_mreq mreq;\n\n        mreq.imr_multiaddr.s_addr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;\n        mreq.imr_interface.s_addr= INADDR_ANY;\n        if (setsockopt(sockfd, IPPROTO_IP, IP_DROP_MEMBERSHIP, (const void *)&mreq, sizeof(mreq)) < 0) {\n            log_net_error(NULL, AV_LOG_ERROR, \"setsockopt(IP_DROP_MEMBERSHIP)\");\n            return -1;\n        }\n    }\n#endif\n#if HAVE_STRUCT_IPV6_MREQ && defined(IPPROTO_IPV6)\n    if (addr->sa_family == AF_INET6) {\n        struct ipv6_mreq mreq6;\n\n        memcpy(&mreq6.ipv6mr_multiaddr, &(((struct sockaddr_in6 *)addr)->sin6_addr), sizeof(struct in6_addr));\n        mreq6.ipv6mr_interface= 0;\n        if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, &mreq6, sizeof(mreq6)) < 0) {\n            log_net_error(NULL, AV_LOG_ERROR, \"setsockopt(IPV6_DROP_MEMBERSHIP)\");\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}", "before_change_lines": [10, 22], "raw_before_change_lines": [10, 22], "after_change_lines": [10, 22], "raw_after_change_lines": [10, 22], "bug_lines": [10, 22], "added": [false, false], "idx": 265}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6555----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_608c0fc57de2027cfb67c513ff7e1610e81fc272_1.json----quantize_mantissas", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_608c0fc57de2027cfb67c513ff7e1610e81fc272_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_608c0fc57de2027cfb67c513ff7e1610e81fc272_1.json", "function_name": "quantize_mantissas", "vul_func_code": "static void quantize_mantissas(AC3EncodeContext *s)\n{\n    int blk, ch, ch0=0, got_cpl;\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n        AC3Block *block = &s->blocks[blk];\n        AC3Block *ref_block;\n        AC3Mant m = { 0 };\n\n        got_cpl = !block->cpl_in_use;\n        for (ch = 1; ch <= s->channels; ch++) {\n            if (!got_cpl && ch > 1 && block->channel_in_cpl[ch-1]) {\n                ch0     = ch - 1;\n                ch      = CPL_CH;\n                got_cpl = 1;\n            }\n            ref_block = block->exp_ref_block[ch];\n            quantize_mantissas_blk_ch(&m, block->fixed_coef[ch],\n                                      ref_block->exp[ch],\n                                      ref_block->bap[ch], block->qmant[ch],\n                                      s->start_freq[ch], block->end_freq[ch]);\n            if (ch == CPL_CH)\n                ch = ch0;\n        }\n    }\n}", "patch_func_code": "static void quantize_mantissas(AC3EncodeContext *s)\n{\n    int blk, ch, ch0=0, got_cpl;\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n        AC3Block *block = &s->blocks[blk];\n        AC3Mant m = { 0 };\n\n        got_cpl = !block->cpl_in_use;\n        for (ch = 1; ch <= s->channels; ch++) {\n            if (!got_cpl && ch > 1 && block->channel_in_cpl[ch-1]) {\n                ch0     = ch - 1;\n                ch      = CPL_CH;\n                got_cpl = 1;\n            }\n            quantize_mantissas_blk_ch(&m, block->fixed_coef[ch],\n                                      s->blocks[s->exp_ref_block[ch][blk]].exp[ch],\n                                      s->ref_bap[ch][blk], block->qmant[ch],\n                                      s->start_freq[ch], block->end_freq[ch]);\n            if (ch == CPL_CH)\n                ch = ch0;\n        }\n    }\n}", "before_change_lines": [7, 17, 19, 20], "raw_before_change_lines": [7, 17, 19, 20], "after_change_lines": [17, 18], "raw_after_change_lines": [17, 18], "bug_lines": [7, 17, 19, 20], "added": [false, false, false, false], "idx": 266}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "6617----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_645f5b2750930839b111371c80149132c9757ded_1.json----parse_h264_sdp_line", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_645f5b2750930839b111371c80149132c9757ded_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_645f5b2750930839b111371c80149132c9757ded_1.json", "function_name": "parse_h264_sdp_line", "vul_func_code": "static int parse_h264_sdp_line(AVFormatContext *s, int st_index,\n                               PayloadContext *h264_data, const char *line)\n{\n    AVStream *stream = s->streams[st_index];\n    AVCodecContext *codec = stream->codec;\n    const char *p = line;\n\n    assert(h264_data->cookie == MAGIC_COOKIE);\n\n    if (av_strstart(p, \"framesize:\", &p)) {\n        char buf1[50];\n        char *dst = buf1;\n\n        // remove the protocol identifier..\n        while (*p && *p == ' ') p++; // strip spaces.\n        while (*p && *p != ' ') p++; // eat protocol identifier\n        while (*p && *p == ' ') p++; // strip trailing spaces.\n        while (*p && *p != '-' && (buf1 - dst) < sizeof(buf1) - 1) {\n            *dst++ = *p++;\n        }\n        *dst = '\\0';\n\n        // a='framesize:96 320-240'\n        // set our parameters..\n        codec->width = atoi(buf1);\n        codec->height = atoi(p + 1); // skip the -\n        codec->pix_fmt = PIX_FMT_YUV420P;\n    } else if (av_strstart(p, \"fmtp:\", &p)) {\n        char attr[256];\n        char value[4096];\n\n        // remove the protocol identifier..\n        while (*p && *p == ' ') p++; // strip spaces.\n        while (*p && *p != ' ') p++; // eat protocol identifier\n        while (*p && *p == ' ') p++; // strip trailing spaces.\n\n        /* loop on each attribute */\n        while (rtsp_next_attr_and_value\n               (&p, attr, sizeof(attr), value, sizeof(value))) {\n            /* grab the codec extra_data from the config parameter of the fmtp line */\n            sdp_parse_fmtp_config_h264(stream, h264_data, attr, value);\n        }\n    } else if (av_strstart(p, \"cliprect:\", &p)) {\n        // could use this if we wanted.\n    }\n\n    av_set_pts_info(stream, 33, 1, 90000);      // 33 should be right, because the pts is 64 bit? (done elsewhere; this is a one time thing)\n\n    return 0;                   // keep processing it the normal way...\n}", "patch_func_code": "static int parse_h264_sdp_line(AVFormatContext *s, int st_index,\n                               PayloadContext *h264_data, const char *line)\n{\n    AVStream *stream = s->streams[st_index];\n    AVCodecContext *codec = stream->codec;\n    const char *p = line;\n\n    assert(h264_data->cookie == MAGIC_COOKIE);\n\n    if (av_strstart(p, \"framesize:\", &p)) {\n        char buf1[50];\n        char *dst = buf1;\n\n        // remove the protocol identifier..\n        while (*p && *p == ' ') p++; // strip spaces.\n        while (*p && *p != ' ') p++; // eat protocol identifier\n        while (*p && *p == ' ') p++; // strip trailing spaces.\n        while (*p && *p != '-' && (dst - buf1) < sizeof(buf1) - 1) {\n            *dst++ = *p++;\n        }\n        *dst = '\\0';\n\n        // a='framesize:96 320-240'\n        // set our parameters..\n        codec->width = atoi(buf1);\n        codec->height = atoi(p + 1); // skip the -\n        codec->pix_fmt = PIX_FMT_YUV420P;\n    } else if (av_strstart(p, \"fmtp:\", &p)) {\n        char attr[256];\n        char value[4096];\n\n        // remove the protocol identifier..\n        while (*p && *p == ' ') p++; // strip spaces.\n        while (*p && *p != ' ') p++; // eat protocol identifier\n        while (*p && *p == ' ') p++; // strip trailing spaces.\n\n        /* loop on each attribute */\n        while (rtsp_next_attr_and_value\n               (&p, attr, sizeof(attr), value, sizeof(value))) {\n            /* grab the codec extra_data from the config parameter of the fmtp line */\n            sdp_parse_fmtp_config_h264(stream, h264_data, attr, value);\n        }\n    } else if (av_strstart(p, \"cliprect:\", &p)) {\n        // could use this if we wanted.\n    }\n\n    av_set_pts_info(stream, 33, 1, 90000);      // 33 should be right, because the pts is 64 bit? (done elsewhere; this is a one time thing)\n\n    return 0;                   // keep processing it the normal way...\n}", "before_change_lines": [18], "raw_before_change_lines": [18], "after_change_lines": [18], "raw_after_change_lines": [18], "bug_lines": [18], "added": [false], "idx": 267}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "6627----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_64c49fb107735bb9c902260416125f7d028d59b4_1.json----udp_set_multicast_ttl", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_64c49fb107735bb9c902260416125f7d028d59b4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_64c49fb107735bb9c902260416125f7d028d59b4_1.json", "function_name": "udp_set_multicast_ttl", "vul_func_code": "static int udp_set_multicast_ttl(int sockfd, int mcastTTL,\n                                 struct sockaddr *addr)\n{\n#ifdef IP_MULTICAST_TTL\n    if (addr->sa_family == AF_INET) {\n        if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &mcastTTL, sizeof(mcastTTL)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"setsockopt(IP_MULTICAST_TTL): %s\\n\", strerror(errno));\n            return -1;\n        }\n    }\n#endif\n#if defined(IPPROTO_IPV6) && defined(IPV6_MULTICAST_HOPS)\n    if (addr->sa_family == AF_INET6) {\n        if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &mcastTTL, sizeof(mcastTTL)) < 0) {\n            av_log(NULL, AV_LOG_ERROR, \"setsockopt(IPV6_MULTICAST_HOPS): %s\\n\", strerror(errno));\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}", "patch_func_code": "static int udp_set_multicast_ttl(int sockfd, int mcastTTL,\n                                 struct sockaddr *addr)\n{\n#ifdef IP_MULTICAST_TTL\n    if (addr->sa_family == AF_INET) {\n        if (setsockopt(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, &mcastTTL, sizeof(mcastTTL)) < 0) {\n            log_net_error(NULL, AV_LOG_ERROR, \"setsockopt(IP_MULTICAST_TTL)\");\n            return -1;\n        }\n    }\n#endif\n#if defined(IPPROTO_IPV6) && defined(IPV6_MULTICAST_HOPS)\n    if (addr->sa_family == AF_INET6) {\n        if (setsockopt(sockfd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &mcastTTL, sizeof(mcastTTL)) < 0) {\n            log_net_error(NULL, AV_LOG_ERROR, \"setsockopt(IPV6_MULTICAST_HOPS)\");\n            return -1;\n        }\n    }\n#endif\n    return 0;\n}", "before_change_lines": [7, 15], "raw_before_change_lines": [7, 15], "after_change_lines": [7, 15], "raw_after_change_lines": [7, 15], "bug_lines": [7, 15], "added": [false, false], "idx": 268}
{"project": "libav", "vul_type": "INFERBO_ALLOC_MAY_BE_BIG", "filepath_func": "6807----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_6d63b782229e4ad0efee7750ed9028a64c482f3e_1.json----mpegts_push_data", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_6d63b782229e4ad0efee7750ed9028a64c482f3e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_6d63b782229e4ad0efee7750ed9028a64c482f3e_1.json", "function_name": "mpegts_push_data", "vul_func_code": "static int mpegts_push_data(MpegTSFilter *filter,\n                            const uint8_t *buf, int buf_size, int is_start,\n                            int64_t pos)\n{\n    PESContext *pes = filter->u.pes_filter.opaque;\n    MpegTSContext *ts = pes->ts;\n    const uint8_t *p;\n    int len, code;\n\n    if(!ts->pkt)\n        return 0;\n\n    if (is_start) {\n        if (pes->state == MPEGTS_PAYLOAD && pes->data_index > 0) {\n            new_pes_packet(pes, ts->pkt);\n            ts->stop_parse = 1;\n        }\n        pes->state = MPEGTS_HEADER;\n        pes->data_index = 0;\n        pes->ts_packet_pos = pos;\n    }\n    p = buf;\n    while (buf_size > 0) {\n        switch(pes->state) {\n        case MPEGTS_HEADER:\n            len = PES_START_SIZE - pes->data_index;\n            if (len > buf_size)\n                len = buf_size;\n            memcpy(pes->header + pes->data_index, p, len);\n            pes->data_index += len;\n            p += len;\n            buf_size -= len;\n            if (pes->data_index == PES_START_SIZE) {\n                /* we got all the PES or section header. We can now\n                   decide */\n                if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n                    pes->header[2] == 0x01) {\n                    /* it must be an mpeg2 PES stream */\n                    code = pes->header[3] | 0x100;\n                    av_dlog(pes->stream, \"pid=%x pes_code=%#x\\n\", pes->pid, code);\n\n                    if ((pes->st && pes->st->discard == AVDISCARD_ALL) ||\n                        code == 0x1be) /* padding_stream */\n                        goto skip;\n\n                    /* stream not present in PMT */\n                    if (!pes->st) {\n                        pes->st = av_new_stream(ts->stream, pes->pid);\n                        if (!pes->st)\n                            return AVERROR(ENOMEM);\n                        mpegts_set_stream_info(pes->st, pes, 0, 0);\n                    }\n\n                    pes->total_size = AV_RB16(pes->header + 4);\n                    /* NOTE: a zero total size means the PES size is\n                       unbounded */\n                    if (!pes->total_size)\n                        pes->total_size = MAX_PES_PAYLOAD;\n\n                    /* allocate pes buffer */\n                    pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE);\n                    if (!pes->buffer)\n                        return AVERROR(ENOMEM);\n\n                    if (code != 0x1bc && code != 0x1bf && /* program_stream_map, private_stream_2 */\n                        code != 0x1f0 && code != 0x1f1 && /* ECM, EMM */\n                        code != 0x1ff && code != 0x1f2 && /* program_stream_directory, DSMCC_stream */\n                        code != 0x1f8) {                  /* ITU-T Rec. H.222.1 type E stream */\n                        pes->state = MPEGTS_PESHEADER;\n                        if (pes->st->codec->codec_id == CODEC_ID_NONE) {\n                            av_dlog(pes->stream, \"pid=%x stream_type=%x probing\\n\",\n                                    pes->pid, pes->stream_type);\n                            pes->st->codec->codec_id = CODEC_ID_PROBE;\n                        }\n                    } else {\n                        pes->state = MPEGTS_PAYLOAD;\n                        pes->data_index = 0;\n                    }\n                } else {\n                    /* otherwise, it should be a table */\n                    /* skip packet */\n                skip:\n                    pes->state = MPEGTS_SKIP;\n                    continue;\n                }\n            }\n            break;\n            /**********************************************/\n            /* PES packing parsing */\n        case MPEGTS_PESHEADER:\n            len = PES_HEADER_SIZE - pes->data_index;\n            if (len < 0)\n                return -1;\n            if (len > buf_size)\n                len = buf_size;\n            memcpy(pes->header + pes->data_index, p, len);\n            pes->data_index += len;\n            p += len;\n            buf_size -= len;\n            if (pes->data_index == PES_HEADER_SIZE) {\n                pes->pes_header_size = pes->header[8] + 9;\n                pes->state = MPEGTS_PESHEADER_FILL;\n            }\n            break;\n        case MPEGTS_PESHEADER_FILL:\n            len = pes->pes_header_size - pes->data_index;\n            if (len < 0)\n                return -1;\n            if (len > buf_size)\n                len = buf_size;\n            memcpy(pes->header + pes->data_index, p, len);\n            pes->data_index += len;\n            p += len;\n            buf_size -= len;\n            if (pes->data_index == pes->pes_header_size) {\n                const uint8_t *r;\n                unsigned int flags, pes_ext, skip;\n\n                flags = pes->header[7];\n                r = pes->header + 9;\n                pes->pts = AV_NOPTS_VALUE;\n                pes->dts = AV_NOPTS_VALUE;\n                if ((flags & 0xc0) == 0x80) {\n                    pes->dts = pes->pts = ff_parse_pes_pts(r);\n                    r += 5;\n                } else if ((flags & 0xc0) == 0xc0) {\n                    pes->pts = ff_parse_pes_pts(r);\n                    r += 5;\n                    pes->dts = ff_parse_pes_pts(r);\n                    r += 5;\n                }\n                pes->extended_stream_id = -1;\n                if (flags & 0x01) { /* PES extension */\n                    pes_ext = *r++;\n                    /* Skip PES private data, program packet sequence counter and P-STD buffer */\n                    skip = (pes_ext >> 4) & 0xb;\n                    skip += skip & 0x9;\n                    r += skip;\n                    if ((pes_ext & 0x41) == 0x01 &&\n                        (r + 2) <= (pes->header + pes->pes_header_size)) {\n                        /* PES extension 2 */\n                        if ((r[0] & 0x7f) > 0 && (r[1] & 0x80) == 0)\n                            pes->extended_stream_id = r[1];\n                    }\n                }\n\n                /* we got the full header. We parse it and get the payload */\n                pes->state = MPEGTS_PAYLOAD;\n                pes->data_index = 0;\n            }\n            break;\n        case MPEGTS_PAYLOAD:\n            if (buf_size > 0 && pes->buffer) {\n                if (pes->data_index > 0 && pes->data_index+buf_size > pes->total_size) {\n                    new_pes_packet(pes, ts->pkt);\n                    pes->total_size = MAX_PES_PAYLOAD;\n                    pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE);\n                    if (!pes->buffer)\n                        return AVERROR(ENOMEM);\n                    ts->stop_parse = 1;\n                } else if (pes->data_index == 0 && buf_size > pes->total_size) {\n                    // pes packet size is < ts size packet and pes data is padded with 0xff\n                    // not sure if this is legal in ts but see issue #2392\n                    buf_size = pes->total_size;\n                }\n                memcpy(pes->buffer+pes->data_index, p, buf_size);\n                pes->data_index += buf_size;\n            }\n            buf_size = 0;\n            /* emit complete packets with known packet size\n             * decreases demuxer delay for infrequent packets like subtitles from\n             * a couple of seconds to milliseconds for properly muxed files.\n             * total_size is the number of bytes following pes_packet_length\n             * in the pes header, i.e. not counting the first 6 bytes */\n            if (pes->total_size < MAX_PES_PAYLOAD &&\n                pes->pes_header_size + pes->data_index == pes->total_size + 6) {\n                ts->stop_parse = 1;\n                new_pes_packet(pes, ts->pkt);\n            }\n            break;\n        case MPEGTS_SKIP:\n            buf_size = 0;\n            break;\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int mpegts_push_data(MpegTSFilter *filter,\n                            const uint8_t *buf, int buf_size, int is_start,\n                            int64_t pos)\n{\n    PESContext *pes = filter->u.pes_filter.opaque;\n    MpegTSContext *ts = pes->ts;\n    const uint8_t *p;\n    int len, code;\n\n    if(!ts->pkt)\n        return 0;\n\n    if (is_start) {\n        if (pes->state == MPEGTS_PAYLOAD && pes->data_index > 0) {\n            new_pes_packet(pes, ts->pkt);\n            ts->stop_parse = 1;\n        }\n        pes->state = MPEGTS_HEADER;\n        pes->data_index = 0;\n        pes->ts_packet_pos = pos;\n    }\n    p = buf;\n    while (buf_size > 0) {\n        switch(pes->state) {\n        case MPEGTS_HEADER:\n            len = PES_START_SIZE - pes->data_index;\n            if (len > buf_size)\n                len = buf_size;\n            memcpy(pes->header + pes->data_index, p, len);\n            pes->data_index += len;\n            p += len;\n            buf_size -= len;\n            if (pes->data_index == PES_START_SIZE) {\n                /* we got all the PES or section header. We can now\n                   decide */\n                if (pes->header[0] == 0x00 && pes->header[1] == 0x00 &&\n                    pes->header[2] == 0x01) {\n                    /* it must be an mpeg2 PES stream */\n                    code = pes->header[3] | 0x100;\n                    av_dlog(pes->stream, \"pid=%x pes_code=%#x\\n\", pes->pid, code);\n\n                    if ((pes->st && pes->st->discard == AVDISCARD_ALL) ||\n                        code == 0x1be) /* padding_stream */\n                        goto skip;\n\n                    /* stream not present in PMT */\n                    if (!pes->st) {\n                        pes->st = av_new_stream(ts->stream, pes->pid);\n                        if (!pes->st)\n                            return AVERROR(ENOMEM);\n                        mpegts_set_stream_info(pes->st, pes, 0, 0);\n                    }\n\n                    pes->total_size = AV_RB16(pes->header + 4);\n                    /* NOTE: a zero total size means the PES size is\n                       unbounded */\n                    if (!pes->total_size)\n                        pes->total_size = MAX_PES_PAYLOAD;\n\n                    /* allocate pes buffer */\n                    pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE);\n                    if (!pes->buffer)\n                        return AVERROR(ENOMEM);\n\n                    if (code != 0x1bc && code != 0x1bf && /* program_stream_map, private_stream_2 */\n                        code != 0x1f0 && code != 0x1f1 && /* ECM, EMM */\n                        code != 0x1ff && code != 0x1f2 && /* program_stream_directory, DSMCC_stream */\n                        code != 0x1f8) {                  /* ITU-T Rec. H.222.1 type E stream */\n                        pes->state = MPEGTS_PESHEADER;\n                        if (pes->st->codec->codec_id == CODEC_ID_NONE) {\n                            av_dlog(pes->stream, \"pid=%x stream_type=%x probing\\n\",\n                                    pes->pid, pes->stream_type);\n                            pes->st->codec->codec_id = CODEC_ID_PROBE;\n                        }\n                    } else {\n                        pes->state = MPEGTS_PAYLOAD;\n                        pes->data_index = 0;\n                    }\n                } else {\n                    /* otherwise, it should be a table */\n                    /* skip packet */\n                skip:\n                    pes->state = MPEGTS_SKIP;\n                    continue;\n                }\n            }\n            break;\n            /**********************************************/\n            /* PES packing parsing */\n        case MPEGTS_PESHEADER:\n            len = PES_HEADER_SIZE - pes->data_index;\n            if (len < 0)\n                return -1;\n            if (len > buf_size)\n                len = buf_size;\n            memcpy(pes->header + pes->data_index, p, len);\n            pes->data_index += len;\n            p += len;\n            buf_size -= len;\n            if (pes->data_index == PES_HEADER_SIZE) {\n                pes->pes_header_size = pes->header[8] + 9;\n                pes->state = MPEGTS_PESHEADER_FILL;\n            }\n            break;\n        case MPEGTS_PESHEADER_FILL:\n            len = pes->pes_header_size - pes->data_index;\n            if (len < 0)\n                return -1;\n            if (len > buf_size)\n                len = buf_size;\n            memcpy(pes->header + pes->data_index, p, len);\n            pes->data_index += len;\n            p += len;\n            buf_size -= len;\n            if (pes->data_index == pes->pes_header_size) {\n                const uint8_t *r;\n                unsigned int flags, pes_ext, skip;\n\n                flags = pes->header[7];\n                r = pes->header + 9;\n                pes->pts = AV_NOPTS_VALUE;\n                pes->dts = AV_NOPTS_VALUE;\n                if ((flags & 0xc0) == 0x80) {\n                    pes->dts = pes->pts = ff_parse_pes_pts(r);\n                    r += 5;\n                } else if ((flags & 0xc0) == 0xc0) {\n                    pes->pts = ff_parse_pes_pts(r);\n                    r += 5;\n                    pes->dts = ff_parse_pes_pts(r);\n                    r += 5;\n                }\n                pes->extended_stream_id = -1;\n                if (flags & 0x01) { /* PES extension */\n                    pes_ext = *r++;\n                    /* Skip PES private data, program packet sequence counter and P-STD buffer */\n                    skip = (pes_ext >> 4) & 0xb;\n                    skip += skip & 0x9;\n                    r += skip;\n                    if ((pes_ext & 0x41) == 0x01 &&\n                        (r + 2) <= (pes->header + pes->pes_header_size)) {\n                        /* PES extension 2 */\n                        if ((r[0] & 0x7f) > 0 && (r[1] & 0x80) == 0)\n                            pes->extended_stream_id = r[1];\n                    }\n                }\n\n                /* we got the full header. We parse it and get the payload */\n                pes->state = MPEGTS_PAYLOAD;\n                pes->data_index = 0;\n            }\n            break;\n        case MPEGTS_PAYLOAD:\n            if (buf_size > 0 && pes->buffer) {\n                if (pes->data_index > 0 && pes->data_index+buf_size > pes->total_size) {\n                    new_pes_packet(pes, ts->pkt);\n                    pes->total_size = MAX_PES_PAYLOAD;\n                    pes->buffer = av_malloc(pes->total_size+FF_INPUT_BUFFER_PADDING_SIZE);\n                    if (!pes->buffer)\n                        return AVERROR(ENOMEM);\n                    ts->stop_parse = 1;\n                } else if (pes->data_index == 0 && buf_size > pes->total_size) {\n                    // pes packet size is < ts size packet and pes data is padded with 0xff\n                    // not sure if this is legal in ts but see issue #2392\n                    buf_size = pes->total_size;\n                }\n                memcpy(pes->buffer+pes->data_index, p, buf_size);\n                pes->data_index += buf_size;\n            }\n            buf_size = 0;\n            /* emit complete packets with known packet size\n             * decreases demuxer delay for infrequent packets like subtitles from\n             * a couple of seconds to milliseconds for properly muxed files.\n             * total_size is the number of bytes following pes_packet_length\n             * in the pes header, i.e. not counting the first 6 bytes */\n            if (!ts->stop_parse && pes->total_size < MAX_PES_PAYLOAD &&\n                pes->pes_header_size + pes->data_index == pes->total_size + 6) {\n                ts->stop_parse = 1;\n                new_pes_packet(pes, ts->pkt);\n            }\n            break;\n        case MPEGTS_SKIP:\n            buf_size = 0;\n            break;\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [175], "raw_before_change_lines": [175], "after_change_lines": [175], "raw_after_change_lines": [175], "bug_lines": [175], "added": [false], "idx": 269}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "6851----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_70b1b67bcf3a04d32d74a9b962868df949c7058a_1.json----decode_i2_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_70b1b67bcf3a04d32d74a9b962868df949c7058a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_70b1b67bcf3a04d32d74a9b962868df949c7058a_1.json", "function_name": "decode_i2_frame", "vul_func_code": "static int decode_i2_frame(FourXContext *f, AVFrame *frame, const uint8_t *buf, int length)\n{\n    int x, y, x2, y2;\n    const int width  = f->avctx->width;\n    const int height = f->avctx->height;\n    const int mbs    = (FFALIGN(width, 16) >> 4) * (FFALIGN(height, 16) >> 4);\n    uint16_t *dst    = (uint16_t*)frame->data[0];\n    const int stride =            frame->linesize[0]>>1;\n    GetByteContext g3;\n\n    if (length < mbs * 8) {\n        av_log(f->avctx, AV_LOG_ERROR, \"packet size too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_init(&g3, buf, length);\n\n    for (y = 0; y < height; y += 16) {\n        for (x = 0; x < width; x += 16) {\n            unsigned int color[4] = { 0 }, bits;\n            // warning following is purely guessed ...\n            color[0] = bytestream2_get_le16u(&g3);\n            color[1] = bytestream2_get_le16u(&g3);\n\n            if (color[0] & 0x8000)\n                av_log(f->avctx, AV_LOG_ERROR, \"unk bit 1\\n\");\n            if (color[1] & 0x8000)\n                av_log(f->avctx, AV_LOG_ERROR, \"unk bit 2\\n\");\n\n            color[2] = mix(color[0], color[1]);\n            color[3] = mix(color[1], color[0]);\n\n            bits = bytestream2_get_le32u(&g3);\n            for (y2 = 0; y2 < 16; y2++) {\n                for (x2 = 0; x2 < 16; x2++) {\n                    int index = 2 * (x2 >> 2) + 8 * (y2 >> 2);\n                    dst[y2 * stride + x2] = color[(bits >> index) & 3];\n                }\n            }\n            dst += 16;\n        }\n        dst += 16 * stride - x;\n    }\n\n    return 0;\n}", "patch_func_code": "static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length)\n{\n    int x, y, x2, y2;\n    const int width  = f->avctx->width;\n    const int height = f->avctx->height;\n    const int mbs    = (FFALIGN(width, 16) >> 4) * (FFALIGN(height, 16) >> 4);\n    uint16_t *dst    = f->frame_buffer;\n    GetByteContext g3;\n\n    if (length < mbs * 8) {\n        av_log(f->avctx, AV_LOG_ERROR, \"packet size too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_init(&g3, buf, length);\n\n    for (y = 0; y < height; y += 16) {\n        for (x = 0; x < width; x += 16) {\n            unsigned int color[4] = { 0 }, bits;\n            // warning following is purely guessed ...\n            color[0] = bytestream2_get_le16u(&g3);\n            color[1] = bytestream2_get_le16u(&g3);\n\n            if (color[0] & 0x8000)\n                av_log(f->avctx, AV_LOG_ERROR, \"unk bit 1\\n\");\n            if (color[1] & 0x8000)\n                av_log(f->avctx, AV_LOG_ERROR, \"unk bit 2\\n\");\n\n            color[2] = mix(color[0], color[1]);\n            color[3] = mix(color[1], color[0]);\n\n            bits = bytestream2_get_le32u(&g3);\n            for (y2 = 0; y2 < 16; y2++) {\n                for (x2 = 0; x2 < 16; x2++) {\n                    int index = 2 * (x2 >> 2) + 8 * (y2 >> 2);\n                    dst[y2 * width + x2] = color[(bits >> index) & 3];\n                }\n            }\n            dst += 16;\n        }\n        dst += 16 * width - x;\n    }\n\n    return 0;\n}", "before_change_lines": [1, 7, 8, 36, 41], "raw_before_change_lines": [1, 7, 8, 36, 41], "after_change_lines": [1, 7, 35, 40], "raw_after_change_lines": [1, 7, 35, 40], "bug_lines": [1, 7, 8, 36, 41], "added": [false, false, false, false, false], "idx": 270}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6880----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7253c7649136664c74320d2294bf3756561cdde1_1.json----mov_write_packet_internal", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_7253c7649136664c74320d2294bf3756561cdde1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7253c7649136664c74320d2294bf3756561cdde1_1.json", "function_name": "mov_write_packet_internal", "vul_func_code": "static int mov_write_packet_internal(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecContext *enc = trk->enc;\n    unsigned int samples_in_chunk = 0;\n    int size= pkt->size;\n    uint8_t *reformatted_data = NULL;\n\n    if (!s->pb->seekable && !(mov->flags & FF_MOV_FLAG_EMPTY_MOOV))\n        return 0; /* Can't handle that */\n\n    if (!size) return 0; /* Discard 0 sized packets */\n\n    if ((mov->max_fragment_duration && trk->entry &&\n         av_rescale_q(pkt->dts - trk->cluster[0].dts,\n                      s->streams[pkt->stream_index]->time_base,\n                      AV_TIME_BASE_Q) >= mov->max_fragment_duration) ||\n         (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) ||\n         (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME &&\n          enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n          trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) {\n        mov_flush_fragment(s);\n    }\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT && mov->fragments > 0) {\n        if (!trk->mdat_buf) {\n            int ret;\n            if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                return ret;\n        }\n        pb = trk->mdat_buf;\n    }\n\n    if (enc->codec_id == CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n    else\n        samples_in_chunk = 1;\n\n    /* copy extradata if it exists */\n    if (trk->vos_len == 0 && enc->extradata_size > 0) {\n        trk->vos_len = enc->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        memcpy(trk->vos_data, enc->extradata, trk->vos_len);\n    }\n\n    if (enc->codec_id == CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1) {\n        /* from x264 or from bytestream h264 */\n        /* nal reformating needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n        }\n    } else {\n        avio_write(pb, pkt->data, size);\n    }\n\n    if ((enc->codec_id == CODEC_ID_DNXHD ||\n         enc->codec_id == CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data)\n            return AVERROR(ENOMEM);\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n        if (!trk->cluster)\n            return -1;\n    }\n\n    trk->cluster[trk->entry].pos = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].size = size;\n    trk->cluster[trk->entry].entries = samples_in_chunk;\n    trk->cluster[trk->entry].dts = pkt->dts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        /* First packet of a new fragment. We already wrote the duration\n         * of the last packet of the previous fragment based on track_duration,\n         * which might not exactly match our dts. Therefore adjust the dts\n         * of this packet to be what the previous packets duration implies. */\n        trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE)\n        trk->start_dts = pkt->dts;\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (enc->codec_id == CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk, mov->fragments);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && enc->codec_id == CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size += size;\n\n    avio_flush(pb);\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n    av_free(reformatted_data);\n    return 0;\n}", "patch_func_code": "static int mov_write_packet_internal(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    AVCodecContext *enc = trk->enc;\n    unsigned int samples_in_chunk = 0;\n    int size= pkt->size;\n    uint8_t *reformatted_data = NULL;\n\n    if (!s->pb->seekable && !(mov->flags & FF_MOV_FLAG_EMPTY_MOOV))\n        return 0; /* Can't handle that */\n\n    if (!size) return 0; /* Discard 0 sized packets */\n\n    if ((mov->max_fragment_duration && trk->entry &&\n         av_rescale_q(pkt->dts - trk->cluster[0].dts,\n                      s->streams[pkt->stream_index]->time_base,\n                      AV_TIME_BASE_Q) >= mov->max_fragment_duration) ||\n         (mov->max_fragment_size && mov->mdat_size + size >= mov->max_fragment_size) ||\n         (mov->flags & FF_MOV_FLAG_FRAG_KEYFRAME &&\n          enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n          trk->entry && pkt->flags & AV_PKT_FLAG_KEY)) {\n        mov_flush_fragment(s);\n    }\n\n    if (mov->flags & FF_MOV_FLAG_FRAGMENT) {\n        int ret;\n        if (mov->fragments > 0) {\n            if (!trk->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&trk->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = trk->mdat_buf;\n        } else {\n            if (!mov->mdat_buf) {\n                if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n                    return ret;\n            }\n            pb = mov->mdat_buf;\n        }\n    }\n\n    if (enc->codec_id == CODEC_ID_AMR_NB) {\n        /* We must find out how many AMR blocks there are in one packet */\n        static uint16_t packed_size[16] =\n            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 1};\n        int len = 0;\n\n        while (len < size && samples_in_chunk < 100) {\n            len += packed_size[(pkt->data[len] >> 3) & 0x0F];\n            samples_in_chunk++;\n        }\n        if (samples_in_chunk > 1) {\n            av_log(s, AV_LOG_ERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\");\n            return -1;\n        }\n    } else if (trk->sample_size)\n        samples_in_chunk = size / trk->sample_size;\n    else\n        samples_in_chunk = 1;\n\n    /* copy extradata if it exists */\n    if (trk->vos_len == 0 && enc->extradata_size > 0) {\n        trk->vos_len = enc->extradata_size;\n        trk->vos_data = av_malloc(trk->vos_len);\n        memcpy(trk->vos_data, enc->extradata, trk->vos_len);\n    }\n\n    if (enc->codec_id == CODEC_ID_H264 && trk->vos_len > 0 && *(uint8_t *)trk->vos_data != 1) {\n        /* from x264 or from bytestream h264 */\n        /* nal reformating needed */\n        if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams) {\n            ff_avc_parse_nal_units_buf(pkt->data, &reformatted_data,\n                                       &size);\n            avio_write(pb, reformatted_data, size);\n        } else {\n            size = ff_avc_parse_nal_units(pb, pkt->data, pkt->size);\n        }\n    } else {\n        avio_write(pb, pkt->data, size);\n    }\n\n    if ((enc->codec_id == CODEC_ID_DNXHD ||\n         enc->codec_id == CODEC_ID_AC3) && !trk->vos_len) {\n        /* copy frame to create needed atoms */\n        trk->vos_len = size;\n        trk->vos_data = av_malloc(size);\n        if (!trk->vos_data)\n            return AVERROR(ENOMEM);\n        memcpy(trk->vos_data, pkt->data, size);\n    }\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n        if (!trk->cluster)\n            return -1;\n    }\n\n    trk->cluster[trk->entry].pos = avio_tell(pb) - size;\n    trk->cluster[trk->entry].samples_in_chunk = samples_in_chunk;\n    trk->cluster[trk->entry].size = size;\n    trk->cluster[trk->entry].entries = samples_in_chunk;\n    trk->cluster[trk->entry].dts = pkt->dts;\n    if (!trk->entry && trk->start_dts != AV_NOPTS_VALUE) {\n        /* First packet of a new fragment. We already wrote the duration\n         * of the last packet of the previous fragment based on track_duration,\n         * which might not exactly match our dts. Therefore adjust the dts\n         * of this packet to be what the previous packets duration implies. */\n        trk->cluster[trk->entry].dts = trk->start_dts + trk->track_duration;\n    }\n    if (trk->start_dts == AV_NOPTS_VALUE)\n        trk->start_dts = pkt->dts;\n    trk->track_duration = pkt->dts - trk->start_dts + pkt->duration;\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n        pkt->pts = pkt->dts;\n    }\n    if (pkt->dts != pkt->pts)\n        trk->flags |= MOV_TRACK_CTTS;\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n    trk->cluster[trk->entry].flags = 0;\n    if (enc->codec_id == CODEC_ID_VC1) {\n        mov_parse_vc1_frame(pkt, trk, mov->fragments);\n    } else if (pkt->flags & AV_PKT_FLAG_KEY) {\n        if (mov->mode == MODE_MOV && enc->codec_id == CODEC_ID_MPEG2VIDEO &&\n            trk->entry > 0) { // force sync sample for the first key frame\n            mov_parse_mpeg2_frame(pkt, &trk->cluster[trk->entry].flags);\n            if (trk->cluster[trk->entry].flags & MOV_PARTIAL_SYNC_SAMPLE)\n                trk->flags |= MOV_TRACK_STPS;\n        } else {\n            trk->cluster[trk->entry].flags = MOV_SYNC_SAMPLE;\n        }\n        if (trk->cluster[trk->entry].flags & MOV_SYNC_SAMPLE)\n            trk->has_keyframes++;\n    }\n    trk->entry++;\n    trk->sample_count += samples_in_chunk;\n    mov->mdat_size += size;\n\n    avio_flush(pb);\n\n    if (trk->hint_track >= 0 && trk->hint_track < mov->nb_streams)\n        ff_mov_add_hinted_packet(s, pkt, trk->hint_track, trk->entry,\n                                 reformatted_data, size);\n    av_free(reformatted_data);\n    return 0;\n}", "before_change_lines": [27, 28, 29, 30, 31, 33], "raw_before_change_lines": [27, 28, 29, 30, 31, 33], "after_change_lines": [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], "raw_after_change_lines": [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], "bug_lines": [27, 28, 29, 30, 31, 33], "added": [false, false, false, false, false, false], "idx": 271}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "6886----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_72e7f0a84efc09519b51f5b5cdec49d2f43856d4_1.json----vmdaudio_decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_72e7f0a84efc09519b51f5b5cdec49d2f43856d4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_72e7f0a84efc09519b51f5b5cdec49d2f43856d4_1.json", "function_name": "vmdaudio_decode_frame", "vul_func_code": "static int vmdaudio_decode_frame(AVCodecContext *avctx,\n                                 void *data, int *data_size,\n                                 AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    VmdAudioContext *s = avctx->priv_data;\n    unsigned char *output_samples = (unsigned char *)data;\n\n    /* point to the start of the encoded data */\n    const unsigned char *p = buf + 16;\n\n    if (buf_size < 16)\n        return buf_size;\n\n    if (buf[6] == 1) {\n        /* the chunk contains audio */\n        *data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16);\n    } else if (buf[6] == 2) {\n        /* initial chunk, may contain audio and silence */\n        uint32_t flags = AV_RB32(p);\n        int raw_block_size = s->block_align *\n                             (av_get_bits_per_sample_fmt(avctx->sample_fmt) / 8);\n        int silent_chunks;\n        if(flags == 0xFFFFFFFF)\n            silent_chunks = 32;\n        else\n            silent_chunks = av_log2(flags + 1);\n        if(*data_size < (s->block_align*silent_chunks + buf_size - 20) * 2)\n            return -1;\n        *data_size = 0;\n        memset(output_samples, 0, raw_block_size * silent_chunks);\n        output_samples += raw_block_size * silent_chunks;\n        *data_size = raw_block_size * silent_chunks;\n        *data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20);\n    } else if (buf[6] == 3) {\n        /* silent chunk */\n        *data_size = vmdaudio_loadsound(s, output_samples, p, 1, s->block_align);\n    }\n\n    return buf_size;\n}", "patch_func_code": "static int vmdaudio_decode_frame(AVCodecContext *avctx,\n                                 void *data, int *data_size,\n                                 AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    VmdAudioContext *s = avctx->priv_data;\n    unsigned char *output_samples = (unsigned char *)data;\n\n    /* point to the start of the encoded data */\n    const unsigned char *p = buf + 16;\n\n    if (buf_size < 16)\n        return buf_size;\n\n    if (buf[6] == 1) {\n        /* the chunk contains audio */\n        *data_size = vmdaudio_loadsound(s, output_samples, p, 0, buf_size - 16);\n    } else if (buf[6] == 2) {\n        /* initial chunk, may contain audio and silence */\n        uint32_t flags = AV_RB32(p);\n        int raw_block_size = s->block_align *\n                             (av_get_bits_per_sample_fmt(avctx->sample_fmt) / 8);\n        int silent_chunks = av_popcount(flags);\n        if(*data_size < (s->block_align*silent_chunks + buf_size - 20) * 2)\n            return -1;\n        *data_size = 0;\n        memset(output_samples, 0, raw_block_size * silent_chunks);\n        output_samples += raw_block_size * silent_chunks;\n        *data_size = raw_block_size * silent_chunks;\n        *data_size += vmdaudio_loadsound(s, output_samples, p + 4, 0, buf_size - 20);\n    } else if (buf[6] == 3) {\n        /* silent chunk */\n        *data_size = vmdaudio_loadsound(s, output_samples, p, 1, s->block_align);\n    }\n\n    return buf_size;\n}", "before_change_lines": [24, 25, 26, 27, 28], "raw_before_change_lines": [24, 25, 26, 27, 28], "after_change_lines": [24], "raw_after_change_lines": [24], "bug_lines": [24, 25, 26, 27, 28], "added": [false, false, false, false, false], "idx": 272}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7048----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7b9818ec3c24ccabdc039e1b0085113ebad9f1e3_1.json----ff_rm_retrieve_cache", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_7b9818ec3c24ccabdc039e1b0085113ebad9f1e3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7b9818ec3c24ccabdc039e1b0085113ebad9f1e3_1.json", "function_name": "ff_rm_retrieve_cache", "vul_func_code": "int\nff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n                      AVStream *st, RMStream *ast, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n\n    assert (rm->audio_pkt_cnt > 0);\n\n    if (ast->deint_id == DEINT_ID_VBRF ||\n        ast->deint_id == DEINT_ID_VBRS)\n        av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]);\n    else {\n        int ret = av_new_packet(pkt, st->codec->block_align);\n        if (ret < 0)\n            return ret;\n        memcpy(pkt->data, ast->pkt.data + st->codec->block_align * //FIXME avoid this\n               (ast->sub_packet_h * ast->audio_framesize / st->codec->block_align - rm->audio_pkt_cnt),\n               st->codec->block_align);\n    }\n    rm->audio_pkt_cnt--;\n    if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) {\n        ast->audiotimestamp = AV_NOPTS_VALUE;\n        pkt->flags = AV_PKT_FLAG_KEY;\n    } else\n        pkt->flags = 0;\n    pkt->stream_index = st->index;\n\n    return rm->audio_pkt_cnt;\n}", "patch_func_code": "int\nff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n                      AVStream *st, RMStream *ast, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n\n    assert (rm->audio_pkt_cnt > 0);\n\n    if (ast->deint_id == DEINT_ID_VBRF ||\n        ast->deint_id == DEINT_ID_VBRS)\n        av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]);\n    else {\n        int ret = av_new_packet(pkt, st->codecpar->block_align);\n        if (ret < 0)\n            return ret;\n        memcpy(pkt->data, ast->pkt.data + st->codecpar->block_align * //FIXME avoid this\n               (ast->sub_packet_h * ast->audio_framesize / st->codecpar->block_align - rm->audio_pkt_cnt),\n               st->codecpar->block_align);\n    }\n    rm->audio_pkt_cnt--;\n    if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) {\n        ast->audiotimestamp = AV_NOPTS_VALUE;\n        pkt->flags = AV_PKT_FLAG_KEY;\n    } else\n        pkt->flags = 0;\n    pkt->stream_index = st->index;\n\n    return rm->audio_pkt_cnt;\n}", "before_change_lines": [13, 16, 17, 18], "raw_before_change_lines": [13, 16, 17, 18], "after_change_lines": [13, 16, 17, 18], "raw_after_change_lines": [13, 16, 17, 18], "bug_lines": [13, 16, 17, 18], "added": [false, false, false, false], "idx": 273}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7106----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7f848f889e2cc759651b139a2cae956e8e5c4c10_1.json----pred8x8_top_dc_rv40_c", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_7f848f889e2cc759651b139a2cae956e8e5c4c10_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_7f848f889e2cc759651b139a2cae956e8e5c4c10_1.json", "function_name": "pred8x8_top_dc_rv40_c", "vul_func_code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n    int i;\n    unsigned dc0;\n\n    dc0=0;\n    for(i=0;i<8; i++)\n        dc0+= src[i-stride];\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n    for(i=0; i<8; i++){\n        ((uint32_t*)(src+i*stride))[0]=\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n    }\n}", "patch_func_code": "static void pred8x8_top_dc_rv40_c(uint8_t *src, ptrdiff_t stride)\n{\n    int i;\n    unsigned dc0;\n\n    dc0=0;\n    for(i=0;i<8; i++)\n        dc0+= src[i-stride];\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n    for(i=0; i<8; i++){\n        ((uint32_t*)(src+i*stride))[0]=\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n    }\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1, 2], "raw_after_change_lines": [1, 2], "bug_lines": [1], "added": [false], "idx": 274}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "7116----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8093fcd4548b7e08ce1b7195d06f5c8d32cf0c28_1.json----await_reference_mb_row", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_8093fcd4548b7e08ce1b7195d06f5c8d32cf0c28_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8093fcd4548b7e08ce1b7195d06f5c8d32cf0c28_1.json", "function_name": "await_reference_mb_row", "vul_func_code": "static void await_reference_mb_row(const H264Context *const h, H264Picture *ref,\n                                   int mb_y)\n{\n    int ref_field         = ref->reference - 1;\n    int ref_field_picture = ref->field_picture;\n    int ref_height        = 16 * h->mb_height >> ref_field_picture;\n\n    if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_FRAME))\n        return;\n\n    /* FIXME: It can be safe to access mb stuff\n     * even if pixels aren't deblocked yet. */\n\n    ff_thread_await_progress(&ref->tf,\n                             FFMIN(16 * mb_y >> ref_field_picture,\n                                   ref_height - 1),\n                             ref_field_picture && ref_field);\n}", "patch_func_code": "static void await_reference_mb_row(const H264Context *const h, H264Ref *ref,\n                                   int mb_y)\n{\n    int ref_field         = ref->reference - 1;\n    int ref_field_picture = ref->parent->field_picture;\n    int ref_height        = 16 * h->mb_height >> ref_field_picture;\n\n    if (!HAVE_THREADS || !(h->avctx->active_thread_type & FF_THREAD_FRAME))\n        return;\n\n    /* FIXME: It can be safe to access mb stuff\n     * even if pixels aren't deblocked yet. */\n\n    ff_thread_await_progress(&ref->parent->tf,\n                             FFMIN(16 * mb_y >> ref_field_picture,\n                                   ref_height - 1),\n                             ref_field_picture && ref_field);\n}", "before_change_lines": [1, 5, 14], "raw_before_change_lines": [1, 5, 14], "after_change_lines": [1, 5, 14], "raw_after_change_lines": [1, 5, 14], "bug_lines": [1, 5, 14], "added": [false, false, false], "idx": 275}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7179----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_84baf70d72a069c01cbb6ae861ce460642e60d5a_1.json----planarCopyWrapper", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_84baf70d72a069c01cbb6ae861ce460642e60d5a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_84baf70d72a069c01cbb6ae861ce460642e60d5a_1.json", "function_name": "planarCopyWrapper", "vul_func_code": "static int planarCopyWrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,\n                             int srcSliceH, uint8_t* dst[], int dstStride[])\n{\n    int plane, i, j;\n    for (plane=0; plane<4; plane++) {\n        int length= (plane==0 || plane==3) ? c->srcW  : -((-c->srcW  )>>c->chrDstHSubSample);\n        int y=      (plane==0 || plane==3) ? srcSliceY: -((-srcSliceY)>>c->chrDstVSubSample);\n        int height= (plane==0 || plane==3) ? srcSliceH: -((-srcSliceH)>>c->chrDstVSubSample);\n        const uint8_t *srcPtr= src[plane];\n        uint8_t *dstPtr= dst[plane] + dstStride[plane]*y;\n\n        if (!dst[plane]) continue;\n        // ignore palette for GRAY8\n        if (plane == 1 && !dst[2]) continue;\n        if (!src[plane] || (plane == 1 && !src[2])) {\n            if(is16BPS(c->dstFormat))\n                length*=2;\n            fillPlane(dst[plane], dstStride[plane], length, height, y, (plane==3) ? 255 : 128);\n        } else {\n            if(is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) {\n                if (!isBE(c->srcFormat)) srcPtr++;\n                for (i=0; i<height; i++) {\n                    for (j=0; j<length; j++) dstPtr[j] = srcPtr[j<<1];\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            } else if(!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) {\n                for (i=0; i<height; i++) {\n                    for (j=0; j<length; j++) {\n                        dstPtr[ j<<1   ] = srcPtr[j];\n                        dstPtr[(j<<1)+1] = srcPtr[j];\n                    }\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            } else if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat)\n                  && isBE(c->srcFormat) != isBE(c->dstFormat)) {\n\n                for (i=0; i<height; i++) {\n                    for (j=0; j<length; j++)\n                        ((uint16_t*)dstPtr)[j] = av_bswap16(((const uint16_t*)srcPtr)[j]);\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0)\n                memcpy(dst[plane] + dstStride[plane]*y, src[plane], height*dstStride[plane]);\n            else {\n                if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat))\n                    length*=2;\n                for (i=0; i<height; i++) {\n                    memcpy(dstPtr, srcPtr, length);\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            }\n        }\n    }\n    return srcSliceH;\n}", "patch_func_code": "static int planarCopyWrapper(SwsContext *c, const uint8_t* src[], int srcStride[], int srcSliceY,\n                             int srcSliceH, uint8_t* dst[], int dstStride[])\n{\n    int plane, i, j;\n    for (plane=0; plane<4; plane++) {\n        int length= (plane==0 || plane==3) ? c->srcW  : -((-c->srcW  )>>c->chrDstHSubSample);\n        int y=      (plane==0 || plane==3) ? srcSliceY: -((-srcSliceY)>>c->chrDstVSubSample);\n        int height= (plane==0 || plane==3) ? srcSliceH: -((-srcSliceH)>>c->chrDstVSubSample);\n        const uint8_t *srcPtr= src[plane];\n        uint8_t *dstPtr= dst[plane] + dstStride[plane]*y;\n\n        if (!dst[plane]) continue;\n        // ignore palette for GRAY8\n        if (plane == 1 && !dst[2]) continue;\n        if (!src[plane] || (plane == 1 && !src[2])) {\n            if(is16BPS(c->dstFormat))\n                length*=2;\n            fillPlane(dst[plane], dstStride[plane], length, height, y, (plane==3) ? 255 : 128);\n        } else {\n            if(is16BPS(c->srcFormat) && !is16BPS(c->dstFormat)) {\n                if (!isBE(c->srcFormat)) srcPtr++;\n                for (i=0; i<height; i++) {\n                    for (j=0; j<length; j++) dstPtr[j] = srcPtr[j<<1];\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            } else if(!is16BPS(c->srcFormat) && is16BPS(c->dstFormat)) {\n                for (i=0; i<height; i++) {\n                    for (j=0; j<length; j++) {\n                        dstPtr[ j<<1   ] = srcPtr[j];\n                        dstPtr[(j<<1)+1] = srcPtr[j];\n                    }\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            } else if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat)\n                  && isBE(c->srcFormat) != isBE(c->dstFormat)) {\n\n                for (i=0; i<height; i++) {\n                    for (j=0; j<length; j++)\n                        ((uint16_t*)dstPtr)[j] = av_bswap16(((const uint16_t*)srcPtr)[j]);\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            } else if (dstStride[plane]==srcStride[plane] && srcStride[plane] > 0) {\n                if (height > 0)\n                    memcpy(dst[plane] + dstStride[plane]*y, src[plane],\n                           (height - 1)*dstStride[plane] + length);\n            } else {\n                if(is16BPS(c->srcFormat) && is16BPS(c->dstFormat))\n                    length*=2;\n                for (i=0; i<height; i++) {\n                    memcpy(dstPtr, srcPtr, length);\n                    srcPtr+= srcStride[plane];\n                    dstPtr+= dstStride[plane];\n                }\n            }\n        }\n    }\n    return srcSliceH;\n}", "before_change_lines": [45, 46, 47], "raw_before_change_lines": [45, 46, 47], "after_change_lines": [45, 46, 47, 48, 49], "raw_after_change_lines": [45, 46, 47, 48, 49], "bug_lines": [45, 46, 47], "added": [false, false, false], "idx": 276}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7186----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_85313cf32b4fd059ece5ea69e8df39432cb2e2c9_1.json----vc1_parse_frame_header_adv", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_85313cf32b4fd059ece5ea69e8df39432cb2e2c9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_85313cf32b4fd059ece5ea69e8df39432cb2e2c9_1.json", "function_name": "vc1_parse_frame_header_adv", "vul_func_code": "int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb)\n{\n    int pqindex, lowquant;\n    int status;\n\n    v->p_frame_skipped = 0;\n\n    if(v->interlace){\n        v->fcm = decode012(gb);\n        if(v->fcm){\n            if(!v->warn_interlaced++)\n                av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced frames/fields support is not implemented\\n\");\n            return -1;\n        }\n    }\n    switch(get_unary(gb, 0, 4)) {\n    case 0:\n        v->s.pict_type = AV_PICTURE_TYPE_P;\n        break;\n    case 1:\n        v->s.pict_type = AV_PICTURE_TYPE_B;\n        break;\n    case 2:\n        v->s.pict_type = AV_PICTURE_TYPE_I;\n        break;\n    case 3:\n        v->s.pict_type = AV_PICTURE_TYPE_BI;\n        break;\n    case 4:\n        v->s.pict_type = AV_PICTURE_TYPE_P; // skipped pic\n        v->p_frame_skipped = 1;\n        return 0;\n    }\n    if(v->tfcntrflag)\n        skip_bits(gb, 8);\n    if(v->broadcast) {\n        if(!v->interlace || v->psf) {\n            v->rptfrm = get_bits(gb, 2);\n        } else {\n            v->tff = get_bits1(gb);\n            v->rptfrm = get_bits1(gb);\n        }\n    }\n    if(v->panscanflag) {\n        av_log_missing_feature(v->s.avctx, \"Pan-scan\", 0);\n        //...\n    }\n    v->rnd = get_bits1(gb);\n    if(v->interlace)\n        v->uvsamp = get_bits1(gb);\n    if(v->finterpflag) v->interpfrm = get_bits1(gb);\n    if(v->s.pict_type == AV_PICTURE_TYPE_B) {\n        v->bfraction_lut_index = get_vlc2(gb, ff_vc1_bfraction_vlc.table, VC1_BFRACTION_VLC_BITS, 1);\n        v->bfraction = ff_vc1_bfraction_lut[v->bfraction_lut_index];\n        if(v->bfraction == 0) {\n            v->s.pict_type = AV_PICTURE_TYPE_BI; /* XXX: should not happen here */\n        }\n    }\n    pqindex = get_bits(gb, 5);\n    if(!pqindex) return -1;\n    v->pqindex = pqindex;\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n        v->pq = ff_vc1_pquant_table[0][pqindex];\n    else\n        v->pq = ff_vc1_pquant_table[1][pqindex];\n\n    v->pquantizer = 1;\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n        v->pquantizer = pqindex < 9;\n    if (v->quantizer_mode == QUANT_NON_UNIFORM)\n        v->pquantizer = 0;\n    v->pqindex = pqindex;\n    if (pqindex < 9) v->halfpq = get_bits1(gb);\n    else v->halfpq = 0;\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n        v->pquantizer = get_bits1(gb);\n    if(v->postprocflag)\n        v->postproc = get_bits(gb, 2);\n\n    if(v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_P) v->use_ic = 0;\n\n    if(v->parse_only)\n        return 0;\n\n    switch(v->s.pict_type) {\n    case AV_PICTURE_TYPE_I:\n    case AV_PICTURE_TYPE_BI:\n        status = bitplane_decoding(v->acpred_plane, &v->acpred_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"ACPRED plane encoding: \"\n                \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n        v->condover = CONDOVER_NONE;\n        if(v->overlap && v->pq <= 8) {\n            v->condover = decode012(gb);\n            if(v->condover == CONDOVER_SELECT) {\n                status = bitplane_decoding(v->over_flags_plane, &v->overflg_is_raw, v);\n                if (status < 0) return -1;\n                av_log(v->s.avctx, AV_LOG_DEBUG, \"CONDOVER plane encoding: \"\n                        \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n            }\n        }\n        break;\n    case AV_PICTURE_TYPE_P:\n        if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3);\n        else v->mvrange = 0;\n        v->k_x = v->mvrange + 9 + (v->mvrange >> 1); //k_x can be 9 10 12 13\n        v->k_y = v->mvrange + 8; //k_y can be 8 9 10 11\n        v->range_x = 1 << (v->k_x - 1);\n        v->range_y = 1 << (v->k_y - 1);\n\n        if (v->pq < 5) v->tt_index = 0;\n        else if(v->pq < 13) v->tt_index = 1;\n        else v->tt_index = 2;\n\n        lowquant = (v->pq > 12) ? 0 : 1;\n        v->mv_mode = ff_vc1_mv_pmode_table[lowquant][get_unary(gb, 1, 4)];\n        if (v->mv_mode == MV_PMODE_INTENSITY_COMP)\n        {\n            int scale, shift, i;\n            v->mv_mode2 = ff_vc1_mv_pmode_table2[lowquant][get_unary(gb, 1, 3)];\n            v->lumscale = get_bits(gb, 6);\n            v->lumshift = get_bits(gb, 6);\n            /* fill lookup tables for intensity compensation */\n            if(!v->lumscale) {\n                scale = -64;\n                shift = (255 - v->lumshift * 2) << 6;\n                if(v->lumshift > 31)\n                    shift += 128 << 6;\n            } else {\n                scale = v->lumscale + 32;\n                if(v->lumshift > 31)\n                    shift = (v->lumshift - 64) << 6;\n                else\n                    shift = v->lumshift << 6;\n            }\n            for(i = 0; i < 256; i++) {\n                v->luty[i] = av_clip_uint8((scale * i + shift + 32) >> 6);\n                v->lutuv[i] = av_clip_uint8((scale * (i - 128) + 128*64 + 32) >> 6);\n            }\n            v->use_ic = 1;\n        }\n        if(v->mv_mode == MV_PMODE_1MV_HPEL || v->mv_mode == MV_PMODE_1MV_HPEL_BILIN)\n            v->s.quarter_sample = 0;\n        else if(v->mv_mode == MV_PMODE_INTENSITY_COMP) {\n            if(v->mv_mode2 == MV_PMODE_1MV_HPEL || v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN)\n                v->s.quarter_sample = 0;\n            else\n                v->s.quarter_sample = 1;\n        } else\n            v->s.quarter_sample = 1;\n        v->s.mspel = !(v->mv_mode == MV_PMODE_1MV_HPEL_BILIN || (v->mv_mode == MV_PMODE_INTENSITY_COMP && v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN));\n\n        if ((v->mv_mode == MV_PMODE_INTENSITY_COMP &&\n                 v->mv_mode2 == MV_PMODE_MIXED_MV)\n                || v->mv_mode == MV_PMODE_MIXED_MV)\n        {\n            status = bitplane_decoding(v->mv_type_mb_plane, &v->mv_type_is_raw, v);\n            if (status < 0) return -1;\n            av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n                   \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n        } else {\n            v->mv_type_is_raw = 0;\n            memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height);\n        }\n        status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Skip plane encoding: \"\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n        /* Hopefully this is correct for P frames */\n        v->s.mv_table_index = get_bits(gb, 2); //but using ff_vc1_ tables\n        v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)];\n        if (v->dquant)\n        {\n            av_log(v->s.avctx, AV_LOG_DEBUG, \"VOP DQuant info\\n\");\n            vop_dquant_decoding(v);\n        }\n\n        v->ttfrm = 0; //FIXME Is that so ?\n        if (v->vstransform)\n        {\n            v->ttmbf = get_bits1(gb);\n            if (v->ttmbf)\n            {\n                v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)];\n            }\n        } else {\n            v->ttmbf = 1;\n            v->ttfrm = TT_8X8;\n        }\n        break;\n    case AV_PICTURE_TYPE_B:\n        if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3);\n        else v->mvrange = 0;\n        v->k_x = v->mvrange + 9 + (v->mvrange >> 1); //k_x can be 9 10 12 13\n        v->k_y = v->mvrange + 8; //k_y can be 8 9 10 11\n        v->range_x = 1 << (v->k_x - 1);\n        v->range_y = 1 << (v->k_y - 1);\n\n        if (v->pq < 5) v->tt_index = 0;\n        else if(v->pq < 13) v->tt_index = 1;\n        else v->tt_index = 2;\n\n        v->mv_mode = get_bits1(gb) ? MV_PMODE_1MV : MV_PMODE_1MV_HPEL_BILIN;\n        v->s.quarter_sample = (v->mv_mode == MV_PMODE_1MV);\n        v->s.mspel = v->s.quarter_sample;\n\n        status = bitplane_decoding(v->direct_mb_plane, &v->dmb_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct Type plane encoding: \"\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n        status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Skip plane encoding: \"\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n        v->s.mv_table_index = get_bits(gb, 2);\n        v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)];\n\n        if (v->dquant)\n        {\n            av_log(v->s.avctx, AV_LOG_DEBUG, \"VOP DQuant info\\n\");\n            vop_dquant_decoding(v);\n        }\n\n        v->ttfrm = 0;\n        if (v->vstransform)\n        {\n            v->ttmbf = get_bits1(gb);\n            if (v->ttmbf)\n            {\n                v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)];\n            }\n        } else {\n            v->ttmbf = 1;\n            v->ttfrm = TT_8X8;\n        }\n        break;\n    }\n\n    /* AC Syntax */\n    v->c_ac_table_index = decode012(gb);\n    if (v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI)\n    {\n        v->y_ac_table_index = decode012(gb);\n    }\n    /* DC Syntax */\n    v->s.dc_table_index = get_bits1(gb);\n    if ((v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI) && v->dquant) {\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"VOP DQuant info\\n\");\n        vop_dquant_decoding(v);\n    }\n\n    v->bi_type = 0;\n    if(v->s.pict_type == AV_PICTURE_TYPE_BI) {\n        v->s.pict_type = AV_PICTURE_TYPE_B;\n        v->bi_type = 1;\n    }\n    return 0;\n}", "patch_func_code": "int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb)\n{\n    int pqindex, lowquant;\n    int status;\n\n    v->p_frame_skipped = 0;\n\n    if(v->interlace){\n        v->fcm = decode012(gb);\n        if(v->fcm){\n            if(!v->warn_interlaced++)\n                av_log(v->s.avctx, AV_LOG_ERROR, \"Interlaced frames/fields support is not implemented\\n\");\n            return -1;\n        }\n    }\n    switch(get_unary(gb, 0, 4)) {\n    case 0:\n        v->s.pict_type = AV_PICTURE_TYPE_P;\n        break;\n    case 1:\n        v->s.pict_type = AV_PICTURE_TYPE_B;\n        break;\n    case 2:\n        v->s.pict_type = AV_PICTURE_TYPE_I;\n        break;\n    case 3:\n        v->s.pict_type = AV_PICTURE_TYPE_BI;\n        break;\n    case 4:\n        v->s.pict_type = AV_PICTURE_TYPE_P; // skipped pic\n        v->p_frame_skipped = 1;\n        break;\n    }\n    if(v->tfcntrflag)\n        skip_bits(gb, 8);\n    if(v->broadcast) {\n        if(!v->interlace || v->psf) {\n            v->rptfrm = get_bits(gb, 2);\n        } else {\n            v->tff = get_bits1(gb);\n            v->rff = get_bits1(gb);\n        }\n    }\n    if(v->panscanflag) {\n        av_log_missing_feature(v->s.avctx, \"Pan-scan\", 0);\n        //...\n    }\n    if(v->p_frame_skipped) {\n        return 0;\n    }\n    v->rnd = get_bits1(gb);\n    if(v->interlace)\n        v->uvsamp = get_bits1(gb);\n    if(v->finterpflag) v->interpfrm = get_bits1(gb);\n    if(v->s.pict_type == AV_PICTURE_TYPE_B) {\n        v->bfraction_lut_index = get_vlc2(gb, ff_vc1_bfraction_vlc.table, VC1_BFRACTION_VLC_BITS, 1);\n        v->bfraction = ff_vc1_bfraction_lut[v->bfraction_lut_index];\n        if(v->bfraction == 0) {\n            v->s.pict_type = AV_PICTURE_TYPE_BI; /* XXX: should not happen here */\n        }\n    }\n    pqindex = get_bits(gb, 5);\n    if(!pqindex) return -1;\n    v->pqindex = pqindex;\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n        v->pq = ff_vc1_pquant_table[0][pqindex];\n    else\n        v->pq = ff_vc1_pquant_table[1][pqindex];\n\n    v->pquantizer = 1;\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n        v->pquantizer = pqindex < 9;\n    if (v->quantizer_mode == QUANT_NON_UNIFORM)\n        v->pquantizer = 0;\n    v->pqindex = pqindex;\n    if (pqindex < 9) v->halfpq = get_bits1(gb);\n    else v->halfpq = 0;\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n        v->pquantizer = get_bits1(gb);\n    if(v->postprocflag)\n        v->postproc = get_bits(gb, 2);\n\n    if(v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_P) v->use_ic = 0;\n\n    if(v->parse_only)\n        return 0;\n\n    switch(v->s.pict_type) {\n    case AV_PICTURE_TYPE_I:\n    case AV_PICTURE_TYPE_BI:\n        status = bitplane_decoding(v->acpred_plane, &v->acpred_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"ACPRED plane encoding: \"\n                \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n        v->condover = CONDOVER_NONE;\n        if(v->overlap && v->pq <= 8) {\n            v->condover = decode012(gb);\n            if(v->condover == CONDOVER_SELECT) {\n                status = bitplane_decoding(v->over_flags_plane, &v->overflg_is_raw, v);\n                if (status < 0) return -1;\n                av_log(v->s.avctx, AV_LOG_DEBUG, \"CONDOVER plane encoding: \"\n                        \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n            }\n        }\n        break;\n    case AV_PICTURE_TYPE_P:\n        if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3);\n        else v->mvrange = 0;\n        v->k_x = v->mvrange + 9 + (v->mvrange >> 1); //k_x can be 9 10 12 13\n        v->k_y = v->mvrange + 8; //k_y can be 8 9 10 11\n        v->range_x = 1 << (v->k_x - 1);\n        v->range_y = 1 << (v->k_y - 1);\n\n        if (v->pq < 5) v->tt_index = 0;\n        else if(v->pq < 13) v->tt_index = 1;\n        else v->tt_index = 2;\n\n        lowquant = (v->pq > 12) ? 0 : 1;\n        v->mv_mode = ff_vc1_mv_pmode_table[lowquant][get_unary(gb, 1, 4)];\n        if (v->mv_mode == MV_PMODE_INTENSITY_COMP)\n        {\n            int scale, shift, i;\n            v->mv_mode2 = ff_vc1_mv_pmode_table2[lowquant][get_unary(gb, 1, 3)];\n            v->lumscale = get_bits(gb, 6);\n            v->lumshift = get_bits(gb, 6);\n            /* fill lookup tables for intensity compensation */\n            if(!v->lumscale) {\n                scale = -64;\n                shift = (255 - v->lumshift * 2) << 6;\n                if(v->lumshift > 31)\n                    shift += 128 << 6;\n            } else {\n                scale = v->lumscale + 32;\n                if(v->lumshift > 31)\n                    shift = (v->lumshift - 64) << 6;\n                else\n                    shift = v->lumshift << 6;\n            }\n            for(i = 0; i < 256; i++) {\n                v->luty[i] = av_clip_uint8((scale * i + shift + 32) >> 6);\n                v->lutuv[i] = av_clip_uint8((scale * (i - 128) + 128*64 + 32) >> 6);\n            }\n            v->use_ic = 1;\n        }\n        if(v->mv_mode == MV_PMODE_1MV_HPEL || v->mv_mode == MV_PMODE_1MV_HPEL_BILIN)\n            v->s.quarter_sample = 0;\n        else if(v->mv_mode == MV_PMODE_INTENSITY_COMP) {\n            if(v->mv_mode2 == MV_PMODE_1MV_HPEL || v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN)\n                v->s.quarter_sample = 0;\n            else\n                v->s.quarter_sample = 1;\n        } else\n            v->s.quarter_sample = 1;\n        v->s.mspel = !(v->mv_mode == MV_PMODE_1MV_HPEL_BILIN || (v->mv_mode == MV_PMODE_INTENSITY_COMP && v->mv_mode2 == MV_PMODE_1MV_HPEL_BILIN));\n\n        if ((v->mv_mode == MV_PMODE_INTENSITY_COMP &&\n                 v->mv_mode2 == MV_PMODE_MIXED_MV)\n                || v->mv_mode == MV_PMODE_MIXED_MV)\n        {\n            status = bitplane_decoding(v->mv_type_mb_plane, &v->mv_type_is_raw, v);\n            if (status < 0) return -1;\n            av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n                   \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n        } else {\n            v->mv_type_is_raw = 0;\n            memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height);\n        }\n        status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Skip plane encoding: \"\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n        /* Hopefully this is correct for P frames */\n        v->s.mv_table_index = get_bits(gb, 2); //but using ff_vc1_ tables\n        v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)];\n        if (v->dquant)\n        {\n            av_log(v->s.avctx, AV_LOG_DEBUG, \"VOP DQuant info\\n\");\n            vop_dquant_decoding(v);\n        }\n\n        v->ttfrm = 0; //FIXME Is that so ?\n        if (v->vstransform)\n        {\n            v->ttmbf = get_bits1(gb);\n            if (v->ttmbf)\n            {\n                v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)];\n            }\n        } else {\n            v->ttmbf = 1;\n            v->ttfrm = TT_8X8;\n        }\n        break;\n    case AV_PICTURE_TYPE_B:\n        if (v->extended_mv) v->mvrange = get_unary(gb, 0, 3);\n        else v->mvrange = 0;\n        v->k_x = v->mvrange + 9 + (v->mvrange >> 1); //k_x can be 9 10 12 13\n        v->k_y = v->mvrange + 8; //k_y can be 8 9 10 11\n        v->range_x = 1 << (v->k_x - 1);\n        v->range_y = 1 << (v->k_y - 1);\n\n        if (v->pq < 5) v->tt_index = 0;\n        else if(v->pq < 13) v->tt_index = 1;\n        else v->tt_index = 2;\n\n        v->mv_mode = get_bits1(gb) ? MV_PMODE_1MV : MV_PMODE_1MV_HPEL_BILIN;\n        v->s.quarter_sample = (v->mv_mode == MV_PMODE_1MV);\n        v->s.mspel = v->s.quarter_sample;\n\n        status = bitplane_decoding(v->direct_mb_plane, &v->dmb_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct Type plane encoding: \"\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n        status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n        if (status < 0) return -1;\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Skip plane encoding: \"\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n        v->s.mv_table_index = get_bits(gb, 2);\n        v->cbpcy_vlc = &ff_vc1_cbpcy_p_vlc[get_bits(gb, 2)];\n\n        if (v->dquant)\n        {\n            av_log(v->s.avctx, AV_LOG_DEBUG, \"VOP DQuant info\\n\");\n            vop_dquant_decoding(v);\n        }\n\n        v->ttfrm = 0;\n        if (v->vstransform)\n        {\n            v->ttmbf = get_bits1(gb);\n            if (v->ttmbf)\n            {\n                v->ttfrm = ff_vc1_ttfrm_to_tt[get_bits(gb, 2)];\n            }\n        } else {\n            v->ttmbf = 1;\n            v->ttfrm = TT_8X8;\n        }\n        break;\n    }\n\n    /* AC Syntax */\n    v->c_ac_table_index = decode012(gb);\n    if (v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI)\n    {\n        v->y_ac_table_index = decode012(gb);\n    }\n    /* DC Syntax */\n    v->s.dc_table_index = get_bits1(gb);\n    if ((v->s.pict_type == AV_PICTURE_TYPE_I || v->s.pict_type == AV_PICTURE_TYPE_BI) && v->dquant) {\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"VOP DQuant info\\n\");\n        vop_dquant_decoding(v);\n    }\n\n    v->bi_type = 0;\n    if(v->s.pict_type == AV_PICTURE_TYPE_BI) {\n        v->s.pict_type = AV_PICTURE_TYPE_B;\n        v->bi_type = 1;\n    }\n    return 0;\n}", "before_change_lines": [32, 41], "raw_before_change_lines": [32, 41], "after_change_lines": [32, 41, 48, 49, 50], "raw_after_change_lines": [32, 41, 48, 49, 50], "bug_lines": [32, 41], "added": [false, false], "idx": 277}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "7200----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_85d8a1cc886b3a1e79125648580750c297f8be06_1.json----ff_acelp_lp_decode", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_85d8a1cc886b3a1e79125648580750c297f8be06_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_85d8a1cc886b3a1e79125648580750c297f8be06_1.json", "function_name": "ff_acelp_lp_decode", "vul_func_code": "void ff_acelp_lp_decode(int16_t* lp_1st, int16_t* lp_2nd, const int16_t* lsp_2nd, const int16_t* lsp_prev, int lp_order)\n{\n    int16_t lsp_1st[lp_order]; // (0.15)\n    int i;\n\n    /* LSP values for first subframe (3.2.5 of G.729, Equation 24)*/\n    for(i=0; i<lp_order; i++)\n#ifdef G729_BITEXACT\n        lsp_1st[i] = (lsp_2nd[i] >> 1) + (lsp_prev[i] >> 1);\n#else\n        lsp_1st[i] = (lsp_2nd[i] + lsp_prev[i]) >> 1;\n#endif\n\n    ff_acelp_lsp2lpc(lp_1st, lsp_1st, lp_order >> 1);\n\n    /* LSP values for second subframe (3.2.5 of G.729)*/\n    ff_acelp_lsp2lpc(lp_2nd, lsp_2nd, lp_order >> 1);\n}", "patch_func_code": "void ff_acelp_lp_decode(int16_t* lp_1st, int16_t* lp_2nd, const int16_t* lsp_2nd, const int16_t* lsp_prev, int lp_order)\n{\n    int16_t lsp_1st[MAX_LP_ORDER]; // (0.15)\n    int i;\n\n    /* LSP values for first subframe (3.2.5 of G.729, Equation 24)*/\n    for(i=0; i<lp_order; i++)\n#ifdef G729_BITEXACT\n        lsp_1st[i] = (lsp_2nd[i] >> 1) + (lsp_prev[i] >> 1);\n#else\n        lsp_1st[i] = (lsp_2nd[i] + lsp_prev[i]) >> 1;\n#endif\n\n    ff_acelp_lsp2lpc(lp_1st, lsp_1st, lp_order >> 1);\n\n    /* LSP values for second subframe (3.2.5 of G.729)*/\n    ff_acelp_lsp2lpc(lp_2nd, lsp_2nd, lp_order >> 1);\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 278}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7285----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8ac04d5aecb0a3919ae92fb965af007105db0ef2_1.json----ff_h263_decode_init", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_8ac04d5aecb0a3919ae92fb965af007105db0ef2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8ac04d5aecb0a3919ae92fb965af007105db0ef2_1.json", "function_name": "ff_h263_decode_init", "vul_func_code": "int ff_h263_decode_init(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int ret;\n\n    s->avctx           = avctx;\n    s->out_format      = FMT_H263;\n    s->width           = avctx->coded_width;\n    s->height          = avctx->coded_height;\n    s->workaround_bugs = avctx->workaround_bugs;\n\n    // set defaults\n    ff_MPV_decode_defaults(s);\n    s->quant_precision = 5;\n    s->decode_mb       = ff_h263_decode_mb;\n    s->low_delay       = 1;\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    else\n        avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n    s->unrestricted_mv = 1;\n\n    /* select sub codec */\n    switch (avctx->codec->id) {\n    case AV_CODEC_ID_H263:\n        s->unrestricted_mv = 0;\n        avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;\n        break;\n    case AV_CODEC_ID_MPEG4:\n        break;\n    case AV_CODEC_ID_MSMPEG4V1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 1;\n        break;\n    case AV_CODEC_ID_MSMPEG4V2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 2;\n        break;\n    case AV_CODEC_ID_MSMPEG4V3:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 3;\n        break;\n    case AV_CODEC_ID_WMV1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 4;\n        break;\n    case AV_CODEC_ID_WMV2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 5;\n        break;\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_WMV3:\n    case AV_CODEC_ID_VC1IMAGE:\n    case AV_CODEC_ID_WMV3IMAGE:\n    case AV_CODEC_ID_MSS2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 6;\n        avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n        break;\n    case AV_CODEC_ID_H263I:\n        break;\n    case AV_CODEC_ID_FLV1:\n        s->h263_flv = 1;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec %d\\n\",\n               avctx->codec->id);\n        return AVERROR(ENOSYS);\n    }\n    s->codec_id    = avctx->codec->id;\n\n    /* for h263, we allocate the images after having read the header */\n    if (avctx->codec->id != AV_CODEC_ID_H263 &&\n        avctx->codec->id != AV_CODEC_ID_MPEG4)\n        if ((ret = ff_MPV_common_init(s)) < 0)\n            return ret;\n\n    ff_h263dsp_init(&s->h263dsp);\n    ff_qpeldsp_init(&s->qdsp);\n    ff_h263_decode_init_vlc();\n\n    return 0;\n}", "patch_func_code": "int ff_h263_decode_init(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    int ret;\n\n    s->avctx           = avctx;\n    s->out_format      = FMT_H263;\n    s->width           = avctx->coded_width;\n    s->height          = avctx->coded_height;\n    s->workaround_bugs = avctx->workaround_bugs;\n\n    // set defaults\n    ff_MPV_decode_defaults(s);\n    s->quant_precision = 5;\n    s->decode_mb       = ff_h263_decode_mb;\n    s->low_delay       = 1;\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n    else\n        avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n    s->unrestricted_mv = 1;\n\n    /* select sub codec */\n    switch (avctx->codec->id) {\n    case AV_CODEC_ID_H263:\n        s->unrestricted_mv = 0;\n        avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;\n        break;\n    case AV_CODEC_ID_MPEG4:\n        break;\n    case AV_CODEC_ID_MSMPEG4V1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 1;\n        break;\n    case AV_CODEC_ID_MSMPEG4V2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 2;\n        break;\n    case AV_CODEC_ID_MSMPEG4V3:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 3;\n        break;\n    case AV_CODEC_ID_WMV1:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 4;\n        break;\n    case AV_CODEC_ID_WMV2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 5;\n        break;\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_WMV3:\n    case AV_CODEC_ID_VC1IMAGE:\n    case AV_CODEC_ID_WMV3IMAGE:\n    case AV_CODEC_ID_MSS2:\n        s->h263_pred       = 1;\n        s->msmpeg4_version = 6;\n        avctx->chroma_sample_location = AVCHROMA_LOC_LEFT;\n        break;\n    case AV_CODEC_ID_H263I:\n        break;\n    case AV_CODEC_ID_FLV1:\n        s->h263_flv = 1;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec %d\\n\",\n               avctx->codec->id);\n        return AVERROR(ENOSYS);\n    }\n    s->codec_id    = avctx->codec->id;\n\n    /* for h263, we allocate the images after having read the header */\n    if (avctx->codec->id != AV_CODEC_ID_H263 &&\n        avctx->codec->id != AV_CODEC_ID_MPEG4) {\n        ff_mpv_idct_init(s);\n        if ((ret = ff_MPV_common_init(s)) < 0)\n            return ret;\n    }\n\n    ff_h263dsp_init(&s->h263dsp);\n    ff_qpeldsp_init(&s->qdsp);\n    ff_h263_decode_init_vlc();\n\n    return 0;\n}", "before_change_lines": [74], "raw_before_change_lines": [74], "after_change_lines": [74, 75, 78], "raw_after_change_lines": [74, 75, 78], "bug_lines": [74], "added": [false], "idx": 279}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "7299----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8c0fd76fb09b63b0528483c85df534f4c18cf8ca_1.json----rv34_decode_block", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_8c0fd76fb09b63b0528483c85df534f4c18cf8ca_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_8c0fd76fb09b63b0528483c85df534f4c18cf8ca_1.json", "function_name": "rv34_decode_block", "vul_func_code": "static inline void rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc)\n{\n    int code, pattern;\n\n    code = get_vlc2(gb, rvlc->first_pattern[fc].table, 9, 2);\n\n    pattern = code & 0x7;\n\n    code >>= 3;\n    decode_subblock(dst, code, 0, gb, &rvlc->coefficient);\n\n    if(pattern & 4){\n        code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient);\n    }\n    if(pattern & 2){ // Looks like coefficients 1 and 2 are swapped for this block\n        code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient);\n    }\n    if(pattern & 1){\n        code = get_vlc2(gb, rvlc->third_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient);\n    }\n\n}", "patch_func_code": "static inline void rv34_decode_block(DCTELEM *dst, GetBitContext *gb, RV34VLC *rvlc, int fc, int sc, int q_dc, int q_ac1, int q_ac2)\n{\n    int code, pattern;\n\n    code = get_vlc2(gb, rvlc->first_pattern[fc].table, 9, 2);\n\n    pattern = code & 0x7;\n\n    code >>= 3;\n    decode_subblock3(dst, code, 0, gb, &rvlc->coefficient, q_dc, q_ac1, q_ac2);\n\n    if(pattern & 4){\n        code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 2, code, 0, gb, &rvlc->coefficient, q_ac2);\n    }\n    if(pattern & 2){ // Looks like coefficients 1 and 2 are swapped for this block\n        code = get_vlc2(gb, rvlc->second_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 8*2, code, 1, gb, &rvlc->coefficient, q_ac2);\n    }\n    if(pattern & 1){\n        code = get_vlc2(gb, rvlc->third_pattern[sc].table, 9, 2);\n        decode_subblock(dst + 8*2+2, code, 0, gb, &rvlc->coefficient, q_ac2);\n    }\n\n}", "before_change_lines": [1, 10, 14, 18, 22], "raw_before_change_lines": [1, 10, 14, 18, 22], "after_change_lines": [1, 10, 14, 18, 22], "raw_after_change_lines": [1, 10, 14, 18, 22], "bug_lines": [1, 10, 14, 18, 22], "added": [false, false, false, false, false], "idx": 280}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7386----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_90e45ea37c9440343091334773297ce12fa8a7ac_1.json----ff_mpv_frame_size_alloc", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_90e45ea37c9440343091334773297ce12fa8a7ac_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_90e45ea37c9440343091334773297ce12fa8a7ac_1.json", "function_name": "ff_mpv_frame_size_alloc", "vul_func_code": "int ff_mpv_frame_size_alloc(MpegEncContext *s, int linesize)\n{\n    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);\n\n    // edge emu needs blocksize + filter length - 1\n    // (= 17x17 for  halfpel / 21x21 for  h264)\n    // linesize * interlaced * MBsize\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, alloc_size * 2 * 21,\n                      fail);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->me.scratchpad, alloc_size * 2 * 16 * 2,\n                      fail)\n    s->me.temp         = s->me.scratchpad;\n    s->rd_scratchpad   = s->me.scratchpad;\n    s->b_scratchpad    = s->me.scratchpad;\n    s->obmc_scratchpad = s->me.scratchpad + 16;\n\n    return 0;\nfail:\n    av_freep(&s->edge_emu_buffer);\n    return AVERROR(ENOMEM);\n}", "patch_func_code": "int ff_mpv_frame_size_alloc(MpegEncContext *s, int linesize)\n{\n    int alloc_size = FFALIGN(FFABS(linesize) + 32, 32);\n\n    // edge emu needs blocksize + filter length - 1\n    // (= 17x17 for  halfpel / 21x21 for  h264)\n    // VC1 computes luma and chroma simultaneously and needs 19X19 + 9x9\n    // at uvlinesize. It supports only YUV420 so 24x24 is enough\n    // linesize * interlaced * MBsize\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->edge_emu_buffer, alloc_size * 2 * 24,\n                      fail);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->me.scratchpad, alloc_size * 2 * 16 * 2,\n                      fail)\n    s->me.temp         = s->me.scratchpad;\n    s->rd_scratchpad   = s->me.scratchpad;\n    s->b_scratchpad    = s->me.scratchpad;\n    s->obmc_scratchpad = s->me.scratchpad + 16;\n\n    return 0;\nfail:\n    av_freep(&s->edge_emu_buffer);\n    return AVERROR(ENOMEM);\n}", "before_change_lines": [8], "raw_before_change_lines": [8], "after_change_lines": [10], "raw_after_change_lines": [7, 8, 10], "bug_lines": [8], "added": [false], "idx": 281}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7395----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_913aa142ab7de323cee76a7d4023ee491f942ece_1.json----common_init", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_913aa142ab7de323cee76a7d4023ee491f942ece_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_913aa142ab7de323cee76a7d4023ee491f942ece_1.json", "function_name": "common_init", "vul_func_code": "static av_cold void common_init(H264Context *h)\n{\n    MpegEncContext *const s = &h->s;\n\n    s->width    = s->avctx->width;\n    s->height   = s->avctx->height;\n    s->codec_id = s->avctx->codec->id;\n\n    ff_h264dsp_init(&h->h264dsp, 8, 1);\n    ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma);\n    ff_h264qpel_init(&h->h264qpel, 8);\n    ff_h264_pred_init(&h->hpc, s->codec_id, 8, 1);\n\n    h->dequant_coeff_pps = -1;\n    s->unrestricted_mv   = 1;\n\n    /* needed so that IDCT permutation is known early */\n    ff_dsputil_init(&s->dsp, s->avctx);\n    ff_videodsp_init(&s->vdsp, 8);\n\n    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));\n}", "patch_func_code": "static av_cold void common_init(H264Context *h)\n{\n\n    h->width    = h->avctx->width;\n    h->height   = h->avctx->height;\n\n    h->bit_depth_luma    = 8;\n    h->chroma_format_idc = 1;\n\n    ff_h264dsp_init(&h->h264dsp, 8, 1);\n    ff_h264chroma_init(&h->h264chroma, h->sps.bit_depth_chroma);\n    ff_h264qpel_init(&h->h264qpel, 8);\n    ff_h264_pred_init(&h->hpc, h->avctx->codec_id, 8, 1);\n\n    h->dequant_coeff_pps = -1;\n\n    /* needed so that IDCT permutation is known early */\n    ff_dsputil_init(&h->dsp, h->avctx);\n    ff_videodsp_init(&h->vdsp, 8);\n\n    memset(h->pps.scaling_matrix4, 16, 6 * 16 * sizeof(uint8_t));\n    memset(h->pps.scaling_matrix8, 16, 2 * 64 * sizeof(uint8_t));\n}", "before_change_lines": [3, 5, 6, 7, 12, 15, 18, 19], "raw_before_change_lines": [3, 5, 6, 7, 12, 15, 18, 19], "after_change_lines": [4, 5, 7, 8, 13, 18, 19], "raw_after_change_lines": [4, 5, 6, 7, 8, 13, 18, 19], "bug_lines": [3, 5, 6, 7, 12, 15, 18, 19], "added": [false, false, false, false, false, false, false, false], "idx": 282}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L2", "filepath_func": "7440----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_93944838599ce510398112e19e3eb3f81b25fd92_1.json----fill_filter_caches", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_93944838599ce510398112e19e3eb3f81b25fd92_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_93944838599ce510398112e19e3eb3f81b25fd92_1.json", "function_name": "fill_filter_caches", "vul_func_code": "static int fill_filter_caches(H264Context *h, int mb_type){\n    MpegEncContext * const s = &h->s;\n    const int mb_xy= h->mb_xy;\n    int top_xy, left_xy[2];\n    int top_type, left_type[2];\n\n    top_xy     = mb_xy  - (s->mb_stride << MB_FIELD);\n\n    //FIXME deblocking could skip the intra and nnz parts.\n\n    /* Wow, what a mess, why didn't they simplify the interlacing & intra\n     * stuff, I can't imagine that these complex rules are worth it. */\n\n    left_xy[1] = left_xy[0] = mb_xy-1;\n    if(FRAME_MBAFF){\n        const int left_mb_field_flag     = IS_INTERLACED(s->current_picture.mb_type[mb_xy-1]);\n        const int curr_mb_field_flag     = IS_INTERLACED(mb_type);\n        if(s->mb_y&1){\n            if (left_mb_field_flag != curr_mb_field_flag) {\n                left_xy[0] -= s->mb_stride;\n            }\n        }else{\n            if(curr_mb_field_flag){\n                top_xy      += s->mb_stride & (((s->current_picture.mb_type[top_xy    ]>>7)&1)-1);\n            }\n            if (left_mb_field_flag != curr_mb_field_flag) {\n                left_xy[1] += s->mb_stride;\n            }\n        }\n    }\n\n    h->top_mb_xy = top_xy;\n    h->left_mb_xy[0] = left_xy[0];\n    h->left_mb_xy[1] = left_xy[1];\n    {\n        //for sufficiently low qp, filtering wouldn't do anything\n        //this is a conservative estimate: could also check beta_offset and more accurate chroma_qp\n        int qp_thresh = h->qp_thresh; //FIXME strictly we should store qp_thresh for each mb of a slice\n        int qp = s->current_picture.qscale_table[mb_xy];\n        if(qp <= qp_thresh\n           && (left_xy[0]<0 || ((qp + s->current_picture.qscale_table[left_xy[0]] + 1)>>1) <= qp_thresh)\n           && (top_xy   < 0 || ((qp + s->current_picture.qscale_table[top_xy    ] + 1)>>1) <= qp_thresh)){\n            if(!FRAME_MBAFF)\n                return 1;\n            if(   (left_xy[0]< 0            || ((qp + s->current_picture.qscale_table[left_xy[1]             ] + 1)>>1) <= qp_thresh)\n               && (top_xy    < s->mb_stride || ((qp + s->current_picture.qscale_table[top_xy    -s->mb_stride] + 1)>>1) <= qp_thresh))\n                return 1;\n        }\n    }\n\n    if(h->deblocking_filter == 2){\n        h->top_type    = top_type     = h->slice_table[top_xy     ] == h->slice_num ? s->current_picture.mb_type[top_xy]     : 0;\n        h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] == h->slice_num ? s->current_picture.mb_type[left_xy[0]] : 0;\n        h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] == h->slice_num ? s->current_picture.mb_type[left_xy[1]] : 0;\n    }else{\n        h->top_type    = top_type     = h->slice_table[top_xy     ] < 0xFFFF ? s->current_picture.mb_type[top_xy]     : 0;\n        h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[0]] : 0;\n        h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[1]] : 0;\n    }\n    if(IS_INTRA(mb_type))\n        return 0;\n\n    AV_COPY64(&h->non_zero_count_cache[0+8*1], &h->non_zero_count[mb_xy][ 0]);\n    AV_COPY64(&h->non_zero_count_cache[0+8*2], &h->non_zero_count[mb_xy][ 8]);\n    *((uint32_t*)&h->non_zero_count_cache[0+8*5])= *((uint32_t*)&h->non_zero_count[mb_xy][16]);\n    *((uint32_t*)&h->non_zero_count_cache[4+8*3])= *((uint32_t*)&h->non_zero_count[mb_xy][20]);\n    AV_COPY64(&h->non_zero_count_cache[0+8*4], &h->non_zero_count[mb_xy][24]);\n\n    h->cbp= h->cbp_table[mb_xy];\n\n    {\n        int list;\n        for(list=0; list<h->list_count; list++){\n            int8_t *ref;\n            int y, b_stride;\n            int16_t (*mv_dst)[2];\n            int16_t (*mv_src)[2];\n\n            if(!USES_LIST(mb_type, list)){\n                fill_rectangle(  h->mv_cache[list][scan8[0]], 4, 4, 8, pack16to32(0,0), 4);\n                *(uint32_t*)&h->ref_cache[list][scan8[ 0]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[ 2]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[ 8]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[10]] = ((LIST_NOT_USED)&0xFF)*0x01010101U;\n                continue;\n            }\n\n            ref = &s->current_picture.ref_index[list][h->mb2b8_xy[mb_xy]];\n            {\n                int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2);\n                *(uint32_t*)&h->ref_cache[list][scan8[ 0]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[ 2]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101;\n                ref += h->b8_stride;\n                *(uint32_t*)&h->ref_cache[list][scan8[ 8]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[10]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101;\n            }\n\n            b_stride = h->b_stride;\n            mv_dst   = &h->mv_cache[list][scan8[0]];\n            mv_src   = &s->current_picture.motion_val[list][4*s->mb_x + 4*s->mb_y*b_stride];\n            for(y=0; y<4; y++){\n                AV_COPY128(mv_dst + 8*y, mv_src + y*b_stride);\n            }\n\n        }\n    }\n\n\n/*\n0 . T T. T T T T\n1 L . .L . . . .\n2 L . .L . . . .\n3 . T TL . . . .\n4 L . .L . . . .\n5 L . .. . . . .\n*/\n//FIXME constraint_intra_pred & partitioning & nnz (let us hope this is just a typo in the spec)\n    if(top_type){\n        *(uint32_t*)&h->non_zero_count_cache[4+8*0]= *(uint32_t*)&h->non_zero_count[top_xy][4+3*8];\n    }\n\n    if(left_type[0]){\n        h->non_zero_count_cache[3+8*1]= h->non_zero_count[left_xy[0]][7+0*8];\n        h->non_zero_count_cache[3+8*2]= h->non_zero_count[left_xy[0]][7+1*8];\n        h->non_zero_count_cache[3+8*3]= h->non_zero_count[left_xy[0]][7+2*8];\n        h->non_zero_count_cache[3+8*4]= h->non_zero_count[left_xy[0]][7+3*8];\n    }\n\n    // CAVLC 8x8dct requires NNZ values for residual decoding that differ from what the loop filter needs\n    if(!CABAC && h->pps.transform_8x8_mode){\n        if(IS_8x8DCT(top_type)){\n            h->non_zero_count_cache[4+8*0]=\n            h->non_zero_count_cache[5+8*0]= h->cbp_table[top_xy] & 4;\n            h->non_zero_count_cache[6+8*0]=\n            h->non_zero_count_cache[7+8*0]= h->cbp_table[top_xy] & 8;\n        }\n        if(IS_8x8DCT(left_type[0])){\n            h->non_zero_count_cache[3+8*1]=\n            h->non_zero_count_cache[3+8*2]= h->cbp_table[left_xy[0]]&2; //FIXME check MBAFF\n        }\n        if(IS_8x8DCT(left_type[1])){\n            h->non_zero_count_cache[3+8*3]=\n            h->non_zero_count_cache[3+8*4]= h->cbp_table[left_xy[1]]&8; //FIXME check MBAFF\n        }\n\n        if(IS_8x8DCT(mb_type)){\n            h->non_zero_count_cache[scan8[0   ]]= h->non_zero_count_cache[scan8[1   ]]=\n            h->non_zero_count_cache[scan8[2   ]]= h->non_zero_count_cache[scan8[3   ]]= h->cbp & 1;\n\n            h->non_zero_count_cache[scan8[0+ 4]]= h->non_zero_count_cache[scan8[1+ 4]]=\n            h->non_zero_count_cache[scan8[2+ 4]]= h->non_zero_count_cache[scan8[3+ 4]]= h->cbp & 2;\n\n            h->non_zero_count_cache[scan8[0+ 8]]= h->non_zero_count_cache[scan8[1+ 8]]=\n            h->non_zero_count_cache[scan8[2+ 8]]= h->non_zero_count_cache[scan8[3+ 8]]= h->cbp & 4;\n\n            h->non_zero_count_cache[scan8[0+12]]= h->non_zero_count_cache[scan8[1+12]]=\n            h->non_zero_count_cache[scan8[2+12]]= h->non_zero_count_cache[scan8[3+12]]= h->cbp & 8;\n        }\n    }\n\n    if(IS_INTER(mb_type) || IS_DIRECT(mb_type)){\n        int list;\n        for(list=0; list<h->list_count; list++){\n            if(USES_LIST(top_type, list)){\n                const int b_xy= h->mb2b_xy[top_xy] + 3*h->b_stride;\n                const int b8_xy= h->mb2b8_xy[top_xy] + h->b8_stride;\n                int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2);\n                AV_COPY128(h->mv_cache[list][scan8[0] + 0 - 1*8], s->current_picture.motion_val[list][b_xy + 0]);\n                h->ref_cache[list][scan8[0] + 0 - 1*8]=\n                h->ref_cache[list][scan8[0] + 1 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 0]];\n                h->ref_cache[list][scan8[0] + 2 - 1*8]=\n                h->ref_cache[list][scan8[0] + 3 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 1]];\n            }else{\n                AV_ZERO128(h->mv_cache[list][scan8[0] + 0 - 1*8]);\n                *(uint32_t*)&h->ref_cache[list][scan8[0] + 0 - 1*8]= ((LIST_NOT_USED)&0xFF)*0x01010101U;\n            }\n\n            if(!IS_INTERLACED(mb_type^left_type[0])){\n                if(USES_LIST(left_type[0], list)){\n                    const int b_xy= h->mb2b_xy[left_xy[0]] + 3;\n                    const int b8_xy= h->mb2b8_xy[left_xy[0]] + 1;\n                    int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ] + (MB_MBAFF ? 20 : 2);\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 0 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*0];\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 8 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*1];\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +16 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*2];\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +24 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*3];\n                    h->ref_cache[list][scan8[0] - 1 + 0 ]=\n                    h->ref_cache[list][scan8[0] - 1 + 8 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*0]];\n                    h->ref_cache[list][scan8[0] - 1 +16 ]=\n                    h->ref_cache[list][scan8[0] - 1 +24 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*1]];\n                }else{\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 0 ]=\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 8 ]=\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +16 ]=\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +24 ]= 0;\n                    h->ref_cache[list][scan8[0] - 1 + 0  ]=\n                    h->ref_cache[list][scan8[0] - 1 + 8  ]=\n                    h->ref_cache[list][scan8[0] - 1 + 16 ]=\n                    h->ref_cache[list][scan8[0] - 1 + 24 ]= LIST_NOT_USED;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "patch_func_code": "static int fill_filter_caches(H264Context *h, int mb_type){\n    MpegEncContext * const s = &h->s;\n    const int mb_xy= h->mb_xy;\n    int top_xy, left_xy[2];\n    int top_type, left_type[2];\n\n    top_xy     = mb_xy  - (s->mb_stride << MB_FIELD);\n\n    //FIXME deblocking could skip the intra and nnz parts.\n\n    /* Wow, what a mess, why didn't they simplify the interlacing & intra\n     * stuff, I can't imagine that these complex rules are worth it. */\n\n    left_xy[1] = left_xy[0] = mb_xy-1;\n    if(FRAME_MBAFF){\n        const int left_mb_field_flag     = IS_INTERLACED(s->current_picture.mb_type[mb_xy-1]);\n        const int curr_mb_field_flag     = IS_INTERLACED(mb_type);\n        if(s->mb_y&1){\n            if (left_mb_field_flag != curr_mb_field_flag) {\n                left_xy[0] -= s->mb_stride;\n            }\n        }else{\n            if(curr_mb_field_flag){\n                top_xy      += s->mb_stride & (((s->current_picture.mb_type[top_xy    ]>>7)&1)-1);\n            }\n            if (left_mb_field_flag != curr_mb_field_flag) {\n                left_xy[1] += s->mb_stride;\n            }\n        }\n    }\n\n    h->top_mb_xy = top_xy;\n    h->left_mb_xy[0] = left_xy[0];\n    h->left_mb_xy[1] = left_xy[1];\n    {\n        //for sufficiently low qp, filtering wouldn't do anything\n        //this is a conservative estimate: could also check beta_offset and more accurate chroma_qp\n        int qp_thresh = h->qp_thresh; //FIXME strictly we should store qp_thresh for each mb of a slice\n        int qp = s->current_picture.qscale_table[mb_xy];\n        if(qp <= qp_thresh\n           && (left_xy[0]<0 || ((qp + s->current_picture.qscale_table[left_xy[0]] + 1)>>1) <= qp_thresh)\n           && (top_xy   < 0 || ((qp + s->current_picture.qscale_table[top_xy    ] + 1)>>1) <= qp_thresh)){\n            if(!FRAME_MBAFF)\n                return 1;\n            if(   (left_xy[0]< 0            || ((qp + s->current_picture.qscale_table[left_xy[1]             ] + 1)>>1) <= qp_thresh)\n               && (top_xy    < s->mb_stride || ((qp + s->current_picture.qscale_table[top_xy    -s->mb_stride] + 1)>>1) <= qp_thresh))\n                return 1;\n        }\n    }\n\n    if(h->deblocking_filter == 2){\n        h->top_type    = top_type     = h->slice_table[top_xy     ] == h->slice_num ? s->current_picture.mb_type[top_xy]     : 0;\n        h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] == h->slice_num ? s->current_picture.mb_type[left_xy[0]] : 0;\n        h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] == h->slice_num ? s->current_picture.mb_type[left_xy[1]] : 0;\n    }else{\n        h->top_type    = top_type     = h->slice_table[top_xy     ] < 0xFFFF ? s->current_picture.mb_type[top_xy]     : 0;\n        h->left_type[0]= left_type[0] = h->slice_table[left_xy[0] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[0]] : 0;\n        h->left_type[1]= left_type[1] = h->slice_table[left_xy[1] ] < 0xFFFF ? s->current_picture.mb_type[left_xy[1]] : 0;\n    }\n    if(IS_INTRA(mb_type))\n        return 0;\n\n    AV_COPY64(&h->non_zero_count_cache[0+8*1], &h->non_zero_count[mb_xy][ 0]);\n    AV_COPY64(&h->non_zero_count_cache[0+8*2], &h->non_zero_count[mb_xy][ 8]);\n    *((uint32_t*)&h->non_zero_count_cache[0+8*5])= *((uint32_t*)&h->non_zero_count[mb_xy][16]);\n    *((uint32_t*)&h->non_zero_count_cache[4+8*3])= *((uint32_t*)&h->non_zero_count[mb_xy][20]);\n    AV_COPY64(&h->non_zero_count_cache[0+8*4], &h->non_zero_count[mb_xy][24]);\n\n    h->cbp= h->cbp_table[mb_xy];\n\n    {\n        int list;\n        for(list=0; list<h->list_count; list++){\n            int8_t *ref;\n            int y, b_stride;\n            int16_t (*mv_dst)[2];\n            int16_t (*mv_src)[2];\n\n            if(!USES_LIST(mb_type, list)){\n                fill_rectangle(  h->mv_cache[list][scan8[0]], 4, 4, 8, pack16to32(0,0), 4);\n                *(uint32_t*)&h->ref_cache[list][scan8[ 0]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[ 2]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[ 8]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[10]] = ((LIST_NOT_USED)&0xFF)*0x01010101U;\n                continue;\n            }\n\n            ref = &s->current_picture.ref_index[list][h->mb2b8_xy[mb_xy]];\n            {\n                int (*ref2frm)[64] = h->ref2frm[ h->slice_num&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);\n                *(uint32_t*)&h->ref_cache[list][scan8[ 0]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[ 2]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101;\n                ref += h->b8_stride;\n                *(uint32_t*)&h->ref_cache[list][scan8[ 8]] =\n                *(uint32_t*)&h->ref_cache[list][scan8[10]] = (pack16to32(ref2frm[list][ref[0]],ref2frm[list][ref[1]])&0x00FF00FF)*0x0101;\n            }\n\n            b_stride = h->b_stride;\n            mv_dst   = &h->mv_cache[list][scan8[0]];\n            mv_src   = &s->current_picture.motion_val[list][4*s->mb_x + 4*s->mb_y*b_stride];\n            for(y=0; y<4; y++){\n                AV_COPY128(mv_dst + 8*y, mv_src + y*b_stride);\n            }\n\n        }\n    }\n\n\n/*\n0 . T T. T T T T\n1 L . .L . . . .\n2 L . .L . . . .\n3 . T TL . . . .\n4 L . .L . . . .\n5 L . .. . . . .\n*/\n//FIXME constraint_intra_pred & partitioning & nnz (let us hope this is just a typo in the spec)\n    if(top_type){\n        *(uint32_t*)&h->non_zero_count_cache[4+8*0]= *(uint32_t*)&h->non_zero_count[top_xy][4+3*8];\n    }\n\n    if(left_type[0]){\n        h->non_zero_count_cache[3+8*1]= h->non_zero_count[left_xy[0]][7+0*8];\n        h->non_zero_count_cache[3+8*2]= h->non_zero_count[left_xy[0]][7+1*8];\n        h->non_zero_count_cache[3+8*3]= h->non_zero_count[left_xy[0]][7+2*8];\n        h->non_zero_count_cache[3+8*4]= h->non_zero_count[left_xy[0]][7+3*8];\n    }\n\n    // CAVLC 8x8dct requires NNZ values for residual decoding that differ from what the loop filter needs\n    if(!CABAC && h->pps.transform_8x8_mode){\n        if(IS_8x8DCT(top_type)){\n            h->non_zero_count_cache[4+8*0]=\n            h->non_zero_count_cache[5+8*0]= h->cbp_table[top_xy] & 4;\n            h->non_zero_count_cache[6+8*0]=\n            h->non_zero_count_cache[7+8*0]= h->cbp_table[top_xy] & 8;\n        }\n        if(IS_8x8DCT(left_type[0])){\n            h->non_zero_count_cache[3+8*1]=\n            h->non_zero_count_cache[3+8*2]= h->cbp_table[left_xy[0]]&2; //FIXME check MBAFF\n        }\n        if(IS_8x8DCT(left_type[1])){\n            h->non_zero_count_cache[3+8*3]=\n            h->non_zero_count_cache[3+8*4]= h->cbp_table[left_xy[1]]&8; //FIXME check MBAFF\n        }\n\n        if(IS_8x8DCT(mb_type)){\n            h->non_zero_count_cache[scan8[0   ]]= h->non_zero_count_cache[scan8[1   ]]=\n            h->non_zero_count_cache[scan8[2   ]]= h->non_zero_count_cache[scan8[3   ]]= h->cbp & 1;\n\n            h->non_zero_count_cache[scan8[0+ 4]]= h->non_zero_count_cache[scan8[1+ 4]]=\n            h->non_zero_count_cache[scan8[2+ 4]]= h->non_zero_count_cache[scan8[3+ 4]]= h->cbp & 2;\n\n            h->non_zero_count_cache[scan8[0+ 8]]= h->non_zero_count_cache[scan8[1+ 8]]=\n            h->non_zero_count_cache[scan8[2+ 8]]= h->non_zero_count_cache[scan8[3+ 8]]= h->cbp & 4;\n\n            h->non_zero_count_cache[scan8[0+12]]= h->non_zero_count_cache[scan8[1+12]]=\n            h->non_zero_count_cache[scan8[2+12]]= h->non_zero_count_cache[scan8[3+12]]= h->cbp & 8;\n        }\n    }\n\n    if(IS_INTER(mb_type) || IS_DIRECT(mb_type)){\n        int list;\n        for(list=0; list<h->list_count; list++){\n            if(USES_LIST(top_type, list)){\n                const int b_xy= h->mb2b_xy[top_xy] + 3*h->b_stride;\n                const int b8_xy= h->mb2b8_xy[top_xy] + h->b8_stride;\n                int (*ref2frm)[64] = h->ref2frm[ h->slice_table[top_xy]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);\n                AV_COPY128(h->mv_cache[list][scan8[0] + 0 - 1*8], s->current_picture.motion_val[list][b_xy + 0]);\n                h->ref_cache[list][scan8[0] + 0 - 1*8]=\n                h->ref_cache[list][scan8[0] + 1 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 0]];\n                h->ref_cache[list][scan8[0] + 2 - 1*8]=\n                h->ref_cache[list][scan8[0] + 3 - 1*8]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + 1]];\n            }else{\n                AV_ZERO128(h->mv_cache[list][scan8[0] + 0 - 1*8]);\n                *(uint32_t*)&h->ref_cache[list][scan8[0] + 0 - 1*8]= ((LIST_NOT_USED)&0xFF)*0x01010101U;\n            }\n\n            if(!IS_INTERLACED(mb_type^left_type[0])){\n                if(USES_LIST(left_type[0], list)){\n                    const int b_xy= h->mb2b_xy[left_xy[0]] + 3;\n                    const int b8_xy= h->mb2b8_xy[left_xy[0]] + 1;\n                    int (*ref2frm)[64] = h->ref2frm[ h->slice_table[left_xy[0]]&(MAX_SLICES-1) ][0] + (MB_MBAFF ? 20 : 2);\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 0 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*0];\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 + 8 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*1];\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +16 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*2];\n                    *(uint32_t*)h->mv_cache[list][scan8[0] - 1 +24 ]= *(uint32_t*)s->current_picture.motion_val[list][b_xy + h->b_stride*3];\n                    h->ref_cache[list][scan8[0] - 1 + 0 ]=\n                    h->ref_cache[list][scan8[0] - 1 + 8 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*0]];\n                    h->ref_cache[list][scan8[0] - 1 +16 ]=\n                    h->ref_cache[list][scan8[0] - 1 +24 ]= ref2frm[list][s->current_picture.ref_index[list][b8_xy + h->b8_stride*1]];\n                }else{\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 0 ]=\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 + 8 ]=\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +16 ]=\n                    *(uint32_t*)h->mv_cache [list][scan8[0] - 1 +24 ]= 0;\n                    h->ref_cache[list][scan8[0] - 1 + 0  ]=\n                    h->ref_cache[list][scan8[0] - 1 + 8  ]=\n                    h->ref_cache[list][scan8[0] - 1 + 16 ]=\n                    h->ref_cache[list][scan8[0] - 1 + 24 ]= LIST_NOT_USED;\n                }\n            }\n        }\n    }\n\n    return 0;\n}", "before_change_lines": [90, 167, 182], "raw_before_change_lines": [90, 167, 182], "after_change_lines": [90, 167, 182], "raw_after_change_lines": [90, 167, 182], "bug_lines": [90, 167, 182], "added": [false, false, false], "idx": 283}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7443----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_93cb98eec0022d2bc12e002052541804e54ef59e_1.json----tcp_open", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_93cb98eec0022d2bc12e002052541804e54ef59e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_93cb98eec0022d2bc12e002052541804e54ef59e_1.json", "function_name": "tcp_open", "vul_func_code": "static int tcp_open(URLContext *h, const char *uri, int flags)\n{\n    struct addrinfo hints = { 0 }, *ai, *cur_ai;\n    int port, fd = -1;\n    TCPContext *s = h->priv_data;\n    int listen_socket = 0;\n    const char *p;\n    char buf[256];\n    int ret;\n    int timeout = 100, listen_timeout = -1;\n    char hostname[1024],proto[1024],path[1024];\n    char portstr[10];\n\n    av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),\n        &port, path, sizeof(path), uri);\n    if (strcmp(proto, \"tcp\"))\n        return AVERROR(EINVAL);\n    if (port <= 0 || port >= 65536) {\n        av_log(h, AV_LOG_ERROR, \"Port missing in uri\\n\");\n        return AVERROR(EINVAL);\n    }\n    p = strchr(uri, '?');\n    if (p) {\n        if (av_find_info_tag(buf, sizeof(buf), \"listen\", p))\n            listen_socket = 1;\n        if (av_find_info_tag(buf, sizeof(buf), \"timeout\", p)) {\n            timeout = strtol(buf, NULL, 10);\n        }\n        if (av_find_info_tag(buf, sizeof(buf), \"listen_timeout\", p)) {\n            listen_timeout = strtol(buf, NULL, 10);\n        }\n    }\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    snprintf(portstr, sizeof(portstr), \"%d\", port);\n    if (listen_socket)\n        hints.ai_flags |= AI_PASSIVE;\n    if (!hostname[0])\n        ret = getaddrinfo(NULL, portstr, &hints, &ai);\n    else\n        ret = getaddrinfo(hostname, portstr, &hints, &ai);\n    if (ret) {\n        av_log(h, AV_LOG_ERROR,\n               \"Failed to resolve hostname %s: %s\\n\",\n               hostname, gai_strerror(ret));\n        return AVERROR(EIO);\n    }\n\n    cur_ai = ai;\n\n restart:\n    fd = socket(cur_ai->ai_family, cur_ai->ai_socktype, cur_ai->ai_protocol);\n    if (fd < 0) {\n        ret = ff_neterrno();\n        goto fail;\n    }\n\n    if (listen_socket) {\n        if ((fd = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                 listen_timeout)) < 0) {\n            ret = fd;\n            goto fail1;\n        }\n    } else {\n        if ((ret = ff_listen_connect(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                     timeout, h)) < 0) {\n\n            if (ret == AVERROR_EXIT)\n                goto fail1;\n            else\n                goto fail;\n        }\n    }\n\n    h->is_streamed = 1;\n    s->fd = fd;\n    freeaddrinfo(ai);\n    return 0;\n\n fail:\n    if (cur_ai->ai_next) {\n        /* Retry with the next sockaddr */\n        cur_ai = cur_ai->ai_next;\n        if (fd >= 0)\n            closesocket(fd);\n        ret = 0;\n        goto restart;\n    }\n fail1:\n    if (fd >= 0)\n        closesocket(fd);\n    freeaddrinfo(ai);\n    return ret;\n}", "patch_func_code": "static int tcp_open(URLContext *h, const char *uri, int flags)\n{\n    struct addrinfo hints = { 0 }, *ai, *cur_ai;\n    int port, fd = -1;\n    TCPContext *s = h->priv_data;\n    int listen_socket = 0;\n    const char *p;\n    char buf[256];\n    int ret;\n    int timeout = 100, listen_timeout = -1;\n    char hostname[1024],proto[1024],path[1024];\n    char portstr[10];\n\n    av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),\n        &port, path, sizeof(path), uri);\n    if (strcmp(proto, \"tcp\"))\n        return AVERROR(EINVAL);\n    if (port <= 0 || port >= 65536) {\n        av_log(h, AV_LOG_ERROR, \"Port missing in uri\\n\");\n        return AVERROR(EINVAL);\n    }\n    p = strchr(uri, '?');\n    if (p) {\n        if (av_find_info_tag(buf, sizeof(buf), \"listen\", p))\n            listen_socket = 1;\n        if (av_find_info_tag(buf, sizeof(buf), \"timeout\", p)) {\n            timeout = strtol(buf, NULL, 10);\n        }\n        if (av_find_info_tag(buf, sizeof(buf), \"listen_timeout\", p)) {\n            listen_timeout = strtol(buf, NULL, 10);\n        }\n    }\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    snprintf(portstr, sizeof(portstr), \"%d\", port);\n    if (listen_socket)\n        hints.ai_flags |= AI_PASSIVE;\n    if (!hostname[0])\n        ret = getaddrinfo(NULL, portstr, &hints, &ai);\n    else\n        ret = getaddrinfo(hostname, portstr, &hints, &ai);\n    if (ret) {\n        av_log(h, AV_LOG_ERROR,\n               \"Failed to resolve hostname %s: %s\\n\",\n               hostname, gai_strerror(ret));\n        return AVERROR(EIO);\n    }\n\n    cur_ai = ai;\n\n restart:\n    fd = socket(cur_ai->ai_family, cur_ai->ai_socktype, cur_ai->ai_protocol);\n    if (fd < 0) {\n        ret = ff_neterrno();\n        goto fail;\n    }\n\n    if (listen_socket) {\n        if ((fd = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                 listen_timeout, h)) < 0) {\n            ret = fd;\n            goto fail1;\n        }\n    } else {\n        if ((ret = ff_listen_connect(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                     timeout * 100, h)) < 0) {\n\n            if (ret == AVERROR_EXIT)\n                goto fail1;\n            else\n                goto fail;\n        }\n    }\n\n    h->is_streamed = 1;\n    s->fd = fd;\n    freeaddrinfo(ai);\n    return 0;\n\n fail:\n    if (cur_ai->ai_next) {\n        /* Retry with the next sockaddr */\n        cur_ai = cur_ai->ai_next;\n        if (fd >= 0)\n            closesocket(fd);\n        ret = 0;\n        goto restart;\n    }\n fail1:\n    if (fd >= 0)\n        closesocket(fd);\n    freeaddrinfo(ai);\n    return ret;\n}", "before_change_lines": [60, 66], "raw_before_change_lines": [60, 66], "after_change_lines": [60, 66], "raw_after_change_lines": [60, 66], "bug_lines": [60, 66], "added": [false, false], "idx": 284}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7547----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_994e6e5cace56cfdeda5b9ce1a4a5d9df5f28150_1.json----av_get_channel_layout_nb_channels", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_994e6e5cace56cfdeda5b9ce1a4a5d9df5f28150_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_994e6e5cace56cfdeda5b9ce1a4a5d9df5f28150_1.json", "function_name": "av_get_channel_layout_nb_channels", "vul_func_code": "int av_get_channel_layout_nb_channels(int64_t channel_layout)\n{\n    int count;\n    uint64_t x = channel_layout;\n    for (count = 0; x; count++)\n        x &= x-1; // unset lowest set bit\n    return count;\n}", "patch_func_code": "int av_get_channel_layout_nb_channels(uint64_t channel_layout)\n{\n    int count;\n    uint64_t x = channel_layout;\n    for (count = 0; x; count++)\n        x &= x-1; // unset lowest set bit\n    return count;\n}", "before_change_lines": [1], "raw_before_change_lines": [1], "after_change_lines": [1], "raw_after_change_lines": [1], "bug_lines": [1], "added": [false], "idx": 285}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7592----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_9c1ec15923ed80cafef4c4dd435bd79a88c53506_1.json----decode_ac_coeffs", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_9c1ec15923ed80cafef4c4dd435bd79a88c53506_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_9c1ec15923ed80cafef4c4dd435bd79a88c53506_1.json", "function_name": "decode_ac_coeffs", "vul_func_code": "static inline void decode_ac_coeffs(GetBitContext *gb, DCTELEM *out,\n                                    int blocks_per_slice,\n                                    int plane_size_factor,\n                                    const uint8_t *scan)\n{\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n    int max_coeffs, bits_left;\n\n    /* set initial prediction values */\n    run   = 4;\n    level = 2;\n\n    max_coeffs = blocks_per_slice << 6;\n    block_mask = blocks_per_slice - 1;\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n        run_cb_index = run_to_cb_index[FFMIN(run, 15)];\n        lev_cb_index = lev_to_cb_index[FFMIN(level, 9)];\n\n        bits_left = get_bits_left(gb);\n        if (bits_left <= 8 && !show_bits(gb, bits_left))\n            return;\n\n        run = decode_vlc_codeword(gb, ac_codebook[run_cb_index]);\n\n        bits_left = get_bits_left(gb);\n        if (bits_left <= 8 && !show_bits(gb, bits_left))\n            return;\n\n        level = decode_vlc_codeword(gb, ac_codebook[lev_cb_index]) + 1;\n\n        pos += run + 1;\n        if (pos >= max_coeffs)\n            break;\n\n        sign = get_sbits(gb, 1);\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n            (level ^ sign) - sign;\n    }\n}", "patch_func_code": "static inline void decode_ac_coeffs(GetBitContext *gb, DCTELEM *out,\n                                    int blocks_per_slice,\n                                    int plane_size_factor,\n                                    const uint8_t *scan)\n{\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n    int max_coeffs, bits_left;\n\n    /* set initial prediction values */\n    run   = 4;\n    level = 2;\n\n    max_coeffs = blocks_per_slice << 6;\n    block_mask = blocks_per_slice - 1;\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n        run_cb_index = run_to_cb_index[FFMIN(run, 15)];\n        lev_cb_index = lev_to_cb_index[FFMIN(level, 9)];\n\n        bits_left = get_bits_left(gb);\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n            return;\n\n        run = decode_vlc_codeword(gb, ac_codebook[run_cb_index]);\n\n        bits_left = get_bits_left(gb);\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n            return;\n\n        level = decode_vlc_codeword(gb, ac_codebook[lev_cb_index]) + 1;\n\n        pos += run + 1;\n        if (pos >= max_coeffs)\n            break;\n\n        sign = get_sbits(gb, 1);\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n            (level ^ sign) - sign;\n    }\n}", "before_change_lines": [21, 27], "raw_before_change_lines": [21, 27], "after_change_lines": [21, 27], "raw_after_change_lines": [21, 27], "bug_lines": [21, 27], "added": [false, false], "idx": 286}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7597----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_9cb9bb024de5b837fd19b6633ed1fa3b57375c99_1.json----svq1_motion_inter_block", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_9cb9bb024de5b837fd19b6633ed1fa3b57375c99_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_9cb9bb024de5b837fd19b6633ed1fa3b57375c99_1.json", "function_name": "svq1_motion_inter_block", "vul_func_code": "static int svq1_motion_inter_block(DSPContext *dsp, GetBitContext *bitbuf,\n                                   uint8_t *current, uint8_t *previous,\n                                   int pitch, svq1_pmv *motion, int x, int y)\n{\n    uint8_t *src;\n    uint8_t *dst;\n    svq1_pmv mv;\n    svq1_pmv *pmv[3];\n    int result;\n\n    /* predict and decode motion vector */\n    pmv[0] = &motion[0];\n    if (y == 0) {\n        pmv[1] =\n        pmv[2] = pmv[0];\n    } else {\n        pmv[1] = &motion[x / 8 + 2];\n        pmv[2] = &motion[x / 8 + 4];\n    }\n\n    result = svq1_decode_motion_vector(bitbuf, &mv, pmv);\n\n    if (result != 0)\n        return result;\n\n    motion[0].x         =\n    motion[x / 8 + 2].x =\n    motion[x / 8 + 3].x = mv.x;\n    motion[0].y         =\n    motion[x / 8 + 2].y =\n    motion[x / 8 + 3].y = mv.y;\n\n    if (y + (mv.y >> 1) < 0)\n        mv.y = 0;\n    if (x + (mv.x >> 1) < 0)\n        mv.x = 0;\n\n    src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1)) * pitch];\n    dst = current;\n\n    dsp->put_pixels_tab[0][(mv.y & 1) << 1 | (mv.x & 1)](dst, src, pitch, 16);\n\n    return 0;\n}", "patch_func_code": "static int svq1_motion_inter_block(DSPContext *dsp, GetBitContext *bitbuf,\n                                   uint8_t *current, uint8_t *previous,\n                                   int pitch, svq1_pmv *motion, int x, int y,\n                                   int width, int height)\n{\n    uint8_t *src;\n    uint8_t *dst;\n    svq1_pmv mv;\n    svq1_pmv *pmv[3];\n    int result;\n\n    /* predict and decode motion vector */\n    pmv[0] = &motion[0];\n    if (y == 0) {\n        pmv[1] =\n        pmv[2] = pmv[0];\n    } else {\n        pmv[1] = &motion[x / 8 + 2];\n        pmv[2] = &motion[x / 8 + 4];\n    }\n\n    result = svq1_decode_motion_vector(bitbuf, &mv, pmv);\n\n    if (result != 0)\n        return result;\n\n    motion[0].x         =\n    motion[x / 8 + 2].x =\n    motion[x / 8 + 3].x = mv.x;\n    motion[0].y         =\n    motion[x / 8 + 2].y =\n    motion[x / 8 + 3].y = mv.y;\n\n    mv.x = av_clip(mv.x, -2 * x, 2 * (width  - x - 16));\n    mv.y = av_clip(mv.y, -2 * y, 2 * (height - y - 16));\n\n    src = &previous[(x + (mv.x >> 1)) + (y + (mv.y >> 1)) * pitch];\n    dst = current;\n\n    dsp->put_pixels_tab[0][(mv.y & 1) << 1 | (mv.x & 1)](dst, src, pitch, 16);\n\n    return 0;\n}", "before_change_lines": [3, 33, 34, 35, 36], "raw_before_change_lines": [3, 33, 34, 35, 36], "after_change_lines": [3, 4, 34, 35], "raw_after_change_lines": [3, 4, 34, 35], "bug_lines": [3, 33, 34, 35, 36], "added": [false, false, false, false, false], "idx": 287}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7724----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a34bfb395d003e6f9c0b777824d5f14940550a5b_1.json----mov_read_stsd", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_a34bfb395d003e6f9c0b777824d5f14940550a5b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a34bfb395d003e6f9c0b777824d5f14940550a5b_1.json", "function_name": "mov_read_stsd", "vul_func_code": "static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int entries;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    return ff_mov_read_stsd_entries(c, pb, entries);\n}", "patch_func_code": "static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    sc->stsd_count = avio_rb32(pb); /* entries */\n\n    /* Prepare space for hosting multiple extradata. */\n    sc->extradata = av_mallocz_array(sc->stsd_count, sizeof(*sc->extradata));\n    if (!sc->extradata)\n        return AVERROR(ENOMEM);\n\n    sc->extradata_size = av_mallocz_array(sc->stsd_count, sizeof(sc->extradata_size));\n    if (!sc->extradata_size)\n        return AVERROR(ENOMEM);\n\n    ret = ff_mov_read_stsd_entries(c, pb, sc->stsd_count);\n    if (ret < 0)\n        return ret;\n\n    /* Restore back the primary extradata. */\n    av_free(st->codecpar->extradata);\n    st->codecpar->extradata_size = sc->extradata_size[0];\n    st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codecpar->extradata)\n        return AVERROR(ENOMEM);\n    memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);\n\n    return 0;\n}", "before_change_lines": [3, 7, 9], "raw_before_change_lines": [3, 7, 9], "after_change_lines": [3, 4, 5, 7, 8, 9, 10, 14, 17, 18, 19, 21, 22, 23, 25, 26, 27, 30, 31, 32, 33, 34, 35, 37], "raw_after_change_lines": [3, 4, 5, 6, 7, 8, 9, 10, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37], "bug_lines": [3, 7, 9], "added": [false, false, false], "idx": 288}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7734----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a43e5676c129f81e287895eaea78a449c724a34b_1.json----parse_command_line", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_a43e5676c129f81e287895eaea78a449c724a34b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a43e5676c129f81e287895eaea78a449c724a34b_1.json", "function_name": "parse_command_line", "vul_func_code": "static inline int parse_command_line(AVFormatContext *s, const char *line,\n                                     int linelen, char *uri, int urisize,\n                                     char *method, int methodsize,\n                                     enum RTSPMethod *methodcode)\n{\n    RTSPState *rt = s->priv_data;\n    const char *linept, *searchlinept;\n    linept = strchr(line, ' ');\n    if (linept - line > methodsize - 1) {\n        av_log(s, AV_LOG_ERROR, \"Method string too long\\n\");\n        return AVERROR(EIO);\n    }\n    memcpy(method, line, linept - line);\n    method[linept - line] = '\\0';\n    linept++;\n    if (!strcmp(method, \"ANNOUNCE\"))\n        *methodcode = ANNOUNCE;\n    else if (!strcmp(method, \"OPTIONS\"))\n        *methodcode = OPTIONS;\n    else if (!strcmp(method, \"RECORD\"))\n        *methodcode = RECORD;\n    else if (!strcmp(method, \"SETUP\"))\n        *methodcode = SETUP;\n    else if (!strcmp(method, \"PAUSE\"))\n        *methodcode = PAUSE;\n    else if (!strcmp(method, \"TEARDOWN\"))\n        *methodcode = TEARDOWN;\n    else\n        *methodcode = UNKNOWN;\n    /* Check method with the state  */\n    if (rt->state == RTSP_STATE_IDLE) {\n        if ((*methodcode != ANNOUNCE) && (*methodcode != OPTIONS)) {\n            av_log(s, AV_LOG_ERROR, \"Unexpected command in Idle State %s\\n\",\n                   line);\n            return AVERROR_PROTOCOL_NOT_FOUND;\n        }\n    } else if (rt->state == RTSP_STATE_PAUSED) {\n        if ((*methodcode != OPTIONS) && (*methodcode != RECORD)\n            && (*methodcode != SETUP)) {\n            av_log(s, AV_LOG_ERROR, \"Unexpected command in Paused State %s\\n\",\n                   line);\n            return AVERROR_PROTOCOL_NOT_FOUND;\n        }\n    } else if (rt->state == RTSP_STATE_STREAMING) {\n        if ((*methodcode != PAUSE) && (*methodcode != OPTIONS)\n            && (*methodcode != TEARDOWN)) {\n            av_log(s, AV_LOG_ERROR, \"Unexpected command in Streaming State\"\n                   \" %s\\n\", line);\n            return AVERROR_PROTOCOL_NOT_FOUND;\n        }\n    } else {\n        av_log(s, AV_LOG_ERROR, \"Unexpected State [%d]\\n\", rt->state);\n        return AVERROR_BUG;\n    }\n\n    searchlinept = strchr(linept, ' ');\n    if (searchlinept == NULL) {\n        av_log(s, AV_LOG_ERROR, \"Error parsing message URI\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (searchlinept - linept > urisize - 1) {\n        av_log(s, AV_LOG_ERROR, \"uri string length exceeded buffer size\\n\");\n        return AVERROR(EIO);\n    }\n    memcpy(uri, linept, searchlinept - linept);\n    uri[searchlinept - linept] = '\\0';\n    if (strcmp(rt->control_uri, uri)) {\n        char host[128], path[512], auth[128];\n        int port;\n        char ctl_host[128], ctl_path[512], ctl_auth[128];\n        int ctl_port;\n        av_url_split(NULL, 0, auth, sizeof(auth), host, sizeof(host), &port,\n                     path, sizeof(path), uri);\n        av_url_split(NULL, 0, ctl_auth, sizeof(ctl_auth), ctl_host,\n                     sizeof(ctl_host), &ctl_port, ctl_path, sizeof(ctl_path),\n                     rt->control_uri);\n        if (strcmp(host, ctl_host))\n            av_log(s, AV_LOG_INFO, \"Host %s differs from expected %s\\n\",\n                   host, ctl_host);\n        if (strcmp(path, ctl_path) && *methodcode != SETUP)\n            av_log(s, AV_LOG_WARNING, \"WARNING: Path %s differs from expected\"\n                   \" %s\\n\", path, ctl_path);\n        if (*methodcode == ANNOUNCE) {\n            av_log(s, AV_LOG_INFO,\n                   \"Updating control URI to %s\\n\", uri);\n            strcpy(rt->control_uri, uri);\n        }\n    }\n\n    linept = searchlinept + 1;\n    if (!av_strstart(linept, \"RTSP/1.0\", NULL)) {\n        av_log(s, AV_LOG_ERROR, \"Error parsing protocol or version\\n\");\n        return AVERROR_PROTOCOL_NOT_FOUND;\n    }\n    return 0;\n}", "patch_func_code": "static inline int parse_command_line(AVFormatContext *s, const char *line,\n                                     int linelen, char *uri, int urisize,\n                                     char *method, int methodsize,\n                                     enum RTSPMethod *methodcode)\n{\n    RTSPState *rt = s->priv_data;\n    const char *linept, *searchlinept;\n    linept = strchr(line, ' ');\n    if (linept - line > methodsize - 1) {\n        av_log(s, AV_LOG_ERROR, \"Method string too long\\n\");\n        return AVERROR(EIO);\n    }\n    memcpy(method, line, linept - line);\n    method[linept - line] = '\\0';\n    linept++;\n    if (!strcmp(method, \"ANNOUNCE\"))\n        *methodcode = ANNOUNCE;\n    else if (!strcmp(method, \"OPTIONS\"))\n        *methodcode = OPTIONS;\n    else if (!strcmp(method, \"RECORD\"))\n        *methodcode = RECORD;\n    else if (!strcmp(method, \"SETUP\"))\n        *methodcode = SETUP;\n    else if (!strcmp(method, \"PAUSE\"))\n        *methodcode = PAUSE;\n    else if (!strcmp(method, \"TEARDOWN\"))\n        *methodcode = TEARDOWN;\n    else\n        *methodcode = UNKNOWN;\n    /* Check method with the state  */\n    if (rt->state == RTSP_STATE_IDLE) {\n        if ((*methodcode != ANNOUNCE) && (*methodcode != OPTIONS)) {\n            av_log(s, AV_LOG_ERROR, \"Unexpected command in Idle State %s\\n\",\n                   line);\n            return AVERROR_PROTOCOL_NOT_FOUND;\n        }\n    } else if (rt->state == RTSP_STATE_PAUSED) {\n        if ((*methodcode != OPTIONS) && (*methodcode != RECORD)\n            && (*methodcode != SETUP)) {\n            av_log(s, AV_LOG_ERROR, \"Unexpected command in Paused State %s\\n\",\n                   line);\n            return AVERROR_PROTOCOL_NOT_FOUND;\n        }\n    } else if (rt->state == RTSP_STATE_STREAMING) {\n        if ((*methodcode != PAUSE) && (*methodcode != OPTIONS)\n            && (*methodcode != TEARDOWN)) {\n            av_log(s, AV_LOG_ERROR, \"Unexpected command in Streaming State\"\n                   \" %s\\n\", line);\n            return AVERROR_PROTOCOL_NOT_FOUND;\n        }\n    } else {\n        av_log(s, AV_LOG_ERROR, \"Unexpected State [%d]\\n\", rt->state);\n        return AVERROR_BUG;\n    }\n\n    searchlinept = strchr(linept, ' ');\n    if (searchlinept == NULL) {\n        av_log(s, AV_LOG_ERROR, \"Error parsing message URI\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (searchlinept - linept > urisize - 1) {\n        av_log(s, AV_LOG_ERROR, \"uri string length exceeded buffer size\\n\");\n        return AVERROR(EIO);\n    }\n    memcpy(uri, linept, searchlinept - linept);\n    uri[searchlinept - linept] = '\\0';\n    if (strcmp(rt->control_uri, uri)) {\n        char host[128], path[512], auth[128];\n        int port;\n        char ctl_host[128], ctl_path[512], ctl_auth[128];\n        int ctl_port;\n        av_url_split(NULL, 0, auth, sizeof(auth), host, sizeof(host), &port,\n                     path, sizeof(path), uri);\n        av_url_split(NULL, 0, ctl_auth, sizeof(ctl_auth), ctl_host,\n                     sizeof(ctl_host), &ctl_port, ctl_path, sizeof(ctl_path),\n                     rt->control_uri);\n        if (strcmp(host, ctl_host))\n            av_log(s, AV_LOG_INFO, \"Host %s differs from expected %s\\n\",\n                   host, ctl_host);\n        if (strcmp(path, ctl_path) && *methodcode != SETUP)\n            av_log(s, AV_LOG_WARNING, \"WARNING: Path %s differs from expected\"\n                   \" %s\\n\", path, ctl_path);\n        if (*methodcode == ANNOUNCE) {\n            av_log(s, AV_LOG_INFO,\n                   \"Updating control URI to %s\\n\", uri);\n            av_strlcpy(rt->control_uri, uri, sizeof(rt->control_uri));\n        }\n    }\n\n    linept = searchlinept + 1;\n    if (!av_strstart(linept, \"RTSP/1.0\", NULL)) {\n        av_log(s, AV_LOG_ERROR, \"Error parsing protocol or version\\n\");\n        return AVERROR_PROTOCOL_NOT_FOUND;\n    }\n    return 0;\n}", "before_change_lines": [86], "raw_before_change_lines": [86], "after_change_lines": [86], "raw_after_change_lines": [86], "bug_lines": [86], "added": [false], "idx": 289}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "7761----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a5a095bf58869d2ba60cadc45e6cdeaa88a12185_1.json----decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_a5a095bf58869d2ba60cadc45e6cdeaa88a12185_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a5a095bf58869d2ba60cadc45e6cdeaa88a12185_1.json", "function_name": "decode_frame", "vul_func_code": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    H264Context *h     = avctx->priv_data;\n    AVFrame *pict      = data;\n    int buf_index      = 0;\n    int ret;\n\n    h->flags  = avctx->flags;\n\n    /* end of stream, output what is still in the buffers */\nout:\n    if (buf_size == 0) {\n        Picture *out;\n        int i, out_idx;\n\n        h->cur_pic_ptr = NULL;\n\n        // FIXME factorize this with the output code below\n        out     = h->delayed_pic[0];\n        out_idx = 0;\n        for (i = 1;\n             h->delayed_pic[i] &&\n             !h->delayed_pic[i]->f.key_frame &&\n             !h->delayed_pic[i]->mmco_reset;\n             i++)\n            if (h->delayed_pic[i]->poc < out->poc) {\n                out     = h->delayed_pic[i];\n                out_idx = i;\n            }\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n        if (out) {\n            if ((ret = av_frame_ref(pict, &out->f)) < 0)\n                return ret;\n            *got_frame = 1;\n        }\n\n        return buf_index;\n    }\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n    if (buf_index < 0)\n        return -1;\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n        buf_size = 0;\n        goto out;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n            return 0;\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n        return -1;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n            decode_postinit(h, 1);\n\n        field_end(h, 0);\n\n        if (!h->next_output_pic) {\n            /* Wait for second field. */\n            *got_frame = 0;\n        } else {\n            if ((ret = av_frame_ref(pict, &h->next_output_pic->f)) < 0)\n                return ret;\n            *got_frame = 1;\n        }\n    }\n\n    assert(pict->data[0] || !*got_frame);\n\n    return get_consumed_bytes(buf_index, buf_size);\n}", "patch_func_code": "static int decode_frame(AVCodecContext *avctx, void *data,\n                        int *got_frame, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    H264Context *h     = avctx->priv_data;\n    AVFrame *pict      = data;\n    int buf_index      = 0;\n    int ret;\n\n    h->flags  = avctx->flags;\n\n    /* end of stream, output what is still in the buffers */\nout:\n    if (buf_size == 0) {\n        Picture *out;\n        int i, out_idx;\n\n        h->cur_pic_ptr = NULL;\n\n        // FIXME factorize this with the output code below\n        out     = h->delayed_pic[0];\n        out_idx = 0;\n        for (i = 1;\n             h->delayed_pic[i] &&\n             !h->delayed_pic[i]->f.key_frame &&\n             !h->delayed_pic[i]->mmco_reset;\n             i++)\n            if (h->delayed_pic[i]->poc < out->poc) {\n                out     = h->delayed_pic[i];\n                out_idx = i;\n            }\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n        if (out) {\n            ret = output_frame(h, pict, &out->f);\n            if (ret < 0)\n                return ret;\n            *got_frame = 1;\n        }\n\n        return buf_index;\n    }\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n    if (buf_index < 0)\n        return -1;\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n        buf_size = 0;\n        goto out;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n            return 0;\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n        return -1;\n    }\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n            decode_postinit(h, 1);\n\n        field_end(h, 0);\n\n        if (!h->next_output_pic) {\n            /* Wait for second field. */\n            *got_frame = 0;\n        } else {\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n            if (ret < 0)\n                return ret;\n            *got_frame = 1;\n        }\n    }\n\n    assert(pict->data[0] || !*got_frame);\n\n    return get_consumed_bytes(buf_index, buf_size);\n}", "before_change_lines": [38, 73], "raw_before_change_lines": [38, 73], "after_change_lines": [38, 39, 74, 75], "raw_after_change_lines": [38, 39, 74, 75], "bug_lines": [38, 73], "added": [false, false], "idx": 290}
{"project": "libav", "vul_type": "INFERBO_ALLOC_MAY_BE_BIG", "filepath_func": "7805----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a8338af27a0f47920be36307107618cb60fb51fa_1.json----allocate_buffers", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_a8338af27a0f47920be36307107618cb60fb51fa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a8338af27a0f47920be36307107618cb60fb51fa_1.json", "function_name": "allocate_buffers", "vul_func_code": "static void allocate_buffers(FLACContext *s)\n{\n    int i;\n\n    assert(s->max_blocksize);\n\n    for (i = 0; i < s->channels; i++) {\n        s->decoded[i] = av_realloc(s->decoded[i],\n                                   sizeof(int32_t)*s->max_blocksize);\n    }\n}", "patch_func_code": "static void allocate_buffers(FLACContext *s)\n{\n    int i;\n\n    assert(s->max_blocksize);\n\n    for (i = 0; i < s->channels; i++) {\n        s->decoded[i] = av_malloc(sizeof(int32_t)*s->max_blocksize);\n    }\n}", "before_change_lines": [8, 9], "raw_before_change_lines": [8, 9], "after_change_lines": [8], "raw_after_change_lines": [8], "bug_lines": [8, 9], "added": [false, false], "idx": 291}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7816----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a88038817c0e7f00b9c1447d22c6c8be305eafab_1.json----encode_slice", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_a88038817c0e7f00b9c1447d22c6c8be305eafab_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_a88038817c0e7f00b9c1447d22c6c8be305eafab_1.json", "function_name": "encode_slice", "vul_func_code": "static int encode_slice(AVCodecContext *avctx, const AVFrame *pic,\n                        PutBitContext *pb,\n                        int sizes[4], int x, int y, int quant,\n                        int mbs_per_slice)\n{\n    ProresContext *ctx = avctx->priv_data;\n    int i, xp, yp;\n    int total_size = 0;\n    const uint16_t *src;\n    int slice_width_factor = av_log2(mbs_per_slice);\n    int num_cblocks, pwidth, linesize, line_add;\n    int plane_factor, is_chroma;\n    uint16_t *qmat;\n\n    if (ctx->pictures_per_frame == 1)\n        line_add = 0;\n    else\n        line_add = ctx->cur_picture_idx ^ !pic->top_field_first;\n\n    if (ctx->force_quant) {\n        qmat = ctx->quants[0];\n    } else if (quant < MAX_STORED_Q) {\n        qmat = ctx->quants[quant];\n    } else {\n        qmat = ctx->custom_q;\n        for (i = 0; i < 64; i++)\n            qmat[i] = ctx->quant_mat[i] * quant;\n    }\n\n    for (i = 0; i < ctx->num_planes; i++) {\n        is_chroma    = (i == 1 || i == 2);\n        plane_factor = slice_width_factor + 2;\n        if (is_chroma)\n            plane_factor += ctx->chroma_factor - 3;\n        if (!is_chroma || ctx->chroma_factor == CFACTOR_Y444) {\n            xp          = x << 4;\n            yp          = y << 4;\n            num_cblocks = 4;\n            pwidth      = avctx->width;\n        } else {\n            xp          = x << 3;\n            yp          = y << 4;\n            num_cblocks = 2;\n            pwidth      = avctx->width >> 1;\n        }\n\n        linesize = pic->linesize[i] * ctx->pictures_per_frame;\n        src = (const uint16_t*)(pic->data[i] + yp * linesize +\n                                line_add * pic->linesize[i]) + xp;\n\n        if (i < 3) {\n            get_slice_data(ctx, src, linesize, xp, yp,\n                           pwidth, avctx->height / ctx->pictures_per_frame,\n                           ctx->blocks[0], ctx->emu_buf,\n                           mbs_per_slice, num_cblocks, is_chroma);\n            sizes[i] = encode_slice_plane(ctx, pb, src, linesize,\n                                          mbs_per_slice, ctx->blocks[0],\n                                          num_cblocks, plane_factor,\n                                          qmat);\n        } else {\n            get_alpha_data(ctx, src, linesize, xp, yp,\n                           pwidth, avctx->height / ctx->pictures_per_frame,\n                           ctx->blocks[0], mbs_per_slice, ctx->alpha_bits);\n            sizes[i] = encode_alpha_plane(ctx, pb, mbs_per_slice,\n                                          ctx->blocks[0], quant);\n        }\n        total_size += sizes[i];\n        if (put_bits_left(pb) < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Underestimated required buffer size.\\n\");\n            return AVERROR_BUG;\n        }\n    }\n    return total_size;\n}", "patch_func_code": "static int encode_slice(AVCodecContext *avctx, const AVFrame *pic,\n                        PutBitContext *pb,\n                        int sizes[4], int x, int y, int quant,\n                        int mbs_per_slice)\n{\n    ProresContext *ctx = avctx->priv_data;\n    int i, xp, yp;\n    int total_size = 0;\n    const uint16_t *src;\n    int slice_width_factor = av_log2(mbs_per_slice);\n    int num_cblocks, pwidth, line_add;\n    ptrdiff_t linesize;\n    int plane_factor, is_chroma;\n    uint16_t *qmat;\n\n    if (ctx->pictures_per_frame == 1)\n        line_add = 0;\n    else\n        line_add = ctx->cur_picture_idx ^ !pic->top_field_first;\n\n    if (ctx->force_quant) {\n        qmat = ctx->quants[0];\n    } else if (quant < MAX_STORED_Q) {\n        qmat = ctx->quants[quant];\n    } else {\n        qmat = ctx->custom_q;\n        for (i = 0; i < 64; i++)\n            qmat[i] = ctx->quant_mat[i] * quant;\n    }\n\n    for (i = 0; i < ctx->num_planes; i++) {\n        is_chroma    = (i == 1 || i == 2);\n        plane_factor = slice_width_factor + 2;\n        if (is_chroma)\n            plane_factor += ctx->chroma_factor - 3;\n        if (!is_chroma || ctx->chroma_factor == CFACTOR_Y444) {\n            xp          = x << 4;\n            yp          = y << 4;\n            num_cblocks = 4;\n            pwidth      = avctx->width;\n        } else {\n            xp          = x << 3;\n            yp          = y << 4;\n            num_cblocks = 2;\n            pwidth      = avctx->width >> 1;\n        }\n\n        linesize = pic->linesize[i] * ctx->pictures_per_frame;\n        src = (const uint16_t*)(pic->data[i] + yp * linesize +\n                                line_add * pic->linesize[i]) + xp;\n\n        if (i < 3) {\n            get_slice_data(ctx, src, linesize, xp, yp,\n                           pwidth, avctx->height / ctx->pictures_per_frame,\n                           ctx->blocks[0], ctx->emu_buf,\n                           mbs_per_slice, num_cblocks, is_chroma);\n            sizes[i] = encode_slice_plane(ctx, pb, src, linesize,\n                                          mbs_per_slice, ctx->blocks[0],\n                                          num_cblocks, plane_factor,\n                                          qmat);\n        } else {\n            get_alpha_data(ctx, src, linesize, xp, yp,\n                           pwidth, avctx->height / ctx->pictures_per_frame,\n                           ctx->blocks[0], mbs_per_slice, ctx->alpha_bits);\n            sizes[i] = encode_alpha_plane(ctx, pb, mbs_per_slice,\n                                          ctx->blocks[0], quant);\n        }\n        total_size += sizes[i];\n        if (put_bits_left(pb) < 0) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"Underestimated required buffer size.\\n\");\n            return AVERROR_BUG;\n        }\n    }\n    return total_size;\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11, 12], "raw_after_change_lines": [11, 12], "bug_lines": [11], "added": [false], "idx": 292}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "7936----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_af34a64f7e7dd87c061d5177159816894859bfc9_1.json----ff_rate_estimate_qscale", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_af34a64f7e7dd87c061d5177159816894859bfc9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_af34a64f7e7dd87c061d5177159816894859bfc9_1.json", "function_name": "ff_rate_estimate_qscale", "vul_func_code": "float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)\n{\n    float q;\n    int qmin, qmax;\n    float br_compensation;\n    double diff;\n    double short_term_q;\n    double fps;\n    int picture_number = s->picture_number;\n    int64_t wanted_bits;\n    RateControlContext *rcc = &s->rc_context;\n    AVCodecContext *a       = s->avctx;\n    RateControlEntry local_rce, *rce;\n    double bits;\n    double rate_factor;\n    int var;\n    const int pict_type = s->pict_type;\n    Picture * const pic = &s->current_picture;\n    emms_c();\n\n#if CONFIG_LIBXVID\n    if ((s->flags & CODEC_FLAG_PASS2) &&\n        s->avctx->rc_strategy == FF_RC_STRATEGY_XVID)\n        return ff_xvid_rate_estimate_qscale(s, dry_run);\n#endif\n\n    get_qminmax(&qmin, &qmax, s, pict_type);\n\n    fps = 1 / av_q2d(s->avctx->time_base);\n    /* update predictors */\n    if (picture_number > 2 && !dry_run) {\n        const int last_var = s->last_pict_type == AV_PICTURE_TYPE_I ? rcc->last_mb_var_sum\n                                                                    : rcc->last_mc_mb_var_sum;\n        update_predictor(&rcc->pred[s->last_pict_type],\n                         rcc->last_qscale,\n                         sqrt(last_var), s->frame_bits);\n    }\n\n    if (s->flags & CODEC_FLAG_PASS2) {\n        assert(picture_number >= 0);\n        assert(picture_number < rcc->num_entries);\n        rce         = &rcc->entry[picture_number];\n        wanted_bits = rce->expected_bits;\n    } else {\n        Picture *dts_pic;\n        rce = &local_rce;\n\n        /* FIXME add a dts field to AVFrame and ensure it is set and use it\n         * here instead of reordering but the reordering is simpler for now\n         * until H.264 B-pyramid must be handled. */\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay)\n            dts_pic = s->current_picture_ptr;\n        else\n            dts_pic = s->last_picture_ptr;\n\n        if (!dts_pic || dts_pic->f.pts == AV_NOPTS_VALUE)\n            wanted_bits = (uint64_t)(s->bit_rate * (double)picture_number / fps);\n        else\n            wanted_bits = (uint64_t)(s->bit_rate * (double)dts_pic->f.pts / fps);\n    }\n\n    diff = s->total_bits - wanted_bits;\n    br_compensation = (a->bit_rate_tolerance - diff) / a->bit_rate_tolerance;\n    if (br_compensation <= 0.0)\n        br_compensation = 0.001;\n\n    var = pict_type == AV_PICTURE_TYPE_I ? pic->mb_var_sum : pic->mc_mb_var_sum;\n\n    short_term_q = 0; /* avoid warning */\n    if (s->flags & CODEC_FLAG_PASS2) {\n        if (pict_type != AV_PICTURE_TYPE_I)\n            assert(pict_type == rce->new_pict_type);\n\n        q = rce->new_qscale / br_compensation;\n        av_dlog(s, \"%f %f %f last:%d var:%d type:%d//\\n\", q, rce->new_qscale,\n                br_compensation, s->frame_bits, var, pict_type);\n    } else {\n        rce->pict_type     =\n        rce->new_pict_type = pict_type;\n        rce->mc_mb_var_sum = pic->mc_mb_var_sum;\n        rce->mb_var_sum    = pic->mb_var_sum;\n        rce->qscale        = FF_QP2LAMBDA * 2;\n        rce->f_code        = s->f_code;\n        rce->b_code        = s->b_code;\n        rce->misc_bits     = 1;\n\n        bits = predict_size(&rcc->pred[pict_type], rce->qscale, sqrt(var));\n        if (pict_type == AV_PICTURE_TYPE_I) {\n            rce->i_count    = s->mb_num;\n            rce->i_tex_bits = bits;\n            rce->p_tex_bits = 0;\n            rce->mv_bits    = 0;\n        } else {\n            rce->i_count    = 0;    // FIXME we do know this approx\n            rce->i_tex_bits = 0;\n            rce->p_tex_bits = bits * 0.9;\n            rce->mv_bits    = bits * 0.1;\n        }\n        rcc->i_cplx_sum[pict_type]  += rce->i_tex_bits * rce->qscale;\n        rcc->p_cplx_sum[pict_type]  += rce->p_tex_bits * rce->qscale;\n        rcc->mv_bits_sum[pict_type] += rce->mv_bits;\n        rcc->frame_count[pict_type]++;\n\n        bits        = rce->i_tex_bits + rce->p_tex_bits;\n        rate_factor = rcc->pass1_wanted_bits /\n                      rcc->pass1_rc_eq_output_sum * br_compensation;\n\n        q = get_qscale(s, rce, rate_factor, picture_number);\n        if (q < 0)\n            return -1;\n\n        assert(q > 0.0);\n        q = get_diff_limited_q(s, rce, q);\n        assert(q > 0.0);\n\n        // FIXME type dependent blur like in 2-pass\n        if (pict_type == AV_PICTURE_TYPE_P || s->intra_only) {\n            rcc->short_term_qsum   *= a->qblur;\n            rcc->short_term_qcount *= a->qblur;\n\n            rcc->short_term_qsum += q;\n            rcc->short_term_qcount++;\n            q = short_term_q = rcc->short_term_qsum / rcc->short_term_qcount;\n        }\n        assert(q > 0.0);\n\n        q = modify_qscale(s, rce, q, picture_number);\n\n        rcc->pass1_wanted_bits += s->bit_rate / fps;\n\n        assert(q > 0.0);\n    }\n\n    if (s->avctx->debug & FF_DEBUG_RC) {\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"%c qp:%d<%2.1f<%d %d want:%d total:%d comp:%f st_q:%2.2f \"\n               \"size:%d var:%d/%d br:%d fps:%d\\n\",\n               av_get_picture_type_char(pict_type),\n               qmin, q, qmax, picture_number,\n               (int)wanted_bits / 1000, (int)s->total_bits / 1000,\n               br_compensation, short_term_q, s->frame_bits,\n               pic->mb_var_sum, pic->mc_mb_var_sum,\n               s->bit_rate / 1000, (int)fps);\n    }\n\n    if (q < qmin)\n        q = qmin;\n    else if (q > qmax)\n        q = qmax;\n\n    if (s->adaptive_quant)\n        adaptive_quantization(s, q);\n    else\n        q = (int)(q + 0.5);\n\n    if (!dry_run) {\n        rcc->last_qscale        = q;\n        rcc->last_mc_mb_var_sum = pic->mc_mb_var_sum;\n        rcc->last_mb_var_sum    = pic->mb_var_sum;\n    }\n    return q;\n}", "patch_func_code": "float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)\n{\n    float q;\n    int qmin, qmax;\n    float br_compensation;\n    double diff;\n    double short_term_q;\n    double fps;\n    int picture_number = s->picture_number;\n    int64_t wanted_bits;\n    RateControlContext *rcc = &s->rc_context;\n    AVCodecContext *a       = s->avctx;\n    RateControlEntry local_rce, *rce;\n    double bits;\n    double rate_factor;\n    int var;\n    const int pict_type = s->pict_type;\n    Picture * const pic = &s->current_picture;\n    emms_c();\n\n#if CONFIG_LIBXVID\n    if ((s->flags & CODEC_FLAG_PASS2) &&\n        s->avctx->rc_strategy == FF_RC_STRATEGY_XVID)\n        return ff_xvid_rate_estimate_qscale(s, dry_run);\n#endif\n\n    get_qminmax(&qmin, &qmax, s, pict_type);\n\n    fps = 1 / av_q2d(s->avctx->time_base);\n    /* update predictors */\n    if (picture_number > 2 && !dry_run) {\n        const int last_var = s->last_pict_type == AV_PICTURE_TYPE_I ? rcc->last_mb_var_sum\n                                                                    : rcc->last_mc_mb_var_sum;\n        update_predictor(&rcc->pred[s->last_pict_type],\n                         rcc->last_qscale,\n                         sqrt(last_var), s->frame_bits);\n    }\n\n    if (s->flags & CODEC_FLAG_PASS2) {\n        assert(picture_number >= 0);\n        assert(picture_number < rcc->num_entries);\n        rce         = &rcc->entry[picture_number];\n        wanted_bits = rce->expected_bits;\n    } else {\n        Picture *dts_pic;\n        rce = &local_rce;\n\n        /* FIXME add a dts field to AVFrame and ensure it is set and use it\n         * here instead of reordering but the reordering is simpler for now\n         * until H.264 B-pyramid must be handled. */\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay)\n            dts_pic = s->current_picture_ptr;\n        else\n            dts_pic = s->last_picture_ptr;\n\n        if (!dts_pic || dts_pic->f->pts == AV_NOPTS_VALUE)\n            wanted_bits = (uint64_t)(s->bit_rate * (double)picture_number / fps);\n        else\n            wanted_bits = (uint64_t)(s->bit_rate * (double)dts_pic->f->pts / fps);\n    }\n\n    diff = s->total_bits - wanted_bits;\n    br_compensation = (a->bit_rate_tolerance - diff) / a->bit_rate_tolerance;\n    if (br_compensation <= 0.0)\n        br_compensation = 0.001;\n\n    var = pict_type == AV_PICTURE_TYPE_I ? pic->mb_var_sum : pic->mc_mb_var_sum;\n\n    short_term_q = 0; /* avoid warning */\n    if (s->flags & CODEC_FLAG_PASS2) {\n        if (pict_type != AV_PICTURE_TYPE_I)\n            assert(pict_type == rce->new_pict_type);\n\n        q = rce->new_qscale / br_compensation;\n        av_dlog(s, \"%f %f %f last:%d var:%d type:%d//\\n\", q, rce->new_qscale,\n                br_compensation, s->frame_bits, var, pict_type);\n    } else {\n        rce->pict_type     =\n        rce->new_pict_type = pict_type;\n        rce->mc_mb_var_sum = pic->mc_mb_var_sum;\n        rce->mb_var_sum    = pic->mb_var_sum;\n        rce->qscale        = FF_QP2LAMBDA * 2;\n        rce->f_code        = s->f_code;\n        rce->b_code        = s->b_code;\n        rce->misc_bits     = 1;\n\n        bits = predict_size(&rcc->pred[pict_type], rce->qscale, sqrt(var));\n        if (pict_type == AV_PICTURE_TYPE_I) {\n            rce->i_count    = s->mb_num;\n            rce->i_tex_bits = bits;\n            rce->p_tex_bits = 0;\n            rce->mv_bits    = 0;\n        } else {\n            rce->i_count    = 0;    // FIXME we do know this approx\n            rce->i_tex_bits = 0;\n            rce->p_tex_bits = bits * 0.9;\n            rce->mv_bits    = bits * 0.1;\n        }\n        rcc->i_cplx_sum[pict_type]  += rce->i_tex_bits * rce->qscale;\n        rcc->p_cplx_sum[pict_type]  += rce->p_tex_bits * rce->qscale;\n        rcc->mv_bits_sum[pict_type] += rce->mv_bits;\n        rcc->frame_count[pict_type]++;\n\n        bits        = rce->i_tex_bits + rce->p_tex_bits;\n        rate_factor = rcc->pass1_wanted_bits /\n                      rcc->pass1_rc_eq_output_sum * br_compensation;\n\n        q = get_qscale(s, rce, rate_factor, picture_number);\n        if (q < 0)\n            return -1;\n\n        assert(q > 0.0);\n        q = get_diff_limited_q(s, rce, q);\n        assert(q > 0.0);\n\n        // FIXME type dependent blur like in 2-pass\n        if (pict_type == AV_PICTURE_TYPE_P || s->intra_only) {\n            rcc->short_term_qsum   *= a->qblur;\n            rcc->short_term_qcount *= a->qblur;\n\n            rcc->short_term_qsum += q;\n            rcc->short_term_qcount++;\n            q = short_term_q = rcc->short_term_qsum / rcc->short_term_qcount;\n        }\n        assert(q > 0.0);\n\n        q = modify_qscale(s, rce, q, picture_number);\n\n        rcc->pass1_wanted_bits += s->bit_rate / fps;\n\n        assert(q > 0.0);\n    }\n\n    if (s->avctx->debug & FF_DEBUG_RC) {\n        av_log(s->avctx, AV_LOG_DEBUG,\n               \"%c qp:%d<%2.1f<%d %d want:%d total:%d comp:%f st_q:%2.2f \"\n               \"size:%d var:%d/%d br:%d fps:%d\\n\",\n               av_get_picture_type_char(pict_type),\n               qmin, q, qmax, picture_number,\n               (int)wanted_bits / 1000, (int)s->total_bits / 1000,\n               br_compensation, short_term_q, s->frame_bits,\n               pic->mb_var_sum, pic->mc_mb_var_sum,\n               s->bit_rate / 1000, (int)fps);\n    }\n\n    if (q < qmin)\n        q = qmin;\n    else if (q > qmax)\n        q = qmax;\n\n    if (s->adaptive_quant)\n        adaptive_quantization(s, q);\n    else\n        q = (int)(q + 0.5);\n\n    if (!dry_run) {\n        rcc->last_qscale        = q;\n        rcc->last_mc_mb_var_sum = pic->mc_mb_var_sum;\n        rcc->last_mb_var_sum    = pic->mb_var_sum;\n    }\n    return q;\n}", "before_change_lines": [56, 59], "raw_before_change_lines": [56, 59], "after_change_lines": [56, 59], "raw_after_change_lines": [56, 59], "bug_lines": [56, 59], "added": [false, false], "idx": 293}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "7990----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_b2c9b95fb38cfbaffe9940504366c515800c7b6c_1.json----read_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_b2c9b95fb38cfbaffe9940504366c515800c7b6c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_b2c9b95fb38cfbaffe9940504366c515800c7b6c_1.json", "function_name": "read_packet", "vul_func_code": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size)\n{\n    AVIOContext *pb = s->pb;\n    int skip, len;\n\n    for(;;) {\n        len = avio_read(pb, buf, TS_PACKET_SIZE);\n        if (len != TS_PACKET_SIZE)\n            return len < 0 ? len : AVERROR_EOF;\n        /* check packet sync byte */\n        if (buf[0] != 0x47) {\n            /* find a new packet start */\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n            if (mpegts_resync(s) < 0)\n                return AVERROR(EAGAIN);\n            else\n                continue;\n        } else {\n            skip = raw_packet_size - TS_PACKET_SIZE;\n            if (skip > 0)\n                avio_skip(pb, skip);\n            break;\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n{\n    AVIOContext *pb = s->pb;\n    int len;\n\n    for(;;) {\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n        if (len != TS_PACKET_SIZE)\n            return len < 0 ? len : AVERROR_EOF;\n        /* check packet sync byte */\n        if ((*data)[0] != 0x47) {\n            /* find a new packet start */\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n            if (mpegts_resync(s) < 0)\n                return AVERROR(EAGAIN);\n            else\n                continue;\n        } else {\n            break;\n        }\n    }\n    return 0;\n}", "before_change_lines": [1, 4, 7, 11, 19, 20, 21], "raw_before_change_lines": [1, 4, 7, 11, 19, 20, 21], "after_change_lines": [1, 4, 7, 11], "raw_after_change_lines": [1, 4, 7, 11], "bug_lines": [1, 4, 7, 11, 19, 20, 21], "added": [false, false, false, false, false, false, false], "idx": 294}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "8017----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_b472f526088b7f473acfea91592c41e19b7ffb66_1.json----expand_rle_row", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_b472f526088b7f473acfea91592c41e19b7ffb66_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_b472f526088b7f473acfea91592c41e19b7ffb66_1.json", "function_name": "expand_rle_row", "vul_func_code": "static int expand_rle_row(SgiState *s, uint8_t *out_buf,\n                          uint8_t *out_end, int pixelstride)\n{\n    unsigned char pixel, count;\n    unsigned char *orig = out_buf;\n\n    while (1) {\n        if (bytestream2_get_bytes_left(&s->g) < 1)\n            return AVERROR_INVALIDDATA;\n        pixel = bytestream2_get_byteu(&s->g);\n        if (!(count = (pixel & 0x7f))) {\n            return (out_buf - orig) / pixelstride;\n        }\n\n        /* Check for buffer overflow. */\n        if(out_buf + pixelstride * count >= out_end) return -1;\n\n        if (pixel & 0x80) {\n            while (count--) {\n                *out_buf = bytestream2_get_byte(&s->g);\n                out_buf += pixelstride;\n            }\n        } else {\n            pixel = bytestream2_get_byte(&s->g);\n\n            while (count--) {\n                *out_buf = pixel;\n                out_buf += pixelstride;\n            }\n        }\n    }\n}", "patch_func_code": "static int expand_rle_row(SgiState *s, uint8_t *out_buf,\n                          int len, int pixelstride)\n{\n    unsigned char pixel, count;\n    unsigned char *orig = out_buf;\n\n    while (1) {\n        if (bytestream2_get_bytes_left(&s->g) < 1)\n            return AVERROR_INVALIDDATA;\n        pixel = bytestream2_get_byteu(&s->g);\n        if (!(count = (pixel & 0x7f))) {\n            return (out_buf - orig) / pixelstride;\n        }\n\n        /* Check for buffer overflow. */\n        if (pixelstride * (count - 1) >= len) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid pixel count.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (pixel & 0x80) {\n            while (count--) {\n                *out_buf = bytestream2_get_byte(&s->g);\n                out_buf += pixelstride;\n            }\n        } else {\n            pixel = bytestream2_get_byte(&s->g);\n\n            while (count--) {\n                *out_buf = pixel;\n                out_buf += pixelstride;\n            }\n        }\n    }\n}", "before_change_lines": [2, 16], "raw_before_change_lines": [2, 16], "after_change_lines": [2, 16, 17, 18, 19], "raw_after_change_lines": [2, 16, 17, 18, 19], "bug_lines": [2, 16], "added": [false, false], "idx": 295}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "8146----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_bd055b74c019049025bcfe911a2e10b6e1a8910d_1.json----flv_read_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_bd055b74c019049025bcfe911a2e10b6e1a8910d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_bd055b74c019049025bcfe911a2e10b6e1a8910d_1.json", "function_name": "flv_read_packet", "vul_func_code": "static int flv_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    FLVContext *flv = s->priv_data;\n    int ret, i, size, flags, is_audio;\n    enum FlvTagType type;\n    int64_t next, pos;\n    int64_t dts, pts = AV_NOPTS_VALUE;\n    int sample_rate = 0, channels = 0;\n    AVStream *st    = NULL;\n\n    /* pkt size is repeated at end. skip it */\n    for (;; avio_skip(s->pb, 4)) {\n        pos  = avio_tell(s->pb);\n        type = avio_r8(s->pb);\n        size = avio_rb24(s->pb);\n        dts  = avio_rb24(s->pb);\n        dts |= avio_r8(s->pb) << 24;\n        av_log(s, AV_LOG_TRACE, \"type:%d, size:%d, dts:%\"PRId64\"\\n\", type, size, dts);\n        if (s->pb->eof_reached)\n            return AVERROR_EOF;\n        avio_skip(s->pb, 3); /* stream id, always 0 */\n        flags = 0;\n\n        if (flv->validate_next < flv->validate_count) {\n            int64_t validate_pos = flv->validate_index[flv->validate_next].pos;\n            if (pos == validate_pos) {\n                if (FFABS(dts - flv->validate_index[flv->validate_next].dts) <=\n                    VALIDATE_INDEX_TS_THRESH) {\n                    flv->validate_next++;\n                } else {\n                    clear_index_entries(s, validate_pos);\n                    flv->validate_count = 0;\n                }\n            } else if (pos > validate_pos) {\n                clear_index_entries(s, validate_pos);\n                flv->validate_count = 0;\n            }\n        }\n\n        if (size == 0)\n            continue;\n\n        next = size + avio_tell(s->pb);\n\n        if (type == FLV_TAG_TYPE_AUDIO) {\n            is_audio = 1;\n            flags    = avio_r8(s->pb);\n            size--;\n        } else if (type == FLV_TAG_TYPE_VIDEO) {\n            is_audio = 0;\n            flags    = avio_r8(s->pb);\n            size--;\n            if ((flags & 0xf0) == 0x50) /* video info / command frame */\n                goto skip;\n        } else {\n            if (type == FLV_TAG_TYPE_META && size > 13 + 1 + 4)\n                if (flv_read_metabody(s, next) > 0) {\n                    return flv_data_packet(s, pkt, dts, next);\n                } else /* skip packet */\n                    av_log(s, AV_LOG_DEBUG,\n                           \"Skipping flv packet: type %d, size %d, flags %d.\\n\",\n                           type, size, flags);\n\nskip:\n            avio_seek(s->pb, next, SEEK_SET);\n            continue;\n        }\n\n        /* skip empty data packets */\n        if (!size)\n            continue;\n\n        /* now find stream */\n        for (i = 0; i < s->nb_streams; i++) {\n            st = s->streams[i];\n            if (is_audio && st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n                if (flv_same_audio_codec(st->codec, flags))\n                    break;\n            } else if (!is_audio &&\n                       st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n                if (flv_same_video_codec(st->codec, flags))\n                    break;\n            }\n        }\n        if (i == s->nb_streams) {\n            st = create_stream(s, is_audio ? AVMEDIA_TYPE_AUDIO\n                                           : AVMEDIA_TYPE_VIDEO);\n            if (!st)\n                return AVERROR(ENOMEM);\n        }\n        av_log(s, AV_LOG_TRACE, \"%d %X %d \\n\", is_audio, flags, st->discard);\n\n        if ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY ||\n            is_audio)\n            av_add_index_entry(st, pos, dts, size, 0, AVINDEX_KEYFRAME);\n\n        if ((st->discard >= AVDISCARD_NONKEY &&\n             !((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || is_audio)) ||\n            (st->discard >= AVDISCARD_BIDIR &&\n             ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_DISP_INTER && !is_audio)) ||\n            st->discard >= AVDISCARD_ALL) {\n            avio_seek(s->pb, next, SEEK_SET);\n            continue;\n        }\n        break;\n    }\n\n    // if not streamed and no duration from metadata then seek to end to find\n    // the duration from the timestamps\n    if (s->pb->seekable && (!s->duration || s->duration == AV_NOPTS_VALUE) &&\n        !flv->searched_for_end) {\n        int size;\n        const int64_t pos   = avio_tell(s->pb);\n        // Read the last 4 bytes of the file, this should be the size of the\n        // previous FLV tag. Use the timestamp of its payload as duration.\n        const int64_t fsize = avio_size(s->pb);\n        avio_seek(s->pb, fsize - 4, SEEK_SET);\n        size = avio_rb32(s->pb);\n        // Seek to the start of the last FLV tag at position (fsize - 4 - size)\n        // but skip the byte indicating the type.\n        avio_seek(s->pb, fsize - 3 - size, SEEK_SET);\n        if (size == avio_rb24(s->pb) + 11) {\n            uint32_t ts = avio_rb24(s->pb);\n            ts         |= avio_r8(s->pb) << 24;\n            s->duration = ts * (int64_t)AV_TIME_BASE / 1000;\n        }\n        avio_seek(s->pb, pos, SEEK_SET);\n        flv->searched_for_end = 1;\n    }\n\n    if (is_audio) {\n        int bits_per_coded_sample;\n        channels = (flags & FLV_AUDIO_CHANNEL_MASK) == FLV_STEREO ? 2 : 1;\n        sample_rate = 44100 << ((flags & FLV_AUDIO_SAMPLERATE_MASK) >>\n                                FLV_AUDIO_SAMPLERATE_OFFSET) >> 3;\n        bits_per_coded_sample = (flags & FLV_AUDIO_SAMPLESIZE_MASK) ? 16 : 8;\n        if (!st->codec->channels || !st->codec->sample_rate ||\n            !st->codec->bits_per_coded_sample) {\n            st->codec->channels              = channels;\n            st->codec->channel_layout        = channels == 1\n                                               ? AV_CH_LAYOUT_MONO\n                                               : AV_CH_LAYOUT_STEREO;\n            st->codec->sample_rate           = sample_rate;\n            st->codec->bits_per_coded_sample = bits_per_coded_sample;\n        }\n        if (!st->codec->codec_id) {\n            flv_set_audio_codec(s, st, st->codec,\n                                flags & FLV_AUDIO_CODECID_MASK);\n            flv->last_sample_rate =\n            sample_rate           = st->codec->sample_rate;\n            flv->last_channels    =\n            channels              = st->codec->channels;\n        } else {\n            AVCodecContext ctx;\n            ctx.sample_rate = sample_rate;\n            ctx.bits_per_coded_sample = bits_per_coded_sample;\n            flv_set_audio_codec(s, st, &ctx, flags & FLV_AUDIO_CODECID_MASK);\n            sample_rate = ctx.sample_rate;\n        }\n    } else {\n        size -= flv_set_video_codec(s, st, flags & FLV_VIDEO_CODECID_MASK, 1);\n    }\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC ||\n        st->codec->codec_id == AV_CODEC_ID_H264) {\n        int type = avio_r8(s->pb);\n        size--;\n        if (st->codec->codec_id == AV_CODEC_ID_H264) {\n            // sign extension\n            int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000;\n            pts = dts + cts;\n            if (cts < 0 && !flv->wrong_dts) { // dts might be wrong\n                flv->wrong_dts = 1;\n                av_log(s, AV_LOG_WARNING,\n                       \"Negative cts, previous timestamps might be wrong.\\n\");\n            }\n        }\n        if (type == 0) {\n            if (st->codec->extradata) {\n                if ((ret = flv_queue_extradata(flv, s->pb, is_audio, size)) < 0)\n                    return ret;\n                ret = AVERROR(EAGAIN);\n                goto leave;\n            }\n            if ((ret = flv_get_extradata(s, st, size)) < 0)\n                return ret;\n            if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n                MPEG4AudioConfig cfg;\n\n                /* Workaround for buggy Omnia A/XE encoder */\n                AVDictionaryEntry *t = av_dict_get(s->metadata, \"Encoder\", NULL, 0);\n                if (t && !strcmp(t->value, \"Omnia A/XE\"))\n                    st->codec->extradata_size = 2;\n\n                avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata,\n                                             st->codec->extradata_size * 8, 1);\n                st->codec->channels       = cfg.channels;\n                st->codec->channel_layout = 0;\n                if (cfg.ext_sample_rate)\n                    st->codec->sample_rate = cfg.ext_sample_rate;\n                else\n                    st->codec->sample_rate = cfg.sample_rate;\n                av_log(s, AV_LOG_TRACE, \"mp4a config channels %d sample rate %d\\n\",\n                        st->codec->channels, st->codec->sample_rate);\n            }\n\n            ret = AVERROR(EAGAIN);\n            goto leave;\n        }\n    }\n\n    /* skip empty data packets */\n    if (!size) {\n        ret = AVERROR(EAGAIN);\n        goto leave;\n    }\n\n    ret = av_get_packet(s->pb, pkt, size);\n    if (ret < 0)\n        return AVERROR(EIO);\n    /* note: we need to modify the packet size here to handle the last\n     * packet */\n    pkt->size         = ret;\n    pkt->dts          = dts;\n    pkt->pts          = pts == AV_NOPTS_VALUE ? dts : pts;\n    pkt->stream_index = st->index;\n    if (flv->new_extradata[is_audio]) {\n        uint8_t *side = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                                flv->new_extradata_size[is_audio]);\n        if (side) {\n            memcpy(side, flv->new_extradata[is_audio],\n                   flv->new_extradata_size[is_audio]);\n            av_freep(&flv->new_extradata[is_audio]);\n            flv->new_extradata_size[is_audio] = 0;\n        }\n    }\n    if (is_audio && (sample_rate != flv->last_sample_rate ||\n                     channels    != flv->last_channels)) {\n        flv->last_sample_rate = sample_rate;\n        flv->last_channels    = channels;\n        ff_add_param_change(pkt, channels, 0, sample_rate, 0, 0);\n    }\n\n    if (is_audio || ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY))\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\nleave:\n    avio_skip(s->pb, 4);\n    return ret;\n}", "patch_func_code": "static int flv_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    FLVContext *flv = s->priv_data;\n    int ret, i, size, flags, is_audio;\n    enum FlvTagType type;\n    int64_t next, pos;\n    int64_t dts, pts = AV_NOPTS_VALUE;\n    int sample_rate = 0, channels = 0;\n    AVStream *st    = NULL;\n\n    /* pkt size is repeated at end. skip it */\n    for (;; avio_skip(s->pb, 4)) {\n        pos  = avio_tell(s->pb);\n        type = avio_r8(s->pb);\n        size = avio_rb24(s->pb);\n        dts  = avio_rb24(s->pb);\n        dts |= avio_r8(s->pb) << 24;\n        av_log(s, AV_LOG_TRACE, \"type:%d, size:%d, dts:%\"PRId64\"\\n\", type, size, dts);\n        if (s->pb->eof_reached)\n            return AVERROR_EOF;\n        avio_skip(s->pb, 3); /* stream id, always 0 */\n        flags = 0;\n\n        if (flv->validate_next < flv->validate_count) {\n            int64_t validate_pos = flv->validate_index[flv->validate_next].pos;\n            if (pos == validate_pos) {\n                if (FFABS(dts - flv->validate_index[flv->validate_next].dts) <=\n                    VALIDATE_INDEX_TS_THRESH) {\n                    flv->validate_next++;\n                } else {\n                    clear_index_entries(s, validate_pos);\n                    flv->validate_count = 0;\n                }\n            } else if (pos > validate_pos) {\n                clear_index_entries(s, validate_pos);\n                flv->validate_count = 0;\n            }\n        }\n\n        if (size == 0)\n            continue;\n\n        next = size + avio_tell(s->pb);\n\n        if (type == FLV_TAG_TYPE_AUDIO) {\n            is_audio = 1;\n            flags    = avio_r8(s->pb);\n            size--;\n        } else if (type == FLV_TAG_TYPE_VIDEO) {\n            is_audio = 0;\n            flags    = avio_r8(s->pb);\n            size--;\n            if ((flags & 0xf0) == 0x50) /* video info / command frame */\n                goto skip;\n        } else {\n            if (type == FLV_TAG_TYPE_META && size > 13 + 1 + 4)\n                if (flv_read_metabody(s, next) > 0) {\n                    return flv_data_packet(s, pkt, dts, next);\n                } else /* skip packet */\n                    av_log(s, AV_LOG_DEBUG,\n                           \"Skipping flv packet: type %d, size %d, flags %d.\\n\",\n                           type, size, flags);\n\nskip:\n            avio_seek(s->pb, next, SEEK_SET);\n            continue;\n        }\n\n        /* skip empty data packets */\n        if (!size)\n            continue;\n\n        /* now find stream */\n        for (i = 0; i < s->nb_streams; i++) {\n            st = s->streams[i];\n            if (is_audio && st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n                if (flv_same_audio_codec(st->codec, flags))\n                    break;\n            } else if (!is_audio &&\n                       st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n                if (flv_same_video_codec(st->codec, flags))\n                    break;\n            }\n        }\n        if (i == s->nb_streams) {\n            st = create_stream(s, is_audio ? AVMEDIA_TYPE_AUDIO\n                                           : AVMEDIA_TYPE_VIDEO);\n            if (!st)\n                return AVERROR(ENOMEM);\n        }\n        av_log(s, AV_LOG_TRACE, \"%d %X %d \\n\", is_audio, flags, st->discard);\n\n        if ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY ||\n            is_audio)\n            av_add_index_entry(st, pos, dts, size, 0, AVINDEX_KEYFRAME);\n\n        if ((st->discard >= AVDISCARD_NONKEY &&\n             !((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY || is_audio)) ||\n            (st->discard >= AVDISCARD_BIDIR &&\n             ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_DISP_INTER && !is_audio)) ||\n            st->discard >= AVDISCARD_ALL) {\n            avio_seek(s->pb, next, SEEK_SET);\n            continue;\n        }\n        break;\n    }\n\n    // if not streamed and no duration from metadata then seek to end to find\n    // the duration from the timestamps\n    if (s->pb->seekable && (!s->duration || s->duration == AV_NOPTS_VALUE) &&\n        !flv->searched_for_end) {\n        int size;\n        const int64_t pos   = avio_tell(s->pb);\n        // Read the last 4 bytes of the file, this should be the size of the\n        // previous FLV tag. Use the timestamp of its payload as duration.\n        const int64_t fsize = avio_size(s->pb);\n        avio_seek(s->pb, fsize - 4, SEEK_SET);\n        size = avio_rb32(s->pb);\n        if (size > 0 && size < fsize) {\n            // Seek to the start of the last FLV tag at position (fsize - 4 - size)\n            // but skip the byte indicating the type.\n            avio_seek(s->pb, fsize - 3 - size, SEEK_SET);\n            if (size == avio_rb24(s->pb) + 11) {\n                uint32_t ts = avio_rb24(s->pb);\n                ts         |= avio_r8(s->pb) << 24;\n                s->duration = ts * (int64_t)AV_TIME_BASE / 1000;\n            }\n        }\n        avio_seek(s->pb, pos, SEEK_SET);\n        flv->searched_for_end = 1;\n    }\n\n    if (is_audio) {\n        int bits_per_coded_sample;\n        channels = (flags & FLV_AUDIO_CHANNEL_MASK) == FLV_STEREO ? 2 : 1;\n        sample_rate = 44100 << ((flags & FLV_AUDIO_SAMPLERATE_MASK) >>\n                                FLV_AUDIO_SAMPLERATE_OFFSET) >> 3;\n        bits_per_coded_sample = (flags & FLV_AUDIO_SAMPLESIZE_MASK) ? 16 : 8;\n        if (!st->codec->channels || !st->codec->sample_rate ||\n            !st->codec->bits_per_coded_sample) {\n            st->codec->channels              = channels;\n            st->codec->channel_layout        = channels == 1\n                                               ? AV_CH_LAYOUT_MONO\n                                               : AV_CH_LAYOUT_STEREO;\n            st->codec->sample_rate           = sample_rate;\n            st->codec->bits_per_coded_sample = bits_per_coded_sample;\n        }\n        if (!st->codec->codec_id) {\n            flv_set_audio_codec(s, st, st->codec,\n                                flags & FLV_AUDIO_CODECID_MASK);\n            flv->last_sample_rate =\n            sample_rate           = st->codec->sample_rate;\n            flv->last_channels    =\n            channels              = st->codec->channels;\n        } else {\n            AVCodecContext ctx;\n            ctx.sample_rate = sample_rate;\n            ctx.bits_per_coded_sample = bits_per_coded_sample;\n            flv_set_audio_codec(s, st, &ctx, flags & FLV_AUDIO_CODECID_MASK);\n            sample_rate = ctx.sample_rate;\n        }\n    } else {\n        size -= flv_set_video_codec(s, st, flags & FLV_VIDEO_CODECID_MASK, 1);\n    }\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC ||\n        st->codec->codec_id == AV_CODEC_ID_H264) {\n        int type = avio_r8(s->pb);\n        size--;\n        if (st->codec->codec_id == AV_CODEC_ID_H264) {\n            // sign extension\n            int32_t cts = (avio_rb24(s->pb) + 0xff800000) ^ 0xff800000;\n            pts = dts + cts;\n            if (cts < 0 && !flv->wrong_dts) { // dts might be wrong\n                flv->wrong_dts = 1;\n                av_log(s, AV_LOG_WARNING,\n                       \"Negative cts, previous timestamps might be wrong.\\n\");\n            }\n        }\n        if (type == 0) {\n            if (st->codec->extradata) {\n                if ((ret = flv_queue_extradata(flv, s->pb, is_audio, size)) < 0)\n                    return ret;\n                ret = AVERROR(EAGAIN);\n                goto leave;\n            }\n            if ((ret = flv_get_extradata(s, st, size)) < 0)\n                return ret;\n            if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n                MPEG4AudioConfig cfg;\n\n                /* Workaround for buggy Omnia A/XE encoder */\n                AVDictionaryEntry *t = av_dict_get(s->metadata, \"Encoder\", NULL, 0);\n                if (t && !strcmp(t->value, \"Omnia A/XE\"))\n                    st->codec->extradata_size = 2;\n\n                avpriv_mpeg4audio_get_config(&cfg, st->codec->extradata,\n                                             st->codec->extradata_size * 8, 1);\n                st->codec->channels       = cfg.channels;\n                st->codec->channel_layout = 0;\n                if (cfg.ext_sample_rate)\n                    st->codec->sample_rate = cfg.ext_sample_rate;\n                else\n                    st->codec->sample_rate = cfg.sample_rate;\n                av_log(s, AV_LOG_TRACE, \"mp4a config channels %d sample rate %d\\n\",\n                        st->codec->channels, st->codec->sample_rate);\n            }\n\n            ret = AVERROR(EAGAIN);\n            goto leave;\n        }\n    }\n\n    /* skip empty data packets */\n    if (!size) {\n        ret = AVERROR(EAGAIN);\n        goto leave;\n    }\n\n    ret = av_get_packet(s->pb, pkt, size);\n    if (ret < 0)\n        return AVERROR(EIO);\n    /* note: we need to modify the packet size here to handle the last\n     * packet */\n    pkt->size         = ret;\n    pkt->dts          = dts;\n    pkt->pts          = pts == AV_NOPTS_VALUE ? dts : pts;\n    pkt->stream_index = st->index;\n    if (flv->new_extradata[is_audio]) {\n        uint8_t *side = av_packet_new_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA,\n                                                flv->new_extradata_size[is_audio]);\n        if (side) {\n            memcpy(side, flv->new_extradata[is_audio],\n                   flv->new_extradata_size[is_audio]);\n            av_freep(&flv->new_extradata[is_audio]);\n            flv->new_extradata_size[is_audio] = 0;\n        }\n    }\n    if (is_audio && (sample_rate != flv->last_sample_rate ||\n                     channels    != flv->last_channels)) {\n        flv->last_sample_rate = sample_rate;\n        flv->last_channels    = channels;\n        ff_add_param_change(pkt, channels, 0, sample_rate, 0, 0);\n    }\n\n    if (is_audio || ((flags & FLV_VIDEO_FRAMETYPE_MASK) == FLV_FRAME_KEY))\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\nleave:\n    avio_skip(s->pb, 4);\n    return ret;\n}", "before_change_lines": [121, 122, 123, 124, 125], "raw_before_change_lines": [119, 120, 121, 122, 123, 124, 125], "after_change_lines": [119, 122, 123, 124, 125, 126, 127], "raw_after_change_lines": [119, 120, 121, 122, 123, 124, 125, 126, 127], "bug_lines": [119, 120, 121, 122, 123, 124, 125], "added": [false, false, false, false, false, false, false], "idx": 296}
{"project": "libav", "vul_type": "DEAD_STORE", "filepath_func": "8365----DEAD_STORE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_cbe0ae4aa54c7e31f4d9333314105b7e0ae4b2cc_1.json----encode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_cbe0ae4aa54c7e31f4d9333314105b7e0ae4b2cc_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_cbe0ae4aa54c7e31f4d9333314105b7e0ae4b2cc_1.json", "function_name": "encode_frame", "vul_func_code": "static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n                        const AVFrame *pic, int *got_packet)\n{\n    ProresContext *ctx = avctx->priv_data;\n    uint8_t *orig_buf, *buf, *slice_hdr, *slice_sizes, *tmp;\n    uint8_t *picture_size_pos;\n    PutBitContext pb;\n    int x, y, i, mb, q = 0;\n    int sizes[4] = { 0 };\n    int slice_hdr_size = 2 + 2 * (ctx->num_planes - 1);\n    int frame_size, picture_size, slice_size;\n    int mbs_per_slice = ctx->mbs_per_slice;\n    int pkt_size, ret;\n\n    *avctx->coded_frame           = *pic;\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n    avctx->coded_frame->key_frame = 1;\n\n    pkt_size = ctx->frame_size + FF_MIN_BUFFER_SIZE;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n        return ret;\n    }\n\n    orig_buf = pkt->data;\n\n    // frame atom\n    orig_buf += 4;                              // frame size\n    bytestream_put_be32  (&orig_buf, FRAME_ID); // frame container ID\n    buf = orig_buf;\n\n    // frame header\n    tmp = buf;\n    buf += 2;                                   // frame header size will be stored here\n    bytestream_put_be16  (&buf, 0);             // version 1\n    bytestream_put_buffer(&buf, ctx->vendor, 4);\n    bytestream_put_be16  (&buf, avctx->width);\n    bytestream_put_be16  (&buf, avctx->height);\n    bytestream_put_byte  (&buf, ctx->chroma_factor << 6); // frame flags\n    bytestream_put_byte  (&buf, 0);             // reserved\n    bytestream_put_byte  (&buf, avctx->color_primaries);\n    bytestream_put_byte  (&buf, avctx->color_trc);\n    bytestream_put_byte  (&buf, avctx->colorspace);\n    bytestream_put_byte  (&buf, 0x40);          // source format and alpha information\n    bytestream_put_byte  (&buf, 0);             // reserved\n    if (ctx->quant_sel != QUANT_MAT_DEFAULT) {\n        bytestream_put_byte  (&buf, 0x03);      // matrix flags - both matrices are present\n        // luma quantisation matrix\n        for (i = 0; i < 64; i++)\n            bytestream_put_byte(&buf, ctx->quant_mat[i]);\n        // chroma quantisation matrix\n        for (i = 0; i < 64; i++)\n            bytestream_put_byte(&buf, ctx->quant_mat[i]);\n    } else {\n        bytestream_put_byte  (&buf, 0x00);      // matrix flags - default matrices are used\n    }\n    bytestream_put_be16  (&tmp, buf - orig_buf); // write back frame header size\n\n    // picture header\n    picture_size_pos = buf + 1;\n    bytestream_put_byte  (&buf, 0x40);          // picture header size (in bits)\n    buf += 4;                                   // picture data size will be stored here\n    bytestream_put_be16  (&buf, ctx->num_slices); // total number of slices\n    bytestream_put_byte  (&buf, av_log2(ctx->mbs_per_slice) << 4); // slice width and height in MBs\n\n    // seek table - will be filled during slice encoding\n    slice_sizes = buf;\n    buf += ctx->num_slices * 2;\n\n    // slices\n    if (!ctx->force_quant) {\n        ret = avctx->execute2(avctx, find_quant_thread, NULL, NULL,\n                              ctx->mb_height);\n        if (ret)\n            return ret;\n    }\n\n    for (y = 0; y < ctx->mb_height; y++) {\n        mbs_per_slice = ctx->mbs_per_slice;\n        for (x = mb = 0; x < ctx->mb_width; x += mbs_per_slice, mb++) {\n            q = ctx->force_quant ? ctx->force_quant\n                                 : ctx->slice_q[mb + y * ctx->slices_width];\n\n            while (ctx->mb_width - x < mbs_per_slice)\n                mbs_per_slice >>= 1;\n\n            bytestream_put_byte(&buf, slice_hdr_size << 3);\n            slice_hdr = buf;\n            buf += slice_hdr_size - 1;\n            init_put_bits(&pb, buf, (pkt_size - (buf - orig_buf)) * 8);\n            encode_slice(avctx, pic, &pb, sizes, x, y, q, mbs_per_slice);\n\n            bytestream_put_byte(&slice_hdr, q);\n            slice_size = slice_hdr_size + sizes[ctx->num_planes - 1];\n            for (i = 0; i < ctx->num_planes - 1; i++) {\n                bytestream_put_be16(&slice_hdr, sizes[i]);\n                slice_size += sizes[i];\n            }\n            bytestream_put_be16(&slice_sizes, slice_size);\n            buf += slice_size - slice_hdr_size;\n        }\n    }\n\n    orig_buf -= 8;\n    frame_size = buf - orig_buf;\n    picture_size = buf - picture_size_pos - 6;\n    bytestream_put_be32(&orig_buf, frame_size);\n    bytestream_put_be32(&picture_size_pos, picture_size);\n\n    pkt->size   = frame_size;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    *got_packet = 1;\n\n    return 0;\n}", "patch_func_code": "static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n                        const AVFrame *pic, int *got_packet)\n{\n    ProresContext *ctx = avctx->priv_data;\n    uint8_t *orig_buf, *buf, *slice_hdr, *slice_sizes, *tmp;\n    uint8_t *picture_size_pos;\n    PutBitContext pb;\n    int x, y, i, mb, q = 0;\n    int sizes[4] = { 0 };\n    int slice_hdr_size = 2 + 2 * (ctx->num_planes - 1);\n    int frame_size, picture_size, slice_size;\n    int pkt_size, ret;\n\n    *avctx->coded_frame           = *pic;\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n    avctx->coded_frame->key_frame = 1;\n\n    pkt_size = ctx->frame_size + FF_MIN_BUFFER_SIZE;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet.\\n\");\n        return ret;\n    }\n\n    orig_buf = pkt->data;\n\n    // frame atom\n    orig_buf += 4;                              // frame size\n    bytestream_put_be32  (&orig_buf, FRAME_ID); // frame container ID\n    buf = orig_buf;\n\n    // frame header\n    tmp = buf;\n    buf += 2;                                   // frame header size will be stored here\n    bytestream_put_be16  (&buf, 0);             // version 1\n    bytestream_put_buffer(&buf, ctx->vendor, 4);\n    bytestream_put_be16  (&buf, avctx->width);\n    bytestream_put_be16  (&buf, avctx->height);\n    bytestream_put_byte  (&buf, ctx->chroma_factor << 6); // frame flags\n    bytestream_put_byte  (&buf, 0);             // reserved\n    bytestream_put_byte  (&buf, avctx->color_primaries);\n    bytestream_put_byte  (&buf, avctx->color_trc);\n    bytestream_put_byte  (&buf, avctx->colorspace);\n    bytestream_put_byte  (&buf, 0x40);          // source format and alpha information\n    bytestream_put_byte  (&buf, 0);             // reserved\n    if (ctx->quant_sel != QUANT_MAT_DEFAULT) {\n        bytestream_put_byte  (&buf, 0x03);      // matrix flags - both matrices are present\n        // luma quantisation matrix\n        for (i = 0; i < 64; i++)\n            bytestream_put_byte(&buf, ctx->quant_mat[i]);\n        // chroma quantisation matrix\n        for (i = 0; i < 64; i++)\n            bytestream_put_byte(&buf, ctx->quant_mat[i]);\n    } else {\n        bytestream_put_byte  (&buf, 0x00);      // matrix flags - default matrices are used\n    }\n    bytestream_put_be16  (&tmp, buf - orig_buf); // write back frame header size\n\n    // picture header\n    picture_size_pos = buf + 1;\n    bytestream_put_byte  (&buf, 0x40);          // picture header size (in bits)\n    buf += 4;                                   // picture data size will be stored here\n    bytestream_put_be16  (&buf, ctx->num_slices); // total number of slices\n    bytestream_put_byte  (&buf, av_log2(ctx->mbs_per_slice) << 4); // slice width and height in MBs\n\n    // seek table - will be filled during slice encoding\n    slice_sizes = buf;\n    buf += ctx->num_slices * 2;\n\n    // slices\n    if (!ctx->force_quant) {\n        ret = avctx->execute2(avctx, find_quant_thread, NULL, NULL,\n                              ctx->mb_height);\n        if (ret)\n            return ret;\n    }\n\n    for (y = 0; y < ctx->mb_height; y++) {\n        int mbs_per_slice = ctx->mbs_per_slice;\n        for (x = mb = 0; x < ctx->mb_width; x += mbs_per_slice, mb++) {\n            q = ctx->force_quant ? ctx->force_quant\n                                 : ctx->slice_q[mb + y * ctx->slices_width];\n\n            while (ctx->mb_width - x < mbs_per_slice)\n                mbs_per_slice >>= 1;\n\n            bytestream_put_byte(&buf, slice_hdr_size << 3);\n            slice_hdr = buf;\n            buf += slice_hdr_size - 1;\n            init_put_bits(&pb, buf, (pkt_size - (buf - orig_buf)) * 8);\n            encode_slice(avctx, pic, &pb, sizes, x, y, q, mbs_per_slice);\n\n            bytestream_put_byte(&slice_hdr, q);\n            slice_size = slice_hdr_size + sizes[ctx->num_planes - 1];\n            for (i = 0; i < ctx->num_planes - 1; i++) {\n                bytestream_put_be16(&slice_hdr, sizes[i]);\n                slice_size += sizes[i];\n            }\n            bytestream_put_be16(&slice_sizes, slice_size);\n            buf += slice_size - slice_hdr_size;\n        }\n    }\n\n    orig_buf -= 8;\n    frame_size = buf - orig_buf;\n    picture_size = buf - picture_size_pos - 6;\n    bytestream_put_be32(&orig_buf, frame_size);\n    bytestream_put_be32(&picture_size_pos, picture_size);\n\n    pkt->size   = frame_size;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    *got_packet = 1;\n\n    return 0;\n}", "before_change_lines": [12, 80], "raw_before_change_lines": [12, 80], "after_change_lines": [79], "raw_after_change_lines": [79], "bug_lines": [12, 80], "added": [false, false], "idx": 297}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "8370----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_cc1f713311284c17845bca5d5214980c5a404d20_1.json----av_get_image_linesize", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_cc1f713311284c17845bca5d5214980c5a404d20_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_cc1f713311284c17845bca5d5214980c5a404d20_1.json", "function_name": "av_get_image_linesize", "vul_func_code": "int av_get_image_linesize(enum PixelFormat pix_fmt, int width, int plane)\n{\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n    int s;\n\n    if (desc->flags & PIX_FMT_BITSTREAM)\n        return (width * (desc->comp[0].step_minus1+1) + 7) >> 3;\n\n    av_fill_image_max_pixstep(max_step, max_step_comp, desc);\n    s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0;\n    return max_step[plane] * (((width + (1 << s) - 1)) >> s);\n}", "patch_func_code": "int av_get_image_linesize(enum PixelFormat pix_fmt, int width, int plane)\n{\n    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];\n    int max_step     [4];       /* max pixel step for each plane */\n    int max_step_comp[4];       /* the component for each plane which has the max pixel step */\n    int s;\n\n    if (desc->flags & PIX_FMT_BITSTREAM)\n        return (width * (desc->comp[0].step_minus1+1) + 7) >> 3;\n\n    av_fill_image_max_pixsteps(max_step, max_step_comp, desc);\n    s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0;\n    return max_step[plane] * (((width + (1 << s) - 1)) >> s);\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [11], "added": [false], "idx": 298}
{"project": "libav", "vul_type": "INFERBO_ALLOC_MAY_BE_BIG", "filepath_func": "8501----INFERBO_ALLOC_MAY_BE_BIG----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d43bbcb985df21168006246469e8e49549944630_1.json----decode_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_d43bbcb985df21168006246469e8e49549944630_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d43bbcb985df21168006246469e8e49549944630_1.json", "function_name": "decode_frame", "vul_func_code": "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    VmncContext * const c = avctx->priv_data;\n    GetByteContext *gb = &c->gb;\n    uint8_t *outptr;\n    int dx, dy, w, h, depth, enc, chunks, res, size_left, ret;\n\n    if ((ret = ff_reget_buffer(avctx, &c->pic)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n        return ret;\n    }\n\n    bytestream2_init(gb, buf, buf_size);\n\n    c->pic.key_frame = 0;\n    c->pic.pict_type = AV_PICTURE_TYPE_P;\n\n    // restore screen after cursor\n    if (c->screendta) {\n        int i;\n        w = c->cur_w;\n        if (c->width < c->cur_x + w)\n            w = c->width - c->cur_x;\n        h = c->cur_h;\n        if (c->height < c->cur_y + h)\n            h = c->height - c->cur_y;\n        dx = c->cur_x;\n        if (dx < 0) {\n            w += dx;\n            dx = 0;\n        }\n        dy = c->cur_y;\n        if (dy < 0) {\n            h += dy;\n            dy = 0;\n        }\n        if ((w > 0) && (h > 0)) {\n            outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0];\n            for (i = 0; i < h; i++) {\n                memcpy(outptr, c->screendta + i * c->cur_w * c->bpp2,\n                       w * c->bpp2);\n                outptr += c->pic.linesize[0];\n            }\n        }\n    }\n    bytestream2_skip(gb, 2);\n    chunks = bytestream2_get_be16(gb);\n    while (chunks--) {\n        dx  = bytestream2_get_be16(gb);\n        dy  = bytestream2_get_be16(gb);\n        w   = bytestream2_get_be16(gb);\n        h   = bytestream2_get_be16(gb);\n        enc = bytestream2_get_be32(gb);\n        outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0];\n        size_left = bytestream2_get_bytes_left(gb);\n        switch (enc) {\n        case MAGIC_WMVd: // cursor\n            if (size_left < 2 + w * h * c->bpp2 * 2) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Premature end of data! (need %i got %i)\\n\",\n                       2 + w * h * c->bpp2 * 2, size_left);\n                return -1;\n            }\n            bytestream2_skip(gb, 2);\n            c->cur_w  = w;\n            c->cur_h  = h;\n            c->cur_hx = dx;\n            c->cur_hy = dy;\n            if ((c->cur_hx > c->cur_w) || (c->cur_hy > c->cur_h)) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Cursor hot spot is not in image: \"\n                       \"%ix%i of %ix%i cursor size\\n\",\n                       c->cur_hx, c->cur_hy, c->cur_w, c->cur_h);\n                c->cur_hx = c->cur_hy = 0;\n            }\n            c->curbits   = av_realloc(c->curbits,   c->cur_w * c->cur_h * c->bpp2);\n            c->curmask   = av_realloc(c->curmask,   c->cur_w * c->cur_h * c->bpp2);\n            c->screendta = av_realloc(c->screendta, c->cur_w * c->cur_h * c->bpp2);\n            load_cursor(c);\n            break;\n        case MAGIC_WMVe: // unknown\n            bytestream2_skip(gb, 2);\n            break;\n        case MAGIC_WMVf: // update cursor position\n            c->cur_x = dx - c->cur_hx;\n            c->cur_y = dy - c->cur_hy;\n            break;\n        case MAGIC_WMVg: // unknown\n            bytestream2_skip(gb, 10);\n            break;\n        case MAGIC_WMVh: // unknown\n            bytestream2_skip(gb, 4);\n            break;\n        case MAGIC_WMVi: // ServerInitialization struct\n            c->pic.key_frame = 1;\n            c->pic.pict_type = AV_PICTURE_TYPE_I;\n            depth = bytestream2_get_byte(gb);\n            if (depth != c->bpp) {\n                av_log(avctx, AV_LOG_INFO,\n                       \"Depth mismatch. Container %i bpp, \"\n                       \"Frame data: %i bpp\\n\",\n                       c->bpp, depth);\n            }\n            bytestream2_skip(gb, 1);\n            c->bigendian = bytestream2_get_byte(gb);\n            if (c->bigendian & (~1)) {\n                av_log(avctx, AV_LOG_INFO,\n                       \"Invalid header: bigendian flag = %i\\n\", c->bigendian);\n                return -1;\n            }\n            //skip the rest of pixel format data\n            bytestream2_skip(gb, 13);\n            break;\n        case MAGIC_WMVj: // unknown\n            bytestream2_skip(gb, 2);\n            break;\n        case 0x00000000: // raw rectangle data\n            if ((dx + w > c->width) || (dy + h > c->height)) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Incorrect frame size: %ix%i+%ix%i of %ix%i\\n\",\n                       w, h, dx, dy, c->width, c->height);\n                return -1;\n            }\n            if (size_left < w * h * c->bpp2) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Premature end of data! (need %i got %i)\\n\",\n                       w * h * c->bpp2, size_left);\n                return -1;\n            }\n            paint_raw(outptr, w, h, gb, c->bpp2, c->bigendian,\n                      c->pic.linesize[0]);\n            break;\n        case 0x00000005: // HexTile encoded rectangle\n            if ((dx + w > c->width) || (dy + h > c->height)) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Incorrect frame size: %ix%i+%ix%i of %ix%i\\n\",\n                       w, h, dx, dy, c->width, c->height);\n                return -1;\n            }\n            res = decode_hextile(c, outptr, gb, w, h, c->pic.linesize[0]);\n            if (res < 0)\n                return -1;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported block type 0x%08X\\n\", enc);\n            chunks = 0; // leave chunks decoding loop\n        }\n    }\n    if (c->screendta) {\n        int i;\n        // save screen data before painting cursor\n        w = c->cur_w;\n        if (c->width < c->cur_x + w)\n            w = c->width - c->cur_x;\n        h = c->cur_h;\n        if (c->height < c->cur_y + h)\n            h = c->height - c->cur_y;\n        dx = c->cur_x;\n        if (dx < 0) {\n            w += dx;\n            dx = 0;\n        }\n        dy = c->cur_y;\n        if (dy < 0) {\n            h += dy;\n            dy = 0;\n        }\n        if ((w > 0) && (h > 0)) {\n            outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0];\n            for (i = 0; i < h; i++) {\n                memcpy(c->screendta + i * c->cur_w * c->bpp2, outptr,\n                       w * c->bpp2);\n                outptr += c->pic.linesize[0];\n            }\n            outptr = c->pic.data[0];\n            put_cursor(outptr, c->pic.linesize[0], c, c->cur_x, c->cur_y);\n        }\n    }\n    *got_frame = 1;\n    if ((ret = av_frame_ref(data, &c->pic)) < 0)\n        return ret;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}", "patch_func_code": "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    VmncContext * const c = avctx->priv_data;\n    GetByteContext *gb = &c->gb;\n    uint8_t *outptr;\n    int dx, dy, w, h, depth, enc, chunks, res, size_left, ret;\n\n    if ((ret = ff_reget_buffer(avctx, &c->pic)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n        return ret;\n    }\n\n    bytestream2_init(gb, buf, buf_size);\n\n    c->pic.key_frame = 0;\n    c->pic.pict_type = AV_PICTURE_TYPE_P;\n\n    // restore screen after cursor\n    if (c->screendta) {\n        int i;\n        w = c->cur_w;\n        if (c->width < c->cur_x + w)\n            w = c->width - c->cur_x;\n        h = c->cur_h;\n        if (c->height < c->cur_y + h)\n            h = c->height - c->cur_y;\n        dx = c->cur_x;\n        if (dx < 0) {\n            w += dx;\n            dx = 0;\n        }\n        dy = c->cur_y;\n        if (dy < 0) {\n            h += dy;\n            dy = 0;\n        }\n        if ((w > 0) && (h > 0)) {\n            outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0];\n            for (i = 0; i < h; i++) {\n                memcpy(outptr, c->screendta + i * c->cur_w * c->bpp2,\n                       w * c->bpp2);\n                outptr += c->pic.linesize[0];\n            }\n        }\n    }\n    bytestream2_skip(gb, 2);\n    chunks = bytestream2_get_be16(gb);\n    while (chunks--) {\n        dx  = bytestream2_get_be16(gb);\n        dy  = bytestream2_get_be16(gb);\n        w   = bytestream2_get_be16(gb);\n        h   = bytestream2_get_be16(gb);\n        enc = bytestream2_get_be32(gb);\n        outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0];\n        size_left = bytestream2_get_bytes_left(gb);\n        switch (enc) {\n        case MAGIC_WMVd: // cursor\n            if (size_left < 2 + w * h * c->bpp2 * 2) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Premature end of data! (need %i got %i)\\n\",\n                       2 + w * h * c->bpp2 * 2, size_left);\n                return -1;\n            }\n            bytestream2_skip(gb, 2);\n            c->cur_w  = w;\n            c->cur_h  = h;\n            c->cur_hx = dx;\n            c->cur_hy = dy;\n            if ((c->cur_hx > c->cur_w) || (c->cur_hy > c->cur_h)) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Cursor hot spot is not in image: \"\n                       \"%ix%i of %ix%i cursor size\\n\",\n                       c->cur_hx, c->cur_hy, c->cur_w, c->cur_h);\n                c->cur_hx = c->cur_hy = 0;\n            }\n            if (c->cur_w * c->cur_h >= INT_MAX / c->bpp2) {\n                reset_buffers(c);\n                return AVERROR(EINVAL);\n            } else {\n                int screen_size = c->cur_w * c->cur_h * c->bpp2;\n                if ((ret = av_reallocp(&c->curbits, screen_size)) < 0 ||\n                    (ret = av_reallocp(&c->curmask, screen_size)) < 0 ||\n                    (ret = av_reallocp(&c->screendta, screen_size)) < 0) {\n                    reset_buffers(c);\n                    return ret;\n                }\n            }\n            load_cursor(c);\n            break;\n        case MAGIC_WMVe: // unknown\n            bytestream2_skip(gb, 2);\n            break;\n        case MAGIC_WMVf: // update cursor position\n            c->cur_x = dx - c->cur_hx;\n            c->cur_y = dy - c->cur_hy;\n            break;\n        case MAGIC_WMVg: // unknown\n            bytestream2_skip(gb, 10);\n            break;\n        case MAGIC_WMVh: // unknown\n            bytestream2_skip(gb, 4);\n            break;\n        case MAGIC_WMVi: // ServerInitialization struct\n            c->pic.key_frame = 1;\n            c->pic.pict_type = AV_PICTURE_TYPE_I;\n            depth = bytestream2_get_byte(gb);\n            if (depth != c->bpp) {\n                av_log(avctx, AV_LOG_INFO,\n                       \"Depth mismatch. Container %i bpp, \"\n                       \"Frame data: %i bpp\\n\",\n                       c->bpp, depth);\n            }\n            bytestream2_skip(gb, 1);\n            c->bigendian = bytestream2_get_byte(gb);\n            if (c->bigendian & (~1)) {\n                av_log(avctx, AV_LOG_INFO,\n                       \"Invalid header: bigendian flag = %i\\n\", c->bigendian);\n                return -1;\n            }\n            //skip the rest of pixel format data\n            bytestream2_skip(gb, 13);\n            break;\n        case MAGIC_WMVj: // unknown\n            bytestream2_skip(gb, 2);\n            break;\n        case 0x00000000: // raw rectangle data\n            if ((dx + w > c->width) || (dy + h > c->height)) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Incorrect frame size: %ix%i+%ix%i of %ix%i\\n\",\n                       w, h, dx, dy, c->width, c->height);\n                return -1;\n            }\n            if (size_left < w * h * c->bpp2) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Premature end of data! (need %i got %i)\\n\",\n                       w * h * c->bpp2, size_left);\n                return -1;\n            }\n            paint_raw(outptr, w, h, gb, c->bpp2, c->bigendian,\n                      c->pic.linesize[0]);\n            break;\n        case 0x00000005: // HexTile encoded rectangle\n            if ((dx + w > c->width) || (dy + h > c->height)) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Incorrect frame size: %ix%i+%ix%i of %ix%i\\n\",\n                       w, h, dx, dy, c->width, c->height);\n                return -1;\n            }\n            res = decode_hextile(c, outptr, gb, w, h, c->pic.linesize[0]);\n            if (res < 0)\n                return -1;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported block type 0x%08X\\n\", enc);\n            chunks = 0; // leave chunks decoding loop\n        }\n    }\n    if (c->screendta) {\n        int i;\n        // save screen data before painting cursor\n        w = c->cur_w;\n        if (c->width < c->cur_x + w)\n            w = c->width - c->cur_x;\n        h = c->cur_h;\n        if (c->height < c->cur_y + h)\n            h = c->height - c->cur_y;\n        dx = c->cur_x;\n        if (dx < 0) {\n            w += dx;\n            dx = 0;\n        }\n        dy = c->cur_y;\n        if (dy < 0) {\n            h += dy;\n            dy = 0;\n        }\n        if ((w > 0) && (h > 0)) {\n            outptr = c->pic.data[0] + dx * c->bpp2 + dy * c->pic.linesize[0];\n            for (i = 0; i < h; i++) {\n                memcpy(c->screendta + i * c->cur_w * c->bpp2, outptr,\n                       w * c->bpp2);\n                outptr += c->pic.linesize[0];\n            }\n            outptr = c->pic.data[0];\n            put_cursor(outptr, c->pic.linesize[0], c, c->cur_x, c->cur_y);\n        }\n    }\n    *got_frame = 1;\n    if ((ret = av_frame_ref(data, &c->pic)) < 0)\n        return ret;\n\n    /* always report that the buffer was completely consumed */\n    return buf_size;\n}", "before_change_lines": [79, 80, 81], "raw_before_change_lines": [79, 80, 81], "after_change_lines": [79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], "raw_after_change_lines": [79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], "bug_lines": [79, 80, 81], "added": [false, false, false], "idx": 299}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "8605----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d8baca8c57eeca5cce4c5929ac81c2c02cd84fea_1.json----pred_temp_direct_motion", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_d8baca8c57eeca5cce4c5929ac81c2c02cd84fea_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d8baca8c57eeca5cce4c5929ac81c2c02cd84fea_1.json", "function_name": "pred_temp_direct_motion", "vul_func_code": "static void pred_temp_direct_motion(const H264Context *const h, H264SliceContext *sl,\n                                    int *mb_type)\n{\n    int b8_stride = 2;\n    int b4_stride = h->b_stride;\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n    int mb_type_col[2];\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n    const int8_t *l1ref0, *l1ref1;\n    const int is_b8x8 = IS_8X8(*mb_type);\n    unsigned int sub_mb_type;\n    int i8, i4;\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n            mb_xy = sl->mb_x +\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n            b8_stride = 0;\n        } else {\n            mb_y  += sl->col_fieldoff;\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n        }\n        goto single_col;\n    } else {                                        // AFL/AFR/FR/FL -> AFR/FR\n        if (IS_INTERLACED(*mb_type)) {              // AFL       /FL -> AFR/FR\n            mb_y           = sl->mb_y & ~1;\n            mb_xy          = sl->mb_x + (sl->mb_y & ~1) * h->mb_stride;\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n            b8_stride      = 2 + 4 * h->mb_stride;\n            b4_stride     *= 6;\n            if (IS_INTERLACED(mb_type_col[0]) !=\n                IS_INTERLACED(mb_type_col[1])) {\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n            }\n\n            sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                          MB_TYPE_DIRECT2;                  /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n                !is_b8x8) {\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_L0L1 |\n                            MB_TYPE_DIRECT2;                /* B_16x8 */\n            } else {\n                *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1;\n            }\n        } else {                                    //     AFR/FR    -> AFR/FR\nsingle_col:\n            mb_type_col[0]     =\n                mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                          MB_TYPE_DIRECT2;                  /* B_SUB_8x8 */\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                            MB_TYPE_DIRECT2;                /* B_16x16 */\n            } else if (!is_b8x8 &&\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n                *mb_type |= MB_TYPE_L0L1 | MB_TYPE_DIRECT2 |\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n            } else {\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n                    /* FIXME: save sub mb types from previous frames (or derive\n                     * from MVs) so we know exactly what block size to use */\n                    sub_mb_type = MB_TYPE_8x8 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                                  MB_TYPE_DIRECT2;          /* B_SUB_4x4 */\n                }\n                *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1;\n            }\n        }\n    }\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n    if (!b8_stride) {\n        if (sl->mb_y & 1) {\n            l1ref0 += 2;\n            l1ref1 += 2;\n            l1mv0  += 2 * b4_stride;\n            l1mv1  += 2 * b4_stride;\n        }\n    }\n\n    {\n        const int *map_col_to_list0[2] = { sl->map_col_to_list0[0],\n                                           sl->map_col_to_list0[1] };\n        const int *dist_scale_factor = sl->dist_scale_factor;\n        int ref_offset;\n\n        if (FRAME_MBAFF(h) && IS_INTERLACED(*mb_type)) {\n            map_col_to_list0[0] = sl->map_col_to_list0_field[sl->mb_y & 1][0];\n            map_col_to_list0[1] = sl->map_col_to_list0_field[sl->mb_y & 1][1];\n            dist_scale_factor   = sl->dist_scale_factor_field[sl->mb_y & 1];\n        }\n        ref_offset = (sl->ref_list[1][0].parent->mbaff << 4) & (mb_type_col[0] >> 3);\n\n        if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n            int y_shift = 2 * !IS_INTERLACED(*mb_type);\n            assert(h->ps.sps->direct_8x8_inference_flag);\n\n            for (i8 = 0; i8 < 4; i8++) {\n                const int x8 = i8 & 1;\n                const int y8 = i8 >> 1;\n                int ref0, scale;\n                const int16_t (*l1mv)[2] = l1mv0;\n\n                if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n                    continue;\n                sl->sub_mb_type[i8] = sub_mb_type;\n\n                fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                if (IS_INTRA(mb_type_col[y8])) {\n                    fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    continue;\n                }\n\n                ref0 = l1ref0[x8 + y8 * b8_stride];\n                if (ref0 >= 0)\n                    ref0 = map_col_to_list0[0][ref0 + ref_offset];\n                else {\n                    ref0 = map_col_to_list0[1][l1ref1[x8 + y8 * b8_stride] +\n                                               ref_offset];\n                    l1mv = l1mv1;\n                }\n                scale = dist_scale_factor[ref0];\n                fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                               ref0, 1);\n\n                {\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * b4_stride];\n                    int my_col            = (mv_col[1] << y_shift) / 2;\n                    int mx                = (scale * mv_col[0] + 128) >> 8;\n                    int my                = (scale * my_col    + 128) >> 8;\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx, my), 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx - mv_col[0], my - my_col), 4);\n                }\n            }\n            return;\n        }\n\n        /* one-to-one mv scaling */\n\n        if (IS_16X16(*mb_type)) {\n            int ref, mv0, mv1;\n\n            fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n            if (IS_INTRA(mb_type_col[0])) {\n                ref = mv0 = mv1 = 0;\n            } else {\n                const int ref0 = l1ref0[0] >= 0 ? map_col_to_list0[0][l1ref0[0] + ref_offset]\n                                                : map_col_to_list0[1][l1ref1[0] + ref_offset];\n                const int scale = dist_scale_factor[ref0];\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n                int mv_l0[2];\n                mv_l0[0] = (scale * mv_col[0] + 128) >> 8;\n                mv_l0[1] = (scale * mv_col[1] + 128) >> 8;\n                ref      = ref0;\n                mv0      = pack16to32(mv_l0[0], mv_l0[1]);\n                mv1      = pack16to32(mv_l0[0] - mv_col[0], mv_l0[1] - mv_col[1]);\n            }\n            fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);\n            fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, mv0, 4);\n            fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, mv1, 4);\n        } else {\n            for (i8 = 0; i8 < 4; i8++) {\n                const int x8 = i8 & 1;\n                const int y8 = i8 >> 1;\n                int ref0, scale;\n                const int16_t (*l1mv)[2] = l1mv0;\n\n                if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n                    continue;\n                sl->sub_mb_type[i8] = sub_mb_type;\n                fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                if (IS_INTRA(mb_type_col[0])) {\n                    fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    continue;\n                }\n\n                assert(b8_stride == 2);\n                ref0 = l1ref0[i8];\n                if (ref0 >= 0)\n                    ref0 = map_col_to_list0[0][ref0 + ref_offset];\n                else {\n                    ref0 = map_col_to_list0[1][l1ref1[i8] + ref_offset];\n                    l1mv = l1mv1;\n                }\n                scale = dist_scale_factor[ref0];\n\n                fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                               ref0, 1);\n                if (IS_SUB_8X8(sub_mb_type)) {\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n                    int mx                = (scale * mv_col[0] + 128) >> 8;\n                    int my                = (scale * mv_col[1] + 128) >> 8;\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx, my), 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx - mv_col[0], my - mv_col[1]), 4);\n                } else {\n                    for (i4 = 0; i4 < 4; i4++) {\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n                        int16_t *mv_l0 = sl->mv_cache[0][scan8[i8 * 4 + i4]];\n                        mv_l0[0] = (scale * mv_col[0] + 128) >> 8;\n                        mv_l0[1] = (scale * mv_col[1] + 128) >> 8;\n                        AV_WN32A(sl->mv_cache[1][scan8[i8 * 4 + i4]],\n                                 pack16to32(mv_l0[0] - mv_col[0],\n                                            mv_l0[1] - mv_col[1]));\n                    }\n                }\n            }\n        }\n    }\n}", "patch_func_code": "static void pred_temp_direct_motion(const H264Context *const h, H264SliceContext *sl,\n                                    int *mb_type)\n{\n    int b8_stride = 2;\n    int b4_stride = h->b_stride;\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n    int mb_type_col[2];\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n    const int8_t *l1ref0, *l1ref1;\n    const int is_b8x8 = IS_8X8(*mb_type);\n    unsigned int sub_mb_type;\n    int i8, i4;\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n    await_reference_mb_row(h, &sl->ref_list[1][0],\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n            mb_xy = sl->mb_x +\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n            b8_stride = 0;\n        } else {\n            mb_y  += sl->col_fieldoff;\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n        }\n        goto single_col;\n    } else {                                        // AFL/AFR/FR/FL -> AFR/FR\n        if (IS_INTERLACED(*mb_type)) {              // AFL       /FL -> AFR/FR\n            mb_y           = sl->mb_y & ~1;\n            mb_xy          = sl->mb_x + (sl->mb_y & ~1) * h->mb_stride;\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n            b8_stride      = 2 + 4 * h->mb_stride;\n            b4_stride     *= 6;\n            if (IS_INTERLACED(mb_type_col[0]) !=\n                IS_INTERLACED(mb_type_col[1])) {\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n            }\n\n            sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                          MB_TYPE_DIRECT2;                  /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n                !is_b8x8) {\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_L0L1 |\n                            MB_TYPE_DIRECT2;                /* B_16x8 */\n            } else {\n                *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1;\n            }\n        } else {                                    //     AFR/FR    -> AFR/FR\nsingle_col:\n            mb_type_col[0]     =\n                mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            sub_mb_type = MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                          MB_TYPE_DIRECT2;                  /* B_SUB_8x8 */\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                            MB_TYPE_DIRECT2;                /* B_16x16 */\n            } else if (!is_b8x8 &&\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n                *mb_type |= MB_TYPE_L0L1 | MB_TYPE_DIRECT2 |\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n            } else {\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n                    /* FIXME: save sub mb types from previous frames (or derive\n                     * from MVs) so we know exactly what block size to use */\n                    sub_mb_type = MB_TYPE_8x8 | MB_TYPE_P0L0 | MB_TYPE_P0L1 |\n                                  MB_TYPE_DIRECT2;          /* B_SUB_4x4 */\n                }\n                *mb_type |= MB_TYPE_8x8 | MB_TYPE_L0L1;\n            }\n        }\n    }\n\n    await_reference_mb_row(h, &sl->ref_list[1][0], mb_y);\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n    if (!b8_stride) {\n        if (sl->mb_y & 1) {\n            l1ref0 += 2;\n            l1ref1 += 2;\n            l1mv0  += 2 * b4_stride;\n            l1mv1  += 2 * b4_stride;\n        }\n    }\n\n    {\n        const int *map_col_to_list0[2] = { sl->map_col_to_list0[0],\n                                           sl->map_col_to_list0[1] };\n        const int *dist_scale_factor = sl->dist_scale_factor;\n        int ref_offset;\n\n        if (FRAME_MBAFF(h) && IS_INTERLACED(*mb_type)) {\n            map_col_to_list0[0] = sl->map_col_to_list0_field[sl->mb_y & 1][0];\n            map_col_to_list0[1] = sl->map_col_to_list0_field[sl->mb_y & 1][1];\n            dist_scale_factor   = sl->dist_scale_factor_field[sl->mb_y & 1];\n        }\n        ref_offset = (sl->ref_list[1][0].parent->mbaff << 4) & (mb_type_col[0] >> 3);\n\n        if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n            int y_shift = 2 * !IS_INTERLACED(*mb_type);\n            assert(h->ps.sps->direct_8x8_inference_flag);\n\n            for (i8 = 0; i8 < 4; i8++) {\n                const int x8 = i8 & 1;\n                const int y8 = i8 >> 1;\n                int ref0, scale;\n                const int16_t (*l1mv)[2] = l1mv0;\n\n                if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n                    continue;\n                sl->sub_mb_type[i8] = sub_mb_type;\n\n                fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                if (IS_INTRA(mb_type_col[y8])) {\n                    fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    continue;\n                }\n\n                ref0 = l1ref0[x8 + y8 * b8_stride];\n                if (ref0 >= 0)\n                    ref0 = map_col_to_list0[0][ref0 + ref_offset];\n                else {\n                    ref0 = map_col_to_list0[1][l1ref1[x8 + y8 * b8_stride] +\n                                               ref_offset];\n                    l1mv = l1mv1;\n                }\n                scale = dist_scale_factor[ref0];\n                fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                               ref0, 1);\n\n                {\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * b4_stride];\n                    int my_col            = (mv_col[1] << y_shift) / 2;\n                    int mx                = (scale * mv_col[0] + 128) >> 8;\n                    int my                = (scale * my_col    + 128) >> 8;\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx, my), 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx - mv_col[0], my - my_col), 4);\n                }\n            }\n            return;\n        }\n\n        /* one-to-one mv scaling */\n\n        if (IS_16X16(*mb_type)) {\n            int ref, mv0, mv1;\n\n            fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n            if (IS_INTRA(mb_type_col[0])) {\n                ref = mv0 = mv1 = 0;\n            } else {\n                const int ref0 = l1ref0[0] >= 0 ? map_col_to_list0[0][l1ref0[0] + ref_offset]\n                                                : map_col_to_list0[1][l1ref1[0] + ref_offset];\n                const int scale = dist_scale_factor[ref0];\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n                int mv_l0[2];\n                mv_l0[0] = (scale * mv_col[0] + 128) >> 8;\n                mv_l0[1] = (scale * mv_col[1] + 128) >> 8;\n                ref      = ref0;\n                mv0      = pack16to32(mv_l0[0], mv_l0[1]);\n                mv1      = pack16to32(mv_l0[0] - mv_col[0], mv_l0[1] - mv_col[1]);\n            }\n            fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, ref, 1);\n            fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, mv0, 4);\n            fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, mv1, 4);\n        } else {\n            for (i8 = 0; i8 < 4; i8++) {\n                const int x8 = i8 & 1;\n                const int y8 = i8 >> 1;\n                int ref0, scale;\n                const int16_t (*l1mv)[2] = l1mv0;\n\n                if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n                    continue;\n                sl->sub_mb_type[i8] = sub_mb_type;\n                fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                if (IS_INTRA(mb_type_col[0])) {\n                    fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 1);\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4);\n                    continue;\n                }\n\n                assert(b8_stride == 2);\n                ref0 = l1ref0[i8];\n                if (ref0 >= 0)\n                    ref0 = map_col_to_list0[0][ref0 + ref_offset];\n                else {\n                    ref0 = map_col_to_list0[1][l1ref1[i8] + ref_offset];\n                    l1mv = l1mv1;\n                }\n                scale = dist_scale_factor[ref0];\n\n                fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                               ref0, 1);\n                if (IS_SUB_8X8(sub_mb_type)) {\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n                    int mx                = (scale * mv_col[0] + 128) >> 8;\n                    int my                = (scale * mv_col[1] + 128) >> 8;\n                    fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx, my), 4);\n                    fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8,\n                                   pack16to32(mx - mv_col[0], my - mv_col[1]), 4);\n                } else {\n                    for (i4 = 0; i4 < 4; i4++) {\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n                        int16_t *mv_l0 = sl->mv_cache[0][scan8[i8 * 4 + i4]];\n                        mv_l0[0] = (scale * mv_col[0] + 128) >> 8;\n                        mv_l0[1] = (scale * mv_col[1] + 128) >> 8;\n                        AV_WN32A(sl->mv_cache[1][scan8[i8 * 4 + i4]],\n                                 pack16to32(mv_l0[0] - mv_col[0],\n                                            mv_l0[1] - mv_col[1]));\n                    }\n                }\n            }\n        }\n    }\n}", "before_change_lines": [16, 81], "raw_before_change_lines": [16, 81], "after_change_lines": [16, 81], "raw_after_change_lines": [16, 81], "bug_lines": [16, 81], "added": [false, false], "idx": 300}
{"project": "libav", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "8614----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d98d9281674a5441d8b3cd0ba666ec1ef87124f6_1.json----flv_write_packet", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_d98d9281674a5441d8b3cd0ba666ec1ef87124f6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_d98d9281674a5441d8b3cd0ba666ec1ef87124f6_1.json", "function_name": "flv_write_packet", "vul_func_code": "static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb      = s->pb;\n    AVCodecContext *enc  = s->streams[pkt->stream_index]->codec;\n    FLVContext *flv      = s->priv_data;\n    FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;\n    unsigned ts;\n    int size = pkt->size;\n    uint8_t *data = NULL;\n    int flags, flags_size;\n\n    // av_log(s, AV_LOG_DEBUG, \"type:%d pts: %\"PRId64\" size:%d\\n\",\n    //        enc->codec_type, timestamp, size);\n\n    if (enc->codec_id == AV_CODEC_ID_VP6 || enc->codec_id == AV_CODEC_ID_VP6F ||\n        enc->codec_id == AV_CODEC_ID_AAC)\n        flags_size = 2;\n    else if (enc->codec_id == AV_CODEC_ID_H264)\n        flags_size = 5;\n    else\n        flags_size = 1;\n\n    switch (enc->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n\n        flags = enc->codec_tag;\n        if (flags == 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"video codec %X not compatible with flv\\n\",\n                   enc->codec_id);\n            return -1;\n        }\n\n        flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        flags = get_audio_flags(s, enc);\n\n        assert(size);\n\n        avio_w8(pb, FLV_TAG_TYPE_AUDIO);\n        break;\n    case AVMEDIA_TYPE_DATA:\n        avio_w8(pb, FLV_TAG_TYPE_META);\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    if (enc->codec_id == AV_CODEC_ID_H264)\n        /* check if extradata looks like MP4 */\n        if (enc->extradata_size > 0 && *(uint8_t*)enc->extradata != 1)\n            if (ff_avc_parse_nal_units_buf(pkt->data, &data, &size) < 0)\n                return -1;\n\n    if (flv->delay == AV_NOPTS_VALUE)\n        flv->delay = -pkt->dts;\n\n    if (pkt->dts < -flv->delay) {\n        av_log(s, AV_LOG_WARNING,\n               \"Packets are not in the proper order with respect to DTS\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ts = pkt->dts + flv->delay; // add delay to force positive dts\n\n    /* check Speex packet duration */\n    if (enc->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)\n        av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"\n                                  \"8 frames per packet. Adobe Flash \"\n                                  \"Player cannot handle this!\\n\");\n\n    if (sc->last_ts < ts)\n        sc->last_ts = ts;\n\n    avio_wb24(pb, size + flags_size);\n    avio_wb24(pb, ts);\n    avio_w8(pb, (ts >> 24) & 0x7F); // timestamps are 32 bits _signed_\n    avio_wb24(pb, flv->reserved);\n\n    if (enc->codec_type == AVMEDIA_TYPE_DATA) {\n        int data_size;\n        int metadata_size_pos = avio_tell(pb);\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, \"onTextData\");\n        avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n        avio_wb32(pb, 2);\n        put_amf_string(pb, \"type\");\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, \"Text\");\n        put_amf_string(pb, \"text\");\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, pkt->data);\n        put_amf_string(pb, \"\");\n        avio_w8(pb, AMF_END_OF_OBJECT);\n        /* write total size of tag */\n        data_size = avio_tell(pb) - metadata_size_pos;\n        avio_seek(pb, metadata_size_pos - 10, SEEK_SET);\n        avio_wb24(pb, data_size);\n        avio_seek(pb, data_size + 10 - 3, SEEK_CUR);\n        avio_wb32(pb, data_size + 11);\n    } else {\n        avio_w8(pb,flags);\n        if (enc->codec_id == AV_CODEC_ID_VP6)\n            avio_w8(pb, 0);\n        if (enc->codec_id == AV_CODEC_ID_VP6F)\n            avio_w8(pb, enc->extradata_size ? enc->extradata[0] : 0);\n        else if (enc->codec_id == AV_CODEC_ID_AAC)\n            avio_w8(pb, 1); // AAC raw\n        else if (enc->codec_id == AV_CODEC_ID_H264) {\n            avio_w8(pb, 1); // AVC NALU\n            avio_wb24(pb, pkt->pts - pkt->dts);\n        }\n\n        avio_write(pb, data ? data : pkt->data, size);\n\n        avio_wb32(pb, size + flags_size + 11); // previous tag size\n        flv->duration = FFMAX(flv->duration,\n                              pkt->pts + flv->delay + pkt->duration);\n    }\n\n    avio_flush(pb);\n    av_free(data);\n\n    return pb->error;\n}", "patch_func_code": "static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    AVIOContext *pb      = s->pb;\n    AVCodecContext *enc  = s->streams[pkt->stream_index]->codec;\n    FLVContext *flv      = s->priv_data;\n    FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data;\n    unsigned ts;\n    int size = pkt->size;\n    uint8_t *data = NULL;\n    int flags = 0, flags_size;\n\n    // av_log(s, AV_LOG_DEBUG, \"type:%d pts: %\"PRId64\" size:%d\\n\",\n    //        enc->codec_type, timestamp, size);\n\n    if (enc->codec_id == AV_CODEC_ID_VP6 || enc->codec_id == AV_CODEC_ID_VP6F ||\n        enc->codec_id == AV_CODEC_ID_AAC)\n        flags_size = 2;\n    else if (enc->codec_id == AV_CODEC_ID_H264)\n        flags_size = 5;\n    else\n        flags_size = 1;\n\n    switch (enc->codec_type) {\n    case AVMEDIA_TYPE_VIDEO:\n        avio_w8(pb, FLV_TAG_TYPE_VIDEO);\n\n        flags = enc->codec_tag;\n        if (flags == 0) {\n            av_log(s, AV_LOG_ERROR,\n                   \"video codec %X not compatible with flv\\n\",\n                   enc->codec_id);\n            return -1;\n        }\n\n        flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER;\n        break;\n    case AVMEDIA_TYPE_AUDIO:\n        flags = get_audio_flags(s, enc);\n\n        assert(size);\n\n        avio_w8(pb, FLV_TAG_TYPE_AUDIO);\n        break;\n    case AVMEDIA_TYPE_DATA:\n        avio_w8(pb, FLV_TAG_TYPE_META);\n        break;\n    default:\n        return AVERROR(EINVAL);\n    }\n\n    if (enc->codec_id == AV_CODEC_ID_H264)\n        /* check if extradata looks like MP4 */\n        if (enc->extradata_size > 0 && *(uint8_t*)enc->extradata != 1)\n            if (ff_avc_parse_nal_units_buf(pkt->data, &data, &size) < 0)\n                return -1;\n\n    if (flv->delay == AV_NOPTS_VALUE)\n        flv->delay = -pkt->dts;\n\n    if (pkt->dts < -flv->delay) {\n        av_log(s, AV_LOG_WARNING,\n               \"Packets are not in the proper order with respect to DTS\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    ts = pkt->dts + flv->delay; // add delay to force positive dts\n\n    /* check Speex packet duration */\n    if (enc->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160)\n        av_log(s, AV_LOG_WARNING, \"Warning: Speex stream has more than \"\n                                  \"8 frames per packet. Adobe Flash \"\n                                  \"Player cannot handle this!\\n\");\n\n    if (sc->last_ts < ts)\n        sc->last_ts = ts;\n\n    avio_wb24(pb, size + flags_size);\n    avio_wb24(pb, ts);\n    avio_w8(pb, (ts >> 24) & 0x7F); // timestamps are 32 bits _signed_\n    avio_wb24(pb, flv->reserved);\n\n    if (enc->codec_type == AVMEDIA_TYPE_DATA) {\n        int data_size;\n        int metadata_size_pos = avio_tell(pb);\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, \"onTextData\");\n        avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY);\n        avio_wb32(pb, 2);\n        put_amf_string(pb, \"type\");\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, \"Text\");\n        put_amf_string(pb, \"text\");\n        avio_w8(pb, AMF_DATA_TYPE_STRING);\n        put_amf_string(pb, pkt->data);\n        put_amf_string(pb, \"\");\n        avio_w8(pb, AMF_END_OF_OBJECT);\n        /* write total size of tag */\n        data_size = avio_tell(pb) - metadata_size_pos;\n        avio_seek(pb, metadata_size_pos - 10, SEEK_SET);\n        avio_wb24(pb, data_size);\n        avio_seek(pb, data_size + 10 - 3, SEEK_CUR);\n        avio_wb32(pb, data_size + 11);\n    } else {\n        avio_w8(pb,flags);\n        if (enc->codec_id == AV_CODEC_ID_VP6)\n            avio_w8(pb, 0);\n        if (enc->codec_id == AV_CODEC_ID_VP6F)\n            avio_w8(pb, enc->extradata_size ? enc->extradata[0] : 0);\n        else if (enc->codec_id == AV_CODEC_ID_AAC)\n            avio_w8(pb, 1); // AAC raw\n        else if (enc->codec_id == AV_CODEC_ID_H264) {\n            avio_w8(pb, 1); // AVC NALU\n            avio_wb24(pb, pkt->pts - pkt->dts);\n        }\n\n        avio_write(pb, data ? data : pkt->data, size);\n\n        avio_wb32(pb, size + flags_size + 11); // previous tag size\n        flv->duration = FFMAX(flv->duration,\n                              pkt->pts + flv->delay + pkt->duration);\n    }\n\n    avio_flush(pb);\n    av_free(data);\n\n    return pb->error;\n}", "before_change_lines": [10], "raw_before_change_lines": [10], "after_change_lines": [10], "raw_after_change_lines": [10], "bug_lines": [10], "added": [false], "idx": 301}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "8871----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_e800f1c631dc56dfeb6e3f390e78698a1bdd646b_1.json----decode_bmv_frame", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_e800f1c631dc56dfeb6e3f390e78698a1bdd646b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_e800f1c631dc56dfeb6e3f390e78698a1bdd646b_1.json", "function_name": "decode_bmv_frame", "vul_func_code": "static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off)\n{\n    unsigned val, saved_val = 0;\n    int tmplen = src_len;\n    const uint8_t *src, *source_end = source + src_len;\n    uint8_t *frame_end = frame + SCREEN_WIDE * SCREEN_HIGH;\n    uint8_t *dst, *dst_end;\n    int len, mask;\n    int forward = (frame_off <= -SCREEN_WIDE) || (frame_off >= 0);\n    int read_two_nibbles, flag;\n    int advance_mode;\n    int mode = 0;\n    int i;\n\n    if (src_len <= 0)\n        return AVERROR_INVALIDDATA;\n\n    if (forward) {\n        src = source;\n        dst = frame;\n        dst_end = frame_end;\n    } else {\n        src = source + src_len - 1;\n        dst = frame_end - 1;\n        dst_end = frame - 1;\n    }\n    for (;;) {\n        int shift = 0;\n        flag = 0;\n\n        /* The mode/len decoding is a bit strange:\n         * values are coded as variable-length codes with nibble units,\n         * code end is signalled by two top bits in the nibble being nonzero.\n         * And since data is bytepacked and we read two nibbles at a time,\n         * we may get a nibble belonging to the next code.\n         * Hence this convoluted loop.\n         */\n        if (!mode || (tmplen == 4)) {\n            if (src < source || src >= source_end)\n                return AVERROR_INVALIDDATA;\n            val = *src;\n            read_two_nibbles = 1;\n        } else {\n            val = saved_val;\n            read_two_nibbles = 0;\n        }\n        if (!(val & 0xC)) {\n            for (;;) {\n                if (!read_two_nibbles) {\n                    if (src < source || src >= source_end)\n                        return AVERROR_INVALIDDATA;\n                    shift += 2;\n                    val |= *src << shift;\n                    if (*src & 0xC)\n                        break;\n                }\n                // two upper bits of the nibble is zero,\n                // so shift top nibble value down into their place\n                read_two_nibbles = 0;\n                shift += 2;\n                mask = (1 << shift) - 1;\n                val = ((val >> 2) & ~mask) | (val & mask);\n                NEXT_BYTE(src);\n                if ((val & (0xC << shift))) {\n                    flag = 1;\n                    break;\n                }\n            }\n        } else if (mode) {\n            flag = tmplen != 4;\n        }\n        if (flag) {\n            tmplen = 4;\n        } else {\n            saved_val = val >> (4 + shift);\n            tmplen = 0;\n            val &= (1 << (shift + 4)) - 1;\n            NEXT_BYTE(src);\n        }\n        advance_mode = val & 1;\n        len = (val >> 1) - 1;\n        mode += 1 + advance_mode;\n        if (mode >= 4)\n            mode -= 3;\n        if (FFABS(dst_end - dst) < len)\n            return AVERROR_INVALIDDATA;\n        switch (mode) {\n        case 1:\n            if (forward) {\n                if (dst - frame + SCREEN_WIDE < frame_off ||\n                        dst - frame + SCREEN_WIDE + frame_off < 0 ||\n                        frame_end - dst < frame_off + len ||\n                        frame_end - dst < len)\n                    return AVERROR_INVALIDDATA;\n                for (i = 0; i < len; i++)\n                    dst[i] = dst[frame_off + i];\n                dst += len;\n            } else {\n                dst -= len;\n                if (dst - frame + SCREEN_WIDE < frame_off ||\n                        dst - frame + SCREEN_WIDE + frame_off < 0 ||\n                        frame_end - dst < frame_off + len ||\n                        frame_end - dst < len)\n                    return AVERROR_INVALIDDATA;\n                for (i = len - 1; i >= 0; i--)\n                    dst[i] = dst[frame_off + i];\n            }\n            break;\n        case 2:\n            if (forward) {\n                if (source + src_len - src < len)\n                    return AVERROR_INVALIDDATA;\n                memcpy(dst, src, len);\n                dst += len;\n                src += len;\n            } else {\n                if (src - source < len)\n                    return AVERROR_INVALIDDATA;\n                dst -= len;\n                src -= len;\n                memcpy(dst, src, len);\n            }\n            break;\n        case 3:\n            val = forward ? dst[-1] : dst[1];\n            if (forward) {\n                memset(dst, val, len);\n                dst += len;\n            } else {\n                dst -= len;\n                memset(dst, val, len);\n            }\n            break;\n        default:\n            break;\n        }\n        if (dst == dst_end)\n            return 0;\n    }\n    return 0;\n}", "patch_func_code": "static int decode_bmv_frame(const uint8_t *source, int src_len, uint8_t *frame, int frame_off)\n{\n    unsigned val, saved_val = 0;\n    int tmplen = src_len;\n    const uint8_t *src, *source_end = source + src_len;\n    uint8_t *frame_end = frame + SCREEN_WIDE * SCREEN_HIGH;\n    uint8_t *dst, *dst_end;\n    int len, mask;\n    int forward = (frame_off <= -SCREEN_WIDE) || (frame_off >= 0);\n    int read_two_nibbles, flag;\n    int advance_mode;\n    int mode = 0;\n    int i;\n\n    if (src_len <= 0)\n        return AVERROR_INVALIDDATA;\n\n    if (forward) {\n        src = source;\n        dst = frame;\n        dst_end = frame_end;\n    } else {\n        src = source + src_len - 1;\n        dst = frame_end - 1;\n        dst_end = frame - 1;\n    }\n    for (;;) {\n        int shift = 0;\n        flag = 0;\n\n        /* The mode/len decoding is a bit strange:\n         * values are coded as variable-length codes with nibble units,\n         * code end is signalled by two top bits in the nibble being nonzero.\n         * And since data is bytepacked and we read two nibbles at a time,\n         * we may get a nibble belonging to the next code.\n         * Hence this convoluted loop.\n         */\n        if (!mode || (tmplen == 4)) {\n            if (src < source || src >= source_end)\n                return AVERROR_INVALIDDATA;\n            val = *src;\n            read_two_nibbles = 1;\n        } else {\n            val = saved_val;\n            read_two_nibbles = 0;\n        }\n        if (!(val & 0xC)) {\n            for (;;) {\n                if (!read_two_nibbles) {\n                    if (src < source || src >= source_end)\n                        return AVERROR_INVALIDDATA;\n                    shift += 2;\n                    val |= *src << shift;\n                    if (*src & 0xC)\n                        break;\n                }\n                // two upper bits of the nibble is zero,\n                // so shift top nibble value down into their place\n                read_two_nibbles = 0;\n                shift += 2;\n                mask = (1 << shift) - 1;\n                val = ((val >> 2) & ~mask) | (val & mask);\n                NEXT_BYTE(src);\n                if ((val & (0xC << shift))) {\n                    flag = 1;\n                    break;\n                }\n            }\n        } else if (mode) {\n            flag = tmplen != 4;\n        }\n        if (flag) {\n            tmplen = 4;\n        } else {\n            saved_val = val >> (4 + shift);\n            tmplen = 0;\n            val &= (1 << (shift + 4)) - 1;\n            NEXT_BYTE(src);\n        }\n        advance_mode = val & 1;\n        len = (val >> 1) - 1;\n        mode += 1 + advance_mode;\n        if (mode >= 4)\n            mode -= 3;\n        if (len <= 0 || FFABS(dst_end - dst) < len)\n            return AVERROR_INVALIDDATA;\n        switch (mode) {\n        case 1:\n            if (forward) {\n                if (dst - frame + SCREEN_WIDE < frame_off ||\n                        dst - frame + SCREEN_WIDE + frame_off < 0 ||\n                        frame_end - dst < frame_off + len ||\n                        frame_end - dst < len)\n                    return AVERROR_INVALIDDATA;\n                for (i = 0; i < len; i++)\n                    dst[i] = dst[frame_off + i];\n                dst += len;\n            } else {\n                dst -= len;\n                if (dst - frame + SCREEN_WIDE < frame_off ||\n                        dst - frame + SCREEN_WIDE + frame_off < 0 ||\n                        frame_end - dst < frame_off + len ||\n                        frame_end - dst < len)\n                    return AVERROR_INVALIDDATA;\n                for (i = len - 1; i >= 0; i--)\n                    dst[i] = dst[frame_off + i];\n            }\n            break;\n        case 2:\n            if (forward) {\n                if (source + src_len - src < len)\n                    return AVERROR_INVALIDDATA;\n                memcpy(dst, src, len);\n                dst += len;\n                src += len;\n            } else {\n                if (src - source < len)\n                    return AVERROR_INVALIDDATA;\n                dst -= len;\n                src -= len;\n                memcpy(dst, src, len);\n            }\n            break;\n        case 3:\n            val = forward ? dst[-1] : dst[1];\n            if (forward) {\n                memset(dst, val, len);\n                dst += len;\n            } else {\n                dst -= len;\n                memset(dst, val, len);\n            }\n            break;\n        default:\n            break;\n        }\n        if (dst == dst_end)\n            return 0;\n    }\n    return 0;\n}", "before_change_lines": [85], "raw_before_change_lines": [85], "after_change_lines": [85], "raw_after_change_lines": [85], "bug_lines": [85], "added": [false], "idx": 302}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "8896----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_e993725add07887bcc0c8776f1db953994f95f2f_1.json----alac_set_info", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_e993725add07887bcc0c8776f1db953994f95f2f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_e993725add07887bcc0c8776f1db953994f95f2f_1.json", "function_name": "alac_set_info", "vul_func_code": "static int alac_set_info(ALACContext *alac)\n{\n    const unsigned char *ptr = alac->avctx->extradata;\n\n    ptr += 4; /* size */\n    ptr += 4; /* alac */\n    ptr += 4; /* 0 ? */\n\n    if(AV_RB32(ptr) >= UINT_MAX/4){\n        av_log(alac->avctx, AV_LOG_ERROR, \"setinfo_max_samples_per_frame too large\\n\");\n        return -1;\n    }\n\n    /* buffer size / 2 ? */\n    alac->setinfo_max_samples_per_frame = bytestream_get_be32(&ptr);\n    ptr++;                          /* ??? */\n    alac->setinfo_sample_size           = *ptr++;\n    alac->setinfo_rice_historymult      = *ptr++;\n    alac->setinfo_rice_initialhistory   = *ptr++;\n    alac->setinfo_rice_kmodifier        = *ptr++;\n    alac->numchannels                   = *ptr++;\n    bytestream_get_be16(&ptr);      /* ??? */\n    bytestream_get_be32(&ptr);      /* max coded frame size */\n    bytestream_get_be32(&ptr);      /* bitrate ? */\n    bytestream_get_be32(&ptr);      /* samplerate */\n\n    allocate_buffers(alac);\n\n    return 0;\n}", "patch_func_code": "static int alac_set_info(ALACContext *alac)\n{\n    const unsigned char *ptr = alac->avctx->extradata;\n\n    ptr += 4; /* size */\n    ptr += 4; /* alac */\n    ptr += 4; /* 0 ? */\n\n    if(AV_RB32(ptr) >= UINT_MAX/4){\n        av_log(alac->avctx, AV_LOG_ERROR, \"setinfo_max_samples_per_frame too large\\n\");\n        return -1;\n    }\n\n    /* buffer size / 2 ? */\n    alac->setinfo_max_samples_per_frame = bytestream_get_be32(&ptr);\n    ptr++;                          /* ??? */\n    alac->setinfo_sample_size           = *ptr++;\n    alac->setinfo_rice_historymult      = *ptr++;\n    alac->setinfo_rice_initialhistory   = *ptr++;\n    alac->setinfo_rice_kmodifier        = *ptr++;\n    alac->numchannels                   = *ptr++;\n    bytestream_get_be16(&ptr);      /* ??? */\n    bytestream_get_be32(&ptr);      /* max coded frame size */\n    bytestream_get_be32(&ptr);      /* bitrate ? */\n    bytestream_get_be32(&ptr);      /* samplerate */\n\n    return 0;\n}", "before_change_lines": [27], "raw_before_change_lines": [27, 28], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [27, 28], "added": [false, false], "idx": 303}
{"project": "libav", "vul_type": "BUFFER_OVERRUN_L3", "filepath_func": "8952----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_ed6fa367c058f7bd46244e47fefdcb74e85070bf_1.json----decode", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_ed6fa367c058f7bd46244e47fefdcb74e85070bf_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_ed6fa367c058f7bd46244e47fefdcb74e85070bf_1.json", "function_name": "decode", "vul_func_code": "static void decode(RA288Context *ractx, float gain, int cb_coef)\n{\n    int x, y;\n    double sumsum;\n    float sum, buffer[5];\n\n    memmove(ractx->sb + 5, ractx->sb, 36 * sizeof(*ractx->sb));\n\n    for (x=4; x >= 0; x--)\n        ractx->sb[x] = -scalar_product_float(ractx->sb + x + 1,\n                                             ractx->sp_lpc, 36);\n\n    /* block 46 of G.728 spec */\n    sum = 32. - scalar_product_float(ractx->gain_lpc, ractx->lhist, 10);\n\n    /* block 47 of G.728 spec */\n    sum = av_clipf(sum, 0, 60);\n\n    /* block 48 of G.728 spec */\n    sumsum = exp(sum * 0.1151292546497) * gain;    /* pow(10.0,sum/20)*f */\n\n    for (x=0; x < 5; x++)\n        buffer[x] = codetable[cb_coef][x] * sumsum;\n\n    sum = scalar_product_float(buffer, buffer, 5) / 5;\n\n    sum = FFMAX(sum, 1);\n\n    /* shift and store */\n    memmove(ractx->lhist, ractx->lhist - 1, 10 * sizeof(*ractx->lhist));\n\n    *ractx->lhist = 10 * log10(sum) - 32;\n\n    for (x=1; x < 5; x++)\n        for (y=x-1; y >= 0; y--)\n            buffer[x] -= ractx->sp_lpc[x-y-1] * buffer[y];\n\n    /* output */\n    for (x=0; x < 5; x++) {\n        ractx->output[ractx->phase*5+x] = ractx->sb[4-x] =\n            av_clipf(ractx->sb[4-x] + buffer[x], -4095, 4095);\n    }\n}", "patch_func_code": "static void decode(RA288Context *ractx, float gain, int cb_coef)\n{\n    int x, y;\n    double sumsum;\n    float sum, buffer[5];\n\n    memmove(ractx->sb + 5, ractx->sb, 36 * sizeof(*ractx->sb));\n\n    for (x=4; x >= 0; x--)\n        ractx->sb[x] = -scalar_product_float(ractx->sb + x + 1,\n                                             ractx->sp_lpc, 36);\n\n    /* block 46 of G.728 spec */\n    sum = 32. - scalar_product_float(ractx->gain_lpc, ractx->lhist, 10);\n\n    /* block 47 of G.728 spec */\n    sum = av_clipf(sum, 0, 60);\n\n    /* block 48 of G.728 spec */\n    sumsum = exp(sum * 0.1151292546497) * gain;    /* pow(10.0,sum/20)*f */\n\n    for (x=0; x < 5; x++)\n        buffer[x] = codetable[cb_coef][x] * sumsum;\n\n    sum = scalar_product_float(buffer, buffer, 5) / 5;\n\n    sum = FFMAX(sum, 1);\n\n    /* shift and store */\n    memmove(ractx->lhist, ractx->lhist - 1, 10 * sizeof(*ractx->lhist));\n\n    *ractx->lhist = 10 * log10(sum) - 32;\n\n    for (x=1; x < 5; x++)\n        for (y=x-1; y >= 0; y--)\n            buffer[x] -= ractx->sp_lpc[x-y-1] * buffer[y];\n\n    /* output */\n    for (x=0; x < 5; x++) {\n        ractx->sb[4-x] =\n            av_clipf(ractx->sb[4-x] + buffer[x], -4095, 4095);\n    }\n}", "before_change_lines": [40], "raw_before_change_lines": [40], "after_change_lines": [40], "raw_after_change_lines": [40], "bug_lines": [40], "added": [false], "idx": 304}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "8954----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_ed8a85d8451e5b6e1158e0cce60cdfadce2614d7_1.json----put_rv40_qpel8_mc33_c", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_ed8a85d8451e5b6e1158e0cce60cdfadce2614d7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_ed8a85d8451e5b6e1158e0cce60cdfadce2614d7_1.json", "function_name": "put_rv40_qpel8_mc33_c", "vul_func_code": "static void put_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, int stride){\n    put_pixels8_xy2_c(dst, src, stride, 8);\n}", "patch_func_code": "static void put_rv40_qpel8_mc33_c(uint8_t *dst, uint8_t *src, int stride){\n    put_pixels8_xy2_8_c(dst, src, stride, 8);\n}", "before_change_lines": [2], "raw_before_change_lines": [2], "after_change_lines": [2], "raw_after_change_lines": [2], "bug_lines": [2], "added": [false], "idx": 305}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9011----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f191399a0e841d780e74bf5d1312ca5dad782b32_1.json----decode_cabac_field_decoding_flag", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_f191399a0e841d780e74bf5d1312ca5dad782b32_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f191399a0e841d780e74bf5d1312ca5dad782b32_1.json", "function_name": "decode_cabac_field_decoding_flag", "vul_func_code": "static int decode_cabac_field_decoding_flag(H264Context *h) {\n    MpegEncContext * const s = &h->s;\n    const long mbb_xy = h->mb_xy - 2L*s->mb_stride;\n\n    unsigned long ctx = 0;\n\n    ctx += h->mb_field_decoding_flag & !!s->mb_x; //for FMO:(s->current_picture.f.mb_type[mba_xy] >> 7) & (h->slice_table[mba_xy] == h->slice_num);\n    ctx += (s->current_picture.f.mb_type[mbb_xy] >> 7) & (h->slice_table[mbb_xy] == h->slice_num);\n\n    return get_cabac_noinline( &h->cabac, &(h->cabac_state+70)[ctx] );\n}", "patch_func_code": "static int decode_cabac_field_decoding_flag(H264Context *h) {\n    const long mbb_xy = h->mb_xy - 2L*h->mb_stride;\n\n    unsigned long ctx = 0;\n\n    ctx += h->mb_field_decoding_flag & !!h->mb_x; //for FMO:(s->current_picture.f.mb_type[mba_xy] >> 7) & (h->slice_table[mba_xy] == h->slice_num);\n    ctx += (h->cur_pic.f.mb_type[mbb_xy] >> 7) & (h->slice_table[mbb_xy] == h->slice_num);\n\n    return get_cabac_noinline( &h->cabac, &(h->cabac_state+70)[ctx] );\n}", "before_change_lines": [2, 3, 7, 8], "raw_before_change_lines": [2, 3, 7, 8], "after_change_lines": [2, 6, 7], "raw_after_change_lines": [2, 6, 7], "bug_lines": [2, 3, 7, 8], "added": [false, false, false, false], "idx": 306}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9015----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f216da225e8b66387d923e9e691e452d6338ab63_1.json----vorbis_parse_setup_hdr_mappings", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_f216da225e8b66387d923e9e691e452d6338ab63_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f216da225e8b66387d923e9e691e452d6338ab63_1.json", "function_name": "vorbis_parse_setup_hdr_mappings", "vul_func_code": "static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc)\n{\n    GetBitContext *gb = &vc->gb;\n    uint_fast8_t i, j;\n\n    vc->mapping_count = get_bits(gb, 6)+1;\n    vc->mappings      = av_mallocz(vc->mapping_count * sizeof(*vc->mappings));\n\n    AV_DEBUG(\" There are %d mappings. \\n\", vc->mapping_count);\n\n    for (i = 0; i < vc->mapping_count; ++i) {\n        vorbis_mapping *mapping_setup = &vc->mappings[i];\n\n        if (get_bits(gb, 16)) {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\");\n            return -1;\n        }\n        if (get_bits1(gb)) {\n            mapping_setup->submaps = get_bits(gb, 4) + 1;\n        } else {\n            mapping_setup->submaps = 1;\n        }\n\n        if (get_bits1(gb)) {\n            mapping_setup->coupling_steps = get_bits(gb, 8) + 1;\n            mapping_setup->magnitude      = av_mallocz(mapping_setup->coupling_steps *\n                                                       sizeof(*mapping_setup->magnitude));\n            mapping_setup->angle          = av_mallocz(mapping_setup->coupling_steps *\n                                                       sizeof(*mapping_setup->angle));\n            for (j = 0; j < mapping_setup->coupling_steps; ++j) {\n                GET_VALIDATED_INDEX(mapping_setup->magnitude[j], ilog(vc->audio_channels - 1), vc->audio_channels)\n                GET_VALIDATED_INDEX(mapping_setup->angle[j],     ilog(vc->audio_channels - 1), vc->audio_channels)\n            }\n        } else {\n            mapping_setup->coupling_steps = 0;\n        }\n\n        AV_DEBUG(\"   %d mapping coupling steps: %d \\n\", i, mapping_setup->coupling_steps);\n\n        if (get_bits(gb, 2)) {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%d. mapping setup data invalid. \\n\", i);\n            return -1; // following spec.\n        }\n\n        if (mapping_setup->submaps>1) {\n            mapping_setup->mux = av_mallocz(vc->audio_channels *\n                                            sizeof(*mapping_setup->mux));\n            for (j = 0; j < vc->audio_channels; ++j)\n                mapping_setup->mux[j] = get_bits(gb, 4);\n        }\n\n        for (j = 0; j < mapping_setup->submaps; ++j) {\n            skip_bits(gb, 8); // FIXME check?\n            GET_VALIDATED_INDEX(mapping_setup->submap_floor[j],   8, vc->floor_count)\n            GET_VALIDATED_INDEX(mapping_setup->submap_residue[j], 8, vc->residue_count)\n\n            AV_DEBUG(\"   %d mapping %d submap : floor %d, residue %d \\n\", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc)\n{\n    GetBitContext *gb = &vc->gb;\n    unsigned i, j;\n\n    vc->mapping_count = get_bits(gb, 6)+1;\n    vc->mappings      = av_mallocz(vc->mapping_count * sizeof(*vc->mappings));\n\n    AV_DEBUG(\" There are %d mappings. \\n\", vc->mapping_count);\n\n    for (i = 0; i < vc->mapping_count; ++i) {\n        vorbis_mapping *mapping_setup = &vc->mappings[i];\n\n        if (get_bits(gb, 16)) {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\");\n            return -1;\n        }\n        if (get_bits1(gb)) {\n            mapping_setup->submaps = get_bits(gb, 4) + 1;\n        } else {\n            mapping_setup->submaps = 1;\n        }\n\n        if (get_bits1(gb)) {\n            mapping_setup->coupling_steps = get_bits(gb, 8) + 1;\n            mapping_setup->magnitude      = av_mallocz(mapping_setup->coupling_steps *\n                                                       sizeof(*mapping_setup->magnitude));\n            mapping_setup->angle          = av_mallocz(mapping_setup->coupling_steps *\n                                                       sizeof(*mapping_setup->angle));\n            for (j = 0; j < mapping_setup->coupling_steps; ++j) {\n                GET_VALIDATED_INDEX(mapping_setup->magnitude[j], ilog(vc->audio_channels - 1), vc->audio_channels)\n                GET_VALIDATED_INDEX(mapping_setup->angle[j],     ilog(vc->audio_channels - 1), vc->audio_channels)\n            }\n        } else {\n            mapping_setup->coupling_steps = 0;\n        }\n\n        AV_DEBUG(\"   %u mapping coupling steps: %d\\n\",\n                 i, mapping_setup->coupling_steps);\n\n        if (get_bits(gb, 2)) {\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%u. mapping setup data invalid.\\n\", i);\n            return -1; // following spec.\n        }\n\n        if (mapping_setup->submaps>1) {\n            mapping_setup->mux = av_mallocz(vc->audio_channels *\n                                            sizeof(*mapping_setup->mux));\n            for (j = 0; j < vc->audio_channels; ++j)\n                mapping_setup->mux[j] = get_bits(gb, 4);\n        }\n\n        for (j = 0; j < mapping_setup->submaps; ++j) {\n            skip_bits(gb, 8); // FIXME check?\n            GET_VALIDATED_INDEX(mapping_setup->submap_floor[j],   8, vc->floor_count)\n            GET_VALIDATED_INDEX(mapping_setup->submap_residue[j], 8, vc->residue_count)\n\n            AV_DEBUG(\"   %u mapping %u submap : floor %d, residue %d\\n\",\n                     i, j,\n                     mapping_setup->submap_floor[j],\n                     mapping_setup->submap_residue[j]);\n        }\n    }\n    return 0;\n}", "before_change_lines": [4, 38, 41, 57], "raw_before_change_lines": [4, 38, 41, 57], "after_change_lines": [4, 38, 39, 42, 58, 59, 60, 61], "raw_after_change_lines": [4, 38, 39, 42, 58, 59, 60, 61], "bug_lines": [4, 38, 41, 57], "added": [false, false, false, false], "idx": 307}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9032----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f2e3310a3143b3b5b495855e982c15f029278dfa_1.json----send_filter_eof", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_f2e3310a3143b3b5b495855e982c15f029278dfa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_f2e3310a3143b3b5b495855e982c15f029278dfa_1.json", "function_name": "send_filter_eof", "vul_func_code": "static int send_filter_eof(InputStream *ist)\n{\n    int i, j, ret;\n    for (i = 0; i < ist->nb_filters; i++) {\n        if (ist->filters[i]->filter) {\n            ret = av_buffersrc_add_frame(ist->filters[i]->filter, NULL);\n            if (ret < 0)\n                return ret;\n        } else {\n            // the filtergraph was never configured\n            FilterGraph *fg = ist->filters[i]->graph;\n            for (j = 0; j < fg->nb_outputs; j++)\n                finish_output_stream(fg->outputs[j]->ost);\n        }\n    }\n    return 0;\n}", "patch_func_code": "static int send_filter_eof(InputStream *ist)\n{\n    int i, ret;\n    for (i = 0; i < ist->nb_filters; i++) {\n        ret = ifilter_send_eof(ist->filters[i]);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "before_change_lines": [3, 5, 6, 7, 8, 9, 11, 12, 13, 14], "raw_before_change_lines": [3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], "after_change_lines": [3, 5, 6, 7], "raw_after_change_lines": [3, 5, 6, 7], "bug_lines": [3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 308}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9138----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fa508c73c8ae5ffe26b0e76063a3947f11c02b86_1.json----vc1_decode_skip_blocks", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_fa508c73c8ae5ffe26b0e76063a3947f11c02b86_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fa508c73c8ae5ffe26b0e76063a3947f11c02b86_1.json", "function_name": "vc1_decode_skip_blocks", "vul_func_code": "static void vc1_decode_skip_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n\n    ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END);\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        ff_init_block_index(s);\n        ff_update_block_index(s);\n        memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);\n        memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        s->first_slice_line = 0;\n    }\n    s->pict_type = AV_PICTURE_TYPE_P;\n}", "patch_func_code": "static void vc1_decode_skip_blocks(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n\n    ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_width - 1, s->end_mb_y - 1, ER_MB_END);\n    s->first_slice_line = 1;\n    for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n        s->mb_x = 0;\n        init_block_index(v);\n        ff_update_block_index(s);\n        memcpy(s->dest[0], s->last_picture.f.data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);\n        memcpy(s->dest[1], s->last_picture.f.data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        memcpy(s->dest[2], s->last_picture.f.data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);\n        ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n        s->first_slice_line = 0;\n    }\n    s->pict_type = AV_PICTURE_TYPE_P;\n}", "before_change_lines": [9], "raw_before_change_lines": [9], "after_change_lines": [9], "raw_after_change_lines": [9], "bug_lines": [9], "added": [false], "idx": 309}
{"project": "libav", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "9143----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fab74083b4b793562a46efd9bcaa924fb6f5863f_1.json----pmt_cb", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_fab74083b4b793562a46efd9bcaa924fb6f5863f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fab74083b4b793562a46efd9bcaa924fb6f5863f_1.json", "function_name": "pmt_cb", "vul_func_code": "static void pmt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len)\n{\n    MpegTSContext *ts = filter->u.section_filter.opaque;\n    SectionHeader h1, *h = &h1;\n    PESContext *pes;\n    AVStream *st;\n    const uint8_t *p, *p_end, *desc_list_end;\n    int program_info_length, pcr_pid, pid, stream_type;\n    int desc_list_len;\n    uint32_t prog_reg_desc = 0; /* registration descriptor */\n\n    Mp4Descr mp4_descr[MAX_MP4_DESCR_COUNT] = {{ 0 }};\n    int mp4_descr_count = 0;\n    int i;\n\n    av_dlog(ts->stream, \"PMT: len %i\\n\", section_len);\n    hex_dump_debug(ts->stream, (uint8_t *)section, section_len);\n\n    p_end = section + section_len - 4;\n    p = section;\n    if (parse_section_header(h, &p, p_end) < 0)\n        return;\n\n    av_dlog(ts->stream, \"sid=0x%x sec_num=%d/%d\\n\",\n           h->id, h->sec_num, h->last_sec_num);\n\n    if (h->tid != PMT_TID)\n        return;\n\n    clear_program(ts, h->id);\n    pcr_pid = get16(&p, p_end) & 0x1fff;\n    if (pcr_pid < 0)\n        return;\n    add_pid_to_pmt(ts, h->id, pcr_pid);\n\n    av_dlog(ts->stream, \"pcr_pid=0x%x\\n\", pcr_pid);\n\n    program_info_length = get16(&p, p_end) & 0xfff;\n    if (program_info_length < 0)\n        return;\n    while(program_info_length >= 2) {\n        uint8_t tag, len;\n        tag = get8(&p, p_end);\n        len = get8(&p, p_end);\n\n        av_dlog(ts->stream, \"program tag: 0x%02x len=%d\\n\", tag, len);\n\n        if(len > program_info_length - 2)\n            //something else is broken, exit the program_descriptors_loop\n            break;\n        program_info_length -= len + 2;\n        if (tag == 0x1d) { // IOD descriptor\n            get8(&p, p_end); // scope\n            get8(&p, p_end); // label\n            len -= 2;\n            mp4_read_iods(ts->stream, p, len, mp4_descr + mp4_descr_count,\n                          &mp4_descr_count, MAX_MP4_DESCR_COUNT);\n        } else if (tag == 0x05 && len >= 4) { // registration descriptor\n            prog_reg_desc = bytestream_get_le32(&p);\n            len -= 4;\n        }\n        p += len;\n    }\n    p += program_info_length;\n    if (p >= p_end)\n        goto out;\n\n    // stop parsing after pmt, we found header\n    if (!ts->stream->nb_streams)\n        ts->stop_parse = 1;\n\n    for(;;) {\n        st = 0;\n        pes = NULL;\n        stream_type = get8(&p, p_end);\n        if (stream_type < 0)\n            break;\n        pid = get16(&p, p_end) & 0x1fff;\n        if (pid < 0)\n            break;\n\n        /* now create stream */\n        if (ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES) {\n            pes = ts->pids[pid]->u.pes_filter.opaque;\n            if (!pes->st) {\n                pes->st = avformat_new_stream(pes->stream, NULL);\n                pes->st->id = pes->pid;\n            }\n            st = pes->st;\n        } else if (stream_type != 0x13) {\n            if (ts->pids[pid]) mpegts_close_filter(ts, ts->pids[pid]); //wrongly added sdt filter probably\n            pes = add_pes_stream(ts, pid, pcr_pid);\n            if (pes) {\n                st = avformat_new_stream(pes->stream, NULL);\n                st->id = pes->pid;\n            }\n        } else {\n            int idx = ff_find_stream_index(ts->stream, pid);\n            if (idx >= 0) {\n                st = ts->stream->streams[idx];\n            } else {\n                st = avformat_new_stream(pes->stream, NULL);\n                st->id = pid;\n                st->codec->codec_type = AVMEDIA_TYPE_DATA;\n            }\n        }\n\n        if (!st)\n            goto out;\n\n        if (pes && !pes->stream_type)\n            mpegts_set_stream_info(st, pes, stream_type, prog_reg_desc);\n\n        add_pid_to_pmt(ts, h->id, pid);\n\n        ff_program_add_stream_index(ts->stream, h->id, st->index);\n\n        desc_list_len = get16(&p, p_end) & 0xfff;\n        if (desc_list_len < 0)\n            break;\n        desc_list_end = p + desc_list_len;\n        if (desc_list_end > p_end)\n            break;\n        for(;;) {\n            if (ff_parse_mpeg2_descriptor(ts->stream, st, stream_type, &p, desc_list_end,\n                mp4_descr, mp4_descr_count, pid, ts) < 0)\n                break;\n\n            if (pes && prog_reg_desc == AV_RL32(\"HDMV\") && stream_type == 0x83 && pes->sub_st) {\n                ff_program_add_stream_index(ts->stream, h->id, pes->sub_st->index);\n                pes->sub_st->codec->codec_tag = st->codec->codec_tag;\n            }\n        }\n        p = desc_list_end;\n    }\n\n out:\n    for (i = 0; i < mp4_descr_count; i++)\n        av_free(mp4_descr[i].dec_config_descr);\n}", "patch_func_code": "static void pmt_cb(MpegTSFilter *filter, const uint8_t *section, int section_len)\n{\n    MpegTSContext *ts = filter->u.section_filter.opaque;\n    SectionHeader h1, *h = &h1;\n    PESContext *pes;\n    AVStream *st;\n    const uint8_t *p, *p_end, *desc_list_end;\n    int program_info_length, pcr_pid, pid, stream_type;\n    int desc_list_len;\n    uint32_t prog_reg_desc = 0; /* registration descriptor */\n\n    Mp4Descr mp4_descr[MAX_MP4_DESCR_COUNT] = {{ 0 }};\n    int mp4_descr_count = 0;\n    int i;\n\n    av_dlog(ts->stream, \"PMT: len %i\\n\", section_len);\n    hex_dump_debug(ts->stream, (uint8_t *)section, section_len);\n\n    p_end = section + section_len - 4;\n    p = section;\n    if (parse_section_header(h, &p, p_end) < 0)\n        return;\n\n    av_dlog(ts->stream, \"sid=0x%x sec_num=%d/%d\\n\",\n           h->id, h->sec_num, h->last_sec_num);\n\n    if (h->tid != PMT_TID)\n        return;\n\n    clear_program(ts, h->id);\n    pcr_pid = get16(&p, p_end) & 0x1fff;\n    if (pcr_pid < 0)\n        return;\n    add_pid_to_pmt(ts, h->id, pcr_pid);\n\n    av_dlog(ts->stream, \"pcr_pid=0x%x\\n\", pcr_pid);\n\n    program_info_length = get16(&p, p_end) & 0xfff;\n    if (program_info_length < 0)\n        return;\n    while(program_info_length >= 2) {\n        uint8_t tag, len;\n        tag = get8(&p, p_end);\n        len = get8(&p, p_end);\n\n        av_dlog(ts->stream, \"program tag: 0x%02x len=%d\\n\", tag, len);\n\n        if(len > program_info_length - 2)\n            //something else is broken, exit the program_descriptors_loop\n            break;\n        program_info_length -= len + 2;\n        if (tag == 0x1d) { // IOD descriptor\n            get8(&p, p_end); // scope\n            get8(&p, p_end); // label\n            len -= 2;\n            mp4_read_iods(ts->stream, p, len, mp4_descr + mp4_descr_count,\n                          &mp4_descr_count, MAX_MP4_DESCR_COUNT);\n        } else if (tag == 0x05 && len >= 4) { // registration descriptor\n            prog_reg_desc = bytestream_get_le32(&p);\n            len -= 4;\n        }\n        p += len;\n    }\n    p += program_info_length;\n    if (p >= p_end)\n        goto out;\n\n    // stop parsing after pmt, we found header\n    if (!ts->stream->nb_streams)\n        ts->stop_parse = 1;\n\n    for(;;) {\n        st = 0;\n        pes = NULL;\n        stream_type = get8(&p, p_end);\n        if (stream_type < 0)\n            break;\n        pid = get16(&p, p_end) & 0x1fff;\n        if (pid < 0)\n            break;\n\n        /* now create stream */\n        if (ts->pids[pid] && ts->pids[pid]->type == MPEGTS_PES) {\n            pes = ts->pids[pid]->u.pes_filter.opaque;\n            if (!pes->st) {\n                pes->st = avformat_new_stream(pes->stream, NULL);\n                pes->st->id = pes->pid;\n            }\n            st = pes->st;\n        } else if (stream_type != 0x13) {\n            if (ts->pids[pid]) mpegts_close_filter(ts, ts->pids[pid]); //wrongly added sdt filter probably\n            pes = add_pes_stream(ts, pid, pcr_pid);\n            if (pes) {\n                st = avformat_new_stream(pes->stream, NULL);\n                st->id = pes->pid;\n            }\n        } else {\n            int idx = ff_find_stream_index(ts->stream, pid);\n            if (idx >= 0) {\n                st = ts->stream->streams[idx];\n            } else {\n                st = avformat_new_stream(ts->stream, NULL);\n                st->id = pid;\n                st->codec->codec_type = AVMEDIA_TYPE_DATA;\n            }\n        }\n\n        if (!st)\n            goto out;\n\n        if (pes && !pes->stream_type)\n            mpegts_set_stream_info(st, pes, stream_type, prog_reg_desc);\n\n        add_pid_to_pmt(ts, h->id, pid);\n\n        ff_program_add_stream_index(ts->stream, h->id, st->index);\n\n        desc_list_len = get16(&p, p_end) & 0xfff;\n        if (desc_list_len < 0)\n            break;\n        desc_list_end = p + desc_list_len;\n        if (desc_list_end > p_end)\n            break;\n        for(;;) {\n            if (ff_parse_mpeg2_descriptor(ts->stream, st, stream_type, &p, desc_list_end,\n                mp4_descr, mp4_descr_count, pid, ts) < 0)\n                break;\n\n            if (pes && prog_reg_desc == AV_RL32(\"HDMV\") && stream_type == 0x83 && pes->sub_st) {\n                ff_program_add_stream_index(ts->stream, h->id, pes->sub_st->index);\n                pes->sub_st->codec->codec_tag = st->codec->codec_tag;\n            }\n        }\n        p = desc_list_end;\n    }\n\n out:\n    for (i = 0; i < mp4_descr_count; i++)\n        av_free(mp4_descr[i].dec_config_descr);\n}", "before_change_lines": [102], "raw_before_change_lines": [102], "after_change_lines": [102], "raw_after_change_lines": [102], "bug_lines": [102], "added": [false], "idx": 310}
{"project": "libav", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9180----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fc712d8d23389edfebbaabdd108d173157eb1489_1.json----jpeg2000_decode_packets", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_fc712d8d23389edfebbaabdd108d173157eb1489_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fc712d8d23389edfebbaabdd108d173157eb1489_1.json", "function_name": "jpeg2000_decode_packets", "vul_func_code": "static int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int layno, reslevelno, compno, precno, ok_reslevel, ret;\n    uint8_t prog_order = tile->codsty[0].prog_order;\n    uint16_t x;\n    uint16_t y;\n\n    s->bit_index = 8;\n    switch (prog_order) {\n    case JPEG2000_PGOD_LRCP:\n        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n            ok_reslevel = 1;\n            for (reslevelno = 0; ok_reslevel; reslevelno++) {\n                ok_reslevel = 0;\n                for (compno = 0; compno < s->ncomponents; compno++) {\n                    Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n                    Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n                    if (reslevelno < codsty->nreslevels) {\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +\n                                                   reslevelno;\n                        ok_reslevel = 1;\n                        for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)\n                            if ((ret = jpeg2000_decode_packet(s,\n                                                              codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_CPRL:\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n\n            /* Set bit stream buffer address according to tile-part.\n             * For DCinema one tile-part per component, so can be\n             * indexed by component. */\n            s->g = tile->tile_part[compno].tpg;\n\n            /* Position loop (y axis)\n             * TODO: Automate computing of step 256.\n             * Fixed here, but to be computed before entering here. */\n            for (y = 0; y < s->height; y += 256) {\n                /* Position loop (y axis)\n                 * TODO: automate computing of step 256.\n                 * Fixed here, but to be computed before entering here. */\n                for (x = 0; x < s->width; x += 256) {\n                    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n                        uint16_t prcx, prcy;\n                        uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;\n\n                        if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||\n                              (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||\n                              (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        // check if a precinct exists\n                        prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;\n                        prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;\n                        precno = prcx + rlevel->num_precincts_x * prcy;\n                        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n                            if ((ret = jpeg2000_decode_packet(s, codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                        }\n                    }\n                }\n            }\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    /* EOC marker reached */\n    bytestream2_skip(&s->g, 2);\n\n    return 0;\n}", "patch_func_code": "static int jpeg2000_decode_packets(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)\n{\n    int ret = 0;\n    int layno, reslevelno, compno, precno, ok_reslevel;\n    int x, y;\n\n    s->bit_index = 8;\n    switch (tile->codsty[0].prog_order) {\n    case JPEG2000_PGOD_LRCP:\n        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n            ok_reslevel = 1;\n            for (reslevelno = 0; ok_reslevel; reslevelno++) {\n                ok_reslevel = 0;\n                for (compno = 0; compno < s->ncomponents; compno++) {\n                    Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n                    Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n                    if (reslevelno < codsty->nreslevels) {\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel +\n                                                   reslevelno;\n                        ok_reslevel = 1;\n                        for (precno = 0; precno < rlevel->num_precincts_x * rlevel->num_precincts_y; precno++)\n                            if ((ret = jpeg2000_decode_packet(s,\n                                                              codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_CPRL:\n        for (compno = 0; compno < s->ncomponents; compno++) {\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n            Jpeg2000QuantStyle *qntsty  = tile->qntsty + compno;\n\n            /* Set bit stream buffer address according to tile-part.\n             * For DCinema one tile-part per component, so can be\n             * indexed by component. */\n            s->g = tile->tile_part[compno].tpg;\n\n            /* Position loop (y axis)\n             * TODO: Automate computing of step 256.\n             * Fixed here, but to be computed before entering here. */\n            for (y = 0; y < s->height; y += 256) {\n                /* Position loop (y axis)\n                 * TODO: automate computing of step 256.\n                 * Fixed here, but to be computed before entering here. */\n                for (x = 0; x < s->width; x += 256) {\n                    for (reslevelno = 0; reslevelno < codsty->nreslevels; reslevelno++) {\n                        uint16_t prcx, prcy;\n                        uint8_t reducedresno = codsty->nreslevels - 1 -reslevelno; //  ==> N_L - r\n                        Jpeg2000ResLevel *rlevel = tile->comp[compno].reslevel + reslevelno;\n\n                        if (!((y % (1 << (rlevel->log2_prec_height + reducedresno)) == 0) ||\n                              (y == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        if (!((x % (1 << (rlevel->log2_prec_width + reducedresno)) == 0) ||\n                              (x == 0))) // TODO: 2nd condition simplified as try0 always =0 for dcinema\n                            continue;\n\n                        // check if a precinct exists\n                        prcx   = ff_jpeg2000_ceildivpow2(x, reducedresno) >> rlevel->log2_prec_width;\n                        prcy   = ff_jpeg2000_ceildivpow2(y, reducedresno) >> rlevel->log2_prec_height;\n                        precno = prcx + rlevel->num_precincts_x * prcy;\n                        for (layno = 0; layno < tile->codsty[0].nlayers; layno++) {\n                            if ((ret = jpeg2000_decode_packet(s, codsty, rlevel,\n                                                              precno, layno,\n                                                              qntsty->expn + (reslevelno ? 3 * (reslevelno - 1) + 1 : 0),\n                                                              qntsty->nguardbits)) < 0)\n                                return ret;\n                        }\n                    }\n                }\n            }\n        }\n        break;\n\n    case JPEG2000_PGOD_RLCP:\n        avpriv_request_sample(s->avctx, \"Progression order RLCP\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    case JPEG2000_PGOD_RPCL:\n        avpriv_request_sample(s->avctx, \"Progression order RPCL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    case JPEG2000_PGOD_PCRL:\n        avpriv_request_sample(s->avctx, \"Progression order PCRL\");\n        ret = AVERROR_PATCHWELCOME;\n        break;\n\n    default:\n        break;\n    }\n\n    /* EOC marker reached */\n    bytestream2_skip(&s->g, 2);\n\n    return ret;\n}", "before_change_lines": [3, 4, 5, 6, 9, 90], "raw_before_change_lines": [3, 4, 5, 6, 9, 90], "after_change_lines": [3, 4, 5, 8, 82, 83, 84, 85, 87, 88, 89, 90, 92, 93, 94, 95, 104], "raw_after_change_lines": [3, 4, 5, 8, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 104], "bug_lines": [3, 4, 5, 6, 9, 90], "added": [false, false, false, false, false, false], "idx": 311}
{"project": "libav", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "9200----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fd35adafef2a16eb21f928ee5a058137470ec2e3_1.json----sws_alloc_context", "patch_filepath": "G:/smm_data/D2A_dataset/libav/d2a/after_fix/libav_fd35adafef2a16eb21f928ee5a058137470ec2e3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libav/d2a/before_fix/libav_fd35adafef2a16eb21f928ee5a058137470ec2e3_1.json", "function_name": "sws_alloc_context", "vul_func_code": "SwsContext *sws_alloc_context(void)\n{\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n    c->av_class = &sws_context_class;\n    av_opt_set_defaults(c);\n\n    return c;\n}", "patch_func_code": "SwsContext *sws_alloc_context(void)\n{\n    SwsContext *c = av_mallocz(sizeof(SwsContext));\n\n    if (c) {\n        c->av_class = &sws_context_class;\n        av_opt_set_defaults(c);\n    }\n\n    return c;\n}", "before_change_lines": [5, 6], "raw_before_change_lines": [5, 6], "after_change_lines": [5, 6, 7, 8], "raw_after_change_lines": [5, 6, 7, 8], "bug_lines": [5, 6], "added": [false, false], "idx": 312}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9241----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_004888c8312af55699e6ca080f496ba9a08891c3_1.json----_TIFFCheckRealloc", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_004888c8312af55699e6ca080f496ba9a08891c3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_004888c8312af55699e6ca080f496ba9a08891c3_1.json", "function_name": "_TIFFCheckRealloc", "vul_func_code": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n\ttmsize_t bytes = nmemb * elem_size;\n\n\t/*\n\t * XXX: Check for integer overflow.\n\t */\n\tif (nmemb && elem_size && bytes / elem_size == nmemb)\n\t\tcp = _TIFFrealloc(buffer, bytes);\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}", "patch_func_code": "void*\n_TIFFCheckRealloc(TIFF* tif, void* buffer,\n\t\t  tmsize_t nmemb, tmsize_t elem_size, const char* what)\n{\n\tvoid* cp = NULL;\n        tmsize_t count = _TIFFMultiplySSize(tif, nmemb, elem_size, NULL);\n\t/*\n\t * Check for integer overflow.\n\t */\n\tif (count != 0)\n\t{\n\t\tcp = _TIFFrealloc(buffer, count);\n\t}\n\n\tif (cp == NULL) {\n\t\tTIFFErrorExt(tif->tif_clientdata, tif->tif_name,\n\t\t\t     \"Failed to allocate memory for %s \"\n\t\t\t     \"(%ld elements of %ld bytes each)\",\n\t\t\t     what,(long) nmemb, (long) elem_size);\n\t}\n\n\treturn cp;\n}", "before_change_lines": [6, 9, 11, 12], "raw_before_change_lines": [6, 7, 9, 11, 12], "after_change_lines": [6, 8, 10, 11, 12, 13], "raw_after_change_lines": [6, 8, 10, 11, 12, 13], "bug_lines": [6, 7, 9, 11, 12], "added": [false, false, false, false, false], "idx": 313}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9243----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_0050b58a796d2d103174eafa6406837e6692556f_1.json----TIFFFillTile", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_0050b58a796d2d103174eafa6406837e6692556f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_0050b58a796d2d103174eafa6406837e6692556f_1.json", "function_name": "TIFFFillTile", "vul_func_code": "int\nTIFFFillTile(TIFF* tif, uint32 tile)\n{\n\tstatic const char module[] = \"TIFFFillTile\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = TIFFGetStrileByteCount(tif, tile);\n\t\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%I64u: Invalid tile byte count, tile %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) tile);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%llu: Invalid tile byte count, tile %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) tile);\n#endif\n\t\t\treturn (0);\n\t\t}\n\n\t\t/* To avoid excessive memory allocations: */\n\t\t/* Byte count should normally not be larger than a number of */\n\t\t/* times the uncompressed size plus some margin */\n                if( bytecount > 1024 * 1024 )\n                {\n\t\t\t/* 10 and 4096 are just values that could be adjusted. */\n\t\t\t/* Hopefully they are safe enough for all codecs */\n\t\t\ttmsize_t stripsize = TIFFTileSize(tif);\n\t\t\tif( stripsize != 0 &&\n\t\t\t    (bytecount - 4096) / 10 > (uint64)stripsize  )\n\t\t\t{\n\t\t\t\tuint64 newbytecount = (uint64)stripsize * 10 + 4096;\n\t\t\t\tif( (int64)newbytecount >= 0 )\n\t\t\t\t{\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large tile byte count %I64u, tile %lu. Limiting to %I64u\",\n\t\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t\t     (unsigned long) tile,\n\t\t\t\t\t     (unsigned __int64) newbytecount);\n#else\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large tile byte count %llu, tile %lu. Limiting to %llu\",\n\t\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t\t     (unsigned long) tile,\n\t\t\t\t\t     (unsigned long long) newbytecount);\n#endif\n\t\t\t\t\tbytecount = newbytecount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif)) {\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  TIFFGetStrileOffset(tif, tile)+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    TIFFGetStrileOffset(tif, tile) > (uint64)tif->tif_size - bytecount) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t     || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata =\n\t\t\t\ttif->tif_base + (tmsize_t)TIFFGetStrileOffset(tif, tile);\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * tile coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold tile %lu\",\n\t\t\t\t\t    (unsigned long) tile);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t\ttif->tif_flags &= ~TIFF_BUFFERMMAP;\n\t\t\t}\n\n\t\t\tif( isMapped(tif) )\n\t\t\t{\n\t\t\t\tif (bytecountm > tif->tif_rawdatasize &&\n\t\t\t\t    !TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (TIFFReadRawTile1(tif, tile, tif->tif_rawdata,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TIFFReadRawStripOrTile2(tif, tile, 0,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (tif->tif_rawdata != NULL &&\n                            !isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata,\n                                                tif->tif_rawdataloaded);\n\t\t}\n\t}\n\treturn (TIFFStartTile(tif, tile));\n}", "patch_func_code": "int\nTIFFFillTile(TIFF* tif, uint32 tile)\n{\n\tstatic const char module[] = \"TIFFFillTile\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tif ((tif->tif_flags&TIFF_NOREADRAW)==0)\n\t{\n\t\tuint64 bytecount = TIFFGetStrileByteCount(tif, tile);\n\t\tif( bytecount == 0 || bytecount > (uint64)TIFF_INT64_MAX ) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%I64u: Invalid tile byte count, tile %lu\",\n\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t     (unsigned long) tile);\n#else\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\"%llu: Invalid tile byte count, tile %lu\",\n\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t     (unsigned long) tile);\n#endif\n\t\t\treturn (0);\n\t\t}\n\n\t\t/* To avoid excessive memory allocations: */\n\t\t/* Byte count should normally not be larger than a number of */\n\t\t/* times the uncompressed size plus some margin */\n                if( bytecount > 1024 * 1024 )\n                {\n\t\t\t/* 10 and 4096 are just values that could be adjusted. */\n\t\t\t/* Hopefully they are safe enough for all codecs */\n\t\t\ttmsize_t stripsize = TIFFTileSize(tif);\n\t\t\tif( stripsize != 0 &&\n\t\t\t    (bytecount - 4096) / 10 > (uint64)stripsize  )\n\t\t\t{\n\t\t\t\tuint64 newbytecount = (uint64)stripsize * 10 + 4096;\n\t\t\t\tif( newbytecount == 0 || newbytecount > (uint64)TIFF_INT64_MAX )\n\t\t\t\t{\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\t\t\tTIFFWarningExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large tile byte count %I64u, tile %lu. Limiting to %I64u\",\n\t\t\t\t\t     (unsigned __int64) bytecount,\n\t\t\t\t\t     (unsigned long) tile,\n\t\t\t\t\t     (unsigned __int64) newbytecount);\n#else\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t  \"Too large tile byte count %llu, tile %lu. Limiting to %llu\",\n\t\t\t\t\t     (unsigned long long) bytecount,\n\t\t\t\t\t     (unsigned long) tile,\n\t\t\t\t\t     (unsigned long long) newbytecount);\n#endif\n\t\t\t\t\tbytecount = newbytecount;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif)) {\n\t\t\t/*\n\t\t\t * We must check for overflow, potentially causing\n\t\t\t * an OOB read. Instead of simple\n\t\t\t *\n\t\t\t *  TIFFGetStrileOffset(tif, tile)+bytecount > tif->tif_size\n\t\t\t *\n\t\t\t * comparison (which can overflow) we do the following\n\t\t\t * two comparisons:\n\t\t\t */\n\t\t\tif (bytecount > (uint64)tif->tif_size ||\n\t\t\t    TIFFGetStrileOffset(tif, tile) > (uint64)tif->tif_size - bytecount) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\n\t\tif (isMapped(tif) &&\n\t\t    (isFillOrder(tif, td->td_fillorder)\n\t\t     || (tif->tif_flags & TIFF_NOBITREV))) {\n\t\t\t/*\n\t\t\t * The image is mapped into memory and we either don't\n\t\t\t * need to flip bits or the compression routine is\n\t\t\t * going to handle this operation itself.  In this\n\t\t\t * case, avoid copying the raw data and instead just\n\t\t\t * reference the data from the memory mapped file\n\t\t\t * image.  This assumes that the decompression\n\t\t\t * routines do not modify the contents of the raw data\n\t\t\t * buffer (if they try to, the application will get a\n\t\t\t * fault since the file is mapped read-only).\n\t\t\t */\n\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata) {\n\t\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t}\n\t\t\ttif->tif_flags &= ~TIFF_MYBUFFER;\n\n\t\t\ttif->tif_rawdatasize = (tmsize_t)bytecount;\n\t\t\ttif->tif_rawdata =\n\t\t\t\ttif->tif_base + (tmsize_t)TIFFGetStrileOffset(tif, tile);\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = (tmsize_t) bytecount;\n\t\t\ttif->tif_flags |= TIFF_BUFFERMMAP;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Expand raw data buffer, if needed, to hold data\n\t\t\t * tile coming from file (perhaps should set upper\n\t\t\t * bound on the size of a buffer we'll use?).\n\t\t\t */\n\t\t\ttmsize_t bytecountm;\n\t\t\tbytecountm=(tmsize_t)bytecount;\n\t\t\tif ((uint64)bytecountm!=bytecount)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (bytecountm > tif->tif_rawdatasize) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\tif ((tif->tif_flags & TIFF_MYBUFFER) == 0) {\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t\t    \"Data buffer too small to hold tile %lu\",\n\t\t\t\t\t    (unsigned long) tile);\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tif->tif_flags&TIFF_BUFFERMMAP) {\n\t\t\t\ttif->tif_curtile = NOTILE;\n\t\t\t\ttif->tif_rawdata = NULL;\n\t\t\t\ttif->tif_rawdatasize = 0;\n\t\t\t\ttif->tif_flags &= ~TIFF_BUFFERMMAP;\n\t\t\t}\n\n\t\t\tif( isMapped(tif) )\n\t\t\t{\n\t\t\t\tif (bytecountm > tif->tif_rawdatasize &&\n\t\t\t\t    !TIFFReadBufferSetup(tif, 0, bytecountm))\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t\tif (TIFFReadRawTile1(tif, tile, tif->tif_rawdata,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (TIFFReadRawStripOrTile2(tif, tile, 0,\n\t\t\t\t    bytecountm, module) != bytecountm)\n\t\t\t\t{\n\t\t\t\t\treturn (0);\n\t\t\t\t}\n\t\t\t}\n\n\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = bytecountm;\n                        \n\t\t\tif (tif->tif_rawdata != NULL &&\n                            !isFillOrder(tif, td->td_fillorder) &&\n\t\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\t\tTIFFReverseBits(tif->tif_rawdata,\n                                                tif->tif_rawdataloaded);\n\t\t}\n\t}\n\treturn (TIFFStartTile(tif, tile));\n}", "before_change_lines": [10, 37], "raw_before_change_lines": [10, 37], "after_change_lines": [10, 37], "raw_after_change_lines": [10, 37], "bug_lines": [10, 37], "added": [false, false], "idx": 314}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9288----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_1340d006666c194aafb4065eb48bc918c4a820fe_1.json----TIFFVStripSize", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_1340d006666c194aafb4065eb48bc918c4a820fe_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_1340d006666c194aafb4065eb48bc918c4a820fe_1.json", "function_name": "TIFFVStripSize", "vul_func_code": "tmsize_t\nTIFFVStripSize(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFVStripSize64(tif,nrows);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}", "patch_func_code": "tmsize_t\nTIFFVStripSize(TIFF* tif, uint32 nrows)\n{\n\tstatic const char module[] = \"TIFFVStripSize\";\n\tuint64 m;\n\tm=TIFFVStripSize64(tif,nrows);\n        return _TIFFCastUInt64ToSSize(tif, m, module);\n}", "before_change_lines": [6, 8, 9, 10, 11, 12, 13, 14], "raw_before_change_lines": [6, 8, 9, 10, 11, 12, 13, 14], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [6, 8, 9, 10, 11, 12, 13, 14], "added": [false, false, false, false, false, false, false, false], "idx": 315}
{"project": "libtiff", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "9299----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_17879c080cc0011b48d2e921ff7bc5a8b13c9919_1.json----TIFFScanlineSize", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_17879c080cc0011b48d2e921ff7bc5a8b13c9919_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_17879c080cc0011b48d2e921ff7bc5a8b13c9919_1.json", "function_name": "TIFFScanlineSize", "vul_func_code": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Integer arithmetic overflow\");\n\t\tn=0;\n\t}\n\treturn(n);\n}", "patch_func_code": "tmsize_t\nTIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"TIFFScanlineSize\";\n\tuint64 m;\n\tm=TIFFScanlineSize64(tif);\n\treturn _TIFFCastUInt64ToSSize(tif, m, module);\n}", "before_change_lines": [6, 8, 9, 10, 11, 12, 13], "raw_before_change_lines": [6, 8, 9, 10, 11, 12, 13], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [6, 8, 9, 10, 11, 12, 13], "added": [false, false, false, false, false, false, false], "idx": 316}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9308----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_1ae02def4133e470d92cdea055339ab0566fceae_1.json----TIFF_WriteOverview", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_1ae02def4133e470d92cdea055339ab0566fceae_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_1ae02def4133e470d92cdea055339ab0566fceae_1.json", "function_name": "TIFF_WriteOverview", "vul_func_code": "uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat,\n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int bUseSubIFDs,\n                           int nHorSubsampling, int nVerSubsampling )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n\n    (void) bUseSubIFDs;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling);\n        /* TODO: also write YCbCrPositioning and YCbCrCoefficients tag identical to source IFD */\n    }\n    /* TODO: add command-line parameter for selecting jpeg compression quality\n     * that gets ignored when compression isn't jpeg */\n\n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"TIFFBuildOverviews\" ) == 0 )\n        return 0;\n\n    TIFFWriteDirectory( hTIFF );\n    TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}", "patch_func_code": "uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize,\n                           int nBitsPerPixel, int nPlanarConfig, int nSamples, \n                           int nBlockXSize, int nBlockYSize,\n                           int bTiled, int nCompressFlag, int nPhotometric,\n                           int nSampleFormat,\n                           unsigned short *panRed,\n                           unsigned short *panGreen,\n                           unsigned short *panBlue,\n                           int bUseSubIFDs,\n                           int nHorSubsampling, int nVerSubsampling )\n\n{\n    toff_t\tnBaseDirOffset;\n    toff_t\tnOffset;\n    tdir_t\tiNumDir;\n\n    (void) bUseSubIFDs;\n\n    nBaseDirOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFCreateDirectory( hTIFF );\n\n/* -------------------------------------------------------------------- */\n/*      Setup TIFF fields.                                              */\n/* -------------------------------------------------------------------- */\n    TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize );\n    TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize );\n    if( nSamples == 1 )\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG );\n    else\n        TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig );\n\n    TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples );\n    TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag );\n    TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric );\n    TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat );\n\n    if( bTiled )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize );\n        TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize );\n    }\n    else\n        TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize );\n\n    TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE );\n\n    if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling);\n        /* TODO: also write YCbCrPositioning and YCbCrCoefficients tag identical to source IFD */\n    }\n    /* TODO: add command-line parameter for selecting jpeg compression quality\n     * that gets ignored when compression isn't jpeg */\n\n/* -------------------------------------------------------------------- */\n/*\tWrite color table if one is present.\t\t\t\t*/\n/* -------------------------------------------------------------------- */\n    if( panRed != NULL )\n    {\n        TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue );\n    }\n\n/* -------------------------------------------------------------------- */\n/*      Write directory, and return byte offset.                        */\n/* -------------------------------------------------------------------- */\n    if( TIFFWriteCheck( hTIFF, bTiled, \"TIFFBuildOverviews\" ) == 0 )\n        return 0;\n\n    TIFFWriteDirectory( hTIFF );\n    iNumDir = TIFFNumberOfDirectories(hTIFF);\n    if( iNumDir > TIFF_DIR_MAX )\n    {\n        TIFFErrorExt( TIFFClientdata(hTIFF),\n                      \"TIFF_WriteOverview\",\n                      \"File `%s' has too many directories.\\n\",\n                      TIFFFileName(hTIFF) );\n        exit(-1);\n    }\n    TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );\n\n    nOffset = TIFFCurrentDirOffset( hTIFF );\n\n    TIFFSetSubDirectory( hTIFF, nBaseDirOffset );\n\n    return nOffset;\n}", "before_change_lines": [71], "raw_before_change_lines": [71], "after_change_lines": [15, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81], "raw_after_change_lines": [15, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81], "bug_lines": [71], "added": [false], "idx": 317}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9324----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_2009d201808b1157aeecc5c6bf454cccce991338_1.json----EstimateStripByteCounts", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_2009d201808b1157aeecc5c6bf454cccce991338_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_2009d201808b1157aeecc5c6bf454cccce991338_1.json", "function_name": "EstimateStripByteCounts", "vul_func_code": "static int\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"EstimateStripByteCounts\";\n\n\tTIFFDirEntry *dp;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n    /* Do not try to load stripbytecount as we will compute it */\n        if( !_TIFFFillStrilesInternal( tif, 0 ) )\n            return -1;\n\n\tif (td->td_stripbytecount)\n\t\t_TIFFfree(td->td_stripbytecount);\n\ttd->td_stripbytecount = (uint64*)\n\t    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n        if( td->td_stripbytecount == NULL )\n            return -1;\n\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint64 space;\n\t\tuint64 filesize;\n\t\tuint16 n;\n\t\tfilesize = TIFFGetFileSize(tif);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tspace=sizeof(TIFFHeaderClassic)+2+dircount*12+4;\n\t\telse\n\t\t\tspace=sizeof(TIFFHeaderBig)+8+dircount*20+8;\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++)\n\t\t{\n\t\t\tuint32 typewidth;\n\t\t\tuint64 datasize;\n\t\t\ttypewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type);\n\t\t\tif (typewidth == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Cannot determine size of unknown tag type %d\",\n\t\t\t\t    dp->tdir_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdatasize=(uint64)typewidth*dp->tdir_count;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tif (datasize<=4)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (datasize<=8)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\tspace+=datasize;\n\t\t}\n\t\tif( filesize < space )\n                    /* we should perhaps return in error ? */\n                    space = filesize;\n                else\n                    space = filesize - space;\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\t\tspace /= td->td_samplesperpixel;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */\n\t\tstrip--;\n\t\tif (td->td_stripoffset[strip]+td->td_stripbytecount[strip] > filesize)\n\t\t\ttd->td_stripbytecount[strip] = filesize - td->td_stripoffset[strip];\n\t} else if (isTiled(tif)) {\n\t\tuint64 bytespertile = TIFFTileSize64(tif);\n\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t    td->td_stripbytecount[strip] = bytespertile;\n\t} else {\n\t\tuint64 rowbytes = TIFFScanlineSize64(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount[strip] = rowbytes * rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n\treturn 1;\n}", "patch_func_code": "static int\nEstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)\n{\n\tstatic const char module[] = \"EstimateStripByteCounts\";\n\n\tTIFFDirEntry *dp;\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 strip;\n\n    /* Do not try to load stripbytecount as we will compute it */\n        if( !_TIFFFillStrilesInternal( tif, 0 ) )\n            return -1;\n\n\tif (td->td_stripbytecount_p)\n\t\t_TIFFfree(td->td_stripbytecount_p);\n\ttd->td_stripbytecount_p = (uint64*)\n\t    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),\n\t\t\"for \\\"StripByteCounts\\\" array\");\n        if( td->td_stripbytecount_p == NULL )\n            return -1;\n\n\tif (td->td_compression != COMPRESSION_NONE) {\n\t\tuint64 space;\n\t\tuint64 filesize;\n\t\tuint16 n;\n\t\tfilesize = TIFFGetFileSize(tif);\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tspace=sizeof(TIFFHeaderClassic)+2+dircount*12+4;\n\t\telse\n\t\t\tspace=sizeof(TIFFHeaderBig)+8+dircount*20+8;\n\t\t/* calculate amount of space used by indirect values */\n\t\tfor (dp = dir, n = dircount; n > 0; n--, dp++)\n\t\t{\n\t\t\tuint32 typewidth;\n\t\t\tuint64 datasize;\n\t\t\ttypewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type);\n\t\t\tif (typewidth == 0) {\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\t    \"Cannot determine size of unknown tag type %d\",\n\t\t\t\t    dp->tdir_type);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tdatasize=(uint64)typewidth*dp->tdir_count;\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t{\n\t\t\t\tif (datasize<=4)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (datasize<=8)\n\t\t\t\t\tdatasize=0;\n\t\t\t}\n\t\t\tspace+=datasize;\n\t\t}\n\t\tif( filesize < space )\n                    /* we should perhaps return in error ? */\n                    space = filesize;\n                else\n                    space = filesize - space;\n\t\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\t\tspace /= td->td_samplesperpixel;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount_p[strip] = space;\n\t\t/*\n\t\t * This gross hack handles the case were the offset to\n\t\t * the last strip is past the place where we think the strip\n\t\t * should begin.  Since a strip of data must be contiguous,\n\t\t * it's safe to assume that we've overestimated the amount\n\t\t * of data in the strip and trim this number back accordingly.\n\t\t */\n\t\tstrip--;\n\t\tif (td->td_stripoffset_p[strip]+td->td_stripbytecount_p[strip] > filesize)\n\t\t\ttd->td_stripbytecount_p[strip] = filesize - td->td_stripoffset_p[strip];\n\t} else if (isTiled(tif)) {\n\t\tuint64 bytespertile = TIFFTileSize64(tif);\n\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t    td->td_stripbytecount_p[strip] = bytespertile;\n\t} else {\n\t\tuint64 rowbytes = TIFFScanlineSize64(tif);\n\t\tuint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;\n\t\tfor (strip = 0; strip < td->td_nstrips; strip++)\n\t\t\ttd->td_stripbytecount_p[strip] = rowbytes * rowsperstrip;\n\t}\n\tTIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);\n\tif (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))\n\t\ttd->td_rowsperstrip = td->td_imagelength;\n\treturn 1;\n}", "before_change_lines": [14, 15, 16, 19, 64, 73, 74, 79, 84], "raw_before_change_lines": [14, 15, 16, 19, 64, 73, 74, 79, 84], "after_change_lines": [14, 15, 16, 19, 64, 73, 74, 79, 84], "raw_after_change_lines": [14, 15, 16, 19, 64, 73, 74, 79, 84], "bug_lines": [14, 15, 16, 19, 64, 73, 74, 79, 84], "added": [false, false, false, false, false, false, false, false, false], "idx": 318}
{"project": "libtiff", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "9370----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_32b1dded7ee035829932aa62ad880d1103081c7d_1.json----TIFFWriteDirectorySec", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_32b1dded7ee035829932aa62ad880d1103081c7d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_32b1dded7ee035829932aa62ad880d1103081c7d_1.json", "function_name": "TIFFWriteDirectorySec", "vul_func_code": "static int\nTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)\n{\n\tstatic const char module[] = \"TIFFWriteDirectorySec\";\n\tuint32 ndir;\n\tTIFFDirEntry* dir;\n\tuint32 dirsize;\n\tvoid* dirmem;\n\tuint32 m;\n\tif (tif->tif_mode == O_RDONLY)\n\t\treturn (1);\n\n        _TIFFFillStriles( tif );\n        \n\t/*\n\t * Clear write state so that subsequent images with\n\t * different characteristics get the right buffers\n\t * setup for them.\n\t */\n\tif (imagedone)\n\t{\n\t\tif (tif->tif_flags & TIFF_POSTENCODE)\n\t\t{\n\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Error post-encoding before directory write\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t(*tif->tif_close)(tif);       /* shutdown encoder */\n\t\t/*\n\t\t * Flush any data that might have been written\n\t\t * by the compression close+cleanup routines.  But\n                 * be careful not to write stuff if we didn't add data\n                 * in the previous steps as the \"rawcc\" data may well be\n                 * a previously read tile/strip in mixed read/write mode.\n\t\t */\n\t\tif (tif->tif_rawcc > 0 \n\t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\n\t\t{\n\t\t    if( !TIFFFlushData1(tif) )\n                    {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Error flushing data before directory write\");\n\t\t\treturn (0);\n                    }\n\t\t}\n\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\n\t\t{\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_rawdata = NULL;\n\t\t\ttif->tif_rawcc = 0;\n\t\t\ttif->tif_rawdatasize = 0;\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = 0;\n\t\t}\n\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\n\t}\n\tdir=NULL;\n\tdirmem=NULL;\n\tdirsize=0;\n\twhile (1)\n\t{\n\t\tndir=0;\n\t\tif (isimage)\n\t\t{\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    /* td_stripoffset might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http://bugzilla.maptools.org/show_bug.cgi?id=2500\n                    */\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\n\t\t\t{\n\t\t\t\tif (tif->tif_dir.td_extrasamples)\n\t\t\t\t{\n\t\t\t\t\tuint16 na;\n\t\t\t\t\tuint16* nb;\n\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint32 n;\n\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\n\t\t\t\t\tconst TIFFField* o;\n\t\t\t\t\to = tif->tif_fields[n];\n\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (o->get_field_type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tchar* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\n\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint16 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tvoid* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\t\t            \"Cannot write tag %d (%s)\",\n\t\t\t\t\t\t\t\t            TIFFFieldTag(o),\n                                                                            o->field_name ? o->field_name : \"unknown\");\n\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\n\t\t{\n                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;\n                        uint32 count = tif->tif_dir.td_customValues[m].count;\n\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\n\t\t\t{\n\t\t\t\tcase TIFF_ASCII:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dir!=NULL)\n\t\t\tbreak;\n\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\n\t\tif (dir==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (isimage)\n\t\t{\n\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse\n\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\n\t\tif (pdiroff!=NULL)\n\t\t\t*pdiroff=tif->tif_diroff;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tdirsize=2+ndir*12+4;\n\t\telse\n\t\t\tdirsize=8+ndir*20+8;\n\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\n\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (isimage)\n\t\t\ttif->tif_curdir++;\n\t}\n\tif (isimage)\n\t{\n\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\n\t\t{\n\t\t\tuint32 na;\n\t\t\tTIFFDirEntry* nb;\n\t\t\tfor (na=0, nb=dir; ; na++, nb++)\n\t\t\t{\n\t\t\t\tif( na == ndir )\n                                {\n                                    TIFFErrorExt(tif->tif_clientdata,module,\n                                                 \"Cannot find SubIFD tag\");\n                                    goto bad;\n                                }\n\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\n\t\t\telse\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\n\t\t}\n\t}\n\tdirmem=_TIFFmalloc(dirsize);\n\tif (dirmem==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\tgoto bad;\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint8* n;\n\t\tuint32 nTmp;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint16*)n=(uint16)ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)n);\n\t\tn+=2;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\tnTmp = (uint32)o->tdir_count;\n\t\t\t_TIFFmemcpy(n,&nTmp,4);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)n);\n\t\t\tn+=4;\n\t\t\t/* This is correct. The data has been */\n\t\t\t/* swabbed previously in TIFFWriteDirectoryTagData */\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\n\t\t\tn+=4;\n\t\t\to++;\n\t\t}\n\t\tnTmp = (uint32)tif->tif_nextdiroff;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nTmp);\n\t\t_TIFFmemcpy(n,&nTmp,4);\n\t}\n\telse\n\t{\n\t\tuint8* n;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint64*)n=ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t\tn+=8;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)n);\n\t\t\tn+=8;\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\n\t\t\tn+=8;\n\t\t\to++;\n\t\t}\n\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t}\n\t_TIFFfree(dir);\n\tdir=NULL;\n\tif (!SeekOK(tif,tif->tif_diroff))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\t_TIFFfree(dirmem);\n\tif (imagedone)\n\t{\n\t\tTIFFFreeDirectory(tif);\n\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\t\t(*tif->tif_cleanup)(tif);\n\t\t/*\n\t\t* Reset directory-related state for subsequent\n\t\t* directories.\n\t\t*/\n\t\tTIFFCreateDirectory(tif);\n\t}\n\treturn(1);\nbad:\n\tif (dir!=NULL)\n\t\t_TIFFfree(dir);\n\tif (dirmem!=NULL)\n\t\t_TIFFfree(dirmem);\n\treturn(0);\n}", "patch_func_code": "static int\nTIFFWriteDirectorySec(TIFF* tif, int isimage, int imagedone, uint64* pdiroff)\n{\n\tstatic const char module[] = \"TIFFWriteDirectorySec\";\n\tuint32 ndir;\n\tTIFFDirEntry* dir;\n\tuint32 dirsize;\n\tvoid* dirmem;\n\tuint32 m;\n\tif (tif->tif_mode == O_RDONLY)\n\t\treturn (1);\n\n        _TIFFFillStriles( tif );\n        \n\t/*\n\t * Clear write state so that subsequent images with\n\t * different characteristics get the right buffers\n\t * setup for them.\n\t */\n\tif (imagedone)\n\t{\n\t\tif (tif->tif_flags & TIFF_POSTENCODE)\n\t\t{\n\t\t\ttif->tif_flags &= ~TIFF_POSTENCODE;\n\t\t\tif (!(*tif->tif_postencode)(tif))\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t    \"Error post-encoding before directory write\");\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t}\n\t\t(*tif->tif_close)(tif);       /* shutdown encoder */\n\t\t/*\n\t\t * Flush any data that might have been written\n\t\t * by the compression close+cleanup routines.  But\n                 * be careful not to write stuff if we didn't add data\n                 * in the previous steps as the \"rawcc\" data may well be\n                 * a previously read tile/strip in mixed read/write mode.\n\t\t */\n\t\tif (tif->tif_rawcc > 0 \n\t\t    && (tif->tif_flags & TIFF_BEENWRITING) != 0 )\n\t\t{\n\t\t    if( !TIFFFlushData1(tif) )\n                    {\n\t\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t    \"Error flushing data before directory write\");\n\t\t\treturn (0);\n                    }\n\t\t}\n\t\tif ((tif->tif_flags & TIFF_MYBUFFER) && tif->tif_rawdata)\n\t\t{\n\t\t\t_TIFFfree(tif->tif_rawdata);\n\t\t\ttif->tif_rawdata = NULL;\n\t\t\ttif->tif_rawcc = 0;\n\t\t\ttif->tif_rawdatasize = 0;\n                        tif->tif_rawdataoff = 0;\n                        tif->tif_rawdataloaded = 0;\n\t\t}\n\t\ttif->tif_flags &= ~(TIFF_BEENWRITING|TIFF_BUFFERSETUP);\n\t}\n\tdir=NULL;\n\tdirmem=NULL;\n\tdirsize=0;\n\twhile (1)\n\t{\n\t\tndir=0;\n\t\tif (isimage)\n\t\t{\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGEWIDTH,tif->tif_dir.td_imagewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_IMAGELENGTH,tif->tif_dir.td_imagelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDIMENSIONS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILEWIDTH,tif->tif_dir.td_tilewidth))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_TILELENGTH,tif->tif_dir.td_tilelength))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XRESOLUTION,tif->tif_dir.td_xresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YRESOLUTION,tif->tif_dir.td_yresolution))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_POSITION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_XPOSITION,tif->tif_dir.td_xposition))\n\t\t\t\t\tgoto bad;\n\t\t\t\tif (!TIFFWriteDirectoryTagRational(tif,&ndir,dir,TIFFTAG_YPOSITION,tif->tif_dir.td_yposition))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBFILETYPE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_SUBFILETYPE,tif->tif_dir.td_subfiletype))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_BITSPERSAMPLE,tif->tif_dir.td_bitspersample))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COMPRESSION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_COMPRESSION,tif->tif_dir.td_compression))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PHOTOMETRIC))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PHOTOMETRIC,tif->tif_dir.td_photometric))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_THRESHHOLDING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_THRESHHOLDING,tif->tif_dir.td_threshholding))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_FILLORDER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_FILLORDER,tif->tif_dir.td_fillorder))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ORIENTATION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_ORIENTATION,tif->tif_dir.td_orientation))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_SAMPLESPERPIXEL,tif->tif_dir.td_samplesperpixel))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortLong(tif,&ndir,dir,TIFFTAG_ROWSPERSTRIP,tif->tif_dir.td_rowsperstrip))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MINSAMPLEVALUE,tif->tif_dir.td_minsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_MAXSAMPLEVALUE,tif->tif_dir.td_maxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PLANARCONFIG))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_PLANARCONFIG,tif->tif_dir.td_planarconfig))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_RESOLUTIONUNIT,tif->tif_dir.td_resolutionunit))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_PAGENUMBER))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_PAGENUMBER,2,&tif->tif_dir.td_pagenumber[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPBYTECOUNTS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount_p))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount_p))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    /* td_stripoffset_p might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http://bugzilla.maptools.org/show_bug.cgi?id=2500\n                    */\n                    if (tif->tif_dir.td_stripoffset_p != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset_p))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset_p))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_EXTRASAMPLES))\n\t\t\t{\n\t\t\t\tif (tif->tif_dir.td_extrasamples)\n\t\t\t\t{\n\t\t\t\t\tuint16 na;\n\t\t\t\t\tuint16* nb;\n\t\t\t\t\tTIFFGetFieldDefaulted(tif,TIFFTAG_EXTRASAMPLES,&na,&nb);\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_EXTRASAMPLES,na,nb))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SAMPLEFORMAT))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortPerSample(tif,&ndir,dir,TIFFTAG_SAMPLEFORMAT,tif->tif_dir.td_sampleformat))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMINSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMINSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_sminsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SMAXSAMPLEVALUE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSampleformatArray(tif,&ndir,dir,TIFFTAG_SMAXSAMPLEVALUE,tif->tif_dir.td_samplesperpixel,tif->tif_dir.td_smaxsamplevalue))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_IMAGEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_IMAGEDEPTH,tif->tif_dir.td_imagedepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TILEDEPTH))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,TIFFTAG_TILEDEPTH,tif->tif_dir.td_tiledepth))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_HALFTONEHINTS))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_HALFTONEHINTS,2,&tif->tif_dir.td_halftonehints[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRSUBSAMPLING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,TIFFTAG_YCBCRSUBSAMPLING,2,&tif->tif_dir.td_ycbcrsubsampling[0]))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_YCBCRPOSITIONING))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,TIFFTAG_YCBCRPOSITIONING,tif->tif_dir.td_ycbcrpositioning))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_REFBLACKWHITE))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,TIFFTAG_REFERENCEBLACKWHITE,6,tif->tif_dir.td_refblackwhite))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_TRANSFERFUNCTION))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagTransferfunction(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_INKNAMES))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,TIFFTAG_INKNAMES,tif->tif_dir.td_inknameslen,tif->tif_dir.td_inknames))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagSubifd(tif,&ndir,dir))\n\t\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t{\n\t\t\t\tuint32 n;\n\t\t\t\tfor (n=0; n<tif->tif_nfields; n++) {\n\t\t\t\t\tconst TIFFField* o;\n\t\t\t\t\to = tif->tif_fields[n];\n\t\t\t\t\tif ((o->field_bit>=FIELD_CODEC)&&(TIFFFieldSet(tif,o->field_bit)))\n\t\t\t\t\t{\n\t\t\t\t\t\tswitch (o->get_field_type)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TIFF_SETGET_ASCII:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tchar* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_ASCII);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pb);\n\t\t\t\t\t\t\t\t\tpa=(uint32)(strlen(pb));\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT16:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint16 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_SHORT);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagShort(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_UINT32:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 p;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_LONG);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==1);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==0);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&p);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagLong(tif,&ndir,dir,(uint16)o->field_tag,p))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SETGET_C32_UINT8:\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tuint32 pa;\n\t\t\t\t\t\t\t\t\tvoid* pb;\n\t\t\t\t\t\t\t\t\tassert(o->field_type==TIFF_UNDEFINED);\n\t\t\t\t\t\t\t\t\tassert(o->field_readcount==TIFF_VARIABLE2);\n\t\t\t\t\t\t\t\t\tassert(o->field_passcount==1);\n\t\t\t\t\t\t\t\t\tTIFFGetField(tif,o->field_tag,&pa,&pb);\n\t\t\t\t\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,(uint16)o->field_tag,pa,pb))\n\t\t\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t\t\t\t\t\t\t            \"Cannot write tag %d (%s)\",\n\t\t\t\t\t\t\t\t            TIFFFieldTag(o),\n                                                                            o->field_name ? o->field_name : \"unknown\");\n\t\t\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (m=0; m<(uint32)(tif->tif_dir.td_customValueCount); m++)\n\t\t{\n                        uint16 tag = (uint16)tif->tif_dir.td_customValues[m].info->field_tag;\n                        uint32 count = tif->tif_dir.td_customValues[m].count;\n\t\t\tswitch (tif->tif_dir.td_customValues[m].info->field_type)\n\t\t\t{\n\t\t\t\tcase TIFF_ASCII:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagAscii(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagUndefinedArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagByteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSbyteArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagShortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSshortArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlongArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSlong8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagRationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagSrationalArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagFloatArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagDoubleArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdArray(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\tif (!TIFFWriteDirectoryTagIfdIfd8Array(tif,&ndir,dir,tag,count,tif->tif_dir.td_customValues[m].value))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);   /* we should never get here */\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (dir!=NULL)\n\t\t\tbreak;\n\t\tdir=_TIFFmalloc(ndir*sizeof(TIFFDirEntry));\n\t\tif (dir==NULL)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (isimage)\n\t\t{\n\t\t\tif ((tif->tif_diroff==0)&&(!TIFFLinkDirectory(tif)))\n\t\t\t\tgoto bad;\n\t\t}\n\t\telse\n\t\t\ttif->tif_diroff=(TIFFSeekFile(tif,0,SEEK_END)+1)&(~((toff_t)1));\n\t\tif (pdiroff!=NULL)\n\t\t\t*pdiroff=tif->tif_diroff;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\tdirsize=2+ndir*12+4;\n\t\telse\n\t\t\tdirsize=8+ndir*20+8;\n\t\ttif->tif_dataoff=tif->tif_diroff+dirsize;\n\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\ttif->tif_dataoff=(uint32)tif->tif_dataoff;\n\t\tif ((tif->tif_dataoff<tif->tif_diroff)||(tif->tif_dataoff<(uint64)dirsize))\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Maximum TIFF file size exceeded\");\n\t\t\tgoto bad;\n\t\t}\n\t\tif (tif->tif_dataoff&1)\n\t\t\ttif->tif_dataoff++;\n\t\tif (isimage)\n\t\t\ttif->tif_curdir++;\n\t}\n\tif (isimage)\n\t{\n\t\tif (TIFFFieldSet(tif,FIELD_SUBIFD)&&(tif->tif_subifdoff==0))\n\t\t{\n\t\t\tuint32 na;\n\t\t\tTIFFDirEntry* nb;\n\t\t\tfor (na=0, nb=dir; ; na++, nb++)\n\t\t\t{\n\t\t\t\tif( na == ndir )\n                                {\n                                    TIFFErrorExt(tif->tif_clientdata,module,\n                                                 \"Cannot find SubIFD tag\");\n                                    goto bad;\n                                }\n\t\t\t\tif (nb->tdir_tag==TIFFTAG_SUBIFD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+2+na*12+8;\n\t\t\telse\n\t\t\t\ttif->tif_subifdoff=tif->tif_diroff+8+na*20+12;\n\t\t}\n\t}\n\tdirmem=_TIFFmalloc(dirsize);\n\tif (dirmem==NULL)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\tgoto bad;\n\t}\n\tif (!(tif->tif_flags&TIFF_BIGTIFF))\n\t{\n\t\tuint8* n;\n\t\tuint32 nTmp;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint16*)n=(uint16)ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabShort((uint16*)n);\n\t\tn+=2;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\tnTmp = (uint32)o->tdir_count;\n\t\t\t_TIFFmemcpy(n,&nTmp,4);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong((uint32*)n);\n\t\t\tn+=4;\n\t\t\t/* This is correct. The data has been */\n\t\t\t/* swabbed previously in TIFFWriteDirectoryTagData */\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,4);\n\t\t\tn+=4;\n\t\t\to++;\n\t\t}\n\t\tnTmp = (uint32)tif->tif_nextdiroff;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong(&nTmp);\n\t\t_TIFFmemcpy(n,&nTmp,4);\n\t}\n\telse\n\t{\n\t\tuint8* n;\n\t\tTIFFDirEntry* o;\n\t\tn=dirmem;\n\t\t*(uint64*)n=ndir;\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t\tn+=8;\n\t\to=dir;\n\t\tfor (m=0; m<ndir; m++)\n\t\t{\n\t\t\t*(uint16*)n=o->tdir_tag;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t*(uint16*)n=o->tdir_type;\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabShort((uint16*)n);\n\t\t\tn+=2;\n\t\t\t_TIFFmemcpy(n,&o->tdir_count,8);\n\t\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\t\tTIFFSwabLong8((uint64*)n);\n\t\t\tn+=8;\n\t\t\t_TIFFmemcpy(n,&o->tdir_offset,8);\n\t\t\tn+=8;\n\t\t\to++;\n\t\t}\n\t\t_TIFFmemcpy(n,&tif->tif_nextdiroff,8);\n\t\tif (tif->tif_flags&TIFF_SWAB)\n\t\t\tTIFFSwabLong8((uint64*)n);\n\t}\n\t_TIFFfree(dir);\n\tdir=NULL;\n\tif (!SeekOK(tif,tif->tif_diroff))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\tif (!WriteOK(tif,dirmem,(tmsize_t)dirsize))\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"IO error writing directory\");\n\t\tgoto bad;\n\t}\n\t_TIFFfree(dirmem);\n\tif (imagedone)\n\t{\n\t\tTIFFFreeDirectory(tif);\n\t\ttif->tif_flags &= ~TIFF_DIRTYDIRECT;\n\t\ttif->tif_flags &= ~TIFF_DIRTYSTRIP;\n\t\t(*tif->tif_cleanup)(tif);\n\t\t/*\n\t\t* Reset directory-related state for subsequent\n\t\t* directories.\n\t\t*/\n\t\tTIFFCreateDirectory(tif);\n\t}\n\treturn(1);\nbad:\n\tif (dir!=NULL)\n\t\t_TIFFfree(dir);\n\tif (dirmem!=NULL)\n\t\t_TIFFfree(dirmem);\n\treturn(0);\n}", "before_change_lines": [171, 176, 195, 196, 201], "raw_before_change_lines": [171, 176, 184, 195, 196, 201], "after_change_lines": [171, 176, 195, 196, 201], "raw_after_change_lines": [171, 176, 184, 195, 196, 201], "bug_lines": [171, 176, 184, 195, 196, 201], "added": [false, false, false, false, false, false], "idx": 319}
{"project": "libtiff", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "9380----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_35bc12ddd07f23865765f6ceed4f382a81a14708_1.json----_TIFFVGetField", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_35bc12ddd07f23865765f6ceed4f382a81a14708_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_35bc12ddd07f23865765f6ceed4f382a81a14708_1.json", "function_name": "_TIFFVGetField", "vul_func_code": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\t\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (ie. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historially treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historially treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip == NULL || fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip ? fip->field_name : \"Unknown\");\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}", "patch_func_code": "static int\n_TIFFVGetField(TIFF* tif, uint32 tag, va_list ap)\n{\n\tTIFFDirectory* td = &tif->tif_dir;\n\tint ret_val = 1;\n\tuint32 standard_tag = tag;\n\tconst TIFFField* fip = TIFFFindField(tif, tag, TIFF_ANY);\n\tif( fip == NULL ) /* cannot happen since TIFFGetField() already checks it */\n\t    return 0;\n\t\n\t/*\n\t * We want to force the custom code to be used for custom\n\t * fields even if the tag happens to match a well known \n\t * one - important for reinterpreted handling of standard\n\t * tag values in custom directories (ie. EXIF) \n\t */\n\tif (fip->field_bit == FIELD_CUSTOM) {\n\t\tstandard_tag = 0;\n\t}\n\n\tswitch (standard_tag) {\n\t\tcase TIFFTAG_SUBFILETYPE:\n\t\t\t*va_arg(ap, uint32*) = td->td_subfiletype;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_BITSPERSAMPLE:\n\t\t\t*va_arg(ap, uint16*) = td->td_bitspersample;\n\t\t\tbreak;\n\t\tcase TIFFTAG_COMPRESSION:\n\t\t\t*va_arg(ap, uint16*) = td->td_compression;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PHOTOMETRIC:\n\t\t\t*va_arg(ap, uint16*) = td->td_photometric;\n\t\t\tbreak;\n\t\tcase TIFFTAG_THRESHHOLDING:\n\t\t\t*va_arg(ap, uint16*) = td->td_threshholding;\n\t\t\tbreak;\n\t\tcase TIFFTAG_FILLORDER:\n\t\t\t*va_arg(ap, uint16*) = td->td_fillorder;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ORIENTATION:\n\t\t\t*va_arg(ap, uint16*) = td->td_orientation;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLESPERPIXEL:\n\t\t\t*va_arg(ap, uint16*) = td->td_samplesperpixel;\n\t\t\tbreak;\n\t\tcase TIFFTAG_ROWSPERSTRIP:\n\t\t\t*va_arg(ap, uint32*) = td->td_rowsperstrip;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MINSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_minsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MAXSAMPLEVALUE:\n\t\t\t*va_arg(ap, uint16*) = td->td_maxsamplevalue;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMINSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_sminsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historially treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_sminsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_sminsamplevalue[i] < v )\n\t\t\t\t\t\tv = td->td_sminsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SMAXSAMPLEVALUE:\n\t\t\tif (tif->tif_flags & TIFF_PERSAMPLE)\n\t\t\t\t*va_arg(ap, double**) = td->td_smaxsamplevalue;\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* libtiff historially treats this as a single value. */\n\t\t\t\tuint16 i;\n\t\t\t\tdouble v = td->td_smaxsamplevalue[0];\n\t\t\t\tfor (i=1; i < td->td_samplesperpixel; ++i)\n\t\t\t\t\tif( td->td_smaxsamplevalue[i] > v )\n\t\t\t\t\t\tv = td->td_smaxsamplevalue[i];\n\t\t\t\t*va_arg(ap, double*) = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_XRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_xresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YRESOLUTION:\n\t\t\t*va_arg(ap, float*) = td->td_yresolution;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PLANARCONFIG:\n\t\t\t*va_arg(ap, uint16*) = td->td_planarconfig;\n\t\t\tbreak;\n\t\tcase TIFFTAG_XPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_xposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YPOSITION:\n\t\t\t*va_arg(ap, float*) = td->td_yposition;\n\t\t\tbreak;\n\t\tcase TIFFTAG_RESOLUTIONUNIT:\n\t\t\t*va_arg(ap, uint16*) = td->td_resolutionunit;\n\t\t\tbreak;\n\t\tcase TIFFTAG_PAGENUMBER:\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_pagenumber[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_HALFTONEHINTS:\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_halftonehints[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_COLORMAP:\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[0];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[1];\n\t\t\t*va_arg(ap, uint16**) = td->td_colormap[2];\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPOFFSETS:\n\t\tcase TIFFTAG_TILEOFFSETS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripoffset;\n\t\t\tbreak;\n\t\tcase TIFFTAG_STRIPBYTECOUNTS:\n\t\tcase TIFFTAG_TILEBYTECOUNTS:\n\t\t\t_TIFFFillStriles( tif );\n\t\t\t*va_arg(ap, uint64**) = td->td_stripbytecount;\n\t\t\tbreak;\n\t\tcase TIFFTAG_MATTEING:\n\t\t\t*va_arg(ap, uint16*) =\n\t\t\t    (td->td_extrasamples == 1 &&\n\t\t\t    td->td_sampleinfo[0] == EXTRASAMPLE_ASSOCALPHA);\n\t\t\tbreak;\n\t\tcase TIFFTAG_EXTRASAMPLES:\n\t\t\t*va_arg(ap, uint16*) = td->td_extrasamples;\n\t\t\t*va_arg(ap, uint16**) = td->td_sampleinfo;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEWIDTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilewidth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILELENGTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tilelength;\n\t\t\tbreak;\n\t\tcase TIFFTAG_TILEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_tiledepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_DATATYPE:\n\t\t\tswitch (td->td_sampleformat) {\n\t\t\t\tcase SAMPLEFORMAT_UINT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_UINT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_INT:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_INT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_IEEEFP:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_IEEEFP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SAMPLEFORMAT_VOID:\n\t\t\t\t\t*va_arg(ap, uint16*) = DATATYPE_VOID;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_SAMPLEFORMAT:\n\t\t\t*va_arg(ap, uint16*) = td->td_sampleformat;\n\t\t\tbreak;\n\t\tcase TIFFTAG_IMAGEDEPTH:\n\t\t\t*va_arg(ap, uint32*) = td->td_imagedepth;\n\t\t\tbreak;\n\t\tcase TIFFTAG_SUBIFD:\n\t\t\t*va_arg(ap, uint16*) = td->td_nsubifd;\n\t\t\t*va_arg(ap, uint64**) = td->td_subifd;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRPOSITIONING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrpositioning;\n\t\t\tbreak;\n\t\tcase TIFFTAG_YCBCRSUBSAMPLING:\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[0];\n\t\t\t*va_arg(ap, uint16*) = td->td_ycbcrsubsampling[1];\n\t\t\tbreak;\n\t\tcase TIFFTAG_TRANSFERFUNCTION:\n\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[0];\n\t\t\tif (td->td_samplesperpixel - td->td_extrasamples > 1) {\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[1];\n\t\t\t\t*va_arg(ap, uint16**) = td->td_transferfunction[2];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIFFTAG_REFERENCEBLACKWHITE:\n\t\t\t*va_arg(ap, float**) = td->td_refblackwhite;\n\t\t\tbreak;\n\t\tcase TIFFTAG_INKNAMES:\n\t\t\t*va_arg(ap, char**) = td->td_inknames;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t{\n\t\t\t\tint i;\n\n\t\t\t\t/*\n\t\t\t\t * This can happen if multiple images are open\n\t\t\t\t * with different codecs which have private\n\t\t\t\t * tags.  The global tag information table may\n\t\t\t\t * then have tags that are valid for one file\n\t\t\t\t * but not the other. If the client tries to\n\t\t\t\t * get a tag that is not valid for the image's\n\t\t\t\t * codec then we'll arrive here.\n\t\t\t\t */\n\t\t\t\tif( fip->field_bit != FIELD_CUSTOM )\n\t\t\t\t{\n\t\t\t\t\tTIFFErrorExt(tif->tif_clientdata, \"_TIFFVGetField\",\n\t\t\t\t\t    \"%s: Invalid %stag \\\"%s\\\" \"\n\t\t\t\t\t    \"(not supported by codec)\",\n\t\t\t\t\t    tif->tif_name,\n\t\t\t\t\t    isPseudoTag(tag) ? \"pseudo-\" : \"\",\n\t\t\t\t\t    fip->field_name);\n\t\t\t\t\tret_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Do we have a custom value?\n\t\t\t\t */\n\t\t\t\tret_val = 0;\n\t\t\t\tfor (i = 0; i < td->td_customValueCount; i++) {\n\t\t\t\t\tTIFFTagValue *tv = td->td_customValues + i;\n\n\t\t\t\t\tif (tv->info->field_tag != tag)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (fip->field_passcount) {\n\t\t\t\t\t\tif (fip->field_readcount == TIFF_VARIABLE2)\n\t\t\t\t\t\t\t*va_arg(ap, uint32*) = (uint32)tv->count;\n\t\t\t\t\t\telse  /* Assume TIFF_VARIABLE */\n\t\t\t\t\t\t\t*va_arg(ap, uint16*) = (uint16)tv->count;\n\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else if (fip->field_tag == TIFFTAG_DOTRANGE\n\t\t\t\t\t\t   && strcmp(fip->field_name,\"DotRange\") == 0) {\n\t\t\t\t\t\t/* TODO: This is an evil exception and should not have been\n\t\t\t\t\t\t   handled this way ... likely best if we move it into\n\t\t\t\t\t\t   the directory structure with an explicit field in \n\t\t\t\t\t\t   libtiff 4.1 and assign it a FIELD_ value */\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[0];\n\t\t\t\t\t\t*va_arg(ap, uint16*) = ((uint16 *)tv->value)[1];\n\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (fip->field_type == TIFF_ASCII\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_VARIABLE2\n\t\t\t\t\t\t    || fip->field_readcount == TIFF_SPP\n\t\t\t\t\t\t    || tv->count > 1) {\n\t\t\t\t\t\t\t*va_arg(ap, void **) = tv->value;\n\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchar *val = (char *)tv->value;\n\t\t\t\t\t\t\tassert( tv->count == 1 );\n\t\t\t\t\t\t\tswitch (fip->field_type) {\n\t\t\t\t\t\t\tcase TIFF_BYTE:\n\t\t\t\t\t\t\tcase TIFF_UNDEFINED:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint8*) =\n\t\t\t\t\t\t\t\t\t*(uint8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SBYTE:\n\t\t\t\t\t\t\t\t*va_arg(ap, int8*) =\n\t\t\t\t\t\t\t\t\t*(int8 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint16*) =\n\t\t\t\t\t\t\t\t\t*(uint16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SSHORT:\n\t\t\t\t\t\t\t\t*va_arg(ap, int16*) =\n\t\t\t\t\t\t\t\t\t*(int16 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG:\n\t\t\t\t\t\t\tcase TIFF_IFD:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint32*) =\n\t\t\t\t\t\t\t\t\t*(uint32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG:\n\t\t\t\t\t\t\t\t*va_arg(ap, int32*) =\n\t\t\t\t\t\t\t\t\t*(int32 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_LONG8:\n\t\t\t\t\t\t\tcase TIFF_IFD8:\n\t\t\t\t\t\t\t\t*va_arg(ap, uint64*) =\n\t\t\t\t\t\t\t\t\t*(uint64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_SLONG8:\n\t\t\t\t\t\t\t\t*va_arg(ap, int64*) =\n\t\t\t\t\t\t\t\t\t*(int64 *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_RATIONAL:\n\t\t\t\t\t\t\tcase TIFF_SRATIONAL:\n\t\t\t\t\t\t\tcase TIFF_FLOAT:\n\t\t\t\t\t\t\t\t*va_arg(ap, float*) =\n\t\t\t\t\t\t\t\t\t*(float *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TIFF_DOUBLE:\n\t\t\t\t\t\t\t\t*va_arg(ap, double*) =\n\t\t\t\t\t\t\t\t\t*(double *)val;\n\t\t\t\t\t\t\t\tret_val = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tret_val = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn(ret_val);\n}", "before_change_lines": [205, 212], "raw_before_change_lines": [205, 212], "after_change_lines": [8, 9, 207, 214], "raw_after_change_lines": [8, 9, 207, 214], "bug_lines": [205, 212], "added": [false, false], "idx": 320}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9423----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_4a926dbf3c916f07e0e8620e6c1bae4d745c7fb4_1.json----TIFFReadRawStrip", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_4a926dbf3c916f07e0e8620e6c1bae4d745c7fb4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_4a926dbf3c916f07e0e8620e6c1bae4d745c7fb4_1.json", "function_name": "TIFFReadRawStrip", "vul_func_code": "tmsize_t\nTIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadRawStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\ttmsize_t bytecountm;\n\n\tif (!TIFFCheckRead(tif, 0))\n\t\treturn ((tmsize_t)(-1));\n\tif (strip >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%lu: Strip out of range, max %lu\",\n\t\t     (unsigned long) strip,\n\t\t     (unsigned long) td->td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Compression scheme does not support access to raw uncompressed data\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tbytecount = TIFFGetStrileByteCount(tif, strip);\n\tif ((int64)bytecount <= 0) {\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%I64u: Invalid strip byte count, strip %lu\",\n\t\t\t     (unsigned __int64) bytecount,\n\t\t\t     (unsigned long) strip);\n#else\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t     \"%llu: Invalid strip byte count, strip %lu\",\n\t\t\t     (unsigned long long) bytecount,\n\t\t\t     (unsigned long) strip);\n#endif\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tbytecountm = (tmsize_t)bytecount;\n\tif ((uint64)bytecountm!=bytecount) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"Integer overflow\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (size != (tmsize_t)(-1) && size < bytecountm)\n\t\tbytecountm = size;\n\treturn (TIFFReadRawStrip1(tif, strip, buf, bytecountm, module));\n}", "patch_func_code": "tmsize_t\nTIFFReadRawStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadRawStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint64 bytecount;\n\ttmsize_t bytecountm;\n\n\tif (!TIFFCheckRead(tif, 0))\n\t\treturn ((tmsize_t)(-1));\n\tif (strip >= td->td_nstrips) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t     \"%lu: Strip out of range, max %lu\",\n\t\t     (unsigned long) strip,\n\t\t     (unsigned long) td->td_nstrips);\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (tif->tif_flags&TIFF_NOREADRAW)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t    \"Compression scheme does not support access to raw uncompressed data\");\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tbytecount = TIFFGetStrileByteCount(tif, strip);\n        bytecountm = _TIFFCastUInt64ToSSize(tif, bytecount, module);\n\tif (bytecountm == 0) {\n\t\treturn ((tmsize_t)(-1));\n\t}\n\tif (size != (tmsize_t)(-1) && size < bytecountm)\n\t\tbytecountm = size;\n\treturn (TIFFReadRawStrip1(tif, strip, buf, bytecountm, module));\n}", "before_change_lines": [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41], "raw_before_change_lines": [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41], "after_change_lines": [25, 26], "raw_after_change_lines": [25, 26], "bug_lines": [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 321}
{"project": "libtiff", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9520----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_760b8c63c78de86e272f3bdbc080d5520b7debd6_1.json----TryChopUpUncompressedBigTiff", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_760b8c63c78de86e272f3bdbc080d5520b7debd6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_760b8c63c78de86e272f3bdbc080d5520b7debd6_1.json", "function_name": "TryChopUpUncompressedBigTiff", "vul_func_code": "static void TryChopUpUncompressedBigTiff( TIFF* tif )\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32 rowblock;\n    uint64 rowblockbytes;\n    uint32 i;\n    uint64 stripsize;\n    uint32 rowblocksperstrip;\n    uint32 rowsperstrip;\n    uint64 stripbytes;\n    uint32 nstrips;\n\n    stripsize = TIFFStripSize64(tif);\n\n    assert( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG );\n    assert( tif->tif_dir.td_compression == COMPRESSION_NONE );\n    assert( (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP );\n    assert( stripsize > 0x7FFFFFFFUL );\n\n    /* On a newly created file, just re-opened to be filled, we */\n    /* don't want strip chop to trigger as it is going to cause issues */\n    /* later ( StripOffsets and StripByteCounts improperly filled) . */\n    if( td->td_stripbytecount[0] == 0 && tif->tif_mode != O_RDONLY )\n        return;\n\n    if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n        (!isUpSampled(tif)))\n        rowblock = td->td_ycbcrsubsampling[1];\n    else\n        rowblock = 1;\n    rowblockbytes = TIFFVStripSize64(tif, rowblock);\n    if( rowblockbytes == 0 || rowblockbytes > 0x7FFFFFFFUL )\n    {\n        /* In case of file with gigantic width */\n        return;\n    }\n\n    /* Check that the strips are contiguous and of the expected size */\n    for( i = 0; i < td->td_nstrips; i++ )\n    {\n        if( i == td->td_nstrips - 1 )\n        {\n            if( td->td_stripbytecount[i] < TIFFVStripSize64(\n                    tif, td->td_imagelength - i * td->td_rowsperstrip ) )\n            {\n                return;\n            }\n        }\n        else\n        {\n            if( td->td_stripbytecount[i] != stripsize )\n            {\n                return;\n            }\n            if( i > 0 && td->td_stripoffset[i] !=\n                    td->td_stripoffset[i-1] + td->td_stripbytecount[i - 1] )\n            {\n                return;\n            }\n        }\n    }\n\n    /* Aim for 512 MB strips (that will still be manageable by 32 bit builds */\n    rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes);\n    if( rowblocksperstrip == 0 )\n        rowblocksperstrip = 1;\n    rowsperstrip = rowblocksperstrip * rowblock;\n    stripbytes = rowblocksperstrip * rowblockbytes;\n    assert( stripbytes <= 0x7FFFFFFFUL );\n\n    nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n    if( nstrips == 0 )\n        return;\n\n    /* If we are going to allocate a lot of memory, make sure that the */\n    /* file is as big as needed */\n    if( tif->tif_mode == O_RDONLY &&\n        nstrips > 1000000 &&\n        (td->td_stripoffset[td->td_nstrips-1] > TIFFGetFileSize(tif) ||\n         td->td_stripoffset[td->td_nstrips-1] +\n         td->td_stripbytecount[td->td_nstrips-1] > TIFFGetFileSize(tif)) )\n    {\n        return;\n    }\n\n    allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}", "patch_func_code": "static void TryChopUpUncompressedBigTiff( TIFF* tif )\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    uint32 rowblock;\n    uint64 rowblockbytes;\n    uint32 i;\n    uint64 stripsize;\n    uint32 rowblocksperstrip;\n    uint32 rowsperstrip;\n    uint64 stripbytes;\n    uint32 nstrips;\n\n    stripsize = TIFFStripSize64(tif);\n\n    assert( tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG );\n    assert( tif->tif_dir.td_compression == COMPRESSION_NONE );\n    assert( (tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED)) == TIFF_STRIPCHOP );\n    assert( stripsize > 0x7FFFFFFFUL );\n\n    /* On a newly created file, just re-opened to be filled, we */\n    /* don't want strip chop to trigger as it is going to cause issues */\n    /* later ( StripOffsets and StripByteCounts improperly filled) . */\n    if( TIFFGetStrileByteCount(tif, 0) == 0 && tif->tif_mode != O_RDONLY )\n        return;\n\n    if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&\n        (!isUpSampled(tif)))\n        rowblock = td->td_ycbcrsubsampling[1];\n    else\n        rowblock = 1;\n    rowblockbytes = TIFFVStripSize64(tif, rowblock);\n    if( rowblockbytes == 0 || rowblockbytes > 0x7FFFFFFFUL )\n    {\n        /* In case of file with gigantic width */\n        return;\n    }\n\n    /* Check that the strips are contiguous and of the expected size */\n    for( i = 0; i < td->td_nstrips; i++ )\n    {\n        if( i == td->td_nstrips - 1 )\n        {\n            if( TIFFGetStrileByteCount(tif, i) < TIFFVStripSize64(\n                    tif, td->td_imagelength - i * td->td_rowsperstrip ) )\n            {\n                return;\n            }\n        }\n        else\n        {\n            if( TIFFGetStrileByteCount(tif, i) != stripsize )\n            {\n                return;\n            }\n            if( i > 0 && TIFFGetStrileOffset(tif, i) !=\n                    TIFFGetStrileOffset(tif, i-1) + TIFFGetStrileByteCount(tif, i-1) )\n            {\n                return;\n            }\n        }\n    }\n\n    /* Aim for 512 MB strips (that will still be manageable by 32 bit builds */\n    rowblocksperstrip = (uint32) (512 * 1024 * 1024 / rowblockbytes);\n    if( rowblocksperstrip == 0 )\n        rowblocksperstrip = 1;\n    rowsperstrip = rowblocksperstrip * rowblock;\n    stripbytes = rowblocksperstrip * rowblockbytes;\n    assert( stripbytes <= 0x7FFFFFFFUL );\n\n    nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n    if( nstrips == 0 )\n        return;\n\n    /* If we are going to allocate a lot of memory, make sure that the */\n    /* file is as big as needed */\n    if( tif->tif_mode == O_RDONLY &&\n        nstrips > 1000000 &&\n        (TIFFGetStrileOffset(tif, td->td_nstrips-1) > TIFFGetFileSize(tif) ||\n         TIFFGetStrileOffset(tif, td->td_nstrips-1) +\n         TIFFGetStrileByteCount(tif, td->td_nstrips-1) > TIFFGetFileSize(tif)) )\n    {\n        return;\n    }\n\n    allocChoppedUpStripArrays(tif, nstrips, stripbytes, rowsperstrip);\n}", "before_change_lines": [23, 43, 51, 55, 56, 79, 80, 81], "raw_before_change_lines": [23, 43, 51, 55, 56, 79, 80, 81], "after_change_lines": [23, 43, 51, 55, 56, 79, 80, 81], "raw_after_change_lines": [23, 43, 51, 55, 56, 79, 80, 81], "bug_lines": [23, 43, 51, 55, 56, 79, 80, 81], "added": [false, false, false, false, false, false, false, false], "idx": 322}
{"project": "libtiff", "vul_type": "PULSE_MEMORY_LEAK", "filepath_func": "9530----PULSE_MEMORY_LEAK----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_7a431772956d0f855855330afae832f180e23b7e_1.json----OJPEGReadHeaderInfoSecStreamDht", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_7a431772956d0f855855330afae832f180e23b7e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_7a431772956d0f855855330afae832f180e23b7e_1.json", "function_name": "OJPEGReadHeaderInfoSecStreamDht", "vul_func_code": "static int\nOJPEGReadHeaderInfoSecStreamDht(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\t/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDht\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t{\n\t\tOJPEGReadSkip(sp,m-2);\n\t}\n\telse\n\t{\n\t\tna=sizeof(uint32)+2+m;\n\t\tnb=_TIFFmalloc(na);\n\t\tif (nb==0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\t*(uint32*)nb=na;\n\t\tnb[sizeof(uint32)]=255;\n\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\tnb[sizeof(uint32)+2]=(m>>8);\n\t\tnb[sizeof(uint32)+3]=(m&255);\n\t\tif (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0)\n\t\t\treturn(0);\n\t\to=nb[sizeof(uint32)+4];\n\t\tif ((o&240)==0)\n\t\t{\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->dctable[o]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[o]);\n\t\t\tsp->dctable[o]=nb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((o&240)!=16)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to&=15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->actable[o]!=0)\n\t\t\t\t_TIFFfree(sp->actable[o]);\n\t\t\tsp->actable[o]=nb;\n\t\t}\n\t}\n\treturn(1);\n}", "patch_func_code": "static int\nOJPEGReadHeaderInfoSecStreamDht(TIFF* tif)\n{\n\t/* this is a table marker, and it is to be saved as a whole for exact pushing on the jpeg stream later on */\n\t/* TODO: the following assumes there is only one table in this marker... but i'm not quite sure that assumption is guaranteed correct */\n\tstatic const char module[]=\"OJPEGReadHeaderInfoSecStreamDht\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\tuint16 m;\n\tuint32 na;\n\tuint8* nb;\n\tuint8 o;\n\tif (OJPEGReadWord(sp,&m)==0)\n\t\treturn(0);\n\tif (m<=2)\n\t{\n\t\tif (sp->subsamplingcorrect==0)\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n\t\treturn(0);\n\t}\n\tif (sp->subsamplingcorrect!=0)\n\t{\n\t\tOJPEGReadSkip(sp,m-2);\n\t}\n\telse\n\t{\n\t\tna=sizeof(uint32)+2+m;\n\t\tnb=_TIFFmalloc(na);\n\t\tif (nb==0)\n\t\t{\n\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Out of memory\");\n\t\t\treturn(0);\n\t\t}\n\t\t*(uint32*)nb=na;\n\t\tnb[sizeof(uint32)]=255;\n\t\tnb[sizeof(uint32)+1]=JPEG_MARKER_DHT;\n\t\tnb[sizeof(uint32)+2]=(m>>8);\n\t\tnb[sizeof(uint32)+3]=(m&255);\n\t\tif (OJPEGReadBlock(sp,m-2,&nb[sizeof(uint32)+4])==0) {\n                        _TIFFfree(nb);\n\t\t\treturn(0);\n                }\n\t\to=nb[sizeof(uint32)+4];\n\t\tif ((o&240)==0)\n\t\t{\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->dctable[o]!=0)\n\t\t\t\t_TIFFfree(sp->dctable[o]);\n\t\t\tsp->dctable[o]=nb;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((o&240)!=16)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\to&=15;\n\t\t\tif (3<o)\n\t\t\t{\n\t\t\t\tTIFFErrorExt(tif->tif_clientdata,module,\"Corrupt DHT marker in JPEG data\");\n                                _TIFFfree(nb);\n\t\t\t\treturn(0);\n\t\t\t}\n\t\t\tif (sp->actable[o]!=0)\n\t\t\t\t_TIFFfree(sp->actable[o]);\n\t\t\tsp->actable[o]=nb;\n\t\t}\n\t}\n\treturn(1);\n}", "before_change_lines": [38], "raw_before_change_lines": [38], "after_change_lines": [38, 39, 41, 48, 60, 67], "raw_after_change_lines": [38, 39, 41, 48, 60, 67], "bug_lines": [38], "added": [false], "idx": 323}
{"project": "libtiff", "vul_type": "MEMORY_LEAK", "filepath_func": "9743----MEMORY_LEAK----G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_cc89c456a3c35b9c712b83119d254599b1722135_1.json----JPEGFixupTagsSubsampling", "patch_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/after_fix/libtiff_cc89c456a3c35b9c712b83119d254599b1722135_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/libtiff/d2a/before_fix/libtiff_cc89c456a3c35b9c712b83119d254599b1722135_1.json", "function_name": "JPEGFixupTagsSubsampling", "vul_func_code": "static void\nJPEGFixupTagsSubsampling(TIFF* tif)\n{\n\t/*\n\t * Some JPEG-in-TIFF produces do not emit the YCBCRSUBSAMPLING values in\n\t * the TIFF tags, but still use non-default (2,2) values within the jpeg\n\t * data stream itself.  In order for TIFF applications to work properly\n\t * - for instance to get the strip buffer size right - it is imperative\n\t * that the subsampling be available before we start reading the image\n\t * data normally.  This function will attempt to analyze the first strip in\n\t * order to get the sampling values from the jpeg data stream.\n\t *\n\t * Note that JPEGPreDeocode() will produce a fairly loud warning when the\n\t * discovered sampling does not match the default sampling (2,2) or whatever\n\t * was actually in the tiff tags.\n\t *\n\t * See the bug in bugzilla for details:\n\t *\n\t * http://bugzilla.remotesensing.org/show_bug.cgi?id=168\n\t *\n\t * Frank Warmerdam, July 2002\n\t * Joris Van Damme, May 2007\n\t */\n\tstatic const char module[] = \"JPEGFixupTagsSubsampling\";\n\tstruct JPEGFixupTagsSubsamplingData m;\n\n        _TIFFFillStriles( tif );\n        \n        if( tif->tif_dir.td_stripbytecount == NULL\n            || tif->tif_dir.td_stripoffset == NULL\n            || tif->tif_dir.td_stripbytecount[0] == 0 )\n        {\n            /* Do not even try to check if the first strip/tile does not\n               yet exist, as occurs when GDAL has created a new NULL file\n               for instance. */\n            return;\n        }\n\n\tm.tif=tif;\n\tm.buffersize=2048;\n\tm.buffer=_TIFFmalloc(m.buffersize);\n\tif (m.buffer==NULL)\n\t{\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped\");\n\t\treturn;\n\t}\n\tm.buffercurrentbyte=NULL;\n\tm.bufferbytesleft=0;\n\tm.fileoffset=tif->tif_dir.td_stripoffset[0];\n\tm.filepositioned=0;\n\tm.filebytesleft=tif->tif_dir.td_stripbytecount[0];\n\tif (!JPEGFixupTagsSubsamplingSec(&m))\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-correcting skipped\");\n\t_TIFFfree(m.buffer);\n}", "patch_func_code": "static void\nJPEGFixupTagsSubsampling(TIFF* tif)\n{\n\t/*\n\t * Some JPEG-in-TIFF produces do not emit the YCBCRSUBSAMPLING values in\n\t * the TIFF tags, but still use non-default (2,2) values within the jpeg\n\t * data stream itself.  In order for TIFF applications to work properly\n\t * - for instance to get the strip buffer size right - it is imperative\n\t * that the subsampling be available before we start reading the image\n\t * data normally.  This function will attempt to analyze the first strip in\n\t * order to get the sampling values from the jpeg data stream.\n\t *\n\t * Note that JPEGPreDeocode() will produce a fairly loud warning when the\n\t * discovered sampling does not match the default sampling (2,2) or whatever\n\t * was actually in the tiff tags.\n\t *\n\t * See the bug in bugzilla for details:\n\t *\n\t * http://bugzilla.remotesensing.org/show_bug.cgi?id=168\n\t *\n\t * Frank Warmerdam, July 2002\n\t * Joris Van Damme, May 2007\n\t */\n\tstatic const char module[] = \"JPEGFixupTagsSubsampling\";\n\tstruct JPEGFixupTagsSubsamplingData m;\n        uint64 fileoffset = TIFFGetStrileOffset(tif, 0);\n\n        if( fileoffset == 0 )\n        {\n            /* Do not even try to check if the first strip/tile does not\n               yet exist, as occurs when GDAL has created a new NULL file\n               for instance. */\n            return;\n        }\n\n\tm.tif=tif;\n\tm.buffersize=2048;\n\tm.buffer=_TIFFmalloc(m.buffersize);\n\tif (m.buffer==NULL)\n\t{\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped\");\n\t\treturn;\n\t}\n\tm.buffercurrentbyte=NULL;\n\tm.bufferbytesleft=0;\n\tm.fileoffset=fileoffset;\n\tm.filepositioned=0;\n\tm.filebytesleft=TIFFGetStrileByteCount(tif, 0);\n\tif (!JPEGFixupTagsSubsamplingSec(&m))\n\t\tTIFFWarningExt(tif->tif_clientdata,module,\n\t\t    \"Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-correcting skipped\");\n\t_TIFFfree(m.buffer);\n}", "before_change_lines": [27, 29, 30, 31, 50, 52], "raw_before_change_lines": [27, 28, 29, 30, 31, 50, 52], "after_change_lines": [26, 28, 47, 49], "raw_after_change_lines": [26, 28, 47, 49], "bug_lines": [27, 28, 29, 30, 31, 50, 52], "added": [false, false, false, false, false, false, false], "idx": 324}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "9837----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_0199e2876a01c4465223787db4a78daa27f3a110_1.json----ngx_http_file_cache_update", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_0199e2876a01c4465223787db4a78daa27f3a110_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_0199e2876a01c4465223787db4a78daa27f3a110_1.json", "function_name": "ngx_http_file_cache_update", "vul_func_code": "void\nngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf)\n{\n    off_t                   fs_size;\n    ngx_int_t               rc;\n    ngx_file_uniq_t         uniq;\n    ngx_file_info_t         fi;\n    ngx_http_cache_t        *c;\n    ngx_ext_rename_file_t   ext;\n    ngx_http_file_cache_t  *cache;\n\n    c = r->cache;\n\n    if (c->updated) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache update\");\n\n    cache = c->file_cache;\n\n    if (c->secondary\n        && ngx_memcmp(c->variant, c->key, NGX_HTTP_CACHE_KEY_LEN) != 0)\n    {\n        /*\n         * if the variant hash doesn't match one we used as a secondary\n         * cache key, switch back to the original key\n         */\n\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http file cache main key\");\n\n        ngx_shmtx_lock(&cache->shpool->mutex);\n\n        c->node->count--;\n        c->node->updating = 0;\n        c->node = NULL;\n\n        ngx_shmtx_unlock(&cache->shpool->mutex);\n\n        c->file.name.len = 0;\n\n        ngx_memcpy(c->key, c->main, NGX_HTTP_CACHE_KEY_LEN);\n\n        if (ngx_http_file_cache_exists(cache, c) == NGX_ERROR) {\n            return;\n        }\n\n        if (ngx_http_file_cache_name(r, cache->path) != NGX_OK) {\n            return;\n        }\n    }\n\n    c->updated = 1;\n    c->updating = 0;\n\n    uniq = 0;\n    fs_size = 0;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache rename: \\\"%s\\\" to \\\"%s\\\"\",\n                   tf->file.name.data, c->file.name.data);\n\n    ext.access = NGX_FILE_OWNER_ACCESS;\n    ext.path_access = NGX_FILE_OWNER_ACCESS;\n    ext.time = -1;\n    ext.create_path = 1;\n    ext.delete_file = 1;\n    ext.log = r->connection->log;\n\n    rc = ngx_ext_rename_file(&tf->file.name, &c->file.name, &ext);\n\n    if (rc == NGX_OK) {\n\n        if (ngx_fd_info(tf->file.fd, &fi) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                          ngx_fd_info_n \" \\\"%s\\\" failed\", tf->file.name.data);\n\n            rc = NGX_ERROR;\n\n        } else {\n            uniq = ngx_file_uniq(&fi);\n            fs_size = (ngx_file_fs_size(&fi) + cache->bsize - 1) / cache->bsize;\n        }\n    }\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    c->node->count--;\n    c->node->uniq = uniq;\n    c->node->body_start = c->body_start;\n\n    cache->sh->size += fs_size - c->node->fs_size;\n    c->node->fs_size = fs_size;\n\n    if (rc == NGX_OK) {\n        c->node->exists = 1;\n    }\n\n    c->node->updating = 0;\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n}", "patch_func_code": "void\nngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf)\n{\n    off_t                   fs_size;\n    ngx_int_t               rc;\n    ngx_file_uniq_t         uniq;\n    ngx_file_info_t         fi;\n    ngx_http_cache_t        *c;\n    ngx_ext_rename_file_t   ext;\n    ngx_http_file_cache_t  *cache;\n\n    c = r->cache;\n\n    if (c->updated) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache update\");\n\n    cache = c->file_cache;\n\n    c->updated = 1;\n    c->updating = 0;\n\n    uniq = 0;\n    fs_size = 0;\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache rename: \\\"%s\\\" to \\\"%s\\\"\",\n                   tf->file.name.data, c->file.name.data);\n\n    ext.access = NGX_FILE_OWNER_ACCESS;\n    ext.path_access = NGX_FILE_OWNER_ACCESS;\n    ext.time = -1;\n    ext.create_path = 1;\n    ext.delete_file = 1;\n    ext.log = r->connection->log;\n\n    rc = ngx_ext_rename_file(&tf->file.name, &c->file.name, &ext);\n\n    if (rc == NGX_OK) {\n\n        if (ngx_fd_info(tf->file.fd, &fi) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                          ngx_fd_info_n \" \\\"%s\\\" failed\", tf->file.name.data);\n\n            rc = NGX_ERROR;\n\n        } else {\n            uniq = ngx_file_uniq(&fi);\n            fs_size = (ngx_file_fs_size(&fi) + cache->bsize - 1) / cache->bsize;\n        }\n    }\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    c->node->count--;\n    c->node->uniq = uniq;\n    c->node->body_start = c->body_start;\n\n    cache->sh->size += fs_size - c->node->fs_size;\n    c->node->fs_size = fs_size;\n\n    if (rc == NGX_OK) {\n        c->node->exists = 1;\n    }\n\n    c->node->updating = 0;\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n}", "before_change_lines": [23, 24, 25, 27, 28, 29, 31, 32, 34, 36, 37, 38, 40, 42, 44, 46, 47, 48, 50, 51, 52, 53], "raw_before_change_lines": [23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 325}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "9838----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_01e4c51254c7bbda573a0868f5e9050437a8c7f1_1.json----ngx_http_upstream_process_request", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_01e4c51254c7bbda573a0868f5e9050437a8c7f1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_01e4c51254c7bbda573a0868f5e9050437a8c7f1_1.json", "function_name": "ngx_http_upstream_process_request", "vul_func_code": "static void\nngx_http_upstream_process_request(ngx_http_request_t *r)\n{\n    ngx_uint_t            del;\n    ngx_temp_file_t      *tf;\n    ngx_event_pipe_t     *p;\n    ngx_http_upstream_t  *u;\n\n    u = r->upstream;\n    p = u->pipe;\n\n    if (u->peer.connection) {\n\n        if (u->store) {\n\n            del = p->upstream_error;\n\n            tf = u->pipe->temp_file;\n\n            if (p->upstream_eof || p->upstream_done) {\n\n                if (u->headers_in.status_n == NGX_HTTP_OK\n                    && (u->headers_in.content_length_n == -1\n                        || (u->headers_in.content_length_n == tf->offset)))\n                {\n                    ngx_http_upstream_store(r, u);\n\n                } else {\n                    del = 1;\n                }\n            }\n\n            if (del && tf->file.fd != NGX_INVALID_FILE) {\n\n                if (ngx_delete_file(tf->file.name.data) == NGX_FILE_ERROR) {\n\n                    ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                                  ngx_delete_file_n \" \\\"%s\\\" failed\",\n                                  u->pipe->temp_file->file.name.data);\n                }\n            }\n        }\n\n#if (NGX_HTTP_CACHE)\n\n        if (u->cacheable) {\n\n            if (p->upstream_done) {\n                ngx_http_file_cache_update(r, u->pipe->temp_file);\n\n            } else if (p->upstream_eof) {\n\n                tf = u->pipe->temp_file;\n\n                if (u->headers_in.content_length_n == -1\n                    || u->headers_in.content_length_n\n                       == tf->offset - (off_t) r->cache->body_start)\n                {\n                    ngx_http_file_cache_update(r, tf);\n\n                } else {\n                    ngx_http_file_cache_free(r->cache, tf);\n                }\n\n            } else if (p->upstream_error) {\n                ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n            }\n        }\n\n#endif\n\n        if (p->upstream_done || p->upstream_eof || p->upstream_error) {\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http upstream exit: %p\", p->out);\n#if 0\n            ngx_http_busy_unlock(u->conf->busy_lock, &u->busy_lock);\n#endif\n            ngx_http_upstream_finalize_request(r, u, 0);\n            return;\n        }\n    }\n\n    if (p->downstream_error) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http upstream downstream error\");\n\n        if (!u->cacheable && !u->store && u->peer.connection) {\n            ngx_http_upstream_finalize_request(r, u, 0);\n        }\n    }\n}", "patch_func_code": "static void\nngx_http_upstream_process_request(ngx_http_request_t *r)\n{\n    ngx_temp_file_t      *tf;\n    ngx_event_pipe_t     *p;\n    ngx_http_upstream_t  *u;\n\n    u = r->upstream;\n    p = u->pipe;\n\n    if (u->peer.connection) {\n\n        if (u->store) {\n\n            if (p->upstream_eof || p->upstream_done) {\n\n                tf = u->pipe->temp_file;\n\n                if (u->headers_in.status_n == NGX_HTTP_OK\n                    && (u->headers_in.content_length_n == -1\n                        || (u->headers_in.content_length_n == tf->offset)))\n                {\n                    ngx_http_upstream_store(r, u);\n                    u->store = 0;\n                }\n            }\n        }\n\n#if (NGX_HTTP_CACHE)\n\n        if (u->cacheable) {\n\n            if (p->upstream_done) {\n                ngx_http_file_cache_update(r, u->pipe->temp_file);\n\n            } else if (p->upstream_eof) {\n\n                tf = u->pipe->temp_file;\n\n                if (u->headers_in.content_length_n == -1\n                    || u->headers_in.content_length_n\n                       == tf->offset - (off_t) r->cache->body_start)\n                {\n                    ngx_http_file_cache_update(r, tf);\n\n                } else {\n                    ngx_http_file_cache_free(r->cache, tf);\n                }\n\n            } else if (p->upstream_error) {\n                ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n            }\n        }\n\n#endif\n\n        if (p->upstream_done || p->upstream_eof || p->upstream_error) {\n            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http upstream exit: %p\", p->out);\n#if 0\n            ngx_http_busy_unlock(u->conf->busy_lock, &u->busy_lock);\n#endif\n            ngx_http_upstream_finalize_request(r, u, 0);\n            return;\n        }\n    }\n\n    if (p->downstream_error) {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http upstream downstream error\");\n\n        if (!u->cacheable && !u->store && u->peer.connection) {\n            ngx_http_upstream_finalize_request(r, u, 0);\n        }\n    }\n}", "before_change_lines": [4, 16, 18, 28, 29, 30, 31, 33, 35, 37, 38, 39], "raw_before_change_lines": [4, 16, 17, 18, 19, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39], "after_change_lines": [17, 24], "raw_after_change_lines": [17, 18, 24], "bug_lines": [4, 16, 17, 18, 19, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 326}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9874----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_18fdcecbb7f758386bd512fb3518ac4097bbf3be_1.json----ngx_http_upstream_finalize_request", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_18fdcecbb7f758386bd512fb3518ac4097bbf3be_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_18fdcecbb7f758386bd512fb3518ac4097bbf3be_1.json", "function_name": "ngx_http_upstream_finalize_request", "vul_func_code": "static void\nngx_http_upstream_finalize_request(ngx_http_request_t *r,\n    ngx_http_upstream_t *u, ngx_int_t rc)\n{\n    ngx_uint_t  flush;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"finalize http upstream request: %i\", rc);\n\n    if (u->cleanup == NULL) {\n        /* the request was already finalized */\n        ngx_http_finalize_request(r, NGX_DONE);\n        return;\n    }\n\n    *u->cleanup = NULL;\n    u->cleanup = NULL;\n\n    if (u->resolved && u->resolved->ctx) {\n        ngx_resolve_name_done(u->resolved->ctx);\n        u->resolved->ctx = NULL;\n    }\n\n    if (u->state && u->state->response_time) {\n        u->state->response_time = ngx_current_msec - u->state->response_time;\n\n        if (u->pipe && u->pipe->read_length) {\n            u->state->bytes_received += u->pipe->read_length\n                                        - u->pipe->preread_size;\n            u->state->response_length = u->pipe->read_length;\n        }\n    }\n\n    u->finalize_request(r, rc);\n\n    if (u->peer.free && u->peer.sockaddr) {\n        u->peer.free(&u->peer, u->peer.data, 0);\n        u->peer.sockaddr = NULL;\n    }\n\n    if (u->peer.connection) {\n\n#if (NGX_HTTP_SSL)\n\n        /* TODO: do not shutdown persistent connection */\n\n        if (u->peer.connection->ssl) {\n\n            /*\n             * We send the \"close notify\" shutdown alert to the upstream only\n             * and do not wait its \"close notify\" shutdown alert.\n             * It is acceptable according to the TLS standard.\n             */\n\n            u->peer.connection->ssl->no_wait_shutdown = 1;\n\n            (void) ngx_ssl_shutdown(u->peer.connection);\n        }\n#endif\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"close http upstream connection: %d\",\n                       u->peer.connection->fd);\n\n        if (u->peer.connection->pool) {\n            ngx_destroy_pool(u->peer.connection->pool);\n        }\n\n        ngx_close_connection(u->peer.connection);\n    }\n\n    u->peer.connection = NULL;\n\n    if (u->pipe && u->pipe->temp_file) {\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http upstream temp fd: %d\",\n                       u->pipe->temp_file->file.fd);\n    }\n\n    if (u->store && u->pipe && u->pipe->temp_file\n        && u->pipe->temp_file->file.fd != NGX_INVALID_FILE)\n    {\n        if (ngx_delete_file(u->pipe->temp_file->file.name.data)\n            == NGX_FILE_ERROR)\n        {\n            ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                          ngx_delete_file_n \" \\\"%s\\\" failed\",\n                          u->pipe->temp_file->file.name.data);\n        }\n    }\n\n#if (NGX_HTTP_CACHE)\n\n    if (r->cache) {\n\n        if (u->cacheable) {\n\n            if (rc == NGX_HTTP_BAD_GATEWAY || rc == NGX_HTTP_GATEWAY_TIME_OUT) {\n                time_t  valid;\n\n                valid = ngx_http_file_cache_valid(u->conf->cache_valid, rc);\n\n                if (valid) {\n                    r->cache->valid_sec = ngx_time() + valid;\n                    r->cache->error = rc;\n                }\n            }\n        }\n\n        ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n    }\n\n#endif\n\n    if (r->subrequest_in_memory\n        && u->headers_in.status_n >= NGX_HTTP_SPECIAL_RESPONSE)\n    {\n        u->buffer.last = u->buffer.pos;\n    }\n\n    r->read_event_handler = ngx_http_block_reading;\n\n    if (rc == NGX_DECLINED) {\n        return;\n    }\n\n    r->connection->log->action = \"sending to client\";\n\n    if (!u->header_sent\n        || rc == NGX_HTTP_REQUEST_TIME_OUT\n        || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST\n        || (u->pipe && u->pipe->downstream_error))\n    {\n        ngx_http_finalize_request(r, rc);\n        return;\n    }\n\n    flush = 0;\n\n    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {\n        rc = NGX_ERROR;\n        flush = 1;\n    }\n\n    if (r->header_only) {\n        ngx_http_finalize_request(r, rc);\n        return;\n    }\n\n    if (rc == 0) {\n        rc = ngx_http_send_special(r, NGX_HTTP_LAST);\n\n    } else if (flush) {\n        r->keepalive = 0;\n        rc = ngx_http_send_special(r, NGX_HTTP_FLUSH);\n    }\n\n    ngx_http_finalize_request(r, rc);\n}", "patch_func_code": "static void\nngx_http_upstream_finalize_request(ngx_http_request_t *r,\n    ngx_http_upstream_t *u, ngx_int_t rc)\n{\n    ngx_uint_t  flush;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"finalize http upstream request: %i\", rc);\n\n    if (u->cleanup == NULL) {\n        /* the request was already finalized */\n        ngx_http_finalize_request(r, NGX_DONE);\n        return;\n    }\n\n    *u->cleanup = NULL;\n    u->cleanup = NULL;\n\n    if (u->resolved && u->resolved->ctx) {\n        ngx_resolve_name_done(u->resolved->ctx);\n        u->resolved->ctx = NULL;\n    }\n\n    if (u->state && u->state->response_time) {\n        u->state->response_time = ngx_current_msec - u->state->response_time;\n\n        if (u->pipe && u->pipe->read_length) {\n            u->state->bytes_received += u->pipe->read_length\n                                        - u->pipe->preread_size;\n            u->state->response_length = u->pipe->read_length;\n        }\n    }\n\n    u->finalize_request(r, rc);\n\n    if (u->peer.free && u->peer.sockaddr) {\n        u->peer.free(&u->peer, u->peer.data, 0);\n        u->peer.sockaddr = NULL;\n    }\n\n    if (u->peer.connection) {\n\n#if (NGX_HTTP_SSL)\n\n        /* TODO: do not shutdown persistent connection */\n\n        if (u->peer.connection->ssl) {\n\n            /*\n             * We send the \"close notify\" shutdown alert to the upstream only\n             * and do not wait its \"close notify\" shutdown alert.\n             * It is acceptable according to the TLS standard.\n             */\n\n            u->peer.connection->ssl->no_wait_shutdown = 1;\n\n            (void) ngx_ssl_shutdown(u->peer.connection);\n        }\n#endif\n\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"close http upstream connection: %d\",\n                       u->peer.connection->fd);\n\n        if (u->peer.connection->pool) {\n            ngx_destroy_pool(u->peer.connection->pool);\n        }\n\n        ngx_close_connection(u->peer.connection);\n    }\n\n    u->peer.connection = NULL;\n\n    if (u->pipe && u->pipe->temp_file) {\n        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                       \"http upstream temp fd: %d\",\n                       u->pipe->temp_file->file.fd);\n    }\n\n    if (u->store && u->pipe && u->pipe->temp_file\n        && u->pipe->temp_file->file.fd != NGX_INVALID_FILE)\n    {\n        if (ngx_delete_file(u->pipe->temp_file->file.name.data)\n            == NGX_FILE_ERROR)\n        {\n            ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                          ngx_delete_file_n \" \\\"%s\\\" failed\",\n                          u->pipe->temp_file->file.name.data);\n        }\n    }\n\n#if (NGX_HTTP_CACHE)\n\n    if (r->cache) {\n\n        if (u->cacheable) {\n\n            if (rc == NGX_HTTP_BAD_GATEWAY || rc == NGX_HTTP_GATEWAY_TIME_OUT) {\n                time_t  valid;\n\n                valid = ngx_http_file_cache_valid(u->conf->cache_valid, rc);\n\n                if (valid) {\n                    r->cache->valid_sec = ngx_time() + valid;\n                    r->cache->error = rc;\n                }\n            }\n        }\n\n        ngx_http_file_cache_free(r->cache, u->pipe->temp_file);\n    }\n\n#endif\n\n    if (r->subrequest_in_memory\n        && u->headers_in.status_n >= NGX_HTTP_SPECIAL_RESPONSE)\n    {\n        u->buffer.last = u->buffer.pos;\n    }\n\n    r->read_event_handler = ngx_http_block_reading;\n\n    if (rc == NGX_DECLINED) {\n        return;\n    }\n\n    r->connection->log->action = \"sending to client\";\n\n    if (!u->header_sent\n        || rc == NGX_HTTP_REQUEST_TIME_OUT\n        || rc == NGX_HTTP_CLIENT_CLOSED_REQUEST)\n    {\n        ngx_http_finalize_request(r, rc);\n        return;\n    }\n\n    flush = 0;\n\n    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {\n        rc = NGX_ERROR;\n        flush = 1;\n    }\n\n    if (r->header_only\n        || (u->pipe && u->pipe->downstream_error))\n    {\n        ngx_http_finalize_request(r, rc);\n        return;\n    }\n\n    if (rc == 0) {\n        rc = ngx_http_send_special(r, NGX_HTTP_LAST);\n\n    } else if (flush) {\n        r->keepalive = 0;\n        rc = ngx_http_send_special(r, NGX_HTTP_FLUSH);\n    }\n\n    ngx_http_finalize_request(r, rc);\n}", "before_change_lines": [131, 132, 145], "raw_before_change_lines": [131, 132, 145], "after_change_lines": [131, 144, 145, 146], "raw_after_change_lines": [131, 144, 145, 146], "bug_lines": [131, 132, 145], "added": [false, false, false], "idx": 327}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "9887----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_20929aa7119dc0f1338b484d9449ff9b3cfa05e5_1.json----ngx_http_map", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_20929aa7119dc0f1338b484d9449ff9b3cfa05e5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_20929aa7119dc0f1338b484d9449ff9b3cfa05e5_1.json", "function_name": "ngx_http_map", "vul_func_code": "static char *\nngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)\n{\n    ngx_int_t                   rc, index;\n    ngx_str_t                  *value, file, name;\n    ngx_uint_t                  i, key;\n    ngx_http_map_conf_ctx_t    *ctx;\n    ngx_http_variable_value_t  *var, **vp;\n\n    ctx = cf->ctx;\n\n    value = cf->args->elts;\n\n    if (cf->args->nelts == 1\n        && ngx_strcmp(value[0].data, \"hostnames\") == 0)\n    {\n        ctx->hostnames = 1;\n        return NGX_CONF_OK;\n\n    } else if (cf->args->nelts != 2) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid number of the map parameters\");\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_strcmp(value[0].data, \"include\") == 0) {\n        file = value[1];\n\n        if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n\n        return ngx_conf_parse(cf, &file);\n    }\n\n    if (value[1].data[0] == '$') {\n        name = value[1];\n        name.len--;\n        name.data++;\n\n        index = ngx_http_get_variable_index(ctx->cf, &name);\n        if (index == NGX_ERROR) {\n            return NGX_CONF_ERROR;\n        }\n\n        var = ctx->var_values.elts;\n\n        for (i = 0; i < ctx->var_values.nelts; i++) {\n            if (index == (ngx_int_t) var[i].data) {\n                var = &var[i];\n                goto found;\n            }\n        }\n\n        var = ngx_array_push(&ctx->var_values);\n        if (var == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        var->valid = 0;\n        var->no_cacheable = 0;\n        var->not_found = 0;\n        var->len = 0;\n        var->data = (u_char *) index;\n\n        goto found;\n    }\n\n    key = 0;\n\n    for (i = 0; i < value[1].len; i++) {\n        key = ngx_hash(key, value[1].data[i]);\n    }\n\n    key %= ctx->keys.hsize;\n\n    vp = ctx->values_hash[key].elts;\n\n    if (vp) {\n        for (i = 0; i < ctx->values_hash[key].nelts; i++) {\n            if (value[1].len != (size_t) vp[i]->len) {\n                continue;\n            }\n\n            if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) {\n                var = vp[i];\n                goto found;\n            }\n        }\n\n    } else {\n        if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4,\n                           sizeof(ngx_http_variable_value_t *))\n            != NGX_OK)\n        {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t));\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->len = value[1].len;\n    var->data = ngx_pstrdup(ctx->keys.pool, &value[1]);\n    if (var->data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->valid = 1;\n    var->no_cacheable = 0;\n    var->not_found = 0;\n\n    vp = ngx_array_push(&ctx->values_hash[key]);\n    if (vp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *vp = var;\n\nfound:\n\n    if (ngx_strcmp(value[0].data, \"default\") == 0) {\n\n        if (ctx->default_value) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"duplicate default map parameter\");\n            return NGX_CONF_ERROR;\n        }\n\n        ctx->default_value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#if (NGX_PCRE)\n\n    if (value[0].len && value[0].data[0] == '~') {\n        ngx_regex_compile_t    rc;\n        ngx_http_map_regex_t  *regex;\n        u_char                 errstr[NGX_MAX_CONF_ERRSTR];\n\n        regex = ngx_array_push(&ctx->regexes);\n        if (regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        value[0].len--;\n        value[0].data++;\n\n        ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n\n        if (value[0].data[0] == '*') {\n            value[0].len--;\n            value[0].data++;\n            rc.options = NGX_REGEX_CASELESS;\n        }\n\n        rc.pattern = value[0];\n        rc.err.len = NGX_MAX_CONF_ERRSTR;\n        rc.err.data = errstr;\n\n        regex->regex = ngx_http_regex_compile(ctx->cf, &rc);\n        if (regex->regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        regex->value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#endif\n\n    if (value[0].len && value[0].data[0] == '\\\\') {\n        value[0].len--;\n        value[0].data++;\n    }\n\n    rc = ngx_hash_add_key(&ctx->keys, &value[0], var,\n                          (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0);\n\n    if (rc == NGX_OK) {\n        return NGX_CONF_OK;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid hostname or wildcard \\\"%V\\\"\", &value[0]);\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting parameter \\\"%V\\\"\", &value[0]);\n    }\n\n    return NGX_CONF_ERROR;\n}", "patch_func_code": "static char *\nngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)\n{\n    ngx_int_t                   rc, index;\n    ngx_str_t                  *value, name;\n    ngx_uint_t                  i, key;\n    ngx_http_map_conf_ctx_t    *ctx;\n    ngx_http_variable_value_t  *var, **vp;\n\n    ctx = cf->ctx;\n\n    value = cf->args->elts;\n\n    if (cf->args->nelts == 1\n        && ngx_strcmp(value[0].data, \"hostnames\") == 0)\n    {\n        ctx->hostnames = 1;\n        return NGX_CONF_OK;\n\n    } else if (cf->args->nelts != 2) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid number of the map parameters\");\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_strcmp(value[0].data, \"include\") == 0) {\n        return ngx_conf_include(cf, dummy, conf);\n    }\n\n    if (value[1].data[0] == '$') {\n        name = value[1];\n        name.len--;\n        name.data++;\n\n        index = ngx_http_get_variable_index(ctx->cf, &name);\n        if (index == NGX_ERROR) {\n            return NGX_CONF_ERROR;\n        }\n\n        var = ctx->var_values.elts;\n\n        for (i = 0; i < ctx->var_values.nelts; i++) {\n            if (index == (ngx_int_t) var[i].data) {\n                var = &var[i];\n                goto found;\n            }\n        }\n\n        var = ngx_array_push(&ctx->var_values);\n        if (var == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        var->valid = 0;\n        var->no_cacheable = 0;\n        var->not_found = 0;\n        var->len = 0;\n        var->data = (u_char *) index;\n\n        goto found;\n    }\n\n    key = 0;\n\n    for (i = 0; i < value[1].len; i++) {\n        key = ngx_hash(key, value[1].data[i]);\n    }\n\n    key %= ctx->keys.hsize;\n\n    vp = ctx->values_hash[key].elts;\n\n    if (vp) {\n        for (i = 0; i < ctx->values_hash[key].nelts; i++) {\n            if (value[1].len != (size_t) vp[i]->len) {\n                continue;\n            }\n\n            if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) {\n                var = vp[i];\n                goto found;\n            }\n        }\n\n    } else {\n        if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4,\n                           sizeof(ngx_http_variable_value_t *))\n            != NGX_OK)\n        {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t));\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->len = value[1].len;\n    var->data = ngx_pstrdup(ctx->keys.pool, &value[1]);\n    if (var->data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->valid = 1;\n    var->no_cacheable = 0;\n    var->not_found = 0;\n\n    vp = ngx_array_push(&ctx->values_hash[key]);\n    if (vp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *vp = var;\n\nfound:\n\n    if (ngx_strcmp(value[0].data, \"default\") == 0) {\n\n        if (ctx->default_value) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"duplicate default map parameter\");\n            return NGX_CONF_ERROR;\n        }\n\n        ctx->default_value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#if (NGX_PCRE)\n\n    if (value[0].len && value[0].data[0] == '~') {\n        ngx_regex_compile_t    rc;\n        ngx_http_map_regex_t  *regex;\n        u_char                 errstr[NGX_MAX_CONF_ERRSTR];\n\n        regex = ngx_array_push(&ctx->regexes);\n        if (regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        value[0].len--;\n        value[0].data++;\n\n        ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n\n        if (value[0].data[0] == '*') {\n            value[0].len--;\n            value[0].data++;\n            rc.options = NGX_REGEX_CASELESS;\n        }\n\n        rc.pattern = value[0];\n        rc.err.len = NGX_MAX_CONF_ERRSTR;\n        rc.err.data = errstr;\n\n        regex->regex = ngx_http_regex_compile(ctx->cf, &rc);\n        if (regex->regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        regex->value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#endif\n\n    if (value[0].len && value[0].data[0] == '\\\\') {\n        value[0].len--;\n        value[0].data++;\n    }\n\n    rc = ngx_hash_add_key(&ctx->keys, &value[0], var,\n                          (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0);\n\n    if (rc == NGX_OK) {\n        return NGX_CONF_OK;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid hostname or wildcard \\\"%V\\\"\", &value[0]);\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting parameter \\\"%V\\\"\", &value[0]);\n    }\n\n    return NGX_CONF_ERROR;\n}", "before_change_lines": [5, 27, 29, 30, 31, 33, 35], "raw_before_change_lines": [5, 27, 28, 29, 30, 31, 32, 33, 34, 35], "after_change_lines": [5, 27], "raw_after_change_lines": [5, 27], "bug_lines": [5, 27, 28, 29, 30, 31, 32, 33, 34, 35], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 328}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9896----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_25176bafe8a006b6a2fea2a5bc9aa90d0ca0378f_1.json----ngx_inet_addr", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_25176bafe8a006b6a2fea2a5bc9aa90d0ca0378f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_25176bafe8a006b6a2fea2a5bc9aa90d0ca0378f_1.json", "function_name": "ngx_inet_addr", "vul_func_code": "in_addr_t\nngx_inet_addr(u_char *text, size_t len)\n{\n    u_char      *p, c;\n    in_addr_t    addr;\n    ngx_uint_t   octet, n;\n\n    addr = 0;\n    octet = 0;\n    n = 0;\n\n    for (p = text; p < text + len; p++) {\n\n        if (octet > 255) {\n            return INADDR_NONE;\n        }\n\n        c = *p;\n\n        if (c >= '0' && c <= '9') {\n            octet = octet * 10 + (c - '0');\n            continue;\n        }\n\n        if (c == '.') {\n            addr = (addr << 8) + octet;\n            octet = 0;\n            n++;\n            continue;\n        }\n\n        return INADDR_NONE;\n    }\n\n    if (n == 3) {\n        addr = (addr << 8) + octet;\n        return htonl(addr);\n    }\n\n    return INADDR_NONE;\n}", "patch_func_code": "in_addr_t\nngx_inet_addr(u_char *text, size_t len)\n{\n    u_char      *p, c;\n    in_addr_t    addr;\n    ngx_uint_t   octet, n;\n\n    addr = 0;\n    octet = 0;\n    n = 0;\n\n    for (p = text; p < text + len; p++) {\n        c = *p;\n\n        if (c >= '0' && c <= '9') {\n            octet = octet * 10 + (c - '0');\n\n            if (octet > 255) {\n                return INADDR_NONE;\n            }\n\n            continue;\n        }\n\n        if (c == '.') {\n            addr = (addr << 8) + octet;\n            octet = 0;\n            n++;\n            continue;\n        }\n\n        return INADDR_NONE;\n    }\n\n    if (n == 3) {\n        addr = (addr << 8) + octet;\n        return htonl(addr);\n    }\n\n    return INADDR_NONE;\n}", "before_change_lines": [14, 15, 16], "raw_before_change_lines": [13, 14, 15, 16, 17], "after_change_lines": [18, 19, 20], "raw_after_change_lines": [17, 18, 19, 20, 21], "bug_lines": [13, 14, 15, 16, 17], "added": [false, false, false, false, false], "idx": 329}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9906----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_2e32a0a724ab0b1a72dd2844cdfe2bc0d1917f9f_1.json----ngx_http_proxy_create_request", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_2e32a0a724ab0b1a72dd2844cdfe2bc0d1917f9f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_2e32a0a724ab0b1a72dd2844cdfe2bc0d1917f9f_1.json", "function_name": "ngx_http_proxy_create_request", "vul_func_code": "static ngx_int_t\nngx_http_proxy_create_request(ngx_http_request_t *r)\n{\n    size_t                        len, uri_len, loc_len, body_len;\n    uintptr_t                     escape;\n    ngx_buf_t                    *b;\n    ngx_str_t                     method;\n    ngx_uint_t                    i, unparsed_uri;\n    ngx_chain_t                  *cl, *body;\n    ngx_list_part_t              *part;\n    ngx_table_elt_t              *header;\n    ngx_http_upstream_t          *u;\n    ngx_http_proxy_ctx_t         *ctx;\n    ngx_http_script_code_pt       code;\n    ngx_http_script_engine_t      e, le;\n    ngx_http_proxy_loc_conf_t    *plcf;\n    ngx_http_script_len_code_pt   lcode;\n\n    u = r->upstream;\n\n    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);\n\n    if (u->method.len) {\n        /* HEAD was changed to GET to cache response */\n        method = u->method;\n        method.len++;\n\n    } else if (plcf->method.len) {\n        method = plcf->method;\n\n    } else {\n        method = r->method_name;\n        method.len++;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);\n\n    if (method.len == 5\n        && ngx_strncasecmp(method.data, (u_char *) \"HEAD \", 5) == 0)\n    {\n        ctx->head = 1;\n    }\n\n    len = method.len + sizeof(ngx_http_proxy_version) - 1 + sizeof(CRLF) - 1;\n\n    escape = 0;\n    loc_len = 0;\n    unparsed_uri = 0;\n\n    if (plcf->proxy_lengths) {\n        uri_len = ctx->vars.uri.len;\n\n    } else if (ctx->vars.uri.len == 0 && r->valid_unparsed_uri && r == r->main)\n    {\n        unparsed_uri = 1;\n        uri_len = r->unparsed_uri.len;\n\n    } else {\n        loc_len = (r->valid_location && ctx->vars.uri.len) ?\n                      plcf->location.len : 0;\n\n        if (r->quoted_uri || r->space_in_uri || r->internal) {\n            escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len,\n                                        r->uri.len - loc_len, NGX_ESCAPE_URI);\n        }\n\n        uri_len = ctx->vars.uri.len + r->uri.len - loc_len + escape\n                  + sizeof(\"?\") - 1 + r->args.len;\n    }\n\n    if (uri_len == 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"zero length URI to proxy\");\n        return NGX_ERROR;\n    }\n\n    len += uri_len;\n\n    ngx_http_script_flush_no_cacheable_variables(r, plcf->flushes);\n\n    if (plcf->body_set_len) {\n        le.ip = plcf->body_set_len->elts;\n        le.request = r;\n        le.flushed = 1;\n        body_len = 0;\n\n        while (*(uintptr_t *) le.ip) {\n            lcode = *(ngx_http_script_len_code_pt *) le.ip;\n            body_len += lcode(&le);\n        }\n\n        ctx->internal_body_length = body_len;\n        len += body_len;\n    }\n\n    le.ip = plcf->headers_set_len->elts;\n    le.request = r;\n    le.flushed = 1;\n\n    while (*(uintptr_t *) le.ip) {\n        while (*(uintptr_t *) le.ip) {\n            lcode = *(ngx_http_script_len_code_pt *) le.ip;\n            len += lcode(&le);\n        }\n        le.ip += sizeof(uintptr_t);\n    }\n\n\n    if (plcf->upstream.pass_request_headers) {\n        part = &r->headers_in.headers.part;\n        header = part->elts;\n\n        for (i = 0; /* void */; i++) {\n\n            if (i >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n\n                part = part->next;\n                header = part->elts;\n                i = 0;\n            }\n\n            if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash,\n                              header[i].lowcase_key, header[i].key.len))\n            {\n                continue;\n            }\n\n            len += header[i].key.len + sizeof(\": \") - 1\n                + header[i].value.len + sizeof(CRLF) - 1;\n        }\n    }\n\n\n    b = ngx_create_temp_buf(r->pool, len);\n    if (b == NULL) {\n        return NGX_ERROR;\n    }\n\n    cl = ngx_alloc_chain_link(r->pool);\n    if (cl == NULL) {\n        return NGX_ERROR;\n    }\n\n    cl->buf = b;\n\n\n    /* the request line */\n\n    b->last = ngx_copy(b->last, method.data, method.len);\n\n    u->uri.data = b->last;\n\n    if (plcf->proxy_lengths) {\n        b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len);\n\n    } else if (unparsed_uri) {\n        b->last = ngx_copy(b->last, r->unparsed_uri.data, r->unparsed_uri.len);\n\n    } else {\n        if (r->valid_location) {\n            b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len);\n        }\n\n        if (escape) {\n            ngx_escape_uri(b->last, r->uri.data + loc_len,\n                           r->uri.len - loc_len, NGX_ESCAPE_URI);\n            b->last += r->uri.len - loc_len + escape;\n\n        } else {\n            b->last = ngx_copy(b->last, r->uri.data + loc_len,\n                               r->uri.len - loc_len);\n        }\n\n        if (r->args.len > 0) {\n            *b->last++ = '?';\n            b->last = ngx_copy(b->last, r->args.data, r->args.len);\n        }\n    }\n\n    u->uri.len = b->last - u->uri.data;\n\n    if (plcf->http_version == NGX_HTTP_VERSION_11) {\n        b->last = ngx_cpymem(b->last, ngx_http_proxy_version_11,\n                             sizeof(ngx_http_proxy_version_11) - 1);\n\n    } else {\n        b->last = ngx_cpymem(b->last, ngx_http_proxy_version,\n                             sizeof(ngx_http_proxy_version) - 1);\n    }\n\n    ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n\n    e.ip = plcf->headers_set->elts;\n    e.pos = b->last;\n    e.request = r;\n    e.flushed = 1;\n\n    le.ip = plcf->headers_set_len->elts;\n\n    while (*(uintptr_t *) le.ip) {\n        lcode = *(ngx_http_script_len_code_pt *) le.ip;\n\n        /* skip the header line name length */\n        (void) lcode(&le);\n\n        if (*(ngx_http_script_len_code_pt *) le.ip) {\n\n            for (len = 0; *(uintptr_t *) le.ip; len += lcode(&le)) {\n                lcode = *(ngx_http_script_len_code_pt *) le.ip;\n            }\n\n            e.skip = (len == sizeof(CRLF) - 1) ? 1 : 0;\n\n        } else {\n            e.skip = 0;\n        }\n\n        le.ip += sizeof(uintptr_t);\n\n        while (*(uintptr_t *) e.ip) {\n            code = *(ngx_http_script_code_pt *) e.ip;\n            code((ngx_http_script_engine_t *) &e);\n        }\n        e.ip += sizeof(uintptr_t);\n    }\n\n    b->last = e.pos;\n\n\n    if (plcf->upstream.pass_request_headers) {\n        part = &r->headers_in.headers.part;\n        header = part->elts;\n\n        for (i = 0; /* void */; i++) {\n\n            if (i >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n\n                part = part->next;\n                header = part->elts;\n                i = 0;\n            }\n\n            if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash,\n                              header[i].lowcase_key, header[i].key.len))\n            {\n                continue;\n            }\n\n            b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n\n            *b->last++ = ':'; *b->last++ = ' ';\n\n            b->last = ngx_copy(b->last, header[i].value.data,\n                               header[i].value.len);\n\n            *b->last++ = CR; *b->last++ = LF;\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http proxy header: \\\"%V: %V\\\"\",\n                           &header[i].key, &header[i].value);\n        }\n    }\n\n\n    /* add \"\\r\\n\" at the header end */\n    *b->last++ = CR; *b->last++ = LF;\n\n    if (plcf->body_set) {\n        e.ip = plcf->body_set->elts;\n        e.pos = b->last;\n\n        while (*(uintptr_t *) e.ip) {\n            code = *(ngx_http_script_code_pt *) e.ip;\n            code((ngx_http_script_engine_t *) &e);\n        }\n\n        b->last = e.pos;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http proxy header:\\n\\\"%*s\\\"\",\n                   (size_t) (b->last - b->pos), b->pos);\n\n    if (plcf->body_set == NULL && plcf->upstream.pass_request_body) {\n\n        body = u->request_bufs;\n        u->request_bufs = cl;\n\n        while (body) {\n            b = ngx_alloc_buf(r->pool);\n            if (b == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(b, body->buf, sizeof(ngx_buf_t));\n\n            cl->next = ngx_alloc_chain_link(r->pool);\n            if (cl->next == NULL) {\n                return NGX_ERROR;\n            }\n\n            cl = cl->next;\n            cl->buf = b;\n\n            body = body->next;\n        }\n\n    } else {\n        u->request_bufs = cl;\n    }\n\n    b->flush = 1;\n    cl->next = NULL;\n\n    return NGX_OK;\n}", "patch_func_code": "static ngx_int_t\nngx_http_proxy_create_request(ngx_http_request_t *r)\n{\n    size_t                        len, uri_len, loc_len, body_len;\n    uintptr_t                     escape;\n    ngx_buf_t                    *b;\n    ngx_str_t                     method;\n    ngx_uint_t                    i, unparsed_uri;\n    ngx_chain_t                  *cl, *body;\n    ngx_list_part_t              *part;\n    ngx_table_elt_t              *header;\n    ngx_http_upstream_t          *u;\n    ngx_http_proxy_ctx_t         *ctx;\n    ngx_http_script_code_pt       code;\n    ngx_http_script_engine_t      e, le;\n    ngx_http_proxy_loc_conf_t    *plcf;\n    ngx_http_script_len_code_pt   lcode;\n\n    u = r->upstream;\n\n    plcf = ngx_http_get_module_loc_conf(r, ngx_http_proxy_module);\n\n    if (u->method.len) {\n        /* HEAD was changed to GET to cache response */\n        method = u->method;\n        method.len++;\n\n    } else if (plcf->method.len) {\n        method = plcf->method;\n\n    } else {\n        method = r->method_name;\n        method.len++;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);\n\n    if (method.len == 5\n        && ngx_strncasecmp(method.data, (u_char *) \"HEAD \", 5) == 0)\n    {\n        ctx->head = 1;\n    }\n\n    len = method.len + sizeof(ngx_http_proxy_version) - 1 + sizeof(CRLF) - 1;\n\n    escape = 0;\n    loc_len = 0;\n    unparsed_uri = 0;\n\n    if (plcf->proxy_lengths && ctx->vars.uri.len) {\n        uri_len = ctx->vars.uri.len;\n\n    } else if (ctx->vars.uri.len == 0 && r->valid_unparsed_uri && r == r->main)\n    {\n        unparsed_uri = 1;\n        uri_len = r->unparsed_uri.len;\n\n    } else {\n        loc_len = (r->valid_location && ctx->vars.uri.len) ?\n                      plcf->location.len : 0;\n\n        if (r->quoted_uri || r->space_in_uri || r->internal) {\n            escape = 2 * ngx_escape_uri(NULL, r->uri.data + loc_len,\n                                        r->uri.len - loc_len, NGX_ESCAPE_URI);\n        }\n\n        uri_len = ctx->vars.uri.len + r->uri.len - loc_len + escape\n                  + sizeof(\"?\") - 1 + r->args.len;\n    }\n\n    if (uri_len == 0) {\n        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                      \"zero length URI to proxy\");\n        return NGX_ERROR;\n    }\n\n    len += uri_len;\n\n    ngx_http_script_flush_no_cacheable_variables(r, plcf->flushes);\n\n    if (plcf->body_set_len) {\n        le.ip = plcf->body_set_len->elts;\n        le.request = r;\n        le.flushed = 1;\n        body_len = 0;\n\n        while (*(uintptr_t *) le.ip) {\n            lcode = *(ngx_http_script_len_code_pt *) le.ip;\n            body_len += lcode(&le);\n        }\n\n        ctx->internal_body_length = body_len;\n        len += body_len;\n    }\n\n    le.ip = plcf->headers_set_len->elts;\n    le.request = r;\n    le.flushed = 1;\n\n    while (*(uintptr_t *) le.ip) {\n        while (*(uintptr_t *) le.ip) {\n            lcode = *(ngx_http_script_len_code_pt *) le.ip;\n            len += lcode(&le);\n        }\n        le.ip += sizeof(uintptr_t);\n    }\n\n\n    if (plcf->upstream.pass_request_headers) {\n        part = &r->headers_in.headers.part;\n        header = part->elts;\n\n        for (i = 0; /* void */; i++) {\n\n            if (i >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n\n                part = part->next;\n                header = part->elts;\n                i = 0;\n            }\n\n            if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash,\n                              header[i].lowcase_key, header[i].key.len))\n            {\n                continue;\n            }\n\n            len += header[i].key.len + sizeof(\": \") - 1\n                + header[i].value.len + sizeof(CRLF) - 1;\n        }\n    }\n\n\n    b = ngx_create_temp_buf(r->pool, len);\n    if (b == NULL) {\n        return NGX_ERROR;\n    }\n\n    cl = ngx_alloc_chain_link(r->pool);\n    if (cl == NULL) {\n        return NGX_ERROR;\n    }\n\n    cl->buf = b;\n\n\n    /* the request line */\n\n    b->last = ngx_copy(b->last, method.data, method.len);\n\n    u->uri.data = b->last;\n\n    if (plcf->proxy_lengths && ctx->vars.uri.len) {\n        b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len);\n\n    } else if (unparsed_uri) {\n        b->last = ngx_copy(b->last, r->unparsed_uri.data, r->unparsed_uri.len);\n\n    } else {\n        if (r->valid_location) {\n            b->last = ngx_copy(b->last, ctx->vars.uri.data, ctx->vars.uri.len);\n        }\n\n        if (escape) {\n            ngx_escape_uri(b->last, r->uri.data + loc_len,\n                           r->uri.len - loc_len, NGX_ESCAPE_URI);\n            b->last += r->uri.len - loc_len + escape;\n\n        } else {\n            b->last = ngx_copy(b->last, r->uri.data + loc_len,\n                               r->uri.len - loc_len);\n        }\n\n        if (r->args.len > 0) {\n            *b->last++ = '?';\n            b->last = ngx_copy(b->last, r->args.data, r->args.len);\n        }\n    }\n\n    u->uri.len = b->last - u->uri.data;\n\n    if (plcf->http_version == NGX_HTTP_VERSION_11) {\n        b->last = ngx_cpymem(b->last, ngx_http_proxy_version_11,\n                             sizeof(ngx_http_proxy_version_11) - 1);\n\n    } else {\n        b->last = ngx_cpymem(b->last, ngx_http_proxy_version,\n                             sizeof(ngx_http_proxy_version) - 1);\n    }\n\n    ngx_memzero(&e, sizeof(ngx_http_script_engine_t));\n\n    e.ip = plcf->headers_set->elts;\n    e.pos = b->last;\n    e.request = r;\n    e.flushed = 1;\n\n    le.ip = plcf->headers_set_len->elts;\n\n    while (*(uintptr_t *) le.ip) {\n        lcode = *(ngx_http_script_len_code_pt *) le.ip;\n\n        /* skip the header line name length */\n        (void) lcode(&le);\n\n        if (*(ngx_http_script_len_code_pt *) le.ip) {\n\n            for (len = 0; *(uintptr_t *) le.ip; len += lcode(&le)) {\n                lcode = *(ngx_http_script_len_code_pt *) le.ip;\n            }\n\n            e.skip = (len == sizeof(CRLF) - 1) ? 1 : 0;\n\n        } else {\n            e.skip = 0;\n        }\n\n        le.ip += sizeof(uintptr_t);\n\n        while (*(uintptr_t *) e.ip) {\n            code = *(ngx_http_script_code_pt *) e.ip;\n            code((ngx_http_script_engine_t *) &e);\n        }\n        e.ip += sizeof(uintptr_t);\n    }\n\n    b->last = e.pos;\n\n\n    if (plcf->upstream.pass_request_headers) {\n        part = &r->headers_in.headers.part;\n        header = part->elts;\n\n        for (i = 0; /* void */; i++) {\n\n            if (i >= part->nelts) {\n                if (part->next == NULL) {\n                    break;\n                }\n\n                part = part->next;\n                header = part->elts;\n                i = 0;\n            }\n\n            if (ngx_hash_find(&plcf->headers_set_hash, header[i].hash,\n                              header[i].lowcase_key, header[i].key.len))\n            {\n                continue;\n            }\n\n            b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);\n\n            *b->last++ = ':'; *b->last++ = ' ';\n\n            b->last = ngx_copy(b->last, header[i].value.data,\n                               header[i].value.len);\n\n            *b->last++ = CR; *b->last++ = LF;\n\n            ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                           \"http proxy header: \\\"%V: %V\\\"\",\n                           &header[i].key, &header[i].value);\n        }\n    }\n\n\n    /* add \"\\r\\n\" at the header end */\n    *b->last++ = CR; *b->last++ = LF;\n\n    if (plcf->body_set) {\n        e.ip = plcf->body_set->elts;\n        e.pos = b->last;\n\n        while (*(uintptr_t *) e.ip) {\n            code = *(ngx_http_script_code_pt *) e.ip;\n            code((ngx_http_script_engine_t *) &e);\n        }\n\n        b->last = e.pos;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http proxy header:\\n\\\"%*s\\\"\",\n                   (size_t) (b->last - b->pos), b->pos);\n\n    if (plcf->body_set == NULL && plcf->upstream.pass_request_body) {\n\n        body = u->request_bufs;\n        u->request_bufs = cl;\n\n        while (body) {\n            b = ngx_alloc_buf(r->pool);\n            if (b == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(b, body->buf, sizeof(ngx_buf_t));\n\n            cl->next = ngx_alloc_chain_link(r->pool);\n            if (cl->next == NULL) {\n                return NGX_ERROR;\n            }\n\n            cl = cl->next;\n            cl->buf = b;\n\n            body = body->next;\n        }\n\n    } else {\n        u->request_bufs = cl;\n    }\n\n    b->flush = 1;\n    cl->next = NULL;\n\n    return NGX_OK;\n}", "before_change_lines": [50, 156], "raw_before_change_lines": [50, 156], "after_change_lines": [50, 156], "raw_after_change_lines": [50, 156], "bug_lines": [50, 156], "added": [false, false], "idx": 330}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "9917----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_36f20e5aa9532fe881dd9d602caaeb7b331ea552_1.json----ngx_http_file_cache_add", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_36f20e5aa9532fe881dd9d602caaeb7b331ea552_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_36f20e5aa9532fe881dd9d602caaeb7b331ea552_1.json", "function_name": "ngx_http_file_cache_add", "vul_func_code": "static ngx_int_t\nngx_http_file_cache_add(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)\n{\n    ngx_http_file_cache_node_t  *fcn;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    fcn = ngx_http_file_cache_lookup(cache, c->key);\n\n    if (fcn == NULL) {\n\n        fcn = ngx_slab_alloc_locked(cache->shpool,\n                                    sizeof(ngx_http_file_cache_node_t));\n        if (fcn == NULL) {\n            ngx_shmtx_unlock(&cache->shpool->mutex);\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy((u_char *) &fcn->node.key, c->key, sizeof(ngx_rbtree_key_t));\n\n        ngx_memcpy(fcn->key, &c->key[sizeof(ngx_rbtree_key_t)],\n                   NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t));\n\n        ngx_rbtree_insert(&cache->sh->rbtree, &fcn->node);\n\n        fcn->uses = 1;\n        fcn->count = 0;\n        fcn->valid_msec = 0;\n        fcn->error = 0;\n        fcn->exists = 1;\n        fcn->updating = 0;\n        fcn->deleting = 0;\n        fcn->uniq = 0;\n        fcn->valid_sec = 0;\n        fcn->body_start = 0;\n        fcn->fs_size = c->fs_size;\n\n        cache->sh->size += c->fs_size;\n\n    } else {\n        ngx_queue_remove(&fcn->queue);\n    }\n\n    fcn->expire = ngx_time() + cache->inactive;\n\n    ngx_queue_insert_head(&cache->sh->queue, &fcn->queue);\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    return NGX_OK;\n}", "patch_func_code": "static ngx_int_t\nngx_http_file_cache_add(ngx_http_file_cache_t *cache, ngx_http_cache_t *c)\n{\n    ngx_http_file_cache_node_t  *fcn;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    fcn = ngx_http_file_cache_lookup(cache, c->key);\n\n    if (fcn == NULL) {\n\n        fcn = ngx_slab_calloc_locked(cache->shpool,\n                                     sizeof(ngx_http_file_cache_node_t));\n        if (fcn == NULL) {\n            ngx_shmtx_unlock(&cache->shpool->mutex);\n            return NGX_ERROR;\n        }\n\n        ngx_memcpy((u_char *) &fcn->node.key, c->key, sizeof(ngx_rbtree_key_t));\n\n        ngx_memcpy(fcn->key, &c->key[sizeof(ngx_rbtree_key_t)],\n                   NGX_HTTP_CACHE_KEY_LEN - sizeof(ngx_rbtree_key_t));\n\n        ngx_rbtree_insert(&cache->sh->rbtree, &fcn->node);\n\n        fcn->uses = 1;\n        fcn->exists = 1;\n        fcn->fs_size = c->fs_size;\n\n        cache->sh->size += c->fs_size;\n\n    } else {\n        ngx_queue_remove(&fcn->queue);\n    }\n\n    fcn->expire = ngx_time() + cache->inactive;\n\n    ngx_queue_insert_head(&cache->sh->queue, &fcn->queue);\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    return NGX_OK;\n}", "before_change_lines": [12, 13, 27, 28, 29, 31, 32, 33, 34, 35], "raw_before_change_lines": [12, 13, 27, 28, 29, 31, 32, 33, 34, 35], "after_change_lines": [12, 13], "raw_after_change_lines": [12, 13], "bug_lines": [12, 13, 27, 28, 29, 31, 32, 33, 34, 35], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 331}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L1", "filepath_func": "9933----INTEGER_OVERFLOW_L1----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_404030dd7da72e271b205e52f6c292f43348345d_1.json----ngx_http_file_cache_cleanup", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_404030dd7da72e271b205e52f6c292f43348345d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_404030dd7da72e271b205e52f6c292f43348345d_1.json", "function_name": "ngx_http_file_cache_cleanup", "vul_func_code": "static void\nngx_http_file_cache_cleanup(void *data)\n{\n    ngx_http_cache_t  *c = data;\n\n    ngx_http_file_cache_t  *cache;\n\n    if (c->updated) {\n        return;\n    }\n\n    c->updated = 1;\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0,\n                   \"http file cache cleanup\");\n\n    if (c->error) {\n        return;\n    }\n\n    cache = c->file_cache;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    c->node->count--;\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n}", "patch_func_code": "static void\nngx_http_file_cache_cleanup(void *data)\n{\n    ngx_http_cache_t  *c = data;\n\n    if (c->updated) {\n        return;\n    }\n\n    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->file.log, 0,\n                   \"http file cache cleanup\");\n\n    if (c->updating) {\n        ngx_log_error(NGX_LOG_ALERT, c->file.log, 0,\n                      \"stalled cache updating, error:%ui\", c->error);\n    }\n\n    ngx_http_file_cache_free(c, NULL);\n}", "before_change_lines": [6, 12, 17, 18, 21, 23, 25, 27], "raw_before_change_lines": [6, 7, 12, 13, 17, 18, 21, 22, 23, 24, 25, 26, 27], "after_change_lines": [13, 14, 15, 18], "raw_after_change_lines": [13, 14, 15, 18], "bug_lines": [6, 7, 12, 13, 17, 18, 21, 22, 23, 24, 25, 26, 27], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 332}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "9936----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_41bc01be78854b521ed5a3ddab5cd6a9c156c114_1.json----ngx_http_add_referer", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_41bc01be78854b521ed5a3ddab5cd6a9c156c114_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_41bc01be78854b521ed5a3ddab5cd6a9c156c114_1.json", "function_name": "ngx_http_add_referer", "vul_func_code": "static ngx_int_t\nngx_http_add_referer(ngx_conf_t *cf, ngx_hash_keys_arrays_t *keys,\n    ngx_str_t *value, ngx_str_t *uri)\n{\n    ngx_int_t   rc;\n    ngx_str_t  *u;\n\n    if (uri->len == 0) {\n        u = NGX_HTTP_REFERER_NO_URI_PART;\n\n    } else {\n        u = ngx_palloc(cf->pool, sizeof(ngx_str_t));\n        if (u == NULL) {\n            return NGX_ERROR;\n        }\n\n        *u = *uri;\n    }\n\n    rc = ngx_hash_add_key(keys, value, u, NGX_HASH_WILDCARD_KEY);\n\n    if (rc == NGX_OK) {\n        return NGX_OK;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid hostname or wildcard \\\"%V\\\"\", value);\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting parameter \\\"%V\\\"\", value);\n    }\n\n    return NGX_ERROR;\n}", "patch_func_code": "static ngx_int_t\nngx_http_add_referer(ngx_conf_t *cf, ngx_hash_keys_arrays_t *keys,\n    ngx_str_t *value, ngx_str_t *uri)\n{\n    ngx_int_t   rc;\n    ngx_str_t  *u;\n\n    if (uri == NULL || uri->len == 0) {\n        u = NGX_HTTP_REFERER_NO_URI_PART;\n\n    } else {\n        u = ngx_palloc(cf->pool, sizeof(ngx_str_t));\n        if (u == NULL) {\n            return NGX_ERROR;\n        }\n\n        *u = *uri;\n    }\n\n    rc = ngx_hash_add_key(keys, value, u, NGX_HASH_WILDCARD_KEY);\n\n    if (rc == NGX_OK) {\n        return NGX_OK;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid hostname or wildcard \\\"%V\\\"\", value);\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting parameter \\\"%V\\\"\", value);\n    }\n\n    return NGX_ERROR;\n}", "before_change_lines": [8], "raw_before_change_lines": [8], "after_change_lines": [8], "raw_after_change_lines": [8], "bug_lines": [8], "added": [false], "idx": 333}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9954----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_4ba4017fe37d85797c7e2c9e338c55719db264c1_1.json----ngx_slab_init", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_4ba4017fe37d85797c7e2c9e338c55719db264c1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_4ba4017fe37d85797c7e2c9e338c55719db264c1_1.json", "function_name": "ngx_slab_init", "vul_func_code": "void\nngx_slab_init(ngx_slab_pool_t *pool)\n{\n    u_char           *p;\n    size_t            size;\n    ngx_int_t         m;\n    ngx_uint_t        i, n, pages;\n    ngx_slab_page_t  *slots, *page;\n\n    /* STUB */\n    if (ngx_slab_max_size == 0) {\n        ngx_slab_max_size = ngx_pagesize / 2;\n        ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));\n        for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {\n            /* void */\n        }\n    }\n    /**/\n\n    pool->min_size = 1 << pool->min_shift;\n\n    slots = ngx_slab_slots(pool);\n\n    p = (u_char *) slots;\n    size = pool->end - p;\n\n    ngx_slab_junk(p, size);\n\n    n = ngx_pagesize_shift - pool->min_shift;\n\n    for (i = 0; i < n; i++) {\n        /* only \"next\" is used in list head */\n        slots[i].slab = 0;\n        slots[i].next = &slots[i];\n        slots[i].prev = 0;\n    }\n\n    p += n * sizeof(ngx_slab_page_t);\n    size -= n * sizeof(ngx_slab_page_t);\n\n    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));\n\n    pool->pages = (ngx_slab_page_t *) p;\n    ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t));\n\n    page = pool->pages;\n\n    /* only \"next\" is used in list head */\n    pool->free.slab = 0;\n    pool->free.next = page;\n    pool->free.prev = 0;\n\n    page->slab = pages;\n    page->next = &pool->free;\n    page->prev = (uintptr_t) &pool->free;\n\n    pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t),\n                                ngx_pagesize);\n\n    m = pages - (pool->end - pool->start) / ngx_pagesize;\n    if (m > 0) {\n        pages -= m;\n        page->slab = pages;\n    }\n\n    pool->last = pool->pages + pages;\n\n    pool->log_nomem = 1;\n    pool->log_ctx = &pool->zero;\n    pool->zero = '\\0';\n}", "patch_func_code": "void\nngx_slab_init(ngx_slab_pool_t *pool)\n{\n    u_char           *p;\n    size_t            size;\n    ngx_int_t         m;\n    ngx_uint_t        i, n, pages;\n    ngx_slab_page_t  *slots, *page;\n\n    /* STUB */\n    if (ngx_slab_max_size == 0) {\n        ngx_slab_max_size = ngx_pagesize / 2;\n        ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));\n        for (n = ngx_slab_exact_size; n >>= 1; ngx_slab_exact_shift++) {\n            /* void */\n        }\n    }\n    /**/\n\n    pool->min_size = 1 << pool->min_shift;\n\n    slots = ngx_slab_slots(pool);\n\n    p = (u_char *) slots;\n    size = pool->end - p;\n\n    ngx_slab_junk(p, size);\n\n    n = ngx_pagesize_shift - pool->min_shift;\n\n    for (i = 0; i < n; i++) {\n        /* only \"next\" is used in list head */\n        slots[i].slab = 0;\n        slots[i].next = &slots[i];\n        slots[i].prev = 0;\n    }\n\n    p += n * sizeof(ngx_slab_page_t);\n\n    pool->stats = (ngx_slab_stat_t *) p;\n    ngx_memzero(pool->stats, n * sizeof(ngx_slab_stat_t));\n\n    p += n * sizeof(ngx_slab_stat_t);\n\n    size -= n * (sizeof(ngx_slab_page_t) + sizeof(ngx_slab_stat_t));\n\n    pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));\n\n    pool->pages = (ngx_slab_page_t *) p;\n    ngx_memzero(pool->pages, pages * sizeof(ngx_slab_page_t));\n\n    page = pool->pages;\n\n    /* only \"next\" is used in list head */\n    pool->free.slab = 0;\n    pool->free.next = page;\n    pool->free.prev = 0;\n\n    page->slab = pages;\n    page->next = &pool->free;\n    page->prev = (uintptr_t) &pool->free;\n\n    pool->start = ngx_align_ptr(p + pages * sizeof(ngx_slab_page_t),\n                                ngx_pagesize);\n\n    m = pages - (pool->end - pool->start) / ngx_pagesize;\n    if (m > 0) {\n        pages -= m;\n        page->slab = pages;\n    }\n\n    pool->last = pool->pages + pages;\n\n    pool->log_nomem = 1;\n    pool->log_ctx = &pool->zero;\n    pool->zero = '\\0';\n}", "before_change_lines": [39], "raw_before_change_lines": [39], "after_change_lines": [40, 41, 43, 45], "raw_after_change_lines": [39, 40, 41, 42, 43, 44, 45], "bug_lines": [39], "added": [false], "idx": 334}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "9967----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_525b151845c54c6365d530a931c8ceb3588cfc58_1.json----ngx_rbtree_insert_timer_value", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_525b151845c54c6365d530a931c8ceb3588cfc58_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_525b151845c54c6365d530a931c8ceb3588cfc58_1.json", "function_name": "ngx_rbtree_insert_timer_value", "vul_func_code": "void\nngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node,\n    ngx_rbtree_node_t *sentinel)\n{\n    ngx_rbtree_node_t  **p;\n\n    for ( ;; ) {\n\n        /*\n         * Timer values\n         * 1) are spread in small range, usually several minutes,\n         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.\n         * The comparison takes into account that overflow.\n         */\n\n        /*  node->key < temp->key */\n\n        p = ((ngx_rbtree_key_int_t) node->key - (ngx_rbtree_key_int_t) temp->key\n              < 0)\n            ? &temp->left : &temp->right;\n\n        if (*p == sentinel) {\n            break;\n        }\n\n        temp = *p;\n    }\n\n    *p = node;\n    node->parent = temp;\n    node->left = sentinel;\n    node->right = sentinel;\n    ngx_rbt_red(node);\n}", "patch_func_code": "void\nngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node,\n    ngx_rbtree_node_t *sentinel)\n{\n    ngx_rbtree_node_t  **p;\n\n    for ( ;; ) {\n\n        /*\n         * Timer values\n         * 1) are spread in small range, usually several minutes,\n         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.\n         * The comparison takes into account that overflow.\n         */\n\n        /*  node->key < temp->key */\n\n        p = ((ngx_rbtree_key_int_t) (node->key - temp->key) < 0)\n            ? &temp->left : &temp->right;\n\n        if (*p == sentinel) {\n            break;\n        }\n\n        temp = *p;\n    }\n\n    *p = node;\n    node->parent = temp;\n    node->left = sentinel;\n    node->right = sentinel;\n    ngx_rbt_red(node);\n}", "before_change_lines": [18, 19], "raw_before_change_lines": [18, 19], "after_change_lines": [18], "raw_after_change_lines": [18], "bug_lines": [18, 19], "added": [false, false], "idx": 335}
{"project": "nginx", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "10002----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_659add3bd258fb898ebbddce72426f1f66a4e8e0_1.json----ngx_http_upstream_process_upgraded", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_659add3bd258fb898ebbddce72426f1f66a4e8e0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_659add3bd258fb898ebbddce72426f1f66a4e8e0_1.json", "function_name": "ngx_http_upstream_process_upgraded", "vul_func_code": "static void\nngx_http_upstream_process_upgraded(ngx_http_request_t *r,\n    ngx_uint_t from_upstream)\n{\n    size_t                     size;\n    ssize_t                    n;\n    ngx_buf_t                 *b;\n    ngx_uint_t                 do_write;\n    ngx_connection_t          *c, *downstream, *upstream, *dst, *src;\n    ngx_http_upstream_t       *u;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    c = r->connection;\n    u = r->upstream;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"http upstream process upgraded, fu:%ui\", from_upstream);\n\n    downstream = c;\n    upstream = u->peer.connection;\n\n    if (downstream->write->timedout) {\n        c->timedout = 1;\n        ngx_connection_error(c, NGX_ETIMEDOUT, \"client timed out\");\n        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);\n        return;\n    }\n\n    if (upstream->read->timedout || upstream->write->timedout) {\n        ngx_connection_error(c, NGX_ETIMEDOUT, \"upstream timed out\");\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (from_upstream) {\n        src = upstream;\n        dst = downstream;\n        b = &u->buffer;\n\n    } else {\n        src = downstream;\n        dst = upstream;\n        b = &u->from_client;\n\n        if (r->header_in->last > r->header_in->pos) {\n            b = r->header_in;\n            b->end = b->last;\n            do_write = 1;\n        }\n\n        if (b->start == NULL) {\n            b->start = ngx_palloc(r->pool, u->conf->buffer_size);\n            if (b->start == NULL) {\n                ngx_http_upstream_finalize_request(r, u, 0);\n                return;\n            }\n\n            b->pos = b->start;\n            b->last = b->start;\n            b->end = b->start + u->conf->buffer_size;\n            b->temporary = 1;\n            b->tag = u->output.tag;\n        }\n    }\n\n    for ( ;; ) {\n\n        if (do_write) {\n\n            size = b->last - b->pos;\n\n            if (size && dst->write->ready) {\n\n                n = dst->send(dst, b->pos, size);\n\n                if (n == NGX_ERROR) {\n                    ngx_http_upstream_finalize_request(r, u, 0);\n                    return;\n                }\n\n                if (n > 0) {\n                    b->pos += n;\n\n                    if (b->pos == b->last) {\n                        b->pos = b->start;\n                        b->last = b->start;\n                    }\n                }\n            }\n        }\n\n        size = b->end - b->last;\n\n        if (size && src->read->ready) {\n\n            n = src->recv(src, b->last, size);\n\n            if (n == NGX_AGAIN || n == 0) {\n                break;\n            }\n\n            if (n > 0) {\n                do_write = 1;\n                b->last += n;\n\n                continue;\n            }\n\n            if (n == NGX_ERROR) {\n                src->read->eof = 1;\n            }\n        }\n\n        break;\n    }\n\n    if ((upstream->read->eof && u->buffer.pos == u->buffer.last)\n        || (downstream->read->eof && u->from_client.pos == u->from_client.last)\n        || (downstream->read->eof && upstream->read->eof))\n    {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                       \"http upstream upgraded done\");\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (ngx_handle_write_event(upstream->write, u->conf->send_lowat)\n        != NGX_OK)\n    {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (upstream->write->active && !upstream->write->ready) {\n        ngx_add_timer(upstream->write, u->conf->send_timeout);\n\n    } else if (upstream->write->timer_set) {\n        ngx_del_timer(upstream->write);\n    }\n\n    if (ngx_handle_read_event(upstream->read, 0) != NGX_OK) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (upstream->read->active && !upstream->read->ready) {\n        ngx_add_timer(upstream->read, u->conf->read_timeout);\n\n    } else if (upstream->read->timer_set) {\n        ngx_del_timer(upstream->read);\n    }\n\n    if (ngx_handle_write_event(downstream->write, clcf->send_lowat)\n        != NGX_OK)\n    {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (ngx_handle_read_event(downstream->read, 0) != NGX_OK) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (downstream->write->active && !downstream->write->ready) {\n        ngx_add_timer(downstream->write, clcf->send_timeout);\n\n    } else if (downstream->write->timer_set) {\n        ngx_del_timer(downstream->write);\n    }\n}", "patch_func_code": "static void\nngx_http_upstream_process_upgraded(ngx_http_request_t *r,\n    ngx_uint_t from_upstream, ngx_uint_t do_write)\n{\n    size_t                     size;\n    ssize_t                    n;\n    ngx_buf_t                 *b;\n    ngx_connection_t          *c, *downstream, *upstream, *dst, *src;\n    ngx_http_upstream_t       *u;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    c = r->connection;\n    u = r->upstream;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                   \"http upstream process upgraded, fu:%ui\", from_upstream);\n\n    downstream = c;\n    upstream = u->peer.connection;\n\n    if (downstream->write->timedout) {\n        c->timedout = 1;\n        ngx_connection_error(c, NGX_ETIMEDOUT, \"client timed out\");\n        ngx_http_upstream_finalize_request(r, u, NGX_HTTP_REQUEST_TIME_OUT);\n        return;\n    }\n\n    if (upstream->read->timedout || upstream->write->timedout) {\n        ngx_connection_error(c, NGX_ETIMEDOUT, \"upstream timed out\");\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (from_upstream) {\n        src = upstream;\n        dst = downstream;\n        b = &u->buffer;\n\n    } else {\n        src = downstream;\n        dst = upstream;\n        b = &u->from_client;\n\n        if (r->header_in->last > r->header_in->pos) {\n            b = r->header_in;\n            b->end = b->last;\n            do_write = 1;\n        }\n\n        if (b->start == NULL) {\n            b->start = ngx_palloc(r->pool, u->conf->buffer_size);\n            if (b->start == NULL) {\n                ngx_http_upstream_finalize_request(r, u, 0);\n                return;\n            }\n\n            b->pos = b->start;\n            b->last = b->start;\n            b->end = b->start + u->conf->buffer_size;\n            b->temporary = 1;\n            b->tag = u->output.tag;\n        }\n    }\n\n    for ( ;; ) {\n\n        if (do_write) {\n\n            size = b->last - b->pos;\n\n            if (size && dst->write->ready) {\n\n                n = dst->send(dst, b->pos, size);\n\n                if (n == NGX_ERROR) {\n                    ngx_http_upstream_finalize_request(r, u, 0);\n                    return;\n                }\n\n                if (n > 0) {\n                    b->pos += n;\n\n                    if (b->pos == b->last) {\n                        b->pos = b->start;\n                        b->last = b->start;\n                    }\n                }\n            }\n        }\n\n        size = b->end - b->last;\n\n        if (size && src->read->ready) {\n\n            n = src->recv(src, b->last, size);\n\n            if (n == NGX_AGAIN || n == 0) {\n                break;\n            }\n\n            if (n > 0) {\n                do_write = 1;\n                b->last += n;\n\n                continue;\n            }\n\n            if (n == NGX_ERROR) {\n                src->read->eof = 1;\n            }\n        }\n\n        break;\n    }\n\n    if ((upstream->read->eof && u->buffer.pos == u->buffer.last)\n        || (downstream->read->eof && u->from_client.pos == u->from_client.last)\n        || (downstream->read->eof && upstream->read->eof))\n    {\n        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0,\n                       \"http upstream upgraded done\");\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (ngx_handle_write_event(upstream->write, u->conf->send_lowat)\n        != NGX_OK)\n    {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (upstream->write->active && !upstream->write->ready) {\n        ngx_add_timer(upstream->write, u->conf->send_timeout);\n\n    } else if (upstream->write->timer_set) {\n        ngx_del_timer(upstream->write);\n    }\n\n    if (ngx_handle_read_event(upstream->read, 0) != NGX_OK) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (upstream->read->active && !upstream->read->ready) {\n        ngx_add_timer(upstream->read, u->conf->read_timeout);\n\n    } else if (upstream->read->timer_set) {\n        ngx_del_timer(upstream->read);\n    }\n\n    if (ngx_handle_write_event(downstream->write, clcf->send_lowat)\n        != NGX_OK)\n    {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (ngx_handle_read_event(downstream->read, 0) != NGX_OK) {\n        ngx_http_upstream_finalize_request(r, u, 0);\n        return;\n    }\n\n    if (downstream->write->active && !downstream->write->ready) {\n        ngx_add_timer(downstream->write, clcf->send_timeout);\n\n    } else if (downstream->write->timer_set) {\n        ngx_del_timer(downstream->write);\n    }\n}", "before_change_lines": [3, 8], "raw_before_change_lines": [3, 8], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3, 8], "added": [false, false], "idx": 336}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "10010----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_6b974c261e83553fcd4c26f7f32b90e6893e4049_1.json----ngx_http_variable_realpath_root", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_6b974c261e83553fcd4c26f7f32b90e6893e4049_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_6b974c261e83553fcd4c26f7f32b90e6893e4049_1.json", "function_name": "ngx_http_variable_realpath_root", "vul_func_code": "static ngx_int_t\nngx_http_variable_realpath_root(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    size_t                     len;\n    ngx_str_t                  path;\n    ngx_http_core_loc_conf_t  *clcf;\n    u_char                     real[NGX_MAX_PATH];\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->root_lengths == NULL) {\n        path = clcf->root;\n\n    } else {\n        if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 1,\n                                clcf->root_values->elts)\n            == NULL)\n        {\n            return NGX_ERROR;\n        }\n\n        path.data[path.len - 1] = '\\0';\n\n        if (ngx_conf_full_name((ngx_cycle_t *) ngx_cycle, &path, 0) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n    if (ngx_realpath(path.data, real) == NULL) {\n        ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                      ngx_realpath_n \" \\\"%s\\\" failed\", path.data);\n        return NGX_ERROR;\n    }\n\n    len = ngx_strlen(real);\n\n    v->data = ngx_pnalloc(r->pool, len);\n    if (v->data == NULL) {\n        return NGX_ERROR;\n    }\n\n    v->len = len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ngx_memcpy(v->data, real, len);\n\n    return NGX_OK;\n}", "patch_func_code": "static ngx_int_t\nngx_http_variable_realpath_root(ngx_http_request_t *r,\n    ngx_http_variable_value_t *v, uintptr_t data)\n{\n    u_char                    *real;\n    size_t                     len;\n    ngx_str_t                  path;\n    ngx_http_core_loc_conf_t  *clcf;\n#if (NGX_HAVE_MAX_PATH)\n    u_char                     buffer[NGX_MAX_PATH];\n#endif\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->root_lengths == NULL) {\n        path = clcf->root;\n\n    } else {\n        if (ngx_http_script_run(r, &path, clcf->root_lengths->elts, 1,\n                                clcf->root_values->elts)\n            == NULL)\n        {\n            return NGX_ERROR;\n        }\n\n        path.data[path.len - 1] = '\\0';\n\n        if (ngx_conf_full_name((ngx_cycle_t *) ngx_cycle, &path, 0) != NGX_OK) {\n            return NGX_ERROR;\n        }\n    }\n\n#if (NGX_HAVE_MAX_PATH)\n    real = buffer;\n#else\n    real = NULL;\n#endif\n\n    real = ngx_realpath(path.data, real);\n\n    if (real == NULL) {\n        ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,\n                      ngx_realpath_n \" \\\"%s\\\" failed\", path.data);\n        return NGX_ERROR;\n    }\n\n    len = ngx_strlen(real);\n\n    v->data = ngx_pnalloc(r->pool, len);\n    if (v->data == NULL) {\n#if !(NGX_HAVE_MAX_PATH)\n        ngx_free(real);\n#endif\n        return NGX_ERROR;\n    }\n\n    v->len = len;\n    v->valid = 1;\n    v->no_cacheable = 0;\n    v->not_found = 0;\n\n    ngx_memcpy(v->data, real, len);\n\n#if !(NGX_HAVE_MAX_PATH)\n    ngx_free(real);\n#endif\n\n    return NGX_OK;\n}", "before_change_lines": [8, 30], "raw_before_change_lines": [8, 30], "after_change_lines": [5, 9, 10, 11, 33, 34, 35, 36, 37, 39, 41, 51, 52, 53, 64, 65, 66], "raw_after_change_lines": [5, 9, 10, 11, 33, 34, 35, 36, 37, 38, 39, 40, 41, 51, 52, 53, 64, 65, 66, 67], "bug_lines": [8, 30], "added": [false, false], "idx": 337}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10013----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_6c8f2f377d14d3e086874efbf2c8d1417e58d91f_1.json----ngx_http_map", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_6c8f2f377d14d3e086874efbf2c8d1417e58d91f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_6c8f2f377d14d3e086874efbf2c8d1417e58d91f_1.json", "function_name": "ngx_http_map", "vul_func_code": "static char *\nngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)\n{\n    ngx_int_t                   rc, index;\n    ngx_str_t                  *value, file, name;\n    ngx_uint_t                  i, key;\n    ngx_http_map_conf_ctx_t    *ctx;\n    ngx_http_variable_value_t  *var, **vp;\n\n    ctx = cf->ctx;\n\n    value = cf->args->elts;\n\n    if (cf->args->nelts == 1\n        && ngx_strcmp(value[0].data, \"hostnames\") == 0)\n    {\n        ctx->hostnames = 1;\n        return NGX_CONF_OK;\n\n    } else if (cf->args->nelts != 2) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid number of the map parameters\");\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_strcmp(value[0].data, \"include\") == 0) {\n        file = value[1];\n\n        if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n\n        return ngx_conf_parse(cf, &file);\n    }\n\n    if (value[1].data[0] == '$') {\n        name = value[1];\n        name.len--;\n        name.data++;\n\n        index = ngx_http_get_variable_index(ctx->cf, &name);\n        if (index == NGX_ERROR) {\n            return NGX_CONF_ERROR;\n        }\n\n        var = ctx->var_values.elts;\n\n        for (i = 0; i < ctx->var_values.nelts; i++) {\n            if (index == (ngx_int_t) var[i].data) {\n                goto found;\n            }\n        }\n\n        var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t));\n        if (var == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        var->valid = 0;\n        var->no_cacheable = 0;\n        var->not_found = 0;\n        var->len = 0;\n        var->data = (u_char *) index;\n\n        vp = ngx_array_push(&ctx->var_values);\n        if (vp == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        *vp = var;\n\n        goto found;\n    }\n\n    key = 0;\n\n    for (i = 0; i < value[1].len; i++) {\n        key = ngx_hash(key, value[1].data[i]);\n    }\n\n    key %= ctx->keys.hsize;\n\n    vp = ctx->values_hash[key].elts;\n\n    if (vp) {\n        for (i = 0; i < ctx->values_hash[key].nelts; i++) {\n            if (value[1].len != (size_t) vp[i]->len) {\n                continue;\n            }\n\n            if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) {\n                var = vp[i];\n                goto found;\n            }\n        }\n\n    } else {\n        if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4,\n                           sizeof(ngx_http_variable_value_t *))\n            != NGX_OK)\n        {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t));\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->len = value[1].len;\n    var->data = ngx_pstrdup(ctx->keys.pool, &value[1]);\n    if (var->data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->valid = 1;\n    var->no_cacheable = 0;\n    var->not_found = 0;\n\n    vp = ngx_array_push(&ctx->values_hash[key]);\n    if (vp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *vp = var;\n\nfound:\n\n    if (ngx_strcmp(value[0].data, \"default\") == 0) {\n\n        if (ctx->default_value) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"duplicate default map parameter\");\n            return NGX_CONF_ERROR;\n        }\n\n        ctx->default_value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#if (NGX_PCRE)\n\n    if (value[0].len && value[0].data[0] == '~') {\n        ngx_regex_compile_t    rc;\n        ngx_http_map_regex_t  *regex;\n        u_char                 errstr[NGX_MAX_CONF_ERRSTR];\n\n        regex = ngx_array_push(&ctx->regexes);\n        if (regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        value[0].len--;\n        value[0].data++;\n\n        ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n\n        if (value[0].data[0] == '*') {\n            value[0].len--;\n            value[0].data++;\n            rc.options = NGX_REGEX_CASELESS;\n        }\n\n        rc.pattern = value[0];\n        rc.err.len = NGX_MAX_CONF_ERRSTR;\n        rc.err.data = errstr;\n\n        regex->regex = ngx_http_regex_compile(ctx->cf, &rc);\n        if (regex->regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        regex->value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#endif\n\n    if (value[0].len && value[0].data[0] == '\\\\') {\n        value[0].len--;\n        value[0].data++;\n    }\n\n    rc = ngx_hash_add_key(&ctx->keys, &value[0], var,\n                          (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0);\n\n    if (rc == NGX_OK) {\n        return NGX_CONF_OK;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid hostname or wildcard \\\"%V\\\"\", &value[0]);\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting parameter \\\"%V\\\"\", &value[0]);\n    }\n\n    return NGX_CONF_ERROR;\n}", "patch_func_code": "static char *\nngx_http_map(ngx_conf_t *cf, ngx_command_t *dummy, void *conf)\n{\n    ngx_int_t                   rc, index;\n    ngx_str_t                  *value, file, name;\n    ngx_uint_t                  i, key;\n    ngx_http_map_conf_ctx_t    *ctx;\n    ngx_http_variable_value_t  *var, **vp;\n\n    ctx = cf->ctx;\n\n    value = cf->args->elts;\n\n    if (cf->args->nelts == 1\n        && ngx_strcmp(value[0].data, \"hostnames\") == 0)\n    {\n        ctx->hostnames = 1;\n        return NGX_CONF_OK;\n\n    } else if (cf->args->nelts != 2) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid number of the map parameters\");\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_strcmp(value[0].data, \"include\") == 0) {\n        file = value[1];\n\n        if (ngx_conf_full_name(cf->cycle, &file, 1) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cf->log, 0, \"include %s\", file.data);\n\n        return ngx_conf_parse(cf, &file);\n    }\n\n    if (value[1].data[0] == '$') {\n        name = value[1];\n        name.len--;\n        name.data++;\n\n        index = ngx_http_get_variable_index(ctx->cf, &name);\n        if (index == NGX_ERROR) {\n            return NGX_CONF_ERROR;\n        }\n\n        var = ctx->var_values.elts;\n\n        for (i = 0; i < ctx->var_values.nelts; i++) {\n            if (index == (ngx_int_t) var[i].data) {\n                var = &var[i];\n                goto found;\n            }\n        }\n\n        var = ngx_array_push(&ctx->var_values);\n        if (var == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        var->valid = 0;\n        var->no_cacheable = 0;\n        var->not_found = 0;\n        var->len = 0;\n        var->data = (u_char *) index;\n\n        goto found;\n    }\n\n    key = 0;\n\n    for (i = 0; i < value[1].len; i++) {\n        key = ngx_hash(key, value[1].data[i]);\n    }\n\n    key %= ctx->keys.hsize;\n\n    vp = ctx->values_hash[key].elts;\n\n    if (vp) {\n        for (i = 0; i < ctx->values_hash[key].nelts; i++) {\n            if (value[1].len != (size_t) vp[i]->len) {\n                continue;\n            }\n\n            if (ngx_strncmp(value[1].data, vp[i]->data, value[1].len) == 0) {\n                var = vp[i];\n                goto found;\n            }\n        }\n\n    } else {\n        if (ngx_array_init(&ctx->values_hash[key], cf->pool, 4,\n                           sizeof(ngx_http_variable_value_t *))\n            != NGX_OK)\n        {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    var = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t));\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->len = value[1].len;\n    var->data = ngx_pstrdup(ctx->keys.pool, &value[1]);\n    if (var->data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    var->valid = 1;\n    var->no_cacheable = 0;\n    var->not_found = 0;\n\n    vp = ngx_array_push(&ctx->values_hash[key]);\n    if (vp == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *vp = var;\n\nfound:\n\n    if (ngx_strcmp(value[0].data, \"default\") == 0) {\n\n        if (ctx->default_value) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"duplicate default map parameter\");\n            return NGX_CONF_ERROR;\n        }\n\n        ctx->default_value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#if (NGX_PCRE)\n\n    if (value[0].len && value[0].data[0] == '~') {\n        ngx_regex_compile_t    rc;\n        ngx_http_map_regex_t  *regex;\n        u_char                 errstr[NGX_MAX_CONF_ERRSTR];\n\n        regex = ngx_array_push(&ctx->regexes);\n        if (regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        value[0].len--;\n        value[0].data++;\n\n        ngx_memzero(&rc, sizeof(ngx_regex_compile_t));\n\n        if (value[0].data[0] == '*') {\n            value[0].len--;\n            value[0].data++;\n            rc.options = NGX_REGEX_CASELESS;\n        }\n\n        rc.pattern = value[0];\n        rc.err.len = NGX_MAX_CONF_ERRSTR;\n        rc.err.data = errstr;\n\n        regex->regex = ngx_http_regex_compile(ctx->cf, &rc);\n        if (regex->regex == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        regex->value = var;\n\n        return NGX_CONF_OK;\n    }\n\n#endif\n\n    if (value[0].len && value[0].data[0] == '\\\\') {\n        value[0].len--;\n        value[0].data++;\n    }\n\n    rc = ngx_hash_add_key(&ctx->keys, &value[0], var,\n                          (ctx->hostnames) ? NGX_HASH_WILDCARD_KEY : 0);\n\n    if (rc == NGX_OK) {\n        return NGX_CONF_OK;\n    }\n\n    if (rc == NGX_DECLINED) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"invalid hostname or wildcard \\\"%V\\\"\", &value[0]);\n    }\n\n    if (rc == NGX_BUSY) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           \"conflicting parameter \\\"%V\\\"\", &value[0]);\n    }\n\n    return NGX_CONF_ERROR;\n}", "before_change_lines": [56, 67, 68, 69, 70, 72], "raw_before_change_lines": [56, 67, 68, 69, 70, 71, 72, 73], "after_change_lines": [52, 57], "raw_after_change_lines": [52, 57], "bug_lines": [56, 67, 68, 69, 70, 71, 72, 73], "added": [false, false, false, false, false, false, false, false], "idx": 338}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "10070----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_8dcd4fc2729bb48b8b52a4bbaafcf495a4295c4f_1.json----ngx_http_init_request", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_8dcd4fc2729bb48b8b52a4bbaafcf495a4295c4f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_8dcd4fc2729bb48b8b52a4bbaafcf495a4295c4f_1.json", "function_name": "ngx_http_init_request", "vul_func_code": "static void\nngx_http_init_request(ngx_event_t *rev)\n{\n    ngx_time_t                 *tp;\n    ngx_connection_t           *c;\n    ngx_http_request_t         *r;\n    ngx_http_log_ctx_t         *ctx;\n    ngx_http_connection_t      *hc;\n    ngx_http_core_srv_conf_t   *cscf;\n    ngx_http_core_loc_conf_t   *clcf;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    c = rev->data;\n\n    if (rev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    c->requests++;\n\n    hc = c->data;\n\n    r = hc->request;\n\n    if (r) {\n        ngx_memzero(r, sizeof(ngx_http_request_t));\n\n        r->pipeline = hc->pipeline;\n\n        if (hc->nbusy) {\n            r->header_in = hc->busy[0];\n        }\n\n    } else {\n        r = ngx_pcalloc(c->pool, sizeof(ngx_http_request_t));\n        if (r == NULL) {\n            ngx_http_close_connection(c);\n            return;\n        }\n\n        hc->request = r;\n    }\n\n    c->data = r;\n    r->http_connection = hc;\n\n    c->sent = 0;\n    r->signature = NGX_HTTP_MODULE;\n\n    r->connection = c;\n\n    r->main_conf = hc->conf_ctx->main_conf;\n    r->srv_conf = hc->conf_ctx->srv_conf;\n    r->loc_conf = hc->conf_ctx->loc_conf;\n\n    rev->handler = ngx_http_process_request_line;\n    r->read_event_handler = ngx_http_block_reading;\n\n#if (NGX_HTTP_SSL)\n\n    {\n    ngx_http_ssl_srv_conf_t  *sscf;\n\n    sscf = ngx_http_get_module_srv_conf(r, ngx_http_ssl_module);\n    if (sscf->enable || hc->addr_conf->ssl) {\n\n        if (c->ssl == NULL) {\n\n            c->log->action = \"SSL handshaking\";\n\n            if (hc->addr_conf->ssl && sscf->ssl.ctx == NULL) {\n                ngx_log_error(NGX_LOG_ERR, c->log, 0,\n                              \"no \\\"ssl_certificate\\\" is defined \"\n                              \"in server listening on SSL port\");\n                ngx_http_close_connection(c);\n                return;\n            }\n\n            if (ngx_ssl_create_connection(&sscf->ssl, c, NGX_SSL_BUFFER)\n                != NGX_OK)\n            {\n                ngx_http_close_connection(c);\n                return;\n            }\n\n            rev->handler = ngx_http_ssl_handshake;\n        }\n\n        r->main_filter_need_in_memory = 1;\n    }\n    }\n\n#endif\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    ngx_http_set_connection_log(r->connection, clcf->error_log);\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n\n    if (c->buffer == NULL) {\n        c->buffer = ngx_create_temp_buf(c->pool,\n                                        cscf->client_header_buffer_size);\n        if (c->buffer == NULL) {\n            ngx_http_close_connection(c);\n            return;\n        }\n    }\n\n    if (r->header_in == NULL) {\n        r->header_in = c->buffer;\n    }\n\n    r->pool = ngx_create_pool(cscf->request_pool_size, c->log);\n    if (r->pool == NULL) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n\n    if (ngx_list_init(&r->headers_out.headers, r->pool, 20,\n                      sizeof(ngx_table_elt_t))\n        != NGX_OK)\n    {\n        ngx_destroy_pool(r->pool);\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    r->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);\n    if (r->ctx == NULL) {\n        ngx_destroy_pool(r->pool);\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    r->variables = ngx_pcalloc(r->pool, cmcf->variables.nelts\n                                        * sizeof(ngx_http_variable_value_t));\n    if (r->variables == NULL) {\n        ngx_destroy_pool(r->pool);\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    c->single_connection = 1;\n    c->destroyed = 0;\n\n    r->main = r;\n    r->count = 1;\n\n    tp = ngx_timeofday();\n    r->start_sec = tp->sec;\n    r->start_msec = tp->msec;\n\n    r->method = NGX_HTTP_UNKNOWN;\n\n    r->headers_in.content_length_n = -1;\n    r->headers_in.keep_alive_n = -1;\n    r->headers_out.content_length_n = -1;\n    r->headers_out.last_modified_time = -1;\n\n    r->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1;\n    r->subrequests = NGX_HTTP_MAX_SUBREQUESTS + 1;\n\n    r->http_state = NGX_HTTP_READING_REQUEST_STATE;\n\n    ctx = c->log->data;\n    ctx->request = r;\n    ctx->current_request = r;\n    r->log_handler = ngx_http_log_error_handler;\n\n#if (NGX_STAT_STUB)\n    (void) ngx_atomic_fetch_add(ngx_stat_reading, 1);\n    r->stat_reading = 1;\n    (void) ngx_atomic_fetch_add(ngx_stat_requests, 1);\n#endif\n\n    rev->handler(rev);\n}", "patch_func_code": "static void\nngx_http_init_request(ngx_event_t *rev)\n{\n    ngx_time_t                 *tp;\n    ngx_connection_t           *c;\n    ngx_http_request_t         *r;\n    ngx_http_log_ctx_t         *ctx;\n    ngx_http_connection_t      *hc;\n    ngx_http_core_srv_conf_t   *cscf;\n    ngx_http_core_loc_conf_t   *clcf;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    c = rev->data;\n\n    if (rev->timedout) {\n        ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, \"client timed out\");\n\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    c->requests++;\n\n    hc = c->data;\n\n    r = hc->request;\n\n    if (r) {\n        ngx_memzero(r, sizeof(ngx_http_request_t));\n\n        r->pipeline = hc->pipeline;\n\n        if (hc->nbusy) {\n            r->header_in = hc->busy[0];\n        }\n\n    } else {\n        r = ngx_pcalloc(c->pool, sizeof(ngx_http_request_t));\n        if (r == NULL) {\n            ngx_http_close_connection(c);\n            return;\n        }\n\n        hc->request = r;\n    }\n\n    c->data = r;\n    r->http_connection = hc;\n\n    c->sent = 0;\n    r->signature = NGX_HTTP_MODULE;\n\n    r->connection = c;\n\n    r->main_conf = hc->conf_ctx->main_conf;\n    r->srv_conf = hc->conf_ctx->srv_conf;\n    r->loc_conf = hc->conf_ctx->loc_conf;\n\n    r->read_event_handler = ngx_http_block_reading;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    ngx_http_set_connection_log(r->connection, clcf->error_log);\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n\n    if (c->buffer == NULL) {\n        c->buffer = ngx_create_temp_buf(c->pool,\n                                        cscf->client_header_buffer_size);\n        if (c->buffer == NULL) {\n            ngx_http_close_connection(c);\n            return;\n        }\n    }\n\n    if (r->header_in == NULL) {\n        r->header_in = c->buffer;\n    }\n\n    r->pool = ngx_create_pool(cscf->request_pool_size, c->log);\n    if (r->pool == NULL) {\n        ngx_http_close_connection(c);\n        return;\n    }\n\n\n    if (ngx_list_init(&r->headers_out.headers, r->pool, 20,\n                      sizeof(ngx_table_elt_t))\n        != NGX_OK)\n    {\n        ngx_destroy_pool(r->pool);\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    r->ctx = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);\n    if (r->ctx == NULL) {\n        ngx_destroy_pool(r->pool);\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    r->variables = ngx_pcalloc(r->pool, cmcf->variables.nelts\n                                        * sizeof(ngx_http_variable_value_t));\n    if (r->variables == NULL) {\n        ngx_destroy_pool(r->pool);\n        ngx_http_close_connection(c);\n        return;\n    }\n\n    c->single_connection = 1;\n    c->destroyed = 0;\n\n#if (NGX_HTTP_SSL)\n    if (c->ssl) {\n        r->main_filter_need_in_memory = 1;\n    }\n#endif\n\n    r->main = r;\n    r->count = 1;\n\n    tp = ngx_timeofday();\n    r->start_sec = tp->sec;\n    r->start_msec = tp->msec;\n\n    r->method = NGX_HTTP_UNKNOWN;\n\n    r->headers_in.content_length_n = -1;\n    r->headers_in.keep_alive_n = -1;\n    r->headers_out.content_length_n = -1;\n    r->headers_out.last_modified_time = -1;\n\n    r->uri_changes = NGX_HTTP_MAX_URI_CHANGES + 1;\n    r->subrequests = NGX_HTTP_MAX_SUBREQUESTS + 1;\n\n    r->http_state = NGX_HTTP_READING_REQUEST_STATE;\n\n    ctx = c->log->data;\n    ctx->request = r;\n    ctx->current_request = r;\n    r->log_handler = ngx_http_log_error_handler;\n\n#if (NGX_STAT_STUB)\n    (void) ngx_atomic_fetch_add(ngx_stat_reading, 1);\n    r->stat_reading = 1;\n    (void) ngx_atomic_fetch_add(ngx_stat_requests, 1);\n#endif\n\n    rev->handler = ngx_http_process_request_line;\n    ngx_http_process_request_line(rev);\n}", "before_change_lines": [59, 62, 64, 65, 67, 68, 70, 72, 74, 75, 76, 77, 78, 79, 80, 82, 83, 84, 85, 86, 87, 89, 90, 92, 93, 94, 96, 183], "raw_before_change_lines": [59, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 183], "after_change_lines": [116, 117, 118, 119, 120, 152, 153], "raw_after_change_lines": [116, 117, 118, 119, 120, 121, 152, 153], "bug_lines": [59, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 183], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 339}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10077----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_8f9848f4746988cfd7bb0007b847de5dbd43eb06_1.json----ngx_http_upstream_cache", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_8f9848f4746988cfd7bb0007b847de5dbd43eb06_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_8f9848f4746988cfd7bb0007b847de5dbd43eb06_1.json", "function_name": "ngx_http_upstream_cache", "vul_func_code": "static ngx_int_t\nngx_http_upstream_cache(ngx_http_request_t *r, ngx_http_upstream_t *u)\n{\n    ngx_int_t               rc;\n    ngx_http_cache_t       *c;\n    ngx_http_file_cache_t  *cache;\n\n    c = r->cache;\n\n    if (c == NULL) {\n\n        if (!(r->method & u->conf->cache_methods)) {\n            return NGX_DECLINED;\n        }\n\n        rc = ngx_http_upstream_cache_get(r, u, &cache);\n\n        if (rc != NGX_OK) {\n            return rc;\n        }\n\n        if (r->method & NGX_HTTP_HEAD) {\n            u->method = ngx_http_core_get_method;\n        }\n\n        if (ngx_http_file_cache_new(r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (u->create_key(r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        /* TODO: add keys */\n\n        ngx_http_file_cache_create_key(r);\n\n        if (r->cache->header_start + 256 >= u->conf->buffer_size) {\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"%V_buffer_size %uz is not enough for cache key, \"\n                          \"it should be increased to at least %uz\",\n                          &u->conf->module, u->conf->buffer_size,\n                          ngx_align(r->cache->header_start + 256, 1024));\n\n            r->cache = NULL;\n            return NGX_DECLINED;\n        }\n\n        u->cacheable = 1;\n\n        c = r->cache;\n\n        c->body_start = u->conf->buffer_size;\n        c->min_uses = u->conf->cache_min_uses;\n        c->file_cache = cache;\n\n        switch (ngx_http_test_predicates(r, u->conf->cache_bypass)) {\n\n        case NGX_ERROR:\n            return NGX_ERROR;\n\n        case NGX_DECLINED:\n            u->cache_status = NGX_HTTP_CACHE_BYPASS;\n            return NGX_DECLINED;\n\n        default: /* NGX_OK */\n            break;\n        }\n\n        c->lock = u->conf->cache_lock;\n        c->lock_timeout = u->conf->cache_lock_timeout;\n        c->lock_age = u->conf->cache_lock_age;\n\n        u->cache_status = NGX_HTTP_CACHE_MISS;\n    }\n\n    rc = ngx_http_file_cache_open(r);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http upstream cache: %i\", rc);\n\n    switch (rc) {\n\n    case NGX_HTTP_CACHE_UPDATING:\n\n        if (u->conf->cache_use_stale & NGX_HTTP_UPSTREAM_FT_UPDATING) {\n            u->cache_status = rc;\n            rc = NGX_OK;\n\n        } else {\n            rc = NGX_HTTP_CACHE_STALE;\n        }\n\n        break;\n\n    case NGX_OK:\n        u->cache_status = NGX_HTTP_CACHE_HIT;\n    }\n\n    switch (rc) {\n\n    case NGX_OK:\n\n        rc = ngx_http_upstream_cache_send(r, u);\n\n        if (rc != NGX_HTTP_UPSTREAM_INVALID_HEADER) {\n            return rc;\n        }\n\n        break;\n\n    case NGX_HTTP_CACHE_STALE:\n\n        c->valid_sec = 0;\n        u->buffer.start = NULL;\n        u->cache_status = NGX_HTTP_CACHE_EXPIRED;\n\n        break;\n\n    case NGX_DECLINED:\n\n        if ((size_t) (u->buffer.end - u->buffer.start) < u->conf->buffer_size) {\n            u->buffer.start = NULL;\n\n        } else {\n            u->buffer.pos = u->buffer.start + c->header_start;\n            u->buffer.last = u->buffer.pos;\n        }\n\n        break;\n\n    case NGX_HTTP_CACHE_SCARCE:\n\n        u->cacheable = 0;\n\n        break;\n\n    case NGX_AGAIN:\n\n        return NGX_BUSY;\n\n    case NGX_ERROR:\n\n        return NGX_ERROR;\n\n    default:\n\n        /* cached NGX_HTTP_BAD_GATEWAY, NGX_HTTP_GATEWAY_TIME_OUT, etc. */\n\n        u->cache_status = NGX_HTTP_CACHE_HIT;\n\n        return rc;\n    }\n\n    r->cached = 0;\n\n    return NGX_DECLINED;\n}", "patch_func_code": "static ngx_int_t\nngx_http_upstream_cache(ngx_http_request_t *r, ngx_http_upstream_t *u)\n{\n    ngx_int_t               rc;\n    ngx_http_cache_t       *c;\n    ngx_http_file_cache_t  *cache;\n\n    c = r->cache;\n\n    if (c == NULL) {\n\n        if (!(r->method & u->conf->cache_methods)) {\n            return NGX_DECLINED;\n        }\n\n        rc = ngx_http_upstream_cache_get(r, u, &cache);\n\n        if (rc != NGX_OK) {\n            return rc;\n        }\n\n        if (r->method & NGX_HTTP_HEAD) {\n            u->method = ngx_http_core_get_method;\n        }\n\n        if (ngx_http_file_cache_new(r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (u->create_key(r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        /* TODO: add keys */\n\n        ngx_http_file_cache_create_key(r);\n\n        if (r->cache->header_start + 256 >= u->conf->buffer_size) {\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"%V_buffer_size %uz is not enough for cache key, \"\n                          \"it should be increased to at least %uz\",\n                          &u->conf->module, u->conf->buffer_size,\n                          ngx_align(r->cache->header_start + 256, 1024));\n\n            r->cache = NULL;\n            return NGX_DECLINED;\n        }\n\n        u->cacheable = 1;\n\n        c = r->cache;\n\n        c->body_start = u->conf->buffer_size;\n        c->min_uses = u->conf->cache_min_uses;\n        c->file_cache = cache;\n\n        switch (ngx_http_test_predicates(r, u->conf->cache_bypass)) {\n\n        case NGX_ERROR:\n            return NGX_ERROR;\n\n        case NGX_DECLINED:\n            u->cache_status = NGX_HTTP_CACHE_BYPASS;\n            return NGX_DECLINED;\n\n        default: /* NGX_OK */\n            break;\n        }\n\n        c->lock = u->conf->cache_lock;\n        c->lock_timeout = u->conf->cache_lock_timeout;\n        c->lock_age = u->conf->cache_lock_age;\n\n        u->cache_status = NGX_HTTP_CACHE_MISS;\n    }\n\n    rc = ngx_http_file_cache_open(r);\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http upstream cache: %i\", rc);\n\n    switch (rc) {\n\n    case NGX_HTTP_CACHE_UPDATING:\n\n        if (u->conf->cache_use_stale & NGX_HTTP_UPSTREAM_FT_UPDATING) {\n            u->cache_status = rc;\n            rc = NGX_OK;\n\n        } else {\n            rc = NGX_HTTP_CACHE_STALE;\n        }\n\n        break;\n\n    case NGX_OK:\n        u->cache_status = NGX_HTTP_CACHE_HIT;\n    }\n\n    switch (rc) {\n\n    case NGX_OK:\n\n        return NGX_OK;\n\n    case NGX_HTTP_CACHE_STALE:\n\n        c->valid_sec = 0;\n        u->buffer.start = NULL;\n        u->cache_status = NGX_HTTP_CACHE_EXPIRED;\n\n        break;\n\n    case NGX_DECLINED:\n\n        if ((size_t) (u->buffer.end - u->buffer.start) < u->conf->buffer_size) {\n            u->buffer.start = NULL;\n\n        } else {\n            u->buffer.pos = u->buffer.start + c->header_start;\n            u->buffer.last = u->buffer.pos;\n        }\n\n        break;\n\n    case NGX_HTTP_CACHE_SCARCE:\n\n        u->cacheable = 0;\n\n        break;\n\n    case NGX_AGAIN:\n\n        return NGX_BUSY;\n\n    case NGX_ERROR:\n\n        return NGX_ERROR;\n\n    default:\n\n        /* cached NGX_HTTP_BAD_GATEWAY, NGX_HTTP_GATEWAY_TIME_OUT, etc. */\n\n        u->cache_status = NGX_HTTP_CACHE_HIT;\n\n        return rc;\n    }\n\n    r->cached = 0;\n\n    return NGX_DECLINED;\n}", "before_change_lines": [104, 106, 107, 108, 110], "raw_before_change_lines": [104, 105, 106, 107, 108, 109, 110], "after_change_lines": [104], "raw_after_change_lines": [104], "bug_lines": [104, 105, 106, 107, 108, 109, 110], "added": [false, false, false, false, false, false, false], "idx": 340}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10079----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_90107b7ab50654464d20c090193e6513fc69bf93_1.json----ngx_conf_merge_path_value", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_90107b7ab50654464d20c090193e6513fc69bf93_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_90107b7ab50654464d20c090193e6513fc69bf93_1.json", "function_name": "ngx_conf_merge_path_value", "vul_func_code": "char *\nngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path, ngx_path_t *prev,\n    ngx_path_init_t *init)\n{\n    if (*path) {\n        return NGX_CONF_OK;\n    }\n\n    if (prev) {\n        *path = prev;\n        return NGX_CONF_OK;\n    }\n\n    *path = ngx_palloc(cf->pool, sizeof(ngx_path_t));\n    if (*path == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    (*path)->name = init->name;\n\n    if (ngx_get_full_name(cf->pool, &cf->cycle->prefix, &(*path)->name)\n        != NGX_OK)\n    {\n        return NGX_CONF_ERROR;\n    }\n\n    (*path)->level[0] = init->level[0];\n    (*path)->level[1] = init->level[1];\n    (*path)->level[2] = init->level[2];\n\n    (*path)->len = init->level[0] + (init->level[0] ? 1 : 0)\n                   + init->level[1] + (init->level[1] ? 1 : 0)\n                   + init->level[2] + (init->level[2] ? 1 : 0);\n\n    (*path)->manager = NULL;\n    (*path)->loader = NULL;\n    (*path)->conf_file = NULL;\n\n    if (ngx_add_path(cf, path) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}", "patch_func_code": "char *\nngx_conf_merge_path_value(ngx_conf_t *cf, ngx_path_t **path, ngx_path_t *prev,\n    ngx_path_init_t *init)\n{\n    if (*path) {\n        return NGX_CONF_OK;\n    }\n\n    if (prev) {\n        *path = prev;\n        return NGX_CONF_OK;\n    }\n\n    *path = ngx_palloc(cf->pool, sizeof(ngx_path_t));\n    if (*path == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    (*path)->name = init->name;\n\n    if (ngx_conf_full_name(cf->cycle, &(*path)->name, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    (*path)->level[0] = init->level[0];\n    (*path)->level[1] = init->level[1];\n    (*path)->level[2] = init->level[2];\n\n    (*path)->len = init->level[0] + (init->level[0] ? 1 : 0)\n                   + init->level[1] + (init->level[1] ? 1 : 0)\n                   + init->level[2] + (init->level[2] ? 1 : 0);\n\n    (*path)->manager = NULL;\n    (*path)->loader = NULL;\n    (*path)->conf_file = NULL;\n\n    if (ngx_add_path(cf, path) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n}", "before_change_lines": [21, 22, 23], "raw_before_change_lines": [21, 22, 23], "after_change_lines": [21], "raw_after_change_lines": [21], "bug_lines": [21, 22, 23], "added": [false, false, false], "idx": 341}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10103----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_9afc53f49764d4738fb7b665bfb139ecd7dabe14_1.json----ngx_reopen_files", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_9afc53f49764d4738fb7b665bfb139ecd7dabe14_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_9afc53f49764d4738fb7b665bfb139ecd7dabe14_1.json", "function_name": "ngx_reopen_files", "vul_func_code": "void\nngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user)\n{\n    ngx_fd_t          fd;\n    ngx_uint_t        i;\n    ngx_list_part_t  *part;\n    ngx_open_file_t  *file;\n\n    part = &cycle->open_files.part;\n    file = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            file = part->elts;\n            i = 0;\n        }\n\n        if (file[i].name.len == 0) {\n            continue;\n        }\n\n        if (file[i].flush) {\n            file[i].flush(&file[i], cycle->log);\n        }\n\n        fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND,\n                           NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS);\n\n        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                       \"reopen file \\\"%s\\\", old:%d new:%d\",\n                       file[i].name.data, file[i].fd, fd);\n\n        if (fd == NGX_INVALID_FILE) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          ngx_open_file_n \" \\\"%s\\\" failed\", file[i].name.data);\n            continue;\n        }\n\n#if !(NGX_WIN32)\n        if (user != (ngx_uid_t) NGX_CONF_UNSET_UINT) {\n            ngx_file_info_t  fi;\n\n            if (ngx_file_info((const char *) file[i].name.data, &fi)\n                == NGX_FILE_ERROR)\n            {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                              ngx_file_info_n \" \\\"%s\\\" failed\",\n                              file[i].name.data);\n\n                if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                  ngx_close_file_n \" \\\"%s\\\" failed\",\n                                  file[i].name.data);\n                }\n            }\n\n            if (fi.st_uid != user) {\n                if (chown((const char *) file[i].name.data, user, -1) == -1) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                  \"chown(\\\"%s\\\", %d) failed\",\n                                  file[i].name.data, user);\n\n                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                      ngx_close_file_n \" \\\"%s\\\" failed\",\n                                      file[i].name.data);\n                    }\n                }\n            }\n\n            if ((fi.st_mode & (S_IRUSR|S_IWUSR)) != (S_IRUSR|S_IWUSR)) {\n\n                fi.st_mode |= (S_IRUSR|S_IWUSR);\n\n                if (chmod((const char *) file[i].name.data, fi.st_mode) == -1) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                  \"chmod() \\\"%s\\\" failed\", file[i].name.data);\n\n                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                      ngx_close_file_n \" \\\"%s\\\" failed\",\n                                      file[i].name.data);\n                    }\n                }\n            }\n        }\n\n        if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"fcntl(FD_CLOEXEC) \\\"%s\\\" failed\",\n                          file[i].name.data);\n\n            if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                              ngx_close_file_n \" \\\"%s\\\" failed\",\n                              file[i].name.data);\n            }\n\n            continue;\n        }\n#endif\n\n        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\",\n                          file[i].name.data);\n        }\n\n        file[i].fd = fd;\n    }\n\n    if (!cycle->log_use_stderr && cycle->log->file->fd != ngx_stderr) {\n\n        if (ngx_set_stderr(cycle->log->file->fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_set_stderr_n \" failed\");\n        }\n    }\n}", "patch_func_code": "void\nngx_reopen_files(ngx_cycle_t *cycle, ngx_uid_t user)\n{\n    ngx_fd_t          fd;\n    ngx_uint_t        i;\n    ngx_list_part_t  *part;\n    ngx_open_file_t  *file;\n\n    part = &cycle->open_files.part;\n    file = part->elts;\n\n    for (i = 0; /* void */ ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            file = part->elts;\n            i = 0;\n        }\n\n        if (file[i].name.len == 0) {\n            continue;\n        }\n\n        if (file[i].flush) {\n            file[i].flush(&file[i], cycle->log);\n        }\n\n        fd = ngx_open_file(file[i].name.data, NGX_FILE_APPEND,\n                           NGX_FILE_CREATE_OR_OPEN, NGX_FILE_DEFAULT_ACCESS);\n\n        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, cycle->log, 0,\n                       \"reopen file \\\"%s\\\", old:%d new:%d\",\n                       file[i].name.data, file[i].fd, fd);\n\n        if (fd == NGX_INVALID_FILE) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          ngx_open_file_n \" \\\"%s\\\" failed\", file[i].name.data);\n            continue;\n        }\n\n#if !(NGX_WIN32)\n        if (user != (ngx_uid_t) NGX_CONF_UNSET_UINT) {\n            ngx_file_info_t  fi;\n\n            if (ngx_file_info((const char *) file[i].name.data, &fi)\n                == NGX_FILE_ERROR)\n            {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                              ngx_file_info_n \" \\\"%s\\\" failed\",\n                              file[i].name.data);\n\n                if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                  ngx_close_file_n \" \\\"%s\\\" failed\",\n                                  file[i].name.data);\n                }\n            }\n\n            if (fi.st_uid != user) {\n                if (chown((const char *) file[i].name.data, user, -1) == -1) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                  \"chown(\\\"%s\\\", %d) failed\",\n                                  file[i].name.data, user);\n\n                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                      ngx_close_file_n \" \\\"%s\\\" failed\",\n                                      file[i].name.data);\n                    }\n                }\n            }\n\n            if ((fi.st_mode & (S_IRUSR|S_IWUSR)) != (S_IRUSR|S_IWUSR)) {\n\n                fi.st_mode |= (S_IRUSR|S_IWUSR);\n\n                if (chmod((const char *) file[i].name.data, fi.st_mode) == -1) {\n                    ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                  \"chmod() \\\"%s\\\" failed\", file[i].name.data);\n\n                    if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                        ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                                      ngx_close_file_n \" \\\"%s\\\" failed\",\n                                      file[i].name.data);\n                    }\n                }\n            }\n        }\n\n        if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"fcntl(FD_CLOEXEC) \\\"%s\\\" failed\",\n                          file[i].name.data);\n\n            if (ngx_close_file(fd) == NGX_FILE_ERROR) {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                              ngx_close_file_n \" \\\"%s\\\" failed\",\n                              file[i].name.data);\n            }\n\n            continue;\n        }\n#endif\n\n        if (ngx_close_file(file[i].fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          ngx_close_file_n \" \\\"%s\\\" failed\",\n                          file[i].name.data);\n        }\n\n        file[i].fd = fd;\n    }\n\n    (void) ngx_log_redirect_stderr(cycle);\n}", "before_change_lines": [117, 119, 120, 121, 122, 123], "raw_before_change_lines": [117, 118, 119, 120, 121, 122, 123], "after_change_lines": [117], "raw_after_change_lines": [117], "bug_lines": [117, 118, 119, 120, 121, 122, 123], "added": [false, false, false, false, false, false, false], "idx": 342}
{"project": "nginx", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10147----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_b6cd647ff834d1ae91a81e2ed2f692ac9726d53f_1.json----ngx_resolve_name_done", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_b6cd647ff834d1ae91a81e2ed2f692ac9726d53f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_b6cd647ff834d1ae91a81e2ed2f692ac9726d53f_1.json", "function_name": "ngx_resolve_name_done", "vul_func_code": "void\nngx_resolve_name_done(ngx_resolver_ctx_t *ctx)\n{\n    uint32_t              hash;\n    ngx_resolver_t       *r;\n    ngx_resolver_ctx_t   *w, **p;\n    ngx_resolver_node_t  *rn;\n\n    r = ctx->resolver;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,\n                   \"resolve name done: %i\", ctx->state);\n\n    if (ctx->quick) {\n        return;\n    }\n\n    if (ctx->event && ctx->event->timer_set) {\n        ngx_del_timer(ctx->event);\n    }\n\n    /* lock name mutex */\n\n    if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOLVE_TIMEDOUT) {\n\n        hash = ngx_crc32_short(ctx->name.data, ctx->name.len);\n\n        rn = ngx_resolver_lookup_name(r, &ctx->name, hash);\n\n        if (rn) {\n            p = &rn->waiting;\n            w = rn->waiting;\n\n            while (w) {\n                if (w == ctx) {\n                    *p = w->next;\n\n                    goto done;\n                }\n\n                p = &w->next;\n                w = w->next;\n            }\n        }\n\n        ngx_log_error(NGX_LOG_ALERT, r->log, 0,\n                      \"could not cancel %V resolving\", &ctx->name);\n    }\n\ndone:\n\n    ngx_resolver_expire(r, &r->name_rbtree, &r->name_expire_queue);\n\n    /* unlock name mutex */\n\n    /* lock alloc mutex */\n\n    if (ctx->event) {\n        ngx_resolver_free_locked(r, ctx->event);\n    }\n\n    ngx_resolver_free_locked(r, ctx);\n\n    /* unlock alloc mutex */\n\n    if (r->event->timer_set && ngx_resolver_resend_empty(r)) {\n        ngx_del_timer(r->event);\n    }\n}", "patch_func_code": "void\nngx_resolve_name_done(ngx_resolver_ctx_t *ctx)\n{\n    ngx_resolver_t       *r;\n    ngx_resolver_ctx_t   *w, **p;\n    ngx_resolver_node_t  *rn;\n\n    r = ctx->resolver;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_CORE, r->log, 0,\n                   \"resolve name done: %i\", ctx->state);\n\n    if (ctx->quick) {\n        return;\n    }\n\n    if (ctx->event && ctx->event->timer_set) {\n        ngx_del_timer(ctx->event);\n    }\n\n    /* lock name mutex */\n\n    if (ctx->state == NGX_AGAIN || ctx->state == NGX_RESOLVE_TIMEDOUT) {\n\n        rn = ctx->node;\n\n        if (rn) {\n            p = &rn->waiting;\n            w = rn->waiting;\n\n            while (w) {\n                if (w == ctx) {\n                    *p = w->next;\n\n                    goto done;\n                }\n\n                p = &w->next;\n                w = w->next;\n            }\n        }\n\n        ngx_log_error(NGX_LOG_ALERT, r->log, 0,\n                      \"could not cancel %V resolving\", &ctx->name);\n    }\n\ndone:\n\n    ngx_resolver_expire(r, &r->name_rbtree, &r->name_expire_queue);\n\n    /* unlock name mutex */\n\n    /* lock alloc mutex */\n\n    if (ctx->event) {\n        ngx_resolver_free_locked(r, ctx->event);\n    }\n\n    ngx_resolver_free_locked(r, ctx);\n\n    /* unlock alloc mutex */\n\n    if (r->event->timer_set && ngx_resolver_resend_empty(r)) {\n        ngx_del_timer(r->event);\n    }\n}", "before_change_lines": [4, 26, 28], "raw_before_change_lines": [4, 26, 27, 28], "after_change_lines": [25], "raw_after_change_lines": [25], "bug_lines": [4, 26, 27, 28], "added": [false, false, false, false], "idx": 343}
{"project": "nginx", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10223----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_de1f9385cd2b3439f6967eb3b72c07ccf3903526_1.json----ngx_http_file_cache_lock", "patch_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/after_fix/nginx_de1f9385cd2b3439f6967eb3b72c07ccf3903526_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/nginx/d2a/before_fix/nginx_de1f9385cd2b3439f6967eb3b72c07ccf3903526_1.json", "function_name": "ngx_http_file_cache_lock", "vul_func_code": "static ngx_int_t\nngx_http_file_cache_lock(ngx_http_request_t *r, ngx_http_cache_t *c)\n{\n    ngx_msec_t                 now, timer;\n    ngx_http_file_cache_t     *cache;\n\n    if (!c->lock) {\n        return NGX_DECLINED;\n    }\n\n    cache = c->file_cache;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    if (!c->node->updating) {\n        c->node->updating = 1;\n        c->updating = 1;\n    }\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache lock u:%d wt:%M\",\n                   c->updating, c->wait_time);\n\n    if (c->updating) {\n        return NGX_DECLINED;\n    }\n\n    c->waiting = 1;\n\n    now = ngx_current_msec;\n\n    if (c->wait_time == 0) {\n        c->wait_time = now + c->lock_timeout;\n\n        c->wait_event.handler = ngx_http_file_cache_lock_wait_handler;\n        c->wait_event.data = r;\n        c->wait_event.log = r->connection->log;\n    }\n\n    timer = c->wait_time - now;\n\n    ngx_add_timer(&c->wait_event, (timer > 500) ? 500 : timer);\n\n    r->main->blocked++;\n\n    return NGX_AGAIN;\n}", "patch_func_code": "static ngx_int_t\nngx_http_file_cache_lock(ngx_http_request_t *r, ngx_http_cache_t *c)\n{\n    ngx_msec_t                 now, timer;\n    ngx_http_file_cache_t     *cache;\n\n    if (!c->lock) {\n        return NGX_DECLINED;\n    }\n\n    now = ngx_current_msec;\n\n    cache = c->file_cache;\n\n    ngx_shmtx_lock(&cache->shpool->mutex);\n\n    timer = c->node->lock_time - now;\n\n    if (!c->node->updating || (ngx_msec_int_t) timer <= 0) {\n        c->node->updating = 1;\n        c->node->lock_time = now + c->lock_age;\n        c->updating = 1;\n        c->lock_time = c->node->lock_time;\n    }\n\n    ngx_shmtx_unlock(&cache->shpool->mutex);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,\n                   \"http file cache lock u:%d wt:%M\",\n                   c->updating, c->wait_time);\n\n    if (c->updating) {\n        return NGX_DECLINED;\n    }\n\n    if (c->lock_timeout == 0) {\n        return NGX_HTTP_CACHE_SCARCE;\n    }\n\n    c->waiting = 1;\n\n    if (c->wait_time == 0) {\n        c->wait_time = now + c->lock_timeout;\n\n        c->wait_event.handler = ngx_http_file_cache_lock_wait_handler;\n        c->wait_event.data = r;\n        c->wait_event.log = r->connection->log;\n    }\n\n    timer = c->wait_time - now;\n\n    ngx_add_timer(&c->wait_event, (timer > 500) ? 500 : timer);\n\n    r->main->blocked++;\n\n    return NGX_AGAIN;\n}", "before_change_lines": [15, 30, 32], "raw_before_change_lines": [15, 30, 32], "after_change_lines": [11, 17, 19, 21, 23, 36, 37, 38, 40], "raw_after_change_lines": [11, 12, 17, 18, 19, 21, 23, 36, 37, 38, 40], "bug_lines": [15, 30, 32], "added": [false, false, false], "idx": 344}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10273----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_000abaeb6fb99358ce2c1efdc56b7b15bf5a0b2c_1.json----bn_expand2", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_000abaeb6fb99358ce2c1efdc56b7b15bf5a0b2c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_000abaeb6fb99358ce2c1efdc56b7b15bf5a0b2c_1.json", "function_name": "bn_expand2", "vul_func_code": "BIGNUM *bn_expand2(BIGNUM *b, int words)\n\t{\n\tBN_ULONG *A;\n\tint i;\n\n\tbn_check_top(b);\n\n\tif (words > b->dmax)\n\t\t{\n\t\tBN_ULONG *a = bn_expand_internal(b, words);\n\t\tif(!a) return NULL;\n\t\tif(b->d) OPENSSL_free(b->d);\n\t\tb->d=a;\n\t\tb->dmax=words;\n\t\t}\n\n\t/* NB: bn_wexpand() calls this only if the BIGNUM really has to grow */\n\tif (b->top < b->dmax)\n\t\t{\n\t\tA = &(b->d[b->top]);\n\t\tfor (i=(b->dmax - b->top)>>3; i>0; i--,A+=8)\n\t\t\t{\n\t\t\tA[0]=0; A[1]=0; A[2]=0; A[3]=0;\n\t\t\tA[4]=0; A[5]=0; A[6]=0; A[7]=0;\n\t\t\t}\n\t\tfor (i=(b->dmax - b->top)&7; i>0; i--,A++)\n\t\t\tA[0]=0;\n\t\tassert(A == &(b->d[b->dmax]));\n\t\t}\n\tbn_check_top(b);\n\treturn b;\n\t}", "patch_func_code": "BIGNUM *bn_expand2(BIGNUM *b, int words)\n\t{\n\tbn_check_top(b);\n\n\tif (words > b->dmax)\n\t\t{\n\t\tBN_ULONG *a = bn_expand_internal(b, words);\n\t\tif(!a) return NULL;\n\t\tif(b->d) OPENSSL_free(b->d);\n\t\tb->d=a;\n\t\tb->dmax=words;\n\t\t}\n\n/* None of this should be necessary because of what b->top means! */\n#if 0\n\t/* NB: bn_wexpand() calls this only if the BIGNUM really has to grow */\n\tif (b->top < b->dmax)\n\t\t{\n\t\tint i;\n\t\tBN_ULONG *A = &(b->d[b->top]);\n\t\tfor (i=(b->dmax - b->top)>>3; i>0; i--,A+=8)\n\t\t\t{\n\t\t\tA[0]=0; A[1]=0; A[2]=0; A[3]=0;\n\t\t\tA[4]=0; A[5]=0; A[6]=0; A[7]=0;\n\t\t\t}\n\t\tfor (i=(b->dmax - b->top)&7; i>0; i--,A++)\n\t\t\tA[0]=0;\n\t\tassert(A == &(b->d[b->dmax]));\n\t\t}\n#endif\n\tbn_check_top(b);\n\treturn b;\n\t}", "before_change_lines": [3, 4, 20], "raw_before_change_lines": [3, 4, 5, 20], "after_change_lines": [15, 19, 20, 30], "raw_after_change_lines": [14, 15, 19, 20, 30], "bug_lines": [3, 4, 5, 20], "added": [false, false, false, false], "idx": 345}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "10296----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_01439aa472ab6dbab4f9b63e3627efb1687802ca_1.json----BN_mod_mul_montgomery", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_01439aa472ab6dbab4f9b63e3627efb1687802ca_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_01439aa472ab6dbab4f9b63e3627efb1687802ca_1.json", "function_name": "BN_mod_mul_montgomery", "vul_func_code": "int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n\t\t\t  BN_MONT_CTX *mont, BN_CTX *ctx)\n\t{\n\tBIGNUM *tmp,*tmp2;\n\tint ret=0;\n\n\tBN_CTX_start(ctx);\n\ttmp = BN_CTX_get(ctx);\n\ttmp2 = BN_CTX_get(ctx);\n\tif (tmp == NULL || tmp2 == NULL) goto err;\n\n\tbn_check_top(tmp);\n\tbn_check_top(tmp2);\n\n\tif (a == b)\n\t\t{\n#if 1 \n\t\tbn_wexpand(tmp,a->top*2);\n\t\tbn_wexpand(tmp2,a->top*4);\n\t\tbn_sqr_recursive(tmp->d,a->d,a->top,tmp2->d);\n\t\ttmp->top=a->top*2;\n\t\tif (tmp->top > 0 && tmp->d[tmp->top-1] == 0)\n\t\t\ttmp->top--;\n#else\n\t\tif (!BN_sqr(tmp,a,ctx)) goto err;\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mul(tmp,a,b,ctx)) goto err;\n\t\t}\n\t/* reduce from aRR to aR */\n\tif (!BN_from_montgomery(r,tmp,mont,ctx)) goto err;\n\tret=1;\nerr:\n\tBN_CTX_end(ctx);\n\treturn(ret);\n\t}", "patch_func_code": "int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,\n\t\t\t  BN_MONT_CTX *mont, BN_CTX *ctx)\n\t{\n\tBIGNUM *tmp,*tmp2;\n\tint ret=0;\n\n\tBN_CTX_start(ctx);\n\ttmp = BN_CTX_get(ctx);\n\ttmp2 = BN_CTX_get(ctx);\n\tif (tmp == NULL || tmp2 == NULL) goto err;\n\n\tbn_check_top(tmp);\n\tbn_check_top(tmp2);\n\n\tif (a == b)\n\t\t{\n#if 0 /* buggy -- try squaring  g  in the following parameters\n         (but note that squaring 2 or 4 works):\nDiffie-Hellman-Parameters: (1024 bit)\n    prime:\n        00:ff:ff:ff:ff:ff:ff:ff:ff:c9:0f:da:a2:21:68:\n        c2:34:c4:c6:62:8b:80:dc:1c:d1:29:02:4e:08:8a:\n        67:cc:74:02:0b:be:a6:3b:13:9b:22:51:4a:08:79:\n        8e:34:04:dd:ef:95:19:b3:cd:3a:43:1b:30:2b:0a:\n        6d:f2:5f:14:37:4f:e1:35:6d:6d:51:c2:45:e4:85:\n        b5:76:62:5e:7e:c6:f4:4c:42:e9:a6:37:ed:6b:0b:\n        ff:5c:b6:f4:06:b7:ed:ee:38:6b:fb:5a:89:9f:a5:\n        ae:9f:24:11:7c:4b:1f:e6:49:28:66:51:ec:e6:53:\n        81:ff:ff:ff:ff:ff:ff:ff:ff\n    generator: 8 (0x8)\n-----BEGIN DH PARAMETERS-----\nMIGHAoGBAP//////////yQ/aoiFowjTExmKLgNwc0SkCTgiKZ8x0Agu+pjsTmyJR\nSgh5jjQE3e+VGbPNOkMbMCsKbfJfFDdP4TVtbVHCReSFtXZiXn7G9ExC6aY37WsL\n/1y29Aa37e44a/taiZ+lrp8kEXxLH+ZJKGZR7OZTgf//////////AgEI\n-----END DH PARAMETERS-----\n*/\n\t\tbn_wexpand(tmp,a->top*2);\n\t\tbn_wexpand(tmp2,a->top*4);\n\t\tbn_sqr_recursive(tmp->d,a->d,a->top,tmp2->d);\n\t\ttmp->top=a->top*2;\n\t\tif (tmp->top > 0 && tmp->d[tmp->top-1] == 0)\n\t\t\ttmp->top--;\n#else\n\t\tif (!BN_sqr(tmp,a,ctx)) goto err;\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (!BN_mul(tmp,a,b,ctx)) goto err;\n\t\t}\n\t/* reduce from aRR to aR */\n\tif (!BN_from_montgomery(r,tmp,mont,ctx)) goto err;\n\tret=1;\nerr:\n\tBN_CTX_end(ctx);\n\treturn(ret);\n\t}", "before_change_lines": [17], "raw_before_change_lines": [17], "after_change_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], "raw_after_change_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], "bug_lines": [17], "added": [false], "idx": 346}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10298----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_014eec82366e16b0cc2a769590ca53ad868b986b_1.json----X509_STORE_new", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_014eec82366e16b0cc2a769590ca53ad868b986b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_014eec82366e16b0cc2a769590ca53ad868b986b_1.json", "function_name": "X509_STORE_new", "vul_func_code": "X509_STORE *X509_STORE_new(void)\n\t{\n\tX509_STORE *ret;\n\n\tif ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)\n\t\treturn(NULL);\n\tret->certs=lh_new(x509_object_hash,x509_object_cmp);\n\tret->cache=1;\n\tret->get_cert_methods=sk_X509_LOOKUP_new_null();\n\tret->verify=NULL;\n\tret->verify_cb=NULL;\n\tmemset(&ret->ex_data,0,sizeof(CRYPTO_EX_DATA));\n\tret->references=1;\n\tret->depth=0;\n\treturn(ret);\n\t}", "patch_func_code": "X509_STORE *X509_STORE_new(void)\n\t{\n\tX509_STORE *ret;\n\n\tif ((ret=(X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)\n\t\treturn(NULL);\n\tret->objs = sk_X509_OBJECT_new(x509_object_cmp);\n\tret->cache=1;\n\tret->get_cert_methods=sk_X509_LOOKUP_new_null();\n\tret->verify=NULL;\n\tret->verify_cb=NULL;\n\tmemset(&ret->ex_data,0,sizeof(CRYPTO_EX_DATA));\n\tret->references=1;\n\tret->depth=0;\n\treturn(ret);\n\t}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [7], "raw_after_change_lines": [7], "bug_lines": [7], "added": [false], "idx": 347}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10307----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_1.json----ubsec_rsa_mod_exp", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_1.json", "function_name": "ubsec_rsa_mod_exp", "vul_func_code": "static int ubsec_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\n\t{\n\tBN_CTX *ctx;\n\tint to_return = 0;\n\n\tif((ctx = BN_CTX_new()) == NULL)\n\t\tgoto err;\n\n\tif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\n\t\t{\n\t\tUBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP, UBSEC_R_MISSING_KEY_COMPONENTS);\n\t\tgoto err;\n\t\t}\n\n\t/*\n\t * Do in software if argument is too large for hardware.\n\t */\n\tif ((BN_num_bits(rsa->p)+BN_num_bits(rsa->q)) > 1024) {\n\t\tconst RSA_METHOD *meth = RSA_PKCS1_SSLeay();\n\t\tto_return = (*meth->rsa_mod_exp)(r0, I, rsa);\n\t} else {\n\t\tto_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,\n\t\t\trsa->dmq1, rsa->iqmp, ctx);\n\t}\nerr:\n\tif(ctx)\n\t\tBN_CTX_free(ctx);\n\treturn to_return;\n\t}", "patch_func_code": "static int ubsec_rsa_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)\n\t{\n\tBN_CTX *ctx;\n\tint to_return = 0;\n\n\tif((ctx = BN_CTX_new()) == NULL)\n\t\tgoto err;\n\n\tif(!rsa->p || !rsa->q || !rsa->dmp1 || !rsa->dmq1 || !rsa->iqmp)\n\t\t{\n\t\tUBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP, UBSEC_R_MISSING_KEY_COMPONENTS);\n\t\tgoto err;\n\t\t}\n\n\tto_return = ubsec_mod_exp_crt(r0, I, rsa->p, rsa->q, rsa->dmp1,\n\t\t    rsa->dmq1, rsa->iqmp, ctx);\n\tif (to_return == FAIL_TO_SOFTWARE)\n\t{\n\t  /*\n\t   * Do in software as hardware failed.\n\t   */\n\t   const RSA_METHOD *meth = RSA_PKCS1_SSLeay();\n\t   to_return = (*meth->rsa_mod_exp)(r0, I, rsa);\n\t}\nerr:\n\tif(ctx)\n\t\tBN_CTX_free(ctx);\n\treturn to_return;\n\t}", "before_change_lines": [16, 17, 18, 19, 20, 21, 22, 23], "raw_before_change_lines": [15, 16, 17, 18, 19, 20, 21, 22, 23], "after_change_lines": [15, 16, 17, 18, 20, 21, 22, 23], "raw_after_change_lines": [15, 16, 17, 18, 19, 20, 21, 22, 23], "bug_lines": [15, 16, 17, 18, 19, 20, 21, 22, 23], "added": [false, false, false, false, false, false, false, false, false], "idx": 348}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10308----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_1.json----ubsec_mod_exp_crt", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018b5558f8273c8e4e78527a0a83a77738b9c836_1.json", "function_name": "ubsec_mod_exp_crt", "vul_func_code": "static int ubsec_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n\t\t\tconst BIGNUM *q, const BIGNUM *dp,\n\t\t\tconst BIGNUM *dq, const BIGNUM *qinv, BN_CTX *ctx)\n\t{\n\tint\ty_len,\n\t\tm_len,\n\t\tfd;\n\n\tm_len = BN_num_bytes(p) + BN_num_bytes(q) + 1;\n\ty_len = BN_num_bits(p) + BN_num_bits(q);\n\n\t/* Check if hardware can't handle this argument. */\n\tif (y_len > 1024) {\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\n\t\treturn 0;\n\t} \n\n\tif (!bn_wexpand(r, p->top + q->top + 1)) {\n\t\tUBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP_CRT, UBSEC_R_BN_EXPAND_FAIL);\n\t\treturn 0;\n\t}\n\n\tif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\n\t\tfd = 0;\n\t\tUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_UNIT_FAILURE);\n\t\treturn 0;\n\t}\n\n\tif (p_UBSEC_rsa_mod_exp_crt_ioctl(fd,\n\t\t(unsigned char *)a->d, BN_num_bits(a), \n\t\t(unsigned char *)qinv->d, BN_num_bits(qinv),\n\t\t(unsigned char *)dp->d, BN_num_bits(dp),\n\t\t(unsigned char *)p->d, BN_num_bits(p),\n\t\t(unsigned char *)dq->d, BN_num_bits(dq),\n\t\t(unsigned char *)q->d, BN_num_bits(q),\n\t\t(unsigned char *)r->d,  &y_len) != 0) {\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_REQUEST_FAILED);\n\t\treturn 0;\n\t}\n\n\tp_UBSEC_ubsec_close(fd);\n\n\tr->top = (BN_num_bits(p) + BN_num_bits(q) + BN_BITS2 - 1)/BN_BITS2;\n\treturn 1;\n}", "patch_func_code": "static int ubsec_mod_exp_crt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,\n\t\t\tconst BIGNUM *q, const BIGNUM *dp,\n\t\t\tconst BIGNUM *dq, const BIGNUM *qinv, BN_CTX *ctx)\n\t{\n\tint\ty_len,\n\t\tm_len,\n\t\tfd;\n\n\tm_len = BN_num_bytes(p) + BN_num_bytes(q) + 1;\n\ty_len = BN_num_bits(p) + BN_num_bits(q);\n\n\t/* Check if hardware can't handle this argument. */\n\tif (y_len > max_key_len) {\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_SIZE_TOO_LARGE_OR_TOO_SMALL);\n\t\treturn FAIL_TO_SOFTWARE;\n\t} \n\n\tif (!bn_wexpand(r, p->top + q->top + 1)) {\n\t\tUBSECerr(UBSEC_F_UBSEC_RSA_MOD_EXP_CRT, UBSEC_R_BN_EXPAND_FAIL);\n\t\treturn 0;\n\t}\n\n\tif ((fd = p_UBSEC_ubsec_open(UBSEC_KEY_DEVICE_NAME)) <= 0) {\n\t\tfd = 0;\n\t\tUBSECerr(UBSEC_F_UBSEC_INIT, UBSEC_R_UNIT_FAILURE);\n\t\treturn FAIL_TO_SOFTWARE;\n\t}\n\n\tif (p_UBSEC_rsa_mod_exp_crt_ioctl(fd,\n\t\t(unsigned char *)a->d, BN_num_bits(a), \n\t\t(unsigned char *)qinv->d, BN_num_bits(qinv),\n\t\t(unsigned char *)dp->d, BN_num_bits(dp),\n\t\t(unsigned char *)p->d, BN_num_bits(p),\n\t\t(unsigned char *)dq->d, BN_num_bits(dq),\n\t\t(unsigned char *)q->d, BN_num_bits(q),\n\t\t(unsigned char *)r->d,  &y_len) != 0) {\n\t\tUBSECerr(UBSEC_F_UBSEC_MOD_EXP, UBSEC_R_REQUEST_FAILED);\n                p_UBSEC_ubsec_close(fd);\n\t\treturn FAIL_TO_SOFTWARE;\n\t}\n\n\tp_UBSEC_ubsec_close(fd);\n\n\tr->top = (BN_num_bits(p) + BN_num_bits(q) + BN_BITS2 - 1)/BN_BITS2;\n\treturn 1;\n}", "before_change_lines": [13, 15, 26, 38], "raw_before_change_lines": [13, 15, 26, 38], "after_change_lines": [13, 15, 26, 38, 39], "raw_after_change_lines": [13, 15, 26, 38, 39], "bug_lines": [13, 15, 26, 38], "added": [false, false, false, false], "idx": 349}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10309----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018dcf8a27af741664ace7773e4fdf2ec9d7db81_1.json----test_encode_tls_sct", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_018dcf8a27af741664ace7773e4fdf2ec9d7db81_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_018dcf8a27af741664ace7773e4fdf2ec9d7db81_1.json", "function_name": "test_encode_tls_sct", "vul_func_code": "static int test_encode_tls_sct()\n{\n    const char log_id[] = \"3xwuwRUAlFJHqWFoMl3cXHlZ6PfG04j8AC4LvT9012Q=\";\n    const uint64_t timestamp = 1;\n    const char extensions[] = \"\";\n    const char signature[] = \"BAMARzBAMiBIL2dRrzXbplQ2vh/WZA89v5pBQpSVkkUwKI+j5\"\n            \"eI+BgIhAOTtwNs6xXKx4vXoq2poBlOYfc9BAn3+/6EFUZ2J7b8I\";\n    SCT *sct = NULL;\n\n    SETUP_CT_TEST_FIXTURE();\n\n    fixture.sct_list = sk_SCT_new_null();\n    sct = SCT_new_from_base64(SCT_VERSION_V1, log_id,\n                              CT_LOG_ENTRY_TYPE_X509, timestamp,\n                              extensions, signature);\n\n    if (sct == NULL) {\n        tear_down(fixture);\n        fprintf(stderr, \"Failed to create SCT from base64-encoded test data\\n\");\n        return 0;\n    }\n\n    sk_SCT_push(fixture.sct_list, sct);\n    fixture.sct_dir = ct_dir;\n    fixture.sct_text_file = \"tls1.sct\";\n    EXECUTE_CT_TEST();\n}", "patch_func_code": "static int test_encode_tls_sct()\n{\n    const char log_id[] = \"3xwuwRUAlFJHqWFoMl3cXHlZ6PfG04j8AC4LvT9012Q=\";\n    const uint64_t timestamp = 1;\n    const char extensions[] = \"\";\n    const char signature[] = \"BAMARzBAMiBIL2dRrzXbplQ2vh/WZA89v5pBQpSVkkUwKI+j5\"\n            \"eI+BgIhAOTtwNs6xXKx4vXoq2poBlOYfc9BAn3+/6EFUZ2J7b8I\";\n    SCT *sct = NULL;\n\n    SETUP_CT_TEST_FIXTURE();\n\n    fixture.sct_list = sk_SCT_new_null();\n    if (!TEST_ptr(sct = SCT_new_from_base64(SCT_VERSION_V1, log_id,\n                                            CT_LOG_ENTRY_TYPE_X509, timestamp,\n                                            extensions, signature)))\n\n        return 0;\n\n    sk_SCT_push(fixture.sct_list, sct);\n    fixture.sct_dir = ct_dir;\n    fixture.sct_text_file = \"tls1.sct\";\n    EXECUTE_CT_TEST();\n}", "before_change_lines": [13, 14, 15, 17, 18, 19, 21], "raw_before_change_lines": [13, 14, 15, 17, 18, 19, 21], "after_change_lines": [13, 14, 15], "raw_after_change_lines": [13, 14, 15], "bug_lines": [13, 14, 15, 17, 18, 19, 21], "added": [false, false, false, false, false, false, false], "idx": 350}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10313----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_01b416b52ae95c48debaf21b8a9849a75f2055dc_1.json----RSA_print", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_01b416b52ae95c48debaf21b8a9849a75f2055dc_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_01b416b52ae95c48debaf21b8a9849a75f2055dc_1.json", "function_name": "RSA_print", "vul_func_code": "int RSA_print(BIO *bp, const RSA *x, int off)\n\t{\n\tchar str[128];\n\tconst char *s;\n\tunsigned char *m=NULL;\n\tint ret=0;\n\tsize_t buf_len=0, i;\n\n\tif (x->n)\n\t\tbuf_len = (size_t)BN_num_bytes(x->n);\n\tif (x->e)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->e)))\n\t\t\tbuf_len = i;\n\tif (x->d)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->d)))\n\t\t\tbuf_len = i;\n\tif (x->p)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->p)))\n\t\t\tbuf_len = i;\n\tif (x->q)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->q)))\n\t\t\tbuf_len = i;\n\tif (x->dmp1)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->dmp1)))\n\t\t\tbuf_len = i;\n\tif (x->dmq1)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->dmq1)))\n\t\t\tbuf_len = i;\n\tif (x->iqmp)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->iqmp)))\n\t\t\tbuf_len = i;\n\n\tm=(unsigned char *)OPENSSL_malloc(buf_len+10);\n\tif (m == NULL)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tif (x->d != NULL)\n\t\t{\n\t\tif(!BIO_indent(bp,off,128))\n\t\t   goto err;\n\t\tif (BIO_printf(bp,\"Private-Key: (%d bit)\\n\",BN_num_bits(x->n))\n\t\t\t<= 0) goto err;\n\t\t}\n\n\tif (x->d == NULL)\n\t\tsprintf(str,\"Modulus (%d bit):\",BN_num_bits(x->n));\n\telse\n\t\tstrcpy(str,\"modulus:\");\n\tif (!print(bp,str,x->n,m,off)) goto err;\n\ts=(x->d == NULL)?\"Exponent:\":\"publicExponent:\";\n\tif (!print(bp,s,x->e,m,off)) goto err;\n\tif (!print(bp,\"privateExponent:\",x->d,m,off)) goto err;\n\tif (!print(bp,\"prime1:\",x->p,m,off)) goto err;\n\tif (!print(bp,\"prime2:\",x->q,m,off)) goto err;\n\tif (!print(bp,\"exponent1:\",x->dmp1,m,off)) goto err;\n\tif (!print(bp,\"exponent2:\",x->dmq1,m,off)) goto err;\n\tif (!print(bp,\"coefficient:\",x->iqmp,m,off)) goto err;\n\tret=1;\nerr:\n\tif (m != NULL) OPENSSL_free(m);\n\treturn(ret);\n\t}", "patch_func_code": "int RSA_print(BIO *bp, const RSA *x, int off)\n\t{\n\tchar str[128];\n\tconst char *s;\n\tunsigned char *m=NULL;\n\tint ret=0;\n\tsize_t buf_len=0, i;\n\n\tif (x->n)\n\t\tbuf_len = (size_t)BN_num_bytes(x->n);\n\tif (x->e)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->e)))\n\t\t\tbuf_len = i;\n\tif (x->d)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->d)))\n\t\t\tbuf_len = i;\n\tif (x->p)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->p)))\n\t\t\tbuf_len = i;\n\tif (x->q)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->q)))\n\t\t\tbuf_len = i;\n\tif (x->dmp1)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->dmp1)))\n\t\t\tbuf_len = i;\n\tif (x->dmq1)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->dmq1)))\n\t\t\tbuf_len = i;\n\tif (x->iqmp)\n\t\tif (buf_len < (i = (size_t)BN_num_bytes(x->iqmp)))\n\t\t\tbuf_len = i;\n\n\tm=(unsigned char *)OPENSSL_malloc(buf_len+10);\n\tif (m == NULL)\n\t\t{\n\t\tRSAerr(RSA_F_RSA_PRINT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tif (x->d != NULL)\n\t\t{\n\t\tif(!BIO_indent(bp,off,128))\n\t\t   goto err;\n\t\tif (BIO_printf(bp,\"Private-Key: (%d bit)\\n\",BN_num_bits(x->n))\n\t\t\t<= 0) goto err;\n\t\t}\n\n\tif (x->d == NULL)\n\t\tBIO_snprintf(str,sizeof str,\"Modulus (%d bit):\",BN_num_bits(x->n));\n\telse\n\t\tBUF_strlcpy(str,\"modulus:\",sizeof str);\n\tif (!print(bp,str,x->n,m,off)) goto err;\n\ts=(x->d == NULL)?\"Exponent:\":\"publicExponent:\";\n\tif (!print(bp,s,x->e,m,off)) goto err;\n\tif (!print(bp,\"privateExponent:\",x->d,m,off)) goto err;\n\tif (!print(bp,\"prime1:\",x->p,m,off)) goto err;\n\tif (!print(bp,\"prime2:\",x->q,m,off)) goto err;\n\tif (!print(bp,\"exponent1:\",x->dmp1,m,off)) goto err;\n\tif (!print(bp,\"exponent2:\",x->dmq1,m,off)) goto err;\n\tif (!print(bp,\"coefficient:\",x->iqmp,m,off)) goto err;\n\tret=1;\nerr:\n\tif (m != NULL) OPENSSL_free(m);\n\treturn(ret);\n\t}", "before_change_lines": [49, 51], "raw_before_change_lines": [49, 51], "after_change_lines": [49, 51], "raw_after_change_lines": [49, 51], "bug_lines": [49, 51], "added": [false, false], "idx": 351}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10322----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0210599e776d56fc5e87091ee443f56b5f0d2734_1.json----ctr_XOR", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0210599e776d56fc5e87091ee443f56b5f0d2734_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0210599e776d56fc5e87091ee443f56b5f0d2734_1.json", "function_name": "ctr_XOR", "vul_func_code": "static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen < cctx->keylen ? inlen : cctx->keylen;\n    for (i = 0; i < n; i++)\n        cctx->K[i] ^= in[i];\n    if (inlen <= cctx->keylen)\n        return;\n\n    n = inlen - cctx->keylen;\n    if (n > 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i < 16; i++)\n        cctx->V[i] ^= in[i + cctx->keylen];\n}", "patch_func_code": "static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen < cctx->keylen ? inlen : cctx->keylen;\n    for (i = 0; i < n; i++)\n        cctx->K[i] ^= in[i];\n    if (inlen <= cctx->keylen)\n        return;\n\n    n = inlen - cctx->keylen;\n    if (n > 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i < n; i++)\n        cctx->V[i] ^= in[i + cctx->keylen];\n}", "before_change_lines": [23], "raw_before_change_lines": [23], "after_change_lines": [23], "raw_after_change_lines": [23], "bug_lines": [23], "added": [false], "idx": 352}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "10337----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0299162b2ec5492f9506b87d8e7dcc3c94101797_1.json----SRP_create_verifier", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0299162b2ec5492f9506b87d8e7dcc3c94101797_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0299162b2ec5492f9506b87d8e7dcc3c94101797_1.json", "function_name": "SRP_create_verifier", "vul_func_code": "char *SRP_create_verifier(const char *user, const char *pass, char **salt,\n                          char **verifier, const char *N, const char *g)\n{\n    int len;\n    char *result = NULL, *vf = NULL;\n    const BIGNUM *N_bn = NULL, *g_bn = NULL;\n    BIGNUM *N_bn_alloc = NULL, *g_bn_alloc = NULL, *s = NULL, *v = NULL;\n    unsigned char tmp[MAX_LEN];\n    unsigned char tmp2[MAX_LEN];\n    char *defgNid = NULL;\n    int vfsize = 0;\n\n    if ((user == NULL) ||\n        (pass == NULL) || (salt == NULL) || (verifier == NULL))\n        goto err;\n\n    if (N) {\n        if ((len = t_fromb64(tmp, N)) == 0)\n            goto err;\n        N_bn_alloc = BN_bin2bn(tmp, len, NULL);\n        N_bn = N_bn_alloc;\n        if ((len = t_fromb64(tmp, g)) == 0)\n            goto err;\n        g_bn_alloc = BN_bin2bn(tmp, len, NULL);\n        g_bn = g_bn_alloc;\n        defgNid = \"*\";\n    } else {\n        SRP_gN *gN = SRP_get_gN_by_id(g, NULL);\n        if (gN == NULL)\n            goto err;\n        N_bn = gN->N;\n        g_bn = gN->g;\n        defgNid = gN->id;\n    }\n\n    if (*salt == NULL) {\n        if (RAND_bytes(tmp2, SRP_RANDOM_SALT_LEN) <= 0)\n            goto err;\n\n        s = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL);\n    } else {\n        if ((len = t_fromb64(tmp2, *salt)) == 0)\n            goto err;\n        s = BN_bin2bn(tmp2, len, NULL);\n    }\n\n    if (!SRP_create_verifier_BN(user, pass, &s, &v, N_bn, g_bn))\n        goto err;\n\n    BN_bn2bin(v, tmp);\n    vfsize = BN_num_bytes(v) * 2;\n    if (((vf = OPENSSL_malloc(vfsize)) == NULL))\n        goto err;\n    t_tob64(vf, tmp, BN_num_bytes(v));\n\n    if (*salt == NULL) {\n        char *tmp_salt;\n\n        if ((tmp_salt = OPENSSL_malloc(SRP_RANDOM_SALT_LEN * 2)) == NULL) {\n            goto err;\n        }\n        t_tob64(tmp_salt, tmp2, SRP_RANDOM_SALT_LEN);\n        *salt = tmp_salt;\n    }\n\n    *verifier = vf;\n    vf = NULL;\n    result = defgNid;\n\n err:\n    BN_free(N_bn_alloc);\n    BN_free(g_bn_alloc);\n    OPENSSL_clear_free(vf, vfsize);\n    BN_clear_free(s);\n    BN_clear_free(v);\n    return result;\n}", "patch_func_code": "char *SRP_create_verifier(const char *user, const char *pass, char **salt,\n                          char **verifier, const char *N, const char *g)\n{\n    int len;\n    char *result = NULL, *vf = NULL;\n    const BIGNUM *N_bn = NULL, *g_bn = NULL;\n    BIGNUM *N_bn_alloc = NULL, *g_bn_alloc = NULL, *s = NULL, *v = NULL;\n    unsigned char tmp[MAX_LEN];\n    unsigned char tmp2[MAX_LEN];\n    char *defgNid = NULL;\n    int vfsize = 0;\n\n    if ((user == NULL) ||\n        (pass == NULL) || (salt == NULL) || (verifier == NULL))\n        goto err;\n\n    if (N) {\n        if ((len = t_fromb64(tmp, sizeof(tmp), N)) <= 0)\n            goto err;\n        N_bn_alloc = BN_bin2bn(tmp, len, NULL);\n        N_bn = N_bn_alloc;\n        if ((len = t_fromb64(tmp, sizeof(tmp) ,g)) <= 0)\n            goto err;\n        g_bn_alloc = BN_bin2bn(tmp, len, NULL);\n        g_bn = g_bn_alloc;\n        defgNid = \"*\";\n    } else {\n        SRP_gN *gN = SRP_get_gN_by_id(g, NULL);\n        if (gN == NULL)\n            goto err;\n        N_bn = gN->N;\n        g_bn = gN->g;\n        defgNid = gN->id;\n    }\n\n    if (*salt == NULL) {\n        if (RAND_bytes(tmp2, SRP_RANDOM_SALT_LEN) <= 0)\n            goto err;\n\n        s = BN_bin2bn(tmp2, SRP_RANDOM_SALT_LEN, NULL);\n    } else {\n        if ((len = t_fromb64(tmp2, sizeof(tmp2), *salt)) <= 0)\n            goto err;\n        s = BN_bin2bn(tmp2, len, NULL);\n    }\n\n    if (!SRP_create_verifier_BN(user, pass, &s, &v, N_bn, g_bn))\n        goto err;\n\n    BN_bn2bin(v, tmp);\n    vfsize = BN_num_bytes(v) * 2;\n    if (((vf = OPENSSL_malloc(vfsize)) == NULL))\n        goto err;\n    t_tob64(vf, tmp, BN_num_bytes(v));\n\n    if (*salt == NULL) {\n        char *tmp_salt;\n\n        if ((tmp_salt = OPENSSL_malloc(SRP_RANDOM_SALT_LEN * 2)) == NULL) {\n            goto err;\n        }\n        t_tob64(tmp_salt, tmp2, SRP_RANDOM_SALT_LEN);\n        *salt = tmp_salt;\n    }\n\n    *verifier = vf;\n    vf = NULL;\n    result = defgNid;\n\n err:\n    BN_free(N_bn_alloc);\n    BN_free(g_bn_alloc);\n    OPENSSL_clear_free(vf, vfsize);\n    BN_clear_free(s);\n    BN_clear_free(v);\n    return result;\n}", "before_change_lines": [18, 22, 42], "raw_before_change_lines": [18, 22, 42], "after_change_lines": [18, 22, 42], "raw_after_change_lines": [18, 22, 42], "bug_lines": [18, 22, 42], "added": [false, false, false], "idx": 353}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10344----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_02aef6aad09723981e862f1c3de40d8bd8db4860_1.json----tls_psk_do_binder", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_02aef6aad09723981e862f1c3de40d8bd8db4860_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_02aef6aad09723981e862f1c3de40d8bd8db4860_1.json", "function_name": "tls_psk_do_binder", "vul_func_code": "int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,\n                      size_t binderoffset, const unsigned char *binderin,\n                      unsigned char *binderout, SSL_SESSION *sess, int sign,\n                      int external)\n{\n    EVP_PKEY *mackey = NULL;\n    EVP_MD_CTX *mctx = NULL;\n    unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE];\n    unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE];\n    unsigned char *early_secret;\n    static const unsigned char resumption_label[] = \"res binder\";\n    static const unsigned char external_label[] = \"ext binder\";\n    const unsigned char *label;\n    size_t bindersize, labelsize, hashsize;\n    int hashsizei = EVP_MD_size(md);\n    int ret = -1;\n    int usepskfored = 0;\n\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(hashsizei >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    hashsize = (size_t)hashsizei;\n\n    if (external\n            && s->early_data_state == SSL_EARLY_DATA_CONNECTING\n            && s->session->ext.max_early_data == 0\n            && sess->ext.max_early_data > 0)\n        usepskfored = 1;\n\n    if (external) {\n        label = external_label;\n        labelsize = sizeof(external_label) - 1;\n    } else {\n        label = resumption_label;\n        labelsize = sizeof(resumption_label) - 1;\n    }\n\n    /*\n     * Generate the early_secret. On the server side we've selected a PSK to\n     * resume with (internal or external) so we always do this. On the client\n     * side we do this for a non-external (i.e. resumption) PSK or external PSK\n     * that will be used for early_data so that it is in place for sending early\n     * data. For client side external PSK not being used for early_data we\n     * generate it but store it away for later use.\n     */\n    if (s->server || !external || usepskfored)\n        early_secret = (unsigned char *)s->early_secret;\n    else\n        early_secret = (unsigned char *)sess->early_secret;\n\n    if (!tls13_generate_secret(s, md, NULL, sess->master_key,\n                               sess->master_key_length, early_secret)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /*\n     * Create the handshake hash for the binder key...the messages so far are\n     * empty!\n     */\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL\n            || EVP_DigestInit_ex(mctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the binder key */\n    if (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash,\n                           hashsize, binderkey, hashsize)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /* Generate the finished key */\n    if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Get a hash of the ClientHello up to the start of the binders. If we are\n     * following a HelloRetryRequest then this includes the hash of the first\n     * ClientHello and the HelloRetryRequest itself.\n     */\n    if (s->hello_retry_request == SSL_HRR_PENDING) {\n        size_t hdatalen;\n        long hdatalen_l;\n        void *hdata;\n\n        hdatalen = hdatalen_l =\n            BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n        if (hdatalen_l <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                     SSL_R_BAD_HANDSHAKE_LENGTH);\n            goto err;\n        }\n\n        /*\n         * For servers the handshake buffer data will include the second\n         * ClientHello - which we don't want - so we need to take that bit off.\n         */\n        if (s->server) {\n            PACKET hashprefix, msg;\n\n            /* Find how many bytes are left after the first two messages */\n            if (!PACKET_buf_init(&hashprefix, hdata, hdatalen)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                         ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            hdatalen -= PACKET_remaining(&hashprefix);\n        }\n\n        if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    mackey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, finishedkey,\n                                          hashsize);\n    if (mackey == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (!sign)\n        binderout = tmpbinder;\n\n    bindersize = hashsize;\n    if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0\n            || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0\n            || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0\n            || bindersize != hashsize) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (sign) {\n        ret = 1;\n    } else {\n        /* HMAC keys can't do EVP_DigestVerify* - use CRYPTO_memcmp instead */\n        ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);\n        if (!ret)\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PSK_DO_BINDER,\n                     SSL_R_BINDER_DOES_NOT_VERIFY);\n    }\n\n err:\n    OPENSSL_cleanse(binderkey, sizeof(binderkey));\n    OPENSSL_cleanse(finishedkey, sizeof(finishedkey));\n    EVP_PKEY_free(mackey);\n    EVP_MD_CTX_free(mctx);\n\n    return ret;\n}", "patch_func_code": "int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,\n                      size_t binderoffset, const unsigned char *binderin,\n                      unsigned char *binderout, SSL_SESSION *sess, int sign,\n                      int external)\n{\n    EVP_PKEY *mackey = NULL;\n    EVP_MD_CTX *mctx = NULL;\n    unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE];\n    unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE];\n    unsigned char *early_secret;\n    static const unsigned char resumption_label[] = \"res binder\";\n    static const unsigned char external_label[] = \"ext binder\";\n    const unsigned char *label;\n    size_t bindersize, labelsize, hashsize;\n    int hashsizei = EVP_MD_size(md);\n    int ret = -1;\n    int usepskfored = 0;\n\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(hashsizei >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    hashsize = (size_t)hashsizei;\n\n    if (external\n            && s->early_data_state == SSL_EARLY_DATA_CONNECTING\n            && s->session->ext.max_early_data == 0\n            && sess->ext.max_early_data > 0)\n        usepskfored = 1;\n\n    if (external) {\n        label = external_label;\n        labelsize = sizeof(external_label) - 1;\n    } else {\n        label = resumption_label;\n        labelsize = sizeof(resumption_label) - 1;\n    }\n\n    /*\n     * Generate the early_secret. On the server side we've selected a PSK to\n     * resume with (internal or external) so we always do this. On the client\n     * side we do this for a non-external (i.e. resumption) PSK or external PSK\n     * that will be used for early_data so that it is in place for sending early\n     * data. For client side external PSK not being used for early_data we\n     * generate it but store it away for later use.\n     */\n    if (s->server || !external || usepskfored)\n        early_secret = (unsigned char *)s->early_secret;\n    else\n        early_secret = (unsigned char *)sess->early_secret;\n\n    if (!tls13_generate_secret(s, md, NULL, sess->master_key,\n                               sess->master_key_length, early_secret)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /*\n     * Create the handshake hash for the binder key...the messages so far are\n     * empty!\n     */\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL\n            || EVP_DigestInit_ex(mctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the binder key */\n    if (!tls13_hkdf_expand(s, md, early_secret, label, labelsize, hash,\n                           hashsize, binderkey, hashsize, 1)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /* Generate the finished key */\n    if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Get a hash of the ClientHello up to the start of the binders. If we are\n     * following a HelloRetryRequest then this includes the hash of the first\n     * ClientHello and the HelloRetryRequest itself.\n     */\n    if (s->hello_retry_request == SSL_HRR_PENDING) {\n        size_t hdatalen;\n        long hdatalen_l;\n        void *hdata;\n\n        hdatalen = hdatalen_l =\n            BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n        if (hdatalen_l <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                     SSL_R_BAD_HANDSHAKE_LENGTH);\n            goto err;\n        }\n\n        /*\n         * For servers the handshake buffer data will include the second\n         * ClientHello - which we don't want - so we need to take that bit off.\n         */\n        if (s->server) {\n            PACKET hashprefix, msg;\n\n            /* Find how many bytes are left after the first two messages */\n            if (!PACKET_buf_init(&hashprefix, hdata, hdatalen)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                         ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            hdatalen -= PACKET_remaining(&hashprefix);\n        }\n\n        if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    mackey = EVP_PKEY_new_raw_private_key(EVP_PKEY_HMAC, NULL, finishedkey,\n                                          hashsize);\n    if (mackey == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (!sign)\n        binderout = tmpbinder;\n\n    bindersize = hashsize;\n    if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0\n            || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0\n            || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0\n            || bindersize != hashsize) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_PSK_DO_BINDER,\n                 ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (sign) {\n        ret = 1;\n    } else {\n        /* HMAC keys can't do EVP_DigestVerify* - use CRYPTO_memcmp instead */\n        ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);\n        if (!ret)\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_F_TLS_PSK_DO_BINDER,\n                     SSL_R_BINDER_DOES_NOT_VERIFY);\n    }\n\n err:\n    OPENSSL_cleanse(binderkey, sizeof(binderkey));\n    OPENSSL_cleanse(finishedkey, sizeof(finishedkey));\n    EVP_PKEY_free(mackey);\n    EVP_MD_CTX_free(mctx);\n\n    return ret;\n}", "before_change_lines": [75], "raw_before_change_lines": [75], "after_change_lines": [75], "raw_after_change_lines": [75], "bug_lines": [75], "added": [false], "idx": 354}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10364----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0313d3d7c2cda8e2e0bc2926e37a917979627536_1.json----test_exp_mod_zero", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0313d3d7c2cda8e2e0bc2926e37a917979627536_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0313d3d7c2cda8e2e0bc2926e37a917979627536_1.json", "function_name": "test_exp_mod_zero", "vul_func_code": "static int test_exp_mod_zero() {\n\tBIGNUM a, p, m;\n\tBIGNUM r;\n\tBN_CTX *ctx = BN_CTX_new();\n\tint ret = 1;\n\n\tBN_init(&m);\n\tBN_one(&m);\n\n\tBN_init(&a);\n\tBN_one(&a);\n\n\tBN_init(&p);\n\tBN_zero(&p);\n\n\tBN_init(&r);\n\tBN_mod_exp(&r, &a, &p, &m, ctx);\n\tBN_CTX_free(ctx);\n\n\tif (BN_is_zero(&r))\n\t\tret = 0;\n\telse\n\t\t{\n\t\tprintf(\"1**0 mod 1 = \");\n\t\tBN_print_fp(stdout, &r);\n\t\tprintf(\", should be 0\\n\");\n\t\t}\n\n\tBN_free(&r);\n\tBN_free(&a);\n\tBN_free(&p);\n\tBN_free(&m);\n\n\treturn ret;\n}", "patch_func_code": "static int test_exp_mod_zero() {\n\tBIGNUM *a = NULL, *p = NULL, *m = NULL;\n\tBIGNUM *r = NULL;\n\tBN_CTX *ctx = BN_CTX_new();\n\tint ret = 1;\n\n\tm = BN_new();\n\tif(!m) goto err;\n\tBN_one(m);\n\n\ta = BN_new();\n\tif(!a) goto err;\n\tBN_one(a);\n\n\tp = BN_new();\n\tif(!p) goto err;\n\tBN_zero(p);\n\n\tr = BN_new();\n\tif(!r) goto err;\n\tBN_mod_exp(r, a, p, m, ctx);\n\tBN_CTX_free(ctx);\n\n\tif (BN_is_zero(r))\n\t\tret = 0;\n\telse\n\t\t{\n\t\tprintf(\"1**0 mod 1 = \");\n\t\tBN_print_fp(stdout, r);\n\t\tprintf(\", should be 0\\n\");\n\t\t}\n\nerr:\n\tBN_free(r);\n\tBN_free(a);\n\tBN_free(p);\n\tBN_free(m);\n\n\treturn ret;\n}", "before_change_lines": [2, 3, 7, 8, 10, 11, 13, 14, 16, 17, 20, 25, 29, 30, 31, 32], "raw_before_change_lines": [2, 3, 7, 8, 10, 11, 13, 14, 16, 17, 20, 25, 29, 30, 31, 32], "after_change_lines": [2, 3, 7, 8, 9, 11, 12, 13, 15, 16, 17, 19, 20, 21, 24, 29, 33, 34, 35, 36, 37], "raw_after_change_lines": [2, 3, 7, 8, 9, 11, 12, 13, 15, 16, 17, 19, 20, 21, 24, 29, 33, 34, 35, 36, 37], "bug_lines": [2, 3, 7, 8, 10, 11, 13, 14, 16, 17, 20, 25, 29, 30, 31, 32], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 355}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10369----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_03168f2f98f3735ab3ffdc01e8499d79e6b4f003_1.json----ctr_XOR", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_03168f2f98f3735ab3ffdc01e8499d79e6b4f003_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_03168f2f98f3735ab3ffdc01e8499d79e6b4f003_1.json", "function_name": "ctr_XOR", "vul_func_code": "static void ctr_XOR(DRBG_CTR_CTX *cctx, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen < cctx->keylen ? inlen : cctx->keylen;\n    for (i = 0; i < n; i++)\n        cctx->K[i] ^= in[i];\n    if (inlen <= cctx->keylen)\n        return;\n\n    n = inlen - cctx->keylen;\n    if (n > 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i < n; i++)\n        cctx->V[i] ^= in[i + cctx->keylen];\n}", "patch_func_code": "static void ctr_XOR(RAND_DRBG_CTR *ctr, const unsigned char *in, size_t inlen)\n{\n    size_t i, n;\n\n    if (in == NULL || inlen == 0)\n        return;\n\n    /*\n     * Any zero padding will have no effect on the result as we\n     * are XORing. So just process however much input we have.\n     */\n    n = inlen < ctr->keylen ? inlen : ctr->keylen;\n    for (i = 0; i < n; i++)\n        ctr->K[i] ^= in[i];\n    if (inlen <= ctr->keylen)\n        return;\n\n    n = inlen - ctr->keylen;\n    if (n > 16) {\n        /* Should never happen */\n        n = 16;\n    }\n    for (i = 0; i < n; i++)\n        ctr->V[i] ^= in[i + ctr->keylen];\n}", "before_change_lines": [1, 12, 14, 15, 18, 24], "raw_before_change_lines": [1, 12, 14, 15, 18, 24], "after_change_lines": [1, 12, 14, 15, 18, 24], "raw_after_change_lines": [1, 12, 14, 15, 18, 24], "bug_lines": [1, 12, 14, 15, 18, 24], "added": [false, false, false, false, false, false], "idx": 356}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L3", "filepath_func": "10384----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_03a9f2df90e1da644719327cf6c1dd33754730ff_1.json----BN_mod_exp_mont", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_03a9f2df90e1da644719327cf6c1dd33754730ff_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_03a9f2df90e1da644719327cf6c1dd33754730ff_1.json", "function_name": "BN_mod_exp_mont", "vul_func_code": "int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    int i, j, bits, ret = 0, wstart, wend, window, wvalue;\n    int start = 1;\n    BIGNUM *d, *r;\n    const BIGNUM *aa;\n    /* Table of variables obtained from 'ctx' */\n    BIGNUM *val[TABLE_SIZE];\n    BN_MONT_CTX *mont = NULL;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(a, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {\n        return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);\n    }\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return 0;\n    }\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1, or x**0 mod -1 is still zero. */\n        if (BN_abs_is_word(m, 1)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    val[0] = BN_CTX_get(ctx);\n    if (val[0] == NULL)\n        goto err;\n\n    /*\n     * If this is not done, things will break in the montgomery part\n     */\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_nnmod(val[0], a, m, ctx))\n            goto err;\n        aa = val[0];\n    } else\n        aa = a;\n    if (BN_is_zero(aa)) {\n        BN_zero(rr);\n        ret = 1;\n        goto err;\n    }\n    if (!BN_to_montgomery(val[0], aa, mont, ctx))\n        goto err;               /* 1 */\n\n    window = BN_window_bits_for_exponent_size(bits);\n    if (window > 1) {\n        if (!BN_mod_mul_montgomery(d, val[0], val[0], mont, ctx))\n            goto err;           /* 2 */\n        j = 1 << (window - 1);\n        for (i = 1; i < j; i++) {\n            if (((val[i] = BN_CTX_get(ctx)) == NULL) ||\n                !BN_mod_mul_montgomery(val[i], val[i - 1], d, mont, ctx))\n                goto err;\n        }\n    }\n\n    start = 1;                  /* This is used to avoid multiplication etc\n                                 * when there is only the value '1' in the\n                                 * buffer. */\n    wvalue = 0;                 /* The 'value' of the window */\n    wstart = bits - 1;          /* The top bit of the window */\n    wend = 0;                   /* The bottom bit of the window */\n\n#if 1                           /* by Shay Gueron's suggestion */\n    j = m->top;                 /* borrow j */\n    if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        if (bn_wexpand(r, j) == NULL)\n            goto err;\n        /* 2^(top*BN_BITS2) - m */\n        r->d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < j; i++)\n            r->d[i] = (~m->d[i]) & BN_MASK2;\n        r->top = j;\n        /*\n         * Upper words will be zero if the corresponding words of 'm' were\n         * 0xfff[...], so decrement r->top accordingly.\n         */\n        bn_correct_top(r);\n    } else\n#endif\n    if (!BN_to_montgomery(r, BN_value_one(), mont, ctx))\n        goto err;\n    for (;;) {\n        if (BN_is_bit_set(p, wstart) == 0) {\n            if (!start) {\n                if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                    goto err;\n            }\n            if (wstart == 0)\n                break;\n            wstart--;\n            continue;\n        }\n        /*\n         * We now have wstart on a 'set' bit, we now need to work out how bit\n         * a window to do.  To do this we need to scan forward until the last\n         * set bit before the end of the window\n         */\n        j = wstart;\n        wvalue = 1;\n        wend = 0;\n        for (i = 1; i < window; i++) {\n            if (wstart - i < 0)\n                break;\n            if (BN_is_bit_set(p, wstart - i)) {\n                wvalue <<= (i - wend);\n                wvalue |= 1;\n                wend = i;\n            }\n        }\n\n        /* wend is the size of the current window */\n        j = wend + 1;\n        /* add the 'bytes above' */\n        if (!start)\n            for (i = 0; i < j; i++) {\n                if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                    goto err;\n            }\n\n        /* wvalue will be an odd number < 2^window */\n        if (!BN_mod_mul_montgomery(r, r, val[wvalue >> 1], mont, ctx))\n            goto err;\n\n        /* move the 'window' down further */\n        wstart -= wend + 1;\n        wvalue = 0;\n        start = 0;\n        if (wstart < 0)\n            break;\n    }\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        j = mont->N.top;        /* borrow j */\n        val[0]->d[0] = 1;       /* borrow val[0] */\n        for (i = 1; i < j; i++)\n            val[0]->d[i] = 0;\n        val[0]->top = j;\n        if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, r, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return ret;\n}", "patch_func_code": "int BN_mod_exp_mont(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,\n                    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    int i, j, bits, ret = 0, wstart, wend, window, wvalue;\n    int start = 1;\n    BIGNUM *d, *r;\n    const BIGNUM *aa;\n    /* Table of variables obtained from 'ctx' */\n    BIGNUM *val[TABLE_SIZE];\n    BN_MONT_CTX *mont = NULL;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(a, BN_FLG_CONSTTIME) != 0\n            || BN_get_flags(m, BN_FLG_CONSTTIME) != 0) {\n        return BN_mod_exp_mont_consttime(rr, a, p, m, ctx, in_mont);\n    }\n\n    bn_check_top(a);\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return 0;\n    }\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1, or x**0 mod -1 is still zero. */\n        if (BN_abs_is_word(m, 1)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    val[0] = BN_CTX_get(ctx);\n    if (val[0] == NULL)\n        goto err;\n\n    /*\n     * If this is not done, things will break in the montgomery part\n     */\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    if (a->neg || BN_ucmp(a, m) >= 0) {\n        if (!BN_nnmod(val[0], a, m, ctx))\n            goto err;\n        aa = val[0];\n    } else\n        aa = a;\n    if (BN_is_zero(aa)) {\n        BN_zero(rr);\n        ret = 1;\n        goto err;\n    }\n    if (!bn_to_mont_fixed_top(val[0], aa, mont, ctx))\n        goto err;               /* 1 */\n\n    window = BN_window_bits_for_exponent_size(bits);\n    if (window > 1) {\n        if (!bn_mul_mont_fixed_top(d, val[0], val[0], mont, ctx))\n            goto err;           /* 2 */\n        j = 1 << (window - 1);\n        for (i = 1; i < j; i++) {\n            if (((val[i] = BN_CTX_get(ctx)) == NULL) ||\n                !bn_mul_mont_fixed_top(val[i], val[i - 1], d, mont, ctx))\n                goto err;\n        }\n    }\n\n    start = 1;                  /* This is used to avoid multiplication etc\n                                 * when there is only the value '1' in the\n                                 * buffer. */\n    wvalue = 0;                 /* The 'value' of the window */\n    wstart = bits - 1;          /* The top bit of the window */\n    wend = 0;                   /* The bottom bit of the window */\n\n#if 1                           /* by Shay Gueron's suggestion */\n    j = m->top;                 /* borrow j */\n    if (m->d[j - 1] & (((BN_ULONG)1) << (BN_BITS2 - 1))) {\n        if (bn_wexpand(r, j) == NULL)\n            goto err;\n        /* 2^(top*BN_BITS2) - m */\n        r->d[0] = (0 - m->d[0]) & BN_MASK2;\n        for (i = 1; i < j; i++)\n            r->d[i] = (~m->d[i]) & BN_MASK2;\n        r->top = j;\n        r->flags |= BN_FLG_FIXED_TOP;\n    } else\n#endif\n    if (!bn_to_mont_fixed_top(r, BN_value_one(), mont, ctx))\n        goto err;\n    for (;;) {\n        if (BN_is_bit_set(p, wstart) == 0) {\n            if (!start) {\n                if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx))\n                    goto err;\n            }\n            if (wstart == 0)\n                break;\n            wstart--;\n            continue;\n        }\n        /*\n         * We now have wstart on a 'set' bit, we now need to work out how bit\n         * a window to do.  To do this we need to scan forward until the last\n         * set bit before the end of the window\n         */\n        j = wstart;\n        wvalue = 1;\n        wend = 0;\n        for (i = 1; i < window; i++) {\n            if (wstart - i < 0)\n                break;\n            if (BN_is_bit_set(p, wstart - i)) {\n                wvalue <<= (i - wend);\n                wvalue |= 1;\n                wend = i;\n            }\n        }\n\n        /* wend is the size of the current window */\n        j = wend + 1;\n        /* add the 'bytes above' */\n        if (!start)\n            for (i = 0; i < j; i++) {\n                if (!bn_mul_mont_fixed_top(r, r, r, mont, ctx))\n                    goto err;\n            }\n\n        /* wvalue will be an odd number < 2^window */\n        if (!bn_mul_mont_fixed_top(r, r, val[wvalue >> 1], mont, ctx))\n            goto err;\n\n        /* move the 'window' down further */\n        wstart -= wend + 1;\n        wvalue = 0;\n        start = 0;\n        if (wstart < 0)\n            break;\n    }\n    /*\n     * Done with zero-padded intermediate BIGNUMs. Final BN_from_montgomery\n     * removes padding [if any] and makes return value suitable for public\n     * API consumer.\n     */\n#if defined(SPARC_T4_MONT)\n    if (OPENSSL_sparcv9cap_P[0] & (SPARCV9_VIS3 | SPARCV9_PREFER_FPU)) {\n        j = mont->N.top;        /* borrow j */\n        val[0]->d[0] = 1;       /* borrow val[0] */\n        for (i = 1; i < j; i++)\n            val[0]->d[i] = 0;\n        val[0]->top = j;\n        if (!BN_mod_mul_montgomery(rr, r, val[0], mont, ctx))\n            goto err;\n    } else\n#endif\n    if (!BN_from_montgomery(rr, r, mont, ctx))\n        goto err;\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return ret;\n}", "before_change_lines": [69, 74, 79, 102, 103, 104, 105, 108, 113, 144, 149], "raw_before_change_lines": [69, 74, 79, 101, 102, 103, 104, 105, 108, 113, 144, 149], "after_change_lines": [69, 74, 79, 101, 104, 109, 140, 145, 156, 157, 158, 159], "raw_after_change_lines": [69, 74, 79, 101, 104, 109, 140, 145, 155, 156, 157, 158, 159], "bug_lines": [69, 74, 79, 101, 102, 103, 104, 105, 108, 113, 144, 149], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 357}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L2", "filepath_func": "10405----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_041a1aee0d2e8593dc3ca89319b9b470b266fe84_1.json----X509V3_add_value", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_041a1aee0d2e8593dc3ca89319b9b470b266fe84_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_041a1aee0d2e8593dc3ca89319b9b470b266fe84_1.json", "function_name": "X509V3_add_value", "vul_func_code": "int X509V3_add_value(const char *name, const char *value,\n                     STACK_OF(CONF_VALUE) **extlist)\n{\n    CONF_VALUE *vtmp = NULL;\n    char *tname = NULL, *tvalue = NULL;\n\n    if (name && (tname = BUF_strdup(name)) == NULL)\n        goto err;\n    if (value && (tvalue = BUF_strdup(value)) == NULL)\n        goto err;\n    if ((vtmp = OPENSSL_malloc(sizeof(*vtmp))) == NULL)\n        goto err;\n    if (*extlist == NULL && (*extlist = sk_CONF_VALUE_new_null()) == NULL)\n        goto err;\n    vtmp->section = NULL;\n    vtmp->name = tname;\n    vtmp->value = tvalue;\n    if (!sk_CONF_VALUE_push(*extlist, vtmp))\n        goto err;\n    return 1;\n err:\n    X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE);\n    OPENSSL_free(vtmp);\n    OPENSSL_free(tname);\n    OPENSSL_free(tvalue);\n    return 0;\n}", "patch_func_code": "int X509V3_add_value(const char *name, const char *value,\n                     STACK_OF(CONF_VALUE) **extlist)\n{\n    CONF_VALUE *vtmp = NULL;\n    char *tname = NULL, *tvalue = NULL;\n\n    if (name && (tname = OPENSSL_strdup(name)) == NULL)\n        goto err;\n    if (value && (tvalue = OPENSSL_strdup(value)) == NULL)\n        goto err;\n    if ((vtmp = OPENSSL_malloc(sizeof(*vtmp))) == NULL)\n        goto err;\n    if (*extlist == NULL && (*extlist = sk_CONF_VALUE_new_null()) == NULL)\n        goto err;\n    vtmp->section = NULL;\n    vtmp->name = tname;\n    vtmp->value = tvalue;\n    if (!sk_CONF_VALUE_push(*extlist, vtmp))\n        goto err;\n    return 1;\n err:\n    X509V3err(X509V3_F_X509V3_ADD_VALUE, ERR_R_MALLOC_FAILURE);\n    OPENSSL_free(vtmp);\n    OPENSSL_free(tname);\n    OPENSSL_free(tvalue);\n    return 0;\n}", "before_change_lines": [7, 9], "raw_before_change_lines": [7, 9], "after_change_lines": [7, 9], "raw_after_change_lines": [7, 9], "bug_lines": [7, 9], "added": [false, false], "idx": 358}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10415----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_04a31f82ffb91b9f1a88b0b360385283a2ab8a3b_1.json----PEM_dek_info", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_04a31f82ffb91b9f1a88b0b360385283a2ab8a3b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_04a31f82ffb91b9f1a88b0b360385283a2ab8a3b_1.json", "function_name": "PEM_dek_info", "vul_func_code": "void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tstrcat(buf,\"DEK-Info: \");\n\tstrcat(buf,type);\n\tstrcat(buf,\",\");\n\tj=strlen(buf);\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}", "patch_func_code": "void PEM_dek_info(char *buf, const char *type, int len, char *str)\n\t{\n\tstatic const unsigned char map[17]=\"0123456789ABCDEF\";\n\tlong i;\n\tint j;\n\n\tBUF_strlcat(buf,\"DEK-Info: \",PEM_BUFSIZE);\n\tBUF_strlcat(buf,type,PEM_BUFSIZE);\n\tBUF_strlcat(buf,\",\",PEM_BUFSIZE);\n\tj=strlen(buf);\n\tif (j + (len * 2) + 1 > PEM_BUFSIZE)\n        \treturn;\n\tfor (i=0; i<len; i++)\n\t\t{\n\t\tbuf[j+i*2]  =map[(str[i]>>4)&0x0f];\n\t\tbuf[j+i*2+1]=map[(str[i]   )&0x0f];\n\t\t}\n\tbuf[j+i*2]='\\n';\n\tbuf[j+i*2+1]='\\0';\n\t}", "before_change_lines": [7, 8, 9], "raw_before_change_lines": [7, 8, 9], "after_change_lines": [7, 8, 9, 11, 12], "raw_after_change_lines": [7, 8, 9, 11, 12], "bug_lines": [7, 8, 9], "added": [false, false, false], "idx": 359}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10436----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0594897dae408f54b75fba7d498527512172141d_1.json----ssl3_connect", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0594897dae408f54b75fba7d498527512172141d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0594897dae408f54b75fba7d498527512172141d_1.json", "function_name": "ssl3_connect", "vul_func_code": "int ssl3_connect(SSL *s)\n{\n    BUF_MEM *buf = NULL;\n    unsigned long Time = (unsigned long)time(NULL);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    int ret = -1;\n    int new_state, state, skip = 0;\n\n    RAND_add(&Time, sizeof(Time), 0);\n    ERR_clear_error();\n    clear_sys_error();\n\n    if (s->info_callback != NULL)\n        cb = s->info_callback;\n    else if (s->ctx->info_callback != NULL)\n        cb = s->ctx->info_callback;\n\n    s->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        if (!SSL_clear(s))\n            return -1;\n    }\n\n#ifndef OPENSSL_NO_HEARTBEATS\n    /*\n     * If we're awaiting a HeartbeatResponse, pretend we already got and\n     * don't await it anymore, because Heartbeats don't make sense during\n     * handshakes anyway.\n     */\n    if (s->tlsext_hb_pending) {\n        s->tlsext_hb_pending = 0;\n        s->tlsext_hb_seq++;\n    }\n#endif\n\n    for (;;) {\n        state = s->state;\n\n        switch (s->state) {\n        case SSL_ST_RENEGOTIATE:\n            s->renegotiate = 1;\n            s->state = SSL_ST_CONNECT;\n            s->ctx->stats.sess_connect_renegotiate++;\n            /* break */\n        case SSL_ST_BEFORE:\n        case SSL_ST_CONNECT:\n        case SSL_ST_BEFORE | SSL_ST_CONNECT:\n        case SSL_ST_OK | SSL_ST_CONNECT:\n\n            s->server = 0;\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR\n                    && s->version != TLS_ANY_VERSION) {\n                SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\n                s->state = SSL_ST_ERR;\n                ret = -1;\n                goto end;\n            }\n\n            if (s->version != TLS_ANY_VERSION &&\n                    !ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n                SSLerr(SSL_F_SSL3_CONNECT, SSL_R_VERSION_TOO_LOW);\n                return -1;\n            }\n\n            /* s->version=SSL3_VERSION; */\n            s->type = SSL_ST_CONNECT;\n\n            if (s->init_buf == NULL) {\n                if ((buf = BUF_MEM_new()) == NULL) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                s->init_buf = buf;\n                buf = NULL;\n            }\n\n            if (!ssl3_setup_buffers(s)) {\n                ret = -1;\n                goto end;\n            }\n\n            /* setup buffing BIO */\n            if (!ssl_init_wbio_buffer(s, 0)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            /* don't push the buffering BIO quite yet */\n\n            ssl3_init_finished_mac(s);\n\n            s->state = SSL3_ST_CW_CLNT_HELLO_A;\n            s->ctx->stats.sess_connect++;\n            s->init_num = 0;\n            /*\n             * Should have been reset by ssl3_get_finished, too.\n             */\n            s->s3->change_cipher_spec = 0;\n            break;\n\n        case SSL3_ST_CW_CLNT_HELLO_A:\n        case SSL3_ST_CW_CLNT_HELLO_B:\n\n            s->shutdown = 0;\n            ret = ssl3_client_hello(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_SRVR_HELLO_A;\n            s->init_num = 0;\n\n            /* turn on buffering for the next lot of output */\n            if (s->bbio != s->wbio)\n                s->wbio = BIO_push(s->bbio, s->wbio);\n\n            break;\n\n        case SSL3_ST_CR_SRVR_HELLO_A:\n        case SSL3_ST_CR_SRVR_HELLO_B:\n            ret = ssl3_get_server_hello(s);\n            if (ret <= 0)\n                goto end;\n\n            if (s->hit) {\n                s->state = SSL3_ST_CR_CHANGE_A;\n                if (s->tlsext_ticket_expected) {\n                    /* receive renewed session ticket */\n                    s->state = SSL3_ST_CR_SESSION_TICKET_A;\n                }\n            } else {\n                s->state = SSL3_ST_CR_CERT_A;\n            }\n            s->init_num = 0;\n            break;\n        case SSL3_ST_CR_CERT_A:\n        case SSL3_ST_CR_CERT_B:\n            /* Noop (ret = 0) for everything but EAP-FAST. */\n            ret = ssl3_check_change(s);\n            if (ret < 0)\n                goto end;\n            if (ret == 1) {\n                s->hit = 1;\n                s->state = SSL3_ST_CR_CHANGE_A;\n                s->init_num = 0;\n                break;\n            }\n\n            /* Check if it is anon DH/ECDH, SRP auth */\n            /* or PSK */\n            if (!(s->s3->tmp.new_cipher->algorithm_auth &\n                    (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {\n                ret = ssl3_get_server_certificate(s);\n                if (ret <= 0)\n                    goto end;\n\n                if (s->tlsext_status_expected)\n                    s->state = SSL3_ST_CR_CERT_STATUS_A;\n                else\n                    s->state = SSL3_ST_CR_KEY_EXCH_A;\n            } else {\n                skip = 1;\n                s->state = SSL3_ST_CR_KEY_EXCH_A;\n            }\n\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_KEY_EXCH_A:\n        case SSL3_ST_CR_KEY_EXCH_B:\n            ret = ssl3_get_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_CERT_REQ_A;\n            s->init_num = 0;\n\n            /*\n             * at this point we check that we have the required stuff from\n             * the server\n             */\n            if (!ssl3_check_cert_and_algorithm(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n            break;\n\n        case SSL3_ST_CR_CERT_REQ_A:\n        case SSL3_ST_CR_CERT_REQ_B:\n            ret = ssl3_get_certificate_request(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_SRVR_DONE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_SRVR_DONE_A:\n        case SSL3_ST_CR_SRVR_DONE_B:\n            ret = ssl3_get_server_done(s);\n            if (ret <= 0)\n                goto end;\n#ifndef OPENSSL_NO_SRP\n            if (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kSRP) {\n                if ((ret = SRP_Calc_A_param(s)) <= 0) {\n                    SSLerr(SSL_F_SSL3_CONNECT, SSL_R_SRP_A_CALC);\n                    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n            }\n#endif\n            if (s->s3->tmp.cert_req)\n                s->state = SSL3_ST_CW_CERT_A;\n            else\n                s->state = SSL3_ST_CW_KEY_EXCH_A;\n            s->init_num = 0;\n\n            break;\n\n        case SSL3_ST_CW_CERT_A:\n        case SSL3_ST_CW_CERT_B:\n        case SSL3_ST_CW_CERT_C:\n        case SSL3_ST_CW_CERT_D:\n            ret = ssl3_send_client_certificate(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_KEY_EXCH_A:\n        case SSL3_ST_CW_KEY_EXCH_B:\n            ret = ssl3_send_client_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            /*\n             * EAY EAY EAY need to check for DH fix cert sent back\n             */\n            /*\n             * For TLS, cert_req is set to 2, so a cert chain of nothing is\n             * sent, but no verify packet is sent\n             */\n            /*\n             * XXX: For now, we do not support client authentication in ECDH\n             * cipher suites with ECDH (rather than ECDSA) certificates. We\n             * need to skip the certificate verify message when client's\n             * ECDH public key is sent inside the client certificate.\n             */\n            if (s->s3->tmp.cert_req == 1) {\n                s->state = SSL3_ST_CW_CERT_VRFY_A;\n            } else {\n                s->state = SSL3_ST_CW_CHANGE_A;\n            }\n            if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n                s->state = SSL3_ST_CW_CHANGE_A;\n            }\n\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_CERT_VRFY_A:\n        case SSL3_ST_CW_CERT_VRFY_B:\n            ret = ssl3_send_client_verify(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_CHANGE_A:\n        case SSL3_ST_CW_CHANGE_B:\n            ret = ssl3_send_change_cipher_spec(s,\n                                               SSL3_ST_CW_CHANGE_A,\n                                               SSL3_ST_CW_CHANGE_B);\n            if (ret <= 0)\n                goto end;\n\n#if defined(OPENSSL_NO_NEXTPROTONEG)\n            s->state = SSL3_ST_CW_FINISHED_A;\n#else\n            if (s->s3->next_proto_neg_seen)\n                s->state = SSL3_ST_CW_NEXT_PROTO_A;\n            else\n                s->state = SSL3_ST_CW_FINISHED_A;\n#endif\n            s->init_num = 0;\n\n            s->session->cipher = s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n            s->session->compress_meth = 0;\n#else\n            if (s->s3->tmp.new_compression == NULL)\n                s->session->compress_meth = 0;\n            else\n                s->session->compress_meth = s->s3->tmp.new_compression->id;\n#endif\n            if (!s->method->ssl3_enc->setup_key_block(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            if (!s->method->ssl3_enc->change_cipher_state(s,\n                                                          SSL3_CHANGE_CIPHER_CLIENT_WRITE))\n            {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            break;\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n        case SSL3_ST_CW_NEXT_PROTO_A:\n        case SSL3_ST_CW_NEXT_PROTO_B:\n            ret = ssl3_send_next_proto(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_FINISHED_A;\n            break;\n#endif\n\n        case SSL3_ST_CW_FINISHED_A:\n        case SSL3_ST_CW_FINISHED_B:\n            ret = ssl3_send_finished(s,\n                                     SSL3_ST_CW_FINISHED_A,\n                                     SSL3_ST_CW_FINISHED_B,\n                                     s->method->\n                                     ssl3_enc->client_finished_label,\n                                     s->method->\n                                     ssl3_enc->client_finished_label_len);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_FLUSH;\n\n            if (s->hit) {\n                s->s3->tmp.next_state = SSL_ST_OK;\n            } else {\n                /*\n                 * Allow NewSessionTicket if ticket expected\n                 */\n                if (s->tlsext_ticket_expected)\n                    s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A;\n                else\n                    s->s3->tmp.next_state = SSL3_ST_CR_CHANGE_A;\n            }\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_SESSION_TICKET_A:\n        case SSL3_ST_CR_SESSION_TICKET_B:\n            ret = ssl3_get_new_session_ticket(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_CERT_STATUS_A:\n        case SSL3_ST_CR_CERT_STATUS_B:\n            ret = ssl3_get_cert_status(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_CHANGE_A:\n        case SSL3_ST_CR_CHANGE_B:\n            ret = ssl3_get_change_cipher_spec(s, SSL3_ST_CR_CHANGE_A,\n                                              SSL3_ST_CR_CHANGE_B);\n            if (ret <= 0)\n                goto end;\n\n            s->state = SSL3_ST_CR_FINISHED_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_FINISHED_A:\n        case SSL3_ST_CR_FINISHED_B:\n            ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A,\n                                    SSL3_ST_CR_FINISHED_B);\n            if (ret <= 0)\n                goto end;\n\n            if (s->hit)\n                s->state = SSL3_ST_CW_CHANGE_A;\n            else\n                s->state = SSL_ST_OK;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_FLUSH:\n            s->rwstate = SSL_WRITING;\n            if (BIO_flush(s->wbio) <= 0) {\n                ret = -1;\n                goto end;\n            }\n            s->rwstate = SSL_NOTHING;\n            s->state = s->s3->tmp.next_state;\n            break;\n\n        case SSL_ST_OK:\n            /* clean a few things up */\n            ssl3_cleanup_key_block(s);\n            BUF_MEM_free(s->init_buf);\n            s->init_buf = NULL;\n\n            /* remove the buffering */\n            ssl_free_wbio_buffer(s);\n\n            s->init_num = 0;\n            s->renegotiate = 0;\n            s->new_session = 0;\n\n            ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n            if (s->hit)\n                s->ctx->stats.sess_hit++;\n\n            ret = 1;\n            /* s->server=0; */\n            s->handshake_func = ssl3_connect;\n            s->ctx->stats.sess_connect_good++;\n\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n\n            goto end;\n            /* break; */\n\n        case SSL_ST_ERR:\n        default:\n            SSLerr(SSL_F_SSL3_CONNECT, SSL_R_UNKNOWN_STATE);\n            ret = -1;\n            goto end;\n            /* break; */\n        }\n\n        /* did we do anything */\n        if (!s->s3->tmp.reuse_message && !skip) {\n            if (s->debug) {\n                if ((ret = BIO_flush(s->wbio)) <= 0)\n                    goto end;\n            }\n\n            if ((cb != NULL) && (s->state != state)) {\n                new_state = s->state;\n                s->state = state;\n                cb(s, SSL_CB_CONNECT_LOOP, 1);\n                s->state = new_state;\n            }\n        }\n        skip = 0;\n    }\n end:\n    s->in_handshake--;\n    BUF_MEM_free(buf);\n    if (cb != NULL)\n        cb(s, SSL_CB_CONNECT_EXIT, ret);\n    return (ret);\n}", "patch_func_code": "int ssl3_connect(SSL *s)\n{\n    BUF_MEM *buf = NULL;\n    unsigned long Time = (unsigned long)time(NULL);\n    void (*cb) (const SSL *ssl, int type, int val) = NULL;\n    int ret = -1;\n    int new_state, state, skip = 0;\n\n    RAND_add(&Time, sizeof(Time), 0);\n    ERR_clear_error();\n    clear_sys_error();\n\n    if (s->info_callback != NULL)\n        cb = s->info_callback;\n    else if (s->ctx->info_callback != NULL)\n        cb = s->ctx->info_callback;\n\n    s->in_handshake++;\n    if (!SSL_in_init(s) || SSL_in_before(s)) {\n        if (!SSL_clear(s))\n            return -1;\n    }\n\n#ifndef OPENSSL_NO_HEARTBEATS\n    /*\n     * If we're awaiting a HeartbeatResponse, pretend we already got and\n     * don't await it anymore, because Heartbeats don't make sense during\n     * handshakes anyway.\n     */\n    if (s->tlsext_hb_pending) {\n        s->tlsext_hb_pending = 0;\n        s->tlsext_hb_seq++;\n    }\n#endif\n\n    for (;;) {\n        state = s->state;\n\n        switch (s->state) {\n        case SSL_ST_RENEGOTIATE:\n            s->renegotiate = 1;\n            s->state = SSL_ST_CONNECT;\n            s->ctx->stats.sess_connect_renegotiate++;\n            /* break */\n        case SSL_ST_BEFORE:\n        case SSL_ST_CONNECT:\n        case SSL_ST_BEFORE | SSL_ST_CONNECT:\n        case SSL_ST_OK | SSL_ST_CONNECT:\n\n            s->server = 0;\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_START, 1);\n\n            if ((s->version >> 8) != SSL3_VERSION_MAJOR\n                    && s->version != TLS_ANY_VERSION) {\n                SSLerr(SSL_F_SSL3_CONNECT, ERR_R_INTERNAL_ERROR);\n                s->state = SSL_ST_ERR;\n                ret = -1;\n                goto end;\n            }\n\n            if (s->version != TLS_ANY_VERSION &&\n                    !ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n                SSLerr(SSL_F_SSL3_CONNECT, SSL_R_VERSION_TOO_LOW);\n                return -1;\n            }\n\n            /* s->version=SSL3_VERSION; */\n            s->type = SSL_ST_CONNECT;\n\n            if (s->init_buf == NULL) {\n                if ((buf = BUF_MEM_new()) == NULL) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {\n                    ret = -1;\n                    s->state = SSL_ST_ERR;\n                    goto end;\n                }\n                s->init_buf = buf;\n                buf = NULL;\n            }\n\n            if (!ssl3_setup_buffers(s)) {\n                ret = -1;\n                goto end;\n            }\n\n            /* setup buffing BIO */\n            if (!ssl_init_wbio_buffer(s, 0)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            /* don't push the buffering BIO quite yet */\n\n            ssl3_init_finished_mac(s);\n\n            s->state = SSL3_ST_CW_CLNT_HELLO_A;\n            s->ctx->stats.sess_connect++;\n            s->init_num = 0;\n            /*\n             * Should have been reset by ssl3_get_finished, too.\n             */\n            s->s3->change_cipher_spec = 0;\n            break;\n\n        case SSL3_ST_CW_CLNT_HELLO_A:\n        case SSL3_ST_CW_CLNT_HELLO_B:\n\n            s->shutdown = 0;\n            ret = ssl3_client_hello(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_SRVR_HELLO_A;\n            s->init_num = 0;\n\n            /* turn on buffering for the next lot of output */\n            if (s->bbio != s->wbio)\n                s->wbio = BIO_push(s->bbio, s->wbio);\n\n            break;\n\n        case SSL3_ST_CR_SRVR_HELLO_A:\n        case SSL3_ST_CR_SRVR_HELLO_B:\n            ret = ssl3_get_server_hello(s);\n            if (ret <= 0)\n                goto end;\n\n            if (s->hit) {\n                s->state = SSL3_ST_CR_CHANGE_A;\n                if (s->tlsext_ticket_expected) {\n                    /* receive renewed session ticket */\n                    s->state = SSL3_ST_CR_SESSION_TICKET_A;\n                }\n            } else {\n                s->state = SSL3_ST_CR_CERT_A;\n            }\n            s->init_num = 0;\n            break;\n        case SSL3_ST_CR_CERT_A:\n        case SSL3_ST_CR_CERT_B:\n            /* Noop (ret = 0) for everything but EAP-FAST. */\n            ret = ssl3_check_change(s);\n            if (ret < 0)\n                goto end;\n            if (ret == 1) {\n                s->hit = 1;\n                s->state = SSL3_ST_CR_CHANGE_A;\n                s->init_num = 0;\n                break;\n            }\n\n            /* Check if it is anon DH/ECDH, SRP auth */\n            /* or PSK */\n            if (!(s->s3->tmp.new_cipher->algorithm_auth &\n                    (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {\n                ret = ssl3_get_server_certificate(s);\n                if (ret <= 0)\n                    goto end;\n\n                if (s->tlsext_status_expected)\n                    s->state = SSL3_ST_CR_CERT_STATUS_A;\n                else\n                    s->state = SSL3_ST_CR_KEY_EXCH_A;\n            } else {\n                skip = 1;\n                s->state = SSL3_ST_CR_KEY_EXCH_A;\n            }\n\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_KEY_EXCH_A:\n        case SSL3_ST_CR_KEY_EXCH_B:\n            ret = ssl3_get_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_CERT_REQ_A;\n            s->init_num = 0;\n\n            /*\n             * at this point we check that we have the required stuff from\n             * the server\n             */\n            if (!ssl3_check_cert_and_algorithm(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n            break;\n\n        case SSL3_ST_CR_CERT_REQ_A:\n        case SSL3_ST_CR_CERT_REQ_B:\n            ret = ssl3_get_certificate_request(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_SRVR_DONE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_SRVR_DONE_A:\n        case SSL3_ST_CR_SRVR_DONE_B:\n            ret = ssl3_get_server_done(s);\n            if (ret <= 0)\n                goto end;\n\n            if (s->s3->tmp.cert_req)\n                s->state = SSL3_ST_CW_CERT_A;\n            else\n                s->state = SSL3_ST_CW_KEY_EXCH_A;\n            s->init_num = 0;\n\n            break;\n\n        case SSL3_ST_CW_CERT_A:\n        case SSL3_ST_CW_CERT_B:\n        case SSL3_ST_CW_CERT_C:\n        case SSL3_ST_CW_CERT_D:\n            ret = ssl3_send_client_certificate(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_KEY_EXCH_A:\n        case SSL3_ST_CW_KEY_EXCH_B:\n            ret = ssl3_send_client_key_exchange(s);\n            if (ret <= 0)\n                goto end;\n            /*\n             * EAY EAY EAY need to check for DH fix cert sent back\n             */\n            /*\n             * For TLS, cert_req is set to 2, so a cert chain of nothing is\n             * sent, but no verify packet is sent\n             */\n            /*\n             * XXX: For now, we do not support client authentication in ECDH\n             * cipher suites with ECDH (rather than ECDSA) certificates. We\n             * need to skip the certificate verify message when client's\n             * ECDH public key is sent inside the client certificate.\n             */\n            if (s->s3->tmp.cert_req == 1) {\n                s->state = SSL3_ST_CW_CERT_VRFY_A;\n            } else {\n                s->state = SSL3_ST_CW_CHANGE_A;\n            }\n            if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n                s->state = SSL3_ST_CW_CHANGE_A;\n            }\n\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_CERT_VRFY_A:\n        case SSL3_ST_CW_CERT_VRFY_B:\n            ret = ssl3_send_client_verify(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_CHANGE_A:\n        case SSL3_ST_CW_CHANGE_B:\n            ret = ssl3_send_change_cipher_spec(s,\n                                               SSL3_ST_CW_CHANGE_A,\n                                               SSL3_ST_CW_CHANGE_B);\n            if (ret <= 0)\n                goto end;\n\n#if defined(OPENSSL_NO_NEXTPROTONEG)\n            s->state = SSL3_ST_CW_FINISHED_A;\n#else\n            if (s->s3->next_proto_neg_seen)\n                s->state = SSL3_ST_CW_NEXT_PROTO_A;\n            else\n                s->state = SSL3_ST_CW_FINISHED_A;\n#endif\n            s->init_num = 0;\n\n            s->session->cipher = s->s3->tmp.new_cipher;\n#ifdef OPENSSL_NO_COMP\n            s->session->compress_meth = 0;\n#else\n            if (s->s3->tmp.new_compression == NULL)\n                s->session->compress_meth = 0;\n            else\n                s->session->compress_meth = s->s3->tmp.new_compression->id;\n#endif\n            if (!s->method->ssl3_enc->setup_key_block(s)) {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            if (!s->method->ssl3_enc->change_cipher_state(s,\n                                                          SSL3_CHANGE_CIPHER_CLIENT_WRITE))\n            {\n                ret = -1;\n                s->state = SSL_ST_ERR;\n                goto end;\n            }\n\n            break;\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n        case SSL3_ST_CW_NEXT_PROTO_A:\n        case SSL3_ST_CW_NEXT_PROTO_B:\n            ret = ssl3_send_next_proto(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_FINISHED_A;\n            break;\n#endif\n\n        case SSL3_ST_CW_FINISHED_A:\n        case SSL3_ST_CW_FINISHED_B:\n            ret = ssl3_send_finished(s,\n                                     SSL3_ST_CW_FINISHED_A,\n                                     SSL3_ST_CW_FINISHED_B,\n                                     s->method->\n                                     ssl3_enc->client_finished_label,\n                                     s->method->\n                                     ssl3_enc->client_finished_label_len);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CW_FLUSH;\n\n            if (s->hit) {\n                s->s3->tmp.next_state = SSL_ST_OK;\n            } else {\n                /*\n                 * Allow NewSessionTicket if ticket expected\n                 */\n                if (s->tlsext_ticket_expected)\n                    s->s3->tmp.next_state = SSL3_ST_CR_SESSION_TICKET_A;\n                else\n                    s->s3->tmp.next_state = SSL3_ST_CR_CHANGE_A;\n            }\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_SESSION_TICKET_A:\n        case SSL3_ST_CR_SESSION_TICKET_B:\n            ret = ssl3_get_new_session_ticket(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_CHANGE_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_CERT_STATUS_A:\n        case SSL3_ST_CR_CERT_STATUS_B:\n            ret = ssl3_get_cert_status(s);\n            if (ret <= 0)\n                goto end;\n            s->state = SSL3_ST_CR_KEY_EXCH_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_CHANGE_A:\n        case SSL3_ST_CR_CHANGE_B:\n            ret = ssl3_get_change_cipher_spec(s, SSL3_ST_CR_CHANGE_A,\n                                              SSL3_ST_CR_CHANGE_B);\n            if (ret <= 0)\n                goto end;\n\n            s->state = SSL3_ST_CR_FINISHED_A;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CR_FINISHED_A:\n        case SSL3_ST_CR_FINISHED_B:\n            ret = ssl3_get_finished(s, SSL3_ST_CR_FINISHED_A,\n                                    SSL3_ST_CR_FINISHED_B);\n            if (ret <= 0)\n                goto end;\n\n            if (s->hit)\n                s->state = SSL3_ST_CW_CHANGE_A;\n            else\n                s->state = SSL_ST_OK;\n            s->init_num = 0;\n            break;\n\n        case SSL3_ST_CW_FLUSH:\n            s->rwstate = SSL_WRITING;\n            if (BIO_flush(s->wbio) <= 0) {\n                ret = -1;\n                goto end;\n            }\n            s->rwstate = SSL_NOTHING;\n            s->state = s->s3->tmp.next_state;\n            break;\n\n        case SSL_ST_OK:\n            /* clean a few things up */\n            ssl3_cleanup_key_block(s);\n            BUF_MEM_free(s->init_buf);\n            s->init_buf = NULL;\n\n            /* remove the buffering */\n            ssl_free_wbio_buffer(s);\n\n            s->init_num = 0;\n            s->renegotiate = 0;\n            s->new_session = 0;\n\n            ssl_update_cache(s, SSL_SESS_CACHE_CLIENT);\n            if (s->hit)\n                s->ctx->stats.sess_hit++;\n\n            ret = 1;\n            /* s->server=0; */\n            s->handshake_func = ssl3_connect;\n            s->ctx->stats.sess_connect_good++;\n\n            if (cb != NULL)\n                cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n\n            goto end;\n            /* break; */\n\n        case SSL_ST_ERR:\n        default:\n            SSLerr(SSL_F_SSL3_CONNECT, SSL_R_UNKNOWN_STATE);\n            ret = -1;\n            goto end;\n            /* break; */\n        }\n\n        /* did we do anything */\n        if (!s->s3->tmp.reuse_message && !skip) {\n            if (s->debug) {\n                if ((ret = BIO_flush(s->wbio)) <= 0)\n                    goto end;\n            }\n\n            if ((cb != NULL) && (s->state != state)) {\n                new_state = s->state;\n                s->state = state;\n                cb(s, SSL_CB_CONNECT_LOOP, 1);\n                s->state = new_state;\n            }\n        }\n        skip = 0;\n    }\n end:\n    s->in_handshake--;\n    BUF_MEM_free(buf);\n    if (cb != NULL)\n        cb(s, SSL_CB_CONNECT_EXIT, ret);\n    return (ret);\n}", "before_change_lines": [210, 211, 212, 213, 214, 215, 216, 217, 218, 219], "raw_before_change_lines": [210, 211, 212, 213, 214, 215, 216, 217, 218, 219], "after_change_lines": [], "raw_after_change_lines": [210], "bug_lines": [210, 211, 212, 213, 214, 215, 216, 217, 218, 219], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 360}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10444----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_05ef78b242f98429990cfd21e2820db71c6b964b_1.json----ssl3_get_cert_verify", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_05ef78b242f98429990cfd21e2820db71c6b964b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_05ef78b242f98429990cfd21e2820db71c6b964b_1.json", "function_name": "ssl3_get_cert_verify", "vul_func_code": "int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\t514, /* 514? */\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s->session->peer != NULL)\n\t\t{\n\t\tpeer=s->session->peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\tif ((peer != NULL) && (type | EVP_PKT_SIGN))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type & EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s->init_msg;\n\tn2s(p,i);\n\tn-=2;\n\tif (i > n)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n\tj=EVP_PKEY_size(pkey);\n\tif ((i > j) || (n > j) || (n <= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n#ifndef OPENSSL_NO_RSA \n\tif (pkey->type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}", "patch_func_code": "int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\t514, /* 514? */\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s->session->peer != NULL)\n\t\t{\n\t\tpeer=s->session->peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\tif ((peer != NULL) && (type | EVP_PKT_SIGN))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type & EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s->init_msg;\n\t/* Check for broken implementations of GOST ciphersuites */\n\t/* If key is GOST and n is exactly 64, it is bare\n\t * signature without length field */\n\tif (n==64 && (pkey->type==NID_id_GostR3410_94 ||\n\t\tpkey->type == NID_id_GostR3410_2001) )\n\t\t{\n\t\ti=64;\n\t\t} \n\telse \n\t\t{\t\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tif (i > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n    \t}\n\tj=EVP_PKEY_size(pkey);\n\tif ((i > j) || (n > j) || (n <= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n#ifndef OPENSSL_NO_RSA \n\tif (pkey->type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)\n\t\t{   unsigned char signature[64];\n\t\t\tint idx;\n\t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\t\tEVP_PKEY_verify_init(pctx);\n\t\t\tif (i!=64) {\n\t\t\t\tfprintf(stderr,\"GOST signature length is %d\",i);\n\t\t\t}\t\n\t\t\tfor (idx=0;idx<64;idx++) {\n\t\t\t\tsignature[63-idx]=p[idx];\n\t\t\t}\t\n\t\t\tj=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);\n\t\t\tEVP_PKEY_CTX_free(pctx);\n\t\t\tif (j<=0) \n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\t\n\t\t}\n\telse\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}", "before_change_lines": [67, 68, 69, 71, 72, 73, 74], "raw_before_change_lines": [67, 68, 69, 71, 72, 73, 74, 75], "after_change_lines": [69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169], "raw_after_change_lines": [67, 68, 69, 70, 71, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169], "bug_lines": [67, 68, 69, 71, 72, 73, 74, 75], "added": [false, false, false, false, false, false, false, false], "idx": 361}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10481----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_07c8308198e2f0348564310010b799e235662d7c_1.json----OBJ_obj2txt", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_07c8308198e2f0348564310010b799e235662d7c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_07c8308198e2f0348564310010b799e235662d7c_1.json", "function_name": "OBJ_obj2txt", "vul_func_code": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n    int i, n = 0, len, nid, first, use_bn;\n    BIGNUM *bl;\n    unsigned long l;\n    const unsigned char *p;\n    char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];\n\n    /* Ensure that, at every state, |buf| is NUL-terminated. */\n    if (buf && buf_len > 0)\n        buf[0] = '\\0';\n\n    if ((a == NULL) || (a->data == NULL))\n        return (0);\n\n    if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {\n        const char *s;\n        s = OBJ_nid2ln(nid);\n        if (s == NULL)\n            s = OBJ_nid2sn(nid);\n        if (s) {\n            if (buf)\n                OPENSSL_strlcpy(buf, s, buf_len);\n            n = strlen(s);\n            return n;\n        }\n    }\n\n    len = a->length;\n    p = a->data;\n\n    first = 1;\n    bl = NULL;\n\n    while (len > 0) {\n        l = 0;\n        use_bn = 0;\n        for (;;) {\n            unsigned char c = *p++;\n            len--;\n            if ((len == 0) && (c & 0x80))\n                goto err;\n            if (use_bn) {\n                if (!BN_add_word(bl, c & 0x7f))\n                    goto err;\n            } else\n                l |= c & 0x7f;\n            if (!(c & 0x80))\n                break;\n            if (!use_bn && (l > (ULONG_MAX >> 7L))) {\n                if (bl == NULL && (bl = BN_new()) == NULL)\n                    goto err;\n                if (!BN_set_word(bl, l))\n                    goto err;\n                use_bn = 1;\n            }\n            if (use_bn) {\n                if (!BN_lshift(bl, bl, 7))\n                    goto err;\n            } else\n                l <<= 7L;\n        }\n\n        if (first) {\n            first = 0;\n            if (l >= 80) {\n                i = 2;\n                if (use_bn) {\n                    if (!BN_sub_word(bl, 80))\n                        goto err;\n                } else\n                    l -= 80;\n            } else {\n                i = (int)(l / 40);\n                l -= (long)(i * 40);\n            }\n            if (buf && (buf_len > 1)) {\n                *buf++ = i + '0';\n                *buf = '\\0';\n                buf_len--;\n            }\n            n++;\n        }\n\n        if (use_bn) {\n            char *bndec;\n            bndec = BN_bn2dec(bl);\n            if (!bndec)\n                goto err;\n            i = strlen(bndec);\n            if (buf) {\n                if (buf_len > 1) {\n                    *buf++ = '.';\n                    *buf = '\\0';\n                    buf_len--;\n                }\n                OPENSSL_strlcpy(buf, bndec, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n++;\n            n += i;\n            OPENSSL_free(bndec);\n        } else {\n            BIO_snprintf(tbuf, sizeof tbuf, \".%lu\", l);\n            i = strlen(tbuf);\n            if (buf && (buf_len > 0)) {\n                OPENSSL_strlcpy(buf, tbuf, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n += i;\n            l = 0;\n        }\n    }\n\n    BN_free(bl);\n    return n;\n\n err:\n    BN_free(bl);\n    return -1;\n}", "patch_func_code": "int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name)\n{\n    int i, n = 0, len, nid, first, use_bn;\n    BIGNUM *bl;\n    unsigned long l;\n    const unsigned char *p;\n    char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];\n\n    /* Ensure that, at every state, |buf| is NUL-terminated. */\n    if (buf && buf_len > 0)\n        buf[0] = '\\0';\n\n    if ((a == NULL) || (a->data == NULL))\n        return (0);\n\n    if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {\n        const char *s;\n        s = OBJ_nid2ln(nid);\n        if (s == NULL)\n            s = OBJ_nid2sn(nid);\n        if (s) {\n            if (buf)\n                OPENSSL_strlcpy(buf, s, buf_len);\n            n = strlen(s);\n            return n;\n        }\n    }\n\n    len = a->length;\n    p = a->data;\n\n    first = 1;\n    bl = NULL;\n\n    while (len > 0) {\n        l = 0;\n        use_bn = 0;\n        for (;;) {\n            unsigned char c = *p++;\n            len--;\n            if ((len == 0) && (c & 0x80))\n                goto err;\n            if (use_bn) {\n                if (!BN_add_word(bl, c & 0x7f))\n                    goto err;\n            } else\n                l |= c & 0x7f;\n            if (!(c & 0x80))\n                break;\n            if (!use_bn && (l > (ULONG_MAX >> 7L))) {\n                if (bl == NULL && (bl = BN_new()) == NULL)\n                    goto err;\n                if (!BN_set_word(bl, l))\n                    goto err;\n                use_bn = 1;\n            }\n            if (use_bn) {\n                if (!BN_lshift(bl, bl, 7))\n                    goto err;\n            } else\n                l <<= 7L;\n        }\n\n        if (first) {\n            first = 0;\n            if (l >= 80) {\n                i = 2;\n                if (use_bn) {\n                    if (!BN_sub_word(bl, 80))\n                        goto err;\n                } else\n                    l -= 80;\n            } else {\n                i = (int)(l / 40);\n                l -= (long)(i * 40);\n            }\n            if (buf && (buf_len > 1)) {\n                *buf++ = i + '0';\n                *buf = '\\0';\n                buf_len--;\n            }\n            n++;\n        }\n\n        if (use_bn) {\n            char *bndec;\n            bndec = BN_bn2dec(bl);\n            if (!bndec)\n                goto err;\n            i = strlen(bndec);\n            if (buf) {\n                if (buf_len > 1) {\n                    *buf++ = '.';\n                    *buf = '\\0';\n                    buf_len--;\n                }\n                OPENSSL_strlcpy(buf, bndec, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n++;\n            n += i;\n            OPENSSL_free(bndec);\n        } else {\n            sprintf(tbuf, \".%lu\", l);\n            i = strlen(tbuf);\n            if (buf && (buf_len > 0)) {\n                OPENSSL_strlcpy(buf, tbuf, buf_len);\n                if (i > buf_len) {\n                    buf += buf_len;\n                    buf_len = 0;\n                } else {\n                    buf += i;\n                    buf_len -= i;\n                }\n            }\n            n += i;\n            l = 0;\n        }\n    }\n\n    BN_free(bl);\n    return n;\n\n err:\n    BN_free(bl);\n    return -1;\n}", "before_change_lines": [110], "raw_before_change_lines": [110], "after_change_lines": [110], "raw_after_change_lines": [110], "bug_lines": [110], "added": [false], "idx": 362}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "10514----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_08e790e7428bb0bf6a59bf40c78cbfa0b7236dbb_1.json----t_fromb64", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_08e790e7428bb0bf6a59bf40c78cbfa0b7236dbb_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_08e790e7428bb0bf6a59bf40c78cbfa0b7236dbb_1.json", "function_name": "t_fromb64", "vul_func_code": "static int t_fromb64(unsigned char *a, size_t alen, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    if (alen > INT_MAX || size > (int)alen)\n        return -1;\n\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (a[j] == 0 && j <= size)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}", "patch_func_code": "static int t_fromb64(unsigned char *a, size_t alen, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    if (alen == 0 || alen > INT_MAX)\n        return -1;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    if (size < 0 || size >= (int)alen)\n        return -1;\n\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (j <= size && a[j] == 0)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}", "before_change_lines": [10, 48], "raw_before_change_lines": [10, 48], "after_change_lines": [7, 8, 13, 51], "raw_after_change_lines": [7, 8, 9, 13, 51], "bug_lines": [10, 48], "added": [false, false], "idx": 363}
{"project": "openssl", "vul_type": "NULL_DEREFERENCE", "filepath_func": "10546----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_09ff7e62219ee73350d6581a8843ff1c3b777288_1.json----nseq_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_09ff7e62219ee73350d6581a8843ff1c3b777288_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_09ff7e62219ee73350d6581a8843ff1c3b777288_1.json", "function_name": "nseq_main", "vul_func_code": "int nseq_main(int argc, char **argv)\n{\n    BIO *in = NULL, *out = NULL;\n    X509 *x509 = NULL;\n    NETSCAPE_CERT_SEQUENCE *seq = NULL;\n    OPTION_CHOICE o;\n    int toseq = 0, ret = 1, i;\n    char *infile = NULL, *outfile = NULL, *prog;\n\n    prog = opt_init(argc, argv, nseq_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            ret = 0;\n            opt_help(nseq_options);\n            goto end;\n        case OPT_TOSEQ:\n            toseq = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    in = bio_open_default(infile, \"r\");\n    if (in == NULL)\n        goto end;\n    out = bio_open_default(outfile, \"w\");\n    if (out == NULL)\n        goto end;\n\n    if (toseq) {\n        seq = NETSCAPE_CERT_SEQUENCE_new();\n        seq->certs = sk_X509_new_null();\n        if (!seq->certs)\n            goto end;\n        while ((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL)))\n            sk_X509_push(seq->certs, x509);\n\n        if (!sk_X509_num(seq->certs)) {\n            BIO_printf(bio_err, \"%s: Error reading certs file %s\\n\",\n                       prog, infile);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\n        ret = 0;\n        goto end;\n    }\n\n    seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL);\n    if (seq == NULL) {\n        BIO_printf(bio_err, \"%s: Error reading sequence file %s\\n\",\n                   prog, infile);\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    for (i = 0; i < sk_X509_num(seq->certs); i++) {\n        x509 = sk_X509_value(seq->certs, i);\n        dump_cert_text(out, x509);\n        PEM_write_bio_X509(out, x509);\n    }\n    ret = 0;\n end:\n    BIO_free(in);\n    BIO_free_all(out);\n    NETSCAPE_CERT_SEQUENCE_free(seq);\n\n    return (ret);\n}", "patch_func_code": "int nseq_main(int argc, char **argv)\n{\n    BIO *in = NULL, *out = NULL;\n    X509 *x509 = NULL;\n    NETSCAPE_CERT_SEQUENCE *seq = NULL;\n    OPTION_CHOICE o;\n    int toseq = 0, ret = 1, i;\n    char *infile = NULL, *outfile = NULL, *prog;\n\n    prog = opt_init(argc, argv, nseq_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            ret = 0;\n            opt_help(nseq_options);\n            goto end;\n        case OPT_TOSEQ:\n            toseq = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    in = bio_open_default(infile, 'r', FORMAT_PEM);\n    if (in == NULL)\n        goto end;\n    out = bio_open_default(outfile, 'w', FORMAT_PEM);\n    if (out == NULL)\n        goto end;\n\n    if (toseq) {\n        seq = NETSCAPE_CERT_SEQUENCE_new();\n        seq->certs = sk_X509_new_null();\n        if (!seq->certs)\n            goto end;\n        while ((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL)))\n            sk_X509_push(seq->certs, x509);\n\n        if (!sk_X509_num(seq->certs)) {\n            BIO_printf(bio_err, \"%s: Error reading certs file %s\\n\",\n                       prog, infile);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\n        ret = 0;\n        goto end;\n    }\n\n    seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL);\n    if (seq == NULL) {\n        BIO_printf(bio_err, \"%s: Error reading sequence file %s\\n\",\n                   prog, infile);\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    for (i = 0; i < sk_X509_num(seq->certs); i++) {\n        x509 = sk_X509_value(seq->certs, i);\n        dump_cert_text(out, x509);\n        PEM_write_bio_X509(out, x509);\n    }\n    ret = 0;\n end:\n    BIO_free(in);\n    BIO_free_all(out);\n    NETSCAPE_CERT_SEQUENCE_free(seq);\n\n    return (ret);\n}", "before_change_lines": [38, 41], "raw_before_change_lines": [38, 41], "after_change_lines": [38, 41], "raw_after_change_lines": [38, 41], "bug_lines": [38, 41], "added": [false, false], "idx": 364}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10565----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0a81f8588f8e9a9d96402855b39e89f9797a34fe_1.json----BN_sub_word", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0a81f8588f8e9a9d96402855b39e89f9797a34fe_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0a81f8588f8e9a9d96402855b39e89f9797a34fe_1.json", "function_name": "BN_sub_word", "vul_func_code": "int BN_sub_word(BIGNUM *a, BN_ULONG w)\n\t{\n\tint i;\n\n\tw &= BN_MASK2;\n\n\tif (!w)\n\t\treturn 1;\n\n\tif (BN_is_zero(a) || a->neg)\n\t\t{\n\t\ta->neg=0;\n\t\ti=BN_add_word(a,w);\n\t\ta->neg=1;\n\t\treturn(i);\n\t\t}\n\n\tif ((a->top == 1) && (a->d[0] < w))\n\t\t{\n\t\ta->d[0]=w-a->d[0];\n\t\ta->neg=1;\n\t\treturn(1);\n\t\t}\n\ti=0;\n\tfor (;;)\n\t\t{\n\t\tif (a->d[i] >= w)\n\t\t\t{\n\t\t\ta->d[i]-=w;\n\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ta->d[i]=(a->d[i]-w)&BN_MASK2;\n\t\t\ti++;\n\t\t\tw=1;\n\t\t\t}\n\t\t}\n\tif ((a->d[i] == 0) && (i == (a->top-1)))\n\t\ta->top--;\n\tbn_check_top(a);\n\treturn(1);\n\t}", "patch_func_code": "int BN_sub_word(BIGNUM *a, BN_ULONG w)\n\t{\n\tint i;\n\n\tbn_check_top(a);\n\tw &= BN_MASK2;\n\n\t/* degenerate case: w is zero */\n\tif (!w) return 1;\n\t/* degenerate case: a is zero */\n\tif(BN_is_zero(a)) return BN_set_word(a,w);\n\t/* handle 'a' when negative */\n\tif (a->neg)\n\t\t{\n\t\ta->neg=0;\n\t\ti=BN_add_word(a,w);\n\t\ta->neg=1;\n\t\treturn(i);\n\t\t}\n\n\tif ((a->top == 1) && (a->d[0] < w))\n\t\t{\n\t\ta->d[0]=w-a->d[0];\n\t\ta->neg=1;\n\t\treturn(1);\n\t\t}\n\ti=0;\n\tfor (;;)\n\t\t{\n\t\tif (a->d[i] >= w)\n\t\t\t{\n\t\t\ta->d[i]-=w;\n\t\t\tbreak;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ta->d[i]=(a->d[i]-w)&BN_MASK2;\n\t\t\ti++;\n\t\t\tw=1;\n\t\t\t}\n\t\t}\n\tif ((a->d[i] == 0) && (i == (a->top-1)))\n\t\ta->top--;\n\tbn_check_top(a);\n\treturn(1);\n\t}", "before_change_lines": [7, 8, 10], "raw_before_change_lines": [7, 8, 9, 10], "after_change_lines": [5, 9, 11, 13], "raw_after_change_lines": [5, 8, 9, 10, 11, 12, 13], "bug_lines": [7, 8, 9, 10], "added": [false, false, false, false], "idx": 365}
{"project": "openssl", "vul_type": "NULL_DEREFERENCE", "filepath_func": "10574----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0aba974665c8408e990a9fecb3347b3cc9fb563d_1.json----pkcs7_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0aba974665c8408e990a9fecb3347b3cc9fb563d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0aba974665c8408e990a9fecb3347b3cc9fb563d_1.json", "function_name": "pkcs7_main", "vul_func_code": "int pkcs7_main(int argc, char **argv)\n{\n    PKCS7 *p7 = NULL;\n    BIO *in = NULL, *out = NULL;\n    int informat = FORMAT_PEM, outformat = FORMAT_PEM;\n    char *infile = NULL, *outfile = NULL, *prog;\n    int i, print_certs = 0, text = 0, noout = 0, p7_print = 0, ret = 1;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, pkcs7_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(pkcs7_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_PRINT:\n            p7_print = 1;\n            break;\n        case OPT_PRINT_CERTS:\n            print_certs = 1;\n            break;\n        case OPT_ENGINE:\n            (void)setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    in = bio_open_default(infile, RB(informat));\n    if (in == NULL)\n        goto end;\n\n    if (informat == FORMAT_ASN1)\n        p7 = d2i_PKCS7_bio(in, NULL);\n    else\n        p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);\n    if (p7 == NULL) {\n        BIO_printf(bio_err, \"unable to load PKCS7 object\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    out = bio_open_default(outfile, WB(outformat));\n    if (out == NULL)\n        goto end;\n\n    if (p7_print)\n        PKCS7_print_ctx(out, p7, 0, NULL);\n\n    if (print_certs) {\n        STACK_OF(X509) *certs = NULL;\n        STACK_OF(X509_CRL) *crls = NULL;\n\n        i = OBJ_obj2nid(p7->type);\n        switch (i) {\n        case NID_pkcs7_signed:\n            certs = p7->d.sign->cert;\n            crls = p7->d.sign->crl;\n            break;\n        case NID_pkcs7_signedAndEnveloped:\n            certs = p7->d.signed_and_enveloped->cert;\n            crls = p7->d.signed_and_enveloped->crl;\n            break;\n        default:\n            break;\n        }\n\n        if (certs != NULL) {\n            X509 *x;\n\n            for (i = 0; i < sk_X509_num(certs); i++) {\n                x = sk_X509_value(certs, i);\n                if (text)\n                    X509_print(out, x);\n                else\n                    dump_cert_text(out, x);\n\n                if (!noout)\n                    PEM_write_bio_X509(out, x);\n                BIO_puts(out, \"\\n\");\n            }\n        }\n        if (crls != NULL) {\n            X509_CRL *crl;\n\n            for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n                crl = sk_X509_CRL_value(crls, i);\n\n                X509_CRL_print(out, crl);\n\n                if (!noout)\n                    PEM_write_bio_X509_CRL(out, crl);\n                BIO_puts(out, \"\\n\");\n            }\n        }\n\n        ret = 0;\n        goto end;\n    }\n\n    if (!noout) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_PKCS7_bio(out, p7);\n        else\n            i = PEM_write_bio_PKCS7(out, p7);\n\n        if (!i) {\n            BIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    PKCS7_free(p7);\n    BIO_free(in);\n    BIO_free_all(out);\n    return (ret);\n}", "patch_func_code": "int pkcs7_main(int argc, char **argv)\n{\n    PKCS7 *p7 = NULL;\n    BIO *in = NULL, *out = NULL;\n    int informat = FORMAT_PEM, outformat = FORMAT_PEM;\n    char *infile = NULL, *outfile = NULL, *prog;\n    int i, print_certs = 0, text = 0, noout = 0, p7_print = 0, ret = 1;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, pkcs7_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(pkcs7_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_PRINT:\n            p7_print = 1;\n            break;\n        case OPT_PRINT_CERTS:\n            print_certs = 1;\n            break;\n        case OPT_ENGINE:\n            (void)setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    in = bio_open_default(infile, 'r', informat);\n    if (in == NULL)\n        goto end;\n\n    if (informat == FORMAT_ASN1)\n        p7 = d2i_PKCS7_bio(in, NULL);\n    else\n        p7 = PEM_read_bio_PKCS7(in, NULL, NULL, NULL);\n    if (p7 == NULL) {\n        BIO_printf(bio_err, \"unable to load PKCS7 object\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    out = bio_open_default(outfile, 'w', outformat);\n    if (out == NULL)\n        goto end;\n\n    if (p7_print)\n        PKCS7_print_ctx(out, p7, 0, NULL);\n\n    if (print_certs) {\n        STACK_OF(X509) *certs = NULL;\n        STACK_OF(X509_CRL) *crls = NULL;\n\n        i = OBJ_obj2nid(p7->type);\n        switch (i) {\n        case NID_pkcs7_signed:\n            certs = p7->d.sign->cert;\n            crls = p7->d.sign->crl;\n            break;\n        case NID_pkcs7_signedAndEnveloped:\n            certs = p7->d.signed_and_enveloped->cert;\n            crls = p7->d.signed_and_enveloped->crl;\n            break;\n        default:\n            break;\n        }\n\n        if (certs != NULL) {\n            X509 *x;\n\n            for (i = 0; i < sk_X509_num(certs); i++) {\n                x = sk_X509_value(certs, i);\n                if (text)\n                    X509_print(out, x);\n                else\n                    dump_cert_text(out, x);\n\n                if (!noout)\n                    PEM_write_bio_X509(out, x);\n                BIO_puts(out, \"\\n\");\n            }\n        }\n        if (crls != NULL) {\n            X509_CRL *crl;\n\n            for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n                crl = sk_X509_CRL_value(crls, i);\n\n                X509_CRL_print(out, crl);\n\n                if (!noout)\n                    PEM_write_bio_X509_CRL(out, crl);\n                BIO_puts(out, \"\\n\");\n            }\n        }\n\n        ret = 0;\n        goto end;\n    }\n\n    if (!noout) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_PKCS7_bio(out, p7);\n        else\n            i = PEM_write_bio_PKCS7(out, p7);\n\n        if (!i) {\n            BIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    PKCS7_free(p7);\n    BIO_free(in);\n    BIO_free_all(out);\n    return (ret);\n}", "before_change_lines": [59, 73], "raw_before_change_lines": [59, 73], "after_change_lines": [59, 73], "raw_after_change_lines": [59, 73], "bug_lines": [59, 73], "added": [false, false], "idx": 366}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "10596----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0bbc4f3f7d03e8b8f0463e1e5c77a65c6282fa7d_1.json----tls13_hkdf_expand", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0bbc4f3f7d03e8b8f0463e1e5c77a65c6282fa7d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0bbc4f3f7d03e8b8f0463e1e5c77a65c6282fa7d_1.json", "function_name": "tls13_hkdf_expand", "vul_func_code": "int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,\n                             const unsigned char *label, size_t labellen,\n                             const unsigned char *hash,\n                             unsigned char *out, size_t outlen)\n{\n    const unsigned char label_prefix[] = \"tls13 \";\n    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, NULL);\n    int ret;\n    size_t hkdflabellen;\n    size_t hashlen;\n    /*\n     * 2 bytes for length of whole HkdfLabel + 1 byte for length of combined\n     * prefix and label + bytes for the label itself + bytes for the hash\n     */\n    unsigned char hkdflabel[sizeof(uint16_t) + sizeof(uint8_t) +\n                            + sizeof(label_prefix) + TLS13_MAX_LABEL_LEN\n                            + EVP_MAX_MD_SIZE];\n    WPACKET pkt;\n\n    if (pctx == NULL)\n        return 0;\n\n    hashlen = EVP_MD_size(md);\n\n    if (!WPACKET_init_static_len(&pkt, hkdflabel, sizeof(hkdflabel), 0)\n            || !WPACKET_put_bytes_u16(&pkt, outlen)\n            || !WPACKET_start_sub_packet_u8(&pkt)\n            || !WPACKET_memcpy(&pkt, label_prefix, sizeof(label_prefix) - 1)\n            || !WPACKET_memcpy(&pkt, label, labellen)\n            || !WPACKET_close(&pkt)\n            || !WPACKET_sub_memcpy_u8(&pkt, hash, (hash == NULL) ? 0 : hashlen)\n            || !WPACKET_get_total_written(&pkt, &hkdflabellen)\n            || !WPACKET_finish(&pkt)) {\n        EVP_PKEY_CTX_free(pctx);\n        WPACKET_cleanup(&pkt);\n        return 0;\n    }\n\n    ret = EVP_PKEY_derive_init(pctx) <= 0\n            || EVP_PKEY_CTX_hkdf_mode(pctx, EVP_PKEY_HKDEF_MODE_EXPAND_ONLY)\n               <= 0\n            || EVP_PKEY_CTX_set_hkdf_md(pctx, md) <= 0\n            || EVP_PKEY_CTX_set1_hkdf_key(pctx, secret, hashlen) <= 0\n            || EVP_PKEY_CTX_add1_hkdf_info(pctx, hkdflabel, hkdflabellen) <= 0\n            || EVP_PKEY_derive(pctx, out, &outlen) <= 0;\n\n    EVP_PKEY_CTX_free(pctx);\n\n    return ret == 0;\n}", "patch_func_code": "int tls13_hkdf_expand(SSL *s, const EVP_MD *md, const unsigned char *secret,\n                             const unsigned char *label, size_t labellen,\n                             const unsigned char *data, size_t datalen,\n                             unsigned char *out, size_t outlen)\n{\n    const unsigned char label_prefix[] = \"tls13 \";\n    EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, NULL);\n    int ret;\n    size_t hkdflabellen;\n    size_t hashlen;\n    /*\n     * 2 bytes for length of whole HkdfLabel + 1 byte for length of combined\n     * prefix and label + bytes for the label itself + bytes for the hash\n     */\n    unsigned char hkdflabel[sizeof(uint16_t) + sizeof(uint8_t) +\n                            + sizeof(label_prefix) + TLS13_MAX_LABEL_LEN\n                            + EVP_MAX_MD_SIZE];\n    WPACKET pkt;\n\n    if (pctx == NULL)\n        return 0;\n\n    hashlen = EVP_MD_size(md);\n\n    if (!WPACKET_init_static_len(&pkt, hkdflabel, sizeof(hkdflabel), 0)\n            || !WPACKET_put_bytes_u16(&pkt, outlen)\n            || !WPACKET_start_sub_packet_u8(&pkt)\n            || !WPACKET_memcpy(&pkt, label_prefix, sizeof(label_prefix) - 1)\n            || !WPACKET_memcpy(&pkt, label, labellen)\n            || !WPACKET_close(&pkt)\n            || !WPACKET_sub_memcpy_u8(&pkt, data, (data == NULL) ? 0 : datalen)\n            || !WPACKET_get_total_written(&pkt, &hkdflabellen)\n            || !WPACKET_finish(&pkt)) {\n        EVP_PKEY_CTX_free(pctx);\n        WPACKET_cleanup(&pkt);\n        return 0;\n    }\n\n    ret = EVP_PKEY_derive_init(pctx) <= 0\n            || EVP_PKEY_CTX_hkdf_mode(pctx, EVP_PKEY_HKDEF_MODE_EXPAND_ONLY)\n               <= 0\n            || EVP_PKEY_CTX_set_hkdf_md(pctx, md) <= 0\n            || EVP_PKEY_CTX_set1_hkdf_key(pctx, secret, hashlen) <= 0\n            || EVP_PKEY_CTX_add1_hkdf_info(pctx, hkdflabel, hkdflabellen) <= 0\n            || EVP_PKEY_derive(pctx, out, &outlen) <= 0;\n\n    EVP_PKEY_CTX_free(pctx);\n\n    return ret == 0;\n}", "before_change_lines": [3, 31], "raw_before_change_lines": [3, 31], "after_change_lines": [3, 31], "raw_after_change_lines": [3, 31], "bug_lines": [3, 31], "added": [false, false], "idx": 367}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10656----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0de840379dbfb8592694c462f4f1aad9dc3e221f_1.json----ec_scalar_mul_ladder", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0de840379dbfb8592694c462f4f1aad9dc3e221f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0de840379dbfb8592694c462f4f1aad9dc3e221f_1.json", "function_name": "ec_scalar_mul_ladder", "vul_func_code": "static\nint ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,\n                         const BIGNUM *scalar, const EC_POINT *point,\n                         BN_CTX *ctx)\n{\n    int i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\n    EC_POINT *p = NULL;\n    EC_POINT *s = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *lambda = NULL;\n    BIGNUM *cardinality = NULL;\n    BN_CTX *new_ctx = NULL;\n    int ret = 0;\n\n    /* early exit if the input point is the point at infinity */\n    if (point != NULL && EC_POINT_is_at_infinity(group, point))\n        return EC_POINT_set_to_infinity(group, r);\n\n    if (ctx == NULL && (ctx = new_ctx = BN_CTX_secure_new()) == NULL)\n        return 0;\n\n    BN_CTX_start(ctx);\n\n    if (((p = EC_POINT_new(group)) == NULL)\n        || ((s = EC_POINT_new(group)) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (point == NULL) {\n        if (!EC_POINT_copy(p, group->generator)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n        }\n    } else {\n        if (!EC_POINT_copy(p, point)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n        }\n    }\n\n    EC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME);\n    EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\n    EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\n\n    cardinality = BN_CTX_get(ctx);\n    lambda = BN_CTX_get(ctx);\n    k = BN_CTX_get(ctx);\n    if (k == NULL) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!BN_mul(cardinality, group->order, group->cofactor, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /*\n     * Group cardinalities are often on a word boundary.\n     * So when we pad the scalar, some timing diff might\n     * pop if it needs to be expanded due to carries.\n     * So expand ahead of time.\n     */\n    cardinality_bits = BN_num_bits(cardinality);\n    group_top = bn_get_top(cardinality);\n    if ((bn_wexpand(k, group_top + 1) == NULL)\n        || (bn_wexpand(lambda, group_top + 1) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    if (!BN_copy(k, scalar)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {\n        /*-\n         * this is an unusual input, and we don't guarantee\n         * constant-timeness\n         */\n        if (!BN_nnmod(k, k, cardinality, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n            goto err;\n        }\n    }\n\n    if (!BN_add(lambda, k, cardinality)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n    BN_set_flags(lambda, BN_FLG_CONSTTIME);\n    if (!BN_add(k, lambda, cardinality)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n    /*\n     * lambda := scalar + cardinality\n     * k := scalar + 2*cardinality\n     */\n    kbit = BN_is_bit_set(lambda, cardinality_bits);\n    BN_consttime_swap(kbit, k, lambda, group_top + 1);\n\n    group_top = bn_get_top(group->field);\n    if ((bn_wexpand(s->X, group_top) == NULL)\n        || (bn_wexpand(s->Y, group_top) == NULL)\n        || (bn_wexpand(s->Z, group_top) == NULL)\n        || (bn_wexpand(r->X, group_top) == NULL)\n        || (bn_wexpand(r->Y, group_top) == NULL)\n        || (bn_wexpand(r->Z, group_top) == NULL)\n        || (bn_wexpand(p->X, group_top) == NULL)\n        || (bn_wexpand(p->Y, group_top) == NULL)\n        || (bn_wexpand(p->Z, group_top) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /*-\n     * Apply coordinate blinding for EC_POINT.\n     *\n     * The underlying EC_METHOD can optionally implement this function:\n     * ec_point_blind_coordinates() returns 0 in case of errors or 1 on\n     * success or if coordinate blinding is not implemented for this\n     * group.\n     */\n    if (!ec_point_blind_coordinates(group, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_POINT_COORDINATES_BLIND_FAILURE);\n        goto err;\n    }\n\n    /* Initialize the Montgomery ladder */\n    if (!ec_point_ladder_pre(group, r, s, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE);\n        goto err;\n    }\n\n    /* top bit is a 1, in a fixed pos */\n    pbit = 1;\n\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\n        BN_consttime_swap(c, (a)->X, (b)->X, w);   \\\n        BN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\n        BN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\n        t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n        (a)->Z_is_one ^= (t);                      \\\n        (b)->Z_is_one ^= (t);                      \\\n} while(0)\n\n    /*-\n     * The ladder step, with branches, is\n     *\n     * k[i] == 0: S = add(R, S), R = dbl(R)\n     * k[i] == 1: R = add(S, R), S = dbl(S)\n     *\n     * Swapping R, S conditionally on k[i] leaves you with state\n     *\n     * k[i] == 0: T, U = R, S\n     * k[i] == 1: T, U = S, R\n     *\n     * Then perform the ECC ops.\n     *\n     * U = add(T, U)\n     * T = dbl(T)\n     *\n     * Which leaves you with state\n     *\n     * k[i] == 0: U = add(R, S), T = dbl(R)\n     * k[i] == 1: U = add(S, R), T = dbl(S)\n     *\n     * Swapping T, U conditionally on k[i] leaves you with state\n     *\n     * k[i] == 0: R, S = T, U\n     * k[i] == 1: R, S = U, T\n     *\n     * Which leaves you with state\n     *\n     * k[i] == 0: S = add(R, S), R = dbl(R)\n     * k[i] == 1: R = add(S, R), S = dbl(S)\n     *\n     * So we get the same logic, but instead of a branch it's a\n     * conditional swap, followed by ECC ops, then another conditional swap.\n     *\n     * Optimization: The end of iteration i and start of i-1 looks like\n     *\n     * ...\n     * CSWAP(k[i], R, S)\n     * ECC\n     * CSWAP(k[i], R, S)\n     * (next iteration)\n     * CSWAP(k[i-1], R, S)\n     * ECC\n     * CSWAP(k[i-1], R, S)\n     * ...\n     *\n     * So instead of two contiguous swaps, you can merge the condition\n     * bits and do a single swap.\n     *\n     * k[i]   k[i-1]    Outcome\n     * 0      0         No Swap\n     * 0      1         Swap\n     * 1      0         Swap\n     * 1      1         No Swap\n     *\n     * This is XOR. pbit tracks the previous bit of k.\n     */\n\n    for (i = cardinality_bits - 1; i >= 0; i--) {\n        kbit = BN_is_bit_set(k, i) ^ pbit;\n        EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\n\n        /* Perform a single step of the Montgomery ladder */\n        if (!ec_point_ladder_step(group, r, s, p, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE);\n            goto err;\n        }\n        /*\n         * pbit logic merges this cswap with that of the\n         * next iteration\n         */\n        pbit ^= kbit;\n    }\n    /* one final cswap to move the right value into r */\n    EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\n\n    /* Finalize ladder (and recover full point coordinates) */\n    if (!ec_point_ladder_post(group, r, s, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE);\n        goto err;\n    }\n\n    ret = 1;\n\n err:\n    EC_POINT_free(p);\n    EC_POINT_free(s);\n    BN_CTX_end(ctx);\n    BN_CTX_free(new_ctx);\n\n    return ret;\n}", "patch_func_code": "int ec_scalar_mul_ladder(const EC_GROUP *group, EC_POINT *r,\n                         const BIGNUM *scalar, const EC_POINT *point,\n                         BN_CTX *ctx)\n{\n    int i, cardinality_bits, group_top, kbit, pbit, Z_is_one;\n    EC_POINT *p = NULL;\n    EC_POINT *s = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *lambda = NULL;\n    BIGNUM *cardinality = NULL;\n    int ret = 0;\n\n    /* early exit if the input point is the point at infinity */\n    if (point != NULL && EC_POINT_is_at_infinity(group, point))\n        return EC_POINT_set_to_infinity(group, r);\n\n    if (BN_is_zero(group->order)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_ORDER);\n        return 0;\n    }\n    if (BN_is_zero(group->cofactor)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_UNKNOWN_COFACTOR);\n        return 0;\n    }\n\n    BN_CTX_start(ctx);\n\n    if (((p = EC_POINT_new(group)) == NULL)\n        || ((s = EC_POINT_new(group)) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (point == NULL) {\n        if (!EC_POINT_copy(p, group->generator)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n        }\n    } else {\n        if (!EC_POINT_copy(p, point)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_EC_LIB);\n            goto err;\n        }\n    }\n\n    EC_POINT_BN_set_flags(p, BN_FLG_CONSTTIME);\n    EC_POINT_BN_set_flags(r, BN_FLG_CONSTTIME);\n    EC_POINT_BN_set_flags(s, BN_FLG_CONSTTIME);\n\n    cardinality = BN_CTX_get(ctx);\n    lambda = BN_CTX_get(ctx);\n    k = BN_CTX_get(ctx);\n    if (k == NULL) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (!BN_mul(cardinality, group->order, group->cofactor, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /*\n     * Group cardinalities are often on a word boundary.\n     * So when we pad the scalar, some timing diff might\n     * pop if it needs to be expanded due to carries.\n     * So expand ahead of time.\n     */\n    cardinality_bits = BN_num_bits(cardinality);\n    group_top = bn_get_top(cardinality);\n    if ((bn_wexpand(k, group_top + 1) == NULL)\n        || (bn_wexpand(lambda, group_top + 1) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    if (!BN_copy(k, scalar)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if ((BN_num_bits(k) > cardinality_bits) || (BN_is_negative(k))) {\n        /*-\n         * this is an unusual input, and we don't guarantee\n         * constant-timeness\n         */\n        if (!BN_nnmod(k, k, cardinality, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n            goto err;\n        }\n    }\n\n    if (!BN_add(lambda, k, cardinality)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n    BN_set_flags(lambda, BN_FLG_CONSTTIME);\n    if (!BN_add(k, lambda, cardinality)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n    /*\n     * lambda := scalar + cardinality\n     * k := scalar + 2*cardinality\n     */\n    kbit = BN_is_bit_set(lambda, cardinality_bits);\n    BN_consttime_swap(kbit, k, lambda, group_top + 1);\n\n    group_top = bn_get_top(group->field);\n    if ((bn_wexpand(s->X, group_top) == NULL)\n        || (bn_wexpand(s->Y, group_top) == NULL)\n        || (bn_wexpand(s->Z, group_top) == NULL)\n        || (bn_wexpand(r->X, group_top) == NULL)\n        || (bn_wexpand(r->Y, group_top) == NULL)\n        || (bn_wexpand(r->Z, group_top) == NULL)\n        || (bn_wexpand(p->X, group_top) == NULL)\n        || (bn_wexpand(p->Y, group_top) == NULL)\n        || (bn_wexpand(p->Z, group_top) == NULL)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, ERR_R_BN_LIB);\n        goto err;\n    }\n\n    /*-\n     * Apply coordinate blinding for EC_POINT.\n     *\n     * The underlying EC_METHOD can optionally implement this function:\n     * ec_point_blind_coordinates() returns 0 in case of errors or 1 on\n     * success or if coordinate blinding is not implemented for this\n     * group.\n     */\n    if (!ec_point_blind_coordinates(group, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_POINT_COORDINATES_BLIND_FAILURE);\n        goto err;\n    }\n\n    /* Initialize the Montgomery ladder */\n    if (!ec_point_ladder_pre(group, r, s, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_PRE_FAILURE);\n        goto err;\n    }\n\n    /* top bit is a 1, in a fixed pos */\n    pbit = 1;\n\n#define EC_POINT_CSWAP(c, a, b, w, t) do {         \\\n        BN_consttime_swap(c, (a)->X, (b)->X, w);   \\\n        BN_consttime_swap(c, (a)->Y, (b)->Y, w);   \\\n        BN_consttime_swap(c, (a)->Z, (b)->Z, w);   \\\n        t = ((a)->Z_is_one ^ (b)->Z_is_one) & (c); \\\n        (a)->Z_is_one ^= (t);                      \\\n        (b)->Z_is_one ^= (t);                      \\\n} while(0)\n\n    /*-\n     * The ladder step, with branches, is\n     *\n     * k[i] == 0: S = add(R, S), R = dbl(R)\n     * k[i] == 1: R = add(S, R), S = dbl(S)\n     *\n     * Swapping R, S conditionally on k[i] leaves you with state\n     *\n     * k[i] == 0: T, U = R, S\n     * k[i] == 1: T, U = S, R\n     *\n     * Then perform the ECC ops.\n     *\n     * U = add(T, U)\n     * T = dbl(T)\n     *\n     * Which leaves you with state\n     *\n     * k[i] == 0: U = add(R, S), T = dbl(R)\n     * k[i] == 1: U = add(S, R), T = dbl(S)\n     *\n     * Swapping T, U conditionally on k[i] leaves you with state\n     *\n     * k[i] == 0: R, S = T, U\n     * k[i] == 1: R, S = U, T\n     *\n     * Which leaves you with state\n     *\n     * k[i] == 0: S = add(R, S), R = dbl(R)\n     * k[i] == 1: R = add(S, R), S = dbl(S)\n     *\n     * So we get the same logic, but instead of a branch it's a\n     * conditional swap, followed by ECC ops, then another conditional swap.\n     *\n     * Optimization: The end of iteration i and start of i-1 looks like\n     *\n     * ...\n     * CSWAP(k[i], R, S)\n     * ECC\n     * CSWAP(k[i], R, S)\n     * (next iteration)\n     * CSWAP(k[i-1], R, S)\n     * ECC\n     * CSWAP(k[i-1], R, S)\n     * ...\n     *\n     * So instead of two contiguous swaps, you can merge the condition\n     * bits and do a single swap.\n     *\n     * k[i]   k[i-1]    Outcome\n     * 0      0         No Swap\n     * 0      1         Swap\n     * 1      0         Swap\n     * 1      1         No Swap\n     *\n     * This is XOR. pbit tracks the previous bit of k.\n     */\n\n    for (i = cardinality_bits - 1; i >= 0; i--) {\n        kbit = BN_is_bit_set(k, i) ^ pbit;\n        EC_POINT_CSWAP(kbit, r, s, group_top, Z_is_one);\n\n        /* Perform a single step of the Montgomery ladder */\n        if (!ec_point_ladder_step(group, r, s, p, ctx)) {\n            ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_STEP_FAILURE);\n            goto err;\n        }\n        /*\n         * pbit logic merges this cswap with that of the\n         * next iteration\n         */\n        pbit ^= kbit;\n    }\n    /* one final cswap to move the right value into r */\n    EC_POINT_CSWAP(pbit, r, s, group_top, Z_is_one);\n#undef EC_POINT_CSWAP\n\n    /* Finalize ladder (and recover full point coordinates) */\n    if (!ec_point_ladder_post(group, r, s, p, ctx)) {\n        ECerr(EC_F_EC_SCALAR_MUL_LADDER, EC_R_LADDER_POST_FAILURE);\n        goto err;\n    }\n\n    ret = 1;\n\n err:\n    EC_POINT_free(p);\n    EC_POINT_free(s);\n    BN_CTX_end(ctx);\n\n    return ret;\n}", "before_change_lines": [1, 12, 19, 241], "raw_before_change_lines": [1, 12, 19, 241], "after_change_lines": [17, 18, 20, 21, 22, 23, 24], "raw_after_change_lines": [17, 18, 20, 21, 22, 23, 24], "bug_lines": [1, 12, 19, 241], "added": [false, false, false, false], "idx": 368}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "10686----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0f6f37d924e594b0f04236bcd45504af502cdbab_1.json----internal_verify", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0f6f37d924e594b0f04236bcd45504af502cdbab_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0f6f37d924e594b0f04236bcd45504af502cdbab_1.json", "function_name": "internal_verify", "vul_func_code": "static int internal_verify(X509_STORE_CTX *ctx)\n\t{\n\tint i,ok=0,n;\n\tX509 *xs,*xi;\n\tEVP_PKEY *pkey=NULL;\n\tint (*cb)();\n\n\tcb=ctx->verify_cb;\n\tif (cb == NULL) cb=null_callback;\n\n\tn=sk_X509_num(ctx->chain);\n\tctx->error_depth=n-1;\n\tn--;\n\txi=sk_X509_value(ctx->chain,n);\n\tif (X509_NAME_cmp(X509_get_subject_name(xi),\n\t\tX509_get_issuer_name(xi)) == 0)\n\t\txs=xi;\n\telse\n\t\t{\n\t\tif (n <= 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\n\t\t\tctx->current_cert=xi;\n\t\t\tok=cb(0,ctx);\n\t\t\tgoto end;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tn--;\n\t\t\tctx->error_depth=n;\n\t\t\txs=sk_X509_value(ctx->chain,n);\n\t\t\t}\n\t\t}\n\n/*\tctx->error=0;  not needed */\n\twhile (n >= 0)\n\t\t{\n\t\tctx->error_depth=n;\n\t\tif (!xs->valid)\n\t\t\t{\n\t\t\tif ((pkey=X509_get_pubkey(xi)) == NULL)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\t\t\tctx->current_cert=xi;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\tif (X509_verify(xs,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\t{\n\t\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tEVP_PKEY_free(pkey);\n\t\t\tpkey=NULL;\n\n\t\t\ti=X509_cmp_current_time(X509_get_notBefore(xs));\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_CERT_NOT_YET_VALID;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\txs->valid=1;\n\t\t\t}\n\n\t\ti=X509_cmp_current_time(X509_get_notAfter(xs));\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\t\tctx->current_cert=xs;\n\t\t\tok=(*cb)(0,ctx);\n\t\t\tif (!ok) goto end;\n\t\t\t}\n\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_CERT_HAS_EXPIRED;\n\t\t\tctx->current_cert=xs;\n\t\t\tok=(*cb)(0,ctx);\n\t\t\tif (!ok) goto end;\n\t\t\t}\n\n\t\t/* CRL CHECK */\n\n\t\t/* The last error (if any) is still in the error value */\n\t\tctx->current_cert=xs;\n\t\tok=(*cb)(1,ctx);\n\t\tif (!ok) goto end;\n\n\t\tn--;\n\t\tif (n >= 0)\n\t\t\t{\n\t\t\txi=xs;\n\t\t\txs=sk_X509_value(ctx->chain,n);\n\t\t\t}\n\t\t}\n\tok=1;\nend:\n\treturn(ok);\n\t}", "patch_func_code": "static int internal_verify(X509_STORE_CTX *ctx)\n\t{\n\tint i,ok=0,n;\n\tX509 *xs,*xi;\n\tEVP_PKEY *pkey=NULL;\n\ttime_t *ptime;\n\tint (*cb)();\n\n\tcb=ctx->verify_cb;\n\tif (cb == NULL) cb=null_callback;\n\n\tn=sk_X509_num(ctx->chain);\n\tctx->error_depth=n-1;\n\tn--;\n\txi=sk_X509_value(ctx->chain,n);\n\tif(ctx->flags & X509_V_FLAG_USE_CHECK_TIME) ptime = &ctx->check_time;\n\telse ptime = NULL;\n\tif (ctx->check_issued(ctx, xi, xi))\n\t\txs=xi;\n\telse\n\t\t{\n\t\tif (n <= 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\n\t\t\tctx->current_cert=xi;\n\t\t\tok=cb(0,ctx);\n\t\t\tgoto end;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tn--;\n\t\t\tctx->error_depth=n;\n\t\t\txs=sk_X509_value(ctx->chain,n);\n\t\t\t}\n\t\t}\n\n/*\tctx->error=0;  not needed */\n\twhile (n >= 0)\n\t\t{\n\t\tctx->error_depth=n;\n\t\tif (!xs->valid)\n\t\t\t{\n\t\t\tif ((pkey=X509_get_pubkey(xi)) == NULL)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\t\t\tctx->current_cert=xi;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\tif (X509_verify(xs,pkey) <= 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok)\n\t\t\t\t\t{\n\t\t\t\t\tEVP_PKEY_free(pkey);\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tEVP_PKEY_free(pkey);\n\t\t\tpkey=NULL;\n\n\t\t\ti=X509_cmp_time(X509_get_notBefore(xs), ptime);\n\t\t\tif (i == 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\tif (i > 0)\n\t\t\t\t{\n\t\t\t\tctx->error=X509_V_ERR_CERT_NOT_YET_VALID;\n\t\t\t\tctx->current_cert=xs;\n\t\t\t\tok=(*cb)(0,ctx);\n\t\t\t\tif (!ok) goto end;\n\t\t\t\t}\n\t\t\txs->valid=1;\n\t\t\t}\n\n\t\ti=X509_cmp_time(X509_get_notAfter(xs), ptime);\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\t\tctx->current_cert=xs;\n\t\t\tok=(*cb)(0,ctx);\n\t\t\tif (!ok) goto end;\n\t\t\t}\n\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tctx->error=X509_V_ERR_CERT_HAS_EXPIRED;\n\t\t\tctx->current_cert=xs;\n\t\t\tok=(*cb)(0,ctx);\n\t\t\tif (!ok) goto end;\n\t\t\t}\n\n\t\t/* CRL CHECK */\n\n\t\t/* The last error (if any) is still in the error value */\n\t\tctx->current_cert=xs;\n\t\tok=(*cb)(1,ctx);\n\t\tif (!ok) goto end;\n\n\t\tn--;\n\t\tif (n >= 0)\n\t\t\t{\n\t\t\txi=xs;\n\t\t\txs=sk_X509_value(ctx->chain,n);\n\t\t\t}\n\t\t}\n\tok=1;\nend:\n\treturn(ok);\n\t}", "before_change_lines": [15, 16, 62, 80], "raw_before_change_lines": [15, 16, 62, 80], "after_change_lines": [6, 16, 17, 18, 64, 82], "raw_after_change_lines": [6, 16, 17, 18, 64, 82], "bug_lines": [15, 16, 62, 80], "added": [false, false, false, false], "idx": 369}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "10687----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0f7bbc491948a94a44b45e94e06ed14defa95b9d_1.json----by_file_ctrl", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_0f7bbc491948a94a44b45e94e06ed14defa95b9d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_0f7bbc491948a94a44b45e94e06ed14defa95b9d_1.json", "function_name": "by_file_ctrl", "vul_func_code": "static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\n\t     char **ret)\n\t{\n\tint ok=0,ok2=0;\n\tchar *file;\n\n\tswitch (cmd)\n\t\t{\n\tcase X509_L_FILE_LOAD:\n\t\tif (argl == X509_FILETYPE_DEFAULT)\n\t\t\t{\n\t\t\tok=X509_load_cert_file(ctx,X509_get_default_cert_file(),\n\t\t\t\tX509_FILETYPE_PEM);\n\t\t\tok2=X509_load_crl_file(ctx,X509_get_default_cert_file(),\n\t\t\t\tX509_FILETYPE_PEM);\n\t\t\tif (!ok || !ok2)\n\t\t\t\t{\n\t\t\t\tX509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfile=(char *)Getenv(X509_get_default_cert_file_env());\n\t\t\t\tok=X509_load_cert_file(ctx,file,\n\t\t\t\t\tX509_FILETYPE_PEM);\n\t\t\t\tok2=X509_load_crl_file(ctx,file,\n\t\t\t\t\tX509_FILETYPE_PEM);\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tok=X509_load_cert_file(ctx,argp,(int)argl);\n\t\t\tok2=X509_load_crl_file(ctx,argp,(int)argl);\n\t\t\t}\n\t\tbreak;\n\t\t}\n\treturn((ok && ok2)?ok:0);\n\t}", "patch_func_code": "static int by_file_ctrl(X509_LOOKUP *ctx, int cmd, const char *argp, long argl,\n\t     char **ret)\n\t{\n\tint ok=0;\n\tchar *file;\n\n\tswitch (cmd)\n\t\t{\n\tcase X509_L_FILE_LOAD:\n\t\tif (argl == X509_FILETYPE_DEFAULT)\n\t\t\t{\n\t\t\tok=X509_load_cert_crl_file(ctx,X509_get_default_cert_file(),\n\t\t\t\tX509_FILETYPE_PEM);\n\t\t\tif (!ok)\n\t\t\t\t{\n\t\t\t\tX509err(X509_F_BY_FILE_CTRL,X509_R_LOADING_DEFAULTS);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfile=(char *)Getenv(X509_get_default_cert_file_env());\n\t\t\t\tok=X509_load_cert_crl_file(ctx,file,\n\t\t\t\t\tX509_FILETYPE_PEM);\n\t\t\t\t}\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tif(argl == X509_FILETYPE_PEM)\n\t\t\t\tok=X509_load_cert_crl_file(ctx,argp,\n\t\t\t\t\tX509_FILETYPE_PEM);\n\t\t\telse ok=X509_load_cert_file(ctx,argp,(int)argl);\n\t\t\t}\n\t\tbreak;\n\t\t}\n\treturn(ok);\n\t}", "before_change_lines": [4, 12, 14, 15, 16, 23, 24, 25, 31, 32, 36], "raw_before_change_lines": [4, 12, 14, 15, 16, 23, 24, 25, 31, 32, 36], "after_change_lines": [4, 12, 14, 21, 27, 28, 29, 30, 34], "raw_after_change_lines": [4, 12, 14, 21, 27, 28, 29, 30, 34], "bug_lines": [4, 12, 14, 15, 16, 23, 24, 25, 31, 32, 36], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 370}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10721----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_10d52df25ef829fb43473cfb6e878bfb1341fd0d_1.json----check_bn", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_10d52df25ef829fb43473cfb6e878bfb1341fd0d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_10d52df25ef829fb43473cfb6e878bfb1341fd0d_1.json", "function_name": "check_bn", "vul_func_code": "static int check_bn(const char *name, const BIGNUM *bn, const char *hexbn)\n{\n    BIGNUM *tmp = NULL;\n\n    if (!TEST_true(BN_hex2bn(&tmp, hexbn)))\n        return 0;\n\n    if (!TEST_int_eq(BN_cmp(bn, tmp), 0)) {\n        TEST_info(\"Unexpected %s value\", name);\n        showbn(\"expecting\", tmp);\n        showbn(\"received\", bn);\n        BN_free(tmp);\n        return 0;\n    }\n    BN_free(tmp);\n    return 1;\n}", "patch_func_code": "static int check_bn(const char *name, const BIGNUM *bn, const char *hexbn)\n{\n    BIGNUM *tmp = NULL;\n    int r;\n\n    if (!TEST_true(BN_hex2bn(&tmp, hexbn)))\n        return 0;\n\n    if (BN_cmp(bn, tmp) != 0)\n        TEST_error(\"unexpected %s value\", name);\n    r = TEST_BN_eq(bn, tmp);\n    BN_free(tmp);\n    return r;\n}", "before_change_lines": [8, 9, 10, 11, 12, 13, 14, 16], "raw_before_change_lines": [8, 9, 10, 11, 12, 13, 14, 16], "after_change_lines": [4, 9, 10, 11, 13], "raw_after_change_lines": [4, 9, 10, 11, 13], "bug_lines": [8, 9, 10, 11, 12, 13, 14, 16], "added": [false, false, false, false, false, false, false, false], "idx": 371}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10725----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_10fa91e12d5a405a42cbae7c9ee00b8efde01838_1.json----EVP_DigestInit_ex", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_10fa91e12d5a405a42cbae7c9ee00b8efde01838_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_10fa91e12d5a405a42cbae7c9ee00b8efde01838_1.json", "function_name": "EVP_DigestInit_ex", "vul_func_code": "int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)\n{\n    EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);\n#ifndef OPENSSL_NO_ENGINE\n    /*\n     * Whether it's nice or not, \"Inits\" can be used on \"Final\"'d contexts so\n     * this context may already have an ENGINE! Try to avoid releasing the\n     * previous handle, re-querying for an ENGINE, and having a\n     * reinitialisation, when it may all be unnecessary.\n     */\n    if (ctx->engine && ctx->digest && (!type ||\n                                       (type\n                                        && (type->type ==\n                                            ctx->digest->type))))\n        goto skip_to_init;\n    if (type) {\n        /*\n         * Ensure an ENGINE left lying around from last time is cleared (the\n         * previous check attempted to avoid this if the same ENGINE and\n         * EVP_MD could be used).\n         */\n        if (ctx->engine)\n            ENGINE_finish(ctx->engine);\n        if (impl) {\n            if (!ENGINE_init(impl)) {\n                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);\n                return 0;\n            }\n        } else\n            /* Ask if an ENGINE is reserved for this job */\n            impl = ENGINE_get_digest_engine(type->type);\n        if (impl) {\n            /* There's an ENGINE for this job ... (apparently) */\n            const EVP_MD *d = ENGINE_get_digest(impl, type->type);\n            if (!d) {\n                /* Same comment from evp_enc.c */\n                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);\n                ENGINE_finish(impl);\n                return 0;\n            }\n            /* We'll use the ENGINE's private digest definition */\n            type = d;\n            /*\n             * Store the ENGINE functional reference so we know 'type' came\n             * from an ENGINE and we need to release it when done.\n             */\n            ctx->engine = impl;\n        } else\n            ctx->engine = NULL;\n    } else {\n        if (!ctx->digest) {\n            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET);\n            return 0;\n        }\n        type = ctx->digest;\n    }\n#endif\n    if (ctx->digest != type) {\n        if (ctx->digest && ctx->digest->ctx_size)\n            OPENSSL_free(ctx->md_data);\n        ctx->digest = type;\n        if (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) {\n            ctx->update = type->update;\n            ctx->md_data = OPENSSL_zalloc(type->ctx_size);\n            if (ctx->md_data == NULL) {\n                EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n        }\n    }\n#ifndef OPENSSL_NO_ENGINE\n skip_to_init:\n#endif\n    if (ctx->pctx) {\n        int r;\n        r = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG,\n                              EVP_PKEY_CTRL_DIGESTINIT, 0, ctx);\n        if (r <= 0 && (r != -2))\n            return 0;\n    }\n    if (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT)\n        return 1;\n    return ctx->digest->init(ctx);\n}", "patch_func_code": "int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl)\n{\n    EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);\n#ifndef OPENSSL_NO_ENGINE\n    /*\n     * Whether it's nice or not, \"Inits\" can be used on \"Final\"'d contexts so\n     * this context may already have an ENGINE! Try to avoid releasing the\n     * previous handle, re-querying for an ENGINE, and having a\n     * reinitialisation, when it may all be unnecessary.\n     */\n    if (ctx->engine && ctx->digest && (!type ||\n                                       (type\n                                        && (type->type ==\n                                            ctx->digest->type))))\n        goto skip_to_init;\n    if (type) {\n        /*\n         * Ensure an ENGINE left lying around from last time is cleared (the\n         * previous check attempted to avoid this if the same ENGINE and\n         * EVP_MD could be used).\n         */\n        ENGINE_finish(ctx->engine);\n        if (impl != NULL) {\n            if (!ENGINE_init(impl)) {\n                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);\n                return 0;\n            }\n        } else {\n            /* Ask if an ENGINE is reserved for this job */\n            impl = ENGINE_get_digest_engine(type->type);\n        }\n        if (impl != NULL) {\n            /* There's an ENGINE for this job ... (apparently) */\n            const EVP_MD *d = ENGINE_get_digest(impl, type->type);\n\n            if (d == NULL) {\n                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);\n                ENGINE_finish(impl);\n                return 0;\n            }\n            /* We'll use the ENGINE's private digest definition */\n            type = d;\n            /*\n             * Store the ENGINE functional reference so we know 'type' came\n             * from an ENGINE and we need to release it when done.\n             */\n            ctx->engine = impl;\n        } else\n            ctx->engine = NULL;\n    } else {\n        if (!ctx->digest) {\n            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET);\n            return 0;\n        }\n        type = ctx->digest;\n    }\n#endif\n    if (ctx->digest != type) {\n        if (ctx->digest && ctx->digest->ctx_size)\n            OPENSSL_free(ctx->md_data);\n        ctx->digest = type;\n        if (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) {\n            ctx->update = type->update;\n            ctx->md_data = OPENSSL_zalloc(type->ctx_size);\n            if (ctx->md_data == NULL) {\n                EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n        }\n    }\n#ifndef OPENSSL_NO_ENGINE\n skip_to_init:\n#endif\n    if (ctx->pctx) {\n        int r;\n        r = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG,\n                              EVP_PKEY_CTRL_DIGESTINIT, 0, ctx);\n        if (r <= 0 && (r != -2))\n            return 0;\n    }\n    if (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT)\n        return 1;\n    return ctx->digest->init(ctx);\n}", "before_change_lines": [22, 23, 24, 29, 32, 35], "raw_before_change_lines": [22, 23, 24, 29, 32, 35, 36], "after_change_lines": [22, 23, 28, 31, 32, 36], "raw_after_change_lines": [22, 23, 28, 31, 32, 35, 36], "bug_lines": [22, 23, 24, 29, 32, 35, 36], "added": [false, false, false, false, false, false, false], "idx": 372}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10729----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_11189973bf616f00ae75b2bd6407fc6e6bb54cc3_1.json----CONF_get1_default_config_file", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_11189973bf616f00ae75b2bd6407fc6e6bb54cc3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_11189973bf616f00ae75b2bd6407fc6e6bb54cc3_1.json", "function_name": "CONF_get1_default_config_file", "vul_func_code": "char *CONF_get1_default_config_file(void)\n{\n    char *file;\n    int len;\n\n    file = getenv(\"OPENSSL_CONF\");\n    if (file)\n        return OPENSSL_strdup(file);\n\n    len = strlen(X509_get_default_cert_area());\n#ifndef OPENSSL_SYS_VMS\n    len++;\n#endif\n    len += strlen(OPENSSL_CONF);\n\n    file = OPENSSL_malloc(len + 1);\n\n    if (file == NULL)\n        return NULL;\n    OPENSSL_strlcpy(file, X509_get_default_cert_area(), len + 1);\n#ifndef OPENSSL_SYS_VMS\n    OPENSSL_strlcat(file, \"/\", len + 1);\n#endif\n    OPENSSL_strlcat(file, OPENSSL_CONF, len + 1);\n\n    return file;\n}", "patch_func_code": "char *CONF_get1_default_config_file(void)\n{\n    char *file;\n    int len;\n\n    file = getenv(\"OPENSSL_CONF\");\n    if (file)\n        return OPENSSL_strdup(file);\n\n    len = strlen(X509_get_default_cert_area());\n#ifndef OPENSSL_SYS_VMS\n    len++;\n#endif\n    len += strlen(OPENSSL_CONF);\n\n    file = OPENSSL_malloc(len + 1);\n\n    if (file == NULL)\n        return NULL;\n    strcpy(file, X509_get_default_cert_area());\n#ifndef OPENSSL_SYS_VMS\n    strcat(file, \"/\");\n#endif\n    strcat(file, OPENSSL_CONF);\n\n    return file;\n}", "before_change_lines": [20, 22, 24], "raw_before_change_lines": [20, 22, 24], "after_change_lines": [20, 22, 24], "raw_after_change_lines": [20, 22, 24], "bug_lines": [20, 22, 24], "added": [false, false, false], "idx": 373}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10733----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_113012cef007976c3aae66c276b7e2095e9090a0_1.json----tls13_change_cipher_state", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_113012cef007976c3aae66c276b7e2095e9090a0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_113012cef007976c3aae66c276b7e2095e9090a0_1.json", "function_name": "tls13_change_cipher_state", "vul_func_code": "int tls13_change_cipher_state(SSL *s, int which)\n{\n    static const unsigned char client_early_traffic[] = \"c e traffic\";\n    static const unsigned char client_handshake_traffic[] = \"c hs traffic\";\n    static const unsigned char client_application_traffic[] = \"c ap traffic\";\n    static const unsigned char server_handshake_traffic[] = \"s hs traffic\";\n    static const unsigned char server_application_traffic[] = \"s ap traffic\";\n    static const unsigned char exporter_master_secret[] = \"exp master\";\n    static const unsigned char resumption_master_secret[] = \"res master\";\n    unsigned char *iv;\n    unsigned char secret[EVP_MAX_MD_SIZE];\n    unsigned char hashval[EVP_MAX_MD_SIZE];\n    unsigned char *hash = hashval;\n    unsigned char *insecret;\n    unsigned char *finsecret = NULL;\n    const char *log_label = NULL;\n    EVP_CIPHER_CTX *ciph_ctx;\n    size_t finsecretlen = 0;\n    const unsigned char *label;\n    size_t labellen, hashlen = 0;\n    int ret = 0;\n    const EVP_MD *md = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    if (which & SSL3_CC_READ) {\n        if (s->enc_read_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        } else {\n            s->enc_read_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_read_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_read_ctx;\n        iv = s->read_iv;\n\n        RECORD_LAYER_reset_read_sequence(&s->rlayer);\n    } else {\n        if (s->enc_write_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_write_ctx);\n        } else {\n            s->enc_write_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_write_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_write_ctx;\n        iv = s->write_iv;\n\n        RECORD_LAYER_reset_write_sequence(&s->rlayer);\n    }\n\n    if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE))\n            || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) {\n        if (which & SSL3_CC_EARLY) {\n            EVP_MD_CTX *mdctx = NULL;\n            long handlen;\n            void *hdata;\n            unsigned int hashlenui;\n            const SSL_CIPHER *sslcipher = SSL_SESSION_get0_cipher(s->session);\n\n            insecret = s->early_secret;\n            label = client_early_traffic;\n            labellen = sizeof(client_early_traffic) - 1;\n            log_label = CLIENT_EARLY_LABEL;\n\n            handlen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n            if (handlen <= 0) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE,\n                       SSL_R_BAD_HANDSHAKE_LENGTH);\n                goto err;\n            }\n            if (sslcipher == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            /*\n             * We need to calculate the handshake digest using the digest from\n             * the session. We haven't yet selected our ciphersuite so we can't\n             * use ssl_handshake_md().\n             */\n            mdctx = EVP_MD_CTX_new();\n            if (mdctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            cipher = EVP_get_cipherbynid(SSL_CIPHER_get_cipher_nid(sslcipher));\n            md = ssl_md(sslcipher->algorithm2);\n            if (md == NULL || !EVP_DigestInit_ex(mdctx, md, NULL)\n                    || !EVP_DigestUpdate(mdctx, hdata, handlen)\n                    || !EVP_DigestFinal_ex(mdctx, hashval, &hashlenui)) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n                EVP_MD_CTX_free(mdctx);\n                goto err;\n            }\n            hashlen = hashlenui;\n            EVP_MD_CTX_free(mdctx);\n        } else if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->client_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = client_handshake_traffic;\n            labellen = sizeof(client_handshake_traffic) - 1;\n            log_label = CLIENT_HANDSHAKE_LABEL;\n            /*\n             * The handshake hash used for the server read/client write handshake\n             * traffic secret is the same as the hash for the server\n             * write/client read handshake traffic secret. However, if we\n             * processed early data then we delay changing the server\n             * read/client write cipher state until later, and the handshake\n             * hashes have moved on. Therefore we use the value saved earlier\n             * when we did the server write/client read change cipher state.\n             */\n            hash = s->handshake_traffic_hash;\n        } else {\n            insecret = s->master_secret;\n            label = client_application_traffic;\n            labellen = sizeof(client_application_traffic) - 1;\n            log_label = CLIENT_APPLICATION_LABEL;\n            /*\n             * For this we only use the handshake hashes up until the server\n             * Finished hash. We do not include the client's Finished, which is\n             * what ssl_handshake_hash() would give us. Instead we use the\n             * previously saved value.\n             */\n            hash = s->server_finished_hash;\n        }\n    } else {\n        /* Early data never applies to client-read/server-write */\n        if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->server_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = server_handshake_traffic;\n            labellen = sizeof(server_handshake_traffic) - 1;\n            log_label = SERVER_HANDSHAKE_LABEL;\n        } else {\n            insecret = s->master_secret;\n            label = server_application_traffic;\n            labellen = sizeof(server_application_traffic) - 1;\n            log_label = SERVER_APPLICATION_LABEL;\n        }\n    }\n\n    if (!(which & SSL3_CC_EARLY)) {\n        md = ssl_handshake_md(s);\n        cipher = s->s3->tmp.new_sym_enc;\n        if (!ssl3_digest_cached_records(s, 1)\n                || !ssl_handshake_hash(s, hashval, sizeof(hashval), &hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    /*\n     * Save the hash of handshakes up to now for use when we calculate the\n     * client application traffic secret\n     */\n    if (label == server_application_traffic)\n        memcpy(s->server_finished_hash, hashval, hashlen);\n\n    if (label == server_handshake_traffic)\n        memcpy(s->handshake_traffic_hash, hashval, hashlen);\n\n    if (label == client_application_traffic) {\n        /*\n         * We also create the resumption master secret, but this time use the\n         * hash for the whole handshake including the Client Finished\n         */\n        if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret,\n                               resumption_master_secret,\n                               sizeof(resumption_master_secret) - 1,\n                               hashval, s->session->master_key, hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->session->master_key_length = hashlen;\n\n        /* Now we create the exporter master secret */\n        if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret,\n                               exporter_master_secret,\n                               sizeof(exporter_master_secret) - 1,\n                               hash, s->exporter_master_secret, hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (!derive_secret_key_and_iv(s, which & SSL3_CC_WRITE, md, cipher,\n                                  insecret, hash, label, labellen, secret, iv,\n                                  ciph_ctx)) {\n        goto err;\n    }\n\n    if (label == server_application_traffic)\n        memcpy(s->server_app_traffic_secret, secret, hashlen);\n    else if (label == client_application_traffic)\n        memcpy(s->client_app_traffic_secret, secret, hashlen);\n\n    if (!ssl_log_secret(s, log_label, secret, hashlen)) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (finsecret != NULL\n            && !tls13_derive_finishedkey(s, ssl_handshake_md(s), secret,\n                                         finsecret, finsecretlen)) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(secret, sizeof(secret));\n    return ret;\n}", "patch_func_code": "int tls13_change_cipher_state(SSL *s, int which)\n{\n    static const unsigned char client_early_traffic[] = \"c e traffic\";\n    static const unsigned char client_handshake_traffic[] = \"c hs traffic\";\n    static const unsigned char client_application_traffic[] = \"c ap traffic\";\n    static const unsigned char server_handshake_traffic[] = \"s hs traffic\";\n    static const unsigned char server_application_traffic[] = \"s ap traffic\";\n    static const unsigned char exporter_master_secret[] = \"exp master\";\n    static const unsigned char resumption_master_secret[] = \"res master\";\n    unsigned char *iv;\n    unsigned char secret[EVP_MAX_MD_SIZE];\n    unsigned char hashval[EVP_MAX_MD_SIZE];\n    unsigned char *hash = hashval;\n    unsigned char *insecret;\n    unsigned char *finsecret = NULL;\n    const char *log_label = NULL;\n    EVP_CIPHER_CTX *ciph_ctx;\n    size_t finsecretlen = 0;\n    const unsigned char *label;\n    size_t labellen, hashlen = 0;\n    int ret = 0;\n    const EVP_MD *md = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    if (which & SSL3_CC_READ) {\n        if (s->enc_read_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        } else {\n            s->enc_read_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_read_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_read_ctx;\n        iv = s->read_iv;\n\n        RECORD_LAYER_reset_read_sequence(&s->rlayer);\n    } else {\n        if (s->enc_write_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_write_ctx);\n        } else {\n            s->enc_write_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_write_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_write_ctx;\n        iv = s->write_iv;\n\n        RECORD_LAYER_reset_write_sequence(&s->rlayer);\n    }\n\n    if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE))\n            || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) {\n        if (which & SSL3_CC_EARLY) {\n            EVP_MD_CTX *mdctx = NULL;\n            long handlen;\n            void *hdata;\n            unsigned int hashlenui;\n            const SSL_CIPHER *sslcipher = SSL_SESSION_get0_cipher(s->session);\n\n            insecret = s->early_secret;\n            label = client_early_traffic;\n            labellen = sizeof(client_early_traffic) - 1;\n            log_label = CLIENT_EARLY_LABEL;\n\n            handlen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n            if (handlen <= 0) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE,\n                       SSL_R_BAD_HANDSHAKE_LENGTH);\n                goto err;\n            }\n            if (sslcipher == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n\n            /*\n             * We need to calculate the handshake digest using the digest from\n             * the session. We haven't yet selected our ciphersuite so we can't\n             * use ssl_handshake_md().\n             */\n            mdctx = EVP_MD_CTX_new();\n            if (mdctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            cipher = EVP_get_cipherbynid(SSL_CIPHER_get_cipher_nid(sslcipher));\n            md = ssl_md(sslcipher->algorithm2);\n            if (md == NULL || !EVP_DigestInit_ex(mdctx, md, NULL)\n                    || !EVP_DigestUpdate(mdctx, hdata, handlen)\n                    || !EVP_DigestFinal_ex(mdctx, hashval, &hashlenui)) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n                EVP_MD_CTX_free(mdctx);\n                goto err;\n            }\n            hashlen = hashlenui;\n            EVP_MD_CTX_free(mdctx);\n        } else if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->client_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = client_handshake_traffic;\n            labellen = sizeof(client_handshake_traffic) - 1;\n            log_label = CLIENT_HANDSHAKE_LABEL;\n            /*\n             * The handshake hash used for the server read/client write handshake\n             * traffic secret is the same as the hash for the server\n             * write/client read handshake traffic secret. However, if we\n             * processed early data then we delay changing the server\n             * read/client write cipher state until later, and the handshake\n             * hashes have moved on. Therefore we use the value saved earlier\n             * when we did the server write/client read change cipher state.\n             */\n            hash = s->handshake_traffic_hash;\n        } else {\n            insecret = s->master_secret;\n            label = client_application_traffic;\n            labellen = sizeof(client_application_traffic) - 1;\n            log_label = CLIENT_APPLICATION_LABEL;\n            /*\n             * For this we only use the handshake hashes up until the server\n             * Finished hash. We do not include the client's Finished, which is\n             * what ssl_handshake_hash() would give us. Instead we use the\n             * previously saved value.\n             */\n            hash = s->server_finished_hash;\n        }\n    } else {\n        /* Early data never applies to client-read/server-write */\n        if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->server_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = server_handshake_traffic;\n            labellen = sizeof(server_handshake_traffic) - 1;\n            log_label = SERVER_HANDSHAKE_LABEL;\n        } else {\n            insecret = s->master_secret;\n            label = server_application_traffic;\n            labellen = sizeof(server_application_traffic) - 1;\n            log_label = SERVER_APPLICATION_LABEL;\n        }\n    }\n\n    if (!(which & SSL3_CC_EARLY)) {\n        md = ssl_handshake_md(s);\n        cipher = s->s3->tmp.new_sym_enc;\n        if (!ssl3_digest_cached_records(s, 1)\n                || !ssl_handshake_hash(s, hashval, sizeof(hashval), &hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    /*\n     * Save the hash of handshakes up to now for use when we calculate the\n     * client application traffic secret\n     */\n    if (label == server_application_traffic)\n        memcpy(s->server_finished_hash, hashval, hashlen);\n\n    if (label == server_handshake_traffic)\n        memcpy(s->handshake_traffic_hash, hashval, hashlen);\n\n    if (label == client_application_traffic) {\n        /*\n         * We also create the resumption master secret, but this time use the\n         * hash for the whole handshake including the Client Finished\n         */\n        if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret,\n                               resumption_master_secret,\n                               sizeof(resumption_master_secret) - 1,\n                               hashval, hashlen, s->session->master_key,\n                               hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->session->master_key_length = hashlen;\n\n        /* Now we create the exporter master secret */\n        if (!tls13_hkdf_expand(s, ssl_handshake_md(s), insecret,\n                               exporter_master_secret,\n                               sizeof(exporter_master_secret) - 1,\n                               hash, hashlen, s->exporter_master_secret,\n                               hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (!derive_secret_key_and_iv(s, which & SSL3_CC_WRITE, md, cipher,\n                                  insecret, hash, label, labellen, secret, iv,\n                                  ciph_ctx)) {\n        goto err;\n    }\n\n    if (label == server_application_traffic)\n        memcpy(s->server_app_traffic_secret, secret, hashlen);\n    else if (label == client_application_traffic)\n        memcpy(s->client_app_traffic_secret, secret, hashlen);\n\n    if (!ssl_log_secret(s, log_label, secret, hashlen)) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (finsecret != NULL\n            && !tls13_derive_finishedkey(s, ssl_handshake_md(s), secret,\n                                         finsecret, finsecretlen)) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(secret, sizeof(secret));\n    return ret;\n}", "before_change_lines": [176, 186], "raw_before_change_lines": [176, 186], "after_change_lines": [176, 177, 187, 188], "raw_after_change_lines": [176, 177, 187, 188], "bug_lines": [176, 186], "added": [false, false], "idx": 374}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "10735----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1134f9f9eb9094e1f8b6bbf48f18dc96b349ce2e_1.json----ssl3_accept", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1134f9f9eb9094e1f8b6bbf48f18dc96b349ce2e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1134f9f9eb9094e1f8b6bbf48f18dc96b349ce2e_1.json", "function_name": "ssl3_accept", "vul_func_code": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;\n\t\t\ts->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\tif (s->rwstate != SSL_X509_LOOKUP)\n\t\t\t{\n\t\t\t\tret=ssl3_get_client_hello(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\ts->state = SSL3_ST_SW_SUPPLEMENTAL_DATA_A;\n#else\n\t\t\ts->state = SSL3_ST_SW_CERT_A;\n#endif\n\t\t\ts->init_num = 0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SUPPLEMENTAL_DATA_A:\n\t\tcase SSL3_ST_SW_SUPPLEMENTAL_DATA_B:\n\t\t\t/* We promised to send an audit proof in the hello. */\n\t\t\tif (s->s3->tlsext_authz_promised_to_client)\n\t\t\t\t{\n\t\t\t\tret = tls1_send_server_supplemental_data(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip = 1;\n\n\t\t\ts->state = SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num = 0;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & SSL_kEDH)\n\t\t\t    || (alg_k & SSL_kEECDH)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n\t\t\telse {\n\t\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t\t{\n\t\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (SSL_USE_SIGALGS(s))\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For sigalgs freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}", "patch_func_code": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long alg_k,Time=(unsigned long)time(NULL);\n\tvoid (*cb)(const SSL *ssl,int type,int val)=NULL;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\ts->in_handshake++;\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* If we're awaiting a HeartbeatResponse, pretend we\n\t * already got and don't await it anymore, because\n\t * Heartbeats don't make sense during handshakes anyway.\n\t */\n\tif (s->tlsext_hb_pending)\n\t\t{\n\t\ts->tlsext_hb_pending = 0;\n\t\ts->tlsext_hb_seq++;\n\t\t}\n#endif\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->renegotiate=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, ERR_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\ts->init_num=0;\n\t\t\ts->s3->flags &= ~SSL3_FLAGS_SGC_RESTART_DONE;\n\t\t\ts->s3->flags &= ~TLS1_FLAGS_SKIP_CERT_VERIFY;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t\t */\n\t\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\t\t\t\t\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse if (!s->s3->send_connection_binding &&\n\t\t\t\t!(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION))\n\t\t\t\t{\n\t\t\t\t/* Server attempting to renegotiate with\n\t\t\t\t * client that doesn't support secure\n\t\t\t\t * renegotiation.\n\t\t\t\t */\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE);\n\t\t\t\tret = -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\t/* s->state == SSL_ST_RENEGOTIATE,\n\t\t\t\t * we will just send a HelloRequest */\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\tif (s->rwstate != SSL_X509_LOOKUP)\n\t\t\t{\n\t\t\t\tret=ssl3_get_client_hello(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t}\n#ifndef OPENSSL_NO_SRP\n\t\t\t{\n\t\t\tint al;\n\t\t\tif ((ret = ssl_check_srp_ext_ClientHello(s,&al))  < 0)\n\t\t\t\t\t{\n\t\t\t\t\t/* callback indicates firther work to be done */\n\t\t\t\t\ts->rwstate=SSL_X509_LOOKUP;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\tif (ret != SSL_ERROR_NONE)\n\t\t\t\t{\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\t\n\t\t\t\t/* This is not really an error but the only means to\n                                   for a client to detect whether srp is supported. */\n \t\t\t\t   if (al != TLS1_AD_UNKNOWN_PSK_IDENTITY) \t\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_CLIENTHELLO_TLSEXT);\t\t\t\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\t\t\t\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t}\n#endif\t\t\n\t\t\t\n\t\t\ts->renegotiate = 2;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\tif (s->hit)\n\t\t\t\t{\n\t\t\t\tif (s->tlsext_ticket_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\t\t}\n#else\n\t\t\tif (s->hit)\n\t\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n#endif\n\t\t\telse\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\ts->state = SSL3_ST_SW_SUPPLEMENTAL_DATA_A;\n#else\n\t\t\ts->state = SSL3_ST_SW_CERT_A;\n#endif\n\t\t\ts->init_num = 0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SUPPLEMENTAL_DATA_A:\n\t\tcase SSL3_ST_SW_SUPPLEMENTAL_DATA_B:\n\t\t\tret = tls1_send_server_supplemental_data(s, &skip);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\ts->state = SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num = 0;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH or anon ECDH, */\n\t\t\t/* normal PSK or KRB5 or SRP */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK)\n\t\t\t\t&& !(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\t\tif (s->tlsext_status_expected)\n\t\t\t\t\ts->state=SSL3_ST_SW_CERT_STATUS_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tskip = 1;\n\t\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\t\t}\n#else\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\talg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef OPENSSL_NO_KRB5\n\t\t\t\t&& !(alg_k & SSL_kKRB5)\n#endif /* OPENSSL_NO_KRB5 */\n\t\t\t\t)\n\t\t\t\t/* option SSL_OP_EPHEMERAL_RSA sends temporary RSA key\n\t\t\t\t * even when forbidden by protocol specs\n\t\t\t\t * (handshake may fail as clients are not required to\n\t\t\t\t * be able to handle this) */\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate\n\t\t\t *\n\t\t\t * PSK: may send PSK identity hints\n\t\t\t *\n\t\t\t * For ECC ciphersuites, we send a serverKeyExchange\n\t\t\t * message only if the cipher suite is either\n\t\t\t * ECDH-anon or ECDHE. In other cases, the\n\t\t\t * server certificate contains the server's\n\t\t\t * public key for key exchange.\n\t\t\t */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t/* PSK: send ServerKeyExchange if PSK identity\n\t\t\t * hint if provided */\n#ifndef OPENSSL_NO_PSK\n\t\t\t    || ((alg_k & SSL_kPSK) && s->ctx->psk_identity_hint)\n#endif\n#ifndef OPENSSL_NO_SRP\n\t\t\t    /* SRP: send ServerKeyExchange */\n\t\t\t    || (alg_k & SSL_kSRP)\n#endif\n\t\t\t    || (alg_k & SSL_kEDH)\n\t\t\t    || (alg_k & SSL_kEECDH)\n\t\t\t    || ((alg_k & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) ||\n\t\t\t\t /* never request cert in Kerberos ciphersuites */\n\t\t\t\t(s->s3->tmp.new_cipher->algorithm_auth & SSL_aKRB5)\n\t\t\t\t/* With normal PSK Certificates and\n\t\t\t\t * Certificate Requests are omitted */\n\t\t\t\t|| (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kPSK))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\n\t\t\t/* This code originally checked to see if\n\t\t\t * any data was pending using BIO_CTRL_INFO\n\t\t\t * and then flushed. This caused problems\n\t\t\t * as documented in PR#1939. The proposed\n\t\t\t * fix doesn't completely resolve this issue\n\t\t\t * as buggy implementations of BIO_CTRL_PENDING\n\t\t\t * still exist. So instead we just flush\n\t\t\t * unconditionally.\n\t\t\t */\n\n\t\t\ts->rwstate=SSL_WRITING;\n\t\t\tif (BIO_flush(s->wbio) <= 0)\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\ts->rwstate=SSL_NOTHING;\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SR_SUPPLEMENTAL_DATA_A:\n\t\tcase SSL3_ST_SR_SUPPLEMENTAL_DATA_B:\n\t\t\tret=tls1_get_client_supplemental_data(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n#endif\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (ret == 3)\n\t\t\t\ts->state = SSL3_ST_SR_SUPPLEMENTAL_DATA_A;\n#endif\n\t\t\telse {\n\t\t\t\tif (s->s3->tmp.cert_request)\n\t\t\t\t\t{\n\t\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\t{\n\t\t\t\t/* For the ECDH ciphersuites when\n\t\t\t\t * the client sends its ECDH pub key in\n\t\t\t\t * a certificate, the CertificateVerify\n\t\t\t\t * message is not sent.\n\t\t\t\t * Also for GOST ciphersuites when\n\t\t\t\t * the client uses its key from the certificate\n\t\t\t\t * for key exchange.\n\t\t\t\t */\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\ts->init_num = 0;\n\t\t\t\t}\n\t\t\telse if (SSL_USE_SIGALGS(s))\n\t\t\t\t{\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\t\t\t\tif (!s->session->peer)\n\t\t\t\t\tbreak;\n\t\t\t\t/* For sigalgs freeze the handshake buffer\n\t\t\t\t * at this point and digest cached records.\n\t\t\t\t */\n\t\t\t\tif (!s->s3->handshake_buffer)\n\t\t\t\t\t{\n\t\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,ERR_R_INTERNAL_ERROR);\n\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\ts->s3->flags |= TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tint offset=0;\n\t\t\t\tint dgst_num;\n\n\t\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\t\ts->init_num=0;\n\n\t\t\t\t/* We need to get hashes here so if there is\n\t\t\t\t * a client cert, it can be verified\n\t\t\t\t * FIXME - digest processing for CertificateVerify\n\t\t\t\t * should be generalized. But it is next step\n\t\t\t\t */\n\t\t\t\tif (s->s3->handshake_buffer)\n\t\t\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\t\t\treturn -1;\n\t\t\t\tfor (dgst_num=0; dgst_num<SSL_MAX_DIGEST;dgst_num++)\t\n\t\t\t\t\tif (s->s3->handshake_dgst[dgst_num]) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tint dgst_size;\n\n\t\t\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,EVP_MD_CTX_type(s->s3->handshake_dgst[dgst_num]),&(s->s3->tmp.cert_verify_md[offset]));\n\t\t\t\t\t\tdgst_size=EVP_MD_CTX_size(s->s3->handshake_dgst[dgst_num]);\n\t\t\t\t\t\tif (dgst_size < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tret = -1;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\toffset+=dgst_size;\n\t\t\t\t\t\t}\t\t\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\ts->state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)\n\t\tcase SSL3_ST_SR_NEXT_PROTO_A:\n\t\tcase SSL3_ST_SR_NEXT_PROTO_B:\n\t\t\tret=ssl3_get_next_proto(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->init_num = 0;\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\tbreak;\n#endif\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n#ifndef OPENSSL_NO_TLSEXT\n\t\t\telse if (s->tlsext_ticket_expected)\n\t\t\t\ts->state=SSL3_ST_SW_SESSION_TICKET_A;\n#endif\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t\tcase SSL3_ST_SW_SESSION_TICKET_A:\n\t\tcase SSL3_ST_SW_SESSION_TICKET_B:\n\t\t\tret=ssl3_send_newsession_ticket(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_STATUS_A:\n\t\tcase SSL3_ST_SW_CERT_STATUS_B:\n\t\t\tret=ssl3_send_cert_status(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n#endif\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\t{\n#if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#else\n\t\t\t\tif (s->s3->next_proto_neg_seen)\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_NEXT_PROTO_A;\n\t\t\t\telse\n\t\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n#endif\n\t\t\t\t}\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->renegotiate == 2) /* skipped if we just sent a HelloRequest */\n\t\t\t\t{\n\t\t\t\ts->renegotiate=0;\n\t\t\t\ts->new_session=0;\n\t\t\t\t\n\t\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\t\t\t\t\n\t\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t\t/* s->server=1; */\n\t\t\t\ts->handshake_func=ssl3_accept;\n\n\t\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\t\t\t\t}\n\t\t\t\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\ts->in_handshake--;\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\treturn(ret);\n\t}", "before_change_lines": [205, 206, 207, 208, 209, 210, 211], "raw_before_change_lines": [204, 205, 206, 207, 208, 209, 210, 211, 386], "after_change_lines": [204, 205, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 398, 399, 400, 401], "raw_after_change_lines": [204, 205, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 398, 399, 400, 401], "bug_lines": [204, 205, 206, 207, 208, 209, 210, 211, 386], "added": [false, false, false, false, false, false, false, false, false], "idx": 375}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10738----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1136cfd78480a327211653fb5a7c7c0c35d6af8d_1.json----add_entry", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1136cfd78480a327211653fb5a7c7c0c35d6af8d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1136cfd78480a327211653fb5a7c7c0c35d6af8d_1.json", "function_name": "add_entry", "vul_func_code": "static int add_entry(enum Type type, unsigned int hash, const char *filename,\n                      const unsigned char *digest, int need_symlink,\n                      unsigned short old_id)\n{\n    static BUCKET nilbucket;\n    static HENTRY nilhentry;\n    BUCKET *bp;\n    HENTRY *ep, *found = NULL;\n    unsigned int ndx = (type + hash) % OSSL_NELEM(hash_table);\n\n    for (bp = hash_table[ndx]; bp; bp = bp->next)\n        if (bp->type == type && bp->hash == hash)\n            break;\n    if (bp == NULL) {\n        bp = app_malloc(sizeof(*bp), \"hash bucket\");\n        *bp = nilbucket;\n        bp->next = hash_table[ndx];\n        bp->type = type;\n        bp->hash = hash;\n        hash_table[ndx] = bp;\n    }\n\n    for (ep = bp->first_entry; ep; ep = ep->next) {\n        if (digest && memcmp(digest, ep->digest, evpmdsize) == 0) {\n            BIO_printf(bio_err,\n                       \"%s: skipping duplicate certificate in %s\\n\",\n                       opt_getprog(), filename);\n            return 1;\n        }\n        if (strcmp(filename, ep->filename) == 0) {\n            found = ep;\n            if (digest == NULL)\n                break;\n        }\n    }\n    ep = found;\n    if (ep == NULL) {\n        if (bp->num_needed >= MAX_COLLISIONS) {\n            BIO_printf(bio_err,\n                       \"%s: hash table overflow for %s\\n\",\n                       opt_getprog(), filename);\n            return 1;\n        }\n        ep = app_malloc(sizeof(*ep), \"collision bucket\");\n        *ep = nilhentry;\n        ep->old_id = ~0;\n        ep->filename = BUF_strdup(filename);\n        if (bp->last_entry)\n            bp->last_entry->next = ep;\n        if (bp->first_entry == NULL)\n            bp->first_entry = ep;\n        bp->last_entry = ep;\n    }\n\n    if (old_id < ep->old_id)\n        ep->old_id = old_id;\n    if (need_symlink && !ep->need_symlink) {\n        ep->need_symlink = 1;\n        bp->num_needed++;\n        memcpy(ep->digest, digest, evpmdsize);\n    }\n    return 0;\n}", "patch_func_code": "static int add_entry(enum Type type, unsigned int hash, const char *filename,\n                      const unsigned char *digest, int need_symlink,\n                      unsigned short old_id)\n{\n    static BUCKET nilbucket;\n    static HENTRY nilhentry;\n    BUCKET *bp;\n    HENTRY *ep, *found = NULL;\n    unsigned int ndx = (type + hash) % OSSL_NELEM(hash_table);\n\n    for (bp = hash_table[ndx]; bp; bp = bp->next)\n        if (bp->type == type && bp->hash == hash)\n            break;\n    if (bp == NULL) {\n        bp = app_malloc(sizeof(*bp), \"hash bucket\");\n        *bp = nilbucket;\n        bp->next = hash_table[ndx];\n        bp->type = type;\n        bp->hash = hash;\n        hash_table[ndx] = bp;\n    }\n\n    for (ep = bp->first_entry; ep; ep = ep->next) {\n        if (digest && memcmp(digest, ep->digest, evpmdsize) == 0) {\n            BIO_printf(bio_err,\n                       \"%s: skipping duplicate certificate in %s\\n\",\n                       opt_getprog(), filename);\n            return 1;\n        }\n        if (strcmp(filename, ep->filename) == 0) {\n            found = ep;\n            if (digest == NULL)\n                break;\n        }\n    }\n    ep = found;\n    if (ep == NULL) {\n        if (bp->num_needed >= MAX_COLLISIONS) {\n            BIO_printf(bio_err,\n                       \"%s: hash table overflow for %s\\n\",\n                       opt_getprog(), filename);\n            return 1;\n        }\n        ep = app_malloc(sizeof(*ep), \"collision bucket\");\n        *ep = nilhentry;\n        ep->old_id = ~0;\n        ep->filename = OPENSSL_strdup(filename);\n        if (bp->last_entry)\n            bp->last_entry->next = ep;\n        if (bp->first_entry == NULL)\n            bp->first_entry = ep;\n        bp->last_entry = ep;\n    }\n\n    if (old_id < ep->old_id)\n        ep->old_id = old_id;\n    if (need_symlink && !ep->need_symlink) {\n        ep->need_symlink = 1;\n        bp->num_needed++;\n        memcpy(ep->digest, digest, evpmdsize);\n    }\n    return 0;\n}", "before_change_lines": [47], "raw_before_change_lines": [47], "after_change_lines": [47], "raw_after_change_lines": [47], "bug_lines": [47], "added": [false], "idx": 376}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10746----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_116ae88bd361daa0cfac158e4e092d396f93677c_1.json----PEM_dek_info", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_116ae88bd361daa0cfac158e4e092d396f93677c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_116ae88bd361daa0cfac158e4e092d396f93677c_1.json", "function_name": "PEM_dek_info", "vul_func_code": "void PEM_dek_info(char *buf, const char *type, int len, char *str)\n{\n    static const unsigned char map[17] = \"0123456789ABCDEF\";\n    long i;\n    int j;\n\n    BUF_strlcat(buf, \"DEK-Info: \", PEM_BUFSIZE);\n    BUF_strlcat(buf, type, PEM_BUFSIZE);\n    BUF_strlcat(buf, \",\", PEM_BUFSIZE);\n    j = strlen(buf);\n    if (j + (len * 2) + 1 > PEM_BUFSIZE)\n        return;\n    for (i = 0; i < len; i++) {\n        buf[j + i * 2] = map[(str[i] >> 4) & 0x0f];\n        buf[j + i * 2 + 1] = map[(str[i]) & 0x0f];\n    }\n    buf[j + i * 2] = '\\n';\n    buf[j + i * 2 + 1] = '\\0';\n}", "patch_func_code": "void PEM_dek_info(char *buf, const char *type, int len, char *str)\n{\n    static const unsigned char map[17] = \"0123456789ABCDEF\";\n    long i;\n    int j;\n\n    OPENSSL_strlcat(buf, \"DEK-Info: \", PEM_BUFSIZE);\n    OPENSSL_strlcat(buf, type, PEM_BUFSIZE);\n    OPENSSL_strlcat(buf, \",\", PEM_BUFSIZE);\n    j = strlen(buf);\n    if (j + (len * 2) + 1 > PEM_BUFSIZE)\n        return;\n    for (i = 0; i < len; i++) {\n        buf[j + i * 2] = map[(str[i] >> 4) & 0x0f];\n        buf[j + i * 2 + 1] = map[(str[i]) & 0x0f];\n    }\n    buf[j + i * 2] = '\\n';\n    buf[j + i * 2 + 1] = '\\0';\n}", "before_change_lines": [7, 8, 9], "raw_before_change_lines": [7, 8, 9], "after_change_lines": [7, 8, 9], "raw_after_change_lines": [7, 8, 9], "bug_lines": [7, 8, 9], "added": [false, false, false], "idx": 377}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "10797----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_130062532cf831fa5086a4d6d34fc09340a20c05_1.json----d2i_SSL_SESSION", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_130062532cf831fa5086a4d6d34fc09340a20c05_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_130062532cf831fa5086a4d6d34fc09340a20c05_1.json", "function_name": "d2i_SSL_SESSION", "vul_func_code": "SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,\n                             long length)\n{\n    long id;\n    size_t tmpl;\n    const unsigned char *p = *pp;\n    SSL_SESSION_ASN1 *as = NULL;\n    SSL_SESSION *ret = NULL;\n\n    as = d2i_SSL_SESSION_ASN1(NULL, &p, length);\n    /* ASN.1 code returns suitable error */\n    if (as == NULL)\n        goto err;\n\n    if (!a || !*a) {\n        ret = SSL_SESSION_new();\n        if (ret == NULL)\n            goto err;\n    } else {\n        ret = *a;\n    }\n\n    if (as->version != SSL_SESSION_ASN1_VERSION) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNKNOWN_SSL_VERSION);\n        goto err;\n    }\n\n    if ((as->ssl_version >> 8) != SSL3_VERSION_MAJOR\n        && (as->ssl_version >> 8) != DTLS1_VERSION_MAJOR\n        && as->ssl_version != DTLS1_BAD_VER) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);\n        goto err;\n    }\n\n    ret->ssl_version = (int)as->ssl_version;\n\n    if (as->cipher->length != 2) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_CIPHER_CODE_WRONG_LENGTH);\n        goto err;\n    }\n\n    p = as->cipher->data;\n    id = 0x03000000L | ((unsigned long)p[0] << 8L) | (unsigned long)p[1];\n\n    ret->cipher = NULL;\n    ret->cipher_id = id;\n\n    if (!ssl_session_memcpy(ret->session_id, &ret->session_id_length,\n                            as->session_id, SSL3_MAX_SSL_SESSION_ID_LENGTH))\n        goto err;\n\n    if (!ssl_session_memcpy(ret->master_key, &tmpl,\n                            as->master_key, SSL_MAX_MASTER_KEY_LENGTH))\n        goto err;\n\n    ret->master_key_length = tmpl;\n\n    if (as->time != 0)\n        ret->time = as->time;\n    else\n        ret->time = (unsigned long)time(NULL);\n\n    if (as->timeout != 0)\n        ret->timeout = as->timeout;\n    else\n        ret->timeout = 3;\n\n    X509_free(ret->peer);\n    ret->peer = as->peer;\n    as->peer = NULL;\n\n    if (!ssl_session_memcpy(ret->sid_ctx, &ret->sid_ctx_length,\n                            as->session_id_context, SSL_MAX_SID_CTX_LENGTH))\n        goto err;\n\n    /* NB: this defaults to zero which is X509_V_OK */\n    ret->verify_result = as->verify_result;\n\n    if (!ssl_session_strndup(&ret->ext.hostname, as->tlsext_hostname))\n        goto err;\n\n#ifndef OPENSSL_NO_PSK\n    if (!ssl_session_strndup(&ret->psk_identity_hint, as->psk_identity_hint))\n        goto err;\n    if (!ssl_session_strndup(&ret->psk_identity, as->psk_identity))\n        goto err;\n#endif\n\n    ret->ext.tick_lifetime_hint = as->tlsext_tick_lifetime_hint;\n    ret->ext.tick_age_add = as->tlsext_tick_age_add;\n    if (as->tlsext_tick) {\n        ret->ext.tick = as->tlsext_tick->data;\n        ret->ext.ticklen = as->tlsext_tick->length;\n        as->tlsext_tick->data = NULL;\n    } else {\n        ret->ext.tick = NULL;\n    }\n#ifndef OPENSSL_NO_COMP\n    if (as->comp_id) {\n        if (as->comp_id->length != 1) {\n            SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_BAD_LENGTH);\n            goto err;\n        }\n        ret->compress_meth = as->comp_id->data[0];\n    } else {\n        ret->compress_meth = 0;\n    }\n#endif\n\n#ifndef OPENSSL_NO_SRP\n    if (!ssl_session_strndup(&ret->srp_username, as->srp_username))\n        goto err;\n#endif                          /* OPENSSL_NO_SRP */\n    /* Flags defaults to zero which is fine */\n    ret->flags = as->flags;\n\n    M_ASN1_free_of(as, SSL_SESSION_ASN1);\n\n    if ((a != NULL) && (*a == NULL))\n        *a = ret;\n    *pp = p;\n    return ret;\n\n err:\n    M_ASN1_free_of(as, SSL_SESSION_ASN1);\n    if ((a == NULL) || (*a != ret))\n        SSL_SESSION_free(ret);\n    return NULL;\n}", "patch_func_code": "SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,\n                             long length)\n{\n    long id;\n    size_t tmpl;\n    const unsigned char *p = *pp;\n    SSL_SESSION_ASN1 *as = NULL;\n    SSL_SESSION *ret = NULL;\n\n    as = d2i_SSL_SESSION_ASN1(NULL, &p, length);\n    /* ASN.1 code returns suitable error */\n    if (as == NULL)\n        goto err;\n\n    if (!a || !*a) {\n        ret = SSL_SESSION_new();\n        if (ret == NULL)\n            goto err;\n    } else {\n        ret = *a;\n    }\n\n    if (as->version != SSL_SESSION_ASN1_VERSION) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNKNOWN_SSL_VERSION);\n        goto err;\n    }\n\n    if ((as->ssl_version >> 8) != SSL3_VERSION_MAJOR\n        && (as->ssl_version >> 8) != DTLS1_VERSION_MAJOR\n        && as->ssl_version != DTLS1_BAD_VER) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);\n        goto err;\n    }\n\n    ret->ssl_version = (int)as->ssl_version;\n\n    if (as->cipher->length != 2) {\n        SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_CIPHER_CODE_WRONG_LENGTH);\n        goto err;\n    }\n\n    p = as->cipher->data;\n    id = 0x03000000L | ((unsigned long)p[0] << 8L) | (unsigned long)p[1];\n\n    ret->cipher_id = id;\n    ret->cipher = ssl3_get_cipher_by_id(id);\n    if (ret->cipher == NULL)\n        goto err;\n\n    if (!ssl_session_memcpy(ret->session_id, &ret->session_id_length,\n                            as->session_id, SSL3_MAX_SSL_SESSION_ID_LENGTH))\n        goto err;\n\n    if (!ssl_session_memcpy(ret->master_key, &tmpl,\n                            as->master_key, SSL_MAX_MASTER_KEY_LENGTH))\n        goto err;\n\n    ret->master_key_length = tmpl;\n\n    if (as->time != 0)\n        ret->time = as->time;\n    else\n        ret->time = (unsigned long)time(NULL);\n\n    if (as->timeout != 0)\n        ret->timeout = as->timeout;\n    else\n        ret->timeout = 3;\n\n    X509_free(ret->peer);\n    ret->peer = as->peer;\n    as->peer = NULL;\n\n    if (!ssl_session_memcpy(ret->sid_ctx, &ret->sid_ctx_length,\n                            as->session_id_context, SSL_MAX_SID_CTX_LENGTH))\n        goto err;\n\n    /* NB: this defaults to zero which is X509_V_OK */\n    ret->verify_result = as->verify_result;\n\n    if (!ssl_session_strndup(&ret->ext.hostname, as->tlsext_hostname))\n        goto err;\n\n#ifndef OPENSSL_NO_PSK\n    if (!ssl_session_strndup(&ret->psk_identity_hint, as->psk_identity_hint))\n        goto err;\n    if (!ssl_session_strndup(&ret->psk_identity, as->psk_identity))\n        goto err;\n#endif\n\n    ret->ext.tick_lifetime_hint = as->tlsext_tick_lifetime_hint;\n    ret->ext.tick_age_add = as->tlsext_tick_age_add;\n    if (as->tlsext_tick) {\n        ret->ext.tick = as->tlsext_tick->data;\n        ret->ext.ticklen = as->tlsext_tick->length;\n        as->tlsext_tick->data = NULL;\n    } else {\n        ret->ext.tick = NULL;\n    }\n#ifndef OPENSSL_NO_COMP\n    if (as->comp_id) {\n        if (as->comp_id->length != 1) {\n            SSLerr(SSL_F_D2I_SSL_SESSION, SSL_R_BAD_LENGTH);\n            goto err;\n        }\n        ret->compress_meth = as->comp_id->data[0];\n    } else {\n        ret->compress_meth = 0;\n    }\n#endif\n\n#ifndef OPENSSL_NO_SRP\n    if (!ssl_session_strndup(&ret->srp_username, as->srp_username))\n        goto err;\n#endif                          /* OPENSSL_NO_SRP */\n    /* Flags defaults to zero which is fine */\n    ret->flags = as->flags;\n\n    M_ASN1_free_of(as, SSL_SESSION_ASN1);\n\n    if ((a != NULL) && (*a == NULL))\n        *a = ret;\n    *pp = p;\n    return ret;\n\n err:\n    M_ASN1_free_of(as, SSL_SESSION_ASN1);\n    if ((a == NULL) || (*a != ret))\n        SSL_SESSION_free(ret);\n    return NULL;\n}", "before_change_lines": [45], "raw_before_change_lines": [45], "after_change_lines": [46, 47, 48], "raw_after_change_lines": [46, 47, 48], "bug_lines": [45], "added": [false], "idx": 378}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "10812----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1389c74ded70b29b6d46e0891261b1d841f4af9d_1.json----rsa_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1389c74ded70b29b6d46e0891261b1d841f4af9d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1389c74ded70b29b6d46e0891261b1d841f4af9d_1.json", "function_name": "rsa_main", "vul_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint ret=1;\n\tRSA *rsa=NULL;\n\tint i,badops=0;\n\tconst EVP_CIPHER *enc=NULL;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat,text=0,check=0,noout=0;\n\tint pubin = 0, pubout = 0;\n\tchar *infile,*outfile,*prog;\n\tchar *passin = NULL, *passout = NULL;\n\tint modulus=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-passin\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tpassin= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-envpassin\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\t\tif(!(passin= getenv(*(++argv))))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t \"Can't read environment variable %s\\n\",\n\t\t\t\t\t\t\t\t*argv);\n\t\t\t\tbadops = 1;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-envpassout\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\t\tif(!(passout= getenv(*(++argv))))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t \"Can't read environment variable %s\\n\",\n\t\t\t\t\t\t\t\t*argv);\n\t\t\t\tbadops = 1;\n\t\t\t\t}\n\t\t\targv++;\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-passout\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tpassout= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-pubin\") == 0)\n\t\t\tpubin=1;\n\t\telse if (strcmp(*argv,\"-pubout\") == 0)\n\t\t\tpubout=1;\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-modulus\") == 0)\n\t\t\tmodulus=1;\n\t\telse if (strcmp(*argv,\"-check\") == 0)\n\t\t\tcheck=1;\n\t\telse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg     input format - one of DER NET PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg    output format - one of DER NET PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg         input file\\n\");\n\t\tBIO_printf(bio_err,\" -passin arg     input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -envpassin arg  environment variable containing input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -in arg         input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg        output file\\n\");\n\t\tBIO_printf(bio_err,\" -passout arg    input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -envpassout arg environment variable containing input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -des            encrypt PEM output with cbc des\\n\");\n\t\tBIO_printf(bio_err,\" -des3           encrypt PEM output with ede cbc des using 168 bit key\\n\");\n#ifndef NO_IDEA\n\t\tBIO_printf(bio_err,\" -idea           encrypt PEM output with cbc idea\\n\");\n#endif\n\t\tBIO_printf(bio_err,\" -text           print the key in text\\n\");\n\t\tBIO_printf(bio_err,\" -noout          don't print key out\\n\");\n\t\tBIO_printf(bio_err,\" -modulus        print the RSA key modulus\\n\");\n\t\tBIO_printf(bio_err,\" -check          verify key consistency\\n\");\n\t\tBIO_printf(bio_err,\" -pubin          expect a public key in input file\\n\");\n\t\tBIO_printf(bio_err,\" -pubout         output a public key\\n\");\n\t\tgoto end;\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tBIO_printf(bio_err,\"read RSA private key\\n\");\n\tif\t(informat == FORMAT_ASN1) {\n\t\tif (pubin) rsa=d2i_RSAPublicKey_bio(in,NULL);\n\t\telse rsa=d2i_RSAPrivateKey_bio(in,NULL);\n\t}\n#ifndef NO_RC4\n\telse if (informat == FORMAT_NETSCAPE)\n\t\t{\n\t\tBUF_MEM *buf=NULL;\n\t\tunsigned char *p;\n\t\tint size=0;\n\n\t\tbuf=BUF_MEM_new();\n\t\tfor (;;)\n\t\t\t{\n\t\t\tif ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))\n\t\t\t\tgoto end;\n\t\t\ti=BIO_read(in,&(buf->data[size]),1024*10);\n\t\t\tsize+=i;\n\t\t\tif (i == 0) break;\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tperror(\"reading private key\");\n\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\tp=(unsigned char *)buf->data;\n\t\trsa=(RSA *)d2i_Netscape_RSA(NULL,&p,(long)size,NULL);\n\t\tBUF_MEM_free(buf);\n\t\t}\n#endif\n\telse if (informat == FORMAT_PEM) {\n\t\tif(pubin) rsa=PEM_read_bio_RSAPublicKey(in,NULL,NULL,NULL);\n\t\telse {\n\t\t\tif(passin) rsa=PEM_read_bio_RSAPrivateKey(in,NULL,\n\t\t\t\t\t\t\t\tkey_cb,passin);\n\t\t\telse rsa=PEM_read_bio_RSAPrivateKey(in,NULL,NULL,NULL);\n\t\t}\n\t}\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified for key\\n\");\n\t\tgoto end;\n\t\t}\n\tif (rsa == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load Key\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (outfile == NULL)\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (text) \n\t\tif (!RSA_print(out,rsa,0))\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\n\tif (modulus)\n\t\t{\n\t\tfprintf(stdout,\"Modulus=\");\n\t\tBN_print(out,rsa->n);\n\t\tfprintf(stdout,\"\\n\");\n\t\t}\n\n\tif (check)\n\t\t{\n\t\tint r = RSA_check_key(rsa);\n\n\t\tif (r == 1)\n\t\t\tBIO_printf(out,\"RSA key ok\\n\");\n\t\telse if (r == 0)\n\t\t\t{\n\t\t\tlong e;\n\n\t\t\twhile ((e = ERR_peek_error()) != 0 &&\n\t\t\t\tERR_GET_LIB(e) == ERR_LIB_RSA &&\n\t\t\t\tERR_GET_FUNC(e) == RSA_F_RSA_CHECK_KEY &&\n\t\t\t\tERR_GET_REASON(e) != ERR_R_MALLOC_FAILURE)\n\t\t\t\t{\n\t\t\t\tBIO_printf(out, \"RSA key error: %s\\n\", ERR_reason_error_string(e));\n\t\t\t\tERR_get_error(); /* remove e from error stack */\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif (r == -1 || ERR_peek_error() != 0) /* should happen only if r == -1 */\n\t\t\t{\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\t\n\tif (noout)\n\t\t{\n\t\tret = 0;\n\t\tgoto end;\n\t\t}\n\tBIO_printf(bio_err,\"writing RSA key\\n\");\n\tif \t(outformat == FORMAT_ASN1) {\n\t\tif(pubout || pubin) i=i2d_RSAPublicKey_bio(out,rsa);\n\t\telse i=i2d_RSAPrivateKey_bio(out,rsa);\n\t}\n#ifndef NO_RC4\n\telse if (outformat == FORMAT_NETSCAPE)\n\t\t{\n\t\tunsigned char *p,*pp;\n\t\tint size;\n\n\t\ti=1;\n\t\tsize=i2d_Netscape_RSA(rsa,NULL,NULL);\n\t\tif ((p=(unsigned char *)Malloc(size)) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"Malloc failure\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tpp=p;\n\t\ti2d_Netscape_RSA(rsa,&p,NULL);\n\t\tBIO_write(out,(char *)pp,size);\n\t\tFree(pp);\n\t\t}\n#endif\n\telse if (outformat == FORMAT_PEM) {\n\t\tif(pubout || pubin)\n\t\t    i=PEM_write_bio_RSAPublicKey(out,rsa);\n\t\telse {\n\t\t\tif(passout) i=PEM_write_bio_RSAPrivateKey(out,rsa,\n\t\t\t\t\t\tenc,NULL,0,key_cb,passout);\n\t\t\telse i=PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL,\n\t\t\t\t\t\t\t\t0,NULL,NULL);\n\t\t}\n\t} else\t{\n\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\tgoto end;\n\t\t}\n\tif (!i)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to write key\\n\");\n\t\tERR_print_errors(bio_err);\n\t\t}\n\telse\n\t\tret=0;\nend:\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free(out);\n\tif (rsa != NULL) RSA_free(rsa);\n\tEXIT(ret);\n\t}", "patch_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint ret=1;\n\tRSA *rsa=NULL;\n\tint i,badops=0;\n\tconst EVP_CIPHER *enc=NULL;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat,text=0,check=0,noout=0;\n\tint pubin = 0, pubout = 0;\n\tchar *infile,*outfile,*prog;\n\tchar *passin = NULL, *passout = NULL;\n\tint modulus=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-passin\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tpassin= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-envpassin\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\t\tif(!(passin= getenv(*(++argv))))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t \"Can't read environment variable %s\\n\",\n\t\t\t\t\t\t\t\t*argv);\n\t\t\t\tbadops = 1;\n\t\t\t\t}\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-envpassout\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\t\tif(!(passout= getenv(*(++argv))))\n\t\t\t\t{\n\t\t\t\tBIO_printf(bio_err,\n\t\t\t\t \"Can't read environment variable %s\\n\",\n\t\t\t\t\t\t\t\t*argv);\n\t\t\t\tbadops = 1;\n\t\t\t\t}\n\t\t\targv++;\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-passout\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tpassout= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-pubin\") == 0)\n\t\t\tpubin=1;\n\t\telse if (strcmp(*argv,\"-pubout\") == 0)\n\t\t\tpubout=1;\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-modulus\") == 0)\n\t\t\tmodulus=1;\n\t\telse if (strcmp(*argv,\"-check\") == 0)\n\t\t\tcheck=1;\n\t\telse if ((enc=EVP_get_cipherbyname(&(argv[0][1]))) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg     input format - one of DER NET PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg    output format - one of DER NET PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg         input file\\n\");\n\t\tBIO_printf(bio_err,\" -passin arg     input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -envpassin arg  environment variable containing input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -in arg         input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg        output file\\n\");\n\t\tBIO_printf(bio_err,\" -passout arg    input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -envpassout arg environment variable containing input file pass phrase\\n\");\n\t\tBIO_printf(bio_err,\" -des            encrypt PEM output with cbc des\\n\");\n\t\tBIO_printf(bio_err,\" -des3           encrypt PEM output with ede cbc des using 168 bit key\\n\");\n#ifndef NO_IDEA\n\t\tBIO_printf(bio_err,\" -idea           encrypt PEM output with cbc idea\\n\");\n#endif\n\t\tBIO_printf(bio_err,\" -text           print the key in text\\n\");\n\t\tBIO_printf(bio_err,\" -noout          don't print key out\\n\");\n\t\tBIO_printf(bio_err,\" -modulus        print the RSA key modulus\\n\");\n\t\tBIO_printf(bio_err,\" -check          verify key consistency\\n\");\n\t\tBIO_printf(bio_err,\" -pubin          expect a public key in input file\\n\");\n\t\tBIO_printf(bio_err,\" -pubout         output a public key\\n\");\n\t\tgoto end;\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tif(check && pubin) {\n\t\tBIO_printf(bio_err, \"Only private keys can be checked\\n\");\n\t\tgoto end;\n\t}\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tBIO_printf(bio_err,\"read RSA key\\n\");\n\tif\t(informat == FORMAT_ASN1) {\n\t\tif (pubin) rsa=d2i_RSA_PUBKEY_bio(in,NULL);\n\t\telse rsa=d2i_RSAPrivateKey_bio(in,NULL);\n\t}\n#ifndef NO_RC4\n\telse if (informat == FORMAT_NETSCAPE)\n\t\t{\n\t\tBUF_MEM *buf=NULL;\n\t\tunsigned char *p;\n\t\tint size=0;\n\n\t\tbuf=BUF_MEM_new();\n\t\tfor (;;)\n\t\t\t{\n\t\t\tif ((buf == NULL) || (!BUF_MEM_grow(buf,size+1024*10)))\n\t\t\t\tgoto end;\n\t\t\ti=BIO_read(in,&(buf->data[size]),1024*10);\n\t\t\tsize+=i;\n\t\t\tif (i == 0) break;\n\t\t\tif (i < 0)\n\t\t\t\t{\n\t\t\t\tperror(\"reading private key\");\n\t\t\t\tBUF_MEM_free(buf);\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\tp=(unsigned char *)buf->data;\n\t\trsa=(RSA *)d2i_Netscape_RSA(NULL,&p,(long)size,NULL);\n\t\tBUF_MEM_free(buf);\n\t\t}\n#endif\n\telse if (informat == FORMAT_PEM) {\n\t\tif(pubin) rsa=PEM_read_bio_RSA_PUBKEY(in,NULL,NULL,NULL);\n\t\telse {\n\t\t\tif(passin) rsa=PEM_read_bio_RSAPrivateKey(in,NULL,\n\t\t\t\t\t\t\t\tkey_cb,passin);\n\t\t\telse rsa=PEM_read_bio_RSAPrivateKey(in,NULL,NULL,NULL);\n\t\t}\n\t}\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified for key\\n\");\n\t\tgoto end;\n\t\t}\n\tif (rsa == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load key\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (outfile == NULL)\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (text) \n\t\tif (!RSA_print(out,rsa,0))\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\n\tif (modulus)\n\t\t{\n\t\tBIO_printf(out,\"Modulus=\");\n\t\tBN_print(out,rsa->n);\n\t\tBIO_printf(out,\"\\n\");\n\t\t}\n\n\tif (check)\n\t\t{\n\t\tint r = RSA_check_key(rsa);\n\n\t\tif (r == 1)\n\t\t\tBIO_printf(out,\"RSA key ok\\n\");\n\t\telse if (r == 0)\n\t\t\t{\n\t\t\tlong e;\n\n\t\t\twhile ((e = ERR_peek_error()) != 0 &&\n\t\t\t\tERR_GET_LIB(e) == ERR_LIB_RSA &&\n\t\t\t\tERR_GET_FUNC(e) == RSA_F_RSA_CHECK_KEY &&\n\t\t\t\tERR_GET_REASON(e) != ERR_R_MALLOC_FAILURE)\n\t\t\t\t{\n\t\t\t\tBIO_printf(out, \"RSA key error: %s\\n\", ERR_reason_error_string(e));\n\t\t\t\tERR_get_error(); /* remove e from error stack */\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif (r == -1 || ERR_peek_error() != 0) /* should happen only if r == -1 */\n\t\t\t{\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\t\n\tif (noout)\n\t\t{\n\t\tret = 0;\n\t\tgoto end;\n\t\t}\n\tBIO_printf(bio_err,\"writing RSA key\\n\");\n\tif \t(outformat == FORMAT_ASN1) {\n\t\tif(pubout || pubin) i=i2d_RSA_PUBKEY_bio(out,rsa);\n\t\telse i=i2d_RSAPrivateKey_bio(out,rsa);\n\t}\n#ifndef NO_RC4\n\telse if (outformat == FORMAT_NETSCAPE)\n\t\t{\n\t\tunsigned char *p,*pp;\n\t\tint size;\n\n\t\ti=1;\n\t\tsize=i2d_Netscape_RSA(rsa,NULL,NULL);\n\t\tif ((p=(unsigned char *)Malloc(size)) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"Malloc failure\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tpp=p;\n\t\ti2d_Netscape_RSA(rsa,&p,NULL);\n\t\tBIO_write(out,(char *)pp,size);\n\t\tFree(pp);\n\t\t}\n#endif\n\telse if (outformat == FORMAT_PEM) {\n\t\tif(pubout || pubin)\n\t\t    i=PEM_write_bio_RSA_PUBKEY(out,rsa);\n\t\telse {\n\t\t\tif(passout) i=PEM_write_bio_RSAPrivateKey(out,rsa,\n\t\t\t\t\t\tenc,NULL,0,key_cb,passout);\n\t\t\telse i=PEM_write_bio_RSAPrivateKey(out,rsa,enc,NULL,\n\t\t\t\t\t\t\t\t0,NULL,NULL);\n\t\t}\n\t} else\t{\n\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\tgoto end;\n\t\t}\n\tif (!i)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to write key\\n\");\n\t\tERR_print_errors(bio_err);\n\t\t}\n\telse\n\t\tret=0;\nend:\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free(out);\n\tif (rsa != NULL) RSA_free(rsa);\n\tEXIT(ret);\n\t}", "before_change_lines": [154, 156, 187, 201, 227, 229, 266, 290], "raw_before_change_lines": [154, 156, 187, 201, 227, 229, 266, 290], "after_change_lines": [135, 136, 137, 138, 159, 161, 192, 206, 232, 234, 271, 295], "raw_after_change_lines": [135, 136, 137, 138, 139, 159, 161, 192, 206, 232, 234, 271, 295], "bug_lines": [154, 156, 187, 201, 227, 229, 266, 290], "added": [false, false, false, false, false, false, false, false], "idx": 379}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10832----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_145a8cda95cd7f614f15b278c10ef2a2f68af658_1.json----fmtint", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_145a8cda95cd7f614f15b278c10ef2a2f68af658_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_145a8cda95cd7f614f15b278c10ef2a2f68af658_1.json", "function_name": "fmtint", "vul_func_code": "static void\nfmtint(\n    char *buffer,\n    size_t *currlen,\n    size_t maxlen,\n    LLONG value,\n    int base,\n    int min,\n    int max,\n    int flags)\n{\n    int signvalue = 0;\n    unsigned LLONG uvalue;\n    char convert[20];\n    int place = 0;\n    int spadlen = 0;\n    int zpadlen = 0;\n    int caps = 0;\n\n    if (max < 0)\n        max = 0;\n    uvalue = value;\n    if (!(flags & DP_F_UNSIGNED)) {\n        if (value < 0) {\n            signvalue = '-';\n            uvalue = -value;\n        } else if (flags & DP_F_PLUS)\n            signvalue = '+';\n        else if (flags & DP_F_SPACE)\n            signvalue = ' ';\n    }\n    if (flags & DP_F_UP)\n        caps = 1;\n    do {\n        convert[place++] =\n            (caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\")\n            [uvalue % (unsigned) base];\n        uvalue = (uvalue / (unsigned) base);\n    } while (uvalue && (place < 20));\n    if (place == 20)\n        place--;\n    convert[place] = 0;\n\n    zpadlen = max - place;\n    spadlen = min - MAX(max, place) - (signvalue ? 1 : 0);\n    if (zpadlen < 0)\n        zpadlen = 0;\n    if (spadlen < 0)\n        spadlen = 0;\n    if (flags & DP_F_ZERO) {\n        zpadlen = MAX(zpadlen, spadlen);\n        spadlen = 0;\n    }\n    if (flags & DP_F_MINUS)\n        spadlen = -spadlen;\n\n    /* spaces */\n    while (spadlen > 0) {\n        dopr_outch(buffer, currlen, maxlen, ' ');\n        --spadlen;\n    }\n\n    /* sign */\n    if (signvalue)\n        dopr_outch(buffer, currlen, maxlen, signvalue);\n\n    /* zeros */\n    if (zpadlen > 0) {\n        while (zpadlen > 0) {\n            dopr_outch(buffer, currlen, maxlen, '0');\n            --zpadlen;\n        }\n    }\n    /* digits */\n    while (place > 0)\n        dopr_outch(buffer, currlen, maxlen, convert[--place]);\n\n    /* left justified spaces */\n    while (spadlen < 0) {\n        dopr_outch(buffer, currlen, maxlen, ' ');\n        ++spadlen;\n    }\n    return;\n}", "patch_func_code": "static void\nfmtint(\n    void (*outch_fn)(char **, size_t *, size_t *, int),\n    char **buffer,\n    size_t *currlen,\n    size_t *maxlen,\n    LLONG value,\n    int base,\n    int min,\n    int max,\n    int flags)\n{\n    int signvalue = 0;\n    unsigned LLONG uvalue;\n    char convert[20];\n    int place = 0;\n    int spadlen = 0;\n    int zpadlen = 0;\n    int caps = 0;\n\n    if (max < 0)\n        max = 0;\n    uvalue = value;\n    if (!(flags & DP_F_UNSIGNED)) {\n        if (value < 0) {\n            signvalue = '-';\n            uvalue = -value;\n        } else if (flags & DP_F_PLUS)\n            signvalue = '+';\n        else if (flags & DP_F_SPACE)\n            signvalue = ' ';\n    }\n    if (flags & DP_F_UP)\n        caps = 1;\n    do {\n        convert[place++] =\n            (caps ? \"0123456789ABCDEF\" : \"0123456789abcdef\")\n            [uvalue % (unsigned) base];\n        uvalue = (uvalue / (unsigned) base);\n    } while (uvalue && (place < 20));\n    if (place == 20)\n        place--;\n    convert[place] = 0;\n\n    zpadlen = max - place;\n    spadlen = min - MAX(max, place) - (signvalue ? 1 : 0);\n    if (zpadlen < 0)\n        zpadlen = 0;\n    if (spadlen < 0)\n        spadlen = 0;\n    if (flags & DP_F_ZERO) {\n        zpadlen = MAX(zpadlen, spadlen);\n        spadlen = 0;\n    }\n    if (flags & DP_F_MINUS)\n        spadlen = -spadlen;\n\n    /* spaces */\n    while (spadlen > 0) {\n        (*outch_fn)(buffer, currlen, maxlen, ' ');\n        --spadlen;\n    }\n\n    /* sign */\n    if (signvalue)\n        (*outch_fn)(buffer, currlen, maxlen, signvalue);\n\n    /* zeros */\n    if (zpadlen > 0) {\n        while (zpadlen > 0) {\n            (*outch_fn)(buffer, currlen, maxlen, '0');\n            --zpadlen;\n        }\n    }\n    /* digits */\n    while (place > 0)\n        (*outch_fn)(buffer, currlen, maxlen, convert[--place]);\n\n    /* left justified spaces */\n    while (spadlen < 0) {\n        (*outch_fn)(buffer, currlen, maxlen, ' ');\n        ++spadlen;\n    }\n    return;\n}", "before_change_lines": [3, 5, 59, 65, 70, 76, 80], "raw_before_change_lines": [3, 5, 59, 65, 70, 76, 80], "after_change_lines": [3, 4, 6, 60, 66, 71, 77, 81], "raw_after_change_lines": [3, 4, 6, 60, 66, 71, 77, 81], "bug_lines": [3, 5, 59, 65, 70, 76, 80], "added": [false, false, false, false, false, false, false], "idx": 380}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L3", "filepath_func": "10842----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1494534c015c78a18b7eb1def3f3aa93968cf8b1_1.json----BN_MONT_CTX_set", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1494534c015c78a18b7eb1def3f3aa93968cf8b1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1494534c015c78a18b7eb1def3f3aa93968cf8b1_1.json", "function_name": "BN_MONT_CTX_set", "vul_func_code": "int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)\n{\n    int ret = 0;\n    BIGNUM *Ri, *R;\n\n    if (BN_is_zero(mod))\n        return 0;\n\n    BN_CTX_start(ctx);\n    if ((Ri = BN_CTX_get(ctx)) == NULL)\n        goto err;\n    R = &(mont->RR);            /* grab RR as a temp */\n    if (!BN_copy(&(mont->N), mod))\n        goto err;               /* Set N */\n    if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\n        BN_set_flags(&(mont->N), BN_FLG_CONSTTIME);\n    mont->N.neg = 0;\n\n#ifdef MONT_WORD\n    {\n        BIGNUM tmod;\n        BN_ULONG buf[2];\n\n        bn_init(&tmod);\n        tmod.d = buf;\n        tmod.dmax = 2;\n        tmod.neg = 0;\n\n        if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\n            BN_set_flags(&tmod, BN_FLG_CONSTTIME);\n\n        mont->ri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2;\n\n# if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)\n        /*\n         * Only certain BN_BITS2<=32 platforms actually make use of n0[1],\n         * and we could use the #else case (with a shorter R value) for the\n         * others.  However, currently only the assembler files do know which\n         * is which.\n         */\n\n        BN_zero(R);\n        if (!(BN_set_bit(R, 2 * BN_BITS2)))\n            goto err;\n\n        tmod.top = 0;\n        if ((buf[0] = mod->d[0]))\n            tmod.top = 1;\n        if ((buf[1] = mod->top > 1 ? mod->d[1] : 0))\n            tmod.top = 2;\n\n        if (BN_is_one(&tmod))\n            BN_zero(Ri);\n        else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, 2 * BN_BITS2))\n            goto err;           /* R*Ri */\n        if (!BN_is_zero(Ri)) {\n            if (!BN_sub_word(Ri, 1))\n                goto err;\n        } else {                /* if N mod word size == 1 */\n\n            if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL)\n                goto err;\n            /* Ri-- (mod double word size) */\n            Ri->neg = 0;\n            Ri->d[0] = BN_MASK2;\n            Ri->d[1] = BN_MASK2;\n            Ri->top = 2;\n        }\n        if (!BN_div(Ri, NULL, Ri, &tmod, ctx))\n            goto err;\n        /*\n         * Ni = (R*Ri-1)/N, keep only couple of least significant words:\n         */\n        mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;\n        mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0;\n# else\n        BN_zero(R);\n        if (!(BN_set_bit(R, BN_BITS2)))\n            goto err;           /* R */\n\n        buf[0] = mod->d[0];     /* tmod = N mod word size */\n        buf[1] = 0;\n        tmod.top = buf[0] != 0 ? 1 : 0;\n        /* Ri = R^-1 mod N */\n        if (BN_is_one(&tmod))\n            BN_zero(Ri);\n        else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, BN_BITS2))\n            goto err;           /* R*Ri */\n        if (!BN_is_zero(Ri)) {\n            if (!BN_sub_word(Ri, 1))\n                goto err;\n        } else {                /* if N mod word size == 1 */\n\n            if (!BN_set_word(Ri, BN_MASK2))\n                goto err;       /* Ri-- (mod word size) */\n        }\n        if (!BN_div(Ri, NULL, Ri, &tmod, ctx))\n            goto err;\n        /*\n         * Ni = (R*Ri-1)/N, keep only least significant word:\n         */\n        mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;\n        mont->n0[1] = 0;\n# endif\n    }\n#else                           /* !MONT_WORD */\n    {                           /* bignum version */\n        mont->ri = BN_num_bits(&mont->N);\n        BN_zero(R);\n        if (!BN_set_bit(R, mont->ri))\n            goto err;           /* R = 2^ri */\n        /* Ri = R^-1 mod N */\n        if ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, mont->ri))\n            goto err;           /* R*Ri */\n        if (!BN_sub_word(Ri, 1))\n            goto err;\n        /*\n         * Ni = (R*Ri-1) / N\n         */\n        if (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx))\n            goto err;\n    }\n#endif\n\n    /* setup RR for conversions */\n    BN_zero(&(mont->RR));\n    if (!BN_set_bit(&(mont->RR), mont->ri * 2))\n        goto err;\n    if (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx))\n        goto err;\n\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}", "patch_func_code": "int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx)\n{\n    int i, ret = 0;\n    BIGNUM *Ri, *R;\n\n    if (BN_is_zero(mod))\n        return 0;\n\n    BN_CTX_start(ctx);\n    if ((Ri = BN_CTX_get(ctx)) == NULL)\n        goto err;\n    R = &(mont->RR);            /* grab RR as a temp */\n    if (!BN_copy(&(mont->N), mod))\n        goto err;               /* Set N */\n    if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\n        BN_set_flags(&(mont->N), BN_FLG_CONSTTIME);\n    mont->N.neg = 0;\n\n#ifdef MONT_WORD\n    {\n        BIGNUM tmod;\n        BN_ULONG buf[2];\n\n        bn_init(&tmod);\n        tmod.d = buf;\n        tmod.dmax = 2;\n        tmod.neg = 0;\n\n        if (BN_get_flags(mod, BN_FLG_CONSTTIME) != 0)\n            BN_set_flags(&tmod, BN_FLG_CONSTTIME);\n\n        mont->ri = (BN_num_bits(mod) + (BN_BITS2 - 1)) / BN_BITS2 * BN_BITS2;\n\n# if defined(OPENSSL_BN_ASM_MONT) && (BN_BITS2<=32)\n        /*\n         * Only certain BN_BITS2<=32 platforms actually make use of n0[1],\n         * and we could use the #else case (with a shorter R value) for the\n         * others.  However, currently only the assembler files do know which\n         * is which.\n         */\n\n        BN_zero(R);\n        if (!(BN_set_bit(R, 2 * BN_BITS2)))\n            goto err;\n\n        tmod.top = 0;\n        if ((buf[0] = mod->d[0]))\n            tmod.top = 1;\n        if ((buf[1] = mod->top > 1 ? mod->d[1] : 0))\n            tmod.top = 2;\n\n        if (BN_is_one(&tmod))\n            BN_zero(Ri);\n        else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, 2 * BN_BITS2))\n            goto err;           /* R*Ri */\n        if (!BN_is_zero(Ri)) {\n            if (!BN_sub_word(Ri, 1))\n                goto err;\n        } else {                /* if N mod word size == 1 */\n\n            if (bn_expand(Ri, (int)sizeof(BN_ULONG) * 2) == NULL)\n                goto err;\n            /* Ri-- (mod double word size) */\n            Ri->neg = 0;\n            Ri->d[0] = BN_MASK2;\n            Ri->d[1] = BN_MASK2;\n            Ri->top = 2;\n        }\n        if (!BN_div(Ri, NULL, Ri, &tmod, ctx))\n            goto err;\n        /*\n         * Ni = (R*Ri-1)/N, keep only couple of least significant words:\n         */\n        mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;\n        mont->n0[1] = (Ri->top > 1) ? Ri->d[1] : 0;\n# else\n        BN_zero(R);\n        if (!(BN_set_bit(R, BN_BITS2)))\n            goto err;           /* R */\n\n        buf[0] = mod->d[0];     /* tmod = N mod word size */\n        buf[1] = 0;\n        tmod.top = buf[0] != 0 ? 1 : 0;\n        /* Ri = R^-1 mod N */\n        if (BN_is_one(&tmod))\n            BN_zero(Ri);\n        else if ((BN_mod_inverse(Ri, R, &tmod, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, BN_BITS2))\n            goto err;           /* R*Ri */\n        if (!BN_is_zero(Ri)) {\n            if (!BN_sub_word(Ri, 1))\n                goto err;\n        } else {                /* if N mod word size == 1 */\n\n            if (!BN_set_word(Ri, BN_MASK2))\n                goto err;       /* Ri-- (mod word size) */\n        }\n        if (!BN_div(Ri, NULL, Ri, &tmod, ctx))\n            goto err;\n        /*\n         * Ni = (R*Ri-1)/N, keep only least significant word:\n         */\n        mont->n0[0] = (Ri->top > 0) ? Ri->d[0] : 0;\n        mont->n0[1] = 0;\n# endif\n    }\n#else                           /* !MONT_WORD */\n    {                           /* bignum version */\n        mont->ri = BN_num_bits(&mont->N);\n        BN_zero(R);\n        if (!BN_set_bit(R, mont->ri))\n            goto err;           /* R = 2^ri */\n        /* Ri = R^-1 mod N */\n        if ((BN_mod_inverse(Ri, R, &mont->N, ctx)) == NULL)\n            goto err;\n        if (!BN_lshift(Ri, Ri, mont->ri))\n            goto err;           /* R*Ri */\n        if (!BN_sub_word(Ri, 1))\n            goto err;\n        /*\n         * Ni = (R*Ri-1) / N\n         */\n        if (!BN_div(&(mont->Ni), NULL, Ri, &mont->N, ctx))\n            goto err;\n    }\n#endif\n\n    /* setup RR for conversions */\n    BN_zero(&(mont->RR));\n    if (!BN_set_bit(&(mont->RR), mont->ri * 2))\n        goto err;\n    if (!BN_mod(&(mont->RR), &(mont->RR), &(mont->N), ctx))\n        goto err;\n\n    for (i = mont->RR.top, ret = mont->N.top; i < ret; i++)\n        mont->RR.d[i] = 0;\n    mont->RR.top = ret;\n    mont->RR.flags |= BN_FLG_FIXED_TOP;\n\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    return ret;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3, 138, 139, 140, 141], "raw_after_change_lines": [3, 138, 139, 140, 141, 142], "bug_lines": [3], "added": [false], "idx": 381}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10885----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_15eb8dda52298b0c86aa61aefebb1523ec61194c_1.json----BN_exp", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_15eb8dda52298b0c86aa61aefebb1523ec61194c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_15eb8dda52298b0c86aa61aefebb1523ec61194c_1.json", "function_name": "BN_exp", "vul_func_code": "int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n{\n    int i, bits, ret = 0;\n    BIGNUM *v, *rr;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    BN_CTX_start(ctx);\n    if ((r == a) || (r == p))\n        rr = BN_CTX_get(ctx);\n    else\n        rr = r;\n    v = BN_CTX_get(ctx);\n    if (rr == NULL || v == NULL)\n        goto err;\n\n    if (BN_copy(v, a) == NULL)\n        goto err;\n    bits = BN_num_bits(p);\n\n    if (BN_is_odd(p)) {\n        if (BN_copy(rr, a) == NULL)\n            goto err;\n    } else {\n        if (!BN_one(rr))\n            goto err;\n    }\n\n    for (i = 1; i < bits; i++) {\n        if (!BN_sqr(v, v, ctx))\n            goto err;\n        if (BN_is_bit_set(p, i)) {\n            if (!BN_mul(rr, rr, v, ctx))\n                goto err;\n        }\n    }\n    ret = 1;\n err:\n    if (r != rr)\n        BN_copy(r, rr);\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return (ret);\n}", "patch_func_code": "int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n{\n    int i, bits, ret = 0;\n    BIGNUM *v, *rr;\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_EXP, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    BN_CTX_start(ctx);\n    if ((r == a) || (r == p))\n        rr = BN_CTX_get(ctx);\n    else\n        rr = r;\n    v = BN_CTX_get(ctx);\n    if (rr == NULL || v == NULL)\n        goto err;\n\n    if (BN_copy(v, a) == NULL)\n        goto err;\n    bits = BN_num_bits(p);\n\n    if (BN_is_odd(p)) {\n        if (BN_copy(rr, a) == NULL)\n            goto err;\n    } else {\n        if (!BN_one(rr))\n            goto err;\n    }\n\n    for (i = 1; i < bits; i++) {\n        if (!BN_sqr(v, v, ctx))\n            goto err;\n        if (BN_is_bit_set(p, i)) {\n            if (!BN_mul(rr, rr, v, ctx))\n                goto err;\n        }\n    }\n    if (r != rr)\n        BN_copy(r, rr);\n    ret = 1;\n err:\n    BN_CTX_end(ctx);\n    bn_check_top(r);\n    return (ret);\n}", "before_change_lines": [41, 42], "raw_before_change_lines": [41, 42], "after_change_lines": [43, 44], "raw_after_change_lines": [43, 44], "bug_lines": [41, 42], "added": [false, false], "idx": 382}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10895----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_160d7256cdbd1ef5bd40b4524626dd2db2d282ab_1.json----X509_VERIFY_PARAM_inherit", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_160d7256cdbd1ef5bd40b4524626dd2db2d282ab_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_160d7256cdbd1ef5bd40b4524626dd2db2d282ab_1.json", "function_name": "X509_VERIFY_PARAM_inherit", "vul_func_code": "int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest,\n\t\t\t\t\t\tconst X509_VERIFY_PARAM *src)\n\t{\n\tunsigned long inh_flags;\n\tint to_default, to_overwrite;\n\tif (!src)\n\t\treturn 1;\n\tinh_flags = dest->inh_flags | src->inh_flags;\n\n\tif (inh_flags & X509_VP_FLAG_ONCE)\n\t\tdest->inh_flags = 0;\n\n\tif (inh_flags & X509_VP_FLAG_LOCKED)\n\t\treturn 1;\n\n\tif (inh_flags & X509_VP_FLAG_DEFAULT)\n\t\tto_default = 1;\n\telse\n\t\tto_default = 0;\n\n\tif (inh_flags & X509_VP_FLAG_OVERWRITE)\n\t\tto_overwrite = 1;\n\telse\n\t\tto_overwrite = 0;\n\n\tx509_verify_param_copy(purpose, 0);\n\tx509_verify_param_copy(trust, 0);\n\tx509_verify_param_copy(depth, -1);\n\n\t/* If overwrite or check time not set, copy across */\n\n\tif (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME))\n\t\t{\n\t\tdest->check_time = src->check_time;\n\t\tdest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;\n\t\t/* Don't need to copy flag: that is done below */\n\t\t}\n\n\tif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\n\t\tdest->flags = 0;\n\n\tdest->flags |= src->flags;\n\n\tif (test_x509_verify_param_copy(policies, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy(host, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_host(dest, src->host, src->hostlen))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy(email, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_email(dest, src->email, src->emaillen))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy(ip, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_ip(dest, src->ip, src->iplen))\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}", "patch_func_code": "int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *dest,\n\t\t\t\t\t\tconst X509_VERIFY_PARAM *src)\n\t{\n\tunsigned long inh_flags;\n\tint to_default, to_overwrite;\n\tX509_VERIFY_PARAM_ID *id;\n\tif (!src)\n\t\treturn 1;\n\tid = src->id;\n\tinh_flags = dest->inh_flags | src->inh_flags;\n\n\tif (inh_flags & X509_VP_FLAG_ONCE)\n\t\tdest->inh_flags = 0;\n\n\tif (inh_flags & X509_VP_FLAG_LOCKED)\n\t\treturn 1;\n\n\tif (inh_flags & X509_VP_FLAG_DEFAULT)\n\t\tto_default = 1;\n\telse\n\t\tto_default = 0;\n\n\tif (inh_flags & X509_VP_FLAG_OVERWRITE)\n\t\tto_overwrite = 1;\n\telse\n\t\tto_overwrite = 0;\n\n\tx509_verify_param_copy(purpose, 0);\n\tx509_verify_param_copy(trust, 0);\n\tx509_verify_param_copy(depth, -1);\n\n\t/* If overwrite or check time not set, copy across */\n\n\tif (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME))\n\t\t{\n\t\tdest->check_time = src->check_time;\n\t\tdest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;\n\t\t/* Don't need to copy flag: that is done below */\n\t\t}\n\n\tif (inh_flags & X509_VP_FLAG_RESET_FLAGS)\n\t\tdest->flags = 0;\n\n\tdest->flags |= src->flags;\n\n\tif (test_x509_verify_param_copy(policies, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy_id(host, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_host(dest, id->host, id->hostlen))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy_id(email, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_email(dest, id->email, id->emaillen))\n\t\t\treturn 0;\n\t\t}\n\n\tif (test_x509_verify_param_copy_id(ip, NULL))\n\t\t{\n\t\tif (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))\n\t\t\treturn 0;\n\t\t}\n\n\treturn 1;\n\t}", "before_change_lines": [50, 52, 56, 58, 62, 64], "raw_before_change_lines": [50, 52, 56, 58, 62, 64], "after_change_lines": [6, 9, 52, 54, 58, 60, 64, 66], "raw_after_change_lines": [6, 9, 52, 54, 58, 60, 64, 66], "bug_lines": [50, 52, 56, 58, 62, 64], "added": [false, false, false, false, false, false], "idx": 383}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10907----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_168047b916a9c1a1fc58369ef355a8b6546f980a_1.json----BN_mod_exp_mont_word", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_168047b916a9c1a1fc58369ef355a8b6546f980a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_168047b916a9c1a1fc58369ef355a8b6546f980a_1.json", "function_name": "BN_mod_exp_mont_word", "vul_func_code": "int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    BN_MONT_CTX *mont = NULL;\n    int b, bits, ret = 0;\n    int r_is_one;\n    BN_ULONG w, next_w;\n    BIGNUM *d, *r, *t;\n    BIGNUM *swap_tmp;\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) && \\\n                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n    if (m->top == 1)\n        a %= m->d[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else\n            ret = BN_one(rr);\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (d == NULL || r == NULL || t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 >= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b >= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return (ret);\n}", "patch_func_code": "int BN_mod_exp_mont_word(BIGNUM *rr, BN_ULONG a, const BIGNUM *p,\n                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *in_mont)\n{\n    BN_MONT_CTX *mont = NULL;\n    int b, bits, ret = 0;\n    int r_is_one;\n    BN_ULONG w, next_w;\n    BIGNUM *d, *r, *t;\n    BIGNUM *swap_tmp;\n#define BN_MOD_MUL_WORD(r, w, m) \\\n                (BN_mul_word(r, (w)) && \\\n                (/* BN_ucmp(r, (m)) < 0 ? 1 :*/  \\\n                        (BN_mod(t, r, m, ctx) && (swap_tmp = r, r = t, t = swap_tmp, 1))))\n    /*\n     * BN_MOD_MUL_WORD is only used with 'w' large, so the BN_ucmp test is\n     * probably more overhead than always using BN_mod (which uses BN_copy if\n     * a similar test returns true).\n     */\n    /*\n     * We can use BN_mod and do not need BN_nnmod because our accumulator is\n     * never negative (the result of BN_mod does not depend on the sign of\n     * the modulus).\n     */\n#define BN_TO_MONTGOMERY_WORD(r, w, mont) \\\n                (BN_set_word(r, (w)) && BN_to_montgomery(r, r, (mont), ctx))\n\n    if (BN_get_flags(p, BN_FLG_CONSTTIME) != 0) {\n        /* BN_FLG_CONSTTIME only supported by BN_mod_exp_mont() */\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return -1;\n    }\n\n    bn_check_top(p);\n    bn_check_top(m);\n\n    if (!BN_is_odd(m)) {\n        BNerr(BN_F_BN_MOD_EXP_MONT_WORD, BN_R_CALLED_WITH_EVEN_MODULUS);\n        return (0);\n    }\n    if (m->top == 1)\n        a %= m->d[0];           /* make sure that 'a' is reduced */\n\n    bits = BN_num_bits(p);\n    if (bits == 0) {\n        /* x**0 mod 1 is still zero. */\n        if (BN_is_one(m)) {\n            ret = 1;\n            BN_zero(rr);\n        } else {\n            ret = BN_one(rr);\n        }\n        return ret;\n    }\n    if (a == 0) {\n        BN_zero(rr);\n        ret = 1;\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    d = BN_CTX_get(ctx);\n    r = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    if (d == NULL || r == NULL || t == NULL)\n        goto err;\n\n    if (in_mont != NULL)\n        mont = in_mont;\n    else {\n        if ((mont = BN_MONT_CTX_new()) == NULL)\n            goto err;\n        if (!BN_MONT_CTX_set(mont, m, ctx))\n            goto err;\n    }\n\n    r_is_one = 1;               /* except for Montgomery factor */\n\n    /* bits-1 >= 0 */\n\n    /* The result is accumulated in the product r*w. */\n    w = a;                      /* bit 'bits-1' of 'p' is always set */\n    for (b = bits - 2; b >= 0; b--) {\n        /* First, square r*w. */\n        next_w = w * w;\n        if ((next_w / w) != w) { /* overflow */\n            if (r_is_one) {\n                if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                    goto err;\n                r_is_one = 0;\n            } else {\n                if (!BN_MOD_MUL_WORD(r, w, m))\n                    goto err;\n            }\n            next_w = 1;\n        }\n        w = next_w;\n        if (!r_is_one) {\n            if (!BN_mod_mul_montgomery(r, r, r, mont, ctx))\n                goto err;\n        }\n\n        /* Second, multiply r*w by 'a' if exponent bit is set. */\n        if (BN_is_bit_set(p, b)) {\n            next_w = w * a;\n            if ((next_w / a) != w) { /* overflow */\n                if (r_is_one) {\n                    if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                        goto err;\n                    r_is_one = 0;\n                } else {\n                    if (!BN_MOD_MUL_WORD(r, w, m))\n                        goto err;\n                }\n                next_w = a;\n            }\n            w = next_w;\n        }\n    }\n\n    /* Finally, set r:=r*w. */\n    if (w != 1) {\n        if (r_is_one) {\n            if (!BN_TO_MONTGOMERY_WORD(r, w, mont))\n                goto err;\n            r_is_one = 0;\n        } else {\n            if (!BN_MOD_MUL_WORD(r, w, m))\n                goto err;\n        }\n    }\n\n    if (r_is_one) {             /* can happen only if a == 1 */\n        if (!BN_one(rr))\n            goto err;\n    } else {\n        if (!BN_from_montgomery(rr, r, mont, ctx))\n            goto err;\n    }\n    ret = 1;\n err:\n    if (in_mont == NULL)\n        BN_MONT_CTX_free(mont);\n    BN_CTX_end(ctx);\n    bn_check_top(rr);\n    return (ret);\n}", "before_change_lines": [49], "raw_before_change_lines": [49], "after_change_lines": [49, 51], "raw_after_change_lines": [49, 51], "bug_lines": [49], "added": [false], "idx": 384}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10930----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_175a5b06518602e4c080ef6264b90a991bce880d_1.json----ssl3_get_finished", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_175a5b06518602e4c080ef6264b90a991bce880d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_175a5b06518602e4c080ef6264b90a991bce880d_1.json", "function_name": "ssl3_get_finished", "vul_func_code": "int ssl3_get_finished(SSL *s, int a, int b)\n{\n    int al, i, ok;\n    long n;\n    unsigned char *p;\n\n#ifdef OPENSSL_NO_NEXTPROTONEG\n    /*\n     * the mac has already been generated when we received the change cipher\n     * spec message and is in s->s3->tmp.peer_finish_md\n     */\n#endif\n\n    /* 64 argument should actually be 36+4 :-) */\n    n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    /* If this occurs, we have missed a message */\n    if (!s->s3->change_cipher_spec) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS);\n        goto f_err;\n    }\n    s->s3->change_cipher_spec = 0;\n\n    p = (unsigned char *)s->init_msg;\n    i = s->s3->tmp.peer_finish_md_len;\n\n    if (i != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_BAD_DIGEST_LENGTH);\n        goto f_err;\n    }\n\n    if (CRYPTO_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0) {\n        al = SSL_AD_DECRYPT_ERROR;\n        SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_DIGEST_CHECK_FAILED);\n        goto f_err;\n    }\n\n    /*\n     * Copy the finished so we can use it for renegotiation checks\n     */\n    if (s->type == SSL_ST_ACCEPT) {\n        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n        memcpy(s->s3->previous_client_finished, s->s3->tmp.peer_finish_md, i);\n        s->s3->previous_client_finished_len = i;\n    } else {\n        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);\n        memcpy(s->s3->previous_server_finished, s->s3->tmp.peer_finish_md, i);\n        s->s3->previous_server_finished_len = i;\n    }\n\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return (0);\n}", "patch_func_code": "int ssl3_get_finished(SSL *s, int a, int b)\n{\n    int ok;\n    long n;\n\n#ifdef OPENSSL_NO_NEXTPROTONEG\n    /*\n     * the mac has already been generated when we received the change cipher\n     * spec message and is in s->s3->tmp.peer_finish_md\n     */\n#endif\n\n    /* 64 argument should actually be 36+4 :-) */\n    n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    return tls_process_finished(s, (unsigned long)n);\n}", "before_change_lines": [3, 5, 23, 31, 33, 39, 56, 59], "raw_before_change_lines": [3, 5, 23, 31, 33, 39, 56, 59], "after_change_lines": [3, 19, 20], "raw_after_change_lines": [3, 19, 20], "bug_lines": [3, 5, 23, 31, 33, 39, 56, 59], "added": [false, false, false, false, false, false, false, false], "idx": 385}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10952----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_180c1b1bc6285945477e27e305f38e94f28fb22f_1.json----ssl3_get_message", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_180c1b1bc6285945477e27e305f38e94f28fb22f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_180c1b1bc6285945477e27e305f38e94f28fb22f_1.json", "function_name": "ssl3_get_message", "vul_func_code": "long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tunsigned char *p;\n\tunsigned long l;\n\tlong n;\n\tint i,al;\n\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\treturn((int)s->s3->tmp.message_size);\n\t\t}\n\n\tp=(unsigned char *)s->init_buf->data;\n\n\tif (s->state == st1)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\n\t\t\t\t  4-s->init_num);\n\t\tif (i < (4-s->init_num))\n\t\t\t{\n\t\t\t*ok=0;\n\t\t\treturn(ssl3_part_read(s,i));\n\t\t\t}\n\n\t\tif ((mt >= 0) && (*p != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t\t\t(st1 == SSL3_ST_SR_CERT_A) &&\n\t\t\t\t\t(stn == SSL3_ST_SR_CERT_B))\n\t\t\t{\n\t\t\t/* At this point we have got an MS SGC second client\n\t\t\t * hello. We need to restart the mac and mac the data\n\t\t\t * currently received.\n\t\t\t */\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tssl3_finish_mac(s, p + s->init_num, i);\n\t\t\t}\n\t\t\t\n\t\ts->s3->tmp.message_type= *(p++);\n\n\t\tn2l3(p,l);\n\t\tif (l > (unsigned long)max)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l && !BUF_MEM_grow(s->init_buf,(int)l))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->s3->tmp.message_size=l;\n\t\ts->state=stn;\n\n\t\ts->init_num=0;\n\t\t}\n\n\t/* next state (stn) */\n\tp=(unsigned char *)s->init_buf->data;\n\tn=s->s3->tmp.message_size;\n\tif (n > 0)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);\n\t\tif (i != (int)n)\n\t\t\t{\n\t\t\t*ok=0;\n\t\t\treturn(ssl3_part_read(s,i));\n\t\t\t}\n\t\t}\n\t*ok=1;\n\treturn(n);\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\t*ok=0;\n\treturn(-1);\n\t}", "patch_func_code": "long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tunsigned char *p;\n\tunsigned long l;\n\tlong n;\n\tint i,al;\n\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\treturn((int)s->s3->tmp.message_size);\n\t\t}\n\n\tp=(unsigned char *)s->init_buf->data;\n\n\tif (s->state == st1) /* s->init_num < 4 */\n\t\t{\n\t\twhile (s->init_num < 4)\n\t\t\t{\n\t\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\n\t\t\t\t4-s->init_num);\n\t\t\tif (i <= 0)\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t*ok = 0;\n\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\ts->init_num+=i;\n\t\t\t}\n\n/* XXX server may always send Hello Request */\n\t\tif ((mt >= 0) && (*p != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t\t\t(st1 == SSL3_ST_SR_CERT_A) &&\n\t\t\t\t\t(stn == SSL3_ST_SR_CERT_B))\n\t\t\t{\n\t\t\t/* At this point we have got an MS SGC second client\n\t\t\t * hello. We need to restart the mac and mac the data\n\t\t\t * currently received.\n\t\t\t */\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tssl3_finish_mac(s, p + s->init_num, i);\n\t\t\t}\n\t\t\t\n\t\ts->s3->tmp.message_type= *(p++);\n\n\t\tn2l3(p,l);\n\t\tif (l > (unsigned long)max)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l && !BUF_MEM_grow(s->init_buf,(int)l))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->s3->tmp.message_size=l;\n\t\ts->state=stn;\n\n\t\ts->init_num=0;\n\t\t}\n\n\t/* next state (stn) */\n\tp=(unsigned char *)s->init_buf->data;\n\tn=s->s3->tmp.message_size;\n\twhile (n > 0)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\ts->init_num += i;\n\t\tn -= i;\n\t\t}\n\t*ok=1;\n\treturn s->init_num;\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\t*ok=0;\n\treturn(-1);\n\t}", "before_change_lines": [23, 25, 26, 27, 29, 30, 74, 77, 79, 80, 84], "raw_before_change_lines": [23, 25, 26, 27, 29, 30, 74, 77, 79, 80, 84], "after_change_lines": [23, 25, 27, 28, 29, 30, 31, 32, 33, 34, 35, 80, 83, 85, 86, 87, 89, 90, 93], "raw_after_change_lines": [23, 25, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 80, 83, 85, 86, 87, 89, 90, 93], "bug_lines": [23, 25, 26, 27, 29, 30, 74, 77, 79, 80, 84], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 386}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10954----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1813e93f682216ce4f4aba0bcddabd5a65dfa286_1.json----bn_mul_part_recursive", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1813e93f682216ce4f4aba0bcddabd5a65dfa286_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1813e93f682216ce4f4aba0bcddabd5a65dfa286_1.json", "function_name": "bn_mul_part_recursive", "vul_func_code": "void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,\n\t     int n, BN_ULONG *t)\n\t{\n\tint i,j,n2=n*2;\n\tunsigned int c1;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tprintf(\" bn_mul_part_recursive %d * %d\\n\",tn+n,tn+n);\n# endif\n\tif (n < 8)\n\t\t{\n\t\ti=tn+n;\n\t\tbn_mul_normal(r,a,i,b,i);\n\t\treturn;\n\t\t}\n\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tbn_sub_words(t,      a,      &(a[n]),n); /* + */\n\tbn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */\n\n# if 0\n\tif (n == 4)\n\t\t{\n\t\tbn_mul_comba4(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n# endif\n\tif (n == 8)\n\t\t{\n\t\tbn_mul_comba8(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n\t\t{\n\t\tp= &(t[n2*2]);\n\t\tbn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);\n\t\tbn_mul_recursive(r,a,b,n,p);\n\t\ti=n/2;\n\t\t/* If there is only a bottom half to the number,\n\t\t * just do it */\n\t\tj=tn-i;\n\t\tif (j == 0)\n\t\t\t{\n\t\t\tbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);\n\t\t\tmemset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\n\t\t\t}\n\t\telse if (j > 0) /* eg, n == 16, i == 8 and tn == 11 */\n\t\t\t\t{\n\t\t\t\tbn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),\n\t\t\t\t\tj,i,p);\n\t\t\t\tmemset(&(r[n2+tn*2]),0,\n\t\t\t\t\tsizeof(BN_ULONG)*(n2-tn*2));\n\t\t\t\t}\n\t\telse /* (j < 0) eg, n == 16, i == 8 and tn == 5 */\n\t\t\t{\n\t\t\tmemset(&(r[n2]),0,sizeof(BN_ULONG)*n2);\n\t\t\tif (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t\t\t{\n\t\t\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\ti/=2;\n\t\t\t\t\tif (i < tn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_part_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ttn-i,i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (i == tn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ti,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\n\tc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= &(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)&BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln < c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)&BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}", "patch_func_code": "void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int tn,\n\t     int n, BN_ULONG *t)\n\t{\n\tint i,j,n2=n*2;\n\tunsigned int c1,c2,neg,zero;\n\tBN_ULONG ln,lo,*p;\n\n# ifdef BN_COUNT\n\tprintf(\" bn_mul_part_recursive %d * %d\\n\",tn+n,tn+n);\n# endif\n\tif (n < 8)\n\t\t{\n\t\ti=tn+n;\n\t\tbn_mul_normal(r,a,i,b,i);\n\t\treturn;\n\t\t}\n\n\t/* r=(a[0]-a[1])*(b[1]-b[0]) */\n\tc1=bn_cmp_words(a,&(a[n]),n);\n\tc2=bn_cmp_words(&(b[n]),b,n);\n\tzero=neg=0;\n\tswitch (c1*3+c2)\n\t\t{\n\tcase -4:\n\t\tbn_sub_words(t,      &(a[n]),a,      n); /* - */\n\t\tbn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */\n\t\tbreak;\n\tcase -3:\n\t\tzero=1;\n\t\t/* break; */\n\tcase -2:\n\t\tbn_sub_words(t,      &(a[n]),a,      n); /* - */\n\t\tbn_sub_words(&(t[n]),&(b[n]),b,      n); /* + */\n\t\tneg=1;\n\t\tbreak;\n\tcase -1:\n\tcase 0:\n\tcase 1:\n\t\tzero=1;\n\t\t/* break; */\n\tcase 2:\n\t\tbn_sub_words(t,      a,      &(a[n]),n); /* + */\n\t\tbn_sub_words(&(t[n]),b,      &(b[n]),n); /* - */\n\t\tneg=1;\n\t\tbreak;\n\tcase 3:\n\t\tzero=1;\n\t\t/* break; */\n\tcase 4:\n\t\tbn_sub_words(t,      a,      &(a[n]),n);\n\t\tbn_sub_words(&(t[n]),&(b[n]),b,      n);\n\t\tbreak;\n\t\t}\n\t\t/* The zero case isn't yet implemented here. The speedup\n\t\t   would probably be negligible. */\n# if 0\n\tif (n == 4)\n\t\t{\n\t\tbn_mul_comba4(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba4(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n# endif\n\tif (n == 8)\n\t\t{\n\t\tbn_mul_comba8(&(t[n2]),t,&(t[n]));\n\t\tbn_mul_comba8(r,a,b);\n\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\tmemset(&(r[n2+tn*2]),0,sizeof(BN_ULONG)*(n2-tn*2));\n\t\t}\n\telse\n\t\t{\n\t\tp= &(t[n2*2]);\n\t\tbn_mul_recursive(&(t[n2]),t,&(t[n]),n,p);\n\t\tbn_mul_recursive(r,a,b,n,p);\n\t\ti=n/2;\n\t\t/* If there is only a bottom half to the number,\n\t\t * just do it */\n\t\tj=tn-i;\n\t\tif (j == 0)\n\t\t\t{\n\t\t\tbn_mul_recursive(&(r[n2]),&(a[n]),&(b[n]),i,p);\n\t\t\tmemset(&(r[n2+i*2]),0,sizeof(BN_ULONG)*(n2-i*2));\n\t\t\t}\n\t\telse if (j > 0) /* eg, n == 16, i == 8 and tn == 11 */\n\t\t\t\t{\n\t\t\t\tbn_mul_part_recursive(&(r[n2]),&(a[n]),&(b[n]),\n\t\t\t\t\tj,i,p);\n\t\t\t\tmemset(&(r[n2+tn*2]),0,\n\t\t\t\t\tsizeof(BN_ULONG)*(n2-tn*2));\n\t\t\t\t}\n\t\telse /* (j < 0) eg, n == 16, i == 8 and tn == 5 */\n\t\t\t{\n\t\t\tmemset(&(r[n2]),0,sizeof(BN_ULONG)*n2);\n\t\t\tif (tn < BN_MUL_RECURSIVE_SIZE_NORMAL)\n\t\t\t\t{\n\t\t\t\tbn_mul_normal(&(r[n2]),&(a[n]),tn,&(b[n]),tn);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\ti/=2;\n\t\t\t\t\tif (i < tn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_part_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ttn-i,i,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (i == tn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tbn_mul_recursive(&(r[n2]),\n\t\t\t\t\t\t\t&(a[n]),&(b[n]),\n\t\t\t\t\t\t\ti,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0]), c1 is the sign\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t */\n\n\tc1=(int)(bn_add_words(t,r,&(r[n2]),n2));\n\n\tif (neg) /* if t[32] is negative */\n\t\t{\n\t\tc1-=(int)(bn_sub_words(&(t[n2]),t,&(t[n2]),n2));\n\t\t}\n\telse\n\t\t{\n\t\t/* Might have a carry */\n\t\tc1+=(int)(bn_add_words(&(t[n2]),&(t[n2]),t,n2));\n\t\t}\n\n\t/* t[32] holds (a[0]-a[1])*(b[1]-b[0])+(a[0]*b[0])+(a[1]*b[1])\n\t * r[10] holds (a[0]*b[0])\n\t * r[32] holds (b[1]*b[1])\n\t * c1 holds the carry bits\n\t */\n\tc1+=(int)(bn_add_words(&(r[n]),&(r[n]),&(t[n2]),n2));\n\tif (c1)\n\t\t{\n\t\tp= &(r[n+n2]);\n\t\tlo= *p;\n\t\tln=(lo+c1)&BN_MASK2;\n\t\t*p=ln;\n\n\t\t/* The overflow will stop before we over write\n\t\t * words we should not overwrite */\n\t\tif (ln < c1)\n\t\t\t{\n\t\t\tdo\t{\n\t\t\t\tp++;\n\t\t\t\tlo= *p;\n\t\t\t\tln=(lo+1)&BN_MASK2;\n\t\t\t\t*p=ln;\n\t\t\t\t} while (ln == 0);\n\t\t\t}\n\t\t}\n\t}", "before_change_lines": [5, 19, 20, 97], "raw_before_change_lines": [5, 19, 20, 21, 97], "after_change_lines": [5, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31, 32, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 55, 132, 133, 134, 135, 136, 137, 139, 140], "raw_after_change_lines": [5, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140], "bug_lines": [5, 19, 20, 21, 97], "added": [false, false, false, false, false], "idx": 387}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "10971----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_18b413c8e735f80c2638f2b6f51c0a8b4eaa5dd3_1.json----ASN1_TIME_to_generalizedtime", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_18b413c8e735f80c2638f2b6f51c0a8b4eaa5dd3_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_18b413c8e735f80c2638f2b6f51c0a8b4eaa5dd3_1.json", "function_name": "ASN1_TIME_to_generalizedtime", "vul_func_code": "ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t,\n                                                   ASN1_GENERALIZEDTIME **out)\n{\n    ASN1_GENERALIZEDTIME *ret;\n    char *str;\n    int newlen;\n\n    if (!ASN1_TIME_check(t))\n        return NULL;\n\n    if (out == NULL || *out == NULL) {\n        if ((ret = ASN1_GENERALIZEDTIME_new()) == NULL)\n            return NULL;\n        if (out)\n            *out = ret;\n    } else\n        ret = *out;\n\n    /* If already GeneralizedTime just copy across */\n    if (t->type == V_ASN1_GENERALIZEDTIME) {\n        if (!ASN1_STRING_set(ret, t->data, t->length))\n            return NULL;\n        return ret;\n    }\n\n    /* grow the string */\n    if (!ASN1_STRING_set(ret, NULL, t->length + 2))\n        return NULL;\n    /* ASN1_STRING_set() allocated 'len + 1' bytes. */\n    newlen = t->length + 2 + 1;\n    str = (char *)ret->data;\n    /* Work out the century and prepend */\n    if (t->data[0] >= '5')\n        BUF_strlcpy(str, \"19\", newlen);\n    else\n        BUF_strlcpy(str, \"20\", newlen);\n\n    BUF_strlcat(str, (char *)t->data, newlen);\n\n    return ret;\n}", "patch_func_code": "ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *t,\n                                                   ASN1_GENERALIZEDTIME **out)\n{\n    ASN1_GENERALIZEDTIME *ret;\n    char *str;\n    int newlen;\n\n    if (!ASN1_TIME_check(t))\n        return NULL;\n\n    if (out == NULL || *out == NULL) {\n        if ((ret = ASN1_GENERALIZEDTIME_new()) == NULL)\n            return NULL;\n        if (out)\n            *out = ret;\n    } else\n        ret = *out;\n\n    /* If already GeneralizedTime just copy across */\n    if (t->type == V_ASN1_GENERALIZEDTIME) {\n        if (!ASN1_STRING_set(ret, t->data, t->length))\n            return NULL;\n        return ret;\n    }\n\n    /* grow the string */\n    if (!ASN1_STRING_set(ret, NULL, t->length + 2))\n        return NULL;\n    /* ASN1_STRING_set() allocated 'len + 1' bytes. */\n    newlen = t->length + 2 + 1;\n    str = (char *)ret->data;\n    /* Work out the century and prepend */\n    if (t->data[0] >= '5')\n        OPENSSL_strlcpy(str, \"19\", newlen);\n    else\n        OPENSSL_strlcpy(str, \"20\", newlen);\n\n    OPENSSL_strlcat(str, (char *)t->data, newlen);\n\n    return ret;\n}", "before_change_lines": [34, 36, 38], "raw_before_change_lines": [34, 36, 38], "after_change_lines": [34, 36, 38], "raw_after_change_lines": [34, 36, 38], "bug_lines": [34, 36, 38], "added": [false, false, false], "idx": 388}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10989----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_1.json----pkey_set_type", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_1.json", "function_name": "pkey_set_type", "vul_func_code": "static int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len)\n{\n    const EVP_PKEY_ASN1_METHOD *ameth;\n    ENGINE *e = NULL;\n    if (pkey) {\n        if (pkey->pkey.ptr)\n            EVP_PKEY_free_it(pkey);\n        /*\n         * If key type matches and a method exists then this lookup has\n         * succeeded once so just indicate success.\n         */\n        if ((type == pkey->save_type) && pkey->ameth)\n            return 1;\n#ifndef OPENSSL_NO_ENGINE\n        /* If we have an ENGINE release it */\n        if (pkey->engine) {\n            ENGINE_finish(pkey->engine);\n            pkey->engine = NULL;\n        }\n#endif\n    }\n    if (str)\n        ameth = EVP_PKEY_asn1_find_str(&e, str, len);\n    else\n        ameth = EVP_PKEY_asn1_find(&e, type);\n#ifndef OPENSSL_NO_ENGINE\n    if (!pkey && e)\n        ENGINE_finish(e);\n#endif\n    if (!ameth) {\n        EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);\n        return 0;\n    }\n    if (pkey) {\n        pkey->ameth = ameth;\n        pkey->engine = e;\n\n        pkey->type = pkey->ameth->pkey_id;\n        pkey->save_type = type;\n    }\n    return 1;\n}", "patch_func_code": "static int pkey_set_type(EVP_PKEY *pkey, int type, const char *str, int len)\n{\n    const EVP_PKEY_ASN1_METHOD *ameth;\n    ENGINE *e = NULL;\n    if (pkey) {\n        if (pkey->pkey.ptr)\n            EVP_PKEY_free_it(pkey);\n        /*\n         * If key type matches and a method exists then this lookup has\n         * succeeded once so just indicate success.\n         */\n        if ((type == pkey->save_type) && pkey->ameth)\n            return 1;\n#ifndef OPENSSL_NO_ENGINE\n        /* If we have an ENGINE release it */\n        ENGINE_finish(pkey->engine);\n        pkey->engine = NULL;\n#endif\n    }\n    if (str)\n        ameth = EVP_PKEY_asn1_find_str(&e, str, len);\n    else\n        ameth = EVP_PKEY_asn1_find(&e, type);\n#ifndef OPENSSL_NO_ENGINE\n    if (pkey == NULL)\n        ENGINE_finish(e);\n#endif\n    if (ameth == NULL) {\n        EVPerr(EVP_F_PKEY_SET_TYPE, EVP_R_UNSUPPORTED_ALGORITHM);\n        return 0;\n    }\n    if (pkey) {\n        pkey->ameth = ameth;\n        pkey->engine = e;\n\n        pkey->type = pkey->ameth->pkey_id;\n        pkey->save_type = type;\n    }\n    return 1;\n}", "before_change_lines": [16, 17, 18, 19, 27, 30], "raw_before_change_lines": [16, 17, 18, 19, 27, 30], "after_change_lines": [16, 17, 25, 28], "raw_after_change_lines": [16, 17, 25, 28], "bug_lines": [16, 17, 18, 19, 27, 30], "added": [false, false, false, false, false, false], "idx": 389}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10990----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_1.json----EVP_PKEY_free_it", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_197d1692964e9b643274a4b0ddfb560108f605fc_1.json", "function_name": "EVP_PKEY_free_it", "vul_func_code": "static void EVP_PKEY_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n    if (x->ameth && x->ameth->pkey_free) {\n        x->ameth->pkey_free(x);\n        x->pkey.ptr = NULL;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    if (x->engine) {\n        ENGINE_finish(x->engine);\n        x->engine = NULL;\n    }\n#endif\n}", "patch_func_code": "static void EVP_PKEY_free_it(EVP_PKEY *x)\n{\n    /* internal function; x is never NULL */\n    if (x->ameth && x->ameth->pkey_free) {\n        x->ameth->pkey_free(x);\n        x->pkey.ptr = NULL;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(x->engine);\n    x->engine = NULL;\n#endif\n}", "before_change_lines": [9, 10, 11, 12], "raw_before_change_lines": [9, 10, 11, 12], "after_change_lines": [9, 10], "raw_after_change_lines": [9, 10], "bug_lines": [9, 10, 11, 12], "added": [false, false, false, false], "idx": 390}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "10992----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_198601e23f65e508d4e94718d9f05a8a731ef541_1.json----X509_STORE_CTX_cleanup", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_198601e23f65e508d4e94718d9f05a8a731ef541_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_198601e23f65e508d4e94718d9f05a8a731ef541_1.json", "function_name": "X509_STORE_CTX_cleanup", "vul_func_code": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n\t{\n\tif (ctx->cleanup) ctx->cleanup(ctx);\n\tX509_VERIFY_PARAM_free(ctx->param);\n\tif (ctx->tree)\n\t\tX509_policy_tree_free(ctx->tree);\n\tif (ctx->chain != NULL)\n\t\t{\n\t\tsk_X509_pop_free(ctx->chain,X509_free);\n\t\tctx->chain=NULL;\n\t\t}\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n\tmemset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));\n\t}", "patch_func_code": "void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)\n\t{\n\tif (ctx->cleanup) ctx->cleanup(ctx);\n\tif (ctx->param != NULL)\n\t\t{\n\t\tX509_VERIFY_PARAM_free(ctx->param);\n\t\tctx->param=NULL;\n\t\t}\n\tif (ctx->tree != NULL)\n\t\t{\n\t\tX509_policy_tree_free(ctx->tree);\n\t\tctx->tree=NULL;\n\t\t}\n\tif (ctx->chain != NULL)\n\t\t{\n\t\tsk_X509_pop_free(ctx->chain,X509_free);\n\t\tctx->chain=NULL;\n\t\t}\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));\n\tmemset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));\n\t}", "before_change_lines": [4, 5], "raw_before_change_lines": [4, 5], "after_change_lines": [4, 5, 6, 7, 8, 9, 10, 12, 13], "raw_after_change_lines": [4, 5, 6, 7, 8, 9, 10, 12, 13], "bug_lines": [4, 5], "added": [false, false], "idx": 391}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L3", "filepath_func": "11021----BUFFER_OVERRUN_L3----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1a7be78b5fdfe9518ad465e00ad8f2fcae759817_1.json----HMAC_CTX_copy", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1a7be78b5fdfe9518ad465e00ad8f2fcae759817_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1a7be78b5fdfe9518ad465e00ad8f2fcae759817_1.json", "function_name": "HMAC_CTX_copy", "vul_func_code": "int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx)\n{\n    if (!hmac_ctx_alloc_mds(dctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx->i_ctx, sctx->i_ctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx->o_ctx, sctx->o_ctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx->md_ctx, sctx->md_ctx))\n        goto err;\n    memcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK);\n    dctx->key_length = sctx->key_length;\n    dctx->md = sctx->md;\n    return 1;\n err:\n    hmac_ctx_cleanup(dctx);\n    return 0;\n}", "patch_func_code": "int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx)\n{\n    if (!hmac_ctx_alloc_mds(dctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx->i_ctx, sctx->i_ctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx->o_ctx, sctx->o_ctx))\n        goto err;\n    if (!EVP_MD_CTX_copy_ex(dctx->md_ctx, sctx->md_ctx))\n        goto err;\n    memcpy(dctx->key, sctx->key, HMAC_MAX_MD_CBLOCK_SIZE);\n    dctx->key_length = sctx->key_length;\n    dctx->md = sctx->md;\n    return 1;\n err:\n    hmac_ctx_cleanup(dctx);\n    return 0;\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [11], "added": [false], "idx": 392}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "11027----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1aaa787e6112b9be148b889811681bb92cc5f4e1_1.json----BN_from_montgomery", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1aaa787e6112b9be148b889811681bb92cc5f4e1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1aaa787e6112b9be148b889811681bb92cc5f4e1_1.json", "function_name": "BN_from_montgomery", "vul_func_code": "int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,\n                       BN_CTX *ctx)\n{\n    int retn = 0;\n#ifdef MONT_WORD\n    BIGNUM *t;\n\n    BN_CTX_start(ctx);\n    if ((t = BN_CTX_get(ctx)) && BN_copy(t, a))\n        retn = BN_from_montgomery_word(ret, t, mont);\n    BN_CTX_end(ctx);\n#else                           /* !MONT_WORD */\n    BIGNUM *t1, *t2;\n\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (!BN_copy(t1, a))\n        goto err;\n    BN_mask_bits(t1, mont->ri);\n\n    if (!BN_mul(t2, t1, &mont->Ni, ctx))\n        goto err;\n    BN_mask_bits(t2, mont->ri);\n\n    if (!BN_mul(t1, t2, &mont->N, ctx))\n        goto err;\n    if (!BN_add(t2, a, t1))\n        goto err;\n    if (!BN_rshift(ret, t2, mont->ri))\n        goto err;\n\n    if (BN_ucmp(ret, &(mont->N)) >= 0) {\n        if (!BN_usub(ret, ret, &(mont->N)))\n            goto err;\n    }\n    retn = 1;\n    bn_check_top(ret);\n err:\n    BN_CTX_end(ctx);\n#endif                          /* MONT_WORD */\n    return retn;\n}", "patch_func_code": "int BN_from_montgomery(BIGNUM *ret, const BIGNUM *a, BN_MONT_CTX *mont,\n                       BN_CTX *ctx)\n{\n    int retn = 0;\n#ifdef MONT_WORD\n    BIGNUM *t;\n\n    BN_CTX_start(ctx);\n    if ((t = BN_CTX_get(ctx)) && BN_copy(t, a)) {\n        retn = bn_from_montgomery_word(ret, t, mont);\n        bn_correct_top(ret);\n        bn_check_top(ret);\n    }\n    BN_CTX_end(ctx);\n#else                           /* !MONT_WORD */\n    BIGNUM *t1, *t2;\n\n    BN_CTX_start(ctx);\n    t1 = BN_CTX_get(ctx);\n    t2 = BN_CTX_get(ctx);\n    if (t2 == NULL)\n        goto err;\n\n    if (!BN_copy(t1, a))\n        goto err;\n    BN_mask_bits(t1, mont->ri);\n\n    if (!BN_mul(t2, t1, &mont->Ni, ctx))\n        goto err;\n    BN_mask_bits(t2, mont->ri);\n\n    if (!BN_mul(t1, t2, &mont->N, ctx))\n        goto err;\n    if (!BN_add(t2, a, t1))\n        goto err;\n    if (!BN_rshift(ret, t2, mont->ri))\n        goto err;\n\n    if (BN_ucmp(ret, &(mont->N)) >= 0) {\n        if (!BN_usub(ret, ret, &(mont->N)))\n            goto err;\n    }\n    retn = 1;\n    bn_check_top(ret);\n err:\n    BN_CTX_end(ctx);\n#endif                          /* MONT_WORD */\n    return retn;\n}", "before_change_lines": [9, 10], "raw_before_change_lines": [9, 10], "after_change_lines": [9, 10, 11, 12, 13], "raw_after_change_lines": [9, 10, 11, 12, 13], "bug_lines": [9, 10], "added": [false, false], "idx": 393}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11073----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c42a9470dfbc423c6f0e8a098f283145e7124a6_1.json----OPENSSL_sk_dup", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1c42a9470dfbc423c6f0e8a098f283145e7124a6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c42a9470dfbc423c6f0e8a098f283145e7124a6_1.json", "function_name": "OPENSSL_sk_dup", "vul_func_code": "OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)\n{\n    OPENSSL_STACK *ret;\n\n    if (sk->num < 0)\n        return NULL;\n\n    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)\n        return NULL;\n\n    /* direct structure assignment */\n    *ret = *sk;\n\n    if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL)\n        goto err;\n    memcpy(ret->data, sk->data, sizeof(char *) * sk->num);\n    return ret;\n err:\n    OPENSSL_sk_free(ret);\n    return NULL;\n}", "patch_func_code": "OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *sk)\n{\n    OPENSSL_STACK *ret;\n\n    if (sk->num < 0)\n        return NULL;\n\n    if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL)\n        return NULL;\n\n    /* direct structure assignment */\n    *ret = *sk;\n\n    if ((ret->data = OPENSSL_malloc(sizeof(*ret->data) * sk->num_alloc)) == NULL)\n        goto err;\n    memcpy(ret->data, sk->data, sizeof(void *) * sk->num);\n    return ret;\n err:\n    OPENSSL_sk_free(ret);\n    return NULL;\n}", "before_change_lines": [16], "raw_before_change_lines": [16], "after_change_lines": [16], "raw_after_change_lines": [16], "bug_lines": [16], "added": [false], "idx": 394}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11078----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c73b428ce6569c8ef199734eda1f530c2b807d8_1.json----EC_KEY_free", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1c73b428ce6569c8ef199734eda1f530c2b807d8_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c73b428ce6569c8ef199734eda1f530c2b807d8_1.json", "function_name": "EC_KEY_free", "vul_func_code": "void EC_KEY_free(EC_KEY *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);\n    REF_PRINT_COUNT(\"EC_KEY\", r);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    if (r->meth->finish != NULL)\n        r->meth->finish(r);\n\n#ifndef OPENSSL_NO_ENGINE\n    if (r->engine != NULL)\n        ENGINE_finish(r->engine);\n#endif\n\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_EC_KEY, r, &r->ex_data);\n    EC_GROUP_free(r->group);\n    EC_POINT_free(r->pub_key);\n    BN_clear_free(r->priv_key);\n\n    OPENSSL_clear_free((void *)r, sizeof(EC_KEY));\n}", "patch_func_code": "void EC_KEY_free(EC_KEY *r)\n{\n    int i;\n\n    if (r == NULL)\n        return;\n\n    i = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_EC);\n    REF_PRINT_COUNT(\"EC_KEY\", r);\n    if (i > 0)\n        return;\n    REF_ASSERT_ISNT(i < 0);\n\n    if (r->meth->finish != NULL)\n        r->meth->finish(r);\n\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_finish(r->engine);\n#endif\n\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_EC_KEY, r, &r->ex_data);\n    EC_GROUP_free(r->group);\n    EC_POINT_free(r->pub_key);\n    BN_clear_free(r->priv_key);\n\n    OPENSSL_clear_free((void *)r, sizeof(EC_KEY));\n}", "before_change_lines": [18, 19], "raw_before_change_lines": [18, 19], "after_change_lines": [18], "raw_after_change_lines": [18], "bug_lines": [18, 19], "added": [false, false], "idx": 395}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "11082----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c933a249550ce37ead5f92298d2d7282f0158e2_1.json----do_dtls1_write", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1c933a249550ce37ead5f92298d2d7282f0158e2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1c933a249550ce37ead5f92298d2d7282f0158e2_1.json", "function_name": "do_dtls1_write", "vul_func_code": "int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)\n\t{\n\tunsigned char *p,*pseq;\n\tint i,mac_size,clear=0;\n\tint prefix_len = 0;\n\tSSL3_RECORD *wr;\n\tSSL3_BUFFER *wb;\n\tSSL_SESSION *sess;\n\tint bs;\n\n\t/* first check if there is a SSL3_BUFFER still being written\n\t * out.  This will happen with non blocking IO */\n\tif (s->s3->wbuf.left != 0)\n\t\t{\n\t\tOPENSSL_assert(0); /* XDTLS:  want to see if we ever get here */\n\t\treturn(ssl3_write_pending(s,type,buf,len));\n\t\t}\n\n\t/* If we have an alert to send, lets send it */\n\tif (s->s3->alert_dispatch)\n\t\t{\n\t\ti=s->method->ssl_dispatch_alert(s);\n\t\tif (i <= 0)\n\t\t\treturn(i);\n\t\t/* if it went, fall through and send more stuff */\n\t\t}\n\n\tif (len == 0 && !create_empty_fragment)\n\t\treturn 0;\n\n\twr= &(s->s3->wrec);\n\twb= &(s->s3->wbuf);\n\tsess=s->session;\n\n\tif (\t(sess == NULL) ||\n\t\t(s->enc_write_ctx == NULL) ||\n\t\t(EVP_MD_CTX_md(s->write_hash) == NULL))\n\t\tclear=1;\n\n\tif (clear)\n\t\tmac_size=0;\n\telse\n\t\tmac_size=EVP_MD_CTX_size(s->write_hash);\n\n\t/* DTLS implements explicit IV, so no need for empty fragments */\n#if 0\n\t/* 'create_empty_fragment' is true only when this function calls itself */\n\tif (!clear && !create_empty_fragment && !s->s3->empty_fragment_done\n\t\t&& SSL_version(s) != DTLS1_VERSION)\n\t\t{\n\t\t/* countermeasure against known-IV weakness in CBC ciphersuites\n\t\t * (see http://www.openssl.org/~bodo/tls-cbc.txt) \n\t\t */\n\n\t\tif (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)\n\t\t\t{\n\t\t\t/* recursive function call with 'create_empty_fragment' set;\n\t\t\t * this prepares and buffers the data for an empty fragment\n\t\t\t * (these 'prefix_len' bytes are sent out later\n\t\t\t * together with the actual payload) */\n\t\t\tprefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);\n\t\t\tif (prefix_len <= 0)\n\t\t\t\tgoto err;\n\n\t\t\tif (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)\n\t\t\t\t{\n\t\t\t\t/* insufficient space */\n\t\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\ts->s3->empty_fragment_done = 1;\n\t\t}\n#endif\n\n\tp = wb->buf + prefix_len;\n\n\t/* write the header */\n\n\t*(p++)=type&0xff;\n\twr->type=type;\n\n\t*(p++)=(s->version>>8);\n\t*(p++)=s->version&0xff;\n\n\t/* field where we are to write out packet epoch, seq num and len */\n\tpseq=p; \n\tp+=10;\n\n\t/* lets setup the record stuff. */\n\n\t/* Make space for the explicit IV in case of CBC.\n\t * (this is a bit of a boundary violation, but what the heck).\n\t */\n\tif ( s->enc_write_ctx && \n\t\t(EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE))\n\t\tbs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher);\n\telse\n\t\tbs = 0;\n\n\twr->data=p + bs;  /* make room for IV in case of CBC */\n\twr->length=(int)len;\n\twr->input=(unsigned char *)buf;\n\n\t/* we now 'read' from wr->input, wr->length bytes into\n\t * wr->data */\n\n\t/* first we compress */\n\tif (s->compress != NULL)\n\t\t{\n\t\tif (!ssl3_do_compress(s))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(wr->data,wr->input,wr->length);\n\t\twr->input=wr->data;\n\t\t}\n\n\t/* we should still have the output to wr->data and the input\n\t * from wr->input.  Length should be wr->length.\n\t * wr->data still points in the wb->buf */\n\n\tif (mac_size != 0)\n\t\t{\n\t\ts->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1);\n\t\twr->length+=mac_size;\n\t\t}\n\n\t/* this is true regardless of mac size */\n\twr->input=p;\n\twr->data=p;\n\n\n\t/* ssl3_enc can only have an error on read */\n\twr->length += bs;  /* bs != 0 in case of CBC.  The enc fn provides\n\t\t\t\t\t\t* the randomness */ \n\ts->method->ssl3_enc->enc(s,1);\n\n\t/* record length after mac and block padding */\n/*\tif (type == SSL3_RT_APPLICATION_DATA ||\n\t(type == SSL3_RT_ALERT && ! SSL_in_init(s))) */\n\t\n\t/* there's only one epoch between handshake and app data */\n\t\n\ts2n(s->d1->w_epoch, pseq);\n\n\t/* XDTLS: ?? */\n/*\telse\n\ts2n(s->d1->handshake_epoch, pseq); */\n\n\tmemcpy(pseq, &(s->s3->write_sequence[2]), 6);\n\tpseq+=6;\n\ts2n(wr->length,pseq);\n\n\t/* we should now have\n\t * wr->data pointing to the encrypted data, which is\n\t * wr->length long */\n\twr->type=type; /* not needed but helps for debugging */\n\twr->length+=DTLS1_RT_HEADER_LENGTH;\n\n#if 0  /* this is now done at the message layer */\n\t/* buffer the record, making it easy to handle retransmits */\n\tif ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\tdtls1_buffer_record(s, wr->data, wr->length, \n\t\t\t*((PQ_64BIT *)&(s->s3->write_sequence[0])));\n#endif\n\n\tssl3_record_sequence_update(&(s->s3->write_sequence[0]));\n\n\tif (create_empty_fragment)\n\t\t{\n\t\t/* we are in a recursive call;\n\t\t * just return the length, don't write out anything here\n\t\t */\n\t\treturn wr->length;\n\t\t}\n\n\t/* now let's set up wb */\n\twb->left = prefix_len + wr->length;\n\twb->offset = 0;\n\n\t/* memorize arguments so that ssl3_write_pending can detect bad write retries later */\n\ts->s3->wpend_tot=len;\n\ts->s3->wpend_buf=buf;\n\ts->s3->wpend_type=type;\n\ts->s3->wpend_ret=len;\n\n\t/* we now just need to write the buffer */\n\treturn ssl3_write_pending(s,type,buf,len);\nerr:\n\treturn -1;\n\t}", "patch_func_code": "int do_dtls1_write(SSL *s, int type, const unsigned char *buf, unsigned int len, int create_empty_fragment)\n\t{\n\tunsigned char *p,*pseq;\n\tint i,mac_size,clear=0;\n\tint prefix_len = 0;\n\tSSL3_RECORD *wr;\n\tSSL3_BUFFER *wb;\n\tSSL_SESSION *sess;\n\tint bs;\n\n\t/* first check if there is a SSL3_BUFFER still being written\n\t * out.  This will happen with non blocking IO */\n\tif (s->s3->wbuf.left != 0)\n\t\t{\n\t\tOPENSSL_assert(0); /* XDTLS:  want to see if we ever get here */\n\t\treturn(ssl3_write_pending(s,type,buf,len));\n\t\t}\n\n\t/* If we have an alert to send, lets send it */\n\tif (s->s3->alert_dispatch)\n\t\t{\n\t\ti=s->method->ssl_dispatch_alert(s);\n\t\tif (i <= 0)\n\t\t\treturn(i);\n\t\t/* if it went, fall through and send more stuff */\n\t\t}\n\n\tif (len == 0 && !create_empty_fragment)\n\t\treturn 0;\n\n\twr= &(s->s3->wrec);\n\twb= &(s->s3->wbuf);\n\tsess=s->session;\n\n\tif (\t(sess == NULL) ||\n\t\t(s->enc_write_ctx == NULL) ||\n\t\t(EVP_MD_CTX_md(s->write_hash) == NULL))\n\t\tclear=1;\n\n\tif (clear)\n\t\tmac_size=0;\n\telse\n\t\tmac_size=EVP_MD_CTX_size(s->write_hash);\n\n\t/* DTLS implements explicit IV, so no need for empty fragments */\n#if 0\n\t/* 'create_empty_fragment' is true only when this function calls itself */\n\tif (!clear && !create_empty_fragment && !s->s3->empty_fragment_done\n\t\t&& SSL_version(s) != DTLS1_VERSION)\n\t\t{\n\t\t/* countermeasure against known-IV weakness in CBC ciphersuites\n\t\t * (see http://www.openssl.org/~bodo/tls-cbc.txt) \n\t\t */\n\n\t\tif (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA)\n\t\t\t{\n\t\t\t/* recursive function call with 'create_empty_fragment' set;\n\t\t\t * this prepares and buffers the data for an empty fragment\n\t\t\t * (these 'prefix_len' bytes are sent out later\n\t\t\t * together with the actual payload) */\n\t\t\tprefix_len = s->method->do_ssl_write(s, type, buf, 0, 1);\n\t\t\tif (prefix_len <= 0)\n\t\t\t\tgoto err;\n\n\t\t\tif (s->s3->wbuf.len < (size_t)prefix_len + SSL3_RT_MAX_PACKET_SIZE)\n\t\t\t\t{\n\t\t\t\t/* insufficient space */\n\t\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE, ERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\ts->s3->empty_fragment_done = 1;\n\t\t}\n#endif\n\n\tp = wb->buf + prefix_len;\n\n\t/* write the header */\n\n\t*(p++)=type&0xff;\n\twr->type=type;\n\n\t*(p++)=(s->version>>8);\n\t*(p++)=s->version&0xff;\n\n\t/* field where we are to write out packet epoch, seq num and len */\n\tpseq=p; \n\tp+=10;\n\n\t/* lets setup the record stuff. */\n\n\t/* Make space for the explicit IV in case of CBC.\n\t * (this is a bit of a boundary violation, but what the heck).\n\t */\n\tif ( s->enc_write_ctx && \n\t\t(EVP_CIPHER_mode( s->enc_write_ctx->cipher ) & EVP_CIPH_CBC_MODE))\n\t\tbs = EVP_CIPHER_block_size(s->enc_write_ctx->cipher);\n\telse\n\t\tbs = 0;\n\n\twr->data=p + bs;  /* make room for IV in case of CBC */\n\twr->length=(int)len;\n\twr->input=(unsigned char *)buf;\n\n\t/* we now 'read' from wr->input, wr->length bytes into\n\t * wr->data */\n\n\t/* first we compress */\n\tif (s->compress != NULL)\n\t\t{\n\t\tif (!ssl3_do_compress(s))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_DO_DTLS1_WRITE,SSL_R_COMPRESSION_FAILURE);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tmemcpy(wr->data,wr->input,wr->length);\n\t\twr->input=wr->data;\n\t\t}\n\n\t/* we should still have the output to wr->data and the input\n\t * from wr->input.  Length should be wr->length.\n\t * wr->data still points in the wb->buf */\n\n\tif (mac_size != 0)\n\t\t{\n\t\ts->method->ssl3_enc->mac(s,&(p[wr->length + bs]),1);\n\t\twr->length+=mac_size;\n\t\t}\n\n\t/* this is true regardless of mac size */\n\twr->input=p;\n\twr->data=p;\n\n\n\t/* ssl3_enc can only have an error on read */\n\tif (bs)\t/* bs != 0 in case of CBC */\n\t\t{\n\t\tRAND_pseudo_bytes(p,bs);\n\t\t/* master IV and last CBC residue stand for\n\t\t * the rest of randomness */\n\t\twr->length += bs;\n\t\t}\n\n\ts->method->ssl3_enc->enc(s,1);\n\n\t/* record length after mac and block padding */\n/*\tif (type == SSL3_RT_APPLICATION_DATA ||\n\t(type == SSL3_RT_ALERT && ! SSL_in_init(s))) */\n\t\n\t/* there's only one epoch between handshake and app data */\n\t\n\ts2n(s->d1->w_epoch, pseq);\n\n\t/* XDTLS: ?? */\n/*\telse\n\ts2n(s->d1->handshake_epoch, pseq); */\n\n\tmemcpy(pseq, &(s->s3->write_sequence[2]), 6);\n\tpseq+=6;\n\ts2n(wr->length,pseq);\n\n\t/* we should now have\n\t * wr->data pointing to the encrypted data, which is\n\t * wr->length long */\n\twr->type=type; /* not needed but helps for debugging */\n\twr->length+=DTLS1_RT_HEADER_LENGTH;\n\n#if 0  /* this is now done at the message layer */\n\t/* buffer the record, making it easy to handle retransmits */\n\tif ( type == SSL3_RT_HANDSHAKE || type == SSL3_RT_CHANGE_CIPHER_SPEC)\n\t\tdtls1_buffer_record(s, wr->data, wr->length, \n\t\t\t*((PQ_64BIT *)&(s->s3->write_sequence[0])));\n#endif\n\n\tssl3_record_sequence_update(&(s->s3->write_sequence[0]));\n\n\tif (create_empty_fragment)\n\t\t{\n\t\t/* we are in a recursive call;\n\t\t * just return the length, don't write out anything here\n\t\t */\n\t\treturn wr->length;\n\t\t}\n\n\t/* now let's set up wb */\n\twb->left = prefix_len + wr->length;\n\twb->offset = 0;\n\n\t/* memorize arguments so that ssl3_write_pending can detect bad write retries later */\n\ts->s3->wpend_tot=len;\n\ts->s3->wpend_buf=buf;\n\ts->s3->wpend_type=type;\n\ts->s3->wpend_ret=len;\n\n\t/* we now just need to write the buffer */\n\treturn ssl3_write_pending(s,type,buf,len);\nerr:\n\treturn -1;\n\t}", "before_change_lines": [140, 141], "raw_before_change_lines": [140, 141], "after_change_lines": [140, 141, 142, 144, 145, 146], "raw_after_change_lines": [140, 141, 142, 143, 144, 145, 146, 147], "bug_lines": [140, 141], "added": [false, false], "idx": 396}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11086----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1cb542048f9d3e79ff9fed2bd43202f97e770b5c_1.json----RSA_new_method", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1cb542048f9d3e79ff9fed2bd43202f97e770b5c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1cb542048f9d3e79ff9fed2bd43202f97e770b5c_1.json", "function_name": "RSA_new_method", "vul_func_code": "RSA *RSA_new_method(ENGINE *engine)\n{\n    RSA *ret;\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->meth = RSA_get_default_method();\n#ifndef OPENSSL_NO_ENGINE\n    if (engine) {\n        if (!ENGINE_init(engine)) {\n            RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\n            OPENSSL_free(ret);\n            return NULL;\n        }\n        ret->engine = engine;\n    } else\n        ret->engine = ENGINE_get_default_RSA();\n    if (ret->engine) {\n        ret->meth = ENGINE_get_RSA(ret->engine);\n        if (!ret->meth) {\n            RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\n            ENGINE_finish(ret->engine);\n            OPENSSL_free(ret);\n            return NULL;\n        }\n    }\n#endif\n\n    ret->references = 1;\n    ret->flags = ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW;\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data)) {\n#ifndef OPENSSL_NO_ENGINE\n        if (ret->engine)\n            ENGINE_finish(ret->engine);\n#endif\n        OPENSSL_free(ret);\n        return (NULL);\n    }\n\n    if ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\n#ifndef OPENSSL_NO_ENGINE\n        if (ret->engine)\n            ENGINE_finish(ret->engine);\n#endif\n        CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);\n        OPENSSL_free(ret);\n        ret = NULL;\n    }\n    return (ret);\n}", "patch_func_code": "RSA *RSA_new_method(ENGINE *engine)\n{\n    RSA *ret;\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->meth = RSA_get_default_method();\n#ifndef OPENSSL_NO_ENGINE\n    if (engine) {\n        if (!ENGINE_init(engine)) {\n            RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\n            OPENSSL_free(ret);\n            return NULL;\n        }\n        ret->engine = engine;\n    } else\n        ret->engine = ENGINE_get_default_RSA();\n    if (ret->engine) {\n        ret->meth = ENGINE_get_RSA(ret->engine);\n        if (ret->meth == NULL) {\n            RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);\n            ENGINE_finish(ret->engine);\n            OPENSSL_free(ret);\n            return NULL;\n        }\n    }\n#endif\n\n    ret->references = 1;\n    ret->flags = ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW;\n    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data)) {\n#ifndef OPENSSL_NO_ENGINE\n        if (ret->engine)\n            ENGINE_finish(ret->engine);\n#endif\n        OPENSSL_free(ret);\n        return (NULL);\n    }\n\n    if ((ret->meth->init != NULL) && !ret->meth->init(ret)) {\n#ifndef OPENSSL_NO_ENGINE\n        if (ret->engine)\n            ENGINE_finish(ret->engine);\n#endif\n        CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);\n        OPENSSL_free(ret);\n        ret = NULL;\n    }\n    return (ret);\n}", "before_change_lines": [24], "raw_before_change_lines": [24], "after_change_lines": [24], "raw_after_change_lines": [24], "bug_lines": [24], "added": [false], "idx": 397}
{"project": "openssl", "vul_type": "NULL_DEREFERENCE", "filepath_func": "11088----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1ccc4bec9f1bb2f12b91b3254023b89d6c677300_1.json----pkey_GOST94cp_decrypt", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_1ccc4bec9f1bb2f12b91b3254023b89d6c677300_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_1ccc4bec9f1bb2f12b91b3254023b89d6c677300_1.json", "function_name": "pkey_GOST94cp_decrypt", "vul_func_code": "int pkey_GOST94cp_decrypt (EVP_PKEY_CTX *ctx, unsigned char *key, size_t *key_len,const unsigned char *in, size_t in_len) {\n\tDH *dh = DH_new();\n\tconst unsigned char *p = in;\n\tGOST_KEY_TRANSPORT *gkt = NULL;\n\tunsigned char wrappedKey[44];\n\tunsigned char sharedKey[32];\n\tgost_ctx cctx;\n\tconst struct gost_cipher_info *param=NULL;\n\tEVP_PKEY *eph_key=NULL;\n\tEVP_PKEY *priv= EVP_PKEY_CTX_get0_pkey(ctx); \n\t\n\tif (!key)\n\t\t{\n\t\t*key_len = 32;\n\t\treturn 1;\n\t\t}\t\n\t\n\tdh->g = BN_dup(priv->pkey.dsa->g);\n\tdh->p = BN_dup(priv->pkey.dsa->p);\n\tdh->priv_key = BN_dup(priv->pkey.dsa->priv_key);\n\tgkt = d2i_GOST_KEY_TRANSPORT(NULL,(const unsigned char **)&p,\n\t\tin_len);\n\tif (!gkt)\n\t\t{\n\t\tGOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n\t\tDH_free(dh);\n\t\treturn 0;\n\t\t}\t\n\teph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);\n\tparam = get_encryption_params(gkt->key_agreement_info->cipher);\n\tgost_init(&cctx,param->sblock);\t\n\tOPENSSL_assert(gkt->key_agreement_info->eph_iv->length==8);\n\tmemcpy(wrappedKey,gkt->key_agreement_info->eph_iv->data,8);\n\tOPENSSL_assert(gkt->key_info->encrypted_key->length==32);\n\tmemcpy(wrappedKey+8,gkt->key_info->encrypted_key->data,32);\n\tOPENSSL_assert(gkt->key_info->imit->length==4);\n\tmemcpy(wrappedKey+40,gkt->key_info->imit->data,4);\t\n\tmake_cp_exchange_key(dh,eph_key,sharedKey);\n\tif (!keyUnwrapCryptoPro(&cctx,sharedKey,wrappedKey,key))\n\t\t{\n\t\tGOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,\n\t\t\tGOST_R_ERROR_COMPUTING_SHARED_KEY);\n\t\tgoto err;\n\t\t}\t\n\t\t\t\t\n\tEVP_PKEY_free(eph_key);\n\tGOST_KEY_TRANSPORT_free(gkt);\n\tDH_free(dh);\n\treturn 1;\nerr:\n\tEVP_PKEY_free(eph_key);\n\tGOST_KEY_TRANSPORT_free(gkt);\n\tDH_free(dh);\n\treturn -1;\n\t}", "patch_func_code": "int pkey_GOST94cp_decrypt (EVP_PKEY_CTX *ctx, unsigned char *key, size_t *key_len,const unsigned char *in, size_t in_len) {\n\tconst unsigned char *p = in;\n\tGOST_KEY_TRANSPORT *gkt = NULL;\n\tunsigned char wrappedKey[44];\n\tunsigned char sharedKey[32];\n\tgost_ctx cctx;\n\tconst struct gost_cipher_info *param=NULL;\n\tEVP_PKEY *eph_key=NULL;\n\tEVP_PKEY *priv= EVP_PKEY_CTX_get0_pkey(ctx); \n\t\n\tif (!key)\n\t\t{\n\t\t*key_len = 32;\n\t\treturn 1;\n\t\t}\t\n\t\n\tgkt = d2i_GOST_KEY_TRANSPORT(NULL,(const unsigned char **)&p,\n\t\tin_len);\n\tif (!gkt)\n\t\t{\n\t\tGOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);\n\t\treturn 0;\n\t\t}\t\n\teph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);\n\t/* No ephemeral key in the structure. Check peer key in the context\n\t */\n\tif (!eph_key) {\n\t\teph_key = EVP_PKEY_CTX_get0_peerkey(ctx);\n\t\tif (! eph_key) {\n\t\t\tGOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,\n\t\t\t\tGOST_R_NO_PEER_KEY);\n\t\t\tgoto err;\n\t\t}\n\t\t/* Increment reference count of peer key */\n\t\tCRYPTO_add(&(eph_key->references),1 ,CRYPTO_LOCK_EVP_PKEY);\n\t}\t\n\n\n\tparam = get_encryption_params(gkt->key_agreement_info->cipher);\n\tgost_init(&cctx,param->sblock);\t\n\tOPENSSL_assert(gkt->key_agreement_info->eph_iv->length==8);\n\tmemcpy(wrappedKey,gkt->key_agreement_info->eph_iv->data,8);\n\tOPENSSL_assert(gkt->key_info->encrypted_key->length==32);\n\tmemcpy(wrappedKey+8,gkt->key_info->encrypted_key->data,32);\n\tOPENSSL_assert(gkt->key_info->imit->length==4);\n\tmemcpy(wrappedKey+40,gkt->key_info->imit->data,4);\t\n\tmake_cp_exchange_key(gost_get0_priv_key(priv),eph_key,sharedKey);\n\tif (!keyUnwrapCryptoPro(&cctx,sharedKey,wrappedKey,key))\n\t\t{\n\t\tGOSTerr(GOST_F_PKEY_GOST94CP_DECRYPT,\n\t\t\tGOST_R_ERROR_COMPUTING_SHARED_KEY);\n\t\tgoto err;\n\t\t}\t\n\t\t\t\t\n\tEVP_PKEY_free(eph_key);\n\tGOST_KEY_TRANSPORT_free(gkt);\n\treturn 1;\nerr:\n\tEVP_PKEY_free(eph_key);\n\tGOST_KEY_TRANSPORT_free(gkt);\n\treturn -1;\n\t}", "before_change_lines": [2, 18, 19, 20, 26, 38, 48, 53], "raw_before_change_lines": [2, 18, 19, 20, 26, 38, 48, 53], "after_change_lines": [26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 47], "raw_after_change_lines": [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 47], "bug_lines": [2, 18, 19, 20, 26, 38, 48, 53], "added": [false, false, false, false, false, false, false, false], "idx": 398}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11205----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_21ad2f506edd48898282bcedd3657df4b80d45f5_1.json----ts_get_status_text", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_21ad2f506edd48898282bcedd3657df4b80d45f5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_21ad2f506edd48898282bcedd3657df4b80d45f5_1.json", "function_name": "ts_get_status_text", "vul_func_code": "static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text)\n{\n    int i;\n    unsigned int length = 0;\n    char *result = NULL;\n    char *p;\n\n    for (i = 0; i < sk_ASN1_UTF8STRING_num(text); ++i) {\n        ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i);\n        length += ASN1_STRING_length(current);\n        length += 1;            /* separator character */\n    }\n    if ((result = OPENSSL_malloc(length)) == NULL) {\n        TSerr(TS_F_TS_GET_STATUS_TEXT, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    for (i = 0, p = result; i < sk_ASN1_UTF8STRING_num(text); ++i) {\n        ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i);\n        length = ASN1_STRING_length(current);\n        if (i > 0)\n            *p++ = '/';\n        strncpy(p, (const char *)ASN1_STRING_data(current), length);\n        p += length;\n    }\n    *p = '\\0';\n\n    return result;\n}", "patch_func_code": "static char *ts_get_status_text(STACK_OF(ASN1_UTF8STRING) *text)\n{\n    int i;\n    int length = 0;\n    char *result = NULL;\n    char *p;\n\n    for (i = 0; i < sk_ASN1_UTF8STRING_num(text); ++i) {\n        ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i);\n        if (ASN1_STRING_length(current) > TS_MAX_STATUS_LENGTH - length - 1)\n            return NULL;\n        length += ASN1_STRING_length(current);\n        length += 1;            /* separator character */\n    }\n    if ((result = OPENSSL_malloc(length)) == NULL) {\n        TSerr(TS_F_TS_GET_STATUS_TEXT, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    for (i = 0, p = result; i < sk_ASN1_UTF8STRING_num(text); ++i) {\n        ASN1_UTF8STRING *current = sk_ASN1_UTF8STRING_value(text, i);\n        length = ASN1_STRING_length(current);\n        if (i > 0)\n            *p++ = '/';\n        strncpy(p, (const char *)ASN1_STRING_data(current), length);\n        p += length;\n    }\n    *p = '\\0';\n\n    return result;\n}", "before_change_lines": [4], "raw_before_change_lines": [4], "after_change_lines": [4, 10, 11], "raw_after_change_lines": [4, 10, 11], "bug_lines": [4], "added": [false], "idx": 399}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "11222----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2228ac0bb84eaa9490fc2c2c6edcff9c629608c9_1.json----ssl3_cbc_digest_record", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2228ac0bb84eaa9490fc2c2c6edcff9c629608c9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2228ac0bb84eaa9490fc2c2c6edcff9c629608c9_1.json", "function_name": "ssl3_cbc_digest_record", "vul_func_code": "void ssl3_cbc_digest_record(\n\tconst EVP_MD_CTX *ctx,\n\tunsigned char* md_out,\n\tsize_t* md_out_size,\n\tconst unsigned char header[13],\n\tconst unsigned char *data,\n\tsize_t data_plus_mac_size,\n\tsize_t data_plus_mac_plus_padding_size,\n\tconst unsigned char *mac_secret,\n\tunsigned mac_secret_length,\n\tchar is_sslv3)\n\t{\n\tunsigned char md_state[sizeof(SHA512_CTX)];\n\tvoid (*md_final_raw)(void *ctx, unsigned char *md_out);\n\tvoid (*md_transform)(void *ctx, const unsigned char *block);\n\tunsigned md_size, md_block_size = 64;\n\tunsigned sslv3_pad_length = 40, header_length, variance_blocks,\n\t\t len, max_mac_bytes, num_blocks,\n\t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b;\n\tunsigned int bits;\t/* at most 18 bits */\n\tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n\t/* hmac_pad is the masked HMAC key. */\n\tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\n\tunsigned char first_block[MAX_HASH_BLOCK_SIZE];\n\tunsigned char mac_out[EVP_MAX_MD_SIZE];\n\tunsigned i, j, md_out_size_u;\n\tEVP_MD_CTX md_ctx;\n\t/* mdLengthSize is the number of bytes in the length field that terminates\n\t* the hash. */\n\tunsigned md_length_size = 8;\n\n\t/* This is a, hopefully redundant, check that allows us to forget about\n\t * many possible overflows later in this function. */\n\tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);\n\n\tswitch (ctx->digest->type)\n\t\t{\n\t\tcase NID_md5:\n\t\t\tMD5_Init((MD5_CTX*)md_state);\n\t\t\tmd_final_raw = tls1_md5_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform;\n\t\t\tmd_size = 16;\n\t\t\tsslv3_pad_length = 48;\n\t\t\tbreak;\n\t\tcase NID_sha1:\n\t\t\tSHA1_Init((SHA_CTX*)md_state);\n\t\t\tmd_final_raw = tls1_sha1_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform;\n\t\t\tmd_size = 20;\n\t\t\tbreak;\n\t\tcase NID_sha224:\n\t\t\tSHA224_Init((SHA256_CTX*)md_state);\n\t\t\tmd_final_raw = tls1_sha256_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;\n\t\t\tmd_size = 224/8;\n\t\t\tbreak;\n\t\tcase NID_sha256:\n\t\t\tSHA256_Init((SHA256_CTX*)md_state);\n\t\t\tmd_final_raw = tls1_sha256_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;\n\t\t\tmd_size = 32;\n\t\t\tbreak;\n\t\tcase NID_sha384:\n\t\t\tSHA384_Init((SHA512_CTX*)md_state);\n\t\t\tmd_final_raw = tls1_sha512_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;\n\t\t\tmd_size = 384/8;\n\t\t\tmd_block_size = 128;\n\t\t\tmd_length_size = 16;\n\t\t\tbreak;\n\t\tcase NID_sha512:\n\t\t\tSHA512_Init((SHA512_CTX*)md_state);\n\t\t\tmd_final_raw = tls1_sha512_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;\n\t\t\tmd_size = 64;\n\t\t\tmd_block_size = 128;\n\t\t\tmd_length_size = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ssl3_cbc_record_digest_supported should have been\n\t\t\t * called first to check that the hash function is\n\t\t\t * supported. */\n\t\t\tOPENSSL_assert(0);\n\t\t\tif (md_out_size)\n\t\t\t\t*md_out_size = -1;\n\t\t\treturn;\n\t\t}\n\n\tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\n\tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\n\tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n\n\theader_length = 13;\n\tif (is_sslv3)\n\t\t{\n\t\theader_length =\n\t\t\tmac_secret_length +\n\t\t\tsslv3_pad_length +\n\t\t\t8 /* sequence number */ +\n\t\t\t1 /* record type */ +\n\t\t\t2 /* record length */;\n\t\t}\n\n\t/* variance_blocks is the number of blocks of the hash that we have to\n\t * calculate in constant time because they could be altered by the\n\t * padding value.\n\t *\n\t * In SSLv3, the padding must be minimal so the end of the plaintext\n\t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that\n\t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash\n\t * termination (0x80 + 64-bit length) don't fit in the final block, we\n\t * say that the final two blocks can vary based on the padding.\n\t *\n\t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n\t * required to be minimal. Therefore we say that the final six blocks\n\t * can vary based on the padding.\n\t *\n\t * Later in the function, if the message is short and there obviously\n\t * cannot be this many blocks then variance_blocks can be reduced. */\n\tvariance_blocks = is_sslv3 ? 2 : 6;\n\t/* From now on we're dealing with the MAC, which conceptually has 13\n\t * bytes of `header' before the start of the data (TLS) or 71/75 bytes\n\t * (SSLv3) */\n\tlen = data_plus_mac_plus_padding_size + header_length;\n\t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including\n\t* |header|, assuming that there's no padding. */\n\tmax_mac_bytes = len - md_size - 1;\n\t/* num_blocks is the maximum number of hash blocks. */\n\tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;\n\t/* In order to calculate the MAC in constant time we have to handle\n\t * the final blocks specially because the padding value could cause the\n\t * end to appear somewhere in the final |variance_blocks| blocks and we\n\t * can't leak where. However, |num_starting_blocks| worth of data can\n\t * be hashed right away because no padding value can affect whether\n\t * they are plaintext. */\n\tnum_starting_blocks = 0;\n\t/* k is the starting byte offset into the conceptual header||data where\n\t * we start processing. */\n\tk = 0;\n\t/* mac_end_offset is the index just past the end of the data to be\n\t * MACed. */\n\tmac_end_offset = data_plus_mac_size + header_length - md_size;\n\t/* c is the index of the 0x80 byte in the final hash block that\n\t * contains application data. */\n\tc = mac_end_offset % md_block_size;\n\t/* index_a is the hash block number that contains the 0x80 terminating\n\t * value. */\n\tindex_a = mac_end_offset / md_block_size;\n\t/* index_b is the hash block number that contains the 64-bit hash\n\t * length, in bits. */\n\tindex_b = (mac_end_offset + md_length_size) / md_block_size;\n\t/* bits is the hash-length in bits. It includes the additional hash\n\t * block for the masked HMAC key, or whole of |header| in the case of\n\t * SSLv3. */\n\n\t/* For SSLv3, if we're going to have any starting blocks then we need\n\t * at least two because the header is larger than a single block. */\n\tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0))\n\t\t{\n\t\tnum_starting_blocks = num_blocks - variance_blocks;\n\t\tk = md_block_size*num_starting_blocks;\n\t\t}\n\n\tbits = 8*mac_end_offset;\n\tif (!is_sslv3)\n\t\t{\n\t\t/* Compute the initial HMAC block. For SSLv3, the padding and\n\t\t * secret bytes are included in |header| because they take more\n\t\t * than a single block. */\n\t\tbits += 8*md_block_size;\n\t\tmemset(hmac_pad, 0, md_block_size);\n\t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\n\t\tmemcpy(hmac_pad, mac_secret, mac_secret_length);\n\t\tfor (i = 0; i < md_block_size; i++)\n\t\t\thmac_pad[i] ^= 0x36;\n\n\t\tmd_transform(md_state, hmac_pad);\n\t\t}\n\n\tmemset(length_bytes,0,md_length_size-4);\n\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24);\n\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16);\n\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8);\n\tlength_bytes[md_length_size-1] = (unsigned char)bits;\n\n\tif (k > 0)\n\t\t{\n\t\tif (is_sslv3)\n\t\t\t{\n\t\t\t/* The SSLv3 header is larger than a single block.\n\t\t\t * overhang is the number of bytes beyond a single\n\t\t\t * block that the header consumes: either 7 bytes\n\t\t\t * (SHA1) or 11 bytes (MD5). */\n\t\t\tunsigned overhang = header_length-md_block_size;\n\t\t\tmd_transform(md_state, header);\n\t\t\tmemcpy(first_block, header + md_block_size, overhang);\n\t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang);\n\t\t\tmd_transform(md_state, first_block);\n\t\t\tfor (i = 1; i < k/md_block_size - 1; i++)\n\t\t\t\tmd_transform(md_state, data + md_block_size*i - overhang);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* k is a multiple of md_block_size. */\n\t\t\tmemcpy(first_block, header, 13);\n\t\t\tmemcpy(first_block+13, data, md_block_size-13);\n\t\t\tmd_transform(md_state, first_block);\n\t\t\tfor (i = 1; i < k/md_block_size; i++)\n\t\t\t\tmd_transform(md_state, data + md_block_size*i - 13);\n\t\t\t}\n\t\t}\n\n\tmemset(mac_out, 0, sizeof(mac_out));\n\n\t/* We now process the final hash blocks. For each block, we construct\n\t * it in constant time. If the |i==index_a| then we'll include the 0x80\n\t * bytes and zero pad etc. For each block we selectively copy it, in\n\t * constant time, to |mac_out|. */\n\tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++)\n\t\t{\n\t\tunsigned char block[MAX_HASH_BLOCK_SIZE];\n\t\tunsigned char is_block_a = constant_time_eq_8(i, index_a);\n\t\tunsigned char is_block_b = constant_time_eq_8(i, index_b);\n\t\tfor (j = 0; j < md_block_size; j++)\n\t\t\t{\n\t\t\tunsigned char b = 0, is_past_c, is_past_cp1;\n\t\t\tif (k < header_length)\n\t\t\t\tb = header[k];\n\t\t\telse if (k < data_plus_mac_plus_padding_size + header_length)\n\t\t\t\tb = data[k-header_length];\n\t\t\tk++;\n\n\t\t\tis_past_c = is_block_a & constant_time_ge(j, c);\n\t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1);\n\t\t\t/* If this is the block containing the end of the\n\t\t\t * application data, and we are at the offset for the\n\t\t\t * 0x80 value, then overwrite b with 0x80. */\n\t\t\tb = (b&~is_past_c) | (0x80&is_past_c);\n\t\t\t/* If this the the block containing the end of the\n\t\t\t * application data and we're past the 0x80 value then\n\t\t\t * just write zero. */\n\t\t\tb = b&~is_past_cp1;\n\t\t\t/* If this is index_b (the final block), but not\n\t\t\t * index_a (the end of the data), then the 64-bit\n\t\t\t * length didn't fit into index_a and we're having to\n\t\t\t * add an extra block of zeros. */\n\t\t\tb &= ~is_block_b | is_block_a;\n\n\t\t\t/* The final bytes of one of the blocks contains the\n\t\t\t * length. */\n\t\t\tif (j >= md_block_size - md_length_size)\n\t\t\t\t{\n\t\t\t\t/* If this is index_b, write a length byte. */\n\t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]);\n\t\t\t\t}\n\t\t\tblock[j] = b;\n\t\t\t}\n\n\t\tmd_transform(md_state, block);\n\t\tmd_final_raw(md_state, block);\n\t\t/* If this is index_b, copy the hash value to |mac_out|. */\n\t\tfor (j = 0; j < md_size; j++)\n\t\t\tmac_out[j] |= block[j]&is_block_b;\n\t\t}\n\n\tEVP_MD_CTX_init(&md_ctx);\n\tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */);\n\tif (is_sslv3)\n\t\t{\n\t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */\n\t\tmemset(hmac_pad, 0x5c, sslv3_pad_length);\n\n\t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);\n\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);\n\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);\n\t\t}\n\telse\n\t\t{\n\t\t/* Complete the HMAC in the standard manner. */\n\t\tfor (i = 0; i < md_block_size; i++)\n\t\t\thmac_pad[i] ^= 0x6a;\n\n\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);\n\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);\n\t\t}\n\tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);\n\tif (md_out_size)\n\t\t*md_out_size = md_out_size_u;\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\t}", "patch_func_code": "void ssl3_cbc_digest_record(\n\tconst EVP_MD_CTX *ctx,\n\tunsigned char* md_out,\n\tsize_t* md_out_size,\n\tconst unsigned char header[13],\n\tconst unsigned char *data,\n\tsize_t data_plus_mac_size,\n\tsize_t data_plus_mac_plus_padding_size,\n\tconst unsigned char *mac_secret,\n\tunsigned mac_secret_length,\n\tchar is_sslv3)\n\t{\n\tunion {\tdouble align;\n\t\tunsigned char c[sizeof(SHA512_CTX)]; } md_state;\n\tvoid (*md_final_raw)(void *ctx, unsigned char *md_out);\n\tvoid (*md_transform)(void *ctx, const unsigned char *block);\n\tunsigned md_size, md_block_size = 64;\n\tunsigned sslv3_pad_length = 40, header_length, variance_blocks,\n\t\t len, max_mac_bytes, num_blocks,\n\t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b;\n\tunsigned int bits;\t/* at most 18 bits */\n\tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n\t/* hmac_pad is the masked HMAC key. */\n\tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\n\tunsigned char first_block[MAX_HASH_BLOCK_SIZE];\n\tunsigned char mac_out[EVP_MAX_MD_SIZE];\n\tunsigned i, j, md_out_size_u;\n\tEVP_MD_CTX md_ctx;\n\t/* mdLengthSize is the number of bytes in the length field that terminates\n\t* the hash. */\n\tunsigned md_length_size = 8;\n\n\t/* This is a, hopefully redundant, check that allows us to forget about\n\t * many possible overflows later in this function. */\n\tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);\n\n\tswitch (ctx->digest->type)\n\t\t{\n\t\tcase NID_md5:\n\t\t\tMD5_Init((MD5_CTX*)md_state.c);\n\t\t\tmd_final_raw = tls1_md5_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform;\n\t\t\tmd_size = 16;\n\t\t\tsslv3_pad_length = 48;\n\t\t\tbreak;\n\t\tcase NID_sha1:\n\t\t\tSHA1_Init((SHA_CTX*)md_state.c);\n\t\t\tmd_final_raw = tls1_sha1_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform;\n\t\t\tmd_size = 20;\n\t\t\tbreak;\n\t\tcase NID_sha224:\n\t\t\tSHA224_Init((SHA256_CTX*)md_state.c);\n\t\t\tmd_final_raw = tls1_sha256_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;\n\t\t\tmd_size = 224/8;\n\t\t\tbreak;\n\t\tcase NID_sha256:\n\t\t\tSHA256_Init((SHA256_CTX*)md_state.c);\n\t\t\tmd_final_raw = tls1_sha256_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;\n\t\t\tmd_size = 32;\n\t\t\tbreak;\n\t\tcase NID_sha384:\n\t\t\tSHA384_Init((SHA512_CTX*)md_state.c);\n\t\t\tmd_final_raw = tls1_sha512_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;\n\t\t\tmd_size = 384/8;\n\t\t\tmd_block_size = 128;\n\t\t\tmd_length_size = 16;\n\t\t\tbreak;\n\t\tcase NID_sha512:\n\t\t\tSHA512_Init((SHA512_CTX*)md_state.c);\n\t\t\tmd_final_raw = tls1_sha512_final_raw;\n\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;\n\t\t\tmd_size = 64;\n\t\t\tmd_block_size = 128;\n\t\t\tmd_length_size = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* ssl3_cbc_record_digest_supported should have been\n\t\t\t * called first to check that the hash function is\n\t\t\t * supported. */\n\t\t\tOPENSSL_assert(0);\n\t\t\tif (md_out_size)\n\t\t\t\t*md_out_size = -1;\n\t\t\treturn;\n\t\t}\n\n\tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\n\tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\n\tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n\n\theader_length = 13;\n\tif (is_sslv3)\n\t\t{\n\t\theader_length =\n\t\t\tmac_secret_length +\n\t\t\tsslv3_pad_length +\n\t\t\t8 /* sequence number */ +\n\t\t\t1 /* record type */ +\n\t\t\t2 /* record length */;\n\t\t}\n\n\t/* variance_blocks is the number of blocks of the hash that we have to\n\t * calculate in constant time because they could be altered by the\n\t * padding value.\n\t *\n\t * In SSLv3, the padding must be minimal so the end of the plaintext\n\t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that\n\t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash\n\t * termination (0x80 + 64-bit length) don't fit in the final block, we\n\t * say that the final two blocks can vary based on the padding.\n\t *\n\t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n\t * required to be minimal. Therefore we say that the final six blocks\n\t * can vary based on the padding.\n\t *\n\t * Later in the function, if the message is short and there obviously\n\t * cannot be this many blocks then variance_blocks can be reduced. */\n\tvariance_blocks = is_sslv3 ? 2 : 6;\n\t/* From now on we're dealing with the MAC, which conceptually has 13\n\t * bytes of `header' before the start of the data (TLS) or 71/75 bytes\n\t * (SSLv3) */\n\tlen = data_plus_mac_plus_padding_size + header_length;\n\t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including\n\t* |header|, assuming that there's no padding. */\n\tmax_mac_bytes = len - md_size - 1;\n\t/* num_blocks is the maximum number of hash blocks. */\n\tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;\n\t/* In order to calculate the MAC in constant time we have to handle\n\t * the final blocks specially because the padding value could cause the\n\t * end to appear somewhere in the final |variance_blocks| blocks and we\n\t * can't leak where. However, |num_starting_blocks| worth of data can\n\t * be hashed right away because no padding value can affect whether\n\t * they are plaintext. */\n\tnum_starting_blocks = 0;\n\t/* k is the starting byte offset into the conceptual header||data where\n\t * we start processing. */\n\tk = 0;\n\t/* mac_end_offset is the index just past the end of the data to be\n\t * MACed. */\n\tmac_end_offset = data_plus_mac_size + header_length - md_size;\n\t/* c is the index of the 0x80 byte in the final hash block that\n\t * contains application data. */\n\tc = mac_end_offset % md_block_size;\n\t/* index_a is the hash block number that contains the 0x80 terminating\n\t * value. */\n\tindex_a = mac_end_offset / md_block_size;\n\t/* index_b is the hash block number that contains the 64-bit hash\n\t * length, in bits. */\n\tindex_b = (mac_end_offset + md_length_size) / md_block_size;\n\t/* bits is the hash-length in bits. It includes the additional hash\n\t * block for the masked HMAC key, or whole of |header| in the case of\n\t * SSLv3. */\n\n\t/* For SSLv3, if we're going to have any starting blocks then we need\n\t * at least two because the header is larger than a single block. */\n\tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0))\n\t\t{\n\t\tnum_starting_blocks = num_blocks - variance_blocks;\n\t\tk = md_block_size*num_starting_blocks;\n\t\t}\n\n\tbits = 8*mac_end_offset;\n\tif (!is_sslv3)\n\t\t{\n\t\t/* Compute the initial HMAC block. For SSLv3, the padding and\n\t\t * secret bytes are included in |header| because they take more\n\t\t * than a single block. */\n\t\tbits += 8*md_block_size;\n\t\tmemset(hmac_pad, 0, md_block_size);\n\t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\n\t\tmemcpy(hmac_pad, mac_secret, mac_secret_length);\n\t\tfor (i = 0; i < md_block_size; i++)\n\t\t\thmac_pad[i] ^= 0x36;\n\n\t\tmd_transform(md_state.c, hmac_pad);\n\t\t}\n\n\tmemset(length_bytes,0,md_length_size-4);\n\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24);\n\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16);\n\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8);\n\tlength_bytes[md_length_size-1] = (unsigned char)bits;\n\n\tif (k > 0)\n\t\t{\n\t\tif (is_sslv3)\n\t\t\t{\n\t\t\t/* The SSLv3 header is larger than a single block.\n\t\t\t * overhang is the number of bytes beyond a single\n\t\t\t * block that the header consumes: either 7 bytes\n\t\t\t * (SHA1) or 11 bytes (MD5). */\n\t\t\tunsigned overhang = header_length-md_block_size;\n\t\t\tmd_transform(md_state.c, header);\n\t\t\tmemcpy(first_block, header + md_block_size, overhang);\n\t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang);\n\t\t\tmd_transform(md_state.c, first_block);\n\t\t\tfor (i = 1; i < k/md_block_size - 1; i++)\n\t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t/* k is a multiple of md_block_size. */\n\t\t\tmemcpy(first_block, header, 13);\n\t\t\tmemcpy(first_block+13, data, md_block_size-13);\n\t\t\tmd_transform(md_state.c, first_block);\n\t\t\tfor (i = 1; i < k/md_block_size; i++)\n\t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13);\n\t\t\t}\n\t\t}\n\n\tmemset(mac_out, 0, sizeof(mac_out));\n\n\t/* We now process the final hash blocks. For each block, we construct\n\t * it in constant time. If the |i==index_a| then we'll include the 0x80\n\t * bytes and zero pad etc. For each block we selectively copy it, in\n\t * constant time, to |mac_out|. */\n\tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++)\n\t\t{\n\t\tunsigned char block[MAX_HASH_BLOCK_SIZE];\n\t\tunsigned char is_block_a = constant_time_eq_8(i, index_a);\n\t\tunsigned char is_block_b = constant_time_eq_8(i, index_b);\n\t\tfor (j = 0; j < md_block_size; j++)\n\t\t\t{\n\t\t\tunsigned char b = 0, is_past_c, is_past_cp1;\n\t\t\tif (k < header_length)\n\t\t\t\tb = header[k];\n\t\t\telse if (k < data_plus_mac_plus_padding_size + header_length)\n\t\t\t\tb = data[k-header_length];\n\t\t\tk++;\n\n\t\t\tis_past_c = is_block_a & constant_time_ge(j, c);\n\t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1);\n\t\t\t/* If this is the block containing the end of the\n\t\t\t * application data, and we are at the offset for the\n\t\t\t * 0x80 value, then overwrite b with 0x80. */\n\t\t\tb = (b&~is_past_c) | (0x80&is_past_c);\n\t\t\t/* If this the the block containing the end of the\n\t\t\t * application data and we're past the 0x80 value then\n\t\t\t * just write zero. */\n\t\t\tb = b&~is_past_cp1;\n\t\t\t/* If this is index_b (the final block), but not\n\t\t\t * index_a (the end of the data), then the 64-bit\n\t\t\t * length didn't fit into index_a and we're having to\n\t\t\t * add an extra block of zeros. */\n\t\t\tb &= ~is_block_b | is_block_a;\n\n\t\t\t/* The final bytes of one of the blocks contains the\n\t\t\t * length. */\n\t\t\tif (j >= md_block_size - md_length_size)\n\t\t\t\t{\n\t\t\t\t/* If this is index_b, write a length byte. */\n\t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]);\n\t\t\t\t}\n\t\t\tblock[j] = b;\n\t\t\t}\n\n\t\tmd_transform(md_state.c, block);\n\t\tmd_final_raw(md_state.c, block);\n\t\t/* If this is index_b, copy the hash value to |mac_out|. */\n\t\tfor (j = 0; j < md_size; j++)\n\t\t\tmac_out[j] |= block[j]&is_block_b;\n\t\t}\n\n\tEVP_MD_CTX_init(&md_ctx);\n\tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */);\n\tif (is_sslv3)\n\t\t{\n\t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */\n\t\tmemset(hmac_pad, 0x5c, sslv3_pad_length);\n\n\t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);\n\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);\n\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);\n\t\t}\n\telse\n\t\t{\n\t\t/* Complete the HMAC in the standard manner. */\n\t\tfor (i = 0; i < md_block_size; i++)\n\t\t\thmac_pad[i] ^= 0x6a;\n\n\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);\n\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);\n\t\t}\n\tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);\n\tif (md_out_size)\n\t\t*md_out_size = md_out_size_u;\n\tEVP_MD_CTX_cleanup(&md_ctx);\n\t}", "before_change_lines": [13, 39, 46, 52, 58, 64, 72, 177, 195, 198, 200, 207, 209, 259, 260], "raw_before_change_lines": [13, 39, 46, 52, 58, 64, 72, 177, 195, 198, 200, 207, 209, 259, 260], "after_change_lines": [13, 14, 40, 47, 53, 59, 65, 73, 178, 196, 199, 201, 208, 210, 260, 261], "raw_after_change_lines": [13, 14, 40, 47, 53, 59, 65, 73, 178, 196, 199, 201, 208, 210, 260, 261], "bug_lines": [13, 39, 46, 52, 58, 64, 72, 177, 195, 198, 200, 207, 209, 259, 260], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 400}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "11233----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_22bb689ddbf96de75637c2607d7430c2059db46a_1.json----tls13_change_cipher_state", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_22bb689ddbf96de75637c2607d7430c2059db46a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_22bb689ddbf96de75637c2607d7430c2059db46a_1.json", "function_name": "tls13_change_cipher_state", "vul_func_code": "int tls13_change_cipher_state(SSL *s, int which)\n{\n    static const unsigned char client_handshake_traffic[] =\n        \"client handshake traffic secret\";\n    static const unsigned char client_application_traffic[] =\n        \"client application traffic secret\";\n    static const unsigned char server_handshake_traffic[] =\n        \"server handshake traffic secret\";\n    static const unsigned char server_application_traffic[] =\n        \"server application traffic secret\";\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    unsigned char *iv;\n    unsigned char secret[EVP_MAX_MD_SIZE];\n    unsigned char *insecret;\n    unsigned char *finsecret = NULL;\n    EVP_CIPHER_CTX *ciph_ctx;\n    const EVP_CIPHER *ciph = s->s3->tmp.new_sym_enc;\n    size_t ivlen, keylen, finsecretlen = 0;\n    const unsigned char *label;\n    size_t labellen;\n    int ret = 0;\n\n    if (which & SSL3_CC_READ) {\n        if (s->enc_read_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        } else {\n            s->enc_read_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_read_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_read_ctx;\n        iv = s->read_iv;\n\n        RECORD_LAYER_reset_read_sequence(&s->rlayer);\n    } else {\n        if (s->enc_write_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_write_ctx);\n        } else {\n            s->enc_write_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_write_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_write_ctx;\n        iv = s->write_iv;\n\n        RECORD_LAYER_reset_write_sequence(&s->rlayer);\n    }\n\n    if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE))\n            || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) {\n        if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->client_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = client_handshake_traffic;\n            labellen = sizeof(client_handshake_traffic) - 1;\n        } else {\n            insecret = s->session->master_key;\n            label = client_application_traffic;\n            labellen = sizeof(client_application_traffic) - 1;\n        }\n    } else {\n        if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->server_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = server_handshake_traffic;\n            labellen = sizeof(server_handshake_traffic) - 1;\n        } else {\n            insecret = s->session->master_key;\n            label = server_application_traffic;\n            labellen = sizeof(server_application_traffic) - 1;\n        }\n    }\n\n    if (!tls13_derive_secret(s, insecret, label, labellen, secret)) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* TODO(size_t): convert me */\n    keylen = EVP_CIPHER_key_length(ciph);\n    ivlen = EVP_CIPHER_iv_length(ciph);\n\n    if (!tls13_derive_key(s, secret, key, keylen)\n            || !tls13_derive_iv(s, secret, iv, ivlen)\n            || (finsecret != NULL && !tls13_derive_finishedkey(s, secret,\n                                                               finsecret,\n                                                               finsecretlen))) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, key, NULL,\n                          (which & SSL3_CC_WRITE)) <= 0) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\n    if (s->msg_callback) {\n        int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0;\n\n        if (ciph->key_len)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\n                            key, ciph->key_len, s, s->msg_callback_arg);\n\n        wh |= TLS1_RT_CRYPTO_IV;\n        s->msg_callback(2, s->version, wh, iv, ivlen, s,\n                        s->msg_callback_arg);\n    }\n#endif\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(secret, sizeof(secret));\n    OPENSSL_cleanse(key, sizeof(key));\n    return ret;\n}", "patch_func_code": "int tls13_change_cipher_state(SSL *s, int which)\n{\n    static const unsigned char client_handshake_traffic[] =\n        \"client handshake traffic secret\";\n    static const unsigned char client_application_traffic[] =\n        \"client application traffic secret\";\n    static const unsigned char server_handshake_traffic[] =\n        \"server handshake traffic secret\";\n    static const unsigned char server_application_traffic[] =\n        \"server application traffic secret\";\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    unsigned char *iv;\n    unsigned char secret[EVP_MAX_MD_SIZE];\n    unsigned char hashval[EVP_MAX_MD_SIZE];\n    unsigned char *hash = hashval;\n    unsigned char *insecret;\n    unsigned char *finsecret = NULL;\n    EVP_CIPHER_CTX *ciph_ctx;\n    const EVP_CIPHER *ciph = s->s3->tmp.new_sym_enc;\n    size_t ivlen, keylen, finsecretlen = 0;\n    const unsigned char *label;\n    size_t labellen, hashlen = 0;\n    int ret = 0;\n\n    if (which & SSL3_CC_READ) {\n        if (s->enc_read_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_read_ctx);\n        } else {\n            s->enc_read_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_read_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_read_ctx;\n        iv = s->read_iv;\n\n        RECORD_LAYER_reset_read_sequence(&s->rlayer);\n    } else {\n        if (s->enc_write_ctx != NULL) {\n            EVP_CIPHER_CTX_reset(s->enc_write_ctx);\n        } else {\n            s->enc_write_ctx = EVP_CIPHER_CTX_new();\n            if (s->enc_write_ctx == NULL) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n        }\n        ciph_ctx = s->enc_write_ctx;\n        iv = s->write_iv;\n\n        RECORD_LAYER_reset_write_sequence(&s->rlayer);\n    }\n\n    if (((which & SSL3_CC_CLIENT) && (which & SSL3_CC_WRITE))\n            || ((which & SSL3_CC_SERVER) && (which & SSL3_CC_READ))) {\n        if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->client_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = client_handshake_traffic;\n            labellen = sizeof(client_handshake_traffic) - 1;\n        } else {\n            int hashleni;\n\n            insecret = s->session->master_key;\n            label = client_application_traffic;\n            labellen = sizeof(client_application_traffic) - 1;\n            /*\n             * For this we only use the handshake hashes up until the server\n             * Finished hash. We do not include the client's Finished, which is\n             * what ssl_handshake_hash() would give us. Instead we use the\n             * previously saved value.\n             */\n            hash = s->server_finished_hash;\n            hashleni = EVP_MD_CTX_size(s->s3->handshake_dgst);\n            if (hashleni < 0) {\n                SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            hashlen = (size_t)hashleni;\n        }\n    } else {\n        if (which & SSL3_CC_HANDSHAKE) {\n            insecret = s->handshake_secret;\n            finsecret = s->server_finished_secret;\n            finsecretlen = EVP_MD_size(ssl_handshake_md(s));\n            label = server_handshake_traffic;\n            labellen = sizeof(server_handshake_traffic) - 1;\n        } else {\n            insecret = s->session->master_key;\n            label = server_application_traffic;\n            labellen = sizeof(server_application_traffic) - 1;\n        }\n    }\n\n    if (label != client_application_traffic) {\n        if (!ssl3_digest_cached_records(s, 1)\n                || !ssl_handshake_hash(s, hash, sizeof(hashval), &hashlen)) {\n            SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        /*\n         * Save the hash of handshakes up to now for use when we calculate the\n         * client application traffic secret\n         */\n        if (label == server_application_traffic)\n            memcpy(s->server_finished_hash, hash, hashlen);\n    }\n\n    if (!tls13_hkdf_expand(s, insecret, label, labellen, hash, secret,\n                           hashlen)) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* TODO(size_t): convert me */\n    keylen = EVP_CIPHER_key_length(ciph);\n    ivlen = EVP_CIPHER_iv_length(ciph);\n\n    if (!tls13_derive_key(s, secret, key, keylen)\n            || !tls13_derive_iv(s, secret, iv, ivlen)\n            || (finsecret != NULL && !tls13_derive_finishedkey(s, secret,\n                                                               finsecret,\n                                                               finsecretlen))) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, key, NULL,\n                          (which & SSL3_CC_WRITE)) <= 0) {\n        SSLerr(SSL_F_TLS13_CHANGE_CIPHER_STATE, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n#ifdef OPENSSL_SSL_TRACE_CRYPTO\n    if (s->msg_callback) {\n        int wh = which & SSL3_CC_WRITE ? TLS1_RT_CRYPTO_WRITE : 0;\n\n        if (ciph->key_len)\n            s->msg_callback(2, s->version, wh | TLS1_RT_CRYPTO_KEY,\n                            key, ciph->key_len, s, s->msg_callback_arg);\n\n        wh |= TLS1_RT_CRYPTO_IV;\n        s->msg_callback(2, s->version, wh, iv, ivlen, s,\n                        s->msg_callback_arg);\n    }\n#endif\n\n    ret = 1;\n err:\n    OPENSSL_cleanse(secret, sizeof(secret));\n    OPENSSL_cleanse(key, sizeof(key));\n    return ret;\n}", "before_change_lines": [20, 80], "raw_before_change_lines": [20, 80], "after_change_lines": [14, 15, 22, 64, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 97, 98, 99, 100, 101, 102, 105, 106, 107, 108, 109, 110, 112, 113], "raw_after_change_lines": [14, 15, 22, 64, 65, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], "bug_lines": [20, 80], "added": [false, false], "idx": 401}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "11331----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_270585c9ba35b54bd54ef547bd400f5d0e69805e_1.json----rand_pool_new", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_270585c9ba35b54bd54ef547bd400f5d0e69805e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_270585c9ba35b54bd54ef547bd400f5d0e69805e_1.json", "function_name": "rand_pool_new", "vul_func_code": "RAND_POOL *rand_pool_new(int entropy, size_t min_len, size_t max_len)\n{\n    RAND_POOL *pool = OPENSSL_zalloc(sizeof(*pool));\n\n    if (pool == NULL) {\n        RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pool->min_len = min_len;\n    pool->max_len = max_len;\n\n    pool->buffer = OPENSSL_secure_zalloc(pool->max_len);\n    if (pool->buffer == NULL) {\n        RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pool->requested_entropy = entropy;\n\n    return pool;\n\nerr:\n    OPENSSL_free(pool);\n    return NULL;\n}", "patch_func_code": "RAND_POOL *rand_pool_new(int entropy_requested, size_t min_len, size_t max_len)\n{\n    RAND_POOL *pool = OPENSSL_zalloc(sizeof(*pool));\n\n    if (pool == NULL) {\n        RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    pool->min_len = min_len;\n    pool->max_len = (max_len > RAND_POOL_MAX_LENGTH) ?\n        RAND_POOL_MAX_LENGTH : max_len;\n\n    pool->buffer = OPENSSL_secure_zalloc(pool->max_len);\n    if (pool->buffer == NULL) {\n        RANDerr(RAND_F_RAND_POOL_NEW, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    pool->entropy_requested = entropy_requested;\n\n    return pool;\n\nerr:\n    OPENSSL_free(pool);\n    return NULL;\n}", "before_change_lines": [1, 7, 11, 19], "raw_before_change_lines": [1, 7, 11, 19], "after_change_lines": [1, 7, 11, 12, 20], "raw_after_change_lines": [1, 7, 11, 12, 20], "bug_lines": [1, 7, 11, 19], "added": [false, false, false, false], "idx": 402}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11336----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_271bcea44854c3066d4ea29de803dace50b5782a_1.json----pkeyparam_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_271bcea44854c3066d4ea29de803dace50b5782a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_271bcea44854c3066d4ea29de803dace50b5782a_1.json", "function_name": "pkeyparam_main", "vul_func_code": "int pkeyparam_main(int argc, char **argv)\n{\n    ENGINE *e = NULL;\n    BIO *in = NULL, *out = NULL;\n    EVP_PKEY *pkey = NULL;\n    int text = 0, noout = 0, ret = 1;\n    OPTION_CHOICE o;\n    char *infile = NULL, *outfile = NULL, *prog;\n\n    prog = opt_init(argc, argv, pkeyparam_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(pkeyparam_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    if (argc != 0)\n        goto opthelp;\n\n    in = bio_open_default(infile, 'r', FORMAT_PEM);\n    if (in == NULL)\n        goto end;\n    out = bio_open_default(outfile, 'w', FORMAT_PEM);\n    if (out == NULL)\n        goto end;\n    pkey = PEM_read_bio_Parameters(in, NULL);\n    if (pkey == NULL) {\n        BIO_printf(bio_err, \"Error reading parameters\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (!noout)\n        PEM_write_bio_Parameters(out, pkey);\n\n    if (text)\n        EVP_PKEY_print_params(out, pkey, 0, NULL);\n\n    ret = 0;\n\n end:\n    EVP_PKEY_free(pkey);\n    release_engine(e);\n    BIO_free_all(out);\n    BIO_free(in);\n\n    return ret;\n}", "patch_func_code": "int pkeyparam_main(int argc, char **argv)\n{\n    ENGINE *e = NULL;\n    BIO *in = NULL, *out = NULL;\n    EVP_PKEY *pkey = NULL;\n    int text = 0, noout = 0, ret = 1, check = 0;\n    OPTION_CHOICE o;\n    char *infile = NULL, *outfile = NULL, *prog;\n\n    prog = opt_init(argc, argv, pkeyparam_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(pkeyparam_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    if (argc != 0)\n        goto opthelp;\n\n    in = bio_open_default(infile, 'r', FORMAT_PEM);\n    if (in == NULL)\n        goto end;\n    out = bio_open_default(outfile, 'w', FORMAT_PEM);\n    if (out == NULL)\n        goto end;\n    pkey = PEM_read_bio_Parameters(in, NULL);\n    if (pkey == NULL) {\n        BIO_printf(bio_err, \"Error reading parameters\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (check) {\n        int r;\n        EVP_PKEY_CTX *ctx;\n\n        ctx = EVP_PKEY_CTX_new(pkey, e);\n        if (ctx == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n        r = EVP_PKEY_param_check(ctx);\n\n        if (r == 1) {\n            BIO_printf(out, \"Parameters are valid\\n\");\n        } else {\n            /*\n             * Note: at least for RSA keys if this function returns\n             * -1, there will be no error reasons.\n             */\n            unsigned long err;\n\n            BIO_printf(out, \"Parameters are invalid\\n\");\n\n            while ((err = ERR_peek_error()) != 0) {\n                BIO_printf(out, \"Detailed error: %s\\n\",\n                           ERR_reason_error_string(err));\n                ERR_get_error(); /* remove err from error stack */\n            }\n        }\n        EVP_PKEY_CTX_free(ctx);\n    }\n\n    if (!noout)\n        PEM_write_bio_Parameters(out, pkey);\n\n    if (text)\n        EVP_PKEY_print_params(out, pkey, 0, NULL);\n\n    ret = 0;\n\n end:\n    EVP_PKEY_free(pkey);\n    release_engine(e);\n    BIO_free_all(out);\n    BIO_free(in);\n\n    return ret;\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6, 37, 38, 39, 59, 60, 61, 63, 64, 65, 66, 67, 69, 71, 72, 73, 75, 76, 77, 78, 80, 82, 83, 84, 85, 86, 87, 88, 89], "raw_after_change_lines": [6, 37, 38, 39, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], "bug_lines": [6], "added": [false], "idx": 403}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "11354----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_27ba45e03d7e244dc09dba2d4c7727579b51388b_1.json----BIO_dump_indent", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_27ba45e03d7e244dc09dba2d4c7727579b51388b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_27ba45e03d7e244dc09dba2d4c7727579b51388b_1.json", "function_name": "BIO_dump_indent", "vul_func_code": "int BIO_dump_indent(BIO *bio, const char *s, int len, int indent)\n\t{\n\tint ret=0;\n\tchar buf[288+1],tmp[20],str[128+1];\n\tint i,j,rows,trc;\n\tunsigned char ch;\n\tint dump_width;\n\t\n\ttrc=0;\n\t\n#ifdef TRUNCATE\n\tfor(; (len > 0) && ((s[len-1] == ' ') || (s[len-1] == '\\0')); len--) \n\t\ttrc++;\n#endif\n\n\tif (indent < 0)\n\t\tindent = 0;\n\tif (indent)\n\t\t{\n\t\tif (indent > 128) indent=128;\n\t\tmemset(str,' ',indent);\n\t\t}\n\tstr[indent]='\\0';\n\t\n\tdump_width=DUMP_WIDTH_LESS_INDENT(indent);\n\trows=(len/dump_width);\n\tif ((rows*dump_width)<len)\n\t\trows++;\n\tfor(i=0;i<rows;i++)\n\t\t{\n\t\tbuf[0]='\\0';\t/* start with empty string */\n\t\tstrcpy(buf,str);\n\t\tsprintf(tmp,\"%04x - \",i*dump_width);\n\t\tstrcat(buf,tmp);\n\t\tfor(j=0;j<dump_width;j++)\n\t\t\t{\n\t\t\tif (((i*dump_width)+j)>=len)\n\t\t\t\t{\n\t\t\t\tstrcat(buf,\"   \");\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tch=((unsigned char)*(s+i*dump_width+j)) & 0xff;\n\t\t\t\tsprintf(tmp,\"%02x%c\",ch,j==7?'-':' ');\n\t\t\t\tstrcat(buf,tmp);\n\t\t\t\t}\n\t\t\t}\n\t\tstrcat(buf,\"  \");\n\t\tfor(j=0;j<dump_width;j++)\n\t\t\t{\n\t\t\tif (((i*dump_width)+j)>=len)\n\t\t\t\tbreak;\n\t\t\tch=((unsigned char)*(s+i*dump_width+j)) & 0xff;\n#ifndef CHARSET_EBCDIC\n\t\t\tsprintf(tmp,\"%c\",((ch>=' ')&&(ch<='~'))?ch:'.');\n#else\n\t\t\tsprintf(tmp,\"%c\",((ch>=os_toascii[' '])&&(ch<=os_toascii['~']))\n\t\t\t\t? os_toebcdic[ch]\n\t\t\t\t: '.');\n#endif\n\t\t\tstrcat(buf,tmp);\n\t\t\t}\n\t\tstrcat(buf,\"\\n\");\n\t\t/* if this is the last call then update the ddt_dump thing so that\n\t\t * we will move the selection point in the debug window \n\t\t */\n\t\tret+=BIO_write(bio,(char *)buf,strlen(buf));\n\t\t}\n#ifdef TRUNCATE\n\tif (trc > 0)\n\t\t{\n\t\tsprintf(buf,\"%s%04x - <SPACES/NULS>\\n\",str,len+trc);\n\t\tret+=BIO_write(bio,(char *)buf,strlen(buf));\n\t\t}\n#endif\n\treturn(ret);\n\t}", "patch_func_code": "int BIO_dump_indent(BIO *bio, const char *s, int len, int indent)\n\t{\n\tint ret=0;\n\tchar buf[288+1],tmp[20],str[128+1];\n\tint i,j,rows,trc;\n\tunsigned char ch;\n\tint dump_width;\n\t\n\ttrc=0;\n\t\n#ifdef TRUNCATE\n\tfor(; (len > 0) && ((s[len-1] == ' ') || (s[len-1] == '\\0')); len--) \n\t\ttrc++;\n#endif\n\n\tif (indent < 0)\n\t\tindent = 0;\n\tif (indent)\n\t\t{\n\t\tif (indent > 128) indent=128;\n\t\tmemset(str,' ',indent);\n\t\t}\n\tstr[indent]='\\0';\n\t\n\tdump_width=DUMP_WIDTH_LESS_INDENT(indent);\n\trows=(len/dump_width);\n\tif ((rows*dump_width)<len)\n\t\trows++;\n\tfor(i=0;i<rows;i++)\n\t\t{\n\t\tbuf[0]='\\0';\t/* start with empty string */\n\t\tBUF_strlcpy(buf,str,sizeof buf);\n\t\tBIO_snprintf(tmp,sizeof tmp,\"%04x - \",i*dump_width);\n\t\tBUF_strlcat(buf,tmp,sizeof buf);\n\t\tfor(j=0;j<dump_width;j++)\n\t\t\t{\n\t\t\tif (((i*dump_width)+j)>=len)\n\t\t\t\t{\n\t\t\t\tBUF_strlcat(buf,\"   \",sizeof buf);\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tch=((unsigned char)*(s+i*dump_width+j)) & 0xff;\n\t\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%02x%c\",ch,\n\t\t\t\t\t j==7?'-':' ');\n\t\t\t\tBUF_strlcat(buf,tmp,sizeof buf);\n\t\t\t\t}\n\t\t\t}\n\t\tBUF_strlcat(buf,\"  \",sizeof buf);\n\t\tfor(j=0;j<dump_width;j++)\n\t\t\t{\n\t\t\tif (((i*dump_width)+j)>=len)\n\t\t\t\tbreak;\n\t\t\tch=((unsigned char)*(s+i*dump_width+j)) & 0xff;\n#ifndef CHARSET_EBCDIC\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%c\",\n\t\t\t\t ((ch>=' ')&&(ch<='~'))?ch:'.');\n#else\n\t\t\tBIO_snprintf(tmp,sizeof tmp,\"%c\",\n\t\t\t\t ((ch>=os_toascii[' '])&&(ch<=os_toascii['~']))\n\t\t\t\t ? os_toebcdic[ch]\n\t\t\t\t : '.');\n#endif\n\t\t\tBUF_strlcat(buf,tmp,sizeof buf);\n\t\t\t}\n\t\tBUF_strlcat(buf,\"\\n\",sizeof buf);\n\t\t/* if this is the last call then update the ddt_dump thing so that\n\t\t * we will move the selection point in the debug window \n\t\t */\n\t\tret+=BIO_write(bio,(char *)buf,strlen(buf));\n\t\t}\n#ifdef TRUNCATE\n\tif (trc > 0)\n\t\t{\n\t\tBIO_snprintf(buf,sizeof buf,\"%s%04x - <SPACES/NULS>\\n\",str,\n\t\t\t     len+trc);\n\t\tret+=BIO_write(bio,(char *)buf,strlen(buf));\n\t\t}\n#endif\n\treturn(ret);\n\t}", "before_change_lines": [32, 33, 34, 39, 44, 45, 48, 55, 57, 58, 59, 61, 63, 72], "raw_before_change_lines": [32, 33, 34, 39, 44, 45, 48, 55, 57, 58, 59, 61, 63, 72], "after_change_lines": [32, 33, 34, 39, 44, 45, 46, 49, 56, 57, 59, 60, 61, 62, 64, 66, 75, 76], "raw_after_change_lines": [32, 33, 34, 39, 44, 45, 46, 49, 56, 57, 59, 60, 61, 62, 64, 66, 75, 76], "bug_lines": [32, 33, 34, 39, 44, 45, 48, 55, 57, 58, 59, 61, 63, 72], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 404}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "11372----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_28261c1d353174fdc94bb2ef525e1667fd5cb888_1.json----SSL_add_ssl_module", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_28261c1d353174fdc94bb2ef525e1667fd5cb888_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_28261c1d353174fdc94bb2ef525e1667fd5cb888_1.json", "function_name": "SSL_add_ssl_module", "vul_func_code": "void SSL_add_ssl_module(void)\n{\n    CONF_module_add(\"ssl_conf\", ssl_module_init, ssl_module_free);\n}", "patch_func_code": "void SSL_add_ssl_module(void)\n{\n    /* Do nothing. This will be added automatically by libcrypto */\n}", "before_change_lines": [3, 4], "raw_before_change_lines": [3, 4], "after_change_lines": [], "raw_after_change_lines": [3], "bug_lines": [3, 4], "added": [false, false], "idx": 405}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11414----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_29472847d5b156c07bd99fa13266a9a08e80c3e7_1.json----bn_probable_prime_dh_coprime", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_29472847d5b156c07bd99fa13266a9a08e80c3e7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_29472847d5b156c07bd99fa13266a9a08e80c3e7_1.json", "function_name": "bn_probable_prime_dh_coprime", "vul_func_code": "int bn_probable_prime_dh_coprime(BIGNUM *rnd, int bits, BN_CTX *ctx)\n\t{\n\tint i;\n\tBIGNUM *offset_index;\n\tBIGNUM *offset_count;\n\tint ret = 0;\n\t\n\tBN_CTX_start(ctx);\n\tif ((offset_index = BN_CTX_get(ctx)) == NULL) goto err;\n\tif ((offset_count = BN_CTX_get(ctx)) == NULL) goto err;\n\t\n\tBN_add_word(offset_count, prime_offset_count);\n\nloop:\n\tif (!BN_rand(rnd, bits, 0, 1)) goto err;\n\tif (!BN_rand_range(offset_index, offset_count)) goto err;\n\n\tBN_mul_word(rnd, prime_multiplier);\n\tBN_add_word(rnd, prime_offsets[BN_get_word(offset_index)]);\n\n\t/* we now have a random number 'rand' to test. */\n\n\t/* skip coprimes */\n\tfor (i = first_prime_index; i < NUMPRIMES; i++)\n\t\t{\n\t\t/* check that rnd is a prime */\n\t\tif (BN_mod_word(rnd, (BN_ULONG)primes[i]) <= 1)\n\t\t\t{\n\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tbn_check_top(rnd);\n\treturn ret;\n\t}", "patch_func_code": "int bn_probable_prime_dh_coprime(BIGNUM *rnd, int bits, BN_CTX *ctx)\n\t{\n\tint i;\n\tBIGNUM *offset_index;\n\tBIGNUM *offset_count;\n\tint ret = 0;\n\n\tOPENSSL_assert(bits > prime_multiplier_bits);\n\t\n\tBN_CTX_start(ctx);\n\tif ((offset_index = BN_CTX_get(ctx)) == NULL) goto err;\n\tif ((offset_count = BN_CTX_get(ctx)) == NULL) goto err;\n\t\n\tBN_add_word(offset_count, prime_offset_count);\n\nloop:\n\tif (!BN_rand(rnd, bits - prime_multiplier_bits, 0, 1)) goto err;\n\tif (!BN_rand_range(offset_index, offset_count)) goto err;\n\n\tBN_mul_word(rnd, prime_multiplier);\n\tBN_add_word(rnd, prime_offsets[BN_get_word(offset_index)]);\n\n\t/* we now have a random number 'rand' to test. */\n\n\t/* skip coprimes */\n\tfor (i = first_prime_index; i < NUMPRIMES; i++)\n\t\t{\n\t\t/* check that rnd is a prime */\n\t\tif (BN_mod_word(rnd, (BN_ULONG)primes[i]) <= 1)\n\t\t\t{\n\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tbn_check_top(rnd);\n\treturn ret;\n\t}", "before_change_lines": [15], "raw_before_change_lines": [15], "after_change_lines": [8, 17], "raw_after_change_lines": [7, 8, 17], "bug_lines": [15], "added": [false], "idx": 406}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "11475----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2b47c1b91b47e71d3a4689a5a35fcd14f10b277b_1.json----gost_set_default_param", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2b47c1b91b47e71d3a4689a5a35fcd14f10b277b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2b47c1b91b47e71d3a4689a5a35fcd14f10b277b_1.json", "function_name": "gost_set_default_param", "vul_func_code": "int gost_set_default_param(int param, const char *value)\n{\n    const char *tmp;\n    if (param < 0 || param > GOST_PARAM_MAX)\n        return 0;\n    tmp = getenv(gost_envnames[param]);\n    /*\n     * if there is value in the environment, use it, else -passed string *\n     */\n    if (!tmp)\n        tmp = value;\n    OPENSSL_free(gost_params[param]);\n    gost_params[param] = BUF_strdup(tmp);\n\n    return 1;\n}", "patch_func_code": "int gost_set_default_param(int param, const char *value)\n{\n    const char *tmp;\n    if (param < 0 || param > GOST_PARAM_MAX)\n        return 0;\n    tmp = getenv(gost_envnames[param]);\n    /*\n     * if there is value in the environment, use it, else -passed string *\n     */\n    if (!tmp)\n        tmp = value;\n    OPENSSL_free(gost_params[param]);\n    gost_params[param] = OPENSSL_strdup(tmp);\n\n    return 1;\n}", "before_change_lines": [13], "raw_before_change_lines": [13], "after_change_lines": [13], "raw_after_change_lines": [13], "bug_lines": [13], "added": [false], "idx": 407}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11514----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2cd53e61f29e3accda637c7621f00d495d9045a9_1.json----dh_init", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2cd53e61f29e3accda637c7621f00d495d9045a9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2cd53e61f29e3accda637c7621f00d495d9045a9_1.json", "function_name": "dh_init", "vul_func_code": "static int dh_init(void *vpdhctx, OSSL_PARAM params[])\n{\n    PROV_DH_CTX *pdhctx = (PROV_DH_CTX *)vpdhctx;\n\n    DH_free(pdhctx->dh);\n    pdhctx->dh = param_to_dh(params, 1);\n\n    return pdhctx->dh != NULL;\n}", "patch_func_code": "static int dh_init(void *vpdhctx, void *vdh)\n{\n    PROV_DH_CTX *pdhctx = (PROV_DH_CTX *)vpdhctx;\n\n    DH_free(pdhctx->dh);\n    pdhctx->dh = vdh;\n    DH_up_ref(pdhctx->dh);\n\n    return pdhctx->dh != NULL;\n}", "before_change_lines": [1, 6], "raw_before_change_lines": [1, 6], "after_change_lines": [1, 6, 7], "raw_after_change_lines": [1, 6, 7], "bug_lines": [1, 6], "added": [false, false], "idx": 408}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11527----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2d2ffde7783c14431072b3a854fbdaaccadbbeaf_1.json----mem_gets", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2d2ffde7783c14431072b3a854fbdaaccadbbeaf_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2d2ffde7783c14431072b3a854fbdaaccadbbeaf_1.json", "function_name": "mem_gets", "vul_func_code": "static int mem_gets(BIO *bp, char *buf, int size)\n{\n    int i, j;\n    int ret = -1;\n    char *p;\n    BUF_MEM *bm = (BUF_MEM *)bp->ptr;\n\n    BIO_clear_retry_flags(bp);\n    j = bm->length;\n    if ((size - 1) < j)\n        j = size - 1;\n    if (j <= 0) {\n        *buf = '\\0';\n        return 0;\n    }\n    p = bm->data;\n    for (i = 0; i < j; i++) {\n        if (p[i] == '\\n') {\n            i++;\n            break;\n        }\n    }\n\n    /*\n     * i is now the max num of bytes to copy, either j or up to\n     * and including the first newline\n     */\n\n    i = mem_read(bp, buf, i);\n    if (i > 0)\n        buf[i] = '\\0';\n    ret = i;\n    return (ret);\n}", "patch_func_code": "static int mem_gets(BIO *bp, char *buf, int size)\n{\n    int i, j;\n    int ret = -1;\n    char *p;\n    BIO_BUF_MEM *bbm = (BIO_BUF_MEM *)bp->ptr;\n    BUF_MEM *bm = bbm->readp;\n\n    BIO_clear_retry_flags(bp);\n    j = bm->length;\n    if ((size - 1) < j)\n        j = size - 1;\n    if (j <= 0) {\n        *buf = '\\0';\n        return 0;\n    }\n    p = bm->data;\n    for (i = 0; i < j; i++) {\n        if (p[i] == '\\n') {\n            i++;\n            break;\n        }\n    }\n\n    /*\n     * i is now the max num of bytes to copy, either j or up to\n     * and including the first newline\n     */\n\n    i = mem_read(bp, buf, i);\n    if (i > 0)\n        buf[i] = '\\0';\n    ret = i;\n    return (ret);\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6, 7], "raw_after_change_lines": [6, 7], "bug_lines": [6], "added": [false], "idx": 409}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11529----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2d43700043cba2db2eba34a285b24f67fab2f978_1.json----ec_key_simple_priv2oct", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2d43700043cba2db2eba34a285b24f67fab2f978_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2d43700043cba2db2eba34a285b24f67fab2f978_1.json", "function_name": "ec_key_simple_priv2oct", "vul_func_code": "size_t ec_key_simple_priv2oct(const EC_KEY *eckey,\n                              unsigned char *buf, size_t len)\n{\n    size_t buf_len;\n\n    buf_len = (EC_GROUP_get_degree(eckey->group) + 7) / 8;\n    if (eckey->priv_key == NULL)\n        return 0;\n    if (buf == NULL)\n        return buf_len;\n    else if (len < buf_len)\n        return 0;\n\n    /* Octetstring may need leading zeros if BN is to short */\n\n    if (BN_bn2binpad(eckey->priv_key, buf, buf_len) == -1) {\n        ECerr(EC_F_EC_KEY_SIMPLE_PRIV2OCT, EC_R_BUFFER_TOO_SMALL);\n        return 0;\n    }\n\n    return buf_len;\n}", "patch_func_code": "size_t ec_key_simple_priv2oct(const EC_KEY *eckey,\n                              unsigned char *buf, size_t len)\n{\n    size_t buf_len;\n\n    buf_len = (EC_GROUP_order_bits(eckey->group) + 7) / 8;\n    if (eckey->priv_key == NULL)\n        return 0;\n    if (buf == NULL)\n        return buf_len;\n    else if (len < buf_len)\n        return 0;\n\n    /* Octetstring may need leading zeros if BN is to short */\n\n    if (BN_bn2binpad(eckey->priv_key, buf, buf_len) == -1) {\n        ECerr(EC_F_EC_KEY_SIMPLE_PRIV2OCT, EC_R_BUFFER_TOO_SMALL);\n        return 0;\n    }\n\n    return buf_len;\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6], "raw_after_change_lines": [6], "bug_lines": [6], "added": [false], "idx": 410}
{"project": "openssl", "vul_type": "DANGLING_POINTER_DEREFERENCE", "filepath_func": "11539----DANGLING_POINTER_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2dc577bc6beabe3d277ce39990048594fd2ee115_1.json----EVP_MAC_name", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2dc577bc6beabe3d277ce39990048594fd2ee115_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2dc577bc6beabe3d277ce39990048594fd2ee115_1.json", "function_name": "EVP_MAC_name", "vul_func_code": "const char *EVP_MAC_name(const EVP_MAC *mac)\n{\n    return mac->name;\n}", "patch_func_code": "const char *EVP_MAC_name(const EVP_MAC *mac)\n{\n    return evp_first_name(mac->prov, mac->name_id);\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 411}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11574----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_1.json----dh_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_1.json", "function_name": "dh_main", "vul_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tDH *dh=NULL;\n\tint i,badops=0,text=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat,check=0,noout=0,C=0,ret=1;\n\tchar *infile,*outfile,*prog;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-check\") == 0)\n\t\t\tcheck=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-C\") == 0)\n\t\t\tC=1;\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg   input format - one of DER PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg  output format - one of DER PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg       input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg      output file\\n\");\n\t\tBIO_printf(bio_err,\" -check        check the DH parameters\\n\");\n\t\tBIO_printf(bio_err,\" -text         print a text form of the DH parameters\\n\");\n\t\tBIO_printf(bio_err,\" -C            Output C code\\n\");\n\t\tBIO_printf(bio_err,\" -noout        no output\\n\");\n\t\tgoto end;\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif\t(informat == FORMAT_ASN1)\n\t\tdh=d2i_DHparams_bio(in,NULL);\n\telse if (informat == FORMAT_PEM)\n\t\tdh=PEM_read_bio_DHparams(in,NULL,NULL,NULL);\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified\\n\");\n\t\tgoto end;\n\t\t}\n\tif (dh == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load DH parameters\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\t\n\n\tif (text)\n\t\t{\n\t\tDHparams_print(out,dh);\n#ifdef undef\n\t\tprintf(\"p=\");\n\t\tBN_print(stdout,dh->p);\n\t\tprintf(\"\\ng=\");\n\t\tBN_print(stdout,dh->g);\n\t\tprintf(\"\\n\");\n\t\tif (dh->length != 0)\n\t\t\tprintf(\"recommended private length=%ld\\n\",dh->length);\n#endif\n\t\t}\n\t\n\tif (check)\n\t\t{\n\t\tif (!DH_check(dh,&i))\n\t\t\t{\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (i & DH_CHECK_P_NOT_PRIME)\n\t\t\tprintf(\"p value is not prime\\n\");\n\t\tif (i & DH_CHECK_P_NOT_SAFE_PRIME)\n\t\t\tprintf(\"p value is not a safe prime\\n\");\n\t\tif (i & DH_UNABLE_TO_CHECK_GENERATOR)\n\t\t\tprintf(\"unable to check the generator value\\n\");\n\t\tif (i & DH_NOT_SUITABLE_GENERATOR)\n\t\t\tprintf(\"the g value is not a generator\\n\");\n\t\tif (i == 0)\n\t\t\tprintf(\"DH parameters appear to be ok.\\n\");\n\t\t}\n\tif (C)\n\t\t{\n\t\tunsigned char *data;\n\t\tint len,l,bits;\n\n\t\tlen=BN_num_bytes(dh->p);\n\t\tbits=BN_num_bits(dh->p);\n\t\tdata=(unsigned char *)OPENSSL_malloc(len);\n\t\tif (data == NULL)\n\t\t\t{\n\t\t\tperror(\"OPENSSL_malloc\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tl=BN_bn2bin(dh->p,data);\n\t\tprintf(\"static unsigned char dh%d_p[]={\",bits);\n\t\tfor (i=0; i<l; i++)\n\t\t\t{\n\t\t\tif ((i%12) == 0) printf(\"\\n\\t\");\n\t\t\tprintf(\"0x%02X,\",data[i]);\n\t\t\t}\n\t\tprintf(\"\\n\\t};\\n\");\n\n\t\tl=BN_bn2bin(dh->g,data);\n\t\tprintf(\"static unsigned char dh%d_g[]={\",bits);\n\t\tfor (i=0; i<l; i++)\n\t\t\t{\n\t\t\tif ((i%12) == 0) printf(\"\\n\\t\");\n\t\t\tprintf(\"0x%02X,\",data[i]);\n\t\t\t}\n\t\tprintf(\"\\n\\t};\\n\\n\");\n\n\t\tprintf(\"DH *get_dh%d()\\n\\t{\\n\",bits);\n\t\tprintf(\"\\tDH *dh;\\n\\n\");\n\t\tprintf(\"\\tif ((dh=DH_new()) == NULL) return(NULL);\\n\");\n\t\tprintf(\"\\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\\n\",\n\t\t\tbits,bits);\n\t\tprintf(\"\\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\\n\",\n\t\t\tbits,bits);\n\t\tprintf(\"\\tif ((dh->p == NULL) || (dh->g == NULL))\\n\");\n\t\tprintf(\"\\t\\treturn(NULL);\\n\");\n\t\tprintf(\"\\treturn(dh);\\n\\t}\\n\");\n\t\tOPENSSL_free(data);\n\t\t}\n\n\n\tif (!noout)\n\t\t{\n\t\tif \t(outformat == FORMAT_ASN1)\n\t\t\ti=i2d_DHparams_bio(out,dh);\n\t\telse if (outformat == FORMAT_PEM)\n\t\t\ti=PEM_write_bio_DHparams(out,dh);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (!i)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to write DH parameters\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\tret=0;\nend:\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free_all(out);\n\tif (dh != NULL) DH_free(dh);\n\tEXIT(ret);\n\t}", "patch_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tENGINE *e = NULL;\n\tDH *dh=NULL;\n\tint i,badops=0,text=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat,check=0,noout=0,C=0,ret=1;\n\tchar *infile,*outfile,*prog,*engine;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tengine=NULL;\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-engine\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tengine= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-check\") == 0)\n\t\t\tcheck=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-C\") == 0)\n\t\t\tC=1;\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg   input format - one of DER PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg  output format - one of DER PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg       input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg      output file\\n\");\n\t\tBIO_printf(bio_err,\" -check        check the DH parameters\\n\");\n\t\tBIO_printf(bio_err,\" -text         print a text form of the DH parameters\\n\");\n\t\tBIO_printf(bio_err,\" -C            Output C code\\n\");\n\t\tBIO_printf(bio_err,\" -noout        no output\\n\");\n\t\tBIO_printf(bio_err,\" -engine e     use engine e, possibly a hardware device.\\n\");\n\t\tgoto end;\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tif (engine != NULL)\n\t\t{\n\t\tif((e = ENGINE_by_id(engine)) == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"invalid engine \\\"%s\\\"\\n\",\n\t\t\t\tengine);\n\t\t\tgoto end;\n\t\t\t}\n\t\tif(!ENGINE_set_default(e, ENGINE_METHOD_ALL))\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"can't use that engine\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tBIO_printf(bio_err,\"engine \\\"%s\\\" set.\\n\", engine);\n\t\t/* Free our \"structural\" reference. */\n\t\tENGINE_free(e);\n\t\t}\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif\t(informat == FORMAT_ASN1)\n\t\tdh=d2i_DHparams_bio(in,NULL);\n\telse if (informat == FORMAT_PEM)\n\t\tdh=PEM_read_bio_DHparams(in,NULL,NULL,NULL);\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified\\n\");\n\t\tgoto end;\n\t\t}\n\tif (dh == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load DH parameters\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\t\n\n\tif (text)\n\t\t{\n\t\tDHparams_print(out,dh);\n#ifdef undef\n\t\tprintf(\"p=\");\n\t\tBN_print(stdout,dh->p);\n\t\tprintf(\"\\ng=\");\n\t\tBN_print(stdout,dh->g);\n\t\tprintf(\"\\n\");\n\t\tif (dh->length != 0)\n\t\t\tprintf(\"recommended private length=%ld\\n\",dh->length);\n#endif\n\t\t}\n\t\n\tif (check)\n\t\t{\n\t\tif (!DH_check(dh,&i))\n\t\t\t{\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (i & DH_CHECK_P_NOT_PRIME)\n\t\t\tprintf(\"p value is not prime\\n\");\n\t\tif (i & DH_CHECK_P_NOT_SAFE_PRIME)\n\t\t\tprintf(\"p value is not a safe prime\\n\");\n\t\tif (i & DH_UNABLE_TO_CHECK_GENERATOR)\n\t\t\tprintf(\"unable to check the generator value\\n\");\n\t\tif (i & DH_NOT_SUITABLE_GENERATOR)\n\t\t\tprintf(\"the g value is not a generator\\n\");\n\t\tif (i == 0)\n\t\t\tprintf(\"DH parameters appear to be ok.\\n\");\n\t\t}\n\tif (C)\n\t\t{\n\t\tunsigned char *data;\n\t\tint len,l,bits;\n\n\t\tlen=BN_num_bytes(dh->p);\n\t\tbits=BN_num_bits(dh->p);\n\t\tdata=(unsigned char *)OPENSSL_malloc(len);\n\t\tif (data == NULL)\n\t\t\t{\n\t\t\tperror(\"OPENSSL_malloc\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tl=BN_bn2bin(dh->p,data);\n\t\tprintf(\"static unsigned char dh%d_p[]={\",bits);\n\t\tfor (i=0; i<l; i++)\n\t\t\t{\n\t\t\tif ((i%12) == 0) printf(\"\\n\\t\");\n\t\t\tprintf(\"0x%02X,\",data[i]);\n\t\t\t}\n\t\tprintf(\"\\n\\t};\\n\");\n\n\t\tl=BN_bn2bin(dh->g,data);\n\t\tprintf(\"static unsigned char dh%d_g[]={\",bits);\n\t\tfor (i=0; i<l; i++)\n\t\t\t{\n\t\t\tif ((i%12) == 0) printf(\"\\n\\t\");\n\t\t\tprintf(\"0x%02X,\",data[i]);\n\t\t\t}\n\t\tprintf(\"\\n\\t};\\n\\n\");\n\n\t\tprintf(\"DH *get_dh%d()\\n\\t{\\n\",bits);\n\t\tprintf(\"\\tDH *dh;\\n\\n\");\n\t\tprintf(\"\\tif ((dh=DH_new()) == NULL) return(NULL);\\n\");\n\t\tprintf(\"\\tdh->p=BN_bin2bn(dh%d_p,sizeof(dh%d_p),NULL);\\n\",\n\t\t\tbits,bits);\n\t\tprintf(\"\\tdh->g=BN_bin2bn(dh%d_g,sizeof(dh%d_g),NULL);\\n\",\n\t\t\tbits,bits);\n\t\tprintf(\"\\tif ((dh->p == NULL) || (dh->g == NULL))\\n\");\n\t\tprintf(\"\\t\\treturn(NULL);\\n\");\n\t\tprintf(\"\\treturn(dh);\\n\\t}\\n\");\n\t\tOPENSSL_free(data);\n\t\t}\n\n\n\tif (!noout)\n\t\t{\n\t\tif \t(outformat == FORMAT_ASN1)\n\t\t\ti=i2d_DHparams_bio(out,dh);\n\t\telse if (outformat == FORMAT_PEM)\n\t\t\ti=PEM_write_bio_DHparams(out,dh);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (!i)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to write DH parameters\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\tret=0;\nend:\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free_all(out);\n\tif (dh != NULL) DH_free(dh);\n\tEXIT(ret);\n\t}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [3, 8, 16, 47, 48, 49, 50, 51, 83, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 104, 105], "raw_after_change_lines": [3, 8, 16, 47, 48, 49, 50, 51, 83, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106], "bug_lines": [7], "added": [false], "idx": 412}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11575----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_1.json----DH_free", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_2f524eb395260a5b1fd3d1f7b7b0661028093ee1_1.json", "function_name": "DH_free", "vul_func_code": "void DH_free(DH *r)\n\t{\n\tint i;\n\tif(r == NULL) return;\n\ti = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH);\n#ifdef REF_PRINT\n\tREF_PRINT(\"DH\",r);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"DH_free, bad reference count\\n\");\n\t\tabort();\n\t}\n#endif\n\n\tCRYPTO_free_ex_data(dh_meth, r, &r->ex_data);\n\n\tif(r->meth->finish) r->meth->finish(r);\n\n\tif (r->p != NULL) BN_clear_free(r->p);\n\tif (r->g != NULL) BN_clear_free(r->g);\n\tif (r->q != NULL) BN_clear_free(r->q);\n\tif (r->j != NULL) BN_clear_free(r->j);\n\tif (r->seed) OPENSSL_free(r->seed);\n\tif (r->counter != NULL) BN_clear_free(r->counter);\n\tif (r->pub_key != NULL) BN_clear_free(r->pub_key);\n\tif (r->priv_key != NULL) BN_clear_free(r->priv_key);\n\tOPENSSL_free(r);\n\t}", "patch_func_code": "void DH_free(DH *r)\n\t{\n\tDH_METHOD *meth;\n\tint i;\n\tif(r == NULL) return;\n\ti = CRYPTO_add(&r->references, -1, CRYPTO_LOCK_DH);\n#ifdef REF_PRINT\n\tREF_PRINT(\"DH\",r);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"DH_free, bad reference count\\n\");\n\t\tabort();\n\t}\n#endif\n\n\tCRYPTO_free_ex_data(dh_meth, r, &r->ex_data);\n\n\tmeth = ENGINE_get_DH(r->engine);\n\tif(meth->finish) meth->finish(r);\n\tENGINE_finish(r->engine);\n\n\tif (r->p != NULL) BN_clear_free(r->p);\n\tif (r->g != NULL) BN_clear_free(r->g);\n\tif (r->q != NULL) BN_clear_free(r->q);\n\tif (r->j != NULL) BN_clear_free(r->j);\n\tif (r->seed) OPENSSL_free(r->seed);\n\tif (r->counter != NULL) BN_clear_free(r->counter);\n\tif (r->pub_key != NULL) BN_clear_free(r->pub_key);\n\tif (r->priv_key != NULL) BN_clear_free(r->priv_key);\n\tOPENSSL_free(r);\n\t}", "before_change_lines": [20], "raw_before_change_lines": [20], "after_change_lines": [3, 21, 22, 23], "raw_after_change_lines": [3, 21, 22, 23], "bug_lines": [20], "added": [false], "idx": 413}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "11597----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_303fa954d4d9f1a0dd903c4bc7841cd14843c39e_1.json----PKCS12_verify_mac", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_303fa954d4d9f1a0dd903c4bc7841cd14843c39e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_303fa954d4d9f1a0dd903c4bc7841cd14843c39e_1.json", "function_name": "PKCS12_verify_mac", "vul_func_code": "int PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)\n{\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    const ASN1_OCTET_STRING *macoct;\n\n    if (p12->mac == NULL) {\n        PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_ABSENT);\n        return 0;\n    }\n    if (!PKCS12_gen_mac(p12, pass, passlen, mac, &maclen)) {\n        PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR);\n        return 0;\n    }\n    X509_SIG_get0(p12->mac->dinfo, NULL, &macoct);\n    if ((maclen != (unsigned int)ASN1_STRING_length(macoct))\n        || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen))\n        return 0;\n    return 1;\n}", "patch_func_code": "int PKCS12_verify_mac(PKCS12 *p12, const char *pass, int passlen)\n{\n    unsigned char mac[EVP_MAX_MD_SIZE];\n    unsigned int maclen;\n    const ASN1_OCTET_STRING *macoct;\n\n    if (p12->mac == NULL) {\n        PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_ABSENT);\n        return 0;\n    }\n    if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen,\n                        PKCS12_key_gen_utf8)) {\n        PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR);\n        return 0;\n    }\n    X509_SIG_get0(p12->mac->dinfo, NULL, &macoct);\n    if (maclen != (unsigned int)ASN1_STRING_length(macoct))\n        return 0;\n\n    if (CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0) {\n        if (pass == NULL)\n            return 0;\n        /*\n         * In order to facilitate accessing old data retry with\n         * old-style broken password ...\n         */\n        if (!pkcs12_gen_mac(p12, pass, passlen, mac, &maclen,\n                            PKCS12_key_gen_asc)) {\n            PKCS12err(PKCS12_F_PKCS12_VERIFY_MAC, PKCS12_R_MAC_GENERATION_ERROR);\n            return 0;\n        }\n        if ((maclen != (unsigned int)ASN1_STRING_length(macoct))\n            || CRYPTO_memcmp(mac, ASN1_STRING_get0_data(macoct), maclen) != 0)\n            return 0;\n        else\n            PKCS12_key_gen = PKCS12_key_gen_asc;\n        /*\n         * ... and if suceeded, pass it on to PKCS12_PBE_keyivgen.\n         */\n    }\n    return 1;\n}", "before_change_lines": [11, 16, 17], "raw_before_change_lines": [11, 16, 17], "after_change_lines": [11, 12, 17, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40], "raw_after_change_lines": [11, 12, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40], "bug_lines": [11, 16, 17], "added": [false, false, false], "idx": 414}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11643----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_31ae451ec8b1bc838bff1acce280b4f1f7a48fa5_1.json----ssl3_send_client_verify", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_31ae451ec8b1bc838bff1acce280b4f1f7a48fa5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_31ae451ec8b1bc838bff1acce280b4f1f7a48fa5_1.json", "function_name": "ssl3_send_client_verify", "vul_func_code": "int ssl3_send_client_verify(SSL *s)\n\t{\n\tunsigned char *p,*d;\n\tunsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\n\tEVP_PKEY *pkey;\n\tEVP_PKEY_CTX *pctx=NULL;\n#ifndef OPENSSL_NO_RSA\n\tunsigned u=0;\n#endif\n\tunsigned long n;\n\tint j;\n\n\tif (s->state == SSL3_ST_CW_CERT_VRFY_A)\n\t\t{\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tp= &(d[4]);\n\t\tpkey=s->cert->key->privatekey;\n/* Create context from key and test if sha1 is allowed as digest */\n\t\tpctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\tEVP_PKEY_sign_init(pctx);\n\t\tif (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0)\n\t\t\t{\n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\t\tNID_sha1,\n\t\t\t\t\t\t&(data[MD5_DIGEST_LENGTH]));\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tERR_clear_error();\n\t\t\t}\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA)\n\t\t\t{\n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\tNID_md5,\n\t\t\t \t&(data[0]));\n\t\t\tif (RSA_sign(NID_md5_sha1, data,\n\t\t\t\t\t MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,\n\t\t\t\t\t&(p[2]), &u, pkey->pkey.rsa) <= 0 )\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(u,p);\n\t\t\tn=u+2;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t\t{\n\t\t\tif (!DSA_sign(pkey->save_type,\n\t\t\t\t&(data[MD5_DIGEST_LENGTH]),\n\t\t\t\tSHA_DIGEST_LENGTH,&(p[2]),\n\t\t\t\t(unsigned int *)&j,pkey->pkey.dsa))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(j,p);\n\t\t\tn=j+2;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t\t{\n\t\t\tif (!ECDSA_sign(pkey->save_type,\n\t\t\t\t&(data[MD5_DIGEST_LENGTH]),\n\t\t\t\tSHA_DIGEST_LENGTH,&(p[2]),\n\t\t\t\t(unsigned int *)&j,pkey->pkey.ec))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t    ERR_R_ECDSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(j,p);\n\t\t\tn=j+2;\n\t\t\t}\n\t\telse\n#endif\n\t\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) \n\t\t{\n\t\tunsigned char signbuf[64];\n\t\tint i;\n\t\tsize_t sigsize=64;\n\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\tNID_id_GostR3411_94,\n\t\t\tdata);\n\t\tif (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\tERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t}\n\t\tfor (i=63,j=0; i>=0; j++, i--) {\n\t\t\tp[2+j]=signbuf[i];\n\t\t}\t\n\t\ts2n(j,p);\n\t\tn=j+2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t}\n\t\t*(d++)=SSL3_MT_CERTIFICATE_VERIFY;\n\t\tl2n3(n,d);\n\n\t\ts->state=SSL3_ST_CW_CERT_VRFY_B;\n\t\ts->init_num=(int)n+4;\n\t\ts->init_off=0;\n\t\t}\n\tEVP_PKEY_CTX_free(pctx);\n\treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\nerr:\n\tEVP_PKEY_CTX_free(pctx);\n\treturn(-1);\n\t}", "patch_func_code": "int ssl3_send_client_verify(SSL *s)\n\t{\n\tunsigned char *p,*d;\n\tunsigned char data[MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH];\n\tEVP_PKEY *pkey;\n\tEVP_PKEY_CTX *pctx=NULL;\n\tEVP_MD_CTX mctx;\n\tunsigned u=0;\n\tunsigned long n;\n\tint j;\n\n\tEVP_MD_CTX_init(&mctx);\n\n\tif (s->state == SSL3_ST_CW_CERT_VRFY_A)\n\t\t{\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tp= &(d[4]);\n\t\tpkey=s->cert->key->privatekey;\n/* Create context from key and test if sha1 is allowed as digest */\n\t\tpctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\tEVP_PKEY_sign_init(pctx);\n\t\tif (EVP_PKEY_CTX_set_signature_md(pctx, EVP_sha1())>0)\n\t\t\t{\n\t\t\tif (s->version < TLS1_2_VERSION)\n\t\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t\t\tNID_sha1,\n\t\t\t\t\t\t&(data[MD5_DIGEST_LENGTH]));\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tERR_clear_error();\n\t\t\t}\n\t\t/* For TLS v1.2 send signature algorithm and signature\n\t\t * using agreed digest and cached handshake records.\n\t\t */\n\t\tif (s->version >= TLS1_2_VERSION)\n\t\t\t{\n\t\t\tlong hdatalen = 0;\n\t\t\tvoid *hdata;\n\t\t\tconst EVP_MD *md = s->cert->key->digest;\n\t\t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer,\n\t\t\t\t\t\t\t\t&hdata);\n\t\t\tif (hdatalen <= 0 || !tls12_get_sigandhash(p, pkey, md))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t\t\tERR_R_INTERNAL_ERROR);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tp += 2;\n#ifdef SSL_DEBUG\n\t\t\tfprintf(stderr, \"Using TLS 1.2 with client alg %s\\n\",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\t\tif (!EVP_SignInit_ex(&mctx, md, NULL)\n\t\t\t\t|| !EVP_SignUpdate(&mctx, hdata, hdatalen)\n\t\t\t\t|| !EVP_SignFinal(&mctx, p + 2, &u, pkey))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t\t\tERR_R_EVP_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(u,p);\n\t\t\tn = u + 4;\n\t\t\tif (!ssl3_digest_cached_records(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n#ifndef OPENSSL_NO_RSA\n\t\tif (pkey->type == EVP_PKEY_RSA)\n\t\t\t{\n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\tNID_md5,\n\t\t\t \t&(data[0]));\n\t\t\tif (RSA_sign(NID_md5_sha1, data,\n\t\t\t\t\t MD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH,\n\t\t\t\t\t&(p[2]), &u, pkey->pkey.rsa) <= 0 )\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_RSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(u,p);\n\t\t\tn=u+2;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t\t{\n\t\t\tif (!DSA_sign(pkey->save_type,\n\t\t\t\t&(data[MD5_DIGEST_LENGTH]),\n\t\t\t\tSHA_DIGEST_LENGTH,&(p[2]),\n\t\t\t\t(unsigned int *)&j,pkey->pkey.dsa))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_DSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(j,p);\n\t\t\tn=j+2;\n\t\t\t}\n\t\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t\t{\n\t\t\tif (!ECDSA_sign(pkey->save_type,\n\t\t\t\t&(data[MD5_DIGEST_LENGTH]),\n\t\t\t\tSHA_DIGEST_LENGTH,&(p[2]),\n\t\t\t\t(unsigned int *)&j,pkey->pkey.ec))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\t\t    ERR_R_ECDSA_LIB);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts2n(j,p);\n\t\t\tn=j+2;\n\t\t\t}\n\t\telse\n#endif\n\t\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001) \n\t\t{\n\t\tunsigned char signbuf[64];\n\t\tint i;\n\t\tsize_t sigsize=64;\n\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\tNID_id_GostR3411_94,\n\t\t\tdata);\n\t\tif (EVP_PKEY_sign(pctx, signbuf, &sigsize, data, 32) <= 0) {\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,\n\t\t\tERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t}\n\t\tfor (i=63,j=0; i>=0; j++, i--) {\n\t\t\tp[2+j]=signbuf[i];\n\t\t}\t\n\t\ts2n(j,p);\n\t\tn=j+2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_SEND_CLIENT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\t\tgoto err;\n\t\t}\n\t\t*(d++)=SSL3_MT_CERTIFICATE_VERIFY;\n\t\tl2n3(n,d);\n\n\t\ts->state=SSL3_ST_CW_CERT_VRFY_B;\n\t\ts->init_num=(int)n+4;\n\t\ts->init_off=0;\n\t\t}\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_CTX_free(pctx);\n\treturn(ssl3_do_write(s,SSL3_RT_HANDSHAKE));\nerr:\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_CTX_free(pctx);\n\treturn(-1);\n\t}", "before_change_lines": [7, 9, 23], "raw_before_change_lines": [7, 9, 23], "after_change_lines": [7, 12, 24, 25, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 150, 154], "raw_after_change_lines": [7, 12, 13, 24, 25, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 150, 154], "bug_lines": [7, 9, 23], "added": [false, false, false], "idx": 415}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "11659----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_320c206e31576cd13132a52b874a347ed3032c78_1.json----ssl3_get_server_hello", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_320c206e31576cd13132a52b874a347ed3032c78_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_320c206e31576cd13132a52b874a347ed3032c78_1.json", "function_name": "ssl3_get_server_hello", "vul_func_code": "int ssl3_get_server_hello(SSL *s)\n{\n    STACK_OF(SSL_CIPHER) *sk;\n    const SSL_CIPHER *c;\n    PACKET pkt, session_id;\n    size_t session_id_len;\n    unsigned char *cipherchars;\n    int i, al = SSL_AD_INTERNAL_ERROR, ok;\n    unsigned int compression;\n    long n;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n    /*\n     * Hello verify request and/or server hello version may not match so set\n     * first packet if we're negotiating version.\n     */\n    s->first_packet = 1;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SRVR_HELLO_A,\n                                   SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    s->first_packet = 0;\n    if (SSL_IS_DTLS(s)) {\n        if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n            if (s->d1->send_cookie == 0) {\n                s->s3->tmp.reuse_message = 1;\n                return 1;\n            } else {            /* already sent a cookie */\n\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n                goto f_err;\n            }\n        }\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n        goto f_err;\n    }\n\n    if (!PACKET_buf_init(&pkt, s->init_msg, n)) {\n        al = SSL_AD_INTERNAL_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n        goto f_err;\n    }\n\n    if (s->method->version == TLS_ANY_VERSION) {\n        unsigned int sversion;\n\n        if (!PACKET_get_net_2(&pkt, &sversion)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n#if TLS_MAX_VERSION != TLS1_2_VERSION\n#error Code needs updating for new TLS version\n#endif\n#ifndef OPENSSL_NO_SSL3\n        if ((sversion == SSL3_VERSION) && !(s->options & SSL_OP_NO_SSLv3)) {\n            if (FIPS_mode()) {\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                       SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);\n                al = SSL_AD_PROTOCOL_VERSION;\n                goto f_err;\n            }\n            s->method = SSLv3_client_method();\n        } else\n#endif\n        if ((sversion == TLS1_VERSION) && !(s->options & SSL_OP_NO_TLSv1)) {\n            s->method = TLSv1_client_method();\n        } else if ((sversion == TLS1_1_VERSION) &&\n                   !(s->options & SSL_OP_NO_TLSv1_1)) {\n            s->method = TLSv1_1_client_method();\n        } else if ((sversion == TLS1_2_VERSION) &&\n                   !(s->options & SSL_OP_NO_TLSv1_2)) {\n            s->method = TLSv1_2_client_method();\n        } else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n        s->session->ssl_version = s->version = s->method->version;\n\n        if (!ssl_security(s, SSL_SECOP_VERSION, 0, s->version, NULL)) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_VERSION_TOO_LOW);\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n    } else if (s->method->version == DTLS_ANY_VERSION) {\n        /* Work out correct protocol version to use */\n        unsigned int hversion;\n        int options;\n\n        if (!PACKET_get_net_2(&pkt, &hversion)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n        options = s->options;\n        if (hversion == DTLS1_2_VERSION && !(options & SSL_OP_NO_DTLSv1_2))\n            s->method = DTLSv1_2_client_method();\n        else if (tls1_suiteb(s)) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);\n            s->version = hversion;\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        } else if (hversion == DTLS1_VERSION && !(options & SSL_OP_NO_DTLSv1))\n            s->method = DTLSv1_client_method();\n        else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);\n            s->version = hversion;\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n        s->session->ssl_version = s->version = s->method->version;\n    } else {\n        unsigned char *vers;\n\n        if (!PACKET_get_bytes(&pkt, &vers, 2)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if ((vers[0] != (s->version >> 8))\n                || (vers[1] != (s->version & 0xff))) {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_SSL_VERSION);\n            s->version = (s->version & 0xff00) | vers[1];\n            al = SSL_AD_PROTOCOL_VERSION;\n            goto f_err;\n        }\n    }\n\n    /* load the server hello data */\n    /* load the server random */\n    if (!PACKET_copy_bytes(&pkt, s->s3->server_random, SSL3_RANDOM_SIZE)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    s->hit = 0;\n\n    /* Get the session-id. */\n    if (!PACKET_get_length_prefixed_1(&pkt, &session_id)) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    session_id_len = PACKET_remaining(&session_id);\n    if (session_id_len > sizeof s->session->session_id\n        || session_id_len > SSL3_SESSION_ID_SIZE) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_SSL3_SESSION_ID_TOO_LONG);\n        goto f_err;\n    }\n\n    if (!PACKET_get_bytes(&pkt, &cipherchars, TLS_CIPHER_LEN)) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n\n    /*\n     * Check if we can resume the session based on external pre-shared secret.\n     * EAP-FAST (RFC 4851) supports two types of session resumption.\n     * Resumption based on server-side state works with session IDs.\n     * Resumption based on pre-shared Protected Access Credentials (PACs)\n     * works by overriding the SessionTicket extension at the application\n     * layer, and does not send a session ID. (We do not know whether EAP-FAST\n     * servers would honour the session ID.) Therefore, the session ID alone\n     * is not a reliable indicator of session resumption, so we first check if\n     * we can resume, and later peek at the next handshake message to see if the\n     * server wants to resume.\n     */\n    if (s->version >= TLS1_VERSION && s->tls_session_secret_cb &&\n        s->session->tlsext_tick) {\n        SSL_CIPHER *pref_cipher = NULL;\n        s->session->master_key_length = sizeof(s->session->master_key);\n        if (s->tls_session_secret_cb(s, s->session->master_key,\n                                     &s->session->master_key_length,\n                                     NULL, &pref_cipher,\n                                     s->tls_session_secret_cb_arg)) {\n            s->session->cipher = pref_cipher ?\n                pref_cipher : ssl_get_cipher_by_char(s, cipherchars);\n        } else {\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, ERR_R_INTERNAL_ERROR);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    }\n\n    if (session_id_len != 0 && session_id_len == s->session->session_id_length\n        && memcmp(PACKET_data(&session_id), s->session->session_id,\n                  session_id_len) == 0) {\n        if (s->sid_ctx_length != s->session->sid_ctx_length\n            || memcmp(s->session->sid_ctx, s->sid_ctx, s->sid_ctx_length)) {\n            /* actually a client application bug */\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n                   SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT);\n            goto f_err;\n        }\n        s->hit = 1;\n    } else {\n        /*\n         * If we were trying for session-id reuse but the server\n         * didn't echo the ID, make a new SSL_SESSION.\n         * In the case of EAP-FAST and PAC, we do not send a session ID,\n         * so the PAC-based session secret is always preserved. It'll be\n         * overwritten if the server refuses resumption.\n         */\n        if (s->session->session_id_length > 0) {\n            if (!ssl_get_new_session(s, 0)) {\n                goto f_err;\n            }\n        }\n\n        s->session->session_id_length = session_id_len;\n        /* session_id_len could be 0 */\n        memcpy(s->session->session_id, PACKET_data(&session_id),\n               session_id_len);\n    }\n\n    c = ssl_get_cipher_by_char(s, cipherchars);\n    if (c == NULL) {\n        /* unknown cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_UNKNOWN_CIPHER_RETURNED);\n        goto f_err;\n    }\n    /* Set version disabled mask now we know version */\n    if (!SSL_USE_TLS1_2_CIPHERS(s))\n        s->s3->tmp.mask_ssl = SSL_TLSV1_2;\n    else\n        s->s3->tmp.mask_ssl = 0;\n    /*\n     * If it is a disabled cipher we didn't send it in client hello, so\n     * return an error.\n     */\n    if (ssl_cipher_disabled(s, c, SSL_SECOP_CIPHER_CHECK)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    sk = ssl_get_ciphers_by_id(s);\n    i = sk_SSL_CIPHER_find(sk, c);\n    if (i < 0) {\n        /* we did not say we would use this cipher */\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_WRONG_CIPHER_RETURNED);\n        goto f_err;\n    }\n\n    /*\n     * Depending on the session caching (internal/external), the cipher\n     * and/or cipher_id values may not be set. Make sure that cipher_id is\n     * set and use it for comparison.\n     */\n    if (s->session->cipher)\n        s->session->cipher_id = s->session->cipher->id;\n    if (s->hit && (s->session->cipher_id != c->id)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED);\n        goto f_err;\n    }\n    s->s3->tmp.new_cipher = c;\n    /*\n     * Don't digest cached records if no sigalgs: we may need them for client\n     * authentication.\n     */\n    if (!SSL_USE_SIGALGS(s) && !ssl3_digest_cached_records(s, 0))\n        goto f_err;\n    /* lets get the compression algorithm */\n    /* COMPRESSION */\n    if (!PACKET_get_1(&pkt, &compression)) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_LENGTH_MISMATCH);\n        al = SSL_AD_DECODE_ERROR;\n        goto f_err;\n    }\n#ifdef OPENSSL_NO_COMP\n    if (compression != 0) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    }\n    /*\n     * If compression is disabled we'd better not try to resume a session\n     * using compression.\n     */\n    if (s->session->compress_meth != 0) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_INCONSISTENT_COMPRESSION);\n        goto f_err;\n    }\n#else\n    if (s->hit && compression != s->session->compress_meth) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED);\n        goto f_err;\n    }\n    if (compression == 0)\n        comp = NULL;\n    else if (!ssl_allow_compression(s)) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_COMPRESSION_DISABLED);\n        goto f_err;\n    } else {\n        comp = ssl3_comp_find(s->ctx->comp_methods, compression);\n    }\n\n    if (compression != 0 && comp == NULL) {\n        al = SSL_AD_ILLEGAL_PARAMETER;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO,\n               SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM);\n        goto f_err;\n    } else {\n        s->s3->tmp.new_compression = comp;\n    }\n#endif\n\n    /* TLS extensions */\n    if (!ssl_parse_serverhello_tlsext(s, &pkt)) {\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_PARSE_TLSEXT);\n        goto err;\n    }\n\n    if (PACKET_remaining(&pkt) != 0) {\n        /* wrong packet length */\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_PACKET_LENGTH);\n        goto f_err;\n    }\n\n    return (1);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "patch_func_code": "int ssl3_get_server_hello(SSL *s)\n{\n    int ok, al;\n    long n;\n    /*\n     * Hello verify request and/or server hello version may not match so set\n     * first packet if we're negotiating version.\n     */\n    s->first_packet = 1;\n\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SRVR_HELLO_A,\n                                   SSL3_ST_CR_SRVR_HELLO_B, -1, 20000, &ok);\n\n    if (!ok)\n        return ((int)n);\n\n    s->first_packet = 0;\n    if (SSL_IS_DTLS(s)) {\n        if (s->s3->tmp.message_type == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n            if (s->d1->send_cookie == 0) {\n                s->s3->tmp.reuse_message = 1;\n                return 1;\n            } else {            /* already sent a cookie */\n\n                al = SSL_AD_UNEXPECTED_MESSAGE;\n                SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n                goto f_err;\n            }\n        }\n    }\n\n    if (s->s3->tmp.message_type != SSL3_MT_SERVER_HELLO) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_SERVER_HELLO, SSL_R_BAD_MESSAGE_TYPE);\n        goto f_err;\n    }\n\n    return tls_process_server_hello(s, (unsigned long)n);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "before_change_lines": [3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 50, 59, 69, 86, 93, 104, 112, 120, 131, 136, 147, 163, 196, 209, 238, 252, 261, 274, 295, 304, 310, 318, 326, 336, 343, 347, 351, 352], "raw_before_change_lines": [3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 50, 59, 69, 86, 93, 104, 112, 120, 131, 136, 147, 163, 196, 209, 238, 252, 261, 274, 295, 304, 310, 318, 326, 336, 343, 347, 351, 352], "after_change_lines": [3, 39, 40, 41, 42, 43, 44], "raw_after_change_lines": [3, 39, 40, 41, 42, 43, 44], "bug_lines": [3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 50, 59, 69, 86, 93, 104, 112, 120, 131, 136, 147, 163, 196, 209, 238, 252, 261, 274, 295, 304, 310, 318, 326, 336, 343, 347, 351, 352], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 416}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "11687----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3309fea9c831959929b9a3954c7addfad9b960e4_1.json----ASN1_UTCTIME_adj", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_3309fea9c831959929b9a3954c7addfad9b960e4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3309fea9c831959929b9a3954c7addfad9b960e4_1.json", "function_name": "ASN1_UTCTIME_adj", "vul_func_code": "ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,\n                               int offset_day, long offset_sec)\n{\n    char *p;\n    struct tm *ts;\n    struct tm data;\n    size_t len = 20;\n    int free_s = 0;\n\n    if (s == NULL) {\n        s = ASN1_UTCTIME_new();\n        if (s == NULL)\n            goto err;\n        free_s = 1;\n    }\n\n    ts = OPENSSL_gmtime(&t, &data);\n    if (ts == NULL)\n        goto err;\n\n    if (offset_day || offset_sec) {\n        if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\n            goto err;\n    }\n\n    if ((ts->tm_year < 50) || (ts->tm_year >= 150))\n        goto err;\n\n    p = (char *)s->data;\n    if ((p == NULL) || ((size_t)s->length < len)) {\n        p = OPENSSL_malloc(len);\n        if (p == NULL) {\n            ASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        OPENSSL_free(s->data);\n        s->data = (unsigned char *)p;\n    }\n\n    BIO_snprintf(p, len, \"%02d%02d%02d%02d%02d%02dZ\", ts->tm_year % 100,\n                 ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,\n                 ts->tm_sec);\n    s->length = strlen(p);\n    s->type = V_ASN1_UTCTIME;\n#ifdef CHARSET_EBCDIC_not\n    ebcdic2ascii(s->data, s->data, s->length);\n#endif\n    return (s);\n err:\n    if (free_s)\n        ASN1_UTCTIME_free(s);\n    return NULL;\n}", "patch_func_code": "ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,\n                               int offset_day, long offset_sec)\n{\n    char *p;\n    struct tm *ts;\n    struct tm data;\n    size_t len = 20;\n    int free_s = 0;\n\n    if (s == NULL) {\n        s = ASN1_UTCTIME_new();\n        if (s == NULL)\n            goto err;\n        free_s = 1;\n    }\n\n    ts = OPENSSL_gmtime(&t, &data);\n    if (ts == NULL)\n        goto err;\n\n    if (offset_day || offset_sec) {\n        if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\n            goto err;\n    }\n\n    if ((ts->tm_year < 50) || (ts->tm_year >= 150))\n        goto err;\n\n    p = (char *)s->data;\n    if ((p == NULL) || ((size_t)s->length < len)) {\n        p = OPENSSL_malloc(len);\n        if (p == NULL) {\n            ASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        OPENSSL_free(s->data);\n        s->data = (unsigned char *)p;\n    }\n\n    sprintf(p, \"%02d%02d%02d%02d%02d%02dZ\", ts->tm_year % 100,\n            ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,\n            ts->tm_sec);\n    s->length = strlen(p);\n    s->type = V_ASN1_UTCTIME;\n#ifdef CHARSET_EBCDIC_not\n    ebcdic2ascii(s->data, s->data, s->length);\n#endif\n    return (s);\n err:\n    if (free_s)\n        ASN1_UTCTIME_free(s);\n    return NULL;\n}", "before_change_lines": [40, 41, 42], "raw_before_change_lines": [40, 41, 42], "after_change_lines": [40, 41, 42], "raw_after_change_lines": [40, 41, 42], "bug_lines": [40, 41, 42], "added": [false, false, false], "idx": 417}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11744----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_34b990c39f2127305bc6002f460e7984882ad409_1.json----fmtfp", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_34b990c39f2127305bc6002f460e7984882ad409_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_34b990c39f2127305bc6002f460e7984882ad409_1.json", "function_name": "fmtfp", "vul_func_code": "static void\nfmtfp(\n    char *buffer,\n    size_t *currlen,\n    size_t maxlen,\n    LDOUBLE fvalue,\n    int min,\n    int max,\n    int flags)\n{\n    int signvalue = 0;\n    LDOUBLE ufvalue;\n    char iconvert[20];\n    char fconvert[20];\n    int iplace = 0;\n    int fplace = 0;\n    int padlen = 0;\n    int zpadlen = 0;\n    int caps = 0;\n    long intpart;\n    long fracpart;\n\n    if (max < 0)\n        max = 6;\n    ufvalue = abs_val(fvalue);\n    if (fvalue < 0)\n        signvalue = '-';\n    else if (flags & DP_F_PLUS)\n        signvalue = '+';\n    else if (flags & DP_F_SPACE)\n        signvalue = ' ';\n\n    intpart = (long)ufvalue;\n\n    /* sorry, we only support 9 digits past the decimal because of our\n       conversion method */\n    if (max > 9)\n        max = 9;\n\n    /* we \"cheat\" by converting the fractional part to integer by\n       multiplying by a factor of 10 */\n    fracpart = round((pow10(max)) * (ufvalue - intpart));\n\n    if (fracpart >= pow10(max)) {\n        intpart++;\n        fracpart -= (long)pow10(max);\n    }\n\n    /* convert integer part */\n    do {\n        iconvert[iplace++] =\n            (caps ? \"0123456789ABCDEF\"\n              : \"0123456789abcdef\")[intpart % 10];\n        intpart = (intpart / 10);\n    } while (intpart && (iplace < 20));\n    if (iplace == 20)\n        iplace--;\n    iconvert[iplace] = 0;\n\n    /* convert fractional part */\n    do {\n        fconvert[fplace++] =\n            (caps ? \"0123456789ABCDEF\"\n              : \"0123456789abcdef\")[fracpart % 10];\n        fracpart = (fracpart / 10);\n    } while (fracpart && (fplace < 20));\n    if (fplace == 20)\n        fplace--;\n    fconvert[fplace] = 0;\n\n    /* -1 for decimal point, another -1 if we are printing a sign */\n    padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\n    zpadlen = max - fplace;\n    if (zpadlen < 0)\n        zpadlen = 0;\n    if (padlen < 0)\n        padlen = 0;\n    if (flags & DP_F_MINUS)\n        padlen = -padlen;\n\n    if ((flags & DP_F_ZERO) && (padlen > 0)) {\n        if (signvalue) {\n            dopr_outch(buffer, currlen, maxlen, signvalue);\n            --padlen;\n            signvalue = 0;\n        }\n        while (padlen > 0) {\n            dopr_outch(buffer, currlen, maxlen, '0');\n            --padlen;\n        }\n    }\n    while (padlen > 0) {\n        dopr_outch(buffer, currlen, maxlen, ' ');\n        --padlen;\n    }\n    if (signvalue)\n        dopr_outch(buffer, currlen, maxlen, signvalue);\n\n    while (iplace > 0)\n        dopr_outch(buffer, currlen, maxlen, iconvert[--iplace]);\n\n    /*\n     * Decimal point. This should probably use locale to find the correct\n     * char to print out.\n     */\n    if (max > 0) {\n        dopr_outch(buffer, currlen, maxlen, '.');\n\n        while (fplace > 0)\n            dopr_outch(buffer, currlen, maxlen, fconvert[--fplace]);\n    }\n    while (zpadlen > 0) {\n        dopr_outch(buffer, currlen, maxlen, '0');\n        --zpadlen;\n    }\n\n    while (padlen < 0) {\n        dopr_outch(buffer, currlen, maxlen, ' ');\n        ++padlen;\n    }\n}", "patch_func_code": "static void\nfmtfp(\n    void (*outch_fn)(char **, size_t *, size_t *, int),\n    char **buffer,\n    size_t *currlen,\n    size_t *maxlen,\n    LDOUBLE fvalue,\n    int min,\n    int max,\n    int flags)\n{\n    int signvalue = 0;\n    LDOUBLE ufvalue;\n    char iconvert[20];\n    char fconvert[20];\n    int iplace = 0;\n    int fplace = 0;\n    int padlen = 0;\n    int zpadlen = 0;\n    int caps = 0;\n    long intpart;\n    long fracpart;\n\n    if (max < 0)\n        max = 6;\n    ufvalue = abs_val(fvalue);\n    if (fvalue < 0)\n        signvalue = '-';\n    else if (flags & DP_F_PLUS)\n        signvalue = '+';\n    else if (flags & DP_F_SPACE)\n        signvalue = ' ';\n\n    intpart = (long)ufvalue;\n\n    /* sorry, we only support 9 digits past the decimal because of our\n       conversion method */\n    if (max > 9)\n        max = 9;\n\n    /* we \"cheat\" by converting the fractional part to integer by\n       multiplying by a factor of 10 */\n    fracpart = round((pow10(max)) * (ufvalue - intpart));\n\n    if (fracpart >= pow10(max)) {\n        intpart++;\n        fracpart -= (long)pow10(max);\n    }\n\n    /* convert integer part */\n    do {\n        iconvert[iplace++] =\n            (caps ? \"0123456789ABCDEF\"\n              : \"0123456789abcdef\")[intpart % 10];\n        intpart = (intpart / 10);\n    } while (intpart && (iplace < 20));\n    if (iplace == 20)\n        iplace--;\n    iconvert[iplace] = 0;\n\n    /* convert fractional part */\n    do {\n        fconvert[fplace++] =\n            (caps ? \"0123456789ABCDEF\"\n              : \"0123456789abcdef\")[fracpart % 10];\n        fracpart = (fracpart / 10);\n    } while (fracpart && (fplace < 20));\n    if (fplace == 20)\n        fplace--;\n    fconvert[fplace] = 0;\n\n    /* -1 for decimal point, another -1 if we are printing a sign */\n    padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);\n    zpadlen = max - fplace;\n    if (zpadlen < 0)\n        zpadlen = 0;\n    if (padlen < 0)\n        padlen = 0;\n    if (flags & DP_F_MINUS)\n        padlen = -padlen;\n\n    if ((flags & DP_F_ZERO) && (padlen > 0)) {\n        if (signvalue) {\n            (*outch_fn)(buffer, currlen, maxlen, signvalue);\n            --padlen;\n            signvalue = 0;\n        }\n        while (padlen > 0) {\n            (*outch_fn)(buffer, currlen, maxlen, '0');\n            --padlen;\n        }\n    }\n    while (padlen > 0) {\n        (*outch_fn)(buffer, currlen, maxlen, ' ');\n        --padlen;\n    }\n    if (signvalue)\n        (*outch_fn)(buffer, currlen, maxlen, signvalue);\n\n    while (iplace > 0)\n        (*outch_fn)(buffer, currlen, maxlen, iconvert[--iplace]);\n\n    /*\n     * Decimal point. This should probably use locale to find the correct\n     * char to print out.\n     */\n    if (max > 0) {\n        (*outch_fn)(buffer, currlen, maxlen, '.');\n\n        while (fplace > 0)\n            (*outch_fn)(buffer, currlen, maxlen, fconvert[--fplace]);\n    }\n    while (zpadlen > 0) {\n        (*outch_fn)(buffer, currlen, maxlen, '0');\n        --zpadlen;\n    }\n\n    while (padlen < 0) {\n        (*outch_fn)(buffer, currlen, maxlen, ' ');\n        ++padlen;\n    }\n}", "before_change_lines": [3, 5, 83, 88, 93, 97, 100, 107, 110, 113, 118], "raw_before_change_lines": [3, 5, 83, 88, 93, 97, 100, 107, 110, 113, 118], "after_change_lines": [3, 4, 6, 84, 89, 94, 98, 101, 108, 111, 114, 119], "raw_after_change_lines": [3, 4, 6, 84, 89, 94, 98, 101, 108, 111, 114, 119], "bug_lines": [3, 5, 83, 88, 93, 97, 100, 107, 110, 113, 118], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 418}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11798----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_36841189f4598a55810a70cd26582f8fad1edd04_1.json----init", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_36841189f4598a55810a70cd26582f8fad1edd04_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_36841189f4598a55810a70cd26582f8fad1edd04_1.json", "function_name": "init", "vul_func_code": "static int init(DRBG_CTX *dctx, DRBG_SELFTEST_DATA *td, TEST_CTX *t)\n{\n    if (!TEST_true(RAND_DRBG_set(dctx, td->nid, td->flags))\n            || !TEST_true(RAND_DRBG_set_callbacks(dctx, kat_entropy, NULL,\n                                                  kat_nonce, NULL)))\n        return 0;\n    RAND_DRBG_set_ex_data(dctx, app_data_index, t);\n    t->ent = td->ent;\n    t->entlen = td->entlen;\n    t->nonce = td->nonce;\n    t->noncelen = td->noncelen;\n    t->entcnt = 0;\n    t->noncecnt = 0;\n    return 1;\n}", "patch_func_code": "static int init(RAND_DRBG *drbg, DRBG_SELFTEST_DATA *td, TEST_CTX *t)\n{\n    if (!TEST_true(RAND_DRBG_set(drbg, td->nid, td->flags))\n            || !TEST_true(RAND_DRBG_set_callbacks(drbg, kat_entropy, NULL,\n                                                  kat_nonce, NULL)))\n        return 0;\n    RAND_DRBG_set_ex_data(drbg, app_data_index, t);\n    t->ent = td->ent;\n    t->entlen = td->entlen;\n    t->nonce = td->nonce;\n    t->noncelen = td->noncelen;\n    t->entcnt = 0;\n    t->noncecnt = 0;\n    return 1;\n}", "before_change_lines": [1, 3, 4, 7], "raw_before_change_lines": [1, 3, 4, 7], "after_change_lines": [1, 3, 4, 7], "raw_after_change_lines": [1, 3, 4, 7], "bug_lines": [1, 3, 4, 7], "added": [false, false, false, false], "idx": 419}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11814----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3700b0bcff75f2a3f4b6309024bae1fad6f45bea_1.json----X509_NAME_cmp", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_3700b0bcff75f2a3f4b6309024bae1fad6f45bea_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3700b0bcff75f2a3f4b6309024bae1fad6f45bea_1.json", "function_name": "X509_NAME_cmp", "vul_func_code": "int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\n{\n    int ret;\n\n    /* Ensure canonical encoding is present and up to date */\n\n    if (!a->canon_enc || a->modified) {\n        ret = i2d_X509_NAME((X509_NAME *)a, NULL);\n        if (ret < 0)\n            return -2;\n    }\n\n    if (!b->canon_enc || b->modified) {\n        ret = i2d_X509_NAME((X509_NAME *)b, NULL);\n        if (ret < 0)\n            return -2;\n    }\n\n    ret = a->canon_enclen - b->canon_enclen;\n\n    if (ret)\n        return ret;\n\n    return memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);\n\n}", "patch_func_code": "int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b)\n{\n    int ret;\n\n    /* Ensure canonical encoding is present and up to date */\n\n    if (!a->canon_enc || a->modified) {\n        ret = i2d_X509_NAME((X509_NAME *)a, NULL);\n        if (ret < 0)\n            return -2;\n    }\n\n    if (!b->canon_enc || b->modified) {\n        ret = i2d_X509_NAME((X509_NAME *)b, NULL);\n        if (ret < 0)\n            return -2;\n    }\n\n    ret = a->canon_enclen - b->canon_enclen;\n\n    if (ret != 0 || a->canon_enclen == 0)\n        return ret;\n\n    return memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);\n\n}", "before_change_lines": [21], "raw_before_change_lines": [21], "after_change_lines": [21], "raw_after_change_lines": [21], "bug_lines": [21], "added": [false], "idx": 420}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "11855----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_384f1da828754015a605aef19222a60d2f80c036_1.json----verify_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_384f1da828754015a605aef19222a60d2f80c036_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_384f1da828754015a605aef19222a60d2f80c036_1.json", "function_name": "verify_main", "vul_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint i,ret=1;\n\tint purpose = -1;\n\tchar *CApath=NULL,*CAfile=NULL;\n\tchar *untfile = NULL;\n\tSTACK_OF(X509) *untrusted = NULL;\n\tX509_STORE *cert_ctx=NULL;\n\tX509_LOOKUP *lookup=NULL;\n\n\tcert_ctx=X509_STORE_new();\n\tif (cert_ctx == NULL) goto end;\n\tX509_STORE_set_verify_cb_func(cert_ctx,cb);\n\n\tERR_load_crypto_strings();\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\targc--;\n\targv++;\n\tfor (;;)\n\t\t{\n\t\tif (argc >= 1)\n\t\t\t{\n\t\t\tif (strcmp(*argv,\"-CApath\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCApath= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-CAfile\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCAfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-purpose\") == 0)\n\t\t\t\t{\n\t\t\t\tX509_PURPOSE *xptmp;\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\ti = X509_PURPOSE_get_by_sname(*(++argv));\n\t\t\t\tif(i < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err, \"unrecognized purpose\\n\");\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\txptmp = X509_PURPOSE_get0(i);\n\t\t\t\tpurpose = X509_PURPOSE_get_id(xptmp);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-untrusted\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tuntfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-help\") == 0)\n\t\t\t\tgoto end;\n\t\t\telse if (strcmp(*argv,\"-verbose\") == 0)\n\t\t\t\tv_verbose=1;\n\t\t\telse if (argv[0][0] == '-')\n\t\t\t\tgoto end;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\targc--;\n\t\t\targv++;\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t\t}\n\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file());\n\tif (lookup == NULL) abort();\n\tif (CAfile) {\n\t\ti=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM);\n\t\tif(!i) {\n\t\t\tBIO_printf(bio_err, \"Error loading file %s\\n\", CAfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\n\t\t\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir());\n\tif (lookup == NULL) abort();\n\tif (CApath) {\n\t\ti=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM);\n\t\tif(!i) {\n\t\t\tBIO_printf(bio_err, \"Error loading directory %s\\n\", CApath);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\n\n\tERR_clear_error();\n\n\tif(untfile) {\n\t\tif(!(untrusted = load_untrusted(untfile))) {\n\t\t\tBIO_printf(bio_err, \"Error loading untrusted file %s\\n\", untfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (argc < 1) check(cert_ctx, NULL, untrusted, purpose);\n\telse\n\t\tfor (i=0; i<argc; i++)\n\t\t\tcheck(cert_ctx,argv[i], untrusted, purpose);\n\tret=0;\nend:\n\tif (ret == 1) {\n\t\tBIO_printf(bio_err,\"usage: verify [-verbose] [-CApath path] [-CAfile file] [-purpose purpose] cert1 cert2 ...\\n\");\n\t\tBIO_printf(bio_err,\"recognized usages:\\n\");\n\t\tfor(i = 0; i < X509_PURPOSE_get_count(); i++) {\n\t\t\tX509_PURPOSE *ptmp;\n\t\t\tptmp = X509_PURPOSE_get0(i);\n\t\t\tBIO_printf(bio_err, \"\\t%-10s\\t%s\\n\", X509_PURPOSE_get0_sname(ptmp),\n\t\t\t\t\t\t\t\tX509_PURPOSE_get0_name(ptmp));\n\t\t}\n\t}\n\tif (cert_ctx != NULL) X509_STORE_free(cert_ctx);\n\tsk_X509_pop_free(untrusted, X509_free);\n\tEXIT(ret);\n\t}", "patch_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint i,ret=1;\n\tint purpose = -1;\n\tchar *CApath=NULL,*CAfile=NULL;\n\tchar *untfile = NULL, *trustfile = NULL;\n\tSTACK_OF(X509) *untrusted = NULL, *trusted = NULL;\n\tX509_STORE *cert_ctx=NULL;\n\tX509_LOOKUP *lookup=NULL;\n\n\tcert_ctx=X509_STORE_new();\n\tif (cert_ctx == NULL) goto end;\n\tX509_STORE_set_verify_cb_func(cert_ctx,cb);\n\n\tERR_load_crypto_strings();\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\targc--;\n\targv++;\n\tfor (;;)\n\t\t{\n\t\tif (argc >= 1)\n\t\t\t{\n\t\t\tif (strcmp(*argv,\"-CApath\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCApath= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-CAfile\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCAfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-purpose\") == 0)\n\t\t\t\t{\n\t\t\t\tX509_PURPOSE *xptmp;\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\ti = X509_PURPOSE_get_by_sname(*(++argv));\n\t\t\t\tif(i < 0)\n\t\t\t\t\t{\n\t\t\t\t\tBIO_printf(bio_err, \"unrecognized purpose\\n\");\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\txptmp = X509_PURPOSE_get0(i);\n\t\t\t\tpurpose = X509_PURPOSE_get_id(xptmp);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-untrusted\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tuntfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-trusted\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\ttrustfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-help\") == 0)\n\t\t\t\tgoto end;\n\t\t\telse if (strcmp(*argv,\"-verbose\") == 0)\n\t\t\t\tv_verbose=1;\n\t\t\telse if (argv[0][0] == '-')\n\t\t\t\tgoto end;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\targc--;\n\t\t\targv++;\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t\t}\n\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file());\n\tif (lookup == NULL) abort();\n\tif (CAfile) {\n\t\ti=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM);\n\t\tif(!i) {\n\t\t\tBIO_printf(bio_err, \"Error loading file %s\\n\", CAfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\n\t\t\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir());\n\tif (lookup == NULL) abort();\n\tif (CApath) {\n\t\ti=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM);\n\t\tif(!i) {\n\t\t\tBIO_printf(bio_err, \"Error loading directory %s\\n\", CApath);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\n\n\tERR_clear_error();\n\n\tif(untfile) {\n\t\tif(!(untrusted = load_untrusted(untfile))) {\n\t\t\tBIO_printf(bio_err, \"Error loading untrusted file %s\\n\", untfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif(trustfile) {\n\t\tif(!(trusted = load_untrusted(trustfile))) {\n\t\t\tBIO_printf(bio_err, \"Error loading untrusted file %s\\n\", trustfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (argc < 1) check(cert_ctx, NULL, untrusted, trusted, purpose);\n\telse\n\t\tfor (i=0; i<argc; i++)\n\t\t\tcheck(cert_ctx,argv[i], untrusted, trusted, purpose);\n\tret=0;\nend:\n\tif (ret == 1) {\n\t\tBIO_printf(bio_err,\"usage: verify [-verbose] [-CApath path] [-CAfile file] [-purpose purpose] cert1 cert2 ...\\n\");\n\t\tBIO_printf(bio_err,\"recognized usages:\\n\");\n\t\tfor(i = 0; i < X509_PURPOSE_get_count(); i++) {\n\t\t\tX509_PURPOSE *ptmp;\n\t\t\tptmp = X509_PURPOSE_get0(i);\n\t\t\tBIO_printf(bio_err, \"\\t%-10s\\t%s\\n\", X509_PURPOSE_get0_sname(ptmp),\n\t\t\t\t\t\t\t\tX509_PURPOSE_get0_name(ptmp));\n\t\t}\n\t}\n\tif (cert_ctx != NULL) X509_STORE_free(cert_ctx);\n\tsk_X509_pop_free(untrusted, X509_free);\n\tsk_X509_pop_free(trusted, X509_free);\n\tEXIT(ret);\n\t}", "before_change_lines": [6, 7, 104, 107], "raw_before_change_lines": [6, 7, 104, 107], "after_change_lines": [6, 7, 57, 58, 59, 60, 61, 109, 110, 111, 112, 113, 114, 115, 117, 120, 135], "raw_after_change_lines": [6, 7, 57, 58, 59, 60, 61, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 135], "bug_lines": [6, 7, 104, 107], "added": [false, false, false, false], "idx": 421}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "11905----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_39a7eef2677c635a5ea55709a085fa393817ecc7_1.json----def_load_bio", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_39a7eef2677c635a5ea55709a085fa393817ecc7_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_39a7eef2677c635a5ea55709a085fa393817ecc7_1.json", "function_name": "def_load_bio", "vul_func_code": "static int def_load_bio(CONF *conf, BIO *in, long *line)\n{\n/* The macro BUFSIZE conflicts with a system macro in VxWorks */\n#define CONFBUFSIZE     512\n    int bufnum = 0, i, ii;\n    BUF_MEM *buff = NULL;\n    char *s, *p, *end;\n    int again;\n    long eline = 0;\n    char btmp[DECIMAL_SIZE(eline) + 1];\n    CONF_VALUE *v = NULL, *tv;\n    CONF_VALUE *sv = NULL;\n    char *section = NULL, *buf;\n    char *start, *psection, *pname;\n    void *h = (void *)(conf->data);\n\n    if ((buff = BUF_MEM_new()) == NULL) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);\n        goto err;\n    }\n\n    section = BUF_strdup(\"default\");\n    if (section == NULL) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (_CONF_new_data(conf) == 0) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    sv = _CONF_new_section(conf, section);\n    if (sv == NULL) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n        goto err;\n    }\n\n    bufnum = 0;\n    again = 0;\n    for (;;) {\n        if (!BUF_MEM_grow(buff, bufnum + CONFBUFSIZE)) {\n            CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);\n            goto err;\n        }\n        p = &(buff->data[bufnum]);\n        *p = '\\0';\n        BIO_gets(in, p, CONFBUFSIZE - 1);\n        p[CONFBUFSIZE - 1] = '\\0';\n        ii = i = strlen(p);\n        if (i == 0 && !again)\n            break;\n        again = 0;\n        while (i > 0) {\n            if ((p[i - 1] != '\\r') && (p[i - 1] != '\\n'))\n                break;\n            else\n                i--;\n        }\n        /*\n         * we removed some trailing stuff so there is a new line on the end.\n         */\n        if (ii && i == ii)\n            again = 1;          /* long line */\n        else {\n            p[i] = '\\0';\n            eline++;            /* another input line */\n        }\n\n        /* we now have a line with trailing \\r\\n removed */\n\n        /* i is the number of bytes */\n        bufnum += i;\n\n        v = NULL;\n        /* check for line continuation */\n        if (bufnum >= 1) {\n            /*\n             * If we have bytes and the last char '\\\\' and second last char\n             * is not '\\\\'\n             */\n            p = &(buff->data[bufnum - 1]);\n            if (IS_ESC(conf, p[0]) && ((bufnum <= 1) || !IS_ESC(conf, p[-1]))) {\n                bufnum--;\n                again = 1;\n            }\n        }\n        if (again)\n            continue;\n        bufnum = 0;\n        buf = buff->data;\n\n        clear_comments(conf, buf);\n        s = eat_ws(conf, buf);\n        if (IS_EOF(conf, *s))\n            continue;           /* blank line */\n        if (*s == '[') {\n            char *ss;\n\n            s++;\n            start = eat_ws(conf, s);\n            ss = start;\n again:\n            end = eat_alpha_numeric(conf, ss);\n            p = eat_ws(conf, end);\n            if (*p != ']') {\n                if (*p != '\\0' && ss != p) {\n                    ss = p;\n                    goto again;\n                }\n                CONFerr(CONF_F_DEF_LOAD_BIO,\n                        CONF_R_MISSING_CLOSE_SQUARE_BRACKET);\n                goto err;\n            }\n            *end = '\\0';\n            if (!str_copy(conf, NULL, &section, start))\n                goto err;\n            if ((sv = _CONF_get_section(conf, section)) == NULL)\n                sv = _CONF_new_section(conf, section);\n            if (sv == NULL) {\n                CONFerr(CONF_F_DEF_LOAD_BIO,\n                        CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n                goto err;\n            }\n            continue;\n        } else {\n            pname = s;\n            psection = NULL;\n            end = eat_alpha_numeric(conf, s);\n            if ((end[0] == ':') && (end[1] == ':')) {\n                *end = '\\0';\n                end += 2;\n                psection = pname;\n                pname = end;\n                end = eat_alpha_numeric(conf, end);\n            }\n            p = eat_ws(conf, end);\n            if (*p != '=') {\n                CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN);\n                goto err;\n            }\n            *end = '\\0';\n            p++;\n            start = eat_ws(conf, p);\n            while (!IS_EOF(conf, *p))\n                p++;\n            p--;\n            while ((p != start) && (IS_WS(conf, *p)))\n                p--;\n            p++;\n            *p = '\\0';\n\n            if ((v = OPENSSL_malloc(sizeof(*v))) == NULL) {\n                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            if (psection == NULL)\n                psection = section;\n            v->name = OPENSSL_malloc(strlen(pname) + 1);\n            v->value = NULL;\n            if (v->name == NULL) {\n                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            BUF_strlcpy(v->name, pname, strlen(pname) + 1);\n            if (!str_copy(conf, psection, &(v->value), start))\n                goto err;\n\n            if (strcmp(psection, section) != 0) {\n                if ((tv = _CONF_get_section(conf, psection))\n                    == NULL)\n                    tv = _CONF_new_section(conf, psection);\n                if (tv == NULL) {\n                    CONFerr(CONF_F_DEF_LOAD_BIO,\n                            CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n                    goto err;\n                }\n            } else\n                tv = sv;\n            if (_CONF_add_string(conf, tv, v) == 0) {\n                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            v = NULL;\n        }\n    }\n    BUF_MEM_free(buff);\n    OPENSSL_free(section);\n    return (1);\n err:\n    BUF_MEM_free(buff);\n    OPENSSL_free(section);\n    if (line != NULL)\n        *line = eline;\n    BIO_snprintf(btmp, sizeof btmp, \"%ld\", eline);\n    ERR_add_error_data(2, \"line \", btmp);\n    if (h != conf->data) {\n        CONF_free(conf->data);\n        conf->data = NULL;\n    }\n    if (v != NULL) {\n        OPENSSL_free(v->name);\n        OPENSSL_free(v->value);\n        OPENSSL_free(v);\n    }\n    return (0);\n}", "patch_func_code": "static int def_load_bio(CONF *conf, BIO *in, long *line)\n{\n/* The macro BUFSIZE conflicts with a system macro in VxWorks */\n#define CONFBUFSIZE     512\n    int bufnum = 0, i, ii;\n    BUF_MEM *buff = NULL;\n    char *s, *p, *end;\n    int again;\n    long eline = 0;\n    char btmp[DECIMAL_SIZE(eline) + 1];\n    CONF_VALUE *v = NULL, *tv;\n    CONF_VALUE *sv = NULL;\n    char *section = NULL, *buf;\n    char *start, *psection, *pname;\n    void *h = (void *)(conf->data);\n\n    if ((buff = BUF_MEM_new()) == NULL) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);\n        goto err;\n    }\n\n    section = OPENSSL_strdup(\"default\");\n    if (section == NULL) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (_CONF_new_data(conf) == 0) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    sv = _CONF_new_section(conf, section);\n    if (sv == NULL) {\n        CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n        goto err;\n    }\n\n    bufnum = 0;\n    again = 0;\n    for (;;) {\n        if (!BUF_MEM_grow(buff, bufnum + CONFBUFSIZE)) {\n            CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_BUF_LIB);\n            goto err;\n        }\n        p = &(buff->data[bufnum]);\n        *p = '\\0';\n        BIO_gets(in, p, CONFBUFSIZE - 1);\n        p[CONFBUFSIZE - 1] = '\\0';\n        ii = i = strlen(p);\n        if (i == 0 && !again)\n            break;\n        again = 0;\n        while (i > 0) {\n            if ((p[i - 1] != '\\r') && (p[i - 1] != '\\n'))\n                break;\n            else\n                i--;\n        }\n        /*\n         * we removed some trailing stuff so there is a new line on the end.\n         */\n        if (ii && i == ii)\n            again = 1;          /* long line */\n        else {\n            p[i] = '\\0';\n            eline++;            /* another input line */\n        }\n\n        /* we now have a line with trailing \\r\\n removed */\n\n        /* i is the number of bytes */\n        bufnum += i;\n\n        v = NULL;\n        /* check for line continuation */\n        if (bufnum >= 1) {\n            /*\n             * If we have bytes and the last char '\\\\' and second last char\n             * is not '\\\\'\n             */\n            p = &(buff->data[bufnum - 1]);\n            if (IS_ESC(conf, p[0]) && ((bufnum <= 1) || !IS_ESC(conf, p[-1]))) {\n                bufnum--;\n                again = 1;\n            }\n        }\n        if (again)\n            continue;\n        bufnum = 0;\n        buf = buff->data;\n\n        clear_comments(conf, buf);\n        s = eat_ws(conf, buf);\n        if (IS_EOF(conf, *s))\n            continue;           /* blank line */\n        if (*s == '[') {\n            char *ss;\n\n            s++;\n            start = eat_ws(conf, s);\n            ss = start;\n again:\n            end = eat_alpha_numeric(conf, ss);\n            p = eat_ws(conf, end);\n            if (*p != ']') {\n                if (*p != '\\0' && ss != p) {\n                    ss = p;\n                    goto again;\n                }\n                CONFerr(CONF_F_DEF_LOAD_BIO,\n                        CONF_R_MISSING_CLOSE_SQUARE_BRACKET);\n                goto err;\n            }\n            *end = '\\0';\n            if (!str_copy(conf, NULL, &section, start))\n                goto err;\n            if ((sv = _CONF_get_section(conf, section)) == NULL)\n                sv = _CONF_new_section(conf, section);\n            if (sv == NULL) {\n                CONFerr(CONF_F_DEF_LOAD_BIO,\n                        CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n                goto err;\n            }\n            continue;\n        } else {\n            pname = s;\n            psection = NULL;\n            end = eat_alpha_numeric(conf, s);\n            if ((end[0] == ':') && (end[1] == ':')) {\n                *end = '\\0';\n                end += 2;\n                psection = pname;\n                pname = end;\n                end = eat_alpha_numeric(conf, end);\n            }\n            p = eat_ws(conf, end);\n            if (*p != '=') {\n                CONFerr(CONF_F_DEF_LOAD_BIO, CONF_R_MISSING_EQUAL_SIGN);\n                goto err;\n            }\n            *end = '\\0';\n            p++;\n            start = eat_ws(conf, p);\n            while (!IS_EOF(conf, *p))\n                p++;\n            p--;\n            while ((p != start) && (IS_WS(conf, *p)))\n                p--;\n            p++;\n            *p = '\\0';\n\n            if ((v = OPENSSL_malloc(sizeof(*v))) == NULL) {\n                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            if (psection == NULL)\n                psection = section;\n            v->name = OPENSSL_malloc(strlen(pname) + 1);\n            v->value = NULL;\n            if (v->name == NULL) {\n                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            OPENSSL_strlcpy(v->name, pname, strlen(pname) + 1);\n            if (!str_copy(conf, psection, &(v->value), start))\n                goto err;\n\n            if (strcmp(psection, section) != 0) {\n                if ((tv = _CONF_get_section(conf, psection))\n                    == NULL)\n                    tv = _CONF_new_section(conf, psection);\n                if (tv == NULL) {\n                    CONFerr(CONF_F_DEF_LOAD_BIO,\n                            CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n                    goto err;\n                }\n            } else\n                tv = sv;\n            if (_CONF_add_string(conf, tv, v) == 0) {\n                CONFerr(CONF_F_DEF_LOAD_BIO, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            v = NULL;\n        }\n    }\n    BUF_MEM_free(buff);\n    OPENSSL_free(section);\n    return (1);\n err:\n    BUF_MEM_free(buff);\n    OPENSSL_free(section);\n    if (line != NULL)\n        *line = eline;\n    BIO_snprintf(btmp, sizeof btmp, \"%ld\", eline);\n    ERR_add_error_data(2, \"line \", btmp);\n    if (h != conf->data) {\n        CONF_free(conf->data);\n        conf->data = NULL;\n    }\n    if (v != NULL) {\n        OPENSSL_free(v->name);\n        OPENSSL_free(v->value);\n        OPENSSL_free(v);\n    }\n    return (0);\n}", "before_change_lines": [22, 165], "raw_before_change_lines": [22, 165], "after_change_lines": [22, 165], "raw_after_change_lines": [22, 165], "bug_lines": [22, 165], "added": [false, false], "idx": 422}
{"project": "openssl", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "11978----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3bbde94becb16b0600d03a5b9ce2a1be93ad9b1f_1.json----RAND_query_egd_bytes", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_3bbde94becb16b0600d03a5b9ce2a1be93ad9b1f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3bbde94becb16b0600d03a5b9ce2a1be93ad9b1f_1.json", "function_name": "RAND_query_egd_bytes", "vul_func_code": "int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\n\t{\n\tint ret = 0;\n\tstruct sockaddr_un addr;\n\tint len, num, numbytes;\n\tint fd = -1;\n\tint success;\n\tunsigned char egdbuf[2], tempbuf[255], *retrievebuf;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tif (strlen(path) >= sizeof(addr.sun_path))\n\t\treturn (-1);\n\tstrcpy(addr.sun_path,path);\n\tlen = offsetof(struct sockaddr_un, sun_path) + strlen(path);\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd == -1) return (-1);\n\tsuccess = 0;\n\twhile (!success)\n\t    {\n\t    if (connect(fd, (struct sockaddr *)&addr, len) == 0)\n\t       success = 1;\n\t    else\n\t\t{\n\t\tswitch (errno)\n\t\t    {\n#ifdef EINTR\n\t\t    case EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    case EAGAIN:\n#endif\n#ifdef EINPROGRESS\n\t\t    case EINPROGRESS:\n#endif\n#ifdef EALREADY\n\t\t    case EALREADY:\n#endif\n\t\t\t/* No error, try again */\n\t\t\tbreak;\n#ifdef EISCONN\n\t\t    case EISCONN:\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n#endif\n\t\t    default:\n\t\t\tgoto err;\t/* failure */\n\t\t    }\n\t\t}\n\t    }\n\n\twhile(bytes > 0)\n\t    {\n\t    egdbuf[0] = 1;\n\t    egdbuf[1] = bytes < 255 ? bytes : 255;\n\t    numbytes = 0;\n\t    while (numbytes != 2)\n\t\t{\n\t        num = write(fd, egdbuf + numbytes, 2 - numbytes);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    numbytes = 0;\n\t    while (numbytes != 1)\n\t\t{\n\t        num = read(fd, egdbuf, 1);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    if(egdbuf[0] == 0)\n\t\tgoto err;\n\t    if (buf)\n\t\tretrievebuf = buf + ret;\n\t    else\n\t\tretrievebuf = tempbuf;\n\t    numbytes = 0;\n\t    while (numbytes != egdbuf[0])\n\t\t{\n\t        num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    ret += egdbuf[0];\n\t    bytes -= egdbuf[0];\n\t    if (!buf)\n\t\tRAND_seed(tempbuf, egdbuf[0]);\n\t    }\n err:\n\tif (fd != -1) close(fd);\n\treturn(ret);\n\t}", "patch_func_code": "int RAND_query_egd_bytes(const char *path, unsigned char *buf, int bytes)\n\t{\n\tint ret = 0;\n\tstruct sockaddr_un addr;\n\tint len, num, numbytes;\n\tint fd = -1;\n\tint success;\n\tunsigned char egdbuf[2], tempbuf[255], *retrievebuf;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tif (strlen(path) >= sizeof(addr.sun_path))\n\t\treturn (-1);\n\tBUF_strlcpy(addr.sun_path,path,sizeof addr.sun_path);\n\tlen = offsetof(struct sockaddr_un, sun_path) + strlen(path);\n\tfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (fd == -1) return (-1);\n\tsuccess = 0;\n\twhile (!success)\n\t    {\n\t    if (connect(fd, (struct sockaddr *)&addr, len) == 0)\n\t       success = 1;\n\t    else\n\t\t{\n\t\tswitch (errno)\n\t\t    {\n#ifdef EINTR\n\t\t    case EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    case EAGAIN:\n#endif\n#ifdef EINPROGRESS\n\t\t    case EINPROGRESS:\n#endif\n#ifdef EALREADY\n\t\t    case EALREADY:\n#endif\n\t\t\t/* No error, try again */\n\t\t\tbreak;\n#ifdef EISCONN\n\t\t    case EISCONN:\n\t\t\tsuccess = 1;\n\t\t\tbreak;\n#endif\n\t\t    default:\n\t\t\tgoto err;\t/* failure */\n\t\t    }\n\t\t}\n\t    }\n\n\twhile(bytes > 0)\n\t    {\n\t    egdbuf[0] = 1;\n\t    egdbuf[1] = bytes < 255 ? bytes : 255;\n\t    numbytes = 0;\n\t    while (numbytes != 2)\n\t\t{\n\t        num = write(fd, egdbuf + numbytes, 2 - numbytes);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    numbytes = 0;\n\t    while (numbytes != 1)\n\t\t{\n\t        num = read(fd, egdbuf, 1);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    if(egdbuf[0] == 0)\n\t\tgoto err;\n\t    if (buf)\n\t\tretrievebuf = buf + ret;\n\t    else\n\t\tretrievebuf = tempbuf;\n\t    numbytes = 0;\n\t    while (numbytes != egdbuf[0])\n\t\t{\n\t        num = read(fd, retrievebuf + numbytes, egdbuf[0] - numbytes);\n\t        if (num >= 0)\n\t\t    numbytes += num;\n\t    \telse\n\t\t    {\n\t\t    switch (errno)\n\t\t    \t{\n#ifdef EINTR\n\t\t    \tcase EINTR:\n#endif\n#ifdef EAGAIN\n\t\t    \tcase EAGAIN:\n#endif\n\t\t\t    /* No error, try again */\n\t\t\t    break;\n\t\t    \tdefault:\n\t\t\t    ret = -1;\n\t\t\t    goto err;\t/* failure */\n\t\t\t}\n\t\t    }\n\t\t}\n\t    ret += egdbuf[0];\n\t    bytes -= egdbuf[0];\n\t    if (!buf)\n\t\tRAND_seed(tempbuf, egdbuf[0]);\n\t    }\n err:\n\tif (fd != -1) close(fd);\n\treturn(ret);\n\t}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [14], "raw_after_change_lines": [14], "bug_lines": [14], "added": [false], "idx": 423}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12030----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3d9a93cd6dec970aea7f1d787536c15caf5ad0a2_1.json----tls_construct_client_hello", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_3d9a93cd6dec970aea7f1d787536c15caf5ad0a2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3d9a93cd6dec970aea7f1d787536c15caf5ad0a2_1.json", "function_name": "tls_construct_client_hello", "vul_func_code": "int tls_construct_client_hello(SSL *s, WPACKET *pkt)\n{\n    unsigned char *p;\n    size_t sess_id_len;\n    int i, protverr;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n    SSL_SESSION *sess = s->session;\n    unsigned char *session_id;\n\n    if (!WPACKET_set_max_size(pkt, SSL3_RT_MAX_PLAIN_LENGTH)) {\n        /* Should not happen */\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* Work out what SSL/TLS/DTLS version to use */\n    protverr = ssl_set_client_hello_version(s);\n    if (protverr != 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 protverr);\n        return 0;\n    }\n\n    if (sess == NULL\n            || !ssl_version_supported(s, sess->ssl_version, NULL)\n            || !SSL_SESSION_is_resumable(sess)) {\n        if (s->hello_retry_request == SSL_HRR_NONE\n                && !ssl_get_new_session(s, 0)) {\n            /* SSLfatal() already called */\n            return 0;\n        }\n    }\n    /* else use the pre-loaded session */\n\n    p = s->s3->client_random;\n\n    /*\n     * for DTLS if client_random is initialized, reuse it, we are\n     * required to use same upon reply to HelloVerify\n     */\n    if (SSL_IS_DTLS(s)) {\n        size_t idx;\n        i = 1;\n        for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n            if (p[idx]) {\n                i = 0;\n                break;\n            }\n        }\n    } else {\n        i = (s->hello_retry_request == SSL_HRR_NONE);\n    }\n\n    if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random),\n                                   DOWNGRADE_NONE) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /*-\n     * version indicates the negotiated version: for example from\n     * an SSLv2/v3 compatible client hello). The client_version\n     * field is the maximum version we permit and it is also\n     * used in RSA encrypted premaster secrets. Some servers can\n     * choke if we initially report a higher version then\n     * renegotiate to a lower one in the premaster secret. This\n     * didn't happen with TLS 1.0 as most servers supported it\n     * but it can with TLS 1.1 or later if the server only supports\n     * 1.0.\n     *\n     * Possible scenario with previous logic:\n     *      1. Client hello indicates TLS 1.2\n     *      2. Server hello says TLS 1.0\n     *      3. RSA encrypted premaster secret uses 1.2.\n     *      4. Handshake proceeds using TLS 1.0.\n     *      5. Server sends hello request to renegotiate.\n     *      6. Client hello indicates TLS v1.0 as we now\n     *         know that is maximum server supports.\n     *      7. Server chokes on RSA encrypted premaster secret\n     *         containing version 1.0.\n     *\n     * For interoperability it should be OK to always use the\n     * maximum version we support in client hello and then rely\n     * on the checking of version to ensure the servers isn't\n     * being inconsistent: for example initially negotiating with\n     * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n     * client_version in client hello and not resetting it to\n     * the negotiated version.\n     *\n     * For TLS 1.3 we always set the ClientHello version to 1.2 and rely on the\n     * supported_versions extension for the real supported versions.\n     */\n    if (!WPACKET_put_bytes_u16(pkt, s->client_version)\n            || !WPACKET_memcpy(pkt, s->s3->client_random, SSL3_RANDOM_SIZE)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* Session ID */\n    session_id = s->session->session_id;\n    if (s->new_session || s->session->ssl_version == TLS1_3_VERSION) {\n        if (s->version == TLS1_3_VERSION\n                && (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0) {\n            sess_id_len = sizeof(s->tmp_session_id);\n            s->tmp_session_id_len = sess_id_len;\n            session_id = s->tmp_session_id;\n            if (s->hello_retry_request == SSL_HRR_NONE\n                    && RAND_bytes(s->tmp_session_id, sess_id_len) <= 0) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                         ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        } else {\n            sess_id_len = 0;\n        }\n    } else {\n        assert(s->session->session_id_length <= sizeof(s->session->session_id));\n        sess_id_len = s->session->session_id_length;\n        if (s->version == TLS1_3_VERSION) {\n            s->tmp_session_id_len = sess_id_len;\n            memcpy(s->tmp_session_id, s->session->session_id, sess_id_len);\n        }\n    }\n    if (!WPACKET_start_sub_packet_u8(pkt)\n            || (sess_id_len != 0 && !WPACKET_memcpy(pkt, session_id,\n                                                    sess_id_len))\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* cookie stuff for DTLS */\n    if (SSL_IS_DTLS(s)) {\n        if (s->d1->cookie_len > sizeof(s->d1->cookie)\n                || !WPACKET_sub_memcpy_u8(pkt, s->d1->cookie,\n                                          s->d1->cookie_len)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                     ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n    /* Ciphers supported */\n    if (!WPACKET_start_sub_packet_u16(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (!ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), pkt)) {\n        /* SSLfatal() already called */\n        return 0;\n    }\n    if (!WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* COMPRESSION */\n    if (!WPACKET_start_sub_packet_u8(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n#ifndef OPENSSL_NO_COMP\n    if (ssl_allow_compression(s)\n            && s->ctx->comp_methods\n            && (SSL_IS_DTLS(s) || s->s3->tmp.max_ver < TLS1_3_VERSION)) {\n        int compnum = sk_SSL_COMP_num(s->ctx->comp_methods);\n        for (i = 0; i < compnum; i++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n            if (!WPACKET_put_bytes_u8(pkt, comp->id)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                         ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        }\n    }\n#endif\n    /* Add the NULL method */\n    if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* TLS extensions */\n    if (!tls_construct_extensions(s, pkt, SSL_EXT_CLIENT_HELLO, NULL, 0)) {\n        /* SSLfatal() already called */\n        return 0;\n    }\n\n    return 1;\n}", "patch_func_code": "int tls_construct_client_hello(SSL *s, WPACKET *pkt)\n{\n    unsigned char *p;\n    size_t sess_id_len;\n    int i, protverr;\n#ifndef OPENSSL_NO_COMP\n    SSL_COMP *comp;\n#endif\n    SSL_SESSION *sess = s->session;\n    unsigned char *session_id;\n\n    /* Work out what SSL/TLS/DTLS version to use */\n    protverr = ssl_set_client_hello_version(s);\n    if (protverr != 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 protverr);\n        return 0;\n    }\n\n    if (sess == NULL\n            || !ssl_version_supported(s, sess->ssl_version, NULL)\n            || !SSL_SESSION_is_resumable(sess)) {\n        if (s->hello_retry_request == SSL_HRR_NONE\n                && !ssl_get_new_session(s, 0)) {\n            /* SSLfatal() already called */\n            return 0;\n        }\n    }\n    /* else use the pre-loaded session */\n\n    p = s->s3->client_random;\n\n    /*\n     * for DTLS if client_random is initialized, reuse it, we are\n     * required to use same upon reply to HelloVerify\n     */\n    if (SSL_IS_DTLS(s)) {\n        size_t idx;\n        i = 1;\n        for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {\n            if (p[idx]) {\n                i = 0;\n                break;\n            }\n        }\n    } else {\n        i = (s->hello_retry_request == SSL_HRR_NONE);\n    }\n\n    if (i && ssl_fill_hello_random(s, 0, p, sizeof(s->s3->client_random),\n                                   DOWNGRADE_NONE) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /*-\n     * version indicates the negotiated version: for example from\n     * an SSLv2/v3 compatible client hello). The client_version\n     * field is the maximum version we permit and it is also\n     * used in RSA encrypted premaster secrets. Some servers can\n     * choke if we initially report a higher version then\n     * renegotiate to a lower one in the premaster secret. This\n     * didn't happen with TLS 1.0 as most servers supported it\n     * but it can with TLS 1.1 or later if the server only supports\n     * 1.0.\n     *\n     * Possible scenario with previous logic:\n     *      1. Client hello indicates TLS 1.2\n     *      2. Server hello says TLS 1.0\n     *      3. RSA encrypted premaster secret uses 1.2.\n     *      4. Handshake proceeds using TLS 1.0.\n     *      5. Server sends hello request to renegotiate.\n     *      6. Client hello indicates TLS v1.0 as we now\n     *         know that is maximum server supports.\n     *      7. Server chokes on RSA encrypted premaster secret\n     *         containing version 1.0.\n     *\n     * For interoperability it should be OK to always use the\n     * maximum version we support in client hello and then rely\n     * on the checking of version to ensure the servers isn't\n     * being inconsistent: for example initially negotiating with\n     * TLS 1.0 and renegotiating with TLS 1.2. We do this by using\n     * client_version in client hello and not resetting it to\n     * the negotiated version.\n     *\n     * For TLS 1.3 we always set the ClientHello version to 1.2 and rely on the\n     * supported_versions extension for the real supported versions.\n     */\n    if (!WPACKET_put_bytes_u16(pkt, s->client_version)\n            || !WPACKET_memcpy(pkt, s->s3->client_random, SSL3_RANDOM_SIZE)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* Session ID */\n    session_id = s->session->session_id;\n    if (s->new_session || s->session->ssl_version == TLS1_3_VERSION) {\n        if (s->version == TLS1_3_VERSION\n                && (s->options & SSL_OP_ENABLE_MIDDLEBOX_COMPAT) != 0) {\n            sess_id_len = sizeof(s->tmp_session_id);\n            s->tmp_session_id_len = sess_id_len;\n            session_id = s->tmp_session_id;\n            if (s->hello_retry_request == SSL_HRR_NONE\n                    && RAND_bytes(s->tmp_session_id, sess_id_len) <= 0) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                         ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        } else {\n            sess_id_len = 0;\n        }\n    } else {\n        assert(s->session->session_id_length <= sizeof(s->session->session_id));\n        sess_id_len = s->session->session_id_length;\n        if (s->version == TLS1_3_VERSION) {\n            s->tmp_session_id_len = sess_id_len;\n            memcpy(s->tmp_session_id, s->session->session_id, sess_id_len);\n        }\n    }\n    if (!WPACKET_start_sub_packet_u8(pkt)\n            || (sess_id_len != 0 && !WPACKET_memcpy(pkt, session_id,\n                                                    sess_id_len))\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* cookie stuff for DTLS */\n    if (SSL_IS_DTLS(s)) {\n        if (s->d1->cookie_len > sizeof(s->d1->cookie)\n                || !WPACKET_sub_memcpy_u8(pkt, s->d1->cookie,\n                                          s->d1->cookie_len)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                     ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n    /* Ciphers supported */\n    if (!WPACKET_start_sub_packet_u16(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (!ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), pkt)) {\n        /* SSLfatal() already called */\n        return 0;\n    }\n    if (!WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* COMPRESSION */\n    if (!WPACKET_start_sub_packet_u8(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n#ifndef OPENSSL_NO_COMP\n    if (ssl_allow_compression(s)\n            && s->ctx->comp_methods\n            && (SSL_IS_DTLS(s) || s->s3->tmp.max_ver < TLS1_3_VERSION)) {\n        int compnum = sk_SSL_COMP_num(s->ctx->comp_methods);\n        for (i = 0; i < compnum; i++) {\n            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);\n            if (!WPACKET_put_bytes_u8(pkt, comp->id)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                         ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        }\n    }\n#endif\n    /* Add the NULL method */\n    if (!WPACKET_put_bytes_u8(pkt, 0) || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_CLIENT_HELLO,\n                 ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* TLS extensions */\n    if (!tls_construct_extensions(s, pkt, SSL_EXT_CLIENT_HELLO, NULL, 0)) {\n        /* SSLfatal() already called */\n        return 0;\n    }\n\n    return 1;\n}", "before_change_lines": [12, 14, 15, 16, 17], "raw_before_change_lines": [12, 13, 14, 15, 16, 17, 18], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [12, 13, 14, 15, 16, 17, 18], "added": [false, false, false, false, false, false, false], "idx": 424}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "12049----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3e70f359de36b613d89a7fc82ee78b0d29c2c72a_1.json----ssl_add_clienthello_tlsext", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_3e70f359de36b613d89a7fc82ee78b0d29c2c72a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3e70f359de36b613d89a7fc82ee78b0d29c2c72a_1.json", "function_name": "ssl_add_clienthello_tlsext", "vul_func_code": "unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit, int *al)\n\t{\n\tint extdatalen=0;\n\tunsigned char *ret = p;\n#ifndef OPENSSL_NO_EC\n\t/* See if we support any ECC ciphersuites */\n\tint using_ecc = 0;\n\tif (s->version >= TLS1_VERSION || SSL_IS_DTLS(s))\n\t\t{\n\t\tint i;\n\t\tunsigned long alg_k, alg_a;\n\t\tSTACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);\n\n\t\tfor (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++)\n\t\t\t{\n\t\t\tSSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);\n\n\t\t\talg_k = c->algorithm_mkey;\n\t\t\talg_a = c->algorithm_auth;\n\t\t\tif ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)\n\t\t\t\t|| (alg_a & SSL_aECDSA)))\n\t\t\t\t{\n\t\t\t\tusing_ecc = 1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t/* don't add extensions for SSLv3 unless doing secure renegotiation */\n\tif (s->client_version == SSL3_VERSION\n\t\t\t\t\t&& !s->s3->send_connection_binding)\n\t\treturn p;\n\n\tret+=2;\n\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n \tif (s->tlsext_hostname != NULL)\n\t\t{ \n\t\t/* Add TLS extension servername to the Client Hello message */\n\t\tunsigned long size_str;\n\t\tlong lenmax; \n\n\t\t/* check for enough space.\n\t\t   4 for the servername type and entension length\n\t\t   2 for servernamelist length\n\t\t   1 for the hostname type\n\t\t   2 for hostname length\n\t\t   + hostname length \n\t\t*/\n\t\t   \n\t\tif ((lenmax = limit - ret - 9) < 0 \n\t\t    || (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) \n\t\t\treturn NULL;\n\t\t\t\n\t\t/* extension type and length */\n\t\ts2n(TLSEXT_TYPE_server_name,ret); \n\t\ts2n(size_str+5,ret);\n\t\t\n\t\t/* length of servername list */\n\t\ts2n(size_str+3,ret);\n\t\n\t\t/* hostname type, length and hostname */\n\t\t*(ret++) = (unsigned char) TLSEXT_NAMETYPE_host_name;\n\t\ts2n(size_str,ret);\n\t\tmemcpy(ret, s->tlsext_hostname, size_str);\n\t\tret+=size_str;\n\t\t}\n\n        /* Add RI if renegotiating */\n        if (s->renegotiate)\n          {\n          int el;\n          \n          if(!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0))\n              {\n              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          if((limit - p - 4 - el) < 0) return NULL;\n          \n          s2n(TLSEXT_TYPE_renegotiate,ret);\n          s2n(el,ret);\n\n          if(!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el))\n              {\n              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          ret += el;\n        }\n\n#ifndef OPENSSL_NO_SRP\n\t/* Add SRP username if there is one */\n\tif (s->srp_ctx.login != NULL)\n\t\t{ /* Add TLS extension SRP username to the Client Hello message */\n\n\t\tint login_len = strlen(s->srp_ctx.login);\t\n\t\tif (login_len > 255 || login_len == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t} \n\n\t\t/* check for enough space.\n\t\t   4 for the srp type type and entension length\n\t\t   1 for the srp user identity\n\t\t   + srp user identity length \n\t\t*/\n\t\tif ((limit - ret - 5 - login_len) < 0) return NULL; \n\n\t\t/* fill in the extension */\n\t\ts2n(TLSEXT_TYPE_srp,ret);\n\t\ts2n(login_len+1,ret);\n\t\t(*ret++) = (unsigned char) login_len;\n\t\tmemcpy(ret, s->srp_ctx.login, login_len);\n\t\tret+=login_len;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_EC\n\tif (using_ecc)\n\t\t{\n\t\t/* Add TLS extension ECPointFormats to the ClientHello message */\n\t\tlong lenmax; \n\t\tconst unsigned char *plist;\n\t\tsize_t plistlen;\n\n\t\ttls1_get_formatlist(s, &plist, &plistlen);\n\n\t\tif ((lenmax = limit - ret - 5) < 0) return NULL; \n\t\tif (plistlen > (size_t)lenmax) return NULL;\n\t\tif (plistlen > 255)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\ts2n(TLSEXT_TYPE_ec_point_formats,ret);\n\t\ts2n(plistlen + 1,ret);\n\t\t*(ret++) = (unsigned char)plistlen ;\n\t\tmemcpy(ret, plist, plistlen);\n\t\tret+=plistlen;\n\n\t\t/* Add TLS extension EllipticCurves to the ClientHello message */\n\t\tplist = s->tlsext_ellipticcurvelist;\n\t\ttls1_get_curvelist(s, 0, &plist, &plistlen);\n\n\t\tif ((lenmax = limit - ret - 6) < 0) return NULL; \n\t\tif (plistlen > (size_t)lenmax) return NULL;\n\t\tif (plistlen > 65532)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\ts2n(TLSEXT_TYPE_elliptic_curves,ret);\n\t\ts2n(plistlen + 2, ret);\n\n\t\t/* NB: draft-ietf-tls-ecc-12.txt uses a one-byte prefix for\n\t\t * elliptic_curve_list, but the examples use two bytes.\n\t\t * http://www1.ietf.org/mail-archive/web/tls/current/msg00538.html\n\t\t * resolves this to two bytes.\n\t\t */\n\t\ts2n(plistlen, ret);\n\t\tmemcpy(ret, plist, plistlen);\n\t\tret+=plistlen;\n\t\t}\n#endif /* OPENSSL_NO_EC */\n\n\tif (!(SSL_get_options(s) & SSL_OP_NO_TICKET))\n\t\t{\n\t\tint ticklen;\n\t\tif (!s->new_session && s->session && s->session->tlsext_tick)\n\t\t\tticklen = s->session->tlsext_ticklen;\n\t\telse if (s->session && s->tlsext_session_ticket &&\n\t\t\t s->tlsext_session_ticket->data)\n\t\t\t{\n\t\t\tticklen = s->tlsext_session_ticket->length;\n\t\t\ts->session->tlsext_tick = OPENSSL_malloc(ticklen);\n\t\t\tif (!s->session->tlsext_tick)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(s->session->tlsext_tick,\n\t\t\t       s->tlsext_session_ticket->data,\n\t\t\t       ticklen);\n\t\t\ts->session->tlsext_ticklen = ticklen;\n\t\t\t}\n\t\telse\n\t\t\tticklen = 0;\n\t\tif (ticklen == 0 && s->tlsext_session_ticket &&\n\t\t    s->tlsext_session_ticket->data == NULL)\n\t\t\tgoto skip_ext;\n\t\t/* Check for enough room 2 for extension type, 2 for len\n \t\t * rest for ticket\n  \t\t */\n\t\tif ((long)(limit - ret - 4 - ticklen) < 0) return NULL;\n\t\ts2n(TLSEXT_TYPE_session_ticket,ret); \n\t\ts2n(ticklen,ret);\n\t\tif (ticklen)\n\t\t\t{\n\t\t\tmemcpy(ret, s->session->tlsext_tick, ticklen);\n\t\t\tret += ticklen;\n\t\t\t}\n\t\t}\n\t\tskip_ext:\n\n\tif (SSL_USE_SIGALGS(s))\n\t\t{\n\t\tsize_t salglen;\n\t\tconst unsigned char *salg;\n\t\tsalglen = tls12_get_psigalgs(s, &salg);\n\t\tif ((size_t)(limit - ret) < salglen + 6)\n\t\t\treturn NULL; \n\t\ts2n(TLSEXT_TYPE_signature_algorithms,ret);\n\t\ts2n(salglen + 2, ret);\n\t\ts2n(salglen, ret);\n\t\tmemcpy(ret, salg, salglen);\n\t\tret += salglen;\n\t\t}\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->client_opaque_prf_input != NULL)\n\t\t{\n\t\tsize_t col = s->s3->client_opaque_prf_input_len;\n\t\t\n\t\tif ((long)(limit - ret - 6 - col < 0))\n\t\t\treturn NULL;\n\t\tif (col > 0xFFFD) /* can't happen */\n\t\t\treturn NULL;\n\n\t\ts2n(TLSEXT_TYPE_opaque_prf_input, ret); \n\t\ts2n(col + 2, ret);\n\t\ts2n(col, ret);\n\t\tmemcpy(ret, s->s3->client_opaque_prf_input, col);\n\t\tret += col;\n\t\t}\n#endif\n\n\tif (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)\n\t\t{\n\t\tint i;\n\t\tlong extlen, idlen, itmp;\n\t\tOCSP_RESPID *id;\n\n\t\tidlen = 0;\n\t\tfor (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)\n\t\t\t{\n\t\t\tid = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n\t\t\titmp = i2d_OCSP_RESPID(id, NULL);\n\t\t\tif (itmp <= 0)\n\t\t\t\treturn NULL;\n\t\t\tidlen += itmp + 2;\n\t\t\t}\n\n\t\tif (s->tlsext_ocsp_exts)\n\t\t\t{\n\t\t\textlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);\n\t\t\tif (extlen < 0)\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\telse\n\t\t\textlen = 0;\n\t\t\t\n\t\tif ((long)(limit - ret - 7 - extlen - idlen) < 0) return NULL;\n\t\ts2n(TLSEXT_TYPE_status_request, ret);\n\t\tif (extlen + idlen > 0xFFF0)\n\t\t\treturn NULL;\n\t\ts2n(extlen + idlen + 5, ret);\n\t\t*(ret++) = TLSEXT_STATUSTYPE_ocsp;\n\t\ts2n(idlen, ret);\n\t\tfor (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)\n\t\t\t{\n\t\t\t/* save position of id len */\n\t\t\tunsigned char *q = ret;\n\t\t\tid = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n\t\t\t/* skip over id len */\n\t\t\tret += 2;\n\t\t\titmp = i2d_OCSP_RESPID(id, &ret);\n\t\t\t/* write id len */\n\t\t\ts2n(itmp, q);\n\t\t\t}\n\t\ts2n(extlen, ret);\n\t\tif (extlen > 0)\n\t\t\ti2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* Add Heartbeat extension */\n\ts2n(TLSEXT_TYPE_heartbeat,ret);\n\ts2n(1,ret);\n\t/* Set mode:\n\t * 1: peer may send requests\n\t * 2: peer not allowed to send requests\n\t */\n\tif (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)\n\t\t*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n\telse\n\t\t*(ret++) = SSL_TLSEXT_HB_ENABLED;\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\tif (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len)\n\t\t{\n\t\t/* The client advertises an emtpy extension to indicate its\n\t\t * support for Next Protocol Negotiation */\n\t\tif (limit - ret - 4 < 0)\n\t\t\treturn NULL;\n\t\ts2n(TLSEXT_TYPE_next_proto_neg,ret);\n\t\ts2n(0,ret);\n\t\t}\n#endif\n\n\tif (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len)\n\t\t{\n\t\tif ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len)\n\t\t\treturn NULL;\n\t\ts2n(TLSEXT_TYPE_application_layer_protocol_negotiation,ret);\n\t\ts2n(2 + s->alpn_client_proto_list_len,ret);\n\t\ts2n(s->alpn_client_proto_list_len,ret);\n\t\tmemcpy(ret, s->alpn_client_proto_list,\n\t\t       s->alpn_client_proto_list_len);\n\t\tret += s->alpn_client_proto_list_len;\n\t\t}\n\n        if(SSL_get_srtp_profiles(s))\n                {\n                int el;\n\n                ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);\n                \n                if((limit - p - 4 - el) < 0) return NULL;\n\n                s2n(TLSEXT_TYPE_use_srtp,ret);\n                s2n(el,ret);\n\n                if(ssl_add_clienthello_use_srtp_ext(s, ret, &el, el))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n                ret += el;\n                }\n\n\t/* Add custom TLS Extensions to ClientHello */\n\tif (s->ctx->custom_cli_ext_records_count)\n\t\t{\n\t\tsize_t i;\n\t\tcustom_cli_ext_record* record;\n\n\t\tfor (i = 0; i < s->ctx->custom_cli_ext_records_count; i++)\n\t\t\t{\n\t\t\tconst unsigned char* out = NULL;\n\t\t\tunsigned short outlen = 0;\n\n\t\t\trecord = &s->ctx->custom_cli_ext_records[i];\n\t\t\t/* NULL callback sends empty extension */ \n\t\t\t/* -1 from callback omits extension */\n\t\t\tif (record->fn1)\n\t\t\t\t{\n\t\t\t\tint cb_retval = 0;\n\t\t\t\tcb_retval = record->fn1(s, record->ext_type,\n\t\t\t\t\t\t\t&out, &outlen, al,\n\t\t\t\t\t\t\trecord->arg);\n\t\t\t\tif (cb_retval == 0)\n\t\t\t\t\treturn NULL; /* error */\n\t\t\t\tif (cb_retval == -1)\n\t\t\t\t\tcontinue; /* skip this extension */\n\t\t\t\t}\n\t\t\tif (limit < ret + 4 + outlen)\n\t\t\t\treturn NULL;\n\t\t\ts2n(record->ext_type, ret);\n\t\t\ts2n(outlen, ret);\n\t\t\tmemcpy(ret, out, outlen);\n\t\t\tret += outlen;\n\t\t\t}\n\t\t}\n#ifdef TLSEXT_TYPE_encrypt_then_mac\n\ts2n(TLSEXT_TYPE_encrypt_then_mac,ret);\n\ts2n(0,ret);\n#endif\n#ifdef TLSEXT_TYPE_padding\n\t/* Add padding to workaround bugs in F5 terminators.\n\t * See https://tools.ietf.org/html/draft-agl-tls-padding-02\n\t *\n\t * NB: because this code works out the length of all existing\n\t * extensions it MUST always appear last.\n\t */\n\t{\n\tint hlen = ret - (unsigned char *)s->init_buf->data;\n\t/* The code in s23_clnt.c to build ClientHello messages includes the\n\t * 5-byte record header in the buffer, while the code in s3_clnt.c does\n\t * not. */\n\tif (s->state == SSL23_ST_CW_CLNT_HELLO_A)\n\t\thlen -= 5;\n\tif (hlen > 0xff && hlen < 0x200)\n\t\t{\n\t\thlen = 0x200 - hlen;\n\t\tif (hlen >= 4)\n\t\t\thlen -= 4;\n\t\telse\n\t\t\thlen = 0;\n\n\t\ts2n(TLSEXT_TYPE_padding, ret);\n\t\ts2n(hlen, ret);\n\t\tmemset(ret, 0, hlen);\n\t\tret += hlen;\n\t\t}\n\t}\n#endif\n\n\tif ((extdatalen = ret-p-2) == 0)\n\t\treturn p;\n\n\ts2n(extdatalen,p);\n\treturn ret;\n\t}", "patch_func_code": "unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *p, unsigned char *limit, int *al)\n\t{\n\tint extdatalen=0;\n\tunsigned char *ret = p;\n#ifndef OPENSSL_NO_EC\n\t/* See if we support any ECC ciphersuites */\n\tint using_ecc = 0;\n\tif (s->version >= TLS1_VERSION || SSL_IS_DTLS(s))\n\t\t{\n\t\tint i;\n\t\tunsigned long alg_k, alg_a;\n\t\tSTACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);\n\n\t\tfor (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++)\n\t\t\t{\n\t\t\tSSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);\n\n\t\t\talg_k = c->algorithm_mkey;\n\t\t\talg_a = c->algorithm_auth;\n\t\t\tif ((alg_k & (SSL_kECDHE|SSL_kECDHr|SSL_kECDHe)\n\t\t\t\t|| (alg_a & SSL_aECDSA)))\n\t\t\t\t{\n\t\t\t\tusing_ecc = 1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\n\t/* don't add extensions for SSLv3 unless doing secure renegotiation */\n\tif (s->client_version == SSL3_VERSION\n\t\t\t\t\t&& !s->s3->send_connection_binding)\n\t\treturn p;\n\n\tret+=2;\n\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n \tif (s->tlsext_hostname != NULL)\n\t\t{ \n\t\t/* Add TLS extension servername to the Client Hello message */\n\t\tunsigned long size_str;\n\t\tlong lenmax; \n\n\t\t/* check for enough space.\n\t\t   4 for the servername type and entension length\n\t\t   2 for servernamelist length\n\t\t   1 for the hostname type\n\t\t   2 for hostname length\n\t\t   + hostname length \n\t\t*/\n\t\t   \n\t\tif ((lenmax = limit - ret - 9) < 0 \n\t\t    || (size_str = strlen(s->tlsext_hostname)) > (unsigned long)lenmax) \n\t\t\treturn NULL;\n\t\t\t\n\t\t/* extension type and length */\n\t\ts2n(TLSEXT_TYPE_server_name,ret); \n\t\ts2n(size_str+5,ret);\n\t\t\n\t\t/* length of servername list */\n\t\ts2n(size_str+3,ret);\n\t\n\t\t/* hostname type, length and hostname */\n\t\t*(ret++) = (unsigned char) TLSEXT_NAMETYPE_host_name;\n\t\ts2n(size_str,ret);\n\t\tmemcpy(ret, s->tlsext_hostname, size_str);\n\t\tret+=size_str;\n\t\t}\n\n        /* Add RI if renegotiating */\n        if (s->renegotiate)\n          {\n          int el;\n          \n          if(!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0))\n              {\n              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          if((limit - p - 4 - el) < 0) return NULL;\n          \n          s2n(TLSEXT_TYPE_renegotiate,ret);\n          s2n(el,ret);\n\n          if(!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el))\n              {\n              SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n              return NULL;\n              }\n\n          ret += el;\n        }\n\n#ifndef OPENSSL_NO_SRP\n\t/* Add SRP username if there is one */\n\tif (s->srp_ctx.login != NULL)\n\t\t{ /* Add TLS extension SRP username to the Client Hello message */\n\n\t\tint login_len = strlen(s->srp_ctx.login);\t\n\t\tif (login_len > 255 || login_len == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t} \n\n\t\t/* check for enough space.\n\t\t   4 for the srp type type and entension length\n\t\t   1 for the srp user identity\n\t\t   + srp user identity length \n\t\t*/\n\t\tif ((limit - ret - 5 - login_len) < 0) return NULL; \n\n\t\t/* fill in the extension */\n\t\ts2n(TLSEXT_TYPE_srp,ret);\n\t\ts2n(login_len+1,ret);\n\t\t(*ret++) = (unsigned char) login_len;\n\t\tmemcpy(ret, s->srp_ctx.login, login_len);\n\t\tret+=login_len;\n\t\t}\n#endif\n\n#ifndef OPENSSL_NO_EC\n\tif (using_ecc)\n\t\t{\n\t\t/* Add TLS extension ECPointFormats to the ClientHello message */\n\t\tlong lenmax; \n\t\tconst unsigned char *plist;\n\t\tsize_t plistlen;\n\t\tsize_t i;\n\t\tunsigned char *etmp;\n\n\t\ttls1_get_formatlist(s, &plist, &plistlen);\n\n\t\tif ((lenmax = limit - ret - 5) < 0) return NULL; \n\t\tif (plistlen > (size_t)lenmax) return NULL;\n\t\tif (plistlen > 255)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\ts2n(TLSEXT_TYPE_ec_point_formats,ret);\n\t\ts2n(plistlen + 1,ret);\n\t\t*(ret++) = (unsigned char)plistlen ;\n\t\tmemcpy(ret, plist, plistlen);\n\t\tret+=plistlen;\n\n\t\t/* Add TLS extension EllipticCurves to the ClientHello message */\n\t\tplist = s->tlsext_ellipticcurvelist;\n\t\ttls1_get_curvelist(s, 0, &plist, &plistlen);\n\n\t\tif ((lenmax = limit - ret - 6) < 0) return NULL; \n\t\tif (plistlen > (size_t)lenmax) return NULL;\n\t\tif (plistlen > 65532)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\n\t\ts2n(TLSEXT_TYPE_elliptic_curves,ret);\n\t\tetmp = ret + 4;\n\t\t/* Copy curve ID if supported */\n\t\tfor (i = 0; i < plistlen; i += 2, plist += 2)\n\t\t\t{\n\t\t\tif (tls_curve_allowed(s, plist, SSL_SECOP_CURVE_SUPPORTED))\n\t\t\t\t{\n\t\t\t\t*etmp++ = plist[0];\n\t\t\t\t*etmp++ = plist[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\tplistlen = etmp - ret - 4;\n\n\t\t/* NB: draft-ietf-tls-ecc-12.txt uses a one-byte prefix for\n\t\t * elliptic_curve_list, but the examples use two bytes.\n\t\t * http://www1.ietf.org/mail-archive/web/tls/current/msg00538.html\n\t\t * resolves this to two bytes.\n\t\t */\n\t\ts2n(plistlen + 2, ret);\n\t\ts2n(plistlen, ret);\n\t\tret+=plistlen;\n\t\t}\n#endif /* OPENSSL_NO_EC */\n\n\tif (tls_use_ticket(s))\n\t\t{\n\t\tint ticklen;\n\t\tif (!s->new_session && s->session && s->session->tlsext_tick)\n\t\t\tticklen = s->session->tlsext_ticklen;\n\t\telse if (s->session && s->tlsext_session_ticket &&\n\t\t\t s->tlsext_session_ticket->data)\n\t\t\t{\n\t\t\tticklen = s->tlsext_session_ticket->length;\n\t\t\ts->session->tlsext_tick = OPENSSL_malloc(ticklen);\n\t\t\tif (!s->session->tlsext_tick)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(s->session->tlsext_tick,\n\t\t\t       s->tlsext_session_ticket->data,\n\t\t\t       ticklen);\n\t\t\ts->session->tlsext_ticklen = ticklen;\n\t\t\t}\n\t\telse\n\t\t\tticklen = 0;\n\t\tif (ticklen == 0 && s->tlsext_session_ticket &&\n\t\t    s->tlsext_session_ticket->data == NULL)\n\t\t\tgoto skip_ext;\n\t\t/* Check for enough room 2 for extension type, 2 for len\n \t\t * rest for ticket\n  \t\t */\n\t\tif ((long)(limit - ret - 4 - ticklen) < 0) return NULL;\n\t\ts2n(TLSEXT_TYPE_session_ticket,ret); \n\t\ts2n(ticklen,ret);\n\t\tif (ticklen)\n\t\t\t{\n\t\t\tmemcpy(ret, s->session->tlsext_tick, ticklen);\n\t\t\tret += ticklen;\n\t\t\t}\n\t\t}\n\t\tskip_ext:\n\n\tif (SSL_USE_SIGALGS(s))\n\t\t{\n\t\tsize_t salglen;\n\t\tconst unsigned char *salg;\n\t\tunsigned char *etmp;\n\t\tsalglen = tls12_get_psigalgs(s, &salg);\n\t\tif ((size_t)(limit - ret) < salglen + 6)\n\t\t\treturn NULL; \n\t\ts2n(TLSEXT_TYPE_signature_algorithms,ret);\n\t\tetmp = ret;\n\t\t/* Skip over lengths for now */\n\t\tret += 4;\n\t\tsalglen = tls12_copy_sigalgs(s, etmp, salg, salglen);\n\t\t/* Fill in lengths */\n\t\ts2n(salglen + 2, etmp);\n\t\ts2n(salglen, etmp);\n\t\tret += salglen;\n\t\t}\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->client_opaque_prf_input != NULL)\n\t\t{\n\t\tsize_t col = s->s3->client_opaque_prf_input_len;\n\t\t\n\t\tif ((long)(limit - ret - 6 - col < 0))\n\t\t\treturn NULL;\n\t\tif (col > 0xFFFD) /* can't happen */\n\t\t\treturn NULL;\n\n\t\ts2n(TLSEXT_TYPE_opaque_prf_input, ret); \n\t\ts2n(col + 2, ret);\n\t\ts2n(col, ret);\n\t\tmemcpy(ret, s->s3->client_opaque_prf_input, col);\n\t\tret += col;\n\t\t}\n#endif\n\n\tif (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp)\n\t\t{\n\t\tint i;\n\t\tlong extlen, idlen, itmp;\n\t\tOCSP_RESPID *id;\n\n\t\tidlen = 0;\n\t\tfor (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)\n\t\t\t{\n\t\t\tid = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n\t\t\titmp = i2d_OCSP_RESPID(id, NULL);\n\t\t\tif (itmp <= 0)\n\t\t\t\treturn NULL;\n\t\t\tidlen += itmp + 2;\n\t\t\t}\n\n\t\tif (s->tlsext_ocsp_exts)\n\t\t\t{\n\t\t\textlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);\n\t\t\tif (extlen < 0)\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\telse\n\t\t\textlen = 0;\n\t\t\t\n\t\tif ((long)(limit - ret - 7 - extlen - idlen) < 0) return NULL;\n\t\ts2n(TLSEXT_TYPE_status_request, ret);\n\t\tif (extlen + idlen > 0xFFF0)\n\t\t\treturn NULL;\n\t\ts2n(extlen + idlen + 5, ret);\n\t\t*(ret++) = TLSEXT_STATUSTYPE_ocsp;\n\t\ts2n(idlen, ret);\n\t\tfor (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++)\n\t\t\t{\n\t\t\t/* save position of id len */\n\t\t\tunsigned char *q = ret;\n\t\t\tid = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n\t\t\t/* skip over id len */\n\t\t\tret += 2;\n\t\t\titmp = i2d_OCSP_RESPID(id, &ret);\n\t\t\t/* write id len */\n\t\t\ts2n(itmp, q);\n\t\t\t}\n\t\ts2n(extlen, ret);\n\t\tif (extlen > 0)\n\t\t\ti2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);\n\t\t}\n\n#ifndef OPENSSL_NO_HEARTBEATS\n\t/* Add Heartbeat extension */\n\ts2n(TLSEXT_TYPE_heartbeat,ret);\n\ts2n(1,ret);\n\t/* Set mode:\n\t * 1: peer may send requests\n\t * 2: peer not allowed to send requests\n\t */\n\tif (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)\n\t\t*(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n\telse\n\t\t*(ret++) = SSL_TLSEXT_HB_ENABLED;\n#endif\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n\tif (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len)\n\t\t{\n\t\t/* The client advertises an emtpy extension to indicate its\n\t\t * support for Next Protocol Negotiation */\n\t\tif (limit - ret - 4 < 0)\n\t\t\treturn NULL;\n\t\ts2n(TLSEXT_TYPE_next_proto_neg,ret);\n\t\ts2n(0,ret);\n\t\t}\n#endif\n\n\tif (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len)\n\t\t{\n\t\tif ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len)\n\t\t\treturn NULL;\n\t\ts2n(TLSEXT_TYPE_application_layer_protocol_negotiation,ret);\n\t\ts2n(2 + s->alpn_client_proto_list_len,ret);\n\t\ts2n(s->alpn_client_proto_list_len,ret);\n\t\tmemcpy(ret, s->alpn_client_proto_list,\n\t\t       s->alpn_client_proto_list_len);\n\t\tret += s->alpn_client_proto_list_len;\n\t\t}\n\n        if(SSL_get_srtp_profiles(s))\n                {\n                int el;\n\n                ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);\n                \n                if((limit - p - 4 - el) < 0) return NULL;\n\n                s2n(TLSEXT_TYPE_use_srtp,ret);\n                s2n(el,ret);\n\n                if(ssl_add_clienthello_use_srtp_ext(s, ret, &el, el))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n\t\t\treturn NULL;\n\t\t\t}\n                ret += el;\n                }\n\n\t/* Add custom TLS Extensions to ClientHello */\n\tif (s->ctx->custom_cli_ext_records_count)\n\t\t{\n\t\tsize_t i;\n\t\tcustom_cli_ext_record* record;\n\n\t\tfor (i = 0; i < s->ctx->custom_cli_ext_records_count; i++)\n\t\t\t{\n\t\t\tconst unsigned char* out = NULL;\n\t\t\tunsigned short outlen = 0;\n\n\t\t\trecord = &s->ctx->custom_cli_ext_records[i];\n\t\t\t/* NULL callback sends empty extension */ \n\t\t\t/* -1 from callback omits extension */\n\t\t\tif (record->fn1)\n\t\t\t\t{\n\t\t\t\tint cb_retval = 0;\n\t\t\t\tcb_retval = record->fn1(s, record->ext_type,\n\t\t\t\t\t\t\t&out, &outlen, al,\n\t\t\t\t\t\t\trecord->arg);\n\t\t\t\tif (cb_retval == 0)\n\t\t\t\t\treturn NULL; /* error */\n\t\t\t\tif (cb_retval == -1)\n\t\t\t\t\tcontinue; /* skip this extension */\n\t\t\t\t}\n\t\t\tif (limit < ret + 4 + outlen)\n\t\t\t\treturn NULL;\n\t\t\ts2n(record->ext_type, ret);\n\t\t\ts2n(outlen, ret);\n\t\t\tmemcpy(ret, out, outlen);\n\t\t\tret += outlen;\n\t\t\t}\n\t\t}\n#ifdef TLSEXT_TYPE_encrypt_then_mac\n\ts2n(TLSEXT_TYPE_encrypt_then_mac,ret);\n\ts2n(0,ret);\n#endif\n#ifdef TLSEXT_TYPE_padding\n\t/* Add padding to workaround bugs in F5 terminators.\n\t * See https://tools.ietf.org/html/draft-agl-tls-padding-02\n\t *\n\t * NB: because this code works out the length of all existing\n\t * extensions it MUST always appear last.\n\t */\n\t{\n\tint hlen = ret - (unsigned char *)s->init_buf->data;\n\t/* The code in s23_clnt.c to build ClientHello messages includes the\n\t * 5-byte record header in the buffer, while the code in s3_clnt.c does\n\t * not. */\n\tif (s->state == SSL23_ST_CW_CLNT_HELLO_A)\n\t\thlen -= 5;\n\tif (hlen > 0xff && hlen < 0x200)\n\t\t{\n\t\thlen = 0x200 - hlen;\n\t\tif (hlen >= 4)\n\t\t\thlen -= 4;\n\t\telse\n\t\t\thlen = 0;\n\n\t\ts2n(TLSEXT_TYPE_padding, ret);\n\t\ts2n(hlen, ret);\n\t\tmemset(ret, 0, hlen);\n\t\tret += hlen;\n\t\t}\n\t}\n#endif\n\n\tif ((extdatalen = ret-p-2) == 0)\n\t\treturn p;\n\n\ts2n(extdatalen,p);\n\treturn ret;\n\t}", "before_change_lines": [161, 169, 174, 218, 219, 220], "raw_before_change_lines": [161, 169, 174, 218, 219, 220], "after_change_lines": [131, 132, 164, 166, 167, 168, 169, 170, 171, 172, 173, 175, 182, 188, 228, 233, 235, 236, 238, 239], "raw_after_change_lines": [131, 132, 161, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 182, 188, 228, 233, 234, 235, 236, 237, 238, 239], "bug_lines": [161, 169, 174, 218, 219, 220], "added": [false, false, false, false, false, false], "idx": 425}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12052----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3e8b11ee7fe6fcfeb17e857340e23e4d4911142e_1.json----SSL_SESSION_free", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_3e8b11ee7fe6fcfeb17e857340e23e4d4911142e_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_3e8b11ee7fe6fcfeb17e857340e23e4d4911142e_1.json", "function_name": "SSL_SESSION_free", "vul_func_code": "void SSL_SESSION_free(SSL_SESSION *ss)\n\t{\n\tint i;\n\n\tif(ss == NULL)\n\t    return;\n\n\ti=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);\n#ifdef REF_PRINT\n\tREF_PRINT(\"SSL_SESSION\",ss);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"SSL_SESSION_free, bad reference count\\n\");\n\t\tabort(); /* ok */\n\t\t}\n#endif\n\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\n\n\tOPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg);\n\tOPENSSL_cleanse(ss->master_key,sizeof ss->master_key);\n\tOPENSSL_cleanse(ss->session_id,sizeof ss->session_id);\n\tif (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert);\n\tif (ss->peer != NULL) X509_free(ss->peer);\n\tif (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers);\n#ifndef OPENSSL_NO_TLSEXT\n\tif (ss->tlsext_hostname != NULL) OPENSSL_free(ss->tlsext_hostname);\n\tif (ss->tlsext_tick != NULL) OPENSSL_free(ss->tlsext_tick);\n#ifndef OPENSSL_NO_EC\n\tss->tlsext_ecpointformatlist_length = 0;\n\tif (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist);\n\tss->tlsext_ellipticcurvelist_length = 0;\n\tif (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist);\n#endif /* OPENSSL_NO_EC */\n\tif (ss->audit_proof != NULL) OPENSSL_free(ss->audit_proof);\n\tss->audit_proof_length = 0;\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (ss->psk_identity_hint != NULL)\n\t\tOPENSSL_free(ss->psk_identity_hint);\n\tif (ss->psk_identity != NULL)\n\t\tOPENSSL_free(ss->psk_identity);\n#endif\n#ifndef OPENSSL_NO_SRP\n\tif (ss->srp_username != NULL)\n\t\tOPENSSL_free(ss->srp_username);\n#endif\n\tOPENSSL_cleanse(ss,sizeof(*ss));\n\tOPENSSL_free(ss);\n\t}", "patch_func_code": "void SSL_SESSION_free(SSL_SESSION *ss)\n\t{\n\tint i;\n\n\tif(ss == NULL)\n\t    return;\n\n\ti=CRYPTO_add(&ss->references,-1,CRYPTO_LOCK_SSL_SESSION);\n#ifdef REF_PRINT\n\tREF_PRINT(\"SSL_SESSION\",ss);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"SSL_SESSION_free, bad reference count\\n\");\n\t\tabort(); /* ok */\n\t\t}\n#endif\n\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);\n\n\tOPENSSL_cleanse(ss->key_arg,sizeof ss->key_arg);\n\tOPENSSL_cleanse(ss->master_key,sizeof ss->master_key);\n\tOPENSSL_cleanse(ss->session_id,sizeof ss->session_id);\n\tif (ss->sess_cert != NULL) ssl_sess_cert_free(ss->sess_cert);\n\tif (ss->peer != NULL) X509_free(ss->peer);\n\tif (ss->ciphers != NULL) sk_SSL_CIPHER_free(ss->ciphers);\n#ifndef OPENSSL_NO_TLSEXT\n\tif (ss->tlsext_hostname != NULL) OPENSSL_free(ss->tlsext_hostname);\n\tif (ss->tlsext_tick != NULL) OPENSSL_free(ss->tlsext_tick);\n#ifndef OPENSSL_NO_EC\n\tss->tlsext_ecpointformatlist_length = 0;\n\tif (ss->tlsext_ecpointformatlist != NULL) OPENSSL_free(ss->tlsext_ecpointformatlist);\n\tss->tlsext_ellipticcurvelist_length = 0;\n\tif (ss->tlsext_ellipticcurvelist != NULL) OPENSSL_free(ss->tlsext_ellipticcurvelist);\n#endif /* OPENSSL_NO_EC */\n#endif\n#ifndef OPENSSL_NO_PSK\n\tif (ss->psk_identity_hint != NULL)\n\t\tOPENSSL_free(ss->psk_identity_hint);\n\tif (ss->psk_identity != NULL)\n\t\tOPENSSL_free(ss->psk_identity);\n#endif\n#ifndef OPENSSL_NO_SRP\n\tif (ss->srp_username != NULL)\n\t\tOPENSSL_free(ss->srp_username);\n#endif\n\tOPENSSL_cleanse(ss,sizeof(*ss));\n\tOPENSSL_free(ss);\n\t}", "before_change_lines": [38, 39], "raw_before_change_lines": [38, 39], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [38, 39], "added": [false, false], "idx": 426}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12171----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_4343cd68794cc430eb16e5678113e29d6263c2a0_1.json----EVP_DecryptFinal_ex", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_4343cd68794cc430eb16e5678113e29d6263c2a0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_4343cd68794cc430eb16e5678113e29d6263c2a0_1.json", "function_name": "EVP_DecryptFinal_ex", "vul_func_code": "int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\n\t{\n\tint i,n;\n\tunsigned int b;\n\n\t*outl=0;\n\tb=ctx->cipher->block_size;\n\tif (ctx->flags & EVP_CIPH_NO_PADDING)\n\t\t{\n\t\tif(ctx->buf_len)\n\t\t\t{\n\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\n\t\t\treturn 0;\n\t\t\t}\n\t\t*outl = 0;\n\t\treturn 1;\n\t\t}\n\tif (b > 1)\n\t\t{\n\t\tif (ctx->buf_len || !ctx->final_used)\n\t\t\t{\n\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);\n\t\t\treturn(0);\n\t\t\t}\n\t\tOPENSSL_assert(b <= sizeof ctx->final);\n\t\tn=ctx->final[b-1];\n\t\tif (n > (int)b)\n\t\t\t{\n\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);\n\t\t\treturn(0);\n\t\t\t}\n\t\tfor (i=0; i<n; i++)\n\t\t\t{\n\t\t\tif (ctx->final[--b] != n)\n\t\t\t\t{\n\t\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);\n\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\tn=ctx->cipher->block_size-n;\n\t\tfor (i=0; i<n; i++)\n\t\t\tout[i]=ctx->final[i];\n\t\t*outl=n;\n\t\t}\n\telse\n\t\t*outl=0;\n\treturn(1);\n\t}", "patch_func_code": "int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)\n\t{\n\tint i,n;\n\tunsigned int b;\n\n\t*outl=0;\n\tb=ctx->cipher->block_size;\n\tif (ctx->flags & EVP_CIPH_NO_PADDING)\n\t\t{\n\t\tif(ctx->buf_len)\n\t\t\t{\n\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);\n\t\t\treturn 0;\n\t\t\t}\n\t\t*outl = 0;\n\t\treturn 1;\n\t\t}\n\tif (b > 1)\n\t\t{\n\t\tif (ctx->buf_len || !ctx->final_used)\n\t\t\t{\n\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);\n\t\t\treturn(0);\n\t\t\t}\n\t\tOPENSSL_assert(b <= sizeof ctx->final);\n\t\tn=ctx->final[b-1];\n\t\tif (n == 0 || n > (int)b)\n\t\t\t{\n\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);\n\t\t\treturn(0);\n\t\t\t}\n\t\tfor (i=0; i<n; i++)\n\t\t\t{\n\t\t\tif (ctx->final[--b] != n)\n\t\t\t\t{\n\t\t\t\tEVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);\n\t\t\t\treturn(0);\n\t\t\t\t}\n\t\t\t}\n\t\tn=ctx->cipher->block_size-n;\n\t\tfor (i=0; i<n; i++)\n\t\t\tout[i]=ctx->final[i];\n\t\t*outl=n;\n\t\t}\n\telse\n\t\t*outl=0;\n\treturn(1);\n\t}", "before_change_lines": [27], "raw_before_change_lines": [27], "after_change_lines": [27], "raw_after_change_lines": [27], "bug_lines": [27], "added": [false], "idx": 427}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "12281----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_475b00f398f353399595baa040397e030a5f66f6_1.json----sm2_encrypt", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_475b00f398f353399595baa040397e030a5f66f6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_475b00f398f353399595baa040397e030a5f66f6_1.json", "function_name": "sm2_encrypt", "vul_func_code": "int sm2_encrypt(const EC_KEY *key,\n                const EVP_MD *digest,\n                const uint8_t *msg,\n                size_t msg_len, uint8_t *ciphertext_buf, size_t *ciphertext_len)\n{\n    int rc = 0, ciphertext_leni;\n    size_t i;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *y1 = NULL;\n    BIGNUM *x2 = NULL;\n    BIGNUM *y2 = NULL;\n    EVP_MD_CTX *hash = EVP_MD_CTX_new();\n    struct SM2_Ciphertext_st ctext_struct;\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n    const EC_POINT *P = EC_KEY_get0_public_key(key);\n    EC_POINT *kG = NULL;\n    EC_POINT *kP = NULL;\n    uint8_t *msg_mask = NULL;\n    uint8_t *x2y2 = NULL;\n    uint8_t *C3 = NULL;\n    const size_t field_size = ec_field_size(group);\n    const size_t C3_size = EVP_MD_size(digest);\n\n    /* NULL these before any \"goto done\" */\n    ctext_struct.C2 = NULL;\n    ctext_struct.C3 = NULL;\n\n    if (hash == NULL\n            || group == NULL\n            || order == NULL\n            || P == NULL\n            || field_size == 0\n            || C3_size == 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    kG = EC_POINT_new(group);\n    kP = EC_POINT_new(group);\n    ctx = BN_CTX_new();\n    if (kG == NULL || kP == NULL || ctx == NULL) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    BN_CTX_start(ctx);\n    k = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    x2 = BN_CTX_get(ctx);\n    y1 = BN_CTX_get(ctx);\n    y2 = BN_CTX_get(ctx);\n\n    if (y2 == NULL) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_BN_LIB);\n        goto done;\n    }\n\n    x2y2 = OPENSSL_zalloc(2 * field_size);\n    C3 = OPENSSL_zalloc(C3_size);\n\n    if (x2y2 == NULL || C3 == NULL) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    memset(ciphertext_buf, 0, *ciphertext_len);\n\n    if (!BN_priv_rand_range(k, order)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx)\n            || !EC_POINT_get_affine_coordinates_GFp(group, kG, x1, y1, ctx)\n            || !EC_POINT_mul(group, kP, NULL, P, k, ctx)\n            || !EC_POINT_get_affine_coordinates_GFp(group, kP, x2, y2, ctx)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EC_LIB);\n        goto done;\n    }\n\n    if (BN_bn2binpad(x2, x2y2, field_size) < 0\n            || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    msg_mask = OPENSSL_zalloc(msg_len);\n    if (msg_mask == NULL) {\n       SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n       goto done;\n   }\n\n    /* X9.63 with no salt happens to match the KDF used in SM2 */\n    if (!ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,\n                        digest)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    for (i = 0; i != msg_len; ++i)\n        msg_mask[i] ^= msg[i];\n\n    if (EVP_DigestInit(hash, digest) == 0\n            || EVP_DigestUpdate(hash, x2y2, field_size) == 0\n            || EVP_DigestUpdate(hash, msg, msg_len) == 0\n            || EVP_DigestUpdate(hash, x2y2 + field_size, field_size) == 0\n            || EVP_DigestFinal(hash, C3, NULL) == 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    ctext_struct.C1x = x1;\n    ctext_struct.C1y = y1;\n    ctext_struct.C3 = ASN1_OCTET_STRING_new();\n    ctext_struct.C2 = ASN1_OCTET_STRING_new();\n\n    if (ctext_struct.C3 == NULL || ctext_struct.C2 == NULL) {\n       SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n       goto done;\n    }\n    if (!ASN1_OCTET_STRING_set(ctext_struct.C3, C3, C3_size)\n            || !ASN1_OCTET_STRING_set(ctext_struct.C2, msg_mask, msg_len)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    ciphertext_leni = i2d_SM2_Ciphertext(&ctext_struct, &ciphertext_buf);\n    /* Ensure cast to size_t is safe */\n    if (ciphertext_leni < 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n    *ciphertext_len = (size_t)ciphertext_leni;\n\n    rc = 1;\n\n done:\n    ASN1_OCTET_STRING_free(ctext_struct.C2);\n    ASN1_OCTET_STRING_free(ctext_struct.C3);\n    OPENSSL_free(msg_mask);\n    OPENSSL_free(x2y2);\n    OPENSSL_free(C3);\n    EVP_MD_CTX_free(hash);\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    EC_POINT_free(kP);\n    return rc;\n}", "patch_func_code": "int sm2_encrypt(const EC_KEY *key,\n                const EVP_MD *digest,\n                const uint8_t *msg,\n                size_t msg_len, uint8_t *ciphertext_buf, size_t *ciphertext_len)\n{\n    int rc = 0, ciphertext_leni;\n    size_t i;\n    BN_CTX *ctx = NULL;\n    BIGNUM *k = NULL;\n    BIGNUM *x1 = NULL;\n    BIGNUM *y1 = NULL;\n    BIGNUM *x2 = NULL;\n    BIGNUM *y2 = NULL;\n    EVP_MD_CTX *hash = EVP_MD_CTX_new();\n    struct SM2_Ciphertext_st ctext_struct;\n    const EC_GROUP *group = EC_KEY_get0_group(key);\n    const BIGNUM *order = EC_GROUP_get0_order(group);\n    const EC_POINT *P = EC_KEY_get0_public_key(key);\n    EC_POINT *kG = NULL;\n    EC_POINT *kP = NULL;\n    uint8_t *msg_mask = NULL;\n    uint8_t *x2y2 = NULL;\n    uint8_t *C3 = NULL;\n    size_t field_size;\n    const int C3_size = EVP_MD_size(digest);\n\n    /* NULL these before any \"goto done\" */\n    ctext_struct.C2 = NULL;\n    ctext_struct.C3 = NULL;\n\n    if (hash == NULL || C3_size <= 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    field_size = ec_field_size(group);\n    if (field_size == 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    kG = EC_POINT_new(group);\n    kP = EC_POINT_new(group);\n    ctx = BN_CTX_new();\n    if (kG == NULL || kP == NULL || ctx == NULL) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    BN_CTX_start(ctx);\n    k = BN_CTX_get(ctx);\n    x1 = BN_CTX_get(ctx);\n    x2 = BN_CTX_get(ctx);\n    y1 = BN_CTX_get(ctx);\n    y2 = BN_CTX_get(ctx);\n\n    if (y2 == NULL) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_BN_LIB);\n        goto done;\n    }\n\n    x2y2 = OPENSSL_zalloc(2 * field_size);\n    C3 = OPENSSL_zalloc(C3_size);\n\n    if (x2y2 == NULL || C3 == NULL) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n        goto done;\n    }\n\n    memset(ciphertext_buf, 0, *ciphertext_len);\n\n    if (!BN_priv_rand_range(k, order)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    if (!EC_POINT_mul(group, kG, k, NULL, NULL, ctx)\n            || !EC_POINT_get_affine_coordinates_GFp(group, kG, x1, y1, ctx)\n            || !EC_POINT_mul(group, kP, NULL, P, k, ctx)\n            || !EC_POINT_get_affine_coordinates_GFp(group, kP, x2, y2, ctx)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EC_LIB);\n        goto done;\n    }\n\n    if (BN_bn2binpad(x2, x2y2, field_size) < 0\n            || BN_bn2binpad(y2, x2y2 + field_size, field_size) < 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    msg_mask = OPENSSL_zalloc(msg_len);\n    if (msg_mask == NULL) {\n       SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n       goto done;\n   }\n\n    /* X9.63 with no salt happens to match the KDF used in SM2 */\n    if (!ECDH_KDF_X9_62(msg_mask, msg_len, x2y2, 2 * field_size, NULL, 0,\n                        digest)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    for (i = 0; i != msg_len; ++i)\n        msg_mask[i] ^= msg[i];\n\n    if (EVP_DigestInit(hash, digest) == 0\n            || EVP_DigestUpdate(hash, x2y2, field_size) == 0\n            || EVP_DigestUpdate(hash, msg, msg_len) == 0\n            || EVP_DigestUpdate(hash, x2y2 + field_size, field_size) == 0\n            || EVP_DigestFinal(hash, C3, NULL) == 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_EVP_LIB);\n        goto done;\n    }\n\n    ctext_struct.C1x = x1;\n    ctext_struct.C1y = y1;\n    ctext_struct.C3 = ASN1_OCTET_STRING_new();\n    ctext_struct.C2 = ASN1_OCTET_STRING_new();\n\n    if (ctext_struct.C3 == NULL || ctext_struct.C2 == NULL) {\n       SM2err(SM2_F_SM2_ENCRYPT, ERR_R_MALLOC_FAILURE);\n       goto done;\n    }\n    if (!ASN1_OCTET_STRING_set(ctext_struct.C3, C3, C3_size)\n            || !ASN1_OCTET_STRING_set(ctext_struct.C2, msg_mask, msg_len)) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n\n    ciphertext_leni = i2d_SM2_Ciphertext(&ctext_struct, &ciphertext_buf);\n    /* Ensure cast to size_t is safe */\n    if (ciphertext_leni < 0) {\n        SM2err(SM2_F_SM2_ENCRYPT, ERR_R_INTERNAL_ERROR);\n        goto done;\n    }\n    *ciphertext_len = (size_t)ciphertext_leni;\n\n    rc = 1;\n\n done:\n    ASN1_OCTET_STRING_free(ctext_struct.C2);\n    ASN1_OCTET_STRING_free(ctext_struct.C3);\n    OPENSSL_free(msg_mask);\n    OPENSSL_free(x2y2);\n    OPENSSL_free(C3);\n    EVP_MD_CTX_free(hash);\n    BN_CTX_free(ctx);\n    EC_POINT_free(kG);\n    EC_POINT_free(kP);\n    return rc;\n}", "before_change_lines": [24, 25, 31, 32, 33, 34, 35, 36], "raw_before_change_lines": [24, 25, 31, 32, 33, 34, 35, 36], "after_change_lines": [24, 25, 31, 32, 33, 34, 36, 37], "raw_after_change_lines": [24, 25, 31, 32, 33, 34, 35, 36, 37], "bug_lines": [24, 25, 31, 32, 33, 34, 35, 36], "added": [false, false, false, false, false, false, false, false], "idx": 428}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "12402----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_4bec462972291cca57a2581001387ea7d76b85f2_1.json----ERR_print_errors_cb", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_4bec462972291cca57a2581001387ea7d76b85f2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_4bec462972291cca57a2581001387ea7d76b85f2_1.json", "function_name": "ERR_print_errors_cb", "vul_func_code": "void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u),\n                         void *u)\n{\n    unsigned long l;\n    char buf[256];\n    char buf2[4096];\n    const char *file, *data;\n    int line, flags;\n    /*\n     * We don't know what kind of thing CRYPTO_THREAD_ID is. Here is our best\n     * attempt to convert it into something we can print.\n     */\n    union {\n        CRYPTO_THREAD_ID tid;\n        unsigned long ltid;\n    } tid;\n\n    tid.ltid = 0;\n    tid.tid = CRYPTO_THREAD_get_current_id();\n\n    while ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) != 0) {\n        ERR_error_string_n(l, buf, sizeof(buf));\n        BIO_snprintf(buf2, sizeof(buf2), \"%lu:%s:%s:%d:%s\\n\", tid.ltid, buf,\n                     file, line, (flags & ERR_TXT_STRING) ? data : \"\");\n        if (cb(buf2, strlen(buf2), u) <= 0)\n            break;              /* abort outputting the error report */\n    }\n}", "patch_func_code": "void ERR_print_errors_cb(int (*cb) (const char *str, size_t len, void *u),\n                         void *u)\n{\n    CRYPTO_THREAD_ID tid = CRYPTO_THREAD_get_current_id();\n    unsigned long l;\n    char buf[256];\n    char buf2[4096], *hex;\n    const char *file, *data;\n    int line, flags;\n\n    while ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) != 0) {\n        ERR_error_string_n(l, buf, sizeof(buf));\n        hex = OPENSSL_buf2hexstr((const unsigned char *)&tid, sizeof(tid));\n        BIO_snprintf(buf2, sizeof(buf2), \"%s:%s:%s:%d:%s\\n\", hex, buf, file,\n                     line, (flags & ERR_TXT_STRING) ? data : \"\");\n        OPENSSL_free(hex);\n        if (cb(buf2, strlen(buf2), u) <= 0)\n            break;              /* abort outputting the error report */\n    }\n}", "before_change_lines": [6, 10, 11, 12, 13, 14, 15, 16, 18, 19, 23, 24], "raw_before_change_lines": [6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 23, 24], "after_change_lines": [4, 7, 13, 14, 15, 16], "raw_after_change_lines": [4, 7, 13, 14, 15, 16], "bug_lines": [6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 23, 24], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 429}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12581----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_51af23894508fbef3f8de651a6b811edfa1b18d6_1.json----EVP_PBE_CipherInit", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_51af23894508fbef3f8de651a6b811edfa1b18d6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_51af23894508fbef3f8de651a6b811edfa1b18d6_1.json", "function_name": "EVP_PBE_CipherInit", "vul_func_code": "int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\n                       ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\n{\n    const EVP_CIPHER *cipher;\n    const EVP_MD *md;\n    int cipher_nid, md_nid;\n    EVP_PBE_KEYGEN *keygen;\n\n    if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj),\n                      &cipher_nid, &md_nid, &keygen)) {\n        char obj_tmp[80];\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);\n        if (!pbe_obj)\n            BUF_strlcpy(obj_tmp, \"NULL\", sizeof obj_tmp);\n        else\n            i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj);\n        ERR_add_error_data(2, \"TYPE=\", obj_tmp);\n        return 0;\n    }\n\n    if (!pass)\n        passlen = 0;\n    else if (passlen == -1)\n        passlen = strlen(pass);\n\n    if (cipher_nid == -1)\n        cipher = NULL;\n    else {\n        cipher = EVP_get_cipherbynid(cipher_nid);\n        if (!cipher) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER);\n            return 0;\n        }\n    }\n\n    if (md_nid == -1)\n        md = NULL;\n    else {\n        md = EVP_get_digestbynid(md_nid);\n        if (!md) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST);\n            return 0;\n        }\n    }\n\n    if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) {\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE);\n        return 0;\n    }\n    return 1;\n}", "patch_func_code": "int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\n                       ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\n{\n    const EVP_CIPHER *cipher;\n    const EVP_MD *md;\n    int cipher_nid, md_nid;\n    EVP_PBE_KEYGEN *keygen;\n\n    if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj),\n                      &cipher_nid, &md_nid, &keygen)) {\n        char obj_tmp[80];\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);\n        if (!pbe_obj)\n            OPENSSL_strlcpy(obj_tmp, \"NULL\", sizeof obj_tmp);\n        else\n            i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj);\n        ERR_add_error_data(2, \"TYPE=\", obj_tmp);\n        return 0;\n    }\n\n    if (!pass)\n        passlen = 0;\n    else if (passlen == -1)\n        passlen = strlen(pass);\n\n    if (cipher_nid == -1)\n        cipher = NULL;\n    else {\n        cipher = EVP_get_cipherbynid(cipher_nid);\n        if (!cipher) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER);\n            return 0;\n        }\n    }\n\n    if (md_nid == -1)\n        md = NULL;\n    else {\n        md = EVP_get_digestbynid(md_nid);\n        if (!md) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST);\n            return 0;\n        }\n    }\n\n    if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) {\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE);\n        return 0;\n    }\n    return 1;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [14], "raw_after_change_lines": [14], "bug_lines": [14], "added": [false], "idx": 430}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "12590----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_51fa1750855ce49f16d4305ab622163ce120dfe1_1.json----append_buf", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_51fa1750855ce49f16d4305ab622163ce120dfe1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_51fa1750855ce49f16d4305ab622163ce120dfe1_1.json", "function_name": "append_buf", "vul_func_code": "static int append_buf(char **buf, const char *s, int *size, int step)\n{\n    if (*buf == NULL) {\n        *size = step;\n        *buf = app_malloc(*size, \"engine buffer\");\n        **buf = '\\0';\n    }\n\n    if (strlen(*buf) + strlen(s) >= (unsigned int)*size) {\n        *size += step;\n        *buf = OPENSSL_realloc(*buf, *size);\n    }\n\n    if (*buf == NULL)\n        return 0;\n\n    if (**buf != '\\0')\n        BUF_strlcat(*buf, \", \", *size);\n    BUF_strlcat(*buf, s, *size);\n\n    return 1;\n}", "patch_func_code": "static int append_buf(char **buf, const char *s, int *size, int step)\n{\n    if (*buf == NULL) {\n        *size = step;\n        *buf = app_malloc(*size, \"engine buffer\");\n        **buf = '\\0';\n    }\n\n    if (strlen(*buf) + strlen(s) >= (unsigned int)*size) {\n        *size += step;\n        *buf = OPENSSL_realloc(*buf, *size);\n    }\n\n    if (*buf == NULL)\n        return 0;\n\n    if (**buf != '\\0')\n        OPENSSL_strlcat(*buf, \", \", *size);\n    OPENSSL_strlcat(*buf, s, *size);\n\n    return 1;\n}", "before_change_lines": [18, 19], "raw_before_change_lines": [18, 19], "after_change_lines": [18, 19], "raw_after_change_lines": [18, 19], "bug_lines": [18, 19], "added": [false, false], "idx": 431}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12652----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5402d3f8f74b9cda8d201e05cfbde1870254ff92_1.json----tls_construct_stoc_renegotiate", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_5402d3f8f74b9cda8d201e05cfbde1870254ff92_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5402d3f8f74b9cda8d201e05cfbde1870254ff92_1.json", "function_name": "tls_construct_stoc_renegotiate", "vul_func_code": "EXT_RETURN tls_construct_stoc_renegotiate(SSL *s, WPACKET *pkt,\n                                          unsigned int context, X509 *x,\n                                          size_t chainidx)\n{\n    if (!s->s3->send_connection_binding)\n        return EXT_RETURN_NOT_SENT;\n\n    /* Still add this even if SSL_OP_NO_RENEGOTIATION is set */\n    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_renegotiate)\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_start_sub_packet_u8(pkt)\n            || !WPACKET_memcpy(pkt, s->s3->previous_client_finished,\n                               s->s3->previous_client_finished_len)\n            || !WPACKET_memcpy(pkt, s->s3->previous_server_finished,\n                               s->s3->previous_server_finished_len)\n            || !WPACKET_close(pkt)\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE,\n                 ERR_R_INTERNAL_ERROR);\n        return EXT_RETURN_FAIL;\n    }\n\n    return EXT_RETURN_SENT;\n}", "patch_func_code": "EXT_RETURN tls_construct_stoc_renegotiate(SSL *s, WPACKET *pkt,\n                                          unsigned int context, X509 *x,\n                                          size_t chainidx)\n{\n    if (!s->s3.send_connection_binding)\n        return EXT_RETURN_NOT_SENT;\n\n    /* Still add this even if SSL_OP_NO_RENEGOTIATION is set */\n    if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_renegotiate)\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_start_sub_packet_u8(pkt)\n            || !WPACKET_memcpy(pkt, s->s3.previous_client_finished,\n                               s->s3.previous_client_finished_len)\n            || !WPACKET_memcpy(pkt, s->s3.previous_server_finished,\n                               s->s3.previous_server_finished_len)\n            || !WPACKET_close(pkt)\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE,\n                 ERR_R_INTERNAL_ERROR);\n        return EXT_RETURN_FAIL;\n    }\n\n    return EXT_RETURN_SENT;\n}", "before_change_lines": [5, 12, 13, 14, 15], "raw_before_change_lines": [5, 12, 13, 14, 15], "after_change_lines": [5, 12, 13, 14, 15], "raw_after_change_lines": [5, 12, 13, 14, 15], "bug_lines": [5, 12, 13, 14, 15], "added": [false, false, false, false, false], "idx": 432}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12679----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_54f1c9e48ca89d3c6971480829afc2f76fdd1b76_1.json----ssl3_accept", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_54f1c9e48ca89d3c6971480829afc2f76fdd1b76_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_54f1c9e48ca89d3c6971480829afc2f76fdd1b76_1.json", "function_name": "ssl3_accept", "vul_func_code": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long l,Time=time(NULL);\n\tvoid (*cb)()=NULL;\n\tlong num1;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\ts->in_handshake++;\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->new_session=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t */\n\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tret=1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_get_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\tl=s->s3->tmp.new_cipher->algorithms;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif (s->options & SSL_OP_EPHEMERAL_RSA)\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t    || (l & (SSL_DH|SSL_kFZA))\n\t\t\t    || ((l & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\t\t\t/* number of bytes to be flushed */\n\t\t\tnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\n\t\t\tif (num1 > 0)\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_WRITING;\n\t\t\t\tnum1=BIO_flush(s->wbio);\n\t\t\t\tif (num1 <= 0) { ret= -1; goto end; }\n\t\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\t\t}\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n\t\t\telse {\n\t\t\t\t/* could be sent for a DH cert, even if we\n\t\t\t\t * have not asked for it :-) */\n\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* We need to get hashes here so if there is\n\t\t\t * a client cert, it can be verified */ \n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t&(s->s3->finish_dgst1),\n\t\t\t\t&(s->s3->tmp.cert_verify_md[0]));\n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t&(s->s3->finish_dgst2),\n\t\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->new_session=0;\n\t\t\ts->init_num=0;\n\n\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\n\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t/* s->server=1; */\n\t\t\ts->handshake_func=ssl3_accept;\n\t\t\tret=1;\n\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\ts->in_handshake--;\n\treturn(ret);\n\t}", "patch_func_code": "int ssl3_accept(SSL *s)\n\t{\n\tBUF_MEM *buf;\n\tunsigned long l,Time=time(NULL);\n\tvoid (*cb)()=NULL;\n\tlong num1;\n\tint ret= -1;\n\tint new_state,state,skip=0;\n\n\tRAND_add(&Time,sizeof(Time),0);\n\tERR_clear_error();\n\tclear_sys_error();\n\n\tif (s->info_callback != NULL)\n\t\tcb=s->info_callback;\n\telse if (s->ctx->info_callback != NULL)\n\t\tcb=s->ctx->info_callback;\n\n\t/* init things to blank */\n\tif (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);\n\ts->in_handshake++;\n\n\tif (s->cert == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_NO_CERTIFICATE_SET);\n\t\treturn(-1);\n\t\t}\n\n\tfor (;;)\n\t\t{\n\t\tstate=s->state;\n\n\t\tswitch (s->state)\n\t\t\t{\n\t\tcase SSL_ST_RENEGOTIATE:\n\t\t\ts->new_session=1;\n\t\t\t/* s->state=SSL_ST_ACCEPT; */\n\n\t\tcase SSL_ST_BEFORE:\n\t\tcase SSL_ST_ACCEPT:\n\t\tcase SSL_ST_BEFORE|SSL_ST_ACCEPT:\n\t\tcase SSL_ST_OK|SSL_ST_ACCEPT:\n\n\t\t\ts->server=1;\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_START,1);\n\n\t\t\tif ((s->version>>8) != 3)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_ACCEPT, SSL_R_INTERNAL_ERROR);\n\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\ts->type=SSL_ST_ACCEPT;\n\n\t\t\tif (s->init_buf == NULL)\n\t\t\t\t{\n\t\t\t\tif ((buf=BUF_MEM_new()) == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\tif (!BUF_MEM_grow(buf,SSL3_RT_MAX_PLAIN_LENGTH))\n\t\t\t\t\t{\n\t\t\t\t\tret= -1;\n\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\ts->init_buf=buf;\n\t\t\t\t}\n\n\t\t\tif (!ssl3_setup_buffers(s))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\t/* Ok, we now need to push on a buffering BIO so that\n\t\t\t * the output is sent in a way that TCP likes :-)\n\t\t\t */\n\t\t\tif (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }\n\n\t\t\ts->init_num=0;\n\n\t\t\tif (s->state != SSL_ST_RENEGOTIATE)\n\t\t\t\t{\n\t\t\t\tssl3_init_finished_mac(s);\n\t\t\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\t\t\t\ts->ctx->stats.sess_accept++;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->ctx->stats.sess_accept_renegotiate++;\n\t\t\t\ts->state=SSL3_ST_SW_HELLO_REQ_A;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_A:\n\t\tcase SSL3_ST_SW_HELLO_REQ_B:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_send_hello_request(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_HELLO_REQ_C:\n\t\t\ts->state=SSL_ST_OK;\n\t\t\tret=1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tcase SSL3_ST_SR_CLNT_HELLO_A:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_B:\n\t\tcase SSL3_ST_SR_CLNT_HELLO_C:\n\n\t\t\ts->shutdown=0;\n\t\t\tret=ssl3_get_client_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_SRVR_HELLO_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_HELLO_A:\n\t\tcase SSL3_ST_SW_SRVR_HELLO_B:\n\t\t\tret=ssl3_send_server_hello(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CERT_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_A:\n\t\tcase SSL3_ST_SW_CERT_B:\n\t\t\t/* Check if it is anon DH */\n\t\t\tif (!(s->s3->tmp.new_cipher->algorithms & SSL_aNULL))\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\t\t\ts->state=SSL3_ST_SW_KEY_EXCH_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_KEY_EXCH_A:\n\t\tcase SSL3_ST_SW_KEY_EXCH_B:\n\t\t\tl=s->s3->tmp.new_cipher->algorithms;\n\n\t\t\t/* clear this, it may get reset by\n\t\t\t * send_server_key_exchange */\n\t\t\tif ((s->options & SSL_OP_EPHEMERAL_RSA)\n#ifndef NO_KRB5\n\t\t\t\t&& !(l & SSL_KRB5)\n#endif /* NO_KRB5 */\n\t\t\t\t)\n\t\t\t\ts->s3->tmp.use_rsa_tmp=1;\n\t\t\telse\n\t\t\t\ts->s3->tmp.use_rsa_tmp=0;\n\n\t\t\t/* only send if a DH key exchange, fortezza or\n\t\t\t * RSA but we have a sign only certificate */\n\t\t\tif (s->s3->tmp.use_rsa_tmp\n\t\t\t    || (l & (SSL_DH|SSL_kFZA))\n\t\t\t    || ((l & SSL_kRSA)\n\t\t\t\t&& (s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL\n\t\t\t\t    || (SSL_C_IS_EXPORT(s->s3->tmp.new_cipher)\n\t\t\t\t\t&& EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey)*8 > SSL_C_EXPORT_PKEYLENGTH(s->s3->tmp.new_cipher)\n\t\t\t\t\t)\n\t\t\t\t    )\n\t\t\t\t)\n\t\t\t    )\n\t\t\t\t{\n\t\t\t\tret=ssl3_send_server_key_exchange(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\tskip=1;\n\n\t\t\ts->state=SSL3_ST_SW_CERT_REQ_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CERT_REQ_A:\n\t\tcase SSL3_ST_SW_CERT_REQ_B:\n\t\t\tif (/* don't request cert unless asked for it: */\n\t\t\t\t!(s->verify_mode & SSL_VERIFY_PEER) ||\n\t\t\t\t/* if SSL_VERIFY_CLIENT_ONCE is set,\n\t\t\t\t * don't request cert during re-negotiation: */\n\t\t\t\t((s->session->peer != NULL) &&\n\t\t\t\t (s->verify_mode & SSL_VERIFY_CLIENT_ONCE)) ||\n\t\t\t\t/* never request cert in anonymous ciphersuites\n\t\t\t\t * (see section \"Certificate request\" in SSL 3 drafts\n\t\t\t\t * and in RFC 2246): */\n\t\t\t\t((s->s3->tmp.new_cipher->algorithms & SSL_aNULL) &&\n\t\t\t\t /* ... except when the application insists on verification\n\t\t\t\t  * (against the specs, but s3_clnt.c accepts this for SSL 3) */\n\t\t\t\t !(s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n\t\t\t\t{\n\t\t\t\t/* no cert request */\n\t\t\t\tskip=1;\n\t\t\t\ts->s3->tmp.cert_request=0;\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ts->s3->tmp.cert_request=1;\n\t\t\t\tret=ssl3_send_certificate_request(s);\n\t\t\t\tif (ret <= 0) goto end;\n#ifndef NETSCAPE_HANG_BUG\n\t\t\t\ts->state=SSL3_ST_SW_SRVR_DONE_A;\n#else\n\t\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n#endif\n\t\t\t\ts->init_num=0;\n\t\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_SRVR_DONE_A:\n\t\tcase SSL3_ST_SW_SRVR_DONE_B:\n\t\t\tret=ssl3_send_server_done(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_CERT_A;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\t\t\n\t\tcase SSL3_ST_SW_FLUSH:\n\t\t\t/* number of bytes to be flushed */\n\t\t\tnum1=BIO_ctrl(s->wbio,BIO_CTRL_INFO,0,NULL);\n\t\t\tif (num1 > 0)\n\t\t\t\t{\n\t\t\t\ts->rwstate=SSL_WRITING;\n\t\t\t\tnum1=BIO_flush(s->wbio);\n\t\t\t\tif (num1 <= 0) { ret= -1; goto end; }\n\t\t\t\ts->rwstate=SSL_NOTHING;\n\t\t\t\t}\n\n\t\t\ts->state=s->s3->tmp.next_state;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_A:\n\t\tcase SSL3_ST_SR_CERT_B:\n\t\t\t/* Check for second client hello (MS SGC) */\n\t\t\tret = ssl3_check_client_hello(s);\n\t\t\tif (ret <= 0)\n\t\t\t\tgoto end;\n\t\t\tif (ret == 2)\n\t\t\t\ts->state = SSL3_ST_SR_CLNT_HELLO_C;\n\t\t\telse {\n\t\t\t\t/* could be sent for a DH cert, even if we\n\t\t\t\t * have not asked for it :-) */\n\t\t\t\tret=ssl3_get_client_certificate(s);\n\t\t\t\tif (ret <= 0) goto end;\n\t\t\t\ts->init_num=0;\n\t\t\t\ts->state=SSL3_ST_SR_KEY_EXCH_A;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_KEY_EXCH_A:\n\t\tcase SSL3_ST_SR_KEY_EXCH_B:\n\t\t\tret=ssl3_get_client_key_exchange(s);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SR_CERT_VRFY_A;\n\t\t\ts->init_num=0;\n\n\t\t\t/* We need to get hashes here so if there is\n\t\t\t * a client cert, it can be verified */ \n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t&(s->s3->finish_dgst1),\n\t\t\t\t&(s->s3->tmp.cert_verify_md[0]));\n\t\t\ts->method->ssl3_enc->cert_verify_mac(s,\n\t\t\t\t&(s->s3->finish_dgst2),\n\t\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]));\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_CERT_VRFY_A:\n\t\tcase SSL3_ST_SR_CERT_VRFY_B:\n\n\t\t\t/* we should decide if we expected this one */\n\t\t\tret=ssl3_get_cert_verify(s);\n\t\t\tif (ret <= 0) goto end;\n\n\t\t\ts->state=SSL3_ST_SR_FINISHED_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SR_FINISHED_A:\n\t\tcase SSL3_ST_SR_FINISHED_B:\n\t\t\tret=ssl3_get_finished(s,SSL3_ST_SR_FINISHED_A,\n\t\t\t\tSSL3_ST_SR_FINISHED_B);\n\t\t\tif (ret <= 0) goto end;\n\t\t\tif (s->hit)\n\t\t\t\ts->state=SSL_ST_OK;\n\t\t\telse\n\t\t\t\ts->state=SSL3_ST_SW_CHANGE_A;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_CHANGE_A:\n\t\tcase SSL3_ST_SW_CHANGE_B:\n\n\t\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\t\tif (!s->method->ssl3_enc->setup_key_block(s))\n\t\t\t\t{ ret= -1; goto end; }\n\n\t\t\tret=ssl3_send_change_cipher_spec(s,\n\t\t\t\tSSL3_ST_SW_CHANGE_A,SSL3_ST_SW_CHANGE_B);\n\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FINISHED_A;\n\t\t\ts->init_num=0;\n\n\t\t\tif (!s->method->ssl3_enc->change_cipher_state(s,\n\t\t\t\tSSL3_CHANGE_CIPHER_SERVER_WRITE))\n\t\t\t\t{\n\t\t\t\tret= -1;\n\t\t\t\tgoto end;\n\t\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SSL3_ST_SW_FINISHED_A:\n\t\tcase SSL3_ST_SW_FINISHED_B:\n\t\t\tret=ssl3_send_finished(s,\n\t\t\t\tSSL3_ST_SW_FINISHED_A,SSL3_ST_SW_FINISHED_B,\n\t\t\t\ts->method->ssl3_enc->server_finished_label,\n\t\t\t\ts->method->ssl3_enc->server_finished_label_len);\n\t\t\tif (ret <= 0) goto end;\n\t\t\ts->state=SSL3_ST_SW_FLUSH;\n\t\t\tif (s->hit)\n\t\t\t\ts->s3->tmp.next_state=SSL3_ST_SR_FINISHED_A;\n\t\t\telse\n\t\t\t\ts->s3->tmp.next_state=SSL_ST_OK;\n\t\t\ts->init_num=0;\n\t\t\tbreak;\n\n\t\tcase SSL_ST_OK:\n\t\t\t/* clean a few things up */\n\t\t\tssl3_cleanup_key_block(s);\n\n\t\t\tBUF_MEM_free(s->init_buf);\n\t\t\ts->init_buf=NULL;\n\n\t\t\t/* remove buffering on output */\n\t\t\tssl_free_wbio_buffer(s);\n\n\t\t\ts->new_session=0;\n\t\t\ts->init_num=0;\n\n\t\t\tssl_update_cache(s,SSL_SESS_CACHE_SERVER);\n\n\t\t\ts->ctx->stats.sess_accept_good++;\n\t\t\t/* s->server=1; */\n\t\t\ts->handshake_func=ssl3_accept;\n\t\t\tret=1;\n\n\t\t\tif (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);\n\n\t\t\tgoto end;\n\t\t\t/* break; */\n\n\t\tdefault:\n\t\t\tSSLerr(SSL_F_SSL3_ACCEPT,SSL_R_UNKNOWN_STATE);\n\t\t\tret= -1;\n\t\t\tgoto end;\n\t\t\t/* break; */\n\t\t\t}\n\t\t\n\t\tif (!s->s3->tmp.reuse_message && !skip)\n\t\t\t{\n\t\t\tif (s->debug)\n\t\t\t\t{\n\t\t\t\tif ((ret=BIO_flush(s->wbio)) <= 0)\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\n\n\t\t\tif ((cb != NULL) && (s->state != state))\n\t\t\t\t{\n\t\t\t\tnew_state=s->state;\n\t\t\t\ts->state=state;\n\t\t\t\tcb(s,SSL_CB_ACCEPT_LOOP,1);\n\t\t\t\ts->state=new_state;\n\t\t\t\t}\n\t\t\t}\n\t\tskip=0;\n\t\t}\nend:\n\t/* BIO_flush(s->wbio); */\n\n\tif (cb != NULL)\n\t\tcb(s,SSL_CB_ACCEPT_EXIT,ret);\n\ts->in_handshake--;\n\treturn(ret);\n\t}", "before_change_lines": [157], "raw_before_change_lines": [157], "after_change_lines": [157, 158, 159, 160, 161], "raw_after_change_lines": [157, 158, 159, 160, 161], "bug_lines": [157], "added": [false], "idx": 433}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "12687----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_555b95fa7dd6674978e11f3590ee75fa08e038dd_1.json----tls_construct_client_key_exchange", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_555b95fa7dd6674978e11f3590ee75fa08e038dd_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_555b95fa7dd6674978e11f3590ee75fa08e038dd_1.json", "function_name": "tls_construct_client_key_exchange", "vul_func_code": "int tls_construct_client_key_exchange(SSL *s)\n{\n    unsigned char *p;\n    int n;\n#ifndef OPENSSL_NO_PSK\n    size_t pskhdrlen = 0;\n#endif\n    unsigned long alg_k;\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q;\n    EVP_PKEY *pkey = NULL;\n#endif\n#ifndef OPENSSL_NO_EC\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n#endif\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    p = ssl_handshake_start(s);\n\n\n#ifndef OPENSSL_NO_PSK\n    if (alg_k & SSL_PSK) {\n        int psk_err = 1;\n        /*\n         * The callback needs PSK_MAX_IDENTITY_LEN + 1 bytes to return a\n         * \\0-terminated identity. The last byte is for us for simulating\n         * strnlen.\n         */\n        char identity[PSK_MAX_IDENTITY_LEN + 1];\n        size_t identitylen;\n        unsigned char psk[PSK_MAX_PSK_LEN];\n        size_t psklen;\n\n        if (s->psk_client_callback == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_PSK_NO_CLIENT_CB);\n            goto err;\n        }\n\n        memset(identity, 0, sizeof(identity));\n\n        psklen = s->psk_client_callback(s, s->session->psk_identity_hint,\n                                        identity, sizeof(identity) - 1,\n                                        psk, sizeof(psk));\n\n        if (psklen > PSK_MAX_PSK_LEN) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto psk_err;\n        } else if (psklen == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_PSK_IDENTITY_NOT_FOUND);\n            goto psk_err;\n        }\n\n        OPENSSL_free(s->s3->tmp.psk);\n        s->s3->tmp.psk = BUF_memdup(psk, psklen);\n        OPENSSL_cleanse(psk, psklen);\n\n        if (s->s3->tmp.psk == NULL) {\n            OPENSSL_cleanse(identity, sizeof(identity));\n            goto memerr;\n        }\n\n        s->s3->tmp.psklen = psklen;\n\n        identitylen = strlen(identity);\n        if (identitylen > PSK_MAX_IDENTITY_LEN) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto psk_err;\n        }\n        OPENSSL_free(s->session->psk_identity);\n        s->session->psk_identity = BUF_strdup(identity);\n        if (s->session->psk_identity == NULL) {\n            OPENSSL_cleanse(identity, sizeof(identity));\n            goto memerr;\n        }\n\n        s2n(identitylen, p);\n        memcpy(p, identity, identitylen);\n        pskhdrlen = 2 + identitylen;\n        p += identitylen;\n        psk_err = 0;\npsk_err:\n        OPENSSL_cleanse(identity, sizeof(identity));\n        if (psk_err != 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            goto err;\n        }\n    }\n    if (alg_k & SSL_kPSK) {\n        n = 0;\n    } else\n#endif\n\n    /* Fool emacs indentation */\n    if (0) {\n    }\n#ifndef OPENSSL_NO_RSA\n    else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) {\n        RSA *rsa;\n        pmslen = SSL_MAX_MASTER_KEY_LENGTH;\n        pms = OPENSSL_malloc(pmslen);\n        if (pms == NULL)\n            goto memerr;\n\n        if (s->session->peer == NULL) {\n            /*\n             * We should always have a server certificate with SSL_kRSA.\n             */\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        pkey = X509_get_pubkey(s->session->peer);\n        if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA)\n            || (pkey->pkey.rsa == NULL)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            EVP_PKEY_free(pkey);\n            goto err;\n        }\n        rsa = pkey->pkey.rsa;\n        EVP_PKEY_free(pkey);\n\n        pms[0] = s->client_version >> 8;\n        pms[1] = s->client_version & 0xff;\n        if (RAND_bytes(pms + 2, pmslen - 2) <= 0)\n            goto err;\n\n        q = p;\n        /* Fix buf for TLS and beyond */\n        if (s->version > SSL3_VERSION)\n            p += 2;\n        n = RSA_public_encrypt(pmslen, pms, p, rsa, RSA_PKCS1_PADDING);\n# ifdef PKCS1_CHECK\n        if (s->options & SSL_OP_PKCS1_CHECK_1)\n            p[1]++;\n        if (s->options & SSL_OP_PKCS1_CHECK_2)\n            tmp_buf[0] = 0x70;\n# endif\n        if (n <= 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_BAD_RSA_ENCRYPT);\n            goto err;\n        }\n\n        /* Fix buf for TLS and beyond */\n        if (s->version > SSL3_VERSION) {\n            s2n(n, q);\n            n += 2;\n        }\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    else if (alg_k & (SSL_kDHE | SSL_kDHr | SSL_kDHd | SSL_kDHEPSK)) {\n        DH *dh_srvr, *dh_clnt;\n        if (s->s3->peer_dh_tmp != NULL)\n            dh_srvr = s->s3->peer_dh_tmp;\n        else {\n            /* we get them from the cert */\n            EVP_PKEY *spkey = NULL;\n            dh_srvr = NULL;\n            spkey = X509_get_pubkey(s->session->peer);\n            if (spkey) {\n                dh_srvr = EVP_PKEY_get1_DH(spkey);\n                EVP_PKEY_free(spkey);\n            }\n            if (dh_srvr == NULL) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n        if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n            /* Use client certificate key */\n            EVP_PKEY *clkey = s->cert->key->privatekey;\n            dh_clnt = NULL;\n            if (clkey)\n                dh_clnt = EVP_PKEY_get1_DH(clkey);\n            if (dh_clnt == NULL) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        } else {\n            /* generate a new random key */\n            if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                goto err;\n            }\n            if (!DH_generate_key(dh_clnt)) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                DH_free(dh_clnt);\n                goto err;\n            }\n        }\n\n        pmslen = DH_size(dh_clnt);\n        pms = OPENSSL_malloc(pmslen);\n        if (pms == NULL)\n            goto memerr;\n\n        /*\n         * use the 'p' output buffer for the DH key, but make sure to\n         * clear it out afterwards\n         */\n\n        n = DH_compute_key(pms, dh_srvr->pub_key, dh_clnt);\n        if (s->s3->peer_dh_tmp == NULL)\n            DH_free(dh_srvr);\n\n        if (n <= 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n            DH_free(dh_clnt);\n            goto err;\n        }\n        pmslen = n;\n\n        if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)\n            n = 0;\n        else {\n            /* send off the data */\n            n = BN_num_bytes(dh_clnt->pub_key);\n            s2n(n, p);\n            BN_bn2bin(dh_clnt->pub_key, p);\n            n += 2;\n        }\n\n        DH_free(dh_clnt);\n    }\n#endif\n\n#ifndef OPENSSL_NO_EC\n    else if (alg_k & (SSL_kECDHE | SSL_kECDHr | SSL_kECDHe | SSL_kECDHEPSK)) {\n\n        if (s->s3->peer_tmp != NULL) {\n            skey = s->s3->peer_tmp;\n        } else {\n            /* Get the Server Public Key from Cert */\n            skey = X509_get0_pubkey(s->session->peer);\n            if ((skey == NULL)\n                || (skey->type != EVP_PKEY_EC)\n                || (skey->pkey.ec == NULL)) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        ckey = ssl_generate_pkey(skey, NID_undef);\n\n        if (ssl_derive(s, ckey, skey) == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB);\n            goto err;\n        }\n\n        /* Generate encoding of client key */\n        encoded_pt_len = EC_KEY_key2buf(EVP_PKEY_get0_EC_KEY(ckey),\n                                        POINT_CONVERSION_UNCOMPRESSED,\n                                        &encodedPoint, NULL);\n\n        if (encoded_pt_len == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n\n        EVP_PKEY_free(ckey);\n        ckey = NULL;\n\n        n = encoded_pt_len;\n\n        *p = n;         /* length of encoded point */\n        /* Encoded point will be copied here */\n        p += 1;\n        /* copy the point */\n        memcpy(p, encodedPoint, n);\n        /* increment n to account for length field */\n        n += 1;\n\n        /* Free allocated memory */\n        OPENSSL_free(encodedPoint);\n    }\n#endif                          /* !OPENSSL_NO_EC */\n#ifndef OPENSSL_NO_GOST\n    else if (alg_k & SSL_kGOST) {\n        /* GOST key exchange message creation */\n        EVP_PKEY_CTX *pkey_ctx;\n        X509 *peer_cert;\n        size_t msglen;\n        unsigned int md_len;\n        unsigned char shared_ukm[32], tmp[256];\n        EVP_MD_CTX *ukm_hash;\n        EVP_PKEY *pub_key;\n        int dgst_nid = NID_id_GostR3411_94;\n        if ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aGOST12) != 0)\n            dgst_nid = NID_id_GostR3411_2012_256;\n\n\n        pmslen = 32;\n        pms = OPENSSL_malloc(pmslen);\n        if (pms == NULL)\n            goto memerr;\n\n        /*\n         * Get server sertificate PKEY and create ctx from it\n         */\n        peer_cert = s->session->peer;\n        if (!peer_cert) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n            goto err;\n        }\n\n        pkey_ctx = EVP_PKEY_CTX_new(pub_key =\n                                    X509_get_pubkey(peer_cert), NULL);\n        if (pkey_ctx == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        /*\n         * If we have send a certificate, and certificate key\n         * parameters match those of server certificate, use\n         * certificate key for key exchange\n         */\n\n        /* Otherwise, generate ephemeral key pair */\n\n        if (pkey_ctx == NULL\n                || EVP_PKEY_encrypt_init(pkey_ctx) <= 0\n                /* Generate session key */\n                || RAND_bytes(pms, pmslen) <= 0) {\n            EVP_PKEY_CTX_free(pkey_ctx);\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        };\n        /*\n         * If we have client certificate, use its secret as peer key\n         */\n        if (s->s3->tmp.cert_req && s->cert->key->privatekey) {\n            if (EVP_PKEY_derive_set_peer\n                (pkey_ctx, s->cert->key->privatekey) <= 0) {\n                /*\n                 * If there was an error - just ignore it. Ephemeral key\n                 * * would be used\n                 */\n                ERR_clear_error();\n            }\n        }\n        /*\n         * Compute shared IV and store it in algorithm-specific context\n         * data\n         */\n        ukm_hash = EVP_MD_CTX_new();\n        if (EVP_DigestInit(ukm_hash,\n                           EVP_get_digestbynid(dgst_nid)) <= 0\n                || EVP_DigestUpdate(ukm_hash, s->s3->client_random,\n                                    SSL3_RANDOM_SIZE) <= 0\n                || EVP_DigestUpdate(ukm_hash, s->s3->server_random,\n                                    SSL3_RANDOM_SIZE) <= 0\n                || EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) {\n            EVP_MD_CTX_free(ukm_hash);\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        EVP_MD_CTX_free(ukm_hash);\n        if (EVP_PKEY_CTX_ctrl\n            (pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV, 8,\n             shared_ukm) < 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_LIBRARY_BUG);\n            goto err;\n        }\n        /* Make GOST keytransport blob message */\n        /*\n         * Encapsulate it into sequence\n         */\n        *(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;\n        msglen = 255;\n        if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_LIBRARY_BUG);\n            goto err;\n        }\n        if (msglen >= 0x80) {\n            *(p++) = 0x81;\n            *(p++) = msglen & 0xff;\n            n = msglen + 3;\n        } else {\n            *(p++) = msglen & 0xff;\n            n = msglen + 2;\n        }\n        memcpy(p, tmp, msglen);\n        /* Check if pubkey from client certificate was used */\n        if (EVP_PKEY_CTX_ctrl\n            (pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) {\n            /* Set flag \"skip certificate verify\" */\n            s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;\n        }\n        EVP_PKEY_CTX_free(pkey_ctx);\n        EVP_PKEY_free(pub_key);\n\n    }\n#endif\n#ifndef OPENSSL_NO_SRP\n    else if (alg_k & SSL_kSRP) {\n        if (s->srp_ctx.A != NULL) {\n            /* send off the data */\n            n = BN_num_bytes(s->srp_ctx.A);\n            s2n(n, p);\n            BN_bn2bin(s->srp_ctx.A, p);\n            n += 2;\n        } else {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        OPENSSL_free(s->session->srp_username);\n        s->session->srp_username = BUF_strdup(s->srp_ctx.login);\n        if (s->session->srp_username == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n#endif\n    else {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n#ifndef OPENSSL_NO_PSK\n    n += pskhdrlen;\n#endif\n\n    if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, n)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (pms != NULL) {\n        s->s3->tmp.pms = pms;\n        s->s3->tmp.pmslen = pmslen;\n    }\n\n    return 1;\n memerr:\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n    SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    s->s3->tmp.pms = NULL;\n#ifndef OPENSSL_NO_EC\n    OPENSSL_free(encodedPoint);\n    EVP_PKEY_free(ckey);\n#endif\n#ifndef OPENSSL_NO_PSK\n    OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen);\n    s->s3->tmp.psk = NULL;\n#endif\n    ossl_statem_set_error(s);\n    return 0;\n}", "patch_func_code": "int tls_construct_client_key_exchange(SSL *s)\n{\n    unsigned char *p;\n    int n;\n#ifndef OPENSSL_NO_PSK\n    size_t pskhdrlen = 0;\n#endif\n    unsigned long alg_k;\n#ifndef OPENSSL_NO_RSA\n    unsigned char *q;\n    EVP_PKEY *pkey = NULL;\n#endif\n#ifndef OPENSSL_NO_EC\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n#endif\n    unsigned char *pms = NULL;\n    size_t pmslen = 0;\n    alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n\n    p = ssl_handshake_start(s);\n\n\n#ifndef OPENSSL_NO_PSK\n    if (alg_k & SSL_PSK) {\n        int psk_err = 1;\n        /*\n         * The callback needs PSK_MAX_IDENTITY_LEN + 1 bytes to return a\n         * \\0-terminated identity. The last byte is for us for simulating\n         * strnlen.\n         */\n        char identity[PSK_MAX_IDENTITY_LEN + 1];\n        size_t identitylen;\n        unsigned char psk[PSK_MAX_PSK_LEN];\n        size_t psklen;\n\n        if (s->psk_client_callback == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_PSK_NO_CLIENT_CB);\n            goto err;\n        }\n\n        memset(identity, 0, sizeof(identity));\n\n        psklen = s->psk_client_callback(s, s->session->psk_identity_hint,\n                                        identity, sizeof(identity) - 1,\n                                        psk, sizeof(psk));\n\n        if (psklen > PSK_MAX_PSK_LEN) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto psk_err;\n        } else if (psklen == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_PSK_IDENTITY_NOT_FOUND);\n            goto psk_err;\n        }\n        OPENSSL_free(s->s3->tmp.psk);\n        s->s3->tmp.psk = OPENSSL_memdup(psk, psklen);\n        OPENSSL_cleanse(psk, psklen);\n\n        if (s->s3->tmp.psk == NULL) {\n            OPENSSL_cleanse(identity, sizeof(identity));\n            goto memerr;\n        }\n\n        s->s3->tmp.psklen = psklen;\n        identitylen = strlen(identity);\n        if (identitylen > PSK_MAX_IDENTITY_LEN) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto psk_err;\n        }\n        OPENSSL_free(s->session->psk_identity);\n        s->session->psk_identity = OPENSSL_strdup(identity);\n        if (s->session->psk_identity == NULL) {\n            OPENSSL_cleanse(identity, sizeof(identity));\n            goto memerr;\n        }\n\n        s2n(identitylen, p);\n        memcpy(p, identity, identitylen);\n        pskhdrlen = 2 + identitylen;\n        p += identitylen;\n        psk_err = 0;\npsk_err:\n        OPENSSL_cleanse(identity, sizeof(identity));\n        if (psk_err != 0) {\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            goto err;\n        }\n    }\n    if (alg_k & SSL_kPSK) {\n        n = 0;\n    } else\n#endif\n\n    /* Fool emacs indentation */\n    if (0) {\n    }\n#ifndef OPENSSL_NO_RSA\n    else if (alg_k & (SSL_kRSA | SSL_kRSAPSK)) {\n        RSA *rsa;\n        pmslen = SSL_MAX_MASTER_KEY_LENGTH;\n        pms = OPENSSL_malloc(pmslen);\n        if (pms == NULL)\n            goto memerr;\n\n        if (s->session->peer == NULL) {\n            /*\n             * We should always have a server certificate with SSL_kRSA.\n             */\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n\n        pkey = X509_get_pubkey(s->session->peer);\n        if ((pkey == NULL) || (pkey->type != EVP_PKEY_RSA)\n            || (pkey->pkey.rsa == NULL)) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            EVP_PKEY_free(pkey);\n            goto err;\n        }\n        rsa = pkey->pkey.rsa;\n        EVP_PKEY_free(pkey);\n\n        pms[0] = s->client_version >> 8;\n        pms[1] = s->client_version & 0xff;\n        if (RAND_bytes(pms + 2, pmslen - 2) <= 0)\n            goto err;\n\n        q = p;\n        /* Fix buf for TLS and beyond */\n        if (s->version > SSL3_VERSION)\n            p += 2;\n        n = RSA_public_encrypt(pmslen, pms, p, rsa, RSA_PKCS1_PADDING);\n# ifdef PKCS1_CHECK\n        if (s->options & SSL_OP_PKCS1_CHECK_1)\n            p[1]++;\n        if (s->options & SSL_OP_PKCS1_CHECK_2)\n            tmp_buf[0] = 0x70;\n# endif\n        if (n <= 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_BAD_RSA_ENCRYPT);\n            goto err;\n        }\n\n        /* Fix buf for TLS and beyond */\n        if (s->version > SSL3_VERSION) {\n            s2n(n, q);\n            n += 2;\n        }\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    else if (alg_k & (SSL_kDHE | SSL_kDHr | SSL_kDHd | SSL_kDHEPSK)) {\n        DH *dh_srvr, *dh_clnt;\n        if (s->s3->peer_dh_tmp != NULL)\n            dh_srvr = s->s3->peer_dh_tmp;\n        else {\n            /* we get them from the cert */\n            EVP_PKEY *spkey = NULL;\n            dh_srvr = NULL;\n            spkey = X509_get_pubkey(s->session->peer);\n            if (spkey) {\n                dh_srvr = EVP_PKEY_get1_DH(spkey);\n                EVP_PKEY_free(spkey);\n            }\n            if (dh_srvr == NULL) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n        if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY) {\n            /* Use client certificate key */\n            EVP_PKEY *clkey = s->cert->key->privatekey;\n            dh_clnt = NULL;\n            if (clkey)\n                dh_clnt = EVP_PKEY_get1_DH(clkey);\n            if (dh_clnt == NULL) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        } else {\n            /* generate a new random key */\n            if ((dh_clnt = DHparams_dup(dh_srvr)) == NULL) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                goto err;\n            }\n            if (!DH_generate_key(dh_clnt)) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n                DH_free(dh_clnt);\n                goto err;\n            }\n        }\n\n        pmslen = DH_size(dh_clnt);\n        pms = OPENSSL_malloc(pmslen);\n        if (pms == NULL)\n            goto memerr;\n\n        /*\n         * use the 'p' output buffer for the DH key, but make sure to\n         * clear it out afterwards\n         */\n\n        n = DH_compute_key(pms, dh_srvr->pub_key, dh_clnt);\n        if (s->s3->peer_dh_tmp == NULL)\n            DH_free(dh_srvr);\n\n        if (n <= 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_DH_LIB);\n            DH_free(dh_clnt);\n            goto err;\n        }\n        pmslen = n;\n\n        if (s->s3->flags & TLS1_FLAGS_SKIP_CERT_VERIFY)\n            n = 0;\n        else {\n            /* send off the data */\n            n = BN_num_bytes(dh_clnt->pub_key);\n            s2n(n, p);\n            BN_bn2bin(dh_clnt->pub_key, p);\n            n += 2;\n        }\n\n        DH_free(dh_clnt);\n    }\n#endif\n\n#ifndef OPENSSL_NO_EC\n    else if (alg_k & (SSL_kECDHE | SSL_kECDHr | SSL_kECDHe | SSL_kECDHEPSK)) {\n\n        if (s->s3->peer_tmp != NULL) {\n            skey = s->s3->peer_tmp;\n        } else {\n            /* Get the Server Public Key from Cert */\n            skey = X509_get0_pubkey(s->session->peer);\n            if ((skey == NULL)\n                || (skey->type != EVP_PKEY_EC)\n                || (skey->pkey.ec == NULL)) {\n                SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                       ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n        }\n\n        ckey = ssl_generate_pkey(skey, NID_undef);\n\n        if (ssl_derive(s, ckey, skey) == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EVP_LIB);\n            goto err;\n        }\n\n        /* Generate encoding of client key */\n        encoded_pt_len = EC_KEY_key2buf(EVP_PKEY_get0_EC_KEY(ckey),\n                                        POINT_CONVERSION_UNCOMPRESSED,\n                                        &encodedPoint, NULL);\n\n        if (encoded_pt_len == 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_EC_LIB);\n            goto err;\n        }\n\n        EVP_PKEY_free(ckey);\n        ckey = NULL;\n\n        n = encoded_pt_len;\n\n        *p = n;         /* length of encoded point */\n        /* Encoded point will be copied here */\n        p += 1;\n        /* copy the point */\n        memcpy(p, encodedPoint, n);\n        /* increment n to account for length field */\n        n += 1;\n\n        /* Free allocated memory */\n        OPENSSL_free(encodedPoint);\n    }\n#endif                          /* !OPENSSL_NO_EC */\n#ifndef OPENSSL_NO_GOST\n    else if (alg_k & SSL_kGOST) {\n        /* GOST key exchange message creation */\n        EVP_PKEY_CTX *pkey_ctx;\n        X509 *peer_cert;\n        size_t msglen;\n        unsigned int md_len;\n        unsigned char shared_ukm[32], tmp[256];\n        EVP_MD_CTX *ukm_hash;\n        EVP_PKEY *pub_key;\n        int dgst_nid = NID_id_GostR3411_94;\n        if ((s->s3->tmp.new_cipher->algorithm_auth & SSL_aGOST12) != 0)\n            dgst_nid = NID_id_GostR3411_2012_256;\n\n\n        pmslen = 32;\n        pms = OPENSSL_malloc(pmslen);\n        if (pms == NULL)\n            goto memerr;\n\n        /*\n         * Get server sertificate PKEY and create ctx from it\n         */\n        peer_cert = s->session->peer;\n        if (!peer_cert) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER);\n            goto err;\n        }\n\n        pkey_ctx = EVP_PKEY_CTX_new(pub_key =\n                                    X509_get_pubkey(peer_cert), NULL);\n        if (pkey_ctx == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        /*\n         * If we have send a certificate, and certificate key\n         * parameters match those of server certificate, use\n         * certificate key for key exchange\n         */\n\n        /* Otherwise, generate ephemeral key pair */\n\n        if (pkey_ctx == NULL\n                || EVP_PKEY_encrypt_init(pkey_ctx) <= 0\n                /* Generate session key */\n                || RAND_bytes(pms, pmslen) <= 0) {\n            EVP_PKEY_CTX_free(pkey_ctx);\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        };\n        /*\n         * If we have client certificate, use its secret as peer key\n         */\n        if (s->s3->tmp.cert_req && s->cert->key->privatekey) {\n            if (EVP_PKEY_derive_set_peer\n                (pkey_ctx, s->cert->key->privatekey) <= 0) {\n                /*\n                 * If there was an error - just ignore it. Ephemeral key\n                 * * would be used\n                 */\n                ERR_clear_error();\n            }\n        }\n        /*\n         * Compute shared IV and store it in algorithm-specific context\n         * data\n         */\n        ukm_hash = EVP_MD_CTX_new();\n        if (EVP_DigestInit(ukm_hash,\n                           EVP_get_digestbynid(dgst_nid)) <= 0\n                || EVP_DigestUpdate(ukm_hash, s->s3->client_random,\n                                    SSL3_RANDOM_SIZE) <= 0\n                || EVP_DigestUpdate(ukm_hash, s->s3->server_random,\n                                    SSL3_RANDOM_SIZE) <= 0\n                || EVP_DigestFinal_ex(ukm_hash, shared_ukm, &md_len) <= 0) {\n            EVP_MD_CTX_free(ukm_hash);\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        EVP_MD_CTX_free(ukm_hash);\n        if (EVP_PKEY_CTX_ctrl\n            (pkey_ctx, -1, EVP_PKEY_OP_ENCRYPT, EVP_PKEY_CTRL_SET_IV, 8,\n             shared_ukm) < 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_LIBRARY_BUG);\n            goto err;\n        }\n        /* Make GOST keytransport blob message */\n        /*\n         * Encapsulate it into sequence\n         */\n        *(p++) = V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED;\n        msglen = 255;\n        if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   SSL_R_LIBRARY_BUG);\n            goto err;\n        }\n        if (msglen >= 0x80) {\n            *(p++) = 0x81;\n            *(p++) = msglen & 0xff;\n            n = msglen + 3;\n        } else {\n            *(p++) = msglen & 0xff;\n            n = msglen + 2;\n        }\n        memcpy(p, tmp, msglen);\n        /* Check if pubkey from client certificate was used */\n        if (EVP_PKEY_CTX_ctrl\n            (pkey_ctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 2, NULL) > 0) {\n            /* Set flag \"skip certificate verify\" */\n            s->s3->flags |= TLS1_FLAGS_SKIP_CERT_VERIFY;\n        }\n        EVP_PKEY_CTX_free(pkey_ctx);\n        EVP_PKEY_free(pub_key);\n\n    }\n#endif\n#ifndef OPENSSL_NO_SRP\n    else if (alg_k & SSL_kSRP) {\n        if (s->srp_ctx.A != NULL) {\n            /* send off the data */\n            n = BN_num_bytes(s->srp_ctx.A);\n            s2n(n, p);\n            BN_bn2bin(s->srp_ctx.A, p);\n            n += 2;\n        } else {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        OPENSSL_free(s->session->srp_username);\n        s->session->srp_username = OPENSSL_strdup(s->srp_ctx.login);\n        if (s->session->srp_username == NULL) {\n            SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE,\n                   ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n#endif\n    else {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n#ifndef OPENSSL_NO_PSK\n    n += pskhdrlen;\n#endif\n\n    if (!ssl_set_handshake_header(s, SSL3_MT_CLIENT_KEY_EXCHANGE, n)) {\n        ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n        SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (pms != NULL) {\n        s->s3->tmp.pms = pms;\n        s->s3->tmp.pmslen = pmslen;\n    }\n\n    return 1;\n memerr:\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);\n    SSLerr(SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE, ERR_R_MALLOC_FAILURE);\n err:\n    OPENSSL_clear_free(pms, pmslen);\n    s->s3->tmp.pms = NULL;\n#ifndef OPENSSL_NO_EC\n    OPENSSL_free(encodedPoint);\n    EVP_PKEY_free(ckey);\n#endif\n#ifndef OPENSSL_NO_PSK\n    OPENSSL_clear_free(s->s3->tmp.psk, s->s3->tmp.psklen);\n    s->s3->tmp.psk = NULL;\n#endif\n    ossl_statem_set_error(s);\n    return 0;\n}", "before_change_lines": [61, 78, 428], "raw_before_change_lines": [59, 61, 70, 78, 428], "after_change_lines": [60, 76, 426], "raw_after_change_lines": [60, 76, 426], "bug_lines": [59, 61, 70, 78, 428], "added": [false, false, false, false, false], "idx": 434}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12717----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_565d73813b30a95858653b1732dab431ac777f4c_1.json----evp_signature_from_dispatch", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_565d73813b30a95858653b1732dab431ac777f4c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_565d73813b30a95858653b1732dab431ac777f4c_1.json", "function_name": "evp_signature_from_dispatch", "vul_func_code": "static void *evp_signature_from_dispatch(const char *name,\n                                         const OSSL_DISPATCH *fns,\n                                         OSSL_PROVIDER *prov,\n                                         void *vkeymgmt_data)\n{\n    /*\n     * Signature functions cannot work without a key, and key management\n     * from the same provider to manage its keys.  We therefore fetch\n     * a key management method using the same algorithm and properties\n     * and pass that down to evp_generic_fetch to be passed on to our\n     * evp_signature_from_dispatch, which will attach the key management\n     * method to the newly created key exchange method as long as the\n     * provider matches.\n     */\n    struct keymgmt_data_st *keymgmt_data = vkeymgmt_data;\n    EVP_KEYMGMT *keymgmt = EVP_KEYMGMT_fetch(keymgmt_data->ctx, name,\n                                             keymgmt_data->properties);\n    EVP_SIGNATURE *signature = NULL;\n    int ctxfncnt = 0, signfncnt = 0, verifyfncnt = 0, verifyrecfncnt = 0;\n    int gparamfncnt = 0, sparamfncnt = 0;\n\n    if (keymgmt == NULL || EVP_KEYMGMT_provider(keymgmt) != prov) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEYMGMT_AVAILABLE);\n        goto err;\n    }\n\n    if ((signature = evp_signature_new(prov)) == NULL\n        || (signature->name = OPENSSL_strdup(name)) == NULL) {\n        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    signature->keymgmt = keymgmt;\n    keymgmt = NULL;              /* avoid double free on failure below */\n\n    for (; fns->function_id != 0; fns++) {\n        switch (fns->function_id) {\n        case OSSL_FUNC_SIGNATURE_NEWCTX:\n            if (signature->newctx != NULL)\n                break;\n            signature->newctx = OSSL_get_OP_signature_newctx(fns);\n            ctxfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SIGN_INIT:\n            if (signature->sign_init != NULL)\n                break;\n            signature->sign_init = OSSL_get_OP_signature_sign_init(fns);\n            signfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SIGN:\n            if (signature->sign != NULL)\n                break;\n            signature->sign = OSSL_get_OP_signature_sign(fns);\n            signfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY_INIT:\n            if (signature->verify_init != NULL)\n                break;\n            signature->verify_init = OSSL_get_OP_signature_verify_init(fns);\n            verifyfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY:\n            if (signature->verify != NULL)\n                break;\n            signature->verify = OSSL_get_OP_signature_verify(fns);\n            verifyfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT:\n            if (signature->verify_recover_init != NULL)\n                break;\n            signature->verify_recover_init\n                = OSSL_get_OP_signature_verify_recover_init(fns);\n            verifyrecfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER:\n            if (signature->verify_recover != NULL)\n                break;\n            signature->verify_recover\n                = OSSL_get_OP_signature_verify_recover(fns);\n            verifyrecfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_FREECTX:\n            if (signature->freectx != NULL)\n                break;\n            signature->freectx = OSSL_get_OP_signature_freectx(fns);\n            ctxfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_DUPCTX:\n            if (signature->dupctx != NULL)\n                break;\n            signature->dupctx = OSSL_get_OP_signature_dupctx(fns);\n            break;\n        case OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS:\n            if (signature->get_ctx_params != NULL)\n                break;\n            signature->get_ctx_params\n                = OSSL_get_OP_signature_get_ctx_params(fns);\n            gparamfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS:\n            if (signature->gettable_ctx_params != NULL)\n                break;\n            signature->gettable_ctx_params\n                = OSSL_get_OP_signature_gettable_ctx_params(fns);\n            gparamfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS:\n            if (signature->set_ctx_params != NULL)\n                break;\n            signature->set_ctx_params\n                = OSSL_get_OP_signature_set_ctx_params(fns);\n            sparamfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS:\n            if (signature->settable_ctx_params != NULL)\n                break;\n            signature->settable_ctx_params\n                = OSSL_get_OP_signature_settable_ctx_params(fns);\n            sparamfncnt++;\n            break;\n        }\n    }\n    if (ctxfncnt != 2\n        || (signfncnt != 2 && verifyfncnt != 2 && verifyrecfncnt != 2)\n        || (gparamfncnt != 0 && gparamfncnt != 2)\n        || (sparamfncnt != 0 && sparamfncnt != 2)) {\n        /*\n         * In order to be a consistent set of functions we must have at least\n         * a set of context functions (newctx and freectx) as well as a pair of\n         * \"signature\" functions: (sign_init, sign) or (verify_init verify) or\n         * (verify_recover_init, verify_recover). set_ctx_params and\n         * settable_ctx_params are optional, but if one of them is present then\n         * the other one must also be present. The same applies to\n         * get_ctx_params and gettable_ctx_params. The dupctx function is\n         * optional.\n         */\n        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);\n        goto err;\n    }\n\n    return signature;\n err:\n    EVP_SIGNATURE_free(signature);\n    EVP_KEYMGMT_free(keymgmt);\n    return NULL;\n}", "patch_func_code": "static void *evp_signature_from_dispatch(int name_id,\n                                         const OSSL_DISPATCH *fns,\n                                         OSSL_PROVIDER *prov,\n                                         void *vkeymgmt_data)\n{\n    /*\n     * Signature functions cannot work without a key, and key management\n     * from the same provider to manage its keys.  We therefore fetch\n     * a key management method using the same algorithm and properties\n     * and pass that down to evp_generic_fetch to be passed on to our\n     * evp_signature_from_dispatch, which will attach the key management\n     * method to the newly created key exchange method as long as the\n     * provider matches.\n     */\n    struct keymgmt_data_st *keymgmt_data = vkeymgmt_data;\n    EVP_KEYMGMT *keymgmt =\n        evp_keymgmt_fetch_by_number(keymgmt_data->ctx, name_id,\n                                    keymgmt_data->properties);\n    EVP_SIGNATURE *signature = NULL;\n    int ctxfncnt = 0, signfncnt = 0, verifyfncnt = 0, verifyrecfncnt = 0;\n    int gparamfncnt = 0, sparamfncnt = 0;\n\n    if (keymgmt == NULL || EVP_KEYMGMT_provider(keymgmt) != prov) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_NO_KEYMGMT_AVAILABLE);\n        goto err;\n    }\n\n    if ((signature = evp_signature_new(prov)) == NULL) {\n        ERR_raise(ERR_LIB_EVP, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    signature->name_id = name_id;\n    signature->keymgmt = keymgmt;\n    keymgmt = NULL;              /* avoid double free on failure below */\n\n    for (; fns->function_id != 0; fns++) {\n        switch (fns->function_id) {\n        case OSSL_FUNC_SIGNATURE_NEWCTX:\n            if (signature->newctx != NULL)\n                break;\n            signature->newctx = OSSL_get_OP_signature_newctx(fns);\n            ctxfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SIGN_INIT:\n            if (signature->sign_init != NULL)\n                break;\n            signature->sign_init = OSSL_get_OP_signature_sign_init(fns);\n            signfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SIGN:\n            if (signature->sign != NULL)\n                break;\n            signature->sign = OSSL_get_OP_signature_sign(fns);\n            signfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY_INIT:\n            if (signature->verify_init != NULL)\n                break;\n            signature->verify_init = OSSL_get_OP_signature_verify_init(fns);\n            verifyfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY:\n            if (signature->verify != NULL)\n                break;\n            signature->verify = OSSL_get_OP_signature_verify(fns);\n            verifyfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT:\n            if (signature->verify_recover_init != NULL)\n                break;\n            signature->verify_recover_init\n                = OSSL_get_OP_signature_verify_recover_init(fns);\n            verifyrecfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_VERIFY_RECOVER:\n            if (signature->verify_recover != NULL)\n                break;\n            signature->verify_recover\n                = OSSL_get_OP_signature_verify_recover(fns);\n            verifyrecfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_FREECTX:\n            if (signature->freectx != NULL)\n                break;\n            signature->freectx = OSSL_get_OP_signature_freectx(fns);\n            ctxfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_DUPCTX:\n            if (signature->dupctx != NULL)\n                break;\n            signature->dupctx = OSSL_get_OP_signature_dupctx(fns);\n            break;\n        case OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS:\n            if (signature->get_ctx_params != NULL)\n                break;\n            signature->get_ctx_params\n                = OSSL_get_OP_signature_get_ctx_params(fns);\n            gparamfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS:\n            if (signature->gettable_ctx_params != NULL)\n                break;\n            signature->gettable_ctx_params\n                = OSSL_get_OP_signature_gettable_ctx_params(fns);\n            gparamfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS:\n            if (signature->set_ctx_params != NULL)\n                break;\n            signature->set_ctx_params\n                = OSSL_get_OP_signature_set_ctx_params(fns);\n            sparamfncnt++;\n            break;\n        case OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS:\n            if (signature->settable_ctx_params != NULL)\n                break;\n            signature->settable_ctx_params\n                = OSSL_get_OP_signature_settable_ctx_params(fns);\n            sparamfncnt++;\n            break;\n        }\n    }\n    if (ctxfncnt != 2\n        || (signfncnt != 2 && verifyfncnt != 2 && verifyrecfncnt != 2)\n        || (gparamfncnt != 0 && gparamfncnt != 2)\n        || (sparamfncnt != 0 && sparamfncnt != 2)) {\n        /*\n         * In order to be a consistent set of functions we must have at least\n         * a set of context functions (newctx and freectx) as well as a pair of\n         * \"signature\" functions: (sign_init, sign) or (verify_init verify) or\n         * (verify_recover_init, verify_recover). set_ctx_params and\n         * settable_ctx_params are optional, but if one of them is present then\n         * the other one must also be present. The same applies to\n         * get_ctx_params and gettable_ctx_params. The dupctx function is\n         * optional.\n         */\n        ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_PROVIDER_FUNCTIONS);\n        goto err;\n    }\n\n    return signature;\n err:\n    EVP_SIGNATURE_free(signature);\n    EVP_KEYMGMT_free(keymgmt);\n    return NULL;\n}", "before_change_lines": [1, 16, 17, 27, 28], "raw_before_change_lines": [1, 16, 17, 27, 28], "after_change_lines": [1, 16, 17, 18, 28, 33], "raw_after_change_lines": [1, 16, 17, 18, 28, 33], "bug_lines": [1, 16, 17, 27, 28], "added": [false, false, false, false, false], "idx": 435}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12778----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5883279e43d89c1000a3fe556b256c6bc2eb29be_1.json----EVP_PBE_CipherInit", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_5883279e43d89c1000a3fe556b256c6bc2eb29be_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5883279e43d89c1000a3fe556b256c6bc2eb29be_1.json", "function_name": "EVP_PBE_CipherInit", "vul_func_code": "int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\n                       ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\n{\n    const EVP_CIPHER *cipher;\n    const EVP_MD *md;\n    int cipher_nid, md_nid;\n    EVP_PBE_KEYGEN *keygen;\n\n    if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj),\n                      &cipher_nid, &md_nid, &keygen)) {\n        char obj_tmp[80];\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);\n        if (!pbe_obj)\n            OPENSSL_strlcpy(obj_tmp, \"NULL\", sizeof obj_tmp);\n        else\n            i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj);\n        ERR_add_error_data(2, \"TYPE=\", obj_tmp);\n        return 0;\n    }\n\n    if (!pass)\n        passlen = 0;\n    else if (passlen == -1)\n        passlen = strlen(pass);\n\n    if (cipher_nid == -1)\n        cipher = NULL;\n    else {\n        cipher = EVP_get_cipherbynid(cipher_nid);\n        if (!cipher) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER);\n            return 0;\n        }\n    }\n\n    if (md_nid == -1)\n        md = NULL;\n    else {\n        md = EVP_get_digestbynid(md_nid);\n        if (!md) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST);\n            return 0;\n        }\n    }\n\n    if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) {\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE);\n        return 0;\n    }\n    return 1;\n}", "patch_func_code": "int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,\n                       ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de)\n{\n    const EVP_CIPHER *cipher;\n    const EVP_MD *md;\n    int cipher_nid, md_nid;\n    EVP_PBE_KEYGEN *keygen;\n\n    if (!EVP_PBE_find(EVP_PBE_TYPE_OUTER, OBJ_obj2nid(pbe_obj),\n                      &cipher_nid, &md_nid, &keygen)) {\n        char obj_tmp[80];\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_PBE_ALGORITHM);\n        if (!pbe_obj)\n            strcpy(obj_tmp, \"NULL\");\n        else\n            i2t_ASN1_OBJECT(obj_tmp, sizeof obj_tmp, pbe_obj);\n        ERR_add_error_data(2, \"TYPE=\", obj_tmp);\n        return 0;\n    }\n\n    if (!pass)\n        passlen = 0;\n    else if (passlen == -1)\n        passlen = strlen(pass);\n\n    if (cipher_nid == -1)\n        cipher = NULL;\n    else {\n        cipher = EVP_get_cipherbynid(cipher_nid);\n        if (!cipher) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_CIPHER);\n            return 0;\n        }\n    }\n\n    if (md_nid == -1)\n        md = NULL;\n    else {\n        md = EVP_get_digestbynid(md_nid);\n        if (!md) {\n            EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_UNKNOWN_DIGEST);\n            return 0;\n        }\n    }\n\n    if (!keygen(ctx, pass, passlen, param, cipher, md, en_de)) {\n        EVPerr(EVP_F_EVP_PBE_CIPHERINIT, EVP_R_KEYGEN_FAILURE);\n        return 0;\n    }\n    return 1;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [14], "raw_after_change_lines": [14], "bug_lines": [14], "added": [false], "idx": 436}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "12800----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_591c377bc6fac27ab8ad423bad190e41ce9271ec_1.json----i2v_AUTHORITY_INFO_ACCESS", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_591c377bc6fac27ab8ad423bad190e41ce9271ec_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_591c377bc6fac27ab8ad423bad190e41ce9271ec_1.json", "function_name": "i2v_AUTHORITY_INFO_ACCESS", "vul_func_code": "static STACK_OF(CONF_VALUE) *i2v_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *method,\n\t\t\t\tAUTHORITY_INFO_ACCESS *ainfo,\n\t\t\t\t\t\tSTACK_OF(CONF_VALUE) *ret)\n{\n\tACCESS_DESCRIPTION *desc;\n\tint i;\n\tchar objtmp[80], *ntmp;\n\tCONF_VALUE *vtmp;\n\tfor(i = 0; i < sk_ACCESS_DESCRIPTION_num(ainfo); i++) {\n\t\tdesc = sk_ACCESS_DESCRIPTION_value(ainfo, i);\n\t\tret = i2v_GENERAL_NAME(method, desc->location, ret);\n\t\tif(!ret) break;\n\t\tvtmp = sk_CONF_VALUE_value(ret, i);\n\t\ti2t_ASN1_OBJECT(objtmp, sizeof objtmp, desc->method);\n\t\tntmp = OPENSSL_malloc(strlen(objtmp) + strlen(vtmp->name) + 5);\n\t\tif(!ntmp) {\n\t\t\tX509V3err(X509V3_F_I2V_AUTHORITY_INFO_ACCESS,\n\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcpy(ntmp, objtmp);\n\t\tstrcat(ntmp, \" - \");\n\t\tstrcat(ntmp, vtmp->name);\n\t\tOPENSSL_free(vtmp->name);\n\t\tvtmp->name = ntmp;\n\t\t\n\t}\n\tif(!ret) return sk_CONF_VALUE_new_null();\n\treturn ret;\n}", "patch_func_code": "static STACK_OF(CONF_VALUE) *i2v_AUTHORITY_INFO_ACCESS(X509V3_EXT_METHOD *method,\n\t\t\t\tAUTHORITY_INFO_ACCESS *ainfo,\n\t\t\t\t\t\tSTACK_OF(CONF_VALUE) *ret)\n{\n\tACCESS_DESCRIPTION *desc;\n\tint i,nlen;\n\tchar objtmp[80], *ntmp;\n\tCONF_VALUE *vtmp;\n\tfor(i = 0; i < sk_ACCESS_DESCRIPTION_num(ainfo); i++) {\n\t\tdesc = sk_ACCESS_DESCRIPTION_value(ainfo, i);\n\t\tret = i2v_GENERAL_NAME(method, desc->location, ret);\n\t\tif(!ret) break;\n\t\tvtmp = sk_CONF_VALUE_value(ret, i);\n\t\ti2t_ASN1_OBJECT(objtmp, sizeof objtmp, desc->method);\n\t\tnlen = strlen(objtmp) + strlen(vtmp->name) + 5;\n\t\tntmp = OPENSSL_malloc(nlen);\n\t\tif(!ntmp) {\n\t\t\tX509V3err(X509V3_F_I2V_AUTHORITY_INFO_ACCESS,\n\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn NULL;\n\t\t}\n\t\tBUF_strlcpy(ntmp, objtmp, nlen);\n\t\tBUF_strlcat(ntmp, \" - \", nlen);\n\t\tBUF_strlcat(ntmp, vtmp->name, nlen);\n\t\tOPENSSL_free(vtmp->name);\n\t\tvtmp->name = ntmp;\n\t\t\n\t}\n\tif(!ret) return sk_CONF_VALUE_new_null();\n\treturn ret;\n}", "before_change_lines": [6, 15, 21, 22, 23], "raw_before_change_lines": [6, 15, 21, 22, 23], "after_change_lines": [6, 15, 16, 22, 23, 24], "raw_after_change_lines": [6, 15, 16, 22, 23, 24], "bug_lines": [6, 15, 21, 22, 23], "added": [false, false, false, false, false], "idx": 437}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "12811----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5981f8c59b86c8704bac714a9301d5f1194a0493_1.json----x509_load_serial", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_5981f8c59b86c8704bac714a9301d5f1194a0493_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5981f8c59b86c8704bac714a9301d5f1194a0493_1.json", "function_name": "x509_load_serial", "vul_func_code": "static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile,\n                                      int create)\n{\n    char *buf = NULL, *p;\n    ASN1_INTEGER *bs = NULL;\n    BIGNUM *serial = NULL;\n    size_t len;\n\n    len = ((serialfile == NULL)\n           ? (strlen(CAfile) + strlen(POSTFIX) + 1)\n           : (strlen(serialfile))) + 1;\n    buf = app_malloc(len, \"serial# buffer\");\n    if (serialfile == NULL) {\n        BUF_strlcpy(buf, CAfile, len);\n        for (p = buf; *p; p++)\n            if (*p == '.') {\n                *p = '\\0';\n                break;\n            }\n        BUF_strlcat(buf, POSTFIX, len);\n    } else\n        BUF_strlcpy(buf, serialfile, len);\n\n    serial = load_serial(buf, create, NULL);\n    if (serial == NULL)\n        goto end;\n\n    if (!BN_add_word(serial, 1)) {\n        BIO_printf(bio_err, \"add_word failure\\n\");\n        goto end;\n    }\n\n    if (!save_serial(buf, NULL, serial, &bs))\n        goto end;\n\n end:\n    OPENSSL_free(buf);\n    BN_free(serial);\n    return bs;\n}", "patch_func_code": "static ASN1_INTEGER *x509_load_serial(char *CAfile, char *serialfile,\n                                      int create)\n{\n    char *buf = NULL, *p;\n    ASN1_INTEGER *bs = NULL;\n    BIGNUM *serial = NULL;\n    size_t len;\n\n    len = ((serialfile == NULL)\n           ? (strlen(CAfile) + strlen(POSTFIX) + 1)\n           : (strlen(serialfile))) + 1;\n    buf = app_malloc(len, \"serial# buffer\");\n    if (serialfile == NULL) {\n        OPENSSL_strlcpy(buf, CAfile, len);\n        for (p = buf; *p; p++)\n            if (*p == '.') {\n                *p = '\\0';\n                break;\n            }\n        OPENSSL_strlcat(buf, POSTFIX, len);\n    } else\n        OPENSSL_strlcpy(buf, serialfile, len);\n\n    serial = load_serial(buf, create, NULL);\n    if (serial == NULL)\n        goto end;\n\n    if (!BN_add_word(serial, 1)) {\n        BIO_printf(bio_err, \"add_word failure\\n\");\n        goto end;\n    }\n\n    if (!save_serial(buf, NULL, serial, &bs))\n        goto end;\n\n end:\n    OPENSSL_free(buf);\n    BN_free(serial);\n    return bs;\n}", "before_change_lines": [14, 20, 22], "raw_before_change_lines": [14, 20, 22], "after_change_lines": [14, 20, 22], "raw_after_change_lines": [14, 20, 22], "bug_lines": [14, 20, 22], "added": [false, false, false], "idx": 438}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "12856----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5b678e708b9cf733587dcfed60a861a02befad75_1.json----NAME_CONSTRAINTS_check_CN", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_5b678e708b9cf733587dcfed60a861a02befad75_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_5b678e708b9cf733587dcfed60a861a02befad75_1.json", "function_name": "NAME_CONSTRAINTS_check_CN", "vul_func_code": "int NAME_CONSTRAINTS_check_CN(X509 *x, NAME_CONSTRAINTS *nc)\n{\n    int r, i;\n    GENERAL_NAMES *gens = NULL;\n    X509_NAME *nm;\n    ASN1_STRING stmp;\n    GENERAL_NAME gntmp;\n\n    stmp.flags = 0;\n    stmp.type = V_ASN1_IA5STRING;\n    gntmp.type = GEN_DNS;\n    gntmp.d.dNSName = &stmp;\n\n    gens = X509_get_ext_d2i(x, NID_subject_alt_name, NULL, NULL);\n    if (gens != NULL) {\n        for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\n            GENERAL_NAME *gen = sk_GENERAL_NAME_value(gens, i);\n\n            if (gen->type == GEN_DNS) {\n                GENERAL_NAMES_free(gens);\n                return X509_V_OK;\n            }\n        }\n        GENERAL_NAMES_free(gens);\n    }\n\n    nm = X509_get_subject_name(x);\n\n    /* Process any commonName attributes in subject name */\n\n    for (i = -1;;) {\n        X509_NAME_ENTRY *ne;\n        ASN1_STRING *cn;\n        unsigned char *idval;\n        size_t idlen;\n\n        i = X509_NAME_get_index_by_NID(nm, NID_commonName, i);\n        if (i == -1)\n            break;\n        ne = X509_NAME_get_entry(nm, i);\n        cn = X509_NAME_ENTRY_get_data(ne);\n\n        /* Only process attributes that look like host names */\n        if ((r = cn2dnsid(cn, &idval, &idlen)) != X509_V_OK)\n            return r;\n        if (idlen == 0)\n            continue;\n\n        stmp.length = idlen;\n        stmp.data = idval;\n        r = nc_match(&gntmp, nc);\n        OPENSSL_free(idval);\n        if (r != X509_V_OK)\n            return r;\n    }\n    return X509_V_OK;\n}", "patch_func_code": "int NAME_CONSTRAINTS_check_CN(X509 *x, NAME_CONSTRAINTS *nc)\n{\n    int r, i;\n    X509_NAME *nm = X509_get_subject_name(x);\n    ASN1_STRING stmp;\n    GENERAL_NAME gntmp;\n\n    stmp.flags = 0;\n    stmp.type = V_ASN1_IA5STRING;\n    gntmp.type = GEN_DNS;\n    gntmp.d.dNSName = &stmp;\n\n    /* Process any commonName attributes in subject name */\n\n    for (i = -1;;) {\n        X509_NAME_ENTRY *ne;\n        ASN1_STRING *cn;\n        unsigned char *idval;\n        size_t idlen;\n\n        i = X509_NAME_get_index_by_NID(nm, NID_commonName, i);\n        if (i == -1)\n            break;\n        ne = X509_NAME_get_entry(nm, i);\n        cn = X509_NAME_ENTRY_get_data(ne);\n\n        /* Only process attributes that look like host names */\n        if ((r = cn2dnsid(cn, &idval, &idlen)) != X509_V_OK)\n            return r;\n        if (idlen == 0)\n            continue;\n\n        stmp.length = idlen;\n        stmp.data = idval;\n        r = nc_match(&gntmp, nc);\n        OPENSSL_free(idval);\n        if (r != X509_V_OK)\n            return r;\n    }\n    return X509_V_OK;\n}", "before_change_lines": [4, 5, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 27], "raw_before_change_lines": [4, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], "after_change_lines": [4], "raw_after_change_lines": [4], "bug_lines": [4, 5, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 439}
{"project": "openssl", "vul_type": "MEMORY_LEAK", "filepath_func": "13046----MEMORY_LEAK----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_61d82097e5b4e03e62f5b19530938285dbb68d19_1.json----BN_MONT_CTX_init", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_61d82097e5b4e03e62f5b19530938285dbb68d19_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_61d82097e5b4e03e62f5b19530938285dbb68d19_1.json", "function_name": "BN_MONT_CTX_init", "vul_func_code": "void BN_MONT_CTX_init(BN_MONT_CTX *ctx)\n{\n    ctx->ri = 0;\n    bn_init(&(ctx->RR));\n    bn_init(&(ctx->N));\n    bn_init(&(ctx->Ni));\n    ctx->n0[0] = ctx->n0[1] = 0;\n    ctx->flags = 0;\n}", "patch_func_code": "void BN_MONT_CTX_init(BN_MONT_CTX *ctx)\n{\n    ctx->ri = 0;\n    bn_init(&ctx->RR);\n    bn_init(&ctx->N);\n    bn_init(&ctx->Ni);\n    ctx->n0[0] = ctx->n0[1] = 0;\n    ctx->flags = 0;\n}", "before_change_lines": [4, 5, 6], "raw_before_change_lines": [4, 5, 6], "after_change_lines": [4, 5, 6], "raw_after_change_lines": [4, 5, 6], "bug_lines": [4, 5, 6], "added": [false, false, false], "idx": 440}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "13061----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6258fdeffa51308853b3eb5ab70f5bedc8ad6304_1.json----tls1_cbc_remove_padding", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_6258fdeffa51308853b3eb5ab70f5bedc8ad6304_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6258fdeffa51308853b3eb5ab70f5bedc8ad6304_1.json", "function_name": "tls1_cbc_remove_padding", "vul_func_code": "int tls1_cbc_remove_padding(const SSL* s,\n\t\t\t    SSL3_RECORD *rec,\n\t\t\t    unsigned block_size,\n\t\t\t    unsigned mac_size)\n\t{\n\tunsigned padding_length, good, to_check, i;\n\tconst char has_explicit_iv =\n\t\ts->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;\n\tconst unsigned overhead = 1 /* padding length byte */ +\n\t\t\t\t  mac_size +\n\t\t\t\t  (has_explicit_iv ? block_size : 0);\n\n\t/* These lengths are all public so we can test them in non-constant\n\t * time. */\n\tif (overhead > rec->length)\n\t\treturn 0;\n\n\tpadding_length = rec->data[rec->length-1];\n\n\t/* NB: if compression is in operation the first packet may not be of\n\t * even length so the padding bug check cannot be performed. This bug\n\t * workaround has been around since SSLeay so hopefully it is either\n\t * fixed now or no buggy implementation supports compression [steve]\n\t */\n\tif ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand)\n\t\t{\n\t\t/* First packet is even in size, so check */\n\t\tif ((memcmp(s->s3->read_sequence, \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) &&\n\t\t    !(padding_length & 1))\n\t\t\t{\n\t\t\ts->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\n\t\t\t}\n\t\tif ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) &&\n\t\t    padding_length > 0)\n\t\t\t{\n\t\t\tpadding_length--;\n\t\t\t}\n\t\t}\n\n\tgood = constant_time_ge(rec->length, overhead+padding_length);\n\t/* The padding consists of a length byte at the end of the record and\n\t * then that many bytes of padding, all with the same value as the\n\t * length byte. Thus, with the length byte included, there are i+1\n\t * bytes of padding.\n\t *\n\t * We can't check just |padding_length+1| bytes because that leaks\n\t * decrypted information. Therefore we always have to check the maximum\n\t * amount of padding possible. (Again, the length of the record is\n\t * public information so we can use it.) */\n\tto_check = 255; /* maximum amount of padding. */\n\tif (to_check > rec->length-1)\n\t\tto_check = rec->length-1;\n\n\tfor (i = 0; i < to_check; i++)\n\t\t{\n\t\tunsigned char mask = constant_time_ge(padding_length, i);\n\t\tunsigned char b = rec->data[rec->length-1-i];\n\t\t/* The final |padding_length+1| bytes should all have the value\n\t\t * |padding_length|. Therefore the XOR should be zero. */\n\t\tgood &= ~(mask&(padding_length ^ b));\n\t\t}\n\n\t/* If any of the final |padding_length+1| bytes had the wrong value,\n\t * one or more of the lower eight bits of |good| will be cleared. We\n\t * AND the bottom 8 bits together and duplicate the result to all the\n\t * bits. */\n\tgood &= good >> 4;\n\tgood &= good >> 2;\n\tgood &= good >> 1;\n\tgood <<= sizeof(good)*8-1;\n\tgood = DUPLICATE_MSB_TO_ALL(good);\n\n\tpadding_length = good & (padding_length+1);\n\trec->length -= padding_length;\n\trec->type |= padding_length<<8;\t/* kludge: pass padding length */\n\n\t/* We can always safely skip the explicit IV. We check at the beginning\n\t * of this function that the record has at least enough space for the\n\t * IV, MAC and padding length byte. (These can be checked in\n\t * non-constant time because it's all public information.) So, if the\n\t * padding was invalid, then we didn't change |rec->length| and this is\n\t * safe. If the padding was valid then we know that we have at least\n\t * overhead+padding_length bytes of space and so this is still safe\n\t * because overhead accounts for the explicit IV. */\n\tif (has_explicit_iv)\n\t\t{\n\t\trec->data += block_size;\n\t\trec->input += block_size;\n\t\trec->length -= block_size;\n\t\t}\n\n\treturn (int)((good & 1) | (~good & -1));\n\t}", "patch_func_code": "int tls1_cbc_remove_padding(const SSL* s,\n\t\t\t    SSL3_RECORD *rec,\n\t\t\t    unsigned block_size,\n\t\t\t    unsigned mac_size)\n\t{\n\tunsigned padding_length, good, to_check, i;\n\tconst char has_explicit_iv =\n\t\ts->version >= TLS1_1_VERSION || s->version == DTLS1_VERSION;\n\tconst unsigned overhead = 1 /* padding length byte */ +\n\t\t\t\t  mac_size +\n\t\t\t\t  (has_explicit_iv ? block_size : 0);\n\n\t/* These lengths are all public so we can test them in non-constant\n\t * time. */\n\tif (overhead > rec->length)\n\t\treturn 0;\n\n\t/* We can always safely skip the explicit IV. We check at the beginning\n\t * of this function that the record has at least enough space for the\n\t * IV, MAC and padding length byte. (These can be checked in\n\t * non-constant time because it's all public information.) So, if the\n\t * padding was invalid, then we didn't change |rec->length| and this is\n\t * safe. If the padding was valid then we know that we have at least\n\t * overhead+padding_length bytes of space and so this is still safe\n\t * because overhead accounts for the explicit IV. */\n\tif (has_explicit_iv)\n\t\t{\n\t\trec->data += block_size;\n\t\trec->input += block_size;\n\t\trec->length -= block_size;\n\t\t}\n\n\tpadding_length = rec->data[rec->length-1];\n\n\t/* NB: if compression is in operation the first packet may not be of\n\t * even length so the padding bug check cannot be performed. This bug\n\t * workaround has been around since SSLeay so hopefully it is either\n\t * fixed now or no buggy implementation supports compression [steve]\n\t */\n\tif ( (s->options&SSL_OP_TLS_BLOCK_PADDING_BUG) && !s->expand)\n\t\t{\n\t\t/* First packet is even in size, so check */\n\t\tif ((memcmp(s->s3->read_sequence, \"\\0\\0\\0\\0\\0\\0\\0\\0\",8) == 0) &&\n\t\t    !(padding_length & 1))\n\t\t\t{\n\t\t\ts->s3->flags|=TLS1_FLAGS_TLS_PADDING_BUG;\n\t\t\t}\n\t\tif ((s->s3->flags & TLS1_FLAGS_TLS_PADDING_BUG) &&\n\t\t    padding_length > 0)\n\t\t\t{\n\t\t\tpadding_length--;\n\t\t\t}\n\t\t}\n\n\tif (EVP_CIPHER_flags(s->enc_read_ctx->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)\n\t\t{\n\t\t/* padding is already verified */\n\t\trec->length -= padding_length;\n\t\treturn 1;\n\t\t}\n\n\tgood = constant_time_ge(rec->length, overhead+padding_length);\n\t/* The padding consists of a length byte at the end of the record and\n\t * then that many bytes of padding, all with the same value as the\n\t * length byte. Thus, with the length byte included, there are i+1\n\t * bytes of padding.\n\t *\n\t * We can't check just |padding_length+1| bytes because that leaks\n\t * decrypted information. Therefore we always have to check the maximum\n\t * amount of padding possible. (Again, the length of the record is\n\t * public information so we can use it.) */\n\tto_check = 255; /* maximum amount of padding. */\n\tif (to_check > rec->length-1)\n\t\tto_check = rec->length-1;\n\n\tfor (i = 0; i < to_check; i++)\n\t\t{\n\t\tunsigned char mask = constant_time_ge(padding_length, i);\n\t\tunsigned char b = rec->data[rec->length-1-i];\n\t\t/* The final |padding_length+1| bytes should all have the value\n\t\t * |padding_length|. Therefore the XOR should be zero. */\n\t\tgood &= ~(mask&(padding_length ^ b));\n\t\t}\n\n\t/* If any of the final |padding_length+1| bytes had the wrong value,\n\t * one or more of the lower eight bits of |good| will be cleared. We\n\t * AND the bottom 8 bits together and duplicate the result to all the\n\t * bits. */\n\tgood &= good >> 4;\n\tgood &= good >> 2;\n\tgood &= good >> 1;\n\tgood <<= sizeof(good)*8-1;\n\tgood = DUPLICATE_MSB_TO_ALL(good);\n\n\tpadding_length = good & (padding_length+1);\n\trec->length -= padding_length;\n\trec->type |= padding_length<<8;\t/* kludge: pass padding length */\n\n\treturn (int)((good & 1) | (~good & -1));\n\t}", "before_change_lines": [78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90], "raw_before_change_lines": [77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91], "after_change_lines": [19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 55, 56, 58, 59, 60], "raw_after_change_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 55, 56, 57, 58, 59, 60, 61], "bug_lines": [77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 441}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "13072----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_62cb3e6a1fa1ed3876644aa2671ff0e218de1060_1.json----do_handshake_internal", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_62cb3e6a1fa1ed3876644aa2671ff0e218de1060_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_62cb3e6a1fa1ed3876644aa2671ff0e218de1060_1.json", "function_name": "do_handshake_internal", "vul_func_code": "static HANDSHAKE_RESULT *do_handshake_internal(\n    SSL_CTX *server_ctx, SSL_CTX *server2_ctx, SSL_CTX *client_ctx,\n    const SSL_TEST_CTX *test_ctx, SSL_SESSION *session_in,\n    SSL_SESSION **session_out)\n{\n    SSL *server, *client;\n    BIO *client_to_server, *server_to_client;\n    HANDSHAKE_EX_DATA server_ex_data, client_ex_data;\n    CTX_DATA client_ctx_data, server_ctx_data, server2_ctx_data;\n    HANDSHAKE_RESULT *ret = HANDSHAKE_RESULT_new();\n    int client_turn = 1, shutdown = 0;\n    peer_status_t client_status = PEER_RETRY, server_status = PEER_RETRY;\n    handshake_status_t status = HANDSHAKE_RETRY;\n    unsigned char* tick = NULL;\n    size_t tick_len = 0;\n    SSL_SESSION* sess = NULL;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    const unsigned char *proto = NULL;\n    /* API dictates unsigned int rather than size_t. */\n    unsigned int proto_len = 0;\n#endif\n\n    memset(&server_ctx_data, 0, sizeof(server_ctx_data));\n    memset(&server2_ctx_data, 0, sizeof(server2_ctx_data));\n    memset(&client_ctx_data, 0, sizeof(client_ctx_data));\n\n    configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, test_ctx,\n                            &server_ctx_data, &server2_ctx_data, &client_ctx_data);\n\n    server = SSL_new(server_ctx);\n    client = SSL_new(client_ctx);\n    OPENSSL_assert(server != NULL && client != NULL);\n\n    configure_handshake_ssl(server, client, test_ctx);\n    if (session_in != NULL) {\n        /* In case we're testing resumption without tickets. */\n        OPENSSL_assert(SSL_CTX_add_session(server_ctx, session_in));\n        OPENSSL_assert(SSL_set_session(client, session_in));\n    }\n\n    memset(&server_ex_data, 0, sizeof(server_ex_data));\n    memset(&client_ex_data, 0, sizeof(client_ex_data));\n\n    ret->result = SSL_TEST_INTERNAL_ERROR;\n\n    client_to_server = BIO_new(BIO_s_mem());\n    server_to_client = BIO_new(BIO_s_mem());\n\n    OPENSSL_assert(client_to_server != NULL && server_to_client != NULL);\n\n    /* Non-blocking bio. */\n    BIO_set_nbio(client_to_server, 1);\n    BIO_set_nbio(server_to_client, 1);\n\n    SSL_set_connect_state(client);\n    SSL_set_accept_state(server);\n\n    /* The bios are now owned by the SSL object. */\n    SSL_set_bio(client, server_to_client, client_to_server);\n    OPENSSL_assert(BIO_up_ref(server_to_client) > 0);\n    OPENSSL_assert(BIO_up_ref(client_to_server) > 0);\n    SSL_set_bio(server, client_to_server, server_to_client);\n\n    ex_data_idx = SSL_get_ex_new_index(0, \"ex data\", NULL, NULL, NULL);\n    OPENSSL_assert(ex_data_idx >= 0);\n\n    OPENSSL_assert(SSL_set_ex_data(server, ex_data_idx,\n                                   &server_ex_data) == 1);\n    OPENSSL_assert(SSL_set_ex_data(client, ex_data_idx,\n                                   &client_ex_data) == 1);\n\n    SSL_set_info_callback(server, &info_cb);\n    SSL_set_info_callback(client, &info_cb);\n\n    /*\n     * Half-duplex handshake loop.\n     * Client and server speak to each other synchronously in the same process.\n     * We use non-blocking BIOs, so whenever one peer blocks for read, it\n     * returns PEER_RETRY to indicate that it's the other peer's turn to write.\n     * The handshake succeeds once both peers have succeeded. If one peer\n     * errors out, we also let the other peer retry (and presumably fail).\n     */\n    for(;;) {\n        if (client_turn) {\n            client_status = do_handshake_step(client, shutdown);\n            status = handshake_status(client_status, server_status,\n                                      1 /* client went last */);\n        } else {\n            server_status = do_handshake_step(server, shutdown);\n            status = handshake_status(server_status, client_status,\n                                      0 /* server went last */);\n        }\n\n        switch (status) {\n        case HANDSHAKE_SUCCESS:\n            if (shutdown) {\n                ret->result = SSL_TEST_SUCCESS;\n                goto err;\n            } else {\n                client_status = server_status = PEER_RETRY;\n                shutdown = 1;\n                client_turn = 1;\n                break;\n            }\n        case CLIENT_ERROR:\n            ret->result = SSL_TEST_CLIENT_FAIL;\n            goto err;\n        case SERVER_ERROR:\n            ret->result = SSL_TEST_SERVER_FAIL;\n            goto err;\n        case INTERNAL_ERROR:\n            ret->result = SSL_TEST_INTERNAL_ERROR;\n            goto err;\n        case HANDSHAKE_RETRY:\n            /* Continue. */\n            client_turn ^= 1;\n            break;\n        }\n    }\n err:\n    ret->server_alert_sent = server_ex_data.alert_sent;\n    ret->server_alert_received = client_ex_data.alert_received;\n    ret->client_alert_sent = client_ex_data.alert_sent;\n    ret->client_alert_received = server_ex_data.alert_received;\n    ret->server_protocol = SSL_version(server);\n    ret->client_protocol = SSL_version(client);\n    ret->servername = server_ex_data.servername;\n    if ((sess = SSL_get0_session(client)) != NULL)\n        SSL_SESSION_get0_ticket(sess, &tick, &tick_len);\n    if (tick == NULL || tick_len == 0)\n        ret->session_ticket = SSL_TEST_SESSION_TICKET_NO;\n    else\n        ret->session_ticket = SSL_TEST_SESSION_TICKET_YES;\n    ret->session_ticket_do_not_call = server_ex_data.session_ticket_do_not_call;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    SSL_get0_next_proto_negotiated(client, &proto, &proto_len);\n    ret->client_npn_negotiated = dup_str(proto, proto_len);\n\n    SSL_get0_next_proto_negotiated(server, &proto, &proto_len);\n    ret->server_npn_negotiated = dup_str(proto, proto_len);\n\n    SSL_get0_alpn_selected(client, &proto, &proto_len);\n    ret->client_alpn_negotiated = dup_str(proto, proto_len);\n\n    SSL_get0_alpn_selected(server, &proto, &proto_len);\n    ret->server_alpn_negotiated = dup_str(proto, proto_len);\n#endif\n\n    ret->client_resumed = SSL_session_reused(client);\n    ret->server_resumed = SSL_session_reused(server);\n\n    if (session_out != NULL)\n        *session_out = SSL_get1_session(client);\n\n    ctx_data_free_data(&server_ctx_data);\n    ctx_data_free_data(&server2_ctx_data);\n    ctx_data_free_data(&client_ctx_data);\n\n    SSL_free(server);\n    SSL_free(client);\n    return ret;\n}", "patch_func_code": "static HANDSHAKE_RESULT *do_handshake_internal(\n    SSL_CTX *server_ctx, SSL_CTX *server2_ctx, SSL_CTX *client_ctx,\n    const SSL_TEST_EXTRA_CONF *extra, SSL_SESSION *session_in,\n    SSL_SESSION **session_out)\n{\n    SSL *server, *client;\n    BIO *client_to_server, *server_to_client;\n    HANDSHAKE_EX_DATA server_ex_data, client_ex_data;\n    CTX_DATA client_ctx_data, server_ctx_data, server2_ctx_data;\n    HANDSHAKE_RESULT *ret = HANDSHAKE_RESULT_new();\n    int client_turn = 1, shutdown = 0;\n    peer_status_t client_status = PEER_RETRY, server_status = PEER_RETRY;\n    handshake_status_t status = HANDSHAKE_RETRY;\n    unsigned char* tick = NULL;\n    size_t tick_len = 0;\n    SSL_SESSION* sess = NULL;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    const unsigned char *proto = NULL;\n    /* API dictates unsigned int rather than size_t. */\n    unsigned int proto_len = 0;\n#endif\n\n    memset(&server_ctx_data, 0, sizeof(server_ctx_data));\n    memset(&server2_ctx_data, 0, sizeof(server2_ctx_data));\n    memset(&client_ctx_data, 0, sizeof(client_ctx_data));\n\n    configure_handshake_ctx(server_ctx, server2_ctx, client_ctx, extra,\n                            &server_ctx_data, &server2_ctx_data, &client_ctx_data);\n\n    server = SSL_new(server_ctx);\n    client = SSL_new(client_ctx);\n    OPENSSL_assert(server != NULL && client != NULL);\n\n    configure_handshake_ssl(server, client, extra);\n    if (session_in != NULL) {\n        /* In case we're testing resumption without tickets. */\n        OPENSSL_assert(SSL_CTX_add_session(server_ctx, session_in));\n        OPENSSL_assert(SSL_set_session(client, session_in));\n    }\n\n    memset(&server_ex_data, 0, sizeof(server_ex_data));\n    memset(&client_ex_data, 0, sizeof(client_ex_data));\n\n    ret->result = SSL_TEST_INTERNAL_ERROR;\n\n    client_to_server = BIO_new(BIO_s_mem());\n    server_to_client = BIO_new(BIO_s_mem());\n\n    OPENSSL_assert(client_to_server != NULL && server_to_client != NULL);\n\n    /* Non-blocking bio. */\n    BIO_set_nbio(client_to_server, 1);\n    BIO_set_nbio(server_to_client, 1);\n\n    SSL_set_connect_state(client);\n    SSL_set_accept_state(server);\n\n    /* The bios are now owned by the SSL object. */\n    SSL_set_bio(client, server_to_client, client_to_server);\n    OPENSSL_assert(BIO_up_ref(server_to_client) > 0);\n    OPENSSL_assert(BIO_up_ref(client_to_server) > 0);\n    SSL_set_bio(server, client_to_server, server_to_client);\n\n    ex_data_idx = SSL_get_ex_new_index(0, \"ex data\", NULL, NULL, NULL);\n    OPENSSL_assert(ex_data_idx >= 0);\n\n    OPENSSL_assert(SSL_set_ex_data(server, ex_data_idx,\n                                   &server_ex_data) == 1);\n    OPENSSL_assert(SSL_set_ex_data(client, ex_data_idx,\n                                   &client_ex_data) == 1);\n\n    SSL_set_info_callback(server, &info_cb);\n    SSL_set_info_callback(client, &info_cb);\n\n    /*\n     * Half-duplex handshake loop.\n     * Client and server speak to each other synchronously in the same process.\n     * We use non-blocking BIOs, so whenever one peer blocks for read, it\n     * returns PEER_RETRY to indicate that it's the other peer's turn to write.\n     * The handshake succeeds once both peers have succeeded. If one peer\n     * errors out, we also let the other peer retry (and presumably fail).\n     */\n    for(;;) {\n        if (client_turn) {\n            client_status = do_handshake_step(client, shutdown);\n            status = handshake_status(client_status, server_status,\n                                      1 /* client went last */);\n        } else {\n            server_status = do_handshake_step(server, shutdown);\n            status = handshake_status(server_status, client_status,\n                                      0 /* server went last */);\n        }\n\n        switch (status) {\n        case HANDSHAKE_SUCCESS:\n            if (shutdown) {\n                ret->result = SSL_TEST_SUCCESS;\n                goto err;\n            } else {\n                client_status = server_status = PEER_RETRY;\n                shutdown = 1;\n                client_turn = 1;\n                break;\n            }\n        case CLIENT_ERROR:\n            ret->result = SSL_TEST_CLIENT_FAIL;\n            goto err;\n        case SERVER_ERROR:\n            ret->result = SSL_TEST_SERVER_FAIL;\n            goto err;\n        case INTERNAL_ERROR:\n            ret->result = SSL_TEST_INTERNAL_ERROR;\n            goto err;\n        case HANDSHAKE_RETRY:\n            /* Continue. */\n            client_turn ^= 1;\n            break;\n        }\n    }\n err:\n    ret->server_alert_sent = server_ex_data.alert_sent;\n    ret->server_alert_received = client_ex_data.alert_received;\n    ret->client_alert_sent = client_ex_data.alert_sent;\n    ret->client_alert_received = server_ex_data.alert_received;\n    ret->server_protocol = SSL_version(server);\n    ret->client_protocol = SSL_version(client);\n    ret->servername = server_ex_data.servername;\n    if ((sess = SSL_get0_session(client)) != NULL)\n        SSL_SESSION_get0_ticket(sess, &tick, &tick_len);\n    if (tick == NULL || tick_len == 0)\n        ret->session_ticket = SSL_TEST_SESSION_TICKET_NO;\n    else\n        ret->session_ticket = SSL_TEST_SESSION_TICKET_YES;\n    ret->session_ticket_do_not_call = server_ex_data.session_ticket_do_not_call;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    SSL_get0_next_proto_negotiated(client, &proto, &proto_len);\n    ret->client_npn_negotiated = dup_str(proto, proto_len);\n\n    SSL_get0_next_proto_negotiated(server, &proto, &proto_len);\n    ret->server_npn_negotiated = dup_str(proto, proto_len);\n\n    SSL_get0_alpn_selected(client, &proto, &proto_len);\n    ret->client_alpn_negotiated = dup_str(proto, proto_len);\n\n    SSL_get0_alpn_selected(server, &proto, &proto_len);\n    ret->server_alpn_negotiated = dup_str(proto, proto_len);\n#endif\n\n    ret->client_resumed = SSL_session_reused(client);\n    ret->server_resumed = SSL_session_reused(server);\n\n    if (session_out != NULL)\n        *session_out = SSL_get1_session(client);\n\n    ctx_data_free_data(&server_ctx_data);\n    ctx_data_free_data(&server2_ctx_data);\n    ctx_data_free_data(&client_ctx_data);\n\n    SSL_free(server);\n    SSL_free(client);\n    return ret;\n}", "before_change_lines": [3, 27, 34], "raw_before_change_lines": [3, 27, 34], "after_change_lines": [3, 27, 34], "raw_after_change_lines": [3, 27, 34], "bug_lines": [3, 27, 34], "added": [false, false, false], "idx": 442}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13145----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_65a87db48fea380df4c7c46a2b8acd20c8e8d6a0_1.json----OPENSSL_fork_child", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_65a87db48fea380df4c7c46a2b8acd20c8e8d6a0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_65a87db48fea380df4c7c46a2b8acd20c8e8d6a0_1.json", "function_name": "OPENSSL_fork_child", "vul_func_code": "void OPENSSL_fork_child(void)\n{\n    rand_fork();\n    /* TODO(3.0): Inform all providers about a fork event */\n}", "patch_func_code": "void OPENSSL_fork_child(void)\n{\n    /* TODO(3.0): Inform all providers about a fork event */\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [3], "added": [false], "idx": 443}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13181----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_66ad9310ee77f7d6434e8a1896edd109d571c116_1.json----OPENSSL_sk_delete", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_66ad9310ee77f7d6434e8a1896edd109d571c116_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_66ad9310ee77f7d6434e8a1896edd109d571c116_1.json", "function_name": "OPENSSL_sk_delete", "vul_func_code": "void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc)\n{\n    const char *ret;\n\n    if (st == NULL || loc < 0 || loc >= st->num)\n        return NULL;\n\n    ret = st->data[loc];\n    if (loc != st->num - 1)\n         memmove(&st->data[loc], &st->data[loc + 1],\n                 sizeof(st->data[0]) * (st->num - loc - 1));\n    st->num--;\n    return (void *)ret;\n}", "patch_func_code": "void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc)\n{\n    const void *ret;\n\n    if (st == NULL || loc < 0 || loc >= st->num)\n        return NULL;\n\n    ret = st->data[loc];\n    if (loc != st->num - 1)\n         memmove(&st->data[loc], &st->data[loc + 1],\n                 sizeof(st->data[0]) * (st->num - loc - 1));\n    st->num--;\n    return (void *)ret;\n}", "before_change_lines": [3], "raw_before_change_lines": [3], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3], "added": [false], "idx": 444}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13226----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_685770b8fe26f3505731263595e67c3810a173a4_1.json----c2i_ASN1_OBJECT", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_685770b8fe26f3505731263595e67c3810a173a4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_685770b8fe26f3505731263595e67c3810a173a4_1.json", "function_name": "c2i_ASN1_OBJECT", "vul_func_code": "ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n\t     long len)\n\t{\n\tASN1_OBJECT *ret=NULL;\n\tconst unsigned char *p;\n\tunsigned char *data;\n\tint i;\n\t/* Sanity check OID encoding: can't have leading 0x80 in\n\t * subidentifiers, see: X.690 8.19.2\n\t */\n\tfor (i = 0, p = *pp + 1; i < len - 1; i++, p++)\n\t\t{\n\t\tif (*p == 0x80 && (!i || !(p[-1] & 0x80)))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_C2I_ASN1_OBJECT,ASN1_R_INVALID_OBJECT_ENCODING);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t/* only the ASN1_OBJECTs from the 'table' will have values\n\t * for ->sn or ->ln */\n\tif ((a == NULL) || ((*a) == NULL) ||\n\t\t!((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC))\n\t\t{\n\t\tif ((ret=ASN1_OBJECT_new()) == NULL) return(NULL);\n\t\t}\n\telse\tret=(*a);\n\n\tp= *pp;\n\t/* detach data from object */\n\tdata = (unsigned char *)ret->data;\n\tret->data = NULL;\n\t/* once detached we can change it */\n\tif ((data == NULL) || (ret->length < len))\n\t\t{\n\t\tret->length=0;\n\t\tif (data != NULL) OPENSSL_free(data);\n\t\tdata=(unsigned char *)OPENSSL_malloc(len ? (int)len : 1);\n\t\tif (data == NULL)\n\t\t\t{ i=ERR_R_MALLOC_FAILURE; goto err; }\n\t\tret->flags|=ASN1_OBJECT_FLAG_DYNAMIC_DATA;\n\t\t}\n\tmemcpy(data,p,(int)len);\n\t/* reattach data to object, after which it remains const */\n\tret->data  =data;\n\tret->length=(int)len;\n\tret->sn=NULL;\n\tret->ln=NULL;\n\t/* ret->flags=ASN1_OBJECT_FLAG_DYNAMIC; we know it is dynamic */\n\tp+=len;\n\n\tif (a != NULL) (*a)=ret;\n\t*pp=p;\n\treturn(ret);\nerr:\n\tASN1err(ASN1_F_C2I_ASN1_OBJECT,i);\n\tif ((ret != NULL) && ((a == NULL) || (*a != ret)))\n\t\tASN1_OBJECT_free(ret);\n\treturn(NULL);\n\t}", "patch_func_code": "ASN1_OBJECT *c2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,\n\t     long len)\n\t{\n\tASN1_OBJECT *ret=NULL;\n\tconst unsigned char *p;\n\tunsigned char *data;\n\tint i;\n\t/* Sanity check OID encoding: can't have leading 0x80 in\n\t * subidentifiers, see: X.690 8.19.2\n\t */\n\tfor (i = 0, p = *pp; i < len; i++, p++)\n\t\t{\n\t\tif (*p == 0x80 && (!i || !(p[-1] & 0x80)))\n\t\t\t{\n\t\t\tASN1err(ASN1_F_C2I_ASN1_OBJECT,ASN1_R_INVALID_OBJECT_ENCODING);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t/* only the ASN1_OBJECTs from the 'table' will have values\n\t * for ->sn or ->ln */\n\tif ((a == NULL) || ((*a) == NULL) ||\n\t\t!((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC))\n\t\t{\n\t\tif ((ret=ASN1_OBJECT_new()) == NULL) return(NULL);\n\t\t}\n\telse\tret=(*a);\n\n\tp= *pp;\n\t/* detach data from object */\n\tdata = (unsigned char *)ret->data;\n\tret->data = NULL;\n\t/* once detached we can change it */\n\tif ((data == NULL) || (ret->length < len))\n\t\t{\n\t\tret->length=0;\n\t\tif (data != NULL) OPENSSL_free(data);\n\t\tdata=(unsigned char *)OPENSSL_malloc(len ? (int)len : 1);\n\t\tif (data == NULL)\n\t\t\t{ i=ERR_R_MALLOC_FAILURE; goto err; }\n\t\tret->flags|=ASN1_OBJECT_FLAG_DYNAMIC_DATA;\n\t\t}\n\tmemcpy(data,p,(int)len);\n\t/* reattach data to object, after which it remains const */\n\tret->data  =data;\n\tret->length=(int)len;\n\tret->sn=NULL;\n\tret->ln=NULL;\n\t/* ret->flags=ASN1_OBJECT_FLAG_DYNAMIC; we know it is dynamic */\n\tp+=len;\n\n\tif (a != NULL) (*a)=ret;\n\t*pp=p;\n\treturn(ret);\nerr:\n\tASN1err(ASN1_F_C2I_ASN1_OBJECT,i);\n\tif ((ret != NULL) && ((a == NULL) || (*a != ret)))\n\t\tASN1_OBJECT_free(ret);\n\treturn(NULL);\n\t}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [11], "added": [false], "idx": 445}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "13252----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_698c2b1bfbbd2714c819dc083b360de7e44a4799_1.json----test_PACKET_get_1", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_698c2b1bfbbd2714c819dc083b360de7e44a4799_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_698c2b1bfbbd2714c819dc083b360de7e44a4799_1.json", "function_name": "test_PACKET_get_1", "vul_func_code": "static int test_PACKET_get_1(unsigned char buf[BUF_LEN])\n{\n    unsigned int i;\n    PACKET pkt;\n\n    if (       !PACKET_buf_init(&pkt, buf, BUF_LEN)\n            || !PACKET_get_1(&pkt, &i)\n            ||  i != 0x02\n            || !PACKET_forward(&pkt, BUF_LEN - 2)\n            || !PACKET_get_1(&pkt, &i)\n            ||  i != 0xfe\n            ||  PACKET_get_1(&pkt, &i)) {\n        fprintf(stderr, \"test_PACKET_get_1() failed\\n\");\n        return 0;\n    }\n\n    return 1;\n}", "patch_func_code": "static int test_PACKET_get_1()\n{\n    unsigned int i;\n    PACKET pkt;\n\n    if (!TEST_true(PACKET_buf_init(&pkt, smbuf, BUF_LEN))\n            || !TEST_true(PACKET_get_1(&pkt, &i))\n            || !TEST_uint_eq(i, 0x02)\n            || !TEST_true(PACKET_forward(&pkt, BUF_LEN - 2))\n            || !TEST_true(PACKET_get_1(&pkt, &i))\n            || !TEST_uint_eq(i, 0xfe)\n            || !TEST_false(PACKET_get_1(&pkt, &i)))\n        return 0;\n\n    return 1;\n}", "before_change_lines": [1, 6, 7, 8, 9, 10, 11, 12, 13, 15], "raw_before_change_lines": [1, 6, 7, 8, 9, 10, 11, 12, 13, 15], "after_change_lines": [1, 6, 7, 8, 9, 10, 11, 12], "raw_after_change_lines": [1, 6, 7, 8, 9, 10, 11, 12], "bug_lines": [1, 6, 7, 8, 9, 10, 11, 12, 13, 15], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 446}
{"project": "openssl", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "13314----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6b5d27987e5c93dfb1a52691dc1dd3df77a3d49f_1.json----TXT_DB_read", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_6b5d27987e5c93dfb1a52691dc1dd3df77a3d49f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6b5d27987e5c93dfb1a52691dc1dd3df77a3d49f_1.json", "function_name": "TXT_DB_read", "vul_func_code": "TXT_DB *TXT_DB_read(BIO *in, int num)\n\t{\n\tTXT_DB *ret=NULL;\n\tint er=1;\n\tint esc=0;\n\tlong ln=0;\n\tint i,add,n;\n\tint size=BUFSIZE;\n\tint offset=0;\n\tchar *p,**pp,*f;\n\tBUF_MEM *buf=NULL;\n\n\tif ((buf=BUF_MEM_new()) == NULL) goto err;\n\tif (!BUF_MEM_grow(buf,size)) goto err;\n\n\tif ((ret=(TXT_DB *)OPENSSL_malloc(sizeof(TXT_DB))) == NULL)\n\t\tgoto err;\n\tret->num_fields=num;\n\tret->index=NULL;\n\tret->qual=NULL;\n\tif ((ret->data=sk_new_null()) == NULL)\n\t\tgoto err;\n\tif ((ret->index=(LHASH **)OPENSSL_malloc(sizeof(LHASH *)*num)) == NULL)\n\t\tgoto err;\n\tif ((ret->qual=(int (**)(char **))OPENSSL_malloc(sizeof(int (**)(char **))*num)) == NULL)\n\t\tgoto err;\n\tfor (i=0; i<num; i++)\n\t\t{\n\t\tret->index[i]=NULL;\n\t\tret->qual[i]=NULL;\n\t\t}\n\n\tadd=(num+1)*sizeof(char *);\n\tbuf->data[size-1]='\\0';\n\toffset=0;\n\tfor (;;)\n\t\t{\n\t\tif (offset != 0)\n\t\t\t{\n\t\t\tsize+=BUFSIZE;\n\t\t\tif (!BUF_MEM_grow_clean(buf,size)) goto err;\n\t\t\t}\n\t\tbuf->data[offset]='\\0';\n\t\tBIO_gets(in,&(buf->data[offset]),size-offset);\n\t\tln++;\n\t\tif (buf->data[offset] == '\\0') break;\n\t\tif ((offset == 0) && (buf->data[0] == '#')) continue;\n\t\ti=strlen(&(buf->data[offset]));\n\t\toffset+=i;\n\t\tif (buf->data[offset-1] != '\\n')\n\t\t\tcontinue;\n\t\telse\n\t\t\t{\n\t\t\tbuf->data[offset-1]='\\0'; /* blat the '\\n' */\n\t\t\tif (!(p=(char *)OPENSSL_malloc(add+offset))) goto err;\n\t\t\toffset=0;\n\t\t\t}\n\t\tpp=(char **)p;\n\t\tp+=add;\n\t\tn=0;\n\t\tpp[n++]=p;\n\t\ti=0;\n\t\tf=buf->data;\n\n\t\tesc=0;\n\t\tfor (;;)\n\t\t\t{\n\t\t\tif (*f == '\\0') break;\n\t\t\tif (*f == '\\t')\n\t\t\t\t{\n\t\t\t\tif (esc)\n\t\t\t\t\tp--;\n\t\t\t\telse\n\t\t\t\t\t{\t\n\t\t\t\t\t*(p++)='\\0';\n\t\t\t\t\tf++;\n\t\t\t\t\tif (n >=  num) break;\n\t\t\t\t\tpp[n++]=p;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tesc=(*f == '\\\\');\n\t\t\t*(p++)= *(f++);\n\t\t\t}\n\t\t*(p++)='\\0';\n\t\tif ((n != num) || (*f != '\\0'))\n\t\t\t{\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\t/* temporaty fix :-( */\n\t\t\tfprintf(stderr,\"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\\n\",ln,num,n,f);\n#endif\n\t\t\ter=2;\n\t\t\tgoto err;\n\t\t\t}\n\t\tpp[n]=p;\n\t\tif (!sk_push(ret->data,(char *)pp))\n\t\t\t{\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\t/* temporaty fix :-( */\n\t\t\tfprintf(stderr,\"failure in sk_push\\n\");\n#endif\n\t\t\ter=2;\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\ter=0;\nerr:\n\tBUF_MEM_free(buf);\n\tif (er)\n\t\t{\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\n\t\tif (er == 1) fprintf(stderr,\"OPENSSL_malloc failure\\n\");\n#endif\n\t\tif (ret->data != NULL) sk_free(ret->data);\n\t\tif (ret->index != NULL) OPENSSL_free(ret->index);\n\t\tif (ret->qual != NULL) OPENSSL_free(ret->qual);\n\t\tif (ret != NULL) OPENSSL_free(ret);\n\t\treturn(NULL);\n\t\t}\n\telse\n\t\treturn(ret);\n\t}", "patch_func_code": "TXT_DB *TXT_DB_read(BIO *in, int num)\n\t{\n\tTXT_DB *ret=NULL;\n\tint er=1;\n\tint esc=0;\n\tlong ln=0;\n\tint i,add,n;\n\tint size=BUFSIZE;\n\tint offset=0;\n\tchar *p,**pp,*f;\n\tBUF_MEM *buf=NULL;\n\n\tif ((buf=BUF_MEM_new()) == NULL) goto err;\n\tif (!BUF_MEM_grow(buf,size)) goto err;\n\n\tif ((ret=(TXT_DB *)OPENSSL_malloc(sizeof(TXT_DB))) == NULL)\n\t\tgoto err;\n\tret->num_fields=num;\n\tret->index=NULL;\n\tret->qual=NULL;\n\tif ((ret->data=sk_new_null()) == NULL)\n\t\tgoto err;\n\tif ((ret->index=(LHASH **)OPENSSL_malloc(sizeof(LHASH *)*num)) == NULL)\n\t\tgoto err;\n\tif ((ret->qual=(int (**)(char **))OPENSSL_malloc(sizeof(int (**)(char **))*num)) == NULL)\n\t\tgoto err;\n\tfor (i=0; i<num; i++)\n\t\t{\n\t\tret->index[i]=NULL;\n\t\tret->qual[i]=NULL;\n\t\t}\n\n\tadd=(num+1)*sizeof(char *);\n\tbuf->data[size-1]='\\0';\n\toffset=0;\n\tfor (;;)\n\t\t{\n\t\tif (offset != 0)\n\t\t\t{\n\t\t\tsize+=BUFSIZE;\n\t\t\tif (!BUF_MEM_grow_clean(buf,size)) goto err;\n\t\t\t}\n\t\tbuf->data[offset]='\\0';\n\t\tBIO_gets(in,&(buf->data[offset]),size-offset);\n\t\tln++;\n\t\tif (buf->data[offset] == '\\0') break;\n\t\tif ((offset == 0) && (buf->data[0] == '#')) continue;\n\t\ti=strlen(&(buf->data[offset]));\n\t\toffset+=i;\n\t\tif (buf->data[offset-1] != '\\n')\n\t\t\tcontinue;\n\t\telse\n\t\t\t{\n\t\t\tbuf->data[offset-1]='\\0'; /* blat the '\\n' */\n\t\t\tif (!(p=(char *)OPENSSL_malloc(add+offset))) goto err;\n\t\t\toffset=0;\n\t\t\t}\n\t\tpp=(char **)p;\n\t\tp+=add;\n\t\tn=0;\n\t\tpp[n++]=p;\n\t\ti=0;\n\t\tf=buf->data;\n\n\t\tesc=0;\n\t\tfor (;;)\n\t\t\t{\n\t\t\tif (*f == '\\0') break;\n\t\t\tif (*f == '\\t')\n\t\t\t\t{\n\t\t\t\tif (esc)\n\t\t\t\t\tp--;\n\t\t\t\telse\n\t\t\t\t\t{\t\n\t\t\t\t\t*(p++)='\\0';\n\t\t\t\t\tf++;\n\t\t\t\t\tif (n >=  num) break;\n\t\t\t\t\tpp[n++]=p;\n\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tesc=(*f == '\\\\');\n\t\t\t*(p++)= *(f++);\n\t\t\t}\n\t\t*(p++)='\\0';\n\t\tif ((n != num) || (*f != '\\0'))\n\t\t\t{\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\t/* temporaty fix :-( */\n\t\t\tfprintf(stderr,\"wrong number of fields on line %ld (looking for field %d, got %d, '%s' left)\\n\",ln,num,n,f);\n#endif\n\t\t\ter=2;\n\t\t\tgoto err;\n\t\t\t}\n\t\tpp[n]=p;\n\t\tif (!sk_push(ret->data,(char *)pp))\n\t\t\t{\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\t/* temporaty fix :-( */\n\t\t\tfprintf(stderr,\"failure in sk_push\\n\");\n#endif\n\t\t\ter=2;\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\ter=0;\nerr:\n\tBUF_MEM_free(buf);\n\tif (er)\n\t\t{\n#if !defined(OPENSSL_NO_STDIO) && !defined(OPENSSL_SYS_WIN16)\n\t\tif (er == 1) fprintf(stderr,\"OPENSSL_malloc failure\\n\");\n#endif\n\t\tif (ret != NULL)\n\t\t\t{\n\t\t\tif (ret->data != NULL) sk_free(ret->data);\n\t\t\tif (ret->index != NULL) OPENSSL_free(ret->index);\n\t\t\tif (ret->qual != NULL) OPENSSL_free(ret->qual);\n\t\t\tif (ret != NULL) OPENSSL_free(ret);\n\t\t\t}\n\t\treturn(NULL);\n\t\t}\n\telse\n\t\treturn(ret);\n\t}", "before_change_lines": [112, 113, 114, 115], "raw_before_change_lines": [112, 113, 114, 115], "after_change_lines": [112, 113, 114, 115, 116, 117, 118], "raw_after_change_lines": [112, 113, 114, 115, 116, 117, 118], "bug_lines": [112, 113, 114, 115], "added": [false, false, false, false], "idx": 447}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13348----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6cf2b5b5c24452a54b670c2e7d086ebab6b7f82b_1.json----sh_clearbit", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_6cf2b5b5c24452a54b670c2e7d086ebab6b7f82b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6cf2b5b5c24452a54b670c2e7d086ebab6b7f82b_1.json", "function_name": "sh_clearbit", "vul_func_code": "static void sh_clearbit(char *ptr, int list, unsigned char *table)\n{\n    int bit;\n\n    OPENSSL_assert(list >= 0 && list < sh.freelist_size);\n    OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);\n    bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));\n    OPENSSL_assert(bit > 0 && bit < sh.bittable_size);\n    OPENSSL_assert(TESTBIT(table, bit));\n    CLEARBIT(table, bit);\n}", "patch_func_code": "static void sh_clearbit(char *ptr, int list, unsigned char *table)\n{\n    size_t bit;\n\n    OPENSSL_assert(list >= 0 && list < sh.freelist_size);\n    OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);\n    bit = (ONE << list) + ((ptr - sh.arena) / (sh.arena_size >> list));\n    OPENSSL_assert(bit > 0 && bit < sh.bittable_size);\n    OPENSSL_assert(TESTBIT(table, bit));\n    CLEARBIT(table, bit);\n}", "before_change_lines": [3, 7], "raw_before_change_lines": [3, 7], "after_change_lines": [3, 7], "raw_after_change_lines": [3, 7], "bug_lines": [3, 7], "added": [false, false], "idx": 448}
{"project": "openssl", "vul_type": "DEAD_STORE", "filepath_func": "13404----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6eaeed1fc25440b9076ab3d5c66bb193525d4391_1.json----BIO_get_accept_socket", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_6eaeed1fc25440b9076ab3d5c66bb193525d4391_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6eaeed1fc25440b9076ab3d5c66bb193525d4391_1.json", "function_name": "BIO_get_accept_socket", "vul_func_code": "int BIO_get_accept_socket(char *host, int bind_mode)\n\t{\n\tint ret=0;\n\tstruct sockaddr_in server,client;\n\tint s= -1,cs;\n\tunsigned char ip[4];\n\tunsigned short port;\n\tchar *str,*e;\n\tconst char *h,*p;\n\tunsigned long l;\n\tint err_num;\n\n\tif (BIO_sock_init() != 1) return(INVALID_SOCKET);\n\n\tif ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET);\n\n\th=p=NULL;\n\th=str;\n\tfor (e=str; *e; e++)\n\t\t{\n\t\tif (*e == ':')\n\t\t\t{\n\t\t\tp= &(e[1]);\n\t\t\t*e='\\0';\n\t\t\t}\n\t\telse if (*e == '/')\n\t\t\t{\n\t\t\t*e='\\0';\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (p == NULL)\n\t\t{\n\t\tp=h;\n\t\th=\"*\";\n\t\t}\n\n\tif (!BIO_get_port(p,&port)) return(INVALID_SOCKET);\n\n\tmemset((char *)&server,0,sizeof(server));\n\tserver.sin_family=AF_INET;\n\tserver.sin_port=htons(port);\n\n\tif (strcmp(h,\"*\") == 0)\n\t\tserver.sin_addr.s_addr=INADDR_ANY;\n\telse\n\t\t{\n\t\tif (!BIO_get_host_ip(h,&(ip[0]))) return(INVALID_SOCKET);\n\t\tl=(unsigned long)\n\t\t\t((unsigned long)ip[0]<<24L)|\n\t\t\t((unsigned long)ip[1]<<16L)|\n\t\t\t((unsigned long)ip[2]<< 8L)|\n\t\t\t((unsigned long)ip[3]);\n\t\tserver.sin_addr.s_addr=htonl(l);\n\t\t}\n\nagain:\n\ts=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\n\tif (s == INVALID_SOCKET)\n\t\t{\n\t\tSYSerr(SYS_F_SOCKET,get_last_socket_error());\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET);\n\t\tgoto err;\n\t\t}\n\n#ifdef SO_REUSEADDR\n\tif (bind_mode == BIO_BIND_REUSEADDR)\n\t\t{\n\t\tint i=1;\n\n\t\tret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));\n\t\tbind_mode=BIO_BIND_NORMAL;\n\t\t}\n#endif\n\tif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\n\t\t{\n#ifdef SO_REUSEADDR\n\t\terr_num=get_last_socket_error();\n\t\tif ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&\n\t\t\t(err_num == EADDRINUSE))\n\t\t\t{\n\t\t\tmemcpy((char *)&client,(char *)&server,sizeof(server));\n\t\t\tif (strcmp(h,\"*\") == 0)\n\t\t\t\tclient.sin_addr.s_addr=htonl(0x7F000001);\n\t\t\tcs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\n\t\t\tif (cs != INVALID_SOCKET)\n\t\t\t\t{\n\t\t\t\tint ii;\n\t\t\t\tii=connect(cs,(struct sockaddr *)&client,\n\t\t\t\t\tsizeof(client));\n\t\t\t\tclosesocket(cs);\n\t\t\t\tif (ii == INVALID_SOCKET)\n\t\t\t\t\t{\n\t\t\t\t\tbind_mode=BIO_BIND_REUSEADDR;\n\t\t\t\t\tclosesocket(s);\n\t\t\t\t\tgoto again;\n\t\t\t\t\t}\n\t\t\t\t/* else error */\n\t\t\t\t}\n\t\t\t/* else error */\n\t\t\t}\n#endif\n\t\tSYSerr(SYS_F_BIND,err_num);\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET);\n\t\tgoto err;\n\t\t}\n\tif (listen(s,MAX_LISTEN) == -1)\n\t\t{\n\t\tSYSerr(SYS_F_BIND,get_last_socket_error());\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET);\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tif (str != NULL) OPENSSL_free(str);\n\tif ((ret == 0) && (s != INVALID_SOCKET))\n\t\t{\n\t\tclosesocket(s);\n\t\ts= INVALID_SOCKET;\n\t\t}\n\treturn(s);\n\t}", "patch_func_code": "int BIO_get_accept_socket(char *host, int bind_mode)\n\t{\n\tint ret=0;\n\tstruct sockaddr_in server,client;\n\tint s=INVALID_SOCKET,cs;\n\tunsigned char ip[4];\n\tunsigned short port;\n\tchar *str=NULL,*e;\n\tconst char *h,*p;\n\tunsigned long l;\n\tint err_num;\n\n\tif (BIO_sock_init() != 1) return(INVALID_SOCKET);\n\n\tif ((str=BUF_strdup(host)) == NULL) return(INVALID_SOCKET);\n\n\th=p=NULL;\n\th=str;\n\tfor (e=str; *e; e++)\n\t\t{\n\t\tif (*e == ':')\n\t\t\t{\n\t\t\tp= &(e[1]);\n\t\t\t*e='\\0';\n\t\t\t}\n\t\telse if (*e == '/')\n\t\t\t{\n\t\t\t*e='\\0';\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tif (p == NULL)\n\t\t{\n\t\tp=h;\n\t\th=\"*\";\n\t\t}\n\n\tif (!BIO_get_port(p,&port)) goto err;\n\n\tmemset((char *)&server,0,sizeof(server));\n\tserver.sin_family=AF_INET;\n\tserver.sin_port=htons(port);\n\n\tif (strcmp(h,\"*\") == 0)\n\t\tserver.sin_addr.s_addr=INADDR_ANY;\n\telse\n\t\t{\n                if (!BIO_get_host_ip(h,&(ip[0]))) goto err;\n\t\tl=(unsigned long)\n\t\t\t((unsigned long)ip[0]<<24L)|\n\t\t\t((unsigned long)ip[1]<<16L)|\n\t\t\t((unsigned long)ip[2]<< 8L)|\n\t\t\t((unsigned long)ip[3]);\n\t\tserver.sin_addr.s_addr=htonl(l);\n\t\t}\n\nagain:\n\ts=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\n\tif (s == INVALID_SOCKET)\n\t\t{\n\t\tSYSerr(SYS_F_SOCKET,get_last_socket_error());\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_CREATE_SOCKET);\n\t\tgoto err;\n\t\t}\n\n#ifdef SO_REUSEADDR\n\tif (bind_mode == BIO_BIND_REUSEADDR)\n\t\t{\n\t\tint i=1;\n\n\t\tret=setsockopt(s,SOL_SOCKET,SO_REUSEADDR,(char *)&i,sizeof(i));\n\t\tbind_mode=BIO_BIND_NORMAL;\n\t\t}\n#endif\n\tif (bind(s,(struct sockaddr *)&server,sizeof(server)) == -1)\n\t\t{\n#ifdef SO_REUSEADDR\n\t\terr_num=get_last_socket_error();\n\t\tif ((bind_mode == BIO_BIND_REUSEADDR_IF_UNUSED) &&\n\t\t\t(err_num == EADDRINUSE))\n\t\t\t{\n\t\t\tmemcpy((char *)&client,(char *)&server,sizeof(server));\n\t\t\tif (strcmp(h,\"*\") == 0)\n\t\t\t\tclient.sin_addr.s_addr=htonl(0x7F000001);\n\t\t\tcs=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);\n\t\t\tif (cs != INVALID_SOCKET)\n\t\t\t\t{\n\t\t\t\tint ii;\n\t\t\t\tii=connect(cs,(struct sockaddr *)&client,\n\t\t\t\t\tsizeof(client));\n\t\t\t\tclosesocket(cs);\n\t\t\t\tif (ii == INVALID_SOCKET)\n\t\t\t\t\t{\n\t\t\t\t\tbind_mode=BIO_BIND_REUSEADDR;\n\t\t\t\t\tclosesocket(s);\n\t\t\t\t\tgoto again;\n\t\t\t\t\t}\n\t\t\t\t/* else error */\n\t\t\t\t}\n\t\t\t/* else error */\n\t\t\t}\n#endif\n\t\tSYSerr(SYS_F_BIND,err_num);\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_BIND_SOCKET);\n\t\tgoto err;\n\t\t}\n\tif (listen(s,MAX_LISTEN) == -1)\n\t\t{\n\t\tSYSerr(SYS_F_BIND,get_last_socket_error());\n\t\tERR_add_error_data(3,\"port='\",host,\"'\");\n\t\tBIOerr(BIO_F_BIO_GET_ACCEPT_SOCKET,BIO_R_UNABLE_TO_LISTEN_SOCKET);\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tif (str != NULL) OPENSSL_free(str);\n\tif ((ret == 0) && (s != INVALID_SOCKET))\n\t\t{\n\t\tclosesocket(s);\n\t\ts= INVALID_SOCKET;\n\t\t}\n\treturn(s);\n\t}", "before_change_lines": [5, 8, 39, 49], "raw_before_change_lines": [5, 8, 39, 49], "after_change_lines": [5, 8, 39, 49], "raw_after_change_lines": [5, 8, 39, 49], "bug_lines": [5, 8, 39, 49], "added": [false, false, false, false], "idx": 449}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13416----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6f4372479013731b10384a65af15820293e28da9_1.json----nseq_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_6f4372479013731b10384a65af15820293e28da9_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_6f4372479013731b10384a65af15820293e28da9_1.json", "function_name": "nseq_main", "vul_func_code": "int MAIN(int argc, char **argv)\n{\n\tchar **args, *infile = NULL, *outfile = NULL;\n\tBIO *in = NULL, *out = NULL;\n\tint toseq = 0;\n\tX509 *x509 = NULL;\n\tNETSCAPE_CERT_SEQUENCE *seq = NULL;\n\tint i, ret = 1;\n\tint badarg = 0;\n\tif (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\n\tERR_load_crypto_strings();\n\targs = argv + 1;\n\twhile (!badarg && *args && *args[0] == '-') {\n\t\tif (!strcmp (*args, \"-toseq\")) toseq = 1;\n\t\telse if (!strcmp (*args, \"-in\")) {\n\t\t\tif (args[1]) {\n\t\t\t\targs++;\n\t\t\t\tinfile = *args;\n\t\t\t} else badarg = 1;\n\t\t} else if (!strcmp (*args, \"-out\")) {\n\t\t\tif (args[1]) {\n\t\t\t\targs++;\n\t\t\t\toutfile = *args;\n\t\t\t} else badarg = 1;\n\t\t} else badarg = 1;\n\t\targs++;\n\t}\n\n\tif (badarg) {\n\t\tBIO_printf (bio_err, \"Netscape certificate sequence utility\\n\");\n\t\tBIO_printf (bio_err, \"Usage nseq [options]\\n\");\n\t\tBIO_printf (bio_err, \"where options are\\n\");\n\t\tBIO_printf (bio_err, \"-in file  input file\\n\");\n\t\tBIO_printf (bio_err, \"-out file output file\\n\");\n\t\tBIO_printf (bio_err, \"-toseq    output NS Sequence file\\n\");\n\t\tEXIT(1);\n\t}\n\n\tif (infile) {\n\t\tif (!(in = BIO_new_file (infile, \"r\"))) {\n\t\t\tBIO_printf (bio_err,\n\t\t\t\t \"Can't open input file %s\\n\", infile);\n\t\t\tgoto end;\n\t\t}\n\t} else in = BIO_new_fp(stdin, BIO_NOCLOSE);\n\n\tif (outfile) {\n\t\tif (!(out = BIO_new_file (outfile, \"w\"))) {\n\t\t\tBIO_printf (bio_err,\n\t\t\t\t \"Can't open output file %s\\n\", outfile);\n\t\t\tgoto end;\n\t\t}\n\t} else out = BIO_new_fp(stdout, BIO_NOCLOSE);\n\n\tif (toseq) {\n\t\tseq = NETSCAPE_CERT_SEQUENCE_new();\n\t\tseq->certs = sk_X509_new_null();\n\t\twhile((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL))) \n\t\t    sk_X509_push(seq->certs,x509);\n\n\t\tif(!sk_X509_num(seq->certs))\n\t\t{\n\t\t\tBIO_printf (bio_err, \"Error reading certs file %s\\n\", infile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t\tPEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tif (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) {\n\t\tBIO_printf (bio_err, \"Error reading sequence file %s\\n\", infile);\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t}\n\n\tfor(i = 0; i < sk_X509_num(seq->certs); i++) {\n\t\tx509 = sk_X509_value(seq->certs, i);\n\t\tdump_cert_text(out, x509);\n\t\tPEM_write_bio_X509(out, x509);\n\t}\n\tret = 0;\nend:\n\tBIO_free(in);\n\tBIO_free(out);\n\tNETSCAPE_CERT_SEQUENCE_free(seq);\n\n\tEXIT(ret);\n}", "patch_func_code": "int MAIN(int argc, char **argv)\n{\n\tchar **args, *infile = NULL, *outfile = NULL;\n\tBIO *in = NULL, *out = NULL;\n\tint toseq = 0;\n\tX509 *x509 = NULL;\n\tNETSCAPE_CERT_SEQUENCE *seq = NULL;\n\tint i, ret = 1;\n\tint badarg = 0;\n\tif (bio_err == NULL) bio_err = BIO_new_fp (stderr, BIO_NOCLOSE);\n\tERR_load_crypto_strings();\n\targs = argv + 1;\n\twhile (!badarg && *args && *args[0] == '-') {\n\t\tif (!strcmp (*args, \"-toseq\")) toseq = 1;\n\t\telse if (!strcmp (*args, \"-in\")) {\n\t\t\tif (args[1]) {\n\t\t\t\targs++;\n\t\t\t\tinfile = *args;\n\t\t\t} else badarg = 1;\n\t\t} else if (!strcmp (*args, \"-out\")) {\n\t\t\tif (args[1]) {\n\t\t\t\targs++;\n\t\t\t\toutfile = *args;\n\t\t\t} else badarg = 1;\n\t\t} else badarg = 1;\n\t\targs++;\n\t}\n\n\tif (badarg) {\n\t\tBIO_printf (bio_err, \"Netscape certificate sequence utility\\n\");\n\t\tBIO_printf (bio_err, \"Usage nseq [options]\\n\");\n\t\tBIO_printf (bio_err, \"where options are\\n\");\n\t\tBIO_printf (bio_err, \"-in file  input file\\n\");\n\t\tBIO_printf (bio_err, \"-out file output file\\n\");\n\t\tBIO_printf (bio_err, \"-toseq    output NS Sequence file\\n\");\n\t\tEXIT(1);\n\t}\n\n\tif (infile) {\n\t\tif (!(in = BIO_new_file (infile, \"r\"))) {\n\t\t\tBIO_printf (bio_err,\n\t\t\t\t \"Can't open input file %s\\n\", infile);\n\t\t\tgoto end;\n\t\t}\n\t} else in = BIO_new_fp(stdin, BIO_NOCLOSE);\n\n\tif (outfile) {\n\t\tif (!(out = BIO_new_file (outfile, \"w\"))) {\n\t\t\tBIO_printf (bio_err,\n\t\t\t\t \"Can't open output file %s\\n\", outfile);\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\tout = BIO_new_fp(stdout, BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t}\n\tif (toseq) {\n\t\tseq = NETSCAPE_CERT_SEQUENCE_new();\n\t\tseq->certs = sk_X509_new_null();\n\t\twhile((x509 = PEM_read_bio_X509(in, NULL, NULL, NULL))) \n\t\t    sk_X509_push(seq->certs,x509);\n\n\t\tif(!sk_X509_num(seq->certs))\n\t\t{\n\t\t\tBIO_printf (bio_err, \"Error reading certs file %s\\n\", infile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t\tPEM_write_bio_NETSCAPE_CERT_SEQUENCE(out, seq);\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tif (!(seq = PEM_read_bio_NETSCAPE_CERT_SEQUENCE(in, NULL, NULL, NULL))) {\n\t\tBIO_printf (bio_err, \"Error reading sequence file %s\\n\", infile);\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t}\n\n\tfor(i = 0; i < sk_X509_num(seq->certs); i++) {\n\t\tx509 = sk_X509_value(seq->certs, i);\n\t\tdump_cert_text(out, x509);\n\t\tPEM_write_bio_X509(out, x509);\n\t}\n\tret = 0;\nend:\n\tBIO_free(in);\n\tBIO_free_all(out);\n\tNETSCAPE_CERT_SEQUENCE_free(seq);\n\n\tEXIT(ret);\n}", "before_change_lines": [53, 86], "raw_before_change_lines": [53, 54, 86], "after_change_lines": [53, 54, 55, 56, 57, 58, 59, 60, 61, 93], "raw_after_change_lines": [53, 54, 55, 56, 57, 58, 59, 60, 61, 93], "bug_lines": [53, 54, 86], "added": [false, false, false], "idx": 450}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13448----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_700f87ea7cbec40d4209c9e8703505cb625e5970_1.json----check_purpose", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_700f87ea7cbec40d4209c9e8703505cb625e5970_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_700f87ea7cbec40d4209c9e8703505cb625e5970_1.json", "function_name": "check_purpose", "vul_func_code": "static int check_purpose(X509_STORE_CTX *ctx, X509 *x, int purpose, int depth,\n                         int must_be_ca)\n{\n    int pu_ok = X509_check_purpose(x, purpose, must_be_ca > 0);\n    int tr_ok = X509_TRUST_UNTRUSTED;\n\n    /*\n     * For trusted certificates we want to see whether any auxiliary trust\n     * settings override the purpose constraints we failed to meet above.\n     *\n     * This is complicated by the fact that the trust ordinals in\n     * ctx->param->trust are entirely independent of the purpose ordinals in\n     * ctx->param->purpose!\n     *\n     * What connects them is their mutual initialization via calls from\n     * X509_STORE_CTX_set_default() into X509_VERIFY_PARAM_lookup() which sets\n     * related values of both param->trust and param->purpose.  It is however\n     * typically possible to infer associated trust values from a purpose value\n     * via the X509_PURPOSE API.\n     *\n     * Therefore, we can only check for trust overrides when the purpose we're\n     * checking is the same as ctx->param->purpose and ctx->param->trust is\n     * also set, or can be inferred from the purpose.\n     */\n    if (depth >= ctx->num_untrusted && purpose == ctx->param->purpose)\n        tr_ok = X509_check_trust(x, ctx->param->trust, X509_TRUST_NO_SS_COMPAT);\n\n    if (tr_ok != X509_TRUST_REJECTED &&\n        (pu_ok == 1 ||\n         (pu_ok != 0 && (ctx->param->flags & X509_V_FLAG_X509_STRICT) == 0)))\n        return 1;\n\n    ctx->error = X509_V_ERR_INVALID_PURPOSE;\n    ctx->error_depth = depth;\n    ctx->current_cert = x;\n    return ctx->verify_cb(0, ctx);\n}", "patch_func_code": "static int check_purpose(X509_STORE_CTX *ctx, X509 *x, int purpose, int depth,\n                         int must_be_ca)\n{\n    int tr_ok = X509_TRUST_UNTRUSTED;\n\n    /*\n     * For trusted certificates we want to see whether any auxiliary trust\n     * settings trump the purpose constraints.\n     *\n     * This is complicated by the fact that the trust ordinals in\n     * ctx->param->trust are entirely independent of the purpose ordinals in\n     * ctx->param->purpose!\n     *\n     * What connects them is their mutual initialization via calls from\n     * X509_STORE_CTX_set_default() into X509_VERIFY_PARAM_lookup() which sets\n     * related values of both param->trust and param->purpose.  It is however\n     * typically possible to infer associated trust values from a purpose value\n     * via the X509_PURPOSE API.\n     *\n     * Therefore, we can only check for trust overrides when the purpose we're\n     * checking is the same as ctx->param->purpose and ctx->param->trust is\n     * also set.\n     */\n    if (depth >= ctx->num_untrusted && purpose == ctx->param->purpose)\n        tr_ok = X509_check_trust(x, ctx->param->trust, X509_TRUST_NO_SS_COMPAT);\n\n    switch (tr_ok) {\n    case X509_TRUST_TRUSTED:\n        return 1;\n    case X509_TRUST_REJECTED:\n        break;\n    default:\n        switch (X509_check_purpose(x, purpose, must_be_ca > 0)) {\n        case 1:\n            return 1;\n        case 0:\n            break;\n        default:\n            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) == 0)\n                return 1;\n        }\n        break;\n    }\n\n    ctx->error = X509_V_ERR_INVALID_PURPOSE;\n    ctx->error_depth = depth;\n    ctx->current_cert = x;\n    return ctx->verify_cb(0, ctx);\n}", "before_change_lines": [4, 9, 23, 28, 29, 30], "raw_before_change_lines": [4, 9, 23, 28, 29, 30], "after_change_lines": [8, 22, 27, 28, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43], "raw_after_change_lines": [8, 22, 27, 28, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43], "bug_lines": [4, 9, 23, 28, 29, 30], "added": [false, false, false, false, false, false], "idx": 451}
{"project": "openssl", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "13455----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_708d345b4e0c0594b035b83c7cb5f118305eb673_1.json----ssl_set_sig_mask", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_708d345b4e0c0594b035b83c7cb5f118305eb673_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_708d345b4e0c0594b035b83c7cb5f118305eb673_1.json", "function_name": "ssl_set_sig_mask", "vul_func_code": "void ssl_set_sig_mask(uint32_t *pmask_a, SSL *s, int op)\n{\n    const uint16_t *sigalgs;\n    size_t i, sigalgslen;\n    uint32_t disabled_mask = SSL_aRSA | SSL_aDSS | SSL_aECDSA;\n    /*\n     * Go through all signature algorithms seeing if we support any\n     * in disabled_mask.\n     */\n    sigalgslen = tls12_get_psigalgs(s, 1, &sigalgs);\n    for (i = 0; i < sigalgslen; i ++, sigalgs++) {\n        const SIGALG_LOOKUP *lu = tls1_lookup_sigalg(*sigalgs);\n        const SSL_CERT_LOOKUP *clu;\n\n        if (lu == NULL)\n            continue;\n\n        clu = ssl_cert_lookup_by_idx(lu->sig_idx);\n\n        /* If algorithm is disabled see if we can enable it */\n        if ((clu->amask & disabled_mask) != 0\n                && tls12_sigalg_allowed(s, op, lu))\n            disabled_mask &= ~clu->amask;\n    }\n    *pmask_a |= disabled_mask;\n}", "patch_func_code": "void ssl_set_sig_mask(uint32_t *pmask_a, SSL *s, int op)\n{\n    const uint16_t *sigalgs;\n    size_t i, sigalgslen;\n    uint32_t disabled_mask = SSL_aRSA | SSL_aDSS | SSL_aECDSA;\n    /*\n     * Go through all signature algorithms seeing if we support any\n     * in disabled_mask.\n     */\n    sigalgslen = tls12_get_psigalgs(s, 1, &sigalgs);\n    for (i = 0; i < sigalgslen; i++, sigalgs++) {\n        const SIGALG_LOOKUP *lu = tls1_lookup_sigalg(*sigalgs);\n        const SSL_CERT_LOOKUP *clu;\n\n        if (lu == NULL)\n            continue;\n\n        clu = ssl_cert_lookup_by_idx(lu->sig_idx);\n\tif (clu == NULL)\n\t\tcontinue;\n\n        /* If algorithm is disabled see if we can enable it */\n        if ((clu->amask & disabled_mask) != 0\n                && tls12_sigalg_allowed(s, op, lu))\n            disabled_mask &= ~clu->amask;\n    }\n    *pmask_a |= disabled_mask;\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11, 19, 20], "raw_after_change_lines": [11, 19, 20], "bug_lines": [11], "added": [false], "idx": 452}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "13470----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_710a178cffb51f4975faffefeec58a3251163406_1.json----BN_CTX_init", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_710a178cffb51f4975faffefeec58a3251163406_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_710a178cffb51f4975faffefeec58a3251163406_1.json", "function_name": "BN_CTX_init", "vul_func_code": "void BN_CTX_init(BN_CTX *ctx)\n#else\nstatic void BN_CTX_init(BN_CTX *ctx)\n#endif\n\t{\n#if 0 /* explicit version */\n\tint i;\n\tctx->tos = 0;\n\tctx->flags = 0;\n\tctx->depth = 0;\n\tctx->too_many = 0;\n\tfor (i = 0; i < BN_CTX_NUM; i++)\n\t\tBN_init(&(ctx->bn[i]));\n#else\n\tmemset(ctx, 0, sizeof *ctx);\n#endif\n\t}", "patch_func_code": "void BN_CTX_init(BN_CTX *ctx)\n\t{\n\t/* Assume the caller obtained the context via BN_CTX_new() and so is\n\t * trying to reset it for use. Nothing else makes sense, least of all\n\t * binary compatibility from a time when they could declare a static\n\t * variable. */\n\tBN_POOL_reset(&ctx->pool);\n\tBN_STACK_reset(&ctx->stack);\n\tctx->used = 0;\n\tctx->err_stack = 0;\n\tctx->too_many = 0;\n\t}", "before_change_lines": [1, 3, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16], "raw_before_change_lines": [1, 3, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16], "after_change_lines": [1, 4, 5, 6, 7, 8, 9, 10], "raw_after_change_lines": [1, 3, 4, 5, 6, 7, 8, 9, 10], "bug_lines": [1, 3, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16], "added": [false, false, false, false, false, false, false, false, false, false, false, false], "idx": 453}
{"project": "openssl", "vul_type": "PULSE_MEMORY_LEAK", "filepath_func": "13588----PULSE_MEMORY_LEAK----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7550e9fcd7d2c5e0eb3c8f71cb423c1c0495b1fa_1.json----OSSL_STORE_LOADER_new", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7550e9fcd7d2c5e0eb3c8f71cb423c1c0495b1fa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7550e9fcd7d2c5e0eb3c8f71cb423c1c0495b1fa_1.json", "function_name": "OSSL_STORE_LOADER_new", "vul_func_code": "OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme)\n{\n    OSSL_STORE_LOADER *res = OPENSSL_zalloc(sizeof(*res));\n\n    if (res == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    /*\n     * We usually don't check NULL arguments.  For loaders, though, the\n     * scheme is crucial and must never be NULL, or the user will get\n     * mysterious errors when trying to register the created loader\n     * later on.\n     */\n    if (scheme == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW,\n                      OSSL_STORE_R_INVALID_SCHEME);\n        return NULL;\n    }\n\n    res->engine = e;\n    res->scheme = scheme;\n    return res;\n}", "patch_func_code": "OSSL_STORE_LOADER *OSSL_STORE_LOADER_new(ENGINE *e, const char *scheme)\n{\n    OSSL_STORE_LOADER *res = NULL;\n\n    /*\n     * We usually don't check NULL arguments.  For loaders, though, the\n     * scheme is crucial and must never be NULL, or the user will get\n     * mysterious errors when trying to register the created loader\n     * later on.\n     */\n    if (scheme == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW,\n                      OSSL_STORE_R_INVALID_SCHEME);\n        return NULL;\n    }\n\n    if ((res = OPENSSL_zalloc(sizeof(*res))) == NULL) {\n        OSSL_STOREerr(OSSL_STORE_F_OSSL_STORE_LOADER_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    res->engine = e;\n    res->scheme = scheme;\n    return res;\n}", "before_change_lines": [3, 5, 6, 7, 8], "raw_before_change_lines": [3, 4, 5, 6, 7, 8], "after_change_lines": [3, 17, 18, 19, 20], "raw_after_change_lines": [3, 17, 18, 19, 20, 21], "bug_lines": [3, 4, 5, 6, 7, 8], "added": [false, false, false, false, false, false], "idx": 454}
{"project": "openssl", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "13615----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7612027932b3e77c3e01c62979cc5a4177a9bfc0_1.json----OPENSSL_sk_pop", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7612027932b3e77c3e01c62979cc5a4177a9bfc0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7612027932b3e77c3e01c62979cc5a4177a9bfc0_1.json", "function_name": "OPENSSL_sk_pop", "vul_func_code": "void *OPENSSL_sk_pop(OPENSSL_STACK *st)\n{\n    if (st == NULL)\n        return (NULL);\n    if (st->num <= 0)\n        return (NULL);\n    return (OPENSSL_sk_delete(st, st->num - 1));\n}", "patch_func_code": "void *OPENSSL_sk_pop(OPENSSL_STACK *st)\n{\n    if (st == NULL)\n        return NULL;\n    if (st->num <= 0)\n        return NULL;\n    return internal_delete(st, st->num - 1);\n}", "before_change_lines": [4, 6, 7], "raw_before_change_lines": [4, 6, 7], "after_change_lines": [4, 6, 7], "raw_after_change_lines": [4, 6, 7], "bug_lines": [4, 6, 7], "added": [false, false, false], "idx": 455}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13801----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7bf66e41311ce56f748a660a38084678963d1e7b_1.json----pack_sign_cp", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7bf66e41311ce56f748a660a38084678963d1e7b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7bf66e41311ce56f748a660a38084678963d1e7b_1.json", "function_name": "pack_sign_cp", "vul_func_code": "int pack_sign_cp(DSA_SIG *s, int order, unsigned char *sig, size_t *siglen)\n{\n    *siglen = 2 * order;\n    memset(sig, 0, *siglen);\n    store_bignum(s->s, sig, order);\n    store_bignum(s->r, sig + order, order);\n    dump_signature(\"serialized\", sig, *siglen);\n    DSA_SIG_free(s);\n    return 1;\n}", "patch_func_code": "int pack_sign_cp(DSA_SIG *s, int order, unsigned char *sig, size_t *siglen)\n{\n    *siglen = 2 * order;\n    memset(sig, 0, *siglen);\n    store_bignum(s->s, sig, order);\n    store_bignum(s->r, sig + order, order);\n    DSA_SIG_free(s);\n    return 1;\n}", "before_change_lines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "raw_before_change_lines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 456}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L2", "filepath_func": "13842----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d1c0f003c7872d7f0de32897ecfe933c827b693_1.json----encode_test_init", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7d1c0f003c7872d7f0de32897ecfe933c827b693_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d1c0f003c7872d7f0de32897ecfe933c827b693_1.json", "function_name": "encode_test_init", "vul_func_code": "static int encode_test_init(struct evp_test *t, const char *encoding)\n{\n    struct encode_data *edata = OPENSSL_zalloc(sizeof(*edata));\n\n    if (strcmp(encoding, \"canonical\") == 0) {\n        edata->encoding = BASE64_CANONICAL_ENCODING;\n    } else if (strcmp(encoding, \"valid\") == 0) {\n        edata->encoding = BASE64_VALID_ENCODING;\n    } else if (strcmp(encoding, \"invalid\") == 0) {\n        edata->encoding = BASE64_INVALID_ENCODING;\n        t->expected_err = BUF_strdup(\"DECODE_ERROR\");\n        if (t->expected_err == NULL)\n            return 0;\n    } else {\n        fprintf(stderr, \"Bad encoding: %s. Should be one of \"\n                \"{canonical, valid, invalid}\\n\", encoding);\n        return 0;\n    }\n    t->data = edata;\n    return 1;\n}", "patch_func_code": "static int encode_test_init(struct evp_test *t, const char *encoding)\n{\n    struct encode_data *edata = OPENSSL_zalloc(sizeof(*edata));\n\n    if (strcmp(encoding, \"canonical\") == 0) {\n        edata->encoding = BASE64_CANONICAL_ENCODING;\n    } else if (strcmp(encoding, \"valid\") == 0) {\n        edata->encoding = BASE64_VALID_ENCODING;\n    } else if (strcmp(encoding, \"invalid\") == 0) {\n        edata->encoding = BASE64_INVALID_ENCODING;\n        t->expected_err = OPENSSL_strdup(\"DECODE_ERROR\");\n        if (t->expected_err == NULL)\n            return 0;\n    } else {\n        fprintf(stderr, \"Bad encoding: %s. Should be one of \"\n                \"{canonical, valid, invalid}\\n\", encoding);\n        return 0;\n    }\n    t->data = edata;\n    return 1;\n}", "before_change_lines": [11], "raw_before_change_lines": [11], "after_change_lines": [11], "raw_after_change_lines": [11], "bug_lines": [11], "added": [false], "idx": 457}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "13845----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d2f101548a24682053862e2b839357fa6a8b520_1.json----dtls1_buffer_record", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7d2f101548a24682053862e2b839357fa6a8b520_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d2f101548a24682053862e2b839357fa6a8b520_1.json", "function_name": "dtls1_buffer_record", "vul_func_code": "int\ndtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n{\n    DTLS1_RECORD_DATA *rdata;\n    pitem *item;\n\n    /* Limit the size of the queue to prevent DOS attacks */\n    if (pqueue_size(queue->q) >= 100)\n        return 0;\n\n    rdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n    item = pitem_new(priority, rdata);\n    if (rdata == NULL || item == NULL) {\n        if (rdata != NULL)\n            OPENSSL_free(rdata);\n        if (item != NULL)\n            pitem_free(item);\n\n        SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    rdata->packet = s->rlayer.packet;\n    rdata->packet_length = s->rlayer.packet_length;\n    memcpy(&(rdata->rbuf), &s->rlayer.rbuf, sizeof(SSL3_BUFFER));\n    memcpy(&(rdata->rrec), &s->rlayer.rrec, sizeof(SSL3_RECORD));\n\n    item->data = rdata;\n\n#ifndef OPENSSL_NO_SCTP\n    /* Store bio_dgram_sctp_rcvinfo struct */\n    if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n        (s->state == SSL3_ST_SR_FINISHED_A\n         || s->state == SSL3_ST_CR_FINISHED_A)) {\n        BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO,\n                 sizeof(rdata->recordinfo), &rdata->recordinfo);\n    }\n#endif\n\n    s->rlayer.packet = NULL;\n    s->rlayer.packet_length = 0;\n    memset(&s->rlayer.rbuf, 0, sizeof(SSL3_BUFFER));\n    memset(&s->rlayer.rrec, 0, sizeof(SSL3_RECORD));\n\n    if (!ssl3_setup_buffers(s)) {\n        SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n        if (rdata->rbuf.buf != NULL)\n            OPENSSL_free(rdata->rbuf.buf);\n        OPENSSL_free(rdata);\n        pitem_free(item);\n        return (-1);\n    }\n\n    /* insert should not fail, since duplicates are dropped */\n    if (pqueue_insert(queue->q, item) == NULL) {\n        SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n        if (rdata->rbuf.buf != NULL)\n            OPENSSL_free(rdata->rbuf.buf);\n        OPENSSL_free(rdata);\n        pitem_free(item);\n        return (-1);\n    }\n\n    return (1);\n}", "patch_func_code": "int dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n{\n    DTLS1_RECORD_DATA *rdata;\n    pitem *item;\n\n    /* Limit the size of the queue to prevent DOS attacks */\n    if (pqueue_size(queue->q) >= 100)\n        return 0;\n\n    rdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n    item = pitem_new(priority, rdata);\n    if (rdata == NULL || item == NULL) {\n        if (rdata != NULL)\n            OPENSSL_free(rdata);\n        if (item != NULL)\n            pitem_free(item);\n\n        SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n        return -1;\n    }\n\n    rdata->packet = s->rlayer.packet;\n    rdata->packet_length = s->rlayer.packet_length;\n    memcpy(&(rdata->rbuf), &s->rlayer.rbuf, sizeof(SSL3_BUFFER));\n    memcpy(&(rdata->rrec), &s->rlayer.rrec, sizeof(SSL3_RECORD));\n\n    item->data = rdata;\n\n#ifndef OPENSSL_NO_SCTP\n    /* Store bio_dgram_sctp_rcvinfo struct */\n    if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n        (s->state == SSL3_ST_SR_FINISHED_A\n         || s->state == SSL3_ST_CR_FINISHED_A)) {\n        BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO,\n                 sizeof(rdata->recordinfo), &rdata->recordinfo);\n    }\n#endif\n\n    s->rlayer.packet = NULL;\n    s->rlayer.packet_length = 0;\n    memset(&s->rlayer.rbuf, 0, sizeof(SSL3_BUFFER));\n    memset(&s->rlayer.rrec, 0, sizeof(SSL3_RECORD));\n\n    if (!ssl3_setup_buffers(s)) {\n        SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n        if (rdata->rbuf.buf != NULL)\n            OPENSSL_free(rdata->rbuf.buf);\n        OPENSSL_free(rdata);\n        pitem_free(item);\n        return (-1);\n    }\n\n    /* insert should not fail, since duplicates are dropped */\n    if (pqueue_insert(queue->q, item) == NULL) {\n        SSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n        if (rdata->rbuf.buf != NULL)\n            OPENSSL_free(rdata->rbuf.buf);\n        OPENSSL_free(rdata);\n        pitem_free(item);\n        return (-1);\n    }\n\n    return (1);\n}", "before_change_lines": [1, 2], "raw_before_change_lines": [1, 2], "after_change_lines": [1], "raw_after_change_lines": [1], "bug_lines": [1, 2], "added": [false, false], "idx": 458}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "13850----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d5bf675f76d0bf7e732def341c71b2a86edcee6_1.json----ssl3_ctrl", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7d5bf675f76d0bf7e732def341c71b2a86edcee6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7d5bf675f76d0bf7e732def341c71b2a86edcee6_1.json", "function_name": "ssl3_ctrl", "vul_func_code": "long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)\n{\n    int ret = 0;\n\n    switch (cmd) {\n    case SSL_CTRL_GET_SESSION_REUSED:\n        ret = s->hit;\n        break;\n    case SSL_CTRL_GET_CLIENT_CERT_REQUEST:\n        break;\n    case SSL_CTRL_GET_NUM_RENEGOTIATIONS:\n        ret = s->s3->num_renegotiations;\n        break;\n    case SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\n        ret = s->s3->num_renegotiations;\n        s->s3->num_renegotiations = 0;\n        break;\n    case SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\n        ret = s->s3->total_renegotiations;\n        break;\n    case SSL_CTRL_GET_FLAGS:\n        ret = (int)(s->s3->flags);\n        break;\n#ifndef OPENSSL_NO_DH\n    case SSL_CTRL_SET_TMP_DH:\n        {\n            DH *dh = (DH *)parg;\n            if (dh == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n                return (ret);\n            }\n            if (!ssl_security(s, SSL_SECOP_TMP_DH,\n                              DH_security_bits(dh), 0, dh)) {\n                SSLerr(SSL_F_SSL3_CTRL, SSL_R_DH_KEY_TOO_SMALL);\n                return (ret);\n            }\n            if ((dh = DHparams_dup(dh)) == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n                return (ret);\n            }\n            if (!(s->options & SSL_OP_SINGLE_DH_USE)) {\n                if (!DH_generate_key(dh)) {\n                    DH_free(dh);\n                    SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n                    return (ret);\n                }\n            }\n            DH_free(s->cert->dh_tmp);\n            s->cert->dh_tmp = dh;\n            ret = 1;\n        }\n        break;\n    case SSL_CTRL_SET_TMP_DH_CB:\n        {\n            SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            return (ret);\n        }\n    case SSL_CTRL_SET_DH_AUTO:\n        s->cert->dh_tmp_auto = larg;\n        return 1;\n#endif\n#ifndef OPENSSL_NO_EC\n    case SSL_CTRL_SET_TMP_ECDH:\n        {\n            const EC_GROUP *group = NULL;\n            int nid;\n\n            if (parg == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n                return 0;\n            }\n            group = EC_KEY_get0_group((const EC_KEY *)parg);\n            if (group == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, EC_R_MISSING_PARAMETERS);\n                return 0;\n            }\n            nid = EC_GROUP_get_curve_name(group);\n            if (nid == NID_undef)\n                return 0;\n            return tls1_set_curves(&s->tlsext_ellipticcurvelist,\n                                   &s->tlsext_ellipticcurvelist_length,\n                                   &nid, 1);\n        }\n        break;\n#endif                          /* !OPENSSL_NO_EC */\n    case SSL_CTRL_SET_TLSEXT_HOSTNAME:\n        if (larg == TLSEXT_NAMETYPE_host_name) {\n            OPENSSL_free(s->tlsext_hostname);\n            s->tlsext_hostname = NULL;\n\n            ret = 1;\n            if (parg == NULL)\n                break;\n            if (strlen((char *)parg) > TLSEXT_MAXLEN_host_name) {\n                SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME);\n                return 0;\n            }\n            if ((s->tlsext_hostname = OPENSSL_strdup((char *)parg)) == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        } else {\n            SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE);\n            return 0;\n        }\n        break;\n    case SSL_CTRL_SET_TLSEXT_DEBUG_ARG:\n        s->tlsext_debug_arg = parg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE:\n        s->tlsext_status_type = larg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS:\n        *(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS:\n        s->tlsext_ocsp_exts = parg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS:\n        *(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS:\n        s->tlsext_ocsp_ids = parg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP:\n        *(unsigned char **)parg = s->tlsext_ocsp_resp;\n        return s->tlsext_ocsp_resplen;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP:\n        OPENSSL_free(s->tlsext_ocsp_resp);\n        s->tlsext_ocsp_resp = parg;\n        s->tlsext_ocsp_resplen = larg;\n        ret = 1;\n        break;\n\n#ifndef OPENSSL_NO_HEARTBEATS\n    case SSL_CTRL_TLS_EXT_SEND_HEARTBEAT:\n        if (SSL_IS_DTLS(s))\n            ret = dtls1_heartbeat(s);\n        else\n            ret = tls1_heartbeat(s);\n        break;\n\n    case SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING:\n        ret = s->tlsext_hb_pending;\n        break;\n\n    case SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS:\n        if (larg)\n            s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n        else\n            s->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n        ret = 1;\n        break;\n#endif\n\n    case SSL_CTRL_CHAIN:\n        if (larg)\n            return ssl_cert_set1_chain(s, NULL, (STACK_OF(X509) *)parg);\n        else\n            return ssl_cert_set0_chain(s, NULL, (STACK_OF(X509) *)parg);\n\n    case SSL_CTRL_CHAIN_CERT:\n        if (larg)\n            return ssl_cert_add1_chain_cert(s, NULL, (X509 *)parg);\n        else\n            return ssl_cert_add0_chain_cert(s, NULL, (X509 *)parg);\n\n    case SSL_CTRL_GET_CHAIN_CERTS:\n        *(STACK_OF(X509) **)parg = s->cert->key->chain;\n        break;\n\n    case SSL_CTRL_SELECT_CURRENT_CERT:\n        return ssl_cert_select_current(s->cert, (X509 *)parg);\n\n    case SSL_CTRL_SET_CURRENT_CERT:\n        if (larg == SSL_CERT_SET_SERVER) {\n            CERT_PKEY *cpk;\n            const SSL_CIPHER *cipher;\n            if (!s->server)\n                return 0;\n            cipher = s->s3->tmp.new_cipher;\n            if (!cipher)\n                return 0;\n            /*\n             * No certificate for unauthenticated ciphersuites or using SRP\n             * authentication\n             */\n            if (cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n                return 2;\n            cpk = ssl_get_server_send_pkey(s);\n            if (!cpk)\n                return 0;\n            s->cert->key = cpk;\n            return 1;\n        }\n        return ssl_cert_set_current(s->cert, larg);\n\n#ifndef OPENSSL_NO_EC\n    case SSL_CTRL_GET_CURVES:\n        {\n            unsigned char *clist;\n            size_t clistlen;\n            if (!s->session)\n                return 0;\n            clist = s->session->tlsext_ellipticcurvelist;\n            clistlen = s->session->tlsext_ellipticcurvelist_length / 2;\n            if (parg) {\n                size_t i;\n                int *cptr = parg;\n                unsigned int cid, nid;\n                for (i = 0; i < clistlen; i++) {\n                    n2s(clist, cid);\n                    nid = tls1_ec_curve_id2nid(cid);\n                    if (nid != 0)\n                        cptr[i] = nid;\n                    else\n                        cptr[i] = TLSEXT_nid_unknown | cid;\n                }\n            }\n            return (int)clistlen;\n        }\n\n    case SSL_CTRL_SET_CURVES:\n        return tls1_set_curves(&s->tlsext_ellipticcurvelist,\n                               &s->tlsext_ellipticcurvelist_length,\n                               parg, larg);\n\n    case SSL_CTRL_SET_CURVES_LIST:\n        return tls1_set_curves_list(&s->tlsext_ellipticcurvelist,\n                                    &s->tlsext_ellipticcurvelist_length,\n                                    parg);\n\n    case SSL_CTRL_GET_SHARED_CURVE:\n        return tls1_shared_curve(s, larg);\n\n#endif\n    case SSL_CTRL_SET_SIGALGS:\n        return tls1_set_sigalgs(s->cert, parg, larg, 0);\n\n    case SSL_CTRL_SET_SIGALGS_LIST:\n        return tls1_set_sigalgs_list(s->cert, parg, 0);\n\n    case SSL_CTRL_SET_CLIENT_SIGALGS:\n        return tls1_set_sigalgs(s->cert, parg, larg, 1);\n\n    case SSL_CTRL_SET_CLIENT_SIGALGS_LIST:\n        return tls1_set_sigalgs_list(s->cert, parg, 1);\n\n    case SSL_CTRL_GET_CLIENT_CERT_TYPES:\n        {\n            const unsigned char **pctype = parg;\n            if (s->server || !s->s3->tmp.cert_req)\n                return 0;\n            if (s->cert->ctypes) {\n                if (pctype)\n                    *pctype = s->cert->ctypes;\n                return (int)s->cert->ctype_num;\n            }\n            if (pctype)\n                *pctype = (unsigned char *)s->s3->tmp.ctype;\n            return s->s3->tmp.ctype_num;\n        }\n\n    case SSL_CTRL_SET_CLIENT_CERT_TYPES:\n        if (!s->server)\n            return 0;\n        return ssl3_set_req_cert_type(s->cert, parg, larg);\n\n    case SSL_CTRL_BUILD_CERT_CHAIN:\n        return ssl_build_cert_chain(s, NULL, larg);\n\n    case SSL_CTRL_SET_VERIFY_CERT_STORE:\n        return ssl_cert_set_cert_store(s->cert, parg, 0, larg);\n\n    case SSL_CTRL_SET_CHAIN_CERT_STORE:\n        return ssl_cert_set_cert_store(s->cert, parg, 1, larg);\n\n    case SSL_CTRL_GET_PEER_SIGNATURE_NID:\n        if (SSL_USE_SIGALGS(s)) {\n            if (s->session) {\n                const EVP_MD *sig;\n                sig = s->s3->tmp.peer_md;\n                if (sig) {\n                    *(int *)parg = EVP_MD_type(sig);\n                    return 1;\n                }\n            }\n            return 0;\n        }\n        /* Might want to do something here for other versions */\n        else\n            return 0;\n\n    case SSL_CTRL_GET_SERVER_TMP_KEY:\n        if (s->server || !s->session)\n            return 0;\n        else {\n            EVP_PKEY *ptmp;\n            int rv = 0;\n#if !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC)\n            if (s->s3->peer_dh_tmp == NULL && s->s3->peer_tmp == NULL)\n                return 0;\n#endif\n            ptmp = EVP_PKEY_new();\n            if (ptmp == NULL)\n                return 0;\n#ifndef OPENSSL_NO_DH\n            else if (s->s3->peer_dh_tmp != NULL)\n                rv = EVP_PKEY_set1_DH(ptmp, s->s3->peer_dh_tmp);\n#endif\n#ifndef OPENSSL_NO_EC\n            else if (s->s3->peer_tmp != NULL)\n                rv = EVP_PKEY_set1_EC_KEY(ptmp,\n                                          EVP_PKEY_get0_EC_KEY(s->s3->peer_tmp));\n#endif\n            if (rv) {\n                *(EVP_PKEY **)parg = ptmp;\n                return 1;\n            }\n            EVP_PKEY_free(ptmp);\n            return 0;\n        }\n#ifndef OPENSSL_NO_EC\n    case SSL_CTRL_GET_EC_POINT_FORMATS:\n        {\n            SSL_SESSION *sess = s->session;\n            const unsigned char **pformat = parg;\n            if (!sess || !sess->tlsext_ecpointformatlist)\n                return 0;\n            *pformat = sess->tlsext_ecpointformatlist;\n            return (int)sess->tlsext_ecpointformatlist_length;\n        }\n#endif\n\n    case SSL_CTRL_CHECK_PROTO_VERSION:\n        /*\n         * For library-internal use; checks that the current protocol is the\n         * highest enabled version (according to s->ctx->method, as version\n         * negotiation may have changed s->method).\n         */\n        if (s->version == s->ctx->method->version)\n            return 1;\n        /*\n         * Apparently we're using a version-flexible SSL_METHOD (not at its\n         * highest protocol version).\n         */\n        if (s->ctx->method->version == TLS_method()->version) {\n#if TLS_MAX_VERSION != TLS1_2_VERSION\n# error Code needs update for TLS_method() support beyond TLS1_2_VERSION.\n#endif\n            if (!(s->options & SSL_OP_NO_TLSv1_2))\n                return s->version == TLS1_2_VERSION;\n            if (!(s->options & SSL_OP_NO_TLSv1_1))\n                return s->version == TLS1_1_VERSION;\n            if (!(s->options & SSL_OP_NO_TLSv1))\n                return s->version == TLS1_VERSION;\n            if (!(s->options & SSL_OP_NO_SSLv3))\n                return s->version == SSL3_VERSION;\n        }\n        return 0;               /* Unexpected state; fail closed. */\n\n    default:\n        break;\n    }\n    return (ret);\n}", "patch_func_code": "long ssl3_ctrl(SSL *s, int cmd, long larg, void *parg)\n{\n    int ret = 0;\n\n    switch (cmd) {\n    case SSL_CTRL_GET_SESSION_REUSED:\n        ret = s->hit;\n        break;\n    case SSL_CTRL_GET_CLIENT_CERT_REQUEST:\n        break;\n    case SSL_CTRL_GET_NUM_RENEGOTIATIONS:\n        ret = s->s3->num_renegotiations;\n        break;\n    case SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:\n        ret = s->s3->num_renegotiations;\n        s->s3->num_renegotiations = 0;\n        break;\n    case SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:\n        ret = s->s3->total_renegotiations;\n        break;\n    case SSL_CTRL_GET_FLAGS:\n        ret = (int)(s->s3->flags);\n        break;\n#ifndef OPENSSL_NO_DH\n    case SSL_CTRL_SET_TMP_DH:\n        {\n            DH *dh = (DH *)parg;\n            if (dh == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n                return (ret);\n            }\n            if (!ssl_security(s, SSL_SECOP_TMP_DH,\n                              DH_security_bits(dh), 0, dh)) {\n                SSLerr(SSL_F_SSL3_CTRL, SSL_R_DH_KEY_TOO_SMALL);\n                return (ret);\n            }\n            if ((dh = DHparams_dup(dh)) == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);\n                return (ret);\n            }\n            DH_free(s->cert->dh_tmp);\n            s->cert->dh_tmp = dh;\n            ret = 1;\n        }\n        break;\n    case SSL_CTRL_SET_TMP_DH_CB:\n        {\n            SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n            return (ret);\n        }\n    case SSL_CTRL_SET_DH_AUTO:\n        s->cert->dh_tmp_auto = larg;\n        return 1;\n#endif\n#ifndef OPENSSL_NO_EC\n    case SSL_CTRL_SET_TMP_ECDH:\n        {\n            const EC_GROUP *group = NULL;\n            int nid;\n\n            if (parg == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);\n                return 0;\n            }\n            group = EC_KEY_get0_group((const EC_KEY *)parg);\n            if (group == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, EC_R_MISSING_PARAMETERS);\n                return 0;\n            }\n            nid = EC_GROUP_get_curve_name(group);\n            if (nid == NID_undef)\n                return 0;\n            return tls1_set_curves(&s->tlsext_ellipticcurvelist,\n                                   &s->tlsext_ellipticcurvelist_length,\n                                   &nid, 1);\n        }\n        break;\n#endif                          /* !OPENSSL_NO_EC */\n    case SSL_CTRL_SET_TLSEXT_HOSTNAME:\n        if (larg == TLSEXT_NAMETYPE_host_name) {\n            OPENSSL_free(s->tlsext_hostname);\n            s->tlsext_hostname = NULL;\n\n            ret = 1;\n            if (parg == NULL)\n                break;\n            if (strlen((char *)parg) > TLSEXT_MAXLEN_host_name) {\n                SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME);\n                return 0;\n            }\n            if ((s->tlsext_hostname = OPENSSL_strdup((char *)parg)) == NULL) {\n                SSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        } else {\n            SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE);\n            return 0;\n        }\n        break;\n    case SSL_CTRL_SET_TLSEXT_DEBUG_ARG:\n        s->tlsext_debug_arg = parg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE:\n        s->tlsext_status_type = larg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS:\n        *(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS:\n        s->tlsext_ocsp_exts = parg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS:\n        *(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS:\n        s->tlsext_ocsp_ids = parg;\n        ret = 1;\n        break;\n\n    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP:\n        *(unsigned char **)parg = s->tlsext_ocsp_resp;\n        return s->tlsext_ocsp_resplen;\n\n    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP:\n        OPENSSL_free(s->tlsext_ocsp_resp);\n        s->tlsext_ocsp_resp = parg;\n        s->tlsext_ocsp_resplen = larg;\n        ret = 1;\n        break;\n\n#ifndef OPENSSL_NO_HEARTBEATS\n    case SSL_CTRL_TLS_EXT_SEND_HEARTBEAT:\n        if (SSL_IS_DTLS(s))\n            ret = dtls1_heartbeat(s);\n        else\n            ret = tls1_heartbeat(s);\n        break;\n\n    case SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING:\n        ret = s->tlsext_hb_pending;\n        break;\n\n    case SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS:\n        if (larg)\n            s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n        else\n            s->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS;\n        ret = 1;\n        break;\n#endif\n\n    case SSL_CTRL_CHAIN:\n        if (larg)\n            return ssl_cert_set1_chain(s, NULL, (STACK_OF(X509) *)parg);\n        else\n            return ssl_cert_set0_chain(s, NULL, (STACK_OF(X509) *)parg);\n\n    case SSL_CTRL_CHAIN_CERT:\n        if (larg)\n            return ssl_cert_add1_chain_cert(s, NULL, (X509 *)parg);\n        else\n            return ssl_cert_add0_chain_cert(s, NULL, (X509 *)parg);\n\n    case SSL_CTRL_GET_CHAIN_CERTS:\n        *(STACK_OF(X509) **)parg = s->cert->key->chain;\n        break;\n\n    case SSL_CTRL_SELECT_CURRENT_CERT:\n        return ssl_cert_select_current(s->cert, (X509 *)parg);\n\n    case SSL_CTRL_SET_CURRENT_CERT:\n        if (larg == SSL_CERT_SET_SERVER) {\n            CERT_PKEY *cpk;\n            const SSL_CIPHER *cipher;\n            if (!s->server)\n                return 0;\n            cipher = s->s3->tmp.new_cipher;\n            if (!cipher)\n                return 0;\n            /*\n             * No certificate for unauthenticated ciphersuites or using SRP\n             * authentication\n             */\n            if (cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))\n                return 2;\n            cpk = ssl_get_server_send_pkey(s);\n            if (!cpk)\n                return 0;\n            s->cert->key = cpk;\n            return 1;\n        }\n        return ssl_cert_set_current(s->cert, larg);\n\n#ifndef OPENSSL_NO_EC\n    case SSL_CTRL_GET_CURVES:\n        {\n            unsigned char *clist;\n            size_t clistlen;\n            if (!s->session)\n                return 0;\n            clist = s->session->tlsext_ellipticcurvelist;\n            clistlen = s->session->tlsext_ellipticcurvelist_length / 2;\n            if (parg) {\n                size_t i;\n                int *cptr = parg;\n                unsigned int cid, nid;\n                for (i = 0; i < clistlen; i++) {\n                    n2s(clist, cid);\n                    nid = tls1_ec_curve_id2nid(cid);\n                    if (nid != 0)\n                        cptr[i] = nid;\n                    else\n                        cptr[i] = TLSEXT_nid_unknown | cid;\n                }\n            }\n            return (int)clistlen;\n        }\n\n    case SSL_CTRL_SET_CURVES:\n        return tls1_set_curves(&s->tlsext_ellipticcurvelist,\n                               &s->tlsext_ellipticcurvelist_length,\n                               parg, larg);\n\n    case SSL_CTRL_SET_CURVES_LIST:\n        return tls1_set_curves_list(&s->tlsext_ellipticcurvelist,\n                                    &s->tlsext_ellipticcurvelist_length,\n                                    parg);\n\n    case SSL_CTRL_GET_SHARED_CURVE:\n        return tls1_shared_curve(s, larg);\n\n#endif\n    case SSL_CTRL_SET_SIGALGS:\n        return tls1_set_sigalgs(s->cert, parg, larg, 0);\n\n    case SSL_CTRL_SET_SIGALGS_LIST:\n        return tls1_set_sigalgs_list(s->cert, parg, 0);\n\n    case SSL_CTRL_SET_CLIENT_SIGALGS:\n        return tls1_set_sigalgs(s->cert, parg, larg, 1);\n\n    case SSL_CTRL_SET_CLIENT_SIGALGS_LIST:\n        return tls1_set_sigalgs_list(s->cert, parg, 1);\n\n    case SSL_CTRL_GET_CLIENT_CERT_TYPES:\n        {\n            const unsigned char **pctype = parg;\n            if (s->server || !s->s3->tmp.cert_req)\n                return 0;\n            if (s->cert->ctypes) {\n                if (pctype)\n                    *pctype = s->cert->ctypes;\n                return (int)s->cert->ctype_num;\n            }\n            if (pctype)\n                *pctype = (unsigned char *)s->s3->tmp.ctype;\n            return s->s3->tmp.ctype_num;\n        }\n\n    case SSL_CTRL_SET_CLIENT_CERT_TYPES:\n        if (!s->server)\n            return 0;\n        return ssl3_set_req_cert_type(s->cert, parg, larg);\n\n    case SSL_CTRL_BUILD_CERT_CHAIN:\n        return ssl_build_cert_chain(s, NULL, larg);\n\n    case SSL_CTRL_SET_VERIFY_CERT_STORE:\n        return ssl_cert_set_cert_store(s->cert, parg, 0, larg);\n\n    case SSL_CTRL_SET_CHAIN_CERT_STORE:\n        return ssl_cert_set_cert_store(s->cert, parg, 1, larg);\n\n    case SSL_CTRL_GET_PEER_SIGNATURE_NID:\n        if (SSL_USE_SIGALGS(s)) {\n            if (s->session) {\n                const EVP_MD *sig;\n                sig = s->s3->tmp.peer_md;\n                if (sig) {\n                    *(int *)parg = EVP_MD_type(sig);\n                    return 1;\n                }\n            }\n            return 0;\n        }\n        /* Might want to do something here for other versions */\n        else\n            return 0;\n\n    case SSL_CTRL_GET_SERVER_TMP_KEY:\n        if (s->server || !s->session)\n            return 0;\n        else {\n            EVP_PKEY *ptmp;\n            int rv = 0;\n#if !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC)\n            if (s->s3->peer_dh_tmp == NULL && s->s3->peer_tmp == NULL)\n                return 0;\n#endif\n            ptmp = EVP_PKEY_new();\n            if (ptmp == NULL)\n                return 0;\n#ifndef OPENSSL_NO_DH\n            else if (s->s3->peer_dh_tmp != NULL)\n                rv = EVP_PKEY_set1_DH(ptmp, s->s3->peer_dh_tmp);\n#endif\n#ifndef OPENSSL_NO_EC\n            else if (s->s3->peer_tmp != NULL)\n                rv = EVP_PKEY_set1_EC_KEY(ptmp,\n                                          EVP_PKEY_get0_EC_KEY(s->s3->peer_tmp));\n#endif\n            if (rv) {\n                *(EVP_PKEY **)parg = ptmp;\n                return 1;\n            }\n            EVP_PKEY_free(ptmp);\n            return 0;\n        }\n#ifndef OPENSSL_NO_EC\n    case SSL_CTRL_GET_EC_POINT_FORMATS:\n        {\n            SSL_SESSION *sess = s->session;\n            const unsigned char **pformat = parg;\n            if (!sess || !sess->tlsext_ecpointformatlist)\n                return 0;\n            *pformat = sess->tlsext_ecpointformatlist;\n            return (int)sess->tlsext_ecpointformatlist_length;\n        }\n#endif\n\n    case SSL_CTRL_CHECK_PROTO_VERSION:\n        /*\n         * For library-internal use; checks that the current protocol is the\n         * highest enabled version (according to s->ctx->method, as version\n         * negotiation may have changed s->method).\n         */\n        if (s->version == s->ctx->method->version)\n            return 1;\n        /*\n         * Apparently we're using a version-flexible SSL_METHOD (not at its\n         * highest protocol version).\n         */\n        if (s->ctx->method->version == TLS_method()->version) {\n#if TLS_MAX_VERSION != TLS1_2_VERSION\n# error Code needs update for TLS_method() support beyond TLS1_2_VERSION.\n#endif\n            if (!(s->options & SSL_OP_NO_TLSv1_2))\n                return s->version == TLS1_2_VERSION;\n            if (!(s->options & SSL_OP_NO_TLSv1_1))\n                return s->version == TLS1_1_VERSION;\n            if (!(s->options & SSL_OP_NO_TLSv1))\n                return s->version == TLS1_VERSION;\n            if (!(s->options & SSL_OP_NO_SSLv3))\n                return s->version == SSL3_VERSION;\n        }\n        return 0;               /* Unexpected state; fail closed. */\n\n    default:\n        break;\n    }\n    return (ret);\n}", "before_change_lines": [41, 42, 43, 44, 45, 46, 47], "raw_before_change_lines": [41, 42, 43, 44, 45, 46, 47], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [41, 42, 43, 44, 45, 46, 47], "added": [false, false, false, false, false, false, false], "idx": 459}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L2", "filepath_func": "13897----INTEGER_OVERFLOW_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7f1040cbd920621e77ef0f4a95e9e266171741fa_1.json----test_PACKET_get_net_3", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7f1040cbd920621e77ef0f4a95e9e266171741fa_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7f1040cbd920621e77ef0f4a95e9e266171741fa_1.json", "function_name": "test_PACKET_get_net_3", "vul_func_code": "static int test_PACKET_get_net_3(unsigned char buf[BUF_LEN])\n{\n    unsigned long i;\n    PACKET pkt;\n\n    if (       !PACKET_buf_init(&pkt, buf, BUF_LEN)\n            || !PACKET_get_net_3(&pkt, &i)\n            ||  i != 0x020406UL\n            || !PACKET_forward(&pkt, BUF_LEN - 6)\n            || !PACKET_get_net_3(&pkt, &i)\n            ||  i != 0xfafcfeUL\n            ||  PACKET_get_net_3(&pkt, &i)) {\n        fprintf(stderr, \"test_PACKET_get_net_3() failed\\n\");\n        return 0;\n    }\n\n    return 1;\n}", "patch_func_code": "static int test_PACKET_get_net_3()\n{\n    unsigned long i;\n    PACKET pkt;\n\n    if (!TEST_true(PACKET_buf_init(&pkt, smbuf, BUF_LEN))\n            || !TEST_true(PACKET_get_net_3(&pkt, &i))\n            || !TEST_ulong_eq(i, 0x020406UL)\n            || !TEST_true(PACKET_forward(&pkt, BUF_LEN - 6))\n            || !TEST_true(PACKET_get_net_3(&pkt, &i))\n            || !TEST_ulong_eq(i, 0xfafcfeUL)\n            || !TEST_false(PACKET_get_net_3(&pkt, &i)))\n        return 0;\n\n    return 1;\n}", "before_change_lines": [1, 6, 7, 8, 9, 10, 11, 12, 13, 15], "raw_before_change_lines": [1, 6, 7, 8, 9, 10, 11, 12, 13, 15], "after_change_lines": [1, 6, 7, 8, 9, 10, 11, 12], "raw_after_change_lines": [1, 6, 7, 8, 9, 10, 11, 12], "bug_lines": [1, 6, 7, 8, 9, 10, 11, 12, 13, 15], "added": [false, false, false, false, false, false, false, false, false, false], "idx": 460}
{"project": "openssl", "vul_type": "NULL_DEREFERENCE", "filepath_func": "13900----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7f1863f41d1927e313fbf20dbee20d39cdac6d21_1.json----UI_create_method", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_7f1863f41d1927e313fbf20dbee20d39cdac6d21_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_7f1863f41d1927e313fbf20dbee20d39cdac6d21_1.json", "function_name": "UI_create_method", "vul_func_code": "UI_METHOD *UI_create_method(char *name)\n\t{\n\tUI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD));\n\n\tif (ui_method)\n\t\tmemset(ui_method, 0, sizeof(*ui_method));\n\tui_method->name = BUF_strdup(name);\n\treturn ui_method;\n\t}", "patch_func_code": "UI_METHOD *UI_create_method(char *name)\n\t{\n\tUI_METHOD *ui_method = (UI_METHOD *)OPENSSL_malloc(sizeof(UI_METHOD));\n\n\tif (ui_method)\n\t\t{\n\t\tmemset(ui_method, 0, sizeof(*ui_method));\n\t\tui_method->name = BUF_strdup(name);\n\t\t}\n\treturn ui_method;\n\t}", "before_change_lines": [7], "raw_before_change_lines": [7], "after_change_lines": [6, 8, 9], "raw_after_change_lines": [6, 8, 9], "bug_lines": [7], "added": [false], "idx": 461}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "13948----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_80cd832b0c93aaf2b42b73ee4833fd1eadacdc26_1.json----test_secret", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_80cd832b0c93aaf2b42b73ee4833fd1eadacdc26_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_80cd832b0c93aaf2b42b73ee4833fd1eadacdc26_1.json", "function_name": "test_secret", "vul_func_code": "static int test_secret(SSL *s, unsigned char *prk,\n                       const unsigned char *label, size_t labellen,\n                       const unsigned char *ref_secret,\n                       const unsigned char *ref_key, const unsigned char *ref_iv)\n{\n    size_t hashsize;\n    unsigned char gensecret[EVP_MAX_MD_SIZE];\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned char key[KEYLEN];\n    unsigned char iv[IVLEN];\n    const EVP_MD *md = ssl_handshake_md(s);\n\n    if (!ssl_handshake_hash(s, hash, sizeof(hash), &hashsize)) {\n        TEST_error(\"Failed to get hash\");\n        return 0;\n    }\n\n    if (!tls13_hkdf_expand(s, md, prk, label, labellen, hash, hashsize,\n                           gensecret, hashsize)) {\n        TEST_error(\"Secret generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(gensecret, hashsize, ref_secret, hashsize))\n        return 0;\n\n    if (!tls13_derive_key(s, md, gensecret, key, KEYLEN)) {\n        TEST_error(\"Key generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(key, KEYLEN, ref_key, KEYLEN))\n        return 0;\n\n    if (!tls13_derive_iv(s, md, gensecret, iv, IVLEN)) {\n        TEST_error(\"IV generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(iv, IVLEN, ref_iv, IVLEN))\n        return 0;\n\n    return 1;\n}", "patch_func_code": "static int test_secret(SSL *s, unsigned char *prk,\n                       const unsigned char *label, size_t labellen,\n                       const unsigned char *ref_secret,\n                       const unsigned char *ref_key, const unsigned char *ref_iv)\n{\n    size_t hashsize;\n    unsigned char gensecret[EVP_MAX_MD_SIZE];\n    unsigned char hash[EVP_MAX_MD_SIZE];\n    unsigned char key[KEYLEN];\n    unsigned char iv[IVLEN];\n    const EVP_MD *md = ssl_handshake_md(s);\n\n    if (!ssl_handshake_hash(s, hash, sizeof(hash), &hashsize)) {\n        TEST_error(\"Failed to get hash\");\n        return 0;\n    }\n\n    if (!tls13_hkdf_expand(s, md, prk, label, labellen, hash, hashsize,\n                           gensecret, hashsize, 1)) {\n        TEST_error(\"Secret generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(gensecret, hashsize, ref_secret, hashsize))\n        return 0;\n\n    if (!tls13_derive_key(s, md, gensecret, key, KEYLEN)) {\n        TEST_error(\"Key generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(key, KEYLEN, ref_key, KEYLEN))\n        return 0;\n\n    if (!tls13_derive_iv(s, md, gensecret, iv, IVLEN)) {\n        TEST_error(\"IV generation failed\");\n        return 0;\n    }\n\n    if (!TEST_mem_eq(iv, IVLEN, ref_iv, IVLEN))\n        return 0;\n\n    return 1;\n}", "before_change_lines": [19], "raw_before_change_lines": [19], "after_change_lines": [19], "raw_after_change_lines": [19], "bug_lines": [19], "added": [false], "idx": 462}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "13999----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_832ac31b36d068df128575e47ed9e25649039f82_1.json----def_load_bio", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_832ac31b36d068df128575e47ed9e25649039f82_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_832ac31b36d068df128575e47ed9e25649039f82_1.json", "function_name": "def_load_bio", "vul_func_code": "static int def_load_bio(CONF *conf, BIO *in, long *line)\n\t{\n/* The macro BUFSIZE conflicts with a system macro in VxWorks */\n#define CONFBUFSIZE\t512\n\tint bufnum=0,i,ii;\n\tBUF_MEM *buff=NULL;\n\tchar *s,*p,*end;\n\tint again,n;\n\tlong eline=0;\n\tchar btmp[DECIMAL_SIZE(eline)+1];\n\tCONF_VALUE *v=NULL,*tv;\n\tCONF_VALUE *sv=NULL;\n\tchar *section=NULL,*buf;\n\tSTACK_OF(CONF_VALUE) *section_sk=NULL,*ts;\n\tchar *start,*psection,*pname;\n\tvoid *h = (void *)(conf->data);\n\n\tif ((buff=BUF_MEM_new()) == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB);\n\t\tgoto err;\n\t\t}\n\n\tsection=(char *)OPENSSL_malloc(10);\n\tif (section == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tstrcpy(section,\"default\");\n\n\tif (_CONF_new_data(conf) == 0)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tsv=_CONF_new_section(conf,section);\n\tif (sv == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\tCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n\t\tgoto err;\n\t\t}\n\tsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\n\n\tbufnum=0;\n\tagain=0;\n\tfor (;;)\n\t\t{\n\t\tif (!BUF_MEM_grow(buff,bufnum+CONFBUFSIZE))\n\t\t\t{\n\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp= &(buff->data[bufnum]);\n\t\t*p='\\0';\n\t\tBIO_gets(in, p, CONFBUFSIZE-1);\n\t\tp[CONFBUFSIZE-1]='\\0';\n\t\tii=i=strlen(p);\n\t\tif (i == 0 && !again) break;\n\t\tagain=0;\n\t\twhile (i > 0)\n\t\t\t{\n\t\t\tif ((p[i-1] != '\\r') && (p[i-1] != '\\n'))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\ti--;\n\t\t\t}\n\t\t/* we removed some trailing stuff so there is a new\n\t\t * line on the end. */\n\t\tif (ii && i == ii)\n\t\t\tagain=1; /* long line */\n\t\telse\n\t\t\t{\n\t\t\tp[i]='\\0';\n\t\t\teline++; /* another input line */\n\t\t\t}\n\n\t\t/* we now have a line with trailing \\r\\n removed */\n\n\t\t/* i is the number of bytes */\n\t\tbufnum+=i;\n\n\t\tv=NULL;\n\t\t/* check for line continuation */\n\t\tif (bufnum >= 1)\n\t\t\t{\n\t\t\t/* If we have bytes and the last char '\\\\' and\n\t\t\t * second last char is not '\\\\' */\n\t\t\tp= &(buff->data[bufnum-1]);\n\t\t\tif (IS_ESC(conf,p[0]) &&\n\t\t\t\t((bufnum <= 1) || !IS_ESC(conf,p[-1])))\n\t\t\t\t{\n\t\t\t\tbufnum--;\n\t\t\t\tagain=1;\n\t\t\t\t}\n\t\t\t}\n\t\tif (again) continue;\n\t\tbufnum=0;\n\t\tbuf=buff->data;\n\n\t\tclear_comments(conf, buf);\n\t\tn=strlen(buf);\n\t\ts=eat_ws(conf, buf);\n\t\tif (IS_EOF(conf,*s)) continue; /* blank line */\n\t\tif (*s == '[')\n\t\t\t{\n\t\t\tchar *ss;\n\n\t\t\ts++;\n\t\t\tstart=eat_ws(conf, s);\n\t\t\tss=start;\nagain:\n\t\t\tend=eat_alpha_numeric(conf, ss);\n\t\t\tp=eat_ws(conf, end);\n\t\t\tif (*p != ']')\n\t\t\t\t{\n\t\t\t\tif (*p != '\\0')\n\t\t\t\t\t{\n\t\t\t\t\tss=p;\n\t\t\t\t\tgoto again;\n\t\t\t\t\t}\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\tCONF_R_MISSING_CLOSE_SQUARE_BRACKET);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t*end='\\0';\n\t\t\tif (!str_copy(conf,NULL,&section,start)) goto err;\n\t\t\tif ((sv=_CONF_get_section(conf,section)) == NULL)\n\t\t\t\tsv=_CONF_new_section(conf,section);\n\t\t\tif (sv == NULL)\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\tCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\n\t\t\tcontinue;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tpname=s;\n\t\t\tpsection=NULL;\n\t\t\tend=eat_alpha_numeric(conf, s);\n\t\t\tif ((end[0] == ':') && (end[1] == ':'))\n\t\t\t\t{\n\t\t\t\t*end='\\0';\n\t\t\t\tend+=2;\n\t\t\t\tpsection=pname;\n\t\t\t\tpname=end;\n\t\t\t\tend=eat_alpha_numeric(conf, end);\n\t\t\t\t}\n\t\t\tp=eat_ws(conf, end);\n\t\t\tif (*p != '=')\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\tCONF_R_MISSING_EQUAL_SIGN);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t*end='\\0';\n\t\t\tp++;\n\t\t\tstart=eat_ws(conf, p);\n\t\t\twhile (!IS_EOF(conf,*p))\n\t\t\t\tp++;\n\t\t\tp--;\n\t\t\twhile ((p != start) && (IS_WS(conf,*p)))\n\t\t\t\tp--;\n\t\t\tp++;\n\t\t\t*p='\\0';\n\n\t\t\tif (!(v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE))))\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (psection == NULL) psection=section;\n\t\t\tv->name=(char *)OPENSSL_malloc(strlen(pname)+1);\n\t\t\tv->value=NULL;\n\t\t\tif (v->name == NULL)\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tstrcpy(v->name,pname);\n\t\t\tif (!str_copy(conf,psection,&(v->value),start)) goto err;\n\n\t\t\tif (strcmp(psection,section) != 0)\n\t\t\t\t{\n\t\t\t\tif ((tv=_CONF_get_section(conf,psection))\n\t\t\t\t\t== NULL)\n\t\t\t\t\ttv=_CONF_new_section(conf,psection);\n\t\t\t\tif (tv == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t   CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\tts=(STACK_OF(CONF_VALUE) *)tv->value;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ttv=sv;\n\t\t\t\tts=section_sk;\n\t\t\t\t}\n#if 1\n\t\t\tif (_CONF_add_string(conf, tv, v) == 0)\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n#else\n\t\t\tv->section=tv->section;\t\n\t\t\tif (!sk_CONF_VALUE_push(ts,v))\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tvv=(CONF_VALUE *)lh_insert(conf->data,v);\n\t\t\tif (vv != NULL)\n\t\t\t\t{\n\t\t\t\tsk_CONF_VALUE_delete_ptr(ts,vv);\n\t\t\t\tOPENSSL_free(vv->name);\n\t\t\t\tOPENSSL_free(vv->value);\n\t\t\t\tOPENSSL_free(vv);\n\t\t\t\t}\n#endif\n\t\t\tv=NULL;\n\t\t\t}\n\t\t}\n\tif (buff != NULL) BUF_MEM_free(buff);\n\tif (section != NULL) OPENSSL_free(section);\n\treturn(1);\nerr:\n\tif (buff != NULL) BUF_MEM_free(buff);\n\tif (section != NULL) OPENSSL_free(section);\n\tif (line != NULL) *line=eline;\n\tsprintf(btmp,\"%ld\",eline);\n\tERR_add_error_data(2,\"line \",btmp);\n\tif ((h != conf->data) && (conf->data != NULL))\n\t\t{\n\t\tCONF_free(conf->data);\n\t\tconf->data=NULL;\n\t\t}\n\tif (v != NULL)\n\t\t{\n\t\tif (v->name != NULL) OPENSSL_free(v->name);\n\t\tif (v->value != NULL) OPENSSL_free(v->value);\n\t\tif (v != NULL) OPENSSL_free(v);\n\t\t}\n\treturn(0);\n\t}", "patch_func_code": "static int def_load_bio(CONF *conf, BIO *in, long *line)\n\t{\n/* The macro BUFSIZE conflicts with a system macro in VxWorks */\n#define CONFBUFSIZE\t512\n\tint bufnum=0,i,ii;\n\tBUF_MEM *buff=NULL;\n\tchar *s,*p,*end;\n\tint again,n;\n\tlong eline=0;\n\tchar btmp[DECIMAL_SIZE(eline)+1];\n\tCONF_VALUE *v=NULL,*tv;\n\tCONF_VALUE *sv=NULL;\n\tchar *section=NULL,*buf;\n\tSTACK_OF(CONF_VALUE) *section_sk=NULL,*ts;\n\tchar *start,*psection,*pname;\n\tvoid *h = (void *)(conf->data);\n\n\tif ((buff=BUF_MEM_new()) == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB);\n\t\tgoto err;\n\t\t}\n\n\tsection=(char *)OPENSSL_malloc(10);\n\tif (section == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tBUF_strlcpy(section,\"default\",10);\n\n\tif (_CONF_new_data(conf) == 0)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tsv=_CONF_new_section(conf,section);\n\tif (sv == NULL)\n\t\t{\n\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\tCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n\t\tgoto err;\n\t\t}\n\tsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\n\n\tbufnum=0;\n\tagain=0;\n\tfor (;;)\n\t\t{\n\t\tif (!BUF_MEM_grow(buff,bufnum+CONFBUFSIZE))\n\t\t\t{\n\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\tp= &(buff->data[bufnum]);\n\t\t*p='\\0';\n\t\tBIO_gets(in, p, CONFBUFSIZE-1);\n\t\tp[CONFBUFSIZE-1]='\\0';\n\t\tii=i=strlen(p);\n\t\tif (i == 0 && !again) break;\n\t\tagain=0;\n\t\twhile (i > 0)\n\t\t\t{\n\t\t\tif ((p[i-1] != '\\r') && (p[i-1] != '\\n'))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\ti--;\n\t\t\t}\n\t\t/* we removed some trailing stuff so there is a new\n\t\t * line on the end. */\n\t\tif (ii && i == ii)\n\t\t\tagain=1; /* long line */\n\t\telse\n\t\t\t{\n\t\t\tp[i]='\\0';\n\t\t\teline++; /* another input line */\n\t\t\t}\n\n\t\t/* we now have a line with trailing \\r\\n removed */\n\n\t\t/* i is the number of bytes */\n\t\tbufnum+=i;\n\n\t\tv=NULL;\n\t\t/* check for line continuation */\n\t\tif (bufnum >= 1)\n\t\t\t{\n\t\t\t/* If we have bytes and the last char '\\\\' and\n\t\t\t * second last char is not '\\\\' */\n\t\t\tp= &(buff->data[bufnum-1]);\n\t\t\tif (IS_ESC(conf,p[0]) &&\n\t\t\t\t((bufnum <= 1) || !IS_ESC(conf,p[-1])))\n\t\t\t\t{\n\t\t\t\tbufnum--;\n\t\t\t\tagain=1;\n\t\t\t\t}\n\t\t\t}\n\t\tif (again) continue;\n\t\tbufnum=0;\n\t\tbuf=buff->data;\n\n\t\tclear_comments(conf, buf);\n\t\tn=strlen(buf);\n\t\ts=eat_ws(conf, buf);\n\t\tif (IS_EOF(conf,*s)) continue; /* blank line */\n\t\tif (*s == '[')\n\t\t\t{\n\t\t\tchar *ss;\n\n\t\t\ts++;\n\t\t\tstart=eat_ws(conf, s);\n\t\t\tss=start;\nagain:\n\t\t\tend=eat_alpha_numeric(conf, ss);\n\t\t\tp=eat_ws(conf, end);\n\t\t\tif (*p != ']')\n\t\t\t\t{\n\t\t\t\tif (*p != '\\0')\n\t\t\t\t\t{\n\t\t\t\t\tss=p;\n\t\t\t\t\tgoto again;\n\t\t\t\t\t}\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\tCONF_R_MISSING_CLOSE_SQUARE_BRACKET);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t*end='\\0';\n\t\t\tif (!str_copy(conf,NULL,&section,start)) goto err;\n\t\t\tif ((sv=_CONF_get_section(conf,section)) == NULL)\n\t\t\t\tsv=_CONF_new_section(conf,section);\n\t\t\tif (sv == NULL)\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\tCONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tsection_sk=(STACK_OF(CONF_VALUE) *)sv->value;\n\t\t\tcontinue;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tpname=s;\n\t\t\tpsection=NULL;\n\t\t\tend=eat_alpha_numeric(conf, s);\n\t\t\tif ((end[0] == ':') && (end[1] == ':'))\n\t\t\t\t{\n\t\t\t\t*end='\\0';\n\t\t\t\tend+=2;\n\t\t\t\tpsection=pname;\n\t\t\t\tpname=end;\n\t\t\t\tend=eat_alpha_numeric(conf, end);\n\t\t\t\t}\n\t\t\tp=eat_ws(conf, end);\n\t\t\tif (*p != '=')\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\tCONF_R_MISSING_EQUAL_SIGN);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t*end='\\0';\n\t\t\tp++;\n\t\t\tstart=eat_ws(conf, p);\n\t\t\twhile (!IS_EOF(conf,*p))\n\t\t\t\tp++;\n\t\t\tp--;\n\t\t\twhile ((p != start) && (IS_WS(conf,*p)))\n\t\t\t\tp--;\n\t\t\tp++;\n\t\t\t*p='\\0';\n\n\t\t\tif (!(v=(CONF_VALUE *)OPENSSL_malloc(sizeof(CONF_VALUE))))\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (psection == NULL) psection=section;\n\t\t\tv->name=(char *)OPENSSL_malloc(strlen(pname)+1);\n\t\t\tv->value=NULL;\n\t\t\tif (v->name == NULL)\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tBUF_strlcpy(v->name,pname,strlen(pname)+1);\n\t\t\tif (!str_copy(conf,psection,&(v->value),start)) goto err;\n\n\t\t\tif (strcmp(psection,section) != 0)\n\t\t\t\t{\n\t\t\t\tif ((tv=_CONF_get_section(conf,psection))\n\t\t\t\t\t== NULL)\n\t\t\t\t\ttv=_CONF_new_section(conf,psection);\n\t\t\t\tif (tv == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t   CONF_R_UNABLE_TO_CREATE_NEW_SECTION);\n\t\t\t\t\tgoto err;\n\t\t\t\t\t}\n\t\t\t\tts=(STACK_OF(CONF_VALUE) *)tv->value;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\ttv=sv;\n\t\t\t\tts=section_sk;\n\t\t\t\t}\n#if 1\n\t\t\tif (_CONF_add_string(conf, tv, v) == 0)\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n#else\n\t\t\tv->section=tv->section;\t\n\t\t\tif (!sk_CONF_VALUE_push(ts,v))\n\t\t\t\t{\n\t\t\t\tCONFerr(CONF_F_CONF_LOAD_BIO,\n\t\t\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tvv=(CONF_VALUE *)lh_insert(conf->data,v);\n\t\t\tif (vv != NULL)\n\t\t\t\t{\n\t\t\t\tsk_CONF_VALUE_delete_ptr(ts,vv);\n\t\t\t\tOPENSSL_free(vv->name);\n\t\t\t\tOPENSSL_free(vv->value);\n\t\t\t\tOPENSSL_free(vv);\n\t\t\t\t}\n#endif\n\t\t\tv=NULL;\n\t\t\t}\n\t\t}\n\tif (buff != NULL) BUF_MEM_free(buff);\n\tif (section != NULL) OPENSSL_free(section);\n\treturn(1);\nerr:\n\tif (buff != NULL) BUF_MEM_free(buff);\n\tif (section != NULL) OPENSSL_free(section);\n\tif (line != NULL) *line=eline;\n\tBIO_snprintf(btmp,sizeof btmp,\"%ld\",eline);\n\tERR_add_error_data(2,\"line \",btmp);\n\tif ((h != conf->data) && (conf->data != NULL))\n\t\t{\n\t\tCONF_free(conf->data);\n\t\tconf->data=NULL;\n\t\t}\n\tif (v != NULL)\n\t\t{\n\t\tif (v->name != NULL) OPENSSL_free(v->name);\n\t\tif (v->value != NULL) OPENSSL_free(v->value);\n\t\tif (v != NULL) OPENSSL_free(v);\n\t\t}\n\treturn(0);\n\t}", "before_change_lines": [30, 187, 242], "raw_before_change_lines": [30, 187, 242], "after_change_lines": [30, 187, 242], "raw_after_change_lines": [30, 187, 242], "bug_lines": [30, 187, 242], "added": [false, false, false], "idx": 463}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "14040----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_84642f9d0b6dbc42dcc13de5afb3685be960f244_1.json----rsa_blinding_convert", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_84642f9d0b6dbc42dcc13de5afb3685be960f244_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_84642f9d0b6dbc42dcc13de5afb3685be960f244_1.json", "function_name": "rsa_blinding_convert", "vul_func_code": "static int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f,\n\tBIGNUM *r, BN_CTX *ctx)\n{\n\tif (local)\n\t\treturn BN_BLINDING_convert_ex(f, NULL, b, ctx);\n\telse\n\t\t{\n\t\tint ret;\n\t\tCRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING);\n\t\tret = BN_BLINDING_convert_ex(f, r, b, ctx);\n\t\tCRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING);\n\t\treturn ret;\n\t\t}\n}", "patch_func_code": "static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,\n\tBN_CTX *ctx)\n\t{\n\tif (unblind == NULL)\n\t\t/* Local blinding: store the unblinding factor\n\t\t * in BN_BLINDING. */\n\t\treturn BN_BLINDING_convert_ex(f, NULL, b, ctx);\n\telse\n\t\t{\n\t\t/* Shared blinding: store the unblinding factor\n\t\t * outside BN_BLINDING. */\n\t\tint ret;\n\t\tCRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING);\n\t\tret = BN_BLINDING_convert_ex(f, unblind, b, ctx);\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING);\n\t\treturn ret;\n\t\t}\n\t}", "before_change_lines": [1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14], "raw_before_change_lines": [1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14], "after_change_lines": [1, 2, 3, 4, 6, 11, 14, 18], "raw_after_change_lines": [1, 2, 3, 4, 5, 6, 10, 11, 14, 18], "bug_lines": [1, 2, 3, 4, 8, 9, 10, 11, 12, 13, 14], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 464}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L2", "filepath_func": "14176----BUFFER_OVERRUN_L2----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_88e1b2a7a8c46de216d606056df8de59d967acfe_1.json----test_modexp_mont5", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_88e1b2a7a8c46de216d606056df8de59d967acfe_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_88e1b2a7a8c46de216d606056df8de59d967acfe_1.json", "function_name": "test_modexp_mont5", "vul_func_code": "static int test_modexp_mont5(void)\n{\n    BIGNUM *a = NULL, *p = NULL, *m = NULL, *d = NULL, *e = NULL;\n    BIGNUM *b = NULL, *n = NULL, *c = NULL;\n    BN_MONT_CTX *mont = NULL;\n    int st = 0;\n\n    if (!TEST_ptr(a = BN_new())\n            || !TEST_ptr(p = BN_new())\n            || !TEST_ptr(m = BN_new())\n            || !TEST_ptr(d = BN_new())\n            || !TEST_ptr(e = BN_new())\n            || !TEST_ptr(b = BN_new())\n            || !TEST_ptr(n = BN_new())\n            || !TEST_ptr(c = BN_new())\n            || !TEST_ptr(mont = BN_MONT_CTX_new()))\n        goto err;\n\n    BN_bntest_rand(m, 1024, 0, 1); /* must be odd for montgomery */\n    /* Zero exponent */\n    BN_bntest_rand(a, 1024, 0, 0);\n    BN_zero(p);\n    if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL)))\n        goto err;\n    if (!TEST_BN_eq_one(d))\n        goto err;\n\n    /* Regression test for carry bug in mulx4x_mont */\n    BN_hex2bn(&a,\n        \"7878787878787878787878787878787878787878787878787878787878787878\"\n        \"7878787878787878787878787878787878787878787878787878787878787878\"\n        \"7878787878787878787878787878787878787878787878787878787878787878\"\n        \"7878787878787878787878787878787878787878787878787878787878787878\");\n    BN_hex2bn(&b,\n        \"095D72C08C097BA488C5E439C655A192EAFB6380073D8C2664668EDDB4060744\"\n        \"E16E57FB4EDB9AE10A0CEFCDC28A894F689A128379DB279D48A2E20849D68593\"\n        \"9B7803BCF46CEBF5C533FB0DD35B080593DE5472E3FE5DB951B8BFF9B4CB8F03\"\n        \"9CC638A5EE8CDD703719F8000E6A9F63BEED5F2FCD52FF293EA05A251BB4AB81\");\n    BN_hex2bn(&n,\n        \"D78AF684E71DB0C39CFF4E64FB9DB567132CB9C50CC98009FEB820B26F2DED9B\"\n        \"91B9B5E2B83AE0AE4EB4E0523CA726BFBE969B89FD754F674CE99118C3F2D1C5\"\n        \"D81FDC7C54E02B60262B241D53C040E99E45826ECA37A804668E690E1AFC1CA4\"\n        \"2C9A15D84D4954425F0B7642FC0BD9D7B24E2618D2DCC9B729D944BADACFDDAF\");\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_mul_montgomery(c, a, b, mont, ctx);\n    BN_mod_mul_montgomery(d, b, a, mont, ctx);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Regression test for carry bug in sqr[x]8x_mont */\n    parse_bigBN(&n, bn1strings);\n    parse_bigBN(&a, bn2strings);\n    BN_free(b);\n    b = BN_dup(a);\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_mul_montgomery(c, a, a, mont, ctx);\n    BN_mod_mul_montgomery(d, a, b, mont, ctx);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Regression test for carry bug in bn_sqrx8x_internal */\n    {\n        static const char *ahex[] = {\n                      \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8FFEADBCFC4DAE7FFF908E92820306B\",\n            \"9544D954000000006C0000000000000000000000000000000000000000000000\",\n            \"00000000000000000000FF030202FFFFF8FFEBDBCFC4DAE7FFF908E92820306B\",\n            \"9544D954000000006C000000FF0302030000000000FFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01FC00FF02FFFFFFFF\",\n            \"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FCFD\",\n            \"FCFFFFFFFFFF000000000000000000FF0302030000000000FFFFFFFFFFFFFFFF\",\n            \"FF00FCFDFDFF030202FF00000000FFFFFFFFFFFFFFFFFF00FCFDFCFFFFFFFFFF\",\n            NULL\n        };\n        static const char *nhex[] = {\n                      \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8F8F8F8000000\",\n            \"00000010000000006C0000000000000000000000000000000000000000000000\",\n            \"00000000000000000000000000000000000000FFFFFFFFFFFFF8F8F8F8000000\",\n            \"00000010000000006C000000000000000000000000FFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFF000000000000000000000000000000000000FFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            NULL\n        };\n\n        parse_bigBN(&a, ahex);\n        parse_bigBN(&n, nhex);\n    }\n    BN_free(b);\n    b = BN_dup(a);\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_mul_montgomery(c, a, a, mont, ctx);\n    BN_mod_mul_montgomery(d, a, b, mont, ctx);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Regression test for bug in rsaz_1024_mul_avx2 */\n    BN_hex2bn(&a,\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020DF\");\n    BN_hex2bn(&b,\n        \"2020202020202020202020202020202020202020202020202020202020202020\"\n        \"2020202020202020202020202020202020202020202020202020202020202020\"\n        \"20202020202020FF202020202020202020202020202020202020202020202020\"\n        \"2020202020202020202020202020202020202020202020202020202020202020\");\n    BN_hex2bn(&n,\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020FF\");\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_exp_mont_consttime(c, a, b, n, ctx, mont);\n    BN_mod_exp_mont(d, a, b, n, ctx, mont);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Zero input */\n    BN_bntest_rand(p, 1024, 0, 0);\n    BN_zero(a);\n    if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL))\n            || !TEST_BN_eq_zero(d))\n        goto err;\n\n    /*\n     * Craft an input whose Montgomery representation is 1, i.e., shorter\n     * than the modulus m, in order to test the const time precomputation\n     * scattering/gathering.\n     */\n    BN_one(a);\n    BN_MONT_CTX_set(mont, m, ctx);\n    if (!TEST_true(BN_from_montgomery(e, a, mont, ctx))\n            || !TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL))\n            || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx))\n            || !TEST_BN_eq(a, d))\n        goto err;\n\n    /* Finally, some regular test vectors. */\n    BN_bntest_rand(e, 1024, 0, 0);\n    if (!TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL))\n            || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx))\n            || !TEST_BN_eq(a, d))\n        goto err;\n\n    st = 1;\n\nerr:\n    BN_MONT_CTX_free(mont);\n    BN_free(a);\n    BN_free(p);\n    BN_free(m);\n    BN_free(d);\n    BN_free(e);\n    BN_free(b);\n    BN_free(n);\n    BN_free(c);\n    return st;\n}", "patch_func_code": "static int test_modexp_mont5(void)\n{\n    BIGNUM *a = NULL, *p = NULL, *m = NULL, *d = NULL, *e = NULL;\n    BIGNUM *b = NULL, *n = NULL, *c = NULL;\n    BN_MONT_CTX *mont = NULL;\n    int st = 0;\n\n    if (!TEST_ptr(a = BN_new())\n            || !TEST_ptr(p = BN_new())\n            || !TEST_ptr(m = BN_new())\n            || !TEST_ptr(d = BN_new())\n            || !TEST_ptr(e = BN_new())\n            || !TEST_ptr(b = BN_new())\n            || !TEST_ptr(n = BN_new())\n            || !TEST_ptr(c = BN_new())\n            || !TEST_ptr(mont = BN_MONT_CTX_new()))\n        goto err;\n\n    BN_bntest_rand(m, 1024, 0, 1); /* must be odd for montgomery */\n    /* Zero exponent */\n    BN_bntest_rand(a, 1024, 0, 0);\n    BN_zero(p);\n    if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL)))\n        goto err;\n    if (!TEST_BN_eq_one(d))\n        goto err;\n\n    /* Regression test for carry bug in mulx4x_mont */\n    BN_hex2bn(&a,\n        \"7878787878787878787878787878787878787878787878787878787878787878\"\n        \"7878787878787878787878787878787878787878787878787878787878787878\"\n        \"7878787878787878787878787878787878787878787878787878787878787878\"\n        \"7878787878787878787878787878787878787878787878787878787878787878\");\n    BN_hex2bn(&b,\n        \"095D72C08C097BA488C5E439C655A192EAFB6380073D8C2664668EDDB4060744\"\n        \"E16E57FB4EDB9AE10A0CEFCDC28A894F689A128379DB279D48A2E20849D68593\"\n        \"9B7803BCF46CEBF5C533FB0DD35B080593DE5472E3FE5DB951B8BFF9B4CB8F03\"\n        \"9CC638A5EE8CDD703719F8000E6A9F63BEED5F2FCD52FF293EA05A251BB4AB81\");\n    BN_hex2bn(&n,\n        \"D78AF684E71DB0C39CFF4E64FB9DB567132CB9C50CC98009FEB820B26F2DED9B\"\n        \"91B9B5E2B83AE0AE4EB4E0523CA726BFBE969B89FD754F674CE99118C3F2D1C5\"\n        \"D81FDC7C54E02B60262B241D53C040E99E45826ECA37A804668E690E1AFC1CA4\"\n        \"2C9A15D84D4954425F0B7642FC0BD9D7B24E2618D2DCC9B729D944BADACFDDAF\");\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_mul_montgomery(c, a, b, mont, ctx);\n    BN_mod_mul_montgomery(d, b, a, mont, ctx);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Regression test for carry bug in sqr[x]8x_mont */\n    parse_bigBN(&n, bn1strings);\n    parse_bigBN(&a, bn2strings);\n    BN_free(b);\n    b = BN_dup(a);\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_mul_montgomery(c, a, a, mont, ctx);\n    BN_mod_mul_montgomery(d, a, b, mont, ctx);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Regression test for carry bug in bn_sqrx8x_internal */\n    {\n        static const char *ahex[] = {\n                      \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8FFEADBCFC4DAE7FFF908E92820306B\",\n            \"9544D954000000006C0000000000000000000000000000000000000000000000\",\n            \"00000000000000000000FF030202FFFFF8FFEBDBCFC4DAE7FFF908E92820306B\",\n            \"9544D954000000006C000000FF0302030000000000FFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF01FC00FF02FFFFFFFF\",\n            \"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FCFD\",\n            \"FCFFFFFFFFFF000000000000000000FF0302030000000000FFFFFFFFFFFFFFFF\",\n            \"FF00FCFDFDFF030202FF00000000FFFFFFFFFFFFFFFFFF00FCFDFCFFFFFFFFFF\",\n            NULL\n        };\n        static const char *nhex[] = {\n                      \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF8F8F8F8000000\",\n            \"00000010000000006C0000000000000000000000000000000000000000000000\",\n            \"00000000000000000000000000000000000000FFFFFFFFFFFFF8F8F8F8000000\",\n            \"00000010000000006C000000000000000000000000FFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFF000000000000000000000000000000000000FFFFFFFFFFFFFFFF\",\n            \"FFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n            NULL\n        };\n\n        parse_bigBN(&a, ahex);\n        parse_bigBN(&n, nhex);\n    }\n    BN_free(b);\n    b = BN_dup(a);\n    BN_MONT_CTX_set(mont, n, ctx);\n    if (!TEST_true(BN_mod_mul_montgomery(c, a, a, mont, ctx))\n            || !TEST_true(BN_mod_mul_montgomery(d, a, b, mont, ctx))\n            || !TEST_BN_eq(c, d))\n        goto err;\n\n    /* Regression test for bug in BN_from_montgomery_word */\n    BN_hex2bn(&a,\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n    BN_hex2bn(&n,\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n    BN_MONT_CTX_set(mont, n, ctx);\n    if (!TEST_false(BN_mod_mul_montgomery(d, a, a, mont, ctx)))\n        goto err;\n\n    /* Regression test for bug in rsaz_1024_mul_avx2 */\n    BN_hex2bn(&a,\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020DF\");\n    BN_hex2bn(&b,\n        \"2020202020202020202020202020202020202020202020202020202020202020\"\n        \"2020202020202020202020202020202020202020202020202020202020202020\"\n        \"20202020202020FF202020202020202020202020202020202020202020202020\"\n        \"2020202020202020202020202020202020202020202020202020202020202020\");\n    BN_hex2bn(&n,\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"\n        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF2020202020FF\");\n    BN_MONT_CTX_set(mont, n, ctx);\n    BN_mod_exp_mont_consttime(c, a, b, n, ctx, mont);\n    BN_mod_exp_mont(d, a, b, n, ctx, mont);\n    if (!TEST_BN_eq(c, d))\n        goto err;\n\n    /* Zero input */\n    BN_bntest_rand(p, 1024, 0, 0);\n    BN_zero(a);\n    if (!TEST_true(BN_mod_exp_mont_consttime(d, a, p, m, ctx, NULL))\n            || !TEST_BN_eq_zero(d))\n        goto err;\n\n    /*\n     * Craft an input whose Montgomery representation is 1, i.e., shorter\n     * than the modulus m, in order to test the const time precomputation\n     * scattering/gathering.\n     */\n    BN_one(a);\n    BN_MONT_CTX_set(mont, m, ctx);\n    if (!TEST_true(BN_from_montgomery(e, a, mont, ctx))\n            || !TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL))\n            || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx))\n            || !TEST_BN_eq(a, d))\n        goto err;\n\n    /* Finally, some regular test vectors. */\n    BN_bntest_rand(e, 1024, 0, 0);\n    if (!TEST_true(BN_mod_exp_mont_consttime(d, e, p, m, ctx, NULL))\n            || !TEST_true(BN_mod_exp_simple(a, e, p, m, ctx))\n            || !TEST_BN_eq(a, d))\n        goto err;\n\n    st = 1;\n\nerr:\n    BN_MONT_CTX_free(mont);\n    BN_free(a);\n    BN_free(p);\n    BN_free(m);\n    BN_free(d);\n    BN_free(e);\n    BN_free(b);\n    BN_free(n);\n    BN_free(c);\n    return st;\n}", "before_change_lines": [100, 101, 102], "raw_before_change_lines": [100, 101, 102], "after_change_lines": [100, 101, 102, 103, 106, 107, 108, 109, 110, 111, 112, 113, 114], "raw_after_change_lines": [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114], "bug_lines": [100, 101, 102], "added": [false, false, false], "idx": 465}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "14194----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_89af2271589c85f8ef8b2840a3ec24afa77611e0_1.json----CRYPTO_secure_malloc", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_89af2271589c85f8ef8b2840a3ec24afa77611e0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_89af2271589c85f8ef8b2840a3ec24afa77611e0_1.json", "function_name": "CRYPTO_secure_malloc", "vul_func_code": "void *CRYPTO_secure_malloc(size_t num, const char *file, int line)\n{\n#ifdef IMPLEMENTED\n    void *ret;\n    size_t actual_size;\n\n    if (!secure_mem_initialized) {\n        too_late = 1;\n        return CRYPTO_malloc(num, file, line);\n    }\n    CRYPTO_THREAD_write_lock(sec_malloc_lock);\n    ret = sh_malloc(num);\n    actual_size = ret ? sh_actual_size(ret) : 0;\n    secure_mem_used += actual_size;\n    CRYPTO_THREAD_unlock(sec_malloc_lock);\n    return ret;\n#else\n    return CRYPTO_malloc(num, file, line);\n#endif /* IMPLEMENTED */\n}", "patch_func_code": "void *CRYPTO_secure_malloc(size_t num, const char *file, int line)\n{\n#ifdef IMPLEMENTED\n    void *ret;\n    size_t actual_size;\n\n    if (!secure_mem_initialized) {\n        return CRYPTO_malloc(num, file, line);\n    }\n    CRYPTO_THREAD_write_lock(sec_malloc_lock);\n    ret = sh_malloc(num);\n    actual_size = ret ? sh_actual_size(ret) : 0;\n    secure_mem_used += actual_size;\n    CRYPTO_THREAD_unlock(sec_malloc_lock);\n    return ret;\n#else\n    return CRYPTO_malloc(num, file, line);\n#endif /* IMPLEMENTED */\n}", "before_change_lines": [8], "raw_before_change_lines": [8], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [8], "added": [false], "idx": 466}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "14239----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_8b2e20c3177254a35200689b718a15a70dd18ff6_1.json----tls1_check_curve", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_8b2e20c3177254a35200689b718a15a70dd18ff6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_8b2e20c3177254a35200689b718a15a70dd18ff6_1.json", "function_name": "tls1_check_curve", "vul_func_code": "int tls1_check_curve(SSL *s, const unsigned char *p, size_t len)\n\t{\n\tconst unsigned char *curves;\n\tsize_t curveslen, i;\n\tunsigned int suiteb_flags = tls1_suiteb(s);\n\tif (len != 3 || p[0] != NAMED_CURVE_TYPE)\n\t\treturn 0;\n\t/* Check curve matches Suite B preferences */\n\tif (suiteb_flags)\n\t\t{\n\t\tunsigned long cid = s->s3->tmp.new_cipher->id;\n\t\tif (p[1])\n\t\t\treturn 0;\n\t\tif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\n\t\t\t{\n\t\t\tif (p[2] != TLSEXT_curve_P_256)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\telse if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\n\t\t\t{\n\t\t\tif (p[2] != TLSEXT_curve_P_384)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\telse\t/* Should never happen */\n\t\t\treturn 0;\n\t\t}\n\ttls1_get_curvelist(s, 0, &curves, &curveslen);\n\tfor (i = 0; i < curveslen; i += 2, curves += 2)\n\t\t{\n\t\tif (p[1] == curves[0] && p[2] == curves[1])\n\t\t\treturn tls_curve_allowed(s, p + 1, SSL_SECOP_CURVE_CHECK);\n\t\t}\n\treturn 0;\n\t}", "patch_func_code": "int tls1_check_curve(SSL *s, const unsigned char *p, size_t len)\n\t{\n\tconst unsigned char *curves;\n\tsize_t num_curves, i;\n\tunsigned int suiteb_flags = tls1_suiteb(s);\n\tif (len != 3 || p[0] != NAMED_CURVE_TYPE)\n\t\treturn 0;\n\t/* Check curve matches Suite B preferences */\n\tif (suiteb_flags)\n\t\t{\n\t\tunsigned long cid = s->s3->tmp.new_cipher->id;\n\t\tif (p[1])\n\t\t\treturn 0;\n\t\tif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\n\t\t\t{\n\t\t\tif (p[2] != TLSEXT_curve_P_256)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\telse if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\n\t\t\t{\n\t\t\tif (p[2] != TLSEXT_curve_P_384)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\telse\t/* Should never happen */\n\t\t\treturn 0;\n\t\t}\n\tif (!tls1_get_curvelist(s, 0, &curves, &num_curves))\n\t\treturn 0;\n\tfor (i = 0; i < num_curves; i++, curves += 2)\n\t\t{\n\t\tif (p[1] == curves[0] && p[2] == curves[1])\n\t\t\treturn tls_curve_allowed(s, p + 1, SSL_SECOP_CURVE_CHECK);\n\t\t}\n\treturn 0;\n\t}", "before_change_lines": [4, 27, 28], "raw_before_change_lines": [4, 27, 28], "after_change_lines": [4, 27, 28, 29], "raw_after_change_lines": [4, 27, 28, 29], "bug_lines": [4, 27, 28], "added": [false, false, false], "idx": 467}
{"project": "openssl", "vul_type": "DEAD_STORE", "filepath_func": "14286----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_8c9e8f9ee7fa46060aeb241db1af24ee7ecffb68_1.json----help_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_8c9e8f9ee7fa46060aeb241db1af24ee7ecffb68_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_8c9e8f9ee7fa46060aeb241db1af24ee7ecffb68_1.json", "function_name": "help_main", "vul_func_code": "int help_main(int argc, char **argv)\n{\n    FUNCTION *fp;\n    int i, nl;\n    FUNC_TYPE tp;\n    char *prog;\n    HELPLIST_CHOICE o;\n\n    prog = opt_init(argc, argv, help_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        default:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            return 1;\n        case OPT_HELP:\n            opt_help(help_options);\n            return 0;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (argc != 0) {\n        BIO_printf(bio_err, \"Usage: %s\\n\", prog);\n        return 1;\n    }\n\n    BIO_printf(bio_err, \"\\nStandard commands\");\n    i = 0;\n    tp = FT_none;\n    for (fp = functions; fp->name != NULL; fp++) {\n        nl = 0;\n        if (((i++) % COLUMNS) == 0) {\n            BIO_printf(bio_err, \"\\n\");\n            nl = 1;\n        }\n        if (fp->type != tp) {\n            tp = fp->type;\n            if (!nl)\n                BIO_printf(bio_err, \"\\n\");\n            if (tp == FT_md) {\n                i = 1;\n                BIO_printf(bio_err,\n                           \"\\nMessage Digest commands (see the `dgst' command for more details)\\n\");\n            } else if (tp == FT_cipher) {\n                i = 1;\n                BIO_printf(bio_err,\n                           \"\\nCipher commands (see the `enc' command for more details)\\n\");\n            }\n        }\n        BIO_printf(bio_err, FORMAT, fp->name);\n    }\n    BIO_printf(bio_err, \"\\n\\n\");\n    return 0;\n}", "patch_func_code": "int help_main(int argc, char **argv)\n{\n    FUNCTION *fp;\n    int i, nl;\n    FUNC_TYPE tp;\n    char *prog;\n    HELPLIST_CHOICE o;\n\n    prog = opt_init(argc, argv, help_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        default:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            return 1;\n        case OPT_HELP:\n            opt_help(help_options);\n            return 0;\n        }\n    }\n    argc = opt_num_rest();\n\n    if (argc != 0) {\n        BIO_printf(bio_err, \"Usage: %s\\n\", prog);\n        return 1;\n    }\n\n    BIO_printf(bio_err, \"\\nStandard commands\");\n    i = 0;\n    tp = FT_none;\n    for (fp = functions; fp->name != NULL; fp++) {\n        nl = 0;\n        if (((i++) % COLUMNS) == 0) {\n            BIO_printf(bio_err, \"\\n\");\n            nl = 1;\n        }\n        if (fp->type != tp) {\n            tp = fp->type;\n            if (!nl)\n                BIO_printf(bio_err, \"\\n\");\n            if (tp == FT_md) {\n                i = 1;\n                BIO_printf(bio_err,\n                           \"\\nMessage Digest commands (see the `dgst' command for more details)\\n\");\n            } else if (tp == FT_cipher) {\n                i = 1;\n                BIO_printf(bio_err,\n                           \"\\nCipher commands (see the `enc' command for more details)\\n\");\n            }\n        }\n        BIO_printf(bio_err, FORMAT, fp->name);\n    }\n    BIO_printf(bio_err, \"\\n\\n\");\n    return 0;\n}", "before_change_lines": [21], "raw_before_change_lines": [21], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [21], "added": [false], "idx": 468}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "14429----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_9197c97670ebeac4caaf69a132edb9ff7dbaf7e6_1.json----add_DN_object", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_9197c97670ebeac4caaf69a132edb9ff7dbaf7e6_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_9197c97670ebeac4caaf69a132edb9ff7dbaf7e6_1.json", "function_name": "add_DN_object", "vul_func_code": "static int add_DN_object(X509_NAME *n, char *text, char *def, char *value,\n\t     int nid, int n_min, int n_max, unsigned long chtype, int mval)\n\t{\n\tint i,ret=0;\n\tMS_STATIC char buf[1024];\nstart:\n\tif (!batch) BIO_printf(bio_err,\"%s [%s]:\",text,def);\n\t(void)BIO_flush(bio_err);\n\tif(value != NULL)\n\t\t{\n\t\tOPENSSL_assert(strlen(value) < sizeof buf-2);\n\t\tstrcpy(buf,value);\n\t\tstrcat(buf,\"\\n\");\n\t\tBIO_printf(bio_err,\"%s\\n\",value);\n\t\t}\n\telse\n\t\t{\n\t\tbuf[0]='\\0';\n\t\tif (!batch)\n\t\t\t{\n\t\t\tfgets(buf,sizeof buf,stdin);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tbuf[0] = '\\n';\n\t\t\tbuf[1] = '\\0';\n\t\t\t}\n\t\t}\n\n\tif (buf[0] == '\\0') return(0);\n\telse if (buf[0] == '\\n')\n\t\t{\n\t\tif ((def == NULL) || (def[0] == '\\0'))\n\t\t\treturn(1);\n\t\tstrcpy(buf,def);\n\t\tstrcat(buf,\"\\n\");\n\t\t}\n\telse if ((buf[0] == '.') && (buf[1] == '\\n')) return(1);\n\n\ti=strlen(buf);\n\tif (buf[i-1] != '\\n')\n\t\t{\n\t\tBIO_printf(bio_err,\"weird input :-(\\n\");\n\t\treturn(0);\n\t\t}\n\tbuf[--i]='\\0';\n#ifdef CHARSET_EBCDIC\n\tebcdic2ascii(buf, buf, i);\n#endif\n\tif(!req_check_len(i, n_min, n_max)) goto start;\n\tif (!X509_NAME_add_entry_by_NID(n,nid, chtype,\n\t\t\t\t(unsigned char *) buf, -1,-1,mval)) goto err;\n\tret=1;\nerr:\n\treturn(ret);\n\t}", "patch_func_code": "static int add_DN_object(X509_NAME *n, char *text, char *def, char *value,\n\t     int nid, int n_min, int n_max, unsigned long chtype, int mval)\n\t{\n\tint i,ret=0;\n\tMS_STATIC char buf[1024];\nstart:\n\tif (!batch) BIO_printf(bio_err,\"%s [%s]:\",text,def);\n\t(void)BIO_flush(bio_err);\n\tif(value != NULL)\n\t\t{\n\t\tBUF_strlcpy(buf,value,sizeof buf);\n\t\tBUF_strlcat(buf,\"\\n\",sizeof buf);\n\t\tBIO_printf(bio_err,\"%s\\n\",value);\n\t\t}\n\telse\n\t\t{\n\t\tbuf[0]='\\0';\n\t\tif (!batch)\n\t\t\t{\n\t\t\tfgets(buf,sizeof buf,stdin);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tbuf[0] = '\\n';\n\t\t\tbuf[1] = '\\0';\n\t\t\t}\n\t\t}\n\n\tif (buf[0] == '\\0') return(0);\n\telse if (buf[0] == '\\n')\n\t\t{\n\t\tif ((def == NULL) || (def[0] == '\\0'))\n\t\t\treturn(1);\n\t\tBUF_strlcpy(buf,def,sizeof buf);\n\t\tBUF_strlcat(buf,\"\\n\",sizeof buf);\n\t\t}\n\telse if ((buf[0] == '.') && (buf[1] == '\\n')) return(1);\n\n\ti=strlen(buf);\n\tif (buf[i-1] != '\\n')\n\t\t{\n\t\tBIO_printf(bio_err,\"weird input :-(\\n\");\n\t\treturn(0);\n\t\t}\n\tbuf[--i]='\\0';\n#ifdef CHARSET_EBCDIC\n\tebcdic2ascii(buf, buf, i);\n#endif\n\tif(!req_check_len(i, n_min, n_max)) goto start;\n\tif (!X509_NAME_add_entry_by_NID(n,nid, chtype,\n\t\t\t\t(unsigned char *) buf, -1,-1,mval)) goto err;\n\tret=1;\nerr:\n\treturn(ret);\n\t}", "before_change_lines": [11, 12, 13, 35, 36], "raw_before_change_lines": [11, 12, 13, 35, 36], "after_change_lines": [11, 12, 34, 35], "raw_after_change_lines": [11, 12, 34, 35], "bug_lines": [11, 12, 13, 35, 36], "added": [false, false, false, false, false], "idx": 469}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "14439----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_91d061b16a4fa0b2daed124f201c844134860ced_1.json----ssl_add_serverhello_tlsext", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_91d061b16a4fa0b2daed124f201c844134860ced_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_91d061b16a4fa0b2daed124f201c844134860ced_1.json", "function_name": "ssl_add_serverhello_tlsext", "vul_func_code": "int ssl_add_serverhello_tlsext(SSL *s, WPACKET *pkt, int *al)\n{\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    int next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA);\n    using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    if (!WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_set_flags(pkt, WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (s->s3->send_connection_binding &&\n            !ssl_add_serverhello_renegotiate_ext(s, pkt)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* Only add RI for SSLv3 */\n    if (s->version == SSL3_VERSION)\n        goto done;\n\n    if (!s->hit && s->servername_done == 1\n            && s->session->tlsext_hostname != NULL) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        const unsigned char *plist;\n        size_t plistlen;\n        /*\n         * Add TLS extension ECPointFormats to the ServerHello message\n         */\n        tls1_get_formatlist(s, &plist, &plistlen);\n\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_ec_point_formats)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_sub_memcpy_u8(pkt, plist, plistlen)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n    /*\n     * Currently the server should not respond with a SupportedCurves\n     * extension\n     */\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->tlsext_ticket_expected && tls_use_ticket(s)) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_session_ticket)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    } else {\n        /*\n         * if we don't add the above TLSEXT, we can't add a session ticket\n         * later\n         */\n        s->tlsext_ticket_expected = 0;\n    }\n\n    if (s->tlsext_status_expected) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && s->srtp_profile) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_use_srtp)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_put_bytes_u16(pkt, 2)\n                || !WPACKET_put_bytes_u16(pkt, s->srtp_profile->id)\n                || !WPACKET_put_bytes_u8(pkt, 0)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n#endif\n\n    if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\n        const unsigned char cryptopro_ext[36] = {\n            0xfd, 0xe8,         /* 65000 */\n            0x00, 0x20,         /* 32 bytes length */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n        if (!WPACKET_memcpy(pkt, cryptopro_ext, sizeof(cryptopro_ext))) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    next_proto_neg_seen = s->s3->next_proto_neg_seen;\n    s->s3->next_proto_neg_seen = 0;\n    if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\n        const unsigned char *npa;\n        unsigned int npalen;\n        int r;\n\n        r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\n                                              s->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (r == SSL_TLSEXT_ERR_OK) {\n            if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_next_proto_neg)\n                    || !WPACKET_sub_memcpy_u16(pkt, npa, npalen)) {\n                SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n            s->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n\n    if (s->version == TLS1_3_VERSION) {\n        unsigned char *encodedPoint;\n        size_t encoded_pt_len = 0;\n        EVP_PKEY *ckey = NULL, *skey = NULL;\n\n        ckey = s->s3->peer_tmp;\n        if (ckey == NULL) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_put_bytes_u16(pkt, s->s3->group_id)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n\n        skey = ssl_generate_pkey(ckey);\n\n        /* Generate encoding of server key */\n        encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(skey, &encodedPoint);\n        if (encoded_pt_len == 0) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_EC_LIB);\n            EVP_PKEY_free(skey);\n            return 0;\n        }\n\n        if (!WPACKET_sub_memcpy_u16(pkt, encodedPoint, encoded_pt_len)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            EVP_PKEY_free(skey);\n            OPENSSL_free(encodedPoint);\n            return 0;\n        }\n\n        s->s3->tmp.pkey = skey;\n        OPENSSL_free(encodedPoint);\n    }\n\n    if (!custom_ext_add(s, 1, pkt, al)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {\n        /*\n         * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n         * for other cases too.\n         */\n        if (s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n        else {\n            if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_encrypt_then_mac)\n                    || !WPACKET_put_bytes_u16(pkt, 0)) {\n                SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        }\n    }\n    if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_extended_master_secret)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n    if (s->s3->alpn_selected != NULL) {\n        if (!WPACKET_put_bytes_u16(pkt,\n                    TLSEXT_TYPE_application_layer_protocol_negotiation)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_sub_memcpy_u8(pkt, s->s3->alpn_selected,\n                                          s->s3->alpn_selected_len)\n                || !WPACKET_close(pkt)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n done:\n    if (!WPACKET_close(pkt)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    return 1;\n}", "patch_func_code": "int ssl_add_serverhello_tlsext(SSL *s, WPACKET *pkt, int *al)\n{\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    int next_proto_neg_seen;\n#endif\n#ifndef OPENSSL_NO_EC\n    unsigned long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;\n    unsigned long alg_a = s->s3->tmp.new_cipher->algorithm_auth;\n    int using_ecc = (alg_k & SSL_kECDHE) || (alg_a & SSL_aECDSA);\n    using_ecc = using_ecc && (s->session->tlsext_ecpointformatlist != NULL);\n#endif\n\n    if (!WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_set_flags(pkt, WPACKET_FLAGS_ABANDON_ON_ZERO_LENGTH)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (s->s3->send_connection_binding &&\n            !ssl_add_serverhello_renegotiate_ext(s, pkt)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    /* Only add RI for SSLv3 */\n    if (s->version == SSL3_VERSION)\n        goto done;\n\n    if (!s->hit && s->servername_done == 1\n            && s->session->tlsext_hostname != NULL) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_server_name)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n#ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        const unsigned char *plist;\n        size_t plistlen;\n        /*\n         * Add TLS extension ECPointFormats to the ServerHello message\n         */\n        tls1_get_formatlist(s, &plist, &plistlen);\n\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_ec_point_formats)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_sub_memcpy_u8(pkt, plist, plistlen)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n    /*\n     * Currently the server should not respond with a SupportedCurves\n     * extension\n     */\n#endif                          /* OPENSSL_NO_EC */\n\n    if (s->tlsext_ticket_expected && tls_use_ticket(s)) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_session_ticket)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    } else {\n        /*\n         * if we don't add the above TLSEXT, we can't add a session ticket\n         * later\n         */\n        s->tlsext_ticket_expected = 0;\n    }\n\n    if (s->tlsext_status_expected) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_status_request)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && s->srtp_profile) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_use_srtp)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_put_bytes_u16(pkt, 2)\n                || !WPACKET_put_bytes_u16(pkt, s->srtp_profile->id)\n                || !WPACKET_put_bytes_u8(pkt, 0)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n#endif\n\n    if (((s->s3->tmp.new_cipher->id & 0xFFFF) == 0x80\n         || (s->s3->tmp.new_cipher->id & 0xFFFF) == 0x81)\n        && (SSL_get_options(s) & SSL_OP_CRYPTOPRO_TLSEXT_BUG)) {\n        const unsigned char cryptopro_ext[36] = {\n            0xfd, 0xe8,         /* 65000 */\n            0x00, 0x20,         /* 32 bytes length */\n            0x30, 0x1e, 0x30, 0x08, 0x06, 0x06, 0x2a, 0x85,\n            0x03, 0x02, 0x02, 0x09, 0x30, 0x08, 0x06, 0x06,\n            0x2a, 0x85, 0x03, 0x02, 0x02, 0x16, 0x30, 0x08,\n            0x06, 0x06, 0x2a, 0x85, 0x03, 0x02, 0x02, 0x17\n        };\n        if (!WPACKET_memcpy(pkt, cryptopro_ext, sizeof(cryptopro_ext))) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    next_proto_neg_seen = s->s3->next_proto_neg_seen;\n    s->s3->next_proto_neg_seen = 0;\n    if (next_proto_neg_seen && s->ctx->next_protos_advertised_cb) {\n        const unsigned char *npa;\n        unsigned int npalen;\n        int r;\n\n        r = s->ctx->next_protos_advertised_cb(s, &npa, &npalen,\n                                              s->\n                                              ctx->next_protos_advertised_cb_arg);\n        if (r == SSL_TLSEXT_ERR_OK) {\n            if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_next_proto_neg)\n                    || !WPACKET_sub_memcpy_u16(pkt, npa, npalen)) {\n                SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n            s->s3->next_proto_neg_seen = 1;\n        }\n    }\n#endif\n\n    if (s->version == TLS1_3_VERSION) {\n        unsigned char *encodedPoint;\n        size_t encoded_pt_len = 0;\n        EVP_PKEY *ckey = NULL, *skey = NULL;\n\n        ckey = s->s3->peer_tmp;\n        if (ckey == NULL) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_key_share)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_put_bytes_u16(pkt, s->s3->group_id)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n\n        skey = ssl_generate_pkey(ckey);\n\n        /* Generate encoding of server key */\n        encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(skey, &encodedPoint);\n        if (encoded_pt_len == 0) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_EC_LIB);\n            EVP_PKEY_free(skey);\n            return 0;\n        }\n\n        if (!WPACKET_sub_memcpy_u16(pkt, encodedPoint, encoded_pt_len)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            EVP_PKEY_free(skey);\n            OPENSSL_free(encodedPoint);\n            return 0;\n        }\n        OPENSSL_free(encodedPoint);\n\n        s->s3->tmp.pkey = skey;\n\n        if (ssl_derive(s, skey, ckey, 1) == 0) {\n            *al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n    if (!custom_ext_add(s, 1, pkt, al)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {\n        /*\n         * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n         * for other cases too.\n         */\n        if (s->s3->tmp.new_cipher->algorithm_mac == SSL_AEAD\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n            || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n        else {\n            if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_encrypt_then_mac)\n                    || !WPACKET_put_bytes_u16(pkt, 0)) {\n                SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n        }\n    }\n    if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        if (!WPACKET_put_bytes_u16(pkt, TLSEXT_TYPE_extended_master_secret)\n                || !WPACKET_put_bytes_u16(pkt, 0)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n    if (s->s3->alpn_selected != NULL) {\n        if (!WPACKET_put_bytes_u16(pkt,\n                    TLSEXT_TYPE_application_layer_protocol_negotiation)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_start_sub_packet_u16(pkt)\n                || !WPACKET_sub_memcpy_u8(pkt, s->s3->alpn_selected,\n                                          s->s3->alpn_selected_len)\n                || !WPACKET_close(pkt)\n                || !WPACKET_close(pkt)) {\n            SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n done:\n    if (!WPACKET_close(pkt)) {\n        SSLerr(SSL_F_SSL_ADD_SERVERHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    return 1;\n}", "before_change_lines": [171], "raw_before_change_lines": [171], "after_change_lines": [169, 173, 174, 175, 176, 177], "raw_after_change_lines": [169, 172, 173, 174, 175, 176, 177], "bug_lines": [171], "added": [false], "idx": 470}
{"project": "openssl", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "14584----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_976c84f9ac3987f322f7dba225e862836cfe0bb5_1.json----EVP_VerifyFinal", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_976c84f9ac3987f322f7dba225e862836cfe0bb5_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_976c84f9ac3987f322f7dba225e862836cfe0bb5_1.json", "function_name": "EVP_VerifyFinal", "vul_func_code": "int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,\n\t     unsigned int siglen, EVP_PKEY *pkey)\n\t{\n\tunsigned char m[EVP_MAX_MD_SIZE];\n\tunsigned int m_len;\n\tint i,ok=0,v;\n\tMS_STATIC EVP_MD_CTX tmp_ctx;\n\n\tEVP_MD_CTX_init(&tmp_ctx);\n\tif (!EVP_MD_CTX_copy_ex(&tmp_ctx,ctx))\n\t\tgoto err;    \n\tif (!EVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len))\n\t\tgoto err;\n\tEVP_MD_CTX_cleanup(&tmp_ctx);\n\n\tif (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE)\n\t\t{\n\t\tEVP_PKEY_CTX *pkctx = NULL;\n\t\ti = -1;\n\t\tpkctx = EVP_PKEY_CTX_new(pkey, NULL);\n\t\tif (!pkctx)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_verify_init(pkctx) <= 0)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0)\n\t\t\tgoto err;\n\t\ti = EVP_PKEY_verify(pkctx, sigbuf, siglen, m, m_len);\n\t\terr:\n\t\tEVP_PKEY_CTX_free(pkctx);\n\t\treturn i;\n\t\t}\n\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tv=ctx->digest->required_pkey_type[i];\n\t\tif (v == 0) break;\n\t\tif (pkey->type == v)\n\t\t\t{\n\t\t\tok=1;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif (!ok)\n\t\t{\n\t\tEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\n\t\treturn(-1);\n\t\t}\n        if (ctx->digest->verify == NULL)\n                {\n\t\tEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_NO_VERIFY_FUNCTION_CONFIGURED);\n\t\treturn(0);\n\t\t}\n\n\treturn(ctx->digest->verify(ctx->digest->type,m,m_len,\n\t\tsigbuf,siglen,pkey->pkey.ptr));\n\t}", "patch_func_code": "int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,\n\t     unsigned int siglen, EVP_PKEY *pkey)\n\t{\n\tunsigned char m[EVP_MAX_MD_SIZE];\n\tunsigned int m_len;\n\tint i = 0,ok = 0,v;\n\tMS_STATIC EVP_MD_CTX tmp_ctx;\n\tEVP_PKEY_CTX *pkctx = NULL;\n\n\tEVP_MD_CTX_init(&tmp_ctx);\n\tif (!EVP_MD_CTX_copy_ex(&tmp_ctx,ctx))\n\t\tgoto err;    \n\tif (!EVP_DigestFinal_ex(&tmp_ctx,&(m[0]),&m_len))\n\t\tgoto err;\n\tEVP_MD_CTX_cleanup(&tmp_ctx);\n\n\tif (ctx->digest->flags & EVP_MD_FLAG_PKEY_METHOD_SIGNATURE)\n\t\t{\n\t\ti = -1;\n\t\tpkctx = EVP_PKEY_CTX_new(pkey, NULL);\n\t\tif (!pkctx)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_verify_init(pkctx) <= 0)\n\t\t\tgoto err;\n\t\tif (EVP_PKEY_CTX_set_signature_md(pkctx, ctx->digest) <= 0)\n\t\t\tgoto err;\n\t\ti = EVP_PKEY_verify(pkctx, sigbuf, siglen, m, m_len);\n\t\terr:\n\t\tEVP_PKEY_CTX_free(pkctx);\n\t\treturn i;\n\t\t}\n\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tv=ctx->digest->required_pkey_type[i];\n\t\tif (v == 0) break;\n\t\tif (pkey->type == v)\n\t\t\t{\n\t\t\tok=1;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif (!ok)\n\t\t{\n\t\tEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_WRONG_PUBLIC_KEY_TYPE);\n\t\treturn(-1);\n\t\t}\n        if (ctx->digest->verify == NULL)\n                {\n\t\tEVPerr(EVP_F_EVP_VERIFYFINAL,EVP_R_NO_VERIFY_FUNCTION_CONFIGURED);\n\t\treturn(0);\n\t\t}\n\n\treturn(ctx->digest->verify(ctx->digest->type,m,m_len,\n\t\tsigbuf,siglen,pkey->pkey.ptr));\n\t}", "before_change_lines": [6, 18], "raw_before_change_lines": [6, 18], "after_change_lines": [6, 8], "raw_after_change_lines": [6, 8], "bug_lines": [6, 18], "added": [false, false], "idx": 471}
{"project": "openssl", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "14618----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_98e72fb76c18fabf7c7da1d8312b2d76e36ff5e0_1.json----asn1_cb", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_98e72fb76c18fabf7c7da1d8312b2d76e36ff5e0_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_98e72fb76c18fabf7c7da1d8312b2d76e36ff5e0_1.json", "function_name": "asn1_cb", "vul_func_code": "static int asn1_cb(const char *elem, int len, void *bitstr)\n\t{\n\ttag_exp_arg *arg = bitstr;\n\tint i;\n\tint utype;\n\tint vlen;\n\tconst char *p, *vstart = NULL;\n\n\tint tmp_tag, tmp_class;\n\n\tfor(i = 0, p = elem; i < len; p++, i++)\n\t\t{\n\t\t/* Look for the ':' in name value pairs */\n\t\tif (*p == ':')\n\t\t\t{\n\t\t\tvstart = p + 1;\n\t\t\tvlen = len - (vstart - elem);\n\t\t\tlen = p - elem;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tutype = asn1_str2tag(elem, len);\n\n\tif (utype == -1)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\n\t\tERR_add_error_data(2, \"tag=\", elem);\n\t\treturn -1;\n\t\t}\n\n\t/* If this is not a modifier mark end of string and exit */\n\tif (!(utype & ASN1_GEN_FLAG))\n\t\t{\n\t\targ->utype = utype;\n\t\targ->str = vstart;\n\t\t/* If no value and not end of string, error */\n\t\tif (!vstart && elem[len])\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\n\t\t\treturn -1;\n\t\t\t}\n\t\treturn 0;\n\t\t}\n\n\tswitch(utype)\n\t\t{\n\n\t\tcase ASN1_GEN_FLAG_IMP:\n\t\t/* Check for illegal multiple IMPLICIT tagging */\n\t\tif (arg->imp_tag != -1)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\n\t\t\treturn -1;\n\t\t\t}\n\t\tif (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_EXP:\n\n\t\tif (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))\n\t\t\treturn -1;\n\t\tif (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_SEQWRAP:\n\t\tif (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_BITWRAP:\n\t\tif (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_OCTWRAP:\n\t\tif (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_FORMAT:\n\t\tif (!strncmp(vstart, \"ASCII\", 5))\n\t\t\targ->format = ASN1_GEN_FORMAT_ASCII;\n\t\telse if (!strncmp(vstart, \"UTF8\", 4))\n\t\t\targ->format = ASN1_GEN_FORMAT_UTF8;\n\t\telse if (!strncmp(vstart, \"HEX\", 3))\n\t\t\targ->format = ASN1_GEN_FORMAT_HEX;\n\t\telse if (!strncmp(vstart, \"BITLIST\", 3))\n\t\t\targ->format = ASN1_GEN_FORMAT_BITLIST;\n\t\telse\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);\n\t\t\treturn -1;\n\t\t\t}\n\t\tbreak;\n\n\t\t}\n\n\treturn 1;\n\n\t}", "patch_func_code": "static int asn1_cb(const char *elem, int len, void *bitstr)\n\t{\n\ttag_exp_arg *arg = bitstr;\n\tint i;\n\tint utype;\n\tint vlen = 0;\n\tconst char *p, *vstart = NULL;\n\n\tint tmp_tag, tmp_class;\n\n\tfor(i = 0, p = elem; i < len; p++, i++)\n\t\t{\n\t\t/* Look for the ':' in name value pairs */\n\t\tif (*p == ':')\n\t\t\t{\n\t\t\tvstart = p + 1;\n\t\t\tvlen = len - (vstart - elem);\n\t\t\tlen = p - elem;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\tutype = asn1_str2tag(elem, len);\n\n\tif (utype == -1)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKNOWN_TAG);\n\t\tERR_add_error_data(2, \"tag=\", elem);\n\t\treturn -1;\n\t\t}\n\n\t/* If this is not a modifier mark end of string and exit */\n\tif (!(utype & ASN1_GEN_FLAG))\n\t\t{\n\t\targ->utype = utype;\n\t\targ->str = vstart;\n\t\t/* If no value and not end of string, error */\n\t\tif (!vstart && elem[len])\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_MISSING_VALUE);\n\t\t\treturn -1;\n\t\t\t}\n\t\treturn 0;\n\t\t}\n\n\tswitch(utype)\n\t\t{\n\n\t\tcase ASN1_GEN_FLAG_IMP:\n\t\t/* Check for illegal multiple IMPLICIT tagging */\n\t\tif (arg->imp_tag != -1)\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_ILLEGAL_NESTED_TAGGING);\n\t\t\treturn -1;\n\t\t\t}\n\t\tif (!parse_tagging(vstart, vlen, &arg->imp_tag, &arg->imp_class))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_EXP:\n\n\t\tif (!parse_tagging(vstart, vlen, &tmp_tag, &tmp_class))\n\t\t\treturn -1;\n\t\tif (!append_exp(arg, tmp_tag, tmp_class, 1, 0, 0))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_SEQWRAP:\n\t\tif (!append_exp(arg, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL, 1, 0, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_BITWRAP:\n\t\tif (!append_exp(arg, V_ASN1_BIT_STRING, V_ASN1_UNIVERSAL, 0, 1, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_OCTWRAP:\n\t\tif (!append_exp(arg, V_ASN1_OCTET_STRING, V_ASN1_UNIVERSAL, 0, 0, 1))\n\t\t\treturn -1;\n\t\tbreak;\n\n\t\tcase ASN1_GEN_FLAG_FORMAT:\n\t\tif (!strncmp(vstart, \"ASCII\", 5))\n\t\t\targ->format = ASN1_GEN_FORMAT_ASCII;\n\t\telse if (!strncmp(vstart, \"UTF8\", 4))\n\t\t\targ->format = ASN1_GEN_FORMAT_UTF8;\n\t\telse if (!strncmp(vstart, \"HEX\", 3))\n\t\t\targ->format = ASN1_GEN_FORMAT_HEX;\n\t\telse if (!strncmp(vstart, \"BITLIST\", 3))\n\t\t\targ->format = ASN1_GEN_FORMAT_BITLIST;\n\t\telse\n\t\t\t{\n\t\t\tASN1err(ASN1_F_ASN1_CB, ASN1_R_UNKOWN_FORMAT);\n\t\t\treturn -1;\n\t\t\t}\n\t\tbreak;\n\n\t\t}\n\n\treturn 1;\n\n\t}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6], "raw_after_change_lines": [6], "bug_lines": [6], "added": [false], "idx": 472}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "14692----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_9bcb3ad0e6dedeb54fec996bf7b16799de82e057_1.json----pkcs7_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_9bcb3ad0e6dedeb54fec996bf7b16799de82e057_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_9bcb3ad0e6dedeb54fec996bf7b16799de82e057_1.json", "function_name": "pkcs7_main", "vul_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tPKCS7 *p7=NULL;\n\tint i,badops=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat;\n\tchar *infile,*outfile,*prog;\n\tint print_certs=0,text=0,noout=0;\n\tint ret=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-print_certs\") == 0)\n\t\t\tprint_certs=1;\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg   input format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg  output format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg       input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg      output file\\n\");\n\t\tBIO_printf(bio_err,\" -print_certs  print any certs or crl in the input\\n\");\n\t\tBIO_printf(bio_err,\" -text         print full details of certificates\\n\");\n\t\tBIO_printf(bio_err,\" -noout        don't output encoded data\\n\");\n\t\tEXIT(1);\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n                goto end;\n                }\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\tif (in == NULL)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif\t(informat == FORMAT_ASN1)\n\t\tp7=d2i_PKCS7_bio(in,NULL);\n\telse if (informat == FORMAT_PEM)\n\t\tp7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL);\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified for pkcs7 object\\n\");\n\t\tgoto end;\n\t\t}\n\tif (p7 == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load PKCS7 object\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (outfile == NULL)\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (print_certs)\n\t\t{\n\t\tSTACK_OF(X509) *certs=NULL;\n\t\tSTACK_OF(X509_CRL) *crls=NULL;\n\n\t\ti=OBJ_obj2nid(p7->type);\n\t\tswitch (i)\n\t\t\t{\n\t\tcase NID_pkcs7_signed:\n\t\t\tcerts=p7->d.sign->cert;\n\t\t\tcrls=p7->d.sign->crl;\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signedAndEnveloped:\n\t\t\tcerts=p7->d.signed_and_enveloped->cert;\n\t\t\tcrls=p7->d.signed_and_enveloped->crl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t}\n\n\t\tif (certs != NULL)\n\t\t\t{\n\t\t\tX509 *x;\n\n\t\t\tfor (i=0; i<sk_X509_num(certs); i++)\n\t\t\t\t{\n\t\t\t\tx=sk_X509_value(certs,i);\n\t\t\t\tif(text) X509_print(out, x);\n\t\t\t\telse dump_cert_text(out, x);\n\n\t\t\t\tif(!noout) PEM_write_bio_X509(out,x);\n\t\t\t\tBIO_puts(out,\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\tif (crls != NULL)\n\t\t\t{\n\t\t\tX509_CRL *crl;\n\n\t\t\tfor (i=0; i<sk_X509_CRL_num(crls); i++)\n\t\t\t\t{\n\t\t\t\tcrl=sk_X509_CRL_value(crls,i);\n\n\t\t\t\tX509_CRL_print(out, crl);\n\n\t\t\t\tif(!noout)PEM_write_bio_X509_CRL(out,crl);\n\t\t\t\tBIO_puts(out,\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tret=0;\n\t\tgoto end;\n\t\t}\n\n\tif(!noout) {\n\t\tif \t(outformat == FORMAT_ASN1)\n\t\t\ti=i2d_PKCS7_bio(out,p7);\n\t\telse if (outformat == FORMAT_PEM)\n\t\t\ti=PEM_write_bio_PKCS7(out,p7);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\n\t\tif (!i)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t}\n\tret=0;\nend:\n\tif (p7 != NULL) PKCS7_free(p7);\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free(out);\n\tEXIT(ret);\n\t}", "patch_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tPKCS7 *p7=NULL;\n\tint i,badops=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat;\n\tchar *infile,*outfile,*prog;\n\tint print_certs=0,text=0,noout=0;\n\tint ret=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-noout\") == 0)\n\t\t\tnoout=1;\n\t\telse if (strcmp(*argv,\"-text\") == 0)\n\t\t\ttext=1;\n\t\telse if (strcmp(*argv,\"-print_certs\") == 0)\n\t\t\tprint_certs=1;\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg   input format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg  output format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg       input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg      output file\\n\");\n\t\tBIO_printf(bio_err,\" -print_certs  print any certs or crl in the input\\n\");\n\t\tBIO_printf(bio_err,\" -text         print full details of certificates\\n\");\n\t\tBIO_printf(bio_err,\" -noout        don't output encoded data\\n\");\n\t\tEXIT(1);\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n                goto end;\n                }\n\n\tif (infile == NULL)\n\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\tif (in == NULL)\n\t\t\t{\n\t\t\tperror(infile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif\t(informat == FORMAT_ASN1)\n\t\tp7=d2i_PKCS7_bio(in,NULL);\n\telse if (informat == FORMAT_PEM)\n\t\tp7=PEM_read_bio_PKCS7(in,NULL,NULL,NULL);\n\telse\n\t\t{\n\t\tBIO_printf(bio_err,\"bad input format specified for pkcs7 object\\n\");\n\t\tgoto end;\n\t\t}\n\tif (p7 == NULL)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to load PKCS7 object\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif (print_certs)\n\t\t{\n\t\tSTACK_OF(X509) *certs=NULL;\n\t\tSTACK_OF(X509_CRL) *crls=NULL;\n\n\t\ti=OBJ_obj2nid(p7->type);\n\t\tswitch (i)\n\t\t\t{\n\t\tcase NID_pkcs7_signed:\n\t\t\tcerts=p7->d.sign->cert;\n\t\t\tcrls=p7->d.sign->crl;\n\t\t\tbreak;\n\t\tcase NID_pkcs7_signedAndEnveloped:\n\t\t\tcerts=p7->d.signed_and_enveloped->cert;\n\t\t\tcrls=p7->d.signed_and_enveloped->crl;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t\t}\n\n\t\tif (certs != NULL)\n\t\t\t{\n\t\t\tX509 *x;\n\n\t\t\tfor (i=0; i<sk_X509_num(certs); i++)\n\t\t\t\t{\n\t\t\t\tx=sk_X509_value(certs,i);\n\t\t\t\tif(text) X509_print(out, x);\n\t\t\t\telse dump_cert_text(out, x);\n\n\t\t\t\tif(!noout) PEM_write_bio_X509(out,x);\n\t\t\t\tBIO_puts(out,\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\tif (crls != NULL)\n\t\t\t{\n\t\t\tX509_CRL *crl;\n\n\t\t\tfor (i=0; i<sk_X509_CRL_num(crls); i++)\n\t\t\t\t{\n\t\t\t\tcrl=sk_X509_CRL_value(crls,i);\n\n\t\t\t\tX509_CRL_print(out, crl);\n\n\t\t\t\tif(!noout)PEM_write_bio_X509_CRL(out,crl);\n\t\t\t\tBIO_puts(out,\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tret=0;\n\t\tgoto end;\n\t\t}\n\n\tif(!noout) {\n\t\tif \t(outformat == FORMAT_ASN1)\n\t\t\ti=i2d_PKCS7_bio(out,p7);\n\t\telse if (outformat == FORMAT_PEM)\n\t\t\ti=PEM_write_bio_PKCS7(out,p7);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\n\t\tif (!i)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t}\n\tret=0;\nend:\n\tif (p7 != NULL) PKCS7_free(p7);\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free_all(out);\n\tEXIT(ret);\n\t}", "before_change_lines": [201], "raw_before_change_lines": [201], "after_change_lines": [117, 119, 120, 121, 122, 123, 124, 125, 209], "raw_after_change_lines": [117, 119, 120, 121, 122, 123, 124, 125, 209], "bug_lines": [201], "added": [false], "idx": 473}
{"project": "openssl", "vul_type": "NULL_DEREFERENCE", "filepath_func": "14962----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a572b57ec1cb118b4dc531ffe774495b52d44b48_1.json----ssl3_get_cert_verify", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_a572b57ec1cb118b4dc531ffe774495b52d44b48_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a572b57ec1cb118b4dc531ffe774495b52d44b48_1.json", "function_name": "ssl3_get_cert_verify", "vul_func_code": "int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\tconst EVP_MD *md = NULL;\n\tEVP_MD_CTX mctx;\n\tEVP_MD_CTX_init(&mctx);\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\t514, /* 514? */\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s->session->peer != NULL)\n\t\t{\n\t\tpeer=s->session->peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\tif ((peer != NULL) && (type | EVP_PKT_SIGN))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type & EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s->init_msg;\n\t/* Check for broken implementations of GOST ciphersuites */\n\t/* If key is GOST and n is exactly 64, it is bare\n\t * signature without length field */\n\tif (n==64 && (pkey->type==NID_id_GostR3410_94 ||\n\t\tpkey->type == NID_id_GostR3410_2001) )\n\t\t{\n\t\ti=64;\n\t\t} \n\telse \n\t\t{\t\n\t\tif (s->version >= TLS1_2_VERSION)\n\t\t\t{\n\t\t\tint sigalg = tls12_get_sigid(pkey);\n\t\t\t/* Should never happen */\n\t\t\tif (sigalg == -1)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t/* Check key type is consistent with signature */\n\t\t\tif (sigalg != (int)p[1])\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_TYPE);\n\t\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tmd = tls12_get_hash(p[0]);\n\t\t\tif (md == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNKNOWN_DIGEST);\n\t\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tif (i > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n    \t}\n\tj=EVP_PKEY_size(pkey);\n\tif ((i > j) || (n > j) || (n <= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->version >= TLS1_2_VERSION)\n\t\t{\n\t\tlong hdatalen = 0;\n\t\tvoid *hdata;\n\t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n\t\tif (hdatalen <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifdef SSL_DEBUG\n\t\tfprintf(stderr, \"Using TLS 1.2 with client verify alg %s\\n\",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\tif (!EVP_VerifyInit_ex(&mctx, md, NULL)\n\t\t\t|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#ifndef OPENSSL_NO_RSA \n\tif (pkey->type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)\n\t\t{   unsigned char signature[64];\n\t\t\tint idx;\n\t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\t\tEVP_PKEY_verify_init(pctx);\n\t\t\tif (i!=64) {\n\t\t\t\tfprintf(stderr,\"GOST signature length is %d\",i);\n\t\t\t}\t\n\t\t\tfor (idx=0;idx<64;idx++) {\n\t\t\t\tsignature[63-idx]=p[idx];\n\t\t\t}\t\n\t\t\tj=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);\n\t\t\tEVP_PKEY_CTX_free(pctx);\n\t\t\tif (j<=0) \n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\t\n\t\t}\n\telse\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tif (s->s3->handshake_buffer)\n\t\t{\n\t\tBIO_free(s->s3->handshake_buffer);\n\t\ts->s3->handshake_buffer = NULL;\n\t\ts->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t}\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}", "patch_func_code": "int ssl3_get_cert_verify(SSL *s)\n\t{\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char *p;\n\tint al,ok,ret=0;\n\tlong n;\n\tint type=0,i,j;\n\tX509 *peer;\n\tconst EVP_MD *md = NULL;\n\tEVP_MD_CTX mctx;\n\tEVP_MD_CTX_init(&mctx);\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_CERT_VRFY_A,\n\t\tSSL3_ST_SR_CERT_VRFY_B,\n\t\t-1,\n\t\t514, /* 514? */\n\t\t&ok);\n\n\tif (!ok) return((int)n);\n\n\tif (s->session->peer != NULL)\n\t\t{\n\t\tpeer=s->session->peer;\n\t\tpkey=X509_get_pubkey(peer);\n\t\ttype=X509_certificate_type(peer,pkey);\n\t\t}\n\telse\n\t\t{\n\t\tpeer=NULL;\n\t\tpkey=NULL;\n\t\t}\n\n\tif (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_VERIFY)\n\t\t{\n\t\ts->s3->tmp.reuse_message=1;\n\t\tif ((peer != NULL) && (type | EVP_PKT_SIGN))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_MISSING_VERIFY_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tret=1;\n\t\tgoto end;\n\t\t}\n\n\tif (peer == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_NO_CLIENT_CERT_RECEIVED);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\tif (!(type & EVP_PKT_SIGN))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE);\n\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\tgoto f_err;\n\t\t}\n\n\tif (s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_CCS_RECEIVED_EARLY);\n\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\tgoto f_err;\n\t\t}\n\n\t/* we now have a signature that we need to verify */\n\tp=(unsigned char *)s->init_msg;\n\t/* Check for broken implementations of GOST ciphersuites */\n\t/* If key is GOST and n is exactly 64, it is bare\n\t * signature without length field */\n\tif (n==64 && (pkey->type==NID_id_GostR3410_94 ||\n\t\tpkey->type == NID_id_GostR3410_2001) )\n\t\t{\n\t\ti=64;\n\t\t} \n\telse \n\t\t{\t\n\t\tif (TLS1_get_version(s) >= TLS1_2_VERSION)\n\t\t\t{\n\t\t\tint sigalg = tls12_get_sigid(pkey);\n\t\t\t/* Should never happen */\n\t\t\tif (sigalg == -1)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\t/* Check key type is consistent with signature */\n\t\t\tif (sigalg != (int)p[1])\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_TYPE);\n\t\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n\t\t\tmd = tls12_get_hash(p[0]);\n\t\t\tif (md == NULL)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_UNKNOWN_DIGEST);\n\t\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\t\tgoto f_err;\n\t\t\t\t}\n#ifdef SSL_DEBUG\nfprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));\n#endif\n\t\t\tp += 2;\n\t\t\tn -= 2;\n\t\t\t}\n\t\tn2s(p,i);\n\t\tn-=2;\n\t\tif (i > n)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_LENGTH_MISMATCH);\n\t\t\tal=SSL_AD_DECODE_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n    \t}\n\tj=EVP_PKEY_size(pkey);\n\tif ((i > j) || (n > j) || (n <= 0))\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_WRONG_SIGNATURE_SIZE);\n\t\tal=SSL_AD_DECODE_ERROR;\n\t\tgoto f_err;\n\t\t}\n\n\tif (TLS1_get_version(s) >= TLS1_2_VERSION)\n\t\t{\n\t\tlong hdatalen = 0;\n\t\tvoid *hdata;\n\t\thdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n\t\tif (hdatalen <= 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_INTERNAL_ERROR);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n#ifdef SSL_DEBUG\n\t\tfprintf(stderr, \"Using TLS 1.2 with client verify alg %s\\n\",\n\t\t\t\t\t\t\tEVP_MD_name(md));\n#endif\n\t\tif (!EVP_VerifyInit_ex(&mctx, md, NULL)\n\t\t\t|| !EVP_VerifyUpdate(&mctx, hdata, hdatalen))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY, ERR_R_EVP_LIB);\n\t\t\tal=SSL_AD_INTERNAL_ERROR;\n\t\t\tgoto f_err;\n\t\t\t}\n\n\t\tif (EVP_VerifyFinal(&mctx, p , i, pkey) <= 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#ifndef OPENSSL_NO_RSA \n\tif (pkey->type == EVP_PKEY_RSA)\n\t\t{\n\t\ti=RSA_verify(NID_md5_sha1, s->s3->tmp.cert_verify_md,\n\t\t\tMD5_DIGEST_LENGTH+SHA_DIGEST_LENGTH, p, i, \n\t\t\t\t\t\t\tpkey->pkey.rsa);\n\t\tif (i < 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_DECRYPT);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (i == 0)\n\t\t\t{\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_RSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_DSA\n\t\tif (pkey->type == EVP_PKEY_DSA)\n\t\t{\n\t\tj=DSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.dsa);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,SSL_R_BAD_DSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n#ifndef OPENSSL_NO_ECDSA\n\t\tif (pkey->type == EVP_PKEY_EC)\n\t\t{\n\t\tj=ECDSA_verify(pkey->save_type,\n\t\t\t&(s->s3->tmp.cert_verify_md[MD5_DIGEST_LENGTH]),\n\t\t\tSHA_DIGEST_LENGTH,p,i,pkey->pkey.ec);\n\t\tif (j <= 0)\n\t\t\t{\n\t\t\t/* bad signature */\n\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t    SSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t}\n\telse\n#endif\n\tif (pkey->type == NID_id_GostR3410_94 || pkey->type == NID_id_GostR3410_2001)\n\t\t{   unsigned char signature[64];\n\t\t\tint idx;\n\t\t\tEVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new(pkey,NULL);\n\t\t\tEVP_PKEY_verify_init(pctx);\n\t\t\tif (i!=64) {\n\t\t\t\tfprintf(stderr,\"GOST signature length is %d\",i);\n\t\t\t}\t\n\t\t\tfor (idx=0;idx<64;idx++) {\n\t\t\t\tsignature[63-idx]=p[idx];\n\t\t\t}\t\n\t\t\tj=EVP_PKEY_verify(pctx,signature,64,s->s3->tmp.cert_verify_md,32);\n\t\t\tEVP_PKEY_CTX_free(pctx);\n\t\t\tif (j<=0) \n\t\t\t\t{\n\t\t\t\tal=SSL_AD_DECRYPT_ERROR;\n\t\t\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,\n\t\t\t\t\tSSL_R_BAD_ECDSA_SIGNATURE);\n\t\t\t\tgoto f_err;\n\t\t\t\t}\t\n\t\t}\n\telse\t\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_CERT_VERIFY,ERR_R_INTERNAL_ERROR);\n\t\tal=SSL_AD_UNSUPPORTED_CERTIFICATE;\n\t\tgoto f_err;\n\t\t}\n\n\n\tret=1;\n\tif (0)\n\t\t{\nf_err:\n\t\tssl3_send_alert(s,SSL3_AL_FATAL,al);\n\t\t}\nend:\n\tif (s->s3->handshake_buffer)\n\t\t{\n\t\tBIO_free(s->s3->handshake_buffer);\n\t\ts->s3->handshake_buffer = NULL;\n\t\ts->s3->flags &= ~TLS1_FLAGS_KEEP_HANDSHAKE;\n\t\t}\n\tEVP_MD_CTX_cleanup(&mctx);\n\tEVP_PKEY_free(pkey);\n\treturn(ret);\n\t}", "before_change_lines": [80, 127], "raw_before_change_lines": [80, 127], "after_change_lines": [80, 127], "raw_after_change_lines": [80, 127], "bug_lines": [80, 127], "added": [false, false], "idx": 474}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "14976----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a5de9f7ff6d23a8b5f079da8c0b912119c9fb20d_1.json----tls_construct_new_session_ticket", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_a5de9f7ff6d23a8b5f079da8c0b912119c9fb20d_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a5de9f7ff6d23a8b5f079da8c0b912119c9fb20d_1.json", "function_name": "tls_construct_new_session_ticket", "vul_func_code": "int tls_construct_new_session_ticket(SSL *s, WPACKET *pkt)\n{\n    unsigned char *senc = NULL;\n    EVP_CIPHER_CTX *ctx = NULL;\n    HMAC_CTX *hctx = NULL;\n    unsigned char *p, *encdata1, *encdata2, *macdata1, *macdata2;\n    const unsigned char *const_p;\n    int len, slen_full, slen, lenfinal;\n    SSL_SESSION *sess;\n    unsigned int hlen;\n    SSL_CTX *tctx = s->session_ctx;\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n    unsigned char key_name[TLSEXT_KEYNAME_LENGTH];\n    int iv_len;\n    size_t macoffset, macendoffset;\n    union {\n        unsigned char age_add_c[sizeof(uint32_t)];\n        uint32_t age_add;\n    } age_add_u;\n\n    if (SSL_IS_TLS13(s)) {\n        void (*cb) (const SSL *ssl, int type, int val) = NULL;\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n\n        if (cb != NULL) {\n            /*\n             * We don't start and stop the handshake in between each ticket when\n             * sending more than one - but it should appear that way to the info\n             * callback.\n             */\n            if (s->sent_tickets != 0) {\n                ossl_statem_set_in_init(s, 0);\n                cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n                ossl_statem_set_in_init(s, 1);\n            }\n            cb(s, SSL_CB_HANDSHAKE_START, 1);\n        }\n        /*\n         * If we already sent one NewSessionTicket then we need to take a copy\n         * of it and create a new session from it.\n         */\n        if (s->sent_tickets != 0) {\n            SSL_SESSION *new_sess = ssl_session_dup(s->session, 0);\n\n            if (new_sess == NULL) {\n                /* SSLfatal already called */\n                goto err;\n            }\n\n            SSL_SESSION_free(s->session);\n            s->session = new_sess;\n        }\n\n        if (!ssl_generate_session_id(s, s->session)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n        if (RAND_bytes(age_add_u.age_add_c, sizeof(age_add_u)) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->session->ext.tick_age_add = age_add_u.age_add;\n       /*\n        * ticket_nonce is set to a single 0 byte because we only ever send a\n        * single ticket per connection. IMPORTANT: If we ever support multiple\n        * tickets per connection then this will need to be changed.\n        */\n        OPENSSL_free(s->session->ext.tick_nonce);\n        s->session->ext.tick_nonce = OPENSSL_zalloc(sizeof(char));\n        if (s->session->ext.tick_nonce == NULL) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        s->session->ext.tick_nonce_len = 1;\n        s->session->time = (long)time(NULL);\n        if (s->s3->alpn_selected != NULL) {\n            OPENSSL_free(s->session->ext.alpn_selected);\n            s->session->ext.alpn_selected =\n                OPENSSL_memdup(s->s3->alpn_selected, s->s3->alpn_selected_len);\n            if (s->session->ext.alpn_selected == NULL) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                         ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            s->session->ext.alpn_selected_len = s->s3->alpn_selected_len;\n        }\n        s->session->ext.max_early_data = s->max_early_data;\n    }\n\n    if (tctx->generate_ticket_cb != NULL &&\n        tctx->generate_ticket_cb(s, tctx->ticket_cb_data) == 0)\n        goto err;\n\n    /* get session encoding length */\n    slen_full = i2d_SSL_SESSION(s->session, NULL);\n    /*\n     * Some length values are 16 bits, so forget it if session is too\n     * long\n     */\n    if (slen_full == 0 || slen_full > 0xFF00) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    senc = OPENSSL_malloc(slen_full);\n    if (senc == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    hctx = HMAC_CTX_new();\n    if (ctx == NULL || hctx == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    p = senc;\n    if (!i2d_SSL_SESSION(s->session, &p)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * create a fresh copy (not shared with other threads) to clean up\n     */\n    const_p = senc;\n    sess = d2i_SSL_SESSION(NULL, &const_p, slen_full);\n    if (sess == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    slen = i2d_SSL_SESSION(sess, NULL);\n    if (slen == 0 || slen > slen_full) {\n        /* shouldn't ever happen */\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        SSL_SESSION_free(sess);\n        goto err;\n    }\n    p = senc;\n    if (!i2d_SSL_SESSION(sess, &p)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        SSL_SESSION_free(sess);\n        goto err;\n    }\n    SSL_SESSION_free(sess);\n\n    /*\n     * Initialize HMAC and cipher contexts. If callback present it does\n     * all the work otherwise use generated values from parent ctx.\n     */\n    if (tctx->ext.ticket_key_cb) {\n        /* if 0 is returned, write an empty ticket */\n        int ret = tctx->ext.ticket_key_cb(s, key_name, iv, ctx,\n                                             hctx, 1);\n\n        if (ret == 0) {\n\n            /* Put timeout and length */\n            if (!WPACKET_put_bytes_u32(pkt, 0)\n                    || !WPACKET_put_bytes_u16(pkt, 0)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                         ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            OPENSSL_free(senc);\n            EVP_CIPHER_CTX_free(ctx);\n            HMAC_CTX_free(hctx);\n            return 1;\n        }\n        if (ret < 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     SSL_R_CALLBACK_FAILED);\n            goto err;\n        }\n        iv_len = EVP_CIPHER_CTX_iv_length(ctx);\n    } else {\n        const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n\n        iv_len = EVP_CIPHER_iv_length(cipher);\n        if (RAND_bytes(iv, iv_len) <= 0\n                || !EVP_EncryptInit_ex(ctx, cipher, NULL,\n                                       tctx->ext.secure->tick_aes_key, iv)\n                || !HMAC_Init_ex(hctx, tctx->ext.secure->tick_hmac_key,\n                                 sizeof(tctx->ext.secure->tick_hmac_key),\n                                 EVP_sha256(), NULL)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        memcpy(key_name, tctx->ext.tick_key_name,\n               sizeof(tctx->ext.tick_key_name));\n    }\n\n    /*\n     * Ticket lifetime hint: For TLSv1.2 this is advisory only and we leave this\n     * unspecified for resumed session (for simplicity).\n     * In TLSv1.3 we reset the \"time\" field above, and always specify the\n     * timeout.\n     */\n    if (!WPACKET_put_bytes_u32(pkt,\n                               (s->hit && !SSL_IS_TLS13(s))\n                               ? 0 : s->session->timeout)\n            || (SSL_IS_TLS13(s)\n                && (!WPACKET_put_bytes_u32(pkt, age_add_u.age_add)\n                    || !WPACKET_sub_memcpy_u8(pkt, s->session->ext.tick_nonce,\n                                              s->session->ext.tick_nonce_len)))\n               /* Now the actual ticket data */\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_get_total_written(pkt, &macoffset)\n               /* Output key name */\n            || !WPACKET_memcpy(pkt, key_name, sizeof(key_name))\n               /* output IV */\n            || !WPACKET_memcpy(pkt, iv, iv_len)\n            || !WPACKET_reserve_bytes(pkt, slen + EVP_MAX_BLOCK_LENGTH,\n                                      &encdata1)\n               /* Encrypt session data */\n            || !EVP_EncryptUpdate(ctx, encdata1, &len, senc, slen)\n            || !WPACKET_allocate_bytes(pkt, len, &encdata2)\n            || encdata1 != encdata2\n            || !EVP_EncryptFinal(ctx, encdata1 + len, &lenfinal)\n            || !WPACKET_allocate_bytes(pkt, lenfinal, &encdata2)\n            || encdata1 + len != encdata2\n            || len + lenfinal > slen + EVP_MAX_BLOCK_LENGTH\n            || !WPACKET_get_total_written(pkt, &macendoffset)\n            || !HMAC_Update(hctx,\n                            (unsigned char *)s->init_buf->data + macoffset,\n                            macendoffset - macoffset)\n            || !WPACKET_reserve_bytes(pkt, EVP_MAX_MD_SIZE, &macdata1)\n            || !HMAC_Final(hctx, macdata1, &hlen)\n            || hlen > EVP_MAX_MD_SIZE\n            || !WPACKET_allocate_bytes(pkt, hlen, &macdata2)\n            || macdata1 != macdata2\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (SSL_IS_TLS13(s)) {\n        if (!tls_construct_extensions(s, pkt,\n                                      SSL_EXT_TLS1_3_NEW_SESSION_TICKET,\n                                      NULL, 0)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n        s->sent_tickets++;\n        ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n    }\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    OPENSSL_free(senc);\n\n    return 1;\n err:\n    OPENSSL_free(senc);\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return 0;\n}", "patch_func_code": "int tls_construct_new_session_ticket(SSL *s, WPACKET *pkt)\n{\n    unsigned char *senc = NULL;\n    EVP_CIPHER_CTX *ctx = NULL;\n    HMAC_CTX *hctx = NULL;\n    unsigned char *p, *encdata1, *encdata2, *macdata1, *macdata2;\n    const unsigned char *const_p;\n    int len, slen_full, slen, lenfinal;\n    SSL_SESSION *sess;\n    unsigned int hlen;\n    SSL_CTX *tctx = s->session_ctx;\n    unsigned char iv[EVP_MAX_IV_LENGTH];\n    unsigned char key_name[TLSEXT_KEYNAME_LENGTH];\n    int iv_len;\n    size_t macoffset, macendoffset;\n    union {\n        unsigned char age_add_c[sizeof(uint32_t)];\n        uint32_t age_add;\n    } age_add_u;\n\n    if (SSL_IS_TLS13(s)) {\n        size_t i, hashlen;\n        uint64_t nonce;\n        const char nonce_label[] = \"resumption\";\n        const EVP_MD *md = ssl_handshake_md(s);\n        void (*cb) (const SSL *ssl, int type, int val) = NULL;\n        int hashleni = EVP_MD_size(md);\n\n        /* Ensure cast to size_t is safe */\n        if (!ossl_assert(hashleni >= 0)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        hashlen = (size_t)hashleni;\n\n        if (s->info_callback != NULL)\n            cb = s->info_callback;\n        else if (s->ctx->info_callback != NULL)\n            cb = s->ctx->info_callback;\n\n\n        if (cb != NULL) {\n            /*\n             * We don't start and stop the handshake in between each ticket when\n             * sending more than one - but it should appear that way to the info\n             * callback.\n             */\n            if (s->sent_tickets != 0) {\n                ossl_statem_set_in_init(s, 0);\n                cb(s, SSL_CB_HANDSHAKE_DONE, 1);\n                ossl_statem_set_in_init(s, 1);\n            }\n            cb(s, SSL_CB_HANDSHAKE_START, 1);\n        }\n        /*\n         * If we already sent one NewSessionTicket then we need to take a copy\n         * of it and create a new session from it.\n         */\n        if (s->sent_tickets != 0) {\n            SSL_SESSION *new_sess = ssl_session_dup(s->session, 0);\n\n            if (new_sess == NULL) {\n                /* SSLfatal already called */\n                goto err;\n            }\n\n            SSL_SESSION_free(s->session);\n            s->session = new_sess;\n        }\n\n        if (!ssl_generate_session_id(s, s->session)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n        if (RAND_bytes(age_add_u.age_add_c, sizeof(age_add_u)) <= 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        s->session->ext.tick_age_add = age_add_u.age_add;\n\n        OPENSSL_free(s->session->ext.tick_nonce);\n        s->session->ext.tick_nonce = OPENSSL_zalloc(TICKET_NONCE_SIZE);\n        if (s->session->ext.tick_nonce == NULL) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        nonce = s->next_ticket_nonce;\n        for (i = TICKET_NONCE_SIZE; nonce > 0 && i > 0; i--) {\n            s->session->ext.tick_nonce[i - 1] = nonce & 0xff;\n            nonce >>= 8;\n        }\n        s->session->ext.tick_nonce_len = TICKET_NONCE_SIZE;\n\n        if (!tls13_hkdf_expand(s, md, s->resumption_master_secret,\n                               (const unsigned char *)nonce_label,\n                               sizeof(nonce_label) - 1,\n                               s->session->ext.tick_nonce,\n                               s->session->ext.tick_nonce_len,\n                               s->session->master_key,\n                               hashlen)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n        s->session->master_key_length = hashlen;\n\n        s->session->time = (long)time(NULL);\n        if (s->s3->alpn_selected != NULL) {\n            OPENSSL_free(s->session->ext.alpn_selected);\n            s->session->ext.alpn_selected =\n                OPENSSL_memdup(s->s3->alpn_selected, s->s3->alpn_selected_len);\n            if (s->session->ext.alpn_selected == NULL) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                         ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            s->session->ext.alpn_selected_len = s->s3->alpn_selected_len;\n        }\n        s->session->ext.max_early_data = s->max_early_data;\n    }\n\n    if (tctx->generate_ticket_cb != NULL &&\n        tctx->generate_ticket_cb(s, tctx->ticket_cb_data) == 0)\n        goto err;\n\n    /* get session encoding length */\n    slen_full = i2d_SSL_SESSION(s->session, NULL);\n    /*\n     * Some length values are 16 bits, so forget it if session is too\n     * long\n     */\n    if (slen_full == 0 || slen_full > 0xFF00) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    senc = OPENSSL_malloc(slen_full);\n    if (senc == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    ctx = EVP_CIPHER_CTX_new();\n    hctx = HMAC_CTX_new();\n    if (ctx == NULL || hctx == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    p = senc;\n    if (!i2d_SSL_SESSION(s->session, &p)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * create a fresh copy (not shared with other threads) to clean up\n     */\n    const_p = senc;\n    sess = d2i_SSL_SESSION(NULL, &const_p, slen_full);\n    if (sess == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    slen = i2d_SSL_SESSION(sess, NULL);\n    if (slen == 0 || slen > slen_full) {\n        /* shouldn't ever happen */\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        SSL_SESSION_free(sess);\n        goto err;\n    }\n    p = senc;\n    if (!i2d_SSL_SESSION(sess, &p)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        SSL_SESSION_free(sess);\n        goto err;\n    }\n    SSL_SESSION_free(sess);\n\n    /*\n     * Initialize HMAC and cipher contexts. If callback present it does\n     * all the work otherwise use generated values from parent ctx.\n     */\n    if (tctx->ext.ticket_key_cb) {\n        /* if 0 is returned, write an empty ticket */\n        int ret = tctx->ext.ticket_key_cb(s, key_name, iv, ctx,\n                                             hctx, 1);\n\n        if (ret == 0) {\n\n            /* Put timeout and length */\n            if (!WPACKET_put_bytes_u32(pkt, 0)\n                    || !WPACKET_put_bytes_u16(pkt, 0)) {\n                SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                         SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                         ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            OPENSSL_free(senc);\n            EVP_CIPHER_CTX_free(ctx);\n            HMAC_CTX_free(hctx);\n            return 1;\n        }\n        if (ret < 0) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     SSL_R_CALLBACK_FAILED);\n            goto err;\n        }\n        iv_len = EVP_CIPHER_CTX_iv_length(ctx);\n    } else {\n        const EVP_CIPHER *cipher = EVP_aes_256_cbc();\n\n        iv_len = EVP_CIPHER_iv_length(cipher);\n        if (RAND_bytes(iv, iv_len) <= 0\n                || !EVP_EncryptInit_ex(ctx, cipher, NULL,\n                                       tctx->ext.secure->tick_aes_key, iv)\n                || !HMAC_Init_ex(hctx, tctx->ext.secure->tick_hmac_key,\n                                 sizeof(tctx->ext.secure->tick_hmac_key),\n                                 EVP_sha256(), NULL)) {\n            SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                     SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET,\n                     ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n        memcpy(key_name, tctx->ext.tick_key_name,\n               sizeof(tctx->ext.tick_key_name));\n    }\n\n    /*\n     * Ticket lifetime hint: For TLSv1.2 this is advisory only and we leave this\n     * unspecified for resumed session (for simplicity).\n     * In TLSv1.3 we reset the \"time\" field above, and always specify the\n     * timeout.\n     */\n    if (!WPACKET_put_bytes_u32(pkt,\n                               (s->hit && !SSL_IS_TLS13(s))\n                               ? 0 : s->session->timeout)\n            || (SSL_IS_TLS13(s)\n                && (!WPACKET_put_bytes_u32(pkt, age_add_u.age_add)\n                    || !WPACKET_sub_memcpy_u8(pkt, s->session->ext.tick_nonce,\n                                              s->session->ext.tick_nonce_len)))\n               /* Now the actual ticket data */\n            || !WPACKET_start_sub_packet_u16(pkt)\n            || !WPACKET_get_total_written(pkt, &macoffset)\n               /* Output key name */\n            || !WPACKET_memcpy(pkt, key_name, sizeof(key_name))\n               /* output IV */\n            || !WPACKET_memcpy(pkt, iv, iv_len)\n            || !WPACKET_reserve_bytes(pkt, slen + EVP_MAX_BLOCK_LENGTH,\n                                      &encdata1)\n               /* Encrypt session data */\n            || !EVP_EncryptUpdate(ctx, encdata1, &len, senc, slen)\n            || !WPACKET_allocate_bytes(pkt, len, &encdata2)\n            || encdata1 != encdata2\n            || !EVP_EncryptFinal(ctx, encdata1 + len, &lenfinal)\n            || !WPACKET_allocate_bytes(pkt, lenfinal, &encdata2)\n            || encdata1 + len != encdata2\n            || len + lenfinal > slen + EVP_MAX_BLOCK_LENGTH\n            || !WPACKET_get_total_written(pkt, &macendoffset)\n            || !HMAC_Update(hctx,\n                            (unsigned char *)s->init_buf->data + macoffset,\n                            macendoffset - macoffset)\n            || !WPACKET_reserve_bytes(pkt, EVP_MAX_MD_SIZE, &macdata1)\n            || !HMAC_Final(hctx, macdata1, &hlen)\n            || hlen > EVP_MAX_MD_SIZE\n            || !WPACKET_allocate_bytes(pkt, hlen, &macdata2)\n            || macdata1 != macdata2\n            || !WPACKET_close(pkt)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (SSL_IS_TLS13(s)) {\n        if (!tls_construct_extensions(s, pkt,\n                                      SSL_EXT_TLS1_3_NEW_SESSION_TICKET,\n                                      NULL, 0)) {\n            /* SSLfatal() already called */\n            goto err;\n        }\n        /*\n         * Increment both |sent_tickets| and |next_ticket_nonce|. |sent_tickets|\n         * gets reset to 0 if we send more tickets following a post-handshake\n         * auth, but |next_ticket_nonce| does not.\n         */\n        s->sent_tickets++;\n        s->next_ticket_nonce++;\n        ssl_update_cache(s, SSL_SESS_CACHE_SERVER);\n    }\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    OPENSSL_free(senc);\n\n    return 1;\n err:\n    OPENSSL_free(senc);\n    EVP_CIPHER_CTX_free(ctx);\n    HMAC_CTX_free(hctx);\n    return 0;\n}", "before_change_lines": [71, 72, 73, 74, 76, 83], "raw_before_change_lines": [70, 71, 72, 73, 74, 76, 83], "after_change_lines": [22, 23, 24, 25, 27, 30, 31, 32, 33, 34, 35, 36, 86, 93, 94, 95, 96, 97, 98, 100, 101, 102, 103, 104, 105, 106, 108, 109, 110, 295, 296, 297, 298, 300], "raw_after_change_lines": [22, 23, 24, 25, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 84, 86, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 294, 295, 296, 297, 298, 300], "bug_lines": [70, 71, 72, 73, 74, 76, 83], "added": [false, false, false, false, false, false, false], "idx": 475}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "15014----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a72d642d3bc2835850d49f91520bff8647a3216c_1.json----UI_create_method", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_a72d642d3bc2835850d49f91520bff8647a3216c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a72d642d3bc2835850d49f91520bff8647a3216c_1.json", "function_name": "UI_create_method", "vul_func_code": "UI_METHOD *UI_create_method(char *name)\n{\n    UI_METHOD *ui_method = OPENSSL_zalloc(sizeof(*ui_method));\n\n    if (ui_method != NULL)\n        ui_method->name = BUF_strdup(name);\n    return ui_method;\n}", "patch_func_code": "UI_METHOD *UI_create_method(char *name)\n{\n    UI_METHOD *ui_method = OPENSSL_zalloc(sizeof(*ui_method));\n\n    if (ui_method != NULL)\n        ui_method->name = OPENSSL_strdup(name);\n    return ui_method;\n}", "before_change_lines": [6], "raw_before_change_lines": [6], "after_change_lines": [6], "raw_after_change_lines": [6], "bug_lines": [6], "added": [false], "idx": 476}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "15050----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a867feac9eddc917e3b01d15062aebb143e2fa80_1.json----wait_for_async", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_a867feac9eddc917e3b01d15062aebb143e2fa80_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a867feac9eddc917e3b01d15062aebb143e2fa80_1.json", "function_name": "wait_for_async", "vul_func_code": "void wait_for_async(SSL *s)\n{\n    int width, fd;\n    fd_set asyncfds;\n\n    fd = SSL_get_async_wait_fd(s);\n    if (fd < 0)\n        return;\n\n    width = fd + 1;\n    FD_ZERO(&asyncfds);\n    openssl_fdset(fd, &asyncfds);\n    select(width, (void *)&asyncfds, NULL, NULL, NULL);\n}", "patch_func_code": "void wait_for_async(SSL *s)\n{\n    int width = 0;\n    fd_set asyncfds;\n    OSSL_ASYNC_FD *fds;\n    size_t numfds;\n\n    if (!SSL_get_all_async_fds(s, NULL, &numfds))\n        return;\n    if (numfds == 0)\n        return;\n    fds = OPENSSL_malloc(sizeof(OSSL_ASYNC_FD) * numfds);\n    if (!SSL_get_all_async_fds(s, fds, &numfds)) {\n        OPENSSL_free(fds);\n    }\n\n    FD_ZERO(&asyncfds);\n    while (numfds > 0) {\n        if (width <= (int)*fds)\n            width = (int)*fds + 1;\n        openssl_fdset((int)*fds, &asyncfds);\n        numfds--;\n        fds++;\n    }\n    select(width, (void *)&asyncfds, NULL, NULL, NULL);\n}", "before_change_lines": [3, 6, 7, 10, 12], "raw_before_change_lines": [3, 6, 7, 10, 12], "after_change_lines": [3, 5, 6, 8, 9, 10, 12, 13, 14, 15, 18, 19, 20, 21, 22, 23, 24], "raw_after_change_lines": [3, 5, 6, 8, 9, 10, 12, 13, 14, 15, 18, 19, 20, 21, 22, 23, 24], "bug_lines": [3, 6, 7, 10, 12], "added": [false, false, false, false, false], "idx": 477}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "15064----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a8c186d247ba40e2875c3751f1af259f05d66909_1.json----derive_secret_key_and_iv", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_a8c186d247ba40e2875c3751f1af259f05d66909_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_a8c186d247ba40e2875c3751f1af259f05d66909_1.json", "function_name": "derive_secret_key_and_iv", "vul_func_code": "static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,\n                                    const EVP_CIPHER *ciph,\n                                    const unsigned char *insecret,\n                                    const unsigned char *hash,\n                                    const unsigned char *label,\n                                    size_t labellen, unsigned char *secret,\n                                    unsigned char *iv, EVP_CIPHER_CTX *ciph_ctx)\n{\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    size_t ivlen, keylen, taglen;\n    int hashleni = EVP_MD_size(md);\n    size_t hashlen;\n\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(hashleni >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    hashlen = (size_t)hashleni;\n\n    if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen,\n                           secret, hashlen)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /* TODO(size_t): convert me */\n    keylen = EVP_CIPHER_key_length(ciph);\n    if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) {\n        uint32_t algenc;\n\n        ivlen = EVP_CCM_TLS_IV_LEN;\n        if (s->s3->tmp.new_cipher == NULL) {\n            /* We've not selected a cipher yet - we must be doing early data */\n            algenc = s->session->cipher->algorithm_enc;\n        } else {\n            algenc = s->s3->tmp.new_cipher->algorithm_enc;\n        }\n        if (algenc & (SSL_AES128CCM8 | SSL_AES256CCM8))\n            taglen = EVP_CCM8_TLS_TAG_LEN;\n         else\n            taglen = EVP_CCM_TLS_TAG_LEN;\n    } else {\n        ivlen = EVP_CIPHER_iv_length(ciph);\n        taglen = 0;\n    }\n\n    if (!tls13_derive_key(s, md, secret, key, keylen)\n            || !tls13_derive_iv(s, md, secret, iv, ivlen)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, NULL, NULL, sending) <= 0\n        || !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)\n        || (taglen != 0 && !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG,\n                                                taglen, NULL))\n        || EVP_CipherInit_ex(ciph_ctx, NULL, NULL, key, NULL, -1) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    return 1;\n err:\n    OPENSSL_cleanse(key, sizeof(key));\n    return 0;\n}", "patch_func_code": "static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,\n                                    const EVP_CIPHER *ciph,\n                                    const unsigned char *insecret,\n                                    const unsigned char *hash,\n                                    const unsigned char *label,\n                                    size_t labellen, unsigned char *secret,\n                                    unsigned char *iv, EVP_CIPHER_CTX *ciph_ctx)\n{\n    unsigned char key[EVP_MAX_KEY_LENGTH];\n    size_t ivlen, keylen, taglen;\n    int hashleni = EVP_MD_size(md);\n    size_t hashlen;\n\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(hashleni >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n    hashlen = (size_t)hashleni;\n\n    if (!tls13_hkdf_expand(s, md, insecret, label, labellen, hash, hashlen,\n                           secret, hashlen, 1)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    /* TODO(size_t): convert me */\n    keylen = EVP_CIPHER_key_length(ciph);\n    if (EVP_CIPHER_mode(ciph) == EVP_CIPH_CCM_MODE) {\n        uint32_t algenc;\n\n        ivlen = EVP_CCM_TLS_IV_LEN;\n        if (s->s3->tmp.new_cipher == NULL) {\n            /* We've not selected a cipher yet - we must be doing early data */\n            algenc = s->session->cipher->algorithm_enc;\n        } else {\n            algenc = s->s3->tmp.new_cipher->algorithm_enc;\n        }\n        if (algenc & (SSL_AES128CCM8 | SSL_AES256CCM8))\n            taglen = EVP_CCM8_TLS_TAG_LEN;\n         else\n            taglen = EVP_CCM_TLS_TAG_LEN;\n    } else {\n        ivlen = EVP_CIPHER_iv_length(ciph);\n        taglen = 0;\n    }\n\n    if (!tls13_derive_key(s, md, secret, key, keylen)\n            || !tls13_derive_iv(s, md, secret, iv, ivlen)) {\n        /* SSLfatal() already called */\n        goto err;\n    }\n\n    if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, NULL, NULL, sending) <= 0\n        || !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)\n        || (taglen != 0 && !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG,\n                                                taglen, NULL))\n        || EVP_CipherInit_ex(ciph_ctx, NULL, NULL, key, NULL, -1) <= 0) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_F_DERIVE_SECRET_KEY_AND_IV,\n                 ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    return 1;\n err:\n    OPENSSL_cleanse(key, sizeof(key));\n    return 0;\n}", "before_change_lines": [23], "raw_before_change_lines": [23], "after_change_lines": [23], "raw_after_change_lines": [23], "bug_lines": [23], "added": [false], "idx": 478}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "15241----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_aecad434706c8bb0b140168ce2e12a1a77c547a4_1.json----ssl_cert_set0_chain", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_aecad434706c8bb0b140168ce2e12a1a77c547a4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_aecad434706c8bb0b140168ce2e12a1a77c547a4_1.json", "function_name": "ssl_cert_set0_chain", "vul_func_code": "int ssl_cert_set0_chain(CERT *c, STACK_OF(X509) *chain)\n\t{\n\tCERT_PKEY *cpk = c->key;\n\tif (!cpk)\n\t\treturn 0;\n\tif (cpk->chain)\n\t\tsk_X509_pop_free(cpk->chain, X509_free);\n\tcpk->chain = chain;\n\treturn 1;\n\t}", "patch_func_code": "int ssl_cert_set0_chain(SSL *s, SSL_CTX *ctx, STACK_OF(X509) *chain)\n\t{\n\tint i, r;\n\tCERT_PKEY *cpk = s ? s->cert->key : ctx->cert->key;\n\tif (!cpk)\n\t\treturn 0;\n\tif (cpk->chain)\n\t\tsk_X509_pop_free(cpk->chain, X509_free);\n\tfor (i = 0; i < sk_X509_num(chain); i++)\n\t\t{\n\t\tr = ssl_security_cert(s, ctx, sk_X509_value(chain, i), 0, 0);\n\t\tif (r != 1)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL_CERT_SET0_CHAIN, r);\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tcpk->chain = chain;\n\treturn 1;\n\t}", "before_change_lines": [1, 3], "raw_before_change_lines": [1, 3], "after_change_lines": [1, 3, 4, 9, 10, 11, 12, 13, 14, 15, 16, 17], "raw_after_change_lines": [1, 3, 4, 9, 10, 11, 12, 13, 14, 15, 16, 17], "bug_lines": [1, 3], "added": [false, false], "idx": 479}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "15307----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b10aa44ddfeb8b95f69326bf598d46cfdfc763fe_1.json----tls_psk_do_binder", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_b10aa44ddfeb8b95f69326bf598d46cfdfc763fe_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b10aa44ddfeb8b95f69326bf598d46cfdfc763fe_1.json", "function_name": "tls_psk_do_binder", "vul_func_code": "int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,\n                      size_t binderoffset, const unsigned char *binderin,\n                      unsigned char *binderout, SSL_SESSION *sess, int sign,\n                      int external)\n{\n    EVP_PKEY *mackey = NULL;\n    EVP_MD_CTX *mctx = NULL;\n    unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE];\n    unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE];\n    unsigned char *early_secret;\n    const char resumption_label[] = \"res binder\";\n    const char external_label[] = \"ext binder\";\n    const char *label;\n    size_t bindersize, labelsize, hashsize = EVP_MD_size(md);\n    int ret = -1;\n\n    if (external) {\n        label = external_label;\n        labelsize = sizeof(external_label) - 1;\n    } else {\n        label = resumption_label;\n        labelsize = sizeof(resumption_label) - 1;\n    }\n\n    /*\n     * Generate the early_secret. On the server side we've selected a PSK to\n     * resume with (internal or external) so we always do this. On the client\n     * side we do this for a non-external (i.e. resumption) PSK so that it\n     * is in place for sending early data. For client side external PSK we\n     * generate it but store it away for later use.\n     */\n    if (s->server || !external)\n        early_secret = (unsigned char *)s->early_secret;\n    else\n        early_secret = (unsigned char *)sess->early_secret;\n    if (!tls13_generate_secret(s, md, NULL, sess->master_key,\n                               sess->master_key_length, early_secret)) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Create the handshake hash for the binder key...the messages so far are\n     * empty!\n     */\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL\n            || EVP_DigestInit_ex(mctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the binder key */\n    if (!tls13_hkdf_expand(s, md, early_secret, (unsigned char *)label,\n                           labelsize, hash, binderkey, hashsize)) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the finished key */\n    if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Get a hash of the ClientHello up to the start of the binders. If we are\n     * following a HelloRetryRequest then this includes the hash of the first\n     * ClientHello and the HelloRetryRequest itself.\n     */\n    if (s->hello_retry_request) {\n        size_t hdatalen;\n        void *hdata;\n\n        hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n        if (hdatalen <= 0) {\n            SSLerr(SSL_F_TLS_PSK_DO_BINDER, SSL_R_BAD_HANDSHAKE_LENGTH);\n            goto err;\n        }\n\n        /*\n         * For servers the handshake buffer data will include the second\n         * ClientHello - which we don't want - so we need to take that bit off.\n         */\n        if (s->server) {\n            PACKET hashprefix, msg;\n\n            /* Find how many bytes are left after the first two messages */\n            if (!PACKET_buf_init(&hashprefix, hdata, hdatalen)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) {\n                SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            hdatalen -= PACKET_remaining(&hashprefix);\n        }\n\n        if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) {\n            SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    mackey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, finishedkey, hashsize);\n    if (mackey == NULL) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (!sign)\n        binderout = tmpbinder;\n\n    bindersize = hashsize;\n    if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0\n            || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0\n            || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0\n            || bindersize != hashsize) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (sign) {\n        ret = 1;\n    } else {\n        /* HMAC keys can't do EVP_DigestVerify* - use CRYPTO_memcmp instead */\n        ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);\n    }\n\n err:\n    OPENSSL_cleanse(binderkey, sizeof(binderkey));\n    OPENSSL_cleanse(finishedkey, sizeof(finishedkey));\n    EVP_PKEY_free(mackey);\n    EVP_MD_CTX_free(mctx);\n\n    return ret;\n}", "patch_func_code": "int tls_psk_do_binder(SSL *s, const EVP_MD *md, const unsigned char *msgstart,\n                      size_t binderoffset, const unsigned char *binderin,\n                      unsigned char *binderout, SSL_SESSION *sess, int sign,\n                      int external)\n{\n    EVP_PKEY *mackey = NULL;\n    EVP_MD_CTX *mctx = NULL;\n    unsigned char hash[EVP_MAX_MD_SIZE], binderkey[EVP_MAX_MD_SIZE];\n    unsigned char finishedkey[EVP_MAX_MD_SIZE], tmpbinder[EVP_MAX_MD_SIZE];\n    unsigned char *early_secret;\n    const char resumption_label[] = \"res binder\";\n    const char external_label[] = \"ext binder\";\n    const char *label;\n    size_t bindersize, labelsize, hashsize = EVP_MD_size(md);\n    int ret = -1;\n\n    if (external) {\n        label = external_label;\n        labelsize = sizeof(external_label) - 1;\n    } else {\n        label = resumption_label;\n        labelsize = sizeof(resumption_label) - 1;\n    }\n\n    /*\n     * Generate the early_secret. On the server side we've selected a PSK to\n     * resume with (internal or external) so we always do this. On the client\n     * side we do this for a non-external (i.e. resumption) PSK so that it\n     * is in place for sending early data. For client side external PSK we\n     * generate it but store it away for later use.\n     */\n    if (s->server || !external)\n        early_secret = (unsigned char *)s->early_secret;\n    else\n        early_secret = (unsigned char *)sess->early_secret;\n    if (!tls13_generate_secret(s, md, NULL, sess->master_key,\n                               sess->master_key_length, early_secret)) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Create the handshake hash for the binder key...the messages so far are\n     * empty!\n     */\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL\n            || EVP_DigestInit_ex(mctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the binder key */\n    if (!tls13_hkdf_expand(s, md, early_secret, (unsigned char *)label,\n                           labelsize, hash, hashsize, binderkey, hashsize)) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /* Generate the finished key */\n    if (!tls13_derive_finishedkey(s, md, binderkey, finishedkey, hashsize)) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (EVP_DigestInit_ex(mctx, md, NULL) <= 0) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    /*\n     * Get a hash of the ClientHello up to the start of the binders. If we are\n     * following a HelloRetryRequest then this includes the hash of the first\n     * ClientHello and the HelloRetryRequest itself.\n     */\n    if (s->hello_retry_request) {\n        size_t hdatalen;\n        void *hdata;\n\n        hdatalen = BIO_get_mem_data(s->s3->handshake_buffer, &hdata);\n        if (hdatalen <= 0) {\n            SSLerr(SSL_F_TLS_PSK_DO_BINDER, SSL_R_BAD_HANDSHAKE_LENGTH);\n            goto err;\n        }\n\n        /*\n         * For servers the handshake buffer data will include the second\n         * ClientHello - which we don't want - so we need to take that bit off.\n         */\n        if (s->server) {\n            PACKET hashprefix, msg;\n\n            /* Find how many bytes are left after the first two messages */\n            if (!PACKET_buf_init(&hashprefix, hdata, hdatalen)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)\n                    || !PACKET_forward(&hashprefix, 1)\n                    || !PACKET_get_length_prefixed_3(&hashprefix, &msg)) {\n                SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n                goto err;\n            }\n            hdatalen -= PACKET_remaining(&hashprefix);\n        }\n\n        if (EVP_DigestUpdate(mctx, hdata, hdatalen) <= 0) {\n            SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n            goto err;\n        }\n    }\n\n    if (EVP_DigestUpdate(mctx, msgstart, binderoffset) <= 0\n            || EVP_DigestFinal_ex(mctx, hash, NULL) <= 0) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    mackey = EVP_PKEY_new_mac_key(EVP_PKEY_HMAC, NULL, finishedkey, hashsize);\n    if (mackey == NULL) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (!sign)\n        binderout = tmpbinder;\n\n    bindersize = hashsize;\n    if (EVP_DigestSignInit(mctx, NULL, md, NULL, mackey) <= 0\n            || EVP_DigestSignUpdate(mctx, hash, hashsize) <= 0\n            || EVP_DigestSignFinal(mctx, binderout, &bindersize) <= 0\n            || bindersize != hashsize) {\n        SSLerr(SSL_F_TLS_PSK_DO_BINDER, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n\n    if (sign) {\n        ret = 1;\n    } else {\n        /* HMAC keys can't do EVP_DigestVerify* - use CRYPTO_memcmp instead */\n        ret = (CRYPTO_memcmp(binderin, binderout, hashsize) == 0);\n    }\n\n err:\n    OPENSSL_cleanse(binderkey, sizeof(binderkey));\n    OPENSSL_cleanse(finishedkey, sizeof(finishedkey));\n    EVP_PKEY_free(mackey);\n    EVP_MD_CTX_free(mctx);\n\n    return ret;\n}", "before_change_lines": [56], "raw_before_change_lines": [56], "after_change_lines": [56], "raw_after_change_lines": [56], "bug_lines": [56], "added": [false], "idx": 480}
{"project": "openssl", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "15541----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b8acf421ad15375c949e9d703b42048bdc81b90a_1.json----ssl23_get_client_hello", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_b8acf421ad15375c949e9d703b42048bdc81b90a_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b8acf421ad15375c949e9d703b42048bdc81b90a_1.json", "function_name": "ssl23_get_client_hello", "vul_func_code": "int ssl23_get_client_hello(SSL *s)\n\t{\n\tchar buf_space[8];\n\tchar *buf= &(buf_space[0]);\n\tunsigned char *p,*d,*dd;\n\tunsigned int i;\n\tunsigned int csl,sil,cl;\n\tint n=0,j,tls1=0;\n\tint type=0,use_sslv2_strong=0;\n\tint v[2];\n\n\tif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n\t\t{\n\t\t/* read the initial header */\n\t\tv[0]=v[1]=0;\n\n\t\tif (!ssl3_setup_buffers(s)) goto err;\n\n\t\tn=ssl23_read_bytes(s,7);\n\t\tif (n != 7) return(n); /* n == -1 || n == 0 */\n\n\t\tp=s->packet;\n\n\t\tmemcpy(buf,p,n);\n\n\t\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n\t\t\t{\n\t\t\t/* SSLv2 header */\n\t\t\tif ((p[3] == 0x00) && (p[4] == 0x02))\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv2 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\t\t\t\t}\n\t\t\telse if (p[3] == SSL3_VERSION_MAJOR)\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv3/TLSv1 */\n\t\t\t\tif (p[4] >= TLS1_VERSION_MINOR)\n\t\t\t\t\t{\n\t\t\t\t\tif (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttls1=1;\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\n\t\t\t\tif (s->options & SSL_OP_NON_EXPORT_FIRST)\n\t\t\t\t\t/* not only confusing, but broken! */\n\t\t\t\t\t{\n\t\t\t\t\tSTACK_OF(SSL_CIPHER) *sk;\n\t\t\t\t\tSSL_CIPHER *c;\n\t\t\t\t\tint ne2,ne3;\n\n\t\t\t\t\tj=((p[0]&0x7f)<<8)|p[1];\n\t\t\t\t\tif (j > (1024*4))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tn=ssl23_read_bytes(s,j+2);\n\t\t\t\t\tif (n <= 0) return(n);\n\t\t\t\t\tp=s->packet;\n\n\t\t\t\t\tif ((buf=Malloc(n)) == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t}\n\t\t\t\t\tmemcpy(buf,p,n);\n\n\t\t\t\t\tp+=5;\n\t\t\t\t\tn2s(p,csl);\n\t\t\t\t\tp+=4;\n\n\t\t\t\t\tsk=ssl_bytes_to_cipher_list(\n\t\t\t\t\t\ts,p,csl,NULL);\n\t\t\t\t\tif (sk != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tne2=ne3=0;\n\t\t\t\t\t\tfor (j=0; j<sk_SSL_CIPHER_num(sk); j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc=sk_SSL_CIPHER_value(sk,j);\n\t\t\t\t\t\t\tif (!SSL_C_IS_EXPORT(c))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((c->id>>24L) == 2L)\n\t\t\t\t\t\t\t\t\tne2=1;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tne3=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ne2 && !ne3)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t\tuse_sslv2_strong=1;\n\t\t\t\t\t\t\tgoto next_bit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n\t\t\t (p[1] == SSL3_VERSION_MAJOR) &&\n\t\t\t (p[5] == SSL3_MT_CLIENT_HELLO))\n\t\t\t{\n\t\t\tv[0]=p[1]; v[1]=p[2];\n\t\t\t/* true SSLv3 or tls1 */\n\t\t\tif (p[2] >= TLS1_VERSION_MINOR)\n\t\t\t\t{\n\t\t\t\tif (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\ttype=3;\n\t\t\t\t\ttls1=1;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\ttype=3;\n\t\t\t\t}\n\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\ttype=3;\n\t\t\t}\n\t\telse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n\t\t\t (strncmp(\"POST \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"HEAD \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"PUT \", (char *)p,4) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\telse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\nnext_bit:\n\tif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n\t\t{\n\t\t/* we have a SSLv3/TLSv1 in a SSLv2 header */\n\t\ttype=2;\n\t\tp=s->packet;\n\t\tv[0] = p[3];\n\t\tv[1] = p[4];\n\t\tn=((p[0]&0x7f)<<8)|p[1];\n\t\tif (n > (1024*4))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tj=ssl23_read_bytes(s,n+2);\n\t\tif (j <= 0) return(j);\n\n\t\tssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2);\n\n\t\tp=s->packet;\n\t\tp+=5;\n\t\tn2s(p,csl);\n\t\tn2s(p,sil);\n\t\tn2s(p,cl);\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tif ((csl+sil+cl+11) != s->packet_length)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t*(d++)=SSL3_VERSION_MAJOR;\n\t\tif (tls1)\n\t\t\t*(d++)=TLS1_VERSION_MINOR;\n\t\telse\n\t\t\t*(d++)=SSL3_VERSION_MINOR;\n\n\t\t/* lets populate the random area */\n\t\t/* get the chalenge_length */\n\t\ti=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\n\t\tmemset(d,0,SSL3_RANDOM_SIZE);\n\t\tmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\n\t\td+=SSL3_RANDOM_SIZE;\n\n\t\t/* no session-id reuse */\n\t\t*(d++)=0;\n\n\t\t/* ciphers */\n\t\tj=0;\n\t\tdd=d;\n\t\td+=2;\n\t\tfor (i=0; i<csl; i+=3)\n\t\t\t{\n\t\t\tif (p[i] != 0) continue;\n\t\t\t*(d++)=p[i+1];\n\t\t\t*(d++)=p[i+2];\n\t\t\tj+=2;\n\t\t\t}\n\t\ts2n(j,dd);\n\n\t\t/* COMPRESSION */\n\t\t*(d++)=1;\n\t\t*(d++)=0;\n\t\t\n\t\ti=(d-(unsigned char *)s->init_buf->data);\n\n\t\t/* get the data reused from the init_buf */\n\t\ts->s3->tmp.reuse_message=1;\n\t\ts->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\n\t\ts->s3->tmp.message_size=i;\n\t\t}\n\n\tif (type == 1)\n\t\t{\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3/TLSv1 setup and put in the\n\t\t * sslv2 stuff. */\n\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_CLIENT_HELLO_A;\n\t\tif ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||\n\t\t\tuse_sslv2_strong)\n\t\t\ts->s2->ssl2_rollback=0;\n\t\telse\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the 5 bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\ts->method=SSLv2_server_method();\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\n\tif ((type == 2) || (type == 3))\n\t\t{\n\t\t/* we have SSLv3/TLSv1 */\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\tif (type == 3)\n\t\t\t{\n\t\t\t/* put the 'n' bytes we have read into the input buffer\n\t\t\t * for SSLv3 */\n\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\ts->packet_length=n;\n\t\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\t\tmemcpy(s->packet,buf,n);\n\t\t\ts->s3->rbuf.left=n;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->packet_length=0;\n\t\t\ts->s3->rbuf.left=0;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\n\t\tif (tls1)\n\t\t\t{\n\t\t\ts->version=TLS1_VERSION;\n\t\t\ts->method=TLSv1_server_method();\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->version=SSL3_VERSION;\n\t\t\ts->method=SSLv3_server_method();\n\t\t\t}\n\t\ts->client_version=(v[0]<<8)|v[1];\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\t\n\tif ((type < 1) || (type > 3))\n\t\t{\n\t\t/* bad, very bad */\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\tif (buf != buf_space) Free(buf);\n\ts->first_packet=1;\n\treturn(SSL_accept(s));\nerr:\n\tif (buf != buf_space) Free(buf);\n\treturn(-1);\n\t}", "patch_func_code": "int ssl23_get_client_hello(SSL *s)\n\t{\n\tchar buf_space[10];\n\tchar *buf= &(buf_space[0]);\n\tunsigned char *p,*d,*dd;\n\tunsigned int i;\n\tunsigned int csl,sil,cl;\n\tint n=0,j,tls1=0;\n\tint type=0,use_sslv2_strong=0;\n\tint v[2];\n\n\tif (s->state ==\tSSL23_ST_SR_CLNT_HELLO_A)\n\t\t{\n\t\t/* read the initial header */\n\t\tv[0]=v[1]=0;\n\n\t\tif (!ssl3_setup_buffers(s)) goto err;\n\n\t\tn=ssl23_read_bytes(s,10);\n\t\tif (n != 10) return(n); /* n == -1 || n == 0 */\n\n\t\tp=s->packet;\n\n\t\tmemcpy(buf,p,n);\n\n\t\tif ((p[0] & 0x80) && (p[2] == SSL2_MT_CLIENT_HELLO))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv2 header\n\t\t\t */\n\t\t\tif ((p[3] == 0x00) && (p[4] == 0x02))\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv2 */\n\t\t\t\tif (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\t\t\t\t}\n\t\t\telse if (p[3] == SSL3_VERSION_MAJOR)\n\t\t\t\t{\n\t\t\t\tv[0]=p[3]; v[1]=p[4];\n\t\t\t\t/* SSLv3/TLSv1 */\n\t\t\t\tif (p[4] >= TLS1_VERSION_MINOR)\n\t\t\t\t\t{\n\t\t\t\t\tif (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttls1=1;\n\t\t\t\t\t\t/* type=2; */ /* done later to survive restarts */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t/* type=2; */\n\t\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\t{\n\t\t\t\t\t/* type=2; */\n\t\t\t\t\ts->state=SSL23_ST_SR_CLNT_HELLO_B;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv2))\n\t\t\t\t\ttype=1;\n\n\t\t\t\tif (s->options & SSL_OP_NON_EXPORT_FIRST)\n\t\t\t\t\t/* Not only utterly confusing, but broken\n\t\t\t\t\t * ('fractured programming'?) -- the details\n\t\t\t\t\t * of this block nearly make it work\n\t\t\t\t\t * as intended in this environment, but on one\n\t\t\t\t\t * of the fine points (w.r.t. restarts) it fails.\n\t\t\t\t\t * The obvious fix would be even more devastating\n\t\t\t\t\t * to program structure; if you want the functionality,\n\t\t\t\t\t * throw this away and implement it in a way\n\t\t\t\t\t * that makes sense */\n\t\t\t\t\t{\n\t\t\t\t\tSTACK_OF(SSL_CIPHER) *sk;\n\t\t\t\t\tSSL_CIPHER *c;\n\t\t\t\t\tint ne2,ne3;\n\n\t\t\t\t\tj=((p[0]&0x7f)<<8)|p[1];\n\t\t\t\t\tif (j > (1024*4))\n\t\t\t\t\t\t{\n\t\t\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tn=ssl23_read_bytes(s,j+2);\n\t\t\t\t\tif (n <= 0) return(n);\n\t\t\t\t\tp=s->packet;\n\n\t\t\t\t\tif ((buf=Malloc(n)) == NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,ERR_R_MALLOC_FAILURE);\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t}\n\t\t\t\t\tmemcpy(buf,p,n);\n\n\t\t\t\t\tp+=5;\n\t\t\t\t\tn2s(p,csl);\n\t\t\t\t\tp+=4;\n\n\t\t\t\t\tsk=ssl_bytes_to_cipher_list(\n\t\t\t\t\t\ts,p,csl,NULL);\n\t\t\t\t\tif (sk != NULL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tne2=ne3=0;\n\t\t\t\t\t\tfor (j=0; j<sk_SSL_CIPHER_num(sk); j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc=sk_SSL_CIPHER_value(sk,j);\n\t\t\t\t\t\t\tif (!SSL_C_IS_EXPORT(c))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((c->id>>24L) == 2L)\n\t\t\t\t\t\t\t\t\tne2=1;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tne3=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ne2 && !ne3)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype=1;\n\t\t\t\t\t\t\tuse_sslv2_strong=1;\n\t\t\t\t\t\t\tgoto next_bit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\telse if ((p[0] == SSL3_RT_HANDSHAKE) &&\n\t\t\t (p[1] == SSL3_VERSION_MAJOR) &&\n\t\t\t (p[5] == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t (p[9] == p[1]))\n\t\t\t{\n\t\t\t/*\n\t\t\t * SSLv3 or tls1 header\n\t\t\t */\n\t\t\t\n\t\t\t/* we must look at client_version inside the client hello: */\n\t\t\tn=ssl23_read_bytes(s,11);\n\t\t\t/* restarts are no problem here, stay in initial state */\n\t\t\tif (n != 11)\n\t\t\t\treturn(n); /* n == -1 || n == 0 */\n\n\t\t\tv[0]=p[9]; v[1]=p[10];\n\t\t\tif (p[2] >= TLS1_VERSION_MINOR)\n\t\t\t\t{\n\t\t\t\tif (!(s->options & SSL_OP_NO_TLSv1))\n\t\t\t\t\t{\n\t\t\t\t\ttype=3;\n\t\t\t\t\ttls1=1;\n\t\t\t\t\t}\n\t\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\t\ttype=3;\n\t\t\t\t}\n\t\t\telse if (!(s->options & SSL_OP_NO_SSLv3))\n\t\t\t\ttype=3;\n\t\t\t}\n\t\telse if ((strncmp(\"GET \", (char *)p,4) == 0) ||\n\t\t\t (strncmp(\"POST \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"HEAD \",(char *)p,5) == 0) ||\n\t\t\t (strncmp(\"PUT \", (char *)p,4) == 0))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTP_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\telse if (strncmp(\"CONNECT\",(char *)p,7) == 0)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_HTTPS_PROXY_REQUEST);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\nnext_bit:\n\tif (s->state == SSL23_ST_SR_CLNT_HELLO_B)\n\t\t{\n\t\t/* we have a SSLv3/TLSv1 in a SSLv2 header\n\t\t * (other cases skip this state)* */\n\t\ttype=2;\n\t\tp=s->packet;\n\t\tv[0] = p[3];\n\t\tv[1] = p[4];\n\t\tn=((p[0]&0x7f)<<8)|p[1];\n\t\tif (n > (1024*4))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_TOO_LARGE);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\tj=ssl23_read_bytes(s,n+2);\n\t\tif (j <= 0) return(j);\n\n\t\tssl3_finish_mac(s,&(s->packet[2]),s->packet_length-2);\n\n\t\tp=s->packet;\n\t\tp+=5;\n\t\tn2s(p,csl);\n\t\tn2s(p,sil);\n\t\tn2s(p,cl);\n\t\td=(unsigned char *)s->init_buf->data;\n\t\tif ((csl+sil+cl+11) != s->packet_length)\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_RECORD_LENGTH_MISMATCH);\n\t\t\tgoto err;\n\t\t\t}\n\n\t\t*(d++)=SSL3_VERSION_MAJOR;\n\t\tif (tls1)\n\t\t\t*(d++)=TLS1_VERSION_MINOR;\n\t\telse\n\t\t\t*(d++)=SSL3_VERSION_MINOR;\n\n\t\t/* lets populate the random area */\n\t\t/* get the chalenge_length */\n\t\ti=(cl > SSL3_RANDOM_SIZE)?SSL3_RANDOM_SIZE:cl;\n\t\tmemset(d,0,SSL3_RANDOM_SIZE);\n\t\tmemcpy(&(d[SSL3_RANDOM_SIZE-i]),&(p[csl+sil]),i);\n\t\td+=SSL3_RANDOM_SIZE;\n\n\t\t/* no session-id reuse */\n\t\t*(d++)=0;\n\n\t\t/* ciphers */\n\t\tj=0;\n\t\tdd=d;\n\t\td+=2;\n\t\tfor (i=0; i<csl; i+=3)\n\t\t\t{\n\t\t\tif (p[i] != 0) continue;\n\t\t\t*(d++)=p[i+1];\n\t\t\t*(d++)=p[i+2];\n\t\t\tj+=2;\n\t\t\t}\n\t\ts2n(j,dd);\n\n\t\t/* COMPRESSION */\n\t\t*(d++)=1;\n\t\t*(d++)=0;\n\t\t\n\t\ti=(d-(unsigned char *)s->init_buf->data);\n\n\t\t/* get the data reused from the init_buf */\n\t\ts->s3->tmp.reuse_message=1;\n\t\ts->s3->tmp.message_type=SSL3_MT_CLIENT_HELLO;\n\t\ts->s3->tmp.message_size=i;\n\t\t}\n\n\t/* imaginary new state (for program structure): */\n\t/* s->state = SSL23_SR_CLNT_HELLO_C */\n\n\tif (type == 1)\n\t\t{\n\t\t/* we are talking sslv2 */\n\t\t/* we need to clean up the SSLv3/TLSv1 setup and put in the\n\t\t * sslv2 stuff. */\n\n\t\tif (s->s2 == NULL)\n\t\t\t{\n\t\t\tif (!ssl2_new(s))\n\t\t\t\tgoto err;\n\t\t\t}\n\t\telse\n\t\t\tssl2_clear(s);\n\n\t\tif (s->s3 != NULL) ssl3_free(s);\n\n\t\tif (!BUF_MEM_grow(s->init_buf,\n\t\t\tSSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER))\n\t\t\t{\n\t\t\tgoto err;\n\t\t\t}\n\n\t\ts->state=SSL2_ST_GET_CLIENT_HELLO_A;\n\t\tif ((s->options & SSL_OP_MSIE_SSLV2_RSA_PADDING) ||\n\t\t\tuse_sslv2_strong)\n\t\t\ts->s2->ssl2_rollback=0;\n\t\telse\n\t\t\ts->s2->ssl2_rollback=1;\n\n\t\t/* setup the n bytes we have read so we get them from\n\t\t * the sslv2 buffer */\n\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\ts->packet_length=n;\n\t\ts->packet= &(s->s2->rbuf[0]);\n\t\tmemcpy(s->packet,buf,n);\n\t\ts->s2->rbuf_left=n;\n\t\ts->s2->rbuf_offs=0;\n\n\t\ts->method=SSLv2_server_method();\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\n\tif ((type == 2) || (type == 3))\n\t\t{\n\t\t/* we have SSLv3/TLSv1 (type 2: SSL2 style, type 3: SSL3/TLS style) */\n\n\t\tif (!ssl_init_wbio_buffer(s,1)) goto err;\n\n\t\t/* we are in this state */\n\t\ts->state=SSL3_ST_SR_CLNT_HELLO_A;\n\n\t\tif (type == 3)\n\t\t\t{\n\t\t\t/* put the 'n' bytes we have read into the input buffer\n\t\t\t * for SSLv3 */\n\t\t\ts->rstate=SSL_ST_READ_HEADER;\n\t\t\ts->packet_length=n;\n\t\t\ts->packet= &(s->s3->rbuf.buf[0]);\n\t\t\tmemcpy(s->packet,buf,n);\n\t\t\ts->s3->rbuf.left=n;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->packet_length=0;\n\t\t\ts->s3->rbuf.left=0;\n\t\t\ts->s3->rbuf.offset=0;\n\t\t\t}\n\n\t\tif (tls1)\n\t\t\t{\n\t\t\ts->version=TLS1_VERSION;\n\t\t\ts->method=TLSv1_server_method();\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\ts->version=SSL3_VERSION;\n\t\t\ts->method=SSLv3_server_method();\n\t\t\t}\n#if 0 /* ssl3_get_client_hello does this */\n\t\ts->client_version=(v[0]<<8)|v[1];\n#endif\n\t\ts->handshake_func=s->method->ssl_accept;\n\t\t}\n\t\n\tif ((type < 1) || (type > 3))\n\t\t{\n\t\t/* bad, very bad */\n\t\tSSLerr(SSL_F_SSL23_GET_CLIENT_HELLO,SSL_R_UNKNOWN_PROTOCOL);\n\t\tgoto err;\n\t\t}\n\ts->init_num=0;\n\n\tif (buf != buf_space) Free(buf);\n\ts->first_packet=1;\n\treturn(SSL_accept(s));\nerr:\n\tif (buf != buf_space) Free(buf);\n\treturn(-1);\n\t}", "before_change_lines": [3, 19, 20, 118, 120], "raw_before_change_lines": [3, 19, 20, 28, 62, 118, 120, 121, 153, 252, 267], "after_change_lines": [3, 19, 20, 29, 30, 61, 64, 70, 71, 72, 73, 74, 75, 76, 77, 133, 134, 137, 138, 141, 143, 144, 146, 179, 331, 333], "raw_after_change_lines": [3, 19, 20, 28, 29, 30, 47, 52, 61, 62, 64, 69, 70, 71, 72, 73, 74, 75, 76, 77, 133, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 178, 179, 249, 250, 251, 281, 296, 331, 333], "bug_lines": [3, 19, 20, 28, 62, 118, 120, 121, 153, 252, 267], "added": [false, false, false, false, false, false, false, false, false, false, false], "idx": 481}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "15588----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b9d912813e7f34c64d38422e12edb60094a19c64_1.json----OPENSSL_sk_new", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_b9d912813e7f34c64d38422e12edb60094a19c64_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_b9d912813e7f34c64d38422e12edb60094a19c64_1.json", "function_name": "OPENSSL_sk_new", "vul_func_code": "OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc c)\n{\n    OPENSSL_STACK *ret;\n\n    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL)\n        goto err;\n    if ((ret->data = OPENSSL_zalloc(sizeof(*ret->data) * MIN_NODES)) == NULL)\n        goto err;\n    ret->comp = c;\n    ret->num_alloc = MIN_NODES;\n    return (ret);\n\n err:\n    OPENSSL_free(ret);\n    return (NULL);\n}", "patch_func_code": "OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc c)\n{\n    OPENSSL_STACK *ret;\n\n    if ((ret = OPENSSL_zalloc(sizeof(*ret))) == NULL)\n        goto err;\n    if ((ret->data = OPENSSL_zalloc(sizeof(*ret->data) * min_nodes)) == NULL)\n        goto err;\n    ret->comp = c;\n    ret->num_alloc = min_nodes;\n    return (ret);\n\n err:\n    OPENSSL_free(ret);\n    return (NULL);\n}", "before_change_lines": [7, 10], "raw_before_change_lines": [7, 10], "after_change_lines": [7, 10], "raw_after_change_lines": [7, 10], "bug_lines": [7, 10], "added": [false, false], "idx": 482}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "15810----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c2abd58491012e6925ca69f39c620f50632e8c37_1.json----GENERAL_NAME_print", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_c2abd58491012e6925ca69f39c620f50632e8c37_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c2abd58491012e6925ca69f39c620f50632e8c37_1.json", "function_name": "GENERAL_NAME_print", "vul_func_code": "int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)\n{\n    unsigned char *p;\n    int i;\n    switch (gen->type) {\n    case GEN_OTHERNAME:\n        BIO_printf(out, \"othername:<unsupported>\");\n        break;\n\n    case GEN_X400:\n        BIO_printf(out, \"X400Name:<unsupported>\");\n        break;\n\n    case GEN_EDIPARTY:\n        /* Maybe fix this: it is supported now */\n        BIO_printf(out, \"EdiPartyName:<unsupported>\");\n        break;\n\n    case GEN_EMAIL:\n        BIO_printf(out, \"email:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_DNS:\n        BIO_printf(out, \"DNS:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_URI:\n        BIO_printf(out, \"URI:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_DIRNAME:\n        BIO_printf(out, \"DirName: \");\n        X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE);\n        break;\n\n    case GEN_IPADD:\n        p = gen->d.ip->data;\n        if (gen->d.ip->length == 4)\n            BIO_printf(out, \"IP Address:%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n        else if (gen->d.ip->length == 16) {\n            BIO_printf(out, \"IP Address\");\n            for (i = 0; i < 8; i++) {\n                BIO_printf(out, \":%X\", p[0] << 8 | p[1]);\n                p += 2;\n            }\n            BIO_puts(out, \"\\n\");\n        } else {\n            BIO_printf(out, \"IP Address:<invalid>\");\n            break;\n        }\n        break;\n\n    case GEN_RID:\n        BIO_printf(out, \"Registered ID\");\n        i2a_ASN1_OBJECT(out, gen->d.rid);\n        break;\n    }\n    return 1;\n}", "patch_func_code": "int GENERAL_NAME_print(BIO *out, GENERAL_NAME *gen)\n{\n    unsigned char *p;\n    int i;\n    switch (gen->type) {\n    case GEN_OTHERNAME:\n        BIO_printf(out, \"othername:<unsupported>\");\n        break;\n\n    case GEN_X400:\n        BIO_printf(out, \"X400Name:<unsupported>\");\n        break;\n\n    case GEN_EDIPARTY:\n        /* Maybe fix this: it is supported now */\n        BIO_printf(out, \"EdiPartyName:<unsupported>\");\n        break;\n\n    case GEN_EMAIL:\n        BIO_printf(out, \"email:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_DNS:\n        BIO_printf(out, \"DNS:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_URI:\n        BIO_printf(out, \"URI:%s\", gen->d.ia5->data);\n        break;\n\n    case GEN_DIRNAME:\n        BIO_printf(out, \"DirName:\");\n        X509_NAME_print_ex(out, gen->d.dirn, 0, XN_FLAG_ONELINE);\n        break;\n\n    case GEN_IPADD:\n        p = gen->d.ip->data;\n        if (gen->d.ip->length == 4)\n            BIO_printf(out, \"IP Address:%d.%d.%d.%d\", p[0], p[1], p[2], p[3]);\n        else if (gen->d.ip->length == 16) {\n            BIO_printf(out, \"IP Address\");\n            for (i = 0; i < 8; i++) {\n                BIO_printf(out, \":%X\", p[0] << 8 | p[1]);\n                p += 2;\n            }\n            BIO_puts(out, \"\\n\");\n        } else {\n            BIO_printf(out, \"IP Address:<invalid>\");\n            break;\n        }\n        break;\n\n    case GEN_RID:\n        BIO_printf(out, \"Registered ID:\");\n        i2a_ASN1_OBJECT(out, gen->d.rid);\n        break;\n    }\n    return 1;\n}", "before_change_lines": [32, 54], "raw_before_change_lines": [32, 54], "after_change_lines": [32, 54], "raw_after_change_lines": [32, 54], "bug_lines": [32, 54], "added": [false, false], "idx": 483}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "15815----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c2d8a680d948497296b7d56c232ab4337aef6a62_1.json----DSO_convert_filename", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_c2d8a680d948497296b7d56c232ab4337aef6a62_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c2d8a680d948497296b7d56c232ab4337aef6a62_1.json", "function_name": "DSO_convert_filename", "vul_func_code": "char *DSO_convert_filename(DSO *dso, const char *filename)\n\t{\n\tchar *result = NULL;\n\n\tif(dso == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\tif(filename == NULL)\n\t\tfilename = dso->filename;\n\tif(filename == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,DSO_R_NO_FILENAME);\n\t\treturn(NULL);\n\t\t}\n\tif((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0)\n\t\t{\n\t\tif(dso->name_converter != NULL)\n\t\t\tresult = dso->name_converter(dso, filename);\n\t\telse if(dso->meth->dso_name_converter != NULL)\n\t\t\tresult = dso->meth->dso_name_converter(dso, filename);\n\t\t}\n\tif(result == NULL)\n\t\t{\n\t\tresult = OPENSSL_malloc(strlen(filename) + 1);\n\t\tif(result == NULL)\n\t\t\t{\n\t\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,\n\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\tstrcpy(result, filename);\n\t\t}\n\treturn(result);\n\t}", "patch_func_code": "char *DSO_convert_filename(DSO *dso, const char *filename)\n\t{\n\tchar *result = NULL;\n\n\tif(dso == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,ERR_R_PASSED_NULL_PARAMETER);\n\t\treturn(NULL);\n\t\t}\n\tif(filename == NULL)\n\t\tfilename = dso->filename;\n\tif(filename == NULL)\n\t\t{\n\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,DSO_R_NO_FILENAME);\n\t\treturn(NULL);\n\t\t}\n\tif((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0)\n\t\t{\n\t\tif(dso->name_converter != NULL)\n\t\t\tresult = dso->name_converter(dso, filename);\n\t\telse if(dso->meth->dso_name_converter != NULL)\n\t\t\tresult = dso->meth->dso_name_converter(dso, filename);\n\t\t}\n\tif(result == NULL)\n\t\t{\n\t\tresult = OPENSSL_malloc(strlen(filename) + 1);\n\t\tif(result == NULL)\n\t\t\t{\n\t\t\tDSOerr(DSO_F_DSO_CONVERT_FILENAME,\n\t\t\t\t\tERR_R_MALLOC_FAILURE);\n\t\t\treturn(NULL);\n\t\t\t}\n\t\tBUF_strlcpy(result, filename, strlen(filename) + 1);\n\t\t}\n\treturn(result);\n\t}", "before_change_lines": [33], "raw_before_change_lines": [33], "after_change_lines": [33], "raw_after_change_lines": [33], "bug_lines": [33], "added": [false], "idx": 484}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L4", "filepath_func": "15872----BUFFER_OVERRUN_L4----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c4ce0c3f067175c913e097e5d518e131be06fd80_1.json----x9_62_tests", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_c4ce0c3f067175c913e097e5d518e131be06fd80_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c4ce0c3f067175c913e097e5d518e131be06fd80_1.json", "function_name": "x9_62_tests", "vul_func_code": "int x9_62_tests(BIO *out)\n{\n    int ret = 0;\n\n    BIO_printf(out, \"some tests from X9.62:\\n\");\n\n    /* set own rand method */\n    if (!change_rand())\n        goto x962_err;\n\n    if (!x9_62_test_internal(out, NID_X9_62_prime192v1,\n                             \"3342403536405981729393488334694600415596881826869351677613\",\n                             \"5735822328888155254683894997897571951568553642892029982342\"))\n        goto x962_err;\n    if (!x9_62_test_internal(out, NID_X9_62_prime239v1,\n                             \"3086361431751678114926225473006680188549593787585317781474\"\n                             \"62058306432176\",\n                             \"3238135532097973577080787768312505059318910517550078427819\"\n                             \"78505179448783\"))\n        goto x962_err;\n# ifndef OPENSSL_NO_EC2M\n    if (!x9_62_test_internal(out, NID_X9_62_c2tnb191v1,\n                             \"87194383164871543355722284926904419997237591535066528048\",\n                             \"308992691965804947361541664549085895292153777025772063598\"))\n        goto x962_err;\n    if (!x9_62_test_internal(out, NID_X9_62_c2tnb239v1,\n                             \"2159633321041961198501834003903461262881815148684178964245\"\n                             \"5876922391552\",\n                             \"1970303740007316867383349976549972270528498040721988191026\"\n                             \"49413465737174\"))\n        goto x962_err;\n# endif\n    ret = 1;\n x962_err:\n    if (!restore_rand())\n        ret = 0;\n    return ret;\n}", "patch_func_code": "static int x9_62_tests()\n{\n    int ret = 0;\n\n    /* set own rand method */\n    if (!change_rand())\n        goto x962_err;\n\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_prime192v1,\n                 \"3342403536405981729393488334694600415596881826869351677613\",\n                 \"5735822328888155254683894997897571951568553642892029982342\")))\n        goto x962_err;\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_prime239v1,\n                 \"3086361431751678114926225473006680188549593787585317781474\"\n                             \"62058306432176\",\n                 \"3238135532097973577080787768312505059318910517550078427819\"\n                             \"78505179448783\")))\n        goto x962_err;\n\n# ifndef OPENSSL_NO_EC2M\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb191v1,\n                 \"87194383164871543355722284926904419997237591535066528048\",\n                 \"308992691965804947361541664549085895292153777025772063598\")))\n        goto x962_err;\n    if (!TEST_true(x9_62_test_internal(NID_X9_62_c2tnb239v1,\n                 \"2159633321041961198501834003903461262881815148684178964245\"\n                             \"5876922391552\",\n                 \"1970303740007316867383349976549972270528498040721988191026\"\n                             \"49413465737174\")))\n        goto x962_err;\n# endif\n    ret = 1;\n\n x962_err:\n    if (!TEST_true(restore_rand()))\n        ret = 0;\n    return ret;\n}", "before_change_lines": [1, 5, 11, 12, 13, 15, 16, 18, 19, 22, 23, 24, 26, 27, 29, 30, 35], "raw_before_change_lines": [1, 5, 6, 11, 12, 13, 15, 16, 18, 19, 22, 23, 24, 26, 27, 29, 30, 35], "after_change_lines": [1, 9, 10, 11, 13, 14, 16, 17, 21, 22, 23, 25, 26, 28, 29, 35], "raw_after_change_lines": [1, 9, 10, 11, 13, 14, 16, 17, 19, 21, 22, 23, 25, 26, 28, 29, 33, 35], "bug_lines": [1, 5, 6, 11, 12, 13, 15, 16, 18, 19, 22, 23, 24, 26, 27, 29, 30, 35], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 485}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "15881----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c5361bff5cd0b71d3697896780499760d2a190a8_1.json----test_div", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_c5361bff5cd0b71d3697896780499760d2a190a8_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c5361bff5cd0b71d3697896780499760d2a190a8_1.json", "function_name": "test_div", "vul_func_code": "int test_div(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,b,c,d,e;\n\tint i;\n\tint j;\n\n\tBN_init(&a);\n\tBN_init(&b);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0+num1; i++)\n\t\t{\n\t\tif (i < num1)\n\t\t\t{\n\t\t\tBN_rand(&a,400,0,0);\n\t\t\tBN_copy(&b,&a);\n\t\t\tBN_lshift(&a,&a,i);\n\t\t\tBN_add_word(&a,i);\n\t\t\t}\n\t\telse\n\t\t\tBN_rand(&b,50+3*(i-num1),0,0);\n\t\ta.neg=rand_neg();\n\t\tb.neg=rand_neg();\n\t\tif (bp == NULL)\n\t\t\tfor (j=0; j<100; j++)\n\t\t\t\tBN_div(&d,&c,&a,&b,ctx);\n\t\tBN_div(&d,&c,&a,&b,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" / \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&d);\n\t\t\tBIO_puts(bp,\"\\n\");\n\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" % \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_mul(&e,&d,&b,ctx);\n\t\tBN_add(&d,&e,&c);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d))\n\t\t    {\n\t\t    fprintf(stderr,\"Division test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&b);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "patch_func_code": "int test_div(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,b,c,d,e;\n\tint i;\n\tint j;\n\n\tBN_init(&a);\n\tBN_init(&b);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0+num1; i++)\n\t\t{\n\t\tif (i < num1)\n\t\t\t{\n\t\t\tBN_bntest_rand(&a,400,0,0);\n\t\t\tBN_copy(&b,&a);\n\t\t\tBN_lshift(&a,&a,i);\n\t\t\tBN_add_word(&a,i);\n\t\t\t}\n\t\telse\n\t\t\tBN_bntest_rand(&b,50+3*(i-num1),0,0);\n\t\ta.neg=rand_neg();\n\t\tb.neg=rand_neg();\n\t\tif (bp == NULL)\n\t\t\tfor (j=0; j<100; j++)\n\t\t\t\tBN_div(&d,&c,&a,&b,ctx);\n\t\tBN_div(&d,&c,&a,&b,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" / \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&d);\n\t\t\tBIO_puts(bp,\"\\n\");\n\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" % \");\n\t\t\t\tBN_print(bp,&b);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_mul(&e,&d,&b,ctx);\n\t\tBN_add(&d,&e,&c);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d))\n\t\t    {\n\t\t    fprintf(stderr,\"Division test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&b);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "before_change_lines": [17, 23], "raw_before_change_lines": [17, 23], "after_change_lines": [17, 23], "raw_after_change_lines": [17, 23], "bug_lines": [17, 23], "added": [false, false], "idx": 486}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_U5", "filepath_func": "15912----INTEGER_OVERFLOW_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c619469b6024836dcdf3f3f4783ad5ef5c29b815_1.json----verify_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_c619469b6024836dcdf3f3f4783ad5ef5c29b815_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c619469b6024836dcdf3f3f4783ad5ef5c29b815_1.json", "function_name": "verify_main", "vul_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint i,ret=1;\n\tchar *CApath=NULL,*CAfile=NULL;\n\tX509_STORE *cert_ctx=NULL;\n\tX509_LOOKUP *lookup=NULL;\n\n\tcert_ctx=X509_STORE_new();\n\tif (cert_ctx == NULL) goto end;\n\tX509_STORE_set_verify_cb_func(cert_ctx,cb);\n\n\tERR_load_crypto_strings();\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\targc--;\n\targv++;\n\tfor (;;)\n\t\t{\n\t\tif (argc >= 1)\n\t\t\t{\n\t\t\tif (strcmp(*argv,\"-CApath\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCApath= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-CAfile\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCAfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-help\") == 0)\n\t\t\t\tgoto end;\n\t\t\telse if (strcmp(*argv,\"-verbose\") == 0)\n\t\t\t\tv_verbose=1;\n\t\t\telse if (argv[0][0] == '-')\n\t\t\t\tgoto end;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\targc--;\n\t\t\targv++;\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t\t}\n\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file());\n\tif (lookup == NULL) abort();\n\tif (!X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM))\n\t\tX509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\n\t\t\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir());\n\tif (lookup == NULL) abort();\n\tif (!X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM))\n\t\tX509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\n\n\n\tERR_clear_error();\n\tif (argc < 1) check(cert_ctx,NULL);\n\telse\n\t\tfor (i=0; i<argc; i++)\n\t\t\tcheck(cert_ctx,argv[i]);\n\tret=0;\nend:\n\tif (ret == 1)\n\t\tBIO_printf(bio_err,\"usage: verify [-verbose] [-CApath path] [-CAfile file] cert1 cert2 ...\\n\");\n\tif (cert_ctx != NULL) X509_STORE_free(cert_ctx);\n\tEXIT(ret);\n\t}", "patch_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint i,ret=1;\n\tchar *CApath=NULL,*CAfile=NULL;\n\tX509_STORE *cert_ctx=NULL;\n\tX509_LOOKUP *lookup=NULL;\n\n\tcert_ctx=X509_STORE_new();\n\tif (cert_ctx == NULL) goto end;\n\tX509_STORE_set_verify_cb_func(cert_ctx,cb);\n\n\tERR_load_crypto_strings();\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\targc--;\n\targv++;\n\tfor (;;)\n\t\t{\n\t\tif (argc >= 1)\n\t\t\t{\n\t\t\tif (strcmp(*argv,\"-CApath\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCApath= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-CAfile\") == 0)\n\t\t\t\t{\n\t\t\t\tif (argc-- < 1) goto end;\n\t\t\t\tCAfile= *(++argv);\n\t\t\t\t}\n\t\t\telse if (strcmp(*argv,\"-help\") == 0)\n\t\t\t\tgoto end;\n\t\t\telse if (strcmp(*argv,\"-verbose\") == 0)\n\t\t\t\tv_verbose=1;\n\t\t\telse if (argv[0][0] == '-')\n\t\t\t\tgoto end;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t\targc--;\n\t\t\targv++;\n\t\t\t}\n\t\telse\n\t\t\tbreak;\n\t\t}\n\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_file());\n\tif (lookup == NULL) abort();\n\tif (CAfile) {\n\t\ti=X509_LOOKUP_load_file(lookup,CAfile,X509_FILETYPE_PEM);\n\t\tif(!i) {\n\t\t\tBIO_printf(bio_err, \"Error loading file %s\\n\", CAfile);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t} else X509_LOOKUP_load_file(lookup,NULL,X509_FILETYPE_DEFAULT);\n\t\t\n\tlookup=X509_STORE_add_lookup(cert_ctx,X509_LOOKUP_hash_dir());\n\tif (lookup == NULL) abort();\n\tif (CApath) {\n\t\ti=X509_LOOKUP_add_dir(lookup,CApath,X509_FILETYPE_PEM);\n\t\tif(!i) {\n\t\t\tBIO_printf(bio_err, \"Error loading directory %s\\n\", CApath);\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t}\n\t} else X509_LOOKUP_add_dir(lookup,NULL,X509_FILETYPE_DEFAULT);\n\n\n\tERR_clear_error();\n\tif (argc < 1) check(cert_ctx,NULL);\n\telse\n\t\tfor (i=0; i<argc; i++)\n\t\t\tcheck(cert_ctx,argv[i]);\n\tret=0;\nend:\n\tif (ret == 1)\n\t\tBIO_printf(bio_err,\"usage: verify [-verbose] [-CApath path] [-CAfile file] cert1 cert2 ...\\n\");\n\tif (cert_ctx != NULL) X509_STORE_free(cert_ctx);\n\tEXIT(ret);\n\t}", "before_change_lines": [53, 54, 58, 59], "raw_before_change_lines": [53, 54, 58, 59], "after_change_lines": [53, 54, 55, 56, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 70, 71], "raw_after_change_lines": [53, 54, 55, 56, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 70, 71], "bug_lines": [53, 54, 58, 59], "added": [false, false, false, false], "idx": 487}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "15977----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c84d95cf53304b2647bf1dda1122ee665bdd3a35_1.json----do_EC_KEY_print", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_c84d95cf53304b2647bf1dda1122ee665bdd3a35_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_c84d95cf53304b2647bf1dda1122ee665bdd3a35_1.json", "function_name": "do_EC_KEY_print", "vul_func_code": "static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype)\n{\n    const char *ecstr;\n    unsigned char *priv = NULL, *pub = NULL;\n    size_t privlen = 0, publen = 0;\n    int ret = 0;\n    const EC_GROUP *group;\n\n    if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) {\n        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (ktype != EC_KEY_PRINT_PARAM) {\n        publen = EC_KEY_key2buf(x, EC_KEY_get_conv_form(x), &pub, NULL);\n        if (publen == 0)\n            goto err;\n    }\n\n    if (ktype == EC_KEY_PRINT_PRIVATE && EC_KEY_get0_private_key(x) != NULL) {\n        privlen = EC_KEY_priv2buf(x, &priv);\n        if (privlen == 0)\n            goto err;\n    }\n\n    if (ktype == EC_KEY_PRINT_PRIVATE)\n        ecstr = \"Private-Key\";\n    else if (ktype == EC_KEY_PRINT_PUBLIC)\n        ecstr = \"Public-Key\";\n    else\n        ecstr = \"ECDSA-Parameters\";\n\n    if (!BIO_indent(bp, off, 128))\n        goto err;\n    if (BIO_printf(bp, \"%s: (%d bit)\\n\", ecstr,\n                   EC_GROUP_order_bits(group)) <= 0)\n        goto err;\n\n    if (privlen != 0) {\n        if (BIO_printf(bp, \"%*spriv:\\n\", off, \"\") <= 0)\n            goto err;\n        if (ASN1_buf_print(bp, priv, privlen, off + 4) == 0)\n            goto err;\n    }\n\n    if (publen != 0) {\n        if (BIO_printf(bp, \"%*spub:\\n\", off, \"\") <= 0)\n            goto err;\n        if (ASN1_buf_print(bp, pub, publen, off + 4) == 0)\n            goto err;\n    }\n\n    if (!ECPKParameters_print(bp, group, off))\n        goto err;\n    ret = 1;\n err:\n    if (!ret)\n        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_EC_LIB);\n    OPENSSL_clear_free(priv, privlen);\n    OPENSSL_free(pub);\n    return ret;\n}", "patch_func_code": "static int do_EC_KEY_print(BIO *bp, const EC_KEY *x, int off, ec_print_t ktype)\n{\n    const char *ecstr;\n    unsigned char *priv = NULL, *pub = NULL;\n    size_t privlen = 0, publen = 0;\n    int ret = 0;\n    const EC_GROUP *group;\n\n    if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL) {\n        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (ktype != EC_KEY_PRINT_PARAM && EC_KEY_get0_public_key(x) != NULL) {\n        publen = EC_KEY_key2buf(x, EC_KEY_get_conv_form(x), &pub, NULL);\n        if (publen == 0)\n            goto err;\n    }\n\n    if (ktype == EC_KEY_PRINT_PRIVATE && EC_KEY_get0_private_key(x) != NULL) {\n        privlen = EC_KEY_priv2buf(x, &priv);\n        if (privlen == 0)\n            goto err;\n    }\n\n    if (ktype == EC_KEY_PRINT_PRIVATE)\n        ecstr = \"Private-Key\";\n    else if (ktype == EC_KEY_PRINT_PUBLIC)\n        ecstr = \"Public-Key\";\n    else\n        ecstr = \"ECDSA-Parameters\";\n\n    if (!BIO_indent(bp, off, 128))\n        goto err;\n    if (BIO_printf(bp, \"%s: (%d bit)\\n\", ecstr,\n                   EC_GROUP_order_bits(group)) <= 0)\n        goto err;\n\n    if (privlen != 0) {\n        if (BIO_printf(bp, \"%*spriv:\\n\", off, \"\") <= 0)\n            goto err;\n        if (ASN1_buf_print(bp, priv, privlen, off + 4) == 0)\n            goto err;\n    }\n\n    if (publen != 0) {\n        if (BIO_printf(bp, \"%*spub:\\n\", off, \"\") <= 0)\n            goto err;\n        if (ASN1_buf_print(bp, pub, publen, off + 4) == 0)\n            goto err;\n    }\n\n    if (!ECPKParameters_print(bp, group, off))\n        goto err;\n    ret = 1;\n err:\n    if (!ret)\n        ECerr(EC_F_DO_EC_KEY_PRINT, ERR_R_EC_LIB);\n    OPENSSL_clear_free(priv, privlen);\n    OPENSSL_free(pub);\n    return ret;\n}", "before_change_lines": [14], "raw_before_change_lines": [14], "after_change_lines": [14], "raw_after_change_lines": [14], "bug_lines": [14], "added": [false], "idx": 488}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "16105----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_cc924d47001675f60463a5c028dc92d06bc9b639_1.json----RECORD_LAYER_clear", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_cc924d47001675f60463a5c028dc92d06bc9b639_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_cc924d47001675f60463a5c028dc92d06bc9b639_1.json", "function_name": "RECORD_LAYER_clear", "vul_func_code": "void RECORD_LAYER_clear(RECORD_LAYER *rl)\n{\n    unsigned int pipes;\n\n    rl->rstate = SSL_ST_READ_HEADER;\n\n    /*\n     * Do I need to clear read_ahead? As far as I can tell read_ahead did not\n     * previously get reset by SSL_clear...so I'll keep it that way..but is\n     * that right?\n     */\n\n    rl->packet = NULL;\n    rl->packet_length = 0;\n    rl->wnum = 0;\n    memset(rl->alert_fragment, 0, sizeof(rl->alert_fragment));\n    rl->alert_fragment_len = 0;\n    memset(rl->handshake_fragment, 0, sizeof(rl->handshake_fragment));\n    rl->handshake_fragment_len = 0;\n    rl->wpend_tot = 0;\n    rl->wpend_type = 0;\n    rl->wpend_ret = 0;\n    rl->wpend_buf = NULL;\n\n    SSL3_BUFFER_clear(&rl->rbuf);\n    for (pipes = 0; pipes < rl->numwpipes; pipes++)\n        SSL3_BUFFER_clear(&rl->wbuf[pipes]);\n    rl->numwpipes = 0;\n    rl->numrpipes = 0;\n    SSL3_RECORD_clear(rl->rrec, SSL_MAX_PIPELINES);\n\n    RECORD_LAYER_reset_read_sequence(rl);\n    RECORD_LAYER_reset_write_sequence(rl);\n\n    if (rl->d)\n        DTLS_RECORD_LAYER_clear(rl);\n}", "patch_func_code": "void RECORD_LAYER_clear(RECORD_LAYER *rl)\n{\n    rl->rstate = SSL_ST_READ_HEADER;\n\n    /*\n     * Do I need to clear read_ahead? As far as I can tell read_ahead did not\n     * previously get reset by SSL_clear...so I'll keep it that way..but is\n     * that right?\n     */\n\n    rl->packet = NULL;\n    rl->packet_length = 0;\n    rl->wnum = 0;\n    memset(rl->alert_fragment, 0, sizeof(rl->alert_fragment));\n    rl->alert_fragment_len = 0;\n    memset(rl->handshake_fragment, 0, sizeof(rl->handshake_fragment));\n    rl->handshake_fragment_len = 0;\n    rl->wpend_tot = 0;\n    rl->wpend_type = 0;\n    rl->wpend_ret = 0;\n    rl->wpend_buf = NULL;\n\n    SSL3_BUFFER_clear(&rl->rbuf);\n    ssl3_release_write_buffer(rl->s);\n    rl->numrpipes = 0;\n    SSL3_RECORD_clear(rl->rrec, SSL_MAX_PIPELINES);\n\n    RECORD_LAYER_reset_read_sequence(rl);\n    RECORD_LAYER_reset_write_sequence(rl);\n\n    if (rl->d)\n        DTLS_RECORD_LAYER_clear(rl);\n}", "before_change_lines": [3, 26, 27, 28], "raw_before_change_lines": [3, 4, 26, 27, 28], "after_change_lines": [24], "raw_after_change_lines": [24], "bug_lines": [3, 4, 26, 27, 28], "added": [false, false, false, false, false], "idx": 489}
{"project": "openssl", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "16228----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d04190439d672a078adba166b7ec198d1ce89218_1.json----tls_process_client_certificate", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d04190439d672a078adba166b7ec198d1ce89218_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d04190439d672a078adba166b7ec198d1ce89218_1.json", "function_name": "tls_process_client_certificate", "vul_func_code": "enum MSG_PROCESS_RETURN tls_process_client_certificate(SSL *s, PACKET *pkt)\n{\n    int i, al, ret = MSG_PROCESS_ERROR;\n    X509 *x = NULL;\n    unsigned long l, llen;\n    const unsigned char *certstart;\n    unsigned char *certbytes;\n    STACK_OF(X509) *sk = NULL;\n    PACKET spkt;\n\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto f_err;\n    }\n\n    if (!PACKET_get_net_3(pkt, &llen)\n            || !PACKET_get_sub_packet(pkt, &spkt, llen)\n            || PACKET_remaining(pkt) != 0) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    while (PACKET_remaining(&spkt) > 0) {\n        if (!PACKET_get_net_3(&spkt, &l)\n                || !PACKET_get_bytes(&spkt, &certbytes, l)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n        certstart = certbytes;\n        x = d2i_X509(NULL, (const unsigned char **)&certbytes, l);\n        if (x == NULL) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto f_err;\n        }\n        if (certbytes != (certstart + l)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if (!sk_X509_push(sk, x)) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n        x = NULL;\n    }\n\n    if (sk_X509_num(sk) <= 0) {\n        /* TLS does not mind 0 certs returned */\n        if (s->version == SSL3_VERSION) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_NO_CERTIFICATES_RETURNED);\n            goto f_err;\n        }\n        /* Fail for TLS only if we required a certificate */\n        else if ((s->verify_mode & SSL_VERIFY_PEER) &&\n                 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            goto f_err;\n        }\n        /* No client certificate so digest cached records */\n        if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s, 0)) {\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    } else {\n        EVP_PKEY *pkey;\n        i = ssl_verify_cert_chain(s, sk);\n        if (i <= 0) {\n            al = ssl_verify_alarm_type(s->verify_result);\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_CERTIFICATE_VERIFY_FAILED);\n            goto f_err;\n        }\n        if (i > 1) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, i);\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            goto f_err;\n        }\n        pkey = X509_get_pubkey(sk_X509_value(sk, 0));\n        if (pkey == NULL) {\n            al = SSL3_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n            goto f_err;\n        }\n        EVP_PKEY_free(pkey);\n    }\n\n    X509_free(s->session->peer);\n    s->session->peer = sk_X509_shift(sk);\n    s->session->verify_result = s->verify_result;\n\n    sk_X509_pop_free(s->session->peer_chain, X509_free);\n    s->session->peer_chain = sk;\n    /*\n     * Inconsistency alert: cert_chain does *not* include the peer's own\n     * certificate, while we do include it in s3_clnt.c\n     */\n    sk = NULL;\n    ret = MSG_PROCESS_CONTINUE_READING;\n    goto done;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n done:\n    X509_free(x);\n    sk_X509_pop_free(sk, X509_free);\n    return ret;\n}", "patch_func_code": "enum MSG_PROCESS_RETURN tls_process_client_certificate(SSL *s, PACKET *pkt)\n{\n    int i, al = SSL_AD_INTERNAL_ERROR, ret = MSG_PROCESS_ERROR;\n    X509 *x = NULL;\n    unsigned long l, llen;\n    const unsigned char *certstart;\n    unsigned char *certbytes;\n    STACK_OF(X509) *sk = NULL;\n    PACKET spkt;\n\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto f_err;\n    }\n\n    if (!PACKET_get_net_3(pkt, &llen)\n            || !PACKET_get_sub_packet(pkt, &spkt, llen)\n            || PACKET_remaining(pkt) != 0) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n\n    while (PACKET_remaining(&spkt) > 0) {\n        if (!PACKET_get_net_3(&spkt, &l)\n                || !PACKET_get_bytes(&spkt, &certbytes, l)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n\n        certstart = certbytes;\n        x = d2i_X509(NULL, (const unsigned char **)&certbytes, l);\n        if (x == NULL) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto f_err;\n        }\n        if (certbytes != (certstart + l)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if (!sk_X509_push(sk, x)) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n        x = NULL;\n    }\n\n    if (sk_X509_num(sk) <= 0) {\n        /* TLS does not mind 0 certs returned */\n        if (s->version == SSL3_VERSION) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_NO_CERTIFICATES_RETURNED);\n            goto f_err;\n        }\n        /* Fail for TLS only if we required a certificate */\n        else if ((s->verify_mode & SSL_VERIFY_PEER) &&\n                 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            goto f_err;\n        }\n        /* No client certificate so digest cached records */\n        if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s, 0)) {\n            goto f_err;\n        }\n    } else {\n        EVP_PKEY *pkey;\n        i = ssl_verify_cert_chain(s, sk);\n        if (i <= 0) {\n            al = ssl_verify_alarm_type(s->verify_result);\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_CERTIFICATE_VERIFY_FAILED);\n            goto f_err;\n        }\n        if (i > 1) {\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE, i);\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            goto f_err;\n        }\n        pkey = X509_get_pubkey(sk_X509_value(sk, 0));\n        if (pkey == NULL) {\n            al = SSL3_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE,\n                   SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n            goto f_err;\n        }\n        EVP_PKEY_free(pkey);\n    }\n\n    X509_free(s->session->peer);\n    s->session->peer = sk_X509_shift(sk);\n    s->session->verify_result = s->verify_result;\n\n    sk_X509_pop_free(s->session->peer_chain, X509_free);\n    s->session->peer_chain = sk;\n    /*\n     * Inconsistency alert: cert_chain does *not* include the peer's own\n     * certificate, while we do include it in s3_clnt.c\n     */\n    sk = NULL;\n    ret = MSG_PROCESS_CONTINUE_READING;\n    goto done;\n\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    ossl_statem_set_error(s);\n done:\n    X509_free(x);\n    sk_X509_pop_free(sk, X509_free);\n    return ret;\n}", "before_change_lines": [3, 70], "raw_before_change_lines": [3, 70], "after_change_lines": [3], "raw_after_change_lines": [3], "bug_lines": [3, 70], "added": [false, false], "idx": 490}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_U5", "filepath_func": "16254----BUFFER_OVERRUN_U5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d1614bb8aa9fafda10e485a9a6b1c88a4ecde179_1.json----X509V3_EXT_add", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d1614bb8aa9fafda10e485a9a6b1c88a4ecde179_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d1614bb8aa9fafda10e485a9a6b1c88a4ecde179_1.json", "function_name": "X509V3_EXT_add", "vul_func_code": "int X509V3_EXT_add(X509V3_EXT_METHOD *ext)\n{\n\tif(!ext_list && !(ext_list = sk_new((int (*)(const void *, const void *))ext_cmp))) {\n\t\tX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\tif(!sk_push(ext_list, (char *)ext)) {\n\t\tX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "patch_func_code": "int X509V3_EXT_add(X509V3_EXT_METHOD *ext)\n{\n\tif(!ext_list && !(ext_list = sk_X509V3_EXT_METHOD_new(ext_cmp))) {\n\t\tX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\tif(!sk_X509V3_EXT_METHOD_push(ext_list, ext)) {\n\t\tX509V3err(X509V3_F_X509V3_EXT_ADD,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "before_change_lines": [3, 7], "raw_before_change_lines": [3, 7], "after_change_lines": [3, 7], "raw_after_change_lines": [3, 7], "bug_lines": [3, 7], "added": [false, false], "idx": 491}
{"project": "openssl", "vul_type": "DEAD_STORE", "filepath_func": "16293----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d2638c5e3abf24038f3e29305b0c1a9bbdeceef1_1.json----b64_read_asn1", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d2638c5e3abf24038f3e29305b0c1a9bbdeceef1_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d2638c5e3abf24038f3e29305b0c1a9bbdeceef1_1.json", "function_name": "b64_read_asn1", "vul_func_code": "static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it)\n{\n    BIO *b64;\n    ASN1_VALUE *val;\n\n    if ((b64 = BIO_new(BIO_f_base64())) == NULL) {\n        ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    bio = BIO_push(b64, bio);\n    val = ASN1_item_d2i_bio(it, bio, NULL);\n    if (!val)\n        ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR);\n    (void)BIO_flush(bio);\n    bio = BIO_pop(bio);\n    BIO_free(b64);\n    return val;\n}", "patch_func_code": "static ASN1_VALUE *b64_read_asn1(BIO *bio, const ASN1_ITEM *it)\n{\n    BIO *b64;\n    ASN1_VALUE *val;\n\n    if ((b64 = BIO_new(BIO_f_base64())) == NULL) {\n        ASN1err(ASN1_F_B64_READ_ASN1, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n    bio = BIO_push(b64, bio);\n    val = ASN1_item_d2i_bio(it, bio, NULL);\n    if (!val)\n        ASN1err(ASN1_F_B64_READ_ASN1, ASN1_R_DECODE_ERROR);\n    (void)BIO_flush(bio);\n    BIO_pop(bio);\n    BIO_free(b64);\n    return val;\n}", "before_change_lines": [15], "raw_before_change_lines": [15], "after_change_lines": [15], "raw_after_change_lines": [15], "bug_lines": [15], "added": [false], "idx": 492}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "16320----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d3604fe9dc1febbd5aebdae7db5a7b4959b42a02_1.json----prefix_write", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d3604fe9dc1febbd5aebdae7db5a7b4959b42a02_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d3604fe9dc1febbd5aebdae7db5a7b4959b42a02_1.json", "function_name": "prefix_write", "vul_func_code": "static int prefix_write(BIO *b, const char *out, size_t outl,\n                        size_t *numwritten)\n{\n    PREFIX_CTX *ctx = BIO_get_data(b);\n\n    if (ctx == NULL)\n        return 0;\n\n    /* If no prefix is set or if it's empty, we've got nothing to do here */\n    if (ctx->prefix == NULL || *ctx->prefix == '\\0') {\n        /* We do note if what comes next will be a new line, though */\n        if (outl > 0)\n            ctx->linestart = (out[outl-1] == '\\n');\n        return BIO_write_ex(BIO_next(b), out, outl, numwritten);\n    }\n\n    *numwritten = 0;\n\n    while (*out != '\\0') {\n        size_t i;\n        char c;\n\n        /* If we know that we're at the start of the line, output the prefix */\n        if (ctx->linestart) {\n            size_t dontcare;\n\n            if (!BIO_write_ex(BIO_next(b), ctx->prefix, strlen(ctx->prefix),\n                              &dontcare))\n                return 0;\n            ctx->linestart = 0;\n        }\n\n        /* Now, go look for the next LF, or the end of the string */\n        for (i = 0; (c = out[i]) != '\\n' && c != '\\0'; i++)\n            continue;\n        if (c == '\\n')\n            i++;\n\n        /* Output what we found so far */\n        while (i > 0) {\n            size_t num = 0;\n\n            if (!BIO_write_ex(BIO_next(b), out, i, &num))\n                return 0;\n            out += num;\n            *numwritten += num;\n            i -= num;\n        }\n\n        /* If we found a LF, what follows is a new line, so take note */\n        if (c == '\\n')\n            ctx->linestart = 1;\n    }\n\n    return 1;\n}", "patch_func_code": "static int prefix_write(BIO *b, const char *out, size_t outl,\n                        size_t *numwritten)\n{\n    PREFIX_CTX *ctx = BIO_get_data(b);\n\n    if (ctx == NULL)\n        return 0;\n\n    /* If no prefix is set or if it's empty, we've got nothing to do here */\n    if (ctx->prefix == NULL || *ctx->prefix == '\\0') {\n        /* We do note if what comes next will be a new line, though */\n        if (outl > 0)\n            ctx->linestart = (out[outl-1] == '\\n');\n        return BIO_write_ex(BIO_next(b), out, outl, numwritten);\n    }\n\n    *numwritten = 0;\n\n    while (outl > 0) {\n        size_t i;\n        char c;\n\n        /* If we know that we're at the start of the line, output the prefix */\n        if (ctx->linestart) {\n            size_t dontcare;\n\n            if (!BIO_write_ex(BIO_next(b), ctx->prefix, strlen(ctx->prefix),\n                              &dontcare))\n                return 0;\n            ctx->linestart = 0;\n        }\n\n        /* Now, go look for the next LF, or the end of the string */\n        for (i = 0, c = '\\0'; i < outl && (c = out[i]) != '\\n'; i++)\n            continue;\n        if (c == '\\n')\n            i++;\n\n        /* Output what we found so far */\n        while (i > 0) {\n            size_t num = 0;\n\n            if (!BIO_write_ex(BIO_next(b), out, i, &num))\n                return 0;\n            out += num;\n            outl -= num;\n            *numwritten += num;\n            i -= num;\n        }\n\n        /* If we found a LF, what follows is a new line, so take note */\n        if (c == '\\n')\n            ctx->linestart = 1;\n    }\n\n    return 1;\n}", "before_change_lines": [19, 34], "raw_before_change_lines": [19, 34], "after_change_lines": [19, 34, 46], "raw_after_change_lines": [19, 34, 46], "bug_lines": [19, 34], "added": [false, false], "idx": 493}
{"project": "openssl", "vul_type": "NULLPTR_DEREFERENCE", "filepath_func": "16356----NULLPTR_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d4df124a04cdb53450c19d310a5e05af95e7b5cf_1.json----SSKDF_mac_kdm", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d4df124a04cdb53450c19d310a5e05af95e7b5cf_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d4df124a04cdb53450c19d310a5e05af95e7b5cf_1.json", "function_name": "SSKDF_mac_kdm", "vul_func_code": "static int SSKDF_mac_kdm(const EVP_MAC *kdf_mac, const EVP_MD *hmac_md,\n                         const unsigned char *kmac_custom,\n                         size_t kmac_custom_len, size_t kmac_out_len,\n                         const unsigned char *salt, size_t salt_len,\n                         const unsigned char *z, size_t z_len,\n                         const unsigned char *info, size_t info_len,\n                         unsigned char *derived_key, size_t derived_key_len)\n{\n    int ret = 0;\n    size_t counter, out_len, len;\n    unsigned char c[4];\n    unsigned char mac_buf[EVP_MAX_MD_SIZE];\n    unsigned char *out = derived_key;\n    EVP_MAC_CTX *ctx = NULL, *ctx_init = NULL;\n    unsigned char *mac = mac_buf, *kmac_buffer = NULL;\n\n    if (z_len > SSKDF_MAX_INLEN || info_len > SSKDF_MAX_INLEN\n            || derived_key_len > SSKDF_MAX_INLEN\n            || derived_key_len == 0)\n        return 0;\n\n    ctx = EVP_MAC_CTX_new(kdf_mac);\n    ctx_init = EVP_MAC_CTX_new(kdf_mac);\n    if (ctx == NULL || ctx_init == NULL)\n        goto end;\n    if (hmac_md != NULL &&\n            EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_MD, hmac_md) <= 0)\n        goto end;\n\n    if (EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_KEY, salt, salt_len) <= 0)\n        goto end;\n\n    if (!kmac_init(ctx_init, kmac_custom, kmac_custom_len, kmac_out_len,\n                   derived_key_len, &kmac_buffer))\n        goto end;\n    if (kmac_buffer != NULL)\n        mac = kmac_buffer;\n\n    if (!EVP_MAC_init(ctx_init))\n        goto end;\n\n    out_len = EVP_MAC_size(ctx_init); /* output size */\n    if (out_len <= 0)\n        goto end;\n    len = derived_key_len;\n\n    for (counter = 1;; counter++) {\n        c[0] = (unsigned char)((counter >> 24) & 0xff);\n        c[1] = (unsigned char)((counter >> 16) & 0xff);\n        c[2] = (unsigned char)((counter >> 8) & 0xff);\n        c[3] = (unsigned char)(counter & 0xff);\n\n        if (!(EVP_MAC_CTX_copy(ctx, ctx_init)\n                && EVP_MAC_update(ctx, c, sizeof(c))\n                && EVP_MAC_update(ctx, z, z_len)\n                && EVP_MAC_update(ctx, info, info_len)))\n            goto end;\n        if (len >= out_len) {\n            if (!EVP_MAC_final(ctx, out, NULL))\n                goto end;\n            out += out_len;\n            len -= out_len;\n            if (len == 0)\n                break;\n        } else {\n            if (!EVP_MAC_final(ctx, mac, NULL))\n                goto end;\n            memcpy(out, mac, len);\n            break;\n        }\n    }\n    ret = 1;\nend:\n    OPENSSL_free(kmac_buffer);\n    EVP_MAC_CTX_free(ctx);\n    EVP_MAC_CTX_free(ctx_init);\n    OPENSSL_cleanse(mac, sizeof(mac));\n    return ret;\n}", "patch_func_code": "static int SSKDF_mac_kdm(const EVP_MAC *kdf_mac, const EVP_MD *hmac_md,\n                         const unsigned char *kmac_custom,\n                         size_t kmac_custom_len, size_t kmac_out_len,\n                         const unsigned char *salt, size_t salt_len,\n                         const unsigned char *z, size_t z_len,\n                         const unsigned char *info, size_t info_len,\n                         unsigned char *derived_key, size_t derived_key_len)\n{\n    int ret = 0;\n    size_t counter, out_len, len;\n    unsigned char c[4];\n    unsigned char mac_buf[EVP_MAX_MD_SIZE];\n    unsigned char *out = derived_key;\n    EVP_MAC_CTX *ctx = NULL, *ctx_init = NULL;\n    unsigned char *mac = mac_buf, *kmac_buffer = NULL;\n\n    if (z_len > SSKDF_MAX_INLEN || info_len > SSKDF_MAX_INLEN\n            || derived_key_len > SSKDF_MAX_INLEN\n            || derived_key_len == 0)\n        return 0;\n\n    ctx = EVP_MAC_CTX_new(kdf_mac);\n    ctx_init = EVP_MAC_CTX_new(kdf_mac);\n    if (ctx == NULL || ctx_init == NULL)\n        goto end;\n    if (hmac_md != NULL &&\n            EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_MD, hmac_md) <= 0)\n        goto end;\n\n    if (EVP_MAC_ctrl(ctx_init, EVP_MAC_CTRL_SET_KEY, salt, salt_len) <= 0)\n        goto end;\n\n    if (!kmac_init(ctx_init, kmac_custom, kmac_custom_len, kmac_out_len,\n                   derived_key_len, &kmac_buffer))\n        goto end;\n    if (kmac_buffer != NULL)\n        mac = kmac_buffer;\n\n    if (!EVP_MAC_init(ctx_init))\n        goto end;\n\n    out_len = EVP_MAC_size(ctx_init); /* output size */\n    if (out_len <= 0)\n        goto end;\n    len = derived_key_len;\n\n    for (counter = 1;; counter++) {\n        c[0] = (unsigned char)((counter >> 24) & 0xff);\n        c[1] = (unsigned char)((counter >> 16) & 0xff);\n        c[2] = (unsigned char)((counter >> 8) & 0xff);\n        c[3] = (unsigned char)(counter & 0xff);\n\n        if (!(EVP_MAC_CTX_copy(ctx, ctx_init)\n                && EVP_MAC_update(ctx, c, sizeof(c))\n                && EVP_MAC_update(ctx, z, z_len)\n                && EVP_MAC_update(ctx, info, info_len)))\n            goto end;\n        if (len >= out_len) {\n            if (!EVP_MAC_final(ctx, out, NULL))\n                goto end;\n            out += out_len;\n            len -= out_len;\n            if (len == 0)\n                break;\n        } else {\n            if (!EVP_MAC_final(ctx, mac, NULL))\n                goto end;\n            memcpy(out, mac, len);\n            break;\n        }\n    }\n    ret = 1;\nend:\n    if (kmac_buffer != NULL)\n        OPENSSL_clear_free(kmac_buffer, kmac_out_len);\n    else\n        OPENSSL_cleanse(mac_buf, sizeof(mac_buf));\n\n    EVP_MAC_CTX_free(ctx);\n    EVP_MAC_CTX_free(ctx_init);\n    return ret;\n}", "before_change_lines": [74, 77], "raw_before_change_lines": [74, 77], "after_change_lines": [74, 75, 76, 77], "raw_after_change_lines": [74, 75, 76, 77, 78], "bug_lines": [74, 77], "added": [false, false], "idx": 494}
{"project": "openssl", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "16375----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d59bb0574da62e8e39dfdb15422c99dc13583538_1.json----ssl3_get_message", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d59bb0574da62e8e39dfdb15422c99dc13583538_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d59bb0574da62e8e39dfdb15422c99dc13583538_1.json", "function_name": "ssl3_get_message", "vul_func_code": "long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tunsigned char *p;\n\tunsigned long l;\n\tlong n;\n\tint i,al;\n\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\treturn((int)s->s3->tmp.message_size);\n\t\t}\n\n\tp=(unsigned char *)s->init_buf->data;\n\n\tif (s->state == st1) /* s->init_num < 4 */\n\t\t{\n\t\tint skip_message;\n\n\t\tdo\n\t\t\t{\n\t\t\twhile (s->init_num < 4)\n\t\t\t\t{\n\t\t\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\n\t\t\t\t\t4-s->init_num);\n\t\t\t\tif (i <= 0)\n\t\t\t\t\t{\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t*ok = 0;\n\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\ts->init_num+=i;\n\t\t\t\t}\n\t\t\t\n\t\t\tskip_message = 0;\n\t\t\tif (!s->server)\n\t\t\t\tif (p[0] == SSL3_MT_HELLO_REQUEST)\n\t\t\t\t\t/* The server may always send 'Hello Request' messages --\n\t\t\t\t\t * we are doing a handshake anyway now, so ignore them\n\t\t\t\t\t * if their format is correct */\n\t\t\t\t\tif (p[1] == 0 && p[2] == 0 &&p[3] == 0)\n\t\t\t\t\t\tskip_message = 1;\n\t\t\t}\n\t\twhile (skip_message);\n\n\t\tif ((mt >= 0) && (*p != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t\t\t(st1 == SSL3_ST_SR_CERT_A) &&\n\t\t\t\t\t(stn == SSL3_ST_SR_CERT_B))\n\t\t\t{\n\t\t\t/* At this point we have got an MS SGC second client\n\t\t\t * hello. We need to restart the mac and mac the data\n\t\t\t * currently received.\n\t\t\t */\n\t\t\tssl3_init_finished_mac(s);\n\t\t\tssl3_finish_mac(s, p + s->init_num, i);\n\t\t\t}\n\t\t\t\n\t\ts->s3->tmp.message_type= *(p++);\n\n\t\tn2l3(p,l);\n\t\tif (l > (unsigned long)max)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l && !BUF_MEM_grow(s->init_buf,(int)l))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->s3->tmp.message_size=l;\n\t\ts->state=stn;\n\n\t\ts->init_num=0;\n\t\t}\n\n\t/* next state (stn) */\n\tp=(unsigned char *)s->init_buf->data;\n\tn=s->s3->tmp.message_size;\n\twhile (n > 0)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\ts->init_num += i;\n\t\tn -= i;\n\t\t}\n\t*ok=1;\n\treturn s->init_num;\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\t*ok=0;\n\treturn(-1);\n\t}", "patch_func_code": "long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)\n\t{\n\tunsigned char *p;\n\tunsigned long l;\n\tlong n;\n\tint i,al;\n\n\tif (s->s3->tmp.reuse_message)\n\t\t{\n\t\ts->s3->tmp.reuse_message=0;\n\t\tif ((mt >= 0) && (s->s3->tmp.message_type != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\t*ok=1;\n\t\treturn((int)s->s3->tmp.message_size);\n\t\t}\n\n\tp=(unsigned char *)s->init_buf->data;\n\n\tif (s->state == st1) /* s->init_num < 4 */\n\t\t{\n\t\tint skip_message;\n\n\t\tdo\n\t\t\t{\n\t\t\twhile (s->init_num < 4)\n\t\t\t\t{\n\t\t\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],\n\t\t\t\t\t4 - s->init_num);\n\t\t\t\tif (i <= 0)\n\t\t\t\t\t{\n\t\t\t\t\ts->rwstate=SSL_READING;\n\t\t\t\t\t*ok = 0;\n\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\ts->init_num+=i;\n\t\t\t\t}\n\t\t\t\n\t\t\tskip_message = 0;\n\t\t\tif (!s->server)\n\t\t\t\tif (p[0] == SSL3_MT_HELLO_REQUEST)\n\t\t\t\t\t/* The server may always send 'Hello Request' messages --\n\t\t\t\t\t * we are doing a handshake anyway now, so ignore them\n\t\t\t\t\t * if their format is correct. Does not count for\n\t\t\t\t\t * 'Finished' MAC. */\n\t\t\t\t\tif (p[1] == 0 && p[2] == 0 &&p[3] == 0)\n\t\t\t\t\t\tskip_message = 1;\n\t\t\t}\n\t\twhile (skip_message);\n\n\t\t/* s->init_num == 4 */\n\n\t\tif ((mt >= 0) && (*p != mt))\n\t\t\t{\n\t\t\tal=SSL_AD_UNEXPECTED_MESSAGE;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_UNEXPECTED_MESSAGE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif((mt < 0) && (*p == SSL3_MT_CLIENT_HELLO) &&\n\t\t\t\t\t(st1 == SSL3_ST_SR_CERT_A) &&\n\t\t\t\t\t(stn == SSL3_ST_SR_CERT_B))\n\t\t\t{\n\t\t\t/* At this point we have got an MS SGC second client\n\t\t\t * hello (maybe we should always allow the client to\n\t\t\t * start a new handshake?). We need to restart the mac.\n\t\t\t */\n\t\t\tssl3_init_finished_mac(s);\n\t\t\t}\n\n\t\tssl3_finish_mac(s, (unsigned char *)s->init_buf->data, 4);\n\t\t\t\n\t\ts->s3->tmp.message_type= *(p++);\n\n\t\tn2l3(p,l);\n\t\tif (l > (unsigned long)max)\n\t\t\t{\n\t\t\tal=SSL_AD_ILLEGAL_PARAMETER;\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,SSL_R_EXCESSIVE_MESSAGE_SIZE);\n\t\t\tgoto f_err;\n\t\t\t}\n\t\tif (l && !BUF_MEM_grow(s->init_buf,(int)l))\n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_GET_MESSAGE,ERR_R_BUF_LIB);\n\t\t\tgoto err;\n\t\t\t}\n\t\ts->s3->tmp.message_size=l;\n\t\ts->state=stn;\n\n\t\ts->init_num=0;\n\t\t}\n\n\t/* next state (stn) */\n\tp=(unsigned char *)s->init_buf->data;\n\tn=s->s3->tmp.message_size;\n\twhile (n > 0)\n\t\t{\n\t\ti=ssl3_read_bytes(s,SSL3_RT_HANDSHAKE,&p[s->init_num],n);\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\ts->rwstate=SSL_READING;\n\t\t\t*ok = 0;\n\t\t\treturn i;\n\t\t\t}\n\t\ts->init_num += i;\n\t\tn -= i;\n\t\t}\n\tssl3_finish_mac(s, (unsigned char *)s->init_buf->data, s->init_num);\n\t*ok=1;\n\treturn s->init_num;\nf_err:\n\tssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n\t*ok=0;\n\treturn(-1);\n\t}", "before_change_lines": [32, 47, 64, 65, 68], "raw_before_change_lines": [32, 47, 64, 65, 68], "after_change_lines": [32, 47, 48, 67, 68, 73, 110], "raw_after_change_lines": [32, 47, 48, 54, 55, 67, 68, 72, 73, 110], "bug_lines": [32, 47, 64, 65, 68], "added": [false, false, false, false, false], "idx": 495}
{"project": "openssl", "vul_type": "DEAD_STORE", "filepath_func": "16412----DEAD_STORE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d6a890e4f5efcee92aa5f5857af1cfa2ff9ff9fc_1.json----ssl_get_prev_session", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d6a890e4f5efcee92aa5f5857af1cfa2ff9ff9fc_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d6a890e4f5efcee92aa5f5857af1cfa2ff9ff9fc_1.json", "function_name": "ssl_get_prev_session", "vul_func_code": "int ssl_get_prev_session(SSL *s, CLIENTHELLO_MSG *hello)\n{\n    /* This is used only by servers. */\n\n    SSL_SESSION *ret = NULL;\n    int fatal = 0;\n    int try_session_cache = 0;\n    int r;\n\n    if (SSL_IS_TLS13(s)) {\n        int al;\n\n        if (!tls_parse_extension(s, TLSEXT_IDX_psk, EXT_CLIENT_HELLO,\n                                 hello->pre_proc_exts, NULL, 0, &al))\n            return -1;\n\n        ret = s->session;\n    } else {\n        /* sets s->ext.ticket_expected */\n        r = tls_get_ticket_from_client(s, hello, &ret);\n        switch (r) {\n        case -1:                   /* Error during processing */\n            fatal = 1;\n            goto err;\n        case 0:                    /* No ticket found */\n        case 1:                    /* Zero length ticket found */\n            try_session_cache = 1;\n            break;                  /* Ok to carry on processing session id. */\n        case 2:                    /* Ticket found but not decrypted. */\n        case 3:                    /* Ticket decrypted, *ret has been set. */\n            break;\n        default:\n            abort();\n        }\n    }\n\n    if (try_session_cache &&\n        ret == NULL &&\n        !(s->session_ctx->session_cache_mode &\n          SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {\n        SSL_SESSION data;\n\n        data.ssl_version = s->version;\n        memset(data.session_id, 0, sizeof(data.session_id));\n        memcpy(data.session_id, hello->session_id, hello->session_id_len);\n        data.session_id_length = hello->session_id_len;\n\n        CRYPTO_THREAD_read_lock(s->session_ctx->lock);\n        ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);\n        if (ret != NULL) {\n            /* don't allow other threads to steal it: */\n            SSL_SESSION_up_ref(ret);\n        }\n        CRYPTO_THREAD_unlock(s->session_ctx->lock);\n        if (ret == NULL)\n            s->session_ctx->stats.sess_miss++;\n    }\n\n    if (try_session_cache &&\n        ret == NULL && s->session_ctx->get_session_cb != NULL) {\n        int copy = 1;\n\n        ret = s->session_ctx->get_session_cb(s, hello->session_id,\n                                             hello->session_id_len,\n                                             &copy);\n\n        if (ret != NULL) {\n            s->session_ctx->stats.sess_cb_hit++;\n\n            /*\n             * Increment reference count now if the session callback asks us\n             * to do so (note that if the session structures returned by the\n             * callback are shared between threads, it must handle the\n             * reference count itself [i.e. copy == 0], or things won't be\n             * thread-safe).\n             */\n            if (copy)\n                SSL_SESSION_up_ref(ret);\n\n            /*\n             * Add the externally cached session to the internal cache as\n             * well if and only if we are supposed to.\n             */\n            if (!\n                (s->session_ctx->session_cache_mode &\n                 SSL_SESS_CACHE_NO_INTERNAL_STORE)) {\n                /*\n                 * The following should not return 1, otherwise, things are\n                 * very strange\n                 */\n                if (SSL_CTX_add_session(s->session_ctx, ret))\n                    goto err;\n            }\n        }\n    }\n\n    if (ret == NULL)\n        goto err;\n\n    /* Now ret is non-NULL and we own one of its reference counts. */\n\n    /* Check TLS version consistency */\n    if (ret->ssl_version != s->version)\n        goto err;\n\n    if (ret->sid_ctx_length != s->sid_ctx_length\n        || memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {\n        /*\n         * We have the session requested by the client, but we don't want to\n         * use it in this context.\n         */\n        goto err;               /* treat like cache miss */\n    }\n\n    if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {\n        /*\n         * We can't be sure if this session is being used out of context,\n         * which is especially important for SSL_VERIFY_PEER. The application\n         * should have used SSL[_CTX]_set_session_id_context. For this error\n         * case, we generate an error instead of treating the event like a\n         * cache miss (otherwise it would be easy for applications to\n         * effectively disable the session cache by accident without anyone\n         * noticing).\n         */\n\n        SSLerr(SSL_F_SSL_GET_PREV_SESSION,\n               SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);\n        fatal = 1;\n        goto err;\n    }\n\n    if (ret->cipher == NULL) {\n        unsigned char buf[5], *p;\n        unsigned long l;\n\n        p = buf;\n        l = ret->cipher_id;\n        l2n(l, p);\n        if ((ret->ssl_version >> 8) >= SSL3_VERSION_MAJOR)\n            ret->cipher = ssl_get_cipher_by_char(s, &(buf[2]));\n        else\n            ret->cipher = ssl_get_cipher_by_char(s, &(buf[1]));\n        if (ret->cipher == NULL)\n            goto err;\n    }\n\n    if (ret->timeout < (long)(time(NULL) - ret->time)) { /* timeout */\n        s->session_ctx->stats.sess_timeout++;\n        if (try_session_cache) {\n            /* session was from the cache, so remove it */\n            SSL_CTX_remove_session(s->session_ctx, ret);\n        }\n        goto err;\n    }\n\n    /* Check extended master secret extension consistency */\n    if (ret->flags & SSL_SESS_FLAG_EXTMS) {\n        /* If old session includes extms, but new does not: abort handshake */\n        if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS)) {\n            SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_INCONSISTENT_EXTMS);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            fatal = 1;\n            goto err;\n        }\n    } else if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /* If new session includes extms, but old does not: do not resume */\n        goto err;\n    }\n\n    if (!SSL_IS_TLS13(s)) {\n        /* We already did this for TLS1.3 */\n        SSL_SESSION_free(s->session);\n        s->session = ret;\n    }\n\n    s->session_ctx->stats.sess_hit++;\n    s->verify_result = s->session->verify_result;\n\n    return 1;\n\n err:\n    if (ret != NULL) {\n        SSL_SESSION_free(ret);\n        /* In TLSv1.3 we already set s->session, so better NULL it out */\n        if (SSL_IS_TLS13(s))\n            s->session = NULL;\n\n        if (!try_session_cache) {\n            /*\n             * The session was from a ticket, so we should issue a ticket for\n             * the new session\n             */\n            s->ext.ticket_expected = 1;\n        }\n    }\n    if (fatal)\n        return -1;\n    else\n        return 0;\n}", "patch_func_code": "int ssl_get_prev_session(SSL *s, CLIENTHELLO_MSG *hello)\n{\n    /* This is used only by servers. */\n\n    SSL_SESSION *ret = NULL;\n    int fatal = 0;\n    int try_session_cache = 0;\n    int r;\n\n    if (SSL_IS_TLS13(s)) {\n        int al;\n\n        if (!tls_parse_extension(s, TLSEXT_IDX_psk, EXT_CLIENT_HELLO,\n                                 hello->pre_proc_exts, NULL, 0, &al))\n            return -1;\n\n        ret = s->session;\n    } else {\n        /* sets s->ext.ticket_expected */\n        r = tls_get_ticket_from_client(s, hello, &ret);\n        switch (r) {\n        case -1:                   /* Error during processing */\n            fatal = 1;\n            goto err;\n        case 0:                    /* No ticket found */\n        case 1:                    /* Zero length ticket found */\n            try_session_cache = 1;\n            break;                  /* Ok to carry on processing session id. */\n        case 2:                    /* Ticket found but not decrypted. */\n        case 3:                    /* Ticket decrypted, *ret has been set. */\n            break;\n        default:\n            abort();\n        }\n    }\n\n    if (try_session_cache &&\n        ret == NULL &&\n        !(s->session_ctx->session_cache_mode &\n          SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)) {\n        SSL_SESSION data;\n\n        data.ssl_version = s->version;\n        memset(data.session_id, 0, sizeof(data.session_id));\n        memcpy(data.session_id, hello->session_id, hello->session_id_len);\n        data.session_id_length = hello->session_id_len;\n\n        CRYPTO_THREAD_read_lock(s->session_ctx->lock);\n        ret = lh_SSL_SESSION_retrieve(s->session_ctx->sessions, &data);\n        if (ret != NULL) {\n            /* don't allow other threads to steal it: */\n            SSL_SESSION_up_ref(ret);\n        }\n        CRYPTO_THREAD_unlock(s->session_ctx->lock);\n        if (ret == NULL)\n            s->session_ctx->stats.sess_miss++;\n    }\n\n    if (try_session_cache &&\n        ret == NULL && s->session_ctx->get_session_cb != NULL) {\n        int copy = 1;\n\n        ret = s->session_ctx->get_session_cb(s, hello->session_id,\n                                             hello->session_id_len,\n                                             &copy);\n\n        if (ret != NULL) {\n            s->session_ctx->stats.sess_cb_hit++;\n\n            /*\n             * Increment reference count now if the session callback asks us\n             * to do so (note that if the session structures returned by the\n             * callback are shared between threads, it must handle the\n             * reference count itself [i.e. copy == 0], or things won't be\n             * thread-safe).\n             */\n            if (copy)\n                SSL_SESSION_up_ref(ret);\n\n            /*\n             * Add the externally cached session to the internal cache as\n             * well if and only if we are supposed to.\n             */\n            if (!\n                (s->session_ctx->session_cache_mode &\n                 SSL_SESS_CACHE_NO_INTERNAL_STORE)) {\n                /*\n                 * The following should not return 1, otherwise, things are\n                 * very strange\n                 */\n                if (SSL_CTX_add_session(s->session_ctx, ret))\n                    goto err;\n            }\n        }\n    }\n\n    if (ret == NULL)\n        goto err;\n\n    /* Now ret is non-NULL and we own one of its reference counts. */\n\n    /* Check TLS version consistency */\n    if (ret->ssl_version != s->version)\n        goto err;\n\n    if (ret->sid_ctx_length != s->sid_ctx_length\n        || memcmp(ret->sid_ctx, s->sid_ctx, ret->sid_ctx_length)) {\n        /*\n         * We have the session requested by the client, but we don't want to\n         * use it in this context.\n         */\n        goto err;               /* treat like cache miss */\n    }\n\n    if ((s->verify_mode & SSL_VERIFY_PEER) && s->sid_ctx_length == 0) {\n        /*\n         * We can't be sure if this session is being used out of context,\n         * which is especially important for SSL_VERIFY_PEER. The application\n         * should have used SSL[_CTX]_set_session_id_context. For this error\n         * case, we generate an error instead of treating the event like a\n         * cache miss (otherwise it would be easy for applications to\n         * effectively disable the session cache by accident without anyone\n         * noticing).\n         */\n\n        SSLerr(SSL_F_SSL_GET_PREV_SESSION,\n               SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED);\n        fatal = 1;\n        goto err;\n    }\n\n    if (ret->timeout < (long)(time(NULL) - ret->time)) { /* timeout */\n        s->session_ctx->stats.sess_timeout++;\n        if (try_session_cache) {\n            /* session was from the cache, so remove it */\n            SSL_CTX_remove_session(s->session_ctx, ret);\n        }\n        goto err;\n    }\n\n    /* Check extended master secret extension consistency */\n    if (ret->flags & SSL_SESS_FLAG_EXTMS) {\n        /* If old session includes extms, but new does not: abort handshake */\n        if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS)) {\n            SSLerr(SSL_F_SSL_GET_PREV_SESSION, SSL_R_INCONSISTENT_EXTMS);\n            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_HANDSHAKE_FAILURE);\n            fatal = 1;\n            goto err;\n        }\n    } else if (s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) {\n        /* If new session includes extms, but old does not: do not resume */\n        goto err;\n    }\n\n    if (!SSL_IS_TLS13(s)) {\n        /* We already did this for TLS1.3 */\n        SSL_SESSION_free(s->session);\n        s->session = ret;\n    }\n\n    s->session_ctx->stats.sess_hit++;\n    s->verify_result = s->session->verify_result;\n\n    return 1;\n\n err:\n    if (ret != NULL) {\n        SSL_SESSION_free(ret);\n        /* In TLSv1.3 we already set s->session, so better NULL it out */\n        if (SSL_IS_TLS13(s))\n            s->session = NULL;\n\n        if (!try_session_cache) {\n            /*\n             * The session was from a ticket, so we should issue a ticket for\n             * the new session\n             */\n            s->ext.ticket_expected = 1;\n        }\n    }\n    if (fatal)\n        return -1;\n    else\n        return 0;\n}", "before_change_lines": [132, 133, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145], "raw_before_change_lines": [132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146], "after_change_lines": [], "raw_after_change_lines": [], "bug_lines": [132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 496}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "16440----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d780ca441a4950d56edca5b2d678ab6761ca1602_1.json----RSA_free", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_d780ca441a4950d56edca5b2d678ab6761ca1602_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_d780ca441a4950d56edca5b2d678ab6761ca1602_1.json", "function_name": "RSA_free", "vul_func_code": "void RSA_free(RSA *r)\n\t{\n\tint i;\n\n\tif (r == NULL) return;\n\n\ti=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);\n#ifdef REF_PRINT\n\tREF_PRINT(\"RSA\",r);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"RSA_free, bad reference count\\n\");\n\t\tabort();\n\t\t}\n#endif\n\n\tCRYPTO_free_ex_data(rsa_meth,r,&r->ex_data);\n\n\tif (r->meth->finish != NULL)\n\t\tr->meth->finish(r);\n\n\tif (r->n != NULL) BN_clear_free(r->n);\n\tif (r->e != NULL) BN_clear_free(r->e);\n\tif (r->d != NULL) BN_clear_free(r->d);\n\tif (r->p != NULL) BN_clear_free(r->p);\n\tif (r->q != NULL) BN_clear_free(r->q);\n\tif (r->dmp1 != NULL) BN_clear_free(r->dmp1);\n\tif (r->dmq1 != NULL) BN_clear_free(r->dmq1);\n\tif (r->iqmp != NULL) BN_clear_free(r->iqmp);\n\tif (r->blinding != NULL) BN_BLINDING_free(r->blinding);\n\tif (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data);\n\tOPENSSL_free(r);\n\t}", "patch_func_code": "void RSA_free(RSA *r)\n\t{\n\tRSA_METHOD *meth;\n\tint i;\n\n\tif (r == NULL) return;\n\n\ti=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);\n#ifdef REF_PRINT\n\tREF_PRINT(\"RSA\",r);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"RSA_free, bad reference count\\n\");\n\t\tabort();\n\t\t}\n#endif\n\n\tCRYPTO_free_ex_data(rsa_meth,r,&r->ex_data);\n\n\tmeth = ENGINE_get_RSA(r->engine);\n\tif (meth->finish != NULL)\n\t\tmeth->finish(r);\n\tENGINE_finish(r->engine);\n\n\tif (r->n != NULL) BN_clear_free(r->n);\n\tif (r->e != NULL) BN_clear_free(r->e);\n\tif (r->d != NULL) BN_clear_free(r->d);\n\tif (r->p != NULL) BN_clear_free(r->p);\n\tif (r->q != NULL) BN_clear_free(r->q);\n\tif (r->dmp1 != NULL) BN_clear_free(r->dmp1);\n\tif (r->dmq1 != NULL) BN_clear_free(r->dmq1);\n\tif (r->iqmp != NULL) BN_clear_free(r->iqmp);\n\tif (r->blinding != NULL) BN_BLINDING_free(r->blinding);\n\tif (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data);\n\tOPENSSL_free(r);\n\t}", "before_change_lines": [22, 23], "raw_before_change_lines": [22, 23], "after_change_lines": [3, 23, 24, 25, 26], "raw_after_change_lines": [3, 23, 24, 25, 26], "bug_lines": [22, 23], "added": [false, false], "idx": 497}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "16502----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_da21ed89ab2422923ff183f61851981d263fa51b_1.json----RAND_poll", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_da21ed89ab2422923ff183f61851981d263fa51b_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_da21ed89ab2422923ff183f61851981d263fa51b_1.json", "function_name": "RAND_poll", "vul_func_code": "int RAND_poll(void)\n{\n    int ret = 0;\n\n    RAND_POOL *pool = NULL;\n\n    const RAND_METHOD *meth = RAND_get_rand_method();\n\n    if (meth == RAND_OpenSSL()) {\n        /* fill random pool and seed the master DRBG */\n        RAND_DRBG *drbg = RAND_DRBG_get0_master();\n\n        if (drbg == NULL)\n            return 0;\n\n        rand_drbg_lock(drbg);\n        ret = rand_drbg_restart(drbg, NULL, 0, 0);\n        rand_drbg_unlock(drbg);\n\n        return ret;\n\n    } else {\n        /* fill random pool and seed the current legacy RNG */\n        pool = rand_pool_new(RAND_DRBG_STRENGTH,\n                             RAND_DRBG_STRENGTH / 8,\n                             DRBG_MINMAX_FACTOR * (RAND_DRBG_STRENGTH / 8));\n        if (pool == NULL)\n            return 0;\n\n        if (rand_pool_acquire_entropy(pool) == 0)\n            goto err;\n\n        if (meth->add == NULL\n            || meth->add(rand_pool_buffer(pool),\n                         rand_pool_length(pool),\n                         (rand_pool_entropy(pool) / 8.0)) == 0)\n            goto err;\n\n        ret = 1;\n    }\n\nerr:\n    rand_pool_free(pool);\n    return ret;\n}", "patch_func_code": "int RAND_poll(void)\n{\n    int ret = 0;\n\n    RAND_POOL *pool = NULL;\n\n    const RAND_METHOD *meth = RAND_get_rand_method();\n\n    if (meth == RAND_OpenSSL()) {\n        /* fill random pool and seed the master DRBG */\n        RAND_DRBG *drbg = RAND_DRBG_get0_master();\n\n        if (drbg == NULL)\n            return 0;\n\n        rand_drbg_lock(drbg);\n        ret = rand_drbg_restart(drbg, NULL, 0, 0);\n        rand_drbg_unlock(drbg);\n\n        return ret;\n\n    } else {\n        /* fill random pool and seed the current legacy RNG */\n        pool = rand_pool_new(RAND_DRBG_STRENGTH,\n                             RAND_DRBG_STRENGTH / 8,\n                             RAND_POOL_MAX_LENGTH);\n        if (pool == NULL)\n            return 0;\n\n        if (rand_pool_acquire_entropy(pool) == 0)\n            goto err;\n\n        if (meth->add == NULL\n            || meth->add(rand_pool_buffer(pool),\n                         rand_pool_length(pool),\n                         (rand_pool_entropy(pool) / 8.0)) == 0)\n            goto err;\n\n        ret = 1;\n    }\n\nerr:\n    rand_pool_free(pool);\n    return ret;\n}", "before_change_lines": [26], "raw_before_change_lines": [26], "after_change_lines": [26], "raw_after_change_lines": [26], "bug_lines": [26], "added": [false], "idx": 498}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "16597----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_dd0f4c6cf3a74118c9bf29ca5aa25d3381de2ca4_1.json----v2i_IPAddrBlocks", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_dd0f4c6cf3a74118c9bf29ca5aa25d3381de2ca4_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_dd0f4c6cf3a74118c9bf29ca5aa25d3381de2ca4_1.json", "function_name": "v2i_IPAddrBlocks", "vul_func_code": "static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,\n                              struct v3_ext_ctx *ctx,\n                              STACK_OF(CONF_VALUE) *values)\n{\n    static const char v4addr_chars[] = \"0123456789.\";\n    static const char v6addr_chars[] = \"0123456789.:abcdefABCDEF\";\n    IPAddrBlocks *addr = NULL;\n    char *s = NULL, *t;\n    int i;\n\n    if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) {\n        X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    for (i = 0; i < sk_CONF_VALUE_num(values); i++) {\n        CONF_VALUE *val = sk_CONF_VALUE_value(values, i);\n        unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN];\n        unsigned afi, *safi = NULL, safi_;\n        const char *addr_chars = NULL;\n        int prefixlen, i1, i2, delim, length;\n\n        if (!name_cmp(val->name, \"IPv4\")) {\n            afi = IANA_AFI_IPV4;\n        } else if (!name_cmp(val->name, \"IPv6\")) {\n            afi = IANA_AFI_IPV6;\n        } else if (!name_cmp(val->name, \"IPv4-SAFI\")) {\n            afi = IANA_AFI_IPV4;\n            safi = &safi_;\n        } else if (!name_cmp(val->name, \"IPv6-SAFI\")) {\n            afi = IANA_AFI_IPV6;\n            safi = &safi_;\n        } else {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                      X509V3_R_EXTENSION_NAME_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        switch (afi) {\n        case IANA_AFI_IPV4:\n            addr_chars = v4addr_chars;\n            break;\n        case IANA_AFI_IPV6:\n            addr_chars = v6addr_chars;\n            break;\n        }\n\n        length = length_from_afi(afi);\n\n        /*\n         * Handle SAFI, if any, and BUF_strdup() so we can null-terminate\n         * the other input values.\n         */\n        if (safi != NULL) {\n            *safi = strtoul(val->value, &t, 0);\n            t += strspn(t, \" \\t\");\n            if (*safi > 0xFF || *t++ != ':') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            t += strspn(t, \" \\t\");\n            s = BUF_strdup(t);\n        } else {\n            s = BUF_strdup(val->value);\n        }\n        if (s == NULL) {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /*\n         * Check for inheritance.  Not worth additional complexity to\n         * optimize this (seldom-used) case.\n         */\n        if (strcmp(s, \"inherit\") == 0) {\n            if (!v3_addr_add_inherit(addr, afi, safi)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_INVALID_INHERITANCE);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            OPENSSL_free(s);\n            s = NULL;\n            continue;\n        }\n\n        i1 = strspn(s, addr_chars);\n        i2 = i1 + strspn(s + i1, \" \\t\");\n        delim = s[i2++];\n        s[i1] = '\\0';\n\n        if (a2i_ipadd(min, s) != length) {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        switch (delim) {\n        case '/':\n            prefixlen = (int)strtoul(s + i2, &t, 10);\n            if (t == s + i2 || *t != '\\0') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (!v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        case '-':\n            i1 = i2 + strspn(s + i2, \" \\t\");\n            i2 = i1 + strspn(s + i1, addr_chars);\n            if (i1 == i2 || s[i2] != '\\0') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (a2i_ipadd(max, s + i1) != length) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_INVALID_IPADDRESS);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (memcmp(min, max, length_from_afi(afi)) > 0) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (!v3_addr_add_range(addr, afi, safi, min, max)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        case '\\0':\n            if (!v3_addr_add_prefix(addr, afi, safi, min, length * 8)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        default:\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                      X509V3_R_EXTENSION_VALUE_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        OPENSSL_free(s);\n        s = NULL;\n    }\n\n    /*\n     * Canonize the result, then we're done.\n     */\n    if (!v3_addr_canonize(addr))\n        goto err;\n    return addr;\n\n err:\n    OPENSSL_free(s);\n    sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free);\n    return NULL;\n}", "patch_func_code": "static void *v2i_IPAddrBlocks(const struct v3_ext_method *method,\n                              struct v3_ext_ctx *ctx,\n                              STACK_OF(CONF_VALUE) *values)\n{\n    static const char v4addr_chars[] = \"0123456789.\";\n    static const char v6addr_chars[] = \"0123456789.:abcdefABCDEF\";\n    IPAddrBlocks *addr = NULL;\n    char *s = NULL, *t;\n    int i;\n\n    if ((addr = sk_IPAddressFamily_new(IPAddressFamily_cmp)) == NULL) {\n        X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    for (i = 0; i < sk_CONF_VALUE_num(values); i++) {\n        CONF_VALUE *val = sk_CONF_VALUE_value(values, i);\n        unsigned char min[ADDR_RAW_BUF_LEN], max[ADDR_RAW_BUF_LEN];\n        unsigned afi, *safi = NULL, safi_;\n        const char *addr_chars = NULL;\n        int prefixlen, i1, i2, delim, length;\n\n        if (!name_cmp(val->name, \"IPv4\")) {\n            afi = IANA_AFI_IPV4;\n        } else if (!name_cmp(val->name, \"IPv6\")) {\n            afi = IANA_AFI_IPV6;\n        } else if (!name_cmp(val->name, \"IPv4-SAFI\")) {\n            afi = IANA_AFI_IPV4;\n            safi = &safi_;\n        } else if (!name_cmp(val->name, \"IPv6-SAFI\")) {\n            afi = IANA_AFI_IPV6;\n            safi = &safi_;\n        } else {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                      X509V3_R_EXTENSION_NAME_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        switch (afi) {\n        case IANA_AFI_IPV4:\n            addr_chars = v4addr_chars;\n            break;\n        case IANA_AFI_IPV6:\n            addr_chars = v6addr_chars;\n            break;\n        }\n\n        length = length_from_afi(afi);\n\n        /*\n         * Handle SAFI, if any, and OPENSSL_strdup() so we can null-terminate\n         * the other input values.\n         */\n        if (safi != NULL) {\n            *safi = strtoul(val->value, &t, 0);\n            t += strspn(t, \" \\t\");\n            if (*safi > 0xFF || *t++ != ':') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_SAFI);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            t += strspn(t, \" \\t\");\n            s = OPENSSL_strdup(t);\n        } else {\n            s = OPENSSL_strdup(val->value);\n        }\n        if (s == NULL) {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n\n        /*\n         * Check for inheritance.  Not worth additional complexity to\n         * optimize this (seldom-used) case.\n         */\n        if (strcmp(s, \"inherit\") == 0) {\n            if (!v3_addr_add_inherit(addr, afi, safi)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_INVALID_INHERITANCE);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            OPENSSL_free(s);\n            s = NULL;\n            continue;\n        }\n\n        i1 = strspn(s, addr_chars);\n        i2 = i1 + strspn(s + i1, \" \\t\");\n        delim = s[i2++];\n        s[i1] = '\\0';\n\n        if (a2i_ipadd(min, s) != length) {\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS, X509V3_R_INVALID_IPADDRESS);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        switch (delim) {\n        case '/':\n            prefixlen = (int)strtoul(s + i2, &t, 10);\n            if (t == s + i2 || *t != '\\0') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (!v3_addr_add_prefix(addr, afi, safi, min, prefixlen)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        case '-':\n            i1 = i2 + strspn(s + i2, \" \\t\");\n            i2 = i1 + strspn(s + i1, addr_chars);\n            if (i1 == i2 || s[i2] != '\\0') {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (a2i_ipadd(max, s + i1) != length) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_INVALID_IPADDRESS);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (memcmp(min, max, length_from_afi(afi)) > 0) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                          X509V3_R_EXTENSION_VALUE_ERROR);\n                X509V3_conf_err(val);\n                goto err;\n            }\n            if (!v3_addr_add_range(addr, afi, safi, min, max)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        case '\\0':\n            if (!v3_addr_add_prefix(addr, afi, safi, min, length * 8)) {\n                X509V3err(X509V3_F_V2I_IPADDRBLOCKS, ERR_R_MALLOC_FAILURE);\n                goto err;\n            }\n            break;\n        default:\n            X509V3err(X509V3_F_V2I_IPADDRBLOCKS,\n                      X509V3_R_EXTENSION_VALUE_ERROR);\n            X509V3_conf_err(val);\n            goto err;\n        }\n\n        OPENSSL_free(s);\n        s = NULL;\n    }\n\n    /*\n     * Canonize the result, then we're done.\n     */\n    if (!v3_addr_canonize(addr))\n        goto err;\n    return addr;\n\n err:\n    OPENSSL_free(s);\n    sk_IPAddressFamily_pop_free(addr, IPAddressFamily_free);\n    return NULL;\n}", "before_change_lines": [52, 64, 66], "raw_before_change_lines": [52, 64, 66], "after_change_lines": [52, 64, 66], "raw_after_change_lines": [52, 64, 66], "bug_lines": [52, 64, 66], "added": [false, false, false], "idx": 499}
{"project": "openssl", "vul_type": "BUFFER_OVERRUN_L5", "filepath_func": "16620----BUFFER_OVERRUN_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_ddbfa79b85c60119be90fa16a23aa03c45c72e9c_1.json----RAND_DRBG_free", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_ddbfa79b85c60119be90fa16a23aa03c45c72e9c_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_ddbfa79b85c60119be90fa16a23aa03c45c72e9c_1.json", "function_name": "RAND_DRBG_free", "vul_func_code": "void RAND_DRBG_free(DRBG_CTX *dctx)\n{\n    if (dctx == NULL)\n        return;\n\n    ctr_uninstantiate(dctx);\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, dctx, &dctx->ex_data);\n\n    /* Don't free up default DRBG */\n    if (dctx == RAND_DRBG_get_default()) {\n        memset(dctx, 0, sizeof(DRBG_CTX));\n        dctx->nid = 0;\n        dctx->status = DRBG_STATUS_UNINITIALISED;\n    } else {\n        OPENSSL_cleanse(&dctx->ctr, sizeof(dctx->ctr));\n        OPENSSL_free(dctx);\n    }\n}", "patch_func_code": "void RAND_DRBG_free(RAND_DRBG *drbg)\n{\n    /* The global DRBG is free'd by rand_cleanup_int() */\n    if (drbg == NULL || drbg == &rand_drbg)\n        return;\n\n    ctr_uninstantiate(drbg);\n    OPENSSL_cleanse(drbg->randomness, drbg->size);\n    OPENSSL_free(drbg->randomness);\n    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_DRBG, drbg, &drbg->ex_data);\n    OPENSSL_clear_free(drbg, sizeof(*drbg));\n}", "before_change_lines": [1, 3, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17], "raw_before_change_lines": [1, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], "after_change_lines": [1, 4, 7, 8, 9, 10, 11], "raw_after_change_lines": [1, 3, 4, 7, 8, 9, 10, 11], "bug_lines": [1, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17], "added": [false, false, false, false, false, false, false, false, false, false, false, false, false, false], "idx": 500}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "16646----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_de919e0935eded987093d8ea3897c7f688a390e2_1.json----crl2pkcs7_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_de919e0935eded987093d8ea3897c7f688a390e2_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_de919e0935eded987093d8ea3897c7f688a390e2_1.json", "function_name": "crl2pkcs7_main", "vul_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint i,badops=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat;\n\tchar *infile,*outfile,*prog,*certfile;\n\tPKCS7 *p7 = NULL;\n\tPKCS7_SIGNED *p7s = NULL;\n\tX509_CRL *crl=NULL;\n\tSTACK *certflst=NULL;\n\tSTACK_OF(X509_CRL) *crl_stack=NULL;\n\tSTACK_OF(X509) *cert_stack=NULL;\n\tint ret=1,nocrl=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-nocrl\") == 0)\n\t\t\t{\n\t\t\tnocrl=1;\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-certfile\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tif(!certflst) certflst = sk_new_null();\n\t\t\tsk_push(certflst,*(++argv));\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg    input format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg   output format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg        input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg       output file\\n\");\n\t\tBIO_printf(bio_err,\" -certfile arg  certificates file of chain to a trusted CA\\n\");\n\t\tBIO_printf(bio_err,\"                (can be used more than once)\\n\");\n\t\tBIO_printf(bio_err,\" -nocrl         no crl to load, just certs from '-certfile'\\n\");\n\t\tEXIT(1);\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (!nocrl)\n\t\t{\n\t\tif (infile == NULL)\n\t\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\t\telse\n\t\t\t{\n\t\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\t\t\t{\n\t\t\t\tperror(infile);\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif \t(informat == FORMAT_ASN1)\n\t\t\tcrl=d2i_X509_CRL_bio(in,NULL);\n\t\telse if (informat == FORMAT_PEM)\n\t\t\tcrl=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (crl == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to load CRL\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\n\tif ((p7=PKCS7_new()) == NULL) goto end;\n\tif ((p7s=PKCS7_SIGNED_new()) == NULL) goto end;\n\tp7->type=OBJ_nid2obj(NID_pkcs7_signed);\n\tp7->d.sign=p7s;\n\tp7s->contents->type=OBJ_nid2obj(NID_pkcs7_data);\n\n\tif (!ASN1_INTEGER_set(p7s->version,1)) goto end;\n\tif ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end;\n\tp7s->crl=crl_stack;\n\tif (crl != NULL)\n\t\t{\n\t\tsk_X509_CRL_push(crl_stack,crl);\n\t\tcrl=NULL; /* now part of p7 for OPENSSL_freeing */\n\t\t}\n\n\tif ((cert_stack=sk_X509_new_null()) == NULL) goto end;\n\tp7s->cert=cert_stack;\n\n\tif(certflst) for(i = 0; i < sk_num(certflst); i++) {\n\t\tcertfile = sk_value(certflst, i);\n\t\tif (add_certs_from_file(cert_stack,certfile) < 0)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"error loading certificates\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t}\n\n\tsk_free(certflst);\n\n\tif (outfile == NULL)\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif \t(outformat == FORMAT_ASN1)\n\t\ti=i2d_PKCS7_bio(out,p7);\n\telse if (outformat == FORMAT_PEM)\n\t\ti=PEM_write_bio_PKCS7(out,p7);\n\telse\t{\n\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\tgoto end;\n\t\t}\n\tif (!i)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\tret=0;\nend:\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free(out);\n\tif (p7 != NULL) PKCS7_free(p7);\n\tif (crl != NULL) X509_CRL_free(crl);\n\n\tEXIT(ret);\n\t}", "patch_func_code": "int MAIN(int argc, char **argv)\n\t{\n\tint i,badops=0;\n\tBIO *in=NULL,*out=NULL;\n\tint informat,outformat;\n\tchar *infile,*outfile,*prog,*certfile;\n\tPKCS7 *p7 = NULL;\n\tPKCS7_SIGNED *p7s = NULL;\n\tX509_CRL *crl=NULL;\n\tSTACK *certflst=NULL;\n\tSTACK_OF(X509_CRL) *crl_stack=NULL;\n\tSTACK_OF(X509) *cert_stack=NULL;\n\tint ret=1,nocrl=0;\n\n\tapps_startup();\n\n\tif (bio_err == NULL)\n\t\tif ((bio_err=BIO_new(BIO_s_file())) != NULL)\n\t\t\tBIO_set_fp(bio_err,stderr,BIO_NOCLOSE|BIO_FP_TEXT);\n\n\tinfile=NULL;\n\toutfile=NULL;\n\tinformat=FORMAT_PEM;\n\toutformat=FORMAT_PEM;\n\n\tprog=argv[0];\n\targc--;\n\targv++;\n\twhile (argc >= 1)\n\t\t{\n\t\tif \t(strcmp(*argv,\"-inform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-outform\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutformat=str2fmt(*(++argv));\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-in\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tinfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-nocrl\") == 0)\n\t\t\t{\n\t\t\tnocrl=1;\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-out\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\toutfile= *(++argv);\n\t\t\t}\n\t\telse if (strcmp(*argv,\"-certfile\") == 0)\n\t\t\t{\n\t\t\tif (--argc < 1) goto bad;\n\t\t\tif(!certflst) certflst = sk_new_null();\n\t\t\tsk_push(certflst,*(++argv));\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unknown option %s\\n\",*argv);\n\t\t\tbadops=1;\n\t\t\tbreak;\n\t\t\t}\n\t\targc--;\n\t\targv++;\n\t\t}\n\n\tif (badops)\n\t\t{\nbad:\n\t\tBIO_printf(bio_err,\"%s [options] <infile >outfile\\n\",prog);\n\t\tBIO_printf(bio_err,\"where options are\\n\");\n\t\tBIO_printf(bio_err,\" -inform arg    input format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -outform arg   output format - DER or PEM\\n\");\n\t\tBIO_printf(bio_err,\" -in arg        input file\\n\");\n\t\tBIO_printf(bio_err,\" -out arg       output file\\n\");\n\t\tBIO_printf(bio_err,\" -certfile arg  certificates file of chain to a trusted CA\\n\");\n\t\tBIO_printf(bio_err,\"                (can be used more than once)\\n\");\n\t\tBIO_printf(bio_err,\" -nocrl         no crl to load, just certs from '-certfile'\\n\");\n\t\tEXIT(1);\n\t\t}\n\n\tERR_load_crypto_strings();\n\n\tin=BIO_new(BIO_s_file());\n\tout=BIO_new(BIO_s_file());\n\tif ((in == NULL) || (out == NULL))\n\t\t{\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\n\tif (!nocrl)\n\t\t{\n\t\tif (infile == NULL)\n\t\t\tBIO_set_fp(in,stdin,BIO_NOCLOSE);\n\t\telse\n\t\t\t{\n\t\t\tif (BIO_read_filename(in,infile) <= 0)\n\t\t\t\t{\n\t\t\t\tperror(infile);\n\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif \t(informat == FORMAT_ASN1)\n\t\t\tcrl=d2i_X509_CRL_bio(in,NULL);\n\t\telse if (informat == FORMAT_PEM)\n\t\t\tcrl=PEM_read_bio_X509_CRL(in,NULL,NULL,NULL);\n\t\telse\t{\n\t\t\tBIO_printf(bio_err,\"bad input format specified for input crl\\n\");\n\t\t\tgoto end;\n\t\t\t}\n\t\tif (crl == NULL)\n\t\t\t{\n\t\t\tBIO_printf(bio_err,\"unable to load CRL\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\n\tif ((p7=PKCS7_new()) == NULL) goto end;\n\tif ((p7s=PKCS7_SIGNED_new()) == NULL) goto end;\n\tp7->type=OBJ_nid2obj(NID_pkcs7_signed);\n\tp7->d.sign=p7s;\n\tp7s->contents->type=OBJ_nid2obj(NID_pkcs7_data);\n\n\tif (!ASN1_INTEGER_set(p7s->version,1)) goto end;\n\tif ((crl_stack=sk_X509_CRL_new_null()) == NULL) goto end;\n\tp7s->crl=crl_stack;\n\tif (crl != NULL)\n\t\t{\n\t\tsk_X509_CRL_push(crl_stack,crl);\n\t\tcrl=NULL; /* now part of p7 for OPENSSL_freeing */\n\t\t}\n\n\tif ((cert_stack=sk_X509_new_null()) == NULL) goto end;\n\tp7s->cert=cert_stack;\n\n\tif(certflst) for(i = 0; i < sk_num(certflst); i++) {\n\t\tcertfile = sk_value(certflst, i);\n\t\tif (add_certs_from_file(cert_stack,certfile) < 0)\n\t\t\t{\n\t\t\tBIO_printf(bio_err, \"error loading certificates\\n\");\n\t\t\tERR_print_errors(bio_err);\n\t\t\tgoto end;\n\t\t\t}\n\t}\n\n\tsk_free(certflst);\n\n\tif (outfile == NULL)\n\t\t{\n\t\tBIO_set_fp(out,stdout,BIO_NOCLOSE);\n#ifdef VMS\n\t\t{\n\t\tBIO *tmpbio = BIO_new(BIO_f_linebuffer());\n\t\tout = BIO_push(tmpbio, out);\n\t\t}\n#endif\n\t\t}\n\telse\n\t\t{\n\t\tif (BIO_write_filename(out,outfile) <= 0)\n\t\t\t{\n\t\t\tperror(outfile);\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\n\tif \t(outformat == FORMAT_ASN1)\n\t\ti=i2d_PKCS7_bio(out,p7);\n\telse if (outformat == FORMAT_PEM)\n\t\ti=PEM_write_bio_PKCS7(out,p7);\n\telse\t{\n\t\tBIO_printf(bio_err,\"bad output format specified for outfile\\n\");\n\t\tgoto end;\n\t\t}\n\tif (!i)\n\t\t{\n\t\tBIO_printf(bio_err,\"unable to write pkcs7 object\\n\");\n\t\tERR_print_errors(bio_err);\n\t\tgoto end;\n\t\t}\n\tret=0;\nend:\n\tif (in != NULL) BIO_free(in);\n\tif (out != NULL) BIO_free_all(out);\n\tif (p7 != NULL) PKCS7_free(p7);\n\tif (crl != NULL) X509_CRL_free(crl);\n\n\tEXIT(ret);\n\t}", "before_change_lines": [183], "raw_before_change_lines": [183], "after_change_lines": [156, 158, 159, 160, 161, 162, 163, 164, 191], "raw_after_change_lines": [156, 158, 159, 160, 161, 162, 163, 164, 191], "bug_lines": [183], "added": [false], "idx": 501}
{"project": "openssl", "vul_type": "UNINITIALIZED_VALUE", "filepath_func": "16648----UNINITIALIZED_VALUE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_deabc03e2be169f0d232a254c025b4d6f98f9f02_1.json----SSL_get_shared_ciphers", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_deabc03e2be169f0d232a254c025b4d6f98f9f02_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_deabc03e2be169f0d232a254c025b4d6f98f9f02_1.json", "function_name": "SSL_get_shared_ciphers", "vul_func_code": "char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)\n\t{\n\tchar *p;\n\tSTACK_OF(SSL_CIPHER) *sk;\n\tSSL_CIPHER *c;\n\tint i;\n\n\tif ((s->session == NULL) || (s->session->ciphers == NULL) ||\n\t\t(len < 2))\n\t\treturn(NULL);\n\n\tif (sk_SSL_CIPHER_num(sk) == 0)\n\t\treturn NULL;\n\n\tp=buf;\n\tsk=s->session->ciphers;\n\tfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\n\t\t{\n\t\tint n;\n\n\t\tc=sk_SSL_CIPHER_value(sk,i);\n\t\tn=strlen(c->name);\n\t\tif (n+1 > len)\n\t\t\t{\n\t\t\tif (p != buf)\n\t\t\t\t--p;\n\t\t\t*p='\\0';\n\t\t\treturn buf;\n\t\t\t}\n\t\tstrcpy(p,c->name);\n\t\tp+=n;\n\t\t*(p++)=':';\n\t\tlen-=n+1;\n\t\t}\n\tp[-1]='\\0';\n\treturn(buf);\n\t}", "patch_func_code": "char *SSL_get_shared_ciphers(const SSL *s,char *buf,int len)\n\t{\n\tchar *p;\n\tSTACK_OF(SSL_CIPHER) *sk;\n\tSSL_CIPHER *c;\n\tint i;\n\n\tif ((s->session == NULL) || (s->session->ciphers == NULL) ||\n\t\t(len < 2))\n\t\treturn(NULL);\n\n\tp=buf;\n\tsk=s->session->ciphers;\n\n\tif (sk_SSL_CIPHER_num(sk) == 0)\n\t\treturn NULL;\n\n\tfor (i=0; i<sk_SSL_CIPHER_num(sk); i++)\n\t\t{\n\t\tint n;\n\n\t\tc=sk_SSL_CIPHER_value(sk,i);\n\t\tn=strlen(c->name);\n\t\tif (n+1 > len)\n\t\t\t{\n\t\t\tif (p != buf)\n\t\t\t\t--p;\n\t\t\t*p='\\0';\n\t\t\treturn buf;\n\t\t\t}\n\t\tstrcpy(p,c->name);\n\t\tp+=n;\n\t\t*(p++)=':';\n\t\tlen-=n+1;\n\t\t}\n\tp[-1]='\\0';\n\treturn(buf);\n\t}", "before_change_lines": [15, 16], "raw_before_change_lines": [15, 16], "after_change_lines": [12, 13], "raw_after_change_lines": [12, 13, 14], "bug_lines": [15, 16], "added": [false, false], "idx": 502}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "16794----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_e4b96056af7e00e9ff2f8aef4b82b89eee329a2f_1.json----EVP_EncryptUpdate", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_e4b96056af7e00e9ff2f8aef4b82b89eee329a2f_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_e4b96056af7e00e9ff2f8aef4b82b89eee329a2f_1.json", "function_name": "EVP_EncryptUpdate", "vul_func_code": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint i,j,bl;\n\n\tOPENSSL_assert(inl > 0);\n\tif(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0)\n\t\t{\n\t\tif(ctx->cipher->do_cipher(ctx,out,in,inl))\n\t\t\t{\n\t\t\t*outl=inl;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t*outl=0;\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\ti=ctx->buf_len;\n\tbl=ctx->cipher->block_size;\n\tOPENSSL_assert(bl <= sizeof ctx->buf);\n\tif (i != 0)\n\t\t{\n\t\tif (i+inl < bl)\n\t\t\t{\n\t\t\tmemcpy(&(ctx->buf[i]),in,inl);\n\t\t\tctx->buf_len+=inl;\n\t\t\t*outl=0;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tj=bl-i;\n\t\t\tmemcpy(&(ctx->buf[i]),in,j);\n\t\t\tif(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;\n\t\t\tinl-=j;\n\t\t\tin+=j;\n\t\t\tout+=bl;\n\t\t\t*outl=bl;\n\t\t\t}\n\t\t}\n\telse\n\t\t*outl = 0;\n\ti=inl&(bl-1);\n\tinl-=i;\n\tif (inl > 0)\n\t\t{\n\t\tif(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;\n\t\t*outl+=inl;\n\t\t}\n\n\tif (i != 0)\n\t\tmemcpy(ctx->buf,&(in[inl]),i);\n\tctx->buf_len=i;\n\treturn 1;\n\t}", "patch_func_code": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n\t     const unsigned char *in, int inl)\n\t{\n\tint i,j,bl;\n\n\tOPENSSL_assert(inl > 0);\n\tif(ctx->buf_len == 0 && (inl&(ctx->block_mask)) == 0)\n\t\t{\n\t\tif(ctx->cipher->do_cipher(ctx,out,in,inl))\n\t\t\t{\n\t\t\t*outl=inl;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t*outl=0;\n\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\ti=ctx->buf_len;\n\tbl=ctx->cipher->block_size;\n\tOPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n\tif (i != 0)\n\t\t{\n\t\tif (i+inl < bl)\n\t\t\t{\n\t\t\tmemcpy(&(ctx->buf[i]),in,inl);\n\t\t\tctx->buf_len+=inl;\n\t\t\t*outl=0;\n\t\t\treturn 1;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tj=bl-i;\n\t\t\tmemcpy(&(ctx->buf[i]),in,j);\n\t\t\tif(!ctx->cipher->do_cipher(ctx,out,ctx->buf,bl)) return 0;\n\t\t\tinl-=j;\n\t\t\tin+=j;\n\t\t\tout+=bl;\n\t\t\t*outl=bl;\n\t\t\t}\n\t\t}\n\telse\n\t\t*outl = 0;\n\ti=inl&(bl-1);\n\tinl-=i;\n\tif (inl > 0)\n\t\t{\n\t\tif(!ctx->cipher->do_cipher(ctx,out,in,inl)) return 0;\n\t\t*outl+=inl;\n\t\t}\n\n\tif (i != 0)\n\t\tmemcpy(ctx->buf,&(in[inl]),i);\n\tctx->buf_len=i;\n\treturn 1;\n\t}", "before_change_lines": [22], "raw_before_change_lines": [22], "after_change_lines": [22], "raw_after_change_lines": [22], "bug_lines": [22], "added": [false], "idx": 503}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "16975----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_eb70282aba0c70825e6968f9b34182cbf10c8b92_1.json----BLAKE2s_Final", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_eb70282aba0c70825e6968f9b34182cbf10c8b92_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_eb70282aba0c70825e6968f9b34182cbf10c8b92_1.json", "function_name": "BLAKE2s_Final", "vul_func_code": "int BLAKE2s_Final(unsigned char *md, BLAKE2S_CTX *c)\n{\n    int i;\n\n    blake2s_increment_counter(c, (uint32_t)c->buflen);\n    blake2s_set_lastblock(c);\n    /* Padding */\n    memset(c->buf + c->buflen, 0, sizeof(c->buf) - c->buflen);\n    blake2s_compress(c, c->buf);\n\n    /* Output full hash to temp buffer */\n    for(i = 0; i < 8; ++i) {\n        store32(md + sizeof(c->h[i]) * i, c->h[i]);\n    }\n\n    OPENSSL_cleanse(c, sizeof(BLAKE2S_CTX));\n    return 1;\n}", "patch_func_code": "int BLAKE2s_Final(unsigned char *md, BLAKE2S_CTX *c)\n{\n    int i;\n\n    blake2s_set_lastblock(c);\n    /* Padding */\n    memset(c->buf + c->buflen, 0, sizeof(c->buf) - c->buflen);\n    blake2s_compress(c, c->buf, c->buflen);\n\n    /* Output full hash to temp buffer */\n    for (i = 0; i < 8; ++i) {\n        store32(md + sizeof(c->h[i]) * i, c->h[i]);\n    }\n\n    OPENSSL_cleanse(c, sizeof(BLAKE2S_CTX));\n    return 1;\n}", "before_change_lines": [5, 9, 12], "raw_before_change_lines": [5, 9, 12], "after_change_lines": [8, 11], "raw_after_change_lines": [8, 11], "bug_lines": [5, 9, 12], "added": [false, false, false], "idx": 504}
{"project": "openssl", "vul_type": "NULL_DEREFERENCE", "filepath_func": "17080----NULL_DEREFERENCE----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_ee69f3f79b14cab8dd61fbd0ea5a999467ab6c04_1.json----crl2pkcs7_main", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_ee69f3f79b14cab8dd61fbd0ea5a999467ab6c04_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_ee69f3f79b14cab8dd61fbd0ea5a999467ab6c04_1.json", "function_name": "crl2pkcs7_main", "vul_func_code": "int crl2pkcs7_main(int argc, char **argv)\n{\n    BIO *in = NULL, *out = NULL;\n    PKCS7 *p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    STACK_OF(OPENSSL_STRING) *certflst = NULL;\n    STACK_OF(X509) *cert_stack = NULL;\n    STACK_OF(X509_CRL) *crl_stack = NULL;\n    X509_CRL *crl = NULL;\n    char *infile = NULL, *outfile = NULL, *prog, *certfile;\n    int i = 0, informat = FORMAT_PEM, outformat = FORMAT_PEM, ret = 1, nocrl =\n        0;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, crl2pkcs7_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(crl2pkcs7_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOCRL:\n            nocrl = 1;\n            break;\n        case OPT_CERTFILE:\n            if ((certflst == NULL)\n                && (certflst = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (!sk_OPENSSL_STRING_push(certflst, *(++argv))) {\n                sk_OPENSSL_STRING_free(certflst);\n                goto end;\n            }\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    if (!nocrl) {\n        in = bio_open_default(infile, RB(informat));\n        if (in == NULL)\n            goto end;\n\n        if (informat == FORMAT_ASN1)\n            crl = d2i_X509_CRL_bio(in, NULL);\n        else if (informat == FORMAT_PEM)\n            crl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);\n        if (crl == NULL) {\n            BIO_printf(bio_err, \"unable to load CRL\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((p7 = PKCS7_new()) == NULL)\n        goto end;\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto end;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n    p7->d.sign = p7s;\n    p7s->contents->type = OBJ_nid2obj(NID_pkcs7_data);\n\n    if (!ASN1_INTEGER_set(p7s->version, 1))\n        goto end;\n    if ((crl_stack = sk_X509_CRL_new_null()) == NULL)\n        goto end;\n    p7s->crl = crl_stack;\n    if (crl != NULL) {\n        sk_X509_CRL_push(crl_stack, crl);\n        crl = NULL;             /* now part of p7 for OPENSSL_freeing */\n    }\n\n    if ((cert_stack = sk_X509_new_null()) == NULL)\n        goto end;\n    p7s->cert = cert_stack;\n\n    if (certflst)\n        for (i = 0; i < sk_OPENSSL_STRING_num(certflst); i++) {\n            certfile = sk_OPENSSL_STRING_value(certflst, i);\n            if (add_certs_from_file(cert_stack, certfile) < 0) {\n                BIO_printf(bio_err, \"error loading certificates\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n        }\n\n    sk_OPENSSL_STRING_free(certflst);\n\n    out = bio_open_default(outfile, WB(outformat));\n    if (out == NULL)\n        goto end;\n\n    if (outformat == FORMAT_ASN1)\n        i = i2d_PKCS7_bio(out, p7);\n    else if (outformat == FORMAT_PEM)\n        i = PEM_write_bio_PKCS7(out, p7);\n    if (!i) {\n        BIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    ret = 0;\n end:\n    BIO_free(in);\n    BIO_free_all(out);\n    PKCS7_free(p7);\n    X509_CRL_free(crl);\n\n    return (ret);\n}", "patch_func_code": "int crl2pkcs7_main(int argc, char **argv)\n{\n    BIO *in = NULL, *out = NULL;\n    PKCS7 *p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    STACK_OF(OPENSSL_STRING) *certflst = NULL;\n    STACK_OF(X509) *cert_stack = NULL;\n    STACK_OF(X509_CRL) *crl_stack = NULL;\n    X509_CRL *crl = NULL;\n    char *infile = NULL, *outfile = NULL, *prog, *certfile;\n    int i = 0, informat = FORMAT_PEM, outformat = FORMAT_PEM, ret = 1, nocrl =\n        0;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, crl2pkcs7_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(crl2pkcs7_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOCRL:\n            nocrl = 1;\n            break;\n        case OPT_CERTFILE:\n            if ((certflst == NULL)\n                && (certflst = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (!sk_OPENSSL_STRING_push(certflst, *(++argv))) {\n                sk_OPENSSL_STRING_free(certflst);\n                goto end;\n            }\n            break;\n        }\n    }\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_load_modules(NULL))\n        goto end;\n\n    if (!nocrl) {\n        in = bio_open_default(infile, 'r', informat);\n        if (in == NULL)\n            goto end;\n\n        if (informat == FORMAT_ASN1)\n            crl = d2i_X509_CRL_bio(in, NULL);\n        else if (informat == FORMAT_PEM)\n            crl = PEM_read_bio_X509_CRL(in, NULL, NULL, NULL);\n        if (crl == NULL) {\n            BIO_printf(bio_err, \"unable to load CRL\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((p7 = PKCS7_new()) == NULL)\n        goto end;\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto end;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n    p7->d.sign = p7s;\n    p7s->contents->type = OBJ_nid2obj(NID_pkcs7_data);\n\n    if (!ASN1_INTEGER_set(p7s->version, 1))\n        goto end;\n    if ((crl_stack = sk_X509_CRL_new_null()) == NULL)\n        goto end;\n    p7s->crl = crl_stack;\n    if (crl != NULL) {\n        sk_X509_CRL_push(crl_stack, crl);\n        crl = NULL;             /* now part of p7 for OPENSSL_freeing */\n    }\n\n    if ((cert_stack = sk_X509_new_null()) == NULL)\n        goto end;\n    p7s->cert = cert_stack;\n\n    if (certflst)\n        for (i = 0; i < sk_OPENSSL_STRING_num(certflst); i++) {\n            certfile = sk_OPENSSL_STRING_value(certflst, i);\n            if (add_certs_from_file(cert_stack, certfile) < 0) {\n                BIO_printf(bio_err, \"error loading certificates\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n        }\n\n    sk_OPENSSL_STRING_free(certflst);\n\n    out = bio_open_default(outfile, 'w', outformat);\n    if (out == NULL)\n        goto end;\n\n    if (outformat == FORMAT_ASN1)\n        i = i2d_PKCS7_bio(out, p7);\n    else if (outformat == FORMAT_PEM)\n        i = PEM_write_bio_PKCS7(out, p7);\n    if (!i) {\n        BIO_printf(bio_err, \"unable to write pkcs7 object\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    ret = 0;\n end:\n    BIO_free(in);\n    BIO_free_all(out);\n    PKCS7_free(p7);\n    X509_CRL_free(crl);\n\n    return (ret);\n}", "before_change_lines": [62, 111], "raw_before_change_lines": [62, 111], "after_change_lines": [62, 111], "raw_after_change_lines": [62, 111], "bug_lines": [62, 111], "added": [false, false], "idx": 505}
{"project": "openssl", "vul_type": "INTEGER_OVERFLOW_L5", "filepath_func": "17365----INTEGER_OVERFLOW_L5----G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_f8c063c882c2172f6fa20d284b85143b06c861dd_1.json----sh_testbit", "patch_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/after_fix/openssl_f8c063c882c2172f6fa20d284b85143b06c861dd_0.json", "vul_filepath": "G:/smm_data/D2A_dataset/openssl/d2a/before_fix/openssl_f8c063c882c2172f6fa20d284b85143b06c861dd_1.json", "function_name": "sh_testbit", "vul_func_code": "static int sh_testbit(char *ptr, int list, unsigned char *table)\n{\n    int bit;\n\n    OPENSSL_assert(list >= 0 && list < sh.freelist_size);\n    OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);\n    bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));\n    OPENSSL_assert(bit > 0 && bit < sh.bittable_size);\n    return TESTBIT(table, bit);\n}", "patch_func_code": "static int sh_testbit(char *ptr, int list, unsigned char *table)\n{\n    size_t bit;\n\n    OPENSSL_assert(list >= 0 && list < sh.freelist_size);\n    OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);\n    bit = (ONE << list) + ((ptr - sh.arena) / (sh.arena_size >> list));\n    OPENSSL_assert(bit > 0 && bit < sh.bittable_size);\n    return TESTBIT(table, bit);\n}", "before_change_lines": [3, 7], "raw_before_change_lines": [3, 7], "after_change_lines": [3, 7], "raw_after_change_lines": [3, 7], "bug_lines": [3, 7], "added": [false, false], "idx": 506}
