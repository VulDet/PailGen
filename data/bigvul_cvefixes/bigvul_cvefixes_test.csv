,filepath,vul_code,diff_target,patch_code
0,584----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-2479--huge_memory.c----hugepage_madvise,"int hugepage_madvise(struct vm_area_struct *vma, unsigned long *vm_flags, int advice) { switch (advice) { case MADV_HUGEPAGE: <S2SV_StartVul> if (*vm_flags & (VM_HUGEPAGE | <S2SV_EndVul> <S2SV_StartVul> VM_SHARED | VM_MAYSHARE | <S2SV_EndVul> <S2SV_StartVul> VM_PFNMAP | VM_IO | VM_DONTEXPAND | <S2SV_EndVul> <S2SV_StartVul> VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | <S2SV_EndVul> <S2SV_StartVul> VM_MIXEDMAP | VM_SAO)) <S2SV_EndVul> return -EINVAL; *vm_flags &= ~VM_NOHUGEPAGE; *vm_flags |= VM_HUGEPAGE; if (unlikely(khugepaged_enter_vma_merge(vma))) return -ENOMEM; break; case MADV_NOHUGEPAGE: <S2SV_StartVul> if (*vm_flags & (VM_NOHUGEPAGE | <S2SV_EndVul> <S2SV_StartVul> VM_SHARED | VM_MAYSHARE | <S2SV_EndVul> <S2SV_StartVul> VM_PFNMAP | VM_IO | VM_DONTEXPAND | <S2SV_EndVul> <S2SV_StartVul> VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE | <S2SV_EndVul> <S2SV_StartVul> VM_MIXEDMAP | VM_SAO)) <S2SV_EndVul> return -EINVAL; *vm_flags &= ~VM_HUGEPAGE; *vm_flags |= VM_NOHUGEPAGE; break; } return 0; }","- if (*vm_flags & (VM_HUGEPAGE |
- VM_SHARED | VM_MAYSHARE |
- VM_PFNMAP | VM_IO | VM_DONTEXPAND |
- VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |
- VM_MIXEDMAP | VM_SAO))
- if (*vm_flags & (VM_NOHUGEPAGE |
- VM_SHARED | VM_MAYSHARE |
- VM_PFNMAP | VM_IO | VM_DONTEXPAND |
- VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |
- VM_MIXEDMAP | VM_SAO))
+ if (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))
+ if (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))","int hugepage_madvise(struct vm_area_struct *vma, unsigned long *vm_flags, int advice) { switch (advice) { case MADV_HUGEPAGE: if (*vm_flags & (VM_HUGEPAGE | VM_NO_THP)) return -EINVAL; *vm_flags &= ~VM_NOHUGEPAGE; *vm_flags |= VM_HUGEPAGE; if (unlikely(khugepaged_enter_vma_merge(vma))) return -ENOMEM; break; case MADV_NOHUGEPAGE: if (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP)) return -EINVAL; *vm_flags &= ~VM_HUGEPAGE; *vm_flags |= VM_NOHUGEPAGE; break; } return 0; }"
1,388----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-7014--pngdsp.c----add_bytes_l2_c,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w) { long i; <S2SV_StartVul> for (i = 0; i <= w - sizeof(long); i += sizeof(long)) { <S2SV_EndVul> long a = *(long *)(src1 + i); long b = *(long *)(src2 + i); *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80); } for (; i < w; i++) dst[i] = src1[i] + src2[i]; }","- for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {
+ for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {","static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w) { long i; for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) { long a = *(long *)(src1 + i); long b = *(long *)(src2 + i); *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80); } for (; i < w; i++) dst[i] = src1[i] + src2[i]; }"
2,955----CWE-284----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-8630--emulate.c----x86_decode_insn,"int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) { int rc = X86EMUL_CONTINUE; int mode = ctxt->mode; int def_op_bytes, def_ad_bytes, goffset, simd_prefix; bool op_prefix = false; bool has_seg_override = false; struct opcode opcode; ctxt->memop.type = OP_NONE; ctxt->memopp = NULL; ctxt->_eip = ctxt->eip; ctxt->fetch.ptr = ctxt->fetch.data; ctxt->fetch.end = ctxt->fetch.data + insn_len; ctxt->opcode_len = 1; if (insn_len > 0) memcpy(ctxt->fetch.data, insn, insn_len); else { rc = __do_insn_fetch_bytes(ctxt, 1); if (rc != X86EMUL_CONTINUE) return rc; } switch (mode) { case X86EMUL_MODE_REAL: case X86EMUL_MODE_VM86: case X86EMUL_MODE_PROT16: def_op_bytes = def_ad_bytes = 2; break; case X86EMUL_MODE_PROT32: def_op_bytes = def_ad_bytes = 4; break; #ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64: def_op_bytes = 4; def_ad_bytes = 8; break; #endif default: return EMULATION_FAILED; } ctxt->op_bytes = def_op_bytes; ctxt->ad_bytes = def_ad_bytes; for (;;) { switch (ctxt->b = insn_fetch(u8, ctxt)) { case 0x66: op_prefix = true; ctxt->op_bytes = def_op_bytes ^ 6; break; case 0x67: if (mode == X86EMUL_MODE_PROT64) ctxt->ad_bytes = def_ad_bytes ^ 12; else ctxt->ad_bytes = def_ad_bytes ^ 6; break; case 0x26: case 0x2e: case 0x36: case 0x3e: has_seg_override = true; ctxt->seg_override = (ctxt->b >> 3) & 3; break; case 0x64: case 0x65: has_seg_override = true; ctxt->seg_override = ctxt->b & 7; break; case 0x40 ... 0x4f: if (mode != X86EMUL_MODE_PROT64) goto done_prefixes; ctxt->rex_prefix = ctxt->b; continue; case 0xf0: ctxt->lock_prefix = 1; break; case 0xf2: case 0xf3: ctxt->rep_prefix = ctxt->b; break; default: goto done_prefixes; } ctxt->rex_prefix = 0; } done_prefixes: if (ctxt->rex_prefix & 8) ctxt->op_bytes = 8; opcode = opcode_table[ctxt->b]; if (ctxt->b == 0x0f) { ctxt->opcode_len = 2; ctxt->b = insn_fetch(u8, ctxt); opcode = twobyte_table[ctxt->b]; if (ctxt->b == 0x38) { ctxt->opcode_len = 3; ctxt->b = insn_fetch(u8, ctxt); opcode = opcode_map_0f_38[ctxt->b]; } } ctxt->d = opcode.flags; if (ctxt->d & ModRM) ctxt->modrm = insn_fetch(u8, ctxt); if (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) && (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) { ctxt->d = NotImpl; } while (ctxt->d & GroupMask) { switch (ctxt->d & GroupMask) { case Group: goffset = (ctxt->modrm >> 3) & 7; opcode = opcode.u.group[goffset]; break; case GroupDual: goffset = (ctxt->modrm >> 3) & 7; if ((ctxt->modrm >> 6) == 3) opcode = opcode.u.gdual->mod3[goffset]; else opcode = opcode.u.gdual->mod012[goffset]; break; case RMExt: goffset = ctxt->modrm & 7; opcode = opcode.u.group[goffset]; break; case Prefix: if (ctxt->rep_prefix && op_prefix) return EMULATION_FAILED; simd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix; switch (simd_prefix) { case 0x00: opcode = opcode.u.gprefix->pfx_no; break; case 0x66: opcode = opcode.u.gprefix->pfx_66; break; case 0xf2: opcode = opcode.u.gprefix->pfx_f2; break; case 0xf3: opcode = opcode.u.gprefix->pfx_f3; break; } break; case Escape: if (ctxt->modrm > 0xbf) opcode = opcode.u.esc->high[ctxt->modrm - 0xc0]; else opcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7]; break; case InstrDual: if ((ctxt->modrm >> 6) == 3) opcode = opcode.u.idual->mod3; else opcode = opcode.u.idual->mod012; break; case ModeDual: if (ctxt->mode == X86EMUL_MODE_PROT64) opcode = opcode.u.mdual->mode64; else opcode = opcode.u.mdual->mode32; break; default: return EMULATION_FAILED; } ctxt->d &= ~(u64)GroupMask; ctxt->d |= opcode.flags; } if (ctxt->d == 0) return EMULATION_FAILED; ctxt->execute = opcode.u.execute; if (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD))) return EMULATION_FAILED; if (unlikely(ctxt->d & (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch| No16))) { ctxt->check_perm = opcode.check_perm; ctxt->intercept = opcode.intercept; if (ctxt->d & NotImpl) return EMULATION_FAILED; if (mode == X86EMUL_MODE_PROT64) { if (ctxt->op_bytes == 4 && (ctxt->d & Stack)) ctxt->op_bytes = 8; else if (ctxt->d & NearBranch) ctxt->op_bytes = 8; } if (ctxt->d & Op3264) { if (mode == X86EMUL_MODE_PROT64) ctxt->op_bytes = 8; else ctxt->op_bytes = 4; } if ((ctxt->d & No16) && ctxt->op_bytes == 2) ctxt->op_bytes = 4; if (ctxt->d & Sse) ctxt->op_bytes = 16; else if (ctxt->d & Mmx) ctxt->op_bytes = 8; } if (ctxt->d & ModRM) { rc = decode_modrm(ctxt, &ctxt->memop); if (!has_seg_override) { has_seg_override = true; ctxt->seg_override = ctxt->modrm_seg; } } else if (ctxt->d & MemAbs) rc = decode_abs(ctxt, &ctxt->memop); if (rc != X86EMUL_CONTINUE) goto done; if (!has_seg_override) ctxt->seg_override = VCPU_SREG_DS; ctxt->memop.addr.mem.seg = ctxt->seg_override; rc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask); if (rc != X86EMUL_CONTINUE) goto done; rc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask); if (rc != X86EMUL_CONTINUE) goto done; rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask); <S2SV_StartVul> if (ctxt->rip_relative) <S2SV_EndVul> ctxt->memopp->addr.mem.ea = address_mask(ctxt, ctxt->memopp->addr.mem.ea + ctxt->_eip); done: return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK; }","- if (ctxt->rip_relative)
+ if (ctxt->rip_relative && likely(ctxt->memopp))","int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len) { int rc = X86EMUL_CONTINUE; int mode = ctxt->mode; int def_op_bytes, def_ad_bytes, goffset, simd_prefix; bool op_prefix = false; bool has_seg_override = false; struct opcode opcode; ctxt->memop.type = OP_NONE; ctxt->memopp = NULL; ctxt->_eip = ctxt->eip; ctxt->fetch.ptr = ctxt->fetch.data; ctxt->fetch.end = ctxt->fetch.data + insn_len; ctxt->opcode_len = 1; if (insn_len > 0) memcpy(ctxt->fetch.data, insn, insn_len); else { rc = __do_insn_fetch_bytes(ctxt, 1); if (rc != X86EMUL_CONTINUE) return rc; } switch (mode) { case X86EMUL_MODE_REAL: case X86EMUL_MODE_VM86: case X86EMUL_MODE_PROT16: def_op_bytes = def_ad_bytes = 2; break; case X86EMUL_MODE_PROT32: def_op_bytes = def_ad_bytes = 4; break; #ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64: def_op_bytes = 4; def_ad_bytes = 8; break; #endif default: return EMULATION_FAILED; } ctxt->op_bytes = def_op_bytes; ctxt->ad_bytes = def_ad_bytes; for (;;) { switch (ctxt->b = insn_fetch(u8, ctxt)) { case 0x66: op_prefix = true; ctxt->op_bytes = def_op_bytes ^ 6; break; case 0x67: if (mode == X86EMUL_MODE_PROT64) ctxt->ad_bytes = def_ad_bytes ^ 12; else ctxt->ad_bytes = def_ad_bytes ^ 6; break; case 0x26: case 0x2e: case 0x36: case 0x3e: has_seg_override = true; ctxt->seg_override = (ctxt->b >> 3) & 3; break; case 0x64: case 0x65: has_seg_override = true; ctxt->seg_override = ctxt->b & 7; break; case 0x40 ... 0x4f: if (mode != X86EMUL_MODE_PROT64) goto done_prefixes; ctxt->rex_prefix = ctxt->b; continue; case 0xf0: ctxt->lock_prefix = 1; break; case 0xf2: case 0xf3: ctxt->rep_prefix = ctxt->b; break; default: goto done_prefixes; } ctxt->rex_prefix = 0; } done_prefixes: if (ctxt->rex_prefix & 8) ctxt->op_bytes = 8; opcode = opcode_table[ctxt->b]; if (ctxt->b == 0x0f) { ctxt->opcode_len = 2; ctxt->b = insn_fetch(u8, ctxt); opcode = twobyte_table[ctxt->b]; if (ctxt->b == 0x38) { ctxt->opcode_len = 3; ctxt->b = insn_fetch(u8, ctxt); opcode = opcode_map_0f_38[ctxt->b]; } } ctxt->d = opcode.flags; if (ctxt->d & ModRM) ctxt->modrm = insn_fetch(u8, ctxt); if (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) && (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) { ctxt->d = NotImpl; } while (ctxt->d & GroupMask) { switch (ctxt->d & GroupMask) { case Group: goffset = (ctxt->modrm >> 3) & 7; opcode = opcode.u.group[goffset]; break; case GroupDual: goffset = (ctxt->modrm >> 3) & 7; if ((ctxt->modrm >> 6) == 3) opcode = opcode.u.gdual->mod3[goffset]; else opcode = opcode.u.gdual->mod012[goffset]; break; case RMExt: goffset = ctxt->modrm & 7; opcode = opcode.u.group[goffset]; break; case Prefix: if (ctxt->rep_prefix && op_prefix) return EMULATION_FAILED; simd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix; switch (simd_prefix) { case 0x00: opcode = opcode.u.gprefix->pfx_no; break; case 0x66: opcode = opcode.u.gprefix->pfx_66; break; case 0xf2: opcode = opcode.u.gprefix->pfx_f2; break; case 0xf3: opcode = opcode.u.gprefix->pfx_f3; break; } break; case Escape: if (ctxt->modrm > 0xbf) opcode = opcode.u.esc->high[ctxt->modrm - 0xc0]; else opcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7]; break; case InstrDual: if ((ctxt->modrm >> 6) == 3) opcode = opcode.u.idual->mod3; else opcode = opcode.u.idual->mod012; break; case ModeDual: if (ctxt->mode == X86EMUL_MODE_PROT64) opcode = opcode.u.mdual->mode64; else opcode = opcode.u.mdual->mode32; break; default: return EMULATION_FAILED; } ctxt->d &= ~(u64)GroupMask; ctxt->d |= opcode.flags; } if (ctxt->d == 0) return EMULATION_FAILED; ctxt->execute = opcode.u.execute; if (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD))) return EMULATION_FAILED; if (unlikely(ctxt->d & (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch| No16))) { ctxt->check_perm = opcode.check_perm; ctxt->intercept = opcode.intercept; if (ctxt->d & NotImpl) return EMULATION_FAILED; if (mode == X86EMUL_MODE_PROT64) { if (ctxt->op_bytes == 4 && (ctxt->d & Stack)) ctxt->op_bytes = 8; else if (ctxt->d & NearBranch) ctxt->op_bytes = 8; } if (ctxt->d & Op3264) { if (mode == X86EMUL_MODE_PROT64) ctxt->op_bytes = 8; else ctxt->op_bytes = 4; } if ((ctxt->d & No16) && ctxt->op_bytes == 2) ctxt->op_bytes = 4; if (ctxt->d & Sse) ctxt->op_bytes = 16; else if (ctxt->d & Mmx) ctxt->op_bytes = 8; } if (ctxt->d & ModRM) { rc = decode_modrm(ctxt, &ctxt->memop); if (!has_seg_override) { has_seg_override = true; ctxt->seg_override = ctxt->modrm_seg; } } else if (ctxt->d & MemAbs) rc = decode_abs(ctxt, &ctxt->memop); if (rc != X86EMUL_CONTINUE) goto done; if (!has_seg_override) ctxt->seg_override = VCPU_SREG_DS; ctxt->memop.addr.mem.seg = ctxt->seg_override; rc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask); if (rc != X86EMUL_CONTINUE) goto done; rc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask); if (rc != X86EMUL_CONTINUE) goto done; rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask); if (ctxt->rip_relative && likely(ctxt->memopp)) ctxt->memopp->addr.mem.ea = address_mask(ctxt, ctxt->memopp->addr.mem.ea + ctxt->_eip); done: return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK; }"
3,2013----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-12460--idctdsp.c----ff_idctdsp_init,"av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx) { const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8; if (avctx->lowres==1) { c->idct_put = ff_jref_idct4_put; c->idct_add = ff_jref_idct4_add; c->idct = ff_j_rev_dct4; c->perm_type = FF_IDCT_PERM_NONE; } else if (avctx->lowres==2) { c->idct_put = ff_jref_idct2_put; c->idct_add = ff_jref_idct2_add; c->idct = ff_j_rev_dct2; c->perm_type = FF_IDCT_PERM_NONE; } else if (avctx->lowres==3) { c->idct_put = ff_jref_idct1_put; c->idct_add = ff_jref_idct1_add; c->idct = ff_j_rev_dct1; c->perm_type = FF_IDCT_PERM_NONE; } else { if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) { <S2SV_StartVul> if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO) <S2SV_EndVul> c->idct_put = ff_simple_idct_put_int32_10bit; else { c->idct_put = ff_simple_idct_put_int16_10bit; c->idct_add = ff_simple_idct_add_int16_10bit; c->idct = ff_simple_idct_int16_10bit; } c->perm_type = FF_IDCT_PERM_NONE; } else if (avctx->bits_per_raw_sample == 12) { c->idct_put = ff_simple_idct_put_int16_12bit; c->idct_add = ff_simple_idct_add_int16_12bit; c->idct = ff_simple_idct_int16_12bit; c->perm_type = FF_IDCT_PERM_NONE; } else { if (avctx->idct_algo == FF_IDCT_INT) { c->idct_put = ff_jref_idct_put; c->idct_add = ff_jref_idct_add; c->idct = ff_j_rev_dct; c->perm_type = FF_IDCT_PERM_LIBMPEG2; #if CONFIG_FAANIDCT } else if (avctx->idct_algo == FF_IDCT_FAAN) { c->idct_put = ff_faanidct_put; c->idct_add = ff_faanidct_add; c->idct = ff_faanidct; c->perm_type = FF_IDCT_PERM_NONE; #endif } else { c->idct_put = ff_simple_idct_put_int16_8bit; c->idct_add = ff_simple_idct_add_int16_8bit; c->idct = ff_simple_idct_int16_8bit; c->perm_type = FF_IDCT_PERM_NONE; } } } c->put_pixels_clamped = ff_put_pixels_clamped_c; c->put_signed_pixels_clamped = put_signed_pixels_clamped_c; c->add_pixels_clamped = ff_add_pixels_clamped_c; if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID) ff_xvid_idct_init(c, avctx); if (ARCH_AARCH64) ff_idctdsp_init_aarch64(c, avctx, high_bit_depth); if (ARCH_ALPHA) ff_idctdsp_init_alpha(c, avctx, high_bit_depth); if (ARCH_ARM) ff_idctdsp_init_arm(c, avctx, high_bit_depth); if (ARCH_PPC) ff_idctdsp_init_ppc(c, avctx, high_bit_depth); if (ARCH_X86) ff_idctdsp_init_x86(c, avctx, high_bit_depth); if (ARCH_MIPS) ff_idctdsp_init_mips(c, avctx, high_bit_depth); ff_init_scantable_permutation(c->idct_permutation, c->perm_type); }","- if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)
+ if (c->mpeg4_studio_profile)","av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx) { const unsigned high_bit_depth = avctx->bits_per_raw_sample > 8; if (avctx->lowres==1) { c->idct_put = ff_jref_idct4_put; c->idct_add = ff_jref_idct4_add; c->idct = ff_j_rev_dct4; c->perm_type = FF_IDCT_PERM_NONE; } else if (avctx->lowres==2) { c->idct_put = ff_jref_idct2_put; c->idct_add = ff_jref_idct2_add; c->idct = ff_j_rev_dct2; c->perm_type = FF_IDCT_PERM_NONE; } else if (avctx->lowres==3) { c->idct_put = ff_jref_idct1_put; c->idct_add = ff_jref_idct1_add; c->idct = ff_j_rev_dct1; c->perm_type = FF_IDCT_PERM_NONE; } else { if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) { if (c->mpeg4_studio_profile) c->idct_put = ff_simple_idct_put_int32_10bit; else { c->idct_put = ff_simple_idct_put_int16_10bit; c->idct_add = ff_simple_idct_add_int16_10bit; c->idct = ff_simple_idct_int16_10bit; } c->perm_type = FF_IDCT_PERM_NONE; } else if (avctx->bits_per_raw_sample == 12) { c->idct_put = ff_simple_idct_put_int16_12bit; c->idct_add = ff_simple_idct_add_int16_12bit; c->idct = ff_simple_idct_int16_12bit; c->perm_type = FF_IDCT_PERM_NONE; } else { if (avctx->idct_algo == FF_IDCT_INT) { c->idct_put = ff_jref_idct_put; c->idct_add = ff_jref_idct_add; c->idct = ff_j_rev_dct; c->perm_type = FF_IDCT_PERM_LIBMPEG2; #if CONFIG_FAANIDCT } else if (avctx->idct_algo == FF_IDCT_FAAN) { c->idct_put = ff_faanidct_put; c->idct_add = ff_faanidct_add; c->idct = ff_faanidct; c->perm_type = FF_IDCT_PERM_NONE; #endif } else { c->idct_put = ff_simple_idct_put_int16_8bit; c->idct_add = ff_simple_idct_add_int16_8bit; c->idct = ff_simple_idct_int16_8bit; c->perm_type = FF_IDCT_PERM_NONE; } } } c->put_pixels_clamped = ff_put_pixels_clamped_c; c->put_signed_pixels_clamped = put_signed_pixels_clamped_c; c->add_pixels_clamped = ff_add_pixels_clamped_c; if (CONFIG_MPEG4_DECODER && avctx->idct_algo == FF_IDCT_XVID) ff_xvid_idct_init(c, avctx); if (ARCH_AARCH64) ff_idctdsp_init_aarch64(c, avctx, high_bit_depth); if (ARCH_ALPHA) ff_idctdsp_init_alpha(c, avctx, high_bit_depth); if (ARCH_ARM) ff_idctdsp_init_arm(c, avctx, high_bit_depth); if (ARCH_PPC) ff_idctdsp_init_ppc(c, avctx, high_bit_depth); if (ARCH_X86) ff_idctdsp_init_x86(c, avctx, high_bit_depth); if (ARCH_MIPS) ff_idctdsp_init_mips(c, avctx, high_bit_depth); ff_init_scantable_permutation(c->idct_permutation, c->perm_type); }"
4,5031----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nl80211.c----nl80211_trigger_scan,"static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) { struct cfg80211_registered_device *rdev = info->user_ptr[0]; struct net_device *dev = info->user_ptr[1]; struct cfg80211_scan_request *request; struct nlattr *attr; struct wiphy *wiphy; int err, tmp, n_ssids = 0, n_channels, i; enum ieee80211_band band; size_t ie_len; if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE])) return -EINVAL; wiphy = &rdev->wiphy; if (!rdev->ops->scan) return -EOPNOTSUPP; if (rdev->scan_req) return -EBUSY; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { n_channels = validate_scan_freqs( info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]); if (!n_channels) return -EINVAL; } else { n_channels = 0; for (band = 0; band < IEEE80211_NUM_BANDS; band++) if (wiphy->bands[band]) n_channels += wiphy->bands[band]->n_channels; } if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) n_ssids++; if (n_ssids > wiphy->max_scan_ssids) return -EINVAL; if (info->attrs[NL80211_ATTR_IE]) ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); else ie_len = 0; if (ie_len > wiphy->max_scan_ie_len) return -EINVAL; request = kzalloc(sizeof(*request) + sizeof(*request->ssids) * n_ssids + sizeof(*request->channels) * n_channels + ie_len, GFP_KERNEL); if (!request) return -ENOMEM; if (n_ssids) request->ssids = (void *)&request->channels[n_channels]; request->n_ssids = n_ssids; if (ie_len) { if (request->ssids) request->ie = (void *)(request->ssids + n_ssids); else request->ie = (void *)(request->channels + n_channels); } i = 0; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) { struct ieee80211_channel *chan; chan = ieee80211_get_channel(wiphy, nla_get_u32(attr)); if (!chan) { err = -EINVAL; goto out_free; } if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } else { for (band = 0; band < IEEE80211_NUM_BANDS; band++) { int j; if (!wiphy->bands[band]) continue; for (j = 0; j < wiphy->bands[band]->n_channels; j++) { struct ieee80211_channel *chan; chan = &wiphy->bands[band]->channels[j]; if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } } if (!i) { err = -EINVAL; goto out_free; } request->n_channels = i; i = 0; if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) { if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) { err = -EINVAL; goto out_free; } memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr)); <S2SV_StartVul> request->ssids[i].ssid_len = nla_len(attr); <S2SV_EndVul> i++; } } if (info->attrs[NL80211_ATTR_IE]) { request->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); memcpy((void *)request->ie, nla_data(info->attrs[NL80211_ATTR_IE]), request->ie_len); } request->dev = dev; request->wiphy = &rdev->wiphy; rdev->scan_req = request; err = rdev->ops->scan(&rdev->wiphy, dev, request); if (!err) { nl80211_send_scan_start(rdev, dev); dev_hold(dev); } else { out_free: rdev->scan_req = NULL; kfree(request); } return err;","- request->ssids[i].ssid_len = nla_len(attr);
+ request->ssids[i].ssid_len = nla_len(attr);","static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) { struct cfg80211_registered_device *rdev = info->user_ptr[0]; struct net_device *dev = info->user_ptr[1]; struct cfg80211_scan_request *request; struct nlattr *attr; struct wiphy *wiphy; int err, tmp, n_ssids = 0, n_channels, i; enum ieee80211_band band; size_t ie_len; if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE])) return -EINVAL; wiphy = &rdev->wiphy; if (!rdev->ops->scan) return -EOPNOTSUPP; if (rdev->scan_req) return -EBUSY; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { n_channels = validate_scan_freqs( info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]); if (!n_channels) return -EINVAL; } else { n_channels = 0; for (band = 0; band < IEEE80211_NUM_BANDS; band++) if (wiphy->bands[band]) n_channels += wiphy->bands[band]->n_channels; } if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) n_ssids++; if (n_ssids > wiphy->max_scan_ssids) return -EINVAL; if (info->attrs[NL80211_ATTR_IE]) ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); else ie_len = 0; if (ie_len > wiphy->max_scan_ie_len) return -EINVAL; request = kzalloc(sizeof(*request) + sizeof(*request->ssids) * n_ssids + sizeof(*request->channels) * n_channels + ie_len, GFP_KERNEL); if (!request) return -ENOMEM; if (n_ssids) request->ssids = (void *)&request->channels[n_channels]; request->n_ssids = n_ssids; if (ie_len) { if (request->ssids) request->ie = (void *)(request->ssids + n_ssids); else request->ie = (void *)(request->channels + n_channels); } i = 0; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) { struct ieee80211_channel *chan; chan = ieee80211_get_channel(wiphy, nla_get_u32(attr)); if (!chan) { err = -EINVAL; goto out_free; } if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } else { for (band = 0; band < IEEE80211_NUM_BANDS; band++) { int j; if (!wiphy->bands[band]) continue; for (j = 0; j < wiphy->bands[band]->n_channels; j++) { struct ieee80211_channel *chan; chan = &wiphy->bands[band]->channels[j]; if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } } if (!i) { err = -EINVAL; goto out_free; } request->n_channels = i; i = 0; if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) { request->ssids[i].ssid_len = nla_len(attr); if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) { err = -EINVAL; goto out_free; } memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr)); i++; } } if (info->attrs[NL80211_ATTR_IE]) { request->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); memcpy((void *)request->ie, nla_data(info->attrs[NL80211_ATTR_IE]), request->ie_len); } request->dev = dev; request->wiphy = &rdev->wiphy; rdev->scan_req = request; err = rdev->ops->scan(&rdev->wiphy, dev, request); if (!err) { nl80211_send_scan_start(rdev, dev); dev_hold(dev); } else { out_free: rdev->scan_req = NULL; kfree(request); } return err;"
5,4641----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/posix-timers.c----posix_timer_fn,"static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer) { struct k_itimer *timr; unsigned long flags; int si_private = 0; enum hrtimer_restart ret = HRTIMER_NORESTART; timr = container_of(timer, struct k_itimer, it.real.timer); spin_lock_irqsave(&timr->it_lock, flags); timr->it_active = 0; if (timr->it_interval != 0) si_private = ++timr->it_requeue_pending; if (posix_timer_event(timr, si_private)) { if (timr->it_interval != 0) { ktime_t now = hrtimer_cb_get_time(timer); #ifdef CONFIG_HIGH_RES_TIMERS { ktime_t kj = NSEC_PER_SEC / HZ; if (timr->it_interval < kj) now = ktime_add(now, kj); } #endif <S2SV_StartVul> timr->it_overrun += (unsigned int) <S2SV_EndVul> <S2SV_StartVul> hrtimer_forward(timer, now, <S2SV_EndVul> <S2SV_StartVul> timr->it_interval); <S2SV_EndVul> ret = HRTIMER_RESTART; ++timr->it_requeue_pending; timr->it_active = 1; } } unlock_timer(timr, flags); return ret; }","- timr->it_overrun += (unsigned int)
- hrtimer_forward(timer, now,
- timr->it_interval);
+ timr->it_overrun += hrtimer_forward(timer, now,
+ timr->it_interval);","static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer) { struct k_itimer *timr; unsigned long flags; int si_private = 0; enum hrtimer_restart ret = HRTIMER_NORESTART; timr = container_of(timer, struct k_itimer, it.real.timer); spin_lock_irqsave(&timr->it_lock, flags); timr->it_active = 0; if (timr->it_interval != 0) si_private = ++timr->it_requeue_pending; if (posix_timer_event(timr, si_private)) { if (timr->it_interval != 0) { ktime_t now = hrtimer_cb_get_time(timer); #ifdef CONFIG_HIGH_RES_TIMERS { ktime_t kj = NSEC_PER_SEC / HZ; if (timr->it_interval < kj) now = ktime_add(now, kj); } #endif timr->it_overrun += hrtimer_forward(timer, now, timr->it_interval); ret = HRTIMER_RESTART; ++timr->it_requeue_pending; timr->it_active = 1; } } unlock_timer(timr, flags); return ret; }"
6,4942----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4xdr.c----encode_share_access,"<S2SV_StartVul> static void encode_share_access(struct xdr_stream *xdr, int open_flags) <S2SV_EndVul> { __be32 *p; RESERVE_SPACE(8); <S2SV_StartVul> switch (open_flags & (FMODE_READ|FMODE_WRITE)) { <S2SV_EndVul> case FMODE_READ: WRITE32(NFS4_SHARE_ACCESS_READ); break; case FMODE_WRITE: WRITE32(NFS4_SHARE_ACCESS_WRITE); break; case FMODE_READ|FMODE_WRITE: WRITE32(NFS4_SHARE_ACCESS_BOTH); break; default: <S2SV_StartVul> BUG(); <S2SV_EndVul> } WRITE32(0); }","- static void encode_share_access(struct xdr_stream *xdr, int open_flags)
- switch (open_flags & (FMODE_READ|FMODE_WRITE)) {
- BUG();
+ static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)
+ switch (fmode & (FMODE_READ|FMODE_WRITE)) {
+ WRITE32(0);","static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode) { __be32 *p; RESERVE_SPACE(8); switch (fmode & (FMODE_READ|FMODE_WRITE)) { case FMODE_READ: WRITE32(NFS4_SHARE_ACCESS_READ); break; case FMODE_WRITE: WRITE32(NFS4_SHARE_ACCESS_WRITE); break; case FMODE_READ|FMODE_WRITE: WRITE32(NFS4_SHARE_ACCESS_BOTH); break; default: WRITE32(0); } WRITE32(0); }"
7,6382----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gd_webp.c----gdImageWebpPtrEx,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality) { void *rv; gdIOCtx *out = gdNewDynamicCtx(2048, NULL); if (out == NULL) { return NULL; } <S2SV_StartVul> gdImageWebpCtx(im, out, quality); <S2SV_EndVul> <S2SV_StartVul> rv = gdDPExtractData(out, size); <S2SV_EndVul> out->gd_free(out); return rv; }","- gdImageWebpCtx(im, out, quality);
- rv = gdDPExtractData(out, size);
+ if (_gdImageWebpCtx(im, out, quality)) {
+ rv = NULL;
+ } else {
+ rv = gdDPExtractData(out, size);
+ }","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality) { void *rv; gdIOCtx *out = gdNewDynamicCtx(2048, NULL); if (out == NULL) { return NULL; } if (_gdImageWebpCtx(im, out, quality)) { rv = NULL; } else { rv = gdDPExtractData(out, size); } out->gd_free(out); return rv; }"
8,4052----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/snmp-mib.c----snmp_mib_find_next,"<S2SV_StartVul> snmp_mib_find_next(uint32_t *oid) <S2SV_EndVul> { snmp_mib_resource_t *resource; resource = NULL; for(resource = list_head(snmp_mib); resource; resource = resource->next) { <S2SV_StartVul> if(snmp_oid_cmp_oid(resource->oid, oid) > 0) { <S2SV_EndVul> return resource; } } return NULL; }","- snmp_mib_find_next(uint32_t *oid)
- if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {
+ snmp_mib_find_next(snmp_oid_t *oid)
+ if(snmp_mib_cmp_oid(&resource->oid, oid) > 0) {","snmp_mib_find_next(snmp_oid_t *oid) { snmp_mib_resource_t *resource; resource = NULL; for(resource = list_head(snmp_mib); resource; resource = resource->next) { if(snmp_mib_cmp_oid(&resource->oid, oid) > 0) { return resource; } } return NULL; }"
9,6900----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mysqlshow.c----main,"int main(int argc, char **argv) { int error; my_bool first_argument_uses_wildcards=0; char *wild; MYSQL mysql; MY_INIT(argv[0]); my_getopt_use_args_separator= TRUE; if (load_defaults(""my"",load_default_groups,&argc,&argv)) exit(1); my_getopt_use_args_separator= FALSE; get_options(&argc,&argv); wild=0; if (argc) { char *pos= argv[argc-1], *to; for (to= pos ; *pos ; pos++, to++) { switch (*pos) { case '*': *pos= '%'; first_argument_uses_wildcards= 1; break; case '?': *pos= '_'; first_argument_uses_wildcards= 1; break; case '%': case '_': first_argument_uses_wildcards= 1; break; case '\\': pos++; default: break; } *to= *pos; } *to= *pos; } if (first_argument_uses_wildcards) wild= argv[--argc]; else if (argc == 3) wild= argv[--argc]; if (argc > 2) { fprintf(stderr,""%s: Too many arguments\n"",my_progname); exit(1); } mysql_init(&mysql); if (opt_compress) mysql_options(&mysql,MYSQL_OPT_COMPRESS,NullS); <S2SV_StartVul> #ifdef HAVE_OPENSSL <S2SV_EndVul> <S2SV_StartVul> if (opt_use_ssl) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> mysql_ssl_set(&mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca, <S2SV_EndVul> <S2SV_StartVul> opt_ssl_capath, opt_ssl_cipher); <S2SV_EndVul> <S2SV_StartVul> mysql_options(&mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl); <S2SV_EndVul> <S2SV_StartVul> mysql_options(&mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> mysql_options(&mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT, <S2SV_EndVul> <S2SV_StartVul> (char*)&opt_ssl_verify_server_cert); <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> if (opt_protocol) mysql_options(&mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol); if (opt_bind_addr) mysql_options(&mysql,MYSQL_OPT_BIND,opt_bind_addr); #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) if (shared_memory_base_name) mysql_options(&mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name); #endif mysql_options(&mysql, MYSQL_SET_CHARSET_NAME, default_charset); if (opt_plugin_dir && *opt_plugin_dir) mysql_options(&mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir); if (opt_default_auth && *opt_default_auth) mysql_options(&mysql, MYSQL_DEFAULT_AUTH, opt_default_auth); mysql_options(&mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0); mysql_options4(&mysql, MYSQL_OPT_CONNECT_ATTR_ADD, ""program_name"", ""mysqlshow""); if (!(mysql_real_connect(&mysql,host,user,opt_password, (first_argument_uses_wildcards) ? """" : argv[0],opt_mysql_port,opt_mysql_unix_port, 0))) { fprintf(stderr,""%s: %s\n"",my_progname,mysql_error(&mysql)); exit(1); } mysql.reconnect= 1; switch (argc) { case 0: error=list_dbs(&mysql,wild); break; case 1: if (opt_status) error=list_table_status(&mysql,argv[0],wild); else error=list_tables(&mysql,argv[0],wild); break; default: if (opt_status && ! wild) error=list_table_status(&mysql,argv[0],argv[1]); else error=list_fields(&mysql,argv[0],argv[1],wild); break; } mysql_close(&mysql); my_free(opt_password); #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) my_free(shared_memory_base_name); #endif my_end(my_end_arg); exit(error ? 1 : 0); return 0; }","- #ifdef HAVE_OPENSSL
- if (opt_use_ssl)
- {
- mysql_ssl_set(&mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
- opt_ssl_capath, opt_ssl_cipher);
- mysql_options(&mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);
- mysql_options(&mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);
- }
- mysql_options(&mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,
- (char*)&opt_ssl_verify_server_cert);
- #endif
+ SSL_SET_OPTIONS(&mysql);","int main(int argc, char **argv) { int error; my_bool first_argument_uses_wildcards=0; char *wild; MYSQL mysql; MY_INIT(argv[0]); my_getopt_use_args_separator= TRUE; if (load_defaults(""my"",load_default_groups,&argc,&argv)) exit(1); my_getopt_use_args_separator= FALSE; get_options(&argc,&argv); wild=0; if (argc) { char *pos= argv[argc-1], *to; for (to= pos ; *pos ; pos++, to++) { switch (*pos) { case '*': *pos= '%'; first_argument_uses_wildcards= 1; break; case '?': *pos= '_'; first_argument_uses_wildcards= 1; break; case '%': case '_': first_argument_uses_wildcards= 1; break; case '\\': pos++; default: break; } *to= *pos; } *to= *pos; } if (first_argument_uses_wildcards) wild= argv[--argc]; else if (argc == 3) wild= argv[--argc]; if (argc > 2) { fprintf(stderr,""%s: Too many arguments\n"",my_progname); exit(1); } mysql_init(&mysql); if (opt_compress) mysql_options(&mysql,MYSQL_OPT_COMPRESS,NullS); SSL_SET_OPTIONS(&mysql); if (opt_protocol) mysql_options(&mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol); if (opt_bind_addr) mysql_options(&mysql,MYSQL_OPT_BIND,opt_bind_addr); #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) if (shared_memory_base_name) mysql_options(&mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name); #endif mysql_options(&mysql, MYSQL_SET_CHARSET_NAME, default_charset); if (opt_plugin_dir && *opt_plugin_dir) mysql_options(&mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir); if (opt_default_auth && *opt_default_auth) mysql_options(&mysql, MYSQL_DEFAULT_AUTH, opt_default_auth); mysql_options(&mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0); mysql_options4(&mysql, MYSQL_OPT_CONNECT_ATTR_ADD, ""program_name"", ""mysqlshow""); if (!(mysql_real_connect(&mysql,host,user,opt_password, (first_argument_uses_wildcards) ? """" : argv[0],opt_mysql_port,opt_mysql_unix_port, 0))) { fprintf(stderr,""%s: %s\n"",my_progname,mysql_error(&mysql)); exit(1); } mysql.reconnect= 1; switch (argc) { case 0: error=list_dbs(&mysql,wild); break; case 1: if (opt_status) error=list_table_status(&mysql,argv[0],wild); else error=list_tables(&mysql,argv[0],wild); break; default: if (opt_status && ! wild) error=list_table_status(&mysql,argv[0],argv[1]); else error=list_fields(&mysql,argv[0],argv[1],wild); break; } mysql_close(&mysql); my_free(opt_password); #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) my_free(shared_memory_base_name); #endif my_end(my_end_arg); exit(error ? 1 : 0); return 0; }"
10,4073----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mysql_secure_installation.cc----init_connection_options,"init_connection_options(MYSQL *mysql) { <S2SV_StartVul> #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY) <S2SV_EndVul> <S2SV_StartVul> if (opt_use_ssl) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca, <S2SV_EndVul> <S2SV_StartVul> opt_ssl_capath, opt_ssl_cipher); <S2SV_EndVul> <S2SV_StartVul> mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl); <S2SV_EndVul> <S2SV_StartVul> mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, <S2SV_EndVul> <S2SV_StartVul> (char*) &opt_ssl_verify_server_cert); <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> if (opt_protocol) mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol); #ifdef HAVE_SMEM if (shared_memory_base_name) mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name); #endif }","- #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
- if (opt_use_ssl)
- {
- mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
- opt_ssl_capath, opt_ssl_cipher);
- mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);
- mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);
- }
- mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,
- (char*) &opt_ssl_verify_server_cert);
- #endif
+ SSL_SET_OPTIONS(mysql);","init_connection_options(MYSQL *mysql) { SSL_SET_OPTIONS(mysql); if (opt_protocol) mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol); #ifdef HAVE_SMEM if (shared_memory_base_name) mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name); #endif }"
11,3188----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/buffer.c----set_curbuf,"set_curbuf(buf_T *buf, int action) { buf_T *prevbuf; int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL || action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE); #ifdef FEAT_SYN_HL long old_tw = curbuf->b_p_tw; #endif bufref_T newbufref; bufref_T prevbufref; setpcmark(); if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0) curwin->w_alt_fnum = curbuf->b_fnum; buflist_altfpos(curwin); VIsual_reselect = FALSE; prevbuf = curbuf; set_bufref(&prevbufref, prevbuf); set_bufref(&newbufref, buf); if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf) || (bufref_valid(&prevbufref) && bufref_valid(&newbufref) #ifdef FEAT_EVAL && !aborting() #endif )) { #ifdef FEAT_SYN_HL if (prevbuf == curwin->w_buffer) reset_synblock(curwin); #endif if (unload) close_windows(prevbuf, FALSE); #if defined(FEAT_EVAL) if (bufref_valid(&prevbufref) && !aborting()) #else if (bufref_valid(&prevbufref)) #endif { win_T *previouswin = curwin; if (prevbuf == curbuf && ((State & INSERT) == 0 || curbuf->b_nwindows <= 1)) u_sync(FALSE); close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf, unload ? action : (action == DOBUF_GOTO && !buf_hide(prevbuf) && !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0, FALSE, FALSE); if (curwin != previouswin && win_valid(previouswin)) curwin = previouswin; } } <S2SV_StartVul> if ((buf_valid(buf) && buf != curbuf <S2SV_EndVul> #ifdef FEAT_EVAL && !aborting() #endif ) || curwin->w_buffer == NULL) { <S2SV_StartVul> enter_buffer(buf); <S2SV_EndVul> #ifdef FEAT_SYN_HL if (old_tw != curbuf->b_p_tw) check_colorcolumn(curwin); #endif } }","- if ((buf_valid(buf) && buf != curbuf
- enter_buffer(buf);
+ int valid;
+ valid = buf_valid(buf);
+ if ((valid && buf != curbuf
+ if (!valid)
+ enter_buffer(lastbuf);
+ else
+ enter_buffer(buf);","set_curbuf(buf_T *buf, int action) { buf_T *prevbuf; int unload = (action == DOBUF_UNLOAD || action == DOBUF_DEL || action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE); #ifdef FEAT_SYN_HL long old_tw = curbuf->b_p_tw; #endif bufref_T newbufref; bufref_T prevbufref; int valid; setpcmark(); if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0) curwin->w_alt_fnum = curbuf->b_fnum; buflist_altfpos(curwin); VIsual_reselect = FALSE; prevbuf = curbuf; set_bufref(&prevbufref, prevbuf); set_bufref(&newbufref, buf); if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf) || (bufref_valid(&prevbufref) && bufref_valid(&newbufref) #ifdef FEAT_EVAL && !aborting() #endif )) { #ifdef FEAT_SYN_HL if (prevbuf == curwin->w_buffer) reset_synblock(curwin); #endif if (unload) close_windows(prevbuf, FALSE); #if defined(FEAT_EVAL) if (bufref_valid(&prevbufref) && !aborting()) #else if (bufref_valid(&prevbufref)) #endif { win_T *previouswin = curwin; if (prevbuf == curbuf && ((State & INSERT) == 0 || curbuf->b_nwindows <= 1)) u_sync(FALSE); close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf, unload ? action : (action == DOBUF_GOTO && !buf_hide(prevbuf) && !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0, FALSE, FALSE); if (curwin != previouswin && win_valid(previouswin)) curwin = previouswin; } } valid = buf_valid(buf); if ((valid && buf != curbuf #ifdef FEAT_EVAL && !aborting() #endif ) || curwin->w_buffer == NULL) { if (!valid) enter_buffer(lastbuf); else enter_buffer(buf); #ifdef FEAT_SYN_HL if (old_tw != curbuf->b_p_tw) check_colorcolumn(curwin); #endif } }"
12,1776--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9391--jpc_bs.c----jpc_bitstream_putbits,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v) { int m; <S2SV_StartVul> assert(n >= 0 && n < 32); <S2SV_EndVul> assert(!(v & (~JAS_ONES(n)))); m = n - 1; while (--n >= 0) { if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) { return EOF; } v <<= 1; } return 0; }","- assert(n >= 0 && n < 32);
+ if (n < 0 || n >= 32) {
+ return EOF;
+ }","int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v) { int m; if (n < 0 || n >= 32) { return EOF; } assert(!(v & (~JAS_ONES(n)))); m = n - 1; while (--n >= 0) { if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) { return EOF; } v <<= 1; } return 0; }"
13,3394----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/huffman.c----send,"<S2SV_StartVul> static void send(node_t *node, node_t *child, byte *fout) { <S2SV_EndVul> if (node->parent) { <S2SV_StartVul> send(node->parent, node, fout); <S2SV_EndVul> } if (child) { if (node->right == child) { add_bit(1, fout); } else { add_bit(0, fout); } } }","- static void send(node_t *node, node_t *child, byte *fout) {
- send(node->parent, node, fout);
+ static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {
+ send(node->parent, node, fout, maxoffset);
+ if (bloc >= maxoffset) {
+ bloc = maxoffset + 1;
+ return;
+ }","static void send(node_t *node, node_t *child, byte *fout, int maxoffset) { if (node->parent) { send(node->parent, node, fout, maxoffset); } if (child) { if (bloc >= maxoffset) { bloc = maxoffset + 1; return; } if (node->right == child) { add_bit(1, fout); } else { add_bit(0, fout); } } }"
14,3155----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/snmp-ber.c----snmp_ber_encode_string_len,"<S2SV_StartVul> snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length) <S2SV_EndVul> { uint32_t i; str += length - 1; for(i = 0; i < length; ++i) { <S2SV_StartVul> (*out_len)++; <S2SV_EndVul> <S2SV_StartVul> *out-- = (uint8_t)*str--; <S2SV_EndVul> } <S2SV_StartVul> out = snmp_ber_encode_length(out, out_len, length); <S2SV_EndVul> <S2SV_StartVul> out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING); <S2SV_EndVul> <S2SV_StartVul> return out; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)
- (*out_len)++;
- out = snmp_ber_encode_length(out, out_len, length);
- out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);
- return out;
- }
+ snmp_ber_encode_string_len(snmp_packet_t *snmp_packet, const char *str, uint32_t length)
+ if(snmp_packet->used == snmp_packet->max) {
+ return 0;
+ }
+ snmp_packet->used++;
+ if(!snmp_ber_encode_length(snmp_packet, length)) {
+ return 0;
+ }
+ if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OCTET_STRING)) {
+ return 0;
+ }
+ return 1;","snmp_ber_encode_string_len(snmp_packet_t *snmp_packet, const char *str, uint32_t length) { uint32_t i; str += length - 1; for(i = 0; i < length; ++i) { if(snmp_packet->used == snmp_packet->max) { return 0; } *snmp_packet->out-- = (uint8_t)*str--; snmp_packet->used++; } if(!snmp_ber_encode_length(snmp_packet, length)) { return 0; } if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OCTET_STRING)) { return 0; } return 1; }"
15,5769----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/py_seq_tensor.cc----tensorflow::PySeqToTensor,"Status PySeqToTensor(PyObject* obj, DataType dtype, Tensor* ret) { ConverterState state; TF_RETURN_IF_ERROR(InferShapeAndType(obj, &state)); DataType requested_dtype = DT_INVALID; if (dtype != DT_INVALID) { requested_dtype = dtype; } switch (requested_dtype) { case DT_FLOAT: if (FloatConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_DOUBLE: if (DoubleConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_HALF: <S2SV_StartVul> RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret)); <S2SV_EndVul> case DT_INT64: if (Int64Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_INT32: if (Int32Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_UINT64: if (UInt64Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_COMPLEX128: if (Complex128Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_STRING: if (StringConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_BOOL: if (BoolConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; default: break; } switch (state.inferred_dtype) { case DT_FLOAT: if (requested_dtype == DT_INVALID) { RETURN_STRING_AS_STATUS(FloatConverter::Convert(obj, &state, ret)); } else { RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret)); } case DT_DOUBLE: RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret)); case DT_HALF: RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret)); case DT_INT64: if (requested_dtype == DT_INVALID) { const char* error = Int32Converter::Convert(obj, &state, ret); if (error == ErrorFoundInt64) { error = Int64Converter::Convert(obj, &state, ret); } if (error == ErrorFoundFloat) { error = FloatConverter::Convert(obj, &state, ret); } RETURN_STRING_AS_STATUS(error); } else { const char* error = Int64Converter::Convert(obj, &state, ret); if (error == ErrorFoundFloat) { error = DoubleConverter::Convert(obj, &state, ret); } RETURN_STRING_AS_STATUS(error); } case DT_STRING: RETURN_STRING_AS_STATUS(StringConverter::Convert(obj, &state, ret)); case DT_COMPLEX128: RETURN_STRING_AS_STATUS(Complex128Converter::Convert(obj, &state, ret)); case DT_BOOL: RETURN_STRING_AS_STATUS(BoolConverter::Convert(obj, &state, ret)); case DT_INVALID: *ret = Tensor(requested_dtype == DT_INVALID ? DT_FLOAT : requested_dtype, state.inferred_shape); return Status::OK(); default: return errors::Unimplemented(""Missing Python -> Tensor conversion for "", DataTypeString(state.inferred_dtype)); } return Status::OK(); }","- RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret));
+ if (NumpyHalfConverter::Convert(obj, &state, ret) == nullptr)
+ return Status::OK();
+ break;","Status PySeqToTensor(PyObject* obj, DataType dtype, Tensor* ret) { ConverterState state; TF_RETURN_IF_ERROR(InferShapeAndType(obj, &state)); DataType requested_dtype = DT_INVALID; if (dtype != DT_INVALID) { requested_dtype = dtype; } switch (requested_dtype) { case DT_FLOAT: if (FloatConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_DOUBLE: if (DoubleConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_HALF: if (NumpyHalfConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_INT64: if (Int64Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_INT32: if (Int32Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_UINT64: if (UInt64Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_COMPLEX128: if (Complex128Converter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_STRING: if (StringConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; case DT_BOOL: if (BoolConverter::Convert(obj, &state, ret) == nullptr) return Status::OK(); break; default: break; } switch (state.inferred_dtype) { case DT_FLOAT: if (requested_dtype == DT_INVALID) { RETURN_STRING_AS_STATUS(FloatConverter::Convert(obj, &state, ret)); } else { RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret)); } case DT_DOUBLE: RETURN_STRING_AS_STATUS(DoubleConverter::Convert(obj, &state, ret)); case DT_HALF: RETURN_STRING_AS_STATUS(NumpyHalfConverter::Convert(obj, &state, ret)); case DT_INT64: if (requested_dtype == DT_INVALID) { const char* error = Int32Converter::Convert(obj, &state, ret); if (error == ErrorFoundInt64) { error = Int64Converter::Convert(obj, &state, ret); } if (error == ErrorFoundFloat) { error = FloatConverter::Convert(obj, &state, ret); } RETURN_STRING_AS_STATUS(error); } else { const char* error = Int64Converter::Convert(obj, &state, ret); if (error == ErrorFoundFloat) { error = DoubleConverter::Convert(obj, &state, ret); } RETURN_STRING_AS_STATUS(error); } case DT_STRING: RETURN_STRING_AS_STATUS(StringConverter::Convert(obj, &state, ret)); case DT_COMPLEX128: RETURN_STRING_AS_STATUS(Complex128Converter::Convert(obj, &state, ret)); case DT_BOOL: RETURN_STRING_AS_STATUS(BoolConverter::Convert(obj, &state, ret)); case DT_INVALID: *ret = Tensor(requested_dtype == DT_INVALID ? DT_FLOAT : requested_dtype, state.inferred_shape); return Status::OK(); default: return errors::Unimplemented(""Missing Python -> Tensor conversion for "", DataTypeString(state.inferred_dtype)); } return Status::OK(); }"
16,5955----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/big_key.c----big_key_describe,"void big_key_describe(const struct key *key, struct seq_file *m) { size_t datalen = (size_t)key->payload.data[big_key_len]; seq_puts(m, key->description); <S2SV_StartVul> if (key_is_instantiated(key)) <S2SV_EndVul> seq_printf(m, "": %zu [%s]"", datalen, datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff""); }","- if (key_is_instantiated(key))
+ if (key_is_positive(key))","void big_key_describe(const struct key *key, struct seq_file *m) { size_t datalen = (size_t)key->payload.data[big_key_len]; seq_puts(m, key->description); if (key_is_positive(key)) seq_printf(m, "": %zu [%s]"", datalen, datalen > BIG_KEY_FILE_THRESHOLD ? ""file"" : ""buff""); }"
17,899----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-8176--d1_lib.c----dtls1_clear_queues,static void dtls1_clear_queues(SSL *s) { pitem *item = NULL; hm_fragment *frag = NULL; DTLS1_RECORD_DATA *rdata; while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL) { rdata = (DTLS1_RECORD_DATA *) item->data; if (rdata->rbuf.buf) { OPENSSL_free(rdata->rbuf.buf); } OPENSSL_free(item->data); pitem_free(item); } while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL) { rdata = (DTLS1_RECORD_DATA *) item->data; if (rdata->rbuf.buf) { OPENSSL_free(rdata->rbuf.buf); } OPENSSL_free(item->data); pitem_free(item); } while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL) { frag = (hm_fragment *)item->data; OPENSSL_free(frag->fragment); OPENSSL_free(frag); pitem_free(item); } while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL) { frag = (hm_fragment *)item->data; OPENSSL_free(frag->fragment); OPENSSL_free(frag); pitem_free(item); } while ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) { <S2SV_StartVul> frag = (hm_fragment *)item->data; <S2SV_EndVul> <S2SV_StartVul> OPENSSL_free(frag->fragment); <S2SV_EndVul> <S2SV_StartVul> OPENSSL_free(frag); <S2SV_EndVul> pitem_free(item); } },"- frag = (hm_fragment *)item->data;
- OPENSSL_free(frag->fragment);
- OPENSSL_free(frag);
+ rdata = (DTLS1_RECORD_DATA *) item->data;
+ if (rdata->rbuf.buf)
+ {
+ OPENSSL_free(rdata->rbuf.buf);
+ }
+ OPENSSL_free(item->data);",static void dtls1_clear_queues(SSL *s) { pitem *item = NULL; hm_fragment *frag = NULL; DTLS1_RECORD_DATA *rdata; while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL) { rdata = (DTLS1_RECORD_DATA *) item->data; if (rdata->rbuf.buf) { OPENSSL_free(rdata->rbuf.buf); } OPENSSL_free(item->data); pitem_free(item); } while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL) { rdata = (DTLS1_RECORD_DATA *) item->data; if (rdata->rbuf.buf) { OPENSSL_free(rdata->rbuf.buf); } OPENSSL_free(item->data); pitem_free(item); } while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL) { frag = (hm_fragment *)item->data; OPENSSL_free(frag->fragment); OPENSSL_free(frag); pitem_free(item); } while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL) { frag = (hm_fragment *)item->data; OPENSSL_free(frag->fragment); OPENSSL_free(frag); pitem_free(item); } while ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL) { rdata = (DTLS1_RECORD_DATA *) item->data; if (rdata->rbuf.buf) { OPENSSL_free(rdata->rbuf.buf); } OPENSSL_free(item->data); pitem_free(item); } }
18,6404----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/health.c----mlx5_fw_fatal_reporter_dump,"mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter, struct devlink_fmsg *fmsg, void *priv_ctx) { struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter); u32 crdump_size = dev->priv.health.crdump_size; u32 *cr_data; u32 data_size; u32 offset; int err; if (!mlx5_core_is_pf(dev)) return -EPERM; cr_data = kvmalloc(crdump_size, GFP_KERNEL); if (!cr_data) return -ENOMEM; err = mlx5_crdump_collect(dev, cr_data); if (err) <S2SV_StartVul> return err; <S2SV_EndVul> if (priv_ctx) { struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx; err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx); if (err) goto free_data; } err = devlink_fmsg_arr_pair_nest_start(fmsg, ""crdump_data""); if (err) goto free_data; for (offset = 0; offset < crdump_size; offset += data_size) { if (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE) data_size = crdump_size - offset; else data_size = MLX5_CR_DUMP_CHUNK_SIZE; err = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset, data_size); if (err) goto free_data; } err = devlink_fmsg_arr_pair_nest_end(fmsg); free_data: kvfree(cr_data); return err; }","- return err;
+ goto free_data;","mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter, struct devlink_fmsg *fmsg, void *priv_ctx) { struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter); u32 crdump_size = dev->priv.health.crdump_size; u32 *cr_data; u32 data_size; u32 offset; int err; if (!mlx5_core_is_pf(dev)) return -EPERM; cr_data = kvmalloc(crdump_size, GFP_KERNEL); if (!cr_data) return -ENOMEM; err = mlx5_crdump_collect(dev, cr_data); if (err) goto free_data; if (priv_ctx) { struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx; err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx); if (err) goto free_data; } err = devlink_fmsg_arr_pair_nest_start(fmsg, ""crdump_data""); if (err) goto free_data; for (offset = 0; offset < crdump_size; offset += data_size) { if (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE) data_size = crdump_size - offset; else data_size = MLX5_CR_DUMP_CHUNK_SIZE; err = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset, data_size); if (err) goto free_data; } err = devlink_fmsg_arr_pair_nest_end(fmsg); free_data: kvfree(cr_data); return err; }"
19,7017----CWE-74----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/itemstackmetadata.cpp----ItemStackMetadata::setString,"bool ItemStackMetadata::setString(const std::string &name, const std::string &var) { <S2SV_StartVul> bool result = Metadata::setString(name, var); <S2SV_EndVul> <S2SV_StartVul> if (name == TOOLCAP_KEY) <S2SV_EndVul> updateToolCapabilities(); return result; }","- bool result = Metadata::setString(name, var);
- if (name == TOOLCAP_KEY)
+ std::string clean_name = name;
+ std::string clean_var = var;
+ sanitize_string(clean_name);
+ sanitize_string(clean_var);
+ bool result = Metadata::setString(clean_name, clean_var);
+ if (clean_name == TOOLCAP_KEY)","bool ItemStackMetadata::setString(const std::string &name, const std::string &var) { std::string clean_name = name; std::string clean_var = var; sanitize_string(clean_name); sanitize_string(clean_var); bool result = Metadata::setString(clean_name, clean_var); if (clean_name == TOOLCAP_KEY) updateToolCapabilities(); return result; }"
20,4007----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/networking.c----addReply,"void addReply(redisClient *c, robj *obj) { if (_installWriteEvent(c) != REDIS_OK) return; <S2SV_StartVul> redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY); <S2SV_EndVul> if (obj->encoding == REDIS_ENCODING_RAW) { if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK) _addReplyObjectToList(c,obj); } else { obj = getDecodedObject(obj); if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK) _addReplyObjectToList(c,obj); decrRefCount(obj); } }","- redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);
+ redisAssert(!server.ds_enabled || obj->storage == REDIS_VM_MEMORY);","void addReply(redisClient *c, robj *obj) { if (_installWriteEvent(c) != REDIS_OK) return; redisAssert(!server.ds_enabled || obj->storage == REDIS_VM_MEMORY); if (obj->encoding == REDIS_ENCODING_RAW) { if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK) _addReplyObjectToList(c,obj); } else { obj = getDecodedObject(obj); if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK) _addReplyObjectToList(c,obj); decrRefCount(obj); } }"
21,6258----CWE-284----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/kadm_rpc_svc.c----check_rpcsec_auth,"check_rpcsec_auth(struct svc_req *rqstp) { gss_ctx_id_t ctx; krb5_context kctx; OM_uint32 maj_stat, min_stat; gss_name_t name; krb5_principal princ; int ret, success; krb5_data *c1, *c2, *realm; gss_buffer_desc gss_str; kadm5_server_handle_t handle; size_t slen; char *sdots; success = 0; handle = (kadm5_server_handle_t)global_server_handle; if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS) return 0; ctx = rqstp->rq_svccred; maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name, NULL, NULL, NULL, NULL, NULL); if (maj_stat != GSS_S_COMPLETE) { krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed "" ""inquire_context, stat=%u""), maj_stat); log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL); goto fail_name; } kctx = handle->context; ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str); if (ret == 0) goto fail_name; slen = gss_str.length; trunc_name(&slen, &sdots); if (krb5_princ_size(kctx, princ) != 2) goto fail_princ; c1 = krb5_princ_component(kctx, princ, 0); c2 = krb5_princ_component(kctx, princ, 1); realm = krb5_princ_realm(kctx, princ); <S2SV_StartVul> if (strncmp(handle->params.realm, realm->data, realm->length) == 0 <S2SV_EndVul> <S2SV_StartVul> && strncmp(""kadmin"", c1->data, c1->length) == 0) { <S2SV_EndVul> <S2SV_StartVul> if (strncmp(""history"", c2->data, c2->length) == 0) <S2SV_EndVul> <S2SV_StartVul> goto fail_princ; <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> success = 1; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> fail_princ: if (!success) { krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""), (int) slen, (char *) gss_str.value, sdots); } gss_release_buffer(&min_stat, &gss_str); krb5_free_principal(kctx, princ); fail_name: gss_release_name(&min_stat, &name); return success; }","- if (strncmp(handle->params.realm, realm->data, realm->length) == 0
- && strncmp(""kadmin"", c1->data, c1->length) == 0) {
- if (strncmp(""history"", c2->data, c2->length) == 0)
- goto fail_princ;
- else
- success = 1;
- }
+ success = data_eq_string(*realm, handle->params.realm) &&
+ data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history"");","check_rpcsec_auth(struct svc_req *rqstp) { gss_ctx_id_t ctx; krb5_context kctx; OM_uint32 maj_stat, min_stat; gss_name_t name; krb5_principal princ; int ret, success; krb5_data *c1, *c2, *realm; gss_buffer_desc gss_str; kadm5_server_handle_t handle; size_t slen; char *sdots; success = 0; handle = (kadm5_server_handle_t)global_server_handle; if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS) return 0; ctx = rqstp->rq_svccred; maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name, NULL, NULL, NULL, NULL, NULL); if (maj_stat != GSS_S_COMPLETE) { krb5_klog_syslog(LOG_ERR, _(""check_rpcsec_auth: failed "" ""inquire_context, stat=%u""), maj_stat); log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL); goto fail_name; } kctx = handle->context; ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str); if (ret == 0) goto fail_name; slen = gss_str.length; trunc_name(&slen, &sdots); if (krb5_princ_size(kctx, princ) != 2) goto fail_princ; c1 = krb5_princ_component(kctx, princ, 0); c2 = krb5_princ_component(kctx, princ, 1); realm = krb5_princ_realm(kctx, princ); success = data_eq_string(*realm, handle->params.realm) && data_eq_string(*c1, ""kadmin"") && !data_eq_string(*c2, ""history""); fail_princ: if (!success) { krb5_klog_syslog(LOG_ERR, _(""bad service principal %.*s%s""), (int) slen, (char *) gss_str.value, sdots); } gss_release_buffer(&min_stat, &gss_str); krb5_free_principal(kctx, princ); fail_name: gss_release_name(&min_stat, &name); return success; }"
22,5903----CWE-681----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/orders.c----update_recv_secondary_order,"static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags) { BOOL rc = FALSE; size_t start, end, diff; BYTE orderType; UINT16 extraFlags; UINT16 orderLength; rdpContext* context = update->context; rdpSettings* settings = context->settings; rdpSecondaryUpdate* secondary = update->secondary; const char* name; if (Stream_GetRemainingLength(s) < 5) { WLog_Print(update->log, WLOG_ERROR, ""Stream_GetRemainingLength(s) < 5""); return FALSE; } Stream_Read_UINT16(s, orderLength); Stream_Read_UINT16(s, extraFlags); Stream_Read_UINT8(s, orderType); if (Stream_GetRemainingLength(s) < orderLength + 7U) { WLog_Print(update->log, WLOG_ERROR, ""Stream_GetRemainingLength(s) %"" PRIuz "" < %"" PRIu16, Stream_GetRemainingLength(s), orderLength + 7); return FALSE; } start = Stream_GetPosition(s); name = secondary_order_string(orderType); WLog_Print(update->log, WLOG_DEBUG, ""Secondary Drawing Order %s"", name); if (!check_secondary_order_supported(update->log, settings, orderType, name)) return FALSE; switch (orderType) { case ORDER_TYPE_BITMAP_UNCOMPRESSED: case ORDER_TYPE_CACHE_BITMAP_COMPRESSED: { const BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED); CACHE_BITMAP_ORDER* order = update_read_cache_bitmap_order(update, s, compressed, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order); free_cache_bitmap_order(context, order); } } break; case ORDER_TYPE_BITMAP_UNCOMPRESSED_V2: case ORDER_TYPE_BITMAP_COMPRESSED_V2: { const BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2); CACHE_BITMAP_V2_ORDER* order = update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order); free_cache_bitmap_v2_order(context, order); } } break; case ORDER_TYPE_BITMAP_COMPRESSED_V3: { CACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order); free_cache_bitmap_v3_order(context, order); } } break; case ORDER_TYPE_CACHE_COLOR_TABLE: { CACHE_COLOR_TABLE_ORDER* order = update_read_cache_color_table_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order); free_cache_color_table_order(context, order); } } break; case ORDER_TYPE_CACHE_GLYPH: { switch (settings->GlyphSupportLevel) { case GLYPH_SUPPORT_PARTIAL: case GLYPH_SUPPORT_FULL: { CACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order); free_cache_glyph_order(context, order); } } break; case GLYPH_SUPPORT_ENCODE: { CACHE_GLYPH_V2_ORDER* order = update_read_cache_glyph_v2_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order); free_cache_glyph_v2_order(context, order); } } break; case GLYPH_SUPPORT_NONE: default: break; } } break; case ORDER_TYPE_CACHE_BRUSH: { CACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order); free_cache_brush_order(context, order); } } break; default: WLog_Print(update->log, WLOG_WARN, ""SECONDARY ORDER %s not supported"", name); break; } if (!rc) { WLog_Print(update->log, WLOG_ERROR, ""SECONDARY ORDER %s failed"", name); } start += orderLength + 7; end = Stream_GetPosition(s); if (start > end) { WLog_Print(update->log, WLOG_WARN, ""SECONDARY_ORDER %s: read %"" PRIuz ""bytes too much"", name, end - start); return FALSE; } <S2SV_StartVul> diff = start - end; <S2SV_EndVul> if (diff > 0) { WLog_Print(update->log, WLOG_DEBUG, ""SECONDARY_ORDER %s: read %"" PRIuz ""bytes short, skipping"", name, diff); <S2SV_StartVul> Stream_Seek(s, diff); <S2SV_EndVul> } return rc; }","- diff = start - end;
- Stream_Seek(s, diff);
+ diff = end - start;
+ if (!Stream_SafeSeek(s, diff))
+ return FALSE;","static BOOL update_recv_secondary_order(rdpUpdate* update, wStream* s, BYTE flags) { BOOL rc = FALSE; size_t start, end, diff; BYTE orderType; UINT16 extraFlags; UINT16 orderLength; rdpContext* context = update->context; rdpSettings* settings = context->settings; rdpSecondaryUpdate* secondary = update->secondary; const char* name; if (Stream_GetRemainingLength(s) < 5) { WLog_Print(update->log, WLOG_ERROR, ""Stream_GetRemainingLength(s) < 5""); return FALSE; } Stream_Read_UINT16(s, orderLength); Stream_Read_UINT16(s, extraFlags); Stream_Read_UINT8(s, orderType); if (Stream_GetRemainingLength(s) < orderLength + 7U) { WLog_Print(update->log, WLOG_ERROR, ""Stream_GetRemainingLength(s) %"" PRIuz "" < %"" PRIu16, Stream_GetRemainingLength(s), orderLength + 7); return FALSE; } start = Stream_GetPosition(s); name = secondary_order_string(orderType); WLog_Print(update->log, WLOG_DEBUG, ""Secondary Drawing Order %s"", name); if (!check_secondary_order_supported(update->log, settings, orderType, name)) return FALSE; switch (orderType) { case ORDER_TYPE_BITMAP_UNCOMPRESSED: case ORDER_TYPE_CACHE_BITMAP_COMPRESSED: { const BOOL compressed = (orderType == ORDER_TYPE_CACHE_BITMAP_COMPRESSED); CACHE_BITMAP_ORDER* order = update_read_cache_bitmap_order(update, s, compressed, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBitmap, context, order); free_cache_bitmap_order(context, order); } } break; case ORDER_TYPE_BITMAP_UNCOMPRESSED_V2: case ORDER_TYPE_BITMAP_COMPRESSED_V2: { const BOOL compressed = (orderType == ORDER_TYPE_BITMAP_COMPRESSED_V2); CACHE_BITMAP_V2_ORDER* order = update_read_cache_bitmap_v2_order(update, s, compressed, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBitmapV2, context, order); free_cache_bitmap_v2_order(context, order); } } break; case ORDER_TYPE_BITMAP_COMPRESSED_V3: { CACHE_BITMAP_V3_ORDER* order = update_read_cache_bitmap_v3_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBitmapV3, context, order); free_cache_bitmap_v3_order(context, order); } } break; case ORDER_TYPE_CACHE_COLOR_TABLE: { CACHE_COLOR_TABLE_ORDER* order = update_read_cache_color_table_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheColorTable, context, order); free_cache_color_table_order(context, order); } } break; case ORDER_TYPE_CACHE_GLYPH: { switch (settings->GlyphSupportLevel) { case GLYPH_SUPPORT_PARTIAL: case GLYPH_SUPPORT_FULL: { CACHE_GLYPH_ORDER* order = update_read_cache_glyph_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheGlyph, context, order); free_cache_glyph_order(context, order); } } break; case GLYPH_SUPPORT_ENCODE: { CACHE_GLYPH_V2_ORDER* order = update_read_cache_glyph_v2_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheGlyphV2, context, order); free_cache_glyph_v2_order(context, order); } } break; case GLYPH_SUPPORT_NONE: default: break; } } break; case ORDER_TYPE_CACHE_BRUSH: { CACHE_BRUSH_ORDER* order = update_read_cache_brush_order(update, s, extraFlags); if (order) { rc = IFCALLRESULT(FALSE, secondary->CacheBrush, context, order); free_cache_brush_order(context, order); } } break; default: WLog_Print(update->log, WLOG_WARN, ""SECONDARY ORDER %s not supported"", name); break; } if (!rc) { WLog_Print(update->log, WLOG_ERROR, ""SECONDARY ORDER %s failed"", name); } start += orderLength + 7; end = Stream_GetPosition(s); if (start > end) { WLog_Print(update->log, WLOG_WARN, ""SECONDARY_ORDER %s: read %"" PRIuz ""bytes too much"", name, end - start); return FALSE; } diff = end - start; if (diff > 0) { WLog_Print(update->log, WLOG_DEBUG, ""SECONDARY_ORDER %s: read %"" PRIuz ""bytes short, skipping"", name, diff); if (!Stream_SafeSeek(s, diff)) return FALSE; } return rc; }"
23,5998----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mysqlshow.c----list_dbs,"list_dbs(MYSQL *mysql,const char *wild) { const char *header; uint length, counter = 0; ulong rowcount = 0L; char tables[NAME_LEN+1], rows[NAME_LEN+1]; <S2SV_StartVul> char query[255]; <S2SV_EndVul> MYSQL_FIELD *field; MYSQL_RES *result; MYSQL_ROW row= NULL, rrow; if (!(result=mysql_list_dbs(mysql,wild))) { fprintf(stderr,""%s: Cannot list databases: %s\n"",my_progname, mysql_error(mysql)); return 1; } if (wild && mysql_num_rows(result) == 1) { row= mysql_fetch_row(result); if (!my_strcasecmp(&my_charset_latin1, row[0], wild)) { mysql_free_result(result); if (opt_status) return list_table_status(mysql, wild, NULL); else return list_tables(mysql, wild, NULL); } } if (wild) printf(""Wildcard: %s\n"",wild); header=""Databases""; length=(uint) strlen(header); field=mysql_fetch_field(result); if (length < field->max_length) length=field->max_length; if (!opt_verbose) print_header(header,length,NullS); else if (opt_verbose == 1) print_header(header,length,""Tables"",6,NullS); else print_header(header,length,""Tables"",6,""Total Rows"",12,NullS); while (row || (row= mysql_fetch_row(result))) { counter++; if (opt_verbose) { if (!(mysql_select_db(mysql,row[0]))) { MYSQL_RES *tresult = mysql_list_tables(mysql,(char*)NULL); if (mysql_affected_rows(mysql) > 0) { sprintf(tables,""%6lu"",(ulong) mysql_affected_rows(mysql)); rowcount = 0; if (opt_verbose > 1) { MYSQL_ROW trow; while ((trow = mysql_fetch_row(tresult))) { <S2SV_StartVul> sprintf(query,""SELECT COUNT(*) FROM `%s`"",trow[0]); <S2SV_EndVul> if (!(mysql_query(mysql,query))) { MYSQL_RES *rresult; if ((rresult = mysql_store_result(mysql))) { rrow = mysql_fetch_row(rresult); rowcount += (ulong) strtoull(rrow[0], (char**) 0, 10); mysql_free_result(rresult); } } } sprintf(rows,""%12lu"",rowcount); } } else { sprintf(tables,""%6d"",0); sprintf(rows,""%12d"",0); } mysql_free_result(tresult); } else { strmov(tables,""N/A""); strmov(rows,""N/A""); } } if (!opt_verbose) print_row(row[0],length,0); else if (opt_verbose == 1) print_row(row[0],length,tables,6,NullS); else print_row(row[0],length,tables,6,rows,12,NullS); row= NULL; } print_trailer(length, (opt_verbose > 0 ? 6 : 0), (opt_verbose > 1 ? 12 :0), 0); if (counter && opt_verbose) printf(""%u row%s in set.\n"",counter,(counter > 1) ? ""s"" : """"); mysql_free_result(result); return 0; }","- char query[255];
- sprintf(query,""SELECT COUNT(*) FROM `%s`"",trow[0]);
+ char query[NAME_LEN + 100];
+ my_snprintf(query, sizeof(query),
+ ""SELECT COUNT(*) FROM `%s`"", trow[0]);","list_dbs(MYSQL *mysql,const char *wild) { const char *header; uint length, counter = 0; ulong rowcount = 0L; char tables[NAME_LEN+1], rows[NAME_LEN+1]; char query[NAME_LEN + 100]; MYSQL_FIELD *field; MYSQL_RES *result; MYSQL_ROW row= NULL, rrow; if (!(result=mysql_list_dbs(mysql,wild))) { fprintf(stderr,""%s: Cannot list databases: %s\n"",my_progname, mysql_error(mysql)); return 1; } if (wild && mysql_num_rows(result) == 1) { row= mysql_fetch_row(result); if (!my_strcasecmp(&my_charset_latin1, row[0], wild)) { mysql_free_result(result); if (opt_status) return list_table_status(mysql, wild, NULL); else return list_tables(mysql, wild, NULL); } } if (wild) printf(""Wildcard: %s\n"",wild); header=""Databases""; length=(uint) strlen(header); field=mysql_fetch_field(result); if (length < field->max_length) length=field->max_length; if (!opt_verbose) print_header(header,length,NullS); else if (opt_verbose == 1) print_header(header,length,""Tables"",6,NullS); else print_header(header,length,""Tables"",6,""Total Rows"",12,NullS); while (row || (row= mysql_fetch_row(result))) { counter++; if (opt_verbose) { if (!(mysql_select_db(mysql,row[0]))) { MYSQL_RES *tresult = mysql_list_tables(mysql,(char*)NULL); if (mysql_affected_rows(mysql) > 0) { sprintf(tables,""%6lu"",(ulong) mysql_affected_rows(mysql)); rowcount = 0; if (opt_verbose > 1) { MYSQL_ROW trow; while ((trow = mysql_fetch_row(tresult))) { my_snprintf(query, sizeof(query), ""SELECT COUNT(*) FROM `%s`"", trow[0]); if (!(mysql_query(mysql,query))) { MYSQL_RES *rresult; if ((rresult = mysql_store_result(mysql))) { rrow = mysql_fetch_row(rresult); rowcount += (ulong) strtoull(rrow[0], (char**) 0, 10); mysql_free_result(rresult); } } } sprintf(rows,""%12lu"",rowcount); } } else { sprintf(tables,""%6d"",0); sprintf(rows,""%12d"",0); } mysql_free_result(tresult); } else { strmov(tables,""N/A""); strmov(rows,""N/A""); } } if (!opt_verbose) print_row(row[0],length,0); else if (opt_verbose == 1) print_row(row[0],length,tables,6,NullS); else print_row(row[0],length,tables,6,rows,12,NullS); row= NULL; } print_trailer(length, (opt_verbose > 0 ? 6 : 0), (opt_verbose > 1 ? 12 :0), 0); if (counter && opt_verbose) printf(""%u row%s in set.\n"",counter,(counter > 1) ? ""s"" : """"); mysql_free_result(result); return 0; }"
24,5050----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/njs_iterator.c----njs_object_iterate_reverse,"njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args, njs_iterator_handler_t handler) { double idx; int64_t i, from, to, length; njs_int_t ret; njs_array_t *array, *keys; njs_value_t *entry, *value, prop, character, string_obj; const u_char *p, *end, *pos; njs_string_prop_t string_prop; njs_object_value_t *object; value = args->value; from = args->from; to = args->to; if (njs_is_array(value)) { array = njs_array(value); from += 1; while (from-- > to) { if (njs_slow_path(!array->object.fast_array)) { goto process_object; } if (njs_fast_path(from < array->length && njs_is_valid(&array->start[from]))) { ret = handler(vm, args, &array->start[from], from); } else { entry = njs_value_arg(&njs_value_invalid); ret = njs_value_property_i64(vm, value, from, &prop); if (njs_slow_path(ret != NJS_DECLINED)) { if (ret == NJS_ERROR) { return NJS_ERROR; } entry = &prop; } ret = handler(vm, args, entry, from); } if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_DONE) { return NJS_DONE; } return NJS_ERROR; } } return NJS_OK; } if (njs_is_string(value) || njs_is_object_string(value)) { if (njs_is_string(value)) { object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value); if (njs_slow_path(object == NULL)) { return NJS_ERROR; } njs_set_object_value(&string_obj, object); args->value = &string_obj; } else { value = njs_object_value(value); } length = njs_string_prop(&string_prop, value); end = string_prop.start + string_prop.size; if ((size_t) length == string_prop.size) { p = string_prop.start + from; i = from + 1; while (i-- > to) { (void) njs_string_new(vm, &character, p, 1, 1); ret = handler(vm, args, &character, i); if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_DONE) { return NJS_DONE; } return NJS_ERROR; } p--; } } else { <S2SV_StartVul> p = njs_string_offset(string_prop.start, end, from); <S2SV_EndVul> <S2SV_StartVul> p = njs_utf8_next(p, end); <S2SV_EndVul> i = from + 1; while (i-- > to) { pos = njs_utf8_prev(p); (void) njs_string_new(vm, &character, pos, p - pos , 1); ret = handler(vm, args, &character, i); if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_DONE) { return NJS_DONE; } return NJS_ERROR; } p = pos; } } return NJS_OK; } if (!njs_is_object(value)) { return NJS_OK; } process_object: if (!njs_fast_object(from - to)) { keys = njs_array_indices(vm, value); if (njs_slow_path(keys == NULL)) { return NJS_ERROR; } i = keys->length; while (i > 0) { idx = njs_string_to_index(&keys->start[--i]); if (idx < to || idx > from) { continue; } ret = njs_iterator_object_handler(vm, handler, args, &keys->start[i], idx); if (njs_slow_path(ret != NJS_OK)) { njs_array_destroy(vm, keys); return ret; } } njs_array_destroy(vm, keys); return NJS_OK; } i = from + 1; while (i-- > to) { ret = njs_iterator_object_handler(vm, handler, args, NULL, i); if (njs_slow_path(ret != NJS_OK)) { return ret; } } return NJS_OK; }","- p = njs_string_offset(string_prop.start, end, from);
- p = njs_utf8_next(p, end);
+ p = NULL;
+ if (i > to) {
+ p = njs_string_offset(string_prop.start, end, from);
+ p = njs_utf8_next(p, end);
+ }","njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args, njs_iterator_handler_t handler) { double idx; int64_t i, from, to, length; njs_int_t ret; njs_array_t *array, *keys; njs_value_t *entry, *value, prop, character, string_obj; const u_char *p, *end, *pos; njs_string_prop_t string_prop; njs_object_value_t *object; value = args->value; from = args->from; to = args->to; if (njs_is_array(value)) { array = njs_array(value); from += 1; while (from-- > to) { if (njs_slow_path(!array->object.fast_array)) { goto process_object; } if (njs_fast_path(from < array->length && njs_is_valid(&array->start[from]))) { ret = handler(vm, args, &array->start[from], from); } else { entry = njs_value_arg(&njs_value_invalid); ret = njs_value_property_i64(vm, value, from, &prop); if (njs_slow_path(ret != NJS_DECLINED)) { if (ret == NJS_ERROR) { return NJS_ERROR; } entry = &prop; } ret = handler(vm, args, entry, from); } if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_DONE) { return NJS_DONE; } return NJS_ERROR; } } return NJS_OK; } if (njs_is_string(value) || njs_is_object_string(value)) { if (njs_is_string(value)) { object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value); if (njs_slow_path(object == NULL)) { return NJS_ERROR; } njs_set_object_value(&string_obj, object); args->value = &string_obj; } else { value = njs_object_value(value); } length = njs_string_prop(&string_prop, value); end = string_prop.start + string_prop.size; if ((size_t) length == string_prop.size) { p = string_prop.start + from; i = from + 1; while (i-- > to) { (void) njs_string_new(vm, &character, p, 1, 1); ret = handler(vm, args, &character, i); if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_DONE) { return NJS_DONE; } return NJS_ERROR; } p--; } } else { p = NULL; i = from + 1; if (i > to) { p = njs_string_offset(string_prop.start, end, from); p = njs_utf8_next(p, end); } while (i-- > to) { pos = njs_utf8_prev(p); (void) njs_string_new(vm, &character, pos, p - pos , 1); ret = handler(vm, args, &character, i); if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_DONE) { return NJS_DONE; } return NJS_ERROR; } p = pos; } } return NJS_OK; } if (!njs_is_object(value)) { return NJS_OK; } process_object: if (!njs_fast_object(from - to)) { keys = njs_array_indices(vm, value); if (njs_slow_path(keys == NULL)) { return NJS_ERROR; } i = keys->length; while (i > 0) { idx = njs_string_to_index(&keys->start[--i]); if (idx < to || idx > from) { continue; } ret = njs_iterator_object_handler(vm, handler, args, &keys->start[i], idx); if (njs_slow_path(ret != NJS_OK)) { njs_array_destroy(vm, keys); return ret; } } njs_array_destroy(vm, keys); return NJS_OK; } i = from + 1; while (i-- > to) { ret = njs_iterator_object_handler(vm, handler, args, NULL, i); if (njs_slow_path(ret != NJS_OK)) { return ret; } } return NJS_OK; }"
25,6077----CWE-203----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ecc.c----wc_ecc_shared_secret_gen_sync,"static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point, byte* out, word32* outlen, ecc_curve_spec* curve) { int err; #ifndef WOLFSSL_SP_MATH ecc_point* result = NULL; word32 x = 0; #endif mp_int* k = &private_key->k; #ifdef HAVE_ECC_CDH mp_int k_lcl; if (private_key->flags & WC_ECC_FLAG_COFACTOR) { mp_digit cofactor = (mp_digit)private_key->dp->cofactor; if (cofactor != 1) { k = &k_lcl; if (mp_init(k) != MP_OKAY) return MEMORY_E; err = mp_mul_d(&private_key->k, cofactor, k); if (err != MP_OKAY) { mp_clear(k); return err; } } } #endif #ifdef WOLFSSL_HAVE_SP_ECC #ifndef WOLFSSL_SP_NO_256 if (private_key->idx != ECC_CUSTOM_IDX && ecc_sets[private_key->idx].id == ECC_SECP256R1) { err = sp_ecc_secret_gen_256(k, point, out, outlen, private_key->heap); } else #endif #ifdef WOLFSSL_SP_384 if (private_key->idx != ECC_CUSTOM_IDX && ecc_sets[private_key->idx].id == ECC_SECP384R1) { err = sp_ecc_secret_gen_384(k, point, out, outlen, private_key->heap); } else #endif #endif #ifdef WOLFSSL_SP_MATH { err = WC_KEY_SIZE_E; (void)curve; } #else { result = wc_ecc_new_point_h(private_key->heap); if (result == NULL) { #ifdef HAVE_ECC_CDH if (k == &k_lcl) mp_clear(k); #endif return MEMORY_E; } <S2SV_StartVul> err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 1, <S2SV_EndVul> private_key->heap); if (err == MP_OKAY) { x = mp_unsigned_bin_size(curve->prime); if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) { err = BUFFER_E; } } if (err == MP_OKAY) { XMEMSET(out, 0, x); err = mp_to_unsigned_bin(result->x,out + (x - mp_unsigned_bin_size(result->x))); } *outlen = x; wc_ecc_del_point_h(result, private_key->heap); } #endif #ifdef HAVE_ECC_CDH if (k == &k_lcl) mp_clear(k); #endif return err; }","- err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 1,
+ mp_digit mp = 0;
+ err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 0,
+ if (err == MP_OKAY) {
+ err = mp_montgomery_setup(curve->prime, &mp);
+ }
+ if (err == MP_OKAY) {
+ err = ecc_map_ex(result, curve->prime, mp, 1);
+ }","static int wc_ecc_shared_secret_gen_sync(ecc_key* private_key, ecc_point* point, byte* out, word32* outlen, ecc_curve_spec* curve) { int err; #ifndef WOLFSSL_SP_MATH ecc_point* result = NULL; word32 x = 0; #endif mp_int* k = &private_key->k; #ifdef HAVE_ECC_CDH mp_int k_lcl; if (private_key->flags & WC_ECC_FLAG_COFACTOR) { mp_digit cofactor = (mp_digit)private_key->dp->cofactor; if (cofactor != 1) { k = &k_lcl; if (mp_init(k) != MP_OKAY) return MEMORY_E; err = mp_mul_d(&private_key->k, cofactor, k); if (err != MP_OKAY) { mp_clear(k); return err; } } } #endif #ifdef WOLFSSL_HAVE_SP_ECC #ifndef WOLFSSL_SP_NO_256 if (private_key->idx != ECC_CUSTOM_IDX && ecc_sets[private_key->idx].id == ECC_SECP256R1) { err = sp_ecc_secret_gen_256(k, point, out, outlen, private_key->heap); } else #endif #ifdef WOLFSSL_SP_384 if (private_key->idx != ECC_CUSTOM_IDX && ecc_sets[private_key->idx].id == ECC_SECP384R1) { err = sp_ecc_secret_gen_384(k, point, out, outlen, private_key->heap); } else #endif #endif #ifdef WOLFSSL_SP_MATH { err = WC_KEY_SIZE_E; (void)curve; } #else { mp_digit mp = 0; result = wc_ecc_new_point_h(private_key->heap); if (result == NULL) { #ifdef HAVE_ECC_CDH if (k == &k_lcl) mp_clear(k); #endif return MEMORY_E; } err = wc_ecc_mulmod_ex(k, point, result, curve->Af, curve->prime, 0, private_key->heap); if (err == MP_OKAY) { err = mp_montgomery_setup(curve->prime, &mp); } if (err == MP_OKAY) { err = ecc_map_ex(result, curve->prime, mp, 1); } if (err == MP_OKAY) { x = mp_unsigned_bin_size(curve->prime); if (*outlen < x || (int)x < mp_unsigned_bin_size(result->x)) { err = BUFFER_E; } } if (err == MP_OKAY) { XMEMSET(out, 0, x); err = mp_to_unsigned_bin(result->x,out + (x - mp_unsigned_bin_size(result->x))); } *outlen = x; wc_ecc_del_point_h(result, private_key->heap); } #endif #ifdef HAVE_ECC_CDH if (k == &k_lcl) mp_clear(k); #endif return err; }"
26,6896----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nf_nat_masquerade_ipv4.c----masq_inet_event,"static int masq_inet_event(struct notifier_block *this, unsigned long event, void *ptr) { <S2SV_StartVul> struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev; <S2SV_EndVul> struct netdev_notifier_info info; <S2SV_StartVul> netdev_notifier_info_init(&info, dev); <S2SV_EndVul> return masq_device_event(this, event, &info); }","- struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
- netdev_notifier_info_init(&info, dev);
+ struct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;
+ if (idev->dead)
+ return NOTIFY_DONE;
+ netdev_notifier_info_init(&info, idev->dev);","static int masq_inet_event(struct notifier_block *this, unsigned long event, void *ptr) { struct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev; struct netdev_notifier_info info; if (idev->dead) return NOTIFY_DONE; netdev_notifier_info_init(&info, idev->dev); return masq_device_event(this, event, &info); }"
27,5112----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jas_image.c----jas_image_cmpt_create,"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx, int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep, int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem) { jas_image_cmpt_t *cmpt; size_t size; cmpt = 0; if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) { goto error; } if (!jas_safe_intfast32_add(tlx, width, 0) || !jas_safe_intfast32_add(tly, height, 0)) { goto error; } if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) { goto error; } cmpt->type_ = JAS_IMAGE_CT_UNKNOWN; cmpt->tlx_ = tlx; cmpt->tly_ = tly; cmpt->hstep_ = hstep; cmpt->vstep_ = vstep; cmpt->width_ = width; cmpt->height_ = height; cmpt->prec_ = depth; cmpt->sgnd_ = sgnd; cmpt->stream_ = 0; cmpt->cps_ = (depth + 7) / 8; if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) || !jas_safe_size_mul(size, cmpt->cps_, &size)) { goto error; } <S2SV_StartVul> cmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : <S2SV_EndVul> jas_stream_tmpfile(); if (!cmpt->stream_) { goto error; } if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 || jas_stream_putc(cmpt->stream_, 0) == EOF || jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) { goto error; } return cmpt; error: if (cmpt) { jas_image_cmpt_destroy(cmpt); } return 0; }","- cmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :
+ cmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :","static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx, int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep, int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem) { jas_image_cmpt_t *cmpt; size_t size; cmpt = 0; if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) { goto error; } if (!jas_safe_intfast32_add(tlx, width, 0) || !jas_safe_intfast32_add(tly, height, 0)) { goto error; } if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) { goto error; } cmpt->type_ = JAS_IMAGE_CT_UNKNOWN; cmpt->tlx_ = tlx; cmpt->tly_ = tly; cmpt->hstep_ = hstep; cmpt->vstep_ = vstep; cmpt->width_ = width; cmpt->height_ = height; cmpt->prec_ = depth; cmpt->sgnd_ = sgnd; cmpt->stream_ = 0; cmpt->cps_ = (depth + 7) / 8; if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) || !jas_safe_size_mul(size, cmpt->cps_, &size)) { goto error; } cmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) : jas_stream_tmpfile(); if (!cmpt->stream_) { goto error; } if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 || jas_stream_putc(cmpt->stream_, 0) == EOF || jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) { goto error; } return cmpt; error: if (cmpt) { jas_image_cmpt_destroy(cmpt); } return 0; }"
28,3742----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hv_kvp.c----kvp_respond_to_host,"kvp_respond_to_host(char *key, char *value, int error) { struct hv_kvp_msg *kvp_msg; struct hv_kvp_msg_enumerate *kvp_data; char *key_name; struct icmsg_hdr *icmsghdrp; int keylen, valuelen; u32 buf_len; struct vmbus_channel *channel; u64 req_id; if (!kvp_transaction.active) { pr_warn(""KVP: Transaction not active\n""); return; } buf_len = kvp_transaction.recv_len; channel = kvp_transaction.recv_channel; req_id = kvp_transaction.recv_req_id; kvp_transaction.active = false; if (channel->onchannel_callback == NULL) return; icmsghdrp = (struct icmsg_hdr *) &recv_buffer[sizeof(struct vmbuspipe_hdr)]; kvp_msg = (struct hv_kvp_msg *) &recv_buffer[sizeof(struct vmbuspipe_hdr) + sizeof(struct icmsg_hdr)]; kvp_data = &kvp_msg->kvp_data; key_name = key; if (error) { icmsghdrp->status = HV_E_FAIL; goto response_done; } <S2SV_StartVul> keylen = utf8s_to_utf16s(key_name, strlen(key_name), <S2SV_EndVul> <S2SV_StartVul> (wchar_t *)kvp_data->data.key); <S2SV_EndVul> kvp_data->data.key_size = 2*(keylen + 1); <S2SV_StartVul> valuelen = utf8s_to_utf16s(value, strlen(value), <S2SV_EndVul> <S2SV_StartVul> (wchar_t *)kvp_data->data.value); <S2SV_EndVul> kvp_data->data.value_size = 2*(valuelen + 1); kvp_data->data.value_type = REG_SZ; icmsghdrp->status = HV_S_OK; response_done: icmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE; vmbus_sendpacket(channel, recv_buffer, buf_len, req_id, VM_PKT_DATA_INBAND, 0); }","- keylen = utf8s_to_utf16s(key_name, strlen(key_name),
- (wchar_t *)kvp_data->data.key);
- valuelen = utf8s_to_utf16s(value, strlen(value),
- (wchar_t *)kvp_data->data.value);
+ keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
+ (wchar_t *) kvp_data->data.key,
+ HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
+ valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
+ (wchar_t *) kvp_data->data.value,
+ HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);","kvp_respond_to_host(char *key, char *value, int error) { struct hv_kvp_msg *kvp_msg; struct hv_kvp_msg_enumerate *kvp_data; char *key_name; struct icmsg_hdr *icmsghdrp; int keylen, valuelen; u32 buf_len; struct vmbus_channel *channel; u64 req_id; if (!kvp_transaction.active) { pr_warn(""KVP: Transaction not active\n""); return; } buf_len = kvp_transaction.recv_len; channel = kvp_transaction.recv_channel; req_id = kvp_transaction.recv_req_id; kvp_transaction.active = false; if (channel->onchannel_callback == NULL) return; icmsghdrp = (struct icmsg_hdr *) &recv_buffer[sizeof(struct vmbuspipe_hdr)]; kvp_msg = (struct hv_kvp_msg *) &recv_buffer[sizeof(struct vmbuspipe_hdr) + sizeof(struct icmsg_hdr)]; kvp_data = &kvp_msg->kvp_data; key_name = key; if (error) { icmsghdrp->status = HV_E_FAIL; goto response_done; } keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN, (wchar_t *) kvp_data->data.key, HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2); kvp_data->data.key_size = 2*(keylen + 1); valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN, (wchar_t *) kvp_data->data.value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2); kvp_data->data.value_size = 2*(valuelen + 1); kvp_data->data.value_type = REG_SZ; icmsghdrp->status = HV_S_OK; response_done: icmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE; vmbus_sendpacket(channel, recv_buffer, buf_len, req_id, VM_PKT_DATA_INBAND, 0); }"
29,5276----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xdelta3-test.h----test_compressed_stream_overflow,"test_compressed_stream_overflow (xd3_stream *stream, int ignore) { int ret; int i; uint8_t *buf; if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; } memset (buf, 0, TWO_MEGS_AND_DELTA); <S2SV_StartVul> for (i = 0; i < (2 << 20); i += 256) <S2SV_EndVul> { int j; int off = mt_random(& static_mtrand) % 10; <S2SV_StartVul> for (j = 0; j < 256; j++) <S2SV_EndVul> { buf[i + j] = j + off; } } if (SIZEOF_XOFF_T == 4) { ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1); if (ret == XD3_INVALID_INPUT && MSG_IS (""decoder file offset overflow"")) { ret = 0; } else { XPR(NT XD3_LIB_ERRMSG (stream, ret)); stream->msg = ""expected overflow condition""; ret = XD3_INTERNAL; goto fail; } } <S2SV_StartVul> if ((ret = test_streaming (stream, <S2SV_EndVul> <S2SV_StartVul> buf, <S2SV_EndVul> <S2SV_StartVul> buf + (1 << 20), <S2SV_EndVul> <S2SV_StartVul> buf + (2 << 20), <S2SV_EndVul> <S2SV_StartVul> 1 << 12))) <S2SV_EndVul> { goto fail; } fail: free (buf); return ret; }","- for (i = 0; i < (2 << 20); i += 256)
- for (j = 0; j < 256; j++)
- if ((ret = test_streaming (stream,
- buf,
- buf + (1 << 20),
- buf + (2 << 20),
- 1 << 12)))
+ for (i = 0; i < (2 << 20); i += 256)
+ for (j = 0; j < 256; j++)
+ if ((ret = test_streaming (stream,
+ buf,
+ buf + (1 << 20),
+ buf + (2 << 20),
+ 1 << 12)))","test_compressed_stream_overflow (xd3_stream *stream, int ignore) { int ret; int i; uint8_t *buf; if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; } memset (buf, 0, TWO_MEGS_AND_DELTA); for (i = 0; i < (2 << 20); i += 256) { int j; int off = mt_random(& static_mtrand) % 10; for (j = 0; j < 256; j++) { buf[i + j] = j + off; } } if (SIZEOF_XOFF_T == 4) { ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1); if (ret == XD3_INVALID_INPUT && MSG_IS (""decoder file offset overflow"")) { ret = 0; } else { XPR(NT XD3_LIB_ERRMSG (stream, ret)); stream->msg = ""expected overflow condition""; ret = XD3_INTERNAL; goto fail; } } if ((ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), 1 << 12))) { goto fail; } fail: free (buf); return ret; }"
30,7497----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/volumes.c----read_one_dev,"static int read_one_dev(struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_dev_item *dev_item) { struct btrfs_fs_devices *fs_devices = fs_info->fs_devices; struct btrfs_device *device; u64 devid; int ret; u8 fs_uuid[BTRFS_FSID_SIZE]; u8 dev_uuid[BTRFS_UUID_SIZE]; devid = btrfs_device_id(leaf, dev_item); read_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item), BTRFS_UUID_SIZE); read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item), BTRFS_FSID_SIZE); if (memcmp(fs_uuid, fs_devices->metadata_uuid, BTRFS_FSID_SIZE)) { fs_devices = open_seed_devices(fs_info, fs_uuid); if (IS_ERR(fs_devices)) return PTR_ERR(fs_devices); } device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid, <S2SV_StartVul> fs_uuid); <S2SV_EndVul> if (!device) { if (!btrfs_test_opt(fs_info, DEGRADED)) { btrfs_report_missing_device(fs_info, devid, dev_uuid, true); return -ENOENT; } device = add_missing_dev(fs_devices, devid, dev_uuid); if (IS_ERR(device)) { btrfs_err(fs_info, ""failed to add missing dev %llu: %ld"", devid, PTR_ERR(device)); return PTR_ERR(device); } btrfs_report_missing_device(fs_info, devid, dev_uuid, false); } else { if (!device->bdev) { if (!btrfs_test_opt(fs_info, DEGRADED)) { btrfs_report_missing_device(fs_info, devid, dev_uuid, true); return -ENOENT; } btrfs_report_missing_device(fs_info, devid, dev_uuid, false); } if (!device->bdev && !test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) { device->fs_devices->missing_devices++; set_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state); } if (device->fs_devices != fs_devices) { ASSERT(test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)); list_move(&device->dev_list, &fs_devices->devices); device->fs_devices->num_devices--; fs_devices->num_devices++; device->fs_devices->missing_devices--; fs_devices->missing_devices++; device->fs_devices = fs_devices; } } if (device->fs_devices != fs_info->fs_devices) { BUG_ON(test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)); if (device->generation != btrfs_device_generation(leaf, dev_item)) return -EINVAL; } fill_device_from_item(leaf, dev_item, device); set_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state); if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) && !test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) { device->fs_devices->total_rw_bytes += device->total_bytes; atomic64_add(device->total_bytes - device->bytes_used, &fs_info->free_chunk_space); } ret = 0; return ret; }","- fs_uuid);
+ fs_uuid, true);","static int read_one_dev(struct btrfs_fs_info *fs_info, struct extent_buffer *leaf, struct btrfs_dev_item *dev_item) { struct btrfs_fs_devices *fs_devices = fs_info->fs_devices; struct btrfs_device *device; u64 devid; int ret; u8 fs_uuid[BTRFS_FSID_SIZE]; u8 dev_uuid[BTRFS_UUID_SIZE]; devid = btrfs_device_id(leaf, dev_item); read_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item), BTRFS_UUID_SIZE); read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item), BTRFS_FSID_SIZE); if (memcmp(fs_uuid, fs_devices->metadata_uuid, BTRFS_FSID_SIZE)) { fs_devices = open_seed_devices(fs_info, fs_uuid); if (IS_ERR(fs_devices)) return PTR_ERR(fs_devices); } device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid, fs_uuid, true); if (!device) { if (!btrfs_test_opt(fs_info, DEGRADED)) { btrfs_report_missing_device(fs_info, devid, dev_uuid, true); return -ENOENT; } device = add_missing_dev(fs_devices, devid, dev_uuid); if (IS_ERR(device)) { btrfs_err(fs_info, ""failed to add missing dev %llu: %ld"", devid, PTR_ERR(device)); return PTR_ERR(device); } btrfs_report_missing_device(fs_info, devid, dev_uuid, false); } else { if (!device->bdev) { if (!btrfs_test_opt(fs_info, DEGRADED)) { btrfs_report_missing_device(fs_info, devid, dev_uuid, true); return -ENOENT; } btrfs_report_missing_device(fs_info, devid, dev_uuid, false); } if (!device->bdev && !test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) { device->fs_devices->missing_devices++; set_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state); } if (device->fs_devices != fs_devices) { ASSERT(test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)); list_move(&device->dev_list, &fs_devices->devices); device->fs_devices->num_devices--; fs_devices->num_devices++; device->fs_devices->missing_devices--; fs_devices->missing_devices++; device->fs_devices = fs_devices; } } if (device->fs_devices != fs_info->fs_devices) { BUG_ON(test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)); if (device->generation != btrfs_device_generation(leaf, dev_item)) return -EINVAL; } fill_device_from_item(leaf, dev_item, device); set_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &device->dev_state); if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) && !test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) { device->fs_devices->total_rw_bytes += device->total_bytes; atomic64_add(device->total_bytes - device->bytes_used, &fs_info->free_chunk_space); } ret = 0; return ret; }"
31,541----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-0310--cipso_ipv4.c----cipso_v4_validate,"int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option) { unsigned char *opt = *option; unsigned char *tag; unsigned char opt_iter; unsigned char err_offset = 0; u8 opt_len; u8 tag_len; struct cipso_v4_doi *doi_def = NULL; u32 tag_iter; opt_len = opt[1]; if (opt_len < 8) { err_offset = 1; goto validate_return; } rcu_read_lock(); doi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2])); if (doi_def == NULL) { err_offset = 2; goto validate_return_locked; } opt_iter = CIPSO_V4_HDR_LEN; tag = opt + opt_iter; while (opt_iter < opt_len) { for (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];) if (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID || ++tag_iter == CIPSO_V4_TAG_MAXCNT) { err_offset = opt_iter; goto validate_return_locked; } tag_len = tag[1]; if (tag_len > (opt_len - opt_iter)) { err_offset = opt_iter + 1; goto validate_return_locked; } switch (tag[0]) { case CIPSO_V4_TAG_RBITMAP: if (tag_len < CIPSO_V4_TAG_RBM_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } if (cipso_v4_rbm_strictvalid) { if (cipso_v4_map_lvl_valid(doi_def, tag[3]) < 0) { err_offset = opt_iter + 3; goto validate_return_locked; } if (tag_len > CIPSO_V4_TAG_RBM_BLEN && cipso_v4_map_cat_rbm_valid(doi_def, &tag[4], tag_len - 4) < 0) { err_offset = opt_iter + 4; goto validate_return_locked; } } break; case CIPSO_V4_TAG_ENUM: if (tag_len < CIPSO_V4_TAG_ENUM_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } if (cipso_v4_map_lvl_valid(doi_def, tag[3]) < 0) { err_offset = opt_iter + 3; goto validate_return_locked; } if (tag_len > CIPSO_V4_TAG_ENUM_BLEN && cipso_v4_map_cat_enum_valid(doi_def, &tag[4], tag_len - 4) < 0) { err_offset = opt_iter + 4; goto validate_return_locked; } break; case CIPSO_V4_TAG_RANGE: if (tag_len < CIPSO_V4_TAG_RNG_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } if (cipso_v4_map_lvl_valid(doi_def, tag[3]) < 0) { err_offset = opt_iter + 3; goto validate_return_locked; } if (tag_len > CIPSO_V4_TAG_RNG_BLEN && cipso_v4_map_cat_rng_valid(doi_def, &tag[4], tag_len - 4) < 0) { err_offset = opt_iter + 4; goto validate_return_locked; } break; case CIPSO_V4_TAG_LOCAL: <S2SV_EndVul> <S2SV_StartVul> if (!(skb->dev->flags & IFF_LOOPBACK)) { <S2SV_EndVul> err_offset = opt_iter; goto validate_return_locked; } if (tag_len != CIPSO_V4_TAG_LOC_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } break; default: err_offset = opt_iter; goto validate_return_locked; } tag += tag_len; opt_iter += tag_len; } validate_return_locked: rcu_read_unlock(); validate_return: *option = opt + err_offset; return err_offset; }","- if (!(skb->dev->flags & IFF_LOOPBACK)) {
+ if (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {","int cipso_v4_validate(const struct sk_buff *skb, unsigned char **option) { unsigned char *opt = *option; unsigned char *tag; unsigned char opt_iter; unsigned char err_offset = 0; u8 opt_len; u8 tag_len; struct cipso_v4_doi *doi_def = NULL; u32 tag_iter; opt_len = opt[1]; if (opt_len < 8) { err_offset = 1; goto validate_return; } rcu_read_lock(); doi_def = cipso_v4_doi_search(get_unaligned_be32(&opt[2])); if (doi_def == NULL) { err_offset = 2; goto validate_return_locked; } opt_iter = CIPSO_V4_HDR_LEN; tag = opt + opt_iter; while (opt_iter < opt_len) { for (tag_iter = 0; doi_def->tags[tag_iter] != tag[0];) if (doi_def->tags[tag_iter] == CIPSO_V4_TAG_INVALID || ++tag_iter == CIPSO_V4_TAG_MAXCNT) { err_offset = opt_iter; goto validate_return_locked; } tag_len = tag[1]; if (tag_len > (opt_len - opt_iter)) { err_offset = opt_iter + 1; goto validate_return_locked; } switch (tag[0]) { case CIPSO_V4_TAG_RBITMAP: if (tag_len < CIPSO_V4_TAG_RBM_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } if (cipso_v4_rbm_strictvalid) { if (cipso_v4_map_lvl_valid(doi_def, tag[3]) < 0) { err_offset = opt_iter + 3; goto validate_return_locked; } if (tag_len > CIPSO_V4_TAG_RBM_BLEN && cipso_v4_map_cat_rbm_valid(doi_def, &tag[4], tag_len - 4) < 0) { err_offset = opt_iter + 4; goto validate_return_locked; } } break; case CIPSO_V4_TAG_ENUM: if (tag_len < CIPSO_V4_TAG_ENUM_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } if (cipso_v4_map_lvl_valid(doi_def, tag[3]) < 0) { err_offset = opt_iter + 3; goto validate_return_locked; } if (tag_len > CIPSO_V4_TAG_ENUM_BLEN && cipso_v4_map_cat_enum_valid(doi_def, &tag[4], tag_len - 4) < 0) { err_offset = opt_iter + 4; goto validate_return_locked; } break; case CIPSO_V4_TAG_RANGE: if (tag_len < CIPSO_V4_TAG_RNG_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } if (cipso_v4_map_lvl_valid(doi_def, tag[3]) < 0) { err_offset = opt_iter + 3; goto validate_return_locked; } if (tag_len > CIPSO_V4_TAG_RNG_BLEN && cipso_v4_map_cat_rng_valid(doi_def, &tag[4], tag_len - 4) < 0) { err_offset = opt_iter + 4; goto validate_return_locked; } break; case CIPSO_V4_TAG_LOCAL: if (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) { err_offset = opt_iter; goto validate_return_locked; } if (tag_len != CIPSO_V4_TAG_LOC_BLEN) { err_offset = opt_iter + 1; goto validate_return_locked; } break; default: err_offset = opt_iter; goto validate_return_locked; } tag += tag_len; opt_iter += tag_len; } validate_return_locked: rcu_read_unlock(); validate_return: *option = opt + err_offset; return err_offset; }"
32,5114----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/certificate_validation_context_config_impl.cc----Envoy::Ssl::CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl,"CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl( const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config, Api::Api& api) : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)), ca_cert_path_(Config::DataSource::getPath(config.trusted_ca()) .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)), certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)), certificate_revocation_list_path_( Config::DataSource::getPath(config.crl()) .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)), <S2SV_StartVul> subject_alt_name_matchers_(config.match_subject_alt_names().begin(), <S2SV_EndVul> <S2SV_StartVul> config.match_subject_alt_names().end()), <S2SV_EndVul> verify_certificate_hash_list_(config.verify_certificate_hash().begin(), config.verify_certificate_hash().end()), verify_certificate_spki_list_(config.verify_certificate_spki().begin(), config.verify_certificate_spki().end()), allow_expired_certificate_(config.allow_expired_certificate()), trust_chain_verification_(config.trust_chain_verification()), custom_validator_config_( config.has_custom_validator_config() ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>( config.custom_validator_config()) : absl::nullopt), api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) { if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) { if (!certificate_revocation_list_.empty()) { throw EnvoyException(fmt::format(""Failed to load CRL from {} without trusted CA"", certificateRevocationListPath())); } if (!subject_alt_name_matchers_.empty()) { throw EnvoyException(""SAN-based verification of peer certificates without "" ""trusted CA is insecure and not allowed""); } if (allow_expired_certificate_) { throw EnvoyException(""Certificate validity period is always ignored without trusted CA""); } } }","- subject_alt_name_matchers_(config.match_subject_alt_names().begin(),
- config.match_subject_alt_names().end()),
+ subject_alt_name_matchers_(getSubjectAltNameMatchers(config)),","CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl( const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config, Api::Api& api) : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)), ca_cert_path_(Config::DataSource::getPath(config.trusted_ca()) .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)), certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)), certificate_revocation_list_path_( Config::DataSource::getPath(config.crl()) .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)), subject_alt_name_matchers_(getSubjectAltNameMatchers(config)), verify_certificate_hash_list_(config.verify_certificate_hash().begin(), config.verify_certificate_hash().end()), verify_certificate_spki_list_(config.verify_certificate_spki().begin(), config.verify_certificate_spki().end()), allow_expired_certificate_(config.allow_expired_certificate()), trust_chain_verification_(config.trust_chain_verification()), custom_validator_config_( config.has_custom_validator_config() ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>( config.custom_validator_config()) : absl::nullopt), api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) { if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) { if (!certificate_revocation_list_.empty()) { throw EnvoyException(fmt::format(""Failed to load CRL from {} without trusted CA"", certificateRevocationListPath())); } if (!subject_alt_name_matchers_.empty()) { throw EnvoyException(""SAN-based verification of peer certificates without "" ""trusted CA is insecure and not allowed""); } if (allow_expired_certificate_) { throw EnvoyException(""Certificate validity period is always ignored without trusted CA""); } } }"
33,1110----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2069--tlb.c----flush_tlb_mm_range,"void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long vmflag) { unsigned long addr; unsigned long base_pages_to_flush = TLB_FLUSH_ALL; preempt_disable(); <S2SV_StartVul> if (current->active_mm != mm) <S2SV_EndVul> goto out; if (!current->mm) { leave_mm(smp_processor_id()); goto out; } if ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB)) base_pages_to_flush = (end - start) >> PAGE_SHIFT; if (base_pages_to_flush > tlb_single_page_flush_ceiling) { base_pages_to_flush = TLB_FLUSH_ALL; count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL); local_flush_tlb(); } else { for (addr = start; addr < end; addr += PAGE_SIZE) { count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE); __flush_tlb_single(addr); } } trace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush); out: if (base_pages_to_flush == TLB_FLUSH_ALL) { start = 0UL; end = TLB_FLUSH_ALL; } if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids) flush_tlb_others(mm_cpumask(mm), mm, start, end); preempt_enable(); }","- if (current->active_mm != mm)
+ if (current->active_mm != mm) {
+ smp_mb();
+ }
+ smp_mb();","void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start, unsigned long end, unsigned long vmflag) { unsigned long addr; unsigned long base_pages_to_flush = TLB_FLUSH_ALL; preempt_disable(); if (current->active_mm != mm) { smp_mb(); goto out; } if (!current->mm) { leave_mm(smp_processor_id()); smp_mb(); goto out; } if ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB)) base_pages_to_flush = (end - start) >> PAGE_SHIFT; if (base_pages_to_flush > tlb_single_page_flush_ceiling) { base_pages_to_flush = TLB_FLUSH_ALL; count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL); local_flush_tlb(); } else { for (addr = start; addr < end; addr += PAGE_SIZE) { count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE); __flush_tlb_single(addr); } } trace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush); out: if (base_pages_to_flush == TLB_FLUSH_ALL) { start = 0UL; end = TLB_FLUSH_ALL; } if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids) flush_tlb_others(mm_cpumask(mm), mm, start, end); preempt_enable(); }"
34,1798----CWE-254----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-7797--tls_backend.c----lrmd_remote_listen,"lrmd_remote_listen(gpointer data) { int csock = 0; int flag = 0; unsigned laddr = 0; struct sockaddr addr; gnutls_session_t *session = NULL; crm_client_t *new_client = NULL; static struct mainloop_fd_callbacks lrmd_remote_fd_cb = { .dispatch = lrmd_remote_client_msg, .destroy = lrmd_remote_client_destroy, }; laddr = sizeof(addr); memset(&addr, 0, sizeof(addr)); getsockname(ssock, &addr, &laddr); if (addr.sa_family == AF_INET6) { struct sockaddr_in6 sa; char addr_str[INET6_ADDRSTRLEN]; laddr = sizeof(sa); memset(&sa, 0, sizeof(sa)); csock = accept(ssock, &sa, &laddr); get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN); crm_info(""New remote connection from %s"", addr_str); } else { struct sockaddr_in sa; char addr_str[INET_ADDRSTRLEN]; laddr = sizeof(sa); memset(&sa, 0, sizeof(sa)); csock = accept(ssock, &sa, &laddr); get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN); crm_info(""New remote connection from %s"", addr_str); } if (csock == -1) { crm_err(""accept socket failed""); return TRUE; } if ((flag = fcntl(csock, F_GETFL)) >= 0) { if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) { crm_err(""fcntl() write failed""); close(csock); return TRUE; } } else { crm_err(""fcntl() read failed""); close(csock); return TRUE; } session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s); if (session == NULL) { crm_err(""TLS session creation failed""); close(csock); return TRUE; } new_client = calloc(1, sizeof(crm_client_t)); new_client->remote = calloc(1, sizeof(crm_remote_t)); new_client->kind = CRM_CLIENT_TLS; new_client->remote->tls_session = session; new_client->id = crm_generate_uuid(); new_client->remote->auth_timeout = g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client); crm_notice(""LRMD client connection established. %p id: %s"", new_client, new_client->id); new_client->remote->source = mainloop_add_fd(""lrmd-remote-client"", G_PRIORITY_DEFAULT, csock, new_client, &lrmd_remote_fd_cb); g_hash_table_insert(client_connections, new_client->id, new_client); <S2SV_StartVul> notify_of_new_client(new_client); <S2SV_EndVul> return TRUE; }",- notify_of_new_client(new_client);,"lrmd_remote_listen(gpointer data) { int csock = 0; int flag = 0; unsigned laddr = 0; struct sockaddr addr; gnutls_session_t *session = NULL; crm_client_t *new_client = NULL; static struct mainloop_fd_callbacks lrmd_remote_fd_cb = { .dispatch = lrmd_remote_client_msg, .destroy = lrmd_remote_client_destroy, }; laddr = sizeof(addr); memset(&addr, 0, sizeof(addr)); getsockname(ssock, &addr, &laddr); if (addr.sa_family == AF_INET6) { struct sockaddr_in6 sa; char addr_str[INET6_ADDRSTRLEN]; laddr = sizeof(sa); memset(&sa, 0, sizeof(sa)); csock = accept(ssock, &sa, &laddr); get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN); crm_info(""New remote connection from %s"", addr_str); } else { struct sockaddr_in sa; char addr_str[INET_ADDRSTRLEN]; laddr = sizeof(sa); memset(&sa, 0, sizeof(sa)); csock = accept(ssock, &sa, &laddr); get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN); crm_info(""New remote connection from %s"", addr_str); } if (csock == -1) { crm_err(""accept socket failed""); return TRUE; } if ((flag = fcntl(csock, F_GETFL)) >= 0) { if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) { crm_err(""fcntl() write failed""); close(csock); return TRUE; } } else { crm_err(""fcntl() read failed""); close(csock); return TRUE; } session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s); if (session == NULL) { crm_err(""TLS session creation failed""); close(csock); return TRUE; } new_client = calloc(1, sizeof(crm_client_t)); new_client->remote = calloc(1, sizeof(crm_remote_t)); new_client->kind = CRM_CLIENT_TLS; new_client->remote->tls_session = session; new_client->id = crm_generate_uuid(); new_client->remote->auth_timeout = g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client); crm_notice(""LRMD client connection established. %p id: %s"", new_client, new_client->id); new_client->remote->source = mainloop_add_fd(""lrmd-remote-client"", G_PRIORITY_DEFAULT, csock, new_client, &lrmd_remote_fd_cb); g_hash_table_insert(client_connections, new_client->id, new_client); return TRUE; }"
35,4693----CWE-913----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/reference_handle.cc----ivm::DeleteRunner::Phase2,"void Phase2() final { <S2SV_StartVul> Local<Context> context_handle = Deref(context); <S2SV_EndVul> <S2SV_StartVul> Context::Scope context_scope{context_handle}; <S2SV_EndVul> <S2SV_StartVul> Local<Object> object = Local<Object>::Cast(Deref(reference)); <S2SV_EndVul> <S2SV_StartVul> result = Unmaybe(object->Delete(context_handle, key->CopyInto())); <S2SV_EndVul> }","- Local<Context> context_handle = Deref(context);
- Context::Scope context_scope{context_handle};
- Local<Object> object = Local<Object>::Cast(Deref(reference));
- result = Unmaybe(object->Delete(context_handle, key->CopyInto()));
+ auto context = Deref(this->context);
+ Context::Scope context_scope{context};
+ auto object = GetTargetAndAlsoCheckForProxy();
+ if (!Unmaybe(object->Delete(context, GetKey(context)))) {
+ throw RuntimeTypeError(""Delete failed"");
+ }","void Phase2() final { auto context = Deref(this->context); Context::Scope context_scope{context}; auto object = GetTargetAndAlsoCheckForProxy(); if (!Unmaybe(object->Delete(context, GetKey(context)))) { throw RuntimeTypeError(""Delete failed""); } }"
36,5158----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----pci_emul_dinit,"pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts) { <S2SV_StartVul> int error; <S2SV_EndVul> struct pci_emul_dummy *dummy; dummy = calloc(1, sizeof(struct pci_emul_dummy)); dev->arg = dummy; pci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001); pci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD); pci_set_cfgdata8(dev, PCIR_CLASS, 0x02); <S2SV_StartVul> error = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS); <S2SV_EndVul> <S2SV_StartVul> assert(error == 0); <S2SV_EndVul> <S2SV_StartVul> error = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ); <S2SV_EndVul> <S2SV_StartVul> assert(error == 0); <S2SV_EndVul> <S2SV_StartVul> error = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ); <S2SV_EndVul> <S2SV_StartVul> assert(error == 0); <S2SV_EndVul> <S2SV_StartVul> error = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ); <S2SV_EndVul> <S2SV_StartVul> assert(error == 0); <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> }","- int error;
- error = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);
- assert(error == 0);
- error = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);
- assert(error == 0);
- error = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);
- assert(error == 0);
- error = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);
- assert(error == 0);
- return 0;
+ return pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS) ||
+ pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ) ||
+ pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ) ||
+ pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);","pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts) { struct pci_emul_dummy *dummy; dummy = calloc(1, sizeof(struct pci_emul_dummy)); dev->arg = dummy; pci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001); pci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD); pci_set_cfgdata8(dev, PCIR_CLASS, 0x02); return pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS) || pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ) || pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ) || pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ); }"
37,7373----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hb-set.cc----hb_set_set,"hb_set_set (hb_set_t *set, const hb_set_t *other) { <S2SV_StartVul> if (unlikely (hb_object_is_immutable (set))) <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> set->set (*other); }","- if (unlikely (hb_object_is_immutable (set)))
- return;","hb_set_set (hb_set_t *set, const hb_set_t *other) { set->set (*other); }"
38,1266----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-15649--af_packet.c----packet_do_bind,"static int packet_do_bind(struct sock *sk, const char *name, int ifindex, __be16 proto) { struct packet_sock *po = pkt_sk(sk); struct net_device *dev_curr; __be16 proto_curr; bool need_rehook; struct net_device *dev = NULL; int ret = 0; bool unlisted = false; <S2SV_StartVul> if (po->fanout) <S2SV_EndVul> <S2SV_StartVul> return -EINVAL; <S2SV_EndVul> lock_sock(sk); spin_lock(&po->bind_lock); rcu_read_lock(); if (name) { dev = dev_get_by_name_rcu(sock_net(sk), name); if (!dev) { ret = -ENODEV; goto out_unlock; } } else if (ifindex) { dev = dev_get_by_index_rcu(sock_net(sk), ifindex); if (!dev) { ret = -ENODEV; goto out_unlock; } } if (dev) dev_hold(dev); proto_curr = po->prot_hook.type; dev_curr = po->prot_hook.dev; need_rehook = proto_curr != proto || dev_curr != dev; if (need_rehook) { if (po->running) { rcu_read_unlock(); __unregister_prot_hook(sk, true); rcu_read_lock(); dev_curr = po->prot_hook.dev; if (dev) unlisted = !dev_get_by_index_rcu(sock_net(sk), dev->ifindex); } po->num = proto; po->prot_hook.type = proto; if (unlikely(unlisted)) { dev_put(dev); po->prot_hook.dev = NULL; po->ifindex = -1; packet_cached_dev_reset(po); } else { po->prot_hook.dev = dev; po->ifindex = dev ? dev->ifindex : 0; packet_cached_dev_assign(po, dev); } } if (dev_curr) dev_put(dev_curr); if (proto == 0 || !need_rehook) goto out_unlock; if (!unlisted && (!dev || (dev->flags & IFF_UP))) { register_prot_hook(sk); } else { sk->sk_err = ENETDOWN; if (!sock_flag(sk, SOCK_DEAD)) sk->sk_error_report(sk); } out_unlock: rcu_read_unlock(); spin_unlock(&po->bind_lock); release_sock(sk); return ret; }","- if (po->fanout)
- return -EINVAL;
+ if (po->fanout) {
+ ret = -EINVAL;
+ goto out_unlock;
+ }","static int packet_do_bind(struct sock *sk, const char *name, int ifindex, __be16 proto) { struct packet_sock *po = pkt_sk(sk); struct net_device *dev_curr; __be16 proto_curr; bool need_rehook; struct net_device *dev = NULL; int ret = 0; bool unlisted = false; lock_sock(sk); spin_lock(&po->bind_lock); rcu_read_lock(); if (po->fanout) { ret = -EINVAL; goto out_unlock; } if (name) { dev = dev_get_by_name_rcu(sock_net(sk), name); if (!dev) { ret = -ENODEV; goto out_unlock; } } else if (ifindex) { dev = dev_get_by_index_rcu(sock_net(sk), ifindex); if (!dev) { ret = -ENODEV; goto out_unlock; } } if (dev) dev_hold(dev); proto_curr = po->prot_hook.type; dev_curr = po->prot_hook.dev; need_rehook = proto_curr != proto || dev_curr != dev; if (need_rehook) { if (po->running) { rcu_read_unlock(); __unregister_prot_hook(sk, true); rcu_read_lock(); dev_curr = po->prot_hook.dev; if (dev) unlisted = !dev_get_by_index_rcu(sock_net(sk), dev->ifindex); } po->num = proto; po->prot_hook.type = proto; if (unlikely(unlisted)) { dev_put(dev); po->prot_hook.dev = NULL; po->ifindex = -1; packet_cached_dev_reset(po); } else { po->prot_hook.dev = dev; po->ifindex = dev ? dev->ifindex : 0; packet_cached_dev_assign(po, dev); } } if (dev_curr) dev_put(dev_curr); if (proto == 0 || !need_rehook) goto out_unlock; if (!unlisted && (!dev || (dev->flags & IFF_UP))) { register_prot_hook(sk); } else { sk->sk_err = ENETDOWN; if (!sock_flag(sk, SOCK_DEAD)) sk->sk_error_report(sk); } out_unlock: rcu_read_unlock(); spin_unlock(&po->bind_lock); release_sock(sk); return ret; }"
39,2873----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/util.c----initiate_stratum,"bool initiate_stratum(struct pool *pool) { bool ret = false, recvd = false, noresume = false, sockd = false; char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid; json_t *val = NULL, *res_val, *err_val; json_error_t err; int n2size; resend: if (!setup_stratum_socket(pool)) { applog(LOG_INFO, ""setup_stratum_socket() on %s failed"", get_pool_name(pool)); sockd = false; goto out; } sockd = true; if (recvd) { clear_sock(pool); sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++); } else { if (pool->sessionid) sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid); else sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++); } if (__stratum_send(pool, s, strlen(s)) != SEND_OK) { applog(LOG_DEBUG, ""Failed to send s in initiate_stratum""); goto out; } if (!socket_full(pool, DEFAULT_SOCKWAIT)) { applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum""); goto out; } sret = recv_line(pool); if (!sret) goto out; recvd = true; val = JSON_LOADS(sret, &err); free(sret); if (!val) { applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text); goto out; } res_val = json_object_get(val, ""result""); err_val = json_object_get(val, ""error""); if (!res_val || json_is_null(res_val) || (err_val && !json_is_null(err_val))) { char *ss; if (err_val) ss = json_dumps(err_val, JSON_INDENT(3)); else ss = strdup(""(unknown reason)""); applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss); free(ss); goto out; } sessionid = get_sessionid(res_val); if (!sessionid) applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum""); nonce1 = json_array_string(res_val, 1); if (!nonce1) { applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum""); free(sessionid); goto out; } n2size = json_integer_value(json_array_get(res_val, 2)); <S2SV_StartVul> if (!n2size) { <S2SV_EndVul> applog(LOG_INFO, ""Failed to get n2size in initiate_stratum""); free(sessionid); free(nonce1); goto out; } cg_wlock(&pool->data_lock); pool->sessionid = sessionid; pool->nonce1 = nonce1; pool->n1_len = strlen(nonce1) / 2; free(pool->nonce1bin); pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1); if (unlikely(!pool->nonce1bin)) quithere(1, ""Failed to calloc pool->nonce1bin""); hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len); pool->n2size = n2size; cg_wunlock(&pool->data_lock); if (sessionid) applog(LOG_DEBUG, ""%s stratum session id: %s"", get_pool_name(pool), pool->sessionid); ret = true; out: if (ret) { if (!pool->stratum_url) pool->stratum_url = pool->sockaddr_url; pool->stratum_active = true; pool->swork.diff = 1; if (opt_protocol) { applog(LOG_DEBUG, ""%s confirmed mining.subscribe with extranonce1 %s extran2size %d"", get_pool_name(pool), pool->nonce1, pool->n2size); } } else { if (recvd && !noresume) { cg_wlock(&pool->data_lock); free(pool->sessionid); free(pool->nonce1); pool->sessionid = pool->nonce1 = NULL; cg_wunlock(&pool->data_lock); applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh""); noresume = true; json_decref(val); goto resend; } applog(LOG_DEBUG, ""Initiating stratum failed on %s"", get_pool_name(pool)); if (sockd) { applog(LOG_DEBUG, ""Suspending stratum on %s"", get_pool_name(pool)); suspend_stratum(pool); } } json_decref(val); return ret; }","- if (!n2size) {
+ if (n2size < 1)
+ {","bool initiate_stratum(struct pool *pool) { bool ret = false, recvd = false, noresume = false, sockd = false; char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid; json_t *val = NULL, *res_val, *err_val; json_error_t err; int n2size; resend: if (!setup_stratum_socket(pool)) { applog(LOG_INFO, ""setup_stratum_socket() on %s failed"", get_pool_name(pool)); sockd = false; goto out; } sockd = true; if (recvd) { clear_sock(pool); sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++); } else { if (pool->sessionid) sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid); else sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++); } if (__stratum_send(pool, s, strlen(s)) != SEND_OK) { applog(LOG_DEBUG, ""Failed to send s in initiate_stratum""); goto out; } if (!socket_full(pool, DEFAULT_SOCKWAIT)) { applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum""); goto out; } sret = recv_line(pool); if (!sret) goto out; recvd = true; val = JSON_LOADS(sret, &err); free(sret); if (!val) { applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text); goto out; } res_val = json_object_get(val, ""result""); err_val = json_object_get(val, ""error""); if (!res_val || json_is_null(res_val) || (err_val && !json_is_null(err_val))) { char *ss; if (err_val) ss = json_dumps(err_val, JSON_INDENT(3)); else ss = strdup(""(unknown reason)""); applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss); free(ss); goto out; } sessionid = get_sessionid(res_val); if (!sessionid) applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum""); nonce1 = json_array_string(res_val, 1); if (!nonce1) { applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum""); free(sessionid); goto out; } n2size = json_integer_value(json_array_get(res_val, 2)); if (n2size < 1) { applog(LOG_INFO, ""Failed to get n2size in initiate_stratum""); free(sessionid); free(nonce1); goto out; } cg_wlock(&pool->data_lock); pool->sessionid = sessionid; pool->nonce1 = nonce1; pool->n1_len = strlen(nonce1) / 2; free(pool->nonce1bin); pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1); if (unlikely(!pool->nonce1bin)) quithere(1, ""Failed to calloc pool->nonce1bin""); hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len); pool->n2size = n2size; cg_wunlock(&pool->data_lock); if (sessionid) applog(LOG_DEBUG, ""%s stratum session id: %s"", get_pool_name(pool), pool->sessionid); ret = true; out: if (ret) { if (!pool->stratum_url) pool->stratum_url = pool->sockaddr_url; pool->stratum_active = true; pool->swork.diff = 1; if (opt_protocol) { applog(LOG_DEBUG, ""%s confirmed mining.subscribe with extranonce1 %s extran2size %d"", get_pool_name(pool), pool->nonce1, pool->n2size); } } else { if (recvd && !noresume) { cg_wlock(&pool->data_lock); free(pool->sessionid); free(pool->nonce1); pool->sessionid = pool->nonce1 = NULL; cg_wunlock(&pool->data_lock); applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh""); noresume = true; json_decref(val); goto resend; } applog(LOG_DEBUG, ""Initiating stratum failed on %s"", get_pool_name(pool)); if (sockd) { applog(LOG_DEBUG, ""Suspending stratum on %s"", get_pool_name(pool)); suspend_stratum(pool); } } json_decref(val); return ret; }"
40,6342----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tja1101_driver.c----tja1101Init,"error_t tja1101Init(NetInterface *interface) { uint16_t value; TRACE_INFO(""Initializing TJA1101...\r\n""); if(interface->phyAddr >= 32) { interface->phyAddr = TJA1101_PHY_ADDR; } if(interface->smiDriver != NULL) { interface->smiDriver->init(); } if(interface->extIntDriver != NULL) { interface->extIntDriver->init(); } tja1101WritePhyReg(interface, TJA1101_BASIC_CTRL, TJA1101_BASIC_CTRL_RESET); while(tja1101ReadPhyReg(interface, TJA1101_BASIC_CTRL) & TJA1101_BASIC_CTRL_RESET) { } tja1101DumpPhyReg(interface); value = tja1101ReadPhyReg(interface, TJA1101_EXTENDED_CTRL); value |= TJA1101_EXTENDED_CTRL_CONFIG_EN; tja1101WritePhyReg(interface, TJA1101_EXTENDED_CTRL, value); value = tja1101ReadPhyReg(interface, TJA1101_CONFIG1); value &= ~TJA1101_CONFIG1_MII_MODE; <S2SV_StartVul> value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ; <S2SV_EndVul> tja1101WritePhyReg(interface, TJA1101_CONFIG1, value); value = tja1101ReadPhyReg(interface, TJA1101_COMM_CTRL); value |= TJA1101_COMM_CTRL_AUTO_OP; tja1101WritePhyReg(interface, TJA1101_COMM_CTRL, value); interface->phyEvent = TRUE; osSetEvent(&netEvent); return NO_ERROR; }","- value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ;
+ value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT;","error_t tja1101Init(NetInterface *interface) { uint16_t value; TRACE_INFO(""Initializing TJA1101...\r\n""); if(interface->phyAddr >= 32) { interface->phyAddr = TJA1101_PHY_ADDR; } if(interface->smiDriver != NULL) { interface->smiDriver->init(); } if(interface->extIntDriver != NULL) { interface->extIntDriver->init(); } tja1101WritePhyReg(interface, TJA1101_BASIC_CTRL, TJA1101_BASIC_CTRL_RESET); while(tja1101ReadPhyReg(interface, TJA1101_BASIC_CTRL) & TJA1101_BASIC_CTRL_RESET) { } tja1101DumpPhyReg(interface); value = tja1101ReadPhyReg(interface, TJA1101_EXTENDED_CTRL); value |= TJA1101_EXTENDED_CTRL_CONFIG_EN; tja1101WritePhyReg(interface, TJA1101_EXTENDED_CTRL, value); value = tja1101ReadPhyReg(interface, TJA1101_CONFIG1); value &= ~TJA1101_CONFIG1_MII_MODE; value |= TJA1101_CONFIG1_MII_MODE_RMII_50MHZ_REF_CLK_OUT; tja1101WritePhyReg(interface, TJA1101_CONFIG1, value); value = tja1101ReadPhyReg(interface, TJA1101_COMM_CTRL); value |= TJA1101_COMM_CTRL_AUTO_OP; tja1101WritePhyReg(interface, TJA1101_COMM_CTRL, value); interface->phyEvent = TRUE; osSetEvent(&netEvent); return NO_ERROR; }"
41,5361----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jas_malloc.c----jas_realloc,"void *jas_realloc(void *ptr, size_t size) { void *result; <S2SV_StartVul> JAS_DBGLOG(101, (""jas_realloc called with %x,%zu\n"", ptr, size)); <S2SV_EndVul> result = realloc(ptr, size); JAS_DBGLOG(100, (""jas_realloc(%p, %zu) -> %p\n"", ptr, size, result)); return result; }","- JAS_DBGLOG(101, (""jas_realloc called with %x,%zu\n"", ptr, size));
+ JAS_DBGLOG(101, (""jas_realloc(%x, %zu)\n"", ptr, size));","void *jas_realloc(void *ptr, size_t size) { void *result; JAS_DBGLOG(101, (""jas_realloc(%x, %zu)\n"", ptr, size)); result = realloc(ptr, size); JAS_DBGLOG(100, (""jas_realloc(%p, %zu) -> %p\n"", ptr, size, result)); return result; }"
42,7200----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/namespace.c----has_locked_children,"<S2SV_StartVul> static bool has_locked_children(struct mount *mnt, struct dentry *dentry) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> struct mount *child; <S2SV_EndVul> <S2SV_StartVul> list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) { <S2SV_EndVul> <S2SV_StartVul> if (!is_subdir(child->mnt_mountpoint, dentry)) <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> <S2SV_StartVul> if (child->mnt.mnt_flags & MNT_LOCKED) <S2SV_EndVul> <S2SV_StartVul> return true; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return false; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- static bool has_locked_children(struct mount *mnt, struct dentry *dentry)
- {
- struct mount *child;
- list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {
- if (!is_subdir(child->mnt_mountpoint, dentry))
- continue;
- if (child->mnt.mnt_flags & MNT_LOCKED)
- return true;
- }
- return false;
- }
+ static bool has_locked_children(struct mount *mnt, struct dentry *dentry)
+ {
+ struct mount *child;
+ list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {
+ if (!is_subdir(child->mnt_mountpoint, dentry))
+ continue;
+ if (child->mnt.mnt_flags & MNT_LOCKED)
+ return true;
+ }
+ return false;
+ }","static bool has_locked_children(struct mount *mnt, struct dentry *dentry) { struct mount *child; list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) { if (!is_subdir(child->mnt_mountpoint, dentry)) continue; if (child->mnt.mnt_flags & MNT_LOCKED) return true; } return false; }"
43,783----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-7509--namei.c----ext4_orphan_add,"int ext4_orphan_add(handle_t *handle, struct inode *inode) { struct super_block *sb = inode->i_sb; struct ext4_iloc iloc; int err = 0, rc; <S2SV_StartVul> if (!ext4_handle_valid(handle)) <S2SV_EndVul> return 0; mutex_lock(&EXT4_SB(sb)->s_orphan_lock); if (!list_empty(&EXT4_I(inode)->i_orphan)) goto out_unlock; J_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) || inode->i_nlink == 0); BUFFER_TRACE(EXT4_SB(sb)->s_sbh, ""get_write_access""); err = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh); if (err) goto out_unlock; err = ext4_reserve_inode_write(handle, inode, &iloc); if (err) goto out_unlock; if (NEXT_ORPHAN(inode) && NEXT_ORPHAN(inode) <= (le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))) goto mem_insert; NEXT_ORPHAN(inode) = le32_to_cpu(EXT4_SB(sb)->s_es->s_last_orphan); EXT4_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino); err = ext4_handle_dirty_super(handle, sb); rc = ext4_mark_iloc_dirty(handle, inode, &iloc); if (!err) err = rc; mem_insert: if (!err) list_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan); jbd_debug(4, ""superblock will point to %lu\n"", inode->i_ino); jbd_debug(4, ""orphan inode %lu will point to %d\n"", inode->i_ino, NEXT_ORPHAN(inode)); out_unlock: mutex_unlock(&EXT4_SB(sb)->s_orphan_lock); ext4_std_error(inode->i_sb, err); return err; }","- if (!ext4_handle_valid(handle))
+ if (!EXT4_SB(sb)->s_journal)","int ext4_orphan_add(handle_t *handle, struct inode *inode) { struct super_block *sb = inode->i_sb; struct ext4_iloc iloc; int err = 0, rc; if (!EXT4_SB(sb)->s_journal) return 0; mutex_lock(&EXT4_SB(sb)->s_orphan_lock); if (!list_empty(&EXT4_I(inode)->i_orphan)) goto out_unlock; J_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) || inode->i_nlink == 0); BUFFER_TRACE(EXT4_SB(sb)->s_sbh, ""get_write_access""); err = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh); if (err) goto out_unlock; err = ext4_reserve_inode_write(handle, inode, &iloc); if (err) goto out_unlock; if (NEXT_ORPHAN(inode) && NEXT_ORPHAN(inode) <= (le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))) goto mem_insert; NEXT_ORPHAN(inode) = le32_to_cpu(EXT4_SB(sb)->s_es->s_last_orphan); EXT4_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino); err = ext4_handle_dirty_super(handle, sb); rc = ext4_mark_iloc_dirty(handle, inode, &iloc); if (!err) err = rc; mem_insert: if (!err) list_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan); jbd_debug(4, ""superblock will point to %lu\n"", inode->i_ino); jbd_debug(4, ""orphan inode %lu will point to %d\n"", inode->i_ino, NEXT_ORPHAN(inode)); out_unlock: mutex_unlock(&EXT4_SB(sb)->s_orphan_lock); ext4_std_error(inode->i_sb, err); return err; }"
44,6207----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fsnotify.c----__fsnotify_parent,"int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask) { struct dentry *parent; struct inode *p_inode; int ret = 0; if (!dentry) dentry = path->dentry; if (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED)) return 0; parent = dget_parent(dentry); p_inode = parent->d_inode; if (unlikely(!fsnotify_inode_watches_children(p_inode))) __fsnotify_update_child_dentry_flags(p_inode); else if (p_inode->i_fsnotify_mask & mask) { mask |= FS_EVENT_ON_CHILD; if (path) ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH, <S2SV_StartVul> dentry->d_name.name, 0); <S2SV_EndVul> else ret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE, <S2SV_StartVul> dentry->d_name.name, 0); <S2SV_EndVul> } dput(parent); return ret; }","- dentry->d_name.name, 0);
- dentry->d_name.name, 0);
+ struct name_snapshot name;
+ take_dentry_name_snapshot(&name, dentry);
+ name.name, 0);
+ name.name, 0);
+ release_dentry_name_snapshot(&name);","int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask) { struct dentry *parent; struct inode *p_inode; int ret = 0; if (!dentry) dentry = path->dentry; if (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED)) return 0; parent = dget_parent(dentry); p_inode = parent->d_inode; if (unlikely(!fsnotify_inode_watches_children(p_inode))) __fsnotify_update_child_dentry_flags(p_inode); else if (p_inode->i_fsnotify_mask & mask) { struct name_snapshot name; mask |= FS_EVENT_ON_CHILD; take_dentry_name_snapshot(&name, dentry); if (path) ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH, name.name, 0); else ret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE, name.name, 0); release_dentry_name_snapshot(&name); } dput(parent); return ret; }"
45,5376----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ServerStateMachine.cpp----quic::updateHandshakeState,"void updateHandshakeState(QuicServerConnectionState& conn) { auto handshakeLayer = conn.serverHandshakeLayer; auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher(); auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher(); auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher(); auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher(); auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher(); auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher(); if (zeroRttReadCipher) { if (conn.qLogger) { conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher); } QUIC_TRACE(fst_trace, conn, ""derived 0-rtt read cipher""); conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher)); } if (zeroRttHeaderCipher) { conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher)); } if (oneRttWriteHeaderCipher) { conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher); } if (oneRttReadHeaderCipher) { conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher)); } if (oneRttWriteCipher) { if (conn.qLogger) { conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher); } QUIC_TRACE(fst_trace, conn, ""derived 1-rtt write cipher""); <S2SV_StartVul> CHECK(!conn.oneRttWriteCipher.get()); <S2SV_EndVul> conn.oneRttWriteCipher = std::move(oneRttWriteCipher); updatePacingOnKeyEstablished(conn); auto clientParams = handshakeLayer->getClientTransportParams(); if (!clientParams) { throw QuicTransportException( ""No client transport params"", TransportErrorCode::TRANSPORT_PARAMETER_ERROR); } processClientInitialParams(conn, std::move(*clientParams)); } if (oneRttReadCipher) { if (conn.qLogger) { conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher); } QUIC_TRACE(fst_trace, conn, ""derived 1-rtt read cipher""); conn.writableBytesLimit = folly::none; conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher)); } auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher(); auto handshakeReadHeaderCipher = handshakeLayer->getHandshakeReadHeaderCipher(); if (handshakeReadCipher) { CHECK(handshakeReadHeaderCipher); conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher)); conn.readCodec->setHandshakeHeaderCipher( std::move(handshakeReadHeaderCipher)); } if (handshakeLayer->isHandshakeDone()) { CHECK(conn.oneRttWriteCipher); if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) { sendSimpleFrame(conn, HandshakeDoneFrame()); conn.sentHandshakeDone = true; } } }","- CHECK(!conn.oneRttWriteCipher.get());
+ if (conn.oneRttWriteCipher) {
+ throw QuicTransportException(
+ ""Duplicate 1-rtt write cipher"", TransportErrorCode::CRYPTO_ERROR);
+ }","void updateHandshakeState(QuicServerConnectionState& conn) { auto handshakeLayer = conn.serverHandshakeLayer; auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher(); auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher(); auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher(); auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher(); auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher(); auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher(); if (zeroRttReadCipher) { if (conn.qLogger) { conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher); } QUIC_TRACE(fst_trace, conn, ""derived 0-rtt read cipher""); conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher)); } if (zeroRttHeaderCipher) { conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher)); } if (oneRttWriteHeaderCipher) { conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher); } if (oneRttReadHeaderCipher) { conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher)); } if (oneRttWriteCipher) { if (conn.qLogger) { conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher); } QUIC_TRACE(fst_trace, conn, ""derived 1-rtt write cipher""); if (conn.oneRttWriteCipher) { throw QuicTransportException( ""Duplicate 1-rtt write cipher"", TransportErrorCode::CRYPTO_ERROR); } conn.oneRttWriteCipher = std::move(oneRttWriteCipher); updatePacingOnKeyEstablished(conn); auto clientParams = handshakeLayer->getClientTransportParams(); if (!clientParams) { throw QuicTransportException( ""No client transport params"", TransportErrorCode::TRANSPORT_PARAMETER_ERROR); } processClientInitialParams(conn, std::move(*clientParams)); } if (oneRttReadCipher) { if (conn.qLogger) { conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher); } QUIC_TRACE(fst_trace, conn, ""derived 1-rtt read cipher""); conn.writableBytesLimit = folly::none; conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher)); } auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher(); auto handshakeReadHeaderCipher = handshakeLayer->getHandshakeReadHeaderCipher(); if (handshakeReadCipher) { CHECK(handshakeReadHeaderCipher); conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher)); conn.readCodec->setHandshakeHeaderCipher( std::move(handshakeReadHeaderCipher)); } if (handshakeLayer->isHandshakeDone()) { CHECK(conn.oneRttWriteCipher); if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) { sendSimpleFrame(conn, HandshakeDoneFrame()); conn.sentHandshakeDone = true; } } }"
46,5366----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/socket.c----oe_recvfrom,"ssize_t oe_recvfrom( int sockfd, void* buf, size_t len, int flags, <S2SV_StartVul> const struct oe_sockaddr* src_addr, <S2SV_EndVul> oe_socklen_t* addrlen) { ssize_t ret = -1; oe_fd_t* sock; if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET))) OE_RAISE_ERRNO(oe_errno); ret = sock->ops.socket.recvfrom(sock, buf, len, flags, src_addr, addrlen); done: return ret; }","- const struct oe_sockaddr* src_addr,
+ struct oe_sockaddr* src_addr,","ssize_t oe_recvfrom( int sockfd, void* buf, size_t len, int flags, struct oe_sockaddr* src_addr, oe_socklen_t* addrlen) { ssize_t ret = -1; oe_fd_t* sock; if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET))) OE_RAISE_ERRNO(oe_errno); ret = sock->ops.socket.recvfrom(sock, buf, len, flags, src_addr, addrlen); done: return ret; }"
47,2033----CWE-190----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-11590--jsutils.c----jsuGetFreeStack,size_t jsuGetFreeStack() { #ifdef ARM void *frame = __builtin_frame_address(0); size_t stackPos = (size_t)((char*)frame); size_t stackEnd = (size_t)((char*)&LINKER_END_VAR); if (stackPos < stackEnd) return 0; return stackPos - stackEnd; #elif defined(LINUX) char ptr; extern void *STACK_BASE; uint32_t count = (uint32_t)((size_t)STACK_BASE - (size_t)&ptr); return 1000000 - count; <S2SV_StartVul> #else <S2SV_EndVul> return 1000000; #endif },"- #else
+ if (count>max_stack) return 0;
+ return max_stack - count;
+ #else",size_t jsuGetFreeStack() { #ifdef ARM void *frame = __builtin_frame_address(0); size_t stackPos = (size_t)((char*)frame); size_t stackEnd = (size_t)((char*)&LINKER_END_VAR); if (stackPos < stackEnd) return 0; return stackPos - stackEnd; #elif defined(LINUX) char ptr; extern void *STACK_BASE; uint32_t count = (uint32_t)((size_t)STACK_BASE - (size_t)&ptr); const uint32_t max_stack = 1000000; if (count>max_stack) return 0; return max_stack - count; #else return 1000000; #endif }
48,1889----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-1999011--asfdec_o.c----parse_video_info,"static int parse_video_info(AVIOContext *pb, AVStream *st) { uint16_t size_asf; uint32_t size_bmp; unsigned int tag; st->codecpar->width = avio_rl32(pb); st->codecpar->height = avio_rl32(pb); avio_skip(pb, 1); size_asf = avio_rl16(pb); tag = ff_get_bmp_header(pb, st, &size_bmp); st->codecpar->codec_tag = tag; st->codecpar->codec_id = ff_codec_get_id(ff_codec_bmp_tags, tag); size_bmp = FFMAX(size_asf, size_bmp); <S2SV_StartVul> if (size_bmp > BMP_HEADER_SIZE) { <S2SV_EndVul> int ret; st->codecpar->extradata_size = size_bmp - BMP_HEADER_SIZE; if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE))) { st->codecpar->extradata_size = 0; return AVERROR(ENOMEM); } memset(st->codecpar->extradata + st->codecpar->extradata_size , 0, AV_INPUT_BUFFER_PADDING_SIZE); if ((ret = avio_read(pb, st->codecpar->extradata, st->codecpar->extradata_size)) < 0) return ret; } return 0; }","- if (size_bmp > BMP_HEADER_SIZE) {
+ if (size_bmp > BMP_HEADER_SIZE &&
+ size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {","static int parse_video_info(AVIOContext *pb, AVStream *st) { uint16_t size_asf; uint32_t size_bmp; unsigned int tag; st->codecpar->width = avio_rl32(pb); st->codecpar->height = avio_rl32(pb); avio_skip(pb, 1); size_asf = avio_rl16(pb); tag = ff_get_bmp_header(pb, st, &size_bmp); st->codecpar->codec_tag = tag; st->codecpar->codec_id = ff_codec_get_id(ff_codec_bmp_tags, tag); size_bmp = FFMAX(size_asf, size_bmp); if (size_bmp > BMP_HEADER_SIZE && size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) { int ret; st->codecpar->extradata_size = size_bmp - BMP_HEADER_SIZE; if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE))) { st->codecpar->extradata_size = 0; return AVERROR(ENOMEM); } memset(st->codecpar->extradata + st->codecpar->extradata_size , 0, AV_INPUT_BUFFER_PADDING_SIZE); if ((ret = avio_read(pb, st->codecpar->extradata, st->codecpar->extradata_size)) < 0) return ret; } return 0; }"
49,6849----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/process_keys.c----install_user_keyrings,"int install_user_keyrings(void) { struct user_struct *user; const struct cred *cred; struct key *uid_keyring, *session_keyring; key_perm_t user_keyring_perm; char buf[20]; int ret; uid_t uid; user_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL; cred = current_cred(); user = cred->user; uid = from_kuid(cred->user_ns, user->uid); kenter(""%p{%u}"", user, uid); if (user->uid_keyring && user->session_keyring) { kleave("" = 0 [exist]""); return 0; } mutex_lock(&key_user_keyring_mutex); ret = 0; if (!user->uid_keyring) { sprintf(buf, ""_uid.%u"", uid); uid_keyring = find_keyring_by_name(buf, true); if (IS_ERR(uid_keyring)) { uid_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, <S2SV_StartVul> KEY_ALLOC_IN_QUOTA, <S2SV_EndVul> NULL, NULL); if (IS_ERR(uid_keyring)) { ret = PTR_ERR(uid_keyring); goto error; } } sprintf(buf, ""_uid_ses.%u"", uid); session_keyring = find_keyring_by_name(buf, true); if (IS_ERR(session_keyring)) { session_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, <S2SV_StartVul> KEY_ALLOC_IN_QUOTA, <S2SV_EndVul> NULL, NULL); if (IS_ERR(session_keyring)) { ret = PTR_ERR(session_keyring); goto error_release; } ret = key_link(session_keyring, uid_keyring); if (ret < 0) goto error_release_both; } user->uid_keyring = uid_keyring; user->session_keyring = session_keyring; } mutex_unlock(&key_user_keyring_mutex); kleave("" = 0""); return 0; error_release_both: key_put(session_keyring); error_release: key_put(uid_keyring); error: mutex_unlock(&key_user_keyring_mutex); kleave("" = %d"", ret); return ret; }","- KEY_ALLOC_IN_QUOTA,
- KEY_ALLOC_IN_QUOTA,
+ KEY_ALLOC_UID_KEYRING |
+ KEY_ALLOC_IN_QUOTA,
+ KEY_ALLOC_UID_KEYRING |
+ KEY_ALLOC_IN_QUOTA,","int install_user_keyrings(void) { struct user_struct *user; const struct cred *cred; struct key *uid_keyring, *session_keyring; key_perm_t user_keyring_perm; char buf[20]; int ret; uid_t uid; user_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL; cred = current_cred(); user = cred->user; uid = from_kuid(cred->user_ns, user->uid); kenter(""%p{%u}"", user, uid); if (user->uid_keyring && user->session_keyring) { kleave("" = 0 [exist]""); return 0; } mutex_lock(&key_user_keyring_mutex); ret = 0; if (!user->uid_keyring) { sprintf(buf, ""_uid.%u"", uid); uid_keyring = find_keyring_by_name(buf, true); if (IS_ERR(uid_keyring)) { uid_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA, NULL, NULL); if (IS_ERR(uid_keyring)) { ret = PTR_ERR(uid_keyring); goto error; } } sprintf(buf, ""_uid_ses.%u"", uid); session_keyring = find_keyring_by_name(buf, true); if (IS_ERR(session_keyring)) { session_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_UID_KEYRING | KEY_ALLOC_IN_QUOTA, NULL, NULL); if (IS_ERR(session_keyring)) { ret = PTR_ERR(session_keyring); goto error_release; } ret = key_link(session_keyring, uid_keyring); if (ret < 0) goto error_release_both; } user->uid_keyring = uid_keyring; user->session_keyring = session_keyring; } mutex_unlock(&key_user_keyring_mutex); kleave("" = 0""); return 0; error_release_both: key_put(session_keyring); error_release: key_put(uid_keyring); error: mutex_unlock(&key_user_keyring_mutex); kleave("" = %d"", ret); return ret; }"
50,2528----CWE-269----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5940--fs_home.c----store_asoundrc,"static int store_asoundrc(void) { fs_build_mnt_dir(); char *src; char *dest = RUN_ASOUNDRC_FILE; FILE *fp = fopen(dest, ""w""); <S2SV_StartVul> if (fp) { <S2SV_EndVul> <S2SV_StartVul> fprintf(fp, ""\n""); <S2SV_EndVul> <S2SV_StartVul> SET_PERMS_STREAM(fp, getuid(), getgid(), 0644); <S2SV_EndVul> <S2SV_StartVul> fclose(fp); <S2SV_EndVul> } <S2SV_StartVul> <S2SV_EndVul> if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1) errExit(""asprintf""); <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> struct stat s; <S2SV_EndVul> <S2SV_StartVul> if (stat(src, &s) == 0) { <S2SV_EndVul> <S2SV_StartVul> if (is_link(src)) { <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> char* rp = realpath(src, NULL); <S2SV_EndVul> <S2SV_StartVul> if (!rp) { <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""Error: Cannot access %s\n"", src); <S2SV_EndVul> exit(1); <S2SV_StartVul> } <S2SV_EndVul> if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) { fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n""); exit(1); } free(rp); } pid_t child = fork(); if (child < 0) errExit(""fork""); if (child == 0) { drop_privs(0); int rv = copy_file(src, dest, getuid(), getgid(), 0644); if (rv) fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n""); else { fs_logger2(""clone"", dest); } _exit(0); } waitpid(child, NULL, 0); return 1; } return 0; }","- if (fp) {
- fprintf(fp, ""\n"");
- SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
- fclose(fp);
- 
- 
- struct stat s;
- if (stat(src, &s) == 0) {
- if (is_link(src)) {
- char* rp = realpath(src, NULL);
- if (!rp) {
- fprintf(stderr, ""Error: Cannot access %s\n"", src);
- }
+ exit(1);
+ }","static int store_asoundrc(void) { fs_build_mnt_dir(); char *src; char *dest = RUN_ASOUNDRC_FILE; FILE *fp = fopen(dest, ""w""); if (fp) { fprintf(fp, ""\n""); SET_PERMS_STREAM(fp, getuid(), getgid(), 0644); fclose(fp); } if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1) errExit(""asprintf""); struct stat s; if (stat(src, &s) == 0) { if (is_link(src)) { char* rp = realpath(src, NULL); if (!rp) { fprintf(stderr, ""Error: Cannot access %s\n"", src); exit(1); } if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) { fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n""); exit(1); } free(rp); } copy_file_as_user(src, dest, getuid(), getgid(), 0644); fs_logger2(""clone"", dest); return 1; } return 0; }"
51,1116----CWE-284----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-1237--nfs2acl.c----nfsacld_proc_setacl,"static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp, struct nfsd3_setaclargs *argp, struct nfsd_attrstat *resp) { struct inode *inode; svc_fh *fh; __be32 nfserr = 0; int error; dprintk(""nfsd: SETACL(2acl) %s\n"", SVCFH_fmt(&argp->fh)); fh = fh_copy(&resp->fh, &argp->fh); nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR); if (nfserr) goto out; inode = d_inode(fh->fh_dentry); <S2SV_StartVul> if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) { <S2SV_EndVul> <S2SV_StartVul> error = -EOPNOTSUPP; <S2SV_EndVul> <S2SV_StartVul> goto out_errno; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> error = fh_want_write(fh); if (error) goto out_errno; <S2SV_StartVul> error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS); <S2SV_EndVul> if (error) <S2SV_StartVul> goto out_drop_write; <S2SV_EndVul> <S2SV_StartVul> error = inode->i_op->set_acl(inode, argp->acl_default, <S2SV_EndVul> <S2SV_StartVul> ACL_TYPE_DEFAULT); <S2SV_EndVul> if (error) <S2SV_StartVul> goto out_drop_write; <S2SV_EndVul> fh_drop_write(fh); nfserr = fh_getattr(fh, &resp->stat); out: posix_acl_release(argp->acl_access); posix_acl_release(argp->acl_default); return nfserr; <S2SV_StartVul> out_drop_write: <S2SV_EndVul> fh_drop_write(fh); out_errno: nfserr = nfserrno(error); goto out; }","- if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
- error = -EOPNOTSUPP;
- goto out_errno;
- }
- error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
- goto out_drop_write;
- error = inode->i_op->set_acl(inode, argp->acl_default,
- ACL_TYPE_DEFAULT);
- goto out_drop_write;
- out_drop_write:
+ fh_lock(fh);
+ error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
+ goto out_drop_lock;
+ error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
+ goto out_drop_lock;
+ fh_unlock(fh);
+ out_drop_lock:
+ fh_unlock(fh);","static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp, struct nfsd3_setaclargs *argp, struct nfsd_attrstat *resp) { struct inode *inode; svc_fh *fh; __be32 nfserr = 0; int error; dprintk(""nfsd: SETACL(2acl) %s\n"", SVCFH_fmt(&argp->fh)); fh = fh_copy(&resp->fh, &argp->fh); nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR); if (nfserr) goto out; inode = d_inode(fh->fh_dentry); error = fh_want_write(fh); if (error) goto out_errno; fh_lock(fh); error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access); if (error) goto out_drop_lock; error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default); if (error) goto out_drop_lock; fh_unlock(fh); fh_drop_write(fh); nfserr = fh_getattr(fh, &resp->stat); out: posix_acl_release(argp->acl_access); posix_acl_release(argp->acl_default); return nfserr; out_drop_lock: fh_unlock(fh); fh_drop_write(fh); out_errno: nfserr = nfserrno(error); goto out; }"
52,128----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4008--decoding.c----_asn1_extract_der_octet,"_asn1_extract_der_octet (asn1_node node, const unsigned char *der, int der_len, unsigned flags) { int len2, len3; int counter, counter_end; int result; len2 = asn1_get_length_der (der, der_len, &len3); if (len2 < -1) return ASN1_DER_ERROR; counter = len3 + 1; DECR_LEN(der_len, len3); if (len2 == -1) <S2SV_StartVul> counter_end = der_len - 2; <S2SV_EndVul> else counter_end = der_len; while (counter < counter_end) { DECR_LEN(der_len, 1); if (len2 >= 0) { DECR_LEN(der_len, len2+len3); _asn1_append_value (node, der + counter + len3, len2); } else { DECR_LEN(der_len, len3); result = _asn1_extract_der_octet (node, der + counter + len3, der_len, flags); if (result != ASN1_SUCCESS) return result; len2 = 0; } counter += len2 + len3 + 1; } return ASN1_SUCCESS; cleanup: return result; }","- counter_end = der_len - 2;
+ {
+ if (der_len < 2)
+ return ASN1_DER_ERROR;
+ counter_end = der_len - 2;
+ }
+ if (counter_end < counter)
+ return ASN1_DER_ERROR;","_asn1_extract_der_octet (asn1_node node, const unsigned char *der, int der_len, unsigned flags) { int len2, len3; int counter, counter_end; int result; len2 = asn1_get_length_der (der, der_len, &len3); if (len2 < -1) return ASN1_DER_ERROR; counter = len3 + 1; DECR_LEN(der_len, len3); if (len2 == -1) { if (der_len < 2) return ASN1_DER_ERROR; counter_end = der_len - 2; } else counter_end = der_len; if (counter_end < counter) return ASN1_DER_ERROR; while (counter < counter_end) { DECR_LEN(der_len, 1); if (len2 >= 0) { DECR_LEN(der_len, len2+len3); _asn1_append_value (node, der + counter + len3, len2); } else { DECR_LEN(der_len, len3); result = _asn1_extract_der_octet (node, der + counter + len3, der_len, flags); if (result != ASN1_SUCCESS) return result; len2 = 0; } counter += len2 + len3 + 1; } return ASN1_SUCCESS; cleanup: return result; }"
53,3387----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gost_ec_keyx.c----pkey_gost2018_encrypt,"static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out, size_t *out_len, const unsigned char *key, size_t key_len) { PSKeyTransport_gost *pst = NULL; EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx); struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx); int pkey_nid = EVP_PKEY_base_id(pubk); unsigned char expkeys[64]; EVP_PKEY *sec_key = NULL; int ret = 0; int mac_nid = NID_undef; size_t mac_len = 0; int exp_len = 0, iv_len = 0; unsigned char *exp_buf = NULL; int key_is_ephemeral = 0; switch (data->cipher_nid) { case NID_magma_ctr: mac_nid = NID_magma_mac; mac_len = 8; iv_len = 4; break; case NID_grasshopper_ctr: mac_nid = NID_grasshopper_mac; mac_len = 16; iv_len = 8; break; default: GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER); return -1; break; } exp_len = key_len + mac_len; exp_buf = OPENSSL_malloc(exp_len); if (!exp_buf) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); return -1; } sec_key = EVP_PKEY_CTX_get0_peerkey(pctx); if (!sec_key) { sec_key = EVP_PKEY_new(); if (sec_key == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE ); goto err; } if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new()) || !EVP_PKEY_copy_parameters(sec_key, pubk) || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_SHARED_KEY); goto err; } key_is_ephemeral = 1; } if (data->shared_ukm_size == 0) { if (RAND_bytes(data->shared_ukm, 32) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR); goto err; } data->shared_ukm_size = 32; } if (gost_keg(data->shared_ukm, pkey_nid, EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)), EVP_PKEY_get0(sec_key), expkeys) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS); goto err; } if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len, exp_buf, &exp_len) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } pst = PSKeyTransport_gost_new(); if (!pst) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } pst->ukm = ASN1_OCTET_STRING_new(); if (pst->ukm == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } <S2SV_StartVul> if ((*out_len = i2d_PSKeyTransport_gost(pst, out ? &out : NULL)) > 0) <S2SV_EndVul> ret = 1; err: OPENSSL_cleanse(expkeys, sizeof(expkeys)); if (key_is_ephemeral) EVP_PKEY_free(sec_key); PSKeyTransport_gost_free(pst); OPENSSL_free(exp_buf); return ret; }","- if ((*out_len = i2d_PSKeyTransport_gost(pst, out ? &out : NULL)) > 0)
+ int res_len = 0;
+ res_len = i2d_PSKeyTransport_gost(pst, NULL);
+ if (res_len <= 0) {
+ GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);
+ goto err;
+ }
+ if (out == NULL) {
+ } else {
+ if ((size_t)res_len > *out_len) {
+ GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);
+ goto err;
+ }
+ if ((*out_len = i2d_PSKeyTransport_gost(pst, &out)) > 0)
+ ret = 1;
+ else
+ GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);
+ }","static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out, size_t *out_len, const unsigned char *key, size_t key_len) { PSKeyTransport_gost *pst = NULL; EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx); struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx); int pkey_nid = EVP_PKEY_base_id(pubk); unsigned char expkeys[64]; EVP_PKEY *sec_key = NULL; int ret = 0; int mac_nid = NID_undef; size_t mac_len = 0; int exp_len = 0, iv_len = 0; unsigned char *exp_buf = NULL; int key_is_ephemeral = 0; int res_len = 0; switch (data->cipher_nid) { case NID_magma_ctr: mac_nid = NID_magma_mac; mac_len = 8; iv_len = 4; break; case NID_grasshopper_ctr: mac_nid = NID_grasshopper_mac; mac_len = 16; iv_len = 8; break; default: GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER); return -1; break; } exp_len = key_len + mac_len; exp_buf = OPENSSL_malloc(exp_len); if (!exp_buf) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); return -1; } sec_key = EVP_PKEY_CTX_get0_peerkey(pctx); if (!sec_key) { sec_key = EVP_PKEY_new(); if (sec_key == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE ); goto err; } if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new()) || !EVP_PKEY_copy_parameters(sec_key, pubk) || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_SHARED_KEY); goto err; } key_is_ephemeral = 1; } if (data->shared_ukm_size == 0) { if (RAND_bytes(data->shared_ukm, 32) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR); goto err; } data->shared_ukm_size = 32; } if (gost_keg(data->shared_ukm, pkey_nid, EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)), EVP_PKEY_get0(sec_key), expkeys) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS); goto err; } if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len, exp_buf, &exp_len) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } pst = PSKeyTransport_gost_new(); if (!pst) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } pst->ukm = ASN1_OCTET_STRING_new(); if (pst->ukm == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } res_len = i2d_PSKeyTransport_gost(pst, NULL); if (res_len <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB); goto err; } if (out == NULL) { *out_len = res_len; ret = 1; } else { if ((size_t)res_len > *out_len) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE); goto err; } if ((*out_len = i2d_PSKeyTransport_gost(pst, &out)) > 0) ret = 1; else GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB); } err: OPENSSL_cleanse(expkeys, sizeof(expkeys)); if (key_is_ephemeral) EVP_PKEY_free(sec_key); PSKeyTransport_gost_free(pst); OPENSSL_free(exp_buf); return ret; }"
54,5843----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiSqlite.c----dbEvalSetColumn,"static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) { Jsi_Interp *interp = p->jdb->interp; <S2SV_StartVul> char nbuf[200]; <S2SV_EndVul> sqlite3_stmt *pStmt = p->pPreStmt->pStmt; switch( sqlite3_column_type(pStmt, iCol) ) { case SQLITE_BLOB: { int bytes = sqlite3_column_bytes(pStmt, iCol); const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol); if( !zBlob ) { return; } Jsi_DSAppendLen(dStr, zBlob, bytes); return; } case SQLITE_INTEGER: { sqlite_int64 v = sqlite3_column_int64(pStmt, iCol); if (v==0 || v==1) { const char *dectyp = sqlite3_column_decltype(pStmt, iCol); if (dectyp && !Jsi_Strncasecmp(dectyp,""bool"", 4)) { Jsi_DSAppend(dStr, (v?""true"":""false""), NULL); return; } } #ifdef __WIN32 snprintf(nbuf, sizeof(nbuf), ""%"" PRId64, (Jsi_Wide)v); #else snprintf(nbuf, sizeof(nbuf), ""%lld"", v); #endif Jsi_DSAppend(dStr, nbuf, NULL); return; } case SQLITE_FLOAT: { Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf)); Jsi_DSAppend(dStr, nbuf, NULL); return; } case SQLITE_NULL: { return; } } const char *str = (char*)sqlite3_column_text(pStmt, iCol ); if (!str) str = p->jdb->optPtr->nullvalue; Jsi_DSAppend(dStr, str?str:"""", NULL); }","- char nbuf[200];
+ char nbuf[JSI_MAX_NUMBER_STRING];","static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) { Jsi_Interp *interp = p->jdb->interp; char nbuf[JSI_MAX_NUMBER_STRING]; sqlite3_stmt *pStmt = p->pPreStmt->pStmt; switch( sqlite3_column_type(pStmt, iCol) ) { case SQLITE_BLOB: { int bytes = sqlite3_column_bytes(pStmt, iCol); const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol); if( !zBlob ) { return; } Jsi_DSAppendLen(dStr, zBlob, bytes); return; } case SQLITE_INTEGER: { sqlite_int64 v = sqlite3_column_int64(pStmt, iCol); if (v==0 || v==1) { const char *dectyp = sqlite3_column_decltype(pStmt, iCol); if (dectyp && !Jsi_Strncasecmp(dectyp,""bool"", 4)) { Jsi_DSAppend(dStr, (v?""true"":""false""), NULL); return; } } #ifdef __WIN32 snprintf(nbuf, sizeof(nbuf), ""%"" PRId64, (Jsi_Wide)v); #else snprintf(nbuf, sizeof(nbuf), ""%lld"", v); #endif Jsi_DSAppend(dStr, nbuf, NULL); return; } case SQLITE_FLOAT: { Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf)); Jsi_DSAppend(dStr, nbuf, NULL); return; } case SQLITE_NULL: { return; } } const char *str = (char*)sqlite3_column_text(pStmt, iCol ); if (!str) str = p->jdb->optPtr->nullvalue; Jsi_DSAppend(dStr, str?str:"""", NULL); }"
55,3180----CWE-755----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip6_fib.c----fib6_rule_lookup,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6, const struct sk_buff *skb, int flags, pol_lookup_t lookup) { struct rt6_info *rt; rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags); if (rt->dst.error == -EAGAIN) { ip6_rt_put_flags(rt, flags); rt = net->ipv6.ip6_null_entry; <S2SV_StartVul> if (!(flags | RT6_LOOKUP_F_DST_NOREF)) <S2SV_EndVul> dst_hold(&rt->dst); } return &rt->dst; }","- if (!(flags | RT6_LOOKUP_F_DST_NOREF))
+ if (!(flags & RT6_LOOKUP_F_DST_NOREF))","struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6, const struct sk_buff *skb, int flags, pol_lookup_t lookup) { struct rt6_info *rt; rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags); if (rt->dst.error == -EAGAIN) { ip6_rt_put_flags(rt, flags); rt = net->ipv6.ip6_null_entry; if (!(flags & RT6_LOOKUP_F_DST_NOREF)) dst_hold(&rt->dst); } return &rt->dst; }"
56,353--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-1767--ip_gre.c----ipgre_fini,"static void __exit ipgre_fini(void) { rtnl_link_unregister(&ipgre_tap_ops); rtnl_link_unregister(&ipgre_link_ops); <S2SV_StartVul> unregister_pernet_device(&ipgre_net_ops); <S2SV_EndVul> if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) printk(KERN_INFO ""ipgre close: can't remove protocol\n""); }","- unregister_pernet_device(&ipgre_net_ops);
+ unregister_pernet_device(&ipgre_net_ops);","static void __exit ipgre_fini(void) { rtnl_link_unregister(&ipgre_tap_ops); rtnl_link_unregister(&ipgre_link_ops); if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) printk(KERN_INFO ""ipgre close: can't remove protocol\n""); unregister_pernet_device(&ipgre_net_ops); }"
57,6225----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ls.c----listdir,"static void listdir(unsigned int depth, int f, void * const tls_fd, const char *name) { PureFileInfo *dir; char *names; PureFileInfo *s; PureFileInfo *r; int d; if (depth >= max_ls_depth || matches >= max_ls_files) { return; } if ((dir = sreaddir(&names)) == NULL) { addreply(226, MSG_CANT_READ_FILE, name); return; } s = dir; while (s->name_offset != (size_t) -1) { d = 0; if (FI_NAME(s)[0] != '.') { d = listfile(s, NULL); } else if (opt_a) { if (FI_NAME(s)[1] == 0 || (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) { listfile(s, NULL); } else { d = listfile(s, NULL); } } if (!d) { s->name_offset = (size_t) -1; } s++; } outputfiles(f, tls_fd); r = dir; while (opt_R && r != s) { if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) { <S2SV_StartVul> char *alloca_subdir; <S2SV_EndVul> <S2SV_StartVul> const size_t sizeof_subdir = PATH_MAX + 1U; <S2SV_EndVul> <S2SV_StartVul> if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) { <S2SV_EndVul> <S2SV_StartVul> goto toomany; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"", name, FI_NAME(r)), sizeof_subdir)) { goto nolist; } wrstr(f, tls_fd, ""\r\n\r\n""); wrstr(f, tls_fd, alloca_subdir); wrstr(f, tls_fd, "":\r\n\r\n""); listdir(depth + 1U, f, tls_fd, alloca_subdir); nolist: <S2SV_StartVul> ALLOCA_FREE(alloca_subdir); <S2SV_EndVul> if (matches >= max_ls_files) { goto toomany; } if (chdir("".."")) { if (chdir(wd) || chdir(name)) { die(421, LOG_ERR, ""chdir: %s"", strerror(errno)); } } } r++; } toomany: free(names); free(dir); names = NULL; }","- char *alloca_subdir;
- const size_t sizeof_subdir = PATH_MAX + 1U;
- if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
- goto toomany;
- }
- ALLOCA_FREE(alloca_subdir);
+ char *alloca_subdir;
+ size_t sizeof_subdir;
+ sizeof_subdir = PATH_MAX + 1U;
+ if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {
+ goto toomany;
+ }
+ ALLOCA_FREE(alloca_subdir);","static void listdir(unsigned int depth, int f, void * const tls_fd, const char *name) { PureFileInfo *dir; char *names; PureFileInfo *s; PureFileInfo *r; char *alloca_subdir; size_t sizeof_subdir; int d; if (depth >= max_ls_depth || matches >= max_ls_files) { return; } if ((dir = sreaddir(&names)) == NULL) { addreply(226, MSG_CANT_READ_FILE, name); return; } s = dir; while (s->name_offset != (size_t) -1) { d = 0; if (FI_NAME(s)[0] != '.') { d = listfile(s, NULL); } else if (opt_a) { if (FI_NAME(s)[1] == 0 || (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) { listfile(s, NULL); } else { d = listfile(s, NULL); } } if (!d) { s->name_offset = (size_t) -1; } s++; } outputfiles(f, tls_fd); r = dir; sizeof_subdir = PATH_MAX + 1U; if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) { goto toomany; } while (opt_R && r != s) { if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) { if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, ""%s/%s"", name, FI_NAME(r)), sizeof_subdir)) { goto nolist; } wrstr(f, tls_fd, ""\r\n\r\n""); wrstr(f, tls_fd, alloca_subdir); wrstr(f, tls_fd, "":\r\n\r\n""); listdir(depth + 1U, f, tls_fd, alloca_subdir); nolist: if (matches >= max_ls_files) { goto toomany; } if (chdir("".."")) { if (chdir(wd) || chdir(name)) { die(421, LOG_ERR, ""chdir: %s"", strerror(errno)); } } } r++; } toomany: ALLOCA_FREE(alloca_subdir); free(names); free(dir); names = NULL; }"
58,2527----CWE-269----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5940--fs_home.c----skel,"static void skel(const char *homedir, uid_t u, gid_t g) { char *fname; if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) { if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1) errExit(""asprintf""); struct stat s; if (stat(fname, &s) == 0) return; if (stat(""/etc/skel/.zshrc"", &s) == 0) { if (copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644) == 0) { fs_logger(""clone /etc/skel/.zshrc""); } <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_StartVul> FILE *fp = fopen(fname, ""w""); <S2SV_EndVul> if (fp) { <S2SV_StartVul> fprintf(fp, ""\n""); <S2SV_EndVul> <S2SV_StartVul> SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR); <S2SV_EndVul> <S2SV_StartVul> fclose(fp); <S2SV_EndVul> <S2SV_StartVul> fs_logger2(""touch"", fname); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> free(fname); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) { if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1) errExit(""asprintf""); struct stat s; if (stat(fname, &s) == 0) return; if (stat(""/etc/skel/.cshrc"", &s) == 0) { if (copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644) == 0) { fs_logger(""clone /etc/skel/.cshrc""); } } else { <S2SV_StartVul> FILE *fp = fopen(fname, ""w""); <S2SV_EndVul> <S2SV_StartVul> if (fp) { <S2SV_EndVul> <S2SV_StartVul> fprintf(fp, ""\n""); <S2SV_EndVul> SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR); <S2SV_StartVul> fclose(fp); <S2SV_EndVul> fs_logger2(""touch"", fname); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> free(fname); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_EndVul> <S2SV_StartVul> if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1) <S2SV_EndVul> <S2SV_StartVul> errExit(""asprintf""); <S2SV_EndVul> struct stat s; if (stat(fname, &s) == 0) return; if (stat(""/etc/skel/.bashrc"", &s) == 0) { if (copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644) == 0) { fs_logger(""clone /etc/skel/.bashrc""); } } free(fname); } }","- }
- else { //
- FILE *fp = fopen(fname, ""w"");
- fprintf(fp, ""\n"");
- SET_PERMS_STREAM(fp, u, g, S_IRUSR | S_IWUSR);
- fclose(fp);
- fs_logger2(""touch"", fname);
- }
- }
- free(fname);
- }
- FILE *fp = fopen(fname, ""w"");
- if (fp) {
- fprintf(fp, ""\n"");
- fclose(fp);
- }
- }
- free(fname);
- }
- else {
- if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
- errExit(""asprintf"");
+ else {
+ touch_file_as_user(fname, u, g, 0644);
+ }
+ free(fname);
+ }
+ }
+ free(fname);
+ else {
+ if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
+ errExit(""asprintf"");","static void skel(const char *homedir, uid_t u, gid_t g) { char *fname; if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) { if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1) errExit(""asprintf""); struct stat s; if (stat(fname, &s) == 0) return; if (stat(""/etc/skel/.zshrc"", &s) == 0) { copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644); fs_logger(""clone /etc/skel/.zshrc""); } else { touch_file_as_user(fname, u, g, 0644); fs_logger2(""touch"", fname); } free(fname); } else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) { if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1) errExit(""asprintf""); struct stat s; if (stat(fname, &s) == 0) return; if (stat(""/etc/skel/.cshrc"", &s) == 0) { copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644); fs_logger(""clone /etc/skel/.cshrc""); } else { touch_file_as_user(fname, u, g, 0644); fs_logger2(""touch"", fname); } free(fname); } else { if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1) errExit(""asprintf""); struct stat s; if (stat(fname, &s) == 0) return; if (stat(""/etc/skel/.bashrc"", &s) == 0) { copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644); fs_logger(""clone /etc/skel/.bashrc""); } free(fname); } }"
59,5205----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mqtt_sn_client_message.c----mqttSnClientSendUnsubscribe,"error_t mqttSnClientSendUnsubscribe(MqttSnClientContext *context, const char_t *topicName) { error_t error; systime_t time; uint16_t topicId; MqttSnFlags flags; error = NO_ERROR; flags.all = 0; topicId = mqttSnClientFindPredefTopicName(context, topicName); if(topicId != MQTT_SN_INVALID_TOPIC_ID) { flags.topicIdType = MQTT_SN_PREDEFINED_TOPIC_ID; } else { <S2SV_StartVul> if(osStrlen(topicName) == 2 && strchr(topicName, '#') == NULL && <S2SV_EndVul> <S2SV_StartVul> strchr(topicName, '+') == NULL) <S2SV_EndVul> { flags.topicIdType = MQTT_SN_SHORT_TOPIC_NAME; } else { flags.topicIdType = MQTT_SN_NORMAL_TOPIC_NAME; } error = mqttSnFormatUnsubscribe(&context->message, flags, context->msgId, topicId, topicName); } if(!error) { TRACE_INFO(""Sending UNSUBSCRIBE message (%"" PRIuSIZE "" bytes)...\r\n"", context->message.length); mqttSnDumpMessage(context->message.buffer, context->message.length); error = mqttSnClientSendDatagram(context, context->message.buffer, context->message.length); time = osGetSystemTime(); context->retransmitStartTime = time; context->keepAliveTimestamp = time; context->state = MQTT_SN_CLIENT_STATE_SENDING_REQ; context->msgType = MQTT_SN_MSG_TYPE_UNSUBSCRIBE; } return error; }","- if(osStrlen(topicName) == 2 && strchr(topicName, '#') == NULL &&
- strchr(topicName, '+') == NULL)
+ if(osStrlen(topicName) == 2 && osStrchr(topicName, '#') == NULL &&
+ osStrchr(topicName, '+') == NULL)","error_t mqttSnClientSendUnsubscribe(MqttSnClientContext *context, const char_t *topicName) { error_t error; systime_t time; uint16_t topicId; MqttSnFlags flags; error = NO_ERROR; flags.all = 0; topicId = mqttSnClientFindPredefTopicName(context, topicName); if(topicId != MQTT_SN_INVALID_TOPIC_ID) { flags.topicIdType = MQTT_SN_PREDEFINED_TOPIC_ID; } else { if(osStrlen(topicName) == 2 && osStrchr(topicName, '#') == NULL && osStrchr(topicName, '+') == NULL) { flags.topicIdType = MQTT_SN_SHORT_TOPIC_NAME; } else { flags.topicIdType = MQTT_SN_NORMAL_TOPIC_NAME; } error = mqttSnFormatUnsubscribe(&context->message, flags, context->msgId, topicId, topicName); } if(!error) { TRACE_INFO(""Sending UNSUBSCRIBE message (%"" PRIuSIZE "" bytes)...\r\n"", context->message.length); mqttSnDumpMessage(context->message.buffer, context->message.length); error = mqttSnClientSendDatagram(context, context->message.buffer, context->message.length); time = osGetSystemTime(); context->retransmitStartTime = time; context->keepAliveTimestamp = time; context->state = MQTT_SN_CLIENT_STATE_SENDING_REQ; context->msgType = MQTT_SN_MSG_TYPE_UNSUBSCRIBE; } return error; }"
60,2678----CWE-674----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/asn1_encode.c----decode_atype,"decode_atype(const taginfo *t, const uint8_t *asn1, size_t len, const struct atype_info *a, void *val) { krb5_error_code ret; switch (a->type) { case atype_fn: { const struct fn_info *fn = a->tinfo; assert(fn->dec != NULL); return fn->dec(t, asn1, len, val); } case atype_sequence: return decode_sequence(asn1, len, a->tinfo, val); case atype_ptr: { const struct ptr_info *ptrinfo = a->tinfo; void *ptr = LOADPTR(val, ptrinfo); assert(ptrinfo->basetype != NULL); if (ptr != NULL) { return decode_atype(t, asn1, len, ptrinfo->basetype, ptr); } else { ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr); if (ret) return ret; STOREPTR(ptr, ptrinfo, val); break; } } case atype_offset: { const struct offset_info *off = a->tinfo; assert(off->basetype != NULL); return decode_atype(t, asn1, len, off->basetype, (char *)val + off->dataoff); } case atype_optional: { const struct optional_info *opt = a->tinfo; return decode_atype(t, asn1, len, opt->basetype, val); } case atype_counted: { const struct counted_info *counted = a->tinfo; void *dataptr = (char *)val + counted->dataoff; size_t count; assert(counted->basetype != NULL); ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count); if (ret) return ret; return store_count(count, counted, val); } case atype_tagged_thing: { const struct tagged_info *tag = a->tinfo; taginfo inner_tag; const taginfo *tp = t; const uint8_t *rem; size_t rlen; if (!tag->implicit) { <S2SV_StartVul> ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen); <S2SV_EndVul> if (ret) return ret; tp = &inner_tag; if (!check_atype_tag(tag->basetype, tp)) return ASN1_BAD_ID; } return decode_atype(tp, asn1, len, tag->basetype, val); } case atype_bool: { intmax_t intval; ret = k5_asn1_decode_bool(asn1, len, &intval); if (ret) return ret; return store_int(intval, a->size, val); } case atype_int: { intmax_t intval; ret = k5_asn1_decode_int(asn1, len, &intval); if (ret) return ret; return store_int(intval, a->size, val); } case atype_uint: { uintmax_t intval; ret = k5_asn1_decode_uint(asn1, len, &intval); if (ret) return ret; return store_uint(intval, a->size, val); } case atype_int_immediate: { const struct immediate_info *imm = a->tinfo; intmax_t intval; ret = k5_asn1_decode_int(asn1, len, &intval); if (ret) return ret; if (intval != imm->val && imm->err != 0) return imm->err; break; } default: assert(a->type != atype_nullterm_sequence_of); assert(a->type != atype_nonempty_nullterm_sequence_of); assert(a->type > atype_min); assert(a->type < atype_max); abort(); } return 0; }","- ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen);
+ ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0);","decode_atype(const taginfo *t, const uint8_t *asn1, size_t len, const struct atype_info *a, void *val) { krb5_error_code ret; switch (a->type) { case atype_fn: { const struct fn_info *fn = a->tinfo; assert(fn->dec != NULL); return fn->dec(t, asn1, len, val); } case atype_sequence: return decode_sequence(asn1, len, a->tinfo, val); case atype_ptr: { const struct ptr_info *ptrinfo = a->tinfo; void *ptr = LOADPTR(val, ptrinfo); assert(ptrinfo->basetype != NULL); if (ptr != NULL) { return decode_atype(t, asn1, len, ptrinfo->basetype, ptr); } else { ret = decode_atype_to_ptr(t, asn1, len, ptrinfo->basetype, &ptr); if (ret) return ret; STOREPTR(ptr, ptrinfo, val); break; } } case atype_offset: { const struct offset_info *off = a->tinfo; assert(off->basetype != NULL); return decode_atype(t, asn1, len, off->basetype, (char *)val + off->dataoff); } case atype_optional: { const struct optional_info *opt = a->tinfo; return decode_atype(t, asn1, len, opt->basetype, val); } case atype_counted: { const struct counted_info *counted = a->tinfo; void *dataptr = (char *)val + counted->dataoff; size_t count; assert(counted->basetype != NULL); ret = decode_cntype(t, asn1, len, counted->basetype, dataptr, &count); if (ret) return ret; return store_count(count, counted, val); } case atype_tagged_thing: { const struct tagged_info *tag = a->tinfo; taginfo inner_tag; const taginfo *tp = t; const uint8_t *rem; size_t rlen; if (!tag->implicit) { ret = get_tag(asn1, len, &inner_tag, &asn1, &len, &rem, &rlen, 0); if (ret) return ret; tp = &inner_tag; if (!check_atype_tag(tag->basetype, tp)) return ASN1_BAD_ID; } return decode_atype(tp, asn1, len, tag->basetype, val); } case atype_bool: { intmax_t intval; ret = k5_asn1_decode_bool(asn1, len, &intval); if (ret) return ret; return store_int(intval, a->size, val); } case atype_int: { intmax_t intval; ret = k5_asn1_decode_int(asn1, len, &intval); if (ret) return ret; return store_int(intval, a->size, val); } case atype_uint: { uintmax_t intval; ret = k5_asn1_decode_uint(asn1, len, &intval); if (ret) return ret; return store_uint(intval, a->size, val); } case atype_int_immediate: { const struct immediate_info *imm = a->tinfo; intmax_t intval; ret = k5_asn1_decode_int(asn1, len, &intval); if (ret) return ret; if (intval != imm->val && imm->err != 0) return imm->err; break; } default: assert(a->type != atype_nullterm_sequence_of); assert(a->type != atype_nonempty_nullterm_sequence_of); assert(a->type > atype_min); assert(a->type < atype_max); abort(); } return 0; }"
61,2029----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-11595--jslex.c----jslGetTokenString,"void jslGetTokenString(char *str, size_t len) { if (lex->tk == LEX_ID) { <S2SV_StartVul> strncpy(str, ""ID:"", len); <S2SV_EndVul> <S2SV_StartVul> strncat(str, jslGetTokenValueAsString(), len); <S2SV_EndVul> } else if (lex->tk == LEX_STR) { <S2SV_StartVul> strncpy(str, ""String:'"", len); <S2SV_EndVul> <S2SV_StartVul> strncat(str, jslGetTokenValueAsString(), len); <S2SV_EndVul> <S2SV_StartVul> strncat(str, ""'"", len); <S2SV_EndVul> } else jslTokenAsString(lex->tk, str, len); }","- strncpy(str, ""ID:"", len);
- strncat(str, jslGetTokenValueAsString(), len);
- strncpy(str, ""String:'"", len);
- strncat(str, jslGetTokenValueAsString(), len);
- strncat(str, ""'"", len);
+ espruino_snprintf(str, len, ""ID:%s"", jslGetTokenValueAsString());
+ espruino_snprintf(str, len, ""String:'%s'"", jslGetTokenValueAsString());","void jslGetTokenString(char *str, size_t len) { if (lex->tk == LEX_ID) { espruino_snprintf(str, len, ""ID:%s"", jslGetTokenValueAsString()); } else if (lex->tk == LEX_STR) { espruino_snprintf(str, len, ""String:'%s'"", jslGetTokenValueAsString()); } else jslTokenAsString(lex->tk, str, len); }"
62,4724----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/function.cc----tensorflow::FunctionInstantiationHelper::BuildInputArgIndex,"Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values, const FunctionDef::ArgAttrs* arg_attrs, bool ints_on_device, int64_t resource_arg_unique_id) { bool is_type_list; DataTypeVector dtypes; TF_RETURN_IF_ERROR( ArgNumType(attr_values, arg_def, &is_type_list, &dtypes)); if (dtypes.size() < size_t{1}) { return errors::Internal(""Expected a list of at least one dtype""); } int arg_index = result_.nodes.size(); TF_RETURN_IF_ERROR( AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes})); for (size_t i = 0; i < dtypes.size(); ++i) { TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), "":"", i), {true, arg_index, 0, false, {dtypes[i]}})); <S2SV_StartVul> DCHECK_EQ(arg_index, result_.nodes.size()); <S2SV_EndVul> string name = arg_def.name(); if (dtypes.size() > 1) { strings::StrAppend(&name, ""_"", i); } NodeDef* gnode = AddNode(name); if (ints_on_device && dtypes[i] == DataType::DT_INT32) { gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp); } else { gnode->set_op(FunctionLibraryDefinition::kArgOp); } DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i]; AddAttr(""T"", dtype, gnode); AddAttr(""index"", arg_index, gnode); if (resource_arg_unique_id >= 0) { AddAttr(""_resource_arg_unique_id"", resource_arg_unique_id, gnode); } if (arg_attrs) { for (const auto& arg_attr : arg_attrs->attr()) { AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr()); } } result_.arg_types.push_back(dtypes[i]); ++arg_index; } return Status::OK(); }","- DCHECK_EQ(arg_index, result_.nodes.size());
+ if (arg_index != result_.nodes.size()) {
+ return errors::Internal(
+ ""Expected arg_index to be equal to the number of nodes in result."",
+ "" Got "", arg_index, "" and "", result_.nodes.size());
+ }","Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values, const FunctionDef::ArgAttrs* arg_attrs, bool ints_on_device, int64_t resource_arg_unique_id) { bool is_type_list; DataTypeVector dtypes; TF_RETURN_IF_ERROR( ArgNumType(attr_values, arg_def, &is_type_list, &dtypes)); if (dtypes.size() < size_t{1}) { return errors::Internal(""Expected a list of at least one dtype""); } int arg_index = result_.nodes.size(); TF_RETURN_IF_ERROR( AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes})); for (size_t i = 0; i < dtypes.size(); ++i) { TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), "":"", i), {true, arg_index, 0, false, {dtypes[i]}})); if (arg_index != result_.nodes.size()) { return errors::Internal( ""Expected arg_index to be equal to the number of nodes in result."", "" Got "", arg_index, "" and "", result_.nodes.size()); } string name = arg_def.name(); if (dtypes.size() > 1) { strings::StrAppend(&name, ""_"", i); } NodeDef* gnode = AddNode(name); if (ints_on_device && dtypes[i] == DataType::DT_INT32) { gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp); } else { gnode->set_op(FunctionLibraryDefinition::kArgOp); } DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i]; AddAttr(""T"", dtype, gnode); AddAttr(""index"", arg_index, gnode); if (resource_arg_unique_id >= 0) { AddAttr(""_resource_arg_unique_id"", resource_arg_unique_id, gnode); } if (arg_attrs) { for (const auto& arg_attr : arg_attrs->attr()) { AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr()); } } result_.arg_types.push_back(dtypes[i]); ++arg_index; } return Status::OK(); }"
63,617----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-6396--ec_postgresql.c----FUNC_DECODER,"FUNC_DECODER(dissector_postgresql) { DECLARE_DISP_PTR(ptr); struct ec_session *s = NULL; void *ident = NULL; char tmp[MAX_ASCII_ADDR_LEN]; struct postgresql_status *conn_status; (void) DECODE_DATA; (void) DECODE_DATALEN; (void) DECODED_LEN; if (FROM_CLIENT(""postgresql"", PACKET)) { if (PACKET->DATA.len < 4) return NULL; dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql)); if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) { unsigned char *u = memmem(ptr, PACKET->DATA.len, ""user"", 4); unsigned char *d = memmem(ptr, PACKET->DATA.len, ""database"", 8); if (!memcmp(ptr + 4, ""\x00\x03\x00\x00"", 4) && u && d) { dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql)); SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status)); conn_status = (struct postgresql_status *) s->data; conn_status->status = WAIT_AUTH; strncpy((char*)conn_status->user, (char*)(u + 5), 65); conn_status->user[64] = 0; strncpy((char*)conn_status->database, (char*)(d + 9), 65); conn_status->database[64] = 0; session_put(s); } } else { conn_status = (struct postgresql_status *) s->data; if (conn_status->status == WAIT_RESPONSE) { if (ptr[0] == 'p' && conn_status->type == MD5) { DEBUG_MSG(""\tDissector_postgresql RESPONSE type is MD5""); if(memcmp(ptr + 1, ""\x00\x00\x00\x28"", 4)) { DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40""); return NULL; } if (PACKET->DATA.len < 40) { DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40""); return NULL; } memcpy(conn_status->hash, ptr + 5 + 3, 32); conn_status->hash[32] = 0; DISSECT_MSG(""%s:$postgres$%s*%s*%s:%s:%d\n"", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst)); dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql)); } else if (ptr[0] == 'p' && conn_status->type == CT) { int length; DEBUG_MSG(""\tDissector_postgresql RESPONSE type is clear-text!""); GET_ULONG_BE(length, ptr, 1); strncpy((char*)conn_status->password, (char*)(ptr + 5), length - 4); conn_status->password[length - 4] = 0; DISSECT_MSG(""PostgreSQL credentials:%s-%d:%s:%s\n"", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password); dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql)); } } } } else { if (PACKET->DATA.len < 9) return NULL; dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql)); if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) { conn_status = (struct postgresql_status *) s->data; if (conn_status->status == WAIT_AUTH && ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x0c"", 4) && !memcmp(ptr + 5, ""\x00\x00\x00\x05"", 4)) { conn_status->status = WAIT_RESPONSE; conn_status->type = MD5; DEBUG_MSG(""\tDissector_postgresql AUTH type is MD5""); hex_encode(ptr + 9, 4, conn_status->salt); } else if (conn_status->status == WAIT_AUTH && ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x08"", 4) && !memcmp(ptr + 5, ""\x00\x00\x00\x03"", 4)) { conn_status->status = WAIT_RESPONSE; conn_status->type = CT; DEBUG_MSG(""\tDissector_postgresql AUTH type is clear-text!""); } } } SAFE_FREE(ident); <S2SV_StartVul> return NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- return NULL;
- }
+ }
+ }
+ 
+ SAFE_FREE(ident);
+ return NULL;
+ }","FUNC_DECODER(dissector_postgresql) { DECLARE_DISP_PTR(ptr); struct ec_session *s = NULL; void *ident = NULL; char tmp[MAX_ASCII_ADDR_LEN]; struct postgresql_status *conn_status; (void) DECODE_DATA; (void) DECODE_DATALEN; (void) DECODED_LEN; if (FROM_CLIENT(""postgresql"", PACKET)) { if (PACKET->DATA.len < 4) return NULL; dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql)); if (session_get(&s, ident, DISSECT_IDENT_LEN) == -ENOTFOUND) { unsigned char *u = memmem(ptr, PACKET->DATA.len, ""user"", 4); unsigned char *d = memmem(ptr, PACKET->DATA.len, ""database"", 8); if (!memcmp(ptr + 4, ""\x00\x03\x00\x00"", 4) && u && d) { dissect_create_session(&s, PACKET, DISSECT_CODE(dissector_postgresql)); SAFE_CALLOC(s->data, 1, sizeof(struct postgresql_status)); conn_status = (struct postgresql_status *) s->data; conn_status->status = WAIT_AUTH; strncpy((char*)conn_status->user, (char*)(u + 5), 65); conn_status->user[64] = 0; strncpy((char*)conn_status->database, (char*)(d + 9), 65); conn_status->database[64] = 0; session_put(s); } } else { conn_status = (struct postgresql_status *) s->data; if (conn_status->status == WAIT_RESPONSE) { if (ptr[0] == 'p' && conn_status->type == MD5) { DEBUG_MSG(""\tDissector_postgresql RESPONSE type is MD5""); if(memcmp(ptr + 1, ""\x00\x00\x00\x28"", 4)) { DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40""); return NULL; } if (PACKET->DATA.len < 40) { DEBUG_MSG(""\tDissector_postgresql BUG, expected length is 40""); return NULL; } memcpy(conn_status->hash, ptr + 5 + 3, 32); conn_status->hash[32] = 0; DISSECT_MSG(""%s:$postgres$%s*%s*%s:%s:%d\n"", conn_status->user, conn_status->user, conn_status->salt, conn_status->hash, ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst)); dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql)); } else if (ptr[0] == 'p' && conn_status->type == CT) { int length; DEBUG_MSG(""\tDissector_postgresql RESPONSE type is clear-text!""); GET_ULONG_BE(length, ptr, 1); length -= 4; if (length < 0 || length > 65 || PACKET->DATA.len < length+5) { dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql)); return NULL; } snprintf((char*)conn_status->password, length+1, ""%s"", (char*)(ptr + 5)); DISSECT_MSG(""PostgreSQL credentials:%s-%d:%s:%s\n"", ip_addr_ntoa(&PACKET->L3.dst, tmp), ntohs(PACKET->L4.dst), conn_status->user, conn_status->password); dissect_wipe_session(PACKET, DISSECT_CODE(dissector_postgresql)); } } } } else { if (PACKET->DATA.len < 9) return NULL; dissect_create_ident(&ident, PACKET, DISSECT_CODE(dissector_postgresql)); if (session_get(&s, ident, DISSECT_IDENT_LEN) == ESUCCESS) { conn_status = (struct postgresql_status *) s->data; if (conn_status->status == WAIT_AUTH && ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x0c"", 4) && !memcmp(ptr + 5, ""\x00\x00\x00\x05"", 4)) { conn_status->status = WAIT_RESPONSE; conn_status->type = MD5; DEBUG_MSG(""\tDissector_postgresql AUTH type is MD5""); hex_encode(ptr + 9, 4, conn_status->salt); } else if (conn_status->status == WAIT_AUTH && ptr[0] == 'R' && !memcmp(ptr + 1, ""\x00\x00\x00\x08"", 4) && !memcmp(ptr + 5, ""\x00\x00\x00\x03"", 4)) { conn_status->status = WAIT_RESPONSE; conn_status->type = CT; DEBUG_MSG(""\tDissector_postgresql AUTH type is clear-text!""); } } } SAFE_FREE(ident); return NULL; }"
64,1842----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8900--hdr.c----*ReadHDRImage,"static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception) { char format[MaxTextExtent], keyword[MaxTextExtent], tag[MaxTextExtent], value[MaxTextExtent]; double gamma; Image *image; int c; MagickBooleanType status, value_expected; register Quantum *q; register ssize_t i, x; register unsigned char *p; ssize_t count, y; unsigned char *end, pixel[4], *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } image->columns=0; image->rows=0; *format='\0'; c=ReadBlobByte(image); if (c == EOF) { image=DestroyImage(image); return((Image *) NULL); } while (isgraph(c) && (image->columns == 0) && (image->rows == 0)) { if (c == (int) '#') { char *comment; register char *p; size_t length; length=MaxTextExtent; comment=AcquireString((char *) NULL); for (p=comment; comment != (char *) NULL; p++) { c=ReadBlobByte(image); if ((c == EOF) || (c == (int) '\n')) break; if ((size_t) (p-comment+1) >= length) { *p='\0'; length<<=1; comment=(char *) ResizeQuantumMemory(comment,length+ MaxTextExtent,sizeof(*comment)); if (comment == (char *) NULL) break; p=comment+strlen(comment); } *p=(char) c; } if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); *p='\0'; (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); c=ReadBlobByte(image); } else if (isalnum(c) == MagickFalse) c=ReadBlobByte(image); else { register char *p; p=keyword; do { if ((size_t) (p-keyword) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); } while (isalnum(c) || (c == '_')); *p='\0'; value_expected=MagickFalse; while ((isspace((int) ((unsigned char) c)) != 0) || (c == '=')) { if (c == '=') value_expected=MagickTrue; c=ReadBlobByte(image); } if (LocaleCompare(keyword,""Y"") == 0) value_expected=MagickTrue; if (value_expected == MagickFalse) continue; p=value; while ((c != '\n') && (c != '\0')) { if ((size_t) (p-value) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); <S2SV_StartVul> } <S2SV_EndVul> *p='\0'; switch (*keyword) { case 'F': case 'f': { if (LocaleCompare(keyword,""format"") == 0) { (void) CopyMagickString(format,value,MaxTextExtent); break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'G': case 'g': { if (LocaleCompare(keyword,""gamma"") == 0) { image->gamma=StringToDouble(value,(char **) NULL); break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'P': case 'p': { if (LocaleCompare(keyword,""primaries"") == 0) { float chromaticity[6], white_point[2]; (void) sscanf(value,""%g %g %g %g %g %g %g %g"", &chromaticity[0],&chromaticity[1],&chromaticity[2], &chromaticity[3],&chromaticity[4],&chromaticity[5], &white_point[0],&white_point[1]); image->chromaticity.red_primary.x=chromaticity[0]; <S2SV_StartVul> image->chromaticity.red_primary.y=chromaticity[1]; <S2SV_EndVul> <S2SV_StartVul> image->chromaticity.green_primary.x=chromaticity[2]; <S2SV_EndVul> <S2SV_StartVul> image->chromaticity.green_primary.y=chromaticity[3]; <S2SV_EndVul> <S2SV_StartVul> image->chromaticity.blue_primary.x=chromaticity[4]; <S2SV_EndVul> <S2SV_StartVul> image->chromaticity.blue_primary.y=chromaticity[5]; <S2SV_EndVul> <S2SV_StartVul> image->chromaticity.white_point.x=white_point[0], <S2SV_EndVul> <S2SV_StartVul> image->chromaticity.white_point.y=white_point[1]; <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); <S2SV_EndVul> <S2SV_StartVul> (void) SetImageProperty(image,tag,value,exception); <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> } case 'Y': case 'y': { char target[] = ""Y""; if (strcmp(keyword,target) == 0) { int height, width; (void) sscanf(value,""%d +X %d"",&height,&width); image->columns=(size_t) width; image->rows=(size_t) height; break; } <S2SV_StartVul> (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); <S2SV_EndVul> <S2SV_StartVul> (void) SetImageProperty(image,tag,value,exception); <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> } default: { (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } } } if ((image->columns == 0) && (image->rows == 0)) while (isspace((int) ((unsigned char) c)) != 0) c=ReadBlobByte(image); } if ((LocaleCompare(format,""32-bit_rle_rgbe"") != 0) && (LocaleCompare(format,""32-bit_rle_xyze"") != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((image->columns == 0) || (image->rows == 0)) ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize""); (void) SetImageColorspace(image,RGBColorspace,exception); if (LocaleCompare(format,""32-bit_rle_xyze"") == 0) (void) SetImageColorspace(image,XYZColorspace,exception); image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ? NoCompression : RLECompression; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4* sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (y=0; y < (ssize_t) image->rows; y++) { if (image->compression != RLECompression) { count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels); if (count != (ssize_t) (4*image->columns*sizeof(*pixels))) break; } else { count=ReadBlob(image,4*sizeof(*pixel),pixel); if (count != 4) break; if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns) { (void) memcpy(pixels,pixel,4*sizeof(*pixel)); count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4); image->compression=NoCompression; } else { p=pixels; for (i=0; i < 4; i++) { end=&pixels[(i+1)*image->columns]; while (p < end) { count=ReadBlob(image,2*sizeof(*pixel),pixel); if (count < 1) break; if (pixel[0] > 128) { count=(ssize_t) pixel[0]-128; if ((count == 0) || (count > (ssize_t) (end-p))) break; while (count-- > 0) *p++=pixel[1]; } else { count=(ssize_t) pixel[0]; if ((count == 0) || (count > (ssize_t) (end-p))) break; *p++=pixel[1]; if (--count > 0) { count=ReadBlob(image,(size_t) count*sizeof(*p),p); if (count < 1) break; p+=count; } } } } } } q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; i=0; for (x=0; x < (ssize_t) image->columns; x++) { if (image->compression == RLECompression) { pixel[0]=pixels[x]; pixel[1]=pixels[x+image->columns]; pixel[2]=pixels[x+2*image->columns]; pixel[3]=pixels[x+3*image->columns]; } else { pixel[0]=pixels[i++]; pixel[1]=pixels[i++]; pixel[2]=pixels[i++]; pixel[3]=pixels[i++]; } SetPixelRed(image,0,q); SetPixelGreen(image,0,q); SetPixelBlue(image,0,q); if (pixel[3] != 0) { gamma=pow(2.0,pixel[3]-(128.0+8.0)); SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q); SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q); SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q); } q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } pixels=(unsigned char *) RelinquishMagickMemory(pixels); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); }","- }
- image->chromaticity.red_primary.y=chromaticity[1];
- image->chromaticity.green_primary.x=chromaticity[2];
- image->chromaticity.green_primary.y=chromaticity[3];
- image->chromaticity.blue_primary.x=chromaticity[4];
- image->chromaticity.blue_primary.y=chromaticity[5];
- image->chromaticity.white_point.x=white_point[0],
- image->chromaticity.white_point.y=white_point[1];
- break;
- }
- (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword);
- (void) SetImageProperty(image,tag,value,exception);
- break;
- (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword);
- (void) SetImageProperty(image,tag,value,exception);
- break;
+ image->chromaticity.blue_primary.x=chromaticity[4];
+ image->chromaticity.blue_primary.y=chromaticity[5];
+ image->chromaticity.white_point.x=white_point[0],
+ image->chromaticity.white_point.y=white_point[1];
+ }
+ break;
+ }
+ (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword);
+ (void) SetImageProperty(image,tag,value,exception);
+ break;
+ }
+ case 'Y':
+ case 'y':
+ {
+ break;
+ }
+ default:
+ {
+ (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword);","static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception) { char format[MaxTextExtent], keyword[MaxTextExtent], tag[MaxTextExtent], value[MaxTextExtent]; double gamma; Image *image; int c; MagickBooleanType status, value_expected; register Quantum *q; register ssize_t i, x; register unsigned char *p; ssize_t count, y; unsigned char *end, pixel[4], *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } image->columns=0; image->rows=0; *format='\0'; c=ReadBlobByte(image); if (c == EOF) { image=DestroyImage(image); return((Image *) NULL); } while (isgraph(c) && (image->columns == 0) && (image->rows == 0)) { if (c == (int) '#') { char *comment; register char *p; size_t length; length=MaxTextExtent; comment=AcquireString((char *) NULL); for (p=comment; comment != (char *) NULL; p++) { c=ReadBlobByte(image); if ((c == EOF) || (c == (int) '\n')) break; if ((size_t) (p-comment+1) >= length) { *p='\0'; length<<=1; comment=(char *) ResizeQuantumMemory(comment,length+ MaxTextExtent,sizeof(*comment)); if (comment == (char *) NULL) break; p=comment+strlen(comment); } *p=(char) c; } if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); *p='\0'; (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); c=ReadBlobByte(image); } else if (isalnum(c) == MagickFalse) c=ReadBlobByte(image); else { register char *p; p=keyword; do { if ((size_t) (p-keyword) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); } while (isalnum(c) || (c == '_')); *p='\0'; value_expected=MagickFalse; while ((isspace((int) ((unsigned char) c)) != 0) || (c == '=')) { if (c == '=') value_expected=MagickTrue; c=ReadBlobByte(image); } if (LocaleCompare(keyword,""Y"") == 0) value_expected=MagickTrue; if (value_expected == MagickFalse) continue; p=value; while ((c != '\n') && (c != '\0') && (c != EOF)) { if ((size_t) (p-value) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); } *p='\0'; switch (*keyword) { case 'F': case 'f': { if (LocaleCompare(keyword,""format"") == 0) { (void) CopyMagickString(format,value,MaxTextExtent); break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'G': case 'g': { if (LocaleCompare(keyword,""gamma"") == 0) { image->gamma=StringToDouble(value,(char **) NULL); break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'P': case 'p': { if (LocaleCompare(keyword,""primaries"") == 0) { float chromaticity[6], white_point[2]; if (sscanf(value,""%g %g %g %g %g %g %g %g"",&chromaticity[0], &chromaticity[1],&chromaticity[2],&chromaticity[3], &chromaticity[4],&chromaticity[5],&white_point[0], &white_point[1]) == 8) { image->chromaticity.red_primary.x=chromaticity[0]; image->chromaticity.red_primary.y=chromaticity[1]; image->chromaticity.green_primary.x=chromaticity[2]; image->chromaticity.green_primary.y=chromaticity[3]; image->chromaticity.blue_primary.x=chromaticity[4]; image->chromaticity.blue_primary.y=chromaticity[5]; image->chromaticity.white_point.x=white_point[0], image->chromaticity.white_point.y=white_point[1]; } break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'Y': case 'y': { char target[] = ""Y""; if (strcmp(keyword,target) == 0) { int height, width; if (sscanf(value,""%d +X %d"",&height,&width) == 2) { image->columns=(size_t) width; image->rows=(size_t) height; } break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } default: { (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } } } if ((image->columns == 0) && (image->rows == 0)) while (isspace((int) ((unsigned char) c)) != 0) c=ReadBlobByte(image); } if ((LocaleCompare(format,""32-bit_rle_rgbe"") != 0) && (LocaleCompare(format,""32-bit_rle_xyze"") != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((image->columns == 0) || (image->rows == 0)) ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize""); (void) SetImageColorspace(image,RGBColorspace,exception); if (LocaleCompare(format,""32-bit_rle_xyze"") == 0) (void) SetImageColorspace(image,XYZColorspace,exception); image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ? NoCompression : RLECompression; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4* sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (y=0; y < (ssize_t) image->rows; y++) { if (image->compression != RLECompression) { count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels); if (count != (ssize_t) (4*image->columns*sizeof(*pixels))) break; } else { count=ReadBlob(image,4*sizeof(*pixel),pixel); if (count != 4) break; if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns) { (void) memcpy(pixels,pixel,4*sizeof(*pixel)); count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4); image->compression=NoCompression; } else { p=pixels; for (i=0; i < 4; i++) { end=&pixels[(i+1)*image->columns]; while (p < end) { count=ReadBlob(image,2*sizeof(*pixel),pixel); if (count < 1) break; if (pixel[0] > 128) { count=(ssize_t) pixel[0]-128; if ((count == 0) || (count > (ssize_t) (end-p))) break; while (count-- > 0) *p++=pixel[1]; } else { count=(ssize_t) pixel[0]; if ((count == 0) || (count > (ssize_t) (end-p))) break; *p++=pixel[1]; if (--count > 0) { count=ReadBlob(image,(size_t) count*sizeof(*p),p); if (count < 1) break; p+=count; } } } } } } q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; i=0; for (x=0; x < (ssize_t) image->columns; x++) { if (image->compression == RLECompression) { pixel[0]=pixels[x]; pixel[1]=pixels[x+image->columns]; pixel[2]=pixels[x+2*image->columns]; pixel[3]=pixels[x+3*image->columns]; } else { pixel[0]=pixels[i++]; pixel[1]=pixels[i++]; pixel[2]=pixels[i++]; pixel[3]=pixels[i++]; } SetPixelRed(image,0,q); SetPixelGreen(image,0,q); SetPixelBlue(image,0,q); if (pixel[3] != 0) { gamma=pow(2.0,pixel[3]-(128.0+8.0)); SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q); SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q); SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q); } q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } pixels=(unsigned char *) RelinquishMagickMemory(pixels); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
65,1257----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-16357--elf.c----*store_versioninfo_gnu_verdef,"static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { const char *section_name = """"; const char *link_section_name = """"; char *end = NULL; Elf_(Shdr) *link_shdr = NULL; ut8 dfs[sizeof (Elf_(Verdef))] = {0}; Sdb *sdb; int cnt, i; if (shdr->sh_link > bin->ehdr.e_shnum) { return false; } link_shdr = &bin->shdr[shdr->sh_link]; <S2SV_StartVul> if (shdr->sh_size < 1) { <S2SV_EndVul> return false; } Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char)); if (!defs) { return false; } if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!defs) { bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n""); return NULL; } sdb = sdb_new0 (); end = (char *)defs + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) { Sdb *sdb_verdef = sdb_new0 (); char *vstart = ((char*)defs) + i; char key[32] = {0}; Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart; Elf_(Verdaux) aux = {0}; int j = 0; int isum = 0; r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef))); verdef->vd_version = READ16 (dfs, j) verdef->vd_flags = READ16 (dfs, j) verdef->vd_ndx = READ16 (dfs, j) verdef->vd_cnt = READ16 (dfs, j) verdef->vd_hash = READ32 (dfs, j) verdef->vd_aux = READ32 (dfs, j) verdef->vd_next = READ32 (dfs, j) int vdaux = verdef->vd_aux; if (vdaux < 1) { sdb_free (sdb_verdef); goto out_error; } vstart += vdaux; if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); goto out_error; } j = 0; aux.vda_name = READ32 (vstart, j) aux.vda_next = READ32 (vstart, j) isum = i + verdef->vd_aux; if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); goto out_error; } sdb_num_set (sdb_verdef, ""idx"", i, 0); sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0); sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0); sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0); sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0); sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0); for (j = 1; j < verdef->vd_cnt; ++j) { int k; Sdb *sdb_parent = sdb_new0 (); isum += aux.vda_next; vstart += aux.vda_next; if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } k = 0; aux.vda_name = READ32 (vstart, k) aux.vda_next = READ32 (vstart, k) if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } sdb_num_set (sdb_parent, ""idx"", isum, 0); sdb_num_set (sdb_parent, ""parent"", j, 0); sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0); snprintf (key, sizeof (key), ""parent%d"", j - 1); sdb_ns_set (sdb_verdef, key, sdb_parent); } snprintf (key, sizeof (key), ""verdef%d"", cnt); sdb_ns_set (sdb, key, sdb_verdef); if (!verdef->vd_next) { sdb_free (sdb_verdef); goto out_error; } if ((st32)verdef->vd_next < 1) { eprintf (""Warning: Invalid vd_next in the ELF version\n""); break; } i += verdef->vd_next; } free (defs); return sdb; out_error: free (defs); sdb_free (sdb); return NULL; }","- if (shdr->sh_size < 1) {
+ if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) {","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { const char *section_name = """"; const char *link_section_name = """"; char *end = NULL; Elf_(Shdr) *link_shdr = NULL; ut8 dfs[sizeof (Elf_(Verdef))] = {0}; Sdb *sdb; int cnt, i; if (shdr->sh_link > bin->ehdr.e_shnum) { return false; } link_shdr = &bin->shdr[shdr->sh_link]; if (shdr->sh_size < 1 || shdr->sh_size > SIZE_MAX) { return false; } Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char)); if (!defs) { return false; } if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!defs) { bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n""); return NULL; } sdb = sdb_new0 (); end = (char *)defs + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) { Sdb *sdb_verdef = sdb_new0 (); char *vstart = ((char*)defs) + i; char key[32] = {0}; Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart; Elf_(Verdaux) aux = {0}; int j = 0; int isum = 0; r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef))); verdef->vd_version = READ16 (dfs, j) verdef->vd_flags = READ16 (dfs, j) verdef->vd_ndx = READ16 (dfs, j) verdef->vd_cnt = READ16 (dfs, j) verdef->vd_hash = READ32 (dfs, j) verdef->vd_aux = READ32 (dfs, j) verdef->vd_next = READ32 (dfs, j) int vdaux = verdef->vd_aux; if (vdaux < 1) { sdb_free (sdb_verdef); goto out_error; } vstart += vdaux; if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); goto out_error; } j = 0; aux.vda_name = READ32 (vstart, j) aux.vda_next = READ32 (vstart, j) isum = i + verdef->vd_aux; if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); goto out_error; } sdb_num_set (sdb_verdef, ""idx"", i, 0); sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0); sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0); sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0); sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0); sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0); for (j = 1; j < verdef->vd_cnt; ++j) { int k; Sdb *sdb_parent = sdb_new0 (); isum += aux.vda_next; vstart += aux.vda_next; if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } k = 0; aux.vda_name = READ32 (vstart, k) aux.vda_next = READ32 (vstart, k) if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } sdb_num_set (sdb_parent, ""idx"", isum, 0); sdb_num_set (sdb_parent, ""parent"", j, 0); sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0); snprintf (key, sizeof (key), ""parent%d"", j - 1); sdb_ns_set (sdb_verdef, key, sdb_parent); } snprintf (key, sizeof (key), ""verdef%d"", cnt); sdb_ns_set (sdb, key, sdb_verdef); if (!verdef->vd_next) { sdb_free (sdb_verdef); goto out_error; } if ((st32)verdef->vd_next < 1) { eprintf (""Warning: Invalid vd_next in the ELF version\n""); break; } i += verdef->vd_next; } free (defs); return sdb; out_error: free (defs); sdb_free (sdb); return NULL; }"
66,2962----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/normal.c----nv_gotofile,"nv_gotofile(cmdarg_T *cap) { char_u *ptr; linenr_T lnum = -1; <S2SV_StartVul> if (text_locked()) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> clearopbeep(cap->oap); <S2SV_EndVul> <S2SV_StartVul> text_locked_msg(); <S2SV_EndVul> return; <S2SV_StartVul> } <S2SV_EndVul> if (curbuf_locked()) { clearop(cap->oap); return; } #ifdef FEAT_PROP_POPUP if (ERROR_IF_TERM_POPUP_WINDOW) return; #endif ptr = grab_file_name(cap->count1, &lnum); if (ptr != NULL) { if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf)) (void)autowrite(curbuf, FALSE); setpcmark(); if (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST, buf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK && cap->nchar == 'F' && lnum >= 0) { curwin->w_cursor.lnum = lnum; check_cursor_lnum(); beginline(BL_SOL | BL_FIX); } vim_free(ptr); } else clearop(cap->oap); }","- if (text_locked())
- {
- clearopbeep(cap->oap);
- text_locked_msg();
- }
+ if (check_text_locked(cap->oap))","nv_gotofile(cmdarg_T *cap) { char_u *ptr; linenr_T lnum = -1; if (check_text_locked(cap->oap)) return; if (curbuf_locked()) { clearop(cap->oap); return; } #ifdef FEAT_PROP_POPUP if (ERROR_IF_TERM_POPUP_WINDOW) return; #endif ptr = grab_file_name(cap->count1, &lnum); if (ptr != NULL) { if (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf)) (void)autowrite(curbuf, FALSE); setpcmark(); if (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST, buf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK && cap->nchar == 'F' && lnum >= 0) { curwin->w_cursor.lnum = lnum; check_cursor_lnum(); beginline(BL_SOL | BL_FIX); } vim_free(ptr); } else clearop(cap->oap); }"
67,230----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9601--jbig2_symbol_dict.c----jbig2_sd_release,"jbig2_sd_release(Jbig2Ctx *ctx, Jbig2SymbolDict *dict) { <S2SV_StartVul> int i; <S2SV_EndVul> if (dict == NULL) return; for (i = 0; i < dict->n_symbols; i++) if (dict->glyphs[i]) jbig2_image_release(ctx, dict->glyphs[i]); jbig2_free(ctx->allocator, dict->glyphs); jbig2_free(ctx->allocator, dict); }","- int i;
+ uint32_t i;","jbig2_sd_release(Jbig2Ctx *ctx, Jbig2SymbolDict *dict) { uint32_t i; if (dict == NULL) return; for (i = 0; i < dict->n_symbols; i++) if (dict->glyphs[i]) jbig2_image_release(ctx, dict->glyphs[i]); jbig2_free(ctx->allocator, dict->glyphs); jbig2_free(ctx->allocator, dict); }"
68,3679----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiPstate.c----jsi_PstateSetFile,"int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang) { jsi_Lexer *l = ps->lexer; jsi_PstateClear(ps); l->ltype = LT_FILE; l->d.fp = fp; Jsi_Rewind(ps->interp, fp); if (skipbang) { <S2SV_StartVul> char buf[1000]; <S2SV_EndVul> <S2SV_StartVul> if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) { <S2SV_EndVul> Jsi_Rewind(ps->interp, fp); } } return JSI_OK; }","- char buf[1000];
- if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {
+ char buf[JSI_BUFSIZ];
+ if (Jsi_Gets(ps->interp, fp, buf, sizeof(buf)) && (buf[0] != '#' || buf[1] != '!')) {","int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang) { jsi_Lexer *l = ps->lexer; jsi_PstateClear(ps); l->ltype = LT_FILE; l->d.fp = fp; Jsi_Rewind(ps->interp, fp); if (skipbang) { char buf[JSI_BUFSIZ]; if (Jsi_Gets(ps->interp, fp, buf, sizeof(buf)) && (buf[0] != '#' || buf[1] != '!')) { Jsi_Rewind(ps->interp, fp); } } return JSI_OK; }"
69,3666----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/usercmd.c----find_ucmd,"find_ucmd( exarg_T *eap, char_u *p, int *full, expand_T *xp, int *complp) { int len = (int)(p - eap->cmd); int j, k, matchlen = 0; ucmd_T *uc; int found = FALSE; int possible = FALSE; char_u *cp, *np; garray_T *gap; int amb_local = FALSE; <S2SV_StartVul> gap = <S2SV_EndVul> <S2SV_StartVul> #ifdef FEAT_CMDWIN <S2SV_EndVul> <S2SV_StartVul> is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds : <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> <S2SV_StartVul> &curbuf->b_ucmds; <S2SV_EndVul> for (;;) { for (j = 0; j < gap->ga_len; ++j) { uc = USER_CMD_GA(gap, j); cp = eap->cmd; np = uc->uc_name; k = 0; while (k < len && *np != NUL && *cp++ == *np++) k++; if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k]))) { if (k == len && found && *np != NUL) { if (gap == &ucmds) return NULL; amb_local = TRUE; } if (!found || (k == len && *np == NUL)) { if (k == len) found = TRUE; else possible = TRUE; if (gap == &ucmds) eap->cmdidx = CMD_USER; else eap->cmdidx = CMD_USER_BUF; eap->argt = (long)uc->uc_argt; eap->useridx = j; eap->addr_type = uc->uc_addr_type; if (complp != NULL) *complp = uc->uc_compl; # ifdef FEAT_EVAL if (xp != NULL) { xp->xp_arg = uc->uc_compl_arg; xp->xp_script_ctx = uc->uc_script_ctx; xp->xp_script_ctx.sc_lnum += SOURCING_LNUM; } # endif matchlen = k; if (k == len && *np == NUL) { if (full != NULL) *full = TRUE; amb_local = FALSE; break; } } } } if (j < gap->ga_len || gap == &ucmds) break; gap = &ucmds; } if (amb_local) { if (xp != NULL) xp->xp_context = EXPAND_UNSUCCESSFUL; return NULL; } if (found || possible) return p + (matchlen - len); return p; }","- gap =
- #ifdef FEAT_CMDWIN
- is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds :
- #endif
- &curbuf->b_ucmds;
+ gap = &prevwin_curwin()->w_buffer->b_ucmds;","find_ucmd( exarg_T *eap, char_u *p, int *full, expand_T *xp, int *complp) { int len = (int)(p - eap->cmd); int j, k, matchlen = 0; ucmd_T *uc; int found = FALSE; int possible = FALSE; char_u *cp, *np; garray_T *gap; int amb_local = FALSE; gap = &prevwin_curwin()->w_buffer->b_ucmds; for (;;) { for (j = 0; j < gap->ga_len; ++j) { uc = USER_CMD_GA(gap, j); cp = eap->cmd; np = uc->uc_name; k = 0; while (k < len && *np != NUL && *cp++ == *np++) k++; if (k == len || (*np == NUL && vim_isdigit(eap->cmd[k]))) { if (k == len && found && *np != NUL) { if (gap == &ucmds) return NULL; amb_local = TRUE; } if (!found || (k == len && *np == NUL)) { if (k == len) found = TRUE; else possible = TRUE; if (gap == &ucmds) eap->cmdidx = CMD_USER; else eap->cmdidx = CMD_USER_BUF; eap->argt = (long)uc->uc_argt; eap->useridx = j; eap->addr_type = uc->uc_addr_type; if (complp != NULL) *complp = uc->uc_compl; # ifdef FEAT_EVAL if (xp != NULL) { xp->xp_arg = uc->uc_compl_arg; xp->xp_script_ctx = uc->uc_script_ctx; xp->xp_script_ctx.sc_lnum += SOURCING_LNUM; } # endif matchlen = k; if (k == len && *np == NUL) { if (full != NULL) *full = TRUE; amb_local = FALSE; break; } } } } if (j < gap->ga_len || gap == &ucmds) break; gap = &ucmds; } if (amb_local) { if (xp != NULL) xp->xp_context = EXPAND_UNSUCCESSFUL; return NULL; } if (found || possible) return p + (matchlen - len); return p; }"
70,5425----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/http_server_misc.c----httpReadRequestHeader,"error_t httpReadRequestHeader(HttpConnection *connection) { error_t error; size_t length; error = socketSetTimeout(connection->socket, HTTP_SERVER_IDLE_TIMEOUT); if(error) return error; error = httpReceive(connection, connection->buffer, HTTP_SERVER_BUFFER_SIZE - 1, &length, SOCKET_FLAG_BREAK_CRLF); if(error) return error; error = socketSetTimeout(connection->socket, HTTP_SERVER_TIMEOUT); if(error) return error; connection->buffer[length] = '\0'; TRACE_INFO(""%s"", connection->buffer); error = httpParseRequestLine(connection, connection->buffer); if(error) return error; connection->request.chunkedEncoding = FALSE; connection->request.contentLength = 0; #if (HTTP_SERVER_WEB_SOCKET_SUPPORT == ENABLED) connection->request.upgradeWebSocket = FALSE; connection->request.connectionUpgrade = FALSE; osStrcpy(connection->request.clientKey, """"); #endif if(connection->request.version >= HTTP_VERSION_1_0) { char_t firstChar; char_t *separator; char_t *name; char_t *value; firstChar = '\0'; while(1) { error = httpReadHeaderField(connection, connection->buffer, HTTP_SERVER_BUFFER_SIZE, &firstChar); if(error) return error; TRACE_DEBUG(""%s"", connection->buffer); if(!osStrcmp(connection->buffer, ""\r\n"")) break; <S2SV_StartVul> separator = strchr(connection->buffer, ':'); <S2SV_EndVul> if(separator != NULL) { *separator = '\0'; name = strTrimWhitespace(connection->buffer); value = strTrimWhitespace(separator + 1); httpParseHeaderField(connection, name, value); } } } if(connection->request.chunkedEncoding) { connection->request.byteCount = 0; connection->request.firstChunk = TRUE; connection->request.lastChunk = FALSE; } else { connection->request.byteCount = connection->request.contentLength; } return NO_ERROR; }","- separator = strchr(connection->buffer, ':');
+ separator = osStrchr(connection->buffer, ':');","error_t httpReadRequestHeader(HttpConnection *connection) { error_t error; size_t length; error = socketSetTimeout(connection->socket, HTTP_SERVER_IDLE_TIMEOUT); if(error) return error; error = httpReceive(connection, connection->buffer, HTTP_SERVER_BUFFER_SIZE - 1, &length, SOCKET_FLAG_BREAK_CRLF); if(error) return error; error = socketSetTimeout(connection->socket, HTTP_SERVER_TIMEOUT); if(error) return error; connection->buffer[length] = '\0'; TRACE_INFO(""%s"", connection->buffer); error = httpParseRequestLine(connection, connection->buffer); if(error) return error; connection->request.chunkedEncoding = FALSE; connection->request.contentLength = 0; #if (HTTP_SERVER_WEB_SOCKET_SUPPORT == ENABLED) connection->request.upgradeWebSocket = FALSE; connection->request.connectionUpgrade = FALSE; osStrcpy(connection->request.clientKey, """"); #endif if(connection->request.version >= HTTP_VERSION_1_0) { char_t firstChar; char_t *separator; char_t *name; char_t *value; firstChar = '\0'; while(1) { error = httpReadHeaderField(connection, connection->buffer, HTTP_SERVER_BUFFER_SIZE, &firstChar); if(error) return error; TRACE_DEBUG(""%s"", connection->buffer); if(!osStrcmp(connection->buffer, ""\r\n"")) break; separator = osStrchr(connection->buffer, ':'); if(separator != NULL) { *separator = '\0'; name = strTrimWhitespace(connection->buffer); value = strTrimWhitespace(separator + 1); httpParseHeaderField(connection, name, value); } } } if(connection->request.chunkedEncoding) { connection->request.byteCount = 0; connection->request.firstChunk = TRUE; connection->request.lastChunk = FALSE; } else { connection->request.byteCount = connection->request.contentLength; } return NO_ERROR; }"
71,5122----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/service_table.c----FindServiceEventURLPath,"service_info *FindServiceEventURLPath( service_table *table, const char *eventURLPath) { service_info *finger = NULL; uri_type parsed_url; uri_type parsed_url_in; <S2SV_StartVul> if (table && <S2SV_EndVul> <S2SV_StartVul> parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) == <S2SV_EndVul> <S2SV_StartVul> HTTP_SUCCESS) { <S2SV_EndVul> finger = table->serviceList; while (finger) { if (finger->eventURL) { if (parse_uri(finger->eventURL, strlen(finger->eventURL), &parsed_url) == HTTP_SUCCESS) { if (!token_cmp(&parsed_url.pathquery, &parsed_url_in.pathquery)) { return finger; } } } finger = finger->next; } } return NULL; }","- if (table &&
- parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==
- HTTP_SUCCESS) {
+ if (!table || !eventURLPath) {
+ return NULL;
+ }
+ if (parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==
+ HTTP_SUCCESS) {","service_info *FindServiceEventURLPath( service_table *table, const char *eventURLPath) { service_info *finger = NULL; uri_type parsed_url; uri_type parsed_url_in; if (!table || !eventURLPath) { return NULL; } if (parse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) == HTTP_SUCCESS) { finger = table->serviceList; while (finger) { if (finger->eventURL) { if (parse_uri(finger->eventURL, strlen(finger->eventURL), &parsed_url) == HTTP_SUCCESS) { if (!token_cmp(&parsed_url.pathquery, &parsed_url_in.pathquery)) { return finger; } } } finger = finger->next; } } return NULL; }"
72,662----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3673--sm_statefuns.c----sctp_sf_do_asconf,"sctp_disposition_t sctp_sf_do_asconf(struct net *net, const struct sctp_endpoint *ep, const struct sctp_association *asoc, const sctp_subtype_t type, void *arg, sctp_cmd_seq_t *commands) { struct sctp_chunk *chunk = arg; struct sctp_chunk *asconf_ack = NULL; struct sctp_paramhdr *err_param = NULL; sctp_addiphdr_t *hdr; <S2SV_StartVul> union sctp_addr_param *addr_param; <S2SV_EndVul> __u32 serial; <S2SV_StartVul> int length; <S2SV_EndVul> if (!sctp_vtag_verify(chunk, asoc)) { sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG, SCTP_NULL()); return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands); } if (!net->sctp.addip_noauth && !chunk->auth) return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands); if (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t))) return sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands); hdr = (sctp_addiphdr_t *)chunk->skb->data; serial = ntohl(hdr->serial); <S2SV_StartVul> addr_param = (union sctp_addr_param *)hdr->params; <S2SV_EndVul> <S2SV_StartVul> length = ntohs(addr_param->p.length); <S2SV_EndVul> <S2SV_StartVul> if (length < sizeof(sctp_paramhdr_t)) <S2SV_EndVul> <S2SV_StartVul> return sctp_sf_violation_paramlen(net, ep, asoc, type, arg, <S2SV_EndVul> <S2SV_StartVul> (void *)addr_param, commands); <S2SV_EndVul> if (!sctp_verify_asconf(asoc, <S2SV_StartVul> (sctp_paramhdr_t *)((void *)addr_param + length), <S2SV_EndVul> <S2SV_StartVul> (void *)chunk->chunk_end, <S2SV_EndVul> <S2SV_StartVul> &err_param)) <S2SV_EndVul> <S2SV_StartVul> return sctp_sf_violation_paramlen(net, ep, asoc, type, arg, <S2SV_EndVul> (void *)err_param, commands); if (serial == asoc->peer.addip_serial + 1) { if (!chunk->has_asconf) sctp_assoc_clean_asconf_ack_cache(asoc); asconf_ack = sctp_process_asconf((struct sctp_association *) asoc, chunk); if (!asconf_ack) return SCTP_DISPOSITION_NOMEM; } else if (serial < asoc->peer.addip_serial + 1) { asconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial); if (!asconf_ack) return SCTP_DISPOSITION_DISCARD; asconf_ack->transport = NULL; } else { return SCTP_DISPOSITION_DISCARD; } asconf_ack->dest = chunk->source; sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack)); if (asoc->new_transport) { sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands); ((struct sctp_association *)asoc)->new_transport = NULL; } return SCTP_DISPOSITION_CONSUME; }","- union sctp_addr_param *addr_param;
- int length;
- addr_param = (union sctp_addr_param *)hdr->params;
- length = ntohs(addr_param->p.length);
- if (length < sizeof(sctp_paramhdr_t))
- return sctp_sf_violation_paramlen(net, ep, asoc, type, arg,
- (void *)addr_param, commands);
- (sctp_paramhdr_t *)((void *)addr_param + length),
- (void *)chunk->chunk_end,
- &err_param))
- return sctp_sf_violation_paramlen(net, ep, asoc, type, arg,
+ if (!sctp_verify_asconf(asoc, chunk, true, &err_param))","sctp_disposition_t sctp_sf_do_asconf(struct net *net, const struct sctp_endpoint *ep, const struct sctp_association *asoc, const sctp_subtype_t type, void *arg, sctp_cmd_seq_t *commands) { struct sctp_chunk *chunk = arg; struct sctp_chunk *asconf_ack = NULL; struct sctp_paramhdr *err_param = NULL; sctp_addiphdr_t *hdr; __u32 serial; if (!sctp_vtag_verify(chunk, asoc)) { sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG, SCTP_NULL()); return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands); } if (!net->sctp.addip_noauth && !chunk->auth) return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands); if (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t))) return sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands); hdr = (sctp_addiphdr_t *)chunk->skb->data; serial = ntohl(hdr->serial); if (!sctp_verify_asconf(asoc, chunk, true, &err_param)) return sctp_sf_violation_paramlen(net, ep, asoc, type, arg, (void *)err_param, commands); if (serial == asoc->peer.addip_serial + 1) { if (!chunk->has_asconf) sctp_assoc_clean_asconf_ack_cache(asoc); asconf_ack = sctp_process_asconf((struct sctp_association *) asoc, chunk); if (!asconf_ack) return SCTP_DISPOSITION_NOMEM; } else if (serial < asoc->peer.addip_serial + 1) { asconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial); if (!asconf_ack) return SCTP_DISPOSITION_DISCARD; asconf_ack->transport = NULL; } else { return SCTP_DISPOSITION_DISCARD; } asconf_ack->dest = chunk->source; sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack)); if (asoc->new_transport) { sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands); ((struct sctp_association *)asoc)->new_transport = NULL; } return SCTP_DISPOSITION_CONSUME; }"
73,3179----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ofx_preproc.cpp----sanitize_proprietary_tags,"string sanitize_proprietary_tags(string input_string) { unsigned int i; <S2SV_StartVul> size_t input_string_size; <S2SV_EndVul> bool strip = false; bool tag_open = false; int tag_open_idx = 0; bool closing_tag_open = false; int orig_tag_open_idx = 0; bool proprietary_tag = false; bool proprietary_closing_tag = false; int crop_end_idx = 0; char buffer[READ_BUFFER_SIZE] = """"; char tagname[READ_BUFFER_SIZE] = """"; int tagname_idx = 0; char close_tagname[READ_BUFFER_SIZE] = """"; for (i = 0; i < READ_BUFFER_SIZE; i++) { buffer[i] = 0; tagname[i] = 0; close_tagname[i] = 0; } <S2SV_StartVul> input_string_size = input_string.size(); <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < input_string_size; i++) <S2SV_EndVul> { if (input_string.c_str()[i] == '<') { tag_open = true; tag_open_idx = i; if (proprietary_tag == true && input_string.c_str()[i+1] == '/') { closing_tag_open = true; if (strncmp(tagname, &(input_string.c_str()[i+2]), strlen(tagname)) != 0) { crop_end_idx = i - 1; strip = true; } else { proprietary_closing_tag = true; } } else if (proprietary_tag == true) { crop_end_idx = i - 1; strip = true; } } else if (input_string.c_str()[i] == '>') { tag_open = false; closing_tag_open = false; tagname[tagname_idx] = 0; tagname_idx = 0; if (proprietary_closing_tag == true) { crop_end_idx = i; strip = true; } } else if (tag_open == true && closing_tag_open == false) { if (input_string.c_str()[i] == '.') { if (proprietary_tag != true) { orig_tag_open_idx = tag_open_idx; proprietary_tag = true; } } tagname[tagname_idx] = input_string.c_str()[i]; tagname_idx++; } if (strip == true && orig_tag_open_idx < input_string.size()) { input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx); message_out(INFO, ""sanitize_proprietary_tags() (end tag or new tag) removed: "" + string(buffer)); input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1); i = orig_tag_open_idx - 1; proprietary_tag = false; proprietary_closing_tag = false; closing_tag_open = false; tag_open = false; strip = false; input_string_size = input_string.size(); } } if (proprietary_tag == true && orig_tag_open_idx < input_string.size()) { if (crop_end_idx == 0) { crop_end_idx = input_string.size() - 1; } input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx); message_out(INFO, ""sanitize_proprietary_tags() (end of line) removed: "" + string(buffer)); input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1); input_string_size = input_string.size(); } return input_string; }","- size_t input_string_size;
- input_string_size = input_string.size();
- for (i = 0; i < input_string_size; i++)
+ size_t input_string_size = input_string.size();
+ for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)","string sanitize_proprietary_tags(string input_string) { unsigned int i; bool strip = false; bool tag_open = false; int tag_open_idx = 0; bool closing_tag_open = false; int orig_tag_open_idx = 0; bool proprietary_tag = false; bool proprietary_closing_tag = false; int crop_end_idx = 0; char buffer[READ_BUFFER_SIZE] = """"; char tagname[READ_BUFFER_SIZE] = """"; int tagname_idx = 0; char close_tagname[READ_BUFFER_SIZE] = """"; for (i = 0; i < READ_BUFFER_SIZE; i++) { buffer[i] = 0; tagname[i] = 0; close_tagname[i] = 0; } size_t input_string_size = input_string.size(); for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++) { if (input_string.c_str()[i] == '<') { tag_open = true; tag_open_idx = i; if (proprietary_tag == true && input_string.c_str()[i+1] == '/') { closing_tag_open = true; if (strncmp(tagname, &(input_string.c_str()[i+2]), strlen(tagname)) != 0) { crop_end_idx = i - 1; strip = true; } else { proprietary_closing_tag = true; } } else if (proprietary_tag == true) { crop_end_idx = i - 1; strip = true; } } else if (input_string.c_str()[i] == '>') { tag_open = false; closing_tag_open = false; tagname[tagname_idx] = 0; tagname_idx = 0; if (proprietary_closing_tag == true) { crop_end_idx = i; strip = true; } } else if (tag_open == true && closing_tag_open == false) { if (input_string.c_str()[i] == '.') { if (proprietary_tag != true) { orig_tag_open_idx = tag_open_idx; proprietary_tag = true; } } tagname[tagname_idx] = input_string.c_str()[i]; tagname_idx++; } if (strip == true && orig_tag_open_idx < input_string.size()) { input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx); message_out(INFO, ""sanitize_proprietary_tags() (end tag or new tag) removed: "" + string(buffer)); input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1); i = orig_tag_open_idx - 1; proprietary_tag = false; proprietary_closing_tag = false; closing_tag_open = false; tag_open = false; strip = false; input_string_size = input_string.size(); } } if (proprietary_tag == true && orig_tag_open_idx < input_string.size()) { if (crop_end_idx == 0) { crop_end_idx = input_string.size() - 1; } input_string.copy(buffer, (crop_end_idx - orig_tag_open_idx) + 1, orig_tag_open_idx); message_out(INFO, ""sanitize_proprietary_tags() (end of line) removed: "" + string(buffer)); input_string.erase(orig_tag_open_idx, (crop_end_idx - orig_tag_open_idx) + 1); input_string_size = input_string.size(); } return input_string; }"
74,2351----CWE-415----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-6978--gd_gif_out.c----gdImageGifPtr,"void * gdImageGifPtr (gdImagePtr im, int *size) { void *rv; gdIOCtx *out = gdNewDynamicCtx (2048, NULL); <S2SV_StartVul> gdImageGifCtx (im, out); <S2SV_EndVul> <S2SV_StartVul> rv = gdDPExtractData (out, size); <S2SV_EndVul> out->gd_free (out); return rv; }","- gdImageGifCtx (im, out);
- rv = gdDPExtractData (out, size);
+ if (!_gdImageGifCtx(im, out)) {
+ rv = gdDPExtractData(out, size);
+ } else {
+ rv = NULL;
+ }","void * gdImageGifPtr (gdImagePtr im, int *size) { void *rv; gdIOCtx *out = gdNewDynamicCtx (2048, NULL); if (!_gdImageGifCtx(im, out)) { rv = gdDPExtractData(out, size); } else { rv = NULL; } out->gd_free (out); return rv; }"
75,3398----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rza1_eth_driver.c----rza1EthEventHandler,void rza1EthEventHandler(NetInterface *interface) { error_t error; if((ETHER.EESR0 & ETHER_EESR0_FR) != 0) { ETHER.EESR0 = ETHER_EESR0_FR; do { error = rza1EthReceivePacket(interface); } while(error != ERROR_BUFFER_EMPTY); } <S2SV_StartVul> ETHER.EESIPR0 = ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP; <S2SV_EndVul> },"- ETHER.EESIPR0 = ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;
+ ETHER.EESIPR0 = ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;",void rza1EthEventHandler(NetInterface *interface) { error_t error; if((ETHER.EESR0 & ETHER_EESR0_FR) != 0) { ETHER.EESR0 = ETHER_EESR0_FR; do { error = rza1EthReceivePacket(interface); } while(error != ERROR_BUFFER_EMPTY); } ETHER.EESIPR0 = ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP; }
76,735----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-0069--file.c----cifs_iovec_write,"cifs_iovec_write(struct file *file, const struct iovec *iov, unsigned long nr_segs, loff_t *poffset) { unsigned long nr_pages, i; <S2SV_StartVul> size_t copied, len, cur_len; <S2SV_EndVul> ssize_t total_written = 0; loff_t offset; struct iov_iter it; struct cifsFileInfo *open_file; struct cifs_tcon *tcon; struct cifs_sb_info *cifs_sb; struct cifs_writedata *wdata, *tmp; struct list_head wdata_list; int rc; pid_t pid; len = iov_length(iov, nr_segs); if (!len) return 0; rc = generic_write_checks(file, poffset, &len, 0); if (rc) return rc; INIT_LIST_HEAD(&wdata_list); cifs_sb = CIFS_SB(file->f_path.dentry->d_sb); open_file = file->private_data; tcon = tlink_tcon(open_file->tlink); if (!tcon->ses->server->ops->async_writev) return -ENOSYS; offset = *poffset; if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD) pid = open_file->pid; else pid = current->tgid; iov_iter_init(&it, iov, nr_segs, len, 0); do { size_t save_len; nr_pages = get_numpages(cifs_sb->wsize, len, &cur_len); wdata = cifs_writedata_alloc(nr_pages, cifs_uncached_writev_complete); if (!wdata) { rc = -ENOMEM; break; } rc = cifs_write_allocate_pages(wdata->pages, nr_pages); if (rc) { kfree(wdata); break; } save_len = cur_len; for (i = 0; i < nr_pages; i++) { <S2SV_StartVul> copied = min_t(const size_t, cur_len, PAGE_SIZE); <S2SV_EndVul> copied = iov_iter_copy_from_user(wdata->pages[i], &it, <S2SV_StartVul> 0, copied); <S2SV_EndVul> cur_len -= copied; iov_iter_advance(&it, copied); } cur_len = save_len - cur_len; wdata->sync_mode = WB_SYNC_ALL; wdata->nr_pages = nr_pages; wdata->offset = (__u64)offset; wdata->cfile = cifsFileInfo_get(open_file); wdata->pid = pid; wdata->bytes = cur_len; wdata->pagesz = PAGE_SIZE; wdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE); rc = cifs_uncached_retry_writev(wdata); if (rc) { kref_put(&wdata->refcount, cifs_uncached_writedata_release); break; } list_add_tail(&wdata->list, &wdata_list); offset += cur_len; len -= cur_len; } while (len > 0); if (!list_empty(&wdata_list)) rc = 0; restart_loop: list_for_each_entry_safe(wdata, tmp, &wdata_list, list) { if (!rc) { rc = wait_for_completion_killable(&wdata->done); if (rc) rc = -EINTR; else if (wdata->result) rc = wdata->result; else total_written += wdata->bytes; if (rc == -EAGAIN) { rc = cifs_uncached_retry_writev(wdata); goto restart_loop; } } list_del_init(&wdata->list); kref_put(&wdata->refcount, cifs_uncached_writedata_release); } if (total_written > 0) *poffset += total_written; cifs_stats_bytes_written(tcon, total_written); return total_written ? total_written : (ssize_t)rc; }","- size_t copied, len, cur_len;
- copied = min_t(const size_t, cur_len, PAGE_SIZE);
- 0, copied);
+ size_t bytes, copied, len, cur_len;
+ bytes = min_t(const size_t, cur_len, PAGE_SIZE);
+ 0, bytes);
+ if (copied < bytes)
+ break;
+ if (!cur_len) {
+ for (i = 0; i < nr_pages; i++)
+ put_page(wdata->pages[i]);
+ kfree(wdata);
+ rc = -EFAULT;
+ break;
+ }
+ for ( ; nr_pages > i + 1; nr_pages--)
+ put_page(wdata->pages[nr_pages - 1]);","cifs_iovec_write(struct file *file, const struct iovec *iov, unsigned long nr_segs, loff_t *poffset) { unsigned long nr_pages, i; size_t bytes, copied, len, cur_len; ssize_t total_written = 0; loff_t offset; struct iov_iter it; struct cifsFileInfo *open_file; struct cifs_tcon *tcon; struct cifs_sb_info *cifs_sb; struct cifs_writedata *wdata, *tmp; struct list_head wdata_list; int rc; pid_t pid; len = iov_length(iov, nr_segs); if (!len) return 0; rc = generic_write_checks(file, poffset, &len, 0); if (rc) return rc; INIT_LIST_HEAD(&wdata_list); cifs_sb = CIFS_SB(file->f_path.dentry->d_sb); open_file = file->private_data; tcon = tlink_tcon(open_file->tlink); if (!tcon->ses->server->ops->async_writev) return -ENOSYS; offset = *poffset; if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD) pid = open_file->pid; else pid = current->tgid; iov_iter_init(&it, iov, nr_segs, len, 0); do { size_t save_len; nr_pages = get_numpages(cifs_sb->wsize, len, &cur_len); wdata = cifs_writedata_alloc(nr_pages, cifs_uncached_writev_complete); if (!wdata) { rc = -ENOMEM; break; } rc = cifs_write_allocate_pages(wdata->pages, nr_pages); if (rc) { kfree(wdata); break; } save_len = cur_len; for (i = 0; i < nr_pages; i++) { bytes = min_t(const size_t, cur_len, PAGE_SIZE); copied = iov_iter_copy_from_user(wdata->pages[i], &it, 0, bytes); cur_len -= copied; iov_iter_advance(&it, copied); if (copied < bytes) break; } cur_len = save_len - cur_len; if (!cur_len) { for (i = 0; i < nr_pages; i++) put_page(wdata->pages[i]); kfree(wdata); rc = -EFAULT; break; } for ( ; nr_pages > i + 1; nr_pages--) put_page(wdata->pages[nr_pages - 1]); wdata->sync_mode = WB_SYNC_ALL; wdata->nr_pages = nr_pages; wdata->offset = (__u64)offset; wdata->cfile = cifsFileInfo_get(open_file); wdata->pid = pid; wdata->bytes = cur_len; wdata->pagesz = PAGE_SIZE; wdata->tailsz = cur_len - ((nr_pages - 1) * PAGE_SIZE); rc = cifs_uncached_retry_writev(wdata); if (rc) { kref_put(&wdata->refcount, cifs_uncached_writedata_release); break; } list_add_tail(&wdata->list, &wdata_list); offset += cur_len; len -= cur_len; } while (len > 0); if (!list_empty(&wdata_list)) rc = 0; restart_loop: list_for_each_entry_safe(wdata, tmp, &wdata_list, list) { if (!rc) { rc = wait_for_completion_killable(&wdata->done); if (rc) rc = -EINTR; else if (wdata->result) rc = wdata->result; else total_written += wdata->bytes; if (rc == -EAGAIN) { rc = cifs_uncached_retry_writev(wdata); goto restart_loop; } } list_del_init(&wdata->list); kref_put(&wdata->refcount, cifs_uncached_writedata_release); } if (total_written > 0) *poffset += total_written; cifs_stats_bytes_written(tcon, total_written); return total_written ? total_written : (ssize_t)rc; }"
77,1680--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-2671--ping.c----ping_unhash,"void ping_unhash(struct sock *sk) { struct inet_sock *isk = inet_sk(sk); pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num); if (sk_hashed(sk)) { <S2SV_StartVul> write_lock_bh(&ping_table.lock); <S2SV_EndVul> hlist_nulls_del(&sk->sk_nulls_node); sk_nulls_node_init(&sk->sk_nulls_node); sock_put(sk); isk->inet_num = 0; isk->inet_sport = 0; sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1); <S2SV_StartVul> write_unlock_bh(&ping_table.lock); <S2SV_EndVul> } }","- write_lock_bh(&ping_table.lock);
- write_unlock_bh(&ping_table.lock);
+ write_lock_bh(&ping_table.lock);
+ write_unlock_bh(&ping_table.lock);","void ping_unhash(struct sock *sk) { struct inet_sock *isk = inet_sk(sk); pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num); write_lock_bh(&ping_table.lock); if (sk_hashed(sk)) { hlist_nulls_del(&sk->sk_nulls_node); sk_nulls_node_init(&sk->sk_nulls_node); sock_put(sk); isk->inet_num = 0; isk->inet_sport = 0; sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1); } write_unlock_bh(&ping_table.lock); }"
78,3732----CWE-191----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/util.c----imap_quote_string,"void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick) { const char *quote = ""`\""\\""; if (!quote_backtick) quote++; char *pt = dest; const char *s = src; *pt++ = '""'; dlen -= 2; for (; *s && dlen; s++) { if (strchr(quote, *s)) { <S2SV_StartVul> dlen -= 2; <S2SV_EndVul> <S2SV_StartVul> if (dlen == 0) <S2SV_EndVul> break; *pt++ = '\\'; *pt++ = *s; } else { *pt++ = *s; dlen--; } } *pt++ = '""'; *pt = '\0'; }","- dlen -= 2;
- if (dlen == 0)
+ if (dlen < 2)
+ dlen -= 2;","void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick) { const char *quote = ""`\""\\""; if (!quote_backtick) quote++; char *pt = dest; const char *s = src; *pt++ = '""'; dlen -= 2; for (; *s && dlen; s++) { if (strchr(quote, *s)) { if (dlen < 2) break; dlen -= 2; *pt++ = '\\'; *pt++ = *s; } else { *pt++ = *s; dlen--; } } *pt++ = '""'; *pt = '\0'; }"
79,111----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-7052--x509_vfy.c----get_crl_sk,"static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl, X509 **pissuer, int *pscore, unsigned int *preasons, STACK_OF(X509_CRL) *crls) { int i, crl_score, best_score = *pscore; unsigned int reasons, best_reasons = 0; X509 *x = ctx->current_cert; X509_CRL *crl, *best_crl = NULL; X509 *crl_issuer = NULL, *best_crl_issuer = NULL; for (i = 0; i < sk_X509_CRL_num(crls); i++) { crl = sk_X509_CRL_value(crls, i); reasons = *preasons; crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x); <S2SV_StartVul> if (crl_score < best_score) <S2SV_EndVul> continue; <S2SV_StartVul> if (crl_score == best_score) { <S2SV_EndVul> int day, sec; if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl), X509_CRL_get_lastUpdate(crl)) == 0) continue; if (day <= 0 && sec <= 0) continue; } best_crl = crl; best_crl_issuer = crl_issuer; best_score = crl_score; best_reasons = reasons; } if (best_crl) { if (*pcrl) X509_CRL_free(*pcrl); *pcrl = best_crl; *pissuer = best_crl_issuer; *pscore = best_score; *preasons = best_reasons; CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL); if (*pdcrl) { X509_CRL_free(*pdcrl); *pdcrl = NULL; } get_delta_sk(ctx, pdcrl, pscore, best_crl, crls); } if (best_score >= CRL_SCORE_VALID) return 1; return 0; }","- if (crl_score < best_score)
- if (crl_score == best_score) {
+ if (crl_score < best_score || crl_score == 0)
+ if (crl_score == best_score && best_crl != NULL) {","static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl, X509 **pissuer, int *pscore, unsigned int *preasons, STACK_OF(X509_CRL) *crls) { int i, crl_score, best_score = *pscore; unsigned int reasons, best_reasons = 0; X509 *x = ctx->current_cert; X509_CRL *crl, *best_crl = NULL; X509 *crl_issuer = NULL, *best_crl_issuer = NULL; for (i = 0; i < sk_X509_CRL_num(crls); i++) { crl = sk_X509_CRL_value(crls, i); reasons = *preasons; crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x); if (crl_score < best_score || crl_score == 0) continue; if (crl_score == best_score && best_crl != NULL) { int day, sec; if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl), X509_CRL_get_lastUpdate(crl)) == 0) continue; if (day <= 0 && sec <= 0) continue; } best_crl = crl; best_crl_issuer = crl_issuer; best_score = crl_score; best_reasons = reasons; } if (best_crl) { if (*pcrl) X509_CRL_free(*pcrl); *pcrl = best_crl; *pissuer = best_crl_issuer; *pscore = best_score; *preasons = best_reasons; CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL); if (*pdcrl) { X509_CRL_free(*pdcrl); *pdcrl = NULL; } get_delta_sk(ctx, pdcrl, pscore, best_crl, crls); } if (best_score >= CRL_SCORE_VALID) return 1; return 0; }"
80,2669----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/buffer.c----buflist_match,"buflist_match( regmatch_T *rmp, buf_T *buf, int ignore_case) { char_u *match; match = fname_match(rmp, buf->b_sfname, ignore_case); <S2SV_StartVul> if (match == NULL) <S2SV_EndVul> match = fname_match(rmp, buf->b_ffname, ignore_case); return match; }","- if (match == NULL)
+ if (match == NULL && rmp->regprog != NULL)","buflist_match( regmatch_T *rmp, buf_T *buf, int ignore_case) { char_u *match; match = fname_match(rmp, buf->b_sfname, ignore_case); if (match == NULL && rmp->regprog != NULL) match = fname_match(rmp, buf->b_ffname, ignore_case); return match; }"
81,1528----CWE-682----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-8326--imagew-bmp.c----find_low_bit,static int find_low_bit(unsigned int x) { int i; for(i=0;i<=31;i++) { <S2SV_StartVul> if(x&(1<<i)) return i; <S2SV_EndVul> } return 0; },"- if(x&(1<<i)) return i;
+ if(x&(1U<<(unsigned int)i)) return i;",static int find_low_bit(unsigned int x) { int i; for(i=0;i<=31;i++) { if(x&(1U<<(unsigned int)i)) return i; } return 0; }
82,6796----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/trio.c----TRIO_ARGS2,"TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback, TRIO_CONST char* name) { trio_userdef_t* def; trio_userdef_t* prev = NULL; if (callback == NULL) return NULL; if (name) { if (name[0] == ':') { if (trio_equal(name, "":enter"")) { internalEnterCriticalRegion = callback; } else if (trio_equal(name, "":leave"")) { internalLeaveCriticalRegion = callback; } return NULL; } <S2SV_StartVul> if (trio_length(name) >= MAX_USER_NAME) <S2SV_EndVul> return NULL; def = TrioFindNamespace(name, &prev); if (def) return NULL; } def = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t)); if (def) { if (internalEnterCriticalRegion) (void)internalEnterCriticalRegion(NULL); if (name) { if (prev == NULL) internalUserDef = def; else prev->next = def; } def->callback = callback; def->name = (name == NULL) ? NULL : trio_duplicate(name); def->next = NULL; if (internalLeaveCriticalRegion) (void)internalLeaveCriticalRegion(NULL); } return (trio_pointer_t)def; }","- if (trio_length(name) >= MAX_USER_NAME)
+ if (trio_length_max(name, MAX_USER_NAME) >= MAX_USER_NAME)","TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback, TRIO_CONST char* name) { trio_userdef_t* def; trio_userdef_t* prev = NULL; if (callback == NULL) return NULL; if (name) { if (name[0] == ':') { if (trio_equal(name, "":enter"")) { internalEnterCriticalRegion = callback; } else if (trio_equal(name, "":leave"")) { internalLeaveCriticalRegion = callback; } return NULL; } if (trio_length_max(name, MAX_USER_NAME) >= MAX_USER_NAME) return NULL; def = TrioFindNamespace(name, &prev); if (def) return NULL; } def = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t)); if (def) { if (internalEnterCriticalRegion) (void)internalEnterCriticalRegion(NULL); if (name) { if (prev == NULL) internalUserDef = def; else prev->next = def; } def->callback = callback; def->name = (name == NULL) ? NULL : trio_duplicate(name); def->next = NULL; if (internalLeaveCriticalRegion) (void)internalLeaveCriticalRegion(NULL); } return (trio_pointer_t)def; }"
83,4746----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/deflate.c----deflateCopy,"int ZEXPORT deflateCopy (dest, source) z_streamp dest; z_streamp source; { #ifdef MAXSEG_64K return Z_STREAM_ERROR; #else deflate_state *ds; deflate_state *ss; <S2SV_StartVul> ushf *overlay; <S2SV_EndVul> if (deflateStateCheck(source) || dest == Z_NULL) { return Z_STREAM_ERROR; } ss = source->state; zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream)); ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state)); if (ds == Z_NULL) return Z_MEM_ERROR; dest->state = (struct internal_state FAR *) ds; zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state)); ds->strm = dest; ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte)); ds->prev = (Posf *) ZALLOC(dest, ds->w_size, sizeof(Pos)); ds->head = (Posf *) ZALLOC(dest, ds->hash_size, sizeof(Pos)); <S2SV_StartVul> overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2); <S2SV_EndVul> <S2SV_StartVul> ds->pending_buf = (uchf *) overlay; <S2SV_EndVul> if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL || ds->pending_buf == Z_NULL) { deflateEnd (dest); return Z_MEM_ERROR; } zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte)); zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos)); zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos)); zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size); ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf); <S2SV_StartVul> ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush); <S2SV_EndVul> <S2SV_StartVul> ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize; <S2SV_EndVul> ds->l_desc.dyn_tree = ds->dyn_ltree; ds->d_desc.dyn_tree = ds->dyn_dtree; ds->bl_desc.dyn_tree = ds->bl_tree; return Z_OK; #endif }","- ushf *overlay;
- overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
- ds->pending_buf = (uchf *) overlay;
- ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
- ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+ ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);
+ ds->sym_buf = ds->pending_buf + ds->lit_bufsize;","int ZEXPORT deflateCopy (dest, source) z_streamp dest; z_streamp source; { #ifdef MAXSEG_64K return Z_STREAM_ERROR; #else deflate_state *ds; deflate_state *ss; if (deflateStateCheck(source) || dest == Z_NULL) { return Z_STREAM_ERROR; } ss = source->state; zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream)); ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state)); if (ds == Z_NULL) return Z_MEM_ERROR; dest->state = (struct internal_state FAR *) ds; zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state)); ds->strm = dest; ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte)); ds->prev = (Posf *) ZALLOC(dest, ds->w_size, sizeof(Pos)); ds->head = (Posf *) ZALLOC(dest, ds->hash_size, sizeof(Pos)); ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4); if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL || ds->pending_buf == Z_NULL) { deflateEnd (dest); return Z_MEM_ERROR; } zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte)); zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos)); zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos)); zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size); ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf); ds->sym_buf = ds->pending_buf + ds->lit_bufsize; ds->l_desc.dyn_tree = ds->dyn_ltree; ds->d_desc.dyn_tree = ds->dyn_dtree; ds->bl_desc.dyn_tree = ds->bl_tree; return Z_OK; #endif }"
84,3759----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mptctl.c----mptctl_eventquery,"<S2SV_StartVul> mptctl_eventquery (unsigned long arg) <S2SV_EndVul> { struct mpt_ioctl_eventquery __user *uarg = (void __user *) arg; struct mpt_ioctl_eventquery karg; <S2SV_StartVul> MPT_ADAPTER *ioc; <S2SV_EndVul> <S2SV_StartVul> int iocnum; <S2SV_EndVul> if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) { printk(KERN_ERR MYNAM ""%s@%d::mptctl_eventquery - "" ""Unable to read in mpt_ioctl_eventquery struct @ %p\n"", __FILE__, __LINE__, uarg); return -EFAULT; } <S2SV_StartVul> if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) || <S2SV_EndVul> <S2SV_StartVul> (ioc == NULL)) { <S2SV_EndVul> <S2SV_StartVul> printk(KERN_DEBUG MYNAM ""%s::mptctl_eventquery() @%d - ioc%d not found!\n"", <S2SV_EndVul> <S2SV_StartVul> __FILE__, __LINE__, iocnum); <S2SV_EndVul> <S2SV_StartVul> return -ENODEV; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ""mptctl_eventquery called.\n"", ioc->name)); karg.eventEntries = MPTCTL_EVENT_LOG_SIZE; karg.eventTypes = ioc->eventTypes; if (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) { printk(MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventquery - "" ""Unable to write out mpt_ioctl_eventquery struct @ %p\n"", ioc->name, __FILE__, __LINE__, uarg); return -EFAULT; } return 0; }","- mptctl_eventquery (unsigned long arg)
- MPT_ADAPTER *ioc;
- int iocnum;
- if (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||
- (ioc == NULL)) {
- printk(KERN_DEBUG MYNAM ""%s::mptctl_eventquery() @%d - ioc%d not found!\n"",
- __FILE__, __LINE__, iocnum);
- return -ENODEV;
- }
+ mptctl_eventquery (MPT_ADAPTER *ioc, unsigned long arg)","mptctl_eventquery (MPT_ADAPTER *ioc, unsigned long arg) { struct mpt_ioctl_eventquery __user *uarg = (void __user *) arg; struct mpt_ioctl_eventquery karg; if (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) { printk(KERN_ERR MYNAM ""%s@%d::mptctl_eventquery - "" ""Unable to read in mpt_ioctl_eventquery struct @ %p\n"", __FILE__, __LINE__, uarg); return -EFAULT; } dctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT ""mptctl_eventquery called.\n"", ioc->name)); karg.eventEntries = MPTCTL_EVENT_LOG_SIZE; karg.eventTypes = ioc->eventTypes; if (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) { printk(MYIOC_s_ERR_FMT ""%s@%d::mptctl_eventquery - "" ""Unable to write out mpt_ioctl_eventquery struct @ %p\n"", ioc->name, __FILE__, __LINE__, uarg); return -EFAULT; } return 0; }"
85,18----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-7540--asn1.c----asn1_write_LDAPString,"bool asn1_write_LDAPString(struct asn1_data *data, const char *s) { <S2SV_StartVul> asn1_write(data, s, strlen(s)); <S2SV_EndVul> <S2SV_StartVul> return !data->has_error; <S2SV_EndVul> }","- asn1_write(data, s, strlen(s));
- return !data->has_error;
+ return asn1_write(data, s, strlen(s));","bool asn1_write_LDAPString(struct asn1_data *data, const char *s) { return asn1_write(data, s, strlen(s)); }"
86,1219----CWE-862----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-17807--request_key.c----*construct_key_and_link,"static struct key *construct_key_and_link(struct keyring_search_context *ctx, const char *callout_info, size_t callout_len, void *aux, struct key *dest_keyring, unsigned long flags) { struct key_user *user; struct key *key; int ret; kenter(""""); if (ctx->index_key.type == &key_type_keyring) return ERR_PTR(-EPERM); <S2SV_StartVul> user = key_user_lookup(current_fsuid()); <S2SV_EndVul> <S2SV_StartVul> if (!user) <S2SV_EndVul> <S2SV_StartVul> return ERR_PTR(-ENOMEM); <S2SV_EndVul> <S2SV_StartVul> construct_get_dest_keyring(&dest_keyring); <S2SV_EndVul> ret = construct_alloc_key(ctx, dest_keyring, flags, user, &key); key_user_put(user); if (ret == 0) { ret = construct_key(key, callout_info, callout_len, aux, dest_keyring); if (ret < 0) { kdebug(""cons failed""); goto construction_failed; } } else if (ret == -EINPROGRESS) { ret = 0; } else { <S2SV_StartVul> goto couldnt_alloc_key; <S2SV_EndVul> } key_put(dest_keyring); kleave("" = key %d"", key_serial(key)); return key; construction_failed: key_negate_and_link(key, key_negative_timeout, NULL, NULL); key_put(key); <S2SV_StartVul> couldnt_alloc_key: <S2SV_EndVul> key_put(dest_keyring); kleave("" = %d"", ret); return ERR_PTR(ret); }","- user = key_user_lookup(current_fsuid());
- if (!user)
- return ERR_PTR(-ENOMEM);
- construct_get_dest_keyring(&dest_keyring);
- goto couldnt_alloc_key;
- couldnt_alloc_key:
+ ret = construct_get_dest_keyring(&dest_keyring);
+ if (ret)
+ goto error;
+ user = key_user_lookup(current_fsuid());
+ if (!user) {
+ ret = -ENOMEM;
+ goto error_put_dest_keyring;
+ }
+ goto error_put_dest_keyring;
+ error_put_dest_keyring:
+ error:","static struct key *construct_key_and_link(struct keyring_search_context *ctx, const char *callout_info, size_t callout_len, void *aux, struct key *dest_keyring, unsigned long flags) { struct key_user *user; struct key *key; int ret; kenter(""""); if (ctx->index_key.type == &key_type_keyring) return ERR_PTR(-EPERM); ret = construct_get_dest_keyring(&dest_keyring); if (ret) goto error; user = key_user_lookup(current_fsuid()); if (!user) { ret = -ENOMEM; goto error_put_dest_keyring; } ret = construct_alloc_key(ctx, dest_keyring, flags, user, &key); key_user_put(user); if (ret == 0) { ret = construct_key(key, callout_info, callout_len, aux, dest_keyring); if (ret < 0) { kdebug(""cons failed""); goto construction_failed; } } else if (ret == -EINPROGRESS) { ret = 0; } else { goto error_put_dest_keyring; } key_put(dest_keyring); kleave("" = key %d"", key_serial(key)); return key; construction_failed: key_negate_and_link(key, key_negative_timeout, NULL, NULL); key_put(key); error_put_dest_keyring: key_put(dest_keyring); error: kleave("" = %d"", ret); return ERR_PTR(ret); }"
87,5375----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hv_kvp_daemon.c----main,"int main(void) { int fd, len, sock_opt; int error; struct cn_msg *message; struct pollfd pfd; struct nlmsghdr *incoming_msg; struct cn_msg *incoming_cn_msg; struct hv_kvp_msg *hv_msg; char *p; char *key_value; char *key_name; daemon(1, 0); openlog(""KVP"", 0, LOG_USER); syslog(LOG_INFO, ""KVP starting; pid is:%d"", getpid()); kvp_get_os_info(); if (kvp_file_init()) { syslog(LOG_ERR, ""Failed to initialize the pools""); exit(-1); } fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR); if (fd < 0) { syslog(LOG_ERR, ""netlink socket creation failed; error:%d"", fd); exit(-1); } addr.nl_family = AF_NETLINK; addr.nl_pad = 0; addr.nl_pid = 0; addr.nl_groups = CN_KVP_IDX; error = bind(fd, (struct sockaddr *)&addr, sizeof(addr)); if (error < 0) { syslog(LOG_ERR, ""bind failed; error:%d"", error); close(fd); exit(-1); } sock_opt = addr.nl_groups; setsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt)); message = (struct cn_msg *)kvp_send_buffer; message->id.idx = CN_KVP_IDX; message->id.val = CN_KVP_VAL; hv_msg = (struct hv_kvp_msg *)message->data; hv_msg->kvp_hdr.operation = KVP_OP_REGISTER; message->ack = 0; message->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, message); if (len < 0) { syslog(LOG_ERR, ""netlink_send failed; error:%d"", len); close(fd); exit(-1); } pfd.fd = fd; while (1) { pfd.events = POLLIN; pfd.revents = 0; poll(&pfd, 1, -1); <S2SV_StartVul> len = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0); <S2SV_EndVul> <S2SV_StartVul> if (len < 0) { <S2SV_EndVul> <S2SV_StartVul> syslog(LOG_ERR, ""recv failed; error:%d"", len); <S2SV_EndVul> close(fd); return -1; } incoming_msg = (struct nlmsghdr *)kvp_recv_buffer; incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg); hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; switch (hv_msg->kvp_hdr.operation) { case KVP_OP_REGISTER: p = (char *)hv_msg->body.kvp_register.version; lic_version = malloc(strlen(p) + 1); if (lic_version) { strcpy(lic_version, p); syslog(LOG_INFO, ""KVP LIC Version: %s"", lic_version); } else { syslog(LOG_ERR, ""malloc failed""); } continue; case KVP_OP_SET: if (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_GET: if (kvp_get_value(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_DELETE: if (kvp_key_delete(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_delete.key, hv_msg->body.kvp_delete.key_size)) strcpy(hv_msg->body.kvp_delete.key, """"); break; default: break; } if (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE) goto kvp_done; if (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) { kvp_pool_enumerate(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_enum_data.index, hv_msg->body.kvp_enum_data.data.key, HV_KVP_EXCHANGE_MAX_KEY_SIZE, hv_msg->body.kvp_enum_data.data.value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); goto kvp_done; } hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; key_name = (char *)hv_msg->body.kvp_enum_data.data.key; key_value = (char *)hv_msg->body.kvp_enum_data.data.value; switch (hv_msg->body.kvp_enum_data.index) { case FullyQualifiedDomainName: kvp_get_domain_name(key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""FullyQualifiedDomainName""); break; case IntegrationServicesVersion: strcpy(key_name, ""IntegrationServicesVersion""); strcpy(key_value, lic_version); break; case NetworkAddressIPv4: kvp_get_ip_address(AF_INET, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv4""); break; case NetworkAddressIPv6: kvp_get_ip_address(AF_INET6, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv6""); break; case OSBuildNumber: strcpy(key_value, os_build); strcpy(key_name, ""OSBuildNumber""); break; case OSName: strcpy(key_value, os_name); strcpy(key_name, ""OSName""); break; case OSMajorVersion: strcpy(key_value, os_major); strcpy(key_name, ""OSMajorVersion""); break; case OSMinorVersion: strcpy(key_value, os_minor); strcpy(key_name, ""OSMinorVersion""); break; case OSVersion: strcpy(key_value, os_build); strcpy(key_name, ""OSVersion""); break; case ProcessorArchitecture: strcpy(key_value, processor_arch); strcpy(key_name, ""ProcessorArchitecture""); break; default: strcpy(key_value, ""Unknown Key""); strcpy(key_name, """"); break; } kvp_done: incoming_cn_msg->id.idx = CN_KVP_IDX; incoming_cn_msg->id.val = CN_KVP_VAL; incoming_cn_msg->ack = 0; incoming_cn_msg->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, incoming_cn_msg); if (len < 0) { syslog(LOG_ERR, ""net_link send failed; error:%d"", len); exit(-1); } } }","- len = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);
- if (len < 0) {
- syslog(LOG_ERR, ""recv failed; error:%d"", len);
+ struct sockaddr *addr_p = (struct sockaddr *) &addr;
+ socklen_t addr_l = sizeof(addr);
+ len = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,
+ addr_p, &addr_l);
+ if (len < 0 || addr.nl_pid) {
+ syslog(LOG_ERR, ""recvfrom failed; pid:%u error:%d %s"",
+ addr.nl_pid, errno, strerror(errno));","int main(void) { int fd, len, sock_opt; int error; struct cn_msg *message; struct pollfd pfd; struct nlmsghdr *incoming_msg; struct cn_msg *incoming_cn_msg; struct hv_kvp_msg *hv_msg; char *p; char *key_value; char *key_name; daemon(1, 0); openlog(""KVP"", 0, LOG_USER); syslog(LOG_INFO, ""KVP starting; pid is:%d"", getpid()); kvp_get_os_info(); if (kvp_file_init()) { syslog(LOG_ERR, ""Failed to initialize the pools""); exit(-1); } fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR); if (fd < 0) { syslog(LOG_ERR, ""netlink socket creation failed; error:%d"", fd); exit(-1); } addr.nl_family = AF_NETLINK; addr.nl_pad = 0; addr.nl_pid = 0; addr.nl_groups = CN_KVP_IDX; error = bind(fd, (struct sockaddr *)&addr, sizeof(addr)); if (error < 0) { syslog(LOG_ERR, ""bind failed; error:%d"", error); close(fd); exit(-1); } sock_opt = addr.nl_groups; setsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt)); message = (struct cn_msg *)kvp_send_buffer; message->id.idx = CN_KVP_IDX; message->id.val = CN_KVP_VAL; hv_msg = (struct hv_kvp_msg *)message->data; hv_msg->kvp_hdr.operation = KVP_OP_REGISTER; message->ack = 0; message->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, message); if (len < 0) { syslog(LOG_ERR, ""netlink_send failed; error:%d"", len); close(fd); exit(-1); } pfd.fd = fd; while (1) { struct sockaddr *addr_p = (struct sockaddr *) &addr; socklen_t addr_l = sizeof(addr); pfd.events = POLLIN; pfd.revents = 0; poll(&pfd, 1, -1); len = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0, addr_p, &addr_l); if (len < 0 || addr.nl_pid) { syslog(LOG_ERR, ""recvfrom failed; pid:%u error:%d %s"", addr.nl_pid, errno, strerror(errno)); close(fd); return -1; } incoming_msg = (struct nlmsghdr *)kvp_recv_buffer; incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg); hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; switch (hv_msg->kvp_hdr.operation) { case KVP_OP_REGISTER: p = (char *)hv_msg->body.kvp_register.version; lic_version = malloc(strlen(p) + 1); if (lic_version) { strcpy(lic_version, p); syslog(LOG_INFO, ""KVP LIC Version: %s"", lic_version); } else { syslog(LOG_ERR, ""malloc failed""); } continue; case KVP_OP_SET: if (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_GET: if (kvp_get_value(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_DELETE: if (kvp_key_delete(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_delete.key, hv_msg->body.kvp_delete.key_size)) strcpy(hv_msg->body.kvp_delete.key, """"); break; default: break; } if (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE) goto kvp_done; if (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) { kvp_pool_enumerate(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_enum_data.index, hv_msg->body.kvp_enum_data.data.key, HV_KVP_EXCHANGE_MAX_KEY_SIZE, hv_msg->body.kvp_enum_data.data.value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); goto kvp_done; } hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; key_name = (char *)hv_msg->body.kvp_enum_data.data.key; key_value = (char *)hv_msg->body.kvp_enum_data.data.value; switch (hv_msg->body.kvp_enum_data.index) { case FullyQualifiedDomainName: kvp_get_domain_name(key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""FullyQualifiedDomainName""); break; case IntegrationServicesVersion: strcpy(key_name, ""IntegrationServicesVersion""); strcpy(key_value, lic_version); break; case NetworkAddressIPv4: kvp_get_ip_address(AF_INET, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv4""); break; case NetworkAddressIPv6: kvp_get_ip_address(AF_INET6, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv6""); break; case OSBuildNumber: strcpy(key_value, os_build); strcpy(key_name, ""OSBuildNumber""); break; case OSName: strcpy(key_value, os_name); strcpy(key_name, ""OSName""); break; case OSMajorVersion: strcpy(key_value, os_major); strcpy(key_name, ""OSMajorVersion""); break; case OSMinorVersion: strcpy(key_value, os_minor); strcpy(key_name, ""OSMinorVersion""); break; case OSVersion: strcpy(key_value, os_build); strcpy(key_name, ""OSVersion""); break; case ProcessorArchitecture: strcpy(key_value, processor_arch); strcpy(key_name, ""ProcessorArchitecture""); break; default: strcpy(key_value, ""Unknown Key""); strcpy(key_name, """"); break; } kvp_done: incoming_cn_msg->id.idx = CN_KVP_IDX; incoming_cn_msg->id.val = CN_KVP_VAL; incoming_cn_msg->ack = 0; incoming_cn_msg->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, incoming_cn_msg); if (len < 0) { syslog(LOG_ERR, ""net_link send failed; error:%d"", len); exit(-1); } } }"
88,7286----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/elf.c----store_versioninfo_gnu_verneed,"static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { ut8 *end, *need = NULL; const char *section_name = """"; Elf_(Shdr) *link_shdr = NULL; const char *link_section_name = """"; Sdb *sdb_vernaux = NULL; Sdb *sdb_version = NULL; Sdb *sdb = NULL; int i, cnt; if (!bin || !bin->dynstr) { return NULL; } if (shdr->sh_link > bin->ehdr.e_shnum) { return NULL; } if (shdr->sh_size < 1) { return NULL; } sdb = sdb_new0 (); if (!sdb) { return NULL; } link_shdr = &bin->shdr[shdr->sh_link]; if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) { bprintf (""Warning: Cannot allocate memory for Elf_(Verneed)\n""); goto beach; } end = need + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""num_entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); if (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) { goto beach; } if (shdr->sh_offset + shdr->sh_size < shdr->sh_size) { goto beach; } i = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size); if (i < 0) goto beach; for (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) { int j, isum; ut8 *vstart = need + i; Elf_(Verneed) vvn = {0}; if (vstart + sizeof (Elf_(Verneed)) > end) { goto beach; } Elf_(Verneed) *entry = &vvn; char key[32] = {0}; sdb_version = sdb_new0 (); if (!sdb_version) { goto beach; } j = 0; vvn.vn_version = READ16 (vstart, j) vvn.vn_cnt = READ16 (vstart, j) vvn.vn_file = READ32 (vstart, j) vvn.vn_aux = READ32 (vstart, j) vvn.vn_next = READ32 (vstart, j) sdb_num_set (sdb_version, ""vn_version"", entry->vn_version, 0); sdb_num_set (sdb_version, ""idx"", i, 0); if (entry->vn_file > bin->dynstr_size) { goto beach; } { char *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16); sdb_set (sdb_version, ""file_name"", s, 0); free (s); } sdb_num_set (sdb_version, ""cnt"", entry->vn_cnt, 0); <S2SV_StartVul> vstart += entry->vn_aux; <S2SV_EndVul> for (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) { int k; Elf_(Vernaux) * aux = NULL; Elf_(Vernaux) vaux = {0}; sdb_vernaux = sdb_new0 (); if (!sdb_vernaux) { goto beach; } aux = (Elf_(Vernaux)*)&vaux; k = 0; vaux.vna_hash = READ32 (vstart, k) vaux.vna_flags = READ16 (vstart, k) vaux.vna_other = READ16 (vstart, k) vaux.vna_name = READ32 (vstart, k) vaux.vna_next = READ32 (vstart, k) if (aux->vna_name > bin->dynstr_size) { goto beach; } sdb_num_set (sdb_vernaux, ""idx"", isum, 0); if (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) { char name [16]; strncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1); name[sizeof(name)-1] = 0; sdb_set (sdb_vernaux, ""name"", name, 0); } sdb_set (sdb_vernaux, ""flags"", get_ver_flags (aux->vna_flags), 0); sdb_num_set (sdb_vernaux, ""version"", aux->vna_other, 0); isum += aux->vna_next; vstart += aux->vna_next; snprintf (key, sizeof (key), ""vernaux%d"", j); sdb_ns_set (sdb_version, key, sdb_vernaux); } if ((int)entry->vn_next < 0) { bprintf (""Invalid vn_next\n""); break; } i += entry->vn_next; snprintf (key, sizeof (key), ""version%d"", cnt ); sdb_ns_set (sdb, key, sdb_version); if (!entry->vn_next) { break; } } free (need); return sdb; beach: free (need); sdb_free (sdb_vernaux); sdb_free (sdb_version); sdb_free (sdb); return NULL; }","- vstart += entry->vn_aux;
+ st32 vnaux = entry->vn_aux;
+ if (vnaux < 1) {
+ goto beach;
+ }
+ vstart += vnaux;","static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { ut8 *end, *need = NULL; const char *section_name = """"; Elf_(Shdr) *link_shdr = NULL; const char *link_section_name = """"; Sdb *sdb_vernaux = NULL; Sdb *sdb_version = NULL; Sdb *sdb = NULL; int i, cnt; if (!bin || !bin->dynstr) { return NULL; } if (shdr->sh_link > bin->ehdr.e_shnum) { return NULL; } if (shdr->sh_size < 1) { return NULL; } sdb = sdb_new0 (); if (!sdb) { return NULL; } link_shdr = &bin->shdr[shdr->sh_link]; if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!(need = (ut8*) calloc (R_MAX (1, shdr->sh_size), sizeof (ut8)))) { bprintf (""Warning: Cannot allocate memory for Elf_(Verneed)\n""); goto beach; } end = need + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""num_entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); if (shdr->sh_offset > bin->size || shdr->sh_offset + shdr->sh_size > bin->size) { goto beach; } if (shdr->sh_offset + shdr->sh_size < shdr->sh_size) { goto beach; } i = r_buf_read_at (bin->b, shdr->sh_offset, need, shdr->sh_size); if (i < 0) goto beach; for (i = 0, cnt = 0; cnt < shdr->sh_info; ++cnt) { int j, isum; ut8 *vstart = need + i; Elf_(Verneed) vvn = {0}; if (vstart + sizeof (Elf_(Verneed)) > end) { goto beach; } Elf_(Verneed) *entry = &vvn; char key[32] = {0}; sdb_version = sdb_new0 (); if (!sdb_version) { goto beach; } j = 0; vvn.vn_version = READ16 (vstart, j) vvn.vn_cnt = READ16 (vstart, j) vvn.vn_file = READ32 (vstart, j) vvn.vn_aux = READ32 (vstart, j) vvn.vn_next = READ32 (vstart, j) sdb_num_set (sdb_version, ""vn_version"", entry->vn_version, 0); sdb_num_set (sdb_version, ""idx"", i, 0); if (entry->vn_file > bin->dynstr_size) { goto beach; } { char *s = r_str_ndup (&bin->dynstr[entry->vn_file], 16); sdb_set (sdb_version, ""file_name"", s, 0); free (s); } sdb_num_set (sdb_version, ""cnt"", entry->vn_cnt, 0); st32 vnaux = entry->vn_aux; if (vnaux < 1) { goto beach; } vstart += vnaux; for (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) { int k; Elf_(Vernaux) * aux = NULL; Elf_(Vernaux) vaux = {0}; sdb_vernaux = sdb_new0 (); if (!sdb_vernaux) { goto beach; } aux = (Elf_(Vernaux)*)&vaux; k = 0; vaux.vna_hash = READ32 (vstart, k) vaux.vna_flags = READ16 (vstart, k) vaux.vna_other = READ16 (vstart, k) vaux.vna_name = READ32 (vstart, k) vaux.vna_next = READ32 (vstart, k) if (aux->vna_name > bin->dynstr_size) { goto beach; } sdb_num_set (sdb_vernaux, ""idx"", isum, 0); if (aux->vna_name > 0 && aux->vna_name + 8 < bin->dynstr_size) { char name [16]; strncpy (name, &bin->dynstr[aux->vna_name], sizeof (name)-1); name[sizeof(name)-1] = 0; sdb_set (sdb_vernaux, ""name"", name, 0); } sdb_set (sdb_vernaux, ""flags"", get_ver_flags (aux->vna_flags), 0); sdb_num_set (sdb_vernaux, ""version"", aux->vna_other, 0); isum += aux->vna_next; vstart += aux->vna_next; snprintf (key, sizeof (key), ""vernaux%d"", j); sdb_ns_set (sdb_version, key, sdb_vernaux); } if ((int)entry->vn_next < 0) { bprintf (""Invalid vn_next\n""); break; } i += entry->vn_next; snprintf (key, sizeof (key), ""version%d"", cnt ); sdb_ns_set (sdb, key, sdb_version); if (!entry->vn_next) { break; } } free (need); return sdb; beach: free (need); sdb_free (sdb_vernaux); sdb_free (sdb_version); sdb_free (sdb); return NULL; }"
89,7450----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pinctrl-amd.c----amd_gpio_probe,"static int amd_gpio_probe(struct platform_device *pdev) { int ret = 0; int irq_base; struct resource *res; struct amd_gpio *gpio_dev; gpio_dev = devm_kzalloc(&pdev->dev, sizeof(struct amd_gpio), GFP_KERNEL); if (!gpio_dev) return -ENOMEM; spin_lock_init(&gpio_dev->lock); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&pdev->dev, ""Failed to get gpio io resource.\n""); return -EINVAL; } gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start, resource_size(res)); if (!gpio_dev->base) return -ENOMEM; irq_base = platform_get_irq(pdev, 0); if (irq_base < 0) { dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n""); return -EINVAL; } gpio_dev->pdev = pdev; gpio_dev->gc.direction_input = amd_gpio_direction_input; gpio_dev->gc.direction_output = amd_gpio_direction_output; gpio_dev->gc.get = amd_gpio_get_value; gpio_dev->gc.set = amd_gpio_set_value; gpio_dev->gc.set_debounce = amd_gpio_set_debounce; gpio_dev->gc.dbg_show = amd_gpio_dbg_show; gpio_dev->gc.base = 0; gpio_dev->gc.label = pdev->name; gpio_dev->gc.owner = THIS_MODULE; gpio_dev->gc.parent = &pdev->dev; gpio_dev->gc.ngpio = TOTAL_NUMBER_OF_PINS; #if defined(CONFIG_OF_GPIO) gpio_dev->gc.of_node = pdev->dev.of_node; #endif gpio_dev->groups = kerncz_groups; gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups); amd_pinctrl_desc.name = dev_name(&pdev->dev); <S2SV_StartVul> gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc, <S2SV_EndVul> <S2SV_StartVul> &pdev->dev, gpio_dev); <S2SV_EndVul> if (IS_ERR(gpio_dev->pctrl)) { dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n""); return PTR_ERR(gpio_dev->pctrl); } ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev); if (ret) <S2SV_StartVul> goto out1; <S2SV_EndVul> ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev), 0, 0, TOTAL_NUMBER_OF_PINS); if (ret) { dev_err(&pdev->dev, ""Failed to add pin range\n""); goto out2; } ret = gpiochip_irqchip_add(&gpio_dev->gc, &amd_gpio_irqchip, 0, handle_simple_irq, IRQ_TYPE_NONE); if (ret) { dev_err(&pdev->dev, ""could not add irqchip\n""); ret = -ENODEV; goto out2; } gpiochip_set_chained_irqchip(&gpio_dev->gc, &amd_gpio_irqchip, irq_base, amd_gpio_irq_handler); platform_set_drvdata(pdev, gpio_dev); dev_dbg(&pdev->dev, ""amd gpio driver loaded\n""); return ret; out2: gpiochip_remove(&gpio_dev->gc); <S2SV_StartVul> out1: <S2SV_EndVul> <S2SV_StartVul> pinctrl_unregister(gpio_dev->pctrl); <S2SV_EndVul> return ret; }","- gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
- &pdev->dev, gpio_dev);
- goto out1;
- out1:
- pinctrl_unregister(gpio_dev->pctrl);
+ gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
+ gpio_dev);
+ return ret;","static int amd_gpio_probe(struct platform_device *pdev) { int ret = 0; int irq_base; struct resource *res; struct amd_gpio *gpio_dev; gpio_dev = devm_kzalloc(&pdev->dev, sizeof(struct amd_gpio), GFP_KERNEL); if (!gpio_dev) return -ENOMEM; spin_lock_init(&gpio_dev->lock); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&pdev->dev, ""Failed to get gpio io resource.\n""); return -EINVAL; } gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start, resource_size(res)); if (!gpio_dev->base) return -ENOMEM; irq_base = platform_get_irq(pdev, 0); if (irq_base < 0) { dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n""); return -EINVAL; } gpio_dev->pdev = pdev; gpio_dev->gc.direction_input = amd_gpio_direction_input; gpio_dev->gc.direction_output = amd_gpio_direction_output; gpio_dev->gc.get = amd_gpio_get_value; gpio_dev->gc.set = amd_gpio_set_value; gpio_dev->gc.set_debounce = amd_gpio_set_debounce; gpio_dev->gc.dbg_show = amd_gpio_dbg_show; gpio_dev->gc.base = 0; gpio_dev->gc.label = pdev->name; gpio_dev->gc.owner = THIS_MODULE; gpio_dev->gc.parent = &pdev->dev; gpio_dev->gc.ngpio = TOTAL_NUMBER_OF_PINS; #if defined(CONFIG_OF_GPIO) gpio_dev->gc.of_node = pdev->dev.of_node; #endif gpio_dev->groups = kerncz_groups; gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups); amd_pinctrl_desc.name = dev_name(&pdev->dev); gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc, gpio_dev); if (IS_ERR(gpio_dev->pctrl)) { dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n""); return PTR_ERR(gpio_dev->pctrl); } ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev); if (ret) return ret; ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev), 0, 0, TOTAL_NUMBER_OF_PINS); if (ret) { dev_err(&pdev->dev, ""Failed to add pin range\n""); goto out2; } ret = gpiochip_irqchip_add(&gpio_dev->gc, &amd_gpio_irqchip, 0, handle_simple_irq, IRQ_TYPE_NONE); if (ret) { dev_err(&pdev->dev, ""could not add irqchip\n""); ret = -ENODEV; goto out2; } gpiochip_set_chained_irqchip(&gpio_dev->gc, &amd_gpio_irqchip, irq_base, amd_gpio_irq_handler); platform_set_drvdata(pdev, gpio_dev); dev_dbg(&pdev->dev, ""amd gpio driver loaded\n""); return ret; out2: gpiochip_remove(&gpio_dev->gc); return ret; }"
90,6736----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiArray.c----jsi_ArrayFilterCmd,"static Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int curlen, nsiz, i, fval, n = 0, maa = 0; Jsi_Obj *obj, *nobj; Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL; Jsi_Func *fptr = NULL; func = Jsi_ValueArrayIndex(interp, args, 0); if (!Jsi_ValueIsFunction(interp, func)) return Jsi_LogError(""expected function""); sthis = Jsi_ValueArrayIndex(interp, args, 1); if (!sthis) sthis = nthis = Jsi_ValueNew1(interp); obj = _this->d.obj; <S2SV_StartVul> curlen = Jsi_ObjGetLength(interp, obj); <S2SV_EndVul> <S2SV_StartVul> if (curlen < 0) { <S2SV_EndVul> <S2SV_StartVul> Jsi_ObjSetLength(interp, obj, 0); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); nsiz = obj->arrCnt; if (nsiz<=0) nsiz = 1; if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) { Jsi_LogError(""index too large: %d"", nsiz); rc = JSI_ERROR; goto bail; } Jsi_ValueMakeArrayObject(interp, ret, nobj); nrPtr = Jsi_ValueNew1(interp); Jsi_Value *vobjs[4]; fptr = func->d.obj->d.fobj->func; maa = (fptr->argnames?fptr->argnames->argCnt:0); if (maa>3) maa = 3; for (i = 0; i < curlen; i++) { if (!obj->arr[i]) continue; vobjs[0] = obj->arr[i]; vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL); vobjs[2] = _this; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0)); Jsi_IncrRefCount(interp, vpargs); rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis); Jsi_DecrRefCount(interp, vpargs); fval = Jsi_ValueIsTrue(interp, nrPtr); Jsi_ValueMakeUndef(interp, &nrPtr); if( JSI_OK!=rc ) { goto bail; } if (fval) { nobj->arr[n++] = obj->arr[i]; Jsi_IncrRefCount(interp, obj->arr[i]); } } if (nthis) Jsi_DecrRefCount(interp, nthis); Jsi_DecrRefCount(interp, nrPtr); Jsi_ObjSetLength(interp, nobj, n); return JSI_OK; bail: if (nthis) Jsi_DecrRefCount(interp, nthis); if (nrPtr) Jsi_DecrRefCount(interp, nrPtr); Jsi_ValueMakeNull(interp, ret); return rc; }","- curlen = Jsi_ObjGetLength(interp, obj);
- if (curlen < 0) {
- Jsi_ObjSetLength(interp, obj, 0);
- }
+ curlen = jsi_SizeOfArray(interp, obj);","static Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int curlen, nsiz, i, fval, n = 0, maa = 0; Jsi_Obj *obj, *nobj; Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL; Jsi_Func *fptr = NULL; func = Jsi_ValueArrayIndex(interp, args, 0); if (!Jsi_ValueIsFunction(interp, func)) return Jsi_LogError(""expected function""); sthis = Jsi_ValueArrayIndex(interp, args, 1); if (!sthis) sthis = nthis = Jsi_ValueNew1(interp); obj = _this->d.obj; curlen = jsi_SizeOfArray(interp, obj); Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); nsiz = obj->arrCnt; if (nsiz<=0) nsiz = 1; if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) { Jsi_LogError(""index too large: %d"", nsiz); rc = JSI_ERROR; goto bail; } Jsi_ValueMakeArrayObject(interp, ret, nobj); nrPtr = Jsi_ValueNew1(interp); Jsi_Value *vobjs[4]; fptr = func->d.obj->d.fobj->func; maa = (fptr->argnames?fptr->argnames->argCnt:0); if (maa>3) maa = 3; for (i = 0; i < curlen; i++) { if (!obj->arr[i]) continue; vobjs[0] = obj->arr[i]; vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL); vobjs[2] = _this; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0)); Jsi_IncrRefCount(interp, vpargs); rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis); Jsi_DecrRefCount(interp, vpargs); fval = Jsi_ValueIsTrue(interp, nrPtr); Jsi_ValueMakeUndef(interp, &nrPtr); if( JSI_OK!=rc ) { goto bail; } if (fval) { nobj->arr[n++] = obj->arr[i]; Jsi_IncrRefCount(interp, obj->arr[i]); } } if (nthis) Jsi_DecrRefCount(interp, nthis); Jsi_DecrRefCount(interp, nrPtr); Jsi_ObjSetLength(interp, nobj, n); return JSI_OK; bail: if (nthis) Jsi_DecrRefCount(interp, nthis); if (nrPtr) Jsi_DecrRefCount(interp, nrPtr); Jsi_ValueMakeNull(interp, ret); return rc; }"
91,929----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9535--tif_predict.c----horAcc16,"<S2SV_StartVul> horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> tmsize_t stride = PredictorState(tif)->stride; <S2SV_EndVul> <S2SV_StartVul> uint16* wp = (uint16*) cp0; <S2SV_EndVul> <S2SV_StartVul> tmsize_t wc = cc / 2; <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> assert((cc%(2*stride))==0); <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> if (wc > stride) { <S2SV_EndVul> <S2SV_StartVul> wc -= stride; <S2SV_EndVul> <S2SV_StartVul> do { <S2SV_EndVul> REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++) wc -= stride; } while (wc > 0); } }","- horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
- {
- tmsize_t stride = PredictorState(tif)->stride;
- uint16* wp = (uint16*) cp0;
- tmsize_t wc = cc / 2;
- 
- assert((cc%(2*stride))==0);
- 
- if (wc > stride) {
- wc -= stride;
- do {
+ horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)
+ {
+ tmsize_t stride = PredictorState(tif)->stride;
+ uint16* wp = (uint16*) cp0;
+ tmsize_t wc = cc / 2;
+ 
+ if((cc%(2*stride))!=0)
+ {
+ TIFFErrorExt(tif->tif_clientdata, ""horAcc16"",
+ ""%s"", ""cc%(2*stride))!=0"");
+ return 0;","horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; uint16* wp = (uint16*) cp0; tmsize_t wc = cc / 2; if((cc%(2*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, ""horAcc16"", ""%s"", ""cc%(2*stride))!=0""); return 0; } if (wc > stride) { wc -= stride; do { REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++) wc -= stride; } while (wc > 0); } return 1; }"
92,5845----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiSqlite.c----dbOutputHexBlob,"static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){ int i; <S2SV_StartVul> char out[100], *zBlob = (char *)pBlob; <S2SV_EndVul> Jsi_DSAppend(dStr, ""X'"", NULL); for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),""%02x"",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); } Jsi_DSAppend(dStr, ""'"", NULL); }","- char out[100], *zBlob = (char *)pBlob;
+ char out[JSI_MAX_NUMBER_STRING], *zBlob = (char *)pBlob;","static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){ int i; char out[JSI_MAX_NUMBER_STRING], *zBlob = (char *)pBlob; Jsi_DSAppend(dStr, ""X'"", NULL); for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),""%02x"",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); } Jsi_DSAppend(dStr, ""'"", NULL); }"
93,1647----CWE-532----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5549--kl5kusb105.c----klsi_105_get_line_state,"static int klsi_105_get_line_state(struct usb_serial_port *port, unsigned long *line_state_p) { int rc; u8 *status_buf; __u16 status; dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n""); status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL); if (!status_buf) return -ENOMEM; status_buf[0] = 0xff; status_buf[1] = 0xff; rc = usb_control_msg(port->serial->dev, usb_rcvctrlpipe(port->serial->dev, 0), KL5KUSB105A_SIO_POLL, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0, status_buf, KLSI_STATUSBUF_LEN, 10000 ); <S2SV_StartVul> if (rc < 0) <S2SV_EndVul> <S2SV_StartVul> dev_err(&port->dev, ""Reading line status failed (error = %d)\n"", <S2SV_EndVul> <S2SV_StartVul> rc); <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_EndVul> status = get_unaligned_le16(status_buf); dev_info(&port->serial->dev->dev, ""read status %x %x\n"", status_buf[0], status_buf[1]); *line_state_p = klsi_105_status2linestate(status); } kfree(status_buf); return rc; }","- if (rc < 0)
- dev_err(&port->dev, ""Reading line status failed (error = %d)\n"",
- rc);
- else {
+ if (rc != KLSI_STATUSBUF_LEN) {
+ dev_err(&port->dev, ""reading line status failed: %d\n"", rc);
+ if (rc >= 0)
+ rc = -EIO;
+ } else {","static int klsi_105_get_line_state(struct usb_serial_port *port, unsigned long *line_state_p) { int rc; u8 *status_buf; __u16 status; dev_info(&port->serial->dev->dev, ""sending SIO Poll request\n""); status_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL); if (!status_buf) return -ENOMEM; status_buf[0] = 0xff; status_buf[1] = 0xff; rc = usb_control_msg(port->serial->dev, usb_rcvctrlpipe(port->serial->dev, 0), KL5KUSB105A_SIO_POLL, USB_TYPE_VENDOR | USB_DIR_IN, 0, 0, status_buf, KLSI_STATUSBUF_LEN, 10000 ); if (rc != KLSI_STATUSBUF_LEN) { dev_err(&port->dev, ""reading line status failed: %d\n"", rc); if (rc >= 0) rc = -EIO; } else { status = get_unaligned_le16(status_buf); dev_info(&port->serial->dev->dev, ""read status %x %x\n"", status_buf[0], status_buf[1]); *line_state_p = klsi_105_status2linestate(status); } kfree(status_buf); return rc; }"
94,569----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-6536--xfrm_user.c----xfrm_alloc_replay_state_esn,"static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn, struct xfrm_replay_state_esn **preplay_esn, struct nlattr *rta) { struct xfrm_replay_state_esn *p, *pp, *up; if (!rta) return 0; up = nla_data(rta); <S2SV_StartVul> p = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL); <S2SV_EndVul> if (!p) return -ENOMEM; <S2SV_StartVul> pp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL); <S2SV_EndVul> if (!pp) { kfree(p); return -ENOMEM; } *replay_esn = p; *preplay_esn = pp; return 0; }","- p = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);
- pp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);
+ int klen, ulen;
+ klen = xfrm_replay_state_esn_len(up);
+ ulen = nla_len(rta) >= klen ? klen : sizeof(*up);
+ p = kzalloc(klen, GFP_KERNEL);
+ pp = kzalloc(klen, GFP_KERNEL);
+ memcpy(p, up, ulen);
+ memcpy(pp, up, ulen);","static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn, struct xfrm_replay_state_esn **preplay_esn, struct nlattr *rta) { struct xfrm_replay_state_esn *p, *pp, *up; int klen, ulen; if (!rta) return 0; up = nla_data(rta); klen = xfrm_replay_state_esn_len(up); ulen = nla_len(rta) >= klen ? klen : sizeof(*up); p = kzalloc(klen, GFP_KERNEL); if (!p) return -ENOMEM; pp = kzalloc(klen, GFP_KERNEL); if (!pp) { kfree(p); return -ENOMEM; } memcpy(p, up, ulen); memcpy(pp, up, ulen); *replay_esn = p; *preplay_esn = pp; return 0; }"
95,3965----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tcp_ipv4.c----tcp_v4_syn_recv_sock,"struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst) { struct inet_request_sock *ireq; struct inet_sock *newinet; struct tcp_sock *newtp; struct sock *newsk; #ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key *key; #endif if (sk_acceptq_is_full(sk)) goto exit_overflow; if (!dst && (dst = inet_csk_route_req(sk, req)) == NULL) goto exit; newsk = tcp_create_openreq_child(sk, req, skb); if (!newsk) goto exit_nonewsk; newsk->sk_gso_type = SKB_GSO_TCPV4; sk_setup_caps(newsk, dst); newtp = tcp_sk(newsk); newinet = inet_sk(newsk); ireq = inet_rsk(req); newinet->inet_daddr = ireq->rmt_addr; newinet->inet_rcv_saddr = ireq->loc_addr; newinet->inet_saddr = ireq->loc_addr; <S2SV_StartVul> newinet->opt = ireq->opt; <S2SV_EndVul> ireq->opt = NULL; newinet->mc_index = inet_iif(skb); newinet->mc_ttl = ip_hdr(skb)->ttl; inet_csk(newsk)->icsk_ext_hdr_len = 0; <S2SV_StartVul> if (newinet->opt) <S2SV_EndVul> <S2SV_StartVul> inet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen; <S2SV_EndVul> newinet->inet_id = newtp->write_seq ^ jiffies; tcp_mtup_init(newsk); tcp_sync_mss(newsk, dst_mtu(dst)); newtp->advmss = dst_metric_advmss(dst); if (tcp_sk(sk)->rx_opt.user_mss && tcp_sk(sk)->rx_opt.user_mss < newtp->advmss) newtp->advmss = tcp_sk(sk)->rx_opt.user_mss; tcp_initialize_rcv_mss(newsk); #ifdef CONFIG_TCP_MD5SIG key = tcp_v4_md5_do_lookup(sk, newinet->inet_daddr); if (key != NULL) { char *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC); if (newkey != NULL) tcp_v4_md5_do_add(newsk, newinet->inet_daddr, newkey, key->keylen); sk_nocaps_add(newsk, NETIF_F_GSO_MASK); } #endif if (__inet_inherit_port(sk, newsk) < 0) { sock_put(newsk); goto exit; } __inet_hash_nolisten(newsk, NULL); return newsk; exit_overflow: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS); exit_nonewsk: dst_release(dst); exit: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS); return NULL; }","- newinet->opt = ireq->opt;
- if (newinet->opt)
- inet_csk(newsk)->icsk_ext_hdr_len = newinet->opt->optlen;
+ struct ip_options_rcu *inet_opt;
+ inet_opt = ireq->opt;
+ rcu_assign_pointer(newinet->inet_opt, inet_opt);
+ if (inet_opt)
+ inet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen;","struct sock *tcp_v4_syn_recv_sock(struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst) { struct inet_request_sock *ireq; struct inet_sock *newinet; struct tcp_sock *newtp; struct sock *newsk; #ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key *key; #endif struct ip_options_rcu *inet_opt; if (sk_acceptq_is_full(sk)) goto exit_overflow; if (!dst && (dst = inet_csk_route_req(sk, req)) == NULL) goto exit; newsk = tcp_create_openreq_child(sk, req, skb); if (!newsk) goto exit_nonewsk; newsk->sk_gso_type = SKB_GSO_TCPV4; sk_setup_caps(newsk, dst); newtp = tcp_sk(newsk); newinet = inet_sk(newsk); ireq = inet_rsk(req); newinet->inet_daddr = ireq->rmt_addr; newinet->inet_rcv_saddr = ireq->loc_addr; newinet->inet_saddr = ireq->loc_addr; inet_opt = ireq->opt; rcu_assign_pointer(newinet->inet_opt, inet_opt); ireq->opt = NULL; newinet->mc_index = inet_iif(skb); newinet->mc_ttl = ip_hdr(skb)->ttl; inet_csk(newsk)->icsk_ext_hdr_len = 0; if (inet_opt) inet_csk(newsk)->icsk_ext_hdr_len = inet_opt->opt.optlen; newinet->inet_id = newtp->write_seq ^ jiffies; tcp_mtup_init(newsk); tcp_sync_mss(newsk, dst_mtu(dst)); newtp->advmss = dst_metric_advmss(dst); if (tcp_sk(sk)->rx_opt.user_mss && tcp_sk(sk)->rx_opt.user_mss < newtp->advmss) newtp->advmss = tcp_sk(sk)->rx_opt.user_mss; tcp_initialize_rcv_mss(newsk); #ifdef CONFIG_TCP_MD5SIG key = tcp_v4_md5_do_lookup(sk, newinet->inet_daddr); if (key != NULL) { char *newkey = kmemdup(key->key, key->keylen, GFP_ATOMIC); if (newkey != NULL) tcp_v4_md5_do_add(newsk, newinet->inet_daddr, newkey, key->keylen); sk_nocaps_add(newsk, NETIF_F_GSO_MASK); } #endif if (__inet_inherit_port(sk, newsk) < 0) { sock_put(newsk); goto exit; } __inet_hash_nolisten(newsk, NULL); return newsk; exit_overflow: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS); exit_nonewsk: dst_release(dst); exit: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS); return NULL; }"
96,3998----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gup.c----get_gate_page,"static int get_gate_page(struct mm_struct *mm, unsigned long address, unsigned int gup_flags, struct vm_area_struct **vma, struct page **page) { pgd_t *pgd; p4d_t *p4d; pud_t *pud; pmd_t *pmd; pte_t *pte; int ret = -EFAULT; if (gup_flags & FOLL_WRITE) return -EFAULT; if (address > TASK_SIZE) pgd = pgd_offset_k(address); else pgd = pgd_offset_gate(mm, address); BUG_ON(pgd_none(*pgd)); p4d = p4d_offset(pgd, address); BUG_ON(p4d_none(*p4d)); pud = pud_offset(p4d, address); BUG_ON(pud_none(*pud)); pmd = pmd_offset(pud, address); if (!pmd_present(*pmd)) return -EFAULT; VM_BUG_ON(pmd_trans_huge(*pmd)); pte = pte_offset_map(pmd, address); if (pte_none(*pte)) goto unmap; *vma = get_gate_vma(mm); if (!page) goto out; *page = vm_normal_page(*vma, address, *pte); if (!*page) { if ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte))) goto unmap; *page = pte_page(*pte); if (is_device_public_page(*page)) goto unmap; } <S2SV_StartVul> get_page(*page); <S2SV_EndVul> out: ret = 0; unmap: pte_unmap(pte); return ret; }","- get_page(*page);
+ if (unlikely(!try_get_page(*page))) {
+ ret = -ENOMEM;
+ goto unmap;
+ }","static int get_gate_page(struct mm_struct *mm, unsigned long address, unsigned int gup_flags, struct vm_area_struct **vma, struct page **page) { pgd_t *pgd; p4d_t *p4d; pud_t *pud; pmd_t *pmd; pte_t *pte; int ret = -EFAULT; if (gup_flags & FOLL_WRITE) return -EFAULT; if (address > TASK_SIZE) pgd = pgd_offset_k(address); else pgd = pgd_offset_gate(mm, address); BUG_ON(pgd_none(*pgd)); p4d = p4d_offset(pgd, address); BUG_ON(p4d_none(*p4d)); pud = pud_offset(p4d, address); BUG_ON(pud_none(*pud)); pmd = pmd_offset(pud, address); if (!pmd_present(*pmd)) return -EFAULT; VM_BUG_ON(pmd_trans_huge(*pmd)); pte = pte_offset_map(pmd, address); if (pte_none(*pte)) goto unmap; *vma = get_gate_vma(mm); if (!page) goto out; *page = vm_normal_page(*vma, address, *pte); if (!*page) { if ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte))) goto unmap; *page = pte_page(*pte); if (is_device_public_page(*page)) goto unmap; } if (unlikely(!try_get_page(*page))) { ret = -ENOMEM; goto unmap; } out: ret = 0; unmap: pte_unmap(pte); return ret; }"
97,7503----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/g2meet.c----kempf_decode_tile,"static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y, const uint8_t *src, int src_size) { int width, height; int hdr, zsize, npal, tidx = -1, ret; int i, j; const uint8_t *src_end = src + src_size; uint8_t pal[768], transp[3]; uLongf dlen = (c->tile_width + 1) * c->tile_height; int sub_type; int nblocks, cblocks, bstride; int bits, bitbuf, coded; uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 + tile_y * c->tile_height * c->framebuf_stride; if (src_size < 2) return AVERROR_INVALIDDATA; width = FFMIN(c->width - tile_x * c->tile_width, c->tile_width); height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height); hdr = *src++; sub_type = hdr >> 5; if (sub_type == 0) { int j; memcpy(transp, src, 3); src += 3; for (j = 0; j < height; j++, dst += c->framebuf_stride) for (i = 0; i < width; i++) memcpy(dst + i * 3, transp, 3); return 0; } else if (sub_type == 1) { return jpg_decode_data(&c->jc, width, height, src, src_end - src, dst, c->framebuf_stride, NULL, 0, 0, 0); } if (sub_type != 2) { memcpy(transp, src, 3); src += 3; } npal = *src++ + 1; memcpy(pal, src, npal * 3); src += npal * 3; if (sub_type != 2) { for (i = 0; i < npal; i++) { if (!memcmp(pal + i * 3, transp, 3)) { tidx = i; break; } } } if (src_end - src < 2) return 0; zsize = (src[0] << 8) | src[1]; src += 2; <S2SV_StartVul> if (src_end - src < zsize) <S2SV_EndVul> return AVERROR_INVALIDDATA; ret = uncompress(c->kempf_buf, &dlen, src, zsize); if (ret) return AVERROR_INVALIDDATA; src += zsize; if (sub_type == 2) { kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride, NULL, 0, width, height, pal, npal, tidx); return 0; } nblocks = *src++ + 1; cblocks = 0; bstride = FFALIGN(width, 16) >> 4; bits = 0; for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) { for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) { if (!bits) { bitbuf = *src++; bits = 8; } coded = bitbuf & 1; bits--; bitbuf >>= 1; cblocks += coded; if (cblocks > nblocks) return AVERROR_INVALIDDATA; c->kempf_flags[j + i * bstride] = coded; } } memset(c->jpeg_tile, 0, c->tile_stride * height); jpg_decode_data(&c->jc, width, height, src, src_end - src, c->jpeg_tile, c->tile_stride, c->kempf_flags, bstride, nblocks, 0); kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride, c->jpeg_tile, c->tile_stride, width, height, pal, npal, tidx); return 0; }","- if (src_end - src < zsize)
+ if (src_end - src < zsize + (sub_type != 2))
+ if (src >= src_end)
+ return AVERROR_INVALIDDATA;","static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y, const uint8_t *src, int src_size) { int width, height; int hdr, zsize, npal, tidx = -1, ret; int i, j; const uint8_t *src_end = src + src_size; uint8_t pal[768], transp[3]; uLongf dlen = (c->tile_width + 1) * c->tile_height; int sub_type; int nblocks, cblocks, bstride; int bits, bitbuf, coded; uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 + tile_y * c->tile_height * c->framebuf_stride; if (src_size < 2) return AVERROR_INVALIDDATA; width = FFMIN(c->width - tile_x * c->tile_width, c->tile_width); height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height); hdr = *src++; sub_type = hdr >> 5; if (sub_type == 0) { int j; memcpy(transp, src, 3); src += 3; for (j = 0; j < height; j++, dst += c->framebuf_stride) for (i = 0; i < width; i++) memcpy(dst + i * 3, transp, 3); return 0; } else if (sub_type == 1) { return jpg_decode_data(&c->jc, width, height, src, src_end - src, dst, c->framebuf_stride, NULL, 0, 0, 0); } if (sub_type != 2) { memcpy(transp, src, 3); src += 3; } npal = *src++ + 1; memcpy(pal, src, npal * 3); src += npal * 3; if (sub_type != 2) { for (i = 0; i < npal; i++) { if (!memcmp(pal + i * 3, transp, 3)) { tidx = i; break; } } } if (src_end - src < 2) return 0; zsize = (src[0] << 8) | src[1]; src += 2; if (src_end - src < zsize + (sub_type != 2)) return AVERROR_INVALIDDATA; ret = uncompress(c->kempf_buf, &dlen, src, zsize); if (ret) return AVERROR_INVALIDDATA; src += zsize; if (sub_type == 2) { kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride, NULL, 0, width, height, pal, npal, tidx); return 0; } nblocks = *src++ + 1; cblocks = 0; bstride = FFALIGN(width, 16) >> 4; bits = 0; for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) { for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) { if (!bits) { if (src >= src_end) return AVERROR_INVALIDDATA; bitbuf = *src++; bits = 8; } coded = bitbuf & 1; bits--; bitbuf >>= 1; cblocks += coded; if (cblocks > nblocks) return AVERROR_INVALIDDATA; c->kempf_flags[j + i * bstride] = coded; } } memset(c->jpeg_tile, 0, c->tile_stride * height); jpg_decode_data(&c->jc, width, height, src, src_end - src, c->jpeg_tile, c->tile_stride, c->kempf_flags, bstride, nblocks, 0); kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride, c->jpeg_tile, c->tile_stride, width, height, pal, npal, tidx); return 0; }"
98,3658----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ctx.c----context_init,"int context_init(SERVICE_OPTIONS *section) { #if OPENSSL_VERSION_NUMBER>=0x10100000L if(section->option.client) section->ctx=SSL_CTX_new(TLS_client_method()); else section->ctx=SSL_CTX_new(TLS_server_method()); if(!SSL_CTX_set_min_proto_version(section->ctx, section->min_proto_version)) { s_log(LOG_ERR, ""Failed to set the minimum protocol version 0x%X"", section->min_proto_version); return 1; } if(!SSL_CTX_set_max_proto_version(section->ctx, section->max_proto_version)) { s_log(LOG_ERR, ""Failed to set the maximum protocol version 0x%X"", section->max_proto_version); return 1; } #else if(section->option.client) section->ctx=SSL_CTX_new(section->client_method); else section->ctx=SSL_CTX_new(section->server_method); #endif if(!section->ctx) { sslerror(""SSL_CTX_new""); return 1; } if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) { sslerror(""SSL_CTX_set_ex_data""); return 1; } current_section=section; if(section->cipher_list) { s_log(LOG_DEBUG, ""Ciphers: %s"", section->cipher_list); if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) { sslerror(""SSL_CTX_set_cipher_list""); return 1; } } #ifndef OPENSSL_NO_TLS1_3 if(section->ciphersuites) { s_log(LOG_DEBUG, ""TLSv1.3 ciphersuites: %s"", section->ciphersuites); if(!SSL_CTX_set_ciphersuites(section->ctx, section->ciphersuites)) { sslerror(""SSL_CTX_set_ciphersuites""); return 1; } } #endif SSL_CTX_set_options(section->ctx, SSL_OP_NO_SSLv2|SSL_OP_NO_SSLv3); #ifdef SSL_OP_NO_COMPRESSION SSL_CTX_clear_options(section->ctx, SSL_OP_NO_COMPRESSION); #endif SSL_CTX_set_options(section->ctx, (SSL_OPTIONS_TYPE)(section->ssl_options_set)); #if OPENSSL_VERSION_NUMBER>=0x009080dfL SSL_CTX_clear_options(section->ctx, (SSL_OPTIONS_TYPE)(section->ssl_options_clear)); #endif #if OPENSSL_VERSION_NUMBER>=0x009080dfL s_log(LOG_DEBUG, ""TLS options: 0x%08lX (+0x%08lX, -0x%08lX)"", SSL_CTX_get_options(section->ctx), section->ssl_options_set, section->ssl_options_clear); #else s_log(LOG_DEBUG, ""TLS options: 0x%08lX (+0x%08lX)"", SSL_CTX_get_options(section->ctx), section->ssl_options_set); #endif if(conf_init(section)) return 1; #ifdef SSL_MODE_RELEASE_BUFFERS SSL_CTX_set_mode(section->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_RELEASE_BUFFERS); #else SSL_CTX_set_mode(section->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER); #endif #if OPENSSL_VERSION_NUMBER >= 0x10101000L SSL_CTX_set_session_ticket_cb(section->ctx, generate_session_ticket_cb, decrypt_session_ticket_cb, NULL); #endif #if OPENSSL_VERSION_NUMBER>=0x10000000L if((section->ticket_key)&&(section->ticket_mac)) SSL_CTX_set_tlsext_ticket_key_cb(section->ctx, ssl_tlsext_ticket_key_cb); #endif if(!section->option.client) { unsigned servname_len=(unsigned)strlen(section->servname); if(servname_len>SSL_MAX_SSL_SESSION_ID_LENGTH) servname_len=SSL_MAX_SSL_SESSION_ID_LENGTH; if(!SSL_CTX_set_session_id_context(section->ctx, (unsigned char *)section->servname, servname_len)) { sslerror(""SSL_CTX_set_session_id_context""); return 1; } } SSL_CTX_set_session_cache_mode(section->ctx, SSL_SESS_CACHE_BOTH | SSL_SESS_CACHE_NO_INTERNAL_STORE); SSL_CTX_sess_set_cache_size(section->ctx, section->session_size); SSL_CTX_set_timeout(section->ctx, section->session_timeout); SSL_CTX_sess_set_new_cb(section->ctx, sess_new_cb); SSL_CTX_sess_set_get_cb(section->ctx, sess_get_cb); SSL_CTX_sess_set_remove_cb(section->ctx, sess_remove_cb); SSL_CTX_set_info_callback(section->ctx, info_callback); if(auth_init(section)) return 1; if(verify_init(section)) return 1; <S2SV_StartVul> if(!section->option.client) { <S2SV_EndVul> #ifndef OPENSSL_NO_TLSEXT SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb); #endif #ifndef OPENSSL_NO_DH <S2SV_StartVul> dh_init(section); <S2SV_EndVul> #endif #ifndef OPENSSL_NO_ECDH <S2SV_StartVul> ecdh_init(section); <S2SV_EndVul> #endif <S2SV_StartVul> } <S2SV_EndVul> return 0; }","- if(!section->option.client) {
- }
+ #if OPENSSL_VERSION_NUMBER>=0x10100000L
+ if(section->security_level>=0) {
+ SSL_CTX_set_security_level(section->ctx, section->security_level);
+ s_log(LOG_INFO, ""User-specified security level set: %d"",
+ section->security_level);
+ } else if(SSL_CTX_get_security_level(section->ctx)<DEFAULT_SECURITY_LEVEL) {
+ SSL_CTX_set_security_level(section->ctx, DEFAULT_SECURITY_LEVEL);
+ s_log(LOG_INFO, ""stunnel default security level set: %d"",
+ DEFAULT_SECURITY_LEVEL);
+ s_log(LOG_INFO, ""OpenSSL security level is used: %d"",
+ SSL_CTX_get_security_level(section->ctx));
+ }
+ if(!section->option.client)","int context_init(SERVICE_OPTIONS *section) { #if OPENSSL_VERSION_NUMBER>=0x10100000L if(section->option.client) section->ctx=SSL_CTX_new(TLS_client_method()); else section->ctx=SSL_CTX_new(TLS_server_method()); if(!SSL_CTX_set_min_proto_version(section->ctx, section->min_proto_version)) { s_log(LOG_ERR, ""Failed to set the minimum protocol version 0x%X"", section->min_proto_version); return 1; } if(!SSL_CTX_set_max_proto_version(section->ctx, section->max_proto_version)) { s_log(LOG_ERR, ""Failed to set the maximum protocol version 0x%X"", section->max_proto_version); return 1; } #else if(section->option.client) section->ctx=SSL_CTX_new(section->client_method); else section->ctx=SSL_CTX_new(section->server_method); #endif if(!section->ctx) { sslerror(""SSL_CTX_new""); return 1; } if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) { sslerror(""SSL_CTX_set_ex_data""); return 1; } current_section=section; #if OPENSSL_VERSION_NUMBER>=0x10100000L if(section->security_level>=0) { SSL_CTX_set_security_level(section->ctx, section->security_level); s_log(LOG_INFO, ""User-specified security level set: %d"", section->security_level); } else if(SSL_CTX_get_security_level(section->ctx)<DEFAULT_SECURITY_LEVEL) { SSL_CTX_set_security_level(section->ctx, DEFAULT_SECURITY_LEVEL); s_log(LOG_INFO, ""stunnel default security level set: %d"", DEFAULT_SECURITY_LEVEL); } else { s_log(LOG_INFO, ""OpenSSL security level is used: %d"", SSL_CTX_get_security_level(section->ctx)); } #endif if(section->cipher_list) { s_log(LOG_DEBUG, ""Ciphers: %s"", section->cipher_list); if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) { sslerror(""SSL_CTX_set_cipher_list""); return 1; } } #ifndef OPENSSL_NO_TLS1_3 if(section->ciphersuites) { s_log(LOG_DEBUG, ""TLSv1.3 ciphersuites: %s"", section->ciphersuites); if(!SSL_CTX_set_ciphersuites(section->ctx, section->ciphersuites)) { sslerror(""SSL_CTX_set_ciphersuites""); return 1; } } #endif SSL_CTX_set_options(section->ctx, SSL_OP_NO_SSLv2|SSL_OP_NO_SSLv3); #ifdef SSL_OP_NO_COMPRESSION SSL_CTX_clear_options(section->ctx, SSL_OP_NO_COMPRESSION); #endif SSL_CTX_set_options(section->ctx, (SSL_OPTIONS_TYPE)(section->ssl_options_set)); #if OPENSSL_VERSION_NUMBER>=0x009080dfL SSL_CTX_clear_options(section->ctx, (SSL_OPTIONS_TYPE)(section->ssl_options_clear)); #endif #if OPENSSL_VERSION_NUMBER>=0x009080dfL s_log(LOG_DEBUG, ""TLS options: 0x%08lX (+0x%08lX, -0x%08lX)"", SSL_CTX_get_options(section->ctx), section->ssl_options_set, section->ssl_options_clear); #else s_log(LOG_DEBUG, ""TLS options: 0x%08lX (+0x%08lX)"", SSL_CTX_get_options(section->ctx), section->ssl_options_set); #endif if(conf_init(section)) return 1; #ifdef SSL_MODE_RELEASE_BUFFERS SSL_CTX_set_mode(section->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER | SSL_MODE_RELEASE_BUFFERS); #else SSL_CTX_set_mode(section->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER); #endif #if OPENSSL_VERSION_NUMBER >= 0x10101000L SSL_CTX_set_session_ticket_cb(section->ctx, generate_session_ticket_cb, decrypt_session_ticket_cb, NULL); #endif #if OPENSSL_VERSION_NUMBER>=0x10000000L if((section->ticket_key)&&(section->ticket_mac)) SSL_CTX_set_tlsext_ticket_key_cb(section->ctx, ssl_tlsext_ticket_key_cb); #endif if(!section->option.client) { unsigned servname_len=(unsigned)strlen(section->servname); if(servname_len>SSL_MAX_SSL_SESSION_ID_LENGTH) servname_len=SSL_MAX_SSL_SESSION_ID_LENGTH; if(!SSL_CTX_set_session_id_context(section->ctx, (unsigned char *)section->servname, servname_len)) { sslerror(""SSL_CTX_set_session_id_context""); return 1; } } SSL_CTX_set_session_cache_mode(section->ctx, SSL_SESS_CACHE_BOTH | SSL_SESS_CACHE_NO_INTERNAL_STORE); SSL_CTX_sess_set_cache_size(section->ctx, section->session_size); SSL_CTX_set_timeout(section->ctx, section->session_timeout); SSL_CTX_sess_set_new_cb(section->ctx, sess_new_cb); SSL_CTX_sess_set_get_cb(section->ctx, sess_get_cb); SSL_CTX_sess_set_remove_cb(section->ctx, sess_remove_cb); SSL_CTX_set_info_callback(section->ctx, info_callback); if(auth_init(section)) return 1; if(verify_init(section)) return 1; #ifndef OPENSSL_NO_TLSEXT if(!section->option.client) SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb); #endif #ifndef OPENSSL_NO_DH dh_init(section); #endif #ifndef OPENSSL_NO_ECDH ecdh_init(section); #endif return 0; }"
99,614----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-6418--auth_x.c----ceph_x_proc_ticket_reply,"static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac, struct ceph_crypto_key *secret, void *buf, void *end) { void *p = buf; <S2SV_StartVul> char *dbuf; <S2SV_EndVul> <S2SV_StartVul> char *ticket_buf; <S2SV_EndVul> u8 reply_struct_v; u32 num; int ret; <S2SV_StartVul> dbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS); <S2SV_EndVul> <S2SV_StartVul> if (!dbuf) <S2SV_EndVul> <S2SV_StartVul> return -ENOMEM; <S2SV_EndVul> ret = -ENOMEM; <S2SV_StartVul> ticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS); <S2SV_EndVul> <S2SV_StartVul> if (!ticket_buf) <S2SV_EndVul> <S2SV_StartVul> goto out_dbuf; <S2SV_EndVul> <S2SV_StartVul> ceph_decode_8_safe(&p, end, reply_struct_v, bad); <S2SV_EndVul> if (reply_struct_v != 1) return -EINVAL; ceph_decode_32_safe(&p, end, num, bad); dout(""%d tickets\n"", num); while (num--) { ret = process_one_ticket(ac, secret, &p, end, dbuf, ticket_buf); <S2SV_StartVul> if (ret) <S2SV_EndVul> <S2SV_StartVul> goto out; <S2SV_EndVul> } <S2SV_StartVul> <S2SV_EndVul> ret = 0; out: <S2SV_StartVul> kfree(ticket_buf); <S2SV_EndVul> <S2SV_StartVul> out_dbuf: <S2SV_EndVul> <S2SV_StartVul> kfree(dbuf); <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> bad: <S2SV_EndVul> ret = -EINVAL; goto out; <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul>","- char *dbuf;
- char *ticket_buf;
- dbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);
- if (!dbuf)
- return -ENOMEM;
- ticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);
- if (!ticket_buf)
- goto out_dbuf;
- ceph_decode_8_safe(&p, end, reply_struct_v, bad);
- if (ret)
- goto out;
- 
- kfree(ticket_buf);
- out_dbuf:
- kfree(dbuf);
- return ret;
- 
- bad:
- }
- 
+ ret = process_one_ticket(ac, secret, &p, end);
+ return ret;
+ return 0;
+ return -EINVAL;","static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac, struct ceph_crypto_key *secret, void *buf, void *end) { void *p = buf; u8 reply_struct_v; u32 num; int ret; ceph_decode_8_safe(&p, end, reply_struct_v, bad); if (reply_struct_v != 1) return -EINVAL; ceph_decode_32_safe(&p, end, num, bad); dout(""%d tickets\n"", num); while (num--) { ret = process_one_ticket(ac, secret, &p, end); if (ret) return ret; } return 0; bad: return -EINVAL; }"
100,56----CWE-78----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-16863--zvmem.c----zrestore,"<S2SV_StartVul> zrestore(i_ctx_t *i_ctx_p) <S2SV_EndVul> { os_ptr op = osp; <S2SV_StartVul> alloc_save_t *asave; <S2SV_EndVul> <S2SV_StartVul> bool last; <S2SV_EndVul> <S2SV_StartVul> vm_save_t *vmsave; <S2SV_EndVul> <S2SV_StartVul> int code = restore_check_operand(op, &asave, idmemory); <S2SV_EndVul> if (code < 0) return code; if_debug2m('u', imemory, ""[u]vmrestore 0x%lx, id = %lu\n"", <S2SV_StartVul> (ulong) alloc_save_client_data(asave), <S2SV_EndVul> (ulong) op->value.saveid); if (I_VALIDATE_BEFORE_RESTORE) ivalidate_clean_spaces(i_ctx_p); ivalidate_clean_spaces(i_ctx_p); { int code; <S2SV_StartVul> if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 || <S2SV_EndVul> <S2SV_StartVul> (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 || <S2SV_EndVul> <S2SV_StartVul> (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0 <S2SV_EndVul> ) { osp++; return code; } } restore_fix_stack(i_ctx_p, &o_stack, asave, false); }","- zrestore(i_ctx_t *i_ctx_p)
- alloc_save_t *asave;
- bool last;
- vm_save_t *vmsave;
- int code = restore_check_operand(op, &asave, idmemory);
- (ulong) alloc_save_client_data(asave),
- if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||
- (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||
- (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0
+ if ((code = restore_check_stack(i_ctx_p, &o_stack, *asave, false)) < 0 ||
+ (code = restore_check_stack(i_ctx_p, &e_stack, *asave, true)) < 0 ||
+ (code = restore_check_stack(i_ctx_p, &d_stack, *asave, false)) < 0
+ ) {
+ osp++;
+ return code;
+ }
+ osp++;
+ return 0;","zrestore(i_ctx_t *i_ctx_p) restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave) { os_ptr op = osp; int code = restore_check_operand(op, asave, idmemory); if (code < 0) return code; if_debug2m('u', imemory, ""[u]vmrestore 0x%lx, id = %lu\n"", (ulong) alloc_save_client_data(*asave), (ulong) op->value.saveid); if (I_VALIDATE_BEFORE_RESTORE) ivalidate_clean_spaces(i_ctx_p); ivalidate_clean_spaces(i_ctx_p); { int code; if ((code = restore_check_stack(i_ctx_p, &o_stack, *asave, false)) < 0 || (code = restore_check_stack(i_ctx_p, &e_stack, *asave, true)) < 0 || (code = restore_check_stack(i_ctx_p, &d_stack, *asave, false)) < 0 ) { osp++; return code; } } osp++; return 0; } int dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave) { os_ptr op = osp; bool last; vm_save_t *vmsave; int code; osp--; restore_fix_stack(i_ctx_p, &o_stack, asave, false); }"
101,864----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-1335--conf.c----setup_ttydir_console,"static int setup_ttydir_console(const struct lxc_rootfs *rootfs, const struct lxc_console *console, char *ttydir) { char path[MAXPATHLEN], lxcpath[MAXPATHLEN]; int ret; ret = snprintf(path, sizeof(path), ""%s/dev/%s"", rootfs->mount, ttydir); if (ret >= sizeof(path)) return -1; ret = mkdir(path, 0755); if (ret && errno != EEXIST) { SYSERROR(""failed with errno %d to create %s"", errno, path); return -1; } INFO(""created %s"", path); ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/dev/%s/console"", rootfs->mount, ttydir); if (ret >= sizeof(lxcpath)) { ERROR(""console path too long""); return -1; } snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount); ret = unlink(path); if (ret && errno != ENOENT) { SYSERROR(""error unlinking %s"", path); return -1; } ret = creat(lxcpath, 0660); if (ret==-1 && errno != EEXIST) { SYSERROR(""error %d creating %s"", errno, lxcpath); return -1; } if (ret >= 0) close(ret); if (console->master < 0) { INFO(""no console""); return 0; } <S2SV_StartVul> if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) { <S2SV_EndVul> ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath); return -1; } ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/console"", ttydir); if (ret >= sizeof(lxcpath)) { ERROR(""lxc/console path too long""); return -1; } ret = symlink(lxcpath, path); if (ret) { SYSERROR(""failed to create symlink for console""); return -1; } INFO(""console has been setup on %s"", lxcpath); return 0; }","- if (mount(console->name, lxcpath, ""none"", MS_BIND, 0)) {
+ if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) {","static int setup_ttydir_console(const struct lxc_rootfs *rootfs, const struct lxc_console *console, char *ttydir) { char path[MAXPATHLEN], lxcpath[MAXPATHLEN]; int ret; ret = snprintf(path, sizeof(path), ""%s/dev/%s"", rootfs->mount, ttydir); if (ret >= sizeof(path)) return -1; ret = mkdir(path, 0755); if (ret && errno != EEXIST) { SYSERROR(""failed with errno %d to create %s"", errno, path); return -1; } INFO(""created %s"", path); ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/dev/%s/console"", rootfs->mount, ttydir); if (ret >= sizeof(lxcpath)) { ERROR(""console path too long""); return -1; } snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount); ret = unlink(path); if (ret && errno != ENOENT) { SYSERROR(""error unlinking %s"", path); return -1; } ret = creat(lxcpath, 0660); if (ret==-1 && errno != EEXIST) { SYSERROR(""error %d creating %s"", errno, lxcpath); return -1; } if (ret >= 0) close(ret); if (console->master < 0) { INFO(""no console""); return 0; } if (safe_mount(console->name, lxcpath, ""none"", MS_BIND, 0, rootfs->mount)) { ERROR(""failed to mount '%s' on '%s'"", console->name, lxcpath); return -1; } ret = snprintf(lxcpath, sizeof(lxcpath), ""%s/console"", ttydir); if (ret >= sizeof(lxcpath)) { ERROR(""lxc/console path too long""); return -1; } ret = symlink(lxcpath, path); if (ret) { SYSERROR(""failed to create symlink for console""); return -1; } INFO(""console has been setup on %s"", lxcpath); return 0; }"
102,6677----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bcon.c----bson_append_bcon_with_state,"static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) { bcon_error_t ret = BCON_OK; bcon_state_t state = start_state; char *key = 0; char *typespec = 0; unsigned char doc_stack[DOC_STACK_SIZE]; size_t doc_stack_pointer = 0; size_t array_index = 0; <S2SV_StartVul> unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE]; <S2SV_EndVul> size_t array_index_stack_pointer = 0; char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; int end_of_data; const bcon *bcp; for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) { bcon bci = *bcp; char *s = bci.s; switch (state) { case State_Element: switch (bcon_token(s)) { case Token_CloseBrace: bson_append_finish_object( b ); DOC_POP_STATE; break; case Token_End: end_of_data = 1; break; default: key = s; state = State_DocSpecValue; break; } break; case State_DocSpecValue: switch (bcon_token(s)) { case Token_Typespec: typespec = s; state = State_DocValue; break; case Token_OpenBrace: bson_append_start_object( b, key ); DOC_PUSH_STATE(State_Element); state = State_Element; break; case Token_OpenBracket: bson_append_start_array( b, key ); ARRAY_PUSH_RESET_INDEX_STATE(State_Element); state = State_ArraySpecValue; break; case Token_End: end_of_data = 1; break; default: ret = bson_bcon_key_value(b, key, typespec, bci); state = State_Element; break; } break; case State_DocValue: ret = bson_bcon_key_value(b, key, typespec, bci); state = State_Element; typespec = 0; break; case State_ArraySpecValue: switch (bcon_token(s)) { case Token_Typespec: typespec = s; state = State_ArrayValue; break; case Token_OpenBrace: key = ARRAY_KEY_STRING(array_index++); bson_append_start_object( b, key ); DOC_PUSH_STATE(State_ArraySpecValue); state = State_Element; break; case Token_OpenBracket: key = ARRAY_KEY_STRING(array_index++); bson_append_start_array( b, key ); ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue); break; case Token_CloseBracket: bson_append_finish_array( b ); ARRAY_POP_INDEX_STATE; break; case Token_End: end_of_data = 1; break; default: key = ARRAY_KEY_STRING(array_index++); ret = bson_bcon_key_value(b, key, typespec, bci); break; } break; case State_ArrayValue: key = ARRAY_KEY_STRING(array_index++); ret = bson_bcon_key_value(b, key, typespec, bci); state = State_ArraySpecValue; typespec = 0; break; default: assert(NOT_REACHED); break; } } return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE; }","- unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];
+ size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];","static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) { bcon_error_t ret = BCON_OK; bcon_state_t state = start_state; char *key = 0; char *typespec = 0; unsigned char doc_stack[DOC_STACK_SIZE]; size_t doc_stack_pointer = 0; size_t array_index = 0; size_t array_index_stack[ARRAY_INDEX_STACK_SIZE]; size_t array_index_stack_pointer = 0; char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; int end_of_data; const bcon *bcp; for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) { bcon bci = *bcp; char *s = bci.s; switch (state) { case State_Element: switch (bcon_token(s)) { case Token_CloseBrace: bson_append_finish_object( b ); DOC_POP_STATE; break; case Token_End: end_of_data = 1; break; default: key = s; state = State_DocSpecValue; break; } break; case State_DocSpecValue: switch (bcon_token(s)) { case Token_Typespec: typespec = s; state = State_DocValue; break; case Token_OpenBrace: bson_append_start_object( b, key ); DOC_PUSH_STATE(State_Element); state = State_Element; break; case Token_OpenBracket: bson_append_start_array( b, key ); ARRAY_PUSH_RESET_INDEX_STATE(State_Element); state = State_ArraySpecValue; break; case Token_End: end_of_data = 1; break; default: ret = bson_bcon_key_value(b, key, typespec, bci); state = State_Element; break; } break; case State_DocValue: ret = bson_bcon_key_value(b, key, typespec, bci); state = State_Element; typespec = 0; break; case State_ArraySpecValue: switch (bcon_token(s)) { case Token_Typespec: typespec = s; state = State_ArrayValue; break; case Token_OpenBrace: key = ARRAY_KEY_STRING(array_index++); bson_append_start_object( b, key ); DOC_PUSH_STATE(State_ArraySpecValue); state = State_Element; break; case Token_OpenBracket: key = ARRAY_KEY_STRING(array_index++); bson_append_start_array( b, key ); ARRAY_PUSH_RESET_INDEX_STATE(State_ArraySpecValue); break; case Token_CloseBracket: bson_append_finish_array( b ); ARRAY_POP_INDEX_STATE; break; case Token_End: end_of_data = 1; break; default: key = ARRAY_KEY_STRING(array_index++); ret = bson_bcon_key_value(b, key, typespec, bci); break; } break; case State_ArrayValue: key = ARRAY_KEY_STRING(array_index++); ret = bson_bcon_key_value(b, key, typespec, bci); state = State_ArraySpecValue; typespec = 0; break; default: assert(NOT_REACHED); break; } } return state == start_state ? BCON_OK : BCON_DOCUMENT_INCOMPLETE; }"
103,2617----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2870--functions.c----xsltGenerateIdFunction,"xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){ xmlNodePtr cur = NULL; long val; xmlChar str[30]; xmlDocPtr doc; if (nargs == 0) { cur = ctxt->context->node; } else if (nargs == 1) { <S2SV_StartVul> xmlXPathObjectPtr obj; <S2SV_EndVul> xmlNodeSetPtr nodelist; int i, ret; if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) { ctxt->error = XPATH_INVALID_TYPE; xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL, ""generate-id() : invalid arg expecting a node-set\n""); return; } obj = valuePop(ctxt); nodelist = obj->nodesetval; if ((nodelist == NULL) || (nodelist->nodeNr <= 0)) { xmlXPathFreeObject(obj); valuePush(ctxt, xmlXPathNewCString("""")); return; } cur = nodelist->nodeTab[0]; for (i = 1;i < nodelist->nodeNr;i++) { ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]); if (ret == -1) cur = nodelist->nodeTab[i]; } <S2SV_StartVul> xmlXPathFreeObject(obj); <S2SV_EndVul> } else { xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL, ""generate-id() : invalid number of args %d\n"", nargs); ctxt->error = XPATH_INVALID_ARITY; return; } if (cur->type != XML_NAMESPACE_DECL) doc = cur->doc; else { xmlNsPtr ns = (xmlNsPtr) cur; if (ns->context != NULL) doc = ns->context; else doc = ctxt->context->doc; } val = (long)((char *)cur - (char *)doc); if (val >= 0) { sprintf((char *)str, ""idp%ld"", val); } else { sprintf((char *)str, ""idm%ld"", -val); } valuePush(ctxt, xmlXPathNewString(str)); }","- xmlXPathObjectPtr obj;
- xmlXPathFreeObject(obj);
+ xmlXPathObjectPtr obj = NULL;
+ if (obj)
+ xmlXPathFreeObject(obj);","xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){ xmlNodePtr cur = NULL; xmlXPathObjectPtr obj = NULL; long val; xmlChar str[30]; xmlDocPtr doc; if (nargs == 0) { cur = ctxt->context->node; } else if (nargs == 1) { xmlNodeSetPtr nodelist; int i, ret; if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) { ctxt->error = XPATH_INVALID_TYPE; xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL, ""generate-id() : invalid arg expecting a node-set\n""); return; } obj = valuePop(ctxt); nodelist = obj->nodesetval; if ((nodelist == NULL) || (nodelist->nodeNr <= 0)) { xmlXPathFreeObject(obj); valuePush(ctxt, xmlXPathNewCString("""")); return; } cur = nodelist->nodeTab[0]; for (i = 1;i < nodelist->nodeNr;i++) { ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]); if (ret == -1) cur = nodelist->nodeTab[i]; } } else { xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL, ""generate-id() : invalid number of args %d\n"", nargs); ctxt->error = XPATH_INVALID_ARITY; return; } if (cur->type != XML_NAMESPACE_DECL) doc = cur->doc; else { xmlNsPtr ns = (xmlNsPtr) cur; if (ns->context != NULL) doc = ns->context; else doc = ctxt->context->doc; } if (obj) xmlXPathFreeObject(obj); val = (long)((char *)cur - (char *)doc); if (val >= 0) { sprintf((char *)str, ""idp%ld"", val); } else { sprintf((char *)str, ""idm%ld"", -val); } valuePush(ctxt, xmlXPathNewString(str)); }"
104,4061----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/webp.c----vp8_lossy_decode_frame,"static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p, int *got_frame, uint8_t *data_start, unsigned int data_size) { WebPContext *s = avctx->priv_data; AVPacket pkt; int ret; if (!s->initialized) { ff_vp8_decode_init(avctx); s->initialized = 1; <S2SV_StartVul> if (s->has_alpha) <S2SV_EndVul> <S2SV_StartVul> avctx->pix_fmt = AV_PIX_FMT_YUVA420P; <S2SV_EndVul> } s->lossless = 0; if (data_size > INT_MAX) { av_log(avctx, AV_LOG_ERROR, ""unsupported chunk size\n""); return AVERROR_PATCHWELCOME; } av_init_packet(&pkt); pkt.data = data_start; pkt.size = data_size; ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt); if (ret < 0) return ret; update_canvas_size(avctx, avctx->width, avctx->height); if (s->has_alpha) { ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data, s->alpha_data_size); if (ret < 0) return ret; } return ret; }","- if (s->has_alpha)
- avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
+ avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;","static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p, int *got_frame, uint8_t *data_start, unsigned int data_size) { WebPContext *s = avctx->priv_data; AVPacket pkt; int ret; if (!s->initialized) { ff_vp8_decode_init(avctx); s->initialized = 1; } avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P; s->lossless = 0; if (data_size > INT_MAX) { av_log(avctx, AV_LOG_ERROR, ""unsupported chunk size\n""); return AVERROR_PATCHWELCOME; } av_init_packet(&pkt); pkt.data = data_start; pkt.size = data_size; ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt); if (ret < 0) return ret; update_canvas_size(avctx, avctx->width, avctx->height); if (s->has_alpha) { ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data, s->alpha_data_size); if (ret < 0) return ret; } return ret; }"
105,5108----CWE-369----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inplace_ops.cc----tensorflow::InplaceOpBase::Compute,"void Compute(OpKernelContext* ctx) override { auto x = ctx->input(0); auto i = ctx->input(1); auto v = ctx->input(2); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()), errors::InvalidArgument(""i must be a vector. "", i.shape().DebugString())); OP_REQUIRES(ctx, x.dims() == v.dims(), errors::InvalidArgument( ""x and v shape doesn't match (ranks differ): "", x.shape().DebugString(), "" vs. "", v.shape().DebugString())); for (int i = 1; i < x.dims(); ++i) { OP_REQUIRES( ctx, x.dim_size(i) == v.dim_size(i), errors::InvalidArgument(""x and v shape doesn't match at index "", i, "" : "", x.shape().DebugString(), "" vs. "", v.shape().DebugString())); } OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0), errors::InvalidArgument( ""i and x shape doesn't match at index 0: "", i.shape().DebugString(), "" vs. "", v.shape().DebugString())); Tensor y = x; <S2SV_StartVul> if (x.NumElements() > 0 || v.NumElements() > 0) { <S2SV_EndVul> OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y)); } ctx->set_output(0, y); }","- if (x.NumElements() > 0 || v.NumElements() > 0) {
+ if (x.NumElements() > 0 && v.NumElements() > 0) {","void Compute(OpKernelContext* ctx) override { auto x = ctx->input(0); auto i = ctx->input(1); auto v = ctx->input(2); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()), errors::InvalidArgument(""i must be a vector. "", i.shape().DebugString())); OP_REQUIRES(ctx, x.dims() == v.dims(), errors::InvalidArgument( ""x and v shape doesn't match (ranks differ): "", x.shape().DebugString(), "" vs. "", v.shape().DebugString())); for (int i = 1; i < x.dims(); ++i) { OP_REQUIRES( ctx, x.dim_size(i) == v.dim_size(i), errors::InvalidArgument(""x and v shape doesn't match at index "", i, "" : "", x.shape().DebugString(), "" vs. "", v.shape().DebugString())); } OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0), errors::InvalidArgument( ""i and x shape doesn't match at index 0: "", i.shape().DebugString(), "" vs. "", v.shape().DebugString())); Tensor y = x; if (x.NumElements() > 0 && v.NumElements() > 0) { OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y)); } ctx->set_output(0, y); }"
106,3174----CWE-78----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/evalfunc.c----f_settabvar,"f_settabvar(typval_T *argvars, typval_T *rettv) { tabpage_T *save_curtab; tabpage_T *tp; char_u *varname, *tabvarname; typval_T *varp; rettv->vval.v_number = 0; <S2SV_StartVul> if (check_restricted() || check_secure()) <S2SV_EndVul> return; tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL)); varname = tv_get_string_chk(&argvars[1]); varp = &argvars[2]; if (varname != NULL && varp != NULL && tp != NULL) { save_curtab = curtab; goto_tabpage_tp(tp, FALSE, FALSE); tabvarname = alloc((unsigned)STRLEN(varname) + 3); if (tabvarname != NULL) { STRCPY(tabvarname, ""t:""); STRCPY(tabvarname + 2, varname); set_var(tabvarname, varp, TRUE); vim_free(tabvarname); } if (valid_tabpage(save_curtab)) goto_tabpage_tp(save_curtab, FALSE, FALSE); } }","- if (check_restricted() || check_secure())
+ if (check_secure())","f_settabvar(typval_T *argvars, typval_T *rettv) { tabpage_T *save_curtab; tabpage_T *tp; char_u *varname, *tabvarname; typval_T *varp; rettv->vval.v_number = 0; if (check_secure()) return; tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL)); varname = tv_get_string_chk(&argvars[1]); varp = &argvars[2]; if (varname != NULL && varp != NULL && tp != NULL) { save_curtab = curtab; goto_tabpage_tp(tp, FALSE, FALSE); tabvarname = alloc((unsigned)STRLEN(varname) + 3); if (tabvarname != NULL) { STRCPY(tabvarname, ""t:""); STRCPY(tabvarname + 2, varname); set_var(tabvarname, varp, TRUE); vim_free(tabvarname); } if (valid_tabpage(save_curtab)) goto_tabpage_tp(save_curtab, FALSE, FALSE); } }"
107,1698----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10197--evdns.c----search_make_new,"search_make_new(const struct search_state *const state, int n, const char *const base_name) { const size_t base_len = strlen(base_name); <S2SV_StartVul> const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1; <S2SV_EndVul> struct search_domain *dom; for (dom = state->head; dom; dom = dom->next) { if (!n--) { const u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain); const int postfix_len = dom->len; char *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1); if (!newname) return NULL; memcpy(newname, base_name, base_len); if (need_to_append_dot) newname[base_len] = '.'; memcpy(newname + base_len + need_to_append_dot, postfix, postfix_len); newname[base_len + need_to_append_dot + postfix_len] = 0; return newname; } } EVUTIL_ASSERT(0); return NULL; }","- const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
+ char need_to_append_dot;
+ if (!base_len) return NULL;
+ need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;","search_make_new(const struct search_state *const state, int n, const char *const base_name) { const size_t base_len = strlen(base_name); char need_to_append_dot; struct search_domain *dom; if (!base_len) return NULL; need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1; for (dom = state->head; dom; dom = dom->next) { if (!n--) { const u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain); const int postfix_len = dom->len; char *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1); if (!newname) return NULL; memcpy(newname, base_name, base_len); if (need_to_append_dot) newname[base_len] = '.'; memcpy(newname + base_len + need_to_append_dot, postfix, postfix_len); newname[base_len + need_to_append_dot + postfix_len] = 0; return newname; } } EVUTIL_ASSERT(0); return NULL; }"
108,5981----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ZlibOutStream.cxx----ZlibOutStream::length,<S2SV_StartVul> int ZlibOutStream::length() <S2SV_EndVul> { return offset + ptr - start; },"- int ZlibOutStream::length()
+ size_t ZlibOutStream::length()",size_t ZlibOutStream::length() { return offset + ptr - start; }
109,4705----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/vim9compile.c----compile_nested_function,"compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free) { int is_global = *eap->arg == 'g' && eap->arg[1] == ':'; char_u *name_start = eap->arg; char_u *name_end = to_name_end(eap->arg, TRUE); int off; char_u *func_name; char_u *lambda_name; ufunc_T *ufunc; int r = FAIL; compiletype_T compile_type; isn_T *funcref_isn = NULL; if (eap->forceit) { emsg(_(e_cannot_use_bang_with_nested_def)); return NULL; } if (*name_start == '/') { name_end = skip_regexp(name_start + 1, '/', TRUE); if (*name_end == '/') ++name_end; set_nextcmd(eap, name_end); } if (name_end == name_start || *skipwhite(name_end) != '(') { if (!ends_excmd2(name_start, name_end)) { if (*skipwhite(name_end) == '.') semsg(_(e_cannot_define_dict_func_in_vim9_script_str), eap->cmd); else semsg(_(e_invalid_command_str), eap->cmd); return NULL; } if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL) return NULL; return eap->nextcmd == NULL ? (char_u *)"""" : eap->nextcmd; } if (name_start[1] == ':' && !is_global) { semsg(_(e_namespace_not_supported_str), name_start); return NULL; } if (cctx->ctx_skip != SKIP_YES && check_defined(name_start, name_end - name_start, cctx, NULL, FALSE) == FAIL) return NULL; if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0])) { semsg(_(e_function_name_must_start_with_capital_str), name_start); return NULL; } eap->arg = name_end; fill_exarg_from_cctx(eap, cctx); eap->forceit = FALSE; lambda_name = vim_strsave(get_lambda_name()); if (lambda_name == NULL) return NULL; off = is_global ? 2 : 0; func_name = vim_strnsave(name_start + off, name_end - name_start - off); if (func_name == NULL) { r = FAIL; goto theend; } ufunc = define_function(eap, lambda_name, lines_to_free); if (ufunc == NULL) { r = eap->skip ? OK : FAIL; goto theend; } if (eap->nextcmd != NULL) { semsg(_(e_text_found_after_str_str), eap->cmdidx == CMD_def ? ""enddef"" : ""endfunction"", eap->nextcmd); r = FAIL; func_ptr_unref(ufunc); goto theend; } if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0) { int block_depth = cctx->ctx_ufunc->uf_block_depth; ufunc->uf_block_ids = ALLOC_MULT(int, block_depth); if (ufunc->uf_block_ids != NULL) { mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids, sizeof(int) * block_depth); ufunc->uf_block_depth = block_depth; } } if (is_global) { r = generate_NEWFUNC(cctx, lambda_name, func_name); func_name = NULL; lambda_name = NULL; } else { <S2SV_StartVul> lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start, <S2SV_EndVul> TRUE, ufunc->uf_func_type); if (lvar == NULL) goto theend; if (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL) goto theend; r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL); } compile_type = get_compile_type(ufunc); #ifdef FEAT_PROFILE if (cctx->ctx_compile_type == CT_PROFILE) compile_type = CT_PROFILE; #endif if (func_needs_compiling(ufunc, compile_type) && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL) { func_ptr_unref(ufunc); goto theend; } #ifdef FEAT_PROFILE if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE)) compile_def_function(ufunc, FALSE, CT_NONE, cctx); #endif if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED) funcref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx; theend: vim_free(lambda_name); vim_free(func_name); return r == FAIL ? NULL : (char_u *)""""; }","- lvar_T *lvar = reserve_local(cctx, func_name, name_end - name_start,
+ lvar_T *lvar = NULL;
+ lvar = reserve_local(cctx, func_name, name_end - name_start,
+ if (lvar != NULL)","compile_nested_function(exarg_T *eap, cctx_T *cctx, garray_T *lines_to_free) { int is_global = *eap->arg == 'g' && eap->arg[1] == ':'; char_u *name_start = eap->arg; char_u *name_end = to_name_end(eap->arg, TRUE); int off; char_u *func_name; char_u *lambda_name; ufunc_T *ufunc; int r = FAIL; compiletype_T compile_type; isn_T *funcref_isn = NULL; lvar_T *lvar = NULL; if (eap->forceit) { emsg(_(e_cannot_use_bang_with_nested_def)); return NULL; } if (*name_start == '/') { name_end = skip_regexp(name_start + 1, '/', TRUE); if (*name_end == '/') ++name_end; set_nextcmd(eap, name_end); } if (name_end == name_start || *skipwhite(name_end) != '(') { if (!ends_excmd2(name_start, name_end)) { if (*skipwhite(name_end) == '.') semsg(_(e_cannot_define_dict_func_in_vim9_script_str), eap->cmd); else semsg(_(e_invalid_command_str), eap->cmd); return NULL; } if (generate_DEF(cctx, name_start, name_end - name_start) == FAIL) return NULL; return eap->nextcmd == NULL ? (char_u *)"""" : eap->nextcmd; } if (name_start[1] == ':' && !is_global) { semsg(_(e_namespace_not_supported_str), name_start); return NULL; } if (cctx->ctx_skip != SKIP_YES && check_defined(name_start, name_end - name_start, cctx, NULL, FALSE) == FAIL) return NULL; if (!ASCII_ISUPPER(is_global ? name_start[2] : name_start[0])) { semsg(_(e_function_name_must_start_with_capital_str), name_start); return NULL; } eap->arg = name_end; fill_exarg_from_cctx(eap, cctx); eap->forceit = FALSE; lambda_name = vim_strsave(get_lambda_name()); if (lambda_name == NULL) return NULL; off = is_global ? 2 : 0; func_name = vim_strnsave(name_start + off, name_end - name_start - off); if (func_name == NULL) { r = FAIL; goto theend; } ufunc = define_function(eap, lambda_name, lines_to_free); if (ufunc == NULL) { r = eap->skip ? OK : FAIL; goto theend; } if (eap->nextcmd != NULL) { semsg(_(e_text_found_after_str_str), eap->cmdidx == CMD_def ? ""enddef"" : ""endfunction"", eap->nextcmd); r = FAIL; func_ptr_unref(ufunc); goto theend; } if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0) { int block_depth = cctx->ctx_ufunc->uf_block_depth; ufunc->uf_block_ids = ALLOC_MULT(int, block_depth); if (ufunc->uf_block_ids != NULL) { mch_memmove(ufunc->uf_block_ids, cctx->ctx_ufunc->uf_block_ids, sizeof(int) * block_depth); ufunc->uf_block_depth = block_depth; } } if (is_global) { r = generate_NEWFUNC(cctx, lambda_name, func_name); func_name = NULL; lambda_name = NULL; } else { lvar = reserve_local(cctx, func_name, name_end - name_start, TRUE, ufunc->uf_func_type); if (lvar == NULL) goto theend; if (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL) goto theend; r = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL); } compile_type = get_compile_type(ufunc); #ifdef FEAT_PROFILE if (cctx->ctx_compile_type == CT_PROFILE) compile_type = CT_PROFILE; #endif if (func_needs_compiling(ufunc, compile_type) && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL) { func_ptr_unref(ufunc); if (lvar != NULL) *lvar->lv_name = '/'; goto theend; } #ifdef FEAT_PROFILE if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE)) compile_def_function(ufunc, FALSE, CT_NONE, cctx); #endif if (funcref_isn != NULL && ufunc->uf_def_status == UF_COMPILED) funcref_isn->isn_arg.funcref.fr_dfunc_idx = ufunc->uf_dfunc_idx; theend: vim_free(lambda_name); vim_free(func_name); return r == FAIL ? NULL : (char_u *)""""; }"
110,2078----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-8789--ntlm_message.c----ntlm_read_message_fields,"<S2SV_StartVul> int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) <S2SV_EndVul> { if (Stream_GetRemainingLength(s) < 8) return -1; Stream_Read_UINT16(s, fields->Len); Stream_Read_UINT16(s, fields->MaxLen); Stream_Read_UINT32(s, fields->BufferOffset); return 1; }","- int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
+ int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
+ ","int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) { if (Stream_GetRemainingLength(s) < 8) return -1; Stream_Read_UINT16(s, fields->Len); Stream_Read_UINT16(s, fields->MaxLen); Stream_Read_UINT32(s, fields->BufferOffset); return 1; }"
111,329----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3209--mmtimer.c----sgi_timer_set,"static int sgi_timer_set(struct k_itimer *timr, int flags, struct itimerspec * new_setting, struct itimerspec * old_setting) { unsigned long when, period, irqflags; int err = 0; cnodeid_t nodeid; struct mmtimer *base; struct rb_node *n; if (old_setting) sgi_timer_get(timr, old_setting); sgi_timer_del(timr); <S2SV_StartVul> when = timespec_to_ns(new_setting->it_value); <S2SV_EndVul> <S2SV_StartVul> period = timespec_to_ns(new_setting->it_interval); <S2SV_EndVul> if (when == 0) return 0; base = kmalloc(sizeof(struct mmtimer), GFP_KERNEL); if (base == NULL) return -ENOMEM; if (flags & TIMER_ABSTIME) { struct timespec n; unsigned long now; getnstimeofday(&n); <S2SV_StartVul> now = timespec_to_ns(n); <S2SV_EndVul> if (when > now) when -= now; else when = 0; } when = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time(); period = (period + sgi_clock_period - 1) / sgi_clock_period; preempt_disable(); nodeid = cpu_to_node(smp_processor_id()); spin_lock_irqsave(&timers[nodeid].lock, irqflags); base->timer = timr; base->cpu = smp_processor_id(); timr->it.mmtimer.clock = TIMER_SET; timr->it.mmtimer.node = nodeid; timr->it.mmtimer.incr = period; timr->it.mmtimer.expires = when; n = timers[nodeid].next; mmtimer_add_list(base); if (timers[nodeid].next == n) { spin_unlock_irqrestore(&timers[nodeid].lock, irqflags); preempt_enable(); return err; } if (n) mmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR); mmtimer_set_next_timer(nodeid); spin_unlock_irqrestore(&timers[nodeid].lock, irqflags); preempt_enable(); return err; }","- when = timespec_to_ns(new_setting->it_value);
- period = timespec_to_ns(new_setting->it_interval);
- now = timespec_to_ns(n);
+ when = timespec_to_ns(&new_setting->it_value);
+ period = timespec_to_ns(&new_setting->it_interval);
+ now = timespec_to_ns(&n);","static int sgi_timer_set(struct k_itimer *timr, int flags, struct itimerspec * new_setting, struct itimerspec * old_setting) { unsigned long when, period, irqflags; int err = 0; cnodeid_t nodeid; struct mmtimer *base; struct rb_node *n; if (old_setting) sgi_timer_get(timr, old_setting); sgi_timer_del(timr); when = timespec_to_ns(&new_setting->it_value); period = timespec_to_ns(&new_setting->it_interval); if (when == 0) return 0; base = kmalloc(sizeof(struct mmtimer), GFP_KERNEL); if (base == NULL) return -ENOMEM; if (flags & TIMER_ABSTIME) { struct timespec n; unsigned long now; getnstimeofday(&n); now = timespec_to_ns(&n); if (when > now) when -= now; else when = 0; } when = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time(); period = (period + sgi_clock_period - 1) / sgi_clock_period; preempt_disable(); nodeid = cpu_to_node(smp_processor_id()); spin_lock_irqsave(&timers[nodeid].lock, irqflags); base->timer = timr; base->cpu = smp_processor_id(); timr->it.mmtimer.clock = TIMER_SET; timr->it.mmtimer.node = nodeid; timr->it.mmtimer.incr = period; timr->it.mmtimer.expires = when; n = timers[nodeid].next; mmtimer_add_list(base); if (timers[nodeid].next == n) { spin_unlock_irqrestore(&timers[nodeid].lock, irqflags); preempt_enable(); return err; } if (n) mmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR); mmtimer_set_next_timer(nodeid); spin_unlock_irqrestore(&timers[nodeid].lock, irqflags); preempt_enable(); return err; }"
112,6313----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pci_core.h----pci_get_cfgdata8,"pci_get_cfgdata8(struct pci_vdev *dev, int offset) { <S2SV_StartVul> assert(offset <= PCI_REGMAX); <S2SV_EndVul> return (*(uint8_t *)(dev->cfgdata + offset)); }","- assert(offset <= PCI_REGMAX);
+ if (offset > PCI_REGMAX) {
+ pr_err(""%s: out of range of PCI config space!\n"", __func__);
+ return 0xff;
+ }","pci_get_cfgdata8(struct pci_vdev *dev, int offset) { if (offset > PCI_REGMAX) { pr_err(""%s: out of range of PCI config space!\n"", __func__); return 0xff; } return (*(uint8_t *)(dev->cfgdata + offset)); }"
113,5428----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mainwindow.cpp----MainWindow::showUpgradePrompt,"void MainWindow::showUpgradePrompt() { if (Settings.checkUpgradeAutomatic()) { showStatusMessage(""Checking for upgrade...""); <S2SV_StartVul> QNetworkRequest request(QUrl(""https://check.shotcut.org/version.json"")); <S2SV_EndVul> <S2SV_StartVul> QSslConfiguration sslConfig = request.sslConfiguration(); <S2SV_EndVul> <S2SV_StartVul> sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone); <S2SV_EndVul> <S2SV_StartVul> request.setSslConfiguration(sslConfig); <S2SV_EndVul> <S2SV_StartVul> m_network.get(request); <S2SV_EndVul> } else { <S2SV_StartVul> m_network.setStrictTransportSecurityEnabled(false); <S2SV_EndVul> QAction* action = new QAction(tr(""Click here to check for a new version of Shotcut.""), 0); connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered())); showStatusMessage(action, 15 ); } }","- QNetworkRequest request(QUrl(""https://check.shotcut.org/version.json""));
- QSslConfiguration sslConfig = request.sslConfiguration();
- sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);
- request.setSslConfiguration(sslConfig);
- m_network.get(request);
- m_network.setStrictTransportSecurityEnabled(false);
+ m_network.get(QNetworkRequest(QUrl(""https://check.shotcut.org/version.json"")));","void MainWindow::showUpgradePrompt() { if (Settings.checkUpgradeAutomatic()) { showStatusMessage(""Checking for upgrade...""); m_network.get(QNetworkRequest(QUrl(""https://check.shotcut.org/version.json""))); } else { QAction* action = new QAction(tr(""Click here to check for a new version of Shotcut.""), 0); connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered())); showStatusMessage(action, 15 ); } }"
114,4439----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/esp.c----inRange,"static bool inRange(cchar *expr, cchar *version) { char *cp, *op, *base, *pre, *low, *high, *preVersion; int64 min, max, numberVersion; ssize i; if ((i = strspn(expr, ""<>=~ \t"")) > 0) { op = snclone(expr, i); expr = &expr[i]; } else { op = 0; } if (smatch(expr, ""*"")) { expr = ""x""; } <S2SV_StartVul> version = stok(sclone(version), ""-"", &preVersion); <S2SV_EndVul> <S2SV_StartVul> base = stok(sclone(expr), ""-"", &pre); <S2SV_EndVul> if (op && (*op == '~' || *op == '^')) { if (*op == '^' && schr(version, '-')) { return 0; } base = slower(base); if ((cp = scontains(base, "".x"")) != 0) { *cp = '\0'; } return sstarts(version, base); } if (scontains(base, ""x"") && !schr(version, '-')) { low = sfmt("">=%s"", sreplace(base, ""x"", ""0"")); high = sfmt(""<%s"", sreplace(base, ""x"", VER_FACTOR_MAX)); return inRange(low, version) && inRange(high, version); } min = 0; max = MAX_VER; if (!op) { min = max = asNumber(base); } else if (smatch(op, "">="")) { min = asNumber(base); } else if (*op == '>') { min = asNumber(base) + 1; } else if (smatch(op, ""<="")) { max = asNumber(base); } else if (*op == '<') { max = asNumber(base) - 1; } else { min = max = asNumber(base); } numberVersion = asNumber(version); if (min <= numberVersion && numberVersion <= max) { if ((pre && smatch(pre, preVersion)) || (!pre && !preVersion)) { return 1; } } return 0; }","- version = stok(sclone(version), ""-"", &preVersion);
- base = stok(sclone(expr), ""-"", &pre);
+ version = ssplit(sclone(version), ""-"", &preVersion);
+ base = ssplit(sclone(expr), ""-"", &pre);","static bool inRange(cchar *expr, cchar *version) { char *cp, *op, *base, *pre, *low, *high, *preVersion; int64 min, max, numberVersion; ssize i; if ((i = strspn(expr, ""<>=~ \t"")) > 0) { op = snclone(expr, i); expr = &expr[i]; } else { op = 0; } if (smatch(expr, ""*"")) { expr = ""x""; } version = ssplit(sclone(version), ""-"", &preVersion); base = ssplit(sclone(expr), ""-"", &pre); if (op && (*op == '~' || *op == '^')) { if (*op == '^' && schr(version, '-')) { return 0; } base = slower(base); if ((cp = scontains(base, "".x"")) != 0) { *cp = '\0'; } return sstarts(version, base); } if (scontains(base, ""x"") && !schr(version, '-')) { low = sfmt("">=%s"", sreplace(base, ""x"", ""0"")); high = sfmt(""<%s"", sreplace(base, ""x"", VER_FACTOR_MAX)); return inRange(low, version) && inRange(high, version); } min = 0; max = MAX_VER; if (!op) { min = max = asNumber(base); } else if (smatch(op, "">="")) { min = asNumber(base); } else if (*op == '>') { min = asNumber(base) + 1; } else if (smatch(op, ""<="")) { max = asNumber(base); } else if (*op == '<') { max = asNumber(base) - 1; } else { min = max = asNumber(base); } numberVersion = asNumber(version); if (min <= numberVersion && numberVersion <= max) { if ((pre && smatch(pre, preVersion)) || (!pre && !preVersion)) { return 1; } } return 0; }"
115,650----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-4027--target_core_rd.c----rd_release_device_space,"<S2SV_StartVul> static void rd_release_device_space(struct rd_dev *rd_dev) <S2SV_EndVul> { <S2SV_StartVul> u32 i, j, page_count = 0, sg_per_table; <S2SV_EndVul> <S2SV_StartVul> struct rd_dev_sg_table *sg_table; <S2SV_EndVul> struct page *pg; struct scatterlist *sg; <S2SV_StartVul> if (!rd_dev->sg_table_array || !rd_dev->sg_table_count) <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> sg_table = rd_dev->sg_table_array; <S2SV_StartVul> for (i = 0; i < rd_dev->sg_table_count; i++) { <S2SV_EndVul> sg = sg_table[i].sg_table; <S2SV_StartVul> sg_per_table = sg_table[i].rd_sg_count; <S2SV_EndVul> for (j = 0; j < sg_per_table; j++) { pg = sg_page(&sg[j]); if (pg) { __free_page(pg); page_count++; } } kfree(sg); } pr_debug(""CORE_RD[%u] - Released device space for Ramdisk"" "" Device ID: %u, pages %u in %u tables total bytes %lu\n"", rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count, rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE); kfree(sg_table); rd_dev->sg_table_array = NULL; rd_dev->sg_table_count = 0; <S2SV_StartVul> } <S2SV_EndVul>","- static void rd_release_device_space(struct rd_dev *rd_dev)
- u32 i, j, page_count = 0, sg_per_table;
- struct rd_dev_sg_table *sg_table;
- if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
- return;
- for (i = 0; i < rd_dev->sg_table_count; i++) {
- sg_per_table = sg_table[i].rd_sg_count;
- }
+ static void rd_release_device_space(struct rd_dev *rd_dev)
+ static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+ u32 sg_table_count)
+ struct page *pg;
+ struct scatterlist *sg;
+ 
+ for (i = 0; i < sg_table_count; i++) {
+ }
+ 
+ {
+ ","static void rd_release_device_space(struct rd_dev *rd_dev) static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table, u32 sg_table_count) { struct page *pg; struct scatterlist *sg; u32 i, j, page_count = 0, sg_per_table; for (i = 0; i < sg_table_count; i++) { sg = sg_table[i].sg_table; sg_per_table = sg_table[i].rd_sg_count; for (j = 0; j < sg_per_table; j++) { pg = sg_page(&sg[j]); if (pg) { __free_page(pg); page_count++; } } kfree(sg); } kfree(sg_table); return page_count; } static void rd_release_device_space(struct rd_dev *rd_dev) { u32 page_count; if (!rd_dev->sg_table_array || !rd_dev->sg_table_count) return; page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array, rd_dev->sg_table_count); pr_debug(""CORE_RD[%u] - Released device space for Ramdisk"" "" Device ID: %u, pages %u in %u tables total bytes %lu\n"", rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count, rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE); rd_dev->sg_table_array = NULL; rd_dev->sg_table_count = 0; }"
116,5452----CWE-134----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rrd_graph.c----print_calc,"int print_calc( image_desc_t *im) { long i, ii, validsteps; double printval; struct tm tmvdef; int graphelement = 0; long vidx; int max_ii; double magfact = -1; char *si_symb = """"; char *percent_s; int prline_cnt = 0; time_t now = time(NULL); localtime_r(&now, &tmvdef); for (i = 0; i < im->gdes_c; i++) { vidx = im->gdes[i].vidx; switch (im->gdes[i].gf) { case GF_PRINT: case GF_GPRINT: if (im->gdes[vidx].gf == GF_VDEF) { printval = im->gdes[vidx].vf.val; localtime_r(&im->gdes[vidx].vf.when, &tmvdef); } else { max_ii = ((im->gdes[vidx].end - im->gdes[vidx].start) / im->gdes[vidx].step * im->gdes[vidx].ds_cnt); printval = DNAN; validsteps = 0; for (ii = im->gdes[vidx].ds; ii < max_ii; ii += im->gdes[vidx].ds_cnt) { if (!finite(im->gdes[vidx].data[ii])) continue; if (isnan(printval)) { printval = im->gdes[vidx].data[ii]; validsteps++; continue; } switch (im->gdes[i].cf) { case CF_HWPREDICT: case CF_MHWPREDICT: case CF_DEVPREDICT: case CF_DEVSEASONAL: case CF_SEASONAL: case CF_AVERAGE: validsteps++; printval += im->gdes[vidx].data[ii]; break; case CF_MINIMUM: printval = min(printval, im->gdes[vidx].data[ii]); break; case CF_FAILURES: case CF_MAXIMUM: printval = max(printval, im->gdes[vidx].data[ii]); break; case CF_LAST: printval = im->gdes[vidx].data[ii]; } } if (im->gdes[i].cf == CF_AVERAGE || im->gdes[i].cf > CF_LAST) { if (validsteps > 1) { printval = (printval / validsteps); } } } if (!im->gdes[i].strftm && (percent_s = strstr(im->gdes[i].format, ""%S"")) != NULL) { if (magfact < 0.0) { auto_scale(im, &printval, &si_symb, &magfact); if (printval == 0.0) magfact = -1.0; } else { printval /= magfact; } *(++percent_s) = 's'; } else if (!im->gdes[i].strftm && strstr(im->gdes[i].format, ""%s"") != NULL) { auto_scale(im, &printval, &si_symb, &magfact); } if (im->gdes[i].gf == GF_PRINT) { rrd_infoval_t prline; if (im->gdes[i].strftm) { prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char)); if (im->gdes[vidx].vf.never == 1) { time_clean(prline.u_str, im->gdes[i].format); } else { strftime(prline.u_str, FMT_LEG_LEN, im->gdes[i].format, &tmvdef); } <S2SV_StartVul> } else if (bad_format(im->gdes[i].format)) { <S2SV_EndVul> <S2SV_StartVul> rrd_set_error <S2SV_EndVul> <S2SV_StartVul> (""bad format for PRINT in '%s'"", im->gdes[i].format); <S2SV_EndVul> return -1; } else { prline.u_str = sprintf_alloc(im->gdes[i].format, printval, si_symb); } grinfo_push(im, sprintf_alloc (""print[%ld]"", prline_cnt++), RD_I_STR, prline); free(prline.u_str); } else { if (im->gdes[i].strftm) { if (im->gdes[vidx].vf.never == 1) { time_clean(im->gdes[i].legend, im->gdes[i].format); } else { strftime(im->gdes[i].legend, FMT_LEG_LEN, im->gdes[i].format, &tmvdef); } } else { <S2SV_StartVul> if (bad_format(im->gdes[i].format)) { <S2SV_EndVul> <S2SV_StartVul> rrd_set_error <S2SV_EndVul> <S2SV_StartVul> (""bad format for GPRINT in '%s'"", <S2SV_EndVul> <S2SV_StartVul> im->gdes[i].format); <S2SV_EndVul> <S2SV_StartVul> return -1; <S2SV_EndVul> } snprintf(im->gdes[i].legend, FMT_LEG_LEN - 2, im->gdes[i].format, printval, si_symb); } graphelement = 1; } break; case GF_LINE: case GF_AREA: case GF_GRAD: case GF_TICK: graphelement = 1; break; case GF_HRULE: if (isnan(im->gdes[i].yrule)) { im->gdes[i].yrule = im->gdes[vidx].vf.val; }; graphelement = 1; break; case GF_VRULE: if (im->gdes[i].xrule == 0) { im->gdes[i].xrule = im->gdes[vidx].vf.when; }; graphelement = 1; break; case GF_COMMENT: case GF_TEXTALIGN: case GF_DEF: case GF_CDEF: case GF_VDEF: #ifdef WITH_PIECHART case GF_PART: #endif case GF_SHIFT: case GF_XPORT: break; case GF_STACK: rrd_set_error (""STACK should already be turned into LINE or AREA here""); return -1; break; case GF_XAXIS: case GF_YAXIS: break; } } return graphelement; }","- } else if (bad_format(im->gdes[i].format)) {
- rrd_set_error
- (""bad format for PRINT in '%s'"", im->gdes[i].format);
- if (bad_format(im->gdes[i].format)) {
- rrd_set_error
- (""bad format for GPRINT in '%s'"",
- im->gdes[i].format);
- return -1;
+ } else if (bad_format_print(im->gdes[i].format)) {
+ if (bad_format_print(im->gdes[i].format)) {
+ return -1;","int print_calc( image_desc_t *im) { long i, ii, validsteps; double printval; struct tm tmvdef; int graphelement = 0; long vidx; int max_ii; double magfact = -1; char *si_symb = """"; char *percent_s; int prline_cnt = 0; time_t now = time(NULL); localtime_r(&now, &tmvdef); for (i = 0; i < im->gdes_c; i++) { vidx = im->gdes[i].vidx; switch (im->gdes[i].gf) { case GF_PRINT: case GF_GPRINT: if (im->gdes[vidx].gf == GF_VDEF) { printval = im->gdes[vidx].vf.val; localtime_r(&im->gdes[vidx].vf.when, &tmvdef); } else { max_ii = ((im->gdes[vidx].end - im->gdes[vidx].start) / im->gdes[vidx].step * im->gdes[vidx].ds_cnt); printval = DNAN; validsteps = 0; for (ii = im->gdes[vidx].ds; ii < max_ii; ii += im->gdes[vidx].ds_cnt) { if (!finite(im->gdes[vidx].data[ii])) continue; if (isnan(printval)) { printval = im->gdes[vidx].data[ii]; validsteps++; continue; } switch (im->gdes[i].cf) { case CF_HWPREDICT: case CF_MHWPREDICT: case CF_DEVPREDICT: case CF_DEVSEASONAL: case CF_SEASONAL: case CF_AVERAGE: validsteps++; printval += im->gdes[vidx].data[ii]; break; case CF_MINIMUM: printval = min(printval, im->gdes[vidx].data[ii]); break; case CF_FAILURES: case CF_MAXIMUM: printval = max(printval, im->gdes[vidx].data[ii]); break; case CF_LAST: printval = im->gdes[vidx].data[ii]; } } if (im->gdes[i].cf == CF_AVERAGE || im->gdes[i].cf > CF_LAST) { if (validsteps > 1) { printval = (printval / validsteps); } } } if (!im->gdes[i].strftm && (percent_s = strstr(im->gdes[i].format, ""%S"")) != NULL) { if (magfact < 0.0) { auto_scale(im, &printval, &si_symb, &magfact); if (printval == 0.0) magfact = -1.0; } else { printval /= magfact; } *(++percent_s) = 's'; } else if (!im->gdes[i].strftm && strstr(im->gdes[i].format, ""%s"") != NULL) { auto_scale(im, &printval, &si_symb, &magfact); } if (im->gdes[i].gf == GF_PRINT) { rrd_infoval_t prline; if (im->gdes[i].strftm) { prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char)); if (im->gdes[vidx].vf.never == 1) { time_clean(prline.u_str, im->gdes[i].format); } else { strftime(prline.u_str, FMT_LEG_LEN, im->gdes[i].format, &tmvdef); } } else if (bad_format_print(im->gdes[i].format)) { return -1; } else { prline.u_str = sprintf_alloc(im->gdes[i].format, printval, si_symb); } grinfo_push(im, sprintf_alloc (""print[%ld]"", prline_cnt++), RD_I_STR, prline); free(prline.u_str); } else { if (im->gdes[i].strftm) { if (im->gdes[vidx].vf.never == 1) { time_clean(im->gdes[i].legend, im->gdes[i].format); } else { strftime(im->gdes[i].legend, FMT_LEG_LEN, im->gdes[i].format, &tmvdef); } } else { if (bad_format_print(im->gdes[i].format)) { return -1; } snprintf(im->gdes[i].legend, FMT_LEG_LEN - 2, im->gdes[i].format, printval, si_symb); } graphelement = 1; } break; case GF_LINE: case GF_AREA: case GF_GRAD: case GF_TICK: graphelement = 1; break; case GF_HRULE: if (isnan(im->gdes[i].yrule)) { im->gdes[i].yrule = im->gdes[vidx].vf.val; }; graphelement = 1; break; case GF_VRULE: if (im->gdes[i].xrule == 0) { im->gdes[i].xrule = im->gdes[vidx].vf.when; }; graphelement = 1; break; case GF_COMMENT: case GF_TEXTALIGN: case GF_DEF: case GF_CDEF: case GF_VDEF: #ifdef WITH_PIECHART case GF_PART: #endif case GF_SHIFT: case GF_XPORT: break; case GF_STACK: rrd_set_error (""STACK should already be turned into LINE or AREA here""); return -1; break; case GF_XAXIS: case GF_YAXIS: break; } } return graphelement; }"
117,5192----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pipe.c----generic_pipe_buf_get,"<S2SV_StartVul> void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf) <S2SV_EndVul> { <S2SV_StartVul> get_page(buf->page); <S2SV_EndVul> }","- void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)
- get_page(buf->page);
+ bool generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)
+ return try_get_page(buf->page);","bool generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf) { return try_get_page(buf->page); }"
118,3961----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tif_predict.c----swabHorDiff16,"swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc) { uint16* wp = (uint16*) cp0; tmsize_t wc = cc / 2; <S2SV_StartVul> horDiff16(tif, cp0, cc); <S2SV_EndVul> TIFFSwabArrayOfShort(wp, wc); }","- horDiff16(tif, cp0, cc);
+ if( !horDiff16(tif, cp0, cc) )
+ return 0;
+ return 1;","swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc) { uint16* wp = (uint16*) cp0; tmsize_t wc = cc / 2; if( !horDiff16(tif, cp0, cc) ) return 0; TIFFSwabArrayOfShort(wp, wc); return 1; }"
119,611----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-7284--utils.c----__net_get_random_once,"bool __net_get_random_once(void *buf, int nbytes, bool *done, <S2SV_StartVul> struct static_key *done_key) <S2SV_EndVul> { static DEFINE_SPINLOCK(lock); unsigned long flags; spin_lock_irqsave(&lock, flags); if (*done) { spin_unlock_irqrestore(&lock, flags); return false; } get_random_bytes(buf, nbytes); *done = true; spin_unlock_irqrestore(&lock, flags); <S2SV_StartVul> __net_random_once_disable_jump(done_key); <S2SV_EndVul> return true; }","- struct static_key *done_key)
- __net_random_once_disable_jump(done_key);
+ struct static_key *once_key)
+ __net_random_once_disable_jump(once_key);","bool __net_get_random_once(void *buf, int nbytes, bool *done, struct static_key *once_key) { static DEFINE_SPINLOCK(lock); unsigned long flags; spin_lock_irqsave(&lock, flags); if (*done) { spin_unlock_irqrestore(&lock, flags); return false; } get_random_bytes(buf, nbytes); *done = true; spin_unlock_irqrestore(&lock, flags); __net_random_once_disable_jump(once_key); return true; }"
120,4531----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ipv6.c----dccp_v6_init_sequence,"<S2SV_StartVul> static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb) <S2SV_EndVul> { return secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32, ipv6_hdr(skb)->saddr.s6_addr32, dccp_hdr(skb)->dccph_dport, dccp_hdr(skb)->dccph_sport ); }","- static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)
+ static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)","static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb) { return secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32, ipv6_hdr(skb)->saddr.s6_addr32, dccp_hdr(skb)->dccph_dport, dccp_hdr(skb)->dccph_sport ); }"
121,4765----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ctree.c----btrfs_search_slot,"int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_key *key, struct btrfs_path *p, int ins_len, int cow) { struct extent_buffer *b; int slot; int ret; int err; int level; int lowest_unlock = 1; int root_lock; int write_lock_level = 0; u8 lowest_level = 0; int min_write_lock_level; int prev_cmp; lowest_level = p->lowest_level; WARN_ON(lowest_level && ins_len > 0); WARN_ON(p->nodes[0] != NULL); BUG_ON(!cow && ins_len); if (ins_len < 0) { lowest_unlock = 2; write_lock_level = 2; } else if (ins_len > 0) { write_lock_level = 1; } if (!cow) write_lock_level = -1; if (cow && (p->keep_locks || p->lowest_level)) write_lock_level = BTRFS_MAX_LEVEL; min_write_lock_level = write_lock_level; again: prev_cmp = -1; root_lock = BTRFS_READ_LOCK; level = 0; if (p->search_commit_root) { if (p->need_commit_sem) down_read(&root->fs_info->commit_root_sem); b = root->commit_root; extent_buffer_get(b); level = btrfs_header_level(b); if (p->need_commit_sem) up_read(&root->fs_info->commit_root_sem); if (!p->skip_locking) btrfs_tree_read_lock(b); } else { if (p->skip_locking) { b = btrfs_root_node(root); level = btrfs_header_level(b); } else { b = btrfs_read_lock_root_node(root); level = btrfs_header_level(b); if (level <= write_lock_level) { btrfs_tree_read_unlock(b); free_extent_buffer(b); b = btrfs_lock_root_node(root); root_lock = BTRFS_WRITE_LOCK; level = btrfs_header_level(b); } } } p->nodes[level] = b; if (!p->skip_locking) p->locks[level] = root_lock; while (b) { level = btrfs_header_level(b); if (cow) { if (!should_cow_block(trans, root, b)) goto cow_done; if (level > write_lock_level || (level + 1 > write_lock_level && level + 1 < BTRFS_MAX_LEVEL && p->nodes[level + 1])) { write_lock_level = level + 1; btrfs_release_path(p); goto again; } btrfs_set_path_blocking(p); err = btrfs_cow_block(trans, root, b, p->nodes[level + 1], p->slots[level + 1], &b); if (err) { ret = err; goto done; } } cow_done: p->nodes[level] = b; btrfs_clear_path_blocking(p, NULL, 0); if (!ins_len && !p->keep_locks) { int u = level + 1; if (u < BTRFS_MAX_LEVEL && p->locks[u]) { btrfs_tree_unlock_rw(p->nodes[u], p->locks[u]); p->locks[u] = 0; } } ret = key_search(b, key, level, &prev_cmp, &slot); if (level != 0) { int dec = 0; if (ret && slot > 0) { dec = 1; slot -= 1; } p->slots[level] = slot; err = setup_nodes_for_search(trans, root, p, b, level, ins_len, &write_lock_level); if (err == -EAGAIN) goto again; if (err) { ret = err; goto done; } b = p->nodes[level]; slot = p->slots[level]; if (slot == 0 && ins_len && write_lock_level < level + 1) { write_lock_level = level + 1; btrfs_release_path(p); goto again; } unlock_up(p, level, lowest_unlock, min_write_lock_level, &write_lock_level); if (level == lowest_level) { if (dec) p->slots[level]++; goto done; } err = read_block_for_search(trans, root, p, &b, level, slot, key, 0); if (err == -EAGAIN) goto again; if (err) { ret = err; goto done; } if (!p->skip_locking) { level = btrfs_header_level(b); if (level <= write_lock_level) { err = btrfs_try_tree_write_lock(b); if (!err) { btrfs_set_path_blocking(p); btrfs_tree_lock(b); btrfs_clear_path_blocking(p, b, BTRFS_WRITE_LOCK); } p->locks[level] = BTRFS_WRITE_LOCK; } else { err = btrfs_try_tree_read_lock(b); if (!err) { btrfs_set_path_blocking(p); btrfs_tree_read_lock(b); btrfs_clear_path_blocking(p, b, BTRFS_READ_LOCK); } p->locks[level] = BTRFS_READ_LOCK; } p->nodes[level] = b; } } else { p->slots[level] = slot; if (ins_len > 0 && btrfs_leaf_free_space(root, b) < ins_len) { if (write_lock_level < 1) { write_lock_level = 1; btrfs_release_path(p); goto again; } btrfs_set_path_blocking(p); err = split_leaf(trans, root, key, p, ins_len, ret == 0); btrfs_clear_path_blocking(p, NULL, 0); BUG_ON(err > 0); if (err) { ret = err; goto done; } } if (!p->search_for_split) unlock_up(p, level, lowest_unlock, min_write_lock_level, &write_lock_level); goto done; } } ret = 1; done: if (!p->leave_spinning) btrfs_set_path_blocking(p); <S2SV_StartVul> if (ret < 0) <S2SV_EndVul> btrfs_release_path(p); return ret; }","- if (ret < 0)
+ if (ret < 0 && !p->skip_release_on_error)","int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root *root, struct btrfs_key *key, struct btrfs_path *p, int ins_len, int cow) { struct extent_buffer *b; int slot; int ret; int err; int level; int lowest_unlock = 1; int root_lock; int write_lock_level = 0; u8 lowest_level = 0; int min_write_lock_level; int prev_cmp; lowest_level = p->lowest_level; WARN_ON(lowest_level && ins_len > 0); WARN_ON(p->nodes[0] != NULL); BUG_ON(!cow && ins_len); if (ins_len < 0) { lowest_unlock = 2; write_lock_level = 2; } else if (ins_len > 0) { write_lock_level = 1; } if (!cow) write_lock_level = -1; if (cow && (p->keep_locks || p->lowest_level)) write_lock_level = BTRFS_MAX_LEVEL; min_write_lock_level = write_lock_level; again: prev_cmp = -1; root_lock = BTRFS_READ_LOCK; level = 0; if (p->search_commit_root) { if (p->need_commit_sem) down_read(&root->fs_info->commit_root_sem); b = root->commit_root; extent_buffer_get(b); level = btrfs_header_level(b); if (p->need_commit_sem) up_read(&root->fs_info->commit_root_sem); if (!p->skip_locking) btrfs_tree_read_lock(b); } else { if (p->skip_locking) { b = btrfs_root_node(root); level = btrfs_header_level(b); } else { b = btrfs_read_lock_root_node(root); level = btrfs_header_level(b); if (level <= write_lock_level) { btrfs_tree_read_unlock(b); free_extent_buffer(b); b = btrfs_lock_root_node(root); root_lock = BTRFS_WRITE_LOCK; level = btrfs_header_level(b); } } } p->nodes[level] = b; if (!p->skip_locking) p->locks[level] = root_lock; while (b) { level = btrfs_header_level(b); if (cow) { if (!should_cow_block(trans, root, b)) goto cow_done; if (level > write_lock_level || (level + 1 > write_lock_level && level + 1 < BTRFS_MAX_LEVEL && p->nodes[level + 1])) { write_lock_level = level + 1; btrfs_release_path(p); goto again; } btrfs_set_path_blocking(p); err = btrfs_cow_block(trans, root, b, p->nodes[level + 1], p->slots[level + 1], &b); if (err) { ret = err; goto done; } } cow_done: p->nodes[level] = b; btrfs_clear_path_blocking(p, NULL, 0); if (!ins_len && !p->keep_locks) { int u = level + 1; if (u < BTRFS_MAX_LEVEL && p->locks[u]) { btrfs_tree_unlock_rw(p->nodes[u], p->locks[u]); p->locks[u] = 0; } } ret = key_search(b, key, level, &prev_cmp, &slot); if (level != 0) { int dec = 0; if (ret && slot > 0) { dec = 1; slot -= 1; } p->slots[level] = slot; err = setup_nodes_for_search(trans, root, p, b, level, ins_len, &write_lock_level); if (err == -EAGAIN) goto again; if (err) { ret = err; goto done; } b = p->nodes[level]; slot = p->slots[level]; if (slot == 0 && ins_len && write_lock_level < level + 1) { write_lock_level = level + 1; btrfs_release_path(p); goto again; } unlock_up(p, level, lowest_unlock, min_write_lock_level, &write_lock_level); if (level == lowest_level) { if (dec) p->slots[level]++; goto done; } err = read_block_for_search(trans, root, p, &b, level, slot, key, 0); if (err == -EAGAIN) goto again; if (err) { ret = err; goto done; } if (!p->skip_locking) { level = btrfs_header_level(b); if (level <= write_lock_level) { err = btrfs_try_tree_write_lock(b); if (!err) { btrfs_set_path_blocking(p); btrfs_tree_lock(b); btrfs_clear_path_blocking(p, b, BTRFS_WRITE_LOCK); } p->locks[level] = BTRFS_WRITE_LOCK; } else { err = btrfs_try_tree_read_lock(b); if (!err) { btrfs_set_path_blocking(p); btrfs_tree_read_lock(b); btrfs_clear_path_blocking(p, b, BTRFS_READ_LOCK); } p->locks[level] = BTRFS_READ_LOCK; } p->nodes[level] = b; } } else { p->slots[level] = slot; if (ins_len > 0 && btrfs_leaf_free_space(root, b) < ins_len) { if (write_lock_level < 1) { write_lock_level = 1; btrfs_release_path(p); goto again; } btrfs_set_path_blocking(p); err = split_leaf(trans, root, key, p, ins_len, ret == 0); btrfs_clear_path_blocking(p, NULL, 0); BUG_ON(err > 0); if (err) { ret = err; goto done; } } if (!p->search_for_split) unlock_up(p, level, lowest_unlock, min_write_lock_level, &write_lock_level); goto done; } } ret = 1; done: if (!p->leave_spinning) btrfs_set_path_blocking(p); if (ret < 0 && !p->skip_release_on_error) btrfs_release_path(p); return ret; }"
122,5334----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mprLib.c----mprGetJsonObj,"PUBLIC MprJson *mprGetJsonObj(MprJson *obj, cchar *key) { MprJson *result; if (key && !strpbrk(key, "".[]*"")) { <S2SV_StartVul> return mprLookupJsonObj(obj, key); <S2SV_EndVul> } if ((result = mprQueryJson(obj, key, 0, 0)) != 0 && result->children) { return result->children; } return 0; }","- return mprLookupJsonObj(obj, key);
+ return mprReadJsonObj(obj, key);","PUBLIC MprJson *mprGetJsonObj(MprJson *obj, cchar *key) { MprJson *result; if (key && !strpbrk(key, "".[]*"")) { return mprReadJsonObj(obj, key); } if ((result = mprQueryJson(obj, key, 0, 0)) != 0 && result->children) { return result->children; } return 0; }"
123,827----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-2697--bld_princ.c----build_principal_va,"build_principal_va(krb5_context context, krb5_principal princ, unsigned int rlen, const char *realm, va_list ap) { krb5_error_code retval = 0; char *r = NULL; krb5_data *data = NULL; krb5_int32 count = 0; krb5_int32 size = 2; char *component = NULL; data = malloc(size * sizeof(krb5_data)); if (!data) { retval = ENOMEM; } <S2SV_StartVul> if (!retval) { <S2SV_EndVul> <S2SV_StartVul> r = strdup(realm); <S2SV_EndVul> <S2SV_StartVul> if (!r) { retval = ENOMEM; } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> while (!retval && (component = va_arg(ap, char *))) { if (count == size) { krb5_data *new_data = NULL; size *= 2; new_data = realloc(data, size * sizeof(krb5_data)); if (new_data) { data = new_data; } else { retval = ENOMEM; } } if (!retval) { data[count].length = strlen(component); data[count].data = strdup(component); if (!data[count].data) { retval = ENOMEM; } count++; } } if (!retval) { princ->type = KRB5_NT_UNKNOWN; princ->magic = KV5M_PRINCIPAL; princ->realm = make_data(r, rlen); princ->data = data; princ->length = count; r = NULL; data = NULL; } if (data) { while (--count >= 0) { free(data[count].data); } free(data); } free(r); return retval; }","- if (!retval) {
- r = strdup(realm);
- if (!r) { retval = ENOMEM; }
- }
+ if (!retval)
+ r = k5memdup0(realm, rlen, &retval);","build_principal_va(krb5_context context, krb5_principal princ, unsigned int rlen, const char *realm, va_list ap) { krb5_error_code retval = 0; char *r = NULL; krb5_data *data = NULL; krb5_int32 count = 0; krb5_int32 size = 2; char *component = NULL; data = malloc(size * sizeof(krb5_data)); if (!data) { retval = ENOMEM; } if (!retval) r = k5memdup0(realm, rlen, &retval); while (!retval && (component = va_arg(ap, char *))) { if (count == size) { krb5_data *new_data = NULL; size *= 2; new_data = realloc(data, size * sizeof(krb5_data)); if (new_data) { data = new_data; } else { retval = ENOMEM; } } if (!retval) { data[count].length = strlen(component); data[count].data = strdup(component); if (!data[count].data) { retval = ENOMEM; } count++; } } if (!retval) { princ->type = KRB5_NT_UNKNOWN; princ->magic = KV5M_PRINCIPAL; princ->realm = make_data(r, rlen); princ->data = data; princ->length = count; r = NULL; data = NULL; } if (data) { while (--count >= 0) { free(data[count].data); } free(data); } free(r); return retval; }"
124,7182----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event_intel_ds.c----intel_pmu_drain_bts_buffer,"static int intel_pmu_drain_bts_buffer(void) { struct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events); struct debug_store *ds = cpuc->ds; struct bts_record { u64 from; u64 to; u64 flags; }; struct perf_event *event = cpuc->events[X86_PMC_IDX_FIXED_BTS]; struct bts_record *at, *top; struct perf_output_handle handle; struct perf_event_header header; struct perf_sample_data data; struct pt_regs regs; if (!event) return 0; if (!x86_pmu.bts_active) return 0; at = (struct bts_record *)(unsigned long)ds->bts_buffer_base; top = (struct bts_record *)(unsigned long)ds->bts_index; if (top <= at) return 0; ds->bts_index = ds->bts_buffer_base; perf_sample_data_init(&data, 0); data.period = event->hw.last_period; regs.ip = 0; perf_prepare_sample(&header, &data, event, &regs); <S2SV_StartVul> if (perf_output_begin(&handle, event, header.size * (top - at), 1, 1)) <S2SV_EndVul> return 1; for (; at < top; at++) { data.ip = at->from; data.addr = at->to; perf_output_sample(&handle, &header, &data, event); } perf_output_end(&handle); event->hw.interrupts++; event->pending_kill = POLL_IN; return 1; }","- if (perf_output_begin(&handle, event, header.size * (top - at), 1, 1))
+ if (perf_output_begin(&handle, event, header.size * (top - at), 1))","static int intel_pmu_drain_bts_buffer(void) { struct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events); struct debug_store *ds = cpuc->ds; struct bts_record { u64 from; u64 to; u64 flags; }; struct perf_event *event = cpuc->events[X86_PMC_IDX_FIXED_BTS]; struct bts_record *at, *top; struct perf_output_handle handle; struct perf_event_header header; struct perf_sample_data data; struct pt_regs regs; if (!event) return 0; if (!x86_pmu.bts_active) return 0; at = (struct bts_record *)(unsigned long)ds->bts_buffer_base; top = (struct bts_record *)(unsigned long)ds->bts_index; if (top <= at) return 0; ds->bts_index = ds->bts_buffer_base; perf_sample_data_init(&data, 0); data.period = event->hw.last_period; regs.ip = 0; perf_prepare_sample(&header, &data, event, &regs); if (perf_output_begin(&handle, event, header.size * (top - at), 1)) return 1; for (; at < top; at++) { data.ip = at->from; data.addr = at->to; perf_output_sample(&handle, &header, &data, event); } perf_output_end(&handle); event->hw.interrupts++; event->pending_kill = POLL_IN; return 1; }"
125,3587----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/udp_offload.c----udp_gro_receive,"struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb, struct udphdr *uh) { struct udp_offload_priv *uo_priv; struct sk_buff *p, **pp = NULL; struct udphdr *uh2; unsigned int off = skb_gro_offset(skb); int flush = 1; <S2SV_StartVul> if (NAPI_GRO_CB(skb)->udp_mark || <S2SV_EndVul> (skb->ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB(skb)->csum_cnt == 0 && !NAPI_GRO_CB(skb)->csum_valid)) goto out; <S2SV_StartVul> NAPI_GRO_CB(skb)->udp_mark = 1; <S2SV_EndVul> rcu_read_lock(); uo_priv = rcu_dereference(udp_offload_base); for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) { if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) && uo_priv->offload->port == uh->dest && uo_priv->offload->callbacks.gro_receive) goto unflush; } goto out_unlock; unflush: flush = 0; for (p = *head; p; p = p->next) { if (!NAPI_GRO_CB(p)->same_flow) continue; uh2 = (struct udphdr *)(p->data + off); if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) || (!uh->check ^ !uh2->check)) { NAPI_GRO_CB(p)->same_flow = 0; continue; } } skb_gro_pull(skb, sizeof(struct udphdr)); skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr)); NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto; pp = uo_priv->offload->callbacks.gro_receive(head, skb, uo_priv->offload); out_unlock: rcu_read_unlock(); out: NAPI_GRO_CB(skb)->flush |= flush; return pp; }","- if (NAPI_GRO_CB(skb)->udp_mark ||
- NAPI_GRO_CB(skb)->udp_mark = 1;
+ if (NAPI_GRO_CB(skb)->encap_mark ||
+ NAPI_GRO_CB(skb)->encap_mark = 1;","struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb, struct udphdr *uh) { struct udp_offload_priv *uo_priv; struct sk_buff *p, **pp = NULL; struct udphdr *uh2; unsigned int off = skb_gro_offset(skb); int flush = 1; if (NAPI_GRO_CB(skb)->encap_mark || (skb->ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB(skb)->csum_cnt == 0 && !NAPI_GRO_CB(skb)->csum_valid)) goto out; NAPI_GRO_CB(skb)->encap_mark = 1; rcu_read_lock(); uo_priv = rcu_dereference(udp_offload_base); for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) { if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) && uo_priv->offload->port == uh->dest && uo_priv->offload->callbacks.gro_receive) goto unflush; } goto out_unlock; unflush: flush = 0; for (p = *head; p; p = p->next) { if (!NAPI_GRO_CB(p)->same_flow) continue; uh2 = (struct udphdr *)(p->data + off); if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) || (!uh->check ^ !uh2->check)) { NAPI_GRO_CB(p)->same_flow = 0; continue; } } skb_gro_pull(skb, sizeof(struct udphdr)); skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr)); NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto; pp = uo_priv->offload->callbacks.gro_receive(head, skb, uo_priv->offload); out_unlock: rcu_read_unlock(); out: NAPI_GRO_CB(skb)->flush |= flush; return pp; }"
126,3480----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/virtio_console.c----put_chars,"static int put_chars(u32 vtermno, const char *buf, int count) { struct port *port; struct scatterlist sg[1]; if (unlikely(early_put_chars)) return early_put_chars(vtermno, buf, count); port = find_port_by_vtermno(vtermno); if (!port) return -EPIPE; <S2SV_StartVul> sg_init_one(sg, buf, count); <S2SV_EndVul> <S2SV_StartVul> return __send_to_port(port, sg, 1, count, (void *)buf, false); <S2SV_EndVul> }","- sg_init_one(sg, buf, count);
- return __send_to_port(port, sg, 1, count, (void *)buf, false);
+ void *data;
+ int ret;
+ data = kmemdup(buf, count, GFP_ATOMIC);
+ if (!data)
+ return -ENOMEM;
+ sg_init_one(sg, data, count);
+ ret = __send_to_port(port, sg, 1, count, data, false);
+ kfree(data);
+ return ret;","static int put_chars(u32 vtermno, const char *buf, int count) { struct port *port; struct scatterlist sg[1]; void *data; int ret; if (unlikely(early_put_chars)) return early_put_chars(vtermno, buf, count); port = find_port_by_vtermno(vtermno); if (!port) return -EPIPE; data = kmemdup(buf, count, GFP_ATOMIC); if (!data) return -ENOMEM; sg_init_one(sg, data, count); ret = __send_to_port(port, sg, 1, count, data, false); kfree(data); return ret; }"
127,6319----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/visemul.c----vis_emul,"int vis_emul(struct pt_regs *regs, unsigned int insn) { unsigned long pc = regs->tpc; unsigned int opf; BUG_ON(regs->tstate & TSTATE_PRIV); <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0); <S2SV_EndVul> if (test_thread_flag(TIF_32BIT)) pc = (u32)pc; if (get_user(insn, (u32 __user *) pc)) return -EFAULT; save_and_clear_fpu(); opf = (insn & VIS_OPF_MASK) >> VIS_OPF_SHIFT; switch (opf) { default: return -EINVAL; case FPACK16_OPF: case FPACK32_OPF: case FPACKFIX_OPF: case FEXPAND_OPF: case FPMERGE_OPF: pformat(regs, insn, opf); break; case FMUL8x16_OPF: case FMUL8x16AU_OPF: case FMUL8x16AL_OPF: case FMUL8SUx16_OPF: case FMUL8ULx16_OPF: case FMULD8SUx16_OPF: case FMULD8ULx16_OPF: pmul(regs, insn, opf); break; case FCMPGT16_OPF: case FCMPGT32_OPF: case FCMPLE16_OPF: case FCMPLE32_OPF: case FCMPNE16_OPF: case FCMPNE32_OPF: case FCMPEQ16_OPF: case FCMPEQ32_OPF: pcmp(regs, insn, opf); break; case EDGE8_OPF: case EDGE8N_OPF: case EDGE8L_OPF: case EDGE8LN_OPF: case EDGE16_OPF: case EDGE16N_OPF: case EDGE16L_OPF: case EDGE16LN_OPF: case EDGE32_OPF: case EDGE32N_OPF: case EDGE32L_OPF: case EDGE32LN_OPF: edge(regs, insn, opf); break; case PDIST_OPF: pdist(regs, insn); break; case ARRAY8_OPF: case ARRAY16_OPF: case ARRAY32_OPF: array(regs, insn, opf); break; case BMASK_OPF: bmask(regs, insn); break; case BSHUFFLE_OPF: bshuffle(regs, insn); break; } regs->tpc = regs->tnpc; regs->tnpc += 4; return 0; }","- perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);
+ perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);","int vis_emul(struct pt_regs *regs, unsigned int insn) { unsigned long pc = regs->tpc; unsigned int opf; BUG_ON(regs->tstate & TSTATE_PRIV); perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0); if (test_thread_flag(TIF_32BIT)) pc = (u32)pc; if (get_user(insn, (u32 __user *) pc)) return -EFAULT; save_and_clear_fpu(); opf = (insn & VIS_OPF_MASK) >> VIS_OPF_SHIFT; switch (opf) { default: return -EINVAL; case FPACK16_OPF: case FPACK32_OPF: case FPACKFIX_OPF: case FEXPAND_OPF: case FPMERGE_OPF: pformat(regs, insn, opf); break; case FMUL8x16_OPF: case FMUL8x16AU_OPF: case FMUL8x16AL_OPF: case FMUL8SUx16_OPF: case FMUL8ULx16_OPF: case FMULD8SUx16_OPF: case FMULD8ULx16_OPF: pmul(regs, insn, opf); break; case FCMPGT16_OPF: case FCMPGT32_OPF: case FCMPLE16_OPF: case FCMPLE32_OPF: case FCMPNE16_OPF: case FCMPNE32_OPF: case FCMPEQ16_OPF: case FCMPEQ32_OPF: pcmp(regs, insn, opf); break; case EDGE8_OPF: case EDGE8N_OPF: case EDGE8L_OPF: case EDGE8LN_OPF: case EDGE16_OPF: case EDGE16N_OPF: case EDGE16L_OPF: case EDGE16LN_OPF: case EDGE32_OPF: case EDGE32N_OPF: case EDGE32L_OPF: case EDGE32LN_OPF: edge(regs, insn, opf); break; case PDIST_OPF: pdist(regs, insn); break; case ARRAY8_OPF: case ARRAY16_OPF: case ARRAY32_OPF: array(regs, insn, opf); break; case BMASK_OPF: bmask(regs, insn); break; case BSHUFFLE_OPF: bshuffle(regs, insn); break; } regs->tpc = regs->tnpc; regs->tnpc += 4; return 0; }"
128,2111----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-7186--gplot.c----gplotAddPlot,"gplotAddPlot(GPLOT *gplot, NUMA *nax, NUMA *nay, l_int32 plotstyle, const char *plottitle) { <S2SV_StartVul> char buf[L_BUF_SIZE]; <S2SV_EndVul> char emptystring[] = """"; char *datastr, *title; l_int32 n, i; l_float32 valx, valy, startx, delx; SARRAY *sa; PROCNAME(""gplotAddPlot""); if (!gplot) return ERROR_INT(""gplot not defined"", procName, 1); if (!nay) return ERROR_INT(""nay not defined"", procName, 1); if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES) return ERROR_INT(""invalid plotstyle"", procName, 1); if ((n = numaGetCount(nay)) == 0) return ERROR_INT(""no points to plot"", procName, 1); if (nax && (n != numaGetCount(nax))) return ERROR_INT(""nax and nay sizes differ"", procName, 1); if (n == 1 && plotstyle == GPLOT_LINES) { L_INFO(""only 1 pt; changing style to points\n"", procName); plotstyle = GPLOT_POINTS; } numaGetParameters(nay, &startx, &delx); numaAddNumber(gplot->plotstyles, plotstyle); if (plottitle) { title = stringNew(plottitle); sarrayAddString(gplot->plottitles, title, L_INSERT); } else { sarrayAddString(gplot->plottitles, emptystring, L_COPY); } gplot->nplots++; <S2SV_StartVul> snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots); <S2SV_EndVul> sarrayAddString(gplot->datanames, buf, L_COPY); sa = sarrayCreate(n); for (i = 0; i < n; i++) { if (nax) numaGetFValue(nax, i, &valx); else valx = startx + i * delx; numaGetFValue(nay, i, &valy); <S2SV_StartVul> snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy); <S2SV_EndVul> sarrayAddString(sa, buf, L_COPY); } datastr = sarrayToString(sa, 0); sarrayAddString(gplot->plotdata, datastr, L_INSERT); sarrayDestroy(&sa); return 0; }","- char buf[L_BUF_SIZE];
- snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
- snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy);
+ char buf[L_BUFSIZE];
+ snprintf(buf, L_BUFSIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
+ snprintf(buf, L_BUFSIZE, ""%f %f\n"", valx, valy);","gplotAddPlot(GPLOT *gplot, NUMA *nax, NUMA *nay, l_int32 plotstyle, const char *plottitle) { char buf[L_BUFSIZE]; char emptystring[] = """"; char *datastr, *title; l_int32 n, i; l_float32 valx, valy, startx, delx; SARRAY *sa; PROCNAME(""gplotAddPlot""); if (!gplot) return ERROR_INT(""gplot not defined"", procName, 1); if (!nay) return ERROR_INT(""nay not defined"", procName, 1); if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES) return ERROR_INT(""invalid plotstyle"", procName, 1); if ((n = numaGetCount(nay)) == 0) return ERROR_INT(""no points to plot"", procName, 1); if (nax && (n != numaGetCount(nax))) return ERROR_INT(""nax and nay sizes differ"", procName, 1); if (n == 1 && plotstyle == GPLOT_LINES) { L_INFO(""only 1 pt; changing style to points\n"", procName); plotstyle = GPLOT_POINTS; } numaGetParameters(nay, &startx, &delx); numaAddNumber(gplot->plotstyles, plotstyle); if (plottitle) { title = stringNew(plottitle); sarrayAddString(gplot->plottitles, title, L_INSERT); } else { sarrayAddString(gplot->plottitles, emptystring, L_COPY); } gplot->nplots++; snprintf(buf, L_BUFSIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots); sarrayAddString(gplot->datanames, buf, L_COPY); sa = sarrayCreate(n); for (i = 0; i < n; i++) { if (nax) numaGetFValue(nax, i, &valx); else valx = startx + i * delx; numaGetFValue(nay, i, &valy); snprintf(buf, L_BUFSIZE, ""%f %f\n"", valx, valy); sarrayAddString(sa, buf, L_COPY); } datastr = sarrayToString(sa, 0); sarrayAddString(gplot->plotdata, datastr, L_INSERT); sarrayDestroy(&sa); return 0; }"
129,3437----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dev.c----dev_forward_skb,"int dev_forward_skb(struct net_device *dev, struct sk_buff *skb) { skb_orphan(skb); <S2SV_StartVul> if (!(dev->flags & IFF_UP)) <S2SV_EndVul> <S2SV_StartVul> return NET_RX_DROP; <S2SV_EndVul> <S2SV_StartVul> if (skb->len > (dev->mtu + dev->hard_header_len)) <S2SV_EndVul> return NET_RX_DROP; skb_set_dev(skb, dev); skb->tstamp.tv64 = 0; skb->pkt_type = PACKET_HOST; skb->protocol = eth_type_trans(skb, dev); return netif_rx(skb); }","- if (!(dev->flags & IFF_UP))
- return NET_RX_DROP;
- if (skb->len > (dev->mtu + dev->hard_header_len))
+ if (!(dev->flags & IFF_UP) ||
+ (skb->len > (dev->mtu + dev->hard_header_len))) {
+ kfree_skb(skb);
+ }","int dev_forward_skb(struct net_device *dev, struct sk_buff *skb) { skb_orphan(skb); if (!(dev->flags & IFF_UP) || (skb->len > (dev->mtu + dev->hard_header_len))) { kfree_skb(skb); return NET_RX_DROP; } skb_set_dev(skb, dev); skb->tstamp.tv64 = 0; skb->pkt_type = PACKET_HOST; skb->protocol = eth_type_trans(skb, dev); return netif_rx(skb); }"
130,7307----CWE-326----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/output_core.c----ipv6_proxy_select_ident,"__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb) { <S2SV_StartVul> static u32 ip6_proxy_idents_hashrnd __read_mostly; <S2SV_EndVul> struct in6_addr buf[2]; struct in6_addr *addrs; u32 id; addrs = skb_header_pointer(skb, skb_network_offset(skb) + offsetof(struct ipv6hdr, saddr), sizeof(buf), buf); if (!addrs) return 0; <S2SV_StartVul> net_get_random_once(&ip6_proxy_idents_hashrnd, <S2SV_EndVul> <S2SV_StartVul> sizeof(ip6_proxy_idents_hashrnd)); <S2SV_EndVul> <S2SV_StartVul> id = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd, <S2SV_EndVul> <S2SV_StartVul> &addrs[1], &addrs[0]); <S2SV_EndVul> return htonl(id); }","- static u32 ip6_proxy_idents_hashrnd __read_mostly;
- net_get_random_once(&ip6_proxy_idents_hashrnd,
- sizeof(ip6_proxy_idents_hashrnd));
- id = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,
- &addrs[1], &addrs[0]);
+ id = __ipv6_select_ident(net, &addrs[1], &addrs[0]);","__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb) { struct in6_addr buf[2]; struct in6_addr *addrs; u32 id; addrs = skb_header_pointer(skb, skb_network_offset(skb) + offsetof(struct ipv6hdr, saddr), sizeof(buf), buf); if (!addrs) return 0; id = __ipv6_select_ident(net, &addrs[1], &addrs[0]); return htonl(id); }"
131,6447----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-beep.c----l_strnstart,"<S2SV_StartVul> l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2) <S2SV_EndVul> { if (tl1 > l2) return 0; return (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0); }","- l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)
+ l_strnstart(netdissect_options *ndo, const char *tstr1, u_int tl1,
+ const char *str2, u_int l2)
+ if (!ND_TTEST2(*str2, tl1)) {
+ return 0;
+ }","l_strnstart(netdissect_options *ndo, const char *tstr1, u_int tl1, const char *str2, u_int l2) { if (!ND_TTEST2(*str2, tl1)) { return 0; } if (tl1 > l2) return 0; return (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0); }"
132,4323----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/alloc.c----ga_init2,"<S2SV_StartVul> ga_init2(garray_T *gap, int itemsize, int growsize) <S2SV_EndVul> { ga_init(gap); gap->ga_itemsize = itemsize; gap->ga_growsize = growsize; }","- ga_init2(garray_T *gap, int itemsize, int growsize)
+ ga_init2(garray_T *gap, size_t itemsize, int growsize)","ga_init2(garray_T *gap, size_t itemsize, int growsize) { ga_init(gap); gap->ga_itemsize = itemsize; gap->ga_growsize = growsize; }"
133,756--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4160--cmsnamed.c----cmsAppendNamedColor,"cmsBool CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList, const char* Name, cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS]) { cmsUInt32Number i; if (NamedColorList == NULL) return FALSE; if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) { if (!GrowNamedColorList(NamedColorList)) return FALSE; } for (i=0; i < NamedColorList ->ColorantCount; i++) NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i]; for (i=0; i < 3; i++) NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i]; if (Name != NULL) { <S2SV_StartVul> strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, <S2SV_EndVul> <S2SV_StartVul> sizeof(NamedColorList ->List[NamedColorList ->nColors].Name)); <S2SV_EndVul> NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0; } else NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0; NamedColorList ->nColors++; return TRUE; }","- strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,
- sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));
+ strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, cmsMAX_PATH-1);","cmsBool CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList, const char* Name, cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS]) { cmsUInt32Number i; if (NamedColorList == NULL) return FALSE; if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) { if (!GrowNamedColorList(NamedColorList)) return FALSE; } for (i=0; i < NamedColorList ->ColorantCount; i++) NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i]; for (i=0; i < 3; i++) NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i]; if (Name != NULL) { strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, cmsMAX_PATH-1); NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0; } else NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0; NamedColorList ->nColors++; return TRUE; }"
134,6561----CWE-330----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/read_config.c----read_config,"int read_config (char *config_file) { char buf[512]; char *cp; FILE *config_fp; char *args[MAXARGS]; int argcnt, errcnt, linenum; if (T.debug > 0) syslog (LOG_DEBUG, ""config file: %s"", config_file); config_fp = fopen (config_file, ""r""); if (!config_fp) { syslog (LOG_ERR, ""can't open config file: %s"", config_file); return -1; } linenum = errcnt = 0; while (fgets (buf, sizeof (buf), config_fp)) { linenum++; cp = strchr (buf, '\n'); if (cp) *cp = '\0'; cp = strchr (buf, '\n'); if (cp) *cp = '\0'; cp = strchr (buf, '#'); if (cp) *cp = '\0'; cp = strchr (buf, ';'); if (cp) *cp = '\0'; args[argcnt = 0] = strtok (buf, "" \t""); while (args[argcnt] && ++argcnt < MAXARGS) args[argcnt] = strtok (NULL, "" \t""); if (!args[0]) continue; if (!strcasecmp (args[0], ""forwarder"")) { if (argcnt < 2 || argcnt > 4 ) { syslog (LOG_ERR, ""line %d: invalid format: forwarder <IPaddr> [port <port>]"", linenum); errcnt++; } else { int port = PORT_TO, i; i = 2; if (argcnt > i) { if (!strcasecmp (args[i], ""port"")) { if (argcnt >= ++i) { port = atoi (args[i++]); } else { syslog (LOG_ERR, ""line %d: invalid format, missing <port> after port attribute"", linenum); errcnt++; continue; } } else { syslog (LOG_ERR, ""line %d: invalid format, cannot parse unknown attribute: %s"", linenum, args[i]); errcnt++; continue; } } if (fwd_add (args[1], port) == -1) return -1; } } else if (!strcasecmp (args[0], ""prefix"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: prefix <IPv6prefix>"", linenum); errcnt++; } else { if (conv_trick_conf ((u_char *)args[1])) { syslog (LOG_INFO, ""can not add prefix %d: %s"", T.prefixnum, args[1]); errcnt++; } else syslog (LOG_INFO, ""prefix %d added: %s"", T.prefixnum, args[1]); } } else if (!strcasecmp (args[0], ""allow"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: allow <IP address>"", linenum); errcnt++; } else { #ifdef SWILL if (T.http_port) { swill_allow(args[1]); syslog (LOG_INFO, ""allow http connects from %s"", args[1]); } else #endif syslog (LOG_INFO, ""NOTE: http support not enabled!!!""); } } else if (!strcasecmp (args[0], ""retry"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: retry <seconds>"", linenum); errcnt++; } else { T.retry_interval = atoi(args[1]); } } else if (!strcasecmp (args[0], ""pidfile"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: pidfile <filename>"", linenum); errcnt++; } else { T.pidfile = strdup(args[1]); } } else if (!strcasecmp (args[0], ""interfaces"")) { int i; if (argcnt < 2) { syslog (LOG_ERR, ""line %d: invalid format: interfaces <ifa> <ifb> ..."", linenum); errcnt++; } <S2SV_StartVul> for (i = 0; T.iflist[i] && i < MAXINTERFACES; i++); <S2SV_EndVul> if (i + argcnt-1 > MAXINTERFACES) { syslog (LOG_ERR, ""line %d: to many interfaces, more than %d"", linenum, MAXINTERFACES); errcnt++; } else { syslog (LOG_DEBUG, ""line %d: %d interfaces listed, no wildcard socket"", linenum, argcnt-1); T.iflist[i + argcnt--] = NULL; while (argcnt) { if (!strcmp(args[argcnt], ""*"")) { T.iflist[0] = NULL; T.wildcard = 1; break; } T.iflist[i+argcnt-1] = strdup(args[argcnt]); argcnt--; } if (T.iflist[0]) T.wildcard = 0; } } else if (!strcasecmp (args[0], ""port"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: port <portnum>"", linenum); errcnt++; } else { T.port = atoi(args[1]); } } #ifdef SCOPED_REWRITE else if (!strcasecmp(args[0], ""scoped"")) { if (argcnt != 4) { syslog (LOG_ERR, ""line %d: invalid format: scoped <from> <to> <plen>"", linenum); errcnt++; } else { if (conv_scoped_conf(args[1], args[2], atoi(args[3]))) { syslog (LOG_INFO, ""can not add scoped %d: %s %s %s"", T.scoped_prefixes, args[1], args[2], args[3]); errcnt++; } else { syslog(LOG_INFO, ""scoped %d added: %s %s %d"", T.scoped_prefixes, args[1], args[2], atoi(args[3])); } } } #endif #ifdef STF else if (!strcasecmp(args[0], ""stf"")) { if (argcnt != 1) { syslog (LOG_ERR, ""line %d: invalid format: stf"", linenum); errcnt++; } else { T.stf = 1; } } #endif else { syslog (LOG_WARNING, ""line %d: unknown keyword in config file: %s"", linenum, args[0]); errcnt++; } } fclose (config_fp); if (errcnt) { syslog (LOG_ERR, ""errors found in config file. errcnt = %d"", errcnt); return -1; } else syslog (LOG_INFO, ""configuration file loaded.""); return 0; }","- for (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);
+ for (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) {
+ };","int read_config (char *config_file) { char buf[512]; char *cp; FILE *config_fp; char *args[MAXARGS]; int argcnt, errcnt, linenum; if (T.debug > 0) syslog (LOG_DEBUG, ""config file: %s"", config_file); config_fp = fopen (config_file, ""r""); if (!config_fp) { syslog (LOG_ERR, ""can't open config file: %s"", config_file); return -1; } linenum = errcnt = 0; while (fgets (buf, sizeof (buf), config_fp)) { linenum++; cp = strchr (buf, '\n'); if (cp) *cp = '\0'; cp = strchr (buf, '\n'); if (cp) *cp = '\0'; cp = strchr (buf, '#'); if (cp) *cp = '\0'; cp = strchr (buf, ';'); if (cp) *cp = '\0'; args[argcnt = 0] = strtok (buf, "" \t""); while (args[argcnt] && ++argcnt < MAXARGS) args[argcnt] = strtok (NULL, "" \t""); if (!args[0]) continue; if (!strcasecmp (args[0], ""forwarder"")) { if (argcnt < 2 || argcnt > 4 ) { syslog (LOG_ERR, ""line %d: invalid format: forwarder <IPaddr> [port <port>]"", linenum); errcnt++; } else { int port = PORT_TO, i; i = 2; if (argcnt > i) { if (!strcasecmp (args[i], ""port"")) { if (argcnt >= ++i) { port = atoi (args[i++]); } else { syslog (LOG_ERR, ""line %d: invalid format, missing <port> after port attribute"", linenum); errcnt++; continue; } } else { syslog (LOG_ERR, ""line %d: invalid format, cannot parse unknown attribute: %s"", linenum, args[i]); errcnt++; continue; } } if (fwd_add (args[1], port) == -1) return -1; } } else if (!strcasecmp (args[0], ""prefix"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: prefix <IPv6prefix>"", linenum); errcnt++; } else { if (conv_trick_conf ((u_char *)args[1])) { syslog (LOG_INFO, ""can not add prefix %d: %s"", T.prefixnum, args[1]); errcnt++; } else syslog (LOG_INFO, ""prefix %d added: %s"", T.prefixnum, args[1]); } } else if (!strcasecmp (args[0], ""allow"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: allow <IP address>"", linenum); errcnt++; } else { #ifdef SWILL if (T.http_port) { swill_allow(args[1]); syslog (LOG_INFO, ""allow http connects from %s"", args[1]); } else #endif syslog (LOG_INFO, ""NOTE: http support not enabled!!!""); } } else if (!strcasecmp (args[0], ""retry"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: retry <seconds>"", linenum); errcnt++; } else { T.retry_interval = atoi(args[1]); } } else if (!strcasecmp (args[0], ""pidfile"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: pidfile <filename>"", linenum); errcnt++; } else { T.pidfile = strdup(args[1]); } } else if (!strcasecmp (args[0], ""interfaces"")) { int i; if (argcnt < 2) { syslog (LOG_ERR, ""line %d: invalid format: interfaces <ifa> <ifb> ..."", linenum); errcnt++; } for (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { }; if (i + argcnt-1 > MAXINTERFACES) { syslog (LOG_ERR, ""line %d: to many interfaces, more than %d"", linenum, MAXINTERFACES); errcnt++; } else { syslog (LOG_DEBUG, ""line %d: %d interfaces listed, no wildcard socket"", linenum, argcnt-1); T.iflist[i + argcnt--] = NULL; while (argcnt) { if (!strcmp(args[argcnt], ""*"")) { T.iflist[0] = NULL; T.wildcard = 1; break; } T.iflist[i+argcnt-1] = strdup(args[argcnt]); argcnt--; } if (T.iflist[0]) T.wildcard = 0; } } else if (!strcasecmp (args[0], ""port"")) { if (argcnt != 2) { syslog (LOG_ERR, ""line %d: invalid format: port <portnum>"", linenum); errcnt++; } else { T.port = atoi(args[1]); } } #ifdef SCOPED_REWRITE else if (!strcasecmp(args[0], ""scoped"")) { if (argcnt != 4) { syslog (LOG_ERR, ""line %d: invalid format: scoped <from> <to> <plen>"", linenum); errcnt++; } else { if (conv_scoped_conf(args[1], args[2], atoi(args[3]))) { syslog (LOG_INFO, ""can not add scoped %d: %s %s %s"", T.scoped_prefixes, args[1], args[2], args[3]); errcnt++; } else { syslog(LOG_INFO, ""scoped %d added: %s %s %d"", T.scoped_prefixes, args[1], args[2], atoi(args[3])); } } } #endif #ifdef STF else if (!strcasecmp(args[0], ""stf"")) { if (argcnt != 1) { syslog (LOG_ERR, ""line %d: invalid format: stf"", linenum); errcnt++; } else { T.stf = 1; } } #endif else { syslog (LOG_WARNING, ""line %d: unknown keyword in config file: %s"", linenum, args[0]); errcnt++; } } fclose (config_fp); if (errcnt) { syslog (LOG_ERR, ""errors found in config file. errcnt = %d"", errcnt); return -1; } else syslog (LOG_INFO, ""configuration file loaded.""); return 0; }"
135,1651----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5547--hid-corsair.c----k90_backlight_get,"static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev) { int ret; struct k90_led *led = container_of(led_cdev, struct k90_led, cdev); struct device *dev = led->cdev.dev->parent; struct usb_interface *usbif = to_usb_interface(dev->parent); struct usb_device *usbdev = interface_to_usbdev(usbif); int brightness; <S2SV_StartVul> char data[8]; <S2SV_EndVul> ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_STATUS, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 8, USB_CTRL_SET_TIMEOUT); if (ret < 0) { dev_warn(dev, ""Failed to get K90 initial state (error %d).\n"", ret); <S2SV_StartVul> return -EIO; <S2SV_EndVul> } brightness = data[4]; if (brightness < 0 || brightness > 3) { dev_warn(dev, ""Read invalid backlight brightness: %02hhx.\n"", data[4]); <S2SV_StartVul> return -EIO; <S2SV_EndVul> } <S2SV_StartVul> return brightness; <S2SV_EndVul> }","- char data[8];
- return -EIO;
- return -EIO;
- return brightness;
+ char *data;
+ data = kmalloc(8, GFP_KERNEL);
+ if (!data)
+ return -ENOMEM;
+ ret = -EIO;
+ goto out;
+ ret = -EIO;
+ goto out;
+ ret = brightness;
+ out:
+ kfree(data);
+ return ret;","static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev) { int ret; struct k90_led *led = container_of(led_cdev, struct k90_led, cdev); struct device *dev = led->cdev.dev->parent; struct usb_interface *usbif = to_usb_interface(dev->parent); struct usb_device *usbdev = interface_to_usbdev(usbif); int brightness; char *data; data = kmalloc(8, GFP_KERNEL); if (!data) return -ENOMEM; ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0), K90_REQUEST_STATUS, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE, 0, 0, data, 8, USB_CTRL_SET_TIMEOUT); if (ret < 0) { dev_warn(dev, ""Failed to get K90 initial state (error %d).\n"", ret); ret = -EIO; goto out; } brightness = data[4]; if (brightness < 0 || brightness > 3) { dev_warn(dev, ""Read invalid backlight brightness: %02hhx.\n"", data[4]); ret = -EIO; goto out; } ret = brightness; out: kfree(data); return ret; }"
136,681----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3487--cdf.c----cdf_read_property_info,"cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount) { const cdf_section_header_t *shp; cdf_section_header_t sh; const uint8_t *p, *q, *e; int16_t s16; int32_t s32; uint32_t u32; int64_t s64; uint64_t u64; cdf_timestamp_t tp; size_t i, o, o4, nelements, j; cdf_property_info_t *inp; if (offs > UINT32_MAX / 4) { errno = EFTYPE; goto out; } shp = CAST(const cdf_section_header_t *, (const void *) ((const char *)sst->sst_tab + offs)); if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1) goto out; sh.sh_len = CDF_TOLE4(shp->sh_len); #define CDF_SHLEN_LIMIT (UINT32_MAX / 8) if (sh.sh_len > CDF_SHLEN_LIMIT) { errno = EFTYPE; goto out; } sh.sh_properties = CDF_TOLE4(shp->sh_properties); #define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp))) if (sh.sh_properties > CDF_PROP_LIMIT) goto out; DPRINTF((""section len: %u properties %u\n"", sh.sh_len, sh.sh_properties)); if (*maxcount) { if (*maxcount > CDF_PROP_LIMIT) goto out; *maxcount += sh.sh_properties; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); } else { *maxcount = sh.sh_properties; inp = CAST(cdf_property_info_t *, malloc(*maxcount * sizeof(*inp))); } if (inp == NULL) goto out; *info = inp; inp += *count; *count += sh.sh_properties; p = CAST(const uint8_t *, (const void *) ((const char *)(const void *)sst->sst_tab + offs + sizeof(sh))); e = CAST(const uint8_t *, (const void *) (((const char *)(const void *)shp) + sh.sh_len)); if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) goto out; for (i = 0; i < sh.sh_properties; i++) { <S2SV_StartVul> size_t ofs = CDF_GETUINT32(p, (i << 1) + 1); <S2SV_EndVul> q = (const uint8_t *)(const void *) ((const char *)(const void *)p + ofs - 2 * sizeof(uint32_t)); if (q > e) { DPRINTF((""Ran of the end %p > %p\n"", q, e)); goto out; } inp[i].pi_id = CDF_GETUINT32(p, i << 1); inp[i].pi_type = CDF_GETUINT32(q, 0); DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"", i, inp[i].pi_id, inp[i].pi_type, q - p, offs)); if (inp[i].pi_type & CDF_VECTOR) { nelements = CDF_GETUINT32(q, 1); if (nelements == 0) { DPRINTF((""CDF_VECTOR with nelements == 0\n"")); goto out; } o = 2; } else { nelements = 1; o = 1; } o4 = o * sizeof(uint32_t); if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED)) goto unknown; switch (inp[i].pi_type & CDF_TYPEMASK) { case CDF_NULL: case CDF_EMPTY: break; case CDF_SIGNED16: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s16, &q[o4], sizeof(s16)); inp[i].pi_s16 = CDF_TOLE2(s16); break; case CDF_SIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s32, &q[o4], sizeof(s32)); inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32); break; case CDF_BOOL: case CDF_UNSIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); inp[i].pi_u32 = CDF_TOLE4(u32); break; case CDF_SIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s64, &q[o4], sizeof(s64)); inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64); break; case CDF_UNSIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64); break; case CDF_FLOAT: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); u32 = CDF_TOLE4(u32); memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f)); break; case CDF_DOUBLE: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); u64 = CDF_TOLE8((uint64_t)u64); memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d)); break; case CDF_LENGTH32_STRING: case CDF_LENGTH32_WSTRING: if (nelements > 1) { size_t nelem = inp - *info; if (*maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT) goto out; *maxcount += nelements; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); if (inp == NULL) goto out; *info = inp; inp = *info + nelem; } DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"", nelements)); for (j = 0; j < nelements && i < sh.sh_properties; j++, i++) { uint32_t l = CDF_GETUINT32(q, o); inp[i].pi_str.s_len = l; inp[i].pi_str.s_buf = (const char *) (const void *)(&q[o4 + sizeof(l)]); DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT ""u, s = %s\n"", l, CDF_ROUND(l, sizeof(l)), inp[i].pi_str.s_buf)); if (l & 1) l++; o += l >> 1; if (q + o >= e) goto out; o4 = o * sizeof(uint32_t); } i--; break; case CDF_FILETIME: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&tp, &q[o4], sizeof(tp)); inp[i].pi_tp = CDF_TOLE8((uint64_t)tp); break; case CDF_CLIPBOARD: if (inp[i].pi_type & CDF_VECTOR) goto unknown; break; default: unknown: DPRINTF((""Don't know how to deal with %x\n"", inp[i].pi_type)); break; } } return 0; out: free(*info); return -1; }","- size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
+ size_t tail = (i << 1) + 1;
+ if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),
+ __LINE__) == -1)
+ goto out;
+ size_t ofs = CDF_GETUINT32(p, tail);","cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount) { const cdf_section_header_t *shp; cdf_section_header_t sh; const uint8_t *p, *q, *e; int16_t s16; int32_t s32; uint32_t u32; int64_t s64; uint64_t u64; cdf_timestamp_t tp; size_t i, o, o4, nelements, j; cdf_property_info_t *inp; if (offs > UINT32_MAX / 4) { errno = EFTYPE; goto out; } shp = CAST(const cdf_section_header_t *, (const void *) ((const char *)sst->sst_tab + offs)); if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1) goto out; sh.sh_len = CDF_TOLE4(shp->sh_len); #define CDF_SHLEN_LIMIT (UINT32_MAX / 8) if (sh.sh_len > CDF_SHLEN_LIMIT) { errno = EFTYPE; goto out; } sh.sh_properties = CDF_TOLE4(shp->sh_properties); #define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp))) if (sh.sh_properties > CDF_PROP_LIMIT) goto out; DPRINTF((""section len: %u properties %u\n"", sh.sh_len, sh.sh_properties)); if (*maxcount) { if (*maxcount > CDF_PROP_LIMIT) goto out; *maxcount += sh.sh_properties; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); } else { *maxcount = sh.sh_properties; inp = CAST(cdf_property_info_t *, malloc(*maxcount * sizeof(*inp))); } if (inp == NULL) goto out; *info = inp; inp += *count; *count += sh.sh_properties; p = CAST(const uint8_t *, (const void *) ((const char *)(const void *)sst->sst_tab + offs + sizeof(sh))); e = CAST(const uint8_t *, (const void *) (((const char *)(const void *)shp) + sh.sh_len)); if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) goto out; for (i = 0; i < sh.sh_properties; i++) { size_t tail = (i << 1) + 1; if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t), __LINE__) == -1) goto out; size_t ofs = CDF_GETUINT32(p, tail); q = (const uint8_t *)(const void *) ((const char *)(const void *)p + ofs - 2 * sizeof(uint32_t)); if (q > e) { DPRINTF((""Ran of the end %p > %p\n"", q, e)); goto out; } inp[i].pi_id = CDF_GETUINT32(p, i << 1); inp[i].pi_type = CDF_GETUINT32(q, 0); DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"", i, inp[i].pi_id, inp[i].pi_type, q - p, offs)); if (inp[i].pi_type & CDF_VECTOR) { nelements = CDF_GETUINT32(q, 1); if (nelements == 0) { DPRINTF((""CDF_VECTOR with nelements == 0\n"")); goto out; } o = 2; } else { nelements = 1; o = 1; } o4 = o * sizeof(uint32_t); if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED)) goto unknown; switch (inp[i].pi_type & CDF_TYPEMASK) { case CDF_NULL: case CDF_EMPTY: break; case CDF_SIGNED16: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s16, &q[o4], sizeof(s16)); inp[i].pi_s16 = CDF_TOLE2(s16); break; case CDF_SIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s32, &q[o4], sizeof(s32)); inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32); break; case CDF_BOOL: case CDF_UNSIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); inp[i].pi_u32 = CDF_TOLE4(u32); break; case CDF_SIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s64, &q[o4], sizeof(s64)); inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64); break; case CDF_UNSIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64); break; case CDF_FLOAT: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); u32 = CDF_TOLE4(u32); memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f)); break; case CDF_DOUBLE: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); u64 = CDF_TOLE8((uint64_t)u64); memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d)); break; case CDF_LENGTH32_STRING: case CDF_LENGTH32_WSTRING: if (nelements > 1) { size_t nelem = inp - *info; if (*maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT) goto out; *maxcount += nelements; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); if (inp == NULL) goto out; *info = inp; inp = *info + nelem; } DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"", nelements)); for (j = 0; j < nelements && i < sh.sh_properties; j++, i++) { uint32_t l = CDF_GETUINT32(q, o); inp[i].pi_str.s_len = l; inp[i].pi_str.s_buf = (const char *) (const void *)(&q[o4 + sizeof(l)]); DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT ""u, s = %s\n"", l, CDF_ROUND(l, sizeof(l)), inp[i].pi_str.s_buf)); if (l & 1) l++; o += l >> 1; if (q + o >= e) goto out; o4 = o * sizeof(uint32_t); } i--; break; case CDF_FILETIME: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&tp, &q[o4], sizeof(tp)); inp[i].pi_tp = CDF_TOLE8((uint64_t)tp); break; case CDF_CLIPBOARD: if (inp[i].pi_type & CDF_VECTOR) goto unknown; break; default: unknown: DPRINTF((""Don't know how to deal with %x\n"", inp[i].pi_type)); break; } } return 0; out: free(*info); return -1; }"
137,5974----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/HexInStream.cxx----HexInStream::pos,<S2SV_StartVul> int HexInStream::pos() { <S2SV_EndVul> return offset + ptr - start; },"- int HexInStream::pos() {
+ size_t HexInStream::pos() {",size_t HexInStream::pos() { return offset + ptr - start; }
138,6454----CWE-129----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4xdr.c----nfsd4_encode_getdeviceinfo,"nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getdeviceinfo *gdev) { struct xdr_stream *xdr = &resp->xdr; <S2SV_StartVul> const struct nfsd4_layout_ops *ops = <S2SV_EndVul> <S2SV_StartVul> nfsd4_layout_ops[gdev->gd_layout_type]; <S2SV_EndVul> u32 starting_len = xdr->buf->len, needed_len; __be32 *p; dprintk(""%s: err %d\n"", __func__, be32_to_cpu(nfserr)); if (nfserr) goto out; nfserr = nfserr_resource; p = xdr_reserve_space(xdr, 4); if (!p) goto out; *p++ = cpu_to_be32(gdev->gd_layout_type); if (gdev->gd_maxcount != 0) { nfserr = ops->encode_getdeviceinfo(xdr, gdev); if (nfserr) { if (xdr->buf->len + 4 > gdev->gd_maxcount) goto toosmall; goto out; } } nfserr = nfserr_resource; if (gdev->gd_notify_types) { p = xdr_reserve_space(xdr, 4 + 4); if (!p) goto out; *p++ = cpu_to_be32(1); *p++ = cpu_to_be32(gdev->gd_notify_types); } else { p = xdr_reserve_space(xdr, 4); if (!p) goto out; *p++ = 0; } nfserr = 0; out: kfree(gdev->gd_device); dprintk(""%s: done: %d\n"", __func__, be32_to_cpu(nfserr)); return nfserr; toosmall: dprintk(""%s: maxcount too small\n"", __func__); needed_len = xdr->buf->len + 4 ; xdr_truncate_encode(xdr, starting_len); p = xdr_reserve_space(xdr, 4); if (!p) { nfserr = nfserr_resource; } else { *p++ = cpu_to_be32(needed_len); nfserr = nfserr_toosmall; } goto out; }","- const struct nfsd4_layout_ops *ops =
- nfsd4_layout_ops[gdev->gd_layout_type];
+ const struct nfsd4_layout_ops *ops;
+ ops = nfsd4_layout_ops[gdev->gd_layout_type];","nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getdeviceinfo *gdev) { struct xdr_stream *xdr = &resp->xdr; const struct nfsd4_layout_ops *ops; u32 starting_len = xdr->buf->len, needed_len; __be32 *p; dprintk(""%s: err %d\n"", __func__, be32_to_cpu(nfserr)); if (nfserr) goto out; nfserr = nfserr_resource; p = xdr_reserve_space(xdr, 4); if (!p) goto out; *p++ = cpu_to_be32(gdev->gd_layout_type); if (gdev->gd_maxcount != 0) { ops = nfsd4_layout_ops[gdev->gd_layout_type]; nfserr = ops->encode_getdeviceinfo(xdr, gdev); if (nfserr) { if (xdr->buf->len + 4 > gdev->gd_maxcount) goto toosmall; goto out; } } nfserr = nfserr_resource; if (gdev->gd_notify_types) { p = xdr_reserve_space(xdr, 4 + 4); if (!p) goto out; *p++ = cpu_to_be32(1); *p++ = cpu_to_be32(gdev->gd_notify_types); } else { p = xdr_reserve_space(xdr, 4); if (!p) goto out; *p++ = 0; } nfserr = 0; out: kfree(gdev->gd_device); dprintk(""%s: done: %d\n"", __func__, be32_to_cpu(nfserr)); return nfserr; toosmall: dprintk(""%s: maxcount too small\n"", __func__); needed_len = xdr->buf->len + 4 ; xdr_truncate_encode(xdr, starting_len); p = xdr_reserve_space(xdr, 4); if (!p) { nfserr = nfserr_resource; } else { *p++ = cpu_to_be32(needed_len); nfserr = nfserr_toosmall; } goto out; }"
139,4161----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spnego_mech.c----spnego_gss_get_mic_iov,"spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count) { <S2SV_StartVul> return gss_get_mic_iov(minor_status, context_handle, qop_req, iov, <S2SV_EndVul> iov_count); }","- return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,
+ spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+ if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+ return (GSS_S_NO_CONTEXT);
+ return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,","spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count) { spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle; if (sc->ctx_handle == GSS_C_NO_CONTEXT) return (GSS_S_NO_CONTEXT); return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov, iov_count); }"
140,2837----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/netscreen.c----netscreen_read,"static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) { gint64 offset; <S2SV_StartVul> int pkt_len; <S2SV_EndVul> char line[NETSCREEN_LINE_LENGTH]; <S2SV_StartVul> char cap_int[NETSCREEN_MAX_INT_NAME_LENGTH]; <S2SV_EndVul> <S2SV_StartVul> gboolean cap_dir; <S2SV_EndVul> <S2SV_StartVul> char cap_dst[13]; <S2SV_EndVul> offset = netscreen_seek_next_packet(wth, err, err_info, line); if (offset < 0) return FALSE; <S2SV_StartVul> pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir, <S2SV_EndVul> <S2SV_StartVul> cap_dst, err, err_info); <S2SV_EndVul> <S2SV_StartVul> if (pkt_len == -1) <S2SV_EndVul> <S2SV_StartVul> return FALSE; <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int, <S2SV_EndVul> <S2SV_StartVul> cap_dst, &wth->phdr, wth->frame_buffer, err, err_info)) <S2SV_EndVul> return FALSE; if (wth->file_encap == WTAP_ENCAP_UNKNOWN) wth->file_encap = wth->phdr.pkt_encap; else { if (wth->file_encap != wth->phdr.pkt_encap) wth->file_encap = WTAP_ENCAP_PER_PACKET; } *data_offset = offset; return TRUE; }","- int pkt_len;
- char cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];
- gboolean cap_dir;
- char cap_dst[13];
- pkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,
- cap_dst, err, err_info);
- if (pkt_len == -1)
- return FALSE;
- if (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,
- cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))
+ if (!parse_netscreen_packet(wth->fh, &wth->phdr,
+ wth->frame_buffer, line, err, err_info))","static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) { gint64 offset; char line[NETSCREEN_LINE_LENGTH]; offset = netscreen_seek_next_packet(wth, err, err_info, line); if (offset < 0) return FALSE; if (!parse_netscreen_packet(wth->fh, &wth->phdr, wth->frame_buffer, line, err, err_info)) return FALSE; if (wth->file_encap == WTAP_ENCAP_UNKNOWN) wth->file_encap = wth->phdr.pkt_encap; else { if (wth->file_encap != wth->phdr.pkt_encap) wth->file_encap = WTAP_ENCAP_PER_PACKET; } *data_offset = offset; return TRUE; }"
141,3453----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/commissioner.cpp----ot::MeshCoP::Commissioner::GeneratePskc,"otError Commissioner::GeneratePskc(const char * aPassPhrase, const char * aNetworkName, const Mac::ExtendedPanId &aExtPanId, Pskc & aPskc) { otError error = OT_ERROR_NONE; const char *saltPrefix = ""Thread""; uint8_t salt[OT_PBKDF2_SALT_MAX_LEN]; uint16_t saltLen = 0; VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) && <S2SV_StartVul> (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE), <S2SV_EndVul> error = OT_ERROR_INVALID_ARGS); memset(salt, 0, sizeof(salt)); memcpy(salt, saltPrefix, strlen(saltPrefix)); saltLen += static_cast<uint16_t>(strlen(saltPrefix)); memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId)); saltLen += OT_EXT_PAN_ID_SIZE; memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName)); saltLen += static_cast<uint16_t>(strlen(aNetworkName)); otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)), reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8); exit: return error; }","- (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE),
+ (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&
+ (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),","otError Commissioner::GeneratePskc(const char * aPassPhrase, const char * aNetworkName, const Mac::ExtendedPanId &aExtPanId, Pskc & aPskc) { otError error = OT_ERROR_NONE; const char *saltPrefix = ""Thread""; uint8_t salt[OT_PBKDF2_SALT_MAX_LEN]; uint16_t saltLen = 0; VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) && (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) && (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE), error = OT_ERROR_INVALID_ARGS); memset(salt, 0, sizeof(salt)); memcpy(salt, saltPrefix, strlen(saltPrefix)); saltLen += static_cast<uint16_t>(strlen(saltPrefix)); memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId)); saltLen += OT_EXT_PAN_ID_SIZE; memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName)); saltLen += static_cast<uint16_t>(strlen(aNetworkName)); otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)), reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8); exit: return error; }"
142,2760----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----perf_swevent_event,"static void perf_swevent_event(struct perf_event *event, u64 nr, <S2SV_StartVul> int nmi, struct perf_sample_data *data, <S2SV_EndVul> struct pt_regs *regs) { struct hw_perf_event *hwc = &event->hw; local64_add(nr, &event->count); if (!regs) return; if (!is_sampling_event(event)) return; if (nr == 1 && hwc->sample_period == 1 && !event->attr.freq) <S2SV_StartVul> return perf_swevent_overflow(event, 1, nmi, data, regs); <S2SV_EndVul> if (local64_add_negative(nr, &hwc->period_left)) return; <S2SV_StartVul> perf_swevent_overflow(event, 0, nmi, data, regs); <S2SV_EndVul> }","- int nmi, struct perf_sample_data *data,
- return perf_swevent_overflow(event, 1, nmi, data, regs);
- perf_swevent_overflow(event, 0, nmi, data, regs);
+ struct perf_sample_data *data,
+ return perf_swevent_overflow(event, 1, data, regs);
+ perf_swevent_overflow(event, 0, data, regs);","static void perf_swevent_event(struct perf_event *event, u64 nr, struct perf_sample_data *data, struct pt_regs *regs) { struct hw_perf_event *hwc = &event->hw; local64_add(nr, &event->count); if (!regs) return; if (!is_sampling_event(event)) return; if (nr == 1 && hwc->sample_period == 1 && !event->attr.freq) return perf_swevent_overflow(event, 1, data, regs); if (local64_add_negative(nr, &hwc->period_left)) return; perf_swevent_overflow(event, 0, data, regs); }"
143,4828----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4proc.c----nfs4_atomic_open,"nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd) { struct path path = { .mnt = nd->path.mnt, .dentry = dentry, }; struct dentry *parent; struct iattr attr; struct rpc_cred *cred; struct nfs4_state *state; struct dentry *res; if (nd->flags & LOOKUP_CREATE) { attr.ia_mode = nd->intent.open.create_mode; attr.ia_valid = ATTR_MODE; if (!IS_POSIXACL(dir)) attr.ia_mode &= ~current->fs->umask; } else { attr.ia_valid = 0; BUG_ON(nd->intent.open.flags & O_CREAT); } cred = rpc_lookup_cred(); if (IS_ERR(cred)) return (struct dentry *)cred; parent = dentry->d_parent; nfs_block_sillyrename(parent); <S2SV_StartVul> state = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred); <S2SV_EndVul> put_rpccred(cred); if (IS_ERR(state)) { if (PTR_ERR(state) == -ENOENT) { d_add(dentry, NULL); nfs_set_verifier(dentry, nfs_save_change_attribute(dir)); } nfs_unblock_sillyrename(parent); return (struct dentry *)state; } res = d_add_unique(dentry, igrab(state->inode)); if (res != NULL) path.dentry = res; nfs_set_verifier(path.dentry, nfs_save_change_attribute(dir)); nfs_unblock_sillyrename(parent); <S2SV_StartVul> nfs4_intent_set_file(nd, &path, state); <S2SV_EndVul> return res; }","- state = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);
- nfs4_intent_set_file(nd, &path, state);
+ fmode_t fmode = nd->intent.open.flags & (FMODE_READ | FMODE_WRITE | FMODE_EXEC);
+ state = nfs4_do_open(dir, &path, fmode, nd->intent.open.flags, &attr, cred);
+ nfs4_intent_set_file(nd, &path, state, fmode);","nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd) { struct path path = { .mnt = nd->path.mnt, .dentry = dentry, }; struct dentry *parent; struct iattr attr; struct rpc_cred *cred; struct nfs4_state *state; struct dentry *res; fmode_t fmode = nd->intent.open.flags & (FMODE_READ | FMODE_WRITE | FMODE_EXEC); if (nd->flags & LOOKUP_CREATE) { attr.ia_mode = nd->intent.open.create_mode; attr.ia_valid = ATTR_MODE; if (!IS_POSIXACL(dir)) attr.ia_mode &= ~current->fs->umask; } else { attr.ia_valid = 0; BUG_ON(nd->intent.open.flags & O_CREAT); } cred = rpc_lookup_cred(); if (IS_ERR(cred)) return (struct dentry *)cred; parent = dentry->d_parent; nfs_block_sillyrename(parent); state = nfs4_do_open(dir, &path, fmode, nd->intent.open.flags, &attr, cred); put_rpccred(cred); if (IS_ERR(state)) { if (PTR_ERR(state) == -ENOENT) { d_add(dentry, NULL); nfs_set_verifier(dentry, nfs_save_change_attribute(dir)); } nfs_unblock_sillyrename(parent); return (struct dentry *)state; } res = d_add_unique(dentry, igrab(state->inode)); if (res != NULL) path.dentry = res; nfs_set_verifier(path.dentry, nfs_save_change_attribute(dir)); nfs_unblock_sillyrename(parent); nfs4_intent_set_file(nd, &path, state, fmode); return res; }"
144,6555----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/zend-string.cpp----HPHP::string_chunk_split,"String string_chunk_split(const char *src, int srclen, const char *end, int endlen, int chunklen) { int chunks = srclen / chunklen; int restlen = srclen - chunks * chunklen; <S2SV_StartVul> int out_len = (chunks + 1) * endlen + srclen; <S2SV_EndVul> <S2SV_StartVul> String ret(out_len, ReserveString); <S2SV_EndVul> char *dest = ret.bufferSlice().ptr; const char *p; char *q; const char *pMax = src + srclen - chunklen + 1; for (p = src, q = dest; p < pMax; ) { memcpy(q, p, chunklen); q += chunklen; memcpy(q, end, endlen); q += endlen; p += chunklen; } if (restlen) { memcpy(q, p, restlen); q += restlen; memcpy(q, end, endlen); q += endlen; } ret.setSize(q - dest); return ret; }","- int out_len = (chunks + 1) * endlen + srclen;
- String ret(out_len, ReserveString);
+ String ret(
+ safe_address(
+ chunks + 1,
+ endlen,
+ srclen
+ ),
+ ReserveString
+ );","String string_chunk_split(const char *src, int srclen, const char *end, int endlen, int chunklen) { int chunks = srclen / chunklen; int restlen = srclen - chunks * chunklen; String ret( safe_address( chunks + 1, endlen, srclen ), ReserveString ); char *dest = ret.bufferSlice().ptr; const char *p; char *q; const char *pMax = src + srclen - chunklen + 1; for (p = src, q = dest; p < pMax; ) { memcpy(q, p, chunklen); q += chunklen; memcpy(q, end, endlen); q += endlen; p += chunklen; } if (restlen) { memcpy(q, p, restlen); q += restlen; memcpy(q, end, endlen); q += endlen; } ret.setSize(q - dest); return ret; }"
145,874----CWE-19----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-0274--xfs_attr_leaf.c----xfs_attr3_leaf_getvalue,"xfs_attr3_leaf_getvalue( struct xfs_buf *bp, struct xfs_da_args *args) { struct xfs_attr_leafblock *leaf; struct xfs_attr3_icleaf_hdr ichdr; struct xfs_attr_leaf_entry *entry; struct xfs_attr_leaf_name_local *name_loc; struct xfs_attr_leaf_name_remote *name_rmt; int valuelen; leaf = bp->b_addr; xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf); ASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8); ASSERT(args->index < ichdr.count); entry = &xfs_attr3_leaf_entryp(leaf)[args->index]; if (entry->flags & XFS_ATTR_LOCAL) { name_loc = xfs_attr3_leaf_name_local(leaf, args->index); ASSERT(name_loc->namelen == args->namelen); ASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0); valuelen = be16_to_cpu(name_loc->valuelen); if (args->flags & ATTR_KERNOVAL) { args->valuelen = valuelen; return 0; } if (args->valuelen < valuelen) { args->valuelen = valuelen; return XFS_ERROR(ERANGE); } args->valuelen = valuelen; memcpy(args->value, &name_loc->nameval[args->namelen], valuelen); } else { name_rmt = xfs_attr3_leaf_name_remote(leaf, args->index); ASSERT(name_rmt->namelen == args->namelen); ASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0); <S2SV_StartVul> valuelen = be32_to_cpu(name_rmt->valuelen); <S2SV_EndVul> args->rmtblkno = be32_to_cpu(name_rmt->valueblk); args->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount, <S2SV_StartVul> valuelen); <S2SV_EndVul> if (args->flags & ATTR_KERNOVAL) { <S2SV_StartVul> args->valuelen = valuelen; <S2SV_EndVul> return 0; } <S2SV_StartVul> if (args->valuelen < valuelen) { <S2SV_EndVul> <S2SV_StartVul> args->valuelen = valuelen; <S2SV_EndVul> return XFS_ERROR(ERANGE); } <S2SV_StartVul> args->valuelen = valuelen; <S2SV_EndVul> } return 0; }","- valuelen = be32_to_cpu(name_rmt->valuelen);
- valuelen);
- args->valuelen = valuelen;
- if (args->valuelen < valuelen) {
- args->valuelen = valuelen;
- args->valuelen = valuelen;
+ args->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);
+ args->rmtvaluelen);
+ args->valuelen = args->rmtvaluelen;
+ if (args->valuelen < args->rmtvaluelen) {
+ args->valuelen = args->rmtvaluelen;
+ args->valuelen = args->rmtvaluelen;","xfs_attr3_leaf_getvalue( struct xfs_buf *bp, struct xfs_da_args *args) { struct xfs_attr_leafblock *leaf; struct xfs_attr3_icleaf_hdr ichdr; struct xfs_attr_leaf_entry *entry; struct xfs_attr_leaf_name_local *name_loc; struct xfs_attr_leaf_name_remote *name_rmt; int valuelen; leaf = bp->b_addr; xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf); ASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8); ASSERT(args->index < ichdr.count); entry = &xfs_attr3_leaf_entryp(leaf)[args->index]; if (entry->flags & XFS_ATTR_LOCAL) { name_loc = xfs_attr3_leaf_name_local(leaf, args->index); ASSERT(name_loc->namelen == args->namelen); ASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0); valuelen = be16_to_cpu(name_loc->valuelen); if (args->flags & ATTR_KERNOVAL) { args->valuelen = valuelen; return 0; } if (args->valuelen < valuelen) { args->valuelen = valuelen; return XFS_ERROR(ERANGE); } args->valuelen = valuelen; memcpy(args->value, &name_loc->nameval[args->namelen], valuelen); } else { name_rmt = xfs_attr3_leaf_name_remote(leaf, args->index); ASSERT(name_rmt->namelen == args->namelen); ASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0); args->rmtvaluelen = be32_to_cpu(name_rmt->valuelen); args->rmtblkno = be32_to_cpu(name_rmt->valueblk); args->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount, args->rmtvaluelen); if (args->flags & ATTR_KERNOVAL) { args->valuelen = args->rmtvaluelen; return 0; } if (args->valuelen < args->rmtvaluelen) { args->valuelen = args->rmtvaluelen; return XFS_ERROR(ERANGE); } args->valuelen = args->rmtvaluelen; } return 0; }"
146,7261----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pal2rgb.c----main,"main(int argc, char* argv[]) { uint16 bitspersample, shortv; uint32 imagewidth, imagelength; uint16 config = PLANARCONFIG_CONTIG; uint32 rowsperstrip = (uint32) -1; uint16 photometric = PHOTOMETRIC_RGB; uint16 *rmap, *gmap, *bmap; uint32 row; int cmap = -1; TIFF *in, *out; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, ""C:c:p:r:"")) != -1) switch (c) { case 'C': cmap = atoi(optarg); break; case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'p': if (streq(optarg, ""separate"")) config = PLANARCONFIG_SEPARATE; else if (streq(optarg, ""contig"")) config = PLANARCONFIG_CONTIG; else usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case '?': usage(); } if (argc - optind != 2) usage(); in = TIFFOpen(argv[optind], ""r""); if (in == NULL) return (-1); if (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &shortv) || shortv != PHOTOMETRIC_PALETTE) { fprintf(stderr, ""%s: Expecting a palette image.\n"", argv[optind]); return (-1); } if (!TIFFGetField(in, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) { fprintf(stderr, ""%s: No colormap (not a valid palette image).\n"", argv[optind]); return (-1); } bitspersample = 0; TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample); if (bitspersample != 8) { fprintf(stderr, ""%s: Sorry, can only handle 8-bit images.\n"", argv[optind]); return (-1); } out = TIFFOpen(argv[optind+1], ""w""); <S2SV_StartVul> if (out == NULL) <S2SV_EndVul> return (-2); cpTags(in, out); TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength); if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else TIFFGetField(in, TIFFTAG_COMPRESSION, &compression); switch (compression) { case COMPRESSION_JPEG: if (jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; else photometric = PHOTOMETRIC_RGB; TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip)); (void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv); if (cmap == -1) cmap = checkcmap(1<<bitspersample, rmap, gmap, bmap); if (cmap == 16) { int i; for (i = (1<<bitspersample)-1; i >= 0; i--) { #define CVT(x) (((x) * 255) / ((1L<<16)-1)) rmap[i] = CVT(rmap[i]); gmap[i] = CVT(gmap[i]); bmap[i] = CVT(bmap[i]); } } { unsigned char *ibuf, *obuf; register unsigned char* pp; register uint32 x; tmsize_t tss_in = TIFFScanlineSize(in); tmsize_t tss_out = TIFFScanlineSize(out); if (tss_out / tss_in < 3) { fprintf(stderr, ""Could not determine correct image size for output. Exiting.\n""); return -1; } ibuf = (unsigned char*)_TIFFmalloc(tss_in); obuf = (unsigned char*)_TIFFmalloc(tss_out); switch (config) { case PLANARCONFIG_CONTIG: for (row = 0; row < imagelength; row++) { if (!TIFFReadScanline(in, ibuf, row, 0)) goto done; pp = obuf; for (x = 0; x < imagewidth; x++) { *pp++ = (unsigned char) rmap[ibuf[x]]; *pp++ = (unsigned char) gmap[ibuf[x]]; *pp++ = (unsigned char) bmap[ibuf[x]]; } if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; } break; case PLANARCONFIG_SEPARATE: for (row = 0; row < imagelength; row++) { if (!TIFFReadScanline(in, ibuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) rmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) gmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) bmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; } break; } _TIFFfree(ibuf); _TIFFfree(obuf); } done: (void) TIFFClose(in); (void) TIFFClose(out); return (0); }","- if (out == NULL)
+ (void) TIFFClose(in);
+ (void) TIFFClose(in);
+ (void) TIFFClose(in);
+ if (out == NULL) {
+ (void) TIFFClose(in);
+ }","main(int argc, char* argv[]) { uint16 bitspersample, shortv; uint32 imagewidth, imagelength; uint16 config = PLANARCONFIG_CONTIG; uint32 rowsperstrip = (uint32) -1; uint16 photometric = PHOTOMETRIC_RGB; uint16 *rmap, *gmap, *bmap; uint32 row; int cmap = -1; TIFF *in, *out; int c; #if !HAVE_DECL_OPTARG extern int optind; extern char* optarg; #endif while ((c = getopt(argc, argv, ""C:c:p:r:"")) != -1) switch (c) { case 'C': cmap = atoi(optarg); break; case 'c': if (!processCompressOptions(optarg)) usage(); break; case 'p': if (streq(optarg, ""separate"")) config = PLANARCONFIG_SEPARATE; else if (streq(optarg, ""contig"")) config = PLANARCONFIG_CONTIG; else usage(); break; case 'r': rowsperstrip = atoi(optarg); break; case '?': usage(); } if (argc - optind != 2) usage(); in = TIFFOpen(argv[optind], ""r""); if (in == NULL) return (-1); if (!TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &shortv) || shortv != PHOTOMETRIC_PALETTE) { fprintf(stderr, ""%s: Expecting a palette image.\n"", argv[optind]); (void) TIFFClose(in); return (-1); } if (!TIFFGetField(in, TIFFTAG_COLORMAP, &rmap, &gmap, &bmap)) { fprintf(stderr, ""%s: No colormap (not a valid palette image).\n"", argv[optind]); (void) TIFFClose(in); return (-1); } bitspersample = 0; TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bitspersample); if (bitspersample != 8) { fprintf(stderr, ""%s: Sorry, can only handle 8-bit images.\n"", argv[optind]); (void) TIFFClose(in); return (-1); } out = TIFFOpen(argv[optind+1], ""w""); if (out == NULL) { (void) TIFFClose(in); return (-2); } cpTags(in, out); TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &imagewidth); TIFFGetField(in, TIFFTAG_IMAGELENGTH, &imagelength); if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else TIFFGetField(in, TIFFTAG_COMPRESSION, &compression); switch (compression) { case COMPRESSION_JPEG: if (jpegcolormode == JPEGCOLORMODE_RGB) photometric = PHOTOMETRIC_YCBCR; else photometric = PHOTOMETRIC_RGB; TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_LZW: case COMPRESSION_DEFLATE: if (predictor != 0) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); break; } TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric); TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, 3); TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip)); (void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv); if (cmap == -1) cmap = checkcmap(1<<bitspersample, rmap, gmap, bmap); if (cmap == 16) { int i; for (i = (1<<bitspersample)-1; i >= 0; i--) { #define CVT(x) (((x) * 255) / ((1L<<16)-1)) rmap[i] = CVT(rmap[i]); gmap[i] = CVT(gmap[i]); bmap[i] = CVT(bmap[i]); } } { unsigned char *ibuf, *obuf; register unsigned char* pp; register uint32 x; tmsize_t tss_in = TIFFScanlineSize(in); tmsize_t tss_out = TIFFScanlineSize(out); if (tss_out / tss_in < 3) { fprintf(stderr, ""Could not determine correct image size for output. Exiting.\n""); return -1; } ibuf = (unsigned char*)_TIFFmalloc(tss_in); obuf = (unsigned char*)_TIFFmalloc(tss_out); switch (config) { case PLANARCONFIG_CONTIG: for (row = 0; row < imagelength; row++) { if (!TIFFReadScanline(in, ibuf, row, 0)) goto done; pp = obuf; for (x = 0; x < imagewidth; x++) { *pp++ = (unsigned char) rmap[ibuf[x]]; *pp++ = (unsigned char) gmap[ibuf[x]]; *pp++ = (unsigned char) bmap[ibuf[x]]; } if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; } break; case PLANARCONFIG_SEPARATE: for (row = 0; row < imagelength; row++) { if (!TIFFReadScanline(in, ibuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) rmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) gmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; for (pp = obuf, x = 0; x < imagewidth; x++) *pp++ = (unsigned char) bmap[ibuf[x]]; if (!TIFFWriteScanline(out, obuf, row, 0)) goto done; } break; } _TIFFfree(ibuf); _TIFFfree(obuf); } done: (void) TIFFClose(in); (void) TIFFClose(out); return (0); }"
147,1921----CWE-22----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-18586--chmextract.c----main,"int main(int argc, char *argv[]) { struct mschm_decompressor *chmd; struct mschmd_header *chm; struct mschmd_file *file, **f; unsigned int numf, i; setbuf(stdout, NULL); setbuf(stderr, NULL); user_umask = umask(0); umask(user_umask); MSPACK_SYS_SELFTEST(i); if (i) return 0; if ((chmd = mspack_create_chm_decompressor(NULL))) { for (argv++; *argv; argv++) { printf(""%s\n"", *argv); if ((chm = chmd->open(chmd, *argv))) { for (numf=0, file=chm->files; file; file = file->next) numf++; if ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) { for (i=0, file=chm->files; file; file = file->next) f[i++] = file; qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc); for (i = 0; i < numf; i++) { <S2SV_StartVul> char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0); <S2SV_EndVul> printf(""Extracting %s\n"", outname); ensure_filepath(outname); if (chmd->extract(chmd, f[i], outname)) { printf(""%s: extract error on \""%s\"": %s\n"", *argv, f[i]->filename, ERROR(chmd)); } free(outname); } free(f); } chmd->close(chmd, chm); } else { printf(""%s: can't open -- %s\n"", *argv, ERROR(chmd)); } } mspack_destroy_chm_decompressor(chmd); } return 0; }","- char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);
+ char *outname = create_output_name(f[i]->filename);","int main(int argc, char *argv[]) { struct mschm_decompressor *chmd; struct mschmd_header *chm; struct mschmd_file *file, **f; unsigned int numf, i; setbuf(stdout, NULL); setbuf(stderr, NULL); user_umask = umask(0); umask(user_umask); MSPACK_SYS_SELFTEST(i); if (i) return 0; if ((chmd = mspack_create_chm_decompressor(NULL))) { for (argv++; *argv; argv++) { printf(""%s\n"", *argv); if ((chm = chmd->open(chmd, *argv))) { for (numf=0, file=chm->files; file; file = file->next) numf++; if ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) { for (i=0, file=chm->files; file; file = file->next) f[i++] = file; qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc); for (i = 0; i < numf; i++) { char *outname = create_output_name(f[i]->filename); printf(""Extracting %s\n"", outname); ensure_filepath(outname); if (chmd->extract(chmd, f[i], outname)) { printf(""%s: extract error on \""%s\"": %s\n"", *argv, f[i]->filename, ERROR(chmd)); } free(outname); } free(f); } chmd->close(chmd, chm); } else { printf(""%s: can't open -- %s\n"", *argv, ERROR(chmd)); } } mspack_destroy_chm_decompressor(chmd); } return 0; }"
148,6339----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/HexOutStream.cxx----HexOutStream::writeBuffer,"HexOutStream::writeBuffer() { U8* pos = start; while (pos != ptr) { out_stream.check(2); U8* optr = out_stream.getptr(); U8* oend = out_stream.getend(); <S2SV_StartVul> int length = min(ptr-pos, (oend-optr)/2); <S2SV_EndVul> <S2SV_StartVul> for (int i=0; i<length; i++) { <S2SV_EndVul> optr[i*2] = intToHex((pos[i] >> 4) & 0xf); optr[i*2+1] = intToHex(pos[i] & 0xf); } out_stream.setptr(optr + length*2); pos += length; } offset += ptr - start; ptr = start; }","- int length = min(ptr-pos, (oend-optr)/2);
- for (int i=0; i<length; i++) {
+ size_t length = min(ptr-pos, (oend-optr)/2);
+ for (size_t i=0; i<length; i++) {","HexOutStream::writeBuffer() { U8* pos = start; while (pos != ptr) { out_stream.check(2); U8* optr = out_stream.getptr(); U8* oend = out_stream.getend(); size_t length = min(ptr-pos, (oend-optr)/2); for (size_t i=0; i<length; i++) { optr[i*2] = intToHex((pos[i] >> 4) & 0xf); optr[i*2+1] = intToHex(pos[i] & 0xf); } out_stream.setptr(optr + length*2); pos += length; } offset += ptr - start; ptr = start; }"
149,4217----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/lxcfs.c----cg_opendir,"static int cg_opendir(const char *path, struct fuse_file_info *fi) { struct fuse_context *fc = fuse_get_context(); const char *cgroup; struct file_info *dir_info; char *controller = NULL; if (!fc) return -EIO; if (strcmp(path, ""/cgroup"") == 0) { cgroup = NULL; controller = NULL; } else { controller = pick_controller_from_path(fc, path); if (!controller) return -EIO; cgroup = find_cgroup_in_path(path); if (!cgroup) { cgroup = ""/""; } } <S2SV_StartVul> if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) { <S2SV_EndVul> <S2SV_StartVul> return -EACCES; <S2SV_EndVul> } dir_info = malloc(sizeof(*dir_info)); if (!dir_info) return -ENOMEM; dir_info->controller = must_copy_string(controller); dir_info->cgroup = must_copy_string(cgroup); dir_info->type = LXC_TYPE_CGDIR; dir_info->buf = NULL; dir_info->file = NULL; dir_info->buflen = 0; fi->fh = (unsigned long)dir_info; return 0; }","- if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {
- return -EACCES;
+ if (cgroup) {
+ if (!caller_may_see_dir(fc->pid, controller, cgroup))
+ return -ENOENT;
+ if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))
+ return -EACCES;","static int cg_opendir(const char *path, struct fuse_file_info *fi) { struct fuse_context *fc = fuse_get_context(); const char *cgroup; struct file_info *dir_info; char *controller = NULL; if (!fc) return -EIO; if (strcmp(path, ""/cgroup"") == 0) { cgroup = NULL; controller = NULL; } else { controller = pick_controller_from_path(fc, path); if (!controller) return -EIO; cgroup = find_cgroup_in_path(path); if (!cgroup) { cgroup = ""/""; } } if (cgroup) { if (!caller_may_see_dir(fc->pid, controller, cgroup)) return -ENOENT; if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) return -EACCES; } dir_info = malloc(sizeof(*dir_info)); if (!dir_info) return -ENOMEM; dir_info->controller = must_copy_string(controller); dir_info->cgroup = must_copy_string(cgroup); dir_info->type = LXC_TYPE_CGDIR; dir_info->buf = NULL; dir_info->file = NULL; dir_info->buflen = 0; fi->fh = (unsigned long)dir_info; return 0; }"
150,241----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2010-0011--test-command.c----test_js,"test_js (void) { GString *result = g_string_new(""""); parse_cmd_line(""js ('x' + 345).toUpperCase()"", result); g_assert_cmpstr(""X345"", ==, result->str); <S2SV_StartVul> uzbl.net.useragent = ""Test useragent""; <S2SV_EndVul> <S2SV_StartVul> parse_cmd_line(""js Uzbl.run('print @useragent').toUpperCase();"", result); <S2SV_EndVul> <S2SV_StartVul> g_assert_cmpstr(""TEST USERAGENT"", ==, result->str); <S2SV_EndVul> g_string_free(result, TRUE); }","- uzbl.net.useragent = ""Test useragent"";
- parse_cmd_line(""js Uzbl.run('print @useragent').toUpperCase();"", result);
- g_assert_cmpstr(""TEST USERAGENT"", ==, result->str);","test_js (void) { GString *result = g_string_new(""""); parse_cmd_line(""js ('x' + 345).toUpperCase()"", result); g_assert_cmpstr(""X345"", ==, result->str); g_string_free(result, TRUE); }"
151,4264----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nego.c----nego_read_request,"BOOL nego_read_request(rdpNego* nego, wStream* s) { BYTE li; BYTE type; UINT16 length; if (!tpkt_read_header(s, &length)) return FALSE; if (!tpdu_read_connection_request(s, &li, length)) return FALSE; if (li != Stream_GetRemainingLength(s) + 6) { WLog_ERR(TAG, ""Incorrect TPDU length indicator.""); return FALSE; } if (!nego_read_request_token_or_cookie(nego, s)) { WLog_ERR(TAG, ""Failed to parse routing token or cookie.""); return FALSE; } if (Stream_GetRemainingLength(s) >= 8) { Stream_Read_UINT8(s, type); if (type != TYPE_RDP_NEG_REQ) { WLog_ERR(TAG, ""Incorrect negotiation request type %"" PRIu8 """", type); return FALSE; } <S2SV_StartVul> nego_process_negotiation_request(nego, s); <S2SV_EndVul> } return tpkt_ensure_stream_consumed(s, length); }","- nego_process_negotiation_request(nego, s);
+ if (!nego_process_negotiation_request(nego, s))
+ return FALSE;","BOOL nego_read_request(rdpNego* nego, wStream* s) { BYTE li; BYTE type; UINT16 length; if (!tpkt_read_header(s, &length)) return FALSE; if (!tpdu_read_connection_request(s, &li, length)) return FALSE; if (li != Stream_GetRemainingLength(s) + 6) { WLog_ERR(TAG, ""Incorrect TPDU length indicator.""); return FALSE; } if (!nego_read_request_token_or_cookie(nego, s)) { WLog_ERR(TAG, ""Failed to parse routing token or cookie.""); return FALSE; } if (Stream_GetRemainingLength(s) >= 8) { Stream_Read_UINT8(s, type); if (type != TYPE_RDP_NEG_REQ) { WLog_ERR(TAG, ""Incorrect negotiation request type %"" PRIu8 """", type); return FALSE; } if (!nego_process_negotiation_request(nego, s)) return FALSE; } return tpkt_ensure_stream_consumed(s, length); }"
152,4766----CWE-672----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/zrleDecode.h----rfb::ZRLE_DECODE,"void ZRLE_DECODE (const Rect& r, rdr::InStream* is, rdr::ZlibInStream* zis, const PixelFormat& pf, ModifiablePixelBuffer* pb) { int length = is->readU32(); zis->setUnderlying(is, length); Rect t; PIXEL_T buf[64 * 64]; for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) { t.br.y = __rfbmin(r.br.y, t.tl.y + 64); for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) { t.br.x = __rfbmin(r.br.x, t.tl.x + 64); int mode = zis->readU8(); bool rle = mode & 128; int palSize = mode & 127; PIXEL_T palette[128]; for (int i = 0; i < palSize; i++) { palette[i] = READ_PIXEL(zis); } if (palSize == 1) { PIXEL_T pix = palette[0]; pb->fillRect(pf, t, &pix); continue; } if (!rle) { if (palSize == 0) { #ifdef CPIXEL for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) { *ptr = READ_PIXEL(zis); } #else zis->readBytes(buf, t.area() * (BPP / 8)); #endif } else { int bppp = ((palSize > 16) ? 8 : ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1))); PIXEL_T* ptr = buf; for (int i = 0; i < t.height(); i++) { PIXEL_T* eol = ptr + t.width(); rdr::U8 byte = 0; rdr::U8 nbits = 0; while (ptr < eol) { if (nbits == 0) { byte = zis->readU8(); nbits = 8; } nbits -= bppp; rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127; *ptr++ = palette[index]; } } } } else { if (palSize == 0) { PIXEL_T* ptr = buf; PIXEL_T* end = ptr + t.area(); while (ptr < end) { PIXEL_T pix = READ_PIXEL(zis); int len = 1; int b; do { b = zis->readU8(); len += b; } while (b == 255); if (end - ptr < len) { throw Exception (""ZRLE decode error""); } while (len-- > 0) *ptr++ = pix; } } else { PIXEL_T* ptr = buf; PIXEL_T* end = ptr + t.area(); while (ptr < end) { int index = zis->readU8(); int len = 1; if (index & 128) { int b; do { b = zis->readU8(); len += b; } while (b == 255); if (end - ptr < len) { throw Exception (""ZRLE decode error""); } } index &= 127; PIXEL_T pix = palette[index]; while (len-- > 0) *ptr++ = pix; } } } pb->imageRect(pf, t, buf); } } <S2SV_StartVul> zis->removeUnderlying(); <S2SV_EndVul> }","- zis->removeUnderlying();
+ zis->flushUnderlying();
+ zis->setUnderlying(NULL, 0);","void ZRLE_DECODE (const Rect& r, rdr::InStream* is, rdr::ZlibInStream* zis, const PixelFormat& pf, ModifiablePixelBuffer* pb) { int length = is->readU32(); zis->setUnderlying(is, length); Rect t; PIXEL_T buf[64 * 64]; for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) { t.br.y = __rfbmin(r.br.y, t.tl.y + 64); for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) { t.br.x = __rfbmin(r.br.x, t.tl.x + 64); int mode = zis->readU8(); bool rle = mode & 128; int palSize = mode & 127; PIXEL_T palette[128]; for (int i = 0; i < palSize; i++) { palette[i] = READ_PIXEL(zis); } if (palSize == 1) { PIXEL_T pix = palette[0]; pb->fillRect(pf, t, &pix); continue; } if (!rle) { if (palSize == 0) { #ifdef CPIXEL for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) { *ptr = READ_PIXEL(zis); } #else zis->readBytes(buf, t.area() * (BPP / 8)); #endif } else { int bppp = ((palSize > 16) ? 8 : ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1))); PIXEL_T* ptr = buf; for (int i = 0; i < t.height(); i++) { PIXEL_T* eol = ptr + t.width(); rdr::U8 byte = 0; rdr::U8 nbits = 0; while (ptr < eol) { if (nbits == 0) { byte = zis->readU8(); nbits = 8; } nbits -= bppp; rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127; *ptr++ = palette[index]; } } } } else { if (palSize == 0) { PIXEL_T* ptr = buf; PIXEL_T* end = ptr + t.area(); while (ptr < end) { PIXEL_T pix = READ_PIXEL(zis); int len = 1; int b; do { b = zis->readU8(); len += b; } while (b == 255); if (end - ptr < len) { throw Exception (""ZRLE decode error""); } while (len-- > 0) *ptr++ = pix; } } else { PIXEL_T* ptr = buf; PIXEL_T* end = ptr + t.area(); while (ptr < end) { int index = zis->readU8(); int len = 1; if (index & 128) { int b; do { b = zis->readU8(); len += b; } while (b == 255); if (end - ptr < len) { throw Exception (""ZRLE decode error""); } } index &= 127; PIXEL_T pix = palette[index]; while (len-- > 0) *ptr++ = pix; } } } pb->imageRect(pf, t, buf); } } zis->flushUnderlying(); zis->setUnderlying(NULL, 0); }"
153,3182----CWE-79----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/peerlistwidget.cpp----PeerListWidget::addPeer,"QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer) { int row = m_listModel->rowCount(); m_listModel->insertRow(row); m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip); m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole); m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port); m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip); if (m_resolveCountries) { const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country()); if (!ico.isNull()) { m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole); const QString countryName = Net::GeoIPManager::CountryName(peer.country()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole); } else { m_missingFlags.insert(ip); } } m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole); <S2SV_StartVul> m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client()); <S2SV_EndVul> m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance()); QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex())); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String("";""))); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(""\n"")), Qt::ToolTipRole); return m_listModel->item(row, PeerListDelegate::IP); }","- m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());
+ m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));","QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer) { int row = m_listModel->rowCount(); m_listModel->insertRow(row); m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip); m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole); m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port); m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip); if (m_resolveCountries) { const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country()); if (!ico.isNull()) { m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole); const QString countryName = Net::GeoIPManager::CountryName(peer.country()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole); } else { m_missingFlags.insert(ip); } } m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole); m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client())); m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance()); QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex())); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String("";""))); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(""\n"")), Qt::ToolTipRole); return m_listModel->item(row, PeerListDelegate::IP); }"
154,5822----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/keys.c----find_jws,"find_jws(struct tang_keys_info* tki, const char* thp) { if (!tki) { return NULL; } if (thp == NULL) { json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign); if (!jws) { return NULL; } return json_incref(jws); } <S2SV_StartVul> return find_by_thp(tki, thp); <S2SV_EndVul> }","- return find_by_thp(tki, thp);
+ json_auto_t* jwk = find_by_thp(tki, thp);
+ if (!jwk_valid_for_signing(jwk)) {
+ return NULL;
+ }
+ json_auto_t* sign = json_deep_copy(tki->m_sign);
+ if (json_array_append(sign, jwk) == -1) {
+ return NULL;
+ }
+ json_auto_t* jws = jwk_sign(tki->m_payload, sign);
+ if (!jws) {
+ return NULL;
+ }
+ return json_incref(jws);","find_jws(struct tang_keys_info* tki, const char* thp) { if (!tki) { return NULL; } if (thp == NULL) { json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign); if (!jws) { return NULL; } return json_incref(jws); } json_auto_t* jwk = find_by_thp(tki, thp); if (!jwk_valid_for_signing(jwk)) { return NULL; } json_auto_t* sign = json_deep_copy(tki->m_sign); if (json_array_append(sign, jwk) == -1) { return NULL; } json_auto_t* jws = jwk_sign(tki->m_payload, sign); if (!jws) { return NULL; } return json_incref(jws); }"
155,3661----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ne.c----r_bin_ne_get_entrypoints,"RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { if (!bin->entry_table) { return NULL; } RList *entries = r_list_newf (free); if (!entries) { return NULL; } RList *segments = r_bin_ne_get_segments (bin); if (!segments) { r_list_free (entries); return NULL; } if (bin->ne_header->csEntryPoint) { RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } entry->bits = 16; ut32 entry_cs = bin->ne_header->csEntryPoint; RBinSection *s = r_list_get_n (segments, entry_cs - 1); entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0); r_list_append (entries, entry); } int off = 0; size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; while (off < bin->ne_header->EntryTableLength) { if (tableat + off >= r_buf_size (bin->buf)) { break; } ut8 bundle_length = *(ut8 *)(bin->entry_table + off); if (!bundle_length) { break; } off++; ut8 bundle_type = *(ut8 *)(bin->entry_table + off); off++; int i; for (i = 0; i < bundle_length; i++) { if (tableat + off + 4 >= r_buf_size (bin->buf)) { break; } RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } off++; if (!bundle_type) { off--; free (entry); break; } else if (bundle_type == 0xff) { off += 2; ut8 segnum = *(bin->entry_table + off); off++; <S2SV_StartVul> ut16 segoff = *(ut16 *)(bin->entry_table + off); <S2SV_EndVul> <S2SV_StartVul> if (segnum > 0) { <S2SV_EndVul> entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; } } else { if (bundle_type < bin->ne_header->SegCount) { entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset <S2SV_StartVul> * bin->alignment + *(ut16 *)(bin->entry_table + off); <S2SV_EndVul> } } off += 2; r_list_append (entries, entry); } } r_list_free (segments); bin->entries = entries; return entries; }","- ut16 segoff = *(ut16 *)(bin->entry_table + off);
- if (segnum > 0) {
+ if (off > bin->ne_header->EntryTableLength) {
+ break;
+ }
+ ut16 segoff = r_read_le16 (bin->entry_table + off);
+ if (segnum > 0 && segnum < bin->ne_header->SegCount) {
+ if (off + 2 >= bin->ne_header->EntryTableLength) {
+ break;
+ }
+ ut16 delta = r_read_le16 (bin->entry_table + off);","RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { if (!bin->entry_table) { return NULL; } RList *entries = r_list_newf (free); if (!entries) { return NULL; } RList *segments = r_bin_ne_get_segments (bin); if (!segments) { r_list_free (entries); return NULL; } if (bin->ne_header->csEntryPoint) { RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } entry->bits = 16; ut32 entry_cs = bin->ne_header->csEntryPoint; RBinSection *s = r_list_get_n (segments, entry_cs - 1); entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0); r_list_append (entries, entry); } int off = 0; size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; while (off < bin->ne_header->EntryTableLength) { if (tableat + off >= r_buf_size (bin->buf)) { break; } ut8 bundle_length = *(ut8 *)(bin->entry_table + off); if (!bundle_length) { break; } off++; ut8 bundle_type = *(ut8 *)(bin->entry_table + off); off++; int i; for (i = 0; i < bundle_length; i++) { if (tableat + off + 4 >= r_buf_size (bin->buf)) { break; } RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } off++; if (!bundle_type) { off--; free (entry); break; } else if (bundle_type == 0xff) { off += 2; ut8 segnum = *(bin->entry_table + off); off++; if (off > bin->ne_header->EntryTableLength) { break; } ut16 segoff = r_read_le16 (bin->entry_table + off); if (segnum > 0 && segnum < bin->ne_header->SegCount) { entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; } } else { if (off + 2 >= bin->ne_header->EntryTableLength) { break; } ut16 delta = r_read_le16 (bin->entry_table + off); if (bundle_type < bin->ne_header->SegCount) { entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + delta; } } off += 2; r_list_append (entries, entry); } } r_list_free (segments); bin->entries = entries; return entries; }"
156,3041----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/secure_enclave.c----trustedGetPublicSharesAES,"<S2SV_StartVul> void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len, <S2SV_EndVul> char *public_shares, unsigned _t, unsigned _n) { LOG_INFO(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(encrypted_dkg_secret); CHECK_STATE(public_shares); CHECK_STATE(_t <= _n && _n > 0) SAFE_CHAR_BUF(decrypted_dkg_secret, DKG_MAX_SEALED_LEN); int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret, DKG_MAX_SEALED_LEN); CHECK_STATUS2(""aes decrypt data - encrypted_dkg_secret failed with status %d""); status = calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0; CHECK_STATUS(""t does not match polynomial in db""); SET_SUCCESS clean: ; LOG_INFO(""SGX call completed""); }","- void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,
+ void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len,","void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t enc_len, char *public_shares, unsigned _t, unsigned _n) { LOG_INFO(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(encrypted_dkg_secret); CHECK_STATE(public_shares); CHECK_STATE(_t <= _n && _n > 0) SAFE_CHAR_BUF(decrypted_dkg_secret, DKG_MAX_SEALED_LEN); int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret, DKG_MAX_SEALED_LEN); CHECK_STATUS2(""aes decrypt data - encrypted_dkg_secret failed with status %d""); status = calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0; CHECK_STATUS(""t does not match polynomial in db""); SET_SUCCESS clean: ; LOG_INFO(""SGX call completed""); }"
157,7323----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xsave.h----xsave_state_booting,"static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask) { u32 lmask = mask; u32 hmask = mask >> 32; int err = 0; WARN_ON(system_state != SYSTEM_BOOTING); if (boot_cpu_has(X86_FEATURE_XSAVES)) asm volatile(""1:""XSAVES""\n\t"" ""2:\n\t"" <S2SV_StartVul> : : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask) <S2SV_EndVul> : ""memory""); else asm volatile(""1:""XSAVE""\n\t"" ""2:\n\t"" <S2SV_StartVul> : : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask) <S2SV_EndVul> : ""memory""); <S2SV_StartVul> asm volatile(xstate_fault <S2SV_EndVul> <S2SV_StartVul> : ""0"" (0) <S2SV_EndVul> <S2SV_StartVul> : ""memory""); <S2SV_EndVul> return err; }","- : : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
- : : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
- asm volatile(xstate_fault
- : ""0"" (0)
- : ""memory"");
+ xstate_fault
+ : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)
+ xstate_fault
+ : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask)","static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask) { u32 lmask = mask; u32 hmask = mask >> 32; int err = 0; WARN_ON(system_state != SYSTEM_BOOTING); if (boot_cpu_has(X86_FEATURE_XSAVES)) asm volatile(""1:""XSAVES""\n\t"" ""2:\n\t"" xstate_fault : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask) : ""memory""); else asm volatile(""1:""XSAVE""\n\t"" ""2:\n\t"" xstate_fault : ""D"" (fx), ""m"" (*fx), ""a"" (lmask), ""d"" (hmask) : ""memory""); return err; }"
158,4726----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gd.c----gdImageLine,"void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color) { int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag; int wid; int w, wstart; int thick = im->thick; if (color == gdAntiAliased) { <S2SV_StartVul> gdImageAALine(im, x1, y1, x2, y2, im->AA_color); <S2SV_EndVul> return; } if (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) { return; } dx = abs (x2 - x1); dy = abs (y2 - y1); if (dx == 0) { gdImageVLine(im, x1, y1, y2, color); return; } else if (dy == 0) { gdImageHLine(im, y1, x1, x2, color); return; } if (dy <= dx) { if ((dx == 0) && (dy == 0)) { wid = 1; } else { double ac = cos (atan2 (dy, dx)); if (ac != 0) { wid = thick / ac; } else { wid = 1; } if (wid == 0) { wid = 1; } } d = 2 * dy - dx; incr1 = 2 * dy; incr2 = 2 * (dy - dx); if (x1 > x2) { x = x2; y = y2; ydirflag = (-1); xend = x1; } else { x = x1; y = y1; ydirflag = 1; xend = x2; } wstart = y - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel(im, x, w, color); } if (((y2 - y1) * ydirflag) > 0) { while (x < xend) { x++; if (d < 0) { d += incr1; } else { y++; d += incr2; } wstart = y - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, x, w, color); } } } else { while (x < xend) { x++; if (d < 0) { d += incr1; } else { y--; d += incr2; } wstart = y - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, x, w, color); } } } } else { double as = sin (atan2 (dy, dx)); if (as != 0) { wid = thick / as; } else { wid = 1; } if (wid == 0) { wid = 1; } d = 2 * dx - dy; incr1 = 2 * dx; incr2 = 2 * (dx - dy); if (y1 > y2) { y = y2; x = x2; yend = y1; xdirflag = (-1); } else { y = y1; x = x1; yend = y2; xdirflag = 1; } wstart = x - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, w, y, color); } if (((x2 - x1) * xdirflag) > 0) { while (y < yend) { y++; if (d < 0) { d += incr1; } else { x++; d += incr2; } wstart = x - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, w, y, color); } } } else { while (y < yend) { y++; if (d < 0) { d += incr1; } else { x--; d += incr2; } wstart = x - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, w, y, color); } } } } }","- gdImageAALine(im, x1, y1, x2, y2, im->AA_color);
+ gdImageAALine(im, x1, y1, x2, y2, im->AA_color);","void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color) { int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag; int wid; int w, wstart; int thick = im->thick; if (color == gdAntiAliased) { gdImageAALine(im, x1, y1, x2, y2, im->AA_color); return; } if (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) { return; } dx = abs (x2 - x1); dy = abs (y2 - y1); if (dx == 0) { gdImageVLine(im, x1, y1, y2, color); return; } else if (dy == 0) { gdImageHLine(im, y1, x1, x2, color); return; } if (dy <= dx) { if ((dx == 0) && (dy == 0)) { wid = 1; } else { double ac = cos (atan2 (dy, dx)); if (ac != 0) { wid = thick / ac; } else { wid = 1; } if (wid == 0) { wid = 1; } } d = 2 * dy - dx; incr1 = 2 * dy; incr2 = 2 * (dy - dx); if (x1 > x2) { x = x2; y = y2; ydirflag = (-1); xend = x1; } else { x = x1; y = y1; ydirflag = 1; xend = x2; } wstart = y - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel(im, x, w, color); } if (((y2 - y1) * ydirflag) > 0) { while (x < xend) { x++; if (d < 0) { d += incr1; } else { y++; d += incr2; } wstart = y - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, x, w, color); } } } else { while (x < xend) { x++; if (d < 0) { d += incr1; } else { y--; d += incr2; } wstart = y - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, x, w, color); } } } } else { double as = sin (atan2 (dy, dx)); if (as != 0) { wid = thick / as; } else { wid = 1; } if (wid == 0) { wid = 1; } d = 2 * dx - dy; incr1 = 2 * dx; incr2 = 2 * (dx - dy); if (y1 > y2) { y = y2; x = x2; yend = y1; xdirflag = (-1); } else { y = y1; x = x1; yend = y2; xdirflag = 1; } wstart = x - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, w, y, color); } if (((x2 - x1) * xdirflag) > 0) { while (y < yend) { y++; if (d < 0) { d += incr1; } else { x++; d += incr2; } wstart = x - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, w, y, color); } } } else { while (y < yend) { y++; if (d < 0) { d += incr1; } else { x--; d += incr2; } wstart = x - wid / 2; for (w = wstart; w < wstart + wid; w++) { gdImageSetPixel (im, w, y, color); } } } } }"
159,5537----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/enc624j600_driver.c----enc624j600UpdateMacConfig,"void enc624j600UpdateMacConfig(NetInterface *interface) { uint16_t duplexMode; <S2SV_StartVul> duplexMode = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_PHYDPX; <S2SV_EndVul> if(duplexMode) { <S2SV_StartVul> enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER | <S2SV_EndVul> <S2SV_StartVul> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX); <S2SV_EndVul> <S2SV_StartVul> enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x15); <S2SV_EndVul> } else { <S2SV_StartVul> enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER | <S2SV_EndVul> <S2SV_StartVul> MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1); <S2SV_EndVul> <S2SV_StartVul> enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x12); <S2SV_EndVul> } }","- duplexMode = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_PHYDPX;
- enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |
- MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX);
- enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x15);
- enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |
- MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1);
- enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x12);
+ duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX;
+ enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |
+ ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |
+ ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX);
+ enc624j600WriteReg(interface, ENC624J600_MABBIPG,
+ ENC624J600_MABBIPG_BBIPG_DEFAULT_FD);
+ enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |
+ ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |
+ ENC624J600_MACON2_R1_DEFAULT);
+ enc624j600WriteReg(interface, ENC624J600_MABBIPG,
+ ENC624J600_MABBIPG_BBIPG_DEFAULT_HD);","void enc624j600UpdateMacConfig(NetInterface *interface) { uint16_t duplexMode; duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX; if(duplexMode) { enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX); enc624j600WriteReg(interface, ENC624J600_MABBIPG, ENC624J600_MABBIPG_BBIPG_DEFAULT_FD); } else { enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER | ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN | ENC624J600_MACON2_R1_DEFAULT); enc624j600WriteReg(interface, ENC624J600_MABBIPG, ENC624J600_MABBIPG_BBIPG_DEFAULT_HD); } }"
160,7181----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event_intel_ds.c----__intel_pmu_pebs_event,"static void __intel_pmu_pebs_event(struct perf_event *event, struct pt_regs *iregs, void *__pebs) { struct pebs_record_core *pebs = __pebs; struct perf_sample_data data; struct pt_regs regs; if (!intel_pmu_save_and_restart(event)) return; perf_sample_data_init(&data, 0); data.period = event->hw.last_period; regs = *iregs; regs.ip = pebs->ip; regs.bp = pebs->bp; regs.sp = pebs->sp; if (event->attr.precise_ip > 1 && intel_pmu_pebs_fixup_ip(&regs)) regs.flags |= PERF_EFLAGS_EXACT; else regs.flags &= ~PERF_EFLAGS_EXACT; <S2SV_StartVul> if (perf_event_overflow(event, 1, &data, &regs)) <S2SV_EndVul> x86_pmu_stop(event, 0); }","- if (perf_event_overflow(event, 1, &data, &regs))
+ if (perf_event_overflow(event, &data, &regs))","static void __intel_pmu_pebs_event(struct perf_event *event, struct pt_regs *iregs, void *__pebs) { struct pebs_record_core *pebs = __pebs; struct perf_sample_data data; struct pt_regs regs; if (!intel_pmu_save_and_restart(event)) return; perf_sample_data_init(&data, 0); data.period = event->hw.last_period; regs = *iregs; regs.ip = pebs->ip; regs.bp = pebs->bp; regs.sp = pebs->sp; if (event->attr.precise_ip > 1 && intel_pmu_pebs_fixup_ip(&regs)) regs.flags |= PERF_EFLAGS_EXACT; else regs.flags &= ~PERF_EFLAGS_EXACT; if (perf_event_overflow(event, &data, &regs)) x86_pmu_stop(event, 0); }"
161,3365----CWE-835----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/wav_playlist.c----pjmedia_wav_playlist_create,"PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool, const pj_str_t *port_label, const pj_str_t file_list[], int file_count, unsigned ptime, unsigned options, pj_ssize_t buff_size, pjmedia_port **p_port) { struct playlist_port *fport; pjmedia_audio_format_detail *afd; pj_off_t pos; pj_status_t status; int index; pj_bool_t has_wave_info = PJ_FALSE; pj_str_t tmp_port_label; char filename[PJ_MAXPATH]; PJ_ASSERT_RETURN(pool && file_list && file_count && p_port, PJ_EINVAL); if (port_label == NULL || port_label->slen == 0) { tmp_port_label = pj_str(""WAV playlist""); port_label = &tmp_port_label; } for (index=0; index<file_count; index++) { PJ_ASSERT_RETURN(file_list[index].slen >= 0, PJ_ETOOSMALL); if (file_list[index].slen >= PJ_MAXPATH) return PJ_ENAMETOOLONG; pj_memcpy(filename, file_list[index].ptr, file_list[index].slen); filename[file_list[index].slen] = '\0'; if (!pj_file_exists(filename)) { PJ_LOG(4,(THIS_FILE, ""WAV playlist error: file '%s' not found"", filename)); return PJ_ENOTFOUND; } } if (ptime == 0) ptime = 20; fport = create_file_list_port(pool, port_label); if (!fport) { return PJ_ENOMEM; } afd = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1); fport->current_file = 0; fport->max_file = file_count; fport->fd_list = (pj_oshandle_t*) pj_pool_zalloc(pool, sizeof(pj_oshandle_t)*file_count); if (!fport->fd_list) { return PJ_ENOMEM; } fport->fsize_list = (pj_off_t*) pj_pool_alloc(pool, sizeof(pj_off_t)*file_count); if (!fport->fsize_list) { return PJ_ENOMEM; } fport->start_data_list = (unsigned*) pj_pool_alloc(pool, sizeof(unsigned)*file_count); if (!fport->start_data_list) { return PJ_ENOMEM; } fport->data_len_list = (unsigned*) pj_pool_alloc(pool, sizeof(unsigned)*file_count); if (!fport->data_len_list) { return PJ_ENOMEM; } fport->data_left_list = (unsigned*) pj_pool_alloc(pool, sizeof(unsigned)*file_count); if (!fport->data_left_list) { return PJ_ENOMEM; } fport->fpos_list = (pj_off_t*) pj_pool_alloc(pool, sizeof(pj_off_t)*file_count); if (!fport->fpos_list) { return PJ_ENOMEM; } if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE; fport->bufsize = (pj_uint32_t)buff_size; fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize); if (!fport->buf) { return PJ_ENOMEM; } fport->options = options; fport->readpos = fport->buf; for (index=file_count-1; index>=0; index--) { pjmedia_wave_hdr wavehdr; <S2SV_StartVul> pj_ssize_t size_to_read, size_read; <S2SV_EndVul> pj_memcpy(filename, file_list[index].ptr, file_list[index].slen); filename[file_list[index].slen] = '\0'; fport->current_file = index; fport->fsize_list[index] = pj_file_size(filename); if (fport->fsize_list[index] <= sizeof(pjmedia_wave_hdr)) { status = PJMEDIA_ENOTVALIDWAVE; goto on_error; } status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd_list[index]); if (status != PJ_SUCCESS) goto on_error; <S2SV_StartVul> size_read = size_to_read = sizeof(wavehdr) - 8; <S2SV_EndVul> status = pj_file_read( fport->fd_list[index], &wavehdr, &size_read); if (status != PJ_SUCCESS) { goto on_error; } if (size_read != size_to_read) { status = PJMEDIA_ENOTVALIDWAVE; goto on_error; } pjmedia_wave_hdr_file_to_host(&wavehdr); if (wavehdr.riff_hdr.riff != PJMEDIA_RIFF_TAG || wavehdr.riff_hdr.wave != PJMEDIA_WAVE_TAG || wavehdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG) { TRACE_((THIS_FILE, ""actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x"", wavehdr.riff_hdr.riff, PJMEDIA_RIFF_TAG, wavehdr.riff_hdr.wave, PJMEDIA_WAVE_TAG, wavehdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG)); status = PJMEDIA_ENOTVALIDWAVE; goto on_error; } if (wavehdr.fmt_hdr.fmt_tag != 1 || wavehdr.fmt_hdr.bits_per_sample != 16) { status = PJMEDIA_EWAVEUNSUPP; goto on_error; } if (wavehdr.fmt_hdr.block_align != wavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE) { status = PJMEDIA_EWAVEUNSUPP; goto on_error; } if (wavehdr.fmt_hdr.len > 16) { <S2SV_StartVul> size_to_read = wavehdr.fmt_hdr.len - 16; <S2SV_EndVul> status = pj_file_setpos(fport->fd_list[index], size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } for (;;) { pjmedia_wave_subchunk subchunk; size_read = 8; status = pj_file_read(fport->fd_list[index], &subchunk, &size_read); if (status != PJ_SUCCESS || size_read != 8) { status = PJMEDIA_EWAVETOOSHORT; goto on_error; } PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk); if (subchunk.id == PJMEDIA_DATA_TAG) { wavehdr.data_hdr.data = PJMEDIA_DATA_TAG; wavehdr.data_hdr.len = subchunk.len; break; } size_to_read = subchunk.len; status = pj_file_setpos(fport->fd_list[index], size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } status = pj_file_getpos(fport->fd_list[index], &pos); fport->start_data_list[index] = (unsigned)pos; fport->data_len_list[index] = wavehdr.data_hdr.len; fport->data_left_list[index] = wavehdr.data_hdr.len; if (wavehdr.data_hdr.len > fport->fsize_list[index] - fport->start_data_list[index]) { status = PJMEDIA_EWAVEUNSUPP; goto on_error; } if (wavehdr.data_hdr.len < ptime * wavehdr.fmt_hdr.sample_rate * wavehdr.fmt_hdr.nchan / 1000) { status = PJMEDIA_EWAVETOOSHORT; goto on_error; } if (!has_wave_info) { afd->channel_count = wavehdr.fmt_hdr.nchan; afd->clock_rate = wavehdr.fmt_hdr.sample_rate; afd->bits_per_sample = wavehdr.fmt_hdr.bits_per_sample; afd->frame_time_usec = ptime * 1000; afd->avg_bps = afd->max_bps = afd->clock_rate * afd->channel_count * afd->bits_per_sample; has_wave_info = PJ_TRUE; } else { if (wavehdr.fmt_hdr.nchan != afd->channel_count || wavehdr.fmt_hdr.sample_rate != afd->clock_rate || wavehdr.fmt_hdr.bits_per_sample != afd->bits_per_sample) { PJ_LOG(4,(THIS_FILE, ""WAV playlist error: file '%s' has differrent number"" "" of channels, sample rate, or bits per sample"", filename)); status = PJMEDIA_EWAVEUNSUPP; goto on_error; } } if (wavehdr.data_hdr.len < (unsigned)buff_size) buff_size = wavehdr.data_hdr.len; fport->bufsize = (pj_uint32_t)buff_size; fport->fpos_list[index] = fport->start_data_list[index]; } status = file_fill_buffer(fport); if (status != PJ_SUCCESS) { goto on_error; } *p_port = &fport->base; PJ_LOG(4,(THIS_FILE, ""WAV playlist '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB"", (int)port_label->slen, port_label->ptr, afd->clock_rate, afd->channel_count, fport->bufsize / 1000)); return PJ_SUCCESS; on_error: for (index=0; index<file_count; ++index) { if (fport->fd_list[index] != 0) pj_file_close(fport->fd_list[index]); } return status; }","- pj_ssize_t size_to_read, size_read;
- size_read = size_to_read = sizeof(wavehdr) - 8;
- size_to_read = wavehdr.fmt_hdr.len - 16;
+ pj_ssize_t size_read;
+ pj_off_t size_to_read;
+ size_to_read = size_read = sizeof(wavehdr) - 8;
+ PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,
+ status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);
+ size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;
+ PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len,
+ status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);","PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool, const pj_str_t *port_label, const pj_str_t file_list[], int file_count, unsigned ptime, unsigned options, pj_ssize_t buff_size, pjmedia_port **p_port) { struct playlist_port *fport; pjmedia_audio_format_detail *afd; pj_off_t pos; pj_status_t status; int index; pj_bool_t has_wave_info = PJ_FALSE; pj_str_t tmp_port_label; char filename[PJ_MAXPATH]; PJ_ASSERT_RETURN(pool && file_list && file_count && p_port, PJ_EINVAL); if (port_label == NULL || port_label->slen == 0) { tmp_port_label = pj_str(""WAV playlist""); port_label = &tmp_port_label; } for (index=0; index<file_count; index++) { PJ_ASSERT_RETURN(file_list[index].slen >= 0, PJ_ETOOSMALL); if (file_list[index].slen >= PJ_MAXPATH) return PJ_ENAMETOOLONG; pj_memcpy(filename, file_list[index].ptr, file_list[index].slen); filename[file_list[index].slen] = '\0'; if (!pj_file_exists(filename)) { PJ_LOG(4,(THIS_FILE, ""WAV playlist error: file '%s' not found"", filename)); return PJ_ENOTFOUND; } } if (ptime == 0) ptime = 20; fport = create_file_list_port(pool, port_label); if (!fport) { return PJ_ENOMEM; } afd = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1); fport->current_file = 0; fport->max_file = file_count; fport->fd_list = (pj_oshandle_t*) pj_pool_zalloc(pool, sizeof(pj_oshandle_t)*file_count); if (!fport->fd_list) { return PJ_ENOMEM; } fport->fsize_list = (pj_off_t*) pj_pool_alloc(pool, sizeof(pj_off_t)*file_count); if (!fport->fsize_list) { return PJ_ENOMEM; } fport->start_data_list = (unsigned*) pj_pool_alloc(pool, sizeof(unsigned)*file_count); if (!fport->start_data_list) { return PJ_ENOMEM; } fport->data_len_list = (unsigned*) pj_pool_alloc(pool, sizeof(unsigned)*file_count); if (!fport->data_len_list) { return PJ_ENOMEM; } fport->data_left_list = (unsigned*) pj_pool_alloc(pool, sizeof(unsigned)*file_count); if (!fport->data_left_list) { return PJ_ENOMEM; } fport->fpos_list = (pj_off_t*) pj_pool_alloc(pool, sizeof(pj_off_t)*file_count); if (!fport->fpos_list) { return PJ_ENOMEM; } if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE; fport->bufsize = (pj_uint32_t)buff_size; fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize); if (!fport->buf) { return PJ_ENOMEM; } fport->options = options; fport->readpos = fport->buf; for (index=file_count-1; index>=0; index--) { pjmedia_wave_hdr wavehdr; pj_ssize_t size_read; pj_off_t size_to_read; pj_memcpy(filename, file_list[index].ptr, file_list[index].slen); filename[file_list[index].slen] = '\0'; fport->current_file = index; fport->fsize_list[index] = pj_file_size(filename); if (fport->fsize_list[index] <= sizeof(pjmedia_wave_hdr)) { status = PJMEDIA_ENOTVALIDWAVE; goto on_error; } status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd_list[index]); if (status != PJ_SUCCESS) goto on_error; size_to_read = size_read = sizeof(wavehdr) - 8; status = pj_file_read( fport->fd_list[index], &wavehdr, &size_read); if (status != PJ_SUCCESS) { goto on_error; } if (size_read != size_to_read) { status = PJMEDIA_ENOTVALIDWAVE; goto on_error; } pjmedia_wave_hdr_file_to_host(&wavehdr); if (wavehdr.riff_hdr.riff != PJMEDIA_RIFF_TAG || wavehdr.riff_hdr.wave != PJMEDIA_WAVE_TAG || wavehdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG) { TRACE_((THIS_FILE, ""actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x"", wavehdr.riff_hdr.riff, PJMEDIA_RIFF_TAG, wavehdr.riff_hdr.wave, PJMEDIA_WAVE_TAG, wavehdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG)); status = PJMEDIA_ENOTVALIDWAVE; goto on_error; } if (wavehdr.fmt_hdr.fmt_tag != 1 || wavehdr.fmt_hdr.bits_per_sample != 16) { status = PJMEDIA_EWAVEUNSUPP; goto on_error; } if (wavehdr.fmt_hdr.block_align != wavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE) { status = PJMEDIA_EWAVEUNSUPP; goto on_error; } if (wavehdr.fmt_hdr.len > 16) { PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16, status = PJMEDIA_ENOTVALIDWAVE; goto on_error;); size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16; status = pj_file_setpos(fport->fd_list[index], size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } for (;;) { pjmedia_wave_subchunk subchunk; size_read = 8; status = pj_file_read(fport->fd_list[index], &subchunk, &size_read); if (status != PJ_SUCCESS || size_read != 8) { status = PJMEDIA_EWAVETOOSHORT; goto on_error; } PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk); if (subchunk.id == PJMEDIA_DATA_TAG) { wavehdr.data_hdr.data = PJMEDIA_DATA_TAG; wavehdr.data_hdr.len = subchunk.len; break; } PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, status = PJMEDIA_ENOTVALIDWAVE; goto on_error;); size_to_read = subchunk.len; status = pj_file_setpos(fport->fd_list[index], size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } status = pj_file_getpos(fport->fd_list[index], &pos); fport->start_data_list[index] = (unsigned)pos; fport->data_len_list[index] = wavehdr.data_hdr.len; fport->data_left_list[index] = wavehdr.data_hdr.len; if (wavehdr.data_hdr.len > fport->fsize_list[index] - fport->start_data_list[index]) { status = PJMEDIA_EWAVEUNSUPP; goto on_error; } if (wavehdr.data_hdr.len < ptime * wavehdr.fmt_hdr.sample_rate * wavehdr.fmt_hdr.nchan / 1000) { status = PJMEDIA_EWAVETOOSHORT; goto on_error; } if (!has_wave_info) { afd->channel_count = wavehdr.fmt_hdr.nchan; afd->clock_rate = wavehdr.fmt_hdr.sample_rate; afd->bits_per_sample = wavehdr.fmt_hdr.bits_per_sample; afd->frame_time_usec = ptime * 1000; afd->avg_bps = afd->max_bps = afd->clock_rate * afd->channel_count * afd->bits_per_sample; has_wave_info = PJ_TRUE; } else { if (wavehdr.fmt_hdr.nchan != afd->channel_count || wavehdr.fmt_hdr.sample_rate != afd->clock_rate || wavehdr.fmt_hdr.bits_per_sample != afd->bits_per_sample) { PJ_LOG(4,(THIS_FILE, ""WAV playlist error: file '%s' has differrent number"" "" of channels, sample rate, or bits per sample"", filename)); status = PJMEDIA_EWAVEUNSUPP; goto on_error; } } if (wavehdr.data_hdr.len < (unsigned)buff_size) buff_size = wavehdr.data_hdr.len; fport->bufsize = (pj_uint32_t)buff_size; fport->fpos_list[index] = fport->start_data_list[index]; } status = file_fill_buffer(fport); if (status != PJ_SUCCESS) { goto on_error; } *p_port = &fport->base; PJ_LOG(4,(THIS_FILE, ""WAV playlist '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB"", (int)port_label->slen, port_label->ptr, afd->clock_rate, afd->channel_count, fport->bufsize / 1000)); return PJ_SUCCESS; on_error: for (index=0; index<file_count; ++index) { if (fport->fd_list[index] != 0) pj_file_close(fport->fd_list[index]); } return status; }"
162,6070----CWE-285----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/acl.c----__ext4_set_acl,"__ext4_set_acl(handle_t *handle, struct inode *inode, int type, struct posix_acl *acl) { int name_index; void *value = NULL; size_t size = 0; int error; switch (type) { case ACL_TYPE_ACCESS: name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS; if (acl) { <S2SV_StartVul> error = posix_acl_equiv_mode(acl, &inode->i_mode); <S2SV_EndVul> <S2SV_StartVul> if (error < 0) <S2SV_EndVul> return error; <S2SV_StartVul> else { <S2SV_EndVul> <S2SV_StartVul> inode->i_ctime = ext4_current_time(inode); <S2SV_EndVul> <S2SV_StartVul> ext4_mark_inode_dirty(handle, inode); <S2SV_EndVul> <S2SV_StartVul> if (error == 0) <S2SV_EndVul> <S2SV_StartVul> acl = NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } break; case ACL_TYPE_DEFAULT: name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT; if (!S_ISDIR(inode->i_mode)) return acl ? -EACCES : 0; break; default: return -EINVAL; } if (acl) { value = ext4_acl_to_disk(acl, &size); if (IS_ERR(value)) return (int)PTR_ERR(value); } error = ext4_xattr_set_handle(handle, inode, name_index, """", value, size, 0); kfree(value); if (!error) set_cached_acl(inode, type, acl); return error; }","- error = posix_acl_equiv_mode(acl, &inode->i_mode);
- if (error < 0)
- else {
- inode->i_ctime = ext4_current_time(inode);
- ext4_mark_inode_dirty(handle, inode);
- if (error == 0)
- acl = NULL;
- }
+ error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ if (error)
+ inode->i_ctime = ext4_current_time(inode);
+ ext4_mark_inode_dirty(handle, inode);","__ext4_set_acl(handle_t *handle, struct inode *inode, int type, struct posix_acl *acl) { int name_index; void *value = NULL; size_t size = 0; int error; switch (type) { case ACL_TYPE_ACCESS: name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS; if (acl) { error = posix_acl_update_mode(inode, &inode->i_mode, &acl); if (error) return error; inode->i_ctime = ext4_current_time(inode); ext4_mark_inode_dirty(handle, inode); } break; case ACL_TYPE_DEFAULT: name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT; if (!S_ISDIR(inode->i_mode)) return acl ? -EACCES : 0; break; default: return -EINVAL; } if (acl) { value = ext4_acl_to_disk(acl, &size); if (IS_ERR(value)) return (int)PTR_ERR(value); } error = ext4_xattr_set_handle(handle, inode, name_index, """", value, size, 0); kfree(value); if (!error) set_cached_acl(inode, type, acl); return error; }"
163,7315----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/commonio.c----commonio_sort,"commonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *)) { struct commonio_entry **entries, *ptr; size_t n = 0, i; #if KEEP_NIS_AT_END struct commonio_entry *nis = NULL; #endif for (ptr = db->head; (NULL != ptr) #if KEEP_NIS_AT_END <S2SV_StartVul> && (NULL != ptr->line) <S2SV_EndVul> <S2SV_StartVul> && ( ('+' != ptr->line[0]) <S2SV_EndVul> <S2SV_StartVul> && ('-' != ptr->line[0])) <S2SV_EndVul> #endif ; ptr = ptr->next) { n++; } #if KEEP_NIS_AT_END <S2SV_StartVul> if ((NULL != ptr) && (NULL != ptr->line)) { <S2SV_EndVul> nis = ptr; } #endif if (n <= 1) { return 0; } entries = malloc (n * sizeof (struct commonio_entry *)); if (entries == NULL) { return -1; } n = 0; for (ptr = db->head; #if KEEP_NIS_AT_END nis != ptr; #else NULL != ptr; #endif ptr = ptr->next ) { entries[n] = ptr; n++; } qsort (entries, n, sizeof (struct commonio_entry *), cmp); db->head = entries[0]; n--; #if KEEP_NIS_AT_END if (NULL == nis) #endif { db->tail = entries[n]; } db->head->prev = NULL; db->head->next = entries[1]; entries[n]->prev = entries[n - 1]; #if KEEP_NIS_AT_END entries[n]->next = nis; #else entries[n]->next = NULL; #endif for (i = 1; i < n; i++) { entries[i]->prev = entries[i - 1]; entries[i]->next = entries[i + 1]; } free (entries); db->changed = true; return 0; }","- && (NULL != ptr->line)
- && ( ('+' != ptr->line[0])
- && ('-' != ptr->line[0]))
- if ((NULL != ptr) && (NULL != ptr->line)) {
+ && ((NULL == ptr->line)
+ || (('+' != ptr->line[0])
+ && ('-' != ptr->line[0])))
+ if (NULL != ptr) {","commonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *)) { struct commonio_entry **entries, *ptr; size_t n = 0, i; #if KEEP_NIS_AT_END struct commonio_entry *nis = NULL; #endif for (ptr = db->head; (NULL != ptr) #if KEEP_NIS_AT_END && ((NULL == ptr->line) || (('+' != ptr->line[0]) && ('-' != ptr->line[0]))) #endif ; ptr = ptr->next) { n++; } #if KEEP_NIS_AT_END if (NULL != ptr) { nis = ptr; } #endif if (n <= 1) { return 0; } entries = malloc (n * sizeof (struct commonio_entry *)); if (entries == NULL) { return -1; } n = 0; for (ptr = db->head; #if KEEP_NIS_AT_END nis != ptr; #else NULL != ptr; #endif ptr = ptr->next ) { entries[n] = ptr; n++; } qsort (entries, n, sizeof (struct commonio_entry *), cmp); db->head = entries[0]; n--; #if KEEP_NIS_AT_END if (NULL == nis) #endif { db->tail = entries[n]; } db->head->prev = NULL; db->head->next = entries[1]; entries[n]->prev = entries[n - 1]; #if KEEP_NIS_AT_END entries[n]->next = nis; #else entries[n]->next = NULL; #endif for (i = 1; i < n; i++) { entries[i]->prev = entries[i - 1]; entries[i]->next = entries[i + 1]; } free (entries); db->changed = true; return 0; }"
164,3773----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/unicode.cpp----WideToCharMap,"bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success) { if (wcschr(Src,(wchar)MappedStringMark)==NULL) return false; Success=true; uint SrcPos=0,DestPos=0; while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX) { if (uint(Src[SrcPos])==MappedStringMark) { SrcPos++; continue; } if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100) Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart); else { mbstate_t ps; memset(&ps,0,sizeof(ps)); <S2SV_StartVul> if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1) <S2SV_EndVul> { Dest[DestPos]='_'; Success=false; } SrcPos++; memset(&ps,0,sizeof(ps)); int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps); DestPos+=Max(Length,1); } } Dest[Min(DestPos,DestSize-1)]=0; return true; }","- if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)
+ if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==(size_t)-1)","bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success) { if (wcschr(Src,(wchar)MappedStringMark)==NULL) return false; Success=true; uint SrcPos=0,DestPos=0; while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX) { if (uint(Src[SrcPos])==MappedStringMark) { SrcPos++; continue; } if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100) Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart); else { mbstate_t ps; memset(&ps,0,sizeof(ps)); if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==(size_t)-1) { Dest[DestPos]='_'; Success=false; } SrcPos++; memset(&ps,0,sizeof(ps)); int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps); DestPos+=Max(Length,1); } } Dest[Min(DestPos,DestSize-1)]=0; return true; }"
165,543----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-0281--callbacks.c----do_local_notify,"do_local_notify(xmlNode * notify_src, const char *client_id, gboolean sync_reply, gboolean from_peer) { cib_client_t *client_obj = NULL; int local_rc = pcmk_ok; if (client_id != NULL) { client_obj = g_hash_table_lookup(client_list, client_id); } else { crm_trace(""No client to sent the response to. F_CIB_CLIENTID not set.""); } if (client_obj == NULL) { local_rc = -ECONNRESET; } else { int rid = 0; if(sync_reply) { <S2SV_StartVul> CRM_LOG_ASSERT(client_obj->request_id); <S2SV_EndVul> <S2SV_StartVul> rid = client_obj->request_id; <S2SV_EndVul> <S2SV_StartVul> client_obj->request_id = 0; <S2SV_EndVul> <S2SV_StartVul> crm_trace(""Sending response %d to %s %s"", <S2SV_EndVul> rid, client_obj->name, from_peer?""(originator of delegated request)"":""""); } else { crm_trace(""Sending an event to %s %s"", client_obj->name, from_peer?""(originator of delegated request)"":""""); } if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) { local_rc = -ENOMSG; #ifdef HAVE_GNUTLS_GNUTLS_H } else if (client_obj->session) { crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted); #endif } else if(client_obj->ipc == NULL) { crm_err(""Unknown transport for %s"", client_obj->name); } } if (local_rc != pcmk_ok && client_obj != NULL) { crm_warn(""%sSync reply to %s failed: %s"", sync_reply ? """" : ""A-"", client_obj ? client_obj->name : ""<unknown>"", pcmk_strerror(local_rc)); } }","- CRM_LOG_ASSERT(client_obj->request_id);
- rid = client_obj->request_id;
- client_obj->request_id = 0;
- crm_trace(""Sending response %d to %s %s"",
+ if (client_obj->ipc) {
+ CRM_LOG_ASSERT(client_obj->request_id);
+ rid = client_obj->request_id;
+ client_obj->request_id = 0;
+ crm_trace(""Sending response %d to %s %s"",
+ } else {
+ crm_trace(""Sending response to %s %s"",
+ client_obj->name, from_peer?""(originator of delegated request)"":"""");
+ }","do_local_notify(xmlNode * notify_src, const char *client_id, gboolean sync_reply, gboolean from_peer) { cib_client_t *client_obj = NULL; int local_rc = pcmk_ok; if (client_id != NULL) { client_obj = g_hash_table_lookup(client_list, client_id); } else { crm_trace(""No client to sent the response to. F_CIB_CLIENTID not set.""); } if (client_obj == NULL) { local_rc = -ECONNRESET; } else { int rid = 0; if(sync_reply) { if (client_obj->ipc) { CRM_LOG_ASSERT(client_obj->request_id); rid = client_obj->request_id; client_obj->request_id = 0; crm_trace(""Sending response %d to %s %s"", rid, client_obj->name, from_peer?""(originator of delegated request)"":""""); } else { crm_trace(""Sending response to %s %s"", client_obj->name, from_peer?""(originator of delegated request)"":""""); } } else { crm_trace(""Sending an event to %s %s"", client_obj->name, from_peer?""(originator of delegated request)"":""""); } if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) { local_rc = -ENOMSG; #ifdef HAVE_GNUTLS_GNUTLS_H } else if (client_obj->session) { crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted); #endif } else if(client_obj->ipc == NULL) { crm_err(""Unknown transport for %s"", client_obj->name); } } if (local_rc != pcmk_ok && client_obj != NULL) { crm_warn(""%sSync reply to %s failed: %s"", sync_reply ? """" : ""A-"", client_obj ? client_obj->name : ""<unknown>"", pcmk_strerror(local_rc)); } }"
166,5894----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/chmd.c----chmd_read_headers,"static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh, struct mschmd_header *chm, int entire) { unsigned int section, name_len, x, errors, num_chunks; unsigned char buf[0x54], *chunk = NULL, *name, *p, *end; struct mschmd_file *fi, *link = NULL; off_t offset, length; int num_entries; chm->files = NULL; chm->sysfiles = NULL; chm->chunk_cache = NULL; chm->sec0.base.chm = chm; chm->sec0.base.id = 0; chm->sec1.base.chm = chm; chm->sec1.base.id = 1; chm->sec1.content = NULL; chm->sec1.control = NULL; chm->sec1.spaninfo = NULL; chm->sec1.rtable = NULL; if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) { return MSPACK_ERR_READ; } if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) { return MSPACK_ERR_SIGNATURE; } if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) { D((""incorrect GUIDs"")) return MSPACK_ERR_SIGNATURE; } chm->version = EndGetI32(&buf[chmhead_Version]); chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]); chm->language = EndGetI32(&buf[chmhead_LanguageID]); if (chm->version > 3) { sys->message(fh, ""WARNING; CHM version > 3""); } if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&offset, &buf[chmhst_OffsetHS0], sys, fh) || read_off64(&chm->dir_offset, &buf[chmhst_OffsetHS1], sys, fh) || read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) { return MSPACK_ERR_READ; } chm->dir_offset = sys->tell(fh); chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]); chm->density = EndGetI32(&buf[chmhs1_Density]); chm->depth = EndGetI32(&buf[chmhs1_Depth]); chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]); chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]); chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]); chm->last_pmgl = EndGetI32(&buf[chmhs1_LastPMGL]); if (chm->version < 3) { chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks); } if (chm->sec0.offset > chm->length) { D((""content section begins after file has ended"")) return MSPACK_ERR_DATAFORMAT; } if (chm->chunk_size < (pmgl_Entries + 2)) { D((""chunk size not large enough"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks == 0) { D((""no chunks"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks > 100000) { D((""more than 100,000 chunks"")) return MSPACK_ERR_DATAFORMAT; } if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) { D((""chunks larger than entire file"")) return MSPACK_ERR_DATAFORMAT; } if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) { sys->message(fh, ""WARNING; chunk size is not a power of two""); } if (chm->first_pmgl != 0) { sys->message(fh, ""WARNING; first PMGL chunk is not zero""); } if (chm->first_pmgl > chm->last_pmgl) { D((""first pmgl chunk is after last pmgl chunk"")) return MSPACK_ERR_DATAFORMAT; } if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) { D((""index_root outside valid range"")) return MSPACK_ERR_DATAFORMAT; } if (!entire) { return MSPACK_ERR_OK; } if ((x = chm->first_pmgl) != 0) { if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) { return MSPACK_ERR_SEEK; } } num_chunks = chm->last_pmgl - x + 1; if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) { return MSPACK_ERR_NOMEMORY; } errors = 0; while (num_chunks--) { if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) { sys->free(chunk); return MSPACK_ERR_READ; } if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue; if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) { sys->message(fh, ""WARNING; PMGL quickref area is too small""); } if (EndGetI32(&chunk[pmgl_QuickRefSize]) > ((int)chm->chunk_size - pmgl_Entries)) { sys->message(fh, ""WARNING; PMGL quickref area is too large""); } p = &chunk[pmgl_Entries]; end = &chunk[chm->chunk_size - 2]; num_entries = EndGetI16(end); while (num_entries--) { READ_ENCINT(name_len); if (name_len > (unsigned int) (end - p)) goto chunk_end; <S2SV_StartVul> if (name_len == 0) goto chunk_end; <S2SV_EndVul> name = p; p += name_len; READ_ENCINT(section); READ_ENCINT(offset); READ_ENCINT(length); if ((offset == 0) && (length == 0)) { if ((name_len > 0) && (name[name_len-1] == '/')) continue; } if (section > 1) { sys->message(fh, ""invalid section number '%u'."", section); continue; } if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) { sys->free(chunk); return MSPACK_ERR_NOMEMORY; } fi->next = NULL; fi->filename = (char *) &fi[1]; fi->section = ((section == 0) ? (struct mschmd_section *) (&chm->sec0) : (struct mschmd_section *) (&chm->sec1)); fi->offset = offset; fi->length = length; sys->copy(name, fi->filename, (size_t) name_len); fi->filename[name_len] = '\0'; if (name[0] == ':' && name[1] == ':') { if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) { if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) { chm->sec1.content = fi; } else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) { chm->sec1.control = fi; } else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) { chm->sec1.spaninfo = fi; } else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) { chm->sec1.rtable = fi; } } fi->next = chm->sysfiles; chm->sysfiles = fi; } else { if (link) link->next = fi; else chm->files = fi; link = fi; } } chunk_end: if (num_entries >= 0) { D((""chunk ended before all entries could be read"")) errors++; } } sys->free(chunk); return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK; }","- if (name_len == 0) goto chunk_end;
+ if (name_len < 2 || !name[0] || !name[1]) continue;","static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh, struct mschmd_header *chm, int entire) { unsigned int section, name_len, x, errors, num_chunks; unsigned char buf[0x54], *chunk = NULL, *name, *p, *end; struct mschmd_file *fi, *link = NULL; off_t offset, length; int num_entries; chm->files = NULL; chm->sysfiles = NULL; chm->chunk_cache = NULL; chm->sec0.base.chm = chm; chm->sec0.base.id = 0; chm->sec1.base.chm = chm; chm->sec1.base.id = 1; chm->sec1.content = NULL; chm->sec1.control = NULL; chm->sec1.spaninfo = NULL; chm->sec1.rtable = NULL; if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) { return MSPACK_ERR_READ; } if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) { return MSPACK_ERR_SIGNATURE; } if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) { D((""incorrect GUIDs"")) return MSPACK_ERR_SIGNATURE; } chm->version = EndGetI32(&buf[chmhead_Version]); chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]); chm->language = EndGetI32(&buf[chmhead_LanguageID]); if (chm->version > 3) { sys->message(fh, ""WARNING; CHM version > 3""); } if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&offset, &buf[chmhst_OffsetHS0], sys, fh) || read_off64(&chm->dir_offset, &buf[chmhst_OffsetHS1], sys, fh) || read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) { return MSPACK_ERR_READ; } chm->dir_offset = sys->tell(fh); chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]); chm->density = EndGetI32(&buf[chmhs1_Density]); chm->depth = EndGetI32(&buf[chmhs1_Depth]); chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]); chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]); chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]); chm->last_pmgl = EndGetI32(&buf[chmhs1_LastPMGL]); if (chm->version < 3) { chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks); } if (chm->sec0.offset > chm->length) { D((""content section begins after file has ended"")) return MSPACK_ERR_DATAFORMAT; } if (chm->chunk_size < (pmgl_Entries + 2)) { D((""chunk size not large enough"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks == 0) { D((""no chunks"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks > 100000) { D((""more than 100,000 chunks"")) return MSPACK_ERR_DATAFORMAT; } if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) { D((""chunks larger than entire file"")) return MSPACK_ERR_DATAFORMAT; } if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) { sys->message(fh, ""WARNING; chunk size is not a power of two""); } if (chm->first_pmgl != 0) { sys->message(fh, ""WARNING; first PMGL chunk is not zero""); } if (chm->first_pmgl > chm->last_pmgl) { D((""first pmgl chunk is after last pmgl chunk"")) return MSPACK_ERR_DATAFORMAT; } if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) { D((""index_root outside valid range"")) return MSPACK_ERR_DATAFORMAT; } if (!entire) { return MSPACK_ERR_OK; } if ((x = chm->first_pmgl) != 0) { if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) { return MSPACK_ERR_SEEK; } } num_chunks = chm->last_pmgl - x + 1; if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) { return MSPACK_ERR_NOMEMORY; } errors = 0; while (num_chunks--) { if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) { sys->free(chunk); return MSPACK_ERR_READ; } if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue; if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) { sys->message(fh, ""WARNING; PMGL quickref area is too small""); } if (EndGetI32(&chunk[pmgl_QuickRefSize]) > ((int)chm->chunk_size - pmgl_Entries)) { sys->message(fh, ""WARNING; PMGL quickref area is too large""); } p = &chunk[pmgl_Entries]; end = &chunk[chm->chunk_size - 2]; num_entries = EndGetI16(end); while (num_entries--) { READ_ENCINT(name_len); if (name_len > (unsigned int) (end - p)) goto chunk_end; name = p; p += name_len; READ_ENCINT(section); READ_ENCINT(offset); READ_ENCINT(length); if (name_len < 2 || !name[0] || !name[1]) continue; if ((offset == 0) && (length == 0)) { if ((name_len > 0) && (name[name_len-1] == '/')) continue; } if (section > 1) { sys->message(fh, ""invalid section number '%u'."", section); continue; } if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) { sys->free(chunk); return MSPACK_ERR_NOMEMORY; } fi->next = NULL; fi->filename = (char *) &fi[1]; fi->section = ((section == 0) ? (struct mschmd_section *) (&chm->sec0) : (struct mschmd_section *) (&chm->sec1)); fi->offset = offset; fi->length = length; sys->copy(name, fi->filename, (size_t) name_len); fi->filename[name_len] = '\0'; if (name[0] == ':' && name[1] == ':') { if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) { if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) { chm->sec1.content = fi; } else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) { chm->sec1.control = fi; } else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) { chm->sec1.spaninfo = fi; } else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) { chm->sec1.rtable = fi; } } fi->next = chm->sysfiles; chm->sysfiles = fi; } else { if (link) link->next = fi; else chm->files = fi; link = fi; } } chunk_end: if (num_entries >= 0) { D((""chunk ended before all entries could be read"")) errors++; } } sys->free(chunk); return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK; }"
167,253----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-3552--ipv4.c----*dccp_v4_request_recv_sock,"struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst) { struct inet_request_sock *ireq; struct inet_sock *newinet; struct sock *newsk; if (sk_acceptq_is_full(sk)) goto exit_overflow; if (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL) goto exit; newsk = dccp_create_openreq_child(sk, req, skb); if (newsk == NULL) goto exit_nonewsk; sk_setup_caps(newsk, dst); newinet = inet_sk(newsk); ireq = inet_rsk(req); newinet->inet_daddr = ireq->rmt_addr; newinet->inet_rcv_saddr = ireq->loc_addr; newinet->inet_saddr = ireq->loc_addr; <S2SV_StartVul> newinet->opt = ireq->opt; <S2SV_EndVul> ireq->opt = NULL; newinet->mc_index = inet_iif(skb); newinet->mc_ttl = ip_hdr(skb)->ttl; newinet->inet_id = jiffies; dccp_sync_mss(newsk, dst_mtu(dst)); if (__inet_inherit_port(sk, newsk) < 0) { sock_put(newsk); goto exit; } __inet_hash_nolisten(newsk, NULL); return newsk; exit_overflow: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS); exit_nonewsk: dst_release(dst); exit: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS); return NULL; }","- newinet->opt = ireq->opt;
+ newinet->inet_opt = ireq->opt;","struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst) { struct inet_request_sock *ireq; struct inet_sock *newinet; struct sock *newsk; if (sk_acceptq_is_full(sk)) goto exit_overflow; if (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL) goto exit; newsk = dccp_create_openreq_child(sk, req, skb); if (newsk == NULL) goto exit_nonewsk; sk_setup_caps(newsk, dst); newinet = inet_sk(newsk); ireq = inet_rsk(req); newinet->inet_daddr = ireq->rmt_addr; newinet->inet_rcv_saddr = ireq->loc_addr; newinet->inet_saddr = ireq->loc_addr; newinet->inet_opt = ireq->opt; ireq->opt = NULL; newinet->mc_index = inet_iif(skb); newinet->mc_ttl = ip_hdr(skb)->ttl; newinet->inet_id = jiffies; dccp_sync_mss(newsk, dst_mtu(dst)); if (__inet_inherit_port(sk, newsk) < 0) { sock_put(newsk); goto exit; } __inet_hash_nolisten(newsk, NULL); return newsk; exit_overflow: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS); exit_nonewsk: dst_release(dst); exit: NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS); return NULL; }"
168,577----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2119--macvtap.c----zerocopy_sg_from_iovec,"static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from, int offset, size_t count) { int len = iov_length(from, count) - offset; int copy = skb_headlen(skb); int size, offset1 = 0; int i = 0; while (count && (offset >= from->iov_len)) { offset -= from->iov_len; ++from; --count; } while (count && (copy > 0)) { size = min_t(unsigned int, copy, from->iov_len - offset); if (copy_from_user(skb->data + offset1, from->iov_base + offset, size)) return -EFAULT; if (copy > size) { ++from; --count; offset = 0; } else offset += size; copy -= size; offset1 += size; } if (len == offset1) return 0; while (count--) { struct page *page[MAX_SKB_FRAGS]; int num_pages; unsigned long base; unsigned long truesize; len = from->iov_len - offset; if (!len) { offset = 0; ++from; continue; } base = (unsigned long)from->iov_base + offset; size = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT; num_pages = get_user_pages_fast(base, size, 0, &page[i]); <S2SV_StartVul> if ((num_pages != size) || <S2SV_EndVul> <S2SV_StartVul> (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) { <S2SV_EndVul> for (i = 0; i < num_pages; i++) put_page(page[i]); return -EFAULT; } truesize = size * PAGE_SIZE; skb->data_len += len; skb->len += len; skb->truesize += truesize; atomic_add(truesize, &skb->sk->sk_wmem_alloc); while (len) { int off = base & ~PAGE_MASK; int size = min_t(int, len, PAGE_SIZE - off); __skb_fill_page_desc(skb, i, page[i], off, size); skb_shinfo(skb)->nr_frags++; base += size; len -= size; i++; } offset = 0; ++from; } return 0; }","- if ((num_pages != size) ||
- (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {
+ if (i + size > MAX_SKB_FRAGS)
+ return -EMSGSIZE;
+ if (num_pages != size) {","static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from, int offset, size_t count) { int len = iov_length(from, count) - offset; int copy = skb_headlen(skb); int size, offset1 = 0; int i = 0; while (count && (offset >= from->iov_len)) { offset -= from->iov_len; ++from; --count; } while (count && (copy > 0)) { size = min_t(unsigned int, copy, from->iov_len - offset); if (copy_from_user(skb->data + offset1, from->iov_base + offset, size)) return -EFAULT; if (copy > size) { ++from; --count; offset = 0; } else offset += size; copy -= size; offset1 += size; } if (len == offset1) return 0; while (count--) { struct page *page[MAX_SKB_FRAGS]; int num_pages; unsigned long base; unsigned long truesize; len = from->iov_len - offset; if (!len) { offset = 0; ++from; continue; } base = (unsigned long)from->iov_base + offset; size = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT; if (i + size > MAX_SKB_FRAGS) return -EMSGSIZE; num_pages = get_user_pages_fast(base, size, 0, &page[i]); if (num_pages != size) { for (i = 0; i < num_pages; i++) put_page(page[i]); return -EFAULT; } truesize = size * PAGE_SIZE; skb->data_len += len; skb->len += len; skb->truesize += truesize; atomic_add(truesize, &skb->sk->sk_wmem_alloc); while (len) { int off = base & ~PAGE_MASK; int size = min_t(int, len, PAGE_SIZE - off); __skb_fill_page_desc(skb, i, page[i], off, size); skb_shinfo(skb)->nr_frags++; base += size; len -= size; i++; } offset = 0; ++from; } return 0; }"
169,643----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-4502--util.c----initiate_stratum,"bool initiate_stratum(struct pool *pool) { bool ret = false, recvd = false, noresume = false, sockd = false; char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid; json_t *val = NULL, *res_val, *err_val; json_error_t err; int n2size; resend: if (!setup_stratum_socket(pool)) { sockd = false; goto out; } sockd = true; if (recvd) { clear_sock(pool); sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++); } else { if (pool->sessionid) sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid); else sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++); } if (__stratum_send(pool, s, strlen(s)) != SEND_OK) { applog(LOG_DEBUG, ""Failed to send s in initiate_stratum""); goto out; } if (!socket_full(pool, DEFAULT_SOCKWAIT)) { applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum""); goto out; } sret = recv_line(pool); if (!sret) goto out; recvd = true; val = JSON_LOADS(sret, &err); free(sret); if (!val) { applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text); goto out; } res_val = json_object_get(val, ""result""); err_val = json_object_get(val, ""error""); if (!res_val || json_is_null(res_val) || (err_val && !json_is_null(err_val))) { char *ss; if (err_val) ss = json_dumps(err_val, JSON_INDENT(3)); else ss = strdup(""(unknown reason)""); applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss); free(ss); goto out; } sessionid = get_sessionid(res_val); if (!sessionid) applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum""); nonce1 = json_array_string(res_val, 1); <S2SV_StartVul> if (!nonce1) { <S2SV_EndVul> <S2SV_StartVul> applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum""); <S2SV_EndVul> free(sessionid); goto out; } n2size = json_integer_value(json_array_get(res_val, 2)); <S2SV_StartVul> if (!n2size) { <S2SV_EndVul> <S2SV_StartVul> applog(LOG_INFO, ""Failed to get n2size in initiate_stratum""); <S2SV_EndVul> free(sessionid); free(nonce1); goto out; } cg_wlock(&pool->data_lock); pool->sessionid = sessionid; pool->nonce1 = nonce1; pool->n1_len = strlen(nonce1) / 2; free(pool->nonce1bin); pool->nonce1bin = calloc(pool->n1_len, 1); if (unlikely(!pool->nonce1bin)) quithere(1, ""Failed to calloc pool->nonce1bin""); hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len); pool->n2size = n2size; cg_wunlock(&pool->data_lock); if (sessionid) applog(LOG_DEBUG, ""Pool %d stratum session id: %s"", pool->pool_no, pool->sessionid); ret = true; out: if (ret) { if (!pool->stratum_url) pool->stratum_url = pool->sockaddr_url; pool->stratum_active = true; pool->sdiff = 1; if (opt_protocol) { applog(LOG_DEBUG, ""Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d"", pool->pool_no, pool->nonce1, pool->n2size); } } else { if (recvd && !noresume) { cg_wlock(&pool->data_lock); free(pool->sessionid); free(pool->nonce1); pool->sessionid = pool->nonce1 = NULL; cg_wunlock(&pool->data_lock); applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh""); noresume = true; json_decref(val); goto resend; } applog(LOG_DEBUG, ""Initiate stratum failed""); if (sockd) suspend_stratum(pool); } json_decref(val); return ret; }","- if (!nonce1) {
- applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum"");
- if (!n2size) {
- applog(LOG_INFO, ""Failed to get n2size in initiate_stratum"");
+ if (!valid_hex(nonce1)) {
+ applog(LOG_INFO, ""Failed to get valid nonce1 in initiate_stratum"");
+ if (n2size < 2 || n2size > 16) {
+ applog(LOG_INFO, ""Failed to get valid n2size in initiate_stratum"");","bool initiate_stratum(struct pool *pool) { bool ret = false, recvd = false, noresume = false, sockd = false; char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid; json_t *val = NULL, *res_val, *err_val; json_error_t err; int n2size; resend: if (!setup_stratum_socket(pool)) { sockd = false; goto out; } sockd = true; if (recvd) { clear_sock(pool); sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++); } else { if (pool->sessionid) sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid); else sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++); } if (__stratum_send(pool, s, strlen(s)) != SEND_OK) { applog(LOG_DEBUG, ""Failed to send s in initiate_stratum""); goto out; } if (!socket_full(pool, DEFAULT_SOCKWAIT)) { applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum""); goto out; } sret = recv_line(pool); if (!sret) goto out; recvd = true; val = JSON_LOADS(sret, &err); free(sret); if (!val) { applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text); goto out; } res_val = json_object_get(val, ""result""); err_val = json_object_get(val, ""error""); if (!res_val || json_is_null(res_val) || (err_val && !json_is_null(err_val))) { char *ss; if (err_val) ss = json_dumps(err_val, JSON_INDENT(3)); else ss = strdup(""(unknown reason)""); applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss); free(ss); goto out; } sessionid = get_sessionid(res_val); if (!sessionid) applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum""); nonce1 = json_array_string(res_val, 1); if (!valid_hex(nonce1)) { applog(LOG_INFO, ""Failed to get valid nonce1 in initiate_stratum""); free(sessionid); goto out; } n2size = json_integer_value(json_array_get(res_val, 2)); if (n2size < 2 || n2size > 16) { applog(LOG_INFO, ""Failed to get valid n2size in initiate_stratum""); free(sessionid); free(nonce1); goto out; } cg_wlock(&pool->data_lock); pool->sessionid = sessionid; pool->nonce1 = nonce1; pool->n1_len = strlen(nonce1) / 2; free(pool->nonce1bin); pool->nonce1bin = calloc(pool->n1_len, 1); if (unlikely(!pool->nonce1bin)) quithere(1, ""Failed to calloc pool->nonce1bin""); hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len); pool->n2size = n2size; cg_wunlock(&pool->data_lock); if (sessionid) applog(LOG_DEBUG, ""Pool %d stratum session id: %s"", pool->pool_no, pool->sessionid); ret = true; out: if (ret) { if (!pool->stratum_url) pool->stratum_url = pool->sockaddr_url; pool->stratum_active = true; pool->sdiff = 1; if (opt_protocol) { applog(LOG_DEBUG, ""Pool %d confirmed mining.subscribe with extranonce1 %s extran2size %d"", pool->pool_no, pool->nonce1, pool->n2size); } } else { if (recvd && !noresume) { cg_wlock(&pool->data_lock); free(pool->sessionid); free(pool->nonce1); pool->sessionid = pool->nonce1 = NULL; cg_wunlock(&pool->data_lock); applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh""); noresume = true; json_decref(val); goto resend; } applog(LOG_DEBUG, ""Initiate stratum failed""); if (sockd) suspend_stratum(pool); } json_decref(val); return ret; }"
170,5110----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/acsequentialscan.hpp----ACSequentialScan::QMContextSet::DCContextMagnitudeSet::Init,"void Init(void) { <S2SV_StartVul> for(int i = 0;i < 19;i++) { <S2SV_EndVul> #ifdef DEBUG_QMCODER char string[5] = ""X0 ""; string[1] = (i / 10) + '0'; string[2] = (i % 10) + '0'; X[i].Init(string); string[0] = 'M'; M[i].Init(string); #else X[i].Init(); M[i].Init(); #endif } }","- for(int i = 0;i < 19;i++) {
+ for(int i = 0;i < MagnitudeContexts;i++) {","void Init(void) { for(int i = 0;i < MagnitudeContexts;i++) { #ifdef DEBUG_QMCODER char string[5] = ""X0 ""; string[1] = (i / 10) + '0'; string[2] = (i % 10) + '0'; X[i].Init(string); string[0] = 'M'; M[i].Init(string); #else X[i].Init(); M[i].Init(); #endif } }"
171,7234----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/src_parser.c----src_parser_trans_stage_1_2_3,"static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg) { struct parser_buf pbuf = { .f_indx = 0, .tmp_indx = 0, .f_read_size = 0 }; int write_count = 0; int src_fd; int p_state = P_STATE_CODE; src_fd = open(src, O_RDONLY); if (src_fd == -1) { fprintf(stderr, ""**Error: Could not open source file: %s.\n"", src); return -1; } while (p_buf_refill(&pbuf, src_fd) > 0) { while (PBUF_F_REMD(pbuf)) { switch (p_state) { case P_STATE_COMMENT_C: switch (PBUF_F_CHAR(pbuf)) { case '*': p_buf_push_tmp_char(&pbuf, '*'); continue; case '/': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) { pbuf.tmp_indx--; p_state = P_STATE_CODE; } break; default: if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) pbuf.tmp_indx--; break; } pbuf.f_indx++; case P_STATE_CODE: default: switch (PBUF_F_CHAR(pbuf)) { case ' ': case '\t': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' || PBUF_TMP_PREV_CHAR(pbuf) == '\n')) pbuf.f_indx++; else p_buf_push_tmp_char(&pbuf, ' '); continue; case '\r': case '\n': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' || PBUF_TMP_PREV_CHAR(pbuf) == '\n')) { pbuf.f_indx++; <S2SV_StartVul> } else if (pbuf.tmp_indx && <S2SV_EndVul> (PBUF_TMP_PREV_CHAR(pbuf) == '\\')) { pbuf.tmp_indx--; pbuf.f_indx++; } else { p_buf_push_tmp_char(&pbuf, '\n'); } continue; case '\\': p_buf_push_tmp_char(&pbuf, '\\'); continue; case '/': p_buf_push_tmp_char(&pbuf, '/'); continue; case '*': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '/')) { pbuf.tmp_indx--; pbuf.f_indx++; p_state = P_STATE_COMMENT_C; continue; } default: break; } p_buf_write_tmp(&pbuf, tmp_fd); p_buf_write_f_char(&pbuf, tmp_fd); } } } p_buf_write_tmp(&pbuf, tmp_fd); return 0; }","- } else if (pbuf.tmp_indx &&
+ } else if (pbuf.tmp_indx &&
+ p_buf_write_tmp(&pbuf, tmp_fd);
+ p_buf_write_tmp(&pbuf, tmp_fd);","static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg) { struct parser_buf pbuf = { .f_indx = 0, .tmp_indx = 0, .f_read_size = 0 }; int write_count = 0; int src_fd; int p_state = P_STATE_CODE; src_fd = open(src, O_RDONLY); if (src_fd == -1) { fprintf(stderr, ""**Error: Could not open source file: %s.\n"", src); return -1; } while (p_buf_refill(&pbuf, src_fd) > 0) { while (PBUF_F_REMD(pbuf)) { switch (p_state) { case P_STATE_COMMENT_C: switch (PBUF_F_CHAR(pbuf)) { case '*': p_buf_push_tmp_char(&pbuf, '*'); continue; case '/': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) { pbuf.tmp_indx--; p_state = P_STATE_CODE; } break; default: if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) pbuf.tmp_indx--; break; } pbuf.f_indx++; case P_STATE_CODE: default: switch (PBUF_F_CHAR(pbuf)) { case ' ': case '\t': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' || PBUF_TMP_PREV_CHAR(pbuf) == '\n')) pbuf.f_indx++; else p_buf_push_tmp_char(&pbuf, ' '); continue; case '\r': case '\n': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' || PBUF_TMP_PREV_CHAR(pbuf) == '\n')) { pbuf.f_indx++; } else if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '\\')) { pbuf.tmp_indx--; pbuf.f_indx++; } else { p_buf_push_tmp_char(&pbuf, '\n'); } continue; case '\\': p_buf_write_tmp(&pbuf, tmp_fd); p_buf_push_tmp_char(&pbuf, '\\'); continue; case '/': p_buf_write_tmp(&pbuf, tmp_fd); p_buf_push_tmp_char(&pbuf, '/'); continue; case '*': if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '/')) { pbuf.tmp_indx--; pbuf.f_indx++; p_state = P_STATE_COMMENT_C; continue; } default: break; } p_buf_write_tmp(&pbuf, tmp_fd); p_buf_write_f_char(&pbuf, tmp_fd); } } } p_buf_write_tmp(&pbuf, tmp_fd); return 0; }"
172,1075----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-3070--migrate.c----migrate_page_copy,"void migrate_page_copy(struct page *newpage, struct page *page) { int cpupid; if (PageHuge(page) || PageTransHuge(page)) copy_huge_page(newpage, page); else copy_highpage(newpage, page); if (PageError(page)) SetPageError(newpage); if (PageReferenced(page)) SetPageReferenced(newpage); if (PageUptodate(page)) SetPageUptodate(newpage); if (TestClearPageActive(page)) { VM_BUG_ON_PAGE(PageUnevictable(page), page); SetPageActive(newpage); } else if (TestClearPageUnevictable(page)) SetPageUnevictable(newpage); if (PageChecked(page)) SetPageChecked(newpage); if (PageMappedToDisk(page)) SetPageMappedToDisk(newpage); <S2SV_StartVul> if (PageDirty(page)) { <S2SV_EndVul> <S2SV_StartVul> clear_page_dirty_for_io(page); <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> if (PageSwapBacked(page)) <S2SV_EndVul> <S2SV_StartVul> SetPageDirty(newpage); <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> __set_page_dirty_nobuffers(newpage); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (page_is_young(page)) set_page_young(newpage); if (page_is_idle(page)) set_page_idle(newpage); cpupid = page_cpupid_xchg_last(page, -1); page_cpupid_xchg_last(newpage, cpupid); ksm_migrate_page(newpage, page); if (PageSwapCache(page)) ClearPageSwapCache(page); ClearPagePrivate(page); set_page_private(page, 0); if (PageWriteback(newpage)) end_page_writeback(newpage); }","- if (PageDirty(page)) {
- clear_page_dirty_for_io(page);
- if (PageSwapBacked(page))
- SetPageDirty(newpage);
- else
- __set_page_dirty_nobuffers(newpage);
- }
+ if (PageDirty(page))
+ SetPageDirty(newpage);","void migrate_page_copy(struct page *newpage, struct page *page) { int cpupid; if (PageHuge(page) || PageTransHuge(page)) copy_huge_page(newpage, page); else copy_highpage(newpage, page); if (PageError(page)) SetPageError(newpage); if (PageReferenced(page)) SetPageReferenced(newpage); if (PageUptodate(page)) SetPageUptodate(newpage); if (TestClearPageActive(page)) { VM_BUG_ON_PAGE(PageUnevictable(page), page); SetPageActive(newpage); } else if (TestClearPageUnevictable(page)) SetPageUnevictable(newpage); if (PageChecked(page)) SetPageChecked(newpage); if (PageMappedToDisk(page)) SetPageMappedToDisk(newpage); if (PageDirty(page)) SetPageDirty(newpage); if (page_is_young(page)) set_page_young(newpage); if (page_is_idle(page)) set_page_idle(newpage); cpupid = page_cpupid_xchg_last(page, -1); page_cpupid_xchg_last(newpage, cpupid); ksm_migrate_page(newpage, page); if (PageSwapCache(page)) ClearPageSwapCache(page); ClearPagePrivate(page); set_page_private(page, 0); if (PageWriteback(newpage)) end_page_writeback(newpage); }"
173,3338----CWE-131----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ragged_tensor_to_tensor_op.cc----tensorflow::RaggedTensorToTensorBaseOp::CalculateOutputIndex,"Status CalculateOutputIndex(OpKernelContext* context, int dimension, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { const RowPartitionTensor row_partition_tensor = GetRowPartitionTensor(context, dimension); auto partition_type = GetRowPartitionTypeByDimension(dimension); switch (partition_type) { case RowPartitionType::VALUE_ROWIDS: <S2SV_StartVul> CalculateOutputIndexValueRowID( <S2SV_EndVul> <S2SV_StartVul> context, row_partition_tensor, parent_output_index, <S2SV_EndVul> <S2SV_StartVul> output_index_multiplier, output_size, result); <S2SV_EndVul> <S2SV_StartVul> return tensorflow::Status::OK(); <S2SV_EndVul> case RowPartitionType::ROW_SPLITS: if (row_partition_tensor.size() - 1 > parent_output_index.size()) { return errors::InvalidArgument( ""Row partition size is greater than output size: "", row_partition_tensor.size() - 1, "" > "", parent_output_index.size()); } <S2SV_StartVul> CalculateOutputIndexRowSplit( <S2SV_EndVul> <S2SV_StartVul> context, row_partition_tensor, parent_output_index, <S2SV_EndVul> <S2SV_StartVul> output_index_multiplier, output_size, result); <S2SV_EndVul> <S2SV_StartVul> return tensorflow::Status::OK(); <S2SV_EndVul> default: return errors::InvalidArgument( ""Unsupported partition type:"", RowPartitionTypeToString(partition_type)); } }","- CalculateOutputIndexValueRowID(
- context, row_partition_tensor, parent_output_index,
- output_index_multiplier, output_size, result);
- return tensorflow::Status::OK();
- CalculateOutputIndexRowSplit(
- context, row_partition_tensor, parent_output_index,
- output_index_multiplier, output_size, result);
- return tensorflow::Status::OK();
+ return CalculateOutputIndexValueRowID(
+ row_partition_tensor, parent_output_index, output_index_multiplier,
+ output_size, result);
+ return CalculateOutputIndexRowSplit(
+ row_partition_tensor, parent_output_index, output_index_multiplier,
+ output_size, result);","Status CalculateOutputIndex(OpKernelContext* context, int dimension, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { const RowPartitionTensor row_partition_tensor = GetRowPartitionTensor(context, dimension); auto partition_type = GetRowPartitionTypeByDimension(dimension); switch (partition_type) { case RowPartitionType::VALUE_ROWIDS: return CalculateOutputIndexValueRowID( row_partition_tensor, parent_output_index, output_index_multiplier, output_size, result); case RowPartitionType::ROW_SPLITS: if (row_partition_tensor.size() - 1 > parent_output_index.size()) { return errors::InvalidArgument( ""Row partition size is greater than output size: "", row_partition_tensor.size() - 1, "" > "", parent_output_index.size()); } return CalculateOutputIndexRowSplit( row_partition_tensor, parent_output_index, output_index_multiplier, output_size, result); default: return errors::InvalidArgument( ""Unsupported partition type:"", RowPartitionTypeToString(partition_type)); } }"
174,432--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4265--mem.c----av_reallocp_array,"int av_reallocp_array(void *ptr, size_t nmemb, size_t size) { void **ptrptr = ptr; *ptrptr = av_realloc_f(*ptrptr, nmemb, size); <S2SV_StartVul> if (!*ptrptr && !(nmemb && size)) <S2SV_EndVul> return AVERROR(ENOMEM); return 0; }","- if (!*ptrptr && !(nmemb && size))
+ if (!*ptrptr && nmemb && size)","int av_reallocp_array(void *ptr, size_t nmemb, size_t size) { void **ptrptr = ptr; *ptrptr = av_realloc_f(*ptrptr, nmemb, size); if (!*ptrptr && nmemb && size) return AVERROR(ENOMEM); return 0; }"
175,3312----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/unaligned_64.c----handle_popc,"int handle_popc(u32 insn, struct pt_regs *regs) { u64 value; int ret, i, rd = ((insn >> 25) & 0x1f); int from_kernel = (regs->tstate & TSTATE_PRIV) != 0; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0); <S2SV_EndVul> if (insn & 0x2000) { maybe_flush_windows(0, 0, rd, from_kernel); value = sign_extend_imm13(insn); } else { maybe_flush_windows(0, insn & 0x1f, rd, from_kernel); value = fetch_reg(insn & 0x1f, regs); } for (ret = 0, i = 0; i < 16; i++) { ret += popc_helper[value & 0xf]; value >>= 4; } if (rd < 16) { if (rd) regs->u_regs[rd] = ret; } else { if (test_thread_flag(TIF_32BIT)) { struct reg_window32 __user *win32; win32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP])); put_user(ret, &win32->locals[rd - 16]); } else { struct reg_window __user *win; win = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS); put_user(ret, &win->locals[rd - 16]); } } advance(regs); return 1; }","- perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);
+ perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);","int handle_popc(u32 insn, struct pt_regs *regs) { u64 value; int ret, i, rd = ((insn >> 25) & 0x1f); int from_kernel = (regs->tstate & TSTATE_PRIV) != 0; perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0); if (insn & 0x2000) { maybe_flush_windows(0, 0, rd, from_kernel); value = sign_extend_imm13(insn); } else { maybe_flush_windows(0, insn & 0x1f, rd, from_kernel); value = fetch_reg(insn & 0x1f, regs); } for (ret = 0, i = 0; i < 16; i++) { ret += popc_helper[value & 0xf]; value >>= 4; } if (rd < 16) { if (rd) regs->u_regs[rd] = ret; } else { if (test_thread_flag(TIF_32BIT)) { struct reg_window32 __user *win32; win32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP])); put_user(ret, &win32->locals[rd - 16]); } else { struct reg_window __user *win; win = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS); put_user(ret, &win->locals[rd - 16]); } } advance(regs); return 1; }"
176,2697----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dnxhddec.c----dnxhd_decode_header,"static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame, const uint8_t *buf, int buf_size, int first_field) { int i, cid, ret; int old_bit_depth = ctx->bit_depth, bitdepth; uint64_t header_prefix; if (buf_size < 0x280) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < 640).\n"", buf_size); return AVERROR_INVALIDDATA; } header_prefix = ff_dnxhd_parse_header_prefix(buf); if (header_prefix == 0) { av_log(ctx->avctx, AV_LOG_ERROR, ""unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"", buf[0], buf[1], buf[2], buf[3], buf[4]); return AVERROR_INVALIDDATA; } if (buf[5] & 2) { ctx->cur_field = buf[5] & 1; frame->interlaced_frame = 1; frame->top_field_first = first_field ^ ctx->cur_field; av_log(ctx->avctx, AV_LOG_DEBUG, ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field); } else { ctx->cur_field = 0; } ctx->mbaff = (buf[0x6] >> 5) & 1; ctx->height = AV_RB16(buf + 0x18); ctx->width = AV_RB16(buf + 0x1a); switch(buf[0x21] >> 5) { case 1: bitdepth = 8; break; case 2: bitdepth = 10; break; case 3: bitdepth = 12; break; default: av_log(ctx->avctx, AV_LOG_ERROR, ""Unknown bitdepth indicator (%d)\n"", buf[0x21] >> 5); return AVERROR_INVALIDDATA; } cid = AV_RB32(buf + 0x28); ctx->avctx->profile = dnxhd_get_profile(cid); if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0) return ret; if (ctx->mbaff && ctx->cid_table->cid != 1260) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive MB interlace flag in an unsupported profile.\n""); ctx->act = buf[0x2C] & 7; if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive color transform in an unsupported profile.\n""); ctx->is_444 = (buf[0x2C] >> 6) & 1; if (ctx->is_444) { if (bitdepth == 8) { avpriv_request_sample(ctx->avctx, ""4:4:4 8 bits""); return AVERROR_INVALIDDATA; } else if (bitdepth == 10) { ctx->decode_dct_block = dnxhd_decode_dct_block_10_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_12_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12; } } else if (bitdepth == 12) { ctx->decode_dct_block = dnxhd_decode_dct_block_12; ctx->pix_fmt = AV_PIX_FMT_YUV422P12; } else if (bitdepth == 10) { if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX) ctx->decode_dct_block = dnxhd_decode_dct_block_10_444; else ctx->decode_dct_block = dnxhd_decode_dct_block_10; ctx->pix_fmt = AV_PIX_FMT_YUV422P10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_8; ctx->pix_fmt = AV_PIX_FMT_YUV422P; } ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth; if (ctx->bit_depth != old_bit_depth) { ff_blockdsp_init(&ctx->bdsp, ctx->avctx); ff_idctdsp_init(&ctx->idsp, ctx->avctx); ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, ff_zigzag_direct); } if (ctx->width != ctx->cid_table->width && ctx->cid_table->width != DNXHD_VARIABLE) { av_reduce(&ctx->avctx->sample_aspect_ratio.num, &ctx->avctx->sample_aspect_ratio.den, ctx->width, ctx->cid_table->width, 255); ctx->width = ctx->cid_table->width; } if (buf_size < ctx->cid_table->coding_unit_size) { av_log(ctx->avctx, AV_LOG_ERROR, ""incorrect frame size (%d < %u).\n"", buf_size, ctx->cid_table->coding_unit_size); return AVERROR_INVALIDDATA; } ctx->mb_width = (ctx->width + 15)>> 4; ctx->mb_height = AV_RB16(buf + 0x16c); if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame) ctx->height <<= 1; av_log(ctx->avctx, AV_LOG_VERBOSE, ""%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"", ctx->width, ctx->height, ctx->is_444 ? ""4:4"" : ""2:2"", ctx->bit_depth, ctx->mbaff, ctx->act); if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) { ctx->data_offset = 0x170 + (ctx->mb_height << 2); } else { <S2SV_StartVul> if (ctx->mb_height > 68 || <S2SV_EndVul> <S2SV_StartVul> (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) { <S2SV_EndVul> av_log(ctx->avctx, AV_LOG_ERROR, ""mb height too big: %d\n"", ctx->mb_height); return AVERROR_INVALIDDATA; } ctx->data_offset = 0x280; } if (buf_size < ctx->data_offset) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < %d).\n"", buf_size, ctx->data_offset); return AVERROR_INVALIDDATA; } if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) { av_log(ctx->avctx, AV_LOG_ERROR, ""mb_height too big (%d > %""SIZE_SPECIFIER"").\n"", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index)); return AVERROR_INVALIDDATA; } for (i = 0; i < ctx->mb_height; i++) { ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2)); ff_dlog(ctx->avctx, ""mb scan index %d, pos %d: %""PRIu32""\n"", i, 0x170 + (i << 2), ctx->mb_scan_index[i]); if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) { av_log(ctx->avctx, AV_LOG_ERROR, ""invalid mb scan index (%""PRIu32"" vs %u).\n"", ctx->mb_scan_index[i], buf_size - ctx->data_offset); return AVERROR_INVALIDDATA; } } return 0; }","- if (ctx->mb_height > 68 ||
- (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
+ if (ctx->mb_height > 68) {
+ if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
+ av_log(ctx->avctx, AV_LOG_ERROR,
+ ""mb height too big: %d\n"", ctx->mb_height);
+ return AVERROR_INVALIDDATA;
+ }","static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame, const uint8_t *buf, int buf_size, int first_field) { int i, cid, ret; int old_bit_depth = ctx->bit_depth, bitdepth; uint64_t header_prefix; if (buf_size < 0x280) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < 640).\n"", buf_size); return AVERROR_INVALIDDATA; } header_prefix = ff_dnxhd_parse_header_prefix(buf); if (header_prefix == 0) { av_log(ctx->avctx, AV_LOG_ERROR, ""unknown header 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X\n"", buf[0], buf[1], buf[2], buf[3], buf[4]); return AVERROR_INVALIDDATA; } if (buf[5] & 2) { ctx->cur_field = buf[5] & 1; frame->interlaced_frame = 1; frame->top_field_first = first_field ^ ctx->cur_field; av_log(ctx->avctx, AV_LOG_DEBUG, ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field); } else { ctx->cur_field = 0; } ctx->mbaff = (buf[0x6] >> 5) & 1; ctx->height = AV_RB16(buf + 0x18); ctx->width = AV_RB16(buf + 0x1a); switch(buf[0x21] >> 5) { case 1: bitdepth = 8; break; case 2: bitdepth = 10; break; case 3: bitdepth = 12; break; default: av_log(ctx->avctx, AV_LOG_ERROR, ""Unknown bitdepth indicator (%d)\n"", buf[0x21] >> 5); return AVERROR_INVALIDDATA; } cid = AV_RB32(buf + 0x28); ctx->avctx->profile = dnxhd_get_profile(cid); if ((ret = dnxhd_init_vlc(ctx, cid, bitdepth)) < 0) return ret; if (ctx->mbaff && ctx->cid_table->cid != 1260) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive MB interlace flag in an unsupported profile.\n""); ctx->act = buf[0x2C] & 7; if (ctx->act && ctx->cid_table->cid != 1256 && ctx->cid_table->cid != 1270) av_log(ctx->avctx, AV_LOG_WARNING, ""Adaptive color transform in an unsupported profile.\n""); ctx->is_444 = (buf[0x2C] >> 6) & 1; if (ctx->is_444) { if (bitdepth == 8) { avpriv_request_sample(ctx->avctx, ""4:4:4 8 bits""); return AVERROR_INVALIDDATA; } else if (bitdepth == 10) { ctx->decode_dct_block = dnxhd_decode_dct_block_10_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_12_444; ctx->pix_fmt = ctx->act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12; } } else if (bitdepth == 12) { ctx->decode_dct_block = dnxhd_decode_dct_block_12; ctx->pix_fmt = AV_PIX_FMT_YUV422P12; } else if (bitdepth == 10) { if (ctx->avctx->profile == FF_PROFILE_DNXHR_HQX) ctx->decode_dct_block = dnxhd_decode_dct_block_10_444; else ctx->decode_dct_block = dnxhd_decode_dct_block_10; ctx->pix_fmt = AV_PIX_FMT_YUV422P10; } else { ctx->decode_dct_block = dnxhd_decode_dct_block_8; ctx->pix_fmt = AV_PIX_FMT_YUV422P; } ctx->avctx->bits_per_raw_sample = ctx->bit_depth = bitdepth; if (ctx->bit_depth != old_bit_depth) { ff_blockdsp_init(&ctx->bdsp, ctx->avctx); ff_idctdsp_init(&ctx->idsp, ctx->avctx); ff_init_scantable(ctx->idsp.idct_permutation, &ctx->scantable, ff_zigzag_direct); } if (ctx->width != ctx->cid_table->width && ctx->cid_table->width != DNXHD_VARIABLE) { av_reduce(&ctx->avctx->sample_aspect_ratio.num, &ctx->avctx->sample_aspect_ratio.den, ctx->width, ctx->cid_table->width, 255); ctx->width = ctx->cid_table->width; } if (buf_size < ctx->cid_table->coding_unit_size) { av_log(ctx->avctx, AV_LOG_ERROR, ""incorrect frame size (%d < %u).\n"", buf_size, ctx->cid_table->coding_unit_size); return AVERROR_INVALIDDATA; } ctx->mb_width = (ctx->width + 15)>> 4; ctx->mb_height = AV_RB16(buf + 0x16c); if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame) ctx->height <<= 1; av_log(ctx->avctx, AV_LOG_VERBOSE, ""%dx%d, 4:%s %d bits, MBAFF=%d ACT=%d\n"", ctx->width, ctx->height, ctx->is_444 ? ""4:4"" : ""2:2"", ctx->bit_depth, ctx->mbaff, ctx->act); if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) { ctx->data_offset = 0x170 + (ctx->mb_height << 2); } else { if (ctx->mb_height > 68) { av_log(ctx->avctx, AV_LOG_ERROR, ""mb height too big: %d\n"", ctx->mb_height); return AVERROR_INVALIDDATA; } ctx->data_offset = 0x280; } if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) { av_log(ctx->avctx, AV_LOG_ERROR, ""mb height too big: %d\n"", ctx->mb_height); return AVERROR_INVALIDDATA; } if (buf_size < ctx->data_offset) { av_log(ctx->avctx, AV_LOG_ERROR, ""buffer too small (%d < %d).\n"", buf_size, ctx->data_offset); return AVERROR_INVALIDDATA; } if (ctx->mb_height > FF_ARRAY_ELEMS(ctx->mb_scan_index)) { av_log(ctx->avctx, AV_LOG_ERROR, ""mb_height too big (%d > %""SIZE_SPECIFIER"").\n"", ctx->mb_height, FF_ARRAY_ELEMS(ctx->mb_scan_index)); return AVERROR_INVALIDDATA; } for (i = 0; i < ctx->mb_height; i++) { ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2)); ff_dlog(ctx->avctx, ""mb scan index %d, pos %d: %""PRIu32""\n"", i, 0x170 + (i << 2), ctx->mb_scan_index[i]); if (buf_size - ctx->data_offset < ctx->mb_scan_index[i]) { av_log(ctx->avctx, AV_LOG_ERROR, ""invalid mb scan index (%""PRIu32"" vs %u).\n"", ctx->mb_scan_index[i], buf_size - ctx->data_offset); return AVERROR_INVALIDDATA; } } return 0; }"
177,3239----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cjson.c----cJSON_CreateObject,<S2SV_StartVul> cJSON *cJSON_CreateObject( void ) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> cJSON *item = cJSON_New_Item(); <S2SV_EndVul> <S2SV_StartVul> if ( item ) <S2SV_EndVul> <S2SV_StartVul> item->type = cJSON_Object; <S2SV_EndVul> <S2SV_StartVul> return item; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>,"- cJSON *cJSON_CreateObject( void )
- {
- cJSON *item = cJSON_New_Item();
- if ( item )
- item->type = cJSON_Object;
- return item;
- }
+ cJSON *cJSON_CreateObject(void) {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}",cJSON *cJSON_CreateObject(void) {cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
178,4471----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-l2tp.c----l2tp_ppp_discon_cc_print,"l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length) { const uint16_t *ptr = (const uint16_t *)dat; <S2SV_StartVul> ND_PRINT((ndo, ""%04x, "", EXTRACT_16BITS(ptr))); ptr++; <S2SV_EndVul> <S2SV_StartVul> ND_PRINT((ndo, ""%04x "", EXTRACT_16BITS(ptr))); ptr++; <S2SV_EndVul> ND_PRINT((ndo, ""%s"", tok2str(l2tp_cc_direction2str, <S2SV_StartVul> ""Direction-#%u"", *((const u_char *)ptr++)))); <S2SV_EndVul> <S2SV_StartVul> if (length > 5) { <S2SV_EndVul> ND_PRINT((ndo, "" "")); <S2SV_StartVul> print_string(ndo, (const u_char *)ptr, length-5); <S2SV_EndVul> } }","- ""Direction-#%u"", *((const u_char *)ptr++))));
- if (length > 5) {
- print_string(ndo, (const u_char *)ptr, length-5);
+ if (length < 5) {
+ ND_PRINT((ndo, ""AVP too short""));
+ return;
+ }
+ ND_PRINT((ndo, ""%04x, "", EXTRACT_16BITS(dat)));
+ dat += 2;
+ length -= 2;
+ ND_PRINT((ndo, ""%04x "", EXTRACT_16BITS(dat)));
+ dat += 2;
+ length -= 2;
+ ""Direction-#%u"", EXTRACT_8BITS(ptr))));
+ ptr++;
+ length--;
+ if (length != 0) {
+ print_string(ndo, (const u_char *)ptr, length);","l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length) { const uint16_t *ptr = (const uint16_t *)dat; if (length < 5) { ND_PRINT((ndo, ""AVP too short"")); return; } ND_PRINT((ndo, ""%04x, "", EXTRACT_16BITS(dat))); dat += 2; length -= 2; ND_PRINT((ndo, ""%04x "", EXTRACT_16BITS(dat))); dat += 2; length -= 2; ND_PRINT((ndo, ""%s"", tok2str(l2tp_cc_direction2str, ""Direction-#%u"", EXTRACT_8BITS(ptr)))); ptr++; length--; if (length != 0) { ND_PRINT((ndo, "" "")); print_string(ndo, (const u_char *)ptr, length); } }"
179,1562----CWE-787----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7875--wallpaper.c----*enl_ipc_get,"char *enl_ipc_get(const char *msg_data) { static char *message = NULL; <S2SV_StartVul> static unsigned short len = 0; <S2SV_EndVul> char buff[13], *ret_msg = NULL; register unsigned char i; unsigned char blen; if (msg_data == IPC_TIMEOUT) { return(IPC_TIMEOUT); } for (i = 0; i < 12; i++) { buff[i] = msg_data[i]; } buff[12] = 0; blen = strlen(buff); if (message != NULL) { len += blen; message = (char *) erealloc(message, len + 1); strcat(message, buff); } else { len = blen; message = (char *) emalloc(len + 1); strcpy(message, buff); } if (blen < 12) { ret_msg = message; message = NULL; D((""Received complete reply: \""%s\""\n"", ret_msg)); } return(ret_msg); }","- static unsigned short len = 0;
+ static size_t len = 0;","char *enl_ipc_get(const char *msg_data) { static char *message = NULL; static size_t len = 0; char buff[13], *ret_msg = NULL; register unsigned char i; unsigned char blen; if (msg_data == IPC_TIMEOUT) { return(IPC_TIMEOUT); } for (i = 0; i < 12; i++) { buff[i] = msg_data[i]; } buff[12] = 0; blen = strlen(buff); if (message != NULL) { len += blen; message = (char *) erealloc(message, len + 1); strcat(message, buff); } else { len = blen; message = (char *) emalloc(len + 1); strcpy(message, buff); } if (blen < 12) { ret_msg = message; message = NULL; D((""Received complete reply: \""%s\""\n"", ret_msg)); } return(ret_msg); }"
180,6000----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mysqlshow.c----list_table_status,"list_table_status(MYSQL *mysql,const char *db,const char *wild) { <S2SV_StartVul> char query[1024],*end; <S2SV_EndVul> MYSQL_RES *result; MYSQL_ROW row; <S2SV_StartVul> end=strxmov(query,""show table status from `"",db,""`"",NullS); <S2SV_EndVul> <S2SV_StartVul> if (wild && wild[0]) <S2SV_EndVul> <S2SV_StartVul> strxmov(end,"" like '"",wild,""'"",NullS); <S2SV_EndVul> if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql))) { fprintf(stderr,""%s: Cannot get status for db: %s, table: %s: %s\n"", my_progname,db,wild ? wild : """",mysql_error(mysql)); if (mysql_errno(mysql) == ER_PARSE_ERROR) fprintf(stderr,""This error probably means that your MySQL server doesn't support the\n\'show table status' command.\n""); return 1; } printf(""Database: %s"",db); if (wild) printf("" Wildcard: %s"",wild); putchar('\n'); print_res_header(result); while ((row=mysql_fetch_row(result))) print_res_row(result,row); print_res_top(result); mysql_free_result(result); return 0; }","- char query[1024],*end;
- end=strxmov(query,""show table status from `"",db,""`"",NullS);
- if (wild && wild[0])
- strxmov(end,"" like '"",wild,""'"",NullS);
+ char query[NAME_LEN + 100];
+ int len;
+ len= sizeof(query);
+ len-= my_snprintf(query, len, ""show table status from `%s`"", db);
+ if (wild && wild[0] && len)
+ strxnmov(query + strlen(query), len, "" like '"", wild, ""'"", NullS);","list_table_status(MYSQL *mysql,const char *db,const char *wild) { char query[NAME_LEN + 100]; int len; MYSQL_RES *result; MYSQL_ROW row; len= sizeof(query); len-= my_snprintf(query, len, ""show table status from `%s`"", db); if (wild && wild[0] && len) strxnmov(query + strlen(query), len, "" like '"", wild, ""'"", NullS); if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql))) { fprintf(stderr,""%s: Cannot get status for db: %s, table: %s: %s\n"", my_progname,db,wild ? wild : """",mysql_error(mysql)); if (mysql_errno(mysql) == ER_PARSE_ERROR) fprintf(stderr,""This error probably means that your MySQL server doesn't support the\n\'show table status' command.\n""); return 1; } printf(""Database: %s"",db); if (wild) printf("" Wildcard: %s"",wild); putchar('\n'); print_res_header(result); while ((row=mysql_fetch_row(result))) print_res_row(result,row); print_res_top(result); mysql_free_result(result); return 0; }"
181,5911----CWE-203----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/password.c----check_passwd,"static int check_passwd(unsigned char *passwd, size_t length) { struct digest *d = NULL; unsigned char *passwd1_sum; unsigned char *passwd2_sum; int ret = 0; int hash_len; if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) { hash_len = PBKDF2_LENGTH; } else { d = digest_alloc(PASSWD_SUM); if (!d) { pr_err(""No such digest: %s\n"", PASSWD_SUM ? PASSWD_SUM : ""NULL""); return -ENOENT; } hash_len = digest_length(d); } passwd1_sum = calloc(hash_len * 2, sizeof(unsigned char)); if (!passwd1_sum) return -ENOMEM; passwd2_sum = passwd1_sum + hash_len; if (is_passwd_env_enable()) ret = read_env_passwd(passwd2_sum, hash_len); else if (is_passwd_default_enable()) ret = read_default_passwd(passwd2_sum, hash_len); else ret = -EINVAL; if (ret < 0) goto err; if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) { char *key = passwd2_sum + PBKDF2_SALT_LEN; char *salt = passwd2_sum; int keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN; ret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt, PBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum); if (ret) goto err; <S2SV_StartVul> if (strncmp(passwd1_sum, key, keylen) == 0) <S2SV_EndVul> ret = 1; } else { ret = digest_digest(d, passwd, length, passwd1_sum); if (ret) goto err; <S2SV_StartVul> if (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0) <S2SV_EndVul> ret = 1; } err: free(passwd1_sum); digest_free(d); return ret; }","- if (strncmp(passwd1_sum, key, keylen) == 0)
- if (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)
+ if (!crypto_memneq(passwd1_sum, key, keylen))
+ if (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len))","static int check_passwd(unsigned char *passwd, size_t length) { struct digest *d = NULL; unsigned char *passwd1_sum; unsigned char *passwd2_sum; int ret = 0; int hash_len; if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) { hash_len = PBKDF2_LENGTH; } else { d = digest_alloc(PASSWD_SUM); if (!d) { pr_err(""No such digest: %s\n"", PASSWD_SUM ? PASSWD_SUM : ""NULL""); return -ENOENT; } hash_len = digest_length(d); } passwd1_sum = calloc(hash_len * 2, sizeof(unsigned char)); if (!passwd1_sum) return -ENOMEM; passwd2_sum = passwd1_sum + hash_len; if (is_passwd_env_enable()) ret = read_env_passwd(passwd2_sum, hash_len); else if (is_passwd_default_enable()) ret = read_default_passwd(passwd2_sum, hash_len); else ret = -EINVAL; if (ret < 0) goto err; if (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) { char *key = passwd2_sum + PBKDF2_SALT_LEN; char *salt = passwd2_sum; int keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN; ret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt, PBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum); if (ret) goto err; if (!crypto_memneq(passwd1_sum, key, keylen)) ret = 1; } else { ret = digest_digest(d, passwd, length, passwd1_sum); if (ret) goto err; if (!crypto_memneq(passwd1_sum, passwd2_sum, hash_len)) ret = 1; } err: free(passwd1_sum); digest_free(d); return ret; }"
182,2412----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-5327--tcm_loop.c----*tcm_loop_make_naa_tpg,"struct se_portal_group *tcm_loop_make_naa_tpg( struct se_wwn *wwn, struct config_group *group, const char *name) { struct tcm_loop_hba *tl_hba = container_of(wwn, struct tcm_loop_hba, tl_hba_wwn); struct tcm_loop_tpg *tl_tpg; char *tpgt_str, *end_ptr; int ret; unsigned short int tpgt; tpgt_str = strstr(name, ""tpgt_""); if (!tpgt_str) { printk(KERN_ERR ""Unable to locate \""tpgt_#\"" directory"" "" group\n""); return ERR_PTR(-EINVAL); } tpgt_str += 5; tpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0); <S2SV_StartVul> if (tpgt > TL_TPGS_PER_HBA) { <S2SV_EndVul> printk(KERN_ERR ""Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:"" "" %u\n"", tpgt, TL_TPGS_PER_HBA); return ERR_PTR(-EINVAL); } tl_tpg = &tl_hba->tl_hba_tpgs[tpgt]; tl_tpg->tl_hba = tl_hba; tl_tpg->tl_tpgt = tpgt; ret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops, wwn, &tl_tpg->tl_se_tpg, tl_tpg, TRANSPORT_TPG_TYPE_NORMAL); if (ret < 0) return ERR_PTR(-ENOMEM); printk(KERN_INFO ""TCM_Loop_ConfigFS: Allocated Emulated %s"" "" Target Port %s,t,0x%04x\n"", tcm_loop_dump_proto_id(tl_hba), config_item_name(&wwn->wwn_group.cg_item), tpgt); return &tl_tpg->tl_se_tpg; }","- if (tpgt > TL_TPGS_PER_HBA) {
+ if (tpgt >= TL_TPGS_PER_HBA) {","struct se_portal_group *tcm_loop_make_naa_tpg( struct se_wwn *wwn, struct config_group *group, const char *name) { struct tcm_loop_hba *tl_hba = container_of(wwn, struct tcm_loop_hba, tl_hba_wwn); struct tcm_loop_tpg *tl_tpg; char *tpgt_str, *end_ptr; int ret; unsigned short int tpgt; tpgt_str = strstr(name, ""tpgt_""); if (!tpgt_str) { printk(KERN_ERR ""Unable to locate \""tpgt_#\"" directory"" "" group\n""); return ERR_PTR(-EINVAL); } tpgt_str += 5; tpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0); if (tpgt >= TL_TPGS_PER_HBA) { printk(KERN_ERR ""Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:"" "" %u\n"", tpgt, TL_TPGS_PER_HBA); return ERR_PTR(-EINVAL); } tl_tpg = &tl_hba->tl_hba_tpgs[tpgt]; tl_tpg->tl_hba = tl_hba; tl_tpg->tl_tpgt = tpgt; ret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops, wwn, &tl_tpg->tl_se_tpg, tl_tpg, TRANSPORT_TPG_TYPE_NORMAL); if (ret < 0) return ERR_PTR(-ENOMEM); printk(KERN_INFO ""TCM_Loop_ConfigFS: Allocated Emulated %s"" "" Target Port %s,t,0x%04x\n"", tcm_loop_dump_proto_id(tl_hba), config_item_name(&wwn->wwn_group.cg_item), tpgt); return &tl_tpg->tl_se_tpg; }"
183,2954----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/futex.c----futex_wait,"static int futex_wait(u32 __user *uaddr, int fshared, u32 val, ktime_t *abs_time, u32 bitset, int clockrt) { struct hrtimer_sleeper timeout, *to = NULL; struct restart_block *restart; struct futex_hash_bucket *hb; struct futex_q q; int ret; if (!bitset) return -EINVAL; q.pi_state = NULL; q.bitset = bitset; q.rt_waiter = NULL; q.requeue_pi_key = NULL; if (abs_time) { to = &timeout; hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC, HRTIMER_MODE_ABS); hrtimer_init_sleeper(to, current); hrtimer_set_expires_range_ns(&to->timer, *abs_time, current->timer_slack_ns); } retry: ret = futex_wait_setup(uaddr, val, fshared, &q, &hb); if (ret) goto out; futex_wait_queue_me(hb, &q, to); ret = 0; if (!unqueue_me(&q)) <S2SV_StartVul> goto out_put_key; <S2SV_EndVul> ret = -ETIMEDOUT; if (to && !to->task) <S2SV_StartVul> goto out_put_key; <S2SV_EndVul> <S2SV_StartVul> if (!signal_pending(current)) { <S2SV_EndVul> <S2SV_StartVul> put_futex_key(fshared, &q.key); <S2SV_EndVul> goto retry; <S2SV_StartVul> } <S2SV_EndVul> ret = -ERESTARTSYS; if (!abs_time) <S2SV_StartVul> goto out_put_key; <S2SV_EndVul> restart = &current_thread_info()->restart_block; restart->fn = futex_wait_restart; restart->futex.uaddr = (u32 *)uaddr; restart->futex.val = val; restart->futex.time = abs_time->tv64; restart->futex.bitset = bitset; restart->futex.flags = FLAGS_HAS_TIMEOUT; if (fshared) restart->futex.flags |= FLAGS_SHARED; if (clockrt) restart->futex.flags |= FLAGS_CLOCKRT; ret = -ERESTART_RESTARTBLOCK; <S2SV_StartVul> out_put_key: <S2SV_EndVul> <S2SV_StartVul> put_futex_key(fshared, &q.key); <S2SV_EndVul> out: if (to) { hrtimer_cancel(&to->timer); destroy_hrtimer_on_stack(&to->timer); } return ret; }","- goto out_put_key;
- goto out_put_key;
- if (!signal_pending(current)) {
- put_futex_key(fshared, &q.key);
- }
- goto out_put_key;
- out_put_key:
- put_futex_key(fshared, &q.key);
+ goto out;
+ goto out;
+ if (!signal_pending(current))
+ goto out;","static int futex_wait(u32 __user *uaddr, int fshared, u32 val, ktime_t *abs_time, u32 bitset, int clockrt) { struct hrtimer_sleeper timeout, *to = NULL; struct restart_block *restart; struct futex_hash_bucket *hb; struct futex_q q; int ret; if (!bitset) return -EINVAL; q.pi_state = NULL; q.bitset = bitset; q.rt_waiter = NULL; q.requeue_pi_key = NULL; if (abs_time) { to = &timeout; hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME : CLOCK_MONOTONIC, HRTIMER_MODE_ABS); hrtimer_init_sleeper(to, current); hrtimer_set_expires_range_ns(&to->timer, *abs_time, current->timer_slack_ns); } retry: ret = futex_wait_setup(uaddr, val, fshared, &q, &hb); if (ret) goto out; futex_wait_queue_me(hb, &q, to); ret = 0; if (!unqueue_me(&q)) goto out; ret = -ETIMEDOUT; if (to && !to->task) goto out; if (!signal_pending(current)) goto retry; ret = -ERESTARTSYS; if (!abs_time) goto out; restart = &current_thread_info()->restart_block; restart->fn = futex_wait_restart; restart->futex.uaddr = (u32 *)uaddr; restart->futex.val = val; restart->futex.time = abs_time->tv64; restart->futex.bitset = bitset; restart->futex.flags = FLAGS_HAS_TIMEOUT; if (fshared) restart->futex.flags |= FLAGS_SHARED; if (clockrt) restart->futex.flags |= FLAGS_CLOCKRT; ret = -ERESTART_RESTARTBLOCK; out: if (to) { hrtimer_cancel(&to->timer); destroy_hrtimer_on_stack(&to->timer); } return ret; }"
184,5657----CWE-613----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/AuthenticationFeature.cpp----arangodb::AuthenticationFeature::AuthenticationFeature,"AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server) : ApplicationFeature(server, ""Authentication""), _userManager(nullptr), _authCache(nullptr), _authenticationUnixSockets(true), _authenticationSystemOnly(true), _localAuthentication(true), _active(true), <S2SV_StartVul> _authenticationTimeout(0.0) { <S2SV_EndVul> setOptional(false); startsAfter<application_features::BasicFeaturePhaseServer>(); #ifdef USE_ENTERPRISE startsAfter<LdapFeature>(); #endif }","- _authenticationTimeout(0.0) {
+ _authenticationTimeout(0.0),
+ _sessionTimeout(static_cast<double>(1 * std::chrono::hours(1) / std::chrono::seconds(1))) { // 1 hour","AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server) : ApplicationFeature(server, ""Authentication""), _userManager(nullptr), _authCache(nullptr), _authenticationUnixSockets(true), _authenticationSystemOnly(true), _localAuthentication(true), _active(true), _authenticationTimeout(0.0), _sessionTimeout(static_cast<double>(1 * std::chrono::hours(1) / std::chrono::seconds(1))) { setOptional(false); startsAfter<application_features::BasicFeaturePhaseServer>(); #ifdef USE_ENTERPRISE startsAfter<LdapFeature>(); #endif }"
185,2648----CWE-18----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/iakerb.c----iakerb_gss_delete_sec_context,"iakerb_gss_delete_sec_context(OM_uint32 *minor_status, gss_ctx_id_t *context_handle, gss_buffer_t output_token) { <S2SV_StartVul> OM_uint32 major_status = GSS_S_COMPLETE; <S2SV_EndVul> if (output_token != GSS_C_NO_BUFFER) { output_token->length = 0; output_token->value = NULL; } *minor_status = 0; <S2SV_StartVul> if (*context_handle != GSS_C_NO_CONTEXT) { <S2SV_EndVul> <S2SV_StartVul> iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle; <S2SV_EndVul> <S2SV_StartVul> if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) { <S2SV_EndVul> <S2SV_StartVul> iakerb_release_context(iakerb_ctx); <S2SV_EndVul> <S2SV_StartVul> *context_handle = GSS_C_NO_CONTEXT; <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> assert(iakerb_ctx->magic == KG_CONTEXT); <S2SV_EndVul> <S2SV_StartVul> major_status = krb5_gss_delete_sec_context(minor_status, <S2SV_EndVul> <S2SV_StartVul> context_handle, <S2SV_EndVul> <S2SV_StartVul> output_token); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return major_status; <S2SV_EndVul> }","- OM_uint32 major_status = GSS_S_COMPLETE;
- if (*context_handle != GSS_C_NO_CONTEXT) {
- iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
- if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
- iakerb_release_context(iakerb_ctx);
- } else {
- assert(iakerb_ctx->magic == KG_CONTEXT);
- major_status = krb5_gss_delete_sec_context(minor_status,
- context_handle,
- output_token);
- }
- }
- return major_status;
+ iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
+ iakerb_release_context(iakerb_ctx);
+ return GSS_S_COMPLETE;","iakerb_gss_delete_sec_context(OM_uint32 *minor_status, gss_ctx_id_t *context_handle, gss_buffer_t output_token) { iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle; if (output_token != GSS_C_NO_BUFFER) { output_token->length = 0; output_token->value = NULL; } *minor_status = 0; *context_handle = GSS_C_NO_CONTEXT; iakerb_release_context(iakerb_ctx); return GSS_S_COMPLETE; }"
186,1727----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10129--smart_pkt.c----git_pkt_parse_line,"int git_pkt_parse_line( git_pkt **head, const char *line, const char **out, size_t bufflen) { int ret; int32_t len; if (bufflen > 0 && bufflen < PKT_LEN_SIZE) return GIT_EBUFS; len = parse_len(line); if (len < 0) { if (bufflen >= 4 && !git__prefixcmp(line, ""PACK"")) { giterr_clear(); *out = line; return pack_pkt(head); } return (int)len; } if (bufflen > 0 && bufflen < (size_t)len) return GIT_EBUFS; if (len != 0 && len < PKT_LEN_SIZE) return GIT_ERROR; line += PKT_LEN_SIZE; if (len == PKT_LEN_SIZE) { <S2SV_StartVul> *head = NULL; <S2SV_EndVul> <S2SV_StartVul> *out = line; <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> } if (len == 0) { *out = line; return flush_pkt(head); } len -= PKT_LEN_SIZE; if (*line == GIT_SIDE_BAND_DATA) ret = data_pkt(head, line, len); else if (*line == GIT_SIDE_BAND_PROGRESS) ret = sideband_progress_pkt(head, line, len); else if (*line == GIT_SIDE_BAND_ERROR) ret = sideband_error_pkt(head, line, len); else if (!git__prefixcmp(line, ""ACK"")) ret = ack_pkt(head, line, len); else if (!git__prefixcmp(line, ""NAK"")) ret = nak_pkt(head); else if (!git__prefixcmp(line, ""ERR "")) ret = err_pkt(head, line, len); else if (*line == '#') ret = comment_pkt(head, line, len); else if (!git__prefixcmp(line, ""ok"")) ret = ok_pkt(head, line, len); else if (!git__prefixcmp(line, ""ng"")) ret = ng_pkt(head, line, len); else if (!git__prefixcmp(line, ""unpack"")) ret = unpack_pkt(head, line, len); else ret = ref_pkt(head, line, len); *out = line + len; return ret; }","- return 0;
+ giterr_set_str(GITERR_NET, ""Invalid empty packet"");
+ return GIT_ERROR;","int git_pkt_parse_line( git_pkt **head, const char *line, const char **out, size_t bufflen) { int ret; int32_t len; if (bufflen > 0 && bufflen < PKT_LEN_SIZE) return GIT_EBUFS; len = parse_len(line); if (len < 0) { if (bufflen >= 4 && !git__prefixcmp(line, ""PACK"")) { giterr_clear(); *out = line; return pack_pkt(head); } return (int)len; } if (bufflen > 0 && bufflen < (size_t)len) return GIT_EBUFS; if (len != 0 && len < PKT_LEN_SIZE) return GIT_ERROR; line += PKT_LEN_SIZE; if (len == PKT_LEN_SIZE) { giterr_set_str(GITERR_NET, ""Invalid empty packet""); return GIT_ERROR; } if (len == 0) { *out = line; return flush_pkt(head); } len -= PKT_LEN_SIZE; if (*line == GIT_SIDE_BAND_DATA) ret = data_pkt(head, line, len); else if (*line == GIT_SIDE_BAND_PROGRESS) ret = sideband_progress_pkt(head, line, len); else if (*line == GIT_SIDE_BAND_ERROR) ret = sideband_error_pkt(head, line, len); else if (!git__prefixcmp(line, ""ACK"")) ret = ack_pkt(head, line, len); else if (!git__prefixcmp(line, ""NAK"")) ret = nak_pkt(head); else if (!git__prefixcmp(line, ""ERR "")) ret = err_pkt(head, line, len); else if (*line == '#') ret = comment_pkt(head, line, len); else if (!git__prefixcmp(line, ""ok"")) ret = ok_pkt(head, line, len); else if (!git__prefixcmp(line, ""ng"")) ret = ng_pkt(head, line, len); else if (!git__prefixcmp(line, ""unpack"")) ret = unpack_pkt(head, line, len); else ret = ref_pkt(head, line, len); *out = line + len; return ret; }"
187,6235----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/BLSCrypto.cpp----carray2Hex,"void carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray, uint64_t _hexArrayLen) { CHECK_STATE(d); CHECK_STATE(_hexArray); char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; CHECK_STATE(_hexArrayLen > 2 * _len); <S2SV_StartVul> for (int j = 0; j < _len; j++) { <S2SV_EndVul> _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)]; _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F]; } _hexArray[_len * 2] = 0; }","- for (int j = 0; j < _len; j++) {
+ for (uint64_t j = 0; j < _len; j++) {","void carray2Hex(const unsigned char *d, uint64_t _len, char *_hexArray, uint64_t _hexArrayLen) { CHECK_STATE(d); CHECK_STATE(_hexArray); char hexval[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; CHECK_STATE(_hexArrayLen > 2 * _len); for (uint64_t j = 0; j < _len; j++) { _hexArray[j * 2] = hexval[((d[j] >> 4) & 0xF)]; _hexArray[j * 2 + 1] = hexval[(d[j]) & 0x0F]; } _hexArray[_len * 2] = 0; }"
188,4967----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/update.c----update_recv,"BOOL update_recv(rdpUpdate* update, wStream* s) { BOOL rc = FALSE; UINT16 updateType; rdpContext* context = update->context; if (Stream_GetRemainingLength(s) < 2) { WLog_ERR(TAG, ""Stream_GetRemainingLength(s) < 2""); return FALSE; } Stream_Read_UINT16(s, updateType); WLog_Print(update->log, WLOG_TRACE, ""%s Update Data PDU"", UPDATE_TYPE_STRINGS[updateType]); if (!update_begin_paint(update)) goto fail; switch (updateType) { case UPDATE_TYPE_ORDERS: rc = update_recv_orders(update, s); break; case UPDATE_TYPE_BITMAP: { BITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s); if (!bitmap_update) { WLog_ERR(TAG, ""UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed""); goto fail; } rc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update); free_bitmap_update(update->context, bitmap_update); } break; case UPDATE_TYPE_PALETTE: { PALETTE_UPDATE* palette_update = update_read_palette(update, s); if (!palette_update) { WLog_ERR(TAG, ""UPDATE_TYPE_PALETTE - update_read_palette() failed""); goto fail; } rc = IFCALLRESULT(FALSE, update->Palette, context, palette_update); free_palette_update(context, palette_update); } break; case UPDATE_TYPE_SYNCHRONIZE: <S2SV_StartVul> update_read_synchronize(update, s); <S2SV_EndVul> rc = IFCALLRESULT(TRUE, update->Synchronize, context); break; default: break; } fail: if (!update_end_paint(update)) rc = FALSE; if (!rc) { WLog_ERR(TAG, ""UPDATE_TYPE %s [%"" PRIu16 ""] failed"", update_type_to_string(updateType), updateType); return FALSE; } return TRUE; }","- update_read_synchronize(update, s);
+ if (!update_read_synchronize(update, s))
+ goto fail;","BOOL update_recv(rdpUpdate* update, wStream* s) { BOOL rc = FALSE; UINT16 updateType; rdpContext* context = update->context; if (Stream_GetRemainingLength(s) < 2) { WLog_ERR(TAG, ""Stream_GetRemainingLength(s) < 2""); return FALSE; } Stream_Read_UINT16(s, updateType); WLog_Print(update->log, WLOG_TRACE, ""%s Update Data PDU"", UPDATE_TYPE_STRINGS[updateType]); if (!update_begin_paint(update)) goto fail; switch (updateType) { case UPDATE_TYPE_ORDERS: rc = update_recv_orders(update, s); break; case UPDATE_TYPE_BITMAP: { BITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s); if (!bitmap_update) { WLog_ERR(TAG, ""UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed""); goto fail; } rc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update); free_bitmap_update(update->context, bitmap_update); } break; case UPDATE_TYPE_PALETTE: { PALETTE_UPDATE* palette_update = update_read_palette(update, s); if (!palette_update) { WLog_ERR(TAG, ""UPDATE_TYPE_PALETTE - update_read_palette() failed""); goto fail; } rc = IFCALLRESULT(FALSE, update->Palette, context, palette_update); free_palette_update(context, palette_update); } break; case UPDATE_TYPE_SYNCHRONIZE: if (!update_read_synchronize(update, s)) goto fail; rc = IFCALLRESULT(TRUE, update->Synchronize, context); break; default: break; } fail: if (!update_end_paint(update)) rc = FALSE; if (!rc) { WLog_ERR(TAG, ""UPDATE_TYPE %s [%"" PRIu16 ""] failed"", update_type_to_string(updateType), updateType); return FALSE; } return TRUE; }"
189,3128----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spl_observer.c----SPL_METHOD,"SPL_METHOD(SplObjectStorage, unserialize) { spl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis()); char *buf; size_t buf_len; const unsigned char *p, *s; php_unserialize_data_t var_hash; zval entry, inf; zval *pcount, *pmembers; spl_SplObjectStorageElement *element; zend_long count; if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"", &buf, &buf_len) == FAILURE) { return; } if (buf_len == 0) { return; } s = p = (const unsigned char*)buf; PHP_VAR_UNSERIALIZE_INIT(var_hash); if (*p!= 'x' || *++p != ':') { goto outexcept; } ++p; pcount = var_tmp_var(&var_hash); if (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) { goto outexcept; } --p; count = Z_LVAL_P(pcount); while (count-- > 0) { spl_SplObjectStorageElement *pelement; zend_string *hash; if (*p != ';') { goto outexcept; } ++p; if(*p != 'O' && *p != 'C' && *p != 'r') { goto outexcept; } if (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) { goto outexcept; } <S2SV_StartVul> if (Z_TYPE(entry) != IS_OBJECT) { <S2SV_EndVul> <S2SV_StartVul> zval_ptr_dtor(&entry); <S2SV_EndVul> <S2SV_StartVul> goto outexcept; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (*p == ',') { ++p; if (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) { zval_ptr_dtor(&entry); goto outexcept; } <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> ZVAL_UNDEF(&inf); <S2SV_EndVul> } hash = spl_object_storage_get_hash(intern, getThis(), &entry); if (!hash) { zval_ptr_dtor(&entry); zval_ptr_dtor(&inf); goto outexcept; } pelement = spl_object_storage_get(intern, hash); spl_object_storage_free_hash(intern, hash); if (pelement) { if (!Z_ISUNDEF(pelement->inf)) { var_push_dtor(&var_hash, &pelement->inf); } if (!Z_ISUNDEF(pelement->obj)) { var_push_dtor(&var_hash, &pelement->obj); } } element = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf); var_replace(&var_hash, &entry, &element->obj); var_replace(&var_hash, &inf, &element->inf); zval_ptr_dtor(&entry); ZVAL_UNDEF(&entry); zval_ptr_dtor(&inf); ZVAL_UNDEF(&inf); } if (*p != ';') { goto outexcept; } ++p; if (*p!= 'm' || *++p != ':') { goto outexcept; } ++p; pmembers = var_tmp_var(&var_hash); if (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) { goto outexcept; } object_properties_load(&intern->std, Z_ARRVAL_P(pmembers)); PHP_VAR_UNSERIALIZE_DESTROY(var_hash); return; outexcept: PHP_VAR_UNSERIALIZE_DESTROY(var_hash); zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, ""Error at offset %pd of %d bytes"", (zend_long)((char*)p - buf), buf_len); return; }","- if (Z_TYPE(entry) != IS_OBJECT) {
- zval_ptr_dtor(&entry);
- goto outexcept;
- }
- } else {
- ZVAL_UNDEF(&inf);
+ ZVAL_UNDEF(&entry);
+ ZVAL_UNDEF(&inf);
+ }
+ if (Z_TYPE(entry) != IS_OBJECT) {
+ zval_ptr_dtor(&entry);
+ zval_ptr_dtor(&inf);
+ goto outexcept;","SPL_METHOD(SplObjectStorage, unserialize) { spl_SplObjectStorage *intern = Z_SPLOBJSTORAGE_P(getThis()); char *buf; size_t buf_len; const unsigned char *p, *s; php_unserialize_data_t var_hash; zval entry, inf; zval *pcount, *pmembers; spl_SplObjectStorageElement *element; zend_long count; if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"", &buf, &buf_len) == FAILURE) { return; } if (buf_len == 0) { return; } s = p = (const unsigned char*)buf; PHP_VAR_UNSERIALIZE_INIT(var_hash); if (*p!= 'x' || *++p != ':') { goto outexcept; } ++p; pcount = var_tmp_var(&var_hash); if (!php_var_unserialize(pcount, &p, s + buf_len, &var_hash) || Z_TYPE_P(pcount) != IS_LONG) { goto outexcept; } --p; count = Z_LVAL_P(pcount); ZVAL_UNDEF(&entry); ZVAL_UNDEF(&inf); while (count-- > 0) { spl_SplObjectStorageElement *pelement; zend_string *hash; if (*p != ';') { goto outexcept; } ++p; if(*p != 'O' && *p != 'C' && *p != 'r') { goto outexcept; } if (!php_var_unserialize(&entry, &p, s + buf_len, &var_hash)) { goto outexcept; } if (*p == ',') { ++p; if (!php_var_unserialize(&inf, &p, s + buf_len, &var_hash)) { zval_ptr_dtor(&entry); goto outexcept; } } if (Z_TYPE(entry) != IS_OBJECT) { zval_ptr_dtor(&entry); zval_ptr_dtor(&inf); goto outexcept; } hash = spl_object_storage_get_hash(intern, getThis(), &entry); if (!hash) { zval_ptr_dtor(&entry); zval_ptr_dtor(&inf); goto outexcept; } pelement = spl_object_storage_get(intern, hash); spl_object_storage_free_hash(intern, hash); if (pelement) { if (!Z_ISUNDEF(pelement->inf)) { var_push_dtor(&var_hash, &pelement->inf); } if (!Z_ISUNDEF(pelement->obj)) { var_push_dtor(&var_hash, &pelement->obj); } } element = spl_object_storage_attach(intern, getThis(), &entry, Z_ISUNDEF(inf)?NULL:&inf); var_replace(&var_hash, &entry, &element->obj); var_replace(&var_hash, &inf, &element->inf); zval_ptr_dtor(&entry); ZVAL_UNDEF(&entry); zval_ptr_dtor(&inf); ZVAL_UNDEF(&inf); } if (*p != ';') { goto outexcept; } ++p; if (*p!= 'm' || *++p != ':') { goto outexcept; } ++p; pmembers = var_tmp_var(&var_hash); if (!php_var_unserialize(pmembers, &p, s + buf_len, &var_hash) || Z_TYPE_P(pmembers) != IS_ARRAY) { goto outexcept; } object_properties_load(&intern->std, Z_ARRVAL_P(pmembers)); PHP_VAR_UNSERIALIZE_DESTROY(var_hash); return; outexcept: PHP_VAR_UNSERIALIZE_DESTROY(var_hash); zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0, ""Error at offset %pd of %d bytes"", (zend_long)((char*)p - buf), buf_len); return; }"
190,5973----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/HexInStream.cxx----HexInStream::overrun,"<S2SV_StartVul> int HexInStream::overrun(int itemSize, int nItems, bool wait) { <S2SV_EndVul> if (itemSize > bufSize) throw Exception(""HexInStream overrun: max itemSize exceeded""); if (end - ptr != 0) memmove(start, ptr, end - ptr); end -= ptr - start; offset += ptr - start; ptr = start; while (end < ptr + itemSize) { <S2SV_StartVul> int n = in_stream.check(2, 1, wait); <S2SV_EndVul> if (n == 0) return 0; const U8* iptr = in_stream.getptr(); const U8* eptr = in_stream.getend(); <S2SV_StartVul> int length = min((eptr - iptr)/2, start + bufSize - end); <S2SV_EndVul> U8* optr = (U8*) end; <S2SV_StartVul> for (int i=0; i<length; i++) { <S2SV_EndVul> int v = 0; readHexAndShift(iptr[i*2], &v); readHexAndShift(iptr[i*2+1], &v); optr[i] = v; } in_stream.setptr(iptr + length*2); end += length; } <S2SV_StartVul> if (itemSize * nItems > end - ptr) <S2SV_EndVul> nItems = (end - ptr) / itemSize; return nItems; }","- int HexInStream::overrun(int itemSize, int nItems, bool wait) {
- int n = in_stream.check(2, 1, wait);
- int length = min((eptr - iptr)/2, start + bufSize - end);
- for (int i=0; i<length; i++) {
- if (itemSize * nItems > end - ptr)
+ size_t HexInStream::overrun(size_t itemSize, size_t nItems, bool wait) {
+ size_t n = in_stream.check(2, 1, wait);
+ size_t length = min((eptr - iptr)/2, start + bufSize - end);
+ for (size_t i=0; i<length; i++) {
+ if (itemSize * nItems > (size_t)(end - ptr))","size_t HexInStream::overrun(size_t itemSize, size_t nItems, bool wait) { if (itemSize > bufSize) throw Exception(""HexInStream overrun: max itemSize exceeded""); if (end - ptr != 0) memmove(start, ptr, end - ptr); end -= ptr - start; offset += ptr - start; ptr = start; while (end < ptr + itemSize) { size_t n = in_stream.check(2, 1, wait); if (n == 0) return 0; const U8* iptr = in_stream.getptr(); const U8* eptr = in_stream.getend(); size_t length = min((eptr - iptr)/2, start + bufSize - end); U8* optr = (U8*) end; for (size_t i=0; i<length; i++) { int v = 0; readHexAndShift(iptr[i*2], &v); readHexAndShift(iptr[i*2+1], &v); optr[i] = v; } in_stream.setptr(iptr + length*2); end += length; } if (itemSize * nItems > (size_t)(end - ptr)) nItems = (end - ptr) / itemSize; return nItems; }"
191,3030----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/secure_enclave.c----trustedDecryptKeyAES,"void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, <S2SV_StartVul> uint32_t enc_len, char *key) { <S2SV_EndVul> LOG_DEBUG(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(encryptedPrivateKey); CHECK_STATE(key); *errStatus = -9; <S2SV_StartVul> int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072); <S2SV_EndVul> if (status != 0) { *errStatus = status; snprintf(errString, BUF_LEN, ""aes decrypt failed with status %d"", status); LOG_ERROR(errString); goto clean; } *errStatus = -10; uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH); if (keyLen == MAX_KEY_LENGTH) { snprintf(errString, BUF_LEN, ""Key is not null terminated""); LOG_ERROR(errString); goto clean; } SET_SUCCESS clean: ; }","- uint32_t enc_len, char *key) {
- int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);
+ uint64_t enc_len, char *key) {
+ int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);","void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t enc_len, char *key) { LOG_DEBUG(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(encryptedPrivateKey); CHECK_STATE(key); *errStatus = -9; int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072); if (status != 0) { *errStatus = status; snprintf(errString, BUF_LEN, ""aes decrypt failed with status %d"", status); LOG_ERROR(errString); goto clean; } *errStatus = -10; uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH); if (keyLen == MAX_KEY_LENGTH) { snprintf(errString, BUF_LEN, ""Key is not null terminated""); LOG_ERROR(errString); goto clean; } SET_SUCCESS clean: ; }"
192,4988----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/slub.c----list_locations,"static int list_locations(struct kmem_cache *s, char *buf, enum track_item alloc) { int len = 0; unsigned long i; struct loc_track t = { 0, 0, NULL }; int node; if (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location), GFP_TEMPORARY)) return sprintf(buf, ""Out of memory\n""); flush_all(s); for_each_node_state(node, N_NORMAL_MEMORY) { struct kmem_cache_node *n = get_node(s, node); unsigned long flags; struct page *page; if (!atomic_long_read(&n->nr_slabs)) continue; spin_lock_irqsave(&n->list_lock, flags); list_for_each_entry(page, &n->partial, lru) process_slab(&t, s, page, alloc); list_for_each_entry(page, &n->full, lru) process_slab(&t, s, page, alloc); spin_unlock_irqrestore(&n->list_lock, flags); } for (i = 0; i < t.count; i++) { struct location *l = &t.loc[i]; if (len > PAGE_SIZE - 100) break; len += sprintf(buf + len, ""%7ld "", l->count); if (l->addr) len += sprint_symbol(buf + len, (unsigned long)l->addr); else len += sprintf(buf + len, ""<not-available>""); if (l->sum_time != l->min_time) { <S2SV_StartVul> unsigned long remainder; <S2SV_EndVul> len += sprintf(buf + len, "" age=%ld/%ld/%ld"", <S2SV_StartVul> l->min_time, <S2SV_EndVul> <S2SV_StartVul> div_long_long_rem(l->sum_time, l->count, &remainder), <S2SV_EndVul> <S2SV_StartVul> l->max_time); <S2SV_EndVul> } else len += sprintf(buf + len, "" age=%ld"", l->min_time); if (l->min_pid != l->max_pid) len += sprintf(buf + len, "" pid=%ld-%ld"", l->min_pid, l->max_pid); else len += sprintf(buf + len, "" pid=%ld"", l->min_pid); if (num_online_cpus() > 1 && !cpus_empty(l->cpus) && len < PAGE_SIZE - 60) { len += sprintf(buf + len, "" cpus=""); len += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50, l->cpus); } if (num_online_nodes() > 1 && !nodes_empty(l->nodes) && len < PAGE_SIZE - 60) { len += sprintf(buf + len, "" nodes=""); len += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50, l->nodes); } len += sprintf(buf + len, ""\n""); } free_loc_track(&t); if (!t.count) len += sprintf(buf, ""No data\n""); return len; }","- unsigned long remainder;
- l->min_time,
- div_long_long_rem(l->sum_time, l->count, &remainder),
- l->max_time);
+ l->min_time,
+ (long)div_u64(l->sum_time, l->count),
+ l->max_time);","static int list_locations(struct kmem_cache *s, char *buf, enum track_item alloc) { int len = 0; unsigned long i; struct loc_track t = { 0, 0, NULL }; int node; if (!alloc_loc_track(&t, PAGE_SIZE / sizeof(struct location), GFP_TEMPORARY)) return sprintf(buf, ""Out of memory\n""); flush_all(s); for_each_node_state(node, N_NORMAL_MEMORY) { struct kmem_cache_node *n = get_node(s, node); unsigned long flags; struct page *page; if (!atomic_long_read(&n->nr_slabs)) continue; spin_lock_irqsave(&n->list_lock, flags); list_for_each_entry(page, &n->partial, lru) process_slab(&t, s, page, alloc); list_for_each_entry(page, &n->full, lru) process_slab(&t, s, page, alloc); spin_unlock_irqrestore(&n->list_lock, flags); } for (i = 0; i < t.count; i++) { struct location *l = &t.loc[i]; if (len > PAGE_SIZE - 100) break; len += sprintf(buf + len, ""%7ld "", l->count); if (l->addr) len += sprint_symbol(buf + len, (unsigned long)l->addr); else len += sprintf(buf + len, ""<not-available>""); if (l->sum_time != l->min_time) { len += sprintf(buf + len, "" age=%ld/%ld/%ld"", l->min_time, (long)div_u64(l->sum_time, l->count), l->max_time); } else len += sprintf(buf + len, "" age=%ld"", l->min_time); if (l->min_pid != l->max_pid) len += sprintf(buf + len, "" pid=%ld-%ld"", l->min_pid, l->max_pid); else len += sprintf(buf + len, "" pid=%ld"", l->min_pid); if (num_online_cpus() > 1 && !cpus_empty(l->cpus) && len < PAGE_SIZE - 60) { len += sprintf(buf + len, "" cpus=""); len += cpulist_scnprintf(buf + len, PAGE_SIZE - len - 50, l->cpus); } if (num_online_nodes() > 1 && !nodes_empty(l->nodes) && len < PAGE_SIZE - 60) { len += sprintf(buf + len, "" nodes=""); len += nodelist_scnprintf(buf + len, PAGE_SIZE - len - 50, l->nodes); } len += sprintf(buf + len, ""\n""); } free_loc_track(&t); if (!t.count) len += sprintf(buf, ""No data\n""); return len; }"
193,831----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-2666--intel_early.c----get_matching_model_microcode,"get_matching_model_microcode(int cpu, unsigned long start, void *data, size_t size, struct mc_saved_data *mc_saved_data, unsigned long *mc_saved_in_initrd, struct ucode_cpu_info *uci) { u8 *ucode_ptr = data; unsigned int leftover = size; enum ucode_state state = UCODE_OK; unsigned int mc_size; struct microcode_header_intel *mc_header; struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT]; unsigned int mc_saved_count = mc_saved_data->mc_saved_count; int i; <S2SV_StartVul> while (leftover) { <S2SV_EndVul> mc_header = (struct microcode_header_intel *)ucode_ptr; mc_size = get_totalsize(mc_header); if (!mc_size || mc_size > leftover || microcode_sanity_check(ucode_ptr, 0) < 0) break; leftover -= mc_size; if (matching_model_microcode(mc_header, uci->cpu_sig.sig) != UCODE_OK) { ucode_ptr += mc_size; continue; } _save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count); ucode_ptr += mc_size; } if (leftover) { state = UCODE_ERROR; goto out; } if (mc_saved_count == 0) { state = UCODE_NFOUND; goto out; } for (i = 0; i < mc_saved_count; i++) mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start; mc_saved_data->mc_saved_count = mc_saved_count; out: return state; }","- while (leftover) {
+ while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) {","get_matching_model_microcode(int cpu, unsigned long start, void *data, size_t size, struct mc_saved_data *mc_saved_data, unsigned long *mc_saved_in_initrd, struct ucode_cpu_info *uci) { u8 *ucode_ptr = data; unsigned int leftover = size; enum ucode_state state = UCODE_OK; unsigned int mc_size; struct microcode_header_intel *mc_header; struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT]; unsigned int mc_saved_count = mc_saved_data->mc_saved_count; int i; while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) { mc_header = (struct microcode_header_intel *)ucode_ptr; mc_size = get_totalsize(mc_header); if (!mc_size || mc_size > leftover || microcode_sanity_check(ucode_ptr, 0) < 0) break; leftover -= mc_size; if (matching_model_microcode(mc_header, uci->cpu_sig.sig) != UCODE_OK) { ucode_ptr += mc_size; continue; } _save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count); ucode_ptr += mc_size; } if (leftover) { state = UCODE_ERROR; goto out; } if (mc_saved_count == 0) { state = UCODE_NFOUND; goto out; } for (i = 0; i < mc_saved_count; i++) mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start; mc_saved_data->mc_saved_count = mc_saved_count; out: return state; }"
194,7456----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/image.cxx----gif_read_lzw,"gif_read_lzw(FILE *fp, int first_time, int input_code_size) { int i, code, incode; static short fresh = 0, code_size = 0, set_code_size = 0, max_code = 0, max_code_size = 0, firstcode = 0, oldcode = 0, clear_code = 0, end_code = 0, table[2][4096], stack[8192], *sp = stack; if (first_time) { set_code_size = (short)input_code_size; code_size = set_code_size + 1; clear_code = (short)(1 << set_code_size); end_code = clear_code + 1; max_code_size = 2 * clear_code; max_code = clear_code + 2; gif_get_code(fp, 0, 1); fresh = 1; for (i = 0; i < clear_code; i ++) { table[0][i] = 0; table[1][i] = (short)i; } for (; i < 4096; i ++) table[0][i] = table[1][0] = 0; sp = stack; return (0); } else if (fresh) { fresh = 0; do firstcode = oldcode = (short)gif_get_code(fp, code_size, 0); while (firstcode == clear_code); return (firstcode); } if (sp > stack) return (*--sp); <S2SV_StartVul> while ((code = gif_get_code (fp, code_size, 0)) >= 0) <S2SV_EndVul> { if (code == clear_code) { for (i = 0; i < clear_code; i ++) { table[0][i] = 0; table[1][i] = (short)i; } for (; i < 4096; i ++) table[0][i] = table[1][i] = 0; code_size = set_code_size + 1; max_code_size = 2 * clear_code; max_code = clear_code + 2; sp = stack; firstcode = oldcode = (short)gif_get_code(fp, code_size, 0); return (firstcode); } else if (code == end_code) { uchar buf[260]; if (!gif_eof) while (gif_get_block(fp, buf) > 0); return (-2); } incode = code; if (code >= max_code) { *sp++ = firstcode; code = oldcode; } while (code >= clear_code) { *sp++ = table[1][code]; if (code == table[0][code]) return (255); code = table[0][code]; } *sp++ = firstcode = table[1][code]; code = max_code; if (code < 4096) { table[0][code] = oldcode; table[1][code] = firstcode; max_code ++; if (max_code >= max_code_size && max_code_size < 4096) { max_code_size *= 2; code_size ++; } } oldcode = (short)incode; if (sp > stack) return (*--sp); } return (code); }","- while ((code = gif_get_code (fp, code_size, 0)) >= 0)
+ while ((code = gif_get_code(fp, code_size, 0)) >= 0)","gif_read_lzw(FILE *fp, int first_time, int input_code_size) { int i, code, incode; static short fresh = 0, code_size = 0, set_code_size = 0, max_code = 0, max_code_size = 0, firstcode = 0, oldcode = 0, clear_code = 0, end_code = 0, table[2][4096], stack[8192], *sp = stack; if (first_time) { set_code_size = (short)input_code_size; code_size = set_code_size + 1; clear_code = (short)(1 << set_code_size); end_code = clear_code + 1; max_code_size = 2 * clear_code; max_code = clear_code + 2; gif_get_code(fp, 0, 1); fresh = 1; for (i = 0; i < clear_code; i ++) { table[0][i] = 0; table[1][i] = (short)i; } for (; i < 4096; i ++) table[0][i] = table[1][0] = 0; sp = stack; return (0); } else if (fresh) { fresh = 0; do firstcode = oldcode = (short)gif_get_code(fp, code_size, 0); while (firstcode == clear_code); return (firstcode); } if (sp > stack) return (*--sp); while ((code = gif_get_code(fp, code_size, 0)) >= 0) { if (code == clear_code) { for (i = 0; i < clear_code; i ++) { table[0][i] = 0; table[1][i] = (short)i; } for (; i < 4096; i ++) table[0][i] = table[1][i] = 0; code_size = set_code_size + 1; max_code_size = 2 * clear_code; max_code = clear_code + 2; sp = stack; firstcode = oldcode = (short)gif_get_code(fp, code_size, 0); return (firstcode); } else if (code == end_code) { uchar buf[260]; if (!gif_eof) while (gif_get_block(fp, buf) > 0); return (-2); } incode = code; if (code >= max_code) { *sp++ = firstcode; code = oldcode; } while (code >= clear_code) { *sp++ = table[1][code]; if (code == table[0][code]) return (255); code = table[0][code]; } *sp++ = firstcode = table[1][code]; code = max_code; if (code < 4096) { table[0][code] = oldcode; table[1][code] = firstcode; max_code ++; if (max_code >= max_code_size && max_code_size < 4096) { max_code_size *= 2; code_size ++; } } oldcode = (short)incode; if (sp > stack) return (*--sp); } return (code); }"
195,2600----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-11487--trace.c----buffer_pipe_buf_get,"<S2SV_StartVul> static void buffer_pipe_buf_get(struct pipe_inode_info *pipe, <S2SV_EndVul> struct pipe_buffer *buf) { struct buffer_ref *ref = (struct buffer_ref *)buf->private; ref->ref++; }","- static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,
+ static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,
+ 
+ if (ref->ref > INT_MAX/2)
+ ref->ref++;","static void buffer_pipe_buf_get(struct pipe_inode_info *pipe, static bool buffer_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf) { struct buffer_ref *ref = (struct buffer_ref *)buf->private; if (ref->ref > INT_MAX/2) return false; ref->ref++; return true; }"
196,340----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-2517--nl80211.c----nl80211_trigger_scan,"static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) { struct cfg80211_registered_device *rdev = info->user_ptr[0]; struct net_device *dev = info->user_ptr[1]; struct cfg80211_scan_request *request; struct nlattr *attr; struct wiphy *wiphy; int err, tmp, n_ssids = 0, n_channels, i; enum ieee80211_band band; size_t ie_len; if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE])) return -EINVAL; wiphy = &rdev->wiphy; if (!rdev->ops->scan) return -EOPNOTSUPP; if (rdev->scan_req) return -EBUSY; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { n_channels = validate_scan_freqs( info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]); if (!n_channels) return -EINVAL; } else { n_channels = 0; for (band = 0; band < IEEE80211_NUM_BANDS; band++) if (wiphy->bands[band]) n_channels += wiphy->bands[band]->n_channels; } if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) n_ssids++; if (n_ssids > wiphy->max_scan_ssids) return -EINVAL; if (info->attrs[NL80211_ATTR_IE]) ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); else ie_len = 0; if (ie_len > wiphy->max_scan_ie_len) return -EINVAL; request = kzalloc(sizeof(*request) + sizeof(*request->ssids) * n_ssids + sizeof(*request->channels) * n_channels + ie_len, GFP_KERNEL); if (!request) return -ENOMEM; if (n_ssids) request->ssids = (void *)&request->channels[n_channels]; request->n_ssids = n_ssids; if (ie_len) { if (request->ssids) request->ie = (void *)(request->ssids + n_ssids); else request->ie = (void *)(request->channels + n_channels); } i = 0; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) { struct ieee80211_channel *chan; chan = ieee80211_get_channel(wiphy, nla_get_u32(attr)); if (!chan) { err = -EINVAL; goto out_free; } if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } else { for (band = 0; band < IEEE80211_NUM_BANDS; band++) { int j; if (!wiphy->bands[band]) continue; for (j = 0; j < wiphy->bands[band]->n_channels; j++) { struct ieee80211_channel *chan; chan = &wiphy->bands[band]->channels[j]; if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } } if (!i) { err = -EINVAL; goto out_free; } request->n_channels = i; i = 0; if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) { if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) { err = -EINVAL; goto out_free; } memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr)); <S2SV_StartVul> request->ssids[i].ssid_len = nla_len(attr); <S2SV_EndVul> i++; } } if (info->attrs[NL80211_ATTR_IE]) { request->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); memcpy((void *)request->ie, nla_data(info->attrs[NL80211_ATTR_IE]), request->ie_len); } request->dev = dev; request->wiphy = &rdev->wiphy; rdev->scan_req = request; err = rdev->ops->scan(&rdev->wiphy, dev, request); if (!err) { nl80211_send_scan_start(rdev, dev); dev_hold(dev); } else { out_free: rdev->scan_req = NULL; kfree(request); } return err; }","- request->ssids[i].ssid_len = nla_len(attr);
+ request->ssids[i].ssid_len = nla_len(attr);","static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info) { struct cfg80211_registered_device *rdev = info->user_ptr[0]; struct net_device *dev = info->user_ptr[1]; struct cfg80211_scan_request *request; struct nlattr *attr; struct wiphy *wiphy; int err, tmp, n_ssids = 0, n_channels, i; enum ieee80211_band band; size_t ie_len; if (!is_valid_ie_attr(info->attrs[NL80211_ATTR_IE])) return -EINVAL; wiphy = &rdev->wiphy; if (!rdev->ops->scan) return -EOPNOTSUPP; if (rdev->scan_req) return -EBUSY; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { n_channels = validate_scan_freqs( info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]); if (!n_channels) return -EINVAL; } else { n_channels = 0; for (band = 0; band < IEEE80211_NUM_BANDS; band++) if (wiphy->bands[band]) n_channels += wiphy->bands[band]->n_channels; } if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) n_ssids++; if (n_ssids > wiphy->max_scan_ssids) return -EINVAL; if (info->attrs[NL80211_ATTR_IE]) ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); else ie_len = 0; if (ie_len > wiphy->max_scan_ie_len) return -EINVAL; request = kzalloc(sizeof(*request) + sizeof(*request->ssids) * n_ssids + sizeof(*request->channels) * n_channels + ie_len, GFP_KERNEL); if (!request) return -ENOMEM; if (n_ssids) request->ssids = (void *)&request->channels[n_channels]; request->n_ssids = n_ssids; if (ie_len) { if (request->ssids) request->ie = (void *)(request->ssids + n_ssids); else request->ie = (void *)(request->channels + n_channels); } i = 0; if (info->attrs[NL80211_ATTR_SCAN_FREQUENCIES]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_FREQUENCIES], tmp) { struct ieee80211_channel *chan; chan = ieee80211_get_channel(wiphy, nla_get_u32(attr)); if (!chan) { err = -EINVAL; goto out_free; } if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } else { for (band = 0; band < IEEE80211_NUM_BANDS; band++) { int j; if (!wiphy->bands[band]) continue; for (j = 0; j < wiphy->bands[band]->n_channels; j++) { struct ieee80211_channel *chan; chan = &wiphy->bands[band]->channels[j]; if (chan->flags & IEEE80211_CHAN_DISABLED) continue; request->channels[i] = chan; i++; } } } if (!i) { err = -EINVAL; goto out_free; } request->n_channels = i; i = 0; if (info->attrs[NL80211_ATTR_SCAN_SSIDS]) { nla_for_each_nested(attr, info->attrs[NL80211_ATTR_SCAN_SSIDS], tmp) { request->ssids[i].ssid_len = nla_len(attr); if (request->ssids[i].ssid_len > IEEE80211_MAX_SSID_LEN) { err = -EINVAL; goto out_free; } memcpy(request->ssids[i].ssid, nla_data(attr), nla_len(attr)); i++; } } if (info->attrs[NL80211_ATTR_IE]) { request->ie_len = nla_len(info->attrs[NL80211_ATTR_IE]); memcpy((void *)request->ie, nla_data(info->attrs[NL80211_ATTR_IE]), request->ie_len); } request->dev = dev; request->wiphy = &rdev->wiphy; rdev->scan_req = request; err = rdev->ops->scan(&rdev->wiphy, dev, request); if (!err) { nl80211_send_scan_start(rdev, dev); dev_hold(dev); } else { out_free: rdev->scan_req = NULL; kfree(request); } return err; }"
197,4224----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/MemoryManager.cpp----MemoryManager::validate_user_read,"bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const { <S2SV_StartVul> auto* region = region_from_vaddr(process, vaddr); <S2SV_EndVul> <S2SV_StartVul> return region && region->is_readable(); <S2SV_EndVul> }","- auto* region = region_from_vaddr(process, vaddr);
- return region && region->is_readable();
+ auto* region = user_region_from_vaddr(const_cast<Process&>(process), vaddr);
+ return region && region->is_user_accessible() && region->is_readable();","bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const { auto* region = user_region_from_vaddr(const_cast<Process&>(process), vaddr); return region && region->is_user_accessible() && region->is_readable(); }"
198,2321----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-11463--archive_read_support_format_zip.c----archive_read_format_zip_cleanup,"archive_read_format_zip_cleanup(struct archive_read *a) { struct zip *zip; struct zip_entry *zip_entry, *next_zip_entry; zip = (struct zip *)(a->format->data); #ifdef HAVE_ZLIB_H if (zip->stream_valid) inflateEnd(&zip->stream); #endif <S2SV_StartVul> #if HAVA_LZMA_H && HAVE_LIBLZMA <S2SV_EndVul> if (zip->zipx_lzma_valid) { lzma_end(&zip->zipx_lzma_stream); } #endif #ifdef HAVE_BZLIB_H if (zip->bzstream_valid) { BZ2_bzDecompressEnd(&zip->bzstream); } #endif free(zip->uncompressed_buffer); if (zip->ppmd8_valid) __archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8); if (zip->zip_entries) { zip_entry = zip->zip_entries; while (zip_entry != NULL) { next_zip_entry = zip_entry->next; archive_string_free(&zip_entry->rsrcname); free(zip_entry); zip_entry = next_zip_entry; } } free(zip->decrypted_buffer); if (zip->cctx_valid) archive_decrypto_aes_ctr_release(&zip->cctx); if (zip->hctx_valid) archive_hmac_sha1_cleanup(&zip->hctx); free(zip->iv); free(zip->erd); free(zip->v_data); archive_string_free(&zip->format_name); free(zip); (a->format->data) = NULL; return (ARCHIVE_OK); }","- #if HAVA_LZMA_H && HAVE_LIBLZMA
+ #if HAVE_LZMA_H && HAVE_LIBLZMA","archive_read_format_zip_cleanup(struct archive_read *a) { struct zip *zip; struct zip_entry *zip_entry, *next_zip_entry; zip = (struct zip *)(a->format->data); #ifdef HAVE_ZLIB_H if (zip->stream_valid) inflateEnd(&zip->stream); #endif #if HAVE_LZMA_H && HAVE_LIBLZMA if (zip->zipx_lzma_valid) { lzma_end(&zip->zipx_lzma_stream); } #endif #ifdef HAVE_BZLIB_H if (zip->bzstream_valid) { BZ2_bzDecompressEnd(&zip->bzstream); } #endif free(zip->uncompressed_buffer); if (zip->ppmd8_valid) __archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8); if (zip->zip_entries) { zip_entry = zip->zip_entries; while (zip_entry != NULL) { next_zip_entry = zip_entry->next; archive_string_free(&zip_entry->rsrcname); free(zip_entry); zip_entry = next_zip_entry; } } free(zip->decrypted_buffer); if (zip->cctx_valid) archive_decrypto_aes_ctr_release(&zip->cctx); if (zip->hctx_valid) archive_hmac_sha1_cleanup(&zip->hctx); free(zip->iv); free(zip->erd); free(zip->v_data); archive_string_free(&zip->format_name); free(zip); (a->format->data) = NULL; return (ARCHIVE_OK); }"
199,1716----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10161--var_unserializer.c----object_common1,"static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce) { long elements; elements = parse_iv2((*p) + 2, p); (*p) += 2; if (ce->serialize == NULL) { object_init_ex(*rval, ce); } else { zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name); <S2SV_StartVul> return 0; <S2SV_EndVul> } return elements; }","- return 0;
+ if( *p >= max - 2) {
+ zend_error(E_WARNING, ""Bad unserialize data"");
+ return -1;
+ }
+ return -1;","static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce) { long elements; if( *p >= max - 2) { zend_error(E_WARNING, ""Bad unserialize data""); return -1; } elements = parse_iv2((*p) + 2, p); (*p) += 2; if (ce->serialize == NULL) { object_init_ex(*rval, ce); } else { zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name); return -1; } return elements; }"
200,3955----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tif_predict.c----horAcc8,"horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; unsigned char* cp = (unsigned char*) cp0; <S2SV_StartVul> assert((cc%stride)==0); <S2SV_EndVul> if (cc > stride) { if (stride == 3) { unsigned int cr = cp[0]; unsigned int cg = cp[1]; unsigned int cb = cp[2]; cc -= 3; cp += 3; while (cc>0) { cp[0] = (unsigned char) ((cr += cp[0]) & 0xff); cp[1] = (unsigned char) ((cg += cp[1]) & 0xff); cp[2] = (unsigned char) ((cb += cp[2]) & 0xff); cc -= 3; cp += 3; } } else if (stride == 4) { unsigned int cr = cp[0]; unsigned int cg = cp[1]; unsigned int cb = cp[2]; unsigned int ca = cp[3]; cc -= 4; cp += 4; while (cc>0) { cp[0] = (unsigned char) ((cr += cp[0]) & 0xff); cp[1] = (unsigned char) ((cg += cp[1]) & 0xff); cp[2] = (unsigned char) ((cb += cp[2]) & 0xff); cp[3] = (unsigned char) ((ca += cp[3]) & 0xff); cc -= 4; cp += 4; } } else { cc -= stride; do { REPEAT4(stride, cp[stride] = (unsigned char) ((cp[stride] + *cp) & 0xff); cp++) cc -= stride; } while (cc>0); } } }","- assert((cc%stride)==0);
+ if((cc%stride)!=0)
+ {
+ TIFFErrorExt(tif->tif_clientdata, ""horAcc8"",
+ ""%s"", ""(cc%stride)!=0"");
+ return 0;
+ }
+ return 1;","horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc) { tmsize_t stride = PredictorState(tif)->stride; unsigned char* cp = (unsigned char*) cp0; if((cc%stride)!=0) { TIFFErrorExt(tif->tif_clientdata, ""horAcc8"", ""%s"", ""(cc%stride)!=0""); return 0; } if (cc > stride) { if (stride == 3) { unsigned int cr = cp[0]; unsigned int cg = cp[1]; unsigned int cb = cp[2]; cc -= 3; cp += 3; while (cc>0) { cp[0] = (unsigned char) ((cr += cp[0]) & 0xff); cp[1] = (unsigned char) ((cg += cp[1]) & 0xff); cp[2] = (unsigned char) ((cb += cp[2]) & 0xff); cc -= 3; cp += 3; } } else if (stride == 4) { unsigned int cr = cp[0]; unsigned int cg = cp[1]; unsigned int cb = cp[2]; unsigned int ca = cp[3]; cc -= 4; cp += 4; while (cc>0) { cp[0] = (unsigned char) ((cr += cp[0]) & 0xff); cp[1] = (unsigned char) ((cg += cp[1]) & 0xff); cp[2] = (unsigned char) ((cb += cp[2]) & 0xff); cp[3] = (unsigned char) ((ca += cp[3]) & 0xff); cc -= 4; cp += 4; } } else { cc -= stride; do { REPEAT4(stride, cp[stride] = (unsigned char) ((cp[stride] + *cp) & 0xff); cp++) cc -= stride; } while (cc>0); } } return 1; }"
201,4375----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/common.c----TfLiteIntArrayGetSizeInBytes,<S2SV_StartVul> int TfLiteIntArrayGetSizeInBytes(int size) { <S2SV_EndVul> static TfLiteIntArray dummy; <S2SV_StartVul> int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size; <S2SV_EndVul> #if defined(_MSC_VER) computed_size -= sizeof(dummy.data[0]); #endif return computed_size; },"- int TfLiteIntArrayGetSizeInBytes(int size) {
- int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;
+ size_t TfLiteIntArrayGetSizeInBytes(int size) {
+ size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;",size_t TfLiteIntArrayGetSizeInBytes(int size) { static TfLiteIntArray dummy; size_t computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size; #if defined(_MSC_VER) computed_size -= sizeof(dummy.data[0]); #endif return computed_size; }
202,5744----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/TLSOutStream.cxx----TLSOutStream::overrun,"<S2SV_StartVul> int TLSOutStream::overrun(int itemSize, int nItems) <S2SV_EndVul> { if (itemSize > bufSize) throw Exception(""TLSOutStream overrun: max itemSize exceeded""); flush(); <S2SV_StartVul> if (itemSize * nItems > end - ptr) <S2SV_EndVul> nItems = (end - ptr) / itemSize; return nItems; }","- int TLSOutStream::overrun(int itemSize, int nItems)
- if (itemSize * nItems > end - ptr)
+ size_t TLSOutStream::overrun(size_t itemSize, size_t nItems)
+ if (itemSize * nItems > (size_t)(end - ptr))","size_t TLSOutStream::overrun(size_t itemSize, size_t nItems) { if (itemSize > bufSize) throw Exception(""TLSOutStream overrun: max itemSize exceeded""); flush(); if (itemSize * nItems > (size_t)(end - ptr)) nItems = (end - ptr) / itemSize; return nItems; }"
203,3574----CWE-134----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ecall.c----ecall_start,"int ecall_start(struct ecall *ecall, enum icall_call_type call_type, bool audio_cbr) { int err; <S2SV_StartVul> info(""ecall(%p): start\n"", ecall); <S2SV_EndVul> if (!ecall) return EINVAL; #ifdef ECALL_CBR_ALWAYS_ON audio_cbr = true; #endif if (ecall->econn) { if (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) { return ecall_answer(ecall, call_type, audio_cbr); } else { warning(""ecall: start: already in progress (econn=%s)\n"", econn_state_name(econn_current_state(ecall->econn))); return EALREADY; } } #if 0 if (ecall->turnc == 0) { warning(""ecall: start: no TURN servers -- cannot start\n""); return EINTR; } #endif ecall->call_type = call_type; err = ecall_create_econn(ecall); if (err) { warning(""ecall: start: create_econn failed: %m\n"", err); return err; } econn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING); err = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr); if (err) { warning(""ecall: start: alloc_flow failed: %m\n"", err); goto out; } IFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr); if (ecall->props_local && (call_type == ICALL_CALL_TYPE_VIDEO && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) { const char *vstate_string = ""true""; int err2 = econn_props_update(ecall->props_local, ""videosend"", vstate_string); if (err2) { warning(""ecall(%p): econn_props_update(videosend)"", "" failed (%m)\n"", ecall, err2); } } ecall->sdp.async = ASYNC_NONE; err = generate_offer(ecall); if (err) { warning(""ecall(%p): start: generate_offer"" "" failed (%m)\n"", ecall, err); goto out; } ecall->ts_started = tmr_jiffies(); ecall->call_setup_time = -1; out: return err; }","- info(""ecall(%p): start\n"", ecall);
+ info(""ecall(%p): start call_type=%d cbr=%d\n"",
+ ecall, call_type, audio_cbr);","int ecall_start(struct ecall *ecall, enum icall_call_type call_type, bool audio_cbr) { int err; info(""ecall(%p): start call_type=%d cbr=%d\n"", ecall, call_type, audio_cbr); if (!ecall) return EINVAL; #ifdef ECALL_CBR_ALWAYS_ON audio_cbr = true; #endif if (ecall->econn) { if (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) { return ecall_answer(ecall, call_type, audio_cbr); } else { warning(""ecall: start: already in progress (econn=%s)\n"", econn_state_name(econn_current_state(ecall->econn))); return EALREADY; } } #if 0 if (ecall->turnc == 0) { warning(""ecall: start: no TURN servers -- cannot start\n""); return EINTR; } #endif ecall->call_type = call_type; err = ecall_create_econn(ecall); if (err) { warning(""ecall: start: create_econn failed: %m\n"", err); return err; } econn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING); err = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr); if (err) { warning(""ecall: start: alloc_flow failed: %m\n"", err); goto out; } IFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr); if (ecall->props_local && (call_type == ICALL_CALL_TYPE_VIDEO && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) { const char *vstate_string = ""true""; int err2 = econn_props_update(ecall->props_local, ""videosend"", vstate_string); if (err2) { warning(""ecall(%p): econn_props_update(videosend)"", "" failed (%m)\n"", ecall, err2); } } ecall->sdp.async = ASYNC_NONE; err = generate_offer(ecall); if (err) { warning(""ecall(%p): start: generate_offer"" "" failed (%m)\n"", ecall, err); goto out; } ecall->ts_started = tmr_jiffies(); ecall->call_setup_time = -1; out: return err; }"
204,860----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-1335--conf.c----mount_entry_on_generic,"static inline int mount_entry_on_generic(struct mntent *mntent, <S2SV_StartVul> const char* path) <S2SV_EndVul> { unsigned long mntflags; char *mntdata; int ret; bool optional = hasmntopt(mntent, ""optional"") != NULL; ret = mount_entry_create_dir_file(mntent, path); if (ret < 0) return optional ? 0 : -1; cull_mntent_opt(mntent); if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) { free(mntdata); return -1; } ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, <S2SV_StartVul> mntflags, mntdata, optional); <S2SV_EndVul> free(mntdata); return ret; }","- const char* path)
- mntflags, mntdata, optional);
+ const char* path, const char *rootfs)
+ mntflags, mntdata, optional, rootfs);","static inline int mount_entry_on_generic(struct mntent *mntent, const char* path, const char *rootfs) { unsigned long mntflags; char *mntdata; int ret; bool optional = hasmntopt(mntent, ""optional"") != NULL; ret = mount_entry_create_dir_file(mntent, path); if (ret < 0) return optional ? 0 : -1; cull_mntent_opt(mntent); if (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) { free(mntdata); return -1; } ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags, mntdata, optional, rootfs); free(mntdata); return ret; }"
205,7128----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/emulate.c----em_jcxz,"static int em_jcxz(struct x86_emulate_ctxt *ctxt) { if (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) <S2SV_StartVul> jmp_rel(ctxt, ctxt->src.val); <S2SV_EndVul> <S2SV_StartVul> return X86EMUL_CONTINUE; <S2SV_EndVul> }","- jmp_rel(ctxt, ctxt->src.val);
- return X86EMUL_CONTINUE;
+ int rc = X86EMUL_CONTINUE;
+ rc = jmp_rel(ctxt, ctxt->src.val);
+ return rc;","static int em_jcxz(struct x86_emulate_ctxt *ctxt) { int rc = X86EMUL_CONTINUE; if (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0) rc = jmp_rel(ctxt, ctxt->src.val); return rc; }"
206,3858----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/config.c----traceLogDirective,"static int traceLogDirective(MaState *state, cchar *key, cchar *value) { HttpRoute *route; char *format, *option, *ovalue, *tok, *path, *formatter; ssize size; int flags, backup, level; route = state->route; size = MAXINT; backup = 0; flags = 0; path = 0; format = ME_HTTP_LOG_FORMAT; formatter = ""detail""; level = 0; if (route->trace->flags & MPR_LOG_CMDLINE) { mprLog(""info appweb config"", 4, ""Already tracing. Ignoring TraceLog directive""); return 0; } for (option = maGetNextArg(sclone(value), &tok); option; option = maGetNextArg(tok, &tok)) { if (!path) { path = sclone(option); } else { <S2SV_StartVul> option = stok(option, "" =\t,"", &ovalue); <S2SV_EndVul> ovalue = strim(ovalue, ""\""'"", MPR_TRIM_BOTH); if (smatch(option, ""anew"")) { flags |= MPR_LOG_ANEW; } else if (smatch(option, ""backup"")) { backup = atoi(ovalue); } else if (smatch(option, ""format"")) { format = ovalue; } else if (smatch(option, ""level"")) { level = (int) stoi(ovalue); } else if (smatch(option, ""size"")) { size = (ssize) getnum(ovalue); } else if (smatch(option, ""formatter"")) { formatter = ovalue; } else { mprLog(""error appweb config"", 0, ""Unknown TraceLog option %s"", option); } } } if (size < HTTP_TRACE_MIN_LOG_SIZE) { size = HTTP_TRACE_MIN_LOG_SIZE; } if (path == 0) { mprLog(""error appweb config"", 0, ""Missing TraceLog filename""); return MPR_ERR_BAD_SYNTAX; } if (formatter) { httpSetTraceFormatterName(route->trace, formatter); } if (!smatch(path, ""stdout"") && !smatch(path, ""stderr"")) { path = httpMakePath(route, state->configDir, path); } route->trace = httpCreateTrace(route->trace); if (httpSetTraceLogFile(route->trace, path, size, backup, format, flags) < 0) { return MPR_ERR_CANT_OPEN; } httpSetTraceLevel(level); return 0; }","- option = stok(option, "" =\t,"", &ovalue);
+ option = ssplit(option, "" =\t,"", &ovalue);","static int traceLogDirective(MaState *state, cchar *key, cchar *value) { HttpRoute *route; char *format, *option, *ovalue, *tok, *path, *formatter; ssize size; int flags, backup, level; route = state->route; size = MAXINT; backup = 0; flags = 0; path = 0; format = ME_HTTP_LOG_FORMAT; formatter = ""detail""; level = 0; if (route->trace->flags & MPR_LOG_CMDLINE) { mprLog(""info appweb config"", 4, ""Already tracing. Ignoring TraceLog directive""); return 0; } for (option = maGetNextArg(sclone(value), &tok); option; option = maGetNextArg(tok, &tok)) { if (!path) { path = sclone(option); } else { option = ssplit(option, "" =\t,"", &ovalue); ovalue = strim(ovalue, ""\""'"", MPR_TRIM_BOTH); if (smatch(option, ""anew"")) { flags |= MPR_LOG_ANEW; } else if (smatch(option, ""backup"")) { backup = atoi(ovalue); } else if (smatch(option, ""format"")) { format = ovalue; } else if (smatch(option, ""level"")) { level = (int) stoi(ovalue); } else if (smatch(option, ""size"")) { size = (ssize) getnum(ovalue); } else if (smatch(option, ""formatter"")) { formatter = ovalue; } else { mprLog(""error appweb config"", 0, ""Unknown TraceLog option %s"", option); } } } if (size < HTTP_TRACE_MIN_LOG_SIZE) { size = HTTP_TRACE_MIN_LOG_SIZE; } if (path == 0) { mprLog(""error appweb config"", 0, ""Missing TraceLog filename""); return MPR_ERR_BAD_SYNTAX; } if (formatter) { httpSetTraceFormatterName(route->trace, formatter); } if (!smatch(path, ""stdout"") && !smatch(path, ""stderr"")) { path = httpMakePath(route, state->configDir, path); } route->trace = httpCreateTrace(route->trace); if (httpSetTraceLogFile(route->trace, path, size, backup, format, flags) < 0) { return MPR_ERR_CANT_OPEN; } httpSetTraceLevel(level); return 0; }"
207,6502----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rwpng.c----rwpng_read_image24_libpng,"static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose) { png_structp png_ptr = NULL; png_infop info_ptr = NULL; png_size_t rowbytes; int color_type, bit_depth; png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler); if (!png_ptr) { return PNG_OUT_OF_MEMORY_ERROR; } info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, NULL, NULL); return PNG_OUT_OF_MEMORY_ERROR; } if (setjmp(mainprog_ptr->jmpbuf)) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return LIBPNG_FATAL_ERROR; } #if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED) png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON); #endif #if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED) png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)""pHYs\0iTXt\0tEXt\0zTXt"", 4); #endif png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback); struct rwpng_read_data read_data = {infile, 0}; png_set_read_fn(png_ptr, &read_data, user_read_data); png_read_info(png_ptr, info_ptr); png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height, &bit_depth, &color_type, NULL, NULL, NULL); <S2SV_StartVul> if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) { <S2SV_EndVul> <S2SV_StartVul> png_destroy_read_struct(&png_ptr, &info_ptr, NULL); <S2SV_EndVul> <S2SV_StartVul> return PNG_OUT_OF_MEMORY_ERROR; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (!(color_type & PNG_COLOR_MASK_ALPHA)) { #ifdef PNG_READ_FILLER_SUPPORTED png_set_expand(png_ptr); png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER); #else fprintf(stderr, ""pngquant readpng: image is neither RGBA nor GA\n""); png_destroy_read_struct(&png_ptr, &info_ptr, NULL); mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE; return mainprog_ptr->retval; #endif } if (bit_depth == 16) { png_set_strip_16(png_ptr); } if (!(color_type & PNG_COLOR_MASK_COLOR)) { png_set_gray_to_rgb(png_ptr); } double gamma = 0.45455; if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) { mainprog_ptr->input_color = RWPNG_SRGB; mainprog_ptr->output_color = RWPNG_SRGB; } else { png_get_gAMA(png_ptr, info_ptr, &gamma); if (gamma > 0 && gamma <= 1.0) { mainprog_ptr->input_color = RWPNG_GAMA_ONLY; mainprog_ptr->output_color = RWPNG_GAMA_ONLY; } else { fprintf(stderr, ""pngquant readpng: ignored out-of-range gamma %f\n"", gamma); mainprog_ptr->input_color = RWPNG_NONE; mainprog_ptr->output_color = RWPNG_NONE; gamma = 0.45455; } } mainprog_ptr->gamma = gamma; png_set_interlace_handling(png_ptr); png_read_update_info(png_ptr, info_ptr); rowbytes = png_get_rowbytes(png_ptr, info_ptr); if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) { fprintf(stderr, ""pngquant readpng: unable to allocate image data\n""); png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return PNG_OUT_OF_MEMORY_ERROR; } png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0); png_read_image(png_ptr, row_pointers); png_read_end(png_ptr, NULL); #if USE_LCMS #if PNG_LIBPNG_VER < 10500 png_charp ProfileData; #else png_bytep ProfileData; #endif png_uint_32 ProfileLen; cmsHPROFILE hInProfile = NULL; int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR; if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) { hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen); cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile); if (colorspace == cmsSigRgbData && COLOR_PNG) { mainprog_ptr->input_color = RWPNG_ICCP; mainprog_ptr->output_color = RWPNG_SRGB; } else { if (colorspace == cmsSigGrayData && !COLOR_PNG) { mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY; mainprog_ptr->output_color = RWPNG_SRGB; } cmsCloseProfile(hInProfile); hInProfile = NULL; } } if (hInProfile == NULL && COLOR_PNG && !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) && png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) && png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) { cmsCIExyY WhitePoint; cmsCIExyYTRIPLE Primaries; png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y, &Primaries.Red.x, &Primaries.Red.y, &Primaries.Green.x, &Primaries.Green.y, &Primaries.Blue.x, &Primaries.Blue.y); WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0; cmsToneCurve *GammaTable[3]; GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma); hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable); cmsFreeToneCurve(GammaTable[0]); mainprog_ptr->input_color = RWPNG_GAMA_CHRM; mainprog_ptr->output_color = RWPNG_SRGB; } if (hInProfile != NULL) { cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile(); cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8, hOutProfile, TYPE_RGBA_8, INTENT_PERCEPTUAL, omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0); #pragma omp parallel for \ if (mainprog_ptr->height*mainprog_ptr->width > 8000) \ schedule(static) for (unsigned int i = 0; i < mainprog_ptr->height; i++) { cmsDoTransform(hTransform, row_pointers[i], row_pointers[i], mainprog_ptr->width); } cmsDeleteTransform(hTransform); cmsCloseProfile(hOutProfile); cmsCloseProfile(hInProfile); mainprog_ptr->gamma = 0.45455; } #endif png_destroy_read_struct(&png_ptr, &info_ptr, NULL); mainprog_ptr->file_size = read_data.bytes_read; mainprog_ptr->row_pointers = (unsigned char **)row_pointers; return SUCCESS; }","- if (mainprog_ptr->width > INT_MAX/mainprog_ptr->height) {
- png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
- }
+ if (rowbytes > INT_MAX/mainprog_ptr->height) {
+ png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+ return PNG_OUT_OF_MEMORY_ERROR;
+ }","static pngquant_error rwpng_read_image24_libpng(FILE *infile, png24_image *mainprog_ptr, int verbose) { png_structp png_ptr = NULL; png_infop info_ptr = NULL; png_size_t rowbytes; int color_type, bit_depth; png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr, rwpng_error_handler, verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler); if (!png_ptr) { return PNG_OUT_OF_MEMORY_ERROR; } info_ptr = png_create_info_struct(png_ptr); if (!info_ptr) { png_destroy_read_struct(&png_ptr, NULL, NULL); return PNG_OUT_OF_MEMORY_ERROR; } if (setjmp(mainprog_ptr->jmpbuf)) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return LIBPNG_FATAL_ERROR; } #if defined(PNG_SKIP_sRGB_CHECK_PROFILE) && defined(PNG_SET_OPTION_SUPPORTED) png_set_option(png_ptr, PNG_SKIP_sRGB_CHECK_PROFILE, PNG_OPTION_ON); #endif #if PNG_LIBPNG_VER >= 10500 && defined(PNG_UNKNOWN_CHUNKS_SUPPORTED) png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_const_bytep)""pHYs\0iTXt\0tEXt\0zTXt"", 4); #endif png_set_read_user_chunk_fn(png_ptr, &mainprog_ptr->chunks, read_chunk_callback); struct rwpng_read_data read_data = {infile, 0}; png_set_read_fn(png_ptr, &read_data, user_read_data); png_read_info(png_ptr, info_ptr); png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width, &mainprog_ptr->height, &bit_depth, &color_type, NULL, NULL, NULL); if (!(color_type & PNG_COLOR_MASK_ALPHA)) { #ifdef PNG_READ_FILLER_SUPPORTED png_set_expand(png_ptr); png_set_filler(png_ptr, 65535L, PNG_FILLER_AFTER); #else fprintf(stderr, ""pngquant readpng: image is neither RGBA nor GA\n""); png_destroy_read_struct(&png_ptr, &info_ptr, NULL); mainprog_ptr->retval = WRONG_INPUT_COLOR_TYPE; return mainprog_ptr->retval; #endif } if (bit_depth == 16) { png_set_strip_16(png_ptr); } if (!(color_type & PNG_COLOR_MASK_COLOR)) { png_set_gray_to_rgb(png_ptr); } double gamma = 0.45455; if (png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB)) { mainprog_ptr->input_color = RWPNG_SRGB; mainprog_ptr->output_color = RWPNG_SRGB; } else { png_get_gAMA(png_ptr, info_ptr, &gamma); if (gamma > 0 && gamma <= 1.0) { mainprog_ptr->input_color = RWPNG_GAMA_ONLY; mainprog_ptr->output_color = RWPNG_GAMA_ONLY; } else { fprintf(stderr, ""pngquant readpng: ignored out-of-range gamma %f\n"", gamma); mainprog_ptr->input_color = RWPNG_NONE; mainprog_ptr->output_color = RWPNG_NONE; gamma = 0.45455; } } mainprog_ptr->gamma = gamma; png_set_interlace_handling(png_ptr); png_read_update_info(png_ptr, info_ptr); rowbytes = png_get_rowbytes(png_ptr, info_ptr); if (rowbytes > INT_MAX/mainprog_ptr->height) { png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return PNG_OUT_OF_MEMORY_ERROR; } if ((mainprog_ptr->rgba_data = malloc(rowbytes * mainprog_ptr->height)) == NULL) { fprintf(stderr, ""pngquant readpng: unable to allocate image data\n""); png_destroy_read_struct(&png_ptr, &info_ptr, NULL); return PNG_OUT_OF_MEMORY_ERROR; } png_bytepp row_pointers = rwpng_create_row_pointers(info_ptr, png_ptr, mainprog_ptr->rgba_data, mainprog_ptr->height, 0); png_read_image(png_ptr, row_pointers); png_read_end(png_ptr, NULL); #if USE_LCMS #if PNG_LIBPNG_VER < 10500 png_charp ProfileData; #else png_bytep ProfileData; #endif png_uint_32 ProfileLen; cmsHPROFILE hInProfile = NULL; int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR; if (png_get_iCCP(png_ptr, info_ptr, &(png_charp){0}, &(int){0}, &ProfileData, &ProfileLen)) { hInProfile = cmsOpenProfileFromMem(ProfileData, ProfileLen); cmsColorSpaceSignature colorspace = cmsGetColorSpace(hInProfile); if (colorspace == cmsSigRgbData && COLOR_PNG) { mainprog_ptr->input_color = RWPNG_ICCP; mainprog_ptr->output_color = RWPNG_SRGB; } else { if (colorspace == cmsSigGrayData && !COLOR_PNG) { mainprog_ptr->input_color = RWPNG_ICCP_WARN_GRAY; mainprog_ptr->output_color = RWPNG_SRGB; } cmsCloseProfile(hInProfile); hInProfile = NULL; } } if (hInProfile == NULL && COLOR_PNG && !png_get_valid(png_ptr, info_ptr, PNG_INFO_sRGB) && png_get_valid(png_ptr, info_ptr, PNG_INFO_gAMA) && png_get_valid(png_ptr, info_ptr, PNG_INFO_cHRM)) { cmsCIExyY WhitePoint; cmsCIExyYTRIPLE Primaries; png_get_cHRM(png_ptr, info_ptr, &WhitePoint.x, &WhitePoint.y, &Primaries.Red.x, &Primaries.Red.y, &Primaries.Green.x, &Primaries.Green.y, &Primaries.Blue.x, &Primaries.Blue.y); WhitePoint.Y = Primaries.Red.Y = Primaries.Green.Y = Primaries.Blue.Y = 1.0; cmsToneCurve *GammaTable[3]; GammaTable[0] = GammaTable[1] = GammaTable[2] = cmsBuildGamma(NULL, 1/gamma); hInProfile = cmsCreateRGBProfile(&WhitePoint, &Primaries, GammaTable); cmsFreeToneCurve(GammaTable[0]); mainprog_ptr->input_color = RWPNG_GAMA_CHRM; mainprog_ptr->output_color = RWPNG_SRGB; } if (hInProfile != NULL) { cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile(); cmsHTRANSFORM hTransform = cmsCreateTransform(hInProfile, TYPE_RGBA_8, hOutProfile, TYPE_RGBA_8, INTENT_PERCEPTUAL, omp_get_max_threads() > 1 ? cmsFLAGS_NOCACHE : 0); #pragma omp parallel for \ if (mainprog_ptr->height*mainprog_ptr->width > 8000) \ schedule(static) for (unsigned int i = 0; i < mainprog_ptr->height; i++) { cmsDoTransform(hTransform, row_pointers[i], row_pointers[i], mainprog_ptr->width); } cmsDeleteTransform(hTransform); cmsCloseProfile(hOutProfile); cmsCloseProfile(hInProfile); mainprog_ptr->gamma = 0.45455; } #endif png_destroy_read_struct(&png_ptr, &info_ptr, NULL); mainprog_ptr->file_size = read_data.bytes_read; mainprog_ptr->row_pointers = (unsigned char **)row_pointers; return SUCCESS; }"
208,6245----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hfs.c----hfs_cat_traverse,"hfs_cat_traverse(HFS_INFO * hfs, TSK_HFS_BTREE_CB a_cb, void *ptr) { TSK_FS_INFO *fs = &(hfs->fs_info); uint32_t cur_node; char *node; uint16_t nodesize; uint8_t is_done = 0; tsk_error_reset(); nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize); if ((node = (char *) tsk_malloc(nodesize)) == NULL) return 1; cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode); if (cur_node == 0) { if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: "" ""empty extents btree\n""); free(node); return 1; } if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: starting at "" ""root node %"" PRIu32 ""; nodesize = %"" PRIu16 ""\n"", cur_node, nodesize); is_done = 0; while (is_done == 0) { TSK_OFF_T cur_off; uint16_t num_rec; ssize_t cnt; hfs_btree_node *node_desc; if (cur_node > tsk_getu32(fs->endian, hfs->catalog_header.totalNodes)) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: Node %d too large for file"", cur_node); free(node); return 1; } cur_off = cur_node * nodesize; cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off, node, nodesize, 0); if (cnt != nodesize) { if (cnt >= 0) { tsk_error_reset(); tsk_error_set_errno(TSK_ERR_FS_READ); } tsk_error_set_errstr2 (""hfs_cat_traverse: Error reading node %d at offset %"" PRIuOFF, cur_node, cur_off); free(node); return 1; } if (nodesize < sizeof(hfs_btree_node)) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: Node size %d is too small to be valid"", nodesize); free(node); return 1; } node_desc = (hfs_btree_node *) node; num_rec = tsk_getu16(fs->endian, node_desc->num_rec); if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: node %"" PRIu32 "" @ %"" PRIu64 "" has %"" PRIu16 "" records\n"", cur_node, cur_off, num_rec); if (num_rec == 0) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr(""hfs_cat_traverse: zero records in node %"" PRIu32, cur_node); free(node); return 1; } if (node_desc->type == HFS_BT_NODE_TYPE_IDX) { uint32_t next_node = 0; int rec; for (rec = 0; rec < num_rec; ++rec) { size_t rec_off; hfs_btree_key_cat *key; uint8_t retval; <S2SV_StartVul> uint16_t keylen; <S2SV_EndVul> rec_off = tsk_getu16(fs->endian, &node[nodesize - (rec + 1) * 2]); if (rec_off > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, (int) rec_off, nodesize); free(node); return 1; } key = (hfs_btree_key_cat *) & node[rec_off]; keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len); if ((keylen) > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: length of key %d in index node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, keylen, nodesize); free(node); return 1; } retval = a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key, cur_off + rec_off, ptr); if (retval == HFS_BTREE_CB_ERR) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr2 (""hfs_cat_traverse: Callback returned error""); free(node); return 1; } else if ((retval == HFS_BTREE_CB_IDX_LT) || (next_node == 0)) { hfs_btree_index_record *idx_rec; int keylen = 2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian, key->key_len), &(hfs->catalog_header)); if (rec_off + keylen > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, (int) rec_off + keylen, nodesize); free(node); return 1; } idx_rec = (hfs_btree_index_record *) & node[rec_off + keylen]; next_node = tsk_getu32(fs->endian, idx_rec->childNode); } if (retval == HFS_BTREE_CB_IDX_EQGT) { break; } } if (next_node == 0) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: did not find any keys in index node %d"", cur_node); is_done = 1; break; } if (next_node == cur_node) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: node %d references itself as next node"", cur_node); is_done = 1; break; } cur_node = next_node; } else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) { int rec; for (rec = 0; rec < num_rec; ++rec) { size_t rec_off; hfs_btree_key_cat *key; uint8_t retval; <S2SV_StartVul> uint16_t keylen; <S2SV_EndVul> rec_off = tsk_getu16(fs->endian, &node[nodesize - (rec + 1) * 2]); if (rec_off > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, (int) rec_off, nodesize); free(node); return 1; } key = (hfs_btree_key_cat *) & node[rec_off]; keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len); if ((keylen) > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, keylen, nodesize); free(node); return 1; } retval = a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key, cur_off + rec_off, ptr); if (retval == HFS_BTREE_CB_LEAF_STOP) { is_done = 1; break; } else if (retval == HFS_BTREE_CB_ERR) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr2 (""hfs_cat_traverse: Callback returned error""); free(node); return 1; } } if (is_done == 0) { cur_node = tsk_getu32(fs->endian, node_desc->flink); if (cur_node == 0) { is_done = 1; } if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: moving forward to next leaf""); } } else { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr(""hfs_cat_traverse: btree node %"" PRIu32 "" (%"" PRIu64 "") is neither index nor leaf (%"" PRIu8 "")"", cur_node, cur_off, node_desc->type); free(node); return 1; } } free(node); return 0; }","- uint16_t keylen;
- uint16_t keylen;
+ int keylen;
+ int keylen;","hfs_cat_traverse(HFS_INFO * hfs, TSK_HFS_BTREE_CB a_cb, void *ptr) { TSK_FS_INFO *fs = &(hfs->fs_info); uint32_t cur_node; char *node; uint16_t nodesize; uint8_t is_done = 0; tsk_error_reset(); nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize); if ((node = (char *) tsk_malloc(nodesize)) == NULL) return 1; cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode); if (cur_node == 0) { if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: "" ""empty extents btree\n""); free(node); return 1; } if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: starting at "" ""root node %"" PRIu32 ""; nodesize = %"" PRIu16 ""\n"", cur_node, nodesize); is_done = 0; while (is_done == 0) { TSK_OFF_T cur_off; uint16_t num_rec; ssize_t cnt; hfs_btree_node *node_desc; if (cur_node > tsk_getu32(fs->endian, hfs->catalog_header.totalNodes)) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: Node %d too large for file"", cur_node); free(node); return 1; } cur_off = cur_node * nodesize; cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off, node, nodesize, 0); if (cnt != nodesize) { if (cnt >= 0) { tsk_error_reset(); tsk_error_set_errno(TSK_ERR_FS_READ); } tsk_error_set_errstr2 (""hfs_cat_traverse: Error reading node %d at offset %"" PRIuOFF, cur_node, cur_off); free(node); return 1; } if (nodesize < sizeof(hfs_btree_node)) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: Node size %d is too small to be valid"", nodesize); free(node); return 1; } node_desc = (hfs_btree_node *) node; num_rec = tsk_getu16(fs->endian, node_desc->num_rec); if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: node %"" PRIu32 "" @ %"" PRIu64 "" has %"" PRIu16 "" records\n"", cur_node, cur_off, num_rec); if (num_rec == 0) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr(""hfs_cat_traverse: zero records in node %"" PRIu32, cur_node); free(node); return 1; } if (node_desc->type == HFS_BT_NODE_TYPE_IDX) { uint32_t next_node = 0; int rec; for (rec = 0; rec < num_rec; ++rec) { size_t rec_off; hfs_btree_key_cat *key; uint8_t retval; int keylen; rec_off = tsk_getu16(fs->endian, &node[nodesize - (rec + 1) * 2]); if (rec_off > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, (int) rec_off, nodesize); free(node); return 1; } key = (hfs_btree_key_cat *) & node[rec_off]; keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len); if ((keylen) > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: length of key %d in index node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, keylen, nodesize); free(node); return 1; } retval = a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key, cur_off + rec_off, ptr); if (retval == HFS_BTREE_CB_ERR) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr2 (""hfs_cat_traverse: Callback returned error""); free(node); return 1; } else if ((retval == HFS_BTREE_CB_IDX_LT) || (next_node == 0)) { hfs_btree_index_record *idx_rec; int keylen = 2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian, key->key_len), &(hfs->catalog_header)); if (rec_off + keylen > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, (int) rec_off + keylen, nodesize); free(node); return 1; } idx_rec = (hfs_btree_index_record *) & node[rec_off + keylen]; next_node = tsk_getu32(fs->endian, idx_rec->childNode); } if (retval == HFS_BTREE_CB_IDX_EQGT) { break; } } if (next_node == 0) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: did not find any keys in index node %d"", cur_node); is_done = 1; break; } if (next_node == cur_node) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: node %d references itself as next node"", cur_node); is_done = 1; break; } cur_node = next_node; } else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) { int rec; for (rec = 0; rec < num_rec; ++rec) { size_t rec_off; hfs_btree_key_cat *key; uint8_t retval; int keylen; rec_off = tsk_getu16(fs->endian, &node[nodesize - (rec + 1) * 2]); if (rec_off > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, (int) rec_off, nodesize); free(node); return 1; } key = (hfs_btree_key_cat *) & node[rec_off]; keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len); if ((keylen) > nodesize) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr (""hfs_cat_traverse: length of key %d in leaf node %d too large (%d vs %"" PRIu16 "")"", rec, cur_node, keylen, nodesize); free(node); return 1; } retval = a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key, cur_off + rec_off, ptr); if (retval == HFS_BTREE_CB_LEAF_STOP) { is_done = 1; break; } else if (retval == HFS_BTREE_CB_ERR) { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr2 (""hfs_cat_traverse: Callback returned error""); free(node); return 1; } } if (is_done == 0) { cur_node = tsk_getu32(fs->endian, node_desc->flink); if (cur_node == 0) { is_done = 1; } if (tsk_verbose) tsk_fprintf(stderr, ""hfs_cat_traverse: moving forward to next leaf""); } } else { tsk_error_set_errno(TSK_ERR_FS_GENFS); tsk_error_set_errstr(""hfs_cat_traverse: btree node %"" PRIu32 "" (%"" PRIu64 "") is neither index nor leaf (%"" PRIu8 "")"", cur_node, cur_off, node_desc->type); free(node); return 1; } } free(node); return 0; }"
209,6801----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sg.c----sg_start_req,"sg_start_req(Sg_request *srp, unsigned char *cmd) { int res; struct request *rq; Sg_fd *sfp = srp->parentfp; sg_io_hdr_t *hp = &srp->header; int dxfer_len = (int) hp->dxfer_len; int dxfer_dir = hp->dxfer_direction; unsigned int iov_count = hp->iovec_count; Sg_scatter_hold *req_schp = &srp->data; Sg_scatter_hold *rsv_schp = &sfp->reserve; struct request_queue *q = sfp->parentdp->device->request_queue; struct rq_map_data *md, map_data; int rw = hp->dxfer_direction == SG_DXFER_TO_DEV ? WRITE : READ; unsigned char *long_cmdp = NULL; SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp, ""sg_start_req: dxfer_len=%d\n"", dxfer_len)); if (hp->cmd_len > BLK_MAX_CDB) { long_cmdp = kzalloc(hp->cmd_len, GFP_KERNEL); if (!long_cmdp) return -ENOMEM; } rq = blk_get_request(q, rw, GFP_KERNEL); if (IS_ERR(rq)) { kfree(long_cmdp); return PTR_ERR(rq); } blk_rq_set_block_pc(rq); if (hp->cmd_len > BLK_MAX_CDB) rq->cmd = long_cmdp; memcpy(rq->cmd, cmd, hp->cmd_len); rq->cmd_len = hp->cmd_len; srp->rq = rq; rq->end_io_data = srp; rq->sense = srp->sense_b; rq->retries = SG_DEFAULT_RETRIES; if ((dxfer_len <= 0) || (dxfer_dir == SG_DXFER_NONE)) return 0; if (sg_allow_dio && hp->flags & SG_FLAG_DIRECT_IO && dxfer_dir != SG_DXFER_UNKNOWN && !iov_count && !sfp->parentdp->device->host->unchecked_isa_dma && blk_rq_aligned(q, (unsigned long)hp->dxferp, dxfer_len)) md = NULL; else md = &map_data; if (md) { if (!sg_res_in_use(sfp) && dxfer_len <= rsv_schp->bufflen) sg_link_reserve(sfp, srp, dxfer_len); else { res = sg_build_indirect(req_schp, sfp, dxfer_len); if (res) return res; } md->pages = req_schp->pages; md->page_order = req_schp->page_order; md->nr_entries = req_schp->k_use_sg; md->offset = 0; md->null_mapped = hp->dxferp ? 0 : 1; if (dxfer_dir == SG_DXFER_TO_FROM_DEV) md->from_user = 1; else md->from_user = 0; } <S2SV_StartVul> if (unlikely(iov_count > MAX_UIOVEC)) <S2SV_EndVul> <S2SV_StartVul> return -EINVAL; <S2SV_EndVul> if (iov_count) { <S2SV_StartVul> int size = sizeof(struct iovec) * iov_count; <S2SV_EndVul> <S2SV_StartVul> struct iovec *iov; <S2SV_EndVul> struct iov_iter i; <S2SV_StartVul> iov = memdup_user(hp->dxferp, size); <S2SV_EndVul> <S2SV_StartVul> if (IS_ERR(iov)) <S2SV_EndVul> <S2SV_StartVul> return PTR_ERR(iov); <S2SV_EndVul> <S2SV_StartVul> iov_iter_init(&i, rw, iov, iov_count, <S2SV_EndVul> <S2SV_StartVul> min_t(size_t, hp->dxfer_len, <S2SV_EndVul> <S2SV_StartVul> iov_length(iov, iov_count))); <S2SV_EndVul> res = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC); kfree(iov); } else res = blk_rq_map_user(q, rq, md, hp->dxferp, hp->dxfer_len, GFP_ATOMIC); if (!res) { srp->bio = rq->bio; if (!md) { req_schp->dio_in_use = 1; hp->info |= SG_INFO_DIRECT_IO; } } return res; }","- if (unlikely(iov_count > MAX_UIOVEC))
- return -EINVAL;
- int size = sizeof(struct iovec) * iov_count;
- struct iovec *iov;
- iov = memdup_user(hp->dxferp, size);
- if (IS_ERR(iov))
- return PTR_ERR(iov);
- iov_iter_init(&i, rw, iov, iov_count,
- min_t(size_t, hp->dxfer_len,
- iov_length(iov, iov_count)));
+ struct iovec *iov = NULL;
+ res = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i);
+ if (res < 0)
+ return res;
+ iov_iter_truncate(&i, hp->dxfer_len);","sg_start_req(Sg_request *srp, unsigned char *cmd) { int res; struct request *rq; Sg_fd *sfp = srp->parentfp; sg_io_hdr_t *hp = &srp->header; int dxfer_len = (int) hp->dxfer_len; int dxfer_dir = hp->dxfer_direction; unsigned int iov_count = hp->iovec_count; Sg_scatter_hold *req_schp = &srp->data; Sg_scatter_hold *rsv_schp = &sfp->reserve; struct request_queue *q = sfp->parentdp->device->request_queue; struct rq_map_data *md, map_data; int rw = hp->dxfer_direction == SG_DXFER_TO_DEV ? WRITE : READ; unsigned char *long_cmdp = NULL; SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp, ""sg_start_req: dxfer_len=%d\n"", dxfer_len)); if (hp->cmd_len > BLK_MAX_CDB) { long_cmdp = kzalloc(hp->cmd_len, GFP_KERNEL); if (!long_cmdp) return -ENOMEM; } rq = blk_get_request(q, rw, GFP_KERNEL); if (IS_ERR(rq)) { kfree(long_cmdp); return PTR_ERR(rq); } blk_rq_set_block_pc(rq); if (hp->cmd_len > BLK_MAX_CDB) rq->cmd = long_cmdp; memcpy(rq->cmd, cmd, hp->cmd_len); rq->cmd_len = hp->cmd_len; srp->rq = rq; rq->end_io_data = srp; rq->sense = srp->sense_b; rq->retries = SG_DEFAULT_RETRIES; if ((dxfer_len <= 0) || (dxfer_dir == SG_DXFER_NONE)) return 0; if (sg_allow_dio && hp->flags & SG_FLAG_DIRECT_IO && dxfer_dir != SG_DXFER_UNKNOWN && !iov_count && !sfp->parentdp->device->host->unchecked_isa_dma && blk_rq_aligned(q, (unsigned long)hp->dxferp, dxfer_len)) md = NULL; else md = &map_data; if (md) { if (!sg_res_in_use(sfp) && dxfer_len <= rsv_schp->bufflen) sg_link_reserve(sfp, srp, dxfer_len); else { res = sg_build_indirect(req_schp, sfp, dxfer_len); if (res) return res; } md->pages = req_schp->pages; md->page_order = req_schp->page_order; md->nr_entries = req_schp->k_use_sg; md->offset = 0; md->null_mapped = hp->dxferp ? 0 : 1; if (dxfer_dir == SG_DXFER_TO_FROM_DEV) md->from_user = 1; else md->from_user = 0; } if (iov_count) { struct iovec *iov = NULL; struct iov_iter i; res = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i); if (res < 0) return res; iov_iter_truncate(&i, hp->dxfer_len); res = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC); kfree(iov); } else res = blk_rq_map_user(q, rq, md, hp->dxferp, hp->dxfer_len, GFP_ATOMIC); if (!res) { srp->bio = rq->bio; if (!md) { req_schp->dio_in_use = 1; hp->info |= SG_INFO_DIRECT_IO; } } return res; }"
210,2212----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-16910--ecdsa.c----mbedtls_ecdsa_sign,"int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s, const mbedtls_mpi *d, const unsigned char *buf, size_t blen, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng ) { ECDSA_VALIDATE_RET( grp != NULL ); ECDSA_VALIDATE_RET( r != NULL ); ECDSA_VALIDATE_RET( s != NULL ); ECDSA_VALIDATE_RET( d != NULL ); ECDSA_VALIDATE_RET( f_rng != NULL ); ECDSA_VALIDATE_RET( buf != NULL || blen == 0 ); return( ecdsa_sign_restartable( grp, r, s, d, buf, blen, <S2SV_StartVul> f_rng, p_rng, NULL ) ); <S2SV_EndVul> }","- f_rng, p_rng, NULL ) );
+ f_rng, p_rng, f_rng, p_rng, NULL ) );","int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s, const mbedtls_mpi *d, const unsigned char *buf, size_t blen, int (*f_rng)(void *, unsigned char *, size_t), void *p_rng ) { ECDSA_VALIDATE_RET( grp != NULL ); ECDSA_VALIDATE_RET( r != NULL ); ECDSA_VALIDATE_RET( s != NULL ); ECDSA_VALIDATE_RET( d != NULL ); ECDSA_VALIDATE_RET( f_rng != NULL ); ECDSA_VALIDATE_RET( buf != NULL || blen == 0 ); return( ecdsa_sign_restartable( grp, r, s, d, buf, blen, f_rng, p_rng, f_rng, p_rng, NULL ) ); }"
211,1051----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-3841--ipv6.c----dccp_v6_send_response,"static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req) { struct inet_request_sock *ireq = inet_rsk(req); struct ipv6_pinfo *np = inet6_sk(sk); struct sk_buff *skb; struct in6_addr *final_p, final; struct flowi6 fl6; int err = -1; struct dst_entry *dst; memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_DCCP; fl6.daddr = ireq->ir_v6_rmt_addr; fl6.saddr = ireq->ir_v6_loc_addr; fl6.flowlabel = 0; fl6.flowi6_oif = ireq->ir_iif; fl6.fl6_dport = ireq->ir_rmt_port; fl6.fl6_sport = htons(ireq->ir_num); security_req_classify_flow(req, flowi6_to_flowi(&fl6)); <S2SV_StartVul> final_p = fl6_update_dst(&fl6, np->opt, &final); <S2SV_EndVul> dst = ip6_dst_lookup_flow(sk, &fl6, final_p); if (IS_ERR(dst)) { err = PTR_ERR(dst); dst = NULL; goto done; } skb = dccp_make_response(sk, dst, req); if (skb != NULL) { struct dccp_hdr *dh = dccp_hdr(skb); dh->dccph_checksum = dccp_v6_csum_finish(skb, &ireq->ir_v6_loc_addr, &ireq->ir_v6_rmt_addr); fl6.daddr = ireq->ir_v6_rmt_addr; <S2SV_StartVul> err = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass); <S2SV_EndVul> err = net_xmit_eval(err); } done: dst_release(dst); return err; }","- final_p = fl6_update_dst(&fl6, np->opt, &final);
- err = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);
+ rcu_read_lock();
+ final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);
+ rcu_read_unlock();
+ rcu_read_lock();
+ err = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
+ np->tclass);
+ rcu_read_unlock();","static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req) { struct inet_request_sock *ireq = inet_rsk(req); struct ipv6_pinfo *np = inet6_sk(sk); struct sk_buff *skb; struct in6_addr *final_p, final; struct flowi6 fl6; int err = -1; struct dst_entry *dst; memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_DCCP; fl6.daddr = ireq->ir_v6_rmt_addr; fl6.saddr = ireq->ir_v6_loc_addr; fl6.flowlabel = 0; fl6.flowi6_oif = ireq->ir_iif; fl6.fl6_dport = ireq->ir_rmt_port; fl6.fl6_sport = htons(ireq->ir_num); security_req_classify_flow(req, flowi6_to_flowi(&fl6)); rcu_read_lock(); final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final); rcu_read_unlock(); dst = ip6_dst_lookup_flow(sk, &fl6, final_p); if (IS_ERR(dst)) { err = PTR_ERR(dst); dst = NULL; goto done; } skb = dccp_make_response(sk, dst, req); if (skb != NULL) { struct dccp_hdr *dh = dccp_hdr(skb); dh->dccph_checksum = dccp_v6_csum_finish(skb, &ireq->ir_v6_loc_addr, &ireq->ir_v6_rmt_addr); fl6.daddr = ireq->ir_v6_rmt_addr; rcu_read_lock(); err = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt), np->tclass); rcu_read_unlock(); err = net_xmit_eval(err); } done: dst_release(dst); return err; }"
212,3902----CWE-672----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/TightDecoder.cxx----TightDecoder::decodeRect,"void TightDecoder::decodeRect(const Rect& r, const void* buffer, size_t buflen, const ServerParams& server, ModifiablePixelBuffer* pb) { const rdr::U8* bufptr; const PixelFormat& pf = server.pf(); rdr::U8 comp_ctl; bufptr = (const rdr::U8*)buffer; assert(buflen >= 1); comp_ctl = *bufptr; bufptr += 1; buflen -= 1; for (int i = 0; i < 4; i++) { if (comp_ctl & 1) { zis[i].reset(); } comp_ctl >>= 1; } if (comp_ctl == tightFill) { if (pf.is888()) { rdr::U8 pix[4]; assert(buflen >= 3); pf.bufferFromRGB(pix, bufptr, 1); pb->fillRect(pf, r, pix); } else { assert(buflen >= (size_t)pf.bpp/8); pb->fillRect(pf, r, bufptr); } return; } if (comp_ctl == tightJpeg) { rdr::U32 len; int stride; rdr::U8 *buf; JpegDecompressor jd; assert(buflen >= 4); memcpy(&len, bufptr, 4); bufptr += 4; buflen -= 4; buf = pb->getBufferRW(r, &stride); jd.decompress(bufptr, len, buf, stride, r, pb->getPF()); pb->commitBufferRW(r); return; } assert(comp_ctl <= tightMaxSubencoding); int palSize = 0; rdr::U8 palette[256 * 4]; bool useGradient = false; if ((comp_ctl & tightExplicitFilter) != 0) { rdr::U8 filterId; assert(buflen >= 1); filterId = *bufptr; bufptr += 1; buflen -= 1; switch (filterId) { case tightFilterPalette: assert(buflen >= 1); palSize = *bufptr + 1; bufptr += 1; buflen -= 1; if (pf.is888()) { size_t len = palSize * 3; rdr::U8Array tightPalette(len); assert(buflen >= len); memcpy(tightPalette.buf, bufptr, len); bufptr += len; buflen -= len; pf.bufferFromRGB(palette, tightPalette.buf, palSize); } else { size_t len; len = palSize * pf.bpp/8; assert(buflen >= len); memcpy(palette, bufptr, len); bufptr += len; buflen -= len; } break; case tightFilterGradient: useGradient = true; break; case tightFilterCopy: break; default: assert(false); } } size_t rowSize, dataSize; rdr::U8* netbuf; netbuf = NULL; if (palSize != 0) { if (palSize <= 2) rowSize = (r.width() + 7) / 8; else rowSize = r.width(); } else if (pf.is888()) { rowSize = r.width() * 3; } else { rowSize = r.width() * pf.bpp/8; } dataSize = r.height() * rowSize; if (dataSize < TIGHT_MIN_TO_COMPRESS) assert(buflen >= dataSize); else { rdr::U32 len; int streamId; rdr::MemInStream* ms; assert(buflen >= 4); memcpy(&len, bufptr, 4); bufptr += 4; buflen -= 4; assert(buflen >= len); streamId = comp_ctl & 0x03; ms = new rdr::MemInStream(bufptr, len); zis[streamId].setUnderlying(ms, len); netbuf = new rdr::U8[dataSize]; zis[streamId].readBytes(netbuf, dataSize); <S2SV_StartVul> zis[streamId].removeUnderlying(); <S2SV_EndVul> delete ms; bufptr = netbuf; buflen = dataSize; } bool directDecode; rdr::U8* outbuf; int stride; if (pb->getPF().equal(pf)) { directDecode = true; } else { directDecode = false; } if (directDecode) outbuf = pb->getBufferRW(r, &stride); else { outbuf = new rdr::U8[r.area() * (pf.bpp/8)]; stride = r.width(); } if (palSize == 0) { if (useGradient) { if (pf.is888()) FilterGradient24(bufptr, pf, (rdr::U32*)outbuf, stride, r); else { switch (pf.bpp) { case 8: assert(false); break; case 16: FilterGradient(bufptr, pf, (rdr::U16*)outbuf, stride, r); break; case 32: FilterGradient(bufptr, pf, (rdr::U32*)outbuf, stride, r); break; } } } else { rdr::U8* ptr = outbuf; const rdr::U8* srcPtr = bufptr; int w = r.width(); int h = r.height(); if (pf.is888()) { while (h > 0) { pf.bufferFromRGB(ptr, srcPtr, w); ptr += stride * pf.bpp/8; srcPtr += w * 3; h--; } } else { while (h > 0) { memcpy(ptr, srcPtr, w * pf.bpp/8); ptr += stride * pf.bpp/8; srcPtr += w * pf.bpp/8; h--; } } } } else { switch (pf.bpp) { case 8: FilterPalette((const rdr::U8*)palette, palSize, bufptr, (rdr::U8*)outbuf, stride, r); break; case 16: FilterPalette((const rdr::U16*)palette, palSize, bufptr, (rdr::U16*)outbuf, stride, r); break; case 32: FilterPalette((const rdr::U32*)palette, palSize, bufptr, (rdr::U32*)outbuf, stride, r); break; } } if (directDecode) pb->commitBufferRW(r); else { pb->imageRect(pf, r, outbuf); delete [] outbuf; } delete [] netbuf; }","- zis[streamId].removeUnderlying();
+ zis[streamId].flushUnderlying();
+ zis[streamId].setUnderlying(NULL, 0);","void TightDecoder::decodeRect(const Rect& r, const void* buffer, size_t buflen, const ServerParams& server, ModifiablePixelBuffer* pb) { const rdr::U8* bufptr; const PixelFormat& pf = server.pf(); rdr::U8 comp_ctl; bufptr = (const rdr::U8*)buffer; assert(buflen >= 1); comp_ctl = *bufptr; bufptr += 1; buflen -= 1; for (int i = 0; i < 4; i++) { if (comp_ctl & 1) { zis[i].reset(); } comp_ctl >>= 1; } if (comp_ctl == tightFill) { if (pf.is888()) { rdr::U8 pix[4]; assert(buflen >= 3); pf.bufferFromRGB(pix, bufptr, 1); pb->fillRect(pf, r, pix); } else { assert(buflen >= (size_t)pf.bpp/8); pb->fillRect(pf, r, bufptr); } return; } if (comp_ctl == tightJpeg) { rdr::U32 len; int stride; rdr::U8 *buf; JpegDecompressor jd; assert(buflen >= 4); memcpy(&len, bufptr, 4); bufptr += 4; buflen -= 4; buf = pb->getBufferRW(r, &stride); jd.decompress(bufptr, len, buf, stride, r, pb->getPF()); pb->commitBufferRW(r); return; } assert(comp_ctl <= tightMaxSubencoding); int palSize = 0; rdr::U8 palette[256 * 4]; bool useGradient = false; if ((comp_ctl & tightExplicitFilter) != 0) { rdr::U8 filterId; assert(buflen >= 1); filterId = *bufptr; bufptr += 1; buflen -= 1; switch (filterId) { case tightFilterPalette: assert(buflen >= 1); palSize = *bufptr + 1; bufptr += 1; buflen -= 1; if (pf.is888()) { size_t len = palSize * 3; rdr::U8Array tightPalette(len); assert(buflen >= len); memcpy(tightPalette.buf, bufptr, len); bufptr += len; buflen -= len; pf.bufferFromRGB(palette, tightPalette.buf, palSize); } else { size_t len; len = palSize * pf.bpp/8; assert(buflen >= len); memcpy(palette, bufptr, len); bufptr += len; buflen -= len; } break; case tightFilterGradient: useGradient = true; break; case tightFilterCopy: break; default: assert(false); } } size_t rowSize, dataSize; rdr::U8* netbuf; netbuf = NULL; if (palSize != 0) { if (palSize <= 2) rowSize = (r.width() + 7) / 8; else rowSize = r.width(); } else if (pf.is888()) { rowSize = r.width() * 3; } else { rowSize = r.width() * pf.bpp/8; } dataSize = r.height() * rowSize; if (dataSize < TIGHT_MIN_TO_COMPRESS) assert(buflen >= dataSize); else { rdr::U32 len; int streamId; rdr::MemInStream* ms; assert(buflen >= 4); memcpy(&len, bufptr, 4); bufptr += 4; buflen -= 4; assert(buflen >= len); streamId = comp_ctl & 0x03; ms = new rdr::MemInStream(bufptr, len); zis[streamId].setUnderlying(ms, len); netbuf = new rdr::U8[dataSize]; zis[streamId].readBytes(netbuf, dataSize); zis[streamId].flushUnderlying(); zis[streamId].setUnderlying(NULL, 0); delete ms; bufptr = netbuf; buflen = dataSize; } bool directDecode; rdr::U8* outbuf; int stride; if (pb->getPF().equal(pf)) { directDecode = true; } else { directDecode = false; } if (directDecode) outbuf = pb->getBufferRW(r, &stride); else { outbuf = new rdr::U8[r.area() * (pf.bpp/8)]; stride = r.width(); } if (palSize == 0) { if (useGradient) { if (pf.is888()) FilterGradient24(bufptr, pf, (rdr::U32*)outbuf, stride, r); else { switch (pf.bpp) { case 8: assert(false); break; case 16: FilterGradient(bufptr, pf, (rdr::U16*)outbuf, stride, r); break; case 32: FilterGradient(bufptr, pf, (rdr::U32*)outbuf, stride, r); break; } } } else { rdr::U8* ptr = outbuf; const rdr::U8* srcPtr = bufptr; int w = r.width(); int h = r.height(); if (pf.is888()) { while (h > 0) { pf.bufferFromRGB(ptr, srcPtr, w); ptr += stride * pf.bpp/8; srcPtr += w * 3; h--; } } else { while (h > 0) { memcpy(ptr, srcPtr, w * pf.bpp/8); ptr += stride * pf.bpp/8; srcPtr += w * pf.bpp/8; h--; } } } } else { switch (pf.bpp) { case 8: FilterPalette((const rdr::U8*)palette, palSize, bufptr, (rdr::U8*)outbuf, stride, r); break; case 16: FilterPalette((const rdr::U16*)palette, palSize, bufptr, (rdr::U16*)outbuf, stride, r); break; case 32: FilterPalette((const rdr::U32*)palette, palSize, bufptr, (rdr::U32*)outbuf, stride, r); break; } } if (directDecode) pb->commitBufferRW(r); else { pb->imageRect(pf, r, outbuf); delete [] outbuf; } delete [] netbuf; }"
213,3615----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cil_reset_ast.c----cil_reset_classpermission,static void cil_reset_classpermission(struct cil_classpermission *cp) { if (cp == NULL) { return; } <S2SV_StartVul> cil_reset_classperms_list(cp->classperms); <S2SV_EndVul> },"- cil_reset_classperms_list(cp->classperms);
+ cil_list_destroy(&cp->classperms, CIL_FALSE);","static void cil_reset_classpermission(struct cil_classpermission *cp) { if (cp == NULL) { return; } cil_list_destroy(&cp->classperms, CIL_FALSE); }"
214,3095----CWE-203----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/verifier.c----sanitize_ptr_alu,"static int sanitize_ptr_alu(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg, struct bpf_reg_state *dst_reg, struct bpf_sanitize_info *info, const bool commit_window) { struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : &info->aux; struct bpf_verifier_state *vstate = env->cur_state; bool off_is_imm = tnum_is_const(off_reg->var_off); bool off_is_neg = off_reg->smin_value < 0; bool ptr_is_dst_reg = ptr_reg == dst_reg; u8 opcode = BPF_OP(insn->code); u32 alu_state, alu_limit; struct bpf_reg_state tmp; bool ret; int err; if (can_skip_alu_sanitation(env, insn)) return 0; if (vstate->speculative) goto do_sim; if (!commit_window) { if (!tnum_is_const(off_reg->var_off) && (off_reg->smin_value < 0) != (off_reg->smax_value < 0)) return REASON_BOUNDS; info->mask_to_left = (opcode == BPF_ADD && off_is_neg) || (opcode == BPF_SUB && !off_is_neg); } err = retrieve_ptr_limit(ptr_reg, &alu_limit, info->mask_to_left); if (err < 0) return err; if (commit_window) { alu_state = info->aux.alu_state; alu_limit = abs(info->aux.alu_limit - alu_limit); } else { alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST; } err = update_alu_sanitation_state(aux, alu_state, alu_limit); if (err < 0) return err; do_sim: if (commit_window || off_is_imm) return 0; if (!ptr_is_dst_reg) { tmp = *dst_reg; *dst_reg = *ptr_reg; } <S2SV_StartVul> ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true); <S2SV_EndVul> if (!ptr_is_dst_reg && ret) *dst_reg = tmp; return !ret ? REASON_STACK : 0; }","- ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);
+ ret = sanitize_speculative_path(env, NULL, env->insn_idx + 1,
+ env->insn_idx);","static int sanitize_ptr_alu(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg, struct bpf_reg_state *dst_reg, struct bpf_sanitize_info *info, const bool commit_window) { struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : &info->aux; struct bpf_verifier_state *vstate = env->cur_state; bool off_is_imm = tnum_is_const(off_reg->var_off); bool off_is_neg = off_reg->smin_value < 0; bool ptr_is_dst_reg = ptr_reg == dst_reg; u8 opcode = BPF_OP(insn->code); u32 alu_state, alu_limit; struct bpf_reg_state tmp; bool ret; int err; if (can_skip_alu_sanitation(env, insn)) return 0; if (vstate->speculative) goto do_sim; if (!commit_window) { if (!tnum_is_const(off_reg->var_off) && (off_reg->smin_value < 0) != (off_reg->smax_value < 0)) return REASON_BOUNDS; info->mask_to_left = (opcode == BPF_ADD && off_is_neg) || (opcode == BPF_SUB && !off_is_neg); } err = retrieve_ptr_limit(ptr_reg, &alu_limit, info->mask_to_left); if (err < 0) return err; if (commit_window) { alu_state = info->aux.alu_state; alu_limit = abs(info->aux.alu_limit - alu_limit); } else { alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0; alu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST; } err = update_alu_sanitation_state(aux, alu_state, alu_limit); if (err < 0) return err; do_sim: if (commit_window || off_is_imm) return 0; if (!ptr_is_dst_reg) { tmp = *dst_reg; *dst_reg = *ptr_reg; } ret = sanitize_speculative_path(env, NULL, env->insn_idx + 1, env->insn_idx); if (!ptr_is_dst_reg && ret) *dst_reg = tmp; return !ret ? REASON_STACK : 0; }"
215,2550----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8957--sun.c----*ReadSUNImage,"static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define RMT_EQUAL_RGB 1 #define RMT_NONE 0 #define RMT_RAW 2 #define RT_STANDARD 1 #define RT_ENCODED 2 #define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic, width, height, depth, length, type, maptype, maplength; } SUNInfo; Image *image; int bit; MagickBooleanType status; MagickSizeType number_pixels; register Quantum *q; register ssize_t i, x; register unsigned char *p; size_t bytes_per_line, extent, length; ssize_t count, y; SUNInfo sun_info; unsigned char *sun_data, *sun_pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info)); sun_info.magic=ReadBlobMSBLong(image); do { if (sun_info.magic != 0x59a66a95) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); sun_info.width=ReadBlobMSBLong(image); sun_info.height=ReadBlobMSBLong(image); sun_info.depth=ReadBlobMSBLong(image); sun_info.length=ReadBlobMSBLong(image); sun_info.type=ReadBlobMSBLong(image); sun_info.maptype=ReadBlobMSBLong(image); sun_info.maplength=ReadBlobMSBLong(image); extent=sun_info.height*sun_info.width; if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) && (sun_info.type != RT_FORMAT_RGB)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.depth == 0) || (sun_info.depth > 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) && (sun_info.maptype != RMT_RAW)) ThrowReaderException(CoderError,""ColormapTypeNotSupported""); image->columns=sun_info.width; image->rows=sun_info.height; image->depth=sun_info.depth <= 8 ? sun_info.depth : MAGICKCORE_QUANTUM_DEPTH; if (sun_info.depth < 24) { size_t one; image->storage_class=PseudoClass; image->colors=sun_info.maplength; one=1; if (sun_info.maptype == RMT_NONE) image->colors=one << sun_info.depth; if (sun_info.maptype == RMT_EQUAL_RGB) image->colors=sun_info.maplength/3; } switch (sun_info.maptype) { case RMT_NONE: { if (sun_info.depth < 24) { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } break; } case RMT_EQUAL_RGB: { unsigned char *sun_colormap; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors, sizeof(*sun_colormap)); if (sun_colormap == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,image->colors,sun_colormap); if (count != (ssize_t) image->colors) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].red=(MagickRealType) ScaleCharToQuantum( sun_colormap[i]); count=ReadBlob(image,image->colors,sun_colormap); if (count != (ssize_t) image->colors) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].green=(MagickRealType) ScaleCharToQuantum( sun_colormap[i]); count=ReadBlob(image,image->colors,sun_colormap); if (count != (ssize_t) image->colors) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum( sun_colormap[i]); sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap); break; } case RMT_RAW: { unsigned char *sun_colormap; sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength, sizeof(*sun_colormap)); if (sun_colormap == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,sun_info.maplength,sun_colormap); if (count != (ssize_t) sun_info.maplength) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap); break; } default: ThrowReaderException(CoderError,""ColormapTypeNotSupported""); } image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait : UndefinedPixelTrait; image->columns=sun_info.width; image->rows=sun_info.height; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) != sun_info.length || !sun_info.length) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); number_pixels=(MagickSizeType) image->columns*image->rows; if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) && ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); sun_data=(unsigned char *) AcquireQuantumMemory((size_t) sun_info.length, sizeof(*sun_data)); if (sun_data == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); <S2SV_StartVul> count=(ssize_t) ReadBlob(image,sun_info.length,sun_data); <S2SV_EndVul> <S2SV_StartVul> if (count != (ssize_t) sun_info.length) <S2SV_EndVul> ThrowReaderException(CorruptImageError,""UnableToReadImageData""); sun_pixels=sun_data; bytes_per_line=0; if (sun_info.type == RT_ENCODED) { size_t height; height=sun_info.height; bytes_per_line=sun_info.width*sun_info.depth; if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) || ((bytes_per_line/sun_info.depth) != sun_info.width)) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); <S2SV_StartVul> bytes_per_line+=15; <S2SV_EndVul> bytes_per_line<<=1; if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15)) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); bytes_per_line>>=4; sun_pixels=(unsigned char *) AcquireQuantumMemory(height, bytes_per_line*sizeof(*sun_pixels)); if (sun_pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line* height); sun_data=(unsigned char *) RelinquishMagickMemory(sun_data); } p=sun_pixels; if (sun_info.depth == 1) for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-7); x+=8) { for (bit=7; bit >= 0; bit--) { SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01), q); q+=GetPixelChannels(image); } p++; } if ((image->columns % 8) != 0) { for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--) { SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),q); q+=GetPixelChannels(image); } p++; } if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0) p++; if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } else if (image->storage_class == PseudoClass) { if (bytes_per_line == 0) bytes_per_line=image->columns; length=image->rows*(image->columns+image->columns % 2); if (((sun_info.type == RT_ENCODED) && (length > (bytes_per_line*image->rows))) || ((sun_info.type != RT_ENCODED) && (length > sun_info.length))) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelIndex(image,*p++,q); q+=GetPixelChannels(image); } if ((image->columns % 2) != 0) p++; if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } else { size_t bytes_per_pixel; bytes_per_pixel=3; if (image->alpha_trait != UndefinedPixelTrait) bytes_per_pixel++; if (bytes_per_line == 0) bytes_per_line=bytes_per_pixel*image->columns; length=image->rows*(bytes_per_line+image->columns % 2); if (((sun_info.type == RT_ENCODED) && (length > (bytes_per_line*image->rows))) || ((sun_info.type != RT_ENCODED) && (length > sun_info.length))) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ScaleCharToQuantum(*p++),q); if (sun_info.type == RT_STANDARD) { SetPixelBlue(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelRed(image,ScaleCharToQuantum(*p++),q); } else { SetPixelRed(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelBlue(image,ScaleCharToQuantum(*p++),q); } if (image->colors != 0) { SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t) GetPixelRed(image,q)].red),q); SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t) GetPixelGreen(image,q)].green),q); SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t) GetPixelBlue(image,q)].blue),q); } q+=GetPixelChannels(image); } if (((bytes_per_pixel*image->columns) % 2) != 0) p++; if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } if (image->storage_class == PseudoClass) (void) SyncImage(image,exception); sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; sun_info.magic=ReadBlobMSBLong(image); if (sun_info.magic == 0x59a66a95) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while (sun_info.magic == 0x59a66a95); (void) CloseBlob(image); return(GetFirstImageInList(image)); }","- count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
- if (count != (ssize_t) sun_info.length)
- bytes_per_line+=15;
+ bytes_per_line=0;
+ if (sun_info.type == RT_ENCODED)
+ {","static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define RMT_EQUAL_RGB 1 #define RMT_NONE 0 #define RMT_RAW 2 #define RT_STANDARD 1 #define RT_ENCODED 2 #define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic, width, height, depth, length, type, maptype, maplength; } SUNInfo; Image *image; int bit; MagickBooleanType status; MagickSizeType number_pixels; register Quantum *q; register ssize_t i, x; register unsigned char *p; size_t bytes_per_line, extent, length; ssize_t count, y; SUNInfo sun_info; unsigned char *sun_data, *sun_pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info)); sun_info.magic=ReadBlobMSBLong(image); do { if (sun_info.magic != 0x59a66a95) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); sun_info.width=ReadBlobMSBLong(image); sun_info.height=ReadBlobMSBLong(image); sun_info.depth=ReadBlobMSBLong(image); sun_info.length=ReadBlobMSBLong(image); sun_info.type=ReadBlobMSBLong(image); sun_info.maptype=ReadBlobMSBLong(image); sun_info.maplength=ReadBlobMSBLong(image); extent=sun_info.height*sun_info.width; if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) && (sun_info.type != RT_FORMAT_RGB)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.depth == 0) || (sun_info.depth > 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) && (sun_info.maptype != RMT_RAW)) ThrowReaderException(CoderError,""ColormapTypeNotSupported""); image->columns=sun_info.width; image->rows=sun_info.height; image->depth=sun_info.depth <= 8 ? sun_info.depth : MAGICKCORE_QUANTUM_DEPTH; if (sun_info.depth < 24) { size_t one; image->storage_class=PseudoClass; image->colors=sun_info.maplength; one=1; if (sun_info.maptype == RMT_NONE) image->colors=one << sun_info.depth; if (sun_info.maptype == RMT_EQUAL_RGB) image->colors=sun_info.maplength/3; } switch (sun_info.maptype) { case RMT_NONE: { if (sun_info.depth < 24) { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } break; } case RMT_EQUAL_RGB: { unsigned char *sun_colormap; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors, sizeof(*sun_colormap)); if (sun_colormap == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,image->colors,sun_colormap); if (count != (ssize_t) image->colors) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].red=(MagickRealType) ScaleCharToQuantum( sun_colormap[i]); count=ReadBlob(image,image->colors,sun_colormap); if (count != (ssize_t) image->colors) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].green=(MagickRealType) ScaleCharToQuantum( sun_colormap[i]); count=ReadBlob(image,image->colors,sun_colormap); if (count != (ssize_t) image->colors) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum( sun_colormap[i]); sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap); break; } case RMT_RAW: { unsigned char *sun_colormap; sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength, sizeof(*sun_colormap)); if (sun_colormap == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,sun_info.maplength,sun_colormap); if (count != (ssize_t) sun_info.maplength) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap); break; } default: ThrowReaderException(CoderError,""ColormapTypeNotSupported""); } image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait : UndefinedPixelTrait; image->columns=sun_info.width; image->rows=sun_info.height; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); if ((sun_info.length*sizeof(*sun_data))/sizeof(*sun_data) != sun_info.length || !sun_info.length) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); number_pixels=(MagickSizeType) image->columns*image->rows; if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) && ((number_pixels*((sun_info.depth+7)/8)) > sun_info.length)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); bytes_per_line=sun_info.width*sun_info.depth; sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax( sun_info.length,bytes_per_line*sun_info.width),sizeof(*sun_data)); if (sun_data == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=(ssize_t) ReadBlob(image,sun_info.length,sun_data); if (count != (ssize_t) sun_info.length) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); sun_pixels=sun_data; bytes_per_line=0; if (sun_info.type == RT_ENCODED) { size_t height; height=sun_info.height; if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) || ((bytes_per_line/sun_info.depth) != sun_info.width)) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); bytes_per_line+=15; bytes_per_line<<=1; if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15)) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); bytes_per_line>>=4; sun_pixels=(unsigned char *) AcquireQuantumMemory(height, bytes_per_line*sizeof(*sun_pixels)); if (sun_pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line* height); sun_data=(unsigned char *) RelinquishMagickMemory(sun_data); } p=sun_pixels; if (sun_info.depth == 1) for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-7); x+=8) { for (bit=7; bit >= 0; bit--) { SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01), q); q+=GetPixelChannels(image); } p++; } if ((image->columns % 8) != 0) { for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--) { SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),q); q+=GetPixelChannels(image); } p++; } if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0) p++; if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } else if (image->storage_class == PseudoClass) { if (bytes_per_line == 0) bytes_per_line=image->columns; length=image->rows*(image->columns+image->columns % 2); if (((sun_info.type == RT_ENCODED) && (length > (bytes_per_line*image->rows))) || ((sun_info.type != RT_ENCODED) && (length > sun_info.length))) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelIndex(image,*p++,q); q+=GetPixelChannels(image); } if ((image->columns % 2) != 0) p++; if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } else { size_t bytes_per_pixel; bytes_per_pixel=3; if (image->alpha_trait != UndefinedPixelTrait) bytes_per_pixel++; if (bytes_per_line == 0) bytes_per_line=bytes_per_pixel*image->columns; length=image->rows*(bytes_per_line+image->columns % 2); if (((sun_info.type == RT_ENCODED) && (length > (bytes_per_line*image->rows))) || ((sun_info.type != RT_ENCODED) && (length > sun_info.length))) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ScaleCharToQuantum(*p++),q); if (sun_info.type == RT_STANDARD) { SetPixelBlue(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelRed(image,ScaleCharToQuantum(*p++),q); } else { SetPixelRed(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelBlue(image,ScaleCharToQuantum(*p++),q); } if (image->colors != 0) { SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t) GetPixelRed(image,q)].red),q); SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t) GetPixelGreen(image,q)].green),q); SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t) GetPixelBlue(image,q)].blue),q); } q+=GetPixelChannels(image); } if (((bytes_per_pixel*image->columns) % 2) != 0) p++; if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } if (image->storage_class == PseudoClass) (void) SyncImage(image,exception); sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; sun_info.magic=ReadBlobMSBLong(image); if (sun_info.magic == 0x59a66a95) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while (sun_info.magic == 0x59a66a95); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
216,3584----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/common.c----print_summary,"void print_summary(const MOBIData *m) { char *title = mobi_meta_get_title(m); if (title) { printf(""Title: %s\n"", title); free(title); } char *author = mobi_meta_get_author(m); if (author) { printf(""Author: %s\n"", author); free(author); } char *contributor = mobi_meta_get_contributor(m); uint32_t major = 0, minor = 0, build = 0; bool is_calibre = false; if (contributor) { const char *calibre_contributor = ""calibre (""; if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) { is_calibre = true; sscanf(contributor, ""calibre (%u.%u.%u)"", &major, &minor, &build); } else { printf(""Contributor: %s\n"", contributor); } free(contributor); } char *subject = mobi_meta_get_subject(m); if (subject) { printf(""Subject: %s\n"", subject); free(subject); } char *publisher = mobi_meta_get_publisher(m); if (publisher) { printf(""Publisher: %s\n"", publisher); free(publisher); } char *date = mobi_meta_get_publishdate(m); if (date) { printf(""Publishing date: %s\n"", date); free(date); } char *description = mobi_meta_get_description(m); if (description) { printf(""Description: %s\n"", description); free(description); } char *review = mobi_meta_get_review(m); if (review) { printf(""Review: %s\n"", review); free(review); } char *imprint = mobi_meta_get_imprint(m); if (imprint) { printf(""Imprint: %s\n"", imprint); free(imprint); } char *copyright = mobi_meta_get_copyright(m); if (copyright) { printf(""Copyright: %s\n"", copyright); free(copyright); } char *isbn = mobi_meta_get_isbn(m); if (isbn) { printf(""ISBN: %s\n"", isbn); free(isbn); } char *asin = mobi_meta_get_asin(m); if (asin) { printf(""ASIN: %s\n"", asin); free(asin); } char *language = mobi_meta_get_language(m); if (language) { printf(""Language: %s"", language); free(language); if (m->mh && m->mh->text_encoding) { uint32_t encoding = *m->mh->text_encoding; if (encoding == MOBI_CP1252) { printf("" (cp1252)""); } else if (encoding == MOBI_UTF8) { printf("" (utf8)""); } } printf(""\n""); } if (mobi_is_dictionary(m)) { printf(""Dictionary""); if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang && *m->mh->dict_input_lang && *m->mh->dict_output_lang) { const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang); const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang); <S2SV_StartVul> printf("": %s => %s"", locale_in, locale_out); <S2SV_EndVul> } printf(""\n""); } printf(""__\n""); if (strcmp(m->ph->type, ""TEXt"") == 0) { if (strcmp(m->ph->creator, ""TlDc"") == 0) { printf(""TealDoc\n""); } else { printf(""PalmDoc\n""); } } else { printf(""Mobi version: %zu"", mobi_get_fileversion(m)); if (mobi_is_hybrid(m)) { size_t version = mobi_get_fileversion(m->next); if (version != MOBI_NOTSET) { printf("" (hybrid with version %zu)"", version); } } printf(""\n""); } if (mobi_is_replica(m)) { printf(""Print Replica\n""); } if (mobi_is_encrypted(m)) { printf(""Document is encrypted\n""); } if (is_calibre) { printf(""Creator software: calibre %u.%u.%u\n"", major, minor, build); } else { MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT); if (exth) { printf(""Creator software: ""); uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size); exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR); if (exth) { major = mobi_decode_exthvalue(exth->data, exth->size); } exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR); if (exth) { minor = mobi_decode_exthvalue(exth->data, exth->size); } exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD); if (exth) { build = mobi_decode_exthvalue(exth->data, exth->size); } exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV); if (major == 2 && minor == 9 && build == 0 && exth) { char *rev = mobi_decode_exthstring(m, exth->data, exth->size); if (rev) { if (strcmp(rev, ""0730-890adc2"") == 0) { is_calibre = true; } free(rev); } } switch (creator) { case 0: printf(""mobipocket reader %u.%u.%u"", major, minor, build); break; case 1: case 101: printf(""mobigen %u.%u.%u"", major, minor, build); break; case 2: printf(""mobipocket creator %u.%u.%u"", major, minor, build); break; case 200: printf(""kindlegen %u.%u.%u (windows)"", major, minor, build); if (is_calibre) { printf("" or calibre""); } break; case 201: printf(""kindlegen %u.%u.%u (linux)"", major, minor, build); if ((major == 1 && minor == 2 && build == 33307) || (major == 2 && minor == 0 && build == 101) || is_calibre) { printf("" or calibre""); } break; case 202: printf(""kindlegen %u.%u.%u (mac)"", major, minor, build); if (is_calibre) { printf("" or calibre""); } break; default: printf(""unknown""); break; } printf(""\n""); } } }","- printf("": %s => %s"", locale_in, locale_out);
+ printf("": %s => %s"", locale_in ? locale_in : ""unknown"", locale_out ? locale_out : ""unknown"");","void print_summary(const MOBIData *m) { char *title = mobi_meta_get_title(m); if (title) { printf(""Title: %s\n"", title); free(title); } char *author = mobi_meta_get_author(m); if (author) { printf(""Author: %s\n"", author); free(author); } char *contributor = mobi_meta_get_contributor(m); uint32_t major = 0, minor = 0, build = 0; bool is_calibre = false; if (contributor) { const char *calibre_contributor = ""calibre (""; if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) { is_calibre = true; sscanf(contributor, ""calibre (%u.%u.%u)"", &major, &minor, &build); } else { printf(""Contributor: %s\n"", contributor); } free(contributor); } char *subject = mobi_meta_get_subject(m); if (subject) { printf(""Subject: %s\n"", subject); free(subject); } char *publisher = mobi_meta_get_publisher(m); if (publisher) { printf(""Publisher: %s\n"", publisher); free(publisher); } char *date = mobi_meta_get_publishdate(m); if (date) { printf(""Publishing date: %s\n"", date); free(date); } char *description = mobi_meta_get_description(m); if (description) { printf(""Description: %s\n"", description); free(description); } char *review = mobi_meta_get_review(m); if (review) { printf(""Review: %s\n"", review); free(review); } char *imprint = mobi_meta_get_imprint(m); if (imprint) { printf(""Imprint: %s\n"", imprint); free(imprint); } char *copyright = mobi_meta_get_copyright(m); if (copyright) { printf(""Copyright: %s\n"", copyright); free(copyright); } char *isbn = mobi_meta_get_isbn(m); if (isbn) { printf(""ISBN: %s\n"", isbn); free(isbn); } char *asin = mobi_meta_get_asin(m); if (asin) { printf(""ASIN: %s\n"", asin); free(asin); } char *language = mobi_meta_get_language(m); if (language) { printf(""Language: %s"", language); free(language); if (m->mh && m->mh->text_encoding) { uint32_t encoding = *m->mh->text_encoding; if (encoding == MOBI_CP1252) { printf("" (cp1252)""); } else if (encoding == MOBI_UTF8) { printf("" (utf8)""); } } printf(""\n""); } if (mobi_is_dictionary(m)) { printf(""Dictionary""); if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang && *m->mh->dict_input_lang && *m->mh->dict_output_lang) { const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang); const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang); printf("": %s => %s"", locale_in ? locale_in : ""unknown"", locale_out ? locale_out : ""unknown""); } printf(""\n""); } printf(""__\n""); if (strcmp(m->ph->type, ""TEXt"") == 0) { if (strcmp(m->ph->creator, ""TlDc"") == 0) { printf(""TealDoc\n""); } else { printf(""PalmDoc\n""); } } else { printf(""Mobi version: %zu"", mobi_get_fileversion(m)); if (mobi_is_hybrid(m)) { size_t version = mobi_get_fileversion(m->next); if (version != MOBI_NOTSET) { printf("" (hybrid with version %zu)"", version); } } printf(""\n""); } if (mobi_is_replica(m)) { printf(""Print Replica\n""); } if (mobi_is_encrypted(m)) { printf(""Document is encrypted\n""); } if (is_calibre) { printf(""Creator software: calibre %u.%u.%u\n"", major, minor, build); } else { MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT); if (exth) { printf(""Creator software: ""); uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size); exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR); if (exth) { major = mobi_decode_exthvalue(exth->data, exth->size); } exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR); if (exth) { minor = mobi_decode_exthvalue(exth->data, exth->size); } exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD); if (exth) { build = mobi_decode_exthvalue(exth->data, exth->size); } exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV); if (major == 2 && minor == 9 && build == 0 && exth) { char *rev = mobi_decode_exthstring(m, exth->data, exth->size); if (rev) { if (strcmp(rev, ""0730-890adc2"") == 0) { is_calibre = true; } free(rev); } } switch (creator) { case 0: printf(""mobipocket reader %u.%u.%u"", major, minor, build); break; case 1: case 101: printf(""mobigen %u.%u.%u"", major, minor, build); break; case 2: printf(""mobipocket creator %u.%u.%u"", major, minor, build); break; case 200: printf(""kindlegen %u.%u.%u (windows)"", major, minor, build); if (is_calibre) { printf("" or calibre""); } break; case 201: printf(""kindlegen %u.%u.%u (linux)"", major, minor, build); if ((major == 1 && minor == 2 && build == 33307) || (major == 2 && minor == 0 && build == 101) || is_calibre) { printf("" or calibre""); } break; case 202: printf(""kindlegen %u.%u.%u (mac)"", major, minor, build); if (is_calibre) { printf("" or calibre""); } break; default: printf(""unknown""); break; } printf(""\n""); } } }"
217,7276----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/my_redel.c----my_redel,"int my_redel(const char *org_name, const char *tmp_name, myf MyFlags) { int error=1; DBUG_ENTER(""my_redel""); DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s' MyFlags: %d"", org_name,tmp_name,MyFlags)); <S2SV_StartVul> if (my_copystat(org_name,tmp_name,MyFlags) < 0) <S2SV_EndVul> <S2SV_StartVul> goto end; <S2SV_EndVul> if (MyFlags & MY_REDEL_MAKE_BACKUP) { char name_buff[FN_REFLEN+20]; char ext[20]; ext[0]='-'; get_date(ext+1,2+4,(time_t) 0); strmov(strend(ext),REDEL_EXT); if (my_rename(org_name, fn_format(name_buff, org_name, """", ext, 2), MyFlags)) goto end; } else if (my_delete_allow_opened(org_name, MyFlags)) goto end; if (my_rename(tmp_name,org_name,MyFlags)) goto end; error=0; end: DBUG_RETURN(error); }","- if (my_copystat(org_name,tmp_name,MyFlags) < 0)
- goto end;
+ if (!(MyFlags & MY_REDEL_NO_COPY_STAT))
+ {
+ if (my_copystat(org_name,tmp_name,MyFlags) < 0)
+ goto end;
+ }","int my_redel(const char *org_name, const char *tmp_name, myf MyFlags) { int error=1; DBUG_ENTER(""my_redel""); DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s' MyFlags: %d"", org_name,tmp_name,MyFlags)); if (!(MyFlags & MY_REDEL_NO_COPY_STAT)) { if (my_copystat(org_name,tmp_name,MyFlags) < 0) goto end; } if (MyFlags & MY_REDEL_MAKE_BACKUP) { char name_buff[FN_REFLEN+20]; char ext[20]; ext[0]='-'; get_date(ext+1,2+4,(time_t) 0); strmov(strend(ext),REDEL_EXT); if (my_rename(org_name, fn_format(name_buff, org_name, """", ext, 2), MyFlags)) goto end; } else if (my_delete_allow_opened(org_name, MyFlags)) goto end; if (my_rename(tmp_name,org_name,MyFlags)) goto end; error=0; end: DBUG_RETURN(error); }"
218,1221----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-17805--salsa20_glue.c----encrypt,"static int encrypt(struct blkcipher_desc *desc, struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes) { struct blkcipher_walk walk; struct crypto_blkcipher *tfm = desc->tfm; struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm); int err; blkcipher_walk_init(&walk, dst, src, nbytes); err = blkcipher_walk_virt_block(desc, &walk, 64); salsa20_ivsetup(ctx, walk.iv); if (likely(walk.nbytes == nbytes)) { salsa20_encrypt_bytes(ctx, walk.src.virt.addr, walk.dst.virt.addr, nbytes); return blkcipher_walk_done(desc, &walk, 0); } while (walk.nbytes >= 64) { salsa20_encrypt_bytes(ctx, walk.src.virt.addr, walk.dst.virt.addr, walk.nbytes - (walk.nbytes % 64)); err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> if (walk.nbytes) { <S2SV_EndVul> <S2SV_StartVul> salsa20_encrypt_bytes(ctx, walk.src.virt.addr, <S2SV_EndVul> <S2SV_StartVul> walk.dst.virt.addr, walk.nbytes); <S2SV_EndVul> <S2SV_StartVul> err = blkcipher_walk_done(desc, &walk, 0); <S2SV_EndVul> } return err; }","- }
- 
- if (walk.nbytes) {
- salsa20_encrypt_bytes(ctx, walk.src.virt.addr,
- walk.dst.virt.addr, walk.nbytes);
- err = blkcipher_walk_done(desc, &walk, 0);","static int encrypt(struct blkcipher_desc *desc, struct scatterlist *dst, struct scatterlist *src, unsigned int nbytes) { struct blkcipher_walk walk; struct crypto_blkcipher *tfm = desc->tfm; struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm); int err; blkcipher_walk_init(&walk, dst, src, nbytes); err = blkcipher_walk_virt_block(desc, &walk, 64); salsa20_ivsetup(ctx, walk.iv); while (walk.nbytes >= 64) { salsa20_encrypt_bytes(ctx, walk.src.virt.addr, walk.dst.virt.addr, walk.nbytes - (walk.nbytes % 64)); err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64); } if (walk.nbytes) { salsa20_encrypt_bytes(ctx, walk.src.virt.addr, walk.dst.virt.addr, walk.nbytes); err = blkcipher_walk_done(desc, &walk, 0); } return err; }"
219,5337----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mprLib.c----queryRange,"static MprJson *queryRange(MprJson *obj, char *property, cchar *rest, MprJson *value, int flags) { MprJson *child, *result; ssize start, end; char *e, *s, ibuf[16]; int index; result = mprCreateJson(MPR_JSON_ARRAY); if (!(obj->type & MPR_JSON_ARRAY)) { return result; } <S2SV_StartVul> s = stok(property, "": \t"", &e); <S2SV_EndVul> start = (ssize) stoi(s); end = (ssize) stoi(e); if (start < 0) { start = obj->length + start; } if (end < 0) { end = obj->length + end; } for (ITERATE_JSON(obj, child, index)) { if (index < start) continue; if (index > end) break; if (rest == 0) { if (flags & MPR_JSON_REMOVE) { appendItem(result, mprRemoveJsonChild(obj, child)); } else { appendItem(result, queryLeaf(obj, itosbuf(ibuf, sizeof(ibuf), index, 10), value, flags)); } } else { appendItems(result, queryCore(child, rest, value, flags)); } } return result; }","- s = stok(property, "": \t"", &e);
+ if ((s = stok(property, "": \t"", &e)) == 0) {
+ return result;
+ }","static MprJson *queryRange(MprJson *obj, char *property, cchar *rest, MprJson *value, int flags) { MprJson *child, *result; ssize start, end; char *e, *s, ibuf[16]; int index; result = mprCreateJson(MPR_JSON_ARRAY); if (!(obj->type & MPR_JSON_ARRAY)) { return result; } if ((s = stok(property, "": \t"", &e)) == 0) { return result; } start = (ssize) stoi(s); end = (ssize) stoi(e); if (start < 0) { start = obj->length + start; } if (end < 0) { end = obj->length + end; } for (ITERATE_JSON(obj, child, index)) { if (index < start) continue; if (index > end) break; if (rest == 0) { if (flags & MPR_JSON_REMOVE) { appendItem(result, mprRemoveJsonChild(obj, child)); } else { appendItem(result, queryLeaf(obj, itosbuf(ibuf, sizeof(ibuf), index, 10), value, flags)); } } else { appendItems(result, queryCore(child, rest, value, flags)); } } return result; }"
220,3079----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nedmalloc.c----nedalloc::CallMalloc,"static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *RESTRICT mspace, size_t size, size_t alignment, unsigned flags) THROWSPEC { void *RESTRICT ret=0; #if USE_MAGIC_HEADERS size_t _alignment=alignment; size_t *_ret=0; <S2SV_StartVul> size+=alignment+3*sizeof(size_t); <S2SV_EndVul> _alignment=0; #endif #if USE_ALLOCATOR==0 ret=(flags & M2_ZERO_MEMORY) ? syscalloc(1, size) : sysmalloc(size); #elif USE_ALLOCATOR==1 ret=mspace_malloc2((mstate) mspace, size, alignment, flags); #ifndef ENABLE_FAST_HEAP_DETECTION if(ret) { mchunkptr p=mem2chunk(ret); size_t truesize=chunksize(p) - overhead_for(p); if(!leastusedaddress || (void *)((mstate) mspace)->least_addr<leastusedaddress) leastusedaddress=(void *)((mstate) mspace)->least_addr; if(!largestusedblock || truesize>largestusedblock) largestusedblock=(truesize+mparams.page_size) & ~(mparams.page_size-1); } #endif #endif if(!ret) return 0; #if DEBUG if(flags & M2_ZERO_MEMORY) { const char *RESTRICT n; for(n=(const char *)ret; n<(const char *)ret+size; n++) { assert(!*n); } } #endif #if USE_MAGIC_HEADERS _ret=(size_t *) ret; ret=(void *)(_ret+3); if(alignment) ret=(void *)(((size_t) ret+alignment-1)&~(alignment-1)); for(; _ret<(size_t *)ret-2; _ret++) *_ret=*(size_t *)""NEDMALOC""; _ret[0]=(size_t) mspace; _ret[1]=size-3*sizeof(size_t); #endif return ret; }","- size+=alignment+3*sizeof(size_t);
+ size_t bytes=size+alignment+3*sizeof(size_t);
+ if(bytes<size)
+ return 0;
+ size=bytes;","static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *RESTRICT mspace, size_t size, size_t alignment, unsigned flags) THROWSPEC { void *RESTRICT ret=0; #if USE_MAGIC_HEADERS size_t _alignment=alignment; size_t *_ret=0; size_t bytes=size+alignment+3*sizeof(size_t); if(bytes<size) return 0; size=bytes; _alignment=0; #endif #if USE_ALLOCATOR==0 ret=(flags & M2_ZERO_MEMORY) ? syscalloc(1, size) : sysmalloc(size); #elif USE_ALLOCATOR==1 ret=mspace_malloc2((mstate) mspace, size, alignment, flags); #ifndef ENABLE_FAST_HEAP_DETECTION if(ret) { mchunkptr p=mem2chunk(ret); size_t truesize=chunksize(p) - overhead_for(p); if(!leastusedaddress || (void *)((mstate) mspace)->least_addr<leastusedaddress) leastusedaddress=(void *)((mstate) mspace)->least_addr; if(!largestusedblock || truesize>largestusedblock) largestusedblock=(truesize+mparams.page_size) & ~(mparams.page_size-1); } #endif #endif if(!ret) return 0; #if DEBUG if(flags & M2_ZERO_MEMORY) { const char *RESTRICT n; for(n=(const char *)ret; n<(const char *)ret+size; n++) { assert(!*n); } } #endif #if USE_MAGIC_HEADERS _ret=(size_t *) ret; ret=(void *)(_ret+3); if(alignment) ret=(void *)(((size_t) ret+alignment-1)&~(alignment-1)); for(; _ret<(size_t *)ret-2; _ret++) *_ret=*(size_t *)""NEDMALOC""; _ret[0]=(size_t) mspace; _ret[1]=size-3*sizeof(size_t); #endif return ret; }"
221,2319----CWE-824----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-11498--dsdiff.c----ParseDsdiffHeaderConfig,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t infilesize, total_samples; DFFFileHeader dff_file_header; DFFChunkHeader dff_chunk_header; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&dff_file_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) || bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1 WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) { error_line (""%s is not a valid .DFF file (by total size)!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize); #endif while (1) { if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) || bcount != sizeof (DFFChunkHeader)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (debug_logging_mode) error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize); if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) { uint32_t version; if (dff_chunk_header.ckDataSize != sizeof (version) || !DoReadFile (infile, &version, sizeof (version), &bcount) || bcount != sizeof (version)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &version, sizeof (version))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&version, ""L""); if (debug_logging_mode) error_line (""dsdiff file version = 0x%08x"", version); } else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) { char *prop_chunk; if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize); prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize); if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) || bcount != dff_chunk_header.ckDataSize) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (prop_chunk); return WAVPACK_SOFT_ERROR; } if (!strncmp (prop_chunk, ""SND "", 4)) { char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize; uint16_t numChannels = 0, chansSpecified, chanMask = 0; uint32_t sampleRate; <S2SV_StartVul> while (eptr - cptr >= sizeof (dff_chunk_header)) { <S2SV_EndVul> memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header)); cptr += sizeof (dff_chunk_header); WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) { if (!strncmp (dff_chunk_header.ckID, ""FS "", 4) && dff_chunk_header.ckDataSize == 4) { memcpy (&sampleRate, cptr, sizeof (sampleRate)); WavpackBigEndianToNative (&sampleRate, ""L""); cptr += dff_chunk_header.ckDataSize; if (debug_logging_mode) error_line (""got sample rate of %u Hz"", sampleRate); } else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) { memcpy (&numChannels, cptr, sizeof (numChannels)); WavpackBigEndianToNative (&numChannels, ""S""); cptr += sizeof (numChannels); chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4; if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } while (chansSpecified--) { if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4)) chanMask |= 0x1; else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4)) chanMask |= 0x2; else if (!strncmp (cptr, ""LS "", 4)) chanMask |= 0x10; else if (!strncmp (cptr, ""RS "", 4)) chanMask |= 0x20; else if (!strncmp (cptr, ""C "", 4)) chanMask |= 0x4; else if (!strncmp (cptr, ""LFE "", 4)) chanMask |= 0x8; else if (debug_logging_mode) error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]); cptr += 4; } if (debug_logging_mode) error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask); } else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) { if (strncmp (cptr, ""DSD "", 4)) { error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"", cptr [0], cptr [1], cptr [2], cptr [3]); free (prop_chunk); return WAVPACK_SOFT_ERROR; } cptr += dff_chunk_header.ckDataSize; } else { if (debug_logging_mode) error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); cptr += dff_chunk_header.ckDataSize; } } else { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } } if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this DSDIFF file already has channel order information!""); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (chanMask) config->channel_mask = chanMask; config->bits_per_sample = 8; config->bytes_per_sample = 1; config->num_channels = numChannels; config->sample_rate = sampleRate / 8; config->qmode |= QMODE_DSD_MSB_FIRST; } else if (debug_logging_mode) error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"", prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize); free (prop_chunk); } else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) { if (!config->num_channels) { error_line (""%s is not a valid .DFF file!"", infilename); <S2SV_StartVul> return WAVPACK_SOFT_ERROR; <S2SV_EndVul> } total_samples = dff_chunk_header.ckDataSize / config->num_channels; break; } else { int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1); char *buff; if (bytes_to_copy < 0 || bytes_to_copy > 4194304) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (debug_logging_mode) error_line (""setting configuration with %lld samples"", total_samples); if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }","- while (eptr - cptr >= sizeof (dff_chunk_header)) {
- return WAVPACK_SOFT_ERROR;
+ while (eptr - cptr >= sizeof (dff_chunk_header)) {
+ return WAVPACK_SOFT_ERROR;","int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t infilesize, total_samples; DFFFileHeader dff_file_header; DFFChunkHeader dff_chunk_header; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&dff_file_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) || bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1 WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) { error_line (""%s is not a valid .DFF file (by total size)!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize); #endif while (1) { if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) || bcount != sizeof (DFFChunkHeader)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (debug_logging_mode) error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize); if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) { uint32_t version; if (dff_chunk_header.ckDataSize != sizeof (version) || !DoReadFile (infile, &version, sizeof (version), &bcount) || bcount != sizeof (version)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &version, sizeof (version))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&version, ""L""); if (debug_logging_mode) error_line (""dsdiff file version = 0x%08x"", version); } else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) { char *prop_chunk; if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize); prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize); if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) || bcount != dff_chunk_header.ckDataSize) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (prop_chunk); return WAVPACK_SOFT_ERROR; } if (!strncmp (prop_chunk, ""SND "", 4)) { char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize; uint16_t numChannels = 0, chansSpecified, chanMask = 0; uint32_t sampleRate = 0; while (eptr - cptr >= sizeof (dff_chunk_header)) { memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header)); cptr += sizeof (dff_chunk_header); WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) { if (!strncmp (dff_chunk_header.ckID, ""FS "", 4) && dff_chunk_header.ckDataSize == 4) { memcpy (&sampleRate, cptr, sizeof (sampleRate)); WavpackBigEndianToNative (&sampleRate, ""L""); cptr += dff_chunk_header.ckDataSize; if (debug_logging_mode) error_line (""got sample rate of %u Hz"", sampleRate); } else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) { memcpy (&numChannels, cptr, sizeof (numChannels)); WavpackBigEndianToNative (&numChannels, ""S""); cptr += sizeof (numChannels); chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4; if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } while (chansSpecified--) { if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4)) chanMask |= 0x1; else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4)) chanMask |= 0x2; else if (!strncmp (cptr, ""LS "", 4)) chanMask |= 0x10; else if (!strncmp (cptr, ""RS "", 4)) chanMask |= 0x20; else if (!strncmp (cptr, ""C "", 4)) chanMask |= 0x4; else if (!strncmp (cptr, ""LFE "", 4)) chanMask |= 0x8; else if (debug_logging_mode) error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]); cptr += 4; } if (debug_logging_mode) error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask); } else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) { if (strncmp (cptr, ""DSD "", 4)) { error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"", cptr [0], cptr [1], cptr [2], cptr [3]); free (prop_chunk); return WAVPACK_SOFT_ERROR; } cptr += dff_chunk_header.ckDataSize; } else { if (debug_logging_mode) error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); cptr += dff_chunk_header.ckDataSize; } } else { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } } if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this DSDIFF file already has channel order information!""); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (chanMask) config->channel_mask = chanMask; config->bits_per_sample = 8; config->bytes_per_sample = 1; config->num_channels = numChannels; config->sample_rate = sampleRate / 8; config->qmode |= QMODE_DSD_MSB_FIRST; } else if (debug_logging_mode) error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"", prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize); free (prop_chunk); } else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) { if (!config->num_channels || !config->sample_rate) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } total_samples = dff_chunk_header.ckDataSize / config->num_channels; break; } else { int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1); char *buff; if (bytes_to_copy < 0 || bytes_to_copy > 4194304) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (debug_logging_mode) error_line (""setting configuration with %lld samples"", total_samples); if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }"
222,3854----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/config.c----parseFileInner,"static int parseFileInner(MaState *state, cchar *path) { MaDirective *directive; char *tok, *key, *line, *value; assert(state); assert(path && *path); if (openConfig(state, path) < 0) { return MPR_ERR_CANT_OPEN; } for (state->lineNumber = 1; state->file && (line = mprReadLine(state->file, 0, NULL)) != 0; state->lineNumber++) { for (tok = line; isspace((uchar) *tok); tok++) ; if (*tok == '\0' || *tok == '#') { continue; } state->key = 0; <S2SV_StartVul> key = getDirective(line, &value); <S2SV_EndVul> if (!state->enabled) { if (key[0] != '<') { continue; } } if ((directive = mprLookupKey(directives, key)) == 0) { mprLog(""error appweb config"", 0, ""Unknown directive \""%s\"". At line %d in %s"", key, state->lineNumber, state->filename); return MPR_ERR_BAD_SYNTAX; } state->key = key; mprPauseGC(); if ((*directive)(state, key, value) < 0) { mprResumeGC(); mprLog(""error appweb config"", 0, ""Error with directive \""%s\"". At line %d in %s"", state->key, state->lineNumber, state->filename); return MPR_ERR_BAD_SYNTAX; } mprResumeGC(); mprYield(0); state = state->top->current; } if (state->prev && state->file == state->prev->file) { mprLog(""error appweb config"", 0, ""Unclosed directives in %s"", state->filename); while (state->prev && state->file == state->prev->file) { state = state->prev; } } mprCloseFile(state->file); return 0; }","- key = getDirective(line, &value);
+ if ((key = getDirective(line, &value)) == 0) {
+ continue;
+ }","static int parseFileInner(MaState *state, cchar *path) { MaDirective *directive; char *tok, *key, *line, *value; assert(state); assert(path && *path); if (openConfig(state, path) < 0) { return MPR_ERR_CANT_OPEN; } for (state->lineNumber = 1; state->file && (line = mprReadLine(state->file, 0, NULL)) != 0; state->lineNumber++) { for (tok = line; isspace((uchar) *tok); tok++) ; if (*tok == '\0' || *tok == '#') { continue; } state->key = 0; if ((key = getDirective(line, &value)) == 0) { continue; } if (!state->enabled) { if (key[0] != '<') { continue; } } if ((directive = mprLookupKey(directives, key)) == 0) { mprLog(""error appweb config"", 0, ""Unknown directive \""%s\"". At line %d in %s"", key, state->lineNumber, state->filename); return MPR_ERR_BAD_SYNTAX; } state->key = key; mprPauseGC(); if ((*directive)(state, key, value) < 0) { mprResumeGC(); mprLog(""error appweb config"", 0, ""Error with directive \""%s\"". At line %d in %s"", state->key, state->lineNumber, state->filename); return MPR_ERR_BAD_SYNTAX; } mprResumeGC(); mprYield(0); state = state->top->current; } if (state->prev && state->file == state->prev->file) { mprLog(""error appweb config"", 0, ""Unclosed directives in %s"", state->filename); while (state->prev && state->file == state->prev->file) { state = state->prev; } } mprCloseFile(state->file); return 0; }"
223,3860----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/php_mbregex.c----_php_mb_regex_ereg_replace_exec,"static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable) { zval **arg_pattern_zval; char *arg_pattern; int arg_pattern_len; char *replace; int replace_len; zend_fcall_info arg_replace_fci; zend_fcall_info_cache arg_replace_fci_cache; char *string; int string_len; char *p; php_mb_regex_t *re; OnigSyntaxType *syntax; OnigRegion *regs = NULL; smart_str out_buf = { 0 }; smart_str eval_buf = { 0 }; smart_str *pbuf; int i, err, eval, n; OnigUChar *pos; OnigUChar *string_lim; char *description = NULL; char pat_buf[2]; const mbfl_encoding *enc; { const char *current_enc_name; current_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype)); if (current_enc_name == NULL || (enc = mbfl_name2encoding(current_enc_name)) == NULL) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error""); RETURN_FALSE; } } eval = 0; { char *option_str = NULL; int option_str_len = 0; if (!is_callable) { if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zss|s"", &arg_pattern_zval, &replace, &replace_len, &string, &string_len, &option_str, &option_str_len) == FAILURE) { RETURN_FALSE; } } else { if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zfs|s"", &arg_pattern_zval, &arg_replace_fci, &arg_replace_fci_cache, &string, &string_len, &option_str, &option_str_len) == FAILURE) { RETURN_FALSE; } } if (option_str != NULL) { _php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval); } else { options |= MBREX(regex_default_options); syntax = MBREX(regex_default_syntax); } } if (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) { arg_pattern = Z_STRVAL_PP(arg_pattern_zval); arg_pattern_len = Z_STRLEN_PP(arg_pattern_zval); } else { convert_to_long_ex(arg_pattern_zval); <S2SV_StartVul> pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval); <S2SV_EndVul> pat_buf[1] = '\0'; arg_pattern = pat_buf; <S2SV_StartVul> arg_pattern_len = 1; <S2SV_EndVul> } re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC); if (re == NULL) { RETURN_FALSE; } if (eval || is_callable) { pbuf = &eval_buf; description = zend_make_compiled_string_description(""mbregex replace"" TSRMLS_CC); } else { pbuf = &out_buf; description = NULL; } if (is_callable) { if (eval) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Option 'e' cannot be used with replacement callback""); RETURN_FALSE; } } err = 0; pos = (OnigUChar *)string; string_lim = (OnigUChar*)(string + string_len); regs = onig_region_new(); while (err >= 0) { err = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0); if (err <= -2) { OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN]; onig_error_code_to_str(err_str, err); php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in php_mbereg_replace_exec(): %s"", err_str); break; } if (err >= 0) { #if moriyoshi_0 if (regs->beg[0] == regs->end[0]) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty regular expression""); break; } #endif smart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos)); if (!is_callable) { i = 0; p = replace; while (i < replace_len) { int fwd = (int) php_mb_mbchar_bytes_ex(p, enc); n = -1; if ((replace_len - i) >= 2 && fwd == 1 && p[0] == '\\' && p[1] >= '0' && p[1] <= '9') { n = p[1] - '0'; } if (n >= 0 && n < regs->num_regs) { if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) { smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]); } p += 2; i += 2; } else { smart_str_appendl(pbuf, p, fwd); p += fwd; i += fwd; } } } if (eval) { zval v; smart_str_0(&eval_buf); if (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) { efree(description); php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, eval_buf.c); } convert_to_string(&v); smart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v)); eval_buf.len = 0; zval_dtor(&v); } else if (is_callable) { <S2SV_StartVul> zval *retval_ptr; <S2SV_EndVul> zval **args[1]; zval *subpats; int i; MAKE_STD_ZVAL(subpats); array_init(subpats); for (i = 0; i < regs->num_regs; i++) { add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1); <S2SV_StartVul> } <S2SV_EndVul> args[0] = &subpats; smart_str_0(&eval_buf); arg_replace_fci.param_count = 1; arg_replace_fci.params = args; arg_replace_fci.retval_ptr_ptr = &retval_ptr; <S2SV_StartVul> if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) { <S2SV_EndVul> convert_to_string_ex(&retval_ptr); smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr)); eval_buf.len = 0; zval_ptr_dtor(&retval_ptr); } else { <S2SV_StartVul> efree(description); <S2SV_EndVul> if (!EG(exception)) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function""); } } zval_ptr_dtor(&subpats); } n = regs->end[0]; if ((pos - (OnigUChar *)string) < n) { pos = (OnigUChar *)string + n; } else { if (pos < string_lim) { <S2SV_StartVul> smart_str_appendl(&out_buf, pos, 1); <S2SV_EndVul> } pos++; } } else { if (string_lim - pos > 0) { smart_str_appendl(&out_buf, pos, string_lim - pos); } } onig_region_free(regs, 0); } if (description) { efree(description); } if (regs != NULL) { onig_region_free(regs, 1); } smart_str_free(&eval_buf); if (err <= -2) { <S2SV_StartVul> smart_str_free(&out_buf); <S2SV_EndVul> RETVAL_FALSE; } else { smart_str_appendc(&out_buf, '\0'); RETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0); } }","- pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
- arg_pattern_len = 1;
- zval *retval_ptr;
- }
- if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
- efree(description);
- smart_str_appendl(&out_buf, pos, 1);
- smart_str_free(&out_buf);
+ pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);
+ arg_pattern_len = 1;
+ zval *retval_ptr = NULL;
+ }
+ if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {
+ smart_str_appendl(&out_buf, pos, 1);
+ smart_str_free(&out_buf);","static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable) { zval **arg_pattern_zval; char *arg_pattern; int arg_pattern_len; char *replace; int replace_len; zend_fcall_info arg_replace_fci; zend_fcall_info_cache arg_replace_fci_cache; char *string; int string_len; char *p; php_mb_regex_t *re; OnigSyntaxType *syntax; OnigRegion *regs = NULL; smart_str out_buf = { 0 }; smart_str eval_buf = { 0 }; smart_str *pbuf; int i, err, eval, n; OnigUChar *pos; OnigUChar *string_lim; char *description = NULL; char pat_buf[2]; const mbfl_encoding *enc; { const char *current_enc_name; current_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype)); if (current_enc_name == NULL || (enc = mbfl_name2encoding(current_enc_name)) == NULL) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error""); RETURN_FALSE; } } eval = 0; { char *option_str = NULL; int option_str_len = 0; if (!is_callable) { if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zss|s"", &arg_pattern_zval, &replace, &replace_len, &string, &string_len, &option_str, &option_str_len) == FAILURE) { RETURN_FALSE; } } else { if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zfs|s"", &arg_pattern_zval, &arg_replace_fci, &arg_replace_fci_cache, &string, &string_len, &option_str, &option_str_len) == FAILURE) { RETURN_FALSE; } } if (option_str != NULL) { _php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval); } else { options |= MBREX(regex_default_options); syntax = MBREX(regex_default_syntax); } } if (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) { arg_pattern = Z_STRVAL_PP(arg_pattern_zval); arg_pattern_len = Z_STRLEN_PP(arg_pattern_zval); } else { convert_to_long_ex(arg_pattern_zval); pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval); pat_buf[1] = '\0'; arg_pattern = pat_buf; arg_pattern_len = 1; } re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC); if (re == NULL) { RETURN_FALSE; } if (eval || is_callable) { pbuf = &eval_buf; description = zend_make_compiled_string_description(""mbregex replace"" TSRMLS_CC); } else { pbuf = &out_buf; description = NULL; } if (is_callable) { if (eval) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Option 'e' cannot be used with replacement callback""); RETURN_FALSE; } } err = 0; pos = (OnigUChar *)string; string_lim = (OnigUChar*)(string + string_len); regs = onig_region_new(); while (err >= 0) { err = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0); if (err <= -2) { OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN]; onig_error_code_to_str(err_str, err); php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in php_mbereg_replace_exec(): %s"", err_str); break; } if (err >= 0) { #if moriyoshi_0 if (regs->beg[0] == regs->end[0]) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty regular expression""); break; } #endif smart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos)); if (!is_callable) { i = 0; p = replace; while (i < replace_len) { int fwd = (int) php_mb_mbchar_bytes_ex(p, enc); n = -1; if ((replace_len - i) >= 2 && fwd == 1 && p[0] == '\\' && p[1] >= '0' && p[1] <= '9') { n = p[1] - '0'; } if (n >= 0 && n < regs->num_regs) { if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) { smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]); } p += 2; i += 2; } else { smart_str_appendl(pbuf, p, fwd); p += fwd; i += fwd; } } } if (eval) { zval v; smart_str_0(&eval_buf); if (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) { efree(description); php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, eval_buf.c); } convert_to_string(&v); smart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v)); eval_buf.len = 0; zval_dtor(&v); } else if (is_callable) { zval *retval_ptr = NULL; zval **args[1]; zval *subpats; int i; MAKE_STD_ZVAL(subpats); array_init(subpats); for (i = 0; i < regs->num_regs; i++) { add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1); } args[0] = &subpats; smart_str_0(&eval_buf); arg_replace_fci.param_count = 1; arg_replace_fci.params = args; arg_replace_fci.retval_ptr_ptr = &retval_ptr; if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) { convert_to_string_ex(&retval_ptr); smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr)); eval_buf.len = 0; zval_ptr_dtor(&retval_ptr); } else { if (!EG(exception)) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function""); } } zval_ptr_dtor(&subpats); } n = regs->end[0]; if ((pos - (OnigUChar *)string) < n) { pos = (OnigUChar *)string + n; } else { if (pos < string_lim) { smart_str_appendl(&out_buf, pos, 1); } pos++; } } else { if (string_lim - pos > 0) { smart_str_appendl(&out_buf, pos, string_lim - pos); } } onig_region_free(regs, 0); } if (description) { efree(description); } if (regs != NULL) { onig_region_free(regs, 1); } smart_str_free(&eval_buf); if (err <= -2) { smart_str_free(&out_buf); RETVAL_FALSE; } else { smart_str_appendc(&out_buf, '\0'); RETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0); } }"
224,3039----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/secure_enclave.c----trustedGetEncryptedSecretShareAES,"<S2SV_StartVul> void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len, <S2SV_EndVul> char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) { LOG_INFO(__FUNCTION__); INIT_ERROR_STATE <S2SV_StartVul> uint32_t enc_len; <S2SV_EndVul> int status; CHECK_STATE(encrypted_skey); CHECK_STATE(result_str); CHECK_STATE(s_shareG2); CHECK_STATE(pub_keyB); LOG_DEBUG(__FUNCTION__); <S2SV_StartVul> SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN); <S2SV_EndVul> SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN); trustedGenerateEcdsaKeyAES(&status, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y); CHECK_STATUS(""trustedGenerateEcdsaKeyAES failed""); <S2SV_StartVul> status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN); <S2SV_EndVul> skey[ECDSA_SKEY_LEN - 1] = 0; CHECK_STATUS2(""AES_decrypt failed (in trustedGetEncryptedSecretShareAES) with status %d""); *dec_len = enc_len; <S2SV_StartVul> SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN); <S2SV_EndVul> status = gen_session_key(skey, pub_keyB, common_key); CHECK_STATUS(""gen_session_key failed"") <S2SV_StartVul> SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN); <S2SV_EndVul> status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind); CHECK_STATUS(""calc secret share failed"") status = calc_secret_shareG2(s_share, s_shareG2); CHECK_STATUS(""invalid decr secret share""); <S2SV_StartVul> SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN); <S2SV_EndVul> status=xor_encrypt(common_key, s_share, cypher); CHECK_STATUS(""xor_encrypt failed"") strncpy(result_str, cypher, strlen(cypher)); strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x)); strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y)); SET_SUCCESS clean: ; LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }","- void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint32_t *dec_len,
- uint32_t enc_len;
- SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);
- status = AES_decrypt(encrypted_skey, enc_len, skey, ECDSA_SKEY_LEN);
- SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);
- SAFE_CHAR_BUF(s_share, ECDSA_SKEY_LEN);
- SAFE_CHAR_BUF(cypher, ECDSA_SKEY_LEN);
+ void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len,
+ uint64_t enc_len;
+ SAFE_CHAR_BUF(skey, BUF_LEN);
+ status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN);
+ SAFE_CHAR_BUF(common_key, BUF_LEN);
+ SAFE_CHAR_BUF(s_share, BUF_LEN);
+ SAFE_CHAR_BUF(cypher, BUF_LEN);","void trustedGetEncryptedSecretShareAES(int *errStatus, char *errString, uint8_t *encrypted_skey, uint64_t *dec_len, char *result_str, char *s_shareG2, char *pub_keyB, uint8_t _t, uint8_t _n, uint8_t ind) { LOG_INFO(__FUNCTION__); INIT_ERROR_STATE uint64_t enc_len; int status; CHECK_STATE(encrypted_skey); CHECK_STATE(result_str); CHECK_STATE(s_shareG2); CHECK_STATE(pub_keyB); LOG_DEBUG(__FUNCTION__); SAFE_CHAR_BUF(skey, BUF_LEN); SAFE_CHAR_BUF(pub_key_x, BUF_LEN);SAFE_CHAR_BUF(pub_key_y, BUF_LEN); trustedGenerateEcdsaKeyAES(&status, errString, encrypted_skey, &enc_len, pub_key_x, pub_key_y); CHECK_STATUS(""trustedGenerateEcdsaKeyAES failed""); status = AES_decrypt(encrypted_skey, enc_len, skey, BUF_LEN); skey[ECDSA_SKEY_LEN - 1] = 0; CHECK_STATUS2(""AES_decrypt failed (in trustedGetEncryptedSecretShareAES) with status %d""); *dec_len = enc_len; SAFE_CHAR_BUF(common_key, BUF_LEN); status = gen_session_key(skey, pub_keyB, common_key); CHECK_STATUS(""gen_session_key failed"") SAFE_CHAR_BUF(s_share, BUF_LEN); status = calc_secret_share(getThreadLocalDecryptedDkgPoly(), s_share, _t, _n, ind); CHECK_STATUS(""calc secret share failed"") status = calc_secret_shareG2(s_share, s_shareG2); CHECK_STATUS(""invalid decr secret share""); SAFE_CHAR_BUF(cypher, BUF_LEN); status=xor_encrypt(common_key, s_share, cypher); CHECK_STATUS(""xor_encrypt failed"") strncpy(result_str, cypher, strlen(cypher)); strncpy(result_str + strlen(cypher), pub_key_x, strlen(pub_key_x)); strncpy(result_str + strlen(pub_key_x) + strlen(pub_key_y), pub_key_y, strlen(pub_key_y)); SET_SUCCESS clean: ; LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }"
225,1095----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2545--timer.c----snd_timer_interrupt,"void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left) { struct snd_timer_instance *ti, *ts, *tmp; unsigned long resolution, ticks; struct list_head *p, *ack_list_head; unsigned long flags; int use_tasklet = 0; if (timer == NULL) return; spin_lock_irqsave(&timer->lock, flags); if (timer->hw.c_resolution) resolution = timer->hw.c_resolution(timer); else resolution = timer->hw.resolution; list_for_each_entry_safe(ti, tmp, &timer->active_list_head, active_list) { if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING)) continue; ti->pticks += ticks_left; ti->resolution = resolution; if (ti->cticks < ticks_left) ti->cticks = 0; else ti->cticks -= ticks_left; if (ti->cticks) continue; if (ti->flags & SNDRV_TIMER_IFLG_AUTO) { ti->cticks = ti->ticks; } else { ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING; if (--timer->running) <S2SV_StartVul> list_del(&ti->active_list); <S2SV_EndVul> } if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) || (ti->flags & SNDRV_TIMER_IFLG_FAST)) ack_list_head = &timer->ack_list_head; else ack_list_head = &timer->sack_list_head; if (list_empty(&ti->ack_list)) list_add_tail(&ti->ack_list, ack_list_head); list_for_each_entry(ts, &ti->slave_active_head, active_list) { ts->pticks = ti->pticks; ts->resolution = resolution; if (list_empty(&ts->ack_list)) list_add_tail(&ts->ack_list, ack_list_head); } } if (timer->flags & SNDRV_TIMER_FLG_RESCHED) snd_timer_reschedule(timer, timer->sticks); if (timer->running) { if (timer->hw.flags & SNDRV_TIMER_HW_STOP) { timer->hw.stop(timer); timer->flags |= SNDRV_TIMER_FLG_CHANGE; } if (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) || (timer->flags & SNDRV_TIMER_FLG_CHANGE)) { timer->flags &= ~SNDRV_TIMER_FLG_CHANGE; timer->hw.start(timer); } } else { timer->hw.stop(timer); } while (!list_empty(&timer->ack_list_head)) { p = timer->ack_list_head.next; ti = list_entry(p, struct snd_timer_instance, ack_list); list_del_init(p); ticks = ti->pticks; ti->pticks = 0; ti->flags |= SNDRV_TIMER_IFLG_CALLBACK; spin_unlock(&timer->lock); if (ti->callback) ti->callback(ti, resolution, ticks); spin_lock(&timer->lock); ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK; } use_tasklet = !list_empty(&timer->sack_list_head); spin_unlock_irqrestore(&timer->lock, flags); if (use_tasklet) tasklet_schedule(&timer->task_queue); }","- list_del(&ti->active_list);
+ list_del_init(&ti->active_list);","void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left) { struct snd_timer_instance *ti, *ts, *tmp; unsigned long resolution, ticks; struct list_head *p, *ack_list_head; unsigned long flags; int use_tasklet = 0; if (timer == NULL) return; spin_lock_irqsave(&timer->lock, flags); if (timer->hw.c_resolution) resolution = timer->hw.c_resolution(timer); else resolution = timer->hw.resolution; list_for_each_entry_safe(ti, tmp, &timer->active_list_head, active_list) { if (!(ti->flags & SNDRV_TIMER_IFLG_RUNNING)) continue; ti->pticks += ticks_left; ti->resolution = resolution; if (ti->cticks < ticks_left) ti->cticks = 0; else ti->cticks -= ticks_left; if (ti->cticks) continue; if (ti->flags & SNDRV_TIMER_IFLG_AUTO) { ti->cticks = ti->ticks; } else { ti->flags &= ~SNDRV_TIMER_IFLG_RUNNING; if (--timer->running) list_del_init(&ti->active_list); } if ((timer->hw.flags & SNDRV_TIMER_HW_TASKLET) || (ti->flags & SNDRV_TIMER_IFLG_FAST)) ack_list_head = &timer->ack_list_head; else ack_list_head = &timer->sack_list_head; if (list_empty(&ti->ack_list)) list_add_tail(&ti->ack_list, ack_list_head); list_for_each_entry(ts, &ti->slave_active_head, active_list) { ts->pticks = ti->pticks; ts->resolution = resolution; if (list_empty(&ts->ack_list)) list_add_tail(&ts->ack_list, ack_list_head); } } if (timer->flags & SNDRV_TIMER_FLG_RESCHED) snd_timer_reschedule(timer, timer->sticks); if (timer->running) { if (timer->hw.flags & SNDRV_TIMER_HW_STOP) { timer->hw.stop(timer); timer->flags |= SNDRV_TIMER_FLG_CHANGE; } if (!(timer->hw.flags & SNDRV_TIMER_HW_AUTO) || (timer->flags & SNDRV_TIMER_FLG_CHANGE)) { timer->flags &= ~SNDRV_TIMER_FLG_CHANGE; timer->hw.start(timer); } } else { timer->hw.stop(timer); } while (!list_empty(&timer->ack_list_head)) { p = timer->ack_list_head.next; ti = list_entry(p, struct snd_timer_instance, ack_list); list_del_init(p); ticks = ti->pticks; ti->pticks = 0; ti->flags |= SNDRV_TIMER_IFLG_CALLBACK; spin_unlock(&timer->lock); if (ti->callback) ti->callback(ti, resolution, ticks); spin_lock(&timer->lock); ti->flags &= ~SNDRV_TIMER_IFLG_CALLBACK; } use_tasklet = !list_empty(&timer->sack_list_head); spin_unlock_irqrestore(&timer->lock, flags); if (use_tasklet) tasklet_schedule(&timer->task_queue); }"
226,5786----CWE-835----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/avi_player.c----pjmedia_avi_player_create_streams,"pjmedia_avi_player_create_streams(pj_pool_t *pool, const char *filename, unsigned options, pjmedia_avi_streams **p_streams) { pjmedia_avi_hdr avi_hdr; struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS]; pj_off_t pos; unsigned i, nstr = 0; pj_status_t status = PJ_SUCCESS; PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL); if (!pj_file_exists(filename)) { return PJ_ENOTFOUND; } fport[0] = create_avi_port(pool); if (!fport[0]) { return PJ_ENOMEM; } fport[0]->fsize = pj_file_size(filename); if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + sizeof(strl_hdr_t)) { return PJMEDIA_EINVALIMEDIATYPE; } status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd); if (status != PJ_SUCCESS) return status; status = file_read(fport[0]->fd, &avi_hdr, sizeof(riff_hdr_t) + sizeof(avih_hdr_t)); if (status != PJ_SUCCESS) goto on_error; if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) || !COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) || !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) || !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) || !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG)) { status = PJMEDIA_EINVALIMEDIATYPE; goto on_error; } PJ_LOG(5, (THIS_FILE, ""The AVI file has %d streams."", avi_hdr.avih_hdr.num_streams)); if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) { status = PJMEDIA_EAVIUNSUPP; goto on_error; } if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX || avi_hdr.avih_hdr.pad > 1) { PJ_LOG(3, (THIS_FILE, ""Warning!!! Possibly unsupported AVI format: "" ""flags:%d, pad:%d"", avi_hdr.avih_hdr.flags, avi_hdr.avih_hdr.pad)); } for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) { pj_size_t elem = 0; <S2SV_StartVul> pj_ssize_t size_to_read; <S2SV_EndVul> status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i], sizeof(strl_hdr_t)); if (status != PJ_SUCCESS) goto on_error; elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_VIDS_TAG) ? sizeof(strf_video_hdr_t) : COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_AUDS_TAG) ? sizeof(strf_audio_hdr_t) : 0; status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i], elem, 0); if (status != PJ_SUCCESS) goto on_error; if (elem == sizeof(strf_video_hdr_t)) data_to_host2(&avi_hdr.strf_hdr[i], sizeof(strf_video_hdr_sizes)/ sizeof(strf_video_hdr_sizes[0]), strf_video_hdr_sizes); else if (elem == sizeof(strf_audio_hdr_t)) data_to_host2(&avi_hdr.strf_hdr[i], sizeof(strf_audio_hdr_sizes)/ sizeof(strf_audio_hdr_sizes[0]), strf_audio_hdr_sizes); size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) - 8) - elem; status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz + sizeof(riff_hdr_t) + 8, PJ_SEEK_SET); if (status != PJ_SUCCESS) { goto on_error; } do { pjmedia_avi_subchunk ch; int read = 0; status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk)); if (status != PJ_SUCCESS) { goto on_error; } if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG)) { read = 4; status = file_read(fport[0]->fd, &ch, read); if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG)) break; } <S2SV_StartVul> status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR); <S2SV_EndVul> if (status != PJ_SUCCESS) { goto on_error; } } while(1); status = pj_file_getpos(fport[0]->fd, &pos); if (status != PJ_SUCCESS) goto on_error; for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) { pjmedia_format_id fmt_id; if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_VIDS_TAG) && !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_AUDS_TAG)) || avi_hdr.strl_hdr[i].flags & AVISF_DISABLED) { continue; } if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_VIDS_TAG)) { int j; if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) { PJ_LOG(4, (THIS_FILE, ""Unsupported video stream"")); continue; } fmt_id = avi_hdr.strl_hdr[i].codec; for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) { if (fmt_id == avi_fmts[j].fmt_id) { if (avi_fmts[j].eff_fmt_id) fmt_id = avi_fmts[j].eff_fmt_id; break; } } if (j < 0) { PJ_LOG(4, (THIS_FILE, ""Unsupported video stream"")); continue; } } else { strf_audio_hdr_t *hdr = (strf_audio_hdr_t*) &avi_hdr.strf_hdr[i].strf_audio_hdr; if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM && hdr->bits_per_sample == 16) { fmt_id = PJMEDIA_FORMAT_PCM; } else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) { fmt_id = PJMEDIA_FORMAT_PCMA; } else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) { fmt_id = PJMEDIA_FORMAT_PCMU; } else { PJ_LOG(4, (THIS_FILE, ""Unsupported audio stream"")); continue; } } if (nstr > 0) { fport[nstr] = create_avi_port(pool); if (!fport[nstr]) { status = PJ_ENOMEM; goto on_error; } status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[nstr]->fd); if (status != PJ_SUCCESS) goto on_error; status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET); if (status != PJ_SUCCESS) { goto on_error; } } fport[nstr]->stream_id = i; fport[nstr]->fmt_id = fmt_id; nstr++; } if (nstr == 0) { status = PJMEDIA_EAVIUNSUPP; goto on_error; } for (i = 0; i < nstr; i++) { strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id]; fport[i]->options = options; fport[i]->fsize = fport[0]->fsize; fport[i]->start_data = pos; if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) { strf_video_hdr_t *strf_hdr = &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr; const pjmedia_video_format_info *vfi; vfi = pjmedia_get_video_format_info( pjmedia_video_format_mgr_instance(), strl_hdr->codec); fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0); fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame; pjmedia_format_init_video(&fport[i]->base.info.fmt, fport[i]->fmt_id, strf_hdr->biWidth, strf_hdr->biHeight, strl_hdr->rate, strl_hdr->scale); #if 0 bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale; if (bps==0) { bps = strf_hdr->biWidth * strf_hdr->biHeight * strf_hdr->biBitCount * strl_hdr->rate / strl_hdr->scale; } fport[i]->base.info.fmt.det.vid.avg_bps = bps; fport[i]->base.info.fmt.det.vid.max_bps = bps; #endif } else { strf_audio_hdr_t *strf_hdr = &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr; fport[i]->bits_per_sample = strf_hdr->bits_per_sample; fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame; pjmedia_format_init_audio(&fport[i]->base.info.fmt, fport[i]->fmt_id, strf_hdr->sample_rate, strf_hdr->nchannels, strf_hdr->bits_per_sample, 20000 , strf_hdr->bytes_per_sec * 8, strf_hdr->bytes_per_sec * 8); if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA || fport[i]->fmt_id == PJMEDIA_FORMAT_PCMU) { fport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM; fport[i]->base.info.fmt.det.aud.bits_per_sample = 16; } } pj_strdup2(pool, &fport[i]->base.info.name, filename); } *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams)); (*p_streams)->num_streams = nstr; (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams, sizeof(pjmedia_port *)); for (i = 0; i < nstr; i++) (*p_streams)->streams[i] = &fport[i]->base; PJ_LOG(4,(THIS_FILE, ""AVI file player '%.*s' created with "" ""%d media ports"", (int)fport[0]->base.info.name.slen, fport[0]->base.info.name.ptr, (*p_streams)->num_streams)); return PJ_SUCCESS; on_error: fport[0]->base.on_destroy(&fport[0]->base); for (i = 1; i < nstr; i++) fport[i]->base.on_destroy(&fport[i]->base); if (status == AVI_EOF) return PJMEDIA_EINVALIMEDIATYPE; return status; }","- pj_ssize_t size_to_read;
- status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);
+ pj_off_t size_to_read;
+ pj_off_t size_to_read;
+ if (ch.len < read) {
+ status = PJ_EINVAL;
+ goto on_error;
+ }
+ PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read,
+ status = PJ_EINVAL; goto on_error;);
+ size_to_read = (pj_off_t)ch.len - read;
+ status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);","pjmedia_avi_player_create_streams(pj_pool_t *pool, const char *filename, unsigned options, pjmedia_avi_streams **p_streams) { pjmedia_avi_hdr avi_hdr; struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS]; pj_off_t pos; unsigned i, nstr = 0; pj_status_t status = PJ_SUCCESS; PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL); if (!pj_file_exists(filename)) { return PJ_ENOTFOUND; } fport[0] = create_avi_port(pool); if (!fport[0]) { return PJ_ENOMEM; } fport[0]->fsize = pj_file_size(filename); if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + sizeof(strl_hdr_t)) { return PJMEDIA_EINVALIMEDIATYPE; } status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd); if (status != PJ_SUCCESS) return status; status = file_read(fport[0]->fd, &avi_hdr, sizeof(riff_hdr_t) + sizeof(avih_hdr_t)); if (status != PJ_SUCCESS) goto on_error; if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) || !COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) || !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) || !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) || !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG)) { status = PJMEDIA_EINVALIMEDIATYPE; goto on_error; } PJ_LOG(5, (THIS_FILE, ""The AVI file has %d streams."", avi_hdr.avih_hdr.num_streams)); if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) { status = PJMEDIA_EAVIUNSUPP; goto on_error; } if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX || avi_hdr.avih_hdr.pad > 1) { PJ_LOG(3, (THIS_FILE, ""Warning!!! Possibly unsupported AVI format: "" ""flags:%d, pad:%d"", avi_hdr.avih_hdr.flags, avi_hdr.avih_hdr.pad)); } for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) { pj_size_t elem = 0; pj_off_t size_to_read; status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i], sizeof(strl_hdr_t)); if (status != PJ_SUCCESS) goto on_error; elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_VIDS_TAG) ? sizeof(strf_video_hdr_t) : COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_AUDS_TAG) ? sizeof(strf_audio_hdr_t) : 0; status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i], elem, 0); if (status != PJ_SUCCESS) goto on_error; if (elem == sizeof(strf_video_hdr_t)) data_to_host2(&avi_hdr.strf_hdr[i], sizeof(strf_video_hdr_sizes)/ sizeof(strf_video_hdr_sizes[0]), strf_video_hdr_sizes); else if (elem == sizeof(strf_audio_hdr_t)) data_to_host2(&avi_hdr.strf_hdr[i], sizeof(strf_audio_hdr_sizes)/ sizeof(strf_audio_hdr_sizes[0]), strf_audio_hdr_sizes); size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) - 8) - elem; status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz + sizeof(riff_hdr_t) + 8, PJ_SEEK_SET); if (status != PJ_SUCCESS) { goto on_error; } do { pjmedia_avi_subchunk ch; int read = 0; pj_off_t size_to_read; status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk)); if (status != PJ_SUCCESS) { goto on_error; } if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG)) { read = 4; status = file_read(fport[0]->fd, &ch, read); if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG)) break; } if (ch.len < read) { status = PJ_EINVAL; goto on_error; } PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, status = PJ_EINVAL; goto on_error;); size_to_read = (pj_off_t)ch.len - read; status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { goto on_error; } } while(1); status = pj_file_getpos(fport[0]->fd, &pos); if (status != PJ_SUCCESS) goto on_error; for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) { pjmedia_format_id fmt_id; if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_VIDS_TAG) && !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_AUDS_TAG)) || avi_hdr.strl_hdr[i].flags & AVISF_DISABLED) { continue; } if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, PJMEDIA_AVI_VIDS_TAG)) { int j; if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) { PJ_LOG(4, (THIS_FILE, ""Unsupported video stream"")); continue; } fmt_id = avi_hdr.strl_hdr[i].codec; for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) { if (fmt_id == avi_fmts[j].fmt_id) { if (avi_fmts[j].eff_fmt_id) fmt_id = avi_fmts[j].eff_fmt_id; break; } } if (j < 0) { PJ_LOG(4, (THIS_FILE, ""Unsupported video stream"")); continue; } } else { strf_audio_hdr_t *hdr = (strf_audio_hdr_t*) &avi_hdr.strf_hdr[i].strf_audio_hdr; if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM && hdr->bits_per_sample == 16) { fmt_id = PJMEDIA_FORMAT_PCM; } else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) { fmt_id = PJMEDIA_FORMAT_PCMA; } else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) { fmt_id = PJMEDIA_FORMAT_PCMU; } else { PJ_LOG(4, (THIS_FILE, ""Unsupported audio stream"")); continue; } } if (nstr > 0) { fport[nstr] = create_avi_port(pool); if (!fport[nstr]) { status = PJ_ENOMEM; goto on_error; } status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[nstr]->fd); if (status != PJ_SUCCESS) goto on_error; status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET); if (status != PJ_SUCCESS) { goto on_error; } } fport[nstr]->stream_id = i; fport[nstr]->fmt_id = fmt_id; nstr++; } if (nstr == 0) { status = PJMEDIA_EAVIUNSUPP; goto on_error; } for (i = 0; i < nstr; i++) { strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id]; fport[i]->options = options; fport[i]->fsize = fport[0]->fsize; fport[i]->start_data = pos; if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) { strf_video_hdr_t *strf_hdr = &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr; const pjmedia_video_format_info *vfi; vfi = pjmedia_get_video_format_info( pjmedia_video_format_mgr_instance(), strl_hdr->codec); fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0); fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame; pjmedia_format_init_video(&fport[i]->base.info.fmt, fport[i]->fmt_id, strf_hdr->biWidth, strf_hdr->biHeight, strl_hdr->rate, strl_hdr->scale); #if 0 bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale; if (bps==0) { bps = strf_hdr->biWidth * strf_hdr->biHeight * strf_hdr->biBitCount * strl_hdr->rate / strl_hdr->scale; } fport[i]->base.info.fmt.det.vid.avg_bps = bps; fport[i]->base.info.fmt.det.vid.max_bps = bps; #endif } else { strf_audio_hdr_t *strf_hdr = &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr; fport[i]->bits_per_sample = strf_hdr->bits_per_sample; fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame; pjmedia_format_init_audio(&fport[i]->base.info.fmt, fport[i]->fmt_id, strf_hdr->sample_rate, strf_hdr->nchannels, strf_hdr->bits_per_sample, 20000 , strf_hdr->bytes_per_sec * 8, strf_hdr->bytes_per_sec * 8); if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA || fport[i]->fmt_id == PJMEDIA_FORMAT_PCMU) { fport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM; fport[i]->base.info.fmt.det.aud.bits_per_sample = 16; } } pj_strdup2(pool, &fport[i]->base.info.name, filename); } *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams)); (*p_streams)->num_streams = nstr; (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams, sizeof(pjmedia_port *)); for (i = 0; i < nstr; i++) (*p_streams)->streams[i] = &fport[i]->base; PJ_LOG(4,(THIS_FILE, ""AVI file player '%.*s' created with "" ""%d media ports"", (int)fport[0]->base.info.name.slen, fport[0]->base.info.name.ptr, (*p_streams)->num_streams)); return PJ_SUCCESS; on_error: fport[0]->base.on_destroy(&fport[0]->base); for (i = 1; i < nstr; i++) fport[i]->base.on_destroy(&fport[i]->base); if (status == AVI_EOF) return PJMEDIA_EINVALIMEDIATYPE; return status; }"
227,1230----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-16994--pagewalk.c----walk_hugetlb_range,"static int walk_hugetlb_range(unsigned long addr, unsigned long end, struct mm_walk *walk) { struct vm_area_struct *vma = walk->vma; struct hstate *h = hstate_vma(vma); unsigned long next; unsigned long hmask = huge_page_mask(h); unsigned long sz = huge_page_size(h); pte_t *pte; int err = 0; do { next = hugetlb_entry_end(h, addr, end); pte = huge_pte_offset(walk->mm, addr & hmask, sz); <S2SV_StartVul> if (pte && walk->hugetlb_entry) <S2SV_EndVul> err = walk->hugetlb_entry(pte, hmask, addr, next, walk); if (err) break; } while (addr = next, addr != end); return err; }","- if (pte && walk->hugetlb_entry)
+ if (pte)
+ else if (walk->pte_hole)
+ err = walk->pte_hole(addr, next, walk);","static int walk_hugetlb_range(unsigned long addr, unsigned long end, struct mm_walk *walk) { struct vm_area_struct *vma = walk->vma; struct hstate *h = hstate_vma(vma); unsigned long next; unsigned long hmask = huge_page_mask(h); unsigned long sz = huge_page_size(h); pte_t *pte; int err = 0; do { next = hugetlb_entry_end(h, addr, end); pte = huge_pte_offset(walk->mm, addr & hmask, sz); if (pte) err = walk->hugetlb_entry(pte, hmask, addr, next, walk); else if (walk->pte_hole) err = walk->pte_hole(addr, next, walk); if (err) break; } while (addr = next, addr != end); return err; }"
228,1589----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7274--r_pkcs7.c----*r_pkcs7_parse_cms,"RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) { RASN1Object *object; RCMS *container; if (!buffer || !length) { return NULL; } container = R_NEW0 (RCMS); if (!container) { return NULL; } object = r_asn1_create_object (buffer, length); <S2SV_StartVul> if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) { <S2SV_EndVul> r_asn1_free_object (object); free (container); return NULL; } container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length); r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]); r_asn1_free_object (object); return container; }","- if (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {
+ if (!object || object->list.length != 2 || !object->list.objects ||
+ !object->list.objects[0] || !object->list.objects[1] ||
+ object->list.objects[1]->list.length != 1) {","RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) { RASN1Object *object; RCMS *container; if (!buffer || !length) { return NULL; } container = R_NEW0 (RCMS); if (!container) { return NULL; } object = r_asn1_create_object (buffer, length); if (!object || object->list.length != 2 || !object->list.objects || !object->list.objects[0] || !object->list.objects[1] || object->list.objects[1]->list.length != 1) { r_asn1_free_object (object); free (container); return NULL; } container->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length); r_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]); r_asn1_free_object (object); return container; }"
229,2012----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-12633--vboxguest_linux.c----vbg_misc_device_ioctl,"static long vbg_misc_device_ioctl(struct file *filp, unsigned int req, unsigned long arg) { struct vbg_session *session = filp->private_data; size_t returned_size, size; struct vbg_ioctl_hdr hdr; bool is_vmmdev_req; int ret = 0; void *buf; if (copy_from_user(&hdr, (void *)arg, sizeof(hdr))) return -EFAULT; if (hdr.version != VBG_IOCTL_HDR_VERSION) return -EINVAL; if (hdr.size_in < sizeof(hdr) || (hdr.size_out && hdr.size_out < sizeof(hdr))) return -EINVAL; size = max(hdr.size_in, hdr.size_out); if (_IOC_SIZE(req) && _IOC_SIZE(req) != size) return -EINVAL; if (size > SZ_16M) return -E2BIG; is_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG; if (is_vmmdev_req) buf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT); else buf = kmalloc(size, GFP_KERNEL); if (!buf) return -ENOMEM; <S2SV_StartVul> if (copy_from_user(buf, (void *)arg, hdr.size_in)) { <S2SV_EndVul> ret = -EFAULT; goto out; } if (hdr.size_in < size) memset(buf + hdr.size_in, 0, size - hdr.size_in); ret = vbg_core_ioctl(session, req, buf); if (ret) goto out; returned_size = ((struct vbg_ioctl_hdr *)buf)->size_out; if (returned_size > size) { vbg_debug(""%s: too much output data %zu > %zu\n"", __func__, returned_size, size); returned_size = size; } if (copy_to_user((void *)arg, buf, returned_size) != 0) ret = -EFAULT; out: if (is_vmmdev_req) vbg_req_free(buf, size); else kfree(buf); return ret; }","- if (copy_from_user(buf, (void *)arg, hdr.size_in)) {
+ if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr),
+ hdr.size_in - sizeof(hdr))) {","static long vbg_misc_device_ioctl(struct file *filp, unsigned int req, unsigned long arg) { struct vbg_session *session = filp->private_data; size_t returned_size, size; struct vbg_ioctl_hdr hdr; bool is_vmmdev_req; int ret = 0; void *buf; if (copy_from_user(&hdr, (void *)arg, sizeof(hdr))) return -EFAULT; if (hdr.version != VBG_IOCTL_HDR_VERSION) return -EINVAL; if (hdr.size_in < sizeof(hdr) || (hdr.size_out && hdr.size_out < sizeof(hdr))) return -EINVAL; size = max(hdr.size_in, hdr.size_out); if (_IOC_SIZE(req) && _IOC_SIZE(req) != size) return -EINVAL; if (size > SZ_16M) return -E2BIG; is_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG; if (is_vmmdev_req) buf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT); else buf = kmalloc(size, GFP_KERNEL); if (!buf) return -ENOMEM; *((struct vbg_ioctl_hdr *)buf) = hdr; if (copy_from_user(buf + sizeof(hdr), (void *)arg + sizeof(hdr), hdr.size_in - sizeof(hdr))) { ret = -EFAULT; goto out; } if (hdr.size_in < size) memset(buf + hdr.size_in, 0, size - hdr.size_in); ret = vbg_core_ioctl(session, req, buf); if (ret) goto out; returned_size = ((struct vbg_ioctl_hdr *)buf)->size_out; if (returned_size > size) { vbg_debug(""%s: too much output data %zu > %zu\n"", __func__, returned_size, size); returned_size = size; } if (copy_to_user((void *)arg, buf, returned_size) != 0) ret = -EFAULT; out: if (is_vmmdev_req) vbg_req_free(buf, size); else kfree(buf); return ret; }"
230,686----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3183--hid-logitech-dj.c----logi_dj_ll_raw_request,"static int logi_dj_ll_raw_request(struct hid_device *hid, unsigned char reportnum, __u8 *buf, size_t count, unsigned char report_type, int reqtype) { struct dj_device *djdev = hid->driver_data; struct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev; u8 *out_buf; int ret; if (buf[0] != REPORT_TYPE_LEDS) return -EINVAL; out_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC); if (!out_buf) return -ENOMEM; <S2SV_StartVul> if (count < DJREPORT_SHORT_LENGTH - 2) <S2SV_EndVul> count = DJREPORT_SHORT_LENGTH - 2; out_buf[0] = REPORT_ID_DJ_SHORT; out_buf[1] = djdev->device_index; memcpy(out_buf + 2, buf, count); ret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf, DJREPORT_SHORT_LENGTH, report_type, reqtype); kfree(out_buf); return ret; }","- if (count < DJREPORT_SHORT_LENGTH - 2)
+ if (count > DJREPORT_SHORT_LENGTH - 2)","static int logi_dj_ll_raw_request(struct hid_device *hid, unsigned char reportnum, __u8 *buf, size_t count, unsigned char report_type, int reqtype) { struct dj_device *djdev = hid->driver_data; struct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev; u8 *out_buf; int ret; if (buf[0] != REPORT_TYPE_LEDS) return -EINVAL; out_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC); if (!out_buf) return -ENOMEM; if (count > DJREPORT_SHORT_LENGTH - 2) count = DJREPORT_SHORT_LENGTH - 2; out_buf[0] = REPORT_ID_DJ_SHORT; out_buf[1] = djdev->device_index; memcpy(out_buf + 2, buf, count); ret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf, DJREPORT_SHORT_LENGTH, report_type, reqtype); kfree(out_buf); return ret; }"
231,6845----CWE-369----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/resource_variable_ops.cc----tensorflow::ResourceGatherOp::Compute,"void Compute(OpKernelContext* c) override { core::RefCountPtr<Var> v; OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v)); OP_REQUIRES_OK(c, EnsureSparseVariableAccess<Device, T>(c, v.get())); tf_shared_lock ml(*v->mu()); const Tensor& params = *v->tensor(); const Tensor& indices = c->input(1); OP_REQUIRES( c, TensorShapeUtils::IsVectorOrHigher(params.shape()), errors::InvalidArgument(""params must be at least 1 dimensional"")); OP_REQUIRES( c, params.shape().dims() >= batch_dims_, errors::InvalidArgument(""params must have at least "", batch_dims_, "" (batch_dims) dimensions but it has shape "", params.shape().DebugString())); const int64_t N = indices.NumElements(); OP_REQUIRES( c, params.dim_size(0) <= std::numeric_limits<Index>::max(), errors::InvalidArgument(""params.shape[0] too large for "", DataTypeString(DataTypeToEnum<Index>::v()), "" indexing: "", params.dim_size(0), "" > "", std::numeric_limits<Index>::max())); TensorShape result_shape; for (int i = 0; i < batch_dims_; ++i) { result_shape.AddDim(params.dim_size(i)); } for (int i = batch_dims_; i < indices.dims(); ++i) { result_shape.AddDim(indices.dim_size(i)); } for (int i = batch_dims_ + 1; i < params.dims(); ++i) { result_shape.AddDim(params.dim_size(i)); } Tensor* out = nullptr; Tensor tmp; if (params.dtype() == DT_VARIANT) { tmp = Tensor(DT_VARIANT, result_shape); c->set_output(0, tmp); out = &tmp; } else { OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, &out)); } if (N > 0) { Tensor tmp_indices; const Tensor* op_indices = &indices; if (batch_dims_ > 0) { OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(), &tmp_indices)); functor::DenseUpdate<Device, Index, ASSIGN> copy_functor; copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(), indices.flat<Index>()); <S2SV_StartVul> AddBatchOffsets(&tmp_indices, params); <S2SV_EndVul> op_indices = &tmp_indices; } int64_t gather_dim_size = 1; for (int idx = 0; idx <= batch_dims_; ++idx) { gather_dim_size *= params.dim_size(idx); } int64_t inner_size = 1; for (int i = batch_dims_ + 1; i < params.dims(); ++i) { inner_size *= params.dim_size(i); } auto params_flat = params.shaped<T, 3>({1, gather_dim_size, inner_size}); const auto indices_flat = op_indices->flat<Index>(); auto out_flat = out->shaped<T, 3>({1, N, out->NumElements() / N}); functor::GatherFunctor<Device, T, Index> functor; int64_t bad_i = functor(c, params_flat, indices_flat, out_flat); OP_REQUIRES( c, bad_i < 0, errors::InvalidArgument( ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "", indices_flat(bad_i), "" is not in [0, "", params.dim_size(0), "")"")); } }","- AddBatchOffsets(&tmp_indices, params);
+ AddBatchOffsets(c, &tmp_indices, params);
+ if (!c->status().ok()) return;","void Compute(OpKernelContext* c) override { core::RefCountPtr<Var> v; OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v)); OP_REQUIRES_OK(c, EnsureSparseVariableAccess<Device, T>(c, v.get())); tf_shared_lock ml(*v->mu()); const Tensor& params = *v->tensor(); const Tensor& indices = c->input(1); OP_REQUIRES( c, TensorShapeUtils::IsVectorOrHigher(params.shape()), errors::InvalidArgument(""params must be at least 1 dimensional"")); OP_REQUIRES( c, params.shape().dims() >= batch_dims_, errors::InvalidArgument(""params must have at least "", batch_dims_, "" (batch_dims) dimensions but it has shape "", params.shape().DebugString())); const int64_t N = indices.NumElements(); OP_REQUIRES( c, params.dim_size(0) <= std::numeric_limits<Index>::max(), errors::InvalidArgument(""params.shape[0] too large for "", DataTypeString(DataTypeToEnum<Index>::v()), "" indexing: "", params.dim_size(0), "" > "", std::numeric_limits<Index>::max())); TensorShape result_shape; for (int i = 0; i < batch_dims_; ++i) { result_shape.AddDim(params.dim_size(i)); } for (int i = batch_dims_; i < indices.dims(); ++i) { result_shape.AddDim(indices.dim_size(i)); } for (int i = batch_dims_ + 1; i < params.dims(); ++i) { result_shape.AddDim(params.dim_size(i)); } Tensor* out = nullptr; Tensor tmp; if (params.dtype() == DT_VARIANT) { tmp = Tensor(DT_VARIANT, result_shape); c->set_output(0, tmp); out = &tmp; } else { OP_REQUIRES_OK(c, c->allocate_output(0, result_shape, &out)); } if (N > 0) { Tensor tmp_indices; const Tensor* op_indices = &indices; if (batch_dims_ > 0) { OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(), &tmp_indices)); functor::DenseUpdate<Device, Index, ASSIGN> copy_functor; copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(), indices.flat<Index>()); AddBatchOffsets(c, &tmp_indices, params); if (!c->status().ok()) return; op_indices = &tmp_indices; } int64_t gather_dim_size = 1; for (int idx = 0; idx <= batch_dims_; ++idx) { gather_dim_size *= params.dim_size(idx); } int64_t inner_size = 1; for (int i = batch_dims_ + 1; i < params.dims(); ++i) { inner_size *= params.dim_size(i); } auto params_flat = params.shaped<T, 3>({1, gather_dim_size, inner_size}); const auto indices_flat = op_indices->flat<Index>(); auto out_flat = out->shaped<T, 3>({1, N, out->NumElements() / N}); functor::GatherFunctor<Device, T, Index> functor; int64_t bad_i = functor(c, params_flat, indices_flat, out_flat); OP_REQUIRES( c, bad_i < 0, errors::InvalidArgument( ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "", indices_flat(bad_i), "" is not in [0, "", params.dim_size(0), "")"")); } }"
232,6565----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fib6_rules.c----fib6_rule_suppress,"static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg) { struct fib6_result *res = arg->result; struct rt6_info *rt = res->rt6; struct net_device *dev = NULL; if (!rt) return false; if (rt->rt6i_idev) dev = rt->rt6i_idev->dev; if (rt->rt6i_dst.plen <= rule->suppress_prefixlen) goto suppress_route; if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup) goto suppress_route; return false; suppress_route: <S2SV_StartVul> ip6_rt_put(rt); <S2SV_EndVul> return true; }","- ip6_rt_put(rt);
+ if (!(arg->flags & FIB_LOOKUP_NOREF))
+ ip6_rt_put(rt);","static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg) { struct fib6_result *res = arg->result; struct rt6_info *rt = res->rt6; struct net_device *dev = NULL; if (!rt) return false; if (rt->rt6i_idev) dev = rt->rt6i_idev->dev; if (rt->rt6i_dst.plen <= rule->suppress_prefixlen) goto suppress_route; if (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup) goto suppress_route; return false; suppress_route: if (!(arg->flags & FIB_LOOKUP_NOREF)) ip6_rt_put(rt); return true; }"
233,6037----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/softmagic.c----mconvert,"*/ private int mconvert(struct magic_set *ms, struct magic *m, int flip) { union VALUETYPE *p = &ms->ms_value; uint8_t type; switch (type = cvt_flip(m->type, flip)) { case FILE_BYTE: cvt_8(p, m); return 1; case FILE_SHORT: cvt_16(p, m); return 1; case FILE_LONG: case FILE_DATE: case FILE_LDATE: cvt_32(p, m); return 1; case FILE_QUAD: case FILE_QDATE: case FILE_QLDATE: case FILE_QWDATE: cvt_64(p, m); return 1; case FILE_STRING: case FILE_BESTRING16: case FILE_LESTRING16: { p->s[sizeof(p->s) - 1] = '\0'; return 1; } case FILE_PSTRING: { size_t sz = file_pstring_length_size(m); char *ptr1 = p->s, *ptr2 = ptr1 + sz; size_t len = file_pstring_get_length(m, ptr1); <S2SV_StartVul> if (len >= sizeof(p->s)) { <S2SV_EndVul> <S2SV_StartVul> len = sizeof(p->s) - sz; <S2SV_EndVul> } while (len--) *ptr1++ = *ptr2++; *ptr1 = '\0'; return 1; } case FILE_BESHORT: p->h = (short)((p->hs[0]<<8)|(p->hs[1])); cvt_16(p, m); return 1; case FILE_BELONG: case FILE_BEDATE: case FILE_BELDATE: p->l = (int32_t) ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3])); if (type == FILE_BELONG) cvt_32(p, m); return 1; case FILE_BEQUAD: case FILE_BEQDATE: case FILE_BEQLDATE: case FILE_BEQWDATE: p->q = (uint64_t) (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)| ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)| ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)| ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7])); if (type == FILE_BEQUAD) cvt_64(p, m); return 1; case FILE_LESHORT: p->h = (short)((p->hs[1]<<8)|(p->hs[0])); cvt_16(p, m); return 1; case FILE_LELONG: case FILE_LEDATE: case FILE_LELDATE: p->l = (int32_t) ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0])); if (type == FILE_LELONG) cvt_32(p, m); return 1; case FILE_LEQUAD: case FILE_LEQDATE: case FILE_LEQLDATE: case FILE_LEQWDATE: p->q = (uint64_t) (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)| ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)| ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)| ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0])); if (type == FILE_LEQUAD) cvt_64(p, m); return 1; case FILE_MELONG: case FILE_MEDATE: case FILE_MELDATE: p->l = (int32_t) ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2])); if (type == FILE_MELONG) cvt_32(p, m); return 1; case FILE_FLOAT: cvt_float(p, m); return 1; case FILE_BEFLOAT: p->l = ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)| ((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]); cvt_float(p, m); return 1; case FILE_LEFLOAT: p->l = ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)| ((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]); cvt_float(p, m); return 1; case FILE_DOUBLE: cvt_double(p, m); return 1; case FILE_BEDOUBLE: p->q = ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)| ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)| ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)| ((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]); cvt_double(p, m); return 1; case FILE_LEDOUBLE: p->q = ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)| ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)| ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)| ((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]); cvt_double(p, m); return 1; case FILE_REGEX: case FILE_SEARCH: case FILE_DEFAULT: case FILE_CLEAR: case FILE_NAME: case FILE_USE: return 1; default: file_magerror(ms, ""invalid type %d in mconvert()"", m->type); return 0;","- if (len >= sizeof(p->s)) {
- len = sizeof(p->s) - sz;
+ if (len >= sz) {
+ len = sz;","*/ private int mconvert(struct magic_set *ms, struct magic *m, int flip) { union VALUETYPE *p = &ms->ms_value; uint8_t type; switch (type = cvt_flip(m->type, flip)) { case FILE_BYTE: cvt_8(p, m); return 1; case FILE_SHORT: cvt_16(p, m); return 1; case FILE_LONG: case FILE_DATE: case FILE_LDATE: cvt_32(p, m); return 1; case FILE_QUAD: case FILE_QDATE: case FILE_QLDATE: case FILE_QWDATE: cvt_64(p, m); return 1; case FILE_STRING: case FILE_BESTRING16: case FILE_LESTRING16: { p->s[sizeof(p->s) - 1] = '\0'; return 1; } case FILE_PSTRING: { size_t sz = file_pstring_length_size(m); char *ptr1 = p->s, *ptr2 = ptr1 + sz; size_t len = file_pstring_get_length(m, ptr1); sz = sizeof(p->s) - sz; if (len >= sz) { len = sz; } while (len--) *ptr1++ = *ptr2++; *ptr1 = '\0'; return 1; } case FILE_BESHORT: p->h = (short)((p->hs[0]<<8)|(p->hs[1])); cvt_16(p, m); return 1; case FILE_BELONG: case FILE_BEDATE: case FILE_BELDATE: p->l = (int32_t) ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3])); if (type == FILE_BELONG) cvt_32(p, m); return 1; case FILE_BEQUAD: case FILE_BEQDATE: case FILE_BEQLDATE: case FILE_BEQWDATE: p->q = (uint64_t) (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)| ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)| ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)| ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7])); if (type == FILE_BEQUAD) cvt_64(p, m); return 1; case FILE_LESHORT: p->h = (short)((p->hs[1]<<8)|(p->hs[0])); cvt_16(p, m); return 1; case FILE_LELONG: case FILE_LEDATE: case FILE_LELDATE: p->l = (int32_t) ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0])); if (type == FILE_LELONG) cvt_32(p, m); return 1; case FILE_LEQUAD: case FILE_LEQDATE: case FILE_LEQLDATE: case FILE_LEQWDATE: p->q = (uint64_t) (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)| ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)| ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)| ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0])); if (type == FILE_LEQUAD) cvt_64(p, m); return 1; case FILE_MELONG: case FILE_MEDATE: case FILE_MELDATE: p->l = (int32_t) ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2])); if (type == FILE_MELONG) cvt_32(p, m); return 1; case FILE_FLOAT: cvt_float(p, m); return 1; case FILE_BEFLOAT: p->l = ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)| ((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]); cvt_float(p, m); return 1; case FILE_LEFLOAT: p->l = ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)| ((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]); cvt_float(p, m); return 1; case FILE_DOUBLE: cvt_double(p, m); return 1; case FILE_BEDOUBLE: p->q = ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)| ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)| ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)| ((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]); cvt_double(p, m); return 1; case FILE_LEDOUBLE: p->q = ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)| ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)| ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)| ((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]); cvt_double(p, m); return 1; case FILE_REGEX: case FILE_SEARCH: case FILE_DEFAULT: case FILE_CLEAR: case FILE_NAME: case FILE_USE: return 1; default: file_magerror(ms, ""invalid type %d in mconvert()"", m->type); return 0;"
234,3511----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/netcdfsg.cpp----nccfdriver::attrf,"std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc) { <S2SV_StartVul> alloc = """"; <S2SV_EndVul> size_t len = 0; nc_inq_attlen(ncid, varId, attrName, &len); if(len < 1) { return alloc; } <S2SV_StartVul> char attr_vals[NC_MAX_NAME + 1]; <S2SV_EndVul> <S2SV_StartVul> memset(attr_vals, 0, NC_MAX_NAME + 1); <S2SV_EndVul> <S2SV_StartVul> if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> return alloc; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> alloc = std::string(attr_vals); <S2SV_EndVul> return alloc; }","- alloc = """";
- char attr_vals[NC_MAX_NAME + 1];
- memset(attr_vals, 0, NC_MAX_NAME + 1);
- if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)
- {
- return alloc;
- }
- alloc = std::string(attr_vals);
+ alloc.clear();
+ alloc.resize(len);
+ memset(&alloc[0], 0, len);
+ nc_get_att_text(ncid, varId, attrName, &alloc[0]);","std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc) { size_t len = 0; nc_inq_attlen(ncid, varId, attrName, &len); if(len < 1) { alloc.clear(); return alloc; } alloc.resize(len); memset(&alloc[0], 0, len); nc_get_att_text(ncid, varId, attrName, &alloc[0]); return alloc; }"
235,2498----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-13145--jp2.c----*ReadJP2Image,"static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception) { const char *option; Image *image; int jp2_status; MagickBooleanType status; opj_codec_t *jp2_codec; opj_codestream_index_t *codestream_index = (opj_codestream_index_t *) NULL; opj_dparameters_t parameters; opj_image_t *jp2_image; opj_stream_t *jp2_stream; register ssize_t i; ssize_t y; unsigned char sans[4]; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (ReadBlob(image,4,sans) != 4) { image=DestroyImageList(image); return((Image *) NULL); } (void) SeekBlob(image,SEEK_SET,0); if (LocaleCompare(image_info->magick,""JPT"") == 0) jp2_codec=opj_create_decompress(OPJ_CODEC_JPT); else if (IsJ2K(sans,4) != MagickFalse) jp2_codec=opj_create_decompress(OPJ_CODEC_J2K); else jp2_codec=opj_create_decompress(OPJ_CODEC_JP2); opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception); opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception); opj_set_default_decoder_parameters(&parameters); option=GetImageOption(image_info,""jp2:reduce-factor""); if (option != (const char *) NULL) parameters.cp_reduce=StringToInteger(option); option=GetImageOption(image_info,""jp2:quality-layers""); if (option == (const char *) NULL) option=GetImageOption(image_info,""jp2:layer-number""); if (option != (const char *) NULL) parameters.cp_layer=StringToInteger(option); if (opj_setup_decoder(jp2_codec,&parameters) == 0) { opj_destroy_codec(jp2_codec); ThrowReaderException(DelegateError,""UnableToManageJP2Stream""); } jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE); opj_stream_set_read_function(jp2_stream,JP2ReadHandler); opj_stream_set_write_function(jp2_stream,JP2WriteHandler); opj_stream_set_seek_function(jp2_stream,JP2SeekHandler); opj_stream_set_skip_function(jp2_stream,JP2SkipHandler); opj_stream_set_user_data(jp2_stream,image,NULL); opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image)); if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } jp2_status=1; if ((image->columns != 0) && (image->rows != 0)) { jp2_status=opj_set_decode_area(jp2_codec,jp2_image, (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y, (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns, (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows); if (jp2_status == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } } if ((image_info->number_scenes != 0) && (image_info->scene != 0)) jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image, (unsigned int) image_info->scene-1); else if (image->ping == MagickFalse) { jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image); if (jp2_status != 0) jp2_status=opj_end_decompress(jp2_codec,jp2_stream); } if (jp2_status == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } opj_stream_destroy(jp2_stream); for (i=0; i < (ssize_t) jp2_image->numcomps; i++) { if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) || (jp2_image->comps[0].dx != jp2_image->comps[i].dx) || (jp2_image->comps[0].dy != jp2_image->comps[i].dy) || (jp2_image->comps[0].prec != jp2_image->comps[i].prec) || (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd)) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(CoderError,""IrregularChannelGeometryNotSupported"") } } image->columns=(size_t) jp2_image->comps[0].w; image->rows=(size_t) jp2_image->comps[0].h; image->depth=jp2_image->comps[0].prec; status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } image->compression=JPEG2000Compression; if (jp2_image->color_space == 2) { SetImageColorspace(image,GRAYColorspace); if (jp2_image->numcomps > 1) image->matte=MagickTrue; } else if (jp2_image->color_space == 3) SetImageColorspace(image,Rec601YCbCrColorspace); if (jp2_image->numcomps > 3) image->matte=MagickTrue; if (jp2_image->icc_profile_buf != (unsigned char *) NULL) { StringInfo *profile; profile=BlobToStringInfo(jp2_image->icc_profile_buf, jp2_image->icc_profile_len); if (profile != (StringInfo *) NULL) SetImageProfile(image,""icc"",profile); } if (image->ping != MagickFalse) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); opj_destroy_cstr_index(&codestream_index); return(GetFirstImageInList(image)); } for (y=0; y < (ssize_t) image->rows; y++) { register PixelPacket *magick_restrict q; register ssize_t x; q=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { register ssize_t i; for (i=0; i < (ssize_t) jp2_image->numcomps; i++) { double pixel, scale; scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1); pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy* <S2SV_StartVul> image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+ <S2SV_EndVul> (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0)); switch (i) { case 0: { q->red=ClampToQuantum(pixel); q->green=q->red; q->blue=q->red; q->opacity=OpaqueOpacity; break; } case 1: { if (jp2_image->numcomps == 2) { q->opacity=ClampToQuantum(QuantumRange-pixel); break; } q->green=ClampToQuantum(pixel); break; } case 2: { q->blue=ClampToQuantum(pixel); break; } case 3: { q->opacity=ClampToQuantum(QuantumRange-pixel); break; } } } q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); opj_destroy_cstr_index(&codestream_index); (void) CloseBlob(image); return(GetFirstImageInList(image)); }","- image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+
+ case 0:
+ {","static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception) { const char *option; Image *image; int jp2_status; MagickBooleanType status; opj_codec_t *jp2_codec; opj_codestream_index_t *codestream_index = (opj_codestream_index_t *) NULL; opj_dparameters_t parameters; opj_image_t *jp2_image; opj_stream_t *jp2_stream; register ssize_t i; ssize_t y; unsigned char sans[4]; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (ReadBlob(image,4,sans) != 4) { image=DestroyImageList(image); return((Image *) NULL); } (void) SeekBlob(image,SEEK_SET,0); if (LocaleCompare(image_info->magick,""JPT"") == 0) jp2_codec=opj_create_decompress(OPJ_CODEC_JPT); else if (IsJ2K(sans,4) != MagickFalse) jp2_codec=opj_create_decompress(OPJ_CODEC_J2K); else jp2_codec=opj_create_decompress(OPJ_CODEC_JP2); opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception); opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception); opj_set_default_decoder_parameters(&parameters); option=GetImageOption(image_info,""jp2:reduce-factor""); if (option != (const char *) NULL) parameters.cp_reduce=StringToInteger(option); option=GetImageOption(image_info,""jp2:quality-layers""); if (option == (const char *) NULL) option=GetImageOption(image_info,""jp2:layer-number""); if (option != (const char *) NULL) parameters.cp_layer=StringToInteger(option); if (opj_setup_decoder(jp2_codec,&parameters) == 0) { opj_destroy_codec(jp2_codec); ThrowReaderException(DelegateError,""UnableToManageJP2Stream""); } jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE); opj_stream_set_read_function(jp2_stream,JP2ReadHandler); opj_stream_set_write_function(jp2_stream,JP2WriteHandler); opj_stream_set_seek_function(jp2_stream,JP2SeekHandler); opj_stream_set_skip_function(jp2_stream,JP2SkipHandler); opj_stream_set_user_data(jp2_stream,image,NULL); opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image)); if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } jp2_status=1; if ((image->columns != 0) && (image->rows != 0)) { jp2_status=opj_set_decode_area(jp2_codec,jp2_image, (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y, (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns, (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows); if (jp2_status == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } } if ((image_info->number_scenes != 0) && (image_info->scene != 0)) jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image, (unsigned int) image_info->scene-1); else if (image->ping == MagickFalse) { jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image); if (jp2_status != 0) jp2_status=opj_end_decompress(jp2_codec,jp2_stream); } if (jp2_status == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } opj_stream_destroy(jp2_stream); for (i=0; i < (ssize_t) jp2_image->numcomps; i++) { if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) || (jp2_image->comps[0].dx != jp2_image->comps[i].dx) || (jp2_image->comps[0].dy != jp2_image->comps[i].dy) || (jp2_image->comps[0].prec != jp2_image->comps[i].prec) || (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) || (jp2_image->comps[i].data == NULL)) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(CoderError,""IrregularChannelGeometryNotSupported"") } } image->columns=(size_t) jp2_image->comps[0].w; image->rows=(size_t) jp2_image->comps[0].h; image->depth=jp2_image->comps[0].prec; status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } image->compression=JPEG2000Compression; if (jp2_image->color_space == 2) { SetImageColorspace(image,GRAYColorspace); if (jp2_image->numcomps > 1) image->matte=MagickTrue; } else if (jp2_image->color_space == 3) SetImageColorspace(image,Rec601YCbCrColorspace); if (jp2_image->numcomps > 3) image->matte=MagickTrue; if (jp2_image->icc_profile_buf != (unsigned char *) NULL) { StringInfo *profile; profile=BlobToStringInfo(jp2_image->icc_profile_buf, jp2_image->icc_profile_len); if (profile != (StringInfo *) NULL) SetImageProfile(image,""icc"",profile); } if (image->ping != MagickFalse) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); opj_destroy_cstr_index(&codestream_index); return(GetFirstImageInList(image)); } for (y=0; y < (ssize_t) image->rows; y++) { register PixelPacket *magick_restrict q; register ssize_t x; q=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { register ssize_t i; for (i=0; i < (ssize_t) jp2_image->numcomps; i++) { double pixel, scale; scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1); pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy* image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+ (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0)); switch (i) { case 0: { q->red=ClampToQuantum(pixel); q->green=q->red; q->blue=q->red; q->opacity=OpaqueOpacity; break; } case 1: { if (jp2_image->numcomps == 2) { q->opacity=ClampToQuantum(QuantumRange-pixel); break; } q->green=ClampToQuantum(pixel); break; } case 2: { q->blue=ClampToQuantum(pixel); break; } case 3: { q->opacity=ClampToQuantum(QuantumRange-pixel); break; } } } q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); opj_destroy_cstr_index(&codestream_index); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
236,4925----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/parallel_main.c----parallel_process_irp_create,"static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp) { char* path = NULL; int status; UINT32 PathLength; <S2SV_StartVul> Stream_Seek(irp->input, 28); <S2SV_EndVul> Stream_Read_UINT32(irp->input, PathLength); <S2SV_StartVul> status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2, <S2SV_EndVul> <S2SV_StartVul> &path, 0, NULL, NULL); <S2SV_EndVul> if (status < 1) if (!(path = (char*)calloc(1, 1))) { WLog_ERR(TAG, ""calloc failed!""); return CHANNEL_RC_NO_MEMORY; } parallel->id = irp->devman->id_sequence++; parallel->file = open(parallel->path, O_RDWR); if (parallel->file < 0) { irp->IoStatus = STATUS_ACCESS_DENIED; parallel->id = 0; } else { if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1) { } } Stream_Write_UINT32(irp->output, parallel->id); Stream_Write_UINT8(irp->output, 0); free(path); return irp->Complete(irp); }","- Stream_Seek(irp->input, 28);
- status = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,
- &path, 0, NULL, NULL);
+ WCHAR* ptr;
+ if (!Stream_SafeSeek(irp->input, 28))
+ return ERROR_INVALID_DATA;
+ if (Stream_GetRemainingLength(irp->input) < 4)
+ return ERROR_INVALID_DATA;
+ ptr = (WCHAR*)Stream_Pointer(irp->input);
+ if (!Stream_SafeSeek(irp->input, PathLength))
+ return ERROR_INVALID_DATA;
+ status = ConvertFromUnicode(CP_UTF8, 0, ptr, PathLength / 2, &path, 0, NULL, NULL);","static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp) { char* path = NULL; int status; WCHAR* ptr; UINT32 PathLength; if (!Stream_SafeSeek(irp->input, 28)) return ERROR_INVALID_DATA; if (Stream_GetRemainingLength(irp->input) < 4) return ERROR_INVALID_DATA; Stream_Read_UINT32(irp->input, PathLength); ptr = (WCHAR*)Stream_Pointer(irp->input); if (!Stream_SafeSeek(irp->input, PathLength)) return ERROR_INVALID_DATA; status = ConvertFromUnicode(CP_UTF8, 0, ptr, PathLength / 2, &path, 0, NULL, NULL); if (status < 1) if (!(path = (char*)calloc(1, 1))) { WLog_ERR(TAG, ""calloc failed!""); return CHANNEL_RC_NO_MEMORY; } parallel->id = irp->devman->id_sequence++; parallel->file = open(parallel->path, O_RDWR); if (parallel->file < 0) { irp->IoStatus = STATUS_ACCESS_DENIED; parallel->id = 0; } else { if (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1) { } } Stream_Write_UINT32(irp->output, parallel->id); Stream_Write_UINT8(irp->output, 0); free(path); return irp->Complete(irp); }"
237,4282----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hostsock.c----_hostsock_recvfrom,"static ssize_t _hostsock_recvfrom( oe_fd_t* sock_, void* buf, size_t count, int flags, <S2SV_StartVul> const struct oe_sockaddr* src_addr, <S2SV_EndVul> oe_socklen_t* addrlen) { ssize_t ret = -1; sock_t* sock = _cast_sock(sock_); oe_socklen_t addrlen_in = 0; oe_errno = 0; <S2SV_StartVul> if (!sock || (count && !buf)) <S2SV_EndVul> OE_RAISE_ERRNO(OE_EINVAL); <S2SV_StartVul> if (addrlen) <S2SV_EndVul> addrlen_in = *addrlen; if (oe_syscall_recvfrom_ocall( &ret, sock->host_fd, buf, count, flags, <S2SV_StartVul> (struct oe_sockaddr*)src_addr, <S2SV_EndVul> addrlen_in, <S2SV_StartVul> addrlen) != OE_OK) <S2SV_EndVul> { OE_RAISE_ERRNO(OE_EINVAL); } done: return ret; }","- const struct oe_sockaddr* src_addr,
- if (!sock || (count && !buf))
- if (addrlen)
- (struct oe_sockaddr*)src_addr,
- addrlen) != OE_OK)
+ struct oe_sockaddr* src_addr,
+ oe_socklen_t addrlen_out = 0;
+ if (!sock || (count && !buf) || count > OE_SSIZE_MAX)
+ if (src_addr && addrlen)
+ src_addr,
+ &addrlen_out) != OE_OK)
+ {
+ OE_RAISE_ERRNO(OE_EINVAL);
+ }
+ if (src_addr && addrlen)
+ {
+ if (addrlen_out > sizeof(struct oe_sockaddr_storage))
+ OE_RAISE_ERRNO(OE_EINVAL);
+ }
+ if (ret > (ssize_t)count)
+ ret = -1;","static ssize_t _hostsock_recvfrom( oe_fd_t* sock_, void* buf, size_t count, int flags, struct oe_sockaddr* src_addr, oe_socklen_t* addrlen) { ssize_t ret = -1; sock_t* sock = _cast_sock(sock_); oe_socklen_t addrlen_in = 0; oe_socklen_t addrlen_out = 0; oe_errno = 0; if (!sock || (count && !buf) || count > OE_SSIZE_MAX) OE_RAISE_ERRNO(OE_EINVAL); if (src_addr && addrlen) addrlen_in = *addrlen; if (oe_syscall_recvfrom_ocall( &ret, sock->host_fd, buf, count, flags, src_addr, addrlen_in, &addrlen_out) != OE_OK) { OE_RAISE_ERRNO(OE_EINVAL); } if (src_addr && addrlen) { if (addrlen_out > sizeof(struct oe_sockaddr_storage)) OE_RAISE_ERRNO(OE_EINVAL); *addrlen = addrlen_out; } if (ret > (ssize_t)count) { ret = -1; OE_RAISE_ERRNO(OE_EINVAL); } done: return ret; }"
238,3165----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/peglib.h----peg::codepoint_length,"inline size_t codepoint_length(const char *s8, size_t l) { if (l) { auto b = static_cast<uint8_t>(s8[0]); if ((b & 0x80) == 0) { return 1; <S2SV_StartVul> } else if ((b & 0xE0) == 0xC0) { <S2SV_EndVul> return 2; <S2SV_StartVul> } else if ((b & 0xF0) == 0xE0) { <S2SV_EndVul> return 3; <S2SV_StartVul> } else if ((b & 0xF8) == 0xF0) { <S2SV_EndVul> return 4; } } return 0; }","- } else if ((b & 0xE0) == 0xC0) {
- } else if ((b & 0xF0) == 0xE0) {
- } else if ((b & 0xF8) == 0xF0) {
+ } else if ((b & 0xE0) == 0xC0 && l >= 2) {
+ } else if ((b & 0xF0) == 0xE0 && l >= 3) {
+ } else if ((b & 0xF8) == 0xF0 && l >= 4) {","inline size_t codepoint_length(const char *s8, size_t l) { if (l) { auto b = static_cast<uint8_t>(s8[0]); if ((b & 0x80) == 0) { return 1; } else if ((b & 0xE0) == 0xC0 && l >= 2) { return 2; } else if ((b & 0xF0) == 0xE0 && l >= 3) { return 3; } else if ((b & 0xF8) == 0xF0 && l >= 4) { return 4; } } return 0; }"
239,6411----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/evalvars.c----get_user_var_name,"get_user_var_name(expand_T *xp, int idx) { static long_u gdone; static long_u bdone; static long_u wdone; static long_u tdone; static int vidx; static hashitem_T *hi; hashtab_T *ht; if (idx == 0) { gdone = bdone = wdone = vidx = 0; tdone = 0; } if (gdone < globvarht.ht_used) { if (gdone++ == 0) hi = globvarht.ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; if (STRNCMP(""g:"", xp->xp_pattern, 2) == 0) return cat_prefix_varname('g', hi->hi_key); return hi->hi_key; } <S2SV_StartVul> ht = <S2SV_EndVul> <S2SV_StartVul> #ifdef FEAT_CMDWIN <S2SV_EndVul> <S2SV_StartVul> is_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab : <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> <S2SV_StartVul> &curbuf->b_vars->dv_hashtab; <S2SV_EndVul> if (bdone < ht->ht_used) { if (bdone++ == 0) hi = ht->ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; return cat_prefix_varname('b', hi->hi_key); } <S2SV_StartVul> ht = <S2SV_EndVul> <S2SV_StartVul> #ifdef FEAT_CMDWIN <S2SV_EndVul> <S2SV_StartVul> is_in_cmdwin() ? &prevwin->w_vars->dv_hashtab : <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> <S2SV_StartVul> &curwin->w_vars->dv_hashtab; <S2SV_EndVul> if (wdone < ht->ht_used) { if (wdone++ == 0) hi = ht->ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; return cat_prefix_varname('w', hi->hi_key); } ht = &curtab->tp_vars->dv_hashtab; if (tdone < ht->ht_used) { if (tdone++ == 0) hi = ht->ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; return cat_prefix_varname('t', hi->hi_key); } if (vidx < VV_LEN) return cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name); VIM_CLEAR(varnamebuf); varnamebuflen = 0; return NULL; }","- ht =
- #ifdef FEAT_CMDWIN
- is_in_cmdwin() ? &prevwin->w_buffer->b_vars->dv_hashtab :
- #endif
- &curbuf->b_vars->dv_hashtab;
- ht =
- #ifdef FEAT_CMDWIN
- is_in_cmdwin() ? &prevwin->w_vars->dv_hashtab :
- #endif
- &curwin->w_vars->dv_hashtab;
+ ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab;
+ ht = &prevwin_curwin()->w_vars->dv_hashtab;","get_user_var_name(expand_T *xp, int idx) { static long_u gdone; static long_u bdone; static long_u wdone; static long_u tdone; static int vidx; static hashitem_T *hi; hashtab_T *ht; if (idx == 0) { gdone = bdone = wdone = vidx = 0; tdone = 0; } if (gdone < globvarht.ht_used) { if (gdone++ == 0) hi = globvarht.ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; if (STRNCMP(""g:"", xp->xp_pattern, 2) == 0) return cat_prefix_varname('g', hi->hi_key); return hi->hi_key; } ht = &prevwin_curwin()->w_buffer->b_vars->dv_hashtab; if (bdone < ht->ht_used) { if (bdone++ == 0) hi = ht->ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; return cat_prefix_varname('b', hi->hi_key); } ht = &prevwin_curwin()->w_vars->dv_hashtab; if (wdone < ht->ht_used) { if (wdone++ == 0) hi = ht->ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; return cat_prefix_varname('w', hi->hi_key); } ht = &curtab->tp_vars->dv_hashtab; if (tdone < ht->ht_used) { if (tdone++ == 0) hi = ht->ht_array; else ++hi; while (HASHITEM_EMPTY(hi)) ++hi; return cat_prefix_varname('t', hi->hi_key); } if (vidx < VV_LEN) return cat_prefix_varname('v', (char_u *)vimvars[vidx++].vv_name); VIM_CLEAR(varnamebuf); varnamebuflen = 0; return NULL; }"
240,3948----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tif_predict.c----PredictorDecodeTile,"PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->decodetile != NULL); if ((*sp->decodetile)(tif, op0, occ0, s)) { tmsize_t rowsize = sp->rowsize; assert(rowsize > 0); <S2SV_StartVul> assert((occ0%rowsize)==0); <S2SV_EndVul> assert(sp->decodepfunc != NULL); while (occ0 > 0) { <S2SV_StartVul> (*sp->decodepfunc)(tif, op0, rowsize); <S2SV_EndVul> occ0 -= rowsize; op0 += rowsize; } return 1; } else return 0; }","- assert((occ0%rowsize)==0);
- (*sp->decodepfunc)(tif, op0, rowsize);
+ if((occ0%rowsize) !=0)
+ {
+ TIFFErrorExt(tif->tif_clientdata, ""PredictorDecodeTile"",
+ ""%s"", ""occ0%rowsize != 0"");
+ return 0;
+ }
+ if( !(*sp->decodepfunc)(tif, op0, rowsize) )
+ return 0;","PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s) { TIFFPredictorState *sp = PredictorState(tif); assert(sp != NULL); assert(sp->decodetile != NULL); if ((*sp->decodetile)(tif, op0, occ0, s)) { tmsize_t rowsize = sp->rowsize; assert(rowsize > 0); if((occ0%rowsize) !=0) { TIFFErrorExt(tif->tif_clientdata, ""PredictorDecodeTile"", ""%s"", ""occ0%rowsize != 0""); return 0; } assert(sp->decodepfunc != NULL); while (occ0 > 0) { if( !(*sp->decodepfunc)(tif, op0, rowsize) ) return 0; occ0 -= rowsize; op0 += rowsize; } return 1; } else return 0; }"
241,6666----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mpeg4videodec.c----mpeg4_decode_profile_level,"<S2SV_StartVul> static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb) <S2SV_EndVul> { <S2SV_StartVul> s->avctx->profile = get_bits(gb, 4); <S2SV_EndVul> <S2SV_StartVul> s->avctx->level = get_bits(gb, 4); <S2SV_EndVul> <S2SV_StartVul> if (s->avctx->profile == 0 && s->avctx->level == 8) { <S2SV_EndVul> <S2SV_StartVul> s->avctx->level = 0; <S2SV_EndVul> } return 0; }","- static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)
- s->avctx->profile = get_bits(gb, 4);
- s->avctx->level = get_bits(gb, 4);
- if (s->avctx->profile == 0 && s->avctx->level == 8) {
- s->avctx->level = 0;
+ static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)
+ if (*profile == 0 && *level == 8) {","static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level) { *profile = get_bits(gb, 4); *level = get_bits(gb, 4); if (*profile == 0 && *level == 8) { *level = 0; } return 0; }"
242,524----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-1797--x86.c----kvm_set_msr_common,"int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info) { bool pr = false; u32 msr = msr_info->index; u64 data = msr_info->data; switch (msr) { case MSR_AMD64_NB_CFG: case MSR_IA32_UCODE_REV: case MSR_IA32_UCODE_WRITE: case MSR_VM_HSAVE_PA: case MSR_AMD64_PATCH_LOADER: case MSR_AMD64_BU_CFG2: break; case MSR_EFER: return set_efer(vcpu, data); case MSR_K7_HWCR: data &= ~(u64)0x40; data &= ~(u64)0x100; data &= ~(u64)0x8; if (data != 0) { vcpu_unimpl(vcpu, ""unimplemented HWCR wrmsr: 0x%llx\n"", data); return 1; } break; case MSR_FAM10H_MMIO_CONF_BASE: if (data != 0) { vcpu_unimpl(vcpu, ""unimplemented MMIO_CONF_BASE wrmsr: "" ""0x%llx\n"", data); return 1; } break; case MSR_IA32_DEBUGCTLMSR: if (!data) { break; } else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) { return 1; } vcpu_unimpl(vcpu, ""%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\n"", __func__, data); break; case 0x200 ... 0x2ff: return set_msr_mtrr(vcpu, msr, data); case MSR_IA32_APICBASE: kvm_set_apic_base(vcpu, data); break; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff: return kvm_x2apic_msr_write(vcpu, msr, data); case MSR_IA32_TSCDEADLINE: kvm_set_lapic_tscdeadline_msr(vcpu, data); break; case MSR_IA32_TSC_ADJUST: if (guest_cpuid_has_tsc_adjust(vcpu)) { if (!msr_info->host_initiated) { u64 adj = data - vcpu->arch.ia32_tsc_adjust_msr; kvm_x86_ops->adjust_tsc_offset(vcpu, adj, true); } vcpu->arch.ia32_tsc_adjust_msr = data; } break; case MSR_IA32_MISC_ENABLE: vcpu->arch.ia32_misc_enable_msr = data; break; case MSR_KVM_WALL_CLOCK_NEW: case MSR_KVM_WALL_CLOCK: vcpu->kvm->arch.wall_clock = data; kvm_write_wall_clock(vcpu->kvm, data); break; case MSR_KVM_SYSTEM_TIME_NEW: case MSR_KVM_SYSTEM_TIME: { kvmclock_reset(vcpu); vcpu->arch.time = data; kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu); if (!(data & 1)) break; <S2SV_StartVul> vcpu->arch.time_offset = data & ~(PAGE_MASK | 1); <S2SV_EndVul> <S2SV_StartVul> if (vcpu->arch.time_offset & <S2SV_EndVul> <S2SV_StartVul> (sizeof(struct pvclock_vcpu_time_info) - 1)) <S2SV_EndVul> break; <S2SV_StartVul> vcpu->arch.time_page = <S2SV_EndVul> <S2SV_StartVul> gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT); <S2SV_EndVul> if (is_error_page(vcpu->arch.time_page)) <S2SV_StartVul> vcpu->arch.time_page = NULL; <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> break; } case MSR_KVM_ASYNC_PF_EN: if (kvm_pv_enable_async_pf(vcpu, data)) return 1; break; case MSR_KVM_STEAL_TIME: if (unlikely(!sched_info_on())) return 1; if (data & KVM_STEAL_RESERVED_MASK) return 1; if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime, data & KVM_STEAL_VALID_BITS)) return 1; vcpu->arch.st.msr_val = data; if (!(data & KVM_MSR_ENABLED)) break; vcpu->arch.st.last_steal = current->sched_info.run_delay; preempt_disable(); accumulate_steal_time(vcpu); preempt_enable(); kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu); break; case MSR_KVM_PV_EOI_EN: if (kvm_lapic_enable_pv_eoi(vcpu, data)) return 1; break; case MSR_IA32_MCG_CTL: case MSR_IA32_MCG_STATUS: case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1: return set_msr_mce(vcpu, msr, data); case MSR_K7_EVNTSEL0: case MSR_K7_EVNTSEL1: case MSR_K7_EVNTSEL2: case MSR_K7_EVNTSEL3: if (data != 0) vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: "" ""0x%x data 0x%llx\n"", msr, data); break; case MSR_K7_PERFCTR0: case MSR_K7_PERFCTR1: case MSR_K7_PERFCTR2: case MSR_K7_PERFCTR3: vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: "" ""0x%x data 0x%llx\n"", msr, data); break; case MSR_P6_PERFCTR0: case MSR_P6_PERFCTR1: pr = true; case MSR_P6_EVNTSEL0: case MSR_P6_EVNTSEL1: if (kvm_pmu_msr(vcpu, msr)) return kvm_pmu_set_msr(vcpu, msr, data); if (pr || data != 0) vcpu_unimpl(vcpu, ""disabled perfctr wrmsr: "" ""0x%x data 0x%llx\n"", msr, data); break; case MSR_K7_CLK_CTL: break; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15: if (kvm_hv_msr_partition_wide(msr)) { int r; mutex_lock(&vcpu->kvm->lock); r = set_msr_hyperv_pw(vcpu, msr, data); mutex_unlock(&vcpu->kvm->lock); return r; } else return set_msr_hyperv(vcpu, msr, data); break; case MSR_IA32_BBL_CR_CTL3: vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"", msr, data); break; case MSR_AMD64_OSVW_ID_LENGTH: if (!guest_cpuid_has_osvw(vcpu)) return 1; vcpu->arch.osvw.length = data; break; case MSR_AMD64_OSVW_STATUS: if (!guest_cpuid_has_osvw(vcpu)) return 1; vcpu->arch.osvw.status = data; break; default: if (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr)) return xen_hvm_config(vcpu, data); if (kvm_pmu_msr(vcpu, msr)) return kvm_pmu_set_msr(vcpu, msr, data); if (!ignore_msrs) { vcpu_unimpl(vcpu, ""unhandled wrmsr: 0x%x data %llx\n"", msr, data); return 1; } else { vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"", msr, data); break; } } return 0; }","- vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);
- if (vcpu->arch.time_offset &
- (sizeof(struct pvclock_vcpu_time_info) - 1))
- vcpu->arch.time_page =
- gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);
- vcpu->arch.time_page = NULL;
- 
+ u64 gpa_offset;
+ gpa_offset = data & ~(PAGE_MASK | 1);
+ if (gpa_offset & (sizeof(struct pvclock_vcpu_time_info) - 1))
+ if (kvm_gfn_to_hva_cache_init(vcpu->kvm,
+ &vcpu->arch.pv_time, data & ~1ULL))
+ vcpu->arch.pv_time_enabled = false;
+ else
+ vcpu->arch.pv_time_enabled = true;","int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info) { bool pr = false; u32 msr = msr_info->index; u64 data = msr_info->data; switch (msr) { case MSR_AMD64_NB_CFG: case MSR_IA32_UCODE_REV: case MSR_IA32_UCODE_WRITE: case MSR_VM_HSAVE_PA: case MSR_AMD64_PATCH_LOADER: case MSR_AMD64_BU_CFG2: break; case MSR_EFER: return set_efer(vcpu, data); case MSR_K7_HWCR: data &= ~(u64)0x40; data &= ~(u64)0x100; data &= ~(u64)0x8; if (data != 0) { vcpu_unimpl(vcpu, ""unimplemented HWCR wrmsr: 0x%llx\n"", data); return 1; } break; case MSR_FAM10H_MMIO_CONF_BASE: if (data != 0) { vcpu_unimpl(vcpu, ""unimplemented MMIO_CONF_BASE wrmsr: "" ""0x%llx\n"", data); return 1; } break; case MSR_IA32_DEBUGCTLMSR: if (!data) { break; } else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) { return 1; } vcpu_unimpl(vcpu, ""%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\n"", __func__, data); break; case 0x200 ... 0x2ff: return set_msr_mtrr(vcpu, msr, data); case MSR_IA32_APICBASE: kvm_set_apic_base(vcpu, data); break; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff: return kvm_x2apic_msr_write(vcpu, msr, data); case MSR_IA32_TSCDEADLINE: kvm_set_lapic_tscdeadline_msr(vcpu, data); break; case MSR_IA32_TSC_ADJUST: if (guest_cpuid_has_tsc_adjust(vcpu)) { if (!msr_info->host_initiated) { u64 adj = data - vcpu->arch.ia32_tsc_adjust_msr; kvm_x86_ops->adjust_tsc_offset(vcpu, adj, true); } vcpu->arch.ia32_tsc_adjust_msr = data; } break; case MSR_IA32_MISC_ENABLE: vcpu->arch.ia32_misc_enable_msr = data; break; case MSR_KVM_WALL_CLOCK_NEW: case MSR_KVM_WALL_CLOCK: vcpu->kvm->arch.wall_clock = data; kvm_write_wall_clock(vcpu->kvm, data); break; case MSR_KVM_SYSTEM_TIME_NEW: case MSR_KVM_SYSTEM_TIME: { u64 gpa_offset; kvmclock_reset(vcpu); vcpu->arch.time = data; kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu); if (!(data & 1)) break; gpa_offset = data & ~(PAGE_MASK | 1); if (gpa_offset & (sizeof(struct pvclock_vcpu_time_info) - 1)) break; if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_time, data & ~1ULL)) vcpu->arch.pv_time_enabled = false; else vcpu->arch.pv_time_enabled = true; break; } case MSR_KVM_ASYNC_PF_EN: if (kvm_pv_enable_async_pf(vcpu, data)) return 1; break; case MSR_KVM_STEAL_TIME: if (unlikely(!sched_info_on())) return 1; if (data & KVM_STEAL_RESERVED_MASK) return 1; if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime, data & KVM_STEAL_VALID_BITS)) return 1; vcpu->arch.st.msr_val = data; if (!(data & KVM_MSR_ENABLED)) break; vcpu->arch.st.last_steal = current->sched_info.run_delay; preempt_disable(); accumulate_steal_time(vcpu); preempt_enable(); kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu); break; case MSR_KVM_PV_EOI_EN: if (kvm_lapic_enable_pv_eoi(vcpu, data)) return 1; break; case MSR_IA32_MCG_CTL: case MSR_IA32_MCG_STATUS: case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1: return set_msr_mce(vcpu, msr, data); case MSR_K7_EVNTSEL0: case MSR_K7_EVNTSEL1: case MSR_K7_EVNTSEL2: case MSR_K7_EVNTSEL3: if (data != 0) vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: "" ""0x%x data 0x%llx\n"", msr, data); break; case MSR_K7_PERFCTR0: case MSR_K7_PERFCTR1: case MSR_K7_PERFCTR2: case MSR_K7_PERFCTR3: vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: "" ""0x%x data 0x%llx\n"", msr, data); break; case MSR_P6_PERFCTR0: case MSR_P6_PERFCTR1: pr = true; case MSR_P6_EVNTSEL0: case MSR_P6_EVNTSEL1: if (kvm_pmu_msr(vcpu, msr)) return kvm_pmu_set_msr(vcpu, msr, data); if (pr || data != 0) vcpu_unimpl(vcpu, ""disabled perfctr wrmsr: "" ""0x%x data 0x%llx\n"", msr, data); break; case MSR_K7_CLK_CTL: break; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15: if (kvm_hv_msr_partition_wide(msr)) { int r; mutex_lock(&vcpu->kvm->lock); r = set_msr_hyperv_pw(vcpu, msr, data); mutex_unlock(&vcpu->kvm->lock); return r; } else return set_msr_hyperv(vcpu, msr, data); break; case MSR_IA32_BBL_CR_CTL3: vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"", msr, data); break; case MSR_AMD64_OSVW_ID_LENGTH: if (!guest_cpuid_has_osvw(vcpu)) return 1; vcpu->arch.osvw.length = data; break; case MSR_AMD64_OSVW_STATUS: if (!guest_cpuid_has_osvw(vcpu)) return 1; vcpu->arch.osvw.status = data; break; default: if (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr)) return xen_hvm_config(vcpu, data); if (kvm_pmu_msr(vcpu, msr)) return kvm_pmu_set_msr(vcpu, msr, data); if (!ignore_msrs) { vcpu_unimpl(vcpu, ""unhandled wrmsr: 0x%x data %llx\n"", msr, data); return 1; } else { vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"", msr, data); break; } } return 0; }"
243,3541----CWE-134----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/msg.c----econn_message_encode,"int econn_message_encode(char **strp, const struct econn_message *msg) { struct json_object *jobj = NULL; char *str = NULL; int err; if (!strp || !msg) return EINVAL; err = jzon_creatf(&jobj, ""sss"", ""version"", econn_proto_version, ""type"", econn_msg_name(msg->msg_type), ""sessid"", msg->sessid_sender); if (err) return err; if (str_isset(msg->src_userid)) { err = jzon_add_str(jobj, ""src_userid"", ""%s"", msg->src_userid); if (err) goto out; } if (str_isset(msg->src_clientid)) { err = jzon_add_str(jobj, ""src_clientid"", ""%s"", msg->src_clientid); if (err) goto out; } if (str_isset(msg->dest_userid)) { err = jzon_add_str(jobj, ""dest_userid"", ""%s"", msg->dest_userid); if (err) goto out; } if (str_isset(msg->dest_clientid)) { err = jzon_add_str(jobj, ""dest_clientid"", ""%s"", msg->dest_clientid); if (err) goto out; } err = jzon_add_bool(jobj, ""resp"", msg->resp); if (err) goto out; switch (msg->msg_type) { case ECONN_SETUP: case ECONN_GROUP_SETUP: case ECONN_UPDATE: err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.setup.sdp_msg); if (err) goto out; if (msg->u.setup.props) { err = econn_props_encode(jobj, msg->u.setup.props); if (err) goto out; } if (msg->u.setup.url) { err = jzon_add_str(jobj, ""url"", ""%s"", msg->u.setup.url); if (err) goto out; } break; case ECONN_CANCEL: break; case ECONN_HANGUP: break; case ECONN_REJECT: break; case ECONN_PROPSYNC: if (!msg->u.propsync.props) { warning(""propsync: missing props\n""); err = EINVAL; goto out; } err = econn_props_encode(jobj, msg->u.propsync.props); if (err) goto out; break; case ECONN_GROUP_START: if (msg->u.groupstart.props) { err = econn_props_encode(jobj, msg->u.groupstart.props); if (err) goto out; } break; case ECONN_GROUP_LEAVE: case ECONN_GROUP_CHECK: break; case ECONN_CONF_CONN: if (msg->u.confconn.turnc > 0) { err = zapi_iceservers_encode(jobj, msg->u.confconn.turnv, msg->u.confconn.turnc); if (err) goto out; } jzon_add_bool(jobj, ""update"", msg->u.confconn.update); <S2SV_StartVul> jzon_add_str(jobj, ""tool"", <S2SV_EndVul> <S2SV_StartVul> msg->u.confconn.tool); <S2SV_EndVul> jzon_add_str(jobj, ""toolver"", <S2SV_StartVul> msg->u.confconn.toolver); <S2SV_EndVul> jzon_add_int(jobj, ""status"", msg->u.confconn.status); jzon_add_bool(jobj, ""selective_audio"", msg->u.confconn.selective_audio); jzon_add_bool(jobj, ""selective_video"", msg->u.confconn.selective_video); jzon_add_int(jobj, ""vstreams"", msg->u.confconn.vstreams); break; case ECONN_CONF_START: jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confstart.sft_url); jzon_add_base64(jobj, ""secret"", msg->u.confstart.secret, msg->u.confstart.secretlen); jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confstart.timestamp); jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confstart.seqno); if (msg->u.confstart.props) { err = econn_props_encode(jobj, msg->u.confstart.props); if (err) goto out; } break; case ECONN_CONF_CHECK: jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confcheck.sft_url); jzon_add_base64(jobj, ""secret"", msg->u.confcheck.secret, msg->u.confcheck.secretlen); jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confcheck.timestamp); jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confcheck.seqno); break; case ECONN_CONF_END: break; case ECONN_CONF_PART: jzon_add_bool(jobj, ""should_start"", msg->u.confpart.should_start); jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confpart.timestamp); jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confpart.seqno); jzon_add_base64(jobj, ""entropy"", msg->u.confpart.entropy, msg->u.confpart.entropylen); econn_parts_encode(jobj, &msg->u.confpart.partl); break; case ECONN_CONF_KEY: econn_keys_encode(jobj, &msg->u.confkey.keyl); break; case ECONN_DEVPAIR_PUBLISH: err = zapi_iceservers_encode(jobj, msg->u.devpair_publish.turnv, msg->u.devpair_publish.turnc); if (err) goto out; err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.devpair_publish.sdp); err |= jzon_add_str(jobj, ""username"", ""%s"", msg->u.devpair_publish.username); if (err) goto out; break; case ECONN_DEVPAIR_ACCEPT: err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.devpair_accept.sdp); if (err) goto out; break; case ECONN_ALERT: err = jzon_add_int(jobj, ""level"", msg->u.alert.level); err |= jzon_add_str(jobj, ""descr"", ""%s"", msg->u.alert.descr); if (err) goto out; break; case ECONN_PING: break; default: warning(""econn: dont know how to encode %d\n"", msg->msg_type); err = EBADMSG; break; } if (err) goto out; err = jzon_encode(&str, jobj); if (err) goto out; out: mem_deref(jobj); if (err) mem_deref(str); else *strp = str; return err; }","- jzon_add_str(jobj, ""tool"",
- msg->u.confconn.tool);
- msg->u.confconn.toolver);
+ jzon_add_str(jobj, ""tool"",
+ ""%s"", msg->u.confconn.tool);
+ ""%s"", msg->u.confconn.toolver);","int econn_message_encode(char **strp, const struct econn_message *msg) { struct json_object *jobj = NULL; char *str = NULL; int err; if (!strp || !msg) return EINVAL; err = jzon_creatf(&jobj, ""sss"", ""version"", econn_proto_version, ""type"", econn_msg_name(msg->msg_type), ""sessid"", msg->sessid_sender); if (err) return err; if (str_isset(msg->src_userid)) { err = jzon_add_str(jobj, ""src_userid"", ""%s"", msg->src_userid); if (err) goto out; } if (str_isset(msg->src_clientid)) { err = jzon_add_str(jobj, ""src_clientid"", ""%s"", msg->src_clientid); if (err) goto out; } if (str_isset(msg->dest_userid)) { err = jzon_add_str(jobj, ""dest_userid"", ""%s"", msg->dest_userid); if (err) goto out; } if (str_isset(msg->dest_clientid)) { err = jzon_add_str(jobj, ""dest_clientid"", ""%s"", msg->dest_clientid); if (err) goto out; } err = jzon_add_bool(jobj, ""resp"", msg->resp); if (err) goto out; switch (msg->msg_type) { case ECONN_SETUP: case ECONN_GROUP_SETUP: case ECONN_UPDATE: err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.setup.sdp_msg); if (err) goto out; if (msg->u.setup.props) { err = econn_props_encode(jobj, msg->u.setup.props); if (err) goto out; } if (msg->u.setup.url) { err = jzon_add_str(jobj, ""url"", ""%s"", msg->u.setup.url); if (err) goto out; } break; case ECONN_CANCEL: break; case ECONN_HANGUP: break; case ECONN_REJECT: break; case ECONN_PROPSYNC: if (!msg->u.propsync.props) { warning(""propsync: missing props\n""); err = EINVAL; goto out; } err = econn_props_encode(jobj, msg->u.propsync.props); if (err) goto out; break; case ECONN_GROUP_START: if (msg->u.groupstart.props) { err = econn_props_encode(jobj, msg->u.groupstart.props); if (err) goto out; } break; case ECONN_GROUP_LEAVE: case ECONN_GROUP_CHECK: break; case ECONN_CONF_CONN: if (msg->u.confconn.turnc > 0) { err = zapi_iceservers_encode(jobj, msg->u.confconn.turnv, msg->u.confconn.turnc); if (err) goto out; } jzon_add_bool(jobj, ""update"", msg->u.confconn.update); jzon_add_str(jobj, ""tool"", ""%s"", msg->u.confconn.tool); jzon_add_str(jobj, ""toolver"", ""%s"", msg->u.confconn.toolver); jzon_add_int(jobj, ""status"", msg->u.confconn.status); jzon_add_bool(jobj, ""selective_audio"", msg->u.confconn.selective_audio); jzon_add_bool(jobj, ""selective_video"", msg->u.confconn.selective_video); jzon_add_int(jobj, ""vstreams"", msg->u.confconn.vstreams); break; case ECONN_CONF_START: jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confstart.sft_url); jzon_add_base64(jobj, ""secret"", msg->u.confstart.secret, msg->u.confstart.secretlen); jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confstart.timestamp); jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confstart.seqno); if (msg->u.confstart.props) { err = econn_props_encode(jobj, msg->u.confstart.props); if (err) goto out; } break; case ECONN_CONF_CHECK: jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confcheck.sft_url); jzon_add_base64(jobj, ""secret"", msg->u.confcheck.secret, msg->u.confcheck.secretlen); jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confcheck.timestamp); jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confcheck.seqno); break; case ECONN_CONF_END: break; case ECONN_CONF_PART: jzon_add_bool(jobj, ""should_start"", msg->u.confpart.should_start); jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confpart.timestamp); jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confpart.seqno); jzon_add_base64(jobj, ""entropy"", msg->u.confpart.entropy, msg->u.confpart.entropylen); econn_parts_encode(jobj, &msg->u.confpart.partl); break; case ECONN_CONF_KEY: econn_keys_encode(jobj, &msg->u.confkey.keyl); break; case ECONN_DEVPAIR_PUBLISH: err = zapi_iceservers_encode(jobj, msg->u.devpair_publish.turnv, msg->u.devpair_publish.turnc); if (err) goto out; err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.devpair_publish.sdp); err |= jzon_add_str(jobj, ""username"", ""%s"", msg->u.devpair_publish.username); if (err) goto out; break; case ECONN_DEVPAIR_ACCEPT: err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.devpair_accept.sdp); if (err) goto out; break; case ECONN_ALERT: err = jzon_add_int(jobj, ""level"", msg->u.alert.level); err |= jzon_add_str(jobj, ""descr"", ""%s"", msg->u.alert.descr); if (err) goto out; break; case ECONN_PING: break; default: warning(""econn: dont know how to encode %d\n"", msg->msg_type); err = EBADMSG; break; } if (err) goto out; err = jzon_encode(&str, jobj); if (err) goto out; out: mem_deref(jobj); if (err) mem_deref(str); else *strp = str; return err; }"
244,1786----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-8675--m4vdec.c----mpeg4video_probe,"static int mpeg4video_probe(AVProbeData *probe_packet) { uint32_t temp_buffer = -1; int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0; int i; for (i = 0; i < probe_packet->buf_size; i++) { temp_buffer = (temp_buffer << 8) + probe_packet->buf[i]; <S2SV_StartVul> if ((temp_buffer & 0xffffff00) != 0x100) <S2SV_EndVul> continue; if (temp_buffer == VOP_START_CODE) VOP++; else if (temp_buffer == VISUAL_OBJECT_START_CODE) VISO++; <S2SV_StartVul> else if (temp_buffer < 0x120) <S2SV_EndVul> VO++; <S2SV_StartVul> else if (temp_buffer < 0x130) <S2SV_EndVul> VOL++; else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) && !(0x1B9 < temp_buffer && temp_buffer < 0x1C4)) res++; } if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0) return AVPROBE_SCORE_EXTENSION; return 0; }","- if ((temp_buffer & 0xffffff00) != 0x100)
- else if (temp_buffer < 0x120)
- else if (temp_buffer < 0x130)
+ if (temp_buffer & 0xfffffe00)
+ continue;
+ if (temp_buffer < 2)
+ else if (temp_buffer >= 0x100 && temp_buffer < 0x120)
+ else if (temp_buffer >= 0x120 && temp_buffer < 0x130)","static int mpeg4video_probe(AVProbeData *probe_packet) { uint32_t temp_buffer = -1; int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0; int i; for (i = 0; i < probe_packet->buf_size; i++) { temp_buffer = (temp_buffer << 8) + probe_packet->buf[i]; if (temp_buffer & 0xfffffe00) continue; if (temp_buffer < 2) continue; if (temp_buffer == VOP_START_CODE) VOP++; else if (temp_buffer == VISUAL_OBJECT_START_CODE) VISO++; else if (temp_buffer >= 0x100 && temp_buffer < 0x120) VO++; else if (temp_buffer >= 0x120 && temp_buffer < 0x130) VOL++; else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) && !(0x1B9 < temp_buffer && temp_buffer < 0x1C4)) res++; } if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0) return AVPROBE_SCORE_EXTENSION; return 0; }"
245,1055----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-3841--ipv6_sockglue.c----*ipv6_update_options,"struct ipv6_txoptions *ipv6_update_options(struct sock *sk, struct ipv6_txoptions *opt) { if (inet_sk(sk)->is_icsk) { if (opt && !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) && inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) { struct inet_connection_sock *icsk = inet_csk(sk); icsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen; icsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie); } } <S2SV_StartVul> opt = xchg(&inet6_sk(sk)->opt, opt); <S2SV_EndVul> sk_dst_reset(sk); return opt; }","- opt = xchg(&inet6_sk(sk)->opt, opt);
+ opt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,
+ opt);","struct ipv6_txoptions *ipv6_update_options(struct sock *sk, struct ipv6_txoptions *opt) { if (inet_sk(sk)->is_icsk) { if (opt && !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) && inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) { struct inet_connection_sock *icsk = inet_csk(sk); icsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen; icsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie); } } opt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt, opt); sk_dst_reset(sk); return opt; }"
246,5341----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pf.c----pf_init,"static int __init pf_init(void) { struct pf_unit *pf; int unit; if (disable) return -EINVAL; pf_init_units(); if (pf_detect()) return -ENODEV; pf_busy = 0; if (register_blkdev(major, name)) { <S2SV_StartVul> for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) <S2SV_EndVul> put_disk(pf->disk); return -EBUSY; } for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) { struct gendisk *disk = pf->disk; if (!pf->present) continue; disk->private_data = pf; add_disk(disk); } return 0; }","- for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)
+ for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
+ if (!pf->disk)
+ continue;
+ blk_cleanup_queue(pf->disk->queue);
+ blk_mq_free_tag_set(&pf->tag_set);
+ }","static int __init pf_init(void) { struct pf_unit *pf; int unit; if (disable) return -EINVAL; pf_init_units(); if (pf_detect()) return -ENODEV; pf_busy = 0; if (register_blkdev(major, name)) { for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) { if (!pf->disk) continue; blk_cleanup_queue(pf->disk->queue); blk_mq_free_tag_set(&pf->tag_set); put_disk(pf->disk); } return -EBUSY; } for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) { struct gendisk *disk = pf->disk; if (!pf->present) continue; disk->private_data = pf; add_disk(disk); } return 0; }"
247,6799----CWE-269----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/iniparser.c----iniparser_load,"<S2SV_StartVul> dictionary * iniparser_load(const char * ininame) <S2SV_EndVul> { FILE * in ; char line [ASCIILINESZ+1] ; char section [ASCIILINESZ+1] ; char key [ASCIILINESZ+1] ; char tmp [(ASCIILINESZ * 2) + 1] ; char val [ASCIILINESZ+1] ; int last=0 ; int len ; int lineno=0 ; int errs=0; dictionary * dict ; if ((in=fopen(ininame, ""r""))==NULL) { fprintf(stderr, ""iniparser: cannot open %s\n"", ininame); return NULL ; } dict = dictionary_new(0) ; if (!dict) { fclose(in); return NULL ; } memset(line, 0, ASCIILINESZ); memset(section, 0, ASCIILINESZ); memset(key, 0, ASCIILINESZ); memset(val, 0, ASCIILINESZ); last=0 ; while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) { lineno++ ; len = (int)strlen(line)-1; if (len==0) continue; if (line[len]!='\n' && !feof(in)) { fprintf(stderr, ""iniparser: input line too long in %s (%d)\n"", ininame, lineno); dictionary_del(dict); fclose(in); return NULL ; } while ((len>=0) && ((line[len]=='\n') || (isspace(line[len])))) { line[len]=0 ; len-- ; } if (len < 0) { len = 0; } if (line[len]=='\\') { last=len ; continue ; } else { last=0 ; } switch (iniparser_line(line, section, key, val)) { case LINE_EMPTY: case LINE_COMMENT: break ; case LINE_SECTION: errs = dictionary_set(dict, section, NULL); break ; case LINE_VALUE: sprintf(tmp, ""%s:%s"", section, key); errs = dictionary_set(dict, tmp, val) ; break ; case LINE_ERROR: <S2SV_StartVul> fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"", <S2SV_EndVul> <S2SV_StartVul> ininame, <S2SV_EndVul> <S2SV_StartVul> lineno); <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""-> %s\n"", line); <S2SV_EndVul> errs++ ; break; default: break ; } memset(line, 0, ASCIILINESZ); last=0; if (errs<0) { fprintf(stderr, ""iniparser: memory allocation failure\n""); break ; } } if (errs) { dictionary_del(dict); dict = NULL ; } fclose(in); return dict ; }","- dictionary * iniparser_load(const char * ininame)
- fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"",
- ininame,
- lineno);
- fprintf(stderr, ""-> %s\n"", line);
+ dictionary * iniparser_load(const char * ininame, load_options options)
+ if(options & HIDE_ERRORED_LINE_CONTENT) {
+ fprintf(stderr, ""iniparser: syntax error in %s (%d)\n"",
+ ininame,
+ lineno);
+ }
+ else {
+ fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"",
+ ininame,
+ lineno);
+ fprintf(stderr, ""-> %s\n"", line);
+ }","dictionary * iniparser_load(const char * ininame, load_options options) { FILE * in ; char line [ASCIILINESZ+1] ; char section [ASCIILINESZ+1] ; char key [ASCIILINESZ+1] ; char tmp [(ASCIILINESZ * 2) + 1] ; char val [ASCIILINESZ+1] ; int last=0 ; int len ; int lineno=0 ; int errs=0; dictionary * dict ; if ((in=fopen(ininame, ""r""))==NULL) { fprintf(stderr, ""iniparser: cannot open %s\n"", ininame); return NULL ; } dict = dictionary_new(0) ; if (!dict) { fclose(in); return NULL ; } memset(line, 0, ASCIILINESZ); memset(section, 0, ASCIILINESZ); memset(key, 0, ASCIILINESZ); memset(val, 0, ASCIILINESZ); last=0 ; while (fgets(line+last, ASCIILINESZ-last, in)!=NULL) { lineno++ ; len = (int)strlen(line)-1; if (len==0) continue; if (line[len]!='\n' && !feof(in)) { fprintf(stderr, ""iniparser: input line too long in %s (%d)\n"", ininame, lineno); dictionary_del(dict); fclose(in); return NULL ; } while ((len>=0) && ((line[len]=='\n') || (isspace(line[len])))) { line[len]=0 ; len-- ; } if (len < 0) { len = 0; } if (line[len]=='\\') { last=len ; continue ; } else { last=0 ; } switch (iniparser_line(line, section, key, val)) { case LINE_EMPTY: case LINE_COMMENT: break ; case LINE_SECTION: errs = dictionary_set(dict, section, NULL); break ; case LINE_VALUE: sprintf(tmp, ""%s:%s"", section, key); errs = dictionary_set(dict, tmp, val) ; break ; case LINE_ERROR: if(options & HIDE_ERRORED_LINE_CONTENT) { fprintf(stderr, ""iniparser: syntax error in %s (%d)\n"", ininame, lineno); } else { fprintf(stderr, ""iniparser: syntax error in %s (%d):\n"", ininame, lineno); fprintf(stderr, ""-> %s\n"", line); } errs++ ; break; default: break ; } memset(line, 0, ASCIILINESZ); last=0; if (errs<0) { fprintf(stderr, ""iniparser: memory allocation failure\n""); break ; } } if (errs) { dictionary_del(dict); dict = NULL ; } fclose(in); return dict ; }"
248,799----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-5273--abrt-action-install-debuginfo-to-abrt-cache.c----main,"int main(int argc, char **argv) { setlocale(LC_ALL, """"); #if ENABLE_NLS bindtextdomain(PACKAGE, LOCALEDIR); textdomain(PACKAGE); #endif abrt_init(argv); const char *program_usage_string = _( ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n"" ""\t[-r REPO]\n"" ""\n"" ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n"" ""ABRT system cache."" ); enum { OPT_v = 1 << 0, OPT_y = 1 << 1, OPT_i = 1 << 2, OPT_e = 1 << 3, OPT_r = 1 << 4, OPT_s = 1 << 5, }; const char *build_ids = ""build_ids""; const char *exact = NULL; const char *repo = NULL; const char *size_mb = NULL; struct options program_options[] = { OPT__VERBOSE(&g_verbose), OPT_BOOL ('y', ""yes"", NULL, _(""Noninteractive, assume 'Yes' to all questions"")), OPT_STRING('i', ""ids"", &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")), OPT_STRING('e', ""exact"", &exact, ""EXACT"", _(""Download only specified files"")), OPT_STRING('r', ""repo"", &repo, ""REPO"", _(""Pattern to use when searching for repos, default: *debug*"")), OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"", _(""Ignored option"")), OPT_END() }; const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string); const gid_t egid = getegid(); const gid_t rgid = getgid(); const uid_t euid = geteuid(); const gid_t ruid = getuid(); char *build_ids_self_fd = NULL; if (strcmp(""-"", build_ids) != 0) { if (setregid(egid, rgid) < 0) perror_msg_and_die(""setregid(egid, rgid)""); if (setreuid(euid, ruid) < 0) perror_msg_and_die(""setreuid(euid, ruid)""); const int build_ids_fd = open(build_ids, O_RDONLY); if (setregid(rgid, egid) < 0) perror_msg_and_die(""setregid(rgid, egid)""); if (setreuid(ruid, euid) < 0 ) perror_msg_and_die(""setreuid(ruid, euid)""); if (build_ids_fd < 0) perror_msg_and_die(""Failed to open file '%s'"", build_ids); build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd); } <S2SV_StartVul> const char *args[11]; <S2SV_EndVul> { const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" }; unsigned i = 0; args[i++] = EXECUTABLE; args[i++] = ""--ids""; args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-""; if (g_verbose > 0) args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3]; if ((opts & OPT_y)) args[i++] = ""-y""; if ((opts & OPT_e)) { args[i++] = ""--exact""; args[i++] = exact; } if ((opts & OPT_r)) { args[i++] = ""--repo""; args[i++] = repo; } args[i++] = ""--""; args[i] = NULL; } if (egid != rgid) IGNORE_RESULT(setregid(egid, egid)); if (euid != ruid) { IGNORE_RESULT(setreuid(euid, euid)); #if 1 static const char *whitelist[] = { ""REPORT_CLIENT_SLAVE"", ""LANG"", }; const size_t wlsize = sizeof(whitelist)/sizeof(char*); char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 }; char *p = NULL; for (size_t i = 0; i < wlsize; i++) if ((p = getenv(whitelist[i])) != NULL) setlist[i] = xstrdup(p); clearenv(); for (size_t i = 0; i < wlsize; i++) if (setlist[i] != NULL) { xsetenv(whitelist[i], setlist[i]); free(setlist[i]); } #else static const char forbid[] = ""LD_LIBRARY_PATH"" ""\0"" ""LD_PRELOAD"" ""\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\0"" ""LD_BIND_NOW"" ""\0"" ""LD_AOUT_LIBRARY_PATH"" ""\0"" ""LD_AOUT_PRELOAD"" ""\0"" ""LD_NOWARN"" ""\0"" ""LD_KEEPDIR"" ""\0"" ; const char *p = forbid; do { unsetenv(p); p += strlen(p) + 1; } while (*p); #endif char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR; if (euid != 0) strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR); putenv(path_env); umask(0022); } execvp(EXECUTABLE, (char **)args); error_msg_and_die(""Can't execute %s"", EXECUTABLE); }","- const char *args[11];
+ char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX"";
+ if (mkdtemp(tmp_directory) == NULL)
+ perror_msg_and_die(""Failed to create working directory"");
+ log_info(""Created working directory: %s"", tmp_directory);
+ const char *args[13];
+ args[i++] = ""--tmpdir"";
+ args[i++] = tmp_directory;
+ int status;
+ if (safe_waitpid(pid, &status, 0) < 0)
+ perror_msg_and_die(""waitpid"");
+ if (rmdir(tmp_directory) >= 0)
+ log_info(""Removed working directory: %s"", tmp_directory);
+ else if (errno != ENOENT)
+ perror_msg(""Failed to remove working directory"");
+ 
+ if (WIFEXITED(status))
+ return WEXITSTATUS(status);
+ 
+ error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status));
+ 
+ error_msg_and_die(""Child exit failed"");
+ }","int main(int argc, char **argv) { setlocale(LC_ALL, """"); #if ENABLE_NLS bindtextdomain(PACKAGE, LOCALEDIR); textdomain(PACKAGE); #endif abrt_init(argv); const char *program_usage_string = _( ""& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\n"" ""\t[-r REPO]\n"" ""\n"" ""Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\n"" ""ABRT system cache."" ); enum { OPT_v = 1 << 0, OPT_y = 1 << 1, OPT_i = 1 << 2, OPT_e = 1 << 3, OPT_r = 1 << 4, OPT_s = 1 << 5, }; const char *build_ids = ""build_ids""; const char *exact = NULL; const char *repo = NULL; const char *size_mb = NULL; struct options program_options[] = { OPT__VERBOSE(&g_verbose), OPT_BOOL ('y', ""yes"", NULL, _(""Noninteractive, assume 'Yes' to all questions"")), OPT_STRING('i', ""ids"", &build_ids, ""BUILD_IDS_FILE"", _(""- means STDIN, default: build_ids"")), OPT_STRING('e', ""exact"", &exact, ""EXACT"", _(""Download only specified files"")), OPT_STRING('r', ""repo"", &repo, ""REPO"", _(""Pattern to use when searching for repos, default: *debug*"")), OPT_STRING('s', ""size_mb"", &size_mb, ""SIZE_MB"", _(""Ignored option"")), OPT_END() }; const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string); const gid_t egid = getegid(); const gid_t rgid = getgid(); const uid_t euid = geteuid(); const gid_t ruid = getuid(); char *build_ids_self_fd = NULL; if (strcmp(""-"", build_ids) != 0) { if (setregid(egid, rgid) < 0) perror_msg_and_die(""setregid(egid, rgid)""); if (setreuid(euid, ruid) < 0) perror_msg_and_die(""setreuid(euid, ruid)""); const int build_ids_fd = open(build_ids, O_RDONLY); if (setregid(rgid, egid) < 0) perror_msg_and_die(""setregid(rgid, egid)""); if (setreuid(ruid, euid) < 0 ) perror_msg_and_die(""setreuid(ruid, euid)""); if (build_ids_fd < 0) perror_msg_and_die(""Failed to open file '%s'"", build_ids); build_ids_self_fd = xasprintf(""/proc/self/fd/%d"", build_ids_fd); } char tmp_directory[] = LARGE_DATA_TMP_DIR""/abrt-tmp-debuginfo.XXXXXX""; if (mkdtemp(tmp_directory) == NULL) perror_msg_and_die(""Failed to create working directory""); log_info(""Created working directory: %s"", tmp_directory); const char *args[13]; { const char *verbs[] = { """", ""-v"", ""-vv"", ""-vvv"" }; unsigned i = 0; args[i++] = EXECUTABLE; args[i++] = ""--ids""; args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : ""-""; if (g_verbose > 0) args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3]; if ((opts & OPT_y)) args[i++] = ""-y""; if ((opts & OPT_e)) { args[i++] = ""--exact""; args[i++] = exact; } if ((opts & OPT_r)) { args[i++] = ""--repo""; args[i++] = repo; } args[i++] = ""--tmpdir""; args[i++] = tmp_directory; args[i++] = ""--""; args[i] = NULL; } if (egid != rgid) IGNORE_RESULT(setregid(egid, egid)); if (euid != ruid) { IGNORE_RESULT(setreuid(euid, euid)); #if 1 static const char *whitelist[] = { ""REPORT_CLIENT_SLAVE"", ""LANG"", }; const size_t wlsize = sizeof(whitelist)/sizeof(char*); char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 }; char *p = NULL; for (size_t i = 0; i < wlsize; i++) if ((p = getenv(whitelist[i])) != NULL) setlist[i] = xstrdup(p); clearenv(); for (size_t i = 0; i < wlsize; i++) if (setlist[i] != NULL) { xsetenv(whitelist[i], setlist[i]); free(setlist[i]); } #else static const char forbid[] = ""LD_LIBRARY_PATH"" ""\0"" ""LD_PRELOAD"" ""\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\0"" ""LD_BIND_NOW"" ""\0"" ""LD_AOUT_LIBRARY_PATH"" ""\0"" ""LD_AOUT_PRELOAD"" ""\0"" ""LD_NOWARN"" ""\0"" ""LD_KEEPDIR"" ""\0"" ; const char *p = forbid; do { unsetenv(p); p += strlen(p) + 1; } while (*p); #endif char path_env[] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:""BIN_DIR"":""SBIN_DIR; if (euid != 0) strcpy(path_env, ""PATH=/usr/bin:/bin:""BIN_DIR); putenv(path_env); umask(0022); } pid_t pid = fork(); if (pid < 0) perror_msg_and_die(""fork""); if (pid == 0) { execvp(EXECUTABLE, (char **)args); error_msg_and_die(""Can't execute %s"", EXECUTABLE); } int status; if (safe_waitpid(pid, &status, 0) < 0) perror_msg_and_die(""waitpid""); if (rmdir(tmp_directory) >= 0) log_info(""Removed working directory: %s"", tmp_directory); else if (errno != ENOENT) perror_msg(""Failed to remove working directory""); if (WIFEXITED(status)) return WEXITSTATUS(status); if (WIFSIGNALED(status)) error_msg_and_die(""Child terminated with signal %d"", WTERMSIG(status)); error_msg_and_die(""Child exit failed""); }"
249,3943----CWE-674----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/QPDFObjectHandle.cc----QPDFObjectHandle::parseInternal,"QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input, std::string const& object_description, QPDFTokenizer& tokenizer, bool& empty, StringDecrypter* decrypter, QPDF* context, bool content_stream) { empty = false; QPDFObjectHandle object; std::vector<std::vector<QPDFObjectHandle> > olist_stack; olist_stack.push_back(std::vector<QPDFObjectHandle>()); std::vector<parser_state_e> state_stack; state_stack.push_back(st_top); std::vector<qpdf_offset_t> offset_stack; qpdf_offset_t offset = input->tell(); offset_stack.push_back(offset); bool done = false; while (! done) { std::vector<QPDFObjectHandle>& olist = olist_stack.back(); parser_state_e state = state_stack.back(); offset = offset_stack.back(); object = QPDFObjectHandle(); QPDFTokenizer::Token token = tokenizer.readToken(input, object_description, true); switch (token.getType()) { case QPDFTokenizer::tt_eof: if (! content_stream) { QTC::TC(""qpdf"", ""QPDFObjectHandle eof in parseInternal""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unexpected EOF"")); } state = st_eof; break; case QPDFTokenizer::tt_bad: QTC::TC(""qpdf"", ""QPDFObjectHandle bad token in parse""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), token.getErrorMessage())); object = newNull(); break; case QPDFTokenizer::tt_brace_open: case QPDFTokenizer::tt_brace_close: QTC::TC(""qpdf"", ""QPDFObjectHandle bad brace""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unexpected brace token as null"")); object = newNull(); break; case QPDFTokenizer::tt_array_close: if (state == st_array) { state = st_stop; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle bad array close""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unexpected array close token as null"")); object = newNull(); } break; case QPDFTokenizer::tt_dict_close: if (state == st_dictionary) { state = st_stop; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle bad dictionary close""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unexpected dictionary close token"")); object = newNull(); } break; case QPDFTokenizer::tt_array_open: case QPDFTokenizer::tt_dict_open: <S2SV_StartVul> olist_stack.push_back(std::vector<QPDFObjectHandle>()); <S2SV_EndVul> <S2SV_StartVul> state = st_start; <S2SV_EndVul> <S2SV_StartVul> offset_stack.push_back(input->tell()); <S2SV_EndVul> <S2SV_StartVul> state_stack.push_back( <S2SV_EndVul> <S2SV_StartVul> (token.getType() == QPDFTokenizer::tt_array_open) ? <S2SV_EndVul> <S2SV_StartVul> st_array : st_dictionary); <S2SV_EndVul> break; case QPDFTokenizer::tt_bool: object = newBool((token.getValue() == ""true"")); break; case QPDFTokenizer::tt_null: object = newNull(); break; case QPDFTokenizer::tt_integer: object = newInteger(QUtil::string_to_ll(token.getValue().c_str())); break; case QPDFTokenizer::tt_real: object = newReal(token.getValue()); break; case QPDFTokenizer::tt_name: object = newName(token.getValue()); break; case QPDFTokenizer::tt_word: { std::string const& value = token.getValue(); if (content_stream) { object = QPDFObjectHandle::newOperator(value); } else if ((value == ""R"") && (state != st_top) && (olist.size() >= 2) && (! olist.at(olist.size() - 1).isIndirect()) && (olist.at(olist.size() - 1).isInteger()) && (! olist.at(olist.size() - 2).isIndirect()) && (olist.at(olist.size() - 2).isInteger())) { if (context == 0) { QTC::TC(""qpdf"", ""QPDFObjectHandle indirect without context""); throw std::logic_error( ""QPDFObjectHandle::parse called without context"" "" on an object with indirect references""); } object = newIndirect( context, olist.at(olist.size() - 2).getIntValue(), olist.at(olist.size() - 1).getIntValue()); olist.pop_back(); olist.pop_back(); } else if ((value == ""endobj"") && (state == st_top)) { object = newNull(); input->seek(input->getLastOffset(), SEEK_SET); empty = true; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle treat word as string""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unknown token while reading object;"" "" treating as string"")); object = newString(value); } } break; case QPDFTokenizer::tt_string: { std::string val = token.getValue(); if (decrypter) { decrypter->decryptString(val); } object = QPDFObjectHandle::newString(val); } break; default: warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unknown token type as null while "" ""reading object"")); object = newNull(); break; } if ((! object.isInitialized()) && (! ((state == st_start) || (state == st_stop) || (state == st_eof)))) { throw std::logic_error( ""QPDFObjectHandle::parseInternal: "" ""unexpected uninitialized object""); object = newNull(); } switch (state) { case st_eof: if (state_stack.size() > 1) { warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""parse error while reading object"")); } done = true; if (! content_stream) { object = newNull(); } break; case st_dictionary: case st_array: setObjectDescriptionFromInput( object, context, object_description, input, input->getLastOffset()); olist.push_back(object); break; case st_top: done = true; break; case st_start: break; case st_stop: if ((state_stack.size() < 2) || (olist_stack.size() < 2)) { throw std::logic_error( ""QPDFObjectHandle::parseInternal: st_stop encountered"" "" with insufficient elements in stack""); } parser_state_e old_state = state_stack.back(); state_stack.pop_back(); if (old_state == st_array) { object = newArray(olist); setObjectDescriptionFromInput( object, context, object_description, input, offset); } else if (old_state == st_dictionary) { std::set<std::string> names; for (std::vector<QPDFObjectHandle>::iterator iter = olist.begin(); iter != olist.end(); ++iter) { if ((! (*iter).isIndirect()) && (*iter).isName()) { names.insert((*iter).getName()); } } std::map<std::string, QPDFObjectHandle> dict; int next_fake_key = 1; for (unsigned int i = 0; i < olist.size(); ++i) { QPDFObjectHandle key_obj = olist.at(i); QPDFObjectHandle val; if (key_obj.isIndirect() || (! key_obj.isName())) { bool found_fake = false; std::string candidate; while (! found_fake) { candidate = ""/QPDFFake"" + QUtil::int_to_string(next_fake_key++); found_fake = (names.count(candidate) == 0); QTC::TC(""qpdf"", ""QPDFObjectHandle found fake"", (found_fake ? 0 : 1)); } warn(context, QPDFExc( qpdf_e_damaged_pdf, input->getName(), object_description, offset, ""expected dictionary key but found"" "" non-name object; inserting key "" + candidate)); val = key_obj; key_obj = newName(candidate); } else if (i + 1 >= olist.size()) { QTC::TC(""qpdf"", ""QPDFObjectHandle no val for last key""); warn(context, QPDFExc( qpdf_e_damaged_pdf, input->getName(), object_description, offset, ""dictionary ended prematurely; "" ""using null as value for last key"")); val = newNull(); setObjectDescriptionFromInput( val, context, object_description, input, offset); } else { val = olist.at(++i); } dict[key_obj.getName()] = val; } object = newDictionary(dict); setObjectDescriptionFromInput( object, context, object_description, input, offset); } olist_stack.pop_back(); offset_stack.pop_back(); if (state_stack.back() == st_top) { done = true; } else { olist_stack.back().push_back(object); } } } setObjectDescriptionFromInput( object, context, object_description, input, offset); return object; }","- olist_stack.push_back(std::vector<QPDFObjectHandle>());
- state = st_start;
- offset_stack.push_back(input->tell());
- state_stack.push_back(
- (token.getType() == QPDFTokenizer::tt_array_open) ?
- st_array : st_dictionary);
+ if (olist_stack.size() > 500)
+ {
+ QTC::TC(""qpdf"", ""QPDFObjectHandle too deep"");
+ warn(context,
+ QPDFExc(qpdf_e_damaged_pdf, input->getName(),
+ object_description,
+ input->getLastOffset(),
+ ""ignoring excessively deeply nested data structure""));
+ object = newNull();
+ state = st_top;
+ }
+ else
+ {
+ olist_stack.push_back(std::vector<QPDFObjectHandle>());
+ state = st_start;
+ offset_stack.push_back(input->tell());
+ state_stack.push_back(
+ (token.getType() == QPDFTokenizer::tt_array_open) ?
+ st_array : st_dictionary);
+ }","QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input, std::string const& object_description, QPDFTokenizer& tokenizer, bool& empty, StringDecrypter* decrypter, QPDF* context, bool content_stream) { empty = false; QPDFObjectHandle object; std::vector<std::vector<QPDFObjectHandle> > olist_stack; olist_stack.push_back(std::vector<QPDFObjectHandle>()); std::vector<parser_state_e> state_stack; state_stack.push_back(st_top); std::vector<qpdf_offset_t> offset_stack; qpdf_offset_t offset = input->tell(); offset_stack.push_back(offset); bool done = false; while (! done) { std::vector<QPDFObjectHandle>& olist = olist_stack.back(); parser_state_e state = state_stack.back(); offset = offset_stack.back(); object = QPDFObjectHandle(); QPDFTokenizer::Token token = tokenizer.readToken(input, object_description, true); switch (token.getType()) { case QPDFTokenizer::tt_eof: if (! content_stream) { QTC::TC(""qpdf"", ""QPDFObjectHandle eof in parseInternal""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unexpected EOF"")); } state = st_eof; break; case QPDFTokenizer::tt_bad: QTC::TC(""qpdf"", ""QPDFObjectHandle bad token in parse""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), token.getErrorMessage())); object = newNull(); break; case QPDFTokenizer::tt_brace_open: case QPDFTokenizer::tt_brace_close: QTC::TC(""qpdf"", ""QPDFObjectHandle bad brace""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unexpected brace token as null"")); object = newNull(); break; case QPDFTokenizer::tt_array_close: if (state == st_array) { state = st_stop; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle bad array close""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unexpected array close token as null"")); object = newNull(); } break; case QPDFTokenizer::tt_dict_close: if (state == st_dictionary) { state = st_stop; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle bad dictionary close""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unexpected dictionary close token"")); object = newNull(); } break; case QPDFTokenizer::tt_array_open: case QPDFTokenizer::tt_dict_open: if (olist_stack.size() > 500) { QTC::TC(""qpdf"", ""QPDFObjectHandle too deep""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""ignoring excessively deeply nested data structure"")); object = newNull(); state = st_top; } else { olist_stack.push_back(std::vector<QPDFObjectHandle>()); state = st_start; offset_stack.push_back(input->tell()); state_stack.push_back( (token.getType() == QPDFTokenizer::tt_array_open) ? st_array : st_dictionary); } break; case QPDFTokenizer::tt_bool: object = newBool((token.getValue() == ""true"")); break; case QPDFTokenizer::tt_null: object = newNull(); break; case QPDFTokenizer::tt_integer: object = newInteger(QUtil::string_to_ll(token.getValue().c_str())); break; case QPDFTokenizer::tt_real: object = newReal(token.getValue()); break; case QPDFTokenizer::tt_name: object = newName(token.getValue()); break; case QPDFTokenizer::tt_word: { std::string const& value = token.getValue(); if (content_stream) { object = QPDFObjectHandle::newOperator(value); } else if ((value == ""R"") && (state != st_top) && (olist.size() >= 2) && (! olist.at(olist.size() - 1).isIndirect()) && (olist.at(olist.size() - 1).isInteger()) && (! olist.at(olist.size() - 2).isIndirect()) && (olist.at(olist.size() - 2).isInteger())) { if (context == 0) { QTC::TC(""qpdf"", ""QPDFObjectHandle indirect without context""); throw std::logic_error( ""QPDFObjectHandle::parse called without context"" "" on an object with indirect references""); } object = newIndirect( context, olist.at(olist.size() - 2).getIntValue(), olist.at(olist.size() - 1).getIntValue()); olist.pop_back(); olist.pop_back(); } else if ((value == ""endobj"") && (state == st_top)) { object = newNull(); input->seek(input->getLastOffset(), SEEK_SET); empty = true; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle treat word as string""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unknown token while reading object;"" "" treating as string"")); object = newString(value); } } break; case QPDFTokenizer::tt_string: { std::string val = token.getValue(); if (decrypter) { decrypter->decryptString(val); } object = QPDFObjectHandle::newString(val); } break; default: warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unknown token type as null while "" ""reading object"")); object = newNull(); break; } if ((! object.isInitialized()) && (! ((state == st_start) || (state == st_stop) || (state == st_eof)))) { throw std::logic_error( ""QPDFObjectHandle::parseInternal: "" ""unexpected uninitialized object""); object = newNull(); } switch (state) { case st_eof: if (state_stack.size() > 1) { warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""parse error while reading object"")); } done = true; if (! content_stream) { object = newNull(); } break; case st_dictionary: case st_array: setObjectDescriptionFromInput( object, context, object_description, input, input->getLastOffset()); olist.push_back(object); break; case st_top: done = true; break; case st_start: break; case st_stop: if ((state_stack.size() < 2) || (olist_stack.size() < 2)) { throw std::logic_error( ""QPDFObjectHandle::parseInternal: st_stop encountered"" "" with insufficient elements in stack""); } parser_state_e old_state = state_stack.back(); state_stack.pop_back(); if (old_state == st_array) { object = newArray(olist); setObjectDescriptionFromInput( object, context, object_description, input, offset); } else if (old_state == st_dictionary) { std::set<std::string> names; for (std::vector<QPDFObjectHandle>::iterator iter = olist.begin(); iter != olist.end(); ++iter) { if ((! (*iter).isIndirect()) && (*iter).isName()) { names.insert((*iter).getName()); } } std::map<std::string, QPDFObjectHandle> dict; int next_fake_key = 1; for (unsigned int i = 0; i < olist.size(); ++i) { QPDFObjectHandle key_obj = olist.at(i); QPDFObjectHandle val; if (key_obj.isIndirect() || (! key_obj.isName())) { bool found_fake = false; std::string candidate; while (! found_fake) { candidate = ""/QPDFFake"" + QUtil::int_to_string(next_fake_key++); found_fake = (names.count(candidate) == 0); QTC::TC(""qpdf"", ""QPDFObjectHandle found fake"", (found_fake ? 0 : 1)); } warn(context, QPDFExc( qpdf_e_damaged_pdf, input->getName(), object_description, offset, ""expected dictionary key but found"" "" non-name object; inserting key "" + candidate)); val = key_obj; key_obj = newName(candidate); } else if (i + 1 >= olist.size()) { QTC::TC(""qpdf"", ""QPDFObjectHandle no val for last key""); warn(context, QPDFExc( qpdf_e_damaged_pdf, input->getName(), object_description, offset, ""dictionary ended prematurely; "" ""using null as value for last key"")); val = newNull(); setObjectDescriptionFromInput( val, context, object_description, input, offset); } else { val = olist.at(++i); } dict[key_obj.getName()] = val; } object = newDictionary(dict); setObjectDescriptionFromInput( object, context, object_description, input, offset); } olist_stack.pop_back(); offset_stack.pop_back(); if (state_stack.back() == st_top) { done = true; } else { olist_stack.back().push_back(object); } } } setObjectDescriptionFromInput( object, context, object_description, input, offset); return object; }"
250,2041----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-11376--bin_elf.c----process_constructors,"static void process_constructors (RBinFile *bf, RList *ret, int bits) { RList *secs = sections (bf); RListIter *iter; RBinSection *sec; int i, type; r_list_foreach (secs, iter, sec) { type = -1; if (!strcmp (sec->name, "".fini_array"")) { type = R_BIN_ENTRY_TYPE_FINI; } else if (!strcmp (sec->name, "".init_array"")) { type = R_BIN_ENTRY_TYPE_INIT; } else if (!strcmp (sec->name, "".preinit_array"")) { type = R_BIN_ENTRY_TYPE_PREINIT; } if (type != -1) { ut8 *buf = calloc (sec->size, 1); if (!buf) { continue; } (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size); if (bits == 32) { <S2SV_StartVul> for (i = 0; i < sec->size; i += 4) { <S2SV_EndVul> ut32 addr32 = r_read_le32 (buf + i); if (addr32) { RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits); r_list_append (ret, ba); } } } else { <S2SV_StartVul> for (i = 0; i < sec->size; i += 8) { <S2SV_EndVul> ut64 addr64 = r_read_le64 (buf + i); if (addr64) { RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits); r_list_append (ret, ba); } } } free (buf); } } r_list_free (secs); }","- for (i = 0; i < sec->size; i += 4) {
- for (i = 0; i < sec->size; i += 8) {
+ for (i = 0; (i + 3) < sec->size; i += 4) {
+ for (i = 0; (i + 7) < sec->size; i += 8) {","static void process_constructors (RBinFile *bf, RList *ret, int bits) { RList *secs = sections (bf); RListIter *iter; RBinSection *sec; int i, type; r_list_foreach (secs, iter, sec) { type = -1; if (!strcmp (sec->name, "".fini_array"")) { type = R_BIN_ENTRY_TYPE_FINI; } else if (!strcmp (sec->name, "".init_array"")) { type = R_BIN_ENTRY_TYPE_INIT; } else if (!strcmp (sec->name, "".preinit_array"")) { type = R_BIN_ENTRY_TYPE_PREINIT; } if (type != -1) { ut8 *buf = calloc (sec->size, 1); if (!buf) { continue; } (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size); if (bits == 32) { for (i = 0; (i + 3) < sec->size; i += 4) { ut32 addr32 = r_read_le32 (buf + i); if (addr32) { RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits); r_list_append (ret, ba); } } } else { for (i = 0; (i + 7) < sec->size; i += 8) { ut64 addr64 = r_read_le64 (buf + i); if (addr64) { RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits); r_list_append (ret, ba); } } } free (buf); } } r_list_free (secs); }"
251,5946----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiMySql.c----mdbEvalSetColumnJSON,"static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) { Jsi_Interp *interp = p->jdb->interp; <S2SV_StartVul> char nbuf[200]; <S2SV_EndVul> MysqlPrep *prep = p->prep; SqlFieldResults *field = prep->fieldResult+iCol; if (field->isnull) { Jsi_DSAppend(dStr, ""null"", NULL); return; } const char *zBlob = """"; int bytes = 0; switch(field->jsiTypeMap) { case JSI_OPTION_BOOL: { snprintf(nbuf, sizeof(nbuf), ""%s"", field->buffer.vchar?""true"":""false""); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_INT64: { snprintf(nbuf, sizeof(nbuf), ""%lld"", field->buffer.vlonglong); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_DOUBLE: { Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf)); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_TIME_D: case JSI_OPTION_TIME_W: { Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp); Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf)); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_STRING: zBlob = field->buffer.vstring; default: { if( !zBlob ) { Jsi_DSAppend(dStr, ""null"", NULL); return; } Jsi_JSONQuote(interp, zBlob, bytes, dStr); return; } } }","- char nbuf[200];
+ char nbuf[JSI_MAX_NUMBER_STRING];","static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) { Jsi_Interp *interp = p->jdb->interp; char nbuf[JSI_MAX_NUMBER_STRING]; MysqlPrep *prep = p->prep; SqlFieldResults *field = prep->fieldResult+iCol; if (field->isnull) { Jsi_DSAppend(dStr, ""null"", NULL); return; } const char *zBlob = """"; int bytes = 0; switch(field->jsiTypeMap) { case JSI_OPTION_BOOL: { snprintf(nbuf, sizeof(nbuf), ""%s"", field->buffer.vchar?""true"":""false""); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_INT64: { snprintf(nbuf, sizeof(nbuf), ""%lld"", field->buffer.vlonglong); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_DOUBLE: { Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf)); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_TIME_D: case JSI_OPTION_TIME_W: { Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp); Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf)); Jsi_DSAppend(dStr, nbuf, NULL); return; } case JSI_OPTION_STRING: zBlob = field->buffer.vstring; default: { if( !zBlob ) { Jsi_DSAppend(dStr, ""null"", NULL); return; } Jsi_JSONQuote(interp, zBlob, bytes, dStr); return; } } }"
252,2579----CWE-78----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-16718--cbin.c----bin_symbols,"static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) { RBinInfo *info = r_bin_get_info (r->bin); RList *entries = r_bin_get_entries (r->bin); RBinSymbol *symbol; RBinAddr *entry; RListIter *iter; bool firstexp = true; bool printHere = false; int i = 0, lastfs = 's'; bool bin_demangle = r_config_get_i (r->config, ""bin.demangle""); if (!info) { return 0; } if (args && *args == '.') { printHere = true; } bool is_arm = info && info->arch && !strncmp (info->arch, ""arm"", 3); const char *lang = bin_demangle ? r_config_get (r->config, ""bin.lang"") : NULL; RList *symbols = r_bin_get_symbols (r->bin); r_spaces_push (&r->anal->meta_spaces, ""bin""); if (IS_MODE_JSON (mode) && !printHere) { r_cons_printf (""[""); } else if (IS_MODE_SET (mode)) { r_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS); } else if (!at && exponly) { if (IS_MODE_RAD (mode)) { r_cons_printf (""fs exports\n""); } else if (IS_MODE_NORMAL (mode)) { r_cons_printf (printHere ? """" : ""[Exports]\n""); } } else if (!at && !exponly) { if (IS_MODE_RAD (mode)) { r_cons_printf (""fs symbols\n""); } else if (IS_MODE_NORMAL (mode)) { r_cons_printf (printHere ? """" : ""[Symbols]\n""); } } if (IS_MODE_NORMAL (mode)) { r_cons_printf (""Num Paddr Vaddr Bind Type Size Name\n""); } size_t count = 0; r_list_foreach (symbols, iter, symbol) { if (!symbol->name) { continue; } char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true); ut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va); int len = symbol->size ? symbol->size : 32; SymName sn = {0}; if (exponly && !isAnExport (symbol)) { free (r_symbol_name); continue; } if (name && strcmp (r_symbol_name, name)) { free (r_symbol_name); continue; } if (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) { free (r_symbol_name); continue; } if ((printHere && !is_in_range (r->offset, symbol->paddr, len)) && (printHere && !is_in_range (r->offset, addr, len))) { free (r_symbol_name); continue; } count ++; snInit (r, &sn, symbol, lang); if (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) { } else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) { if (is_arm) { handle_arm_special_symbol (r, symbol, va); } } else if (IS_MODE_SET (mode)) { if (is_arm) { handle_arm_symbol (r, symbol, info, va); } select_flag_space (r, symbol); if (sn.classname) { RFlagItem *fi = r_flag_get (r->flags, sn.methflag); if (r->bin->prefix) { char *prname = r_str_newf (""%s.%s"", r->bin->prefix, sn.methflag); r_name_filter (sn.methflag, -1); free (sn.methflag); sn.methflag = prname; } if (fi) { r_flag_item_set_realname (fi, sn.methname); if ((fi->offset - r->flags->base) == addr) { r_flag_unset (r->flags, fi); } } else { fi = r_flag_set (r->flags, sn.methflag, addr, symbol->size); char *comment = fi->comment ? strdup (fi->comment) : NULL; if (comment) { r_flag_item_set_comment (fi, comment); R_FREE (comment); } } } else { const char *n = sn.demname ? sn.demname : sn.name; const char *fn = sn.demflag ? sn.demflag : sn.nameflag; char *fnp = (r->bin->prefix) ? r_str_newf (""%s.%s"", r->bin->prefix, fn): strdup (fn); RFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size); if (fi) { r_flag_item_set_realname (fi, n); fi->demangled = (bool)(size_t)sn.demname; } else { if (fn) { eprintf (""[Warning] Can't find flag (%s)\n"", fn); } } free (fnp); } if (sn.demname) { r_meta_add (r->anal, R_META_TYPE_COMMENT, addr, symbol->size, sn.demname); } r_flag_space_pop (r->flags); } else if (IS_MODE_JSON (mode)) { char *str = r_str_escape_utf8_for_json (r_symbol_name, -1); r_cons_printf (""%s{\""name\"":\""%s\"","" ""\""demname\"":\""%s\"","" ""\""flagname\"":\""%s\"","" ""\""ordinal\"":%d,"" ""\""bind\"":\""%s\"","" ""\""size\"":%d,"" ""\""type\"":\""%s\"","" ""\""vaddr\"":%""PFMT64d"","" ""\""paddr\"":%""PFMT64d""}"", ((exponly && firstexp) || printHere) ? """" : (iter->p ? "","" : """"), str, sn.demname? sn.demname: """", sn.nameflag, symbol->ordinal, symbol->bind, (int)symbol->size, symbol->type, (ut64)addr, (ut64)symbol->paddr); free (str); } else if (IS_MODE_SIMPLE (mode)) { const char *name = sn.demname? sn.demname: r_symbol_name; r_cons_printf (""0x%08""PFMT64x"" %d %s\n"", addr, (int)symbol->size, name); } else if (IS_MODE_SIMPLEST (mode)) { const char *name = sn.demname? sn.demname: r_symbol_name; r_cons_printf (""%s\n"", name); } else if (IS_MODE_RAD (mode)) { if (is_special_symbol (symbol)) { goto next; } RBinFile *binfile; RBinPlugin *plugin; const char *name = sn.demname? sn.demname: r_symbol_name; if (!name) { goto next; } if (!strncmp (name, ""imp."", 4)) { if (lastfs != 'i') { r_cons_printf (""fs imports\n""); } lastfs = 'i'; } else { if (lastfs != 's') { const char *fs = exponly? ""exports"": ""symbols""; r_cons_printf (""fs %s\n"", fs); } lastfs = 's'; } if (r->bin->prefix || *name) { char *flagname = construct_symbol_flagname (""sym"", name, MAXFLAG_LEN_DEFAULT); if (!flagname) { goto next; } r_cons_printf (""\""f %s%s%s %u 0x%08"" PFMT64x ""\""\n"", r->bin->prefix ? r->bin->prefix : """", r->bin->prefix ? ""."" : """", flagname, symbol->size, addr); free (flagname); } binfile = r_bin_cur (r->bin); plugin = r_bin_file_cur_plugin (binfile); if (plugin && plugin->name) { if (r_str_startswith (plugin->name, ""pe"")) { char *module = strdup (r_symbol_name); char *p = strstr (module, "".dll_""); if (p && strstr (module, ""imp."")) { char *symname = __filterShell (p + 5); char *m = __filterShell (module); *p = 0; if (r->bin->prefix) { r_cons_printf (""k bin/pe/%s/%d=%s.%s\n"", module, symbol->ordinal, r->bin->prefix, symname); } else { <S2SV_StartVul> r_cons_printf (""k bin/pe/%s/%d=%s\n"", <S2SV_EndVul> module, symbol->ordinal, symname); } <S2SV_StartVul> free (symname); <S2SV_EndVul> free (m); } free (module); } } } else { const char *bind = symbol->bind? symbol->bind: ""NONE""; const char *type = symbol->type? symbol->type: ""NONE""; const char *name = r_str_get (sn.demname? sn.demname: r_symbol_name); r_cons_printf (""%03u"", symbol->ordinal); if (symbol->paddr == UT64_MAX) { r_cons_printf ("" ----------""); } else { r_cons_printf ("" 0x%08""PFMT64x, symbol->paddr); } r_cons_printf ("" 0x%08""PFMT64x"" %6s %6s %4d%s%s\n"", addr, bind, type, symbol->size, *name? "" "": """", name); } next: snFini (&sn); i++; free (r_symbol_name); if (exponly && firstexp) { firstexp = false; } if (printHere) { break; } } if (count == 0 && IS_MODE_JSON (mode)) { r_cons_printf (""{}""); } if (is_arm) { r_list_foreach (entries, iter, entry) { if (IS_MODE_SET (mode)) { handle_arm_entry (r, entry, info, va); } } } if (IS_MODE_JSON (mode) && !printHere) { r_cons_printf (""]""); } r_spaces_pop (&r->anal->meta_spaces); return true; }","- r_cons_printf (""k bin/pe/%s/%d=%s\n"",
- free (symname);
+ r_cons_printf (""\""k bin/pe/%s/%d=%s\""\n"",
+ free (symname);","static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) { RBinInfo *info = r_bin_get_info (r->bin); RList *entries = r_bin_get_entries (r->bin); RBinSymbol *symbol; RBinAddr *entry; RListIter *iter; bool firstexp = true; bool printHere = false; int i = 0, lastfs = 's'; bool bin_demangle = r_config_get_i (r->config, ""bin.demangle""); if (!info) { return 0; } if (args && *args == '.') { printHere = true; } bool is_arm = info && info->arch && !strncmp (info->arch, ""arm"", 3); const char *lang = bin_demangle ? r_config_get (r->config, ""bin.lang"") : NULL; RList *symbols = r_bin_get_symbols (r->bin); r_spaces_push (&r->anal->meta_spaces, ""bin""); if (IS_MODE_JSON (mode) && !printHere) { r_cons_printf (""[""); } else if (IS_MODE_SET (mode)) { r_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS); } else if (!at && exponly) { if (IS_MODE_RAD (mode)) { r_cons_printf (""fs exports\n""); } else if (IS_MODE_NORMAL (mode)) { r_cons_printf (printHere ? """" : ""[Exports]\n""); } } else if (!at && !exponly) { if (IS_MODE_RAD (mode)) { r_cons_printf (""fs symbols\n""); } else if (IS_MODE_NORMAL (mode)) { r_cons_printf (printHere ? """" : ""[Symbols]\n""); } } if (IS_MODE_NORMAL (mode)) { r_cons_printf (""Num Paddr Vaddr Bind Type Size Name\n""); } size_t count = 0; r_list_foreach (symbols, iter, symbol) { if (!symbol->name) { continue; } char *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true); ut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va); int len = symbol->size ? symbol->size : 32; SymName sn = {0}; if (exponly && !isAnExport (symbol)) { free (r_symbol_name); continue; } if (name && strcmp (r_symbol_name, name)) { free (r_symbol_name); continue; } if (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) { free (r_symbol_name); continue; } if ((printHere && !is_in_range (r->offset, symbol->paddr, len)) && (printHere && !is_in_range (r->offset, addr, len))) { free (r_symbol_name); continue; } count ++; snInit (r, &sn, symbol, lang); if (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) { } else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) { if (is_arm) { handle_arm_special_symbol (r, symbol, va); } } else if (IS_MODE_SET (mode)) { if (is_arm) { handle_arm_symbol (r, symbol, info, va); } select_flag_space (r, symbol); if (sn.classname) { RFlagItem *fi = r_flag_get (r->flags, sn.methflag); if (r->bin->prefix) { char *prname = r_str_newf (""%s.%s"", r->bin->prefix, sn.methflag); r_name_filter (sn.methflag, -1); free (sn.methflag); sn.methflag = prname; } if (fi) { r_flag_item_set_realname (fi, sn.methname); if ((fi->offset - r->flags->base) == addr) { r_flag_unset (r->flags, fi); } } else { fi = r_flag_set (r->flags, sn.methflag, addr, symbol->size); char *comment = fi->comment ? strdup (fi->comment) : NULL; if (comment) { r_flag_item_set_comment (fi, comment); R_FREE (comment); } } } else { const char *n = sn.demname ? sn.demname : sn.name; const char *fn = sn.demflag ? sn.demflag : sn.nameflag; char *fnp = (r->bin->prefix) ? r_str_newf (""%s.%s"", r->bin->prefix, fn): strdup (fn); RFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size); if (fi) { r_flag_item_set_realname (fi, n); fi->demangled = (bool)(size_t)sn.demname; } else { if (fn) { eprintf (""[Warning] Can't find flag (%s)\n"", fn); } } free (fnp); } if (sn.demname) { r_meta_add (r->anal, R_META_TYPE_COMMENT, addr, symbol->size, sn.demname); } r_flag_space_pop (r->flags); } else if (IS_MODE_JSON (mode)) { char *str = r_str_escape_utf8_for_json (r_symbol_name, -1); r_cons_printf (""%s{\""name\"":\""%s\"","" ""\""demname\"":\""%s\"","" ""\""flagname\"":\""%s\"","" ""\""ordinal\"":%d,"" ""\""bind\"":\""%s\"","" ""\""size\"":%d,"" ""\""type\"":\""%s\"","" ""\""vaddr\"":%""PFMT64d"","" ""\""paddr\"":%""PFMT64d""}"", ((exponly && firstexp) || printHere) ? """" : (iter->p ? "","" : """"), str, sn.demname? sn.demname: """", sn.nameflag, symbol->ordinal, symbol->bind, (int)symbol->size, symbol->type, (ut64)addr, (ut64)symbol->paddr); free (str); } else if (IS_MODE_SIMPLE (mode)) { const char *name = sn.demname? sn.demname: r_symbol_name; r_cons_printf (""0x%08""PFMT64x"" %d %s\n"", addr, (int)symbol->size, name); } else if (IS_MODE_SIMPLEST (mode)) { const char *name = sn.demname? sn.demname: r_symbol_name; r_cons_printf (""%s\n"", name); } else if (IS_MODE_RAD (mode)) { if (is_special_symbol (symbol)) { goto next; } RBinFile *binfile; RBinPlugin *plugin; const char *name = sn.demname? sn.demname: r_symbol_name; if (!name) { goto next; } if (!strncmp (name, ""imp."", 4)) { if (lastfs != 'i') { r_cons_printf (""fs imports\n""); } lastfs = 'i'; } else { if (lastfs != 's') { const char *fs = exponly? ""exports"": ""symbols""; r_cons_printf (""fs %s\n"", fs); } lastfs = 's'; } if (r->bin->prefix || *name) { char *flagname = construct_symbol_flagname (""sym"", name, MAXFLAG_LEN_DEFAULT); if (!flagname) { goto next; } r_cons_printf (""\""f %s%s%s %u 0x%08"" PFMT64x ""\""\n"", r->bin->prefix ? r->bin->prefix : """", r->bin->prefix ? ""."" : """", flagname, symbol->size, addr); free (flagname); } binfile = r_bin_cur (r->bin); plugin = r_bin_file_cur_plugin (binfile); if (plugin && plugin->name) { if (r_str_startswith (plugin->name, ""pe"")) { char *module = strdup (r_symbol_name); char *p = strstr (module, "".dll_""); if (p && strstr (module, ""imp."")) { char *symname = __filterShell (p + 5); char *m = __filterShell (module); *p = 0; if (r->bin->prefix) { r_cons_printf (""\""k bin/pe/%s/%d=%s.%s\""\n"", module, symbol->ordinal, r->bin->prefix, symname); } else { r_cons_printf (""\""k bin/pe/%s/%d=%s\""\n"", module, symbol->ordinal, symname); } free (symname); free (m); } free (module); } } } else { const char *bind = symbol->bind? symbol->bind: ""NONE""; const char *type = symbol->type? symbol->type: ""NONE""; const char *name = r_str_get (sn.demname? sn.demname: r_symbol_name); r_cons_printf (""%03u"", symbol->ordinal); if (symbol->paddr == UT64_MAX) { r_cons_printf ("" ----------""); } else { r_cons_printf ("" 0x%08""PFMT64x, symbol->paddr); } r_cons_printf ("" 0x%08""PFMT64x"" %6s %6s %4d%s%s\n"", addr, bind, type, symbol->size, *name? "" "": """", name); } next: snFini (&sn); i++; free (r_symbol_name); if (exponly && firstexp) { firstexp = false; } if (printHere) { break; } } if (count == 0 && IS_MODE_JSON (mode)) { r_cons_printf (""{}""); } if (is_arm) { r_list_foreach (entries, iter, entry) { if (IS_MODE_SET (mode)) { handle_arm_entry (r, entry, info, va); } } } if (IS_MODE_JSON (mode) && !printHere) { r_cons_printf (""]""); } r_spaces_pop (&r->anal->meta_spaces); return true; }"
253,1661----CWE-787----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5509--psd.c----ReadPSDChannelRLE,"static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info, const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception) { MagickBooleanType status; size_t length, row_size; ssize_t count, y; unsigned char *compact_pixels, *pixels; if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), "" layer data is RLE compressed""); row_size=GetPSDRowSize(image); pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); length=0; for (y=0; y < (ssize_t) image->rows; y++) if ((MagickOffsetType) length < sizes[y]) <S2SV_StartVul> length=(size_t) sizes[y]; <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> if (length > row_size + 256) { pixels=(unsigned char *) RelinquishMagickMemory(pixels); ThrowBinaryException(ResourceLimitError,""InvalidLength"", image->filename); } compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels)); if (compact_pixels == (unsigned char *) NULL) { pixels=(unsigned char *) RelinquishMagickMemory(pixels); ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); } (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels)); status=MagickTrue; for (y=0; y < (ssize_t) image->rows; y++) { status=MagickFalse; count=ReadBlob(image,(size_t) sizes[y],compact_pixels); if (count != (ssize_t) sizes[y]) break; count=DecodePSDPixels((size_t) sizes[y],compact_pixels, (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels); if (count != (ssize_t) row_size) break; status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels, exception); if (status == MagickFalse) break; } compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels); pixels=(unsigned char *) RelinquishMagickMemory(pixels); return(status); }","- length=(size_t) sizes[y];
- 
+ ThrowBinaryException(ResourceLimitError,""InvalidLength"",image->filename);","static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info, const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception) { MagickBooleanType status; size_t length, row_size; ssize_t count, y; unsigned char *compact_pixels, *pixels; if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), "" layer data is RLE compressed""); row_size=GetPSDRowSize(image); pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); length=0; for (y=0; y < (ssize_t) image->rows; y++) if ((MagickOffsetType) length < sizes[y]) length=(size_t) sizes[y]; if (length > row_size + 256) { pixels=(unsigned char *) RelinquishMagickMemory(pixels); ThrowBinaryException(ResourceLimitError,""InvalidLength"",image->filename); } compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels)); if (compact_pixels == (unsigned char *) NULL) { pixels=(unsigned char *) RelinquishMagickMemory(pixels); ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); } (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels)); status=MagickTrue; for (y=0; y < (ssize_t) image->rows; y++) { status=MagickFalse; count=ReadBlob(image,(size_t) sizes[y],compact_pixels); if (count != (ssize_t) sizes[y]) break; count=DecodePSDPixels((size_t) sizes[y],compact_pixels, (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels); if (count != (ssize_t) row_size) break; status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels, exception); if (status == MagickFalse) break; } compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels); pixels=(unsigned char *) RelinquishMagickMemory(pixels); return(status); }"
254,4066----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/buffer.c----buflist_getfile,"buflist_getfile( int n, linenr_T lnum, int options, int forceit) { buf_T *buf; win_T *wp = NULL; pos_T *fpos; colnr_T col; buf = buflist_findnr(n); if (buf == NULL) { if ((options & GETF_ALT) && n == 0) emsg(_(e_no_alternate_file)); else semsg(_(e_buffer_nr_not_found), n); return FAIL; } if (buf == curbuf) return OK; <S2SV_StartVul> if (text_locked()) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> text_locked_msg(); <S2SV_EndVul> <S2SV_StartVul> return FAIL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (curbuf_locked()) <S2SV_EndVul> return FAIL; if (lnum == 0) { fpos = buflist_findfpos(buf); lnum = fpos->lnum; col = fpos->col; } else col = 0; if (options & GETF_SWITCH) { if (swb_flags & SWB_USEOPEN) wp = buf_jump_open_win(buf); if (wp == NULL && (swb_flags & SWB_USETAB)) wp = buf_jump_open_tab(buf); if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB)) && !BUFEMPTY()) { if (swb_flags & SWB_NEWTAB) tabpage_new(); else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0) == FAIL) return FAIL; RESET_BINDING(curwin); } } ++RedrawingDisabled; if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL, (options & GETF_SETMARK), lnum, forceit))) { --RedrawingDisabled; if (!p_sol && col != 0) { curwin->w_cursor.col = col; check_cursor_col(); curwin->w_cursor.coladd = 0; curwin->w_set_curswant = TRUE; } return OK; } --RedrawingDisabled; return FAIL; }","- if (text_locked())
- {
- text_locked_msg();
- return FAIL;
- }
- if (curbuf_locked())
+ if (text_or_buf_locked())","buflist_getfile( int n, linenr_T lnum, int options, int forceit) { buf_T *buf; win_T *wp = NULL; pos_T *fpos; colnr_T col; buf = buflist_findnr(n); if (buf == NULL) { if ((options & GETF_ALT) && n == 0) emsg(_(e_no_alternate_file)); else semsg(_(e_buffer_nr_not_found), n); return FAIL; } if (buf == curbuf) return OK; if (text_or_buf_locked()) return FAIL; if (lnum == 0) { fpos = buflist_findfpos(buf); lnum = fpos->lnum; col = fpos->col; } else col = 0; if (options & GETF_SWITCH) { if (swb_flags & SWB_USEOPEN) wp = buf_jump_open_win(buf); if (wp == NULL && (swb_flags & SWB_USETAB)) wp = buf_jump_open_tab(buf); if (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB)) && !BUFEMPTY()) { if (swb_flags & SWB_NEWTAB) tabpage_new(); else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0) == FAIL) return FAIL; RESET_BINDING(curwin); } } ++RedrawingDisabled; if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL, (options & GETF_SETMARK), lnum, forceit))) { --RedrawingDisabled; if (!p_sol && col != 0) { curwin->w_cursor.col = col; check_cursor_col(); curwin->w_cursor.coladd = 0; curwin->w_set_curswant = TRUE; } return OK; } --RedrawingDisabled; return FAIL; }"
255,3525----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event.c----validate_event,"<S2SV_StartVul> validate_event(struct pmu_hw_events *hw_events, <S2SV_EndVul> <S2SV_StartVul> struct perf_event *event) <S2SV_EndVul> { <S2SV_StartVul> struct arm_pmu *armpmu = to_arm_pmu(event->pmu); <S2SV_EndVul> struct hw_perf_event fake_event = event->hw; struct pmu *leader_pmu = event->group_leader->pmu; if (is_software_event(event)) return 1; if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF) return 1; if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec) return 1; return armpmu->get_event_idx(hw_events, &fake_event) >= 0; }","- validate_event(struct pmu_hw_events *hw_events,
- struct perf_event *event)
- struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
+ validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,
+ struct perf_event *event)
+ struct arm_pmu *armpmu;
+ if (event->pmu != pmu)
+ return 0;
+ armpmu = to_arm_pmu(event->pmu);","validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events, struct perf_event *event) { struct arm_pmu *armpmu; struct hw_perf_event fake_event = event->hw; struct pmu *leader_pmu = event->group_leader->pmu; if (is_software_event(event)) return 1; if (event->pmu != pmu) return 0; if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF) return 1; if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec) return 1; armpmu = to_arm_pmu(event->pmu); return armpmu->get_event_idx(hw_events, &fake_event) >= 0; }"
256,216----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9601--jbig2_huffman.c----huff_get_next_word,"<S2SV_StartVul> huff_get_next_word(Jbig2HuffmanState *hs, int offset) <S2SV_EndVul> { uint32_t word = 0; Jbig2WordStream *ws = hs->ws; if ((ws->get_next_word(ws, offset, &word)) && ((hs->offset_limit == 0) || (offset < hs->offset_limit))) hs->offset_limit = offset; return word; }","- huff_get_next_word(Jbig2HuffmanState *hs, int offset)
+ huff_get_next_word(Jbig2HuffmanState *hs, int offset)","huff_get_next_word(Jbig2HuffmanState *hs, int offset) huff_get_next_word(Jbig2HuffmanState *hs, uint32_t offset) { uint32_t word = 0; Jbig2WordStream *ws = hs->ws; if ((ws->get_next_word(ws, offset, &word)) && ((hs->offset_limit == 0) || (offset < hs->offset_limit))) hs->offset_limit = offset; return word; }"
257,1012----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4997--arp_tables.c----check_compat_entry_size_and_hooks,"check_compat_entry_size_and_hooks(struct compat_arpt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 || (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_arpt_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!arp_checkentry(&e->arp)) return -EINVAL; <S2SV_StartVul> ret = xt_compat_check_entry_offsets(e, e->target_offset, <S2SV_EndVul> e->next_offset); if (ret) return ret; off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry); entry_offset = (void *)e - (void *)base; t = compat_arpt_get_target(e); target = xt_request_find_target(NFPROTO_ARP, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto out; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off); if (ret) goto release_target; for (h = 0; h < NF_ARP_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; release_target: module_put(t->u.kernel.target->me); out: return ret; }","- ret = xt_compat_check_entry_offsets(e, e->target_offset,
+ ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,","check_compat_entry_size_and_hooks(struct compat_arpt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 || (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_arpt_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!arp_checkentry(&e->arp)) return -EINVAL; ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset, e->next_offset); if (ret) return ret; off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry); entry_offset = (void *)e - (void *)base; t = compat_arpt_get_target(e); target = xt_request_find_target(NFPROTO_ARP, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto out; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off); if (ret) goto release_target; for (h = 0; h < NF_ARP_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; release_target: module_put(t->u.kernel.target->me); out: return ret; }"
258,2805----CWE-89----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/smtp.c----smtp_connect,"static CURLcode smtp_connect(struct connectdata *conn, bool *done) { CURLcode result; struct smtp_conn *smtpc = &conn->proto.smtpc; struct SessionHandle *data = conn->data; struct pingpong *pp = &smtpc->pp; const char *path = conn->data->state.path; <S2SV_StartVul> int len; <S2SV_EndVul> char localhost[HOSTNAME_MAX + 1]; *done = FALSE; Curl_reset_reqproto(conn); result = smtp_init(conn); if(CURLE_OK != result) return result; conn->bits.close = FALSE; pp->response_time = RESP_TIMEOUT; pp->statemach_act = smtp_statemach_act; pp->endofresp = smtp_endofresp; pp->conn = conn; if(conn->bits.tunnel_proxy && conn->bits.httpproxy) { struct HTTP http_proxy; struct FTP *smtp_save; smtp_save = data->state.proto.smtp; memset(&http_proxy, 0, sizeof(http_proxy)); data->state.proto.http = &http_proxy; result = Curl_proxyCONNECT(conn, FIRSTSOCKET, conn->host.name, conn->remote_port); data->state.proto.smtp = smtp_save; if(CURLE_OK != result) return result; } if((conn->handler->protocol & CURLPROTO_SMTPS) && data->state.used_interface != Curl_if_multi) { result = Curl_ssl_connect(conn, FIRSTSOCKET); if(result) return result; } Curl_pp_init(pp); pp->response_time = RESP_TIMEOUT; pp->statemach_act = smtp_statemach_act; pp->endofresp = smtp_endofresp; pp->conn = conn; if(!*path) { if(!Curl_gethostname(localhost, sizeof localhost)) path = localhost; else path = ""localhost""; } <S2SV_StartVul> smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len); <S2SV_EndVul> <S2SV_StartVul> if(!smtpc->domain) <S2SV_EndVul> <S2SV_StartVul> return CURLE_OUT_OF_MEMORY; <S2SV_EndVul> state(conn, SMTP_SERVERGREET); if(data->state.used_interface == Curl_if_multi) result = smtp_multi_statemach(conn, done); else { result = smtp_easy_statemach(conn); if(!result) *done = TRUE; } return result; }","- int len;
- smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);
- if(!smtpc->domain)
- return CURLE_OUT_OF_MEMORY;
+ result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);
+ if(result)
+ return result;","static CURLcode smtp_connect(struct connectdata *conn, bool *done) { CURLcode result; struct smtp_conn *smtpc = &conn->proto.smtpc; struct SessionHandle *data = conn->data; struct pingpong *pp = &smtpc->pp; const char *path = conn->data->state.path; char localhost[HOSTNAME_MAX + 1]; *done = FALSE; Curl_reset_reqproto(conn); result = smtp_init(conn); if(CURLE_OK != result) return result; conn->bits.close = FALSE; pp->response_time = RESP_TIMEOUT; pp->statemach_act = smtp_statemach_act; pp->endofresp = smtp_endofresp; pp->conn = conn; if(conn->bits.tunnel_proxy && conn->bits.httpproxy) { struct HTTP http_proxy; struct FTP *smtp_save; smtp_save = data->state.proto.smtp; memset(&http_proxy, 0, sizeof(http_proxy)); data->state.proto.http = &http_proxy; result = Curl_proxyCONNECT(conn, FIRSTSOCKET, conn->host.name, conn->remote_port); data->state.proto.smtp = smtp_save; if(CURLE_OK != result) return result; } if((conn->handler->protocol & CURLPROTO_SMTPS) && data->state.used_interface != Curl_if_multi) { result = Curl_ssl_connect(conn, FIRSTSOCKET); if(result) return result; } Curl_pp_init(pp); pp->response_time = RESP_TIMEOUT; pp->statemach_act = smtp_statemach_act; pp->endofresp = smtp_endofresp; pp->conn = conn; if(!*path) { if(!Curl_gethostname(localhost, sizeof localhost)) path = localhost; else path = ""localhost""; } result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE); if(result) return result; state(conn, SMTP_SERVERGREET); if(data->state.used_interface == Curl_if_multi) result = smtp_multi_statemach(conn, done); else { result = smtp_easy_statemach(conn); if(!result) *done = TRUE; } return result; }"
259,2832----CWE-909----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4file.c----nfs4_file_open,"nfs4_file_open(struct inode *inode, struct file *filp) { struct nfs_open_context *ctx; struct dentry *dentry = file_dentry(filp); struct dentry *parent = NULL; struct inode *dir; unsigned openflags = filp->f_flags; struct iattr attr; int err; dprintk(""NFS: open file(%pd2)\n"", dentry); err = nfs_check_flags(openflags); if (err) return err; if ((openflags & O_ACCMODE) == 3) <S2SV_StartVul> return nfs_open(inode, filp); <S2SV_EndVul> openflags &= ~(O_CREAT|O_EXCL); parent = dget_parent(dentry); dir = d_inode(parent); ctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp); err = PTR_ERR(ctx); if (IS_ERR(ctx)) goto out; attr.ia_valid = ATTR_OPEN; if (openflags & O_TRUNC) { attr.ia_valid |= ATTR_SIZE; attr.ia_size = 0; filemap_write_and_wait(inode->i_mapping); } inode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL); if (IS_ERR(inode)) { err = PTR_ERR(inode); switch (err) { default: goto out_put_ctx; case -ENOENT: case -ESTALE: case -EISDIR: case -ENOTDIR: case -ELOOP: goto out_drop; } } if (inode != d_inode(dentry)) goto out_drop; nfs_file_set_open_context(filp, ctx); nfs_fscache_open_file(inode, filp); err = 0; out_put_ctx: put_nfs_open_context(ctx); out: dput(parent); return err; out_drop: d_drop(dentry); err = -EOPENSTALE; goto out_put_ctx; }","- return nfs_open(inode, filp);
+ openflags--;","nfs4_file_open(struct inode *inode, struct file *filp) { struct nfs_open_context *ctx; struct dentry *dentry = file_dentry(filp); struct dentry *parent = NULL; struct inode *dir; unsigned openflags = filp->f_flags; struct iattr attr; int err; dprintk(""NFS: open file(%pd2)\n"", dentry); err = nfs_check_flags(openflags); if (err) return err; if ((openflags & O_ACCMODE) == 3) openflags--; openflags &= ~(O_CREAT|O_EXCL); parent = dget_parent(dentry); dir = d_inode(parent); ctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp); err = PTR_ERR(ctx); if (IS_ERR(ctx)) goto out; attr.ia_valid = ATTR_OPEN; if (openflags & O_TRUNC) { attr.ia_valid |= ATTR_SIZE; attr.ia_size = 0; filemap_write_and_wait(inode->i_mapping); } inode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL); if (IS_ERR(inode)) { err = PTR_ERR(inode); switch (err) { default: goto out_put_ctx; case -ENOENT: case -ESTALE: case -EISDIR: case -ENOTDIR: case -ELOOP: goto out_drop; } } if (inode != d_inode(dentry)) goto out_drop; nfs_file_set_open_context(filp, ctx); nfs_fscache_open_file(inode, filp); err = 0; out_put_ctx: put_nfs_open_context(ctx); out: dput(parent); return err; out_drop: d_drop(dentry); err = -EOPENSTALE; goto out_put_ctx; }"
260,1428----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-12193--assoc_array.c----assoc_array_insert_into_terminal_node,"static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit, const struct assoc_array_ops *ops, const void *index_key, struct assoc_array_walk_result *result) { struct assoc_array_shortcut *shortcut, *new_s0; struct assoc_array_node *node, *new_n0, *new_n1, *side; struct assoc_array_ptr *ptr; unsigned long dissimilarity, base_seg, blank; size_t keylen; bool have_meta; int level, diff; int slot, next_slot, free_slot, i, j; node = result->terminal_node.node; level = result->terminal_node.level; edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot; pr_devel(""-->%s()\n"", __func__); free_slot = -1; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; if (!ptr) { free_slot = i; continue; } if (assoc_array_ptr_is_leaf(ptr) && ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) { pr_devel(""replace in slot %d\n"", i); edit->leaf_p = &node->slots[i]; edit->dead_leaf = node->slots[i]; pr_devel(""<--%s() = ok [replace]\n"", __func__); return true; } } if (free_slot >= 0) { pr_devel(""insert in free slot %d\n"", free_slot); edit->leaf_p = &node->slots[free_slot]; edit->adjust_count_on = node; pr_devel(""<--%s() = ok [insert]\n"", __func__); return true; } new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL); if (!new_n0) return false; edit->new_meta[0] = assoc_array_node_to_ptr(new_n0); new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL); if (!new_n1) return false; edit->new_meta[1] = assoc_array_node_to_ptr(new_n1); pr_devel(""no spare slots\n""); have_meta = false; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; if (assoc_array_ptr_is_meta(ptr)) { edit->segment_cache[i] = 0xff; have_meta = true; continue; } base_seg = ops->get_object_key_chunk( assoc_array_ptr_to_leaf(ptr), level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK; } if (have_meta) { pr_devel(""have meta\n""); goto split_node; } dissimilarity = 0; base_seg = edit->segment_cache[0]; for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++) dissimilarity |= edit->segment_cache[i] ^ base_seg; pr_devel(""only leaves; dissimilarity=%lx\n"", dissimilarity); if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) { if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0) goto all_leaves_cluster_together; <S2SV_StartVul> goto present_leaves_cluster_but_not_new_leaf; <S2SV_EndVul> } split_node: pr_devel(""split node\n""); edit->set[0].to = assoc_array_node_to_ptr(new_n0); new_n0->back_pointer = node->back_pointer; new_n0->parent_slot = node->parent_slot; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = -1; do_split_node: pr_devel(""do_split_node\n""); new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch; new_n1->nr_leaves_on_branch = 0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { slot = edit->segment_cache[i]; if (slot != 0xff) for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++) if (edit->segment_cache[j] == slot) goto found_slot_for_multiple_occupancy; } found_slot_for_multiple_occupancy: pr_devel(""same slot: %x %x [%02x]\n"", i, j, slot); BUG_ON(i >= ASSOC_ARRAY_FAN_OUT); BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1); BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT); new_n1->parent_slot = slot; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) if (assoc_array_ptr_is_meta(node->slots[i])) new_n0->slots[i] = node->slots[i]; else new_n0->slots[i] = NULL; BUG_ON(new_n0->slots[slot] != NULL); new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1); free_slot = -1; next_slot = 0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { if (assoc_array_ptr_is_meta(node->slots[i])) continue; if (edit->segment_cache[i] == slot) { new_n1->slots[next_slot++] = node->slots[i]; new_n1->nr_leaves_on_branch++; } else { do { free_slot++; } while (new_n0->slots[free_slot] != NULL); new_n0->slots[free_slot] = node->slots[i]; } } pr_devel(""filtered: f=%x n=%x\n"", free_slot, next_slot); if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) { do { free_slot++; } while (new_n0->slots[free_slot] != NULL); edit->leaf_p = &new_n0->slots[free_slot]; edit->adjust_count_on = new_n0; } else { edit->leaf_p = &new_n1->slots[next_slot++]; edit->adjust_count_on = new_n1; } BUG_ON(next_slot <= 1); edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0); for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { if (edit->segment_cache[i] == 0xff) { ptr = node->slots[i]; BUG_ON(assoc_array_ptr_is_leaf(ptr)); if (assoc_array_ptr_is_node(ptr)) { side = assoc_array_ptr_to_node(ptr); edit->set_backpointers[i] = &side->back_pointer; } else { shortcut = assoc_array_ptr_to_shortcut(ptr); edit->set_backpointers[i] = &shortcut->back_pointer; } } } ptr = node->back_pointer; if (!ptr) edit->set[0].ptr = &edit->array->root; else if (assoc_array_ptr_is_node(ptr)) edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot]; else edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node; edit->excised_meta[0] = assoc_array_node_to_ptr(node); pr_devel(""<--%s() = ok [split node]\n"", __func__); return true; <S2SV_StartVul> present_leaves_cluster_but_not_new_leaf: <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> pr_devel(""present leaves cluster but not new leaf\n""); <S2SV_EndVul> new_n0->back_pointer = node->back_pointer; <S2SV_StartVul> new_n0->parent_slot = node->parent_slot; <S2SV_EndVul> <S2SV_StartVul> new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch; <S2SV_EndVul> <S2SV_StartVul> new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); <S2SV_EndVul> <S2SV_StartVul> new_n1->parent_slot = edit->segment_cache[0]; <S2SV_EndVul> <S2SV_StartVul> new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch; <S2SV_EndVul> <S2SV_StartVul> edit->adjust_count_on = new_n0; <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) <S2SV_EndVul> new_n1->slots[i] = node->slots[i]; <S2SV_StartVul> new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0); <S2SV_EndVul> <S2SV_StartVul> edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]]; <S2SV_EndVul> edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot]; <S2SV_StartVul> edit->set[0].to = assoc_array_node_to_ptr(new_n0); <S2SV_EndVul> <S2SV_StartVul> edit->excised_meta[0] = assoc_array_node_to_ptr(node); <S2SV_EndVul> pr_devel(""<--%s() = ok [insert node before]\n"", __func__); <S2SV_StartVul> return true; <S2SV_EndVul> <S2SV_StartVul> all_leaves_cluster_together: <S2SV_EndVul> <S2SV_StartVul> pr_devel(""all leaves cluster together\n""); diff = INT_MAX; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { int x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]), index_key); if (x < diff) { BUG_ON(x < 0); diff = x; } } BUG_ON(diff == INT_MAX); BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP); keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE); keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) + keylen * sizeof(unsigned long), GFP_KERNEL); if (!new_s0) return false; edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0); edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0); new_s0->back_pointer = node->back_pointer; new_s0->parent_slot = node->parent_slot; new_s0->next_node = assoc_array_node_to_ptr(new_n0); new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0); new_n0->parent_slot = 0; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = -1; new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK; pr_devel(""skip_to_level = %d [diff %d]\n"", level, diff); BUG_ON(level <= 0); for (i = 0; i < keylen; i++) new_s0->index_key[i] = ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE); blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK); pr_devel(""blank off [%zu] %d: %lx\n"", keylen - 1, level, blank); new_s0->index_key[keylen - 1] &= ~blank; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr), level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK; } base_seg = ops->get_key_chunk(index_key, level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK; goto do_split_node; }","- goto present_leaves_cluster_but_not_new_leaf;
- present_leaves_cluster_but_not_new_leaf:
- pr_devel(""present leaves cluster but not new leaf\n"");
- new_n0->parent_slot = node->parent_slot;
- new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;
- new_n1->back_pointer = assoc_array_node_to_ptr(new_n0);
- new_n1->parent_slot = edit->segment_cache[0];
- new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;
- edit->adjust_count_on = new_n0;
- for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)
- new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);
- edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];
- edit->set[0].to = assoc_array_node_to_ptr(new_n0);
- edit->excised_meta[0] = assoc_array_node_to_ptr(node);
- return true;
- all_leaves_cluster_together:
- /* All the leaves, new and old, want to cluster together in this node
+ pr_devel(""present leaves cluster but not new leaf\n"");","static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit, const struct assoc_array_ops *ops, const void *index_key, struct assoc_array_walk_result *result) { struct assoc_array_shortcut *shortcut, *new_s0; struct assoc_array_node *node, *new_n0, *new_n1, *side; struct assoc_array_ptr *ptr; unsigned long dissimilarity, base_seg, blank; size_t keylen; bool have_meta; int level, diff; int slot, next_slot, free_slot, i, j; node = result->terminal_node.node; level = result->terminal_node.level; edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot; pr_devel(""-->%s()\n"", __func__); free_slot = -1; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; if (!ptr) { free_slot = i; continue; } if (assoc_array_ptr_is_leaf(ptr) && ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) { pr_devel(""replace in slot %d\n"", i); edit->leaf_p = &node->slots[i]; edit->dead_leaf = node->slots[i]; pr_devel(""<--%s() = ok [replace]\n"", __func__); return true; } } if (free_slot >= 0) { pr_devel(""insert in free slot %d\n"", free_slot); edit->leaf_p = &node->slots[free_slot]; edit->adjust_count_on = node; pr_devel(""<--%s() = ok [insert]\n"", __func__); return true; } new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL); if (!new_n0) return false; edit->new_meta[0] = assoc_array_node_to_ptr(new_n0); new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL); if (!new_n1) return false; edit->new_meta[1] = assoc_array_node_to_ptr(new_n1); pr_devel(""no spare slots\n""); have_meta = false; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; if (assoc_array_ptr_is_meta(ptr)) { edit->segment_cache[i] = 0xff; have_meta = true; continue; } base_seg = ops->get_object_key_chunk( assoc_array_ptr_to_leaf(ptr), level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK; } if (have_meta) { pr_devel(""have meta\n""); goto split_node; } dissimilarity = 0; base_seg = edit->segment_cache[0]; for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++) dissimilarity |= edit->segment_cache[i] ^ base_seg; pr_devel(""only leaves; dissimilarity=%lx\n"", dissimilarity); if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) { if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0) goto all_leaves_cluster_together; pr_devel(""present leaves cluster but not new leaf\n""); } split_node: pr_devel(""split node\n""); edit->set[0].to = assoc_array_node_to_ptr(new_n0); new_n0->back_pointer = node->back_pointer; new_n0->parent_slot = node->parent_slot; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = -1; do_split_node: pr_devel(""do_split_node\n""); new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch; new_n1->nr_leaves_on_branch = 0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { slot = edit->segment_cache[i]; if (slot != 0xff) for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++) if (edit->segment_cache[j] == slot) goto found_slot_for_multiple_occupancy; } found_slot_for_multiple_occupancy: pr_devel(""same slot: %x %x [%02x]\n"", i, j, slot); BUG_ON(i >= ASSOC_ARRAY_FAN_OUT); BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1); BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT); new_n1->parent_slot = slot; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) if (assoc_array_ptr_is_meta(node->slots[i])) new_n0->slots[i] = node->slots[i]; else new_n0->slots[i] = NULL; BUG_ON(new_n0->slots[slot] != NULL); new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1); free_slot = -1; next_slot = 0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { if (assoc_array_ptr_is_meta(node->slots[i])) continue; if (edit->segment_cache[i] == slot) { new_n1->slots[next_slot++] = node->slots[i]; new_n1->nr_leaves_on_branch++; } else { do { free_slot++; } while (new_n0->slots[free_slot] != NULL); new_n0->slots[free_slot] = node->slots[i]; } } pr_devel(""filtered: f=%x n=%x\n"", free_slot, next_slot); if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) { do { free_slot++; } while (new_n0->slots[free_slot] != NULL); edit->leaf_p = &new_n0->slots[free_slot]; edit->adjust_count_on = new_n0; } else { edit->leaf_p = &new_n1->slots[next_slot++]; edit->adjust_count_on = new_n1; } BUG_ON(next_slot <= 1); edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0); for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { if (edit->segment_cache[i] == 0xff) { ptr = node->slots[i]; BUG_ON(assoc_array_ptr_is_leaf(ptr)); if (assoc_array_ptr_is_node(ptr)) { side = assoc_array_ptr_to_node(ptr); edit->set_backpointers[i] = &side->back_pointer; } else { shortcut = assoc_array_ptr_to_shortcut(ptr); edit->set_backpointers[i] = &shortcut->back_pointer; } } } ptr = node->back_pointer; if (!ptr) edit->set[0].ptr = &edit->array->root; else if (assoc_array_ptr_is_node(ptr)) edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot]; else edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node; edit->excised_meta[0] = assoc_array_node_to_ptr(node); pr_devel(""<--%s() = ok [split node]\n"", __func__); return true; all_leaves_cluster_together: pr_devel(""all leaves cluster together\n""); diff = INT_MAX; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { int x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]), index_key); if (x < diff) { BUG_ON(x < 0); diff = x; } } BUG_ON(diff == INT_MAX); BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP); keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE); keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) + keylen * sizeof(unsigned long), GFP_KERNEL); if (!new_s0) return false; edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0); edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0); new_s0->back_pointer = node->back_pointer; new_s0->parent_slot = node->parent_slot; new_s0->next_node = assoc_array_node_to_ptr(new_n0); new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0); new_n0->parent_slot = 0; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = -1; new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK; pr_devel(""skip_to_level = %d [diff %d]\n"", level, diff); BUG_ON(level <= 0); for (i = 0; i < keylen; i++) new_s0->index_key[i] = ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE); blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK); pr_devel(""blank off [%zu] %d: %lx\n"", keylen - 1, level, blank); new_s0->index_key[keylen - 1] &= ~blank; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr), level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK; } base_seg = ops->get_key_chunk(index_key, level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK; goto do_split_node; }"
261,6315----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pci_core.h----pci_set_cfgdata32,"pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val) { <S2SV_StartVul> assert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0); <S2SV_EndVul> *(uint32_t *)(dev->cfgdata + offset) = val; }","- assert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);
+ if ((offset > PCI_REGMAX - 3) || (offset & 3) != 0) {
+ pr_err(""%s: out of range of PCI config space!\n"", __func__);
+ return;
+ }","pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val) { if ((offset > PCI_REGMAX - 3) || (offset & 3) != 0) { pr_err(""%s: out of range of PCI config space!\n"", __func__); return; } *(uint32_t *)(dev->cfgdata + offset) = val; }"
262,6948----CWE-835----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gsm-xsmp-server.c----accept_xsmp_connection,"accept_xsmp_connection (SmsConn sms_conn, GsmXsmpServer *server, unsigned long *mask_ret, SmsCallbacks *callbacks_ret, char **failure_reason_ret) { <S2SV_StartVul> IceConn ice_conn; <S2SV_EndVul> <S2SV_StartVul> GsmXSMPClient *client; <S2SV_EndVul> if (server->priv->xsmp_sockets == NULL) { g_debug (""GsmXsmpServer: In shutdown, rejecting new client""); *failure_reason_ret = strdup (_(""Refusing new client connection because the session is currently being shut down\n"")); return FALSE; } ice_conn = SmsGetIceConnection (sms_conn); <S2SV_StartVul> client = ice_conn->context; <S2SV_EndVul> <S2SV_StartVul> g_return_val_if_fail (client != NULL, TRUE); <S2SV_EndVul> <S2SV_StartVul> gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret); <S2SV_EndVul> return TRUE; }","- IceConn ice_conn;
- GsmXSMPClient *client;
- client = ice_conn->context;
- g_return_val_if_fail (client != NULL, TRUE);
- gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);
+ IceConn ice_conn;
+ GsmClient *client;
+ GsmIceConnectionWatch *data;
+ data = ice_conn->context;
+ free_ice_connection_watch (data);
+ client = gsm_xsmp_client_new (ice_conn);
+ gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
+ g_object_unref (client);
+ gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);","accept_xsmp_connection (SmsConn sms_conn, GsmXsmpServer *server, unsigned long *mask_ret, SmsCallbacks *callbacks_ret, char **failure_reason_ret) { IceConn ice_conn; GsmClient *client; GsmIceConnectionWatch *data; if (server->priv->xsmp_sockets == NULL) { g_debug (""GsmXsmpServer: In shutdown, rejecting new client""); *failure_reason_ret = strdup (_(""Refusing new client connection because the session is currently being shut down\n"")); return FALSE; } ice_conn = SmsGetIceConnection (sms_conn); data = ice_conn->context; free_ice_connection_watch (data); client = gsm_xsmp_client_new (ice_conn); gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client)); g_object_unref (client); gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret); return TRUE; }"
263,2424----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-0038--xfs_acl.c----xfs_acl_from_disk,"xfs_acl_from_disk(struct xfs_acl *aclp) { struct posix_acl_entry *acl_e; struct posix_acl *acl; struct xfs_acl_entry *ace; <S2SV_StartVul> int count, i; <S2SV_EndVul> count = be32_to_cpu(aclp->acl_cnt); if (count > XFS_ACL_MAX_ENTRIES) return ERR_PTR(-EFSCORRUPTED); acl = posix_acl_alloc(count, GFP_KERNEL); if (!acl) return ERR_PTR(-ENOMEM); for (i = 0; i < count; i++) { acl_e = &acl->a_entries[i]; ace = &aclp->acl_entry[i]; acl_e->e_tag = be32_to_cpu(ace->ae_tag); acl_e->e_perm = be16_to_cpu(ace->ae_perm); switch (acl_e->e_tag) { case ACL_USER: case ACL_GROUP: acl_e->e_id = be32_to_cpu(ace->ae_id); break; case ACL_USER_OBJ: case ACL_GROUP_OBJ: case ACL_MASK: case ACL_OTHER: acl_e->e_id = ACL_UNDEFINED_ID; break; default: goto fail; } } return acl; fail: posix_acl_release(acl); return ERR_PTR(-EINVAL); }","- int count, i;
+ unsigned int count, i;","xfs_acl_from_disk(struct xfs_acl *aclp) { struct posix_acl_entry *acl_e; struct posix_acl *acl; struct xfs_acl_entry *ace; unsigned int count, i; count = be32_to_cpu(aclp->acl_cnt); if (count > XFS_ACL_MAX_ENTRIES) return ERR_PTR(-EFSCORRUPTED); acl = posix_acl_alloc(count, GFP_KERNEL); if (!acl) return ERR_PTR(-ENOMEM); for (i = 0; i < count; i++) { acl_e = &acl->a_entries[i]; ace = &aclp->acl_entry[i]; acl_e->e_tag = be32_to_cpu(ace->ae_tag); acl_e->e_perm = be16_to_cpu(ace->ae_perm); switch (acl_e->e_tag) { case ACL_USER: case ACL_GROUP: acl_e->e_id = be32_to_cpu(ace->ae_id); break; case ACL_USER_OBJ: case ACL_GROUP_OBJ: case ACL_MASK: case ACL_OTHER: acl_e->e_id = ACL_UNDEFINED_ID; break; default: goto fail; } } return acl; fail: posix_acl_release(acl); return ERR_PTR(-EINVAL); }"
264,5164----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----pci_lintr_request,"pci_lintr_request(struct pci_vdev *dev) { struct businfo *bi; struct slotinfo *si; int bestpin, bestcount, pin; bi = pci_businfo[dev->bus]; <S2SV_StartVul> assert(bi != NULL); <S2SV_EndVul> si = &bi->slotinfo[dev->slot]; bestpin = 0; bestcount = si->si_intpins[0].ii_count; for (pin = 1; pin < 4; pin++) { if (si->si_intpins[pin].ii_count < bestcount) { bestpin = pin; bestcount = si->si_intpins[pin].ii_count; } } si->si_intpins[bestpin].ii_count++; dev->lintr.pin = bestpin + 1; pci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1); }","- assert(bi != NULL);
+ if (bi == NULL) {
+ pr_err(""%s: pci [%s] has wrong bus %d info!\n"", __func__, dev->name, dev->bus);
+ return;
+ }","pci_lintr_request(struct pci_vdev *dev) { struct businfo *bi; struct slotinfo *si; int bestpin, bestcount, pin; bi = pci_businfo[dev->bus]; if (bi == NULL) { pr_err(""%s: pci [%s] has wrong bus %d info!\n"", __func__, dev->name, dev->bus); return; } si = &bi->slotinfo[dev->slot]; bestpin = 0; bestcount = si->si_intpins[0].ii_count; for (pin = 1; pin < 4; pin++) { if (si->si_intpins[pin].ii_count < bestcount) { bestpin = pin; bestcount = si->si_intpins[pin].ii_count; } } si->si_intpins[bestpin].ii_count++; dev->lintr.pin = bestpin + 1; pci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1); }"
265,845----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-1344--lxcfs.c----cg_write,"int cg_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi) { struct fuse_context *fc = fuse_get_context(); char *localbuf = NULL; struct cgfs_files *k = NULL; struct file_info *f = (struct file_info *)fi->fh; bool r; if (f->type != LXC_TYPE_CGFILE) { fprintf(stderr, ""Internal error: directory cache info used in cg_write\n""); return -EIO; } if (offset) return 0; if (!fc) return -EIO; localbuf = alloca(size+1); localbuf[size] = '\0'; memcpy(localbuf, buf, size); if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) { size = -EINVAL; goto out; } if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) { size = -EACCES; goto out; } if (strcmp(f->file, ""tasks"") == 0 || strcmp(f->file, ""/tasks"") == 0 || strcmp(f->file, ""/cgroup.procs"") == 0 || strcmp(f->file, ""cgroup.procs"") == 0) r = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf); <S2SV_StartVul> else <S2SV_EndVul> r = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf); if (!r) size = -EINVAL; out: free_key(k); return size; }","- else
+ else","int cg_write(const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fi) { struct fuse_context *fc = fuse_get_context(); char *localbuf = NULL; struct cgfs_files *k = NULL; struct file_info *f = (struct file_info *)fi->fh; bool r; if (f->type != LXC_TYPE_CGFILE) { fprintf(stderr, ""Internal error: directory cache info used in cg_write\n""); return -EIO; } if (offset) return 0; if (!fc) return -EIO; localbuf = alloca(size+1); localbuf[size] = '\0'; memcpy(localbuf, buf, size); if ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) { size = -EINVAL; goto out; } if (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) { size = -EACCES; goto out; } if (strcmp(f->file, ""tasks"") == 0 || strcmp(f->file, ""/tasks"") == 0 || strcmp(f->file, ""/cgroup.procs"") == 0 || strcmp(f->file, ""cgroup.procs"") == 0) r = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf); else r = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf); if (!r) size = -EINVAL; out: free_key(k); return size; }"
266,7496----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/volumes.c----read_one_chunk,"static int read_one_chunk(struct btrfs_fs_info *fs_info, struct btrfs_key *key, struct extent_buffer *leaf, struct btrfs_chunk *chunk) { struct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree; struct map_lookup *map; struct extent_map *em; u64 logical; u64 length; u64 devid; u8 uuid[BTRFS_UUID_SIZE]; int num_stripes; int ret; int i; logical = key->offset; length = btrfs_chunk_length(leaf, chunk); num_stripes = btrfs_chunk_num_stripes(leaf, chunk); ret = btrfs_check_chunk_valid(fs_info, leaf, chunk, logical); if (ret) return ret; read_lock(&map_tree->map_tree.lock); em = lookup_extent_mapping(&map_tree->map_tree, logical, 1); read_unlock(&map_tree->map_tree.lock); if (em && em->start <= logical && em->start + em->len > logical) { free_extent_map(em); return 0; } else if (em) { free_extent_map(em); } em = alloc_extent_map(); if (!em) return -ENOMEM; map = kmalloc(map_lookup_size(num_stripes), GFP_NOFS); if (!map) { free_extent_map(em); return -ENOMEM; } set_bit(EXTENT_FLAG_FS_MAPPING, &em->flags); em->map_lookup = map; em->start = logical; em->len = length; em->orig_start = 0; em->block_start = 0; em->block_len = em->len; map->num_stripes = num_stripes; map->io_width = btrfs_chunk_io_width(leaf, chunk); map->io_align = btrfs_chunk_io_align(leaf, chunk); map->stripe_len = btrfs_chunk_stripe_len(leaf, chunk); map->type = btrfs_chunk_type(leaf, chunk); map->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk); map->verified_stripes = 0; for (i = 0; i < num_stripes; i++) { map->stripes[i].physical = btrfs_stripe_offset_nr(leaf, chunk, i); devid = btrfs_stripe_devid_nr(leaf, chunk, i); read_extent_buffer(leaf, uuid, (unsigned long) btrfs_stripe_dev_uuid_nr(chunk, i), BTRFS_UUID_SIZE); map->stripes[i].dev = btrfs_find_device(fs_info->fs_devices, <S2SV_StartVul> devid, uuid, NULL); <S2SV_EndVul> if (!map->stripes[i].dev && !btrfs_test_opt(fs_info, DEGRADED)) { free_extent_map(em); btrfs_report_missing_device(fs_info, devid, uuid, true); return -ENOENT; } if (!map->stripes[i].dev) { map->stripes[i].dev = add_missing_dev(fs_info->fs_devices, devid, uuid); if (IS_ERR(map->stripes[i].dev)) { free_extent_map(em); btrfs_err(fs_info, ""failed to init missing dev %llu: %ld"", devid, PTR_ERR(map->stripes[i].dev)); return PTR_ERR(map->stripes[i].dev); } btrfs_report_missing_device(fs_info, devid, uuid, false); } set_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &(map->stripes[i].dev->dev_state)); } write_lock(&map_tree->map_tree.lock); ret = add_extent_mapping(&map_tree->map_tree, em, 0); write_unlock(&map_tree->map_tree.lock); if (ret < 0) { btrfs_err(fs_info, ""failed to add chunk map, start=%llu len=%llu: %d"", em->start, em->len, ret); } free_extent_map(em); return ret; }","- devid, uuid, NULL);
+ devid, uuid, NULL, true);","static int read_one_chunk(struct btrfs_fs_info *fs_info, struct btrfs_key *key, struct extent_buffer *leaf, struct btrfs_chunk *chunk) { struct btrfs_mapping_tree *map_tree = &fs_info->mapping_tree; struct map_lookup *map; struct extent_map *em; u64 logical; u64 length; u64 devid; u8 uuid[BTRFS_UUID_SIZE]; int num_stripes; int ret; int i; logical = key->offset; length = btrfs_chunk_length(leaf, chunk); num_stripes = btrfs_chunk_num_stripes(leaf, chunk); ret = btrfs_check_chunk_valid(fs_info, leaf, chunk, logical); if (ret) return ret; read_lock(&map_tree->map_tree.lock); em = lookup_extent_mapping(&map_tree->map_tree, logical, 1); read_unlock(&map_tree->map_tree.lock); if (em && em->start <= logical && em->start + em->len > logical) { free_extent_map(em); return 0; } else if (em) { free_extent_map(em); } em = alloc_extent_map(); if (!em) return -ENOMEM; map = kmalloc(map_lookup_size(num_stripes), GFP_NOFS); if (!map) { free_extent_map(em); return -ENOMEM; } set_bit(EXTENT_FLAG_FS_MAPPING, &em->flags); em->map_lookup = map; em->start = logical; em->len = length; em->orig_start = 0; em->block_start = 0; em->block_len = em->len; map->num_stripes = num_stripes; map->io_width = btrfs_chunk_io_width(leaf, chunk); map->io_align = btrfs_chunk_io_align(leaf, chunk); map->stripe_len = btrfs_chunk_stripe_len(leaf, chunk); map->type = btrfs_chunk_type(leaf, chunk); map->sub_stripes = btrfs_chunk_sub_stripes(leaf, chunk); map->verified_stripes = 0; for (i = 0; i < num_stripes; i++) { map->stripes[i].physical = btrfs_stripe_offset_nr(leaf, chunk, i); devid = btrfs_stripe_devid_nr(leaf, chunk, i); read_extent_buffer(leaf, uuid, (unsigned long) btrfs_stripe_dev_uuid_nr(chunk, i), BTRFS_UUID_SIZE); map->stripes[i].dev = btrfs_find_device(fs_info->fs_devices, devid, uuid, NULL, true); if (!map->stripes[i].dev && !btrfs_test_opt(fs_info, DEGRADED)) { free_extent_map(em); btrfs_report_missing_device(fs_info, devid, uuid, true); return -ENOENT; } if (!map->stripes[i].dev) { map->stripes[i].dev = add_missing_dev(fs_info->fs_devices, devid, uuid); if (IS_ERR(map->stripes[i].dev)) { free_extent_map(em); btrfs_err(fs_info, ""failed to init missing dev %llu: %ld"", devid, PTR_ERR(map->stripes[i].dev)); return PTR_ERR(map->stripes[i].dev); } btrfs_report_missing_device(fs_info, devid, uuid, false); } set_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &(map->stripes[i].dev->dev_state)); } write_lock(&map_tree->map_tree.lock); ret = add_extent_mapping(&map_tree->map_tree, em, 0); write_unlock(&map_tree->map_tree.lock); if (ret < 0) { btrfs_err(fs_info, ""failed to add chunk map, start=%llu len=%llu: %d"", em->start, em->len, ret); } free_extent_map(em); return ret; }"
267,1630----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-6194--bin_bflt.c----*relocs,"static RList *relocs(RBinFile *arch) { struct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj; RList *list = r_list_newf ((RListFree)free); int i, len, n_got, amount; if (!list || !obj) { r_list_free (list); return NULL; } if (obj->hdr->flags & FLAT_FLAG_GOTPIC) { n_got = get_ngot_entries (obj); if (n_got) { amount = n_got * sizeof (ut32); if (amount < n_got || amount > UT32_MAX) { goto out_error; } <S2SV_StartVul> struct reloc_struct_t *got_table = calloc (1, n_got * sizeof (ut32)); <S2SV_EndVul> if (got_table) { ut32 offset = 0; for (i = 0; i < n_got ; offset += 4, i++) { ut32 got_entry; if (obj->hdr->data_start + offset + 4 > obj->size || obj->hdr->data_start + offset + 4 < offset) { break; } len = r_buf_read_at (obj->b, obj->hdr->data_start + offset, (ut8 *)&got_entry, sizeof (ut32)); if (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) { break; } got_table[i].addr_to_patch = got_entry; got_table[i].data_offset = got_entry + BFLT_HDR_SIZE; } obj->n_got = n_got; obj->got_table = got_table; } } } if (obj->hdr->reloc_count > 0) { int n_reloc = obj->hdr->reloc_count; amount = n_reloc * sizeof (struct reloc_struct_t); if (amount < n_reloc || amount > UT32_MAX) { goto out_error; } struct reloc_struct_t *reloc_table = calloc (1, amount + 1); if (!reloc_table) { goto out_error; } amount = n_reloc * sizeof (ut32); if (amount < n_reloc || amount > UT32_MAX) { free (reloc_table); goto out_error; } ut32 *reloc_pointer_table = calloc (1, amount + 1); if (!reloc_pointer_table) { free (reloc_table); goto out_error; } if (obj->hdr->reloc_start + amount > obj->size || obj->hdr->reloc_start + amount < amount) { free (reloc_table); free (reloc_pointer_table); goto out_error; } len = r_buf_read_at (obj->b, obj->hdr->reloc_start, (ut8 *)reloc_pointer_table, amount); if (len != amount) { free (reloc_table); free (reloc_pointer_table); goto out_error; } for (i = 0; i < obj->hdr->reloc_count; i++) { ut32 reloc_offset = r_swap_ut32 (reloc_pointer_table[i]) + BFLT_HDR_SIZE; if (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) { ut32 reloc_fixed, reloc_data_offset; if (reloc_offset + sizeof (ut32) > obj->size || reloc_offset + sizeof (ut32) < reloc_offset) { free (reloc_table); free (reloc_pointer_table); goto out_error; } len = r_buf_read_at (obj->b, reloc_offset, (ut8 *)&reloc_fixed, sizeof (ut32)); if (len != sizeof (ut32)) { eprintf (""problem while reading relocation entries\n""); free (reloc_table); free (reloc_pointer_table); goto out_error; } reloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE; reloc_table[i].addr_to_patch = reloc_offset; reloc_table[i].data_offset = reloc_data_offset; RBinReloc *reloc = R_NEW0 (RBinReloc); if (reloc) { reloc->type = R_BIN_RELOC_32; reloc->paddr = reloc_table[i].addr_to_patch; reloc->vaddr = reloc->paddr; r_list_append (list, reloc); } } } free (reloc_pointer_table); obj->reloc_table = reloc_table; } return list; out_error: r_list_free (list); return NULL; }","- struct reloc_struct_t *got_table = calloc (1, n_got * sizeof (ut32));
+ struct reloc_struct_t *got_table = calloc (
+ 1, n_got * sizeof (struct reloc_struct_t));","static RList *relocs(RBinFile *arch) { struct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj; RList *list = r_list_newf ((RListFree)free); int i, len, n_got, amount; if (!list || !obj) { r_list_free (list); return NULL; } if (obj->hdr->flags & FLAT_FLAG_GOTPIC) { n_got = get_ngot_entries (obj); if (n_got) { amount = n_got * sizeof (ut32); if (amount < n_got || amount > UT32_MAX) { goto out_error; } struct reloc_struct_t *got_table = calloc ( 1, n_got * sizeof (struct reloc_struct_t)); if (got_table) { ut32 offset = 0; for (i = 0; i < n_got ; offset += 4, i++) { ut32 got_entry; if (obj->hdr->data_start + offset + 4 > obj->size || obj->hdr->data_start + offset + 4 < offset) { break; } len = r_buf_read_at (obj->b, obj->hdr->data_start + offset, (ut8 *)&got_entry, sizeof (ut32)); if (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) { break; } got_table[i].addr_to_patch = got_entry; got_table[i].data_offset = got_entry + BFLT_HDR_SIZE; } obj->n_got = n_got; obj->got_table = got_table; } } } if (obj->hdr->reloc_count > 0) { int n_reloc = obj->hdr->reloc_count; amount = n_reloc * sizeof (struct reloc_struct_t); if (amount < n_reloc || amount > UT32_MAX) { goto out_error; } struct reloc_struct_t *reloc_table = calloc (1, amount + 1); if (!reloc_table) { goto out_error; } amount = n_reloc * sizeof (ut32); if (amount < n_reloc || amount > UT32_MAX) { free (reloc_table); goto out_error; } ut32 *reloc_pointer_table = calloc (1, amount + 1); if (!reloc_pointer_table) { free (reloc_table); goto out_error; } if (obj->hdr->reloc_start + amount > obj->size || obj->hdr->reloc_start + amount < amount) { free (reloc_table); free (reloc_pointer_table); goto out_error; } len = r_buf_read_at (obj->b, obj->hdr->reloc_start, (ut8 *)reloc_pointer_table, amount); if (len != amount) { free (reloc_table); free (reloc_pointer_table); goto out_error; } for (i = 0; i < obj->hdr->reloc_count; i++) { ut32 reloc_offset = r_swap_ut32 (reloc_pointer_table[i]) + BFLT_HDR_SIZE; if (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) { ut32 reloc_fixed, reloc_data_offset; if (reloc_offset + sizeof (ut32) > obj->size || reloc_offset + sizeof (ut32) < reloc_offset) { free (reloc_table); free (reloc_pointer_table); goto out_error; } len = r_buf_read_at (obj->b, reloc_offset, (ut8 *)&reloc_fixed, sizeof (ut32)); if (len != sizeof (ut32)) { eprintf (""problem while reading relocation entries\n""); free (reloc_table); free (reloc_pointer_table); goto out_error; } reloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE; reloc_table[i].addr_to_patch = reloc_offset; reloc_table[i].data_offset = reloc_data_offset; RBinReloc *reloc = R_NEW0 (RBinReloc); if (reloc) { reloc->type = R_BIN_RELOC_32; reloc->paddr = reloc_table[i].addr_to_patch; reloc->vaddr = reloc->paddr; r_list_append (list, reloc); } } } free (reloc_pointer_table); obj->reloc_table = reloc_table; } return list; out_error: r_list_free (list); return NULL; }"
268,2650----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/unpack50mt.cpp----Unpack::ProcessDecoded,"bool Unpack::ProcessDecoded(UnpackThreadData &D) { UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize; while (Item<Border) { UnpPtr&=MaxWinMask; <S2SV_StartVul> if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr) <S2SV_EndVul> { UnpWriteBuf(); if (WrittenFileSize>DestUnpSize) return false; } if (Item->Type==UNPDT_LITERAL) { #if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED) if (Item->Length==3 && UnpPtr<MaxWinSize-4) { *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal; UnpPtr+=4; } else #endif for (uint I=0;I<=Item->Length;I++) Window[UnpPtr++ & MaxWinMask]=Item->Literal[I]; } else if (Item->Type==UNPDT_MATCH) { InsertOldDist(Item->Distance); LastLength=Item->Length; CopyString(Item->Length,Item->Distance); } else if (Item->Type==UNPDT_REP) { uint Distance=OldDist[Item->Distance]; for (uint I=Item->Distance;I>0;I--) OldDist[I]=OldDist[I-1]; OldDist[0]=Distance; LastLength=Item->Length; CopyString(Item->Length,Distance); } else if (Item->Type==UNPDT_FULLREP) { if (LastLength!=0) CopyString(LastLength,OldDist[0]); } else if (Item->Type==UNPDT_FILTER) { UnpackFilter Filter; Filter.Type=(byte)Item->Length; Filter.BlockStart=Item->Distance; Item++; Filter.Channels=(byte)Item->Length; Filter.BlockLength=Item->Distance; AddFilter(Filter); } Item++; } return true; }","- if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)
+ if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr)","bool Unpack::ProcessDecoded(UnpackThreadData &D) { UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize; while (Item<Border) { UnpPtr&=MaxWinMask; if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr) { UnpWriteBuf(); if (WrittenFileSize>DestUnpSize) return false; } if (Item->Type==UNPDT_LITERAL) { #if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED) if (Item->Length==3 && UnpPtr<MaxWinSize-4) { *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal; UnpPtr+=4; } else #endif for (uint I=0;I<=Item->Length;I++) Window[UnpPtr++ & MaxWinMask]=Item->Literal[I]; } else if (Item->Type==UNPDT_MATCH) { InsertOldDist(Item->Distance); LastLength=Item->Length; CopyString(Item->Length,Item->Distance); } else if (Item->Type==UNPDT_REP) { uint Distance=OldDist[Item->Distance]; for (uint I=Item->Distance;I>0;I--) OldDist[I]=OldDist[I-1]; OldDist[0]=Distance; LastLength=Item->Length; CopyString(Item->Length,Distance); } else if (Item->Type==UNPDT_FULLREP) { if (LastLength!=0) CopyString(LastLength,OldDist[0]); } else if (Item->Type==UNPDT_FILTER) { UnpackFilter Filter; Filter.Type=(byte)Item->Length; Filter.BlockStart=Item->Distance; Item++; Filter.Channels=(byte)Item->Length; Filter.BlockLength=Item->Distance; AddFilter(Filter); } Item++; } return true; }"
269,4993----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/h263dec.c----h263_get_format,"static enum AVPixelFormat h263_get_format(AVCodecContext *avctx) { if (avctx->bits_per_raw_sample > 8) { <S2SV_StartVul> av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO); <S2SV_EndVul> return avctx->pix_fmt; } if (avctx->codec->id == AV_CODEC_ID_MSS2) return AV_PIX_FMT_YUV420P; if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) { if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED) avctx->color_range = AVCOL_RANGE_MPEG; return AV_PIX_FMT_GRAY8; } return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts); }","- av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
+ MpegEncContext *s = avctx->priv_data;
+ av_assert1(s->studio_profile);","static enum AVPixelFormat h263_get_format(AVCodecContext *avctx) { MpegEncContext *s = avctx->priv_data; if (avctx->bits_per_raw_sample > 8) { av_assert1(s->studio_profile); return avctx->pix_fmt; } if (avctx->codec->id == AV_CODEC_ID_MSS2) return AV_PIX_FMT_YUV420P; if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) { if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED) avctx->color_range = AVCOL_RANGE_MPEG; return AV_PIX_FMT_GRAY8; } return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts); }"
270,4548----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spl_array.c----SPL_METHOD,"SPL_METHOD(Array, unserialize) { spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC); char *buf; int buf_len; const unsigned char *p, *s; php_unserialize_data_t var_hash; zval *pmembers, *pflags = NULL; HashTable *aht; long flags; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &buf, &buf_len) == FAILURE) { return; } if (buf_len == 0) { return; } aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC); if (aht->nApplyCount > 0) { zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited""); return; } s = p = (const unsigned char*)buf; PHP_VAR_UNSERIALIZE_INIT(var_hash); if (*p!= 'x' || *++p != ':') { goto outexcept; } ++p; ALLOC_INIT_ZVAL(pflags); if (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) { goto outexcept; } var_push_dtor(&var_hash, &pflags); --p; flags = Z_LVAL_P(pflags); if (*p != ';') { goto outexcept; } ++p; if (*p!='m') { if (*p!='a' && *p!='O' && *p!='C' && *p!='r') { goto outexcept; } intern->ar_flags &= ~SPL_ARRAY_CLONE_MASK; intern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK; zval_ptr_dtor(&intern->array); ALLOC_INIT_ZVAL(intern->array); <S2SV_StartVul> if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) { <S2SV_EndVul> goto outexcept; } var_push_dtor(&var_hash, &intern->array); } if (*p != ';') { goto outexcept; } ++p; if (*p!= 'm' || *++p != ':') { goto outexcept; } ++p; ALLOC_INIT_ZVAL(pmembers); if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) { zval_ptr_dtor(&pmembers); goto outexcept; } var_push_dtor(&var_hash, &pmembers); if (!intern->std.properties) { rebuild_object_properties(&intern->std); } zend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *)); zval_ptr_dtor(&pmembers); PHP_VAR_UNSERIALIZE_DESTROY(var_hash); if (pflags) { zval_ptr_dtor(&pflags); } return; outexcept: PHP_VAR_UNSERIALIZE_DESTROY(var_hash); if (pflags) { zval_ptr_dtor(&pflags); } zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Error at offset %ld of %d bytes"", (long)((char*)p - buf), buf_len); return; }","- if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {
+ if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)
+ || (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {
+ zval_ptr_dtor(&intern->array);","SPL_METHOD(Array, unserialize) { spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC); char *buf; int buf_len; const unsigned char *p, *s; php_unserialize_data_t var_hash; zval *pmembers, *pflags = NULL; HashTable *aht; long flags; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &buf, &buf_len) == FAILURE) { return; } if (buf_len == 0) { return; } aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC); if (aht->nApplyCount > 0) { zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited""); return; } s = p = (const unsigned char*)buf; PHP_VAR_UNSERIALIZE_INIT(var_hash); if (*p!= 'x' || *++p != ':') { goto outexcept; } ++p; ALLOC_INIT_ZVAL(pflags); if (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) { goto outexcept; } var_push_dtor(&var_hash, &pflags); --p; flags = Z_LVAL_P(pflags); if (*p != ';') { goto outexcept; } ++p; if (*p!='m') { if (*p!='a' && *p!='O' && *p!='C' && *p!='r') { goto outexcept; } intern->ar_flags &= ~SPL_ARRAY_CLONE_MASK; intern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK; zval_ptr_dtor(&intern->array); ALLOC_INIT_ZVAL(intern->array); if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC) || (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) { zval_ptr_dtor(&intern->array); goto outexcept; } var_push_dtor(&var_hash, &intern->array); } if (*p != ';') { goto outexcept; } ++p; if (*p!= 'm' || *++p != ':') { goto outexcept; } ++p; ALLOC_INIT_ZVAL(pmembers); if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) { zval_ptr_dtor(&pmembers); goto outexcept; } var_push_dtor(&var_hash, &pmembers); if (!intern->std.properties) { rebuild_object_properties(&intern->std); } zend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *)); zval_ptr_dtor(&pmembers); PHP_VAR_UNSERIALIZE_DESTROY(var_hash); if (pflags) { zval_ptr_dtor(&pflags); } return; outexcept: PHP_VAR_UNSERIALIZE_DESTROY(var_hash); if (pflags) { zval_ptr_dtor(&pflags); } zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Error at offset %ld of %d bytes"", (long)((char*)p - buf), buf_len); return; }"
271,615----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-6418--auth_x.c----ceph_x_verify_authorizer_reply,"static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac, struct ceph_authorizer *a, size_t len) { struct ceph_x_authorizer *au = (void *)a; struct ceph_x_ticket_handler *th; int ret = 0; struct ceph_x_authorize_reply reply; void *p = au->reply_buf; void *end = p + sizeof(au->reply_buf); th = get_ticket_handler(ac, au->service); if (IS_ERR(th)) return PTR_ERR(th); <S2SV_StartVul> ret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply)); <S2SV_EndVul> if (ret < 0) return ret; if (ret != sizeof(reply)) return -EPERM; if (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one)) ret = -EPERM; else ret = 0; dout(""verify_authorizer_reply nonce %llx got %llx ret %d\n"", au->nonce, le64_to_cpu(reply.nonce_plus_one), ret); return ret; }","- ret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));
+ void *preply = &reply;
+ ret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));","static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac, struct ceph_authorizer *a, size_t len) { struct ceph_x_authorizer *au = (void *)a; struct ceph_x_ticket_handler *th; int ret = 0; struct ceph_x_authorize_reply reply; void *preply = &reply; void *p = au->reply_buf; void *end = p + sizeof(au->reply_buf); th = get_ticket_handler(ac, au->service); if (IS_ERR(th)) return PTR_ERR(th); ret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply)); if (ret < 0) return ret; if (ret != sizeof(reply)) return -EPERM; if (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one)) ret = -EPERM; else ret = 0; dout(""verify_authorizer_reply nonce %llx got %llx ret %d\n"", au->nonce, le64_to_cpu(reply.nonce_plus_one), ret); return ret; }"
272,1351----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-13037--print-ip.c----ip_printts,"ip_printts(netdissect_options *ndo, register const u_char *cp, u_int length) { register u_int ptr; register u_int len; int hoplen; const char *type; if (length < 4) { ND_PRINT((ndo, ""[bad length %u]"", length)); <S2SV_StartVul> return; <S2SV_EndVul> } ND_PRINT((ndo, "" TS{"")); hoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4; if ((length - 4) & (hoplen-1)) ND_PRINT((ndo, ""[bad length %u]"", length)); ptr = cp[2] - 1; len = 0; if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1) ND_PRINT((ndo, ""[bad ptr %u]"", cp[2])); switch (cp[3]&0xF) { case IPOPT_TS_TSONLY: ND_PRINT((ndo, ""TSONLY"")); break; case IPOPT_TS_TSANDADDR: ND_PRINT((ndo, ""TS+ADDR"")); break; case 2: ND_PRINT((ndo, ""PRESPEC2.0"")); break; case 3: ND_PRINT((ndo, ""PRESPEC"")); break; default: ND_PRINT((ndo, ""[bad ts type %d]"", cp[3]&0xF)); goto done; } type = "" ""; for (len = 4; len < length; len += hoplen) { if (ptr == len) type = "" ^ ""; ND_PRINT((ndo, ""%s%d@%s"", type, EXTRACT_32BITS(&cp[len+hoplen-4]), hoplen!=8 ? """" : ipaddr_string(ndo, &cp[len]))); type = "" ""; } done: ND_PRINT((ndo, ""%s"", ptr == len ? "" ^ "" : """")); if (cp[3]>>4) ND_PRINT((ndo, "" [%d hops not recorded]} "", cp[3]>>4)); else ND_PRINT((ndo, ""}""));","- return;
+ return (0);
+ ND_TCHECK(cp[2]);
+ ND_TCHECK(cp[3]);
+ ND_TCHECK2(cp[len], hoplen);
+ ","ip_printts(netdissect_options *ndo, register const u_char *cp, u_int length) { register u_int ptr; register u_int len; int hoplen; const char *type; if (length < 4) { ND_PRINT((ndo, ""[bad length %u]"", length)); return (0); } ND_PRINT((ndo, "" TS{"")); hoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4; if ((length - 4) & (hoplen-1)) ND_PRINT((ndo, ""[bad length %u]"", length)); ND_TCHECK(cp[2]); ptr = cp[2] - 1; len = 0; if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1) ND_PRINT((ndo, ""[bad ptr %u]"", cp[2])); ND_TCHECK(cp[3]); switch (cp[3]&0xF) { case IPOPT_TS_TSONLY: ND_PRINT((ndo, ""TSONLY"")); break; case IPOPT_TS_TSANDADDR: ND_PRINT((ndo, ""TS+ADDR"")); break; case 2: ND_PRINT((ndo, ""PRESPEC2.0"")); break; case 3: ND_PRINT((ndo, ""PRESPEC"")); break; default: ND_PRINT((ndo, ""[bad ts type %d]"", cp[3]&0xF)); goto done; } type = "" ""; for (len = 4; len < length; len += hoplen) { if (ptr == len) type = "" ^ ""; ND_TCHECK2(cp[len], hoplen); ND_PRINT((ndo, ""%s%d@%s"", type, EXTRACT_32BITS(&cp[len+hoplen-4]), hoplen!=8 ? """" : ipaddr_string(ndo, &cp[len]))); type = "" ""; } done: ND_PRINT((ndo, ""%s"", ptr == len ? "" ^ "" : """")); if (cp[3]>>4) ND_PRINT((ndo, "" [%d hops not recorded]} "", cp[3]>>4)); else ND_PRINT((ndo, ""}""));"
273,5531----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/enc624j600_driver.c----enc624j600IrqHandler,"bool_t enc624j600IrqHandler(NetInterface *interface) { bool_t flag; uint16_t status; flag = FALSE; <S2SV_StartVul> enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_INTIE); <S2SV_EndVul> <S2SV_StartVul> status = enc624j600ReadReg(interface, ENC624J600_REG_EIR); <S2SV_EndVul> <S2SV_StartVul> if((status & EIR_LINKIF) != 0) <S2SV_EndVul> { <S2SV_StartVul> enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_LINKIE); <S2SV_EndVul> interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } <S2SV_StartVul> if((status & EIR_PKTIF) != 0) <S2SV_EndVul> { <S2SV_StartVul> enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_PKTIE); <S2SV_EndVul> interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } <S2SV_StartVul> if((status & (EIR_TXIF | EIR_TXABTIF)) != 0) <S2SV_EndVul> { <S2SV_StartVul> enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_TXIF | EIR_TXABTIF); <S2SV_EndVul> flag |= osSetEventFromIsr(&interface->nicTxEvent); } <S2SV_StartVul> enc624j600SetBit(interface, ENC624J600_REG_EIE, EIE_INTIE); <S2SV_EndVul> return flag; }","- enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_INTIE);
- status = enc624j600ReadReg(interface, ENC624J600_REG_EIR);
- if((status & EIR_LINKIF) != 0)
- enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_LINKIE);
- if((status & EIR_PKTIF) != 0)
- enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_PKTIE);
- if((status & (EIR_TXIF | EIR_TXABTIF)) != 0)
- enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_TXIF | EIR_TXABTIF);
- enc624j600SetBit(interface, ENC624J600_REG_EIE, EIE_INTIE);
+ enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_INTIE);
+ status = enc624j600ReadReg(interface, ENC624J600_EIR);
+ if((status & ENC624J600_EIR_LINKIF) != 0)
+ enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE);
+ if((status & ENC624J600_EIR_PKTIF) != 0)
+ enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_PKTIE);
+ if((status & (ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF)) != 0)
+ enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_TXIF |
+ ENC624J600_EIR_TXABTIF);
+ enc624j600SetBit(interface, ENC624J600_EIE, ENC624J600_EIE_INTIE);","bool_t enc624j600IrqHandler(NetInterface *interface) { bool_t flag; uint16_t status; flag = FALSE; enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_INTIE); status = enc624j600ReadReg(interface, ENC624J600_EIR); if((status & ENC624J600_EIR_LINKIF) != 0) { enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE); interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } if((status & ENC624J600_EIR_PKTIF) != 0) { enc624j600ClearBit(interface, ENC624J600_EIE, ENC624J600_EIE_PKTIE); interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } if((status & (ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF)) != 0) { enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_TXIF | ENC624J600_EIR_TXABTIF); flag |= osSetEventFromIsr(&interface->nicTxEvent); } enc624j600SetBit(interface, ENC624J600_EIE, ENC624J600_EIE_INTIE); return flag; }"
274,4556----CWE-200----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dsa.cpp----Botan::DSA_PrivateKey::create_signature_op,"<S2SV_StartVul> DSA_PrivateKey::create_signature_op(RandomNumberGenerator& , <S2SV_EndVul> const std::string& params, const std::string& provider) const { if(provider == ""base"" || provider.empty()) <S2SV_StartVul> return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params)); <S2SV_EndVul> throw Provider_Not_Found(algo_name(), provider); }","- DSA_PrivateKey::create_signature_op(RandomNumberGenerator& /*rng*/,
- return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));
+ DSA_PrivateKey::create_signature_op(RandomNumberGenerator& rng,
+ return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params, rng));","DSA_PrivateKey::create_signature_op(RandomNumberGenerator& rng, const std::string& params, const std::string& provider) const { if(provider == ""base"" || provider.empty()) return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params, rng)); throw Provider_Not_Found(algo_name(), provider); }"
275,7226----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip6_tables.c----check_entry_size_and_hooks,"check_entry_size_and_hooks(struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks) { unsigned int h; int err; if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 || <S2SV_StartVul> (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) { <S2SV_EndVul> duprintf(""Bad offset %p\n"", e); return -EINVAL; } if (e->next_offset < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } err = check_entry(e); if (err) return err; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if (!(valid_hooks & (1 << h))) continue; if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) { if (!check_underflow(e)) { pr_err(""Underflows must be unconditional and "" ""use the STANDARD target with "" ""ACCEPT/DROP\n""); return -EINVAL; } newinfo->underflow[h] = underflows[h]; } } e->counters = ((struct xt_counters) { 0, 0 }); e->comefrom = 0; return 0; }","- (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {
+ (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||
+ (unsigned char *)e + e->next_offset > limit) {","check_entry_size_and_hooks(struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks) { unsigned int h; int err; if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 || (unsigned char *)e + sizeof(struct ip6t_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p\n"", e); return -EINVAL; } if (e->next_offset < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } err = check_entry(e); if (err) return err; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if (!(valid_hooks & (1 << h))) continue; if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) { if (!check_underflow(e)) { pr_err(""Underflows must be unconditional and "" ""use the STANDARD target with "" ""ACCEPT/DROP\n""); return -EINVAL; } newinfo->underflow[h] = underflows[h]; } } e->counters = ((struct xt_counters) { 0, 0 }); e->comefrom = 0; return 0; }"
276,2767----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/traps.c----get_tp_trap,"static int get_tp_trap(struct pt_regs *regs, unsigned int instr) { int reg = (instr >> 12) & 15; if (reg == 15) return 1; <S2SV_StartVul> regs->uregs[reg] = current_thread_info()->tp_value; <S2SV_EndVul> regs->ARM_pc += 4; return 0; }","- regs->uregs[reg] = current_thread_info()->tp_value;
+ regs->uregs[reg] = current_thread_info()->tp_value[0];","static int get_tp_trap(struct pt_regs *regs, unsigned int instr) { int reg = (instr >> 12) & 15; if (reg == 15) return 1; regs->uregs[reg] = current_thread_info()->tp_value[0]; regs->ARM_pc += 4; return 0; }"
277,6903----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/auth_gss.c----imap_auth_gss,"imap_auth_res_t imap_auth_gss (IMAP_DATA* idata, const char* method) { gss_buffer_desc request_buf, send_token; gss_buffer_t sec_token; gss_name_t target_name; gss_ctx_id_t context; #ifdef DEBUG gss_OID mech_name; char server_conf_flags; #endif gss_qop_t quality; int cflags; OM_uint32 maj_stat, min_stat; char buf1[GSS_BUFSIZE], buf2[GSS_BUFSIZE]; unsigned long buf_size; int rc; if (!mutt_bit_isset (idata->capabilities, AGSSAPI)) return IMAP_AUTH_UNAVAIL; if (mutt_account_getuser (&idata->conn->account)) return IMAP_AUTH_FAILURE; snprintf (buf1, sizeof (buf1), ""imap@%s"", idata->conn->account.host); request_buf.value = buf1; request_buf.length = strlen (buf1); maj_stat = gss_import_name (&min_stat, &request_buf, gss_nt_service_name, &target_name); if (maj_stat != GSS_S_COMPLETE) { dprint (2, (debugfile, ""Couldn't get service name for [%s]\n"", buf1)); return IMAP_AUTH_UNAVAIL; } #ifdef DEBUG else if (debuglevel >= 2) { maj_stat = gss_display_name (&min_stat, target_name, &request_buf, &mech_name); dprint (2, (debugfile, ""Using service name [%s]\n"", (char*) request_buf.value)); maj_stat = gss_release_buffer (&min_stat, &request_buf); } #endif sec_token = GSS_C_NO_BUFFER; context = GSS_C_NO_CONTEXT; maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token, (unsigned int*) &cflags, NULL); if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED) { print_gss_error(maj_stat, min_stat); dprint (1, (debugfile, ""Error acquiring credentials - no TGT?\n"")); gss_release_name (&min_stat, &target_name); return IMAP_AUTH_UNAVAIL; } mutt_message _(""Authenticating (GSSAPI)...""); imap_cmd_start (idata, ""AUTHENTICATE GSSAPI""); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { dprint (2, (debugfile, ""Invalid response from server: %s\n"", buf1)); gss_release_name (&min_stat, &target_name); goto bail; } dprint (2, (debugfile, ""Sending credentials\n"")); mutt_to_base64 ((unsigned char*) buf1, send_token.value, send_token.length, sizeof (buf1) - 2); gss_release_buffer (&min_stat, &send_token); safe_strcat (buf1, sizeof (buf1), ""\r\n""); mutt_socket_write (idata->conn, buf1); while (maj_stat == GSS_S_CONTINUE_NEEDED) { do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { dprint (1, (debugfile, ""Error receiving server response.\n"")); gss_release_name (&min_stat, &target_name); goto bail; } <S2SV_StartVul> request_buf.length = mutt_from_base64 (buf2, idata->buf + 2); <S2SV_EndVul> request_buf.value = buf2; sec_token = &request_buf; maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token, (unsigned int*) &cflags, NULL); if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED) { print_gss_error(maj_stat, min_stat); dprint (1, (debugfile, ""Error exchanging credentials\n"")); gss_release_name (&min_stat, &target_name); goto err_abort_cmd; } mutt_to_base64 ((unsigned char*) buf1, send_token.value, send_token.length, sizeof (buf1) - 2); gss_release_buffer (&min_stat, &send_token); safe_strcat (buf1, sizeof (buf1), ""\r\n""); mutt_socket_write (idata->conn, buf1); } gss_release_name (&min_stat, &target_name); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { dprint (1, (debugfile, ""Error receiving server response.\n"")); goto bail; } <S2SV_StartVul> request_buf.length = mutt_from_base64 (buf2, idata->buf + 2); <S2SV_EndVul> request_buf.value = buf2; maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token, &cflags, &quality); if (maj_stat != GSS_S_COMPLETE) { print_gss_error(maj_stat, min_stat); dprint (2, (debugfile, ""Couldn't unwrap security level data\n"")); gss_release_buffer (&min_stat, &send_token); goto err_abort_cmd; } dprint (2, (debugfile, ""Credential exchange complete\n"")); #ifdef DEBUG server_conf_flags = ((char*) send_token.value)[0]; #endif if ( !(((char*) send_token.value)[0] & GSS_AUTH_P_NONE) ) { dprint (2, (debugfile, ""Server requires integrity or privacy\n"")); gss_release_buffer (&min_stat, &send_token); goto err_abort_cmd; } ((char*) send_token.value)[0] = 0; buf_size = ntohl (*((long *) send_token.value)); gss_release_buffer (&min_stat, &send_token); dprint (2, (debugfile, ""Unwrapped security level flags: %c%c%c\n"", server_conf_flags & GSS_AUTH_P_NONE ? 'N' : '-', server_conf_flags & GSS_AUTH_P_INTEGRITY ? 'I' : '-', server_conf_flags & GSS_AUTH_P_PRIVACY ? 'P' : '-')); dprint (2, (debugfile, ""Maximum GSS token size is %ld\n"", buf_size)); buf_size = htonl (buf_size); memcpy (buf1, &buf_size, 4); buf1[0] = GSS_AUTH_P_NONE; strncpy (buf1 + 4, idata->conn->account.user, sizeof (buf1) - 4); request_buf.value = buf1; request_buf.length = 4 + strlen (idata->conn->account.user); maj_stat = gss_wrap (&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf, &cflags, &send_token); if (maj_stat != GSS_S_COMPLETE) { dprint (2, (debugfile, ""Error creating login request\n"")); goto err_abort_cmd; } mutt_to_base64 ((unsigned char*) buf1, send_token.value, send_token.length, sizeof (buf1) - 2); dprint (2, (debugfile, ""Requesting authorisation as %s\n"", idata->conn->account.user)); safe_strcat (buf1, sizeof (buf1), ""\r\n""); mutt_socket_write (idata->conn, buf1); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc == IMAP_CMD_RESPOND) { dprint (1, (debugfile, ""Unexpected server continuation request.\n"")); goto err_abort_cmd; } if (imap_code (idata->buf)) { dprint (2, (debugfile, ""Releasing GSS credentials\n"")); maj_stat = gss_delete_sec_context (&min_stat, &context, &send_token); if (maj_stat != GSS_S_COMPLETE) dprint (1, (debugfile, ""Error releasing credentials\n"")); gss_release_buffer (&min_stat, &send_token); return IMAP_AUTH_SUCCESS; } else goto bail; err_abort_cmd: mutt_socket_write (idata->conn, ""*\r\n""); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); bail: mutt_error _(""GSSAPI authentication failed.""); mutt_sleep (2); return IMAP_AUTH_FAILURE; }","- request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);
- request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);
+ request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));
+ request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));","imap_auth_res_t imap_auth_gss (IMAP_DATA* idata, const char* method) { gss_buffer_desc request_buf, send_token; gss_buffer_t sec_token; gss_name_t target_name; gss_ctx_id_t context; #ifdef DEBUG gss_OID mech_name; char server_conf_flags; #endif gss_qop_t quality; int cflags; OM_uint32 maj_stat, min_stat; char buf1[GSS_BUFSIZE], buf2[GSS_BUFSIZE]; unsigned long buf_size; int rc; if (!mutt_bit_isset (idata->capabilities, AGSSAPI)) return IMAP_AUTH_UNAVAIL; if (mutt_account_getuser (&idata->conn->account)) return IMAP_AUTH_FAILURE; snprintf (buf1, sizeof (buf1), ""imap@%s"", idata->conn->account.host); request_buf.value = buf1; request_buf.length = strlen (buf1); maj_stat = gss_import_name (&min_stat, &request_buf, gss_nt_service_name, &target_name); if (maj_stat != GSS_S_COMPLETE) { dprint (2, (debugfile, ""Couldn't get service name for [%s]\n"", buf1)); return IMAP_AUTH_UNAVAIL; } #ifdef DEBUG else if (debuglevel >= 2) { maj_stat = gss_display_name (&min_stat, target_name, &request_buf, &mech_name); dprint (2, (debugfile, ""Using service name [%s]\n"", (char*) request_buf.value)); maj_stat = gss_release_buffer (&min_stat, &request_buf); } #endif sec_token = GSS_C_NO_BUFFER; context = GSS_C_NO_CONTEXT; maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token, (unsigned int*) &cflags, NULL); if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED) { print_gss_error(maj_stat, min_stat); dprint (1, (debugfile, ""Error acquiring credentials - no TGT?\n"")); gss_release_name (&min_stat, &target_name); return IMAP_AUTH_UNAVAIL; } mutt_message _(""Authenticating (GSSAPI)...""); imap_cmd_start (idata, ""AUTHENTICATE GSSAPI""); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { dprint (2, (debugfile, ""Invalid response from server: %s\n"", buf1)); gss_release_name (&min_stat, &target_name); goto bail; } dprint (2, (debugfile, ""Sending credentials\n"")); mutt_to_base64 ((unsigned char*) buf1, send_token.value, send_token.length, sizeof (buf1) - 2); gss_release_buffer (&min_stat, &send_token); safe_strcat (buf1, sizeof (buf1), ""\r\n""); mutt_socket_write (idata->conn, buf1); while (maj_stat == GSS_S_CONTINUE_NEEDED) { do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { dprint (1, (debugfile, ""Error receiving server response.\n"")); gss_release_name (&min_stat, &target_name); goto bail; } request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2)); request_buf.value = buf2; sec_token = &request_buf; maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context, target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token, (unsigned int*) &cflags, NULL); if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED) { print_gss_error(maj_stat, min_stat); dprint (1, (debugfile, ""Error exchanging credentials\n"")); gss_release_name (&min_stat, &target_name); goto err_abort_cmd; } mutt_to_base64 ((unsigned char*) buf1, send_token.value, send_token.length, sizeof (buf1) - 2); gss_release_buffer (&min_stat, &send_token); safe_strcat (buf1, sizeof (buf1), ""\r\n""); mutt_socket_write (idata->conn, buf1); } gss_release_name (&min_stat, &target_name); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { dprint (1, (debugfile, ""Error receiving server response.\n"")); goto bail; } request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2)); request_buf.value = buf2; maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token, &cflags, &quality); if (maj_stat != GSS_S_COMPLETE) { print_gss_error(maj_stat, min_stat); dprint (2, (debugfile, ""Couldn't unwrap security level data\n"")); gss_release_buffer (&min_stat, &send_token); goto err_abort_cmd; } dprint (2, (debugfile, ""Credential exchange complete\n"")); #ifdef DEBUG server_conf_flags = ((char*) send_token.value)[0]; #endif if ( !(((char*) send_token.value)[0] & GSS_AUTH_P_NONE) ) { dprint (2, (debugfile, ""Server requires integrity or privacy\n"")); gss_release_buffer (&min_stat, &send_token); goto err_abort_cmd; } ((char*) send_token.value)[0] = 0; buf_size = ntohl (*((long *) send_token.value)); gss_release_buffer (&min_stat, &send_token); dprint (2, (debugfile, ""Unwrapped security level flags: %c%c%c\n"", server_conf_flags & GSS_AUTH_P_NONE ? 'N' : '-', server_conf_flags & GSS_AUTH_P_INTEGRITY ? 'I' : '-', server_conf_flags & GSS_AUTH_P_PRIVACY ? 'P' : '-')); dprint (2, (debugfile, ""Maximum GSS token size is %ld\n"", buf_size)); buf_size = htonl (buf_size); memcpy (buf1, &buf_size, 4); buf1[0] = GSS_AUTH_P_NONE; strncpy (buf1 + 4, idata->conn->account.user, sizeof (buf1) - 4); request_buf.value = buf1; request_buf.length = 4 + strlen (idata->conn->account.user); maj_stat = gss_wrap (&min_stat, context, 0, GSS_C_QOP_DEFAULT, &request_buf, &cflags, &send_token); if (maj_stat != GSS_S_COMPLETE) { dprint (2, (debugfile, ""Error creating login request\n"")); goto err_abort_cmd; } mutt_to_base64 ((unsigned char*) buf1, send_token.value, send_token.length, sizeof (buf1) - 2); dprint (2, (debugfile, ""Requesting authorisation as %s\n"", idata->conn->account.user)); safe_strcat (buf1, sizeof (buf1), ""\r\n""); mutt_socket_write (idata->conn, buf1); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); if (rc == IMAP_CMD_RESPOND) { dprint (1, (debugfile, ""Unexpected server continuation request.\n"")); goto err_abort_cmd; } if (imap_code (idata->buf)) { dprint (2, (debugfile, ""Releasing GSS credentials\n"")); maj_stat = gss_delete_sec_context (&min_stat, &context, &send_token); if (maj_stat != GSS_S_COMPLETE) dprint (1, (debugfile, ""Error releasing credentials\n"")); gss_release_buffer (&min_stat, &send_token); return IMAP_AUTH_SUCCESS; } else goto bail; err_abort_cmd: mutt_socket_write (idata->conn, ""*\r\n""); do rc = imap_cmd_step (idata); while (rc == IMAP_CMD_CONTINUE); bail: mutt_error _(""GSSAPI authentication failed.""); mutt_sleep (2); return IMAP_AUTH_FAILURE; }"
278,113----CWE-400----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-6307--statem_lib.c----tls_get_message_header,"int tls_get_message_header(SSL *s, int *mt) { int skip_message, i, recvd_type, al; unsigned char *p; unsigned long l; p = (unsigned char *)s->init_buf->data; do { while (s->init_num < SSL3_HM_HEADER_LENGTH) { i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type, &p[s->init_num], SSL3_HM_HEADER_LENGTH - s->init_num, 0); if (i <= 0) { s->rwstate = SSL_READING; return 0; } if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) { if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_BAD_CHANGE_CIPHER_SPEC); goto f_err; } s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC; s->init_num = i - 1; s->s3->tmp.message_size = i; return 1; } else if (recvd_type != SSL3_RT_HANDSHAKE) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY); goto f_err; } s->init_num += i; } skip_message = 0; if (!s->server) if (p[0] == SSL3_MT_HELLO_REQUEST) if (p[1] == 0 && p[2] == 0 && p[3] == 0) { s->init_num = 0; skip_message = 1; if (s->msg_callback) s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, SSL3_HM_HEADER_LENGTH, s, s->msg_callback_arg); } } while (skip_message); *mt = *p; s->s3->tmp.message_type = *(p++); if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) { l = RECORD_LAYER_get_rrec_length(&s->rlayer) + SSL3_HM_HEADER_LENGTH; <S2SV_StartVul> if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) { <S2SV_EndVul> <S2SV_StartVul> SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB); <S2SV_EndVul> <S2SV_StartVul> goto err; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> s->s3->tmp.message_size = l; s->init_msg = s->init_buf->data; } s->s3->tmp.message_size = l; s->init_msg = s->init_buf->data; s->init_num = SSL3_HM_HEADER_LENGTH; } else { SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE); goto f_err; } <S2SV_StartVul> <S2SV_EndVul>","- if (l && !BUF_MEM_grow_clean(s->init_buf, (int)l)) {
- SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, ERR_R_BUF_LIB);
- goto err;
- }
- ","int tls_get_message_header(SSL *s, int *mt) { int skip_message, i, recvd_type, al; unsigned char *p; unsigned long l; p = (unsigned char *)s->init_buf->data; do { while (s->init_num < SSL3_HM_HEADER_LENGTH) { i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &recvd_type, &p[s->init_num], SSL3_HM_HEADER_LENGTH - s->init_num, 0); if (i <= 0) { s->rwstate = SSL_READING; return 0; } if (recvd_type == SSL3_RT_CHANGE_CIPHER_SPEC) { if (s->init_num != 0 || i != 1 || p[0] != SSL3_MT_CCS) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_BAD_CHANGE_CIPHER_SPEC); goto f_err; } s->s3->tmp.message_type = *mt = SSL3_MT_CHANGE_CIPHER_SPEC; s->init_num = i - 1; s->s3->tmp.message_size = i; return 1; } else if (recvd_type != SSL3_RT_HANDSHAKE) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_CCS_RECEIVED_EARLY); goto f_err; } s->init_num += i; } skip_message = 0; if (!s->server) if (p[0] == SSL3_MT_HELLO_REQUEST) if (p[1] == 0 && p[2] == 0 && p[3] == 0) { s->init_num = 0; skip_message = 1; if (s->msg_callback) s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, p, SSL3_HM_HEADER_LENGTH, s, s->msg_callback_arg); } } while (skip_message); *mt = *p; s->s3->tmp.message_type = *(p++); if (RECORD_LAYER_is_sslv2_record(&s->rlayer)) { l = RECORD_LAYER_get_rrec_length(&s->rlayer) + SSL3_HM_HEADER_LENGTH; s->s3->tmp.message_size = l; s->init_msg = s->init_buf->data; } s->s3->tmp.message_size = l; s->init_msg = s->init_buf->data; s->init_num = SSL3_HM_HEADER_LENGTH; } else { SSLerr(SSL_F_TLS_GET_MESSAGE_HEADER, SSL_R_EXCESSIVE_MESSAGE_SIZE); goto f_err; }"
279,2906----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/virtio_rpmsg_bus.c----rpmsg_virtio_add_ctrl_dev,"static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev) { struct virtproc_info *vrp = vdev->priv; struct virtio_rpmsg_channel *vch; struct rpmsg_device *rpdev_ctrl; int err = 0; vch = kzalloc(sizeof(*vch), GFP_KERNEL); if (!vch) return ERR_PTR(-ENOMEM); vch->vrp = vrp; rpdev_ctrl = &vch->rpdev; rpdev_ctrl->ops = &virtio_rpmsg_ops; rpdev_ctrl->dev.parent = &vrp->vdev->dev; rpdev_ctrl->dev.release = virtio_rpmsg_release_device; rpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev); err = rpmsg_ctrldev_register_device(rpdev_ctrl); if (err) { <S2SV_StartVul> kfree(vch); <S2SV_EndVul> return ERR_PTR(err); } return rpdev_ctrl; }",- kfree(vch);,"static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev) { struct virtproc_info *vrp = vdev->priv; struct virtio_rpmsg_channel *vch; struct rpmsg_device *rpdev_ctrl; int err = 0; vch = kzalloc(sizeof(*vch), GFP_KERNEL); if (!vch) return ERR_PTR(-ENOMEM); vch->vrp = vrp; rpdev_ctrl = &vch->rpdev; rpdev_ctrl->ops = &virtio_rpmsg_ops; rpdev_ctrl->dev.parent = &vrp->vdev->dev; rpdev_ctrl->dev.release = virtio_rpmsg_release_device; rpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev); err = rpmsg_ctrldev_register_device(rpdev_ctrl); if (err) { return ERR_PTR(err); } return rpdev_ctrl; }"
280,2615----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2893--templates.c----xsltAttrTemplateProcess,"xsltAttrTemplateProcess(xsltTransformContextPtr ctxt, xmlNodePtr target, xmlAttrPtr attr) { const xmlChar *value; xmlAttrPtr ret; if ((ctxt == NULL) || (attr == NULL) || (target == NULL)) return(NULL); if (attr->type != XML_ATTRIBUTE_NODE) return(NULL); #ifdef XSLT_REFACTORED if (attr->psvi == xsltXSLTAttrMarker) return(NULL); #else if ((attr->ns != NULL) && xmlStrEqual(attr->ns->href, XSLT_NAMESPACE)) return(NULL); #endif if (attr->children != NULL) { if ((attr->children->type != XML_TEXT_NODE) || (attr->children->next != NULL)) { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: The children of an attribute node of a "" ""literal result element are not in the expected form.\n""); return(NULL); } value = attr->children->content; if (value == NULL) value = xmlDictLookup(ctxt->dict, BAD_CAST """", 0); } else value = xmlDictLookup(ctxt->dict, BAD_CAST """", 0); ret = target->properties; while (ret != NULL) { if (((attr->ns != NULL) == (ret->ns != NULL)) && xmlStrEqual(ret->name, attr->name) && ((attr->ns == NULL) || xmlStrEqual(ret->ns->href, attr->ns->href))) { break; } ret = ret->next; } if (ret != NULL) { xmlFreeNodeList(ret->children); ret->children = ret->last = NULL; if ((ret->ns != NULL) && (! xmlStrEqual(ret->ns->prefix, attr->ns->prefix))) { ret->ns = xsltGetNamespace(ctxt, attr->parent, attr->ns, target); } } else { if (attr->ns != NULL) ret = xmlNewNsProp(target, xsltGetNamespace(ctxt, attr->parent, attr->ns, target), attr->name, NULL); else ret = xmlNewNsProp(target, NULL, attr->name, NULL); } if (ret != NULL) { xmlNodePtr text; text = xmlNewText(NULL); if (text != NULL) { ret->last = ret->children = text; text->parent = (xmlNodePtr) ret; text->doc = ret->doc; if (attr->psvi != NULL) { xmlChar *val; val = xsltEvalAVT(ctxt, attr->psvi, attr->parent); if (val == NULL) { if (attr->ns) { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to evaluate the AVT "" ""of attribute '{%s}%s'.\n"", attr->ns->href, attr->name); } else { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to evaluate the AVT "" ""of attribute '%s'.\n"", attr->name); } text->content = xmlStrdup(BAD_CAST """"); } else { text->content = val; } } else if ((ctxt->internalized) && (target != NULL) && (target->doc != NULL) && <S2SV_StartVul> (target->doc->dict == ctxt->dict)) { <S2SV_EndVul> text->content = (xmlChar *) value; } else { text->content = xmlStrdup(value); } } } else { if (attr->ns) { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to create attribute '{%s}%s'.\n"", attr->ns->href, attr->name); } else { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to create attribute '%s'.\n"", attr->name); } } return(ret); }","- (target->doc->dict == ctxt->dict)) {
+ (target->doc->dict == ctxt->dict) &&
+ xmlDictOwns(ctxt->dict, value)) {","xsltAttrTemplateProcess(xsltTransformContextPtr ctxt, xmlNodePtr target, xmlAttrPtr attr) { const xmlChar *value; xmlAttrPtr ret; if ((ctxt == NULL) || (attr == NULL) || (target == NULL)) return(NULL); if (attr->type != XML_ATTRIBUTE_NODE) return(NULL); #ifdef XSLT_REFACTORED if (attr->psvi == xsltXSLTAttrMarker) return(NULL); #else if ((attr->ns != NULL) && xmlStrEqual(attr->ns->href, XSLT_NAMESPACE)) return(NULL); #endif if (attr->children != NULL) { if ((attr->children->type != XML_TEXT_NODE) || (attr->children->next != NULL)) { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: The children of an attribute node of a "" ""literal result element are not in the expected form.\n""); return(NULL); } value = attr->children->content; if (value == NULL) value = xmlDictLookup(ctxt->dict, BAD_CAST """", 0); } else value = xmlDictLookup(ctxt->dict, BAD_CAST """", 0); ret = target->properties; while (ret != NULL) { if (((attr->ns != NULL) == (ret->ns != NULL)) && xmlStrEqual(ret->name, attr->name) && ((attr->ns == NULL) || xmlStrEqual(ret->ns->href, attr->ns->href))) { break; } ret = ret->next; } if (ret != NULL) { xmlFreeNodeList(ret->children); ret->children = ret->last = NULL; if ((ret->ns != NULL) && (! xmlStrEqual(ret->ns->prefix, attr->ns->prefix))) { ret->ns = xsltGetNamespace(ctxt, attr->parent, attr->ns, target); } } else { if (attr->ns != NULL) ret = xmlNewNsProp(target, xsltGetNamespace(ctxt, attr->parent, attr->ns, target), attr->name, NULL); else ret = xmlNewNsProp(target, NULL, attr->name, NULL); } if (ret != NULL) { xmlNodePtr text; text = xmlNewText(NULL); if (text != NULL) { ret->last = ret->children = text; text->parent = (xmlNodePtr) ret; text->doc = ret->doc; if (attr->psvi != NULL) { xmlChar *val; val = xsltEvalAVT(ctxt, attr->psvi, attr->parent); if (val == NULL) { if (attr->ns) { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to evaluate the AVT "" ""of attribute '{%s}%s'.\n"", attr->ns->href, attr->name); } else { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to evaluate the AVT "" ""of attribute '%s'.\n"", attr->name); } text->content = xmlStrdup(BAD_CAST """"); } else { text->content = val; } } else if ((ctxt->internalized) && (target != NULL) && (target->doc != NULL) && (target->doc->dict == ctxt->dict) && xmlDictOwns(ctxt->dict, value)) { text->content = (xmlChar *) value; } else { text->content = xmlStrdup(value); } } } else { if (attr->ns) { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to create attribute '{%s}%s'.\n"", attr->ns->href, attr->name); } else { xsltTransformError(ctxt, NULL, attr->parent, ""Internal error: Failed to create attribute '%s'.\n"", attr->name); } } return(ret); }"
281,6222----CWE-352----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/processor.c----set_content_type,"void set_content_type(HttpResponse res, const char *mime) { <S2SV_StartVul> set_header(res, ""Content-Type"", mime); <S2SV_EndVul> }","- set_header(res, ""Content-Type"", mime);
+ set_header(res, ""Content-Type"", ""%s"", mime);","void set_content_type(HttpResponse res, const char *mime) { set_header(res, ""Content-Type"", ""%s"", mime); }"
282,632--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-4653--control.c----snd_ctl_add,"int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol) { struct snd_ctl_elem_id id; unsigned int idx; int err = -EINVAL; if (! kcontrol) return err; if (snd_BUG_ON(!card || !kcontrol->info)) goto error; id = kcontrol->id; down_write(&card->controls_rwsem); if (snd_ctl_find_id(card, &id)) { up_write(&card->controls_rwsem); dev_err(card->dev, ""control %i:%i:%i:%s:%i is already present\n"", id.iface, id.device, id.subdevice, id.name, id.index); err = -EBUSY; goto error; } if (snd_ctl_find_hole(card, kcontrol->count) < 0) { up_write(&card->controls_rwsem); err = -ENOMEM; goto error; } list_add_tail(&kcontrol->list, &card->controls); card->controls_count += kcontrol->count; kcontrol->id.numid = card->last_numid + 1; card->last_numid += kcontrol->count; up_write(&card->controls_rwsem); <S2SV_StartVul> for (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++) <S2SV_EndVul> snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id); return 0; error: snd_ctl_free_one(kcontrol); return err; }","- for (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)
+ unsigned int count;
+ count = kcontrol->count;
+ for (idx = 0; idx < count; idx++, id.index++, id.numid++)","int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol) { struct snd_ctl_elem_id id; unsigned int idx; unsigned int count; int err = -EINVAL; if (! kcontrol) return err; if (snd_BUG_ON(!card || !kcontrol->info)) goto error; id = kcontrol->id; down_write(&card->controls_rwsem); if (snd_ctl_find_id(card, &id)) { up_write(&card->controls_rwsem); dev_err(card->dev, ""control %i:%i:%i:%s:%i is already present\n"", id.iface, id.device, id.subdevice, id.name, id.index); err = -EBUSY; goto error; } if (snd_ctl_find_hole(card, kcontrol->count) < 0) { up_write(&card->controls_rwsem); err = -ENOMEM; goto error; } list_add_tail(&kcontrol->list, &card->controls); card->controls_count += kcontrol->count; kcontrol->id.numid = card->last_numid + 1; card->last_numid += kcontrol->count; count = kcontrol->count; up_write(&card->controls_rwsem); for (idx = 0; idx < count; idx++, id.index++, id.numid++) snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id); return 0; error: snd_ctl_free_one(kcontrol); return err; }"
283,3337----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiJSON.c----jsonNewDString,"static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len) { <S2SV_StartVul> char buf[100], *dp = buf; <S2SV_EndVul> const char *cp = str; int ulen; while ((cp-str)<len) { if (*cp == '\\') { switch (cp[1]) { case 'b': *dp++ = '\b'; break; case 'n': *dp++ = '\n'; break; case 'r': *dp++ = '\r'; break; case 'f': *dp++ = '\f'; break; case 't': *dp++ = '\t'; break; case '\""': *dp++ = '\""'; break; case '\\': *dp++ = '\\'; break; case 'u': if ((ulen=Jsi_UtfDecode(cp+2, dp))) { dp += ulen; cp += 4; } else { *dp++ = '\\'; *dp++ = 'u'; } break; } cp+=2; } else { *dp++ = *cp++; } if ((dp-buf)>90) { *dp = 0; Jsi_DSAppendLen(dStr, buf, dp-buf); dp = buf; } } *dp = 0; Jsi_DSAppendLen(dStr, buf, dp-buf); }","- char buf[100], *dp = buf;
+ char buf[JSI_MAX_NUMBER_STRING], *dp = buf;","static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len) { char buf[JSI_MAX_NUMBER_STRING], *dp = buf; const char *cp = str; int ulen; while ((cp-str)<len) { if (*cp == '\\') { switch (cp[1]) { case 'b': *dp++ = '\b'; break; case 'n': *dp++ = '\n'; break; case 'r': *dp++ = '\r'; break; case 'f': *dp++ = '\f'; break; case 't': *dp++ = '\t'; break; case '\""': *dp++ = '\""'; break; case '\\': *dp++ = '\\'; break; case 'u': if ((ulen=Jsi_UtfDecode(cp+2, dp))) { dp += ulen; cp += 4; } else { *dp++ = '\\'; *dp++ = 'u'; } break; } cp+=2; } else { *dp++ = *cp++; } if ((dp-buf)>90) { *dp = 0; Jsi_DSAppendLen(dStr, buf, dp-buf); dp = buf; } } *dp = 0; Jsi_DSAppendLen(dStr, buf, dp-buf); }"
284,1008----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-5195--gup.c----*follow_page_pte,"static struct page *follow_page_pte(struct vm_area_struct *vma, unsigned long address, pmd_t *pmd, unsigned int flags) { struct mm_struct *mm = vma->vm_mm; struct dev_pagemap *pgmap = NULL; struct page *page; spinlock_t *ptl; pte_t *ptep, pte; retry: if (unlikely(pmd_bad(*pmd))) return no_page_table(vma, flags); ptep = pte_offset_map_lock(mm, pmd, address, &ptl); pte = *ptep; if (!pte_present(pte)) { swp_entry_t entry; if (likely(!(flags & FOLL_MIGRATION))) goto no_page; if (pte_none(pte)) goto no_page; entry = pte_to_swp_entry(pte); if (!is_migration_entry(entry)) goto no_page; pte_unmap_unlock(ptep, ptl); migration_entry_wait(mm, pmd, address); goto retry; } if ((flags & FOLL_NUMA) && pte_protnone(pte)) goto no_page; <S2SV_StartVul> if ((flags & FOLL_WRITE) && !pte_write(pte)) { <S2SV_EndVul> pte_unmap_unlock(ptep, ptl); return NULL; } page = vm_normal_page(vma, address, pte); if (!page && pte_devmap(pte) && (flags & FOLL_GET)) { pgmap = get_dev_pagemap(pte_pfn(pte), NULL); if (pgmap) page = pte_page(pte); else goto no_page; } else if (unlikely(!page)) { if (flags & FOLL_DUMP) { page = ERR_PTR(-EFAULT); goto out; } if (is_zero_pfn(pte_pfn(pte))) { page = pte_page(pte); } else { int ret; ret = follow_pfn_pte(vma, address, ptep, flags); page = ERR_PTR(ret); goto out; } } if (flags & FOLL_SPLIT && PageTransCompound(page)) { int ret; get_page(page); pte_unmap_unlock(ptep, ptl); lock_page(page); ret = split_huge_page(page); unlock_page(page); put_page(page); if (ret) return ERR_PTR(ret); goto retry; } if (flags & FOLL_GET) { get_page(page); if (pgmap) { put_dev_pagemap(pgmap); pgmap = NULL; } } if (flags & FOLL_TOUCH) { if ((flags & FOLL_WRITE) && !pte_dirty(pte) && !PageDirty(page)) set_page_dirty(page); mark_page_accessed(page); } if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) { if (PageTransCompound(page)) goto out; if (page->mapping && trylock_page(page)) { lru_add_drain(); mlock_vma_page(page); unlock_page(page); } } out: pte_unmap_unlock(ptep, ptl); return page; no_page: pte_unmap_unlock(ptep, ptl); if (!pte_none(pte)) return NULL; return no_page_table(vma, flags); }","- if ((flags & FOLL_WRITE) && !pte_write(pte)) {
+ if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {","static struct page *follow_page_pte(struct vm_area_struct *vma, unsigned long address, pmd_t *pmd, unsigned int flags) { struct mm_struct *mm = vma->vm_mm; struct dev_pagemap *pgmap = NULL; struct page *page; spinlock_t *ptl; pte_t *ptep, pte; retry: if (unlikely(pmd_bad(*pmd))) return no_page_table(vma, flags); ptep = pte_offset_map_lock(mm, pmd, address, &ptl); pte = *ptep; if (!pte_present(pte)) { swp_entry_t entry; if (likely(!(flags & FOLL_MIGRATION))) goto no_page; if (pte_none(pte)) goto no_page; entry = pte_to_swp_entry(pte); if (!is_migration_entry(entry)) goto no_page; pte_unmap_unlock(ptep, ptl); migration_entry_wait(mm, pmd, address); goto retry; } if ((flags & FOLL_NUMA) && pte_protnone(pte)) goto no_page; if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) { pte_unmap_unlock(ptep, ptl); return NULL; } page = vm_normal_page(vma, address, pte); if (!page && pte_devmap(pte) && (flags & FOLL_GET)) { pgmap = get_dev_pagemap(pte_pfn(pte), NULL); if (pgmap) page = pte_page(pte); else goto no_page; } else if (unlikely(!page)) { if (flags & FOLL_DUMP) { page = ERR_PTR(-EFAULT); goto out; } if (is_zero_pfn(pte_pfn(pte))) { page = pte_page(pte); } else { int ret; ret = follow_pfn_pte(vma, address, ptep, flags); page = ERR_PTR(ret); goto out; } } if (flags & FOLL_SPLIT && PageTransCompound(page)) { int ret; get_page(page); pte_unmap_unlock(ptep, ptl); lock_page(page); ret = split_huge_page(page); unlock_page(page); put_page(page); if (ret) return ERR_PTR(ret); goto retry; } if (flags & FOLL_GET) { get_page(page); if (pgmap) { put_dev_pagemap(pgmap); pgmap = NULL; } } if (flags & FOLL_TOUCH) { if ((flags & FOLL_WRITE) && !pte_dirty(pte) && !PageDirty(page)) set_page_dirty(page); mark_page_accessed(page); } if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) { if (PageTransCompound(page)) goto out; if (page->mapping && trylock_page(page)) { lru_add_drain(); mlock_vma_page(page); unlock_page(page); } } out: pte_unmap_unlock(ptep, ptl); return page; no_page: pte_unmap_unlock(ptep, ptl); if (!pte_none(pte)) return NULL; return no_page_table(vma, flags); }"
285,3623----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/user_namespace.c----new_idmap_permitted,"<S2SV_StartVul> static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid, <S2SV_EndVul> struct uid_gid_map *new_map) { if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) { u32 id = new_map->extent[0].lower_first; if (cap_setid == CAP_SETUID) { kuid_t uid = make_kuid(ns->parent, id); if (uid_eq(uid, current_fsuid())) return true; } else if (cap_setid == CAP_SETGID) { kgid_t gid = make_kgid(ns->parent, id); if (gid_eq(gid, current_fsgid())) return true; } } if (!cap_valid(cap_setid)) return true; <S2SV_StartVul> if (ns_capable(ns->parent, cap_setid)) <S2SV_EndVul> return true; return false; }","- static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,
- if (ns_capable(ns->parent, cap_setid))
+ static bool new_idmap_permitted(const struct file *file,
+ struct user_namespace *ns, int cap_setid,
+ if (ns_capable(ns->parent, cap_setid) &&
+ file_ns_capable(file, ns->parent, cap_setid))","static bool new_idmap_permitted(const struct file *file, struct user_namespace *ns, int cap_setid, struct uid_gid_map *new_map) { if ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) { u32 id = new_map->extent[0].lower_first; if (cap_setid == CAP_SETUID) { kuid_t uid = make_kuid(ns->parent, id); if (uid_eq(uid, current_fsuid())) return true; } else if (cap_setid == CAP_SETGID) { kgid_t gid = make_kgid(ns->parent, id); if (gid_eq(gid, current_fsgid())) return true; } } if (!cap_valid(cap_setid)) return true; if (ns_capable(ns->parent, cap_setid) && file_ns_capable(file, ns->parent, cap_setid)) return true; return false; }"
286,6567----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/normal.c----nv_replace,"nv_replace(cmdarg_T *cap) { char_u *ptr; int had_ctrl_v; long n; if (checkclearop(cap->oap)) return; #ifdef FEAT_JOB_CHANNEL if (bt_prompt(curbuf) && !prompt_curpos_editable()) { clearopbeep(cap->oap); return; } #endif if (cap->nchar == Ctrl_V) { had_ctrl_v = Ctrl_V; cap->nchar = get_literal(FALSE); if (cap->nchar > DEL) had_ctrl_v = NUL; } else had_ctrl_v = NUL; if (IS_SPECIAL(cap->nchar)) { clearopbeep(cap->oap); return; } if (VIsual_active) { if (got_int) reset_VIsual(); if (had_ctrl_v) { if (cap->nchar == CAR) cap->nchar = REPLACE_CR_NCHAR; else if (cap->nchar == NL) cap->nchar = REPLACE_NL_NCHAR; } nv_operator(cap); return; } if (virtual_active()) { if (u_save_cursor() == FAIL) return; if (gchar_cursor() == NUL) { coladvance_force((colnr_T)(getviscol() + cap->count1)); curwin->w_cursor.col -= cap->count1; } else if (gchar_cursor() == TAB) coladvance_force(getviscol()); } ptr = ml_get_cursor(); if (STRLEN(ptr) < (unsigned)cap->count1 || (has_mbyte && mb_charlen(ptr) < cap->count1)) { clearopbeep(cap->oap); return; } if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta)) { stuffnumReadbuff(cap->count1); stuffcharReadbuff('R'); stuffcharReadbuff('\t'); stuffcharReadbuff(ESC); return; } if (u_save_cursor() == FAIL) return; if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n')) { (void)del_chars(cap->count1, FALSE); stuffcharReadbuff('\r'); stuffcharReadbuff(ESC); invoke_edit(cap, TRUE, 'r', FALSE); } else { prep_redo(cap->oap->regname, cap->count1, NUL, 'r', NUL, had_ctrl_v, cap->nchar); curbuf->b_op_start = curwin->w_cursor; if (has_mbyte) { int old_State = State; if (cap->ncharC1 != 0) AppendCharToRedobuff(cap->ncharC1); if (cap->ncharC2 != 0) AppendCharToRedobuff(cap->ncharC2); for (n = cap->count1; n > 0; --n) { State = REPLACE; if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ins_char(c); else ++curwin->w_cursor.col; } else ins_char(cap->nchar); State = old_State; if (cap->ncharC1 != 0) ins_char(cap->ncharC1); if (cap->ncharC2 != 0) ins_char(cap->ncharC2); } } else { for (n = cap->count1; n > 0; --n) { <S2SV_StartVul> ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE); <S2SV_EndVul> if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ptr[curwin->w_cursor.col] = c; } else ptr[curwin->w_cursor.col] = cap->nchar; if (p_sm && msg_silent == 0) showmatch(cap->nchar); ++curwin->w_cursor.col; } #ifdef FEAT_NETBEANS_INTG if (netbeans_active()) { colnr_T start = (colnr_T)(curwin->w_cursor.col - cap->count1); netbeans_removed(curbuf, curwin->w_cursor.lnum, start, (long)cap->count1); netbeans_inserted(curbuf, curwin->w_cursor.lnum, start, &ptr[start], (int)cap->count1); } #endif changed_bytes(curwin->w_cursor.lnum, (colnr_T)(curwin->w_cursor.col - cap->count1)); } --curwin->w_cursor.col; if (has_mbyte) mb_adjust_cursor(); curbuf->b_op_end = curwin->w_cursor; curwin->w_set_curswant = TRUE; set_last_insert(cap->nchar); } }","- ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
+ ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
+ {
+ ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
+ }","nv_replace(cmdarg_T *cap) { char_u *ptr; int had_ctrl_v; long n; if (checkclearop(cap->oap)) return; #ifdef FEAT_JOB_CHANNEL if (bt_prompt(curbuf) && !prompt_curpos_editable()) { clearopbeep(cap->oap); return; } #endif if (cap->nchar == Ctrl_V) { had_ctrl_v = Ctrl_V; cap->nchar = get_literal(FALSE); if (cap->nchar > DEL) had_ctrl_v = NUL; } else had_ctrl_v = NUL; if (IS_SPECIAL(cap->nchar)) { clearopbeep(cap->oap); return; } if (VIsual_active) { if (got_int) reset_VIsual(); if (had_ctrl_v) { if (cap->nchar == CAR) cap->nchar = REPLACE_CR_NCHAR; else if (cap->nchar == NL) cap->nchar = REPLACE_NL_NCHAR; } nv_operator(cap); return; } if (virtual_active()) { if (u_save_cursor() == FAIL) return; if (gchar_cursor() == NUL) { coladvance_force((colnr_T)(getviscol() + cap->count1)); curwin->w_cursor.col -= cap->count1; } else if (gchar_cursor() == TAB) coladvance_force(getviscol()); } ptr = ml_get_cursor(); if (STRLEN(ptr) < (unsigned)cap->count1 || (has_mbyte && mb_charlen(ptr) < cap->count1)) { clearopbeep(cap->oap); return; } if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta)) { stuffnumReadbuff(cap->count1); stuffcharReadbuff('R'); stuffcharReadbuff('\t'); stuffcharReadbuff(ESC); return; } if (u_save_cursor() == FAIL) return; if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n')) { (void)del_chars(cap->count1, FALSE); stuffcharReadbuff('\r'); stuffcharReadbuff(ESC); invoke_edit(cap, TRUE, 'r', FALSE); } else { prep_redo(cap->oap->regname, cap->count1, NUL, 'r', NUL, had_ctrl_v, cap->nchar); curbuf->b_op_start = curwin->w_cursor; if (has_mbyte) { int old_State = State; if (cap->ncharC1 != 0) AppendCharToRedobuff(cap->ncharC1); if (cap->ncharC2 != 0) AppendCharToRedobuff(cap->ncharC2); for (n = cap->count1; n > 0; --n) { State = REPLACE; if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ins_char(c); else ++curwin->w_cursor.col; } else ins_char(cap->nchar); State = old_State; if (cap->ncharC1 != 0) ins_char(cap->ncharC1); if (cap->ncharC2 != 0) ins_char(cap->ncharC2); } } else { for (n = cap->count1; n > 0; --n) { if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE); if (c != NUL) ptr[curwin->w_cursor.col] = c; } else { ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE); ptr[curwin->w_cursor.col] = cap->nchar; } if (p_sm && msg_silent == 0) showmatch(cap->nchar); ++curwin->w_cursor.col; } #ifdef FEAT_NETBEANS_INTG if (netbeans_active()) { colnr_T start = (colnr_T)(curwin->w_cursor.col - cap->count1); netbeans_removed(curbuf, curwin->w_cursor.lnum, start, (long)cap->count1); netbeans_inserted(curbuf, curwin->w_cursor.lnum, start, &ptr[start], (int)cap->count1); } #endif changed_bytes(curwin->w_cursor.lnum, (colnr_T)(curwin->w_cursor.col - cap->count1)); } --curwin->w_cursor.col; if (has_mbyte) mb_adjust_cursor(); curbuf->b_op_end = curwin->w_cursor; curwin->w_set_curswant = TRUE; set_last_insert(cap->nchar); } }"
287,4011----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/amqp_connection.c----amqp_handle_input,"int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data, amqp_frame_t *decoded_frame) { size_t bytes_consumed; void *raw_frame; decoded_frame->frame_type = 0; if (received_data.len == 0) { return AMQP_STATUS_OK; } if (state->state == CONNECTION_STATE_IDLE) { state->state = CONNECTION_STATE_HEADER; } bytes_consumed = consume_data(state, &received_data); if (state->inbound_offset < state->target_size) { return (int)bytes_consumed; } raw_frame = state->inbound_buffer.bytes; switch (state->state) { case CONNECTION_STATE_INITIAL: if (memcmp(raw_frame, ""AMQP"", 4) == 0) { decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER; decoded_frame->channel = 0; decoded_frame->payload.protocol_header.transport_high = amqp_d8(amqp_offset(raw_frame, 4)); decoded_frame->payload.protocol_header.transport_low = amqp_d8(amqp_offset(raw_frame, 5)); decoded_frame->payload.protocol_header.protocol_version_major = amqp_d8(amqp_offset(raw_frame, 6)); decoded_frame->payload.protocol_header.protocol_version_minor = amqp_d8(amqp_offset(raw_frame, 7)); return_to_idle(state); return (int)bytes_consumed; } case CONNECTION_STATE_HEADER: { amqp_channel_t channel; amqp_pool_t *channel_pool; channel = amqp_d16(amqp_offset(raw_frame, 1)); <S2SV_StartVul> state->target_size = <S2SV_EndVul> <S2SV_StartVul> amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE; <S2SV_EndVul> if ((size_t)state->frame_max < state->target_size) { return AMQP_STATUS_BAD_AMQP_DATA; } channel_pool = amqp_get_or_create_channel_pool(state, channel); if (NULL == channel_pool) { return AMQP_STATUS_NO_MEMORY; } amqp_pool_alloc_bytes(channel_pool, state->target_size, &state->inbound_buffer); if (NULL == state->inbound_buffer.bytes) { return AMQP_STATUS_NO_MEMORY; } memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE); raw_frame = state->inbound_buffer.bytes; state->state = CONNECTION_STATE_BODY; bytes_consumed += consume_data(state, &received_data); if (state->inbound_offset < state->target_size) { return (int)bytes_consumed; } } case CONNECTION_STATE_BODY: { amqp_bytes_t encoded; int res; amqp_pool_t *channel_pool; if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) != AMQP_FRAME_END) { return AMQP_STATUS_BAD_AMQP_DATA; } decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0)); decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1)); channel_pool = amqp_get_or_create_channel_pool(state, decoded_frame->channel); if (NULL == channel_pool) { return AMQP_STATUS_NO_MEMORY; } switch (decoded_frame->frame_type) { case AMQP_FRAME_METHOD: decoded_frame->payload.method.id = amqp_d32(amqp_offset(raw_frame, HEADER_SIZE)); encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4); encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE; res = amqp_decode_method(decoded_frame->payload.method.id, channel_pool, encoded, &decoded_frame->payload.method.decoded); if (res < 0) { return res; } break; case AMQP_FRAME_HEADER: decoded_frame->payload.properties.class_id = amqp_d16(amqp_offset(raw_frame, HEADER_SIZE)); decoded_frame->payload.properties.body_size = amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4)); encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12); encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE; decoded_frame->payload.properties.raw = encoded; res = amqp_decode_properties( decoded_frame->payload.properties.class_id, channel_pool, encoded, &decoded_frame->payload.properties.decoded); if (res < 0) { return res; } break; case AMQP_FRAME_BODY: decoded_frame->payload.body_fragment.len = state->target_size - HEADER_SIZE - FOOTER_SIZE; decoded_frame->payload.body_fragment.bytes = amqp_offset(raw_frame, HEADER_SIZE); break; case AMQP_FRAME_HEARTBEAT: break; default: decoded_frame->frame_type = 0; break; } return_to_idle(state); return (int)bytes_consumed; } default: amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"", state->state); } }","- state->target_size =
- amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE;
+ uint32_t frame_size;
+ frame_size = amqp_d32(amqp_offset(raw_frame, 3));
+ if (frame_size >= INT32_MAX) {
+ return AMQP_STATUS_BAD_AMQP_DATA;
+ }
+ state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE;","int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data, amqp_frame_t *decoded_frame) { size_t bytes_consumed; void *raw_frame; decoded_frame->frame_type = 0; if (received_data.len == 0) { return AMQP_STATUS_OK; } if (state->state == CONNECTION_STATE_IDLE) { state->state = CONNECTION_STATE_HEADER; } bytes_consumed = consume_data(state, &received_data); if (state->inbound_offset < state->target_size) { return (int)bytes_consumed; } raw_frame = state->inbound_buffer.bytes; switch (state->state) { case CONNECTION_STATE_INITIAL: if (memcmp(raw_frame, ""AMQP"", 4) == 0) { decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER; decoded_frame->channel = 0; decoded_frame->payload.protocol_header.transport_high = amqp_d8(amqp_offset(raw_frame, 4)); decoded_frame->payload.protocol_header.transport_low = amqp_d8(amqp_offset(raw_frame, 5)); decoded_frame->payload.protocol_header.protocol_version_major = amqp_d8(amqp_offset(raw_frame, 6)); decoded_frame->payload.protocol_header.protocol_version_minor = amqp_d8(amqp_offset(raw_frame, 7)); return_to_idle(state); return (int)bytes_consumed; } case CONNECTION_STATE_HEADER: { amqp_channel_t channel; amqp_pool_t *channel_pool; uint32_t frame_size; channel = amqp_d16(amqp_offset(raw_frame, 1)); frame_size = amqp_d32(amqp_offset(raw_frame, 3)); if (frame_size >= INT32_MAX) { return AMQP_STATUS_BAD_AMQP_DATA; } state->target_size = frame_size + HEADER_SIZE + FOOTER_SIZE; if ((size_t)state->frame_max < state->target_size) { return AMQP_STATUS_BAD_AMQP_DATA; } channel_pool = amqp_get_or_create_channel_pool(state, channel); if (NULL == channel_pool) { return AMQP_STATUS_NO_MEMORY; } amqp_pool_alloc_bytes(channel_pool, state->target_size, &state->inbound_buffer); if (NULL == state->inbound_buffer.bytes) { return AMQP_STATUS_NO_MEMORY; } memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE); raw_frame = state->inbound_buffer.bytes; state->state = CONNECTION_STATE_BODY; bytes_consumed += consume_data(state, &received_data); if (state->inbound_offset < state->target_size) { return (int)bytes_consumed; } } case CONNECTION_STATE_BODY: { amqp_bytes_t encoded; int res; amqp_pool_t *channel_pool; if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) != AMQP_FRAME_END) { return AMQP_STATUS_BAD_AMQP_DATA; } decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0)); decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1)); channel_pool = amqp_get_or_create_channel_pool(state, decoded_frame->channel); if (NULL == channel_pool) { return AMQP_STATUS_NO_MEMORY; } switch (decoded_frame->frame_type) { case AMQP_FRAME_METHOD: decoded_frame->payload.method.id = amqp_d32(amqp_offset(raw_frame, HEADER_SIZE)); encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4); encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE; res = amqp_decode_method(decoded_frame->payload.method.id, channel_pool, encoded, &decoded_frame->payload.method.decoded); if (res < 0) { return res; } break; case AMQP_FRAME_HEADER: decoded_frame->payload.properties.class_id = amqp_d16(amqp_offset(raw_frame, HEADER_SIZE)); decoded_frame->payload.properties.body_size = amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4)); encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12); encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE; decoded_frame->payload.properties.raw = encoded; res = amqp_decode_properties( decoded_frame->payload.properties.class_id, channel_pool, encoded, &decoded_frame->payload.properties.decoded); if (res < 0) { return res; } break; case AMQP_FRAME_BODY: decoded_frame->payload.body_fragment.len = state->target_size - HEADER_SIZE - FOOTER_SIZE; decoded_frame->payload.body_fragment.bytes = amqp_offset(raw_frame, HEADER_SIZE); break; case AMQP_FRAME_HEARTBEAT: break; default: decoded_frame->frame_type = 0; break; } return_to_idle(state); return (int)bytes_consumed; } default: amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"", state->state); } }"
288,861----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-1335--conf.c----mount_entry_on_relative_rootfs,"static int mount_entry_on_relative_rootfs(struct mntent *mntent, const char *rootfs) { char path[MAXPATHLEN]; int ret; ret = snprintf(path, sizeof(path), ""%s/%s"", rootfs, mntent->mnt_dir); if (ret >= sizeof(path)) { ERROR(""path name too long""); return -1; } <S2SV_StartVul> return mount_entry_on_generic(mntent, path); <S2SV_EndVul> }","- return mount_entry_on_generic(mntent, path);
+ return mount_entry_on_generic(mntent, path, rootfs);","static int mount_entry_on_relative_rootfs(struct mntent *mntent, const char *rootfs) { char path[MAXPATHLEN]; int ret; ret = snprintf(path, sizeof(path), ""%s/%s"", rootfs, mntent->mnt_dir); if (ret >= sizeof(path)) { ERROR(""path name too long""); return -1; } return mount_entry_on_generic(mntent, path, rootfs); }"
289,2988----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dm9000_driver.c----dm9000ReceivePacket,"error_t dm9000ReceivePacket(NetInterface *interface) { error_t error; size_t i; size_t n; size_t length; volatile uint8_t status; volatile uint16_t data; Dm9000Context *context; context = (Dm9000Context *) interface->nicContext; <S2SV_StartVul> data = dm9000ReadReg(DM9000_REG_MRCMDX); <S2SV_EndVul> <S2SV_StartVul> DM9000_INDEX_REG = DM9000_REG_MRCMDX1; <S2SV_EndVul> status = LSB(DM9000_DATA_REG); if(status == 0x01) { <S2SV_StartVul> DM9000_INDEX_REG = DM9000_REG_MRCMD; <S2SV_EndVul> status = MSB(DM9000_DATA_REG); length = DM9000_DATA_REG; n = MIN(length, ETH_MAX_FRAME_SIZE); i = 0; <S2SV_StartVul> if((status & (RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE)) == 0) <S2SV_EndVul> { while((i + 1) < n) { data = DM9000_DATA_REG; context->rxBuffer[i++] = LSB(data); context->rxBuffer[i++] = MSB(data); } if((i + 1) == n) { data = DM9000_DATA_REG; context->rxBuffer[i] = LSB(data); i += 2; } error = NO_ERROR; } else { error = ERROR_INVALID_PACKET; } while(i < length) { data = DM9000_DATA_REG; i += 2; } } else { error = ERROR_BUFFER_EMPTY; } if(!error) { NetRxAncillary ancillary; ancillary = NET_DEFAULT_RX_ANCILLARY; nicProcessPacket(interface, context->rxBuffer, n, &ancillary); } return error; }","- data = dm9000ReadReg(DM9000_REG_MRCMDX);
- DM9000_INDEX_REG = DM9000_REG_MRCMDX1;
- DM9000_INDEX_REG = DM9000_REG_MRCMD;
- if((status & (RSR_LCS | RSR_RWTO | RSR_PLE | RSR_AE | RSR_CE | RSR_FOE)) == 0)
+ data = dm9000ReadReg(DM9000_MRCMDX);
+ DM9000_INDEX_REG = DM9000_MRCMDX1;
+ DM9000_INDEX_REG = DM9000_MRCMD;
+ if((status & (DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE |
+ DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE)) == 0)","error_t dm9000ReceivePacket(NetInterface *interface) { error_t error; size_t i; size_t n; size_t length; volatile uint8_t status; volatile uint16_t data; Dm9000Context *context; context = (Dm9000Context *) interface->nicContext; data = dm9000ReadReg(DM9000_MRCMDX); DM9000_INDEX_REG = DM9000_MRCMDX1; status = LSB(DM9000_DATA_REG); if(status == 0x01) { DM9000_INDEX_REG = DM9000_MRCMD; status = MSB(DM9000_DATA_REG); length = DM9000_DATA_REG; n = MIN(length, ETH_MAX_FRAME_SIZE); i = 0; if((status & (DM9000_RSR_LCS | DM9000_RSR_RWTO | DM9000_RSR_PLE | DM9000_RSR_AE | DM9000_RSR_CE | DM9000_RSR_FOE)) == 0) { while((i + 1) < n) { data = DM9000_DATA_REG; context->rxBuffer[i++] = LSB(data); context->rxBuffer[i++] = MSB(data); } if((i + 1) == n) { data = DM9000_DATA_REG; context->rxBuffer[i] = LSB(data); i += 2; } error = NO_ERROR; } else { error = ERROR_INVALID_PACKET; } while(i < length) { data = DM9000_DATA_REG; i += 2; } } else { error = ERROR_BUFFER_EMPTY; } if(!error) { NetRxAncillary ancillary; ancillary = NET_DEFAULT_RX_ANCILLARY; nicProcessPacket(interface, context->rxBuffer, n, &ancillary); } return error; }"
290,552----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-0216--netback.c----netbk_set_skb_gso,"static int netbk_set_skb_gso(struct xenvif *vif, struct sk_buff *skb, struct xen_netif_extra_info *gso) { if (!gso->u.gso.size) { <S2SV_StartVul> netdev_dbg(vif->dev, ""GSO size must not be zero.\n""); <S2SV_EndVul> return -EINVAL; } if (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) { <S2SV_StartVul> netdev_dbg(vif->dev, ""Bad GSO type %d.\n"", gso->u.gso.type); <S2SV_EndVul> return -EINVAL; } skb_shinfo(skb)->gso_size = gso->u.gso.size; skb_shinfo(skb)->gso_type = SKB_GSO_TCPV4; skb_shinfo(skb)->gso_type |= SKB_GSO_DODGY; skb_shinfo(skb)->gso_segs = 0; return 0; }","- netdev_dbg(vif->dev, ""GSO size must not be zero.\n"");
- netdev_dbg(vif->dev, ""Bad GSO type %d.\n"", gso->u.gso.type);
+ netdev_err(vif->dev, ""GSO size must not be zero.\n"");
+ netbk_fatal_tx_err(vif);
+ netdev_err(vif->dev, ""Bad GSO type %d.\n"", gso->u.gso.type);
+ netbk_fatal_tx_err(vif);","static int netbk_set_skb_gso(struct xenvif *vif, struct sk_buff *skb, struct xen_netif_extra_info *gso) { if (!gso->u.gso.size) { netdev_err(vif->dev, ""GSO size must not be zero.\n""); netbk_fatal_tx_err(vif); return -EINVAL; } if (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) { netdev_err(vif->dev, ""Bad GSO type %d.\n"", gso->u.gso.type); netbk_fatal_tx_err(vif); return -EINVAL; } skb_shinfo(skb)->gso_size = gso->u.gso.size; skb_shinfo(skb)->gso_type = SKB_GSO_TCPV4; skb_shinfo(skb)->gso_type |= SKB_GSO_DODGY; skb_shinfo(skb)->gso_segs = 0; return 0; }"
291,386----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-7016--jpeg2000dec.c----get_siz,"static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) return AVERROR_INVALIDDATA; s->avctx->profile = bytestream2_get_be16u(&s->g); s->width = bytestream2_get_be32u(&s->g); s->height = bytestream2_get_be32u(&s->g); s->image_offset_x = bytestream2_get_be32u(&s->g); s->image_offset_y = bytestream2_get_be32u(&s->g); s->tile_width = bytestream2_get_be32u(&s->g); s->tile_height = bytestream2_get_be32u(&s->g); s->tile_offset_x = bytestream2_get_be32u(&s->g); s->tile_offset_y = bytestream2_get_be32u(&s->g); ncomponents = bytestream2_get_be16u(&s->g); if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"", s->ncomponents); return AVERROR_INVALIDDATA; } if (ncomponents > 4) { avpriv_request_sample(s->avctx, ""Support for %d components"", s->ncomponents); return AVERROR_PATCHWELCOME; } s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"", s->tile_width, s->tile_height); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) return AVERROR_INVALIDDATA; for (i = 0; i < s->ncomponents; i++) { uint8_t x = bytestream2_get_byteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2_get_byteu(&s->g); s->cdy[i] = bytestream2_get_byteu(&s->g); <S2SV_StartVul> if (!s->cdx[i] || !s->cdy[i]) { <S2SV_EndVul> av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample seperation\n""); return AVERROR_INVALIDDATA; } log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; } s->numXtiles = ff_jpeg2000_ceildiv(s->width - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); } s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); } for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); } s->avctx->width = ff_jpeg2000_ceildivpow2(s->width - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; } } for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; } } if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) { av_log(s->avctx, AV_LOG_ERROR, ""Unknown pix_fmt, profile: %d, colour_space: %d, "" ""components: %d, precision: %d, "" ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"", s->avctx->profile, s->colour_space, ncomponents, s->precision, ncomponents > 2 ? s->cdx[1] : 0, ncomponents > 2 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0); } return 0; }","- if (!s->cdx[i] || !s->cdy[i]) {
+ if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
+ || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {","static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) return AVERROR_INVALIDDATA; s->avctx->profile = bytestream2_get_be16u(&s->g); s->width = bytestream2_get_be32u(&s->g); s->height = bytestream2_get_be32u(&s->g); s->image_offset_x = bytestream2_get_be32u(&s->g); s->image_offset_y = bytestream2_get_be32u(&s->g); s->tile_width = bytestream2_get_be32u(&s->g); s->tile_height = bytestream2_get_be32u(&s->g); s->tile_offset_x = bytestream2_get_be32u(&s->g); s->tile_offset_y = bytestream2_get_be32u(&s->g); ncomponents = bytestream2_get_be16u(&s->g); if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"", s->ncomponents); return AVERROR_INVALIDDATA; } if (ncomponents > 4) { avpriv_request_sample(s->avctx, ""Support for %d components"", s->ncomponents); return AVERROR_PATCHWELCOME; } s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"", s->tile_width, s->tile_height); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) return AVERROR_INVALIDDATA; for (i = 0; i < s->ncomponents; i++) { uint8_t x = bytestream2_get_byteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2_get_byteu(&s->g); s->cdy[i] = bytestream2_get_byteu(&s->g); if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample seperation\n""); return AVERROR_INVALIDDATA; } log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; } s->numXtiles = ff_jpeg2000_ceildiv(s->width - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); } s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); } for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); } s->avctx->width = ff_jpeg2000_ceildivpow2(s->width - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; } } for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; } } if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) { av_log(s->avctx, AV_LOG_ERROR, ""Unknown pix_fmt, profile: %d, colour_space: %d, "" ""components: %d, precision: %d, "" ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"", s->avctx->profile, s->colour_space, ncomponents, s->precision, ncomponents > 2 ? s->cdx[1] : 0, ncomponents > 2 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0); } return 0; }"
292,2986----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dm9000_driver.c----dm9000IrqHandler,"bool_t dm9000IrqHandler(NetInterface *interface) { bool_t flag; uint8_t status; uint8_t mask; Dm9000Context *context; flag = FALSE; context = (Dm9000Context *) interface->nicContext; <S2SV_StartVul> status = dm9000ReadReg(DM9000_REG_ISR); <S2SV_EndVul> <S2SV_StartVul> if((status & ISR_LNKCHG) != 0) <S2SV_EndVul> { <S2SV_StartVul> mask = dm9000ReadReg(DM9000_REG_IMR); <S2SV_EndVul> <S2SV_StartVul> dm9000WriteReg(DM9000_REG_IMR, mask & ~IMR_LNKCHGI); <S2SV_EndVul> interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } <S2SV_StartVul> if((status & ISR_PT) != 0) <S2SV_EndVul> { <S2SV_StartVul> if(dm9000ReadReg(DM9000_REG_NSR) & (NSR_TX2END | NSR_TX1END)) <S2SV_EndVul> { if(context->queuedPackets > 0) { context->queuedPackets--; } flag |= osSetEventFromIsr(&interface->nicTxEvent); } <S2SV_StartVul> dm9000WriteReg(DM9000_REG_ISR, ISR_PT); <S2SV_EndVul> } <S2SV_StartVul> if((status & ISR_PR) != 0) <S2SV_EndVul> { <S2SV_StartVul> mask = dm9000ReadReg(DM9000_REG_IMR); <S2SV_EndVul> <S2SV_StartVul> dm9000WriteReg(DM9000_REG_IMR, mask & ~IMR_PRI); <S2SV_EndVul> interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } return flag; }","- status = dm9000ReadReg(DM9000_REG_ISR);
- if((status & ISR_LNKCHG) != 0)
- mask = dm9000ReadReg(DM9000_REG_IMR);
- dm9000WriteReg(DM9000_REG_IMR, mask & ~IMR_LNKCHGI);
- if((status & ISR_PT) != 0)
- if(dm9000ReadReg(DM9000_REG_NSR) & (NSR_TX2END | NSR_TX1END))
- dm9000WriteReg(DM9000_REG_ISR, ISR_PT);
- if((status & ISR_PR) != 0)
- mask = dm9000ReadReg(DM9000_REG_IMR);
- dm9000WriteReg(DM9000_REG_IMR, mask & ~IMR_PRI);
+ status = dm9000ReadReg(DM9000_ISR);
+ if((status & DM9000_ISR_LNKCHG) != 0)
+ mask = dm9000ReadReg(DM9000_IMR);
+ dm9000WriteReg(DM9000_IMR, mask & ~DM9000_IMR_LNKCHGI);
+ if((status & DM9000_ISR_PT) != 0)
+ if((dm9000ReadReg(DM9000_NSR) & (DM9000_NSR_TX2END | DM9000_NSR_TX1END)) != 0)
+ dm9000WriteReg(DM9000_ISR, DM9000_ISR_PT);
+ if((status & DM9000_ISR_PR) != 0)
+ mask = dm9000ReadReg(DM9000_IMR);
+ dm9000WriteReg(DM9000_IMR, mask & ~DM9000_IMR_PRI);","bool_t dm9000IrqHandler(NetInterface *interface) { bool_t flag; uint8_t status; uint8_t mask; Dm9000Context *context; flag = FALSE; context = (Dm9000Context *) interface->nicContext; status = dm9000ReadReg(DM9000_ISR); if((status & DM9000_ISR_LNKCHG) != 0) { mask = dm9000ReadReg(DM9000_IMR); dm9000WriteReg(DM9000_IMR, mask & ~DM9000_IMR_LNKCHGI); interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } if((status & DM9000_ISR_PT) != 0) { if((dm9000ReadReg(DM9000_NSR) & (DM9000_NSR_TX2END | DM9000_NSR_TX1END)) != 0) { if(context->queuedPackets > 0) { context->queuedPackets--; } flag |= osSetEventFromIsr(&interface->nicTxEvent); } dm9000WriteReg(DM9000_ISR, DM9000_ISR_PT); } if((status & DM9000_ISR_PR) != 0) { mask = dm9000ReadReg(DM9000_IMR); dm9000WriteReg(DM9000_IMR, mask & ~DM9000_IMR_PRI); interface->nicEvent = TRUE; flag |= osSetEventFromIsr(&netEvent); } return flag; }"
293,6618----CWE-200----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/linenoise.cpp----linenoiseHistorySave,"int linenoiseHistorySave(const char* filename) { <S2SV_StartVul> FILE* fp = fopen(filename, ""wt""); <S2SV_EndVul> if (fp == NULL) { return -1; } for (int j = 0; j < historyLen; ++j) { if (history[j][0] != '\0') { fprintf(fp, ""%s\n"", history[j]); } } <S2SV_StartVul> fclose(fp); <S2SV_EndVul> return 0; }","- FILE* fp = fopen(filename, ""wt"");
- fclose(fp);
+ FILE* fp;
+ #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE
+ int fd = open(filename, O_CREAT, S_IRUSR | S_IWUSR);
+ if (fd == -1) {
+ return -1;
+ }
+ fp = fdopen(fd, ""wt"");
+ #else
+ fp = fopen(filename, ""wt"");
+ #endif // _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE
+ fclose(fp); // Also causes fd to be closed.","int linenoiseHistorySave(const char* filename) { FILE* fp; #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE int fd = open(filename, O_CREAT, S_IRUSR | S_IWUSR); if (fd == -1) { return -1; } fp = fdopen(fd, ""wt""); #else fp = fopen(filename, ""wt""); #endif if (fp == NULL) { return -1; } for (int j = 0; j < historyLen; ++j) { if (history[j][0] != '\0') { fprintf(fp, ""%s\n"", history[j]); } } fclose(fp); return 0; }"
294,3603----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sm_statefuns.c----sctp_sf_do_asconf,"sctp_disposition_t sctp_sf_do_asconf(struct net *net, const struct sctp_endpoint *ep, const struct sctp_association *asoc, const sctp_subtype_t type, void *arg, sctp_cmd_seq_t *commands) { struct sctp_chunk *chunk = arg; struct sctp_chunk *asconf_ack = NULL; struct sctp_paramhdr *err_param = NULL; sctp_addiphdr_t *hdr; <S2SV_StartVul> union sctp_addr_param *addr_param; <S2SV_EndVul> __u32 serial; <S2SV_StartVul> int length; <S2SV_EndVul> if (!sctp_vtag_verify(chunk, asoc)) { sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG, SCTP_NULL()); return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands); } if (!net->sctp.addip_noauth && !chunk->auth) return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands); if (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t))) return sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands); hdr = (sctp_addiphdr_t *)chunk->skb->data; serial = ntohl(hdr->serial); <S2SV_StartVul> addr_param = (union sctp_addr_param *)hdr->params; <S2SV_EndVul> <S2SV_StartVul> length = ntohs(addr_param->p.length); <S2SV_EndVul> <S2SV_StartVul> if (length < sizeof(sctp_paramhdr_t)) <S2SV_EndVul> <S2SV_StartVul> return sctp_sf_violation_paramlen(net, ep, asoc, type, arg, <S2SV_EndVul> <S2SV_StartVul> (void *)addr_param, commands); <S2SV_EndVul> <S2SV_StartVul> if (!sctp_verify_asconf(asoc, <S2SV_EndVul> <S2SV_StartVul> (sctp_paramhdr_t *)((void *)addr_param + length), <S2SV_EndVul> <S2SV_StartVul> (void *)chunk->chunk_end, <S2SV_EndVul> <S2SV_StartVul> &err_param)) <S2SV_EndVul> return sctp_sf_violation_paramlen(net, ep, asoc, type, arg, (void *)err_param, commands); if (serial == asoc->peer.addip_serial + 1) { if (!chunk->has_asconf) sctp_assoc_clean_asconf_ack_cache(asoc); asconf_ack = sctp_process_asconf((struct sctp_association *) asoc, chunk); if (!asconf_ack) return SCTP_DISPOSITION_NOMEM; } else if (serial < asoc->peer.addip_serial + 1) { asconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial); if (!asconf_ack) return SCTP_DISPOSITION_DISCARD; asconf_ack->transport = NULL; } else { return SCTP_DISPOSITION_DISCARD; } asconf_ack->dest = chunk->source; sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack)); if (asoc->new_transport) { sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands); ((struct sctp_association *)asoc)->new_transport = NULL; } return SCTP_DISPOSITION_CONSUME; }","- union sctp_addr_param *addr_param;
- int length;
- addr_param = (union sctp_addr_param *)hdr->params;
- length = ntohs(addr_param->p.length);
- if (length < sizeof(sctp_paramhdr_t))
- return sctp_sf_violation_paramlen(net, ep, asoc, type, arg,
- (void *)addr_param, commands);
- if (!sctp_verify_asconf(asoc,
- (sctp_paramhdr_t *)((void *)addr_param + length),
- (void *)chunk->chunk_end,
- &err_param))
+ if (!sctp_verify_asconf(asoc, chunk, true, &err_param))","sctp_disposition_t sctp_sf_do_asconf(struct net *net, const struct sctp_endpoint *ep, const struct sctp_association *asoc, const sctp_subtype_t type, void *arg, sctp_cmd_seq_t *commands) { struct sctp_chunk *chunk = arg; struct sctp_chunk *asconf_ack = NULL; struct sctp_paramhdr *err_param = NULL; sctp_addiphdr_t *hdr; __u32 serial; if (!sctp_vtag_verify(chunk, asoc)) { sctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG, SCTP_NULL()); return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands); } if (!net->sctp.addip_noauth && !chunk->auth) return sctp_sf_discard_chunk(net, ep, asoc, type, arg, commands); if (!sctp_chunk_length_valid(chunk, sizeof(sctp_addip_chunk_t))) return sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands); hdr = (sctp_addiphdr_t *)chunk->skb->data; serial = ntohl(hdr->serial); if (!sctp_verify_asconf(asoc, chunk, true, &err_param)) return sctp_sf_violation_paramlen(net, ep, asoc, type, arg, (void *)err_param, commands); if (serial == asoc->peer.addip_serial + 1) { if (!chunk->has_asconf) sctp_assoc_clean_asconf_ack_cache(asoc); asconf_ack = sctp_process_asconf((struct sctp_association *) asoc, chunk); if (!asconf_ack) return SCTP_DISPOSITION_NOMEM; } else if (serial < asoc->peer.addip_serial + 1) { asconf_ack = sctp_assoc_lookup_asconf_ack(asoc, hdr->serial); if (!asconf_ack) return SCTP_DISPOSITION_DISCARD; asconf_ack->transport = NULL; } else { return SCTP_DISPOSITION_DISCARD; } asconf_ack->dest = chunk->source; sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(asconf_ack)); if (asoc->new_transport) { sctp_sf_heartbeat(ep, asoc, type, asoc->new_transport, commands); ((struct sctp_association *)asoc)->new_transport = NULL; } return SCTP_DISPOSITION_CONSUME; }"
295,2152----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18222--hns_dsaf_gmac.c----hns_gmac_get_sset_count,static int hns_gmac_get_sset_count(int stringset) { <S2SV_StartVul> if (stringset == ETH_SS_STATS) <S2SV_EndVul> return ARRAY_SIZE(g_gmac_stats_string); return 0; },"- if (stringset == ETH_SS_STATS)
+ if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)",static int hns_gmac_get_sset_count(int stringset) { if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS) return ARRAY_SIZE(g_gmac_stats_string); return 0; }
296,4522----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mm.h----get_page,"static inline void get_page(struct page *page) { page = compound_head(page); <S2SV_StartVul> VM_BUG_ON_PAGE(page_ref_count(page) <= 0, page); <S2SV_EndVul> page_ref_inc(page); }","- VM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);
+ VM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page);","static inline void get_page(struct page *page) { page = compound_head(page); VM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page); page_ref_inc(page); }"
297,631----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-4655--control.c----snd_ctl_elem_add,"static int snd_ctl_elem_add(struct snd_ctl_file *file, struct snd_ctl_elem_info *info, int replace) { struct snd_card *card = file->card; struct snd_kcontrol kctl, *_kctl; unsigned int access; long private_size; struct user_element *ue; int idx, err; <S2SV_StartVul> if (!replace && card->user_ctl_count >= MAX_USER_CONTROLS) <S2SV_EndVul> <S2SV_StartVul> return -ENOMEM; <S2SV_EndVul> if (info->count < 1) return -EINVAL; access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : (info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE| SNDRV_CTL_ELEM_ACCESS_INACTIVE| SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE)); info->id.numid = 0; memset(&kctl, 0, sizeof(kctl)); <S2SV_StartVul> down_write(&card->controls_rwsem); <S2SV_EndVul> <S2SV_StartVul> _kctl = snd_ctl_find_id(card, &info->id); <S2SV_EndVul> <S2SV_StartVul> err = 0; <S2SV_EndVul> <S2SV_StartVul> if (_kctl) { <S2SV_EndVul> <S2SV_StartVul> if (replace) <S2SV_EndVul> <S2SV_StartVul> err = snd_ctl_remove(card, _kctl); <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> err = -EBUSY; <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> if (replace) <S2SV_EndVul> <S2SV_StartVul> err = -ENOENT; <S2SV_EndVul> } <S2SV_StartVul> up_write(&card->controls_rwsem); <S2SV_EndVul> <S2SV_StartVul> if (err < 0) <S2SV_EndVul> <S2SV_StartVul> return err; <S2SV_EndVul> memcpy(&kctl.id, &info->id, sizeof(info->id)); kctl.count = info->owner ? info->owner : 1; access |= SNDRV_CTL_ELEM_ACCESS_USER; if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) kctl.info = snd_ctl_elem_user_enum_info; else kctl.info = snd_ctl_elem_user_info; if (access & SNDRV_CTL_ELEM_ACCESS_READ) kctl.get = snd_ctl_elem_user_get; if (access & SNDRV_CTL_ELEM_ACCESS_WRITE) kctl.put = snd_ctl_elem_user_put; if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) { kctl.tlv.c = snd_ctl_elem_user_tlv; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK; } switch (info->type) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN: case SNDRV_CTL_ELEM_TYPE_INTEGER: private_size = sizeof(long); if (info->count > 128) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_INTEGER64: private_size = sizeof(long long); if (info->count > 64) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_ENUMERATED: private_size = sizeof(unsigned int); if (info->count > 128 || info->value.enumerated.items == 0) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_BYTES: private_size = sizeof(unsigned char); if (info->count > 512) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_IEC958: private_size = sizeof(struct snd_aes_iec958); if (info->count != 1) return -EINVAL; break; default: return -EINVAL; } private_size *= info->count; ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL); if (ue == NULL) return -ENOMEM; ue->card = card; ue->info = *info; ue->info.access = 0; ue->elem_data = (char *)ue + sizeof(*ue); ue->elem_data_size = private_size; if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) { err = snd_ctl_elem_init_enum_names(ue); if (err < 0) { kfree(ue); return err; } } kctl.private_free = snd_ctl_elem_user_free; _kctl = snd_ctl_new(&kctl, access); if (_kctl == NULL) { kfree(ue->priv_data); kfree(ue); return -ENOMEM; } _kctl->private_data = ue; for (idx = 0; idx < _kctl->count; idx++) _kctl->vd[idx].owner = file; err = snd_ctl_add(card, _kctl); if (err < 0) return err; down_write(&card->controls_rwsem); card->user_ctl_count++; up_write(&card->controls_rwsem); return 0; }","- if (!replace && card->user_ctl_count >= MAX_USER_CONTROLS)
- return -ENOMEM;
- down_write(&card->controls_rwsem);
- _kctl = snd_ctl_find_id(card, &info->id);
- err = 0;
- if (_kctl) {
- if (replace)
- err = snd_ctl_remove(card, _kctl);
- else
- err = -EBUSY;
- } else {
- if (replace)
- err = -ENOENT;
- up_write(&card->controls_rwsem);
- if (err < 0)
- return err;
+ if (replace) {
+ err = snd_ctl_remove_user_ctl(file, &info->id);
+ if (err)
+ return err;
+ if (card->user_ctl_count >= MAX_USER_CONTROLS)
+ return -ENOMEM;","static int snd_ctl_elem_add(struct snd_ctl_file *file, struct snd_ctl_elem_info *info, int replace) { struct snd_card *card = file->card; struct snd_kcontrol kctl, *_kctl; unsigned int access; long private_size; struct user_element *ue; int idx, err; if (info->count < 1) return -EINVAL; access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : (info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE| SNDRV_CTL_ELEM_ACCESS_INACTIVE| SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE)); info->id.numid = 0; memset(&kctl, 0, sizeof(kctl)); if (replace) { err = snd_ctl_remove_user_ctl(file, &info->id); if (err) return err; } if (card->user_ctl_count >= MAX_USER_CONTROLS) return -ENOMEM; memcpy(&kctl.id, &info->id, sizeof(info->id)); kctl.count = info->owner ? info->owner : 1; access |= SNDRV_CTL_ELEM_ACCESS_USER; if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) kctl.info = snd_ctl_elem_user_enum_info; else kctl.info = snd_ctl_elem_user_info; if (access & SNDRV_CTL_ELEM_ACCESS_READ) kctl.get = snd_ctl_elem_user_get; if (access & SNDRV_CTL_ELEM_ACCESS_WRITE) kctl.put = snd_ctl_elem_user_put; if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) { kctl.tlv.c = snd_ctl_elem_user_tlv; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK; } switch (info->type) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN: case SNDRV_CTL_ELEM_TYPE_INTEGER: private_size = sizeof(long); if (info->count > 128) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_INTEGER64: private_size = sizeof(long long); if (info->count > 64) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_ENUMERATED: private_size = sizeof(unsigned int); if (info->count > 128 || info->value.enumerated.items == 0) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_BYTES: private_size = sizeof(unsigned char); if (info->count > 512) return -EINVAL; break; case SNDRV_CTL_ELEM_TYPE_IEC958: private_size = sizeof(struct snd_aes_iec958); if (info->count != 1) return -EINVAL; break; default: return -EINVAL; } private_size *= info->count; ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL); if (ue == NULL) return -ENOMEM; ue->card = card; ue->info = *info; ue->info.access = 0; ue->elem_data = (char *)ue + sizeof(*ue); ue->elem_data_size = private_size; if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) { err = snd_ctl_elem_init_enum_names(ue); if (err < 0) { kfree(ue); return err; } } kctl.private_free = snd_ctl_elem_user_free; _kctl = snd_ctl_new(&kctl, access); if (_kctl == NULL) { kfree(ue->priv_data); kfree(ue); return -ENOMEM; } _kctl->private_data = ue; for (idx = 0; idx < _kctl->count; idx++) _kctl->vd[idx].owner = file; err = snd_ctl_add(card, _kctl); if (err < 0) return err; down_write(&card->controls_rwsem); card->user_ctl_count++; up_write(&card->controls_rwsem); return 0; }"
298,2279----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-13233--insn-eval.c----get_seg_limit,"static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx) { <S2SV_StartVul> struct desc_struct *desc; <S2SV_EndVul> unsigned long limit; short sel; sel = get_segment_selector(regs, seg_reg_idx); if (sel < 0) return 0; if (user_64bit_mode(regs) || v8086_mode(regs)) return -1L; if (!sel) return 0; <S2SV_StartVul> desc = get_desc(sel); <S2SV_EndVul> <S2SV_StartVul> if (!desc) <S2SV_EndVul> return 0; <S2SV_StartVul> limit = get_desc_limit(desc); <S2SV_EndVul> <S2SV_StartVul> if (desc->g) <S2SV_EndVul> limit = (limit << 12) + 0xfff; return limit; }","- struct desc_struct *desc;
- desc = get_desc(sel);
- if (!desc)
- limit = get_desc_limit(desc);
- if (desc->g)
+ struct desc_struct desc;
+ if (!get_desc(&desc, sel))
+ limit = get_desc_limit(&desc);
+ if (desc.g)","static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx) { struct desc_struct desc; unsigned long limit; short sel; sel = get_segment_selector(regs, seg_reg_idx); if (sel < 0) return 0; if (user_64bit_mode(regs) || v8086_mode(regs)) return -1L; if (!sel) return 0; if (!get_desc(&desc, sel)) return 0; limit = get_desc_limit(&desc); if (desc.g) limit = (limit << 12) + 0xfff; return limit; }"
299,742----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-7294--ikev2_parent.c----ikev2parent_inI1outR1,"stf_status ikev2parent_inI1outR1(struct msg_digest *md) { struct state *st = md->st; lset_t policy = POLICY_IKEV2_ALLOW; struct connection *c = find_host_connection(&md->iface->ip_addr, md->iface->port, &md->sender, md->sender_port, POLICY_IKEV2_ALLOW); #if 0 if (c == NULL) { pb_stream pre_sa_pbs = sa_pd->pbs; policy = preparse_isakmp_sa_body(&pre_sa_pbs); c = find_host_connection(&md->iface->ip_addr, pluto_port, (ip_address*)NULL, md->sender_port, policy); } #endif if (c == NULL) { { struct connection *d; d = find_host_connection(&md->iface->ip_addr, pluto_port, (ip_address*)NULL, md->sender_port, policy); for (; d != NULL; d = d->hp_next) { if (d->kind == CK_GROUP) { } else { if (d->kind == CK_TEMPLATE && !(d->policy & POLICY_OPPO)) { c = d; break; } if (addrinsubnet(&md->sender, &d->spd.that.client) && (c == NULL || !subnetinsubnet(&c->spd.that. client, &d->spd.that. client))) c = d; } } } if (c == NULL) { loglog(RC_LOG_SERIOUS, ""initial parent SA message received on %s:%u"" "" but no connection has been authorized%s%s"", ip_str( &md->iface->ip_addr), ntohs(portof(&md->iface->ip_addr)), (policy != LEMPTY) ? "" with policy="" : """", (policy != LEMPTY) ? bitnamesof(sa_policy_bit_names, policy) : """"); return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN; } if (c->kind != CK_TEMPLATE) { loglog(RC_LOG_SERIOUS, ""initial parent SA message received on %s:%u"" "" but \""%s\"" forbids connection"", ip_str( &md->iface->ip_addr), pluto_port, c->name); return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN; } c = rw_instantiate(c, &md->sender, NULL, NULL); } else { if ((c->kind == CK_TEMPLATE) && c->spd.that.virt) { DBG(DBG_CONTROL, DBG_log( ""local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation"")); c = rw_instantiate(c, &md->sender, NULL, NULL); } else if ((c->kind == CK_TEMPLATE) && (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) { DBG(DBG_CONTROL, DBG_log( ""local endpoint has narrowing=yes - needs instantiation"")); c = rw_instantiate(c, &md->sender, NULL, NULL); } } DBG_log(""found connection: %s\n"", c ? c->name : ""<none>""); if (!st) { st = new_state(); memcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE); get_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender); initialize_new_state(st, c, policy, 0, NULL_FD, pcim_stranger_crypto); st->st_ikev2 = TRUE; change_state(st, STATE_PARENT_R1); st->st_msgid_lastack = INVALID_MSGID; st->st_msgid_nextuse = 0; md->st = st; md->from_state = STATE_IKEv2_BASE; } if (force_busy == TRUE) { u_char dcookie[SHA1_DIGEST_SIZE]; chunk_t dc; ikev2_get_dcookie( dcookie, st->st_ni, &md->sender, st->st_icookie); dc.ptr = dcookie; dc.len = SHA1_DIGEST_SIZE; if ( md->chain[ISAKMP_NEXT_v2KE] && md->chain[ISAKMP_NEXT_v2N] && (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type == v2N_COOKIE)) { u_int8_t spisize; const pb_stream *dc_pbs; chunk_t blob; DBG(DBG_CONTROLMORE, DBG_log(""received a DOS cookie in I1 verify it"")); spisize = md->chain[ISAKMP_NEXT_v2N]->payload.v2n. isan_spisize; dc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs; blob.ptr = dc_pbs->cur + spisize; blob.len = pbs_left(dc_pbs) - spisize; DBG(DBG_CONTROLMORE, DBG_dump_chunk(""dcookie received in I1 Packet"", blob); DBG_dump(""dcookie computed"", dcookie, SHA1_DIGEST_SIZE)); if (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) { libreswan_log( ""mismatch in DOS v2N_COOKIE,send a new one""); SEND_NOTIFICATION_AA(v2N_COOKIE, &dc); return STF_FAIL + v2N_INVALID_IKE_SPI; } DBG(DBG_CONTROLMORE, DBG_log(""dcookie received match with computed one"")); } else { DBG(DBG_CONTROLMORE, DBG_log( ""busy mode on. receieved I1 without a valid dcookie""); DBG_log(""send a dcookie and forget this state"")); SEND_NOTIFICATION_AA(v2N_COOKIE, &dc); return STF_FAIL; } } else { DBG(DBG_CONTROLMORE, DBG_log(""will not send/process a dcookie"")); } { struct ikev2_ke *ke; ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke; st->st_oakley.group = lookup_group(ke->isak_group); if (st->st_oakley.group == NULL) { <S2SV_StartVul> char fromname[ADDRTOT_BUF]; <S2SV_EndVul> addrtot(&md->sender, 0, fromname, ADDRTOT_BUF); <S2SV_StartVul> libreswan_log( <S2SV_EndVul> ""rejecting I1 from %s:%u, invalid DH group=%u"", fromname, md->sender_port, ke->isak_group); return v2N_INVALID_KE_PAYLOAD; <S2SV_StartVul> } <S2SV_EndVul> } { struct ke_continuation *ke = alloc_thing( struct ke_continuation, ""ikev2_inI1outR1 KE""); stf_status e; ke->md = md; set_suspended(st, ke->md); if (!st->st_sec_in_use) { pcrc_init(&ke->ke_pcrc); ke->ke_pcrc.pcrc_func = ikev2_parent_inI1outR1_continue; e = build_ke(&ke->ke_pcrc, st, st->st_oakley.group, pcim_stranger_crypto); if (e != STF_SUSPEND && e != STF_INLINE) { loglog(RC_CRYPTOFAILED, ""system too busy""); delete_state(st); } } else { e = ikev2_parent_inI1outR1_tail((struct pluto_crypto_req_cont *)ke, NULL); } reset_globals(); return e; } }","- char fromname[ADDRTOT_BUF];
- libreswan_log(
- }
+ char fromname[ADDRTOT_BUF];
+ addrtot(&md->sender, 0, fromname, ADDRTOT_BUF);
+ if (!md->chain[ISAKMP_NEXT_v2KE]) {
+ if(md->chain[ISAKMP_NEXT_v2N]) {
+ libreswan_log(""Received Notify(%d): %s"",
+ md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,
+ enum_name(&ikev2_notify_names,
+ md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));
+ }
+ libreswan_log(
+ ""rejecting I1 from %s:%u, no KE payload present"",
+ fromname, md->sender_port);
+ return STF_FAIL + v2N_INVALID_KE_PAYLOAD;
+ }
+ return STF_FAIL + v2N_INVALID_KE_PAYLOAD;","stf_status ikev2parent_inI1outR1(struct msg_digest *md) { struct state *st = md->st; lset_t policy = POLICY_IKEV2_ALLOW; struct connection *c = find_host_connection(&md->iface->ip_addr, md->iface->port, &md->sender, md->sender_port, POLICY_IKEV2_ALLOW); #if 0 if (c == NULL) { pb_stream pre_sa_pbs = sa_pd->pbs; policy = preparse_isakmp_sa_body(&pre_sa_pbs); c = find_host_connection(&md->iface->ip_addr, pluto_port, (ip_address*)NULL, md->sender_port, policy); } #endif if (c == NULL) { { struct connection *d; d = find_host_connection(&md->iface->ip_addr, pluto_port, (ip_address*)NULL, md->sender_port, policy); for (; d != NULL; d = d->hp_next) { if (d->kind == CK_GROUP) { } else { if (d->kind == CK_TEMPLATE && !(d->policy & POLICY_OPPO)) { c = d; break; } if (addrinsubnet(&md->sender, &d->spd.that.client) && (c == NULL || !subnetinsubnet(&c->spd.that. client, &d->spd.that. client))) c = d; } } } if (c == NULL) { loglog(RC_LOG_SERIOUS, ""initial parent SA message received on %s:%u"" "" but no connection has been authorized%s%s"", ip_str( &md->iface->ip_addr), ntohs(portof(&md->iface->ip_addr)), (policy != LEMPTY) ? "" with policy="" : """", (policy != LEMPTY) ? bitnamesof(sa_policy_bit_names, policy) : """"); return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN; } if (c->kind != CK_TEMPLATE) { loglog(RC_LOG_SERIOUS, ""initial parent SA message received on %s:%u"" "" but \""%s\"" forbids connection"", ip_str( &md->iface->ip_addr), pluto_port, c->name); return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN; } c = rw_instantiate(c, &md->sender, NULL, NULL); } else { if ((c->kind == CK_TEMPLATE) && c->spd.that.virt) { DBG(DBG_CONTROL, DBG_log( ""local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation"")); c = rw_instantiate(c, &md->sender, NULL, NULL); } else if ((c->kind == CK_TEMPLATE) && (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) { DBG(DBG_CONTROL, DBG_log( ""local endpoint has narrowing=yes - needs instantiation"")); c = rw_instantiate(c, &md->sender, NULL, NULL); } } DBG_log(""found connection: %s\n"", c ? c->name : ""<none>""); if (!st) { st = new_state(); memcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE); get_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender); initialize_new_state(st, c, policy, 0, NULL_FD, pcim_stranger_crypto); st->st_ikev2 = TRUE; change_state(st, STATE_PARENT_R1); st->st_msgid_lastack = INVALID_MSGID; st->st_msgid_nextuse = 0; md->st = st; md->from_state = STATE_IKEv2_BASE; } if (force_busy == TRUE) { u_char dcookie[SHA1_DIGEST_SIZE]; chunk_t dc; ikev2_get_dcookie( dcookie, st->st_ni, &md->sender, st->st_icookie); dc.ptr = dcookie; dc.len = SHA1_DIGEST_SIZE; if ( md->chain[ISAKMP_NEXT_v2KE] && md->chain[ISAKMP_NEXT_v2N] && (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type == v2N_COOKIE)) { u_int8_t spisize; const pb_stream *dc_pbs; chunk_t blob; DBG(DBG_CONTROLMORE, DBG_log(""received a DOS cookie in I1 verify it"")); spisize = md->chain[ISAKMP_NEXT_v2N]->payload.v2n. isan_spisize; dc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs; blob.ptr = dc_pbs->cur + spisize; blob.len = pbs_left(dc_pbs) - spisize; DBG(DBG_CONTROLMORE, DBG_dump_chunk(""dcookie received in I1 Packet"", blob); DBG_dump(""dcookie computed"", dcookie, SHA1_DIGEST_SIZE)); if (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) { libreswan_log( ""mismatch in DOS v2N_COOKIE,send a new one""); SEND_NOTIFICATION_AA(v2N_COOKIE, &dc); return STF_FAIL + v2N_INVALID_IKE_SPI; } DBG(DBG_CONTROLMORE, DBG_log(""dcookie received match with computed one"")); } else { DBG(DBG_CONTROLMORE, DBG_log( ""busy mode on. receieved I1 without a valid dcookie""); DBG_log(""send a dcookie and forget this state"")); SEND_NOTIFICATION_AA(v2N_COOKIE, &dc); return STF_FAIL; } } else { DBG(DBG_CONTROLMORE, DBG_log(""will not send/process a dcookie"")); } { struct ikev2_ke *ke; char fromname[ADDRTOT_BUF]; addrtot(&md->sender, 0, fromname, ADDRTOT_BUF); if (!md->chain[ISAKMP_NEXT_v2KE]) { if(md->chain[ISAKMP_NEXT_v2N]) { libreswan_log(""Received Notify(%d): %s"", md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type, enum_name(&ikev2_notify_names, md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type)); } libreswan_log( ""rejecting I1 from %s:%u, no KE payload present"", fromname, md->sender_port); return STF_FAIL + v2N_INVALID_KE_PAYLOAD; } ke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke; st->st_oakley.group = lookup_group(ke->isak_group); if (st->st_oakley.group == NULL) { libreswan_log( ""rejecting I1 from %s:%u, invalid DH group=%u"", fromname, md->sender_port, ke->isak_group); return STF_FAIL + v2N_INVALID_KE_PAYLOAD; } } { struct ke_continuation *ke = alloc_thing( struct ke_continuation, ""ikev2_inI1outR1 KE""); stf_status e; ke->md = md; set_suspended(st, ke->md); if (!st->st_sec_in_use) { pcrc_init(&ke->ke_pcrc); ke->ke_pcrc.pcrc_func = ikev2_parent_inI1outR1_continue; e = build_ke(&ke->ke_pcrc, st, st->st_oakley.group, pcim_stranger_crypto); if (e != STF_SUSPEND && e != STF_INLINE) { loglog(RC_CRYPTOFAILED, ""system too busy""); delete_state(st); } } else { e = ikev2_parent_inI1outR1_tail((struct pluto_crypto_req_cont *)ke, NULL); } reset_globals(); return e; } }"
300,7448----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/icecast_client.c----icecastClientConnect,"error_t icecastClientConnect(IcecastClientContext *context) { error_t error; size_t length; uint16_t serverPort; IpAddr serverIpAddr; NetInterface *interface; interface = context->settings.interface; if(osStrcmp(interface->proxyName, """")) { const char_t requestTemplate[] = ""GET http://%s:%"" PRIu16 ""%s HTTP/1.1\r\n"" ""Host: %s:%"" PRIu16 ""\r\n"" ""User-agent: UserAgent\r\n"" ""Icy-MetaData: 1\r\n"" ""Connection: close\r\n"" ""\r\n""; length = osSprintf(context->buffer, requestTemplate, context->settings.serverName, context->settings.serverPort, context->settings.resource, context->settings.serverName, context->settings.serverPort); error = getHostByName(interface, interface->proxyName, &serverIpAddr, 0); if(error) return error; serverPort = interface->proxyPort; } else { const char_t requestTemplate[] = ""GET %s HTTP/1.1\r\n"" ""Host: %s\r\n"" ""User-agent: UserAgent\r\n"" ""Icy-MetaData: 1\r\n"" ""Connection: close\r\n"" ""\r\n""; length = osSprintf(context->buffer, requestTemplate, context->settings.resource, context->settings.serverName); error = getHostByName(interface, context->settings.serverName, &serverIpAddr, 0); if(error) return error; serverPort = context->settings.serverPort; } context->socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP); if(context->socket == NULL) return ERROR_OUT_OF_RESOURCES; do { error = socketBindToInterface(context->socket, interface); if(error) break; error = socketSetTimeout(context->socket, ICECAST_CLIENT_TIMEOUT); if(error) break; error = socketConnect(context->socket, &serverIpAddr, serverPort); if(error) break; TRACE_DEBUG(context->buffer); error = socketSend(context->socket, context->buffer, length, NULL, SOCKET_FLAG_WAIT_ACK); if(error) break; while(1) { char_t *separator; char_t *property; char_t *value; error = socketReceive(context->socket, context->buffer, ICECAST_CLIENT_METADATA_MAX_SIZE, &length, SOCKET_FLAG_BREAK_CRLF); if(error) break; context->buffer[length] = '\0'; if(!osStrcmp(context->buffer, ""\r\n"")) break; <S2SV_StartVul> separator = strchr(context->buffer, ':'); <S2SV_EndVul> if(separator) { *separator = '\0'; property = strTrimWhitespace(context->buffer); value = strTrimWhitespace(separator + 1); TRACE_INFO(""<%s>=<%s>\r\n"", property, value); if(!osStrcasecmp(property, ""Icy-Metaint"")) { context->blockSize = atoi(value); } } } } while(0); if(error) { socketClose(context->socket); } return error; }","- separator = strchr(context->buffer, ':');
+ separator = osStrchr(context->buffer, ':');","error_t icecastClientConnect(IcecastClientContext *context) { error_t error; size_t length; uint16_t serverPort; IpAddr serverIpAddr; NetInterface *interface; interface = context->settings.interface; if(osStrcmp(interface->proxyName, """")) { const char_t requestTemplate[] = ""GET http://%s:%"" PRIu16 ""%s HTTP/1.1\r\n"" ""Host: %s:%"" PRIu16 ""\r\n"" ""User-agent: UserAgent\r\n"" ""Icy-MetaData: 1\r\n"" ""Connection: close\r\n"" ""\r\n""; length = osSprintf(context->buffer, requestTemplate, context->settings.serverName, context->settings.serverPort, context->settings.resource, context->settings.serverName, context->settings.serverPort); error = getHostByName(interface, interface->proxyName, &serverIpAddr, 0); if(error) return error; serverPort = interface->proxyPort; } else { const char_t requestTemplate[] = ""GET %s HTTP/1.1\r\n"" ""Host: %s\r\n"" ""User-agent: UserAgent\r\n"" ""Icy-MetaData: 1\r\n"" ""Connection: close\r\n"" ""\r\n""; length = osSprintf(context->buffer, requestTemplate, context->settings.resource, context->settings.serverName); error = getHostByName(interface, context->settings.serverName, &serverIpAddr, 0); if(error) return error; serverPort = context->settings.serverPort; } context->socket = socketOpen(SOCKET_TYPE_STREAM, SOCKET_IP_PROTO_TCP); if(context->socket == NULL) return ERROR_OUT_OF_RESOURCES; do { error = socketBindToInterface(context->socket, interface); if(error) break; error = socketSetTimeout(context->socket, ICECAST_CLIENT_TIMEOUT); if(error) break; error = socketConnect(context->socket, &serverIpAddr, serverPort); if(error) break; TRACE_DEBUG(context->buffer); error = socketSend(context->socket, context->buffer, length, NULL, SOCKET_FLAG_WAIT_ACK); if(error) break; while(1) { char_t *separator; char_t *property; char_t *value; error = socketReceive(context->socket, context->buffer, ICECAST_CLIENT_METADATA_MAX_SIZE, &length, SOCKET_FLAG_BREAK_CRLF); if(error) break; context->buffer[length] = '\0'; if(!osStrcmp(context->buffer, ""\r\n"")) break; separator = osStrchr(context->buffer, ':'); if(separator) { *separator = '\0'; property = strTrimWhitespace(context->buffer); value = strTrimWhitespace(separator + 1); TRACE_INFO(""<%s>=<%s>\r\n"", property, value); if(!osStrcasecmp(property, ""Icy-Metaint"")) { context->blockSize = atoi(value); } } } } while(0); if(error) { socketClose(context->socket); } return error; }"
301,623----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-5336--mk_request.c----mk_request_free,void mk_request_free(struct session_request *sr) { if (sr->fd_file > 0) { <S2SV_StartVul> mk_vhost_close(sr); <S2SV_EndVul> } if (sr->headers.location) { mk_mem_free(sr->headers.location); } if (sr->uri_processed.data != sr->uri.data) { mk_ptr_free(&sr->uri_processed); } if (sr->real_path.data != sr->real_path_static) { mk_ptr_free(&sr->real_path); } },"- mk_vhost_close(sr);
+ if (sr->fd_is_fdt == MK_TRUE) {
+ mk_vhost_close(sr);
+ }
+ else {
+ close(sr->fd_file);
+ }",void mk_request_free(struct session_request *sr) { if (sr->fd_file > 0) { if (sr->fd_is_fdt == MK_TRUE) { mk_vhost_close(sr); } else { close(sr->fd_file); } } if (sr->headers.location) { mk_mem_free(sr->headers.location); } if (sr->uri_processed.data != sr->uri.data) { mk_ptr_free(&sr->uri_processed); } if (sr->real_path.data != sr->real_path_static) { mk_ptr_free(&sr->real_path); } }
302,5333----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mprLib.c----mprGetJson,"PUBLIC cchar *mprGetJson(MprJson *obj, cchar *key) { MprJson *result; if (key && !strpbrk(key, "".[]*"")) { <S2SV_StartVul> return mprLookupJson(obj, key); <S2SV_EndVul> } if ((result = mprQueryJson(obj, key, 0, 0)) != 0) { if (result->length == 1 && result->children->type & MPR_JSON_VALUE) { return result->children->value; } else if (result->length > 1) { return mprJsonToString(result, 0); } } return 0; }","- return mprLookupJson(obj, key);
+ return mprReadJson(obj, key);","PUBLIC cchar *mprGetJson(MprJson *obj, cchar *key) { MprJson *result; if (key && !strpbrk(key, "".[]*"")) { return mprReadJson(obj, key); } if ((result = mprQueryJson(obj, key, 0, 0)) != 0) { if (result->length == 1 && result->children->type & MPR_JSON_VALUE) { return result->children->value; } else if (result->length > 1) { return mprJsonToString(result, 0); } } return 0; }"
303,2440----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-4502--util.c----initiate_stratum,"bool initiate_stratum(struct pool *pool) { bool ret = false, recvd = false, noresume = false, sockd = false; char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid; json_t *val = NULL, *res_val, *err_val; json_error_t err; int n2size; resend: if (!setup_stratum_socket(pool)) { applog(LOG_INFO, ""setup_stratum_socket() on %s failed"", get_pool_name(pool)); sockd = false; goto out; } sockd = true; if (recvd) { clear_sock(pool); sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++); } else { if (pool->sessionid) sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid); else sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++); <S2SV_StartVul> } <S2SV_EndVul> if (__stratum_send(pool, s, strlen(s)) != SEND_OK) { applog(LOG_DEBUG, ""Failed to send s in initiate_stratum""); goto out; } if (!socket_full(pool, DEFAULT_SOCKWAIT)) { applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum""); goto out; } sret = recv_line(pool); if (!sret) goto out; recvd = true; val = JSON_LOADS(sret, &err); free(sret); if (!val) { applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text); goto out; } res_val = json_object_get(val, ""result""); err_val = json_object_get(val, ""error""); if (!res_val || json_is_null(res_val) || (err_val && !json_is_null(err_val))) { char *ss; if (err_val) ss = json_dumps(err_val, JSON_INDENT(3)); else ss = strdup(""(unknown reason)""); applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss); free(ss); goto out; } sessionid = get_sessionid(res_val); if (!sessionid) applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum""); nonce1 = json_array_string(res_val, 1); if (!nonce1) { applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum""); free(sessionid); goto out; } n2size = json_integer_value(json_array_get(res_val, 2)); if (!n2size) { applog(LOG_INFO, ""Failed to get n2size in initiate_stratum""); free(sessionid); free(nonce1); goto out; } cg_wlock(&pool->data_lock); pool->sessionid = sessionid; pool->nonce1 = nonce1; pool->n1_len = strlen(nonce1) / 2; free(pool->nonce1bin); pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1); if (unlikely(!pool->nonce1bin)) quithere(1, ""Failed to calloc pool->nonce1bin""); hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len); pool->n2size = n2size; cg_wunlock(&pool->data_lock); if (sessionid) applog(LOG_DEBUG, ""%s stratum session id: %s"", get_pool_name(pool), pool->sessionid); ret = true; out: if (ret) { if (!pool->stratum_url) pool->stratum_url = pool->sockaddr_url; pool->stratum_active = true; pool->swork.diff = 1; if (opt_protocol) { applog(LOG_DEBUG, ""%s confirmed mining.subscribe with extranonce1 %s extran2size %d"", get_pool_name(pool), pool->nonce1, pool->n2size); } } else { if (recvd && !noresume) { cg_wlock(&pool->data_lock); free(pool->sessionid); free(pool->nonce1); pool->sessionid = pool->nonce1 = NULL; cg_wunlock(&pool->data_lock); applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh""); noresume = true; json_decref(val); goto resend; } applog(LOG_DEBUG, ""Initiating stratum failed on %s"", get_pool_name(pool)); if (sockd) { applog(LOG_DEBUG, ""Suspending stratum on %s"", get_pool_name(pool)); suspend_stratum(pool); } } json_decref(val); return ret; }","- }
+ bool initiate_stratum(struct pool *pool)
+ {","bool initiate_stratum(struct pool *pool) { bool ret = false, recvd = false, noresume = false, sockd = false; char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid; json_t *val = NULL, *res_val, *err_val; json_error_t err; int n2size; resend: if (!setup_stratum_socket(pool)) { applog(LOG_INFO, ""setup_stratum_socket() on %s failed"", get_pool_name(pool)); sockd = false; goto out; } sockd = true; if (recvd) { clear_sock(pool); sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++); } else { if (pool->sessionid) sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid); else sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++); } if (__stratum_send(pool, s, strlen(s)) != SEND_OK) { applog(LOG_DEBUG, ""Failed to send s in initiate_stratum""); goto out; } if (!socket_full(pool, DEFAULT_SOCKWAIT)) { applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum""); goto out; } sret = recv_line(pool); if (!sret) goto out; recvd = true; val = JSON_LOADS(sret, &err); free(sret); if (!val) { applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text); goto out; } res_val = json_object_get(val, ""result""); err_val = json_object_get(val, ""error""); if (!res_val || json_is_null(res_val) || (err_val && !json_is_null(err_val))) { char *ss; if (err_val) ss = json_dumps(err_val, JSON_INDENT(3)); else ss = strdup(""(unknown reason)""); applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss); free(ss); goto out; } sessionid = get_sessionid(res_val); if (!sessionid) applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum""); nonce1 = json_array_string(res_val, 1); if (!nonce1) { applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum""); free(sessionid); goto out; } n2size = json_integer_value(json_array_get(res_val, 2)); if (n2size < 1) { applog(LOG_INFO, ""Failed to get n2size in initiate_stratum""); free(sessionid); free(nonce1); goto out; } cg_wlock(&pool->data_lock); pool->sessionid = sessionid; pool->nonce1 = nonce1; pool->n1_len = strlen(nonce1) / 2; free(pool->nonce1bin); pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1); if (unlikely(!pool->nonce1bin)) quithere(1, ""Failed to calloc pool->nonce1bin""); hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len); pool->n2size = n2size; cg_wunlock(&pool->data_lock); if (sessionid) applog(LOG_DEBUG, ""%s stratum session id: %s"", get_pool_name(pool), pool->sessionid); ret = true; out: if (ret) { if (!pool->stratum_url) pool->stratum_url = pool->sockaddr_url; pool->stratum_active = true; pool->swork.diff = 1; if (opt_protocol) { applog(LOG_DEBUG, ""%s confirmed mining.subscribe with extranonce1 %s extran2size %d"", get_pool_name(pool), pool->nonce1, pool->n2size); } } else { if (recvd && !noresume) { cg_wlock(&pool->data_lock); free(pool->sessionid); free(pool->nonce1); pool->sessionid = pool->nonce1 = NULL; cg_wunlock(&pool->data_lock); applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh""); noresume = true; json_decref(val); goto resend; } applog(LOG_DEBUG, ""Initiating stratum failed on %s"", get_pool_name(pool)); if (sockd) { applog(LOG_DEBUG, ""Suspending stratum on %s"", get_pool_name(pool)); suspend_stratum(pool); } } json_decref(val); return ret; }"
304,448----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4125--ip6_fib.c----fib6_add_rt2node,"static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt, struct nl_info *info) { struct rt6_info *iter = NULL; struct rt6_info **ins; int replace = (info->nlh && (info->nlh->nlmsg_flags & NLM_F_REPLACE)); int add = (!info->nlh || (info->nlh->nlmsg_flags & NLM_F_CREATE)); int found = 0; ins = &fn->leaf; for (iter = fn->leaf; iter; iter = iter->dst.rt6_next) { if (iter->rt6i_metric == rt->rt6i_metric) { if (info->nlh && (info->nlh->nlmsg_flags & NLM_F_EXCL)) return -EEXIST; if (replace) { found++; break; } if (iter->dst.dev == rt->dst.dev && iter->rt6i_idev == rt->rt6i_idev && ipv6_addr_equal(&iter->rt6i_gateway, &rt->rt6i_gateway)) { if (rt->rt6i_nsiblings) rt->rt6i_nsiblings = 0; if (!(iter->rt6i_flags & RTF_EXPIRES)) return -EEXIST; if (!(rt->rt6i_flags & RTF_EXPIRES)) rt6_clean_expires(iter); else rt6_set_expires(iter, rt->dst.expires); return -EEXIST; } <S2SV_StartVul> if (rt->rt6i_flags & RTF_GATEWAY && <S2SV_EndVul> <S2SV_StartVul> !(rt->rt6i_flags & RTF_EXPIRES) && <S2SV_EndVul> <S2SV_StartVul> !(iter->rt6i_flags & RTF_EXPIRES)) <S2SV_EndVul> rt->rt6i_nsiblings++; } if (iter->rt6i_metric > rt->rt6i_metric) break; ins = &iter->dst.rt6_next; } if (ins == &fn->leaf) fn->rr_ptr = NULL; if (rt->rt6i_nsiblings) { unsigned int rt6i_nsiblings; struct rt6_info *sibling, *temp_sibling; sibling = fn->leaf; while (sibling) { <S2SV_StartVul> if (sibling->rt6i_metric == rt->rt6i_metric) { <S2SV_EndVul> list_add_tail(&rt->rt6i_siblings, &sibling->rt6i_siblings); break; } sibling = sibling->dst.rt6_next; } rt6i_nsiblings = 0; list_for_each_entry_safe(sibling, temp_sibling, &rt->rt6i_siblings, rt6i_siblings) { sibling->rt6i_nsiblings++; BUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings); rt6i_nsiblings++; } BUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings); } if (!replace) { if (!add) pr_warn(""NLM_F_CREATE should be set when creating new route\n""); add: rt->dst.rt6_next = iter; *ins = rt; rt->rt6i_node = fn; atomic_inc(&rt->rt6i_ref); inet6_rt_notify(RTM_NEWROUTE, rt, info); info->nl_net->ipv6.rt6_stats->fib_rt_entries++; if (!(fn->fn_flags & RTN_RTINFO)) { info->nl_net->ipv6.rt6_stats->fib_route_nodes++; fn->fn_flags |= RTN_RTINFO; } } else { if (!found) { if (add) goto add; pr_warn(""NLM_F_REPLACE set, but no existing node found!\n""); return -ENOENT; } *ins = rt; rt->rt6i_node = fn; rt->dst.rt6_next = iter->dst.rt6_next; atomic_inc(&rt->rt6i_ref); inet6_rt_notify(RTM_NEWROUTE, rt, info); rt6_release(iter); if (!(fn->fn_flags & RTN_RTINFO)) { info->nl_net->ipv6.rt6_stats->fib_route_nodes++; fn->fn_flags |= RTN_RTINFO; } } return 0; }","- if (rt->rt6i_flags & RTF_GATEWAY &&
- !(rt->rt6i_flags & RTF_EXPIRES) &&
- !(iter->rt6i_flags & RTF_EXPIRES))
- if (sibling->rt6i_metric == rt->rt6i_metric) {
+ bool rt_can_ecmp = rt6_qualify_for_ecmp(rt);
+ if (rt_can_ecmp &&
+ rt6_qualify_for_ecmp(iter))
+ if (sibling->rt6i_metric == rt->rt6i_metric &&
+ rt6_qualify_for_ecmp(sibling)) {","static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt, struct nl_info *info) { struct rt6_info *iter = NULL; struct rt6_info **ins; int replace = (info->nlh && (info->nlh->nlmsg_flags & NLM_F_REPLACE)); int add = (!info->nlh || (info->nlh->nlmsg_flags & NLM_F_CREATE)); int found = 0; bool rt_can_ecmp = rt6_qualify_for_ecmp(rt); ins = &fn->leaf; for (iter = fn->leaf; iter; iter = iter->dst.rt6_next) { if (iter->rt6i_metric == rt->rt6i_metric) { if (info->nlh && (info->nlh->nlmsg_flags & NLM_F_EXCL)) return -EEXIST; if (replace) { found++; break; } if (iter->dst.dev == rt->dst.dev && iter->rt6i_idev == rt->rt6i_idev && ipv6_addr_equal(&iter->rt6i_gateway, &rt->rt6i_gateway)) { if (rt->rt6i_nsiblings) rt->rt6i_nsiblings = 0; if (!(iter->rt6i_flags & RTF_EXPIRES)) return -EEXIST; if (!(rt->rt6i_flags & RTF_EXPIRES)) rt6_clean_expires(iter); else rt6_set_expires(iter, rt->dst.expires); return -EEXIST; } if (rt_can_ecmp && rt6_qualify_for_ecmp(iter)) rt->rt6i_nsiblings++; } if (iter->rt6i_metric > rt->rt6i_metric) break; ins = &iter->dst.rt6_next; } if (ins == &fn->leaf) fn->rr_ptr = NULL; if (rt->rt6i_nsiblings) { unsigned int rt6i_nsiblings; struct rt6_info *sibling, *temp_sibling; sibling = fn->leaf; while (sibling) { if (sibling->rt6i_metric == rt->rt6i_metric && rt6_qualify_for_ecmp(sibling)) { list_add_tail(&rt->rt6i_siblings, &sibling->rt6i_siblings); break; } sibling = sibling->dst.rt6_next; } rt6i_nsiblings = 0; list_for_each_entry_safe(sibling, temp_sibling, &rt->rt6i_siblings, rt6i_siblings) { sibling->rt6i_nsiblings++; BUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings); rt6i_nsiblings++; } BUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings); } if (!replace) { if (!add) pr_warn(""NLM_F_CREATE should be set when creating new route\n""); add: rt->dst.rt6_next = iter; *ins = rt; rt->rt6i_node = fn; atomic_inc(&rt->rt6i_ref); inet6_rt_notify(RTM_NEWROUTE, rt, info); info->nl_net->ipv6.rt6_stats->fib_rt_entries++; if (!(fn->fn_flags & RTN_RTINFO)) { info->nl_net->ipv6.rt6_stats->fib_route_nodes++; fn->fn_flags |= RTN_RTINFO; } } else { if (!found) { if (add) goto add; pr_warn(""NLM_F_REPLACE set, but no existing node found!\n""); return -ENOENT; } *ins = rt; rt->rt6i_node = fn; rt->dst.rt6_next = iter->dst.rt6_next; atomic_inc(&rt->rt6i_ref); inet6_rt_notify(RTM_NEWROUTE, rt, info); rt6_release(iter); if (!(fn->fn_flags & RTN_RTINFO)) { info->nl_net->ipv6.rt6_stats->fib_route_nodes++; fn->fn_flags |= RTN_RTINFO; } } return 0; }"
305,5213----CWE-78----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/manager.c----build_config,"<S2SV_StartVul> build_config(char *prefix, struct server *server) <S2SV_EndVul> { char *path = NULL; int path_size = strlen(prefix) + strlen(server->port) + 20; path = ss_malloc(path_size); snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port); FILE *f = fopen(path, ""w+""); if (f == NULL) { if (verbose) { LOGE(""unable to open config file""); } ss_free(path); return; } fprintf(f, ""{\n""); fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port)); fprintf(f, ""\""password\"":\""%s\"""", server->password); <S2SV_StartVul> if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open); <S2SV_EndVul> <S2SV_StartVul> if (server->mode) fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode); <S2SV_EndVul> <S2SV_StartVul> if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method); <S2SV_EndVul> <S2SV_StartVul> if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin); <S2SV_EndVul> <S2SV_StartVul> if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts); <S2SV_EndVul> fprintf(f, ""\n}\n""); fclose(f); ss_free(path); }","- build_config(char *prefix, struct server *server)
- if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
- if (server->mode) fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
- if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
- if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
- if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
+ build_config(char *prefix, struct manager_ctx *manager, struct server *server)
+ if (server->method)
+ fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
+ else if (manager->method)
+ fprintf(f, "",\n\""method\"":\""%s\"""", manager->method);
+ if (server->fast_open[0])
+ fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
+ if (server->mode)
+ fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
+ if (server->plugin)
+ fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
+ if (server->plugin_opts)
+ fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);","build_config(char *prefix, struct manager_ctx *manager, struct server *server) { char *path = NULL; int path_size = strlen(prefix) + strlen(server->port) + 20; path = ss_malloc(path_size); snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port); FILE *f = fopen(path, ""w+""); if (f == NULL) { if (verbose) { LOGE(""unable to open config file""); } ss_free(path); return; } fprintf(f, ""{\n""); fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port)); fprintf(f, ""\""password\"":\""%s\"""", server->password); if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method); else if (manager->method) fprintf(f, "",\n\""method\"":\""%s\"""", manager->method); if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open); if (server->mode) fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode); if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin); if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts); fprintf(f, ""\n}\n""); fclose(f); ss_free(path); }"
306,218----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9601--jbig2_image.c----jbig2_image_compose_unopt,"jbig2_image_compose_unopt(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op) { <S2SV_StartVul> int i, j; <S2SV_EndVul> <S2SV_StartVul> int sw = src->width; <S2SV_EndVul> <S2SV_StartVul> int sh = src->height; <S2SV_EndVul> <S2SV_StartVul> int sx = 0; <S2SV_EndVul> <S2SV_StartVul> int sy = 0; <S2SV_EndVul> if (x < 0) { sx += -x; sw -= -x; x = 0; } if (y < 0) { sy += -y; sh -= -y; y = 0; } if (x + sw >= dst->width) sw = dst->width - x; if (y + sh >= dst->height) sh = dst->height - y; switch (op) { case JBIG2_COMPOSE_OR: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) | jbig2_image_get_pixel(dst, i + x, j + y)); } } break; case JBIG2_COMPOSE_AND: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) & jbig2_image_get_pixel(dst, i + x, j + y)); } } break; case JBIG2_COMPOSE_XOR: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) ^ jbig2_image_get_pixel(dst, i + x, j + y)); } } break; case JBIG2_COMPOSE_XNOR: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, (jbig2_image_get_pixel(src, i + sx, j + sy) == jbig2_image_get_pixel(dst, i + x, j + y))); } } break; case JBIG2_COMPOSE_REPLACE: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy)); } } break; } return 0; }","- int i, j;
- int sw = src->width;
- int sh = src->height;
- int sx = 0;
- int sy = 0;
+ uint32_t i, j;
+ uint32_t sw = src->width;
+ uint32_t sh = src->height;
+ uint32_t sx = 0;
+ uint32_t sy = 0;","jbig2_image_compose_unopt(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op) { uint32_t i, j; uint32_t sw = src->width; uint32_t sh = src->height; uint32_t sx = 0; uint32_t sy = 0; if (x < 0) { sx += -x; sw -= -x; x = 0; } if (y < 0) { sy += -y; sh -= -y; y = 0; } if (x + sw >= dst->width) sw = dst->width - x; if (y + sh >= dst->height) sh = dst->height - y; switch (op) { case JBIG2_COMPOSE_OR: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) | jbig2_image_get_pixel(dst, i + x, j + y)); } } break; case JBIG2_COMPOSE_AND: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) & jbig2_image_get_pixel(dst, i + x, j + y)); } } break; case JBIG2_COMPOSE_XOR: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy) ^ jbig2_image_get_pixel(dst, i + x, j + y)); } } break; case JBIG2_COMPOSE_XNOR: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, (jbig2_image_get_pixel(src, i + sx, j + sy) == jbig2_image_get_pixel(dst, i + x, j + y))); } } break; case JBIG2_COMPOSE_REPLACE: for (j = 0; j < sh; j++) { for (i = 0; i < sw; i++) { jbig2_image_set_pixel(dst, i + x, j + y, jbig2_image_get_pixel(src, i + sx, j + sy)); } } break; } return 0; }"
307,6206----CWE-284----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/flags.c----cs_cmd_flags,"static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[]) { chanacs_t *ca; mowgli_node_t *n; char *channel = parv[0]; char *target = sstrdup(parv[1]); char *flagstr = parv[2]; const char *str1; unsigned int addflags, removeflags, restrictflags; hook_channel_acl_req_t req; mychan_t *mc; if (parc < 1) { command_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, ""FLAGS""); command_fail(si, fault_needmoreparams, _(""Syntax: FLAGS <channel> [target] [flags]"")); return; } mc = mychan_find(channel); if (!mc) { command_fail(si, fault_nosuch_target, _(""Channel \2%s\2 is not registered.""), channel); return; } if (metadata_find(mc, ""private:close:closer"") && (target || !has_priv(si, PRIV_CHAN_AUSPEX))) { command_fail(si, fault_noprivs, _(""\2%s\2 is closed.""), channel); return; } if (!target || (target && target[0] == '+' && flagstr == NULL)) { unsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0; do_list(si, mc, flags); return; } <S2SV_StartVul> else if (!strcasecmp(target, ""LIST"") && myentity_find_ext(target) == NULL) <S2SV_EndVul> { do_list(si, mc, 0); free(target); return; } <S2SV_StartVul> else if (!strcasecmp(target, ""CLEAR"") && myentity_find_ext(target) == NULL) <S2SV_EndVul> { free(target); if (!chanacs_source_has_flag(mc, si, CA_FOUNDER)) { command_fail(si, fault_noprivs, ""You are not authorized to perform this operation.""); return; } mowgli_node_t *tn; MOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head) { ca = n->data; if (ca->level & CA_FOUNDER) continue; object_unref(ca); } logcommand(si, CMDLOG_DO, ""CLEAR:FLAGS: \2%s\2"", mc->name); command_success_nodata(si, _(""Cleared flags in \2%s\2.""), mc->name); return; } <S2SV_StartVul> else if (!strcasecmp(target, ""MODIFY"") && myentity_find_ext(target) == NULL) <S2SV_EndVul> { free(target); if (parc < 3) { command_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, ""FLAGS""); command_fail(si, fault_needmoreparams, _(""Syntax: FLAGS <#channel> MODIFY [target] <flags>"")); return; } flagstr = strchr(parv[2], ' '); if (flagstr) *flagstr++ = '\0'; target = strdup(parv[2]); } { myentity_t *mt; if (!si->smu) { command_fail(si, fault_noprivs, _(""You are not logged in."")); return; } if (!flagstr) { if (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW)) { command_fail(si, fault_noprivs, _(""You are not authorized to execute this command."")); return; } if (validhostmask(target)) ca = chanacs_find_host_literal(mc, target, 0); else { if (!(mt = myentity_find_ext(target))) { command_fail(si, fault_nosuch_target, _(""\2%s\2 is not registered.""), target); return; } free(target); target = sstrdup(mt->name); ca = chanacs_find_literal(mc, mt, 0); } if (ca != NULL) { str1 = bitmask_to_flags2(ca->level, 0); command_success_string(si, str1, _(""Flags for \2%s\2 in \2%s\2 are \2%s\2.""), target, channel, str1); } else command_success_string(si, """", _(""No flags for \2%s\2 in \2%s\2.""), target, channel); logcommand(si, CMDLOG_GET, ""FLAGS: \2%s\2 on \2%s\2"", mc->name, target); return; } restrictflags = chanacs_source_flags(mc, si); if (restrictflags & CA_FOUNDER) restrictflags = ca_all; else { if (!(restrictflags & CA_FLAGS)) { if (restrictflags & CA_AKICK || si->smu == NULL || irccasecmp(target, entity(si->smu)->name) || strcmp(flagstr, ""-*"")) { command_fail(si, fault_noprivs, _(""You are not authorized to execute this command."")); return; } } if (irccasecmp(target, entity(si->smu)->name)) restrictflags = allow_flags(mc, restrictflags); else restrictflags |= allow_flags(mc, restrictflags); } if (*flagstr == '+' || *flagstr == '-' || *flagstr == '=') { flags_make_bitmasks(flagstr, &addflags, &removeflags); if (addflags == 0 && removeflags == 0) { command_fail(si, fault_badparams, _(""No valid flags given, use /%s%s HELP FLAGS for a list""), ircd->uses_rcommand ? """" : ""msg "", chansvs.me->disp); return; } } else { addflags = get_template_flags(mc, flagstr); if (addflags == 0) { if (*target == '+' || *target == '-' || *target == '=') command_fail(si, fault_badparams, _(""Usage: FLAGS %s [target] [flags]""), mc->name); else command_fail(si, fault_badparams, _(""Invalid template name given, use /%s%s TEMPLATE %s for a list""), ircd->uses_rcommand ? """" : ""msg "", chansvs.me->disp, mc->name); return; } removeflags = ca_all & ~addflags; } if (!validhostmask(target)) { if (!(mt = myentity_find_ext(target))) { command_fail(si, fault_nosuch_target, _(""\2%s\2 is not registered.""), target); return; } free(target); target = sstrdup(mt->name); ca = chanacs_open(mc, mt, NULL, true, entity(si->smu)); if (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER)) { command_fail(si, fault_noprivs, _(""You may not remove a founder's +f access."")); return; } if (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1) { command_fail(si, fault_noprivs, _(""You may not remove the last founder."")); return; } if (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER) { if (mychan_num_founders(mc) >= chansvs.maxfounders) { command_fail(si, fault_noprivs, _(""Only %d founders allowed per channel.""), chansvs.maxfounders); chanacs_close(ca); return; } if (!myentity_can_register_channel(mt)) { command_fail(si, fault_toomany, _(""\2%s\2 has too many channels registered.""), mt->name); chanacs_close(ca); return; } if (!myentity_allow_foundership(mt)) { command_fail(si, fault_toomany, _(""\2%s\2 cannot take foundership of a channel.""), mt->name); chanacs_close(ca); return; } } if (addflags & CA_FOUNDER) addflags |= CA_FLAGS, removeflags &= ~CA_FLAGS; if (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK))) { command_fail(si, fault_noprivs, _(""\2%s\2 does not wish to be added to channel access lists (NEVEROP set).""), mt->name); chanacs_close(ca); return; } if (ca->level == 0 && chanacs_is_table_full(ca)) { command_fail(si, fault_toomany, _(""Channel %s access list is full.""), mc->name); chanacs_close(ca); return; } req.ca = ca; req.oldlevel = ca->level; if (!chanacs_modify(ca, &addflags, &removeflags, restrictflags)) { command_fail(si, fault_noprivs, _(""You are not allowed to set \2%s\2 on \2%s\2 in \2%s\2.""), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name); chanacs_close(ca); return; } req.newlevel = ca->level; hook_call_channel_acl_change(&req); chanacs_close(ca); } else { if (addflags & CA_FOUNDER) { command_fail(si, fault_badparams, _(""You may not set founder status on a hostmask."")); return; } ca = chanacs_open(mc, NULL, target, true, entity(si->smu)); if (ca->level == 0 && chanacs_is_table_full(ca)) { command_fail(si, fault_toomany, _(""Channel %s access list is full.""), mc->name); chanacs_close(ca); return; } req.ca = ca; req.oldlevel = ca->level; if (!chanacs_modify(ca, &addflags, &removeflags, restrictflags)) { command_fail(si, fault_noprivs, _(""You are not allowed to set \2%s\2 on \2%s\2 in \2%s\2.""), bitmask_to_flags2(addflags, removeflags), target, mc->name); chanacs_close(ca); return; } req.newlevel = ca->level; hook_call_channel_acl_change(&req); chanacs_close(ca); } if ((addflags | removeflags) == 0) { command_fail(si, fault_nochange, _(""Channel access to \2%s\2 for \2%s\2 unchanged.""), channel, target); return; } flagstr = bitmask_to_flags2(addflags, removeflags); command_success_nodata(si, _(""Flags \2%s\2 were set on \2%s\2 in \2%s\2.""), flagstr, target, channel); logcommand(si, CMDLOG_SET, ""FLAGS: \2%s\2 \2%s\2 \2%s\2"", mc->name, target, flagstr); verbose(mc, ""\2%s\2 set flags \2%s\2 on \2%s\2"", get_source_name(si), flagstr, target); } free(target); }","- else if (!strcasecmp(target, ""LIST"") && myentity_find_ext(target) == NULL)
- else if (!strcasecmp(target, ""CLEAR"") && myentity_find_ext(target) == NULL)
- else if (!strcasecmp(target, ""MODIFY"") && myentity_find_ext(target) == NULL)
+ else if (anope_flags_compat && !strcasecmp(target, ""LIST"") && myentity_find_ext(target) == NULL)
+ else if (anope_flags_compat && !strcasecmp(target, ""CLEAR"") && myentity_find_ext(target) == NULL)
+ else if (anope_flags_compat && !strcasecmp(target, ""MODIFY"") && myentity_find_ext(target) == NULL)","static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[]) { chanacs_t *ca; mowgli_node_t *n; char *channel = parv[0]; char *target = sstrdup(parv[1]); char *flagstr = parv[2]; const char *str1; unsigned int addflags, removeflags, restrictflags; hook_channel_acl_req_t req; mychan_t *mc; if (parc < 1) { command_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, ""FLAGS""); command_fail(si, fault_needmoreparams, _(""Syntax: FLAGS <channel> [target] [flags]"")); return; } mc = mychan_find(channel); if (!mc) { command_fail(si, fault_nosuch_target, _(""Channel \2%s\2 is not registered.""), channel); return; } if (metadata_find(mc, ""private:close:closer"") && (target || !has_priv(si, PRIV_CHAN_AUSPEX))) { command_fail(si, fault_noprivs, _(""\2%s\2 is closed.""), channel); return; } if (!target || (target && target[0] == '+' && flagstr == NULL)) { unsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0; do_list(si, mc, flags); return; } else if (anope_flags_compat && !strcasecmp(target, ""LIST"") && myentity_find_ext(target) == NULL) { do_list(si, mc, 0); free(target); return; } else if (anope_flags_compat && !strcasecmp(target, ""CLEAR"") && myentity_find_ext(target) == NULL) { free(target); if (!chanacs_source_has_flag(mc, si, CA_FOUNDER)) { command_fail(si, fault_noprivs, ""You are not authorized to perform this operation.""); return; } mowgli_node_t *tn; MOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head) { ca = n->data; if (ca->level & CA_FOUNDER) continue; object_unref(ca); } logcommand(si, CMDLOG_DO, ""CLEAR:FLAGS: \2%s\2"", mc->name); command_success_nodata(si, _(""Cleared flags in \2%s\2.""), mc->name); return; } else if (anope_flags_compat && !strcasecmp(target, ""MODIFY"") && myentity_find_ext(target) == NULL) { free(target); if (parc < 3) { command_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, ""FLAGS""); command_fail(si, fault_needmoreparams, _(""Syntax: FLAGS <#channel> MODIFY [target] <flags>"")); return; } flagstr = strchr(parv[2], ' '); if (flagstr) *flagstr++ = '\0'; target = strdup(parv[2]); } { myentity_t *mt; if (!si->smu) { command_fail(si, fault_noprivs, _(""You are not logged in."")); return; } if (!flagstr) { if (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW)) { command_fail(si, fault_noprivs, _(""You are not authorized to execute this command."")); return; } if (validhostmask(target)) ca = chanacs_find_host_literal(mc, target, 0); else { if (!(mt = myentity_find_ext(target))) { command_fail(si, fault_nosuch_target, _(""\2%s\2 is not registered.""), target); return; } free(target); target = sstrdup(mt->name); ca = chanacs_find_literal(mc, mt, 0); } if (ca != NULL) { str1 = bitmask_to_flags2(ca->level, 0); command_success_string(si, str1, _(""Flags for \2%s\2 in \2%s\2 are \2%s\2.""), target, channel, str1); } else command_success_string(si, """", _(""No flags for \2%s\2 in \2%s\2.""), target, channel); logcommand(si, CMDLOG_GET, ""FLAGS: \2%s\2 on \2%s\2"", mc->name, target); return; } restrictflags = chanacs_source_flags(mc, si); if (restrictflags & CA_FOUNDER) restrictflags = ca_all; else { if (!(restrictflags & CA_FLAGS)) { if (restrictflags & CA_AKICK || si->smu == NULL || irccasecmp(target, entity(si->smu)->name) || strcmp(flagstr, ""-*"")) { command_fail(si, fault_noprivs, _(""You are not authorized to execute this command."")); return; } } if (irccasecmp(target, entity(si->smu)->name)) restrictflags = allow_flags(mc, restrictflags); else restrictflags |= allow_flags(mc, restrictflags); } if (*flagstr == '+' || *flagstr == '-' || *flagstr == '=') { flags_make_bitmasks(flagstr, &addflags, &removeflags); if (addflags == 0 && removeflags == 0) { command_fail(si, fault_badparams, _(""No valid flags given, use /%s%s HELP FLAGS for a list""), ircd->uses_rcommand ? """" : ""msg "", chansvs.me->disp); return; } } else { addflags = get_template_flags(mc, flagstr); if (addflags == 0) { if (*target == '+' || *target == '-' || *target == '=') command_fail(si, fault_badparams, _(""Usage: FLAGS %s [target] [flags]""), mc->name); else command_fail(si, fault_badparams, _(""Invalid template name given, use /%s%s TEMPLATE %s for a list""), ircd->uses_rcommand ? """" : ""msg "", chansvs.me->disp, mc->name); return; } removeflags = ca_all & ~addflags; } if (!validhostmask(target)) { if (!(mt = myentity_find_ext(target))) { command_fail(si, fault_nosuch_target, _(""\2%s\2 is not registered.""), target); return; } free(target); target = sstrdup(mt->name); ca = chanacs_open(mc, mt, NULL, true, entity(si->smu)); if (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER)) { command_fail(si, fault_noprivs, _(""You may not remove a founder's +f access."")); return; } if (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1) { command_fail(si, fault_noprivs, _(""You may not remove the last founder."")); return; } if (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER) { if (mychan_num_founders(mc) >= chansvs.maxfounders) { command_fail(si, fault_noprivs, _(""Only %d founders allowed per channel.""), chansvs.maxfounders); chanacs_close(ca); return; } if (!myentity_can_register_channel(mt)) { command_fail(si, fault_toomany, _(""\2%s\2 has too many channels registered.""), mt->name); chanacs_close(ca); return; } if (!myentity_allow_foundership(mt)) { command_fail(si, fault_toomany, _(""\2%s\2 cannot take foundership of a channel.""), mt->name); chanacs_close(ca); return; } } if (addflags & CA_FOUNDER) addflags |= CA_FLAGS, removeflags &= ~CA_FLAGS; if (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK))) { command_fail(si, fault_noprivs, _(""\2%s\2 does not wish to be added to channel access lists (NEVEROP set).""), mt->name); chanacs_close(ca); return; } if (ca->level == 0 && chanacs_is_table_full(ca)) { command_fail(si, fault_toomany, _(""Channel %s access list is full.""), mc->name); chanacs_close(ca); return; } req.ca = ca; req.oldlevel = ca->level; if (!chanacs_modify(ca, &addflags, &removeflags, restrictflags)) { command_fail(si, fault_noprivs, _(""You are not allowed to set \2%s\2 on \2%s\2 in \2%s\2.""), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name); chanacs_close(ca); return; } req.newlevel = ca->level; hook_call_channel_acl_change(&req); chanacs_close(ca); } else { if (addflags & CA_FOUNDER) { command_fail(si, fault_badparams, _(""You may not set founder status on a hostmask."")); return; } ca = chanacs_open(mc, NULL, target, true, entity(si->smu)); if (ca->level == 0 && chanacs_is_table_full(ca)) { command_fail(si, fault_toomany, _(""Channel %s access list is full.""), mc->name); chanacs_close(ca); return; } req.ca = ca; req.oldlevel = ca->level; if (!chanacs_modify(ca, &addflags, &removeflags, restrictflags)) { command_fail(si, fault_noprivs, _(""You are not allowed to set \2%s\2 on \2%s\2 in \2%s\2.""), bitmask_to_flags2(addflags, removeflags), target, mc->name); chanacs_close(ca); return; } req.newlevel = ca->level; hook_call_channel_acl_change(&req); chanacs_close(ca); } if ((addflags | removeflags) == 0) { command_fail(si, fault_nochange, _(""Channel access to \2%s\2 for \2%s\2 unchanged.""), channel, target); return; } flagstr = bitmask_to_flags2(addflags, removeflags); command_success_nodata(si, _(""Flags \2%s\2 were set on \2%s\2 in \2%s\2.""), flagstr, target, channel); logcommand(si, CMDLOG_SET, ""FLAGS: \2%s\2 \2%s\2 \2%s\2"", mc->name, target, flagstr); verbose(mc, ""\2%s\2 set flags \2%s\2 on \2%s\2"", get_source_name(si), flagstr, target); } free(target); }"
308,803----CWE-17----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-4335--ldo.c----f_parser,"static void f_parser (lua_State *L, void *ud) { int i; Proto *tf; Closure *cl; struct SParser *p = cast(struct SParser *, ud); int c = luaZ_lookahead(p->z); luaC_checkGC(L); <S2SV_StartVul> tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z, <S2SV_EndVul> &p->buff, p->name); cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L))); cl->l.p = tf; for (i = 0; i < tf->nups; i++) cl->l.upvals[i] = luaF_newupval(L); setclvalue(L, L->top, cl); incr_top(L); }","- tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,
+ tf = (luaY_parser)(L, p->z,","static void f_parser (lua_State *L, void *ud) { int i; Proto *tf; Closure *cl; struct SParser *p = cast(struct SParser *, ud); int c = luaZ_lookahead(p->z); luaC_checkGC(L); tf = (luaY_parser)(L, p->z, &p->buff, p->name); cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L))); cl->l.p = tf; for (i = 0; i < tf->nups; i++) cl->l.upvals[i] = luaF_newupval(L); setclvalue(L, L->top, cl); incr_top(L); }"
309,5038----CWE-672----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pkcs15-prkey.c----sc_pkcs15_decode_prkdf_entry,"int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card, struct sc_pkcs15_object *obj, const u8 ** buf, size_t *buflen) { sc_context_t *ctx = p15card->card->ctx; struct sc_pkcs15_prkey_info info; int r, i, gostr3410_params[3]; struct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams; size_t usage_len = sizeof(info.usage); size_t af_len = sizeof(info.access_flags); struct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE]; struct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE]; struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE]; struct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR]; struct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR]; struct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE]; struct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE]; struct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr}; struct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr}; struct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr}; struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr }; sc_copy_asn1_entry(c_asn1_prkey, asn1_prkey); sc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms); sc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr); sc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr); sc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr); sc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr); sc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr); sc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr); sc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr); sc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr); sc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr); sc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr); sc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr); sc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr); sc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0); sc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0); sc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0); sc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0); sc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0); sc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0); sc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0); sc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0); for (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++) sc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0); sc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0); memset(&info, 0, sizeof(info)); info.key_reference = -1; info.native = 1; memset(gostr3410_params, 0, sizeof(gostr3410_params)); r = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen); if (r < 0) { <S2SV_StartVul> if (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT && <S2SV_EndVul> <S2SV_StartVul> asn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) { <S2SV_EndVul> <S2SV_StartVul> free(asn1_com_prkey_attr[0].parm); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } if (r == SC_ERROR_ASN1_END_OF_CONTENTS) return r; LOG_TEST_RET(ctx, r, ""PrKey DF ASN.1 decoding failed""); if (asn1_prkey[0].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_RSA; } else if (asn1_prkey[1].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_EC; } else if (asn1_prkey[2].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_DSA; if (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT) info.path.type = SC_PATH_TYPE_PATH_PROT; } else if (asn1_prkey[3].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410; assert(info.modulus_length == 0); info.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE; assert(info.params.len == 0); info.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams); info.params.data = malloc(info.params.len); if (info.params.data == NULL) LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); assert(sizeof(*keyinfo_gostparams) == info.params.len); keyinfo_gostparams = info.params.data; keyinfo_gostparams->gostr3410 = gostr3410_params[0]; keyinfo_gostparams->gostr3411 = gostr3410_params[1]; keyinfo_gostparams->gost28147 = gostr3410_params[2]; } else { sc_log(ctx, ""Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.""); LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT); } if (!p15card->app || !p15card->app->ddo.aid.len) { r = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path); if (r < 0) { sc_pkcs15_free_key_params(&info.params); return r; } } else { info.path.aid = p15card->app->ddo.aid; } sc_log(ctx, ""PrivKey path '%s'"", sc_print_path(&info.path)); if (info.key_reference < -1) info.key_reference += 256; if ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) { sc_log(ctx, ""Private key %s has no auth ID - checking AccessControlRules"", sc_pkcs15_print_id(&info.id)); for (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) { if (obj->access_rules[i].access_mode & (SC_PKCS15_ACCESS_RULE_MODE_EXECUTE | SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS | SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT | SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) { if (obj->access_rules[i].auth_id.len != 0) { obj->auth_id = obj->access_rules[i].auth_id; sc_log(ctx, ""Auth ID found - %s"", sc_pkcs15_print_id(&obj->auth_id)); break; } } } if (i == SC_PKCS15_MAX_ACCESS_RULES) sc_log(ctx, ""Warning: No auth ID found""); } obj->data = malloc(sizeof(info)); if (obj->data == NULL) { sc_pkcs15_free_key_params(&info.params); LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); } memcpy(obj->data, &info, sizeof(info)); sc_log(ctx, ""Key Subject %s"", sc_dump_hex(info.subject.value, info.subject.len)); sc_log(ctx, ""Key path %s"", sc_print_path(&info.path)); return 0; }","- if (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT &&
- asn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) {
- free(asn1_com_prkey_attr[0].parm);
- }
+ free(info.subject.value);","int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card, struct sc_pkcs15_object *obj, const u8 ** buf, size_t *buflen) { sc_context_t *ctx = p15card->card->ctx; struct sc_pkcs15_prkey_info info; int r, i, gostr3410_params[3]; struct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams; size_t usage_len = sizeof(info.usage); size_t af_len = sizeof(info.access_flags); struct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE]; struct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE]; struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE]; struct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR]; struct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR]; struct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE]; struct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE]; struct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr}; struct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr}; struct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr}; struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr }; sc_copy_asn1_entry(c_asn1_prkey, asn1_prkey); sc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms); sc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr); sc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr); sc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr); sc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr); sc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr); sc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr); sc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr); sc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr); sc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr); sc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr); sc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr); sc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr); sc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0); sc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0); sc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0); sc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0); sc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0); sc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0); sc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0); sc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0); for (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++) sc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0); sc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0); memset(&info, 0, sizeof(info)); info.key_reference = -1; info.native = 1; memset(gostr3410_params, 0, sizeof(gostr3410_params)); r = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen); if (r < 0) { free(info.subject.value); } if (r == SC_ERROR_ASN1_END_OF_CONTENTS) return r; LOG_TEST_RET(ctx, r, ""PrKey DF ASN.1 decoding failed""); if (asn1_prkey[0].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_RSA; } else if (asn1_prkey[1].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_EC; } else if (asn1_prkey[2].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_DSA; if (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT) info.path.type = SC_PATH_TYPE_PATH_PROT; } else if (asn1_prkey[3].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410; assert(info.modulus_length == 0); info.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE; assert(info.params.len == 0); info.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams); info.params.data = malloc(info.params.len); if (info.params.data == NULL) LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); assert(sizeof(*keyinfo_gostparams) == info.params.len); keyinfo_gostparams = info.params.data; keyinfo_gostparams->gostr3410 = gostr3410_params[0]; keyinfo_gostparams->gostr3411 = gostr3410_params[1]; keyinfo_gostparams->gost28147 = gostr3410_params[2]; } else { sc_log(ctx, ""Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.""); LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT); } if (!p15card->app || !p15card->app->ddo.aid.len) { r = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path); if (r < 0) { sc_pkcs15_free_key_params(&info.params); return r; } } else { info.path.aid = p15card->app->ddo.aid; } sc_log(ctx, ""PrivKey path '%s'"", sc_print_path(&info.path)); if (info.key_reference < -1) info.key_reference += 256; if ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) { sc_log(ctx, ""Private key %s has no auth ID - checking AccessControlRules"", sc_pkcs15_print_id(&info.id)); for (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) { if (obj->access_rules[i].access_mode & (SC_PKCS15_ACCESS_RULE_MODE_EXECUTE | SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS | SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT | SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) { if (obj->access_rules[i].auth_id.len != 0) { obj->auth_id = obj->access_rules[i].auth_id; sc_log(ctx, ""Auth ID found - %s"", sc_pkcs15_print_id(&obj->auth_id)); break; } } } if (i == SC_PKCS15_MAX_ACCESS_RULES) sc_log(ctx, ""Warning: No auth ID found""); } obj->data = malloc(sizeof(info)); if (obj->data == NULL) { sc_pkcs15_free_key_params(&info.params); LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); } memcpy(obj->data, &info, sizeof(info)); sc_log(ctx, ""Key Subject %s"", sc_dump_hex(info.subject.value, info.subject.len)); sc_log(ctx, ""Key path %s"", sc_print_path(&info.path)); return 0; }"
310,2673----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/resource_handle.cc----tensorflow::ResourceHandle::FromProto,"<S2SV_StartVul> void ResourceHandle::FromProto(const ResourceHandleProto& proto) { <S2SV_EndVul> set_device(proto.device()); set_container(proto.container()); set_name(proto.name()); set_hash_code(proto.hash_code()); set_maybe_type_name(proto.maybe_type_name()); std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes; for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) { DataType dtype = dtype_and_shape.dtype(); <S2SV_StartVul> PartialTensorShape shape(dtype_and_shape.shape()); <S2SV_EndVul> dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape}); } dtypes_and_shapes_ = std::move(dtypes_and_shapes); }","- void ResourceHandle::FromProto(const ResourceHandleProto& proto) {
- PartialTensorShape shape(dtype_and_shape.shape());
+ Status ResourceHandle::FromProto(const ResourceHandleProto& proto) {
+ PartialTensorShape shape;
+ Status s = PartialTensorShape::BuildPartialTensorShape(
+ dtype_and_shape.shape(), &shape);
+ if (!s.ok()) {
+ return s;
+ }
+ return Status::OK();","Status ResourceHandle::FromProto(const ResourceHandleProto& proto) { set_device(proto.device()); set_container(proto.container()); set_name(proto.name()); set_hash_code(proto.hash_code()); set_maybe_type_name(proto.maybe_type_name()); std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes; for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) { DataType dtype = dtype_and_shape.dtype(); PartialTensorShape shape; Status s = PartialTensorShape::BuildPartialTensorShape( dtype_and_shape.shape(), &shape); if (!s.ok()) { return s; } dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape}); } dtypes_and_shapes_ = std::move(dtypes_and_shapes); return Status::OK(); }"
311,7151----CWE-19----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xattr.c----ext2_xattr_delete_inode,"ext2_xattr_delete_inode(struct inode *inode) { struct buffer_head *bh = NULL; <S2SV_StartVul> struct mb_cache_entry *ce; <S2SV_EndVul> down_write(&EXT2_I(inode)->xattr_sem); if (!EXT2_I(inode)->i_file_acl) goto cleanup; bh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl); if (!bh) { ext2_error(inode->i_sb, ""ext2_xattr_delete_inode"", ""inode %ld: block %d read error"", inode->i_ino, EXT2_I(inode)->i_file_acl); goto cleanup; } ea_bdebug(bh, ""b_count=%d"", atomic_read(&(bh->b_count))); if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) || HDR(bh)->h_blocks != cpu_to_le32(1)) { ext2_error(inode->i_sb, ""ext2_xattr_delete_inode"", ""inode %ld: bad block %d"", inode->i_ino, EXT2_I(inode)->i_file_acl); goto cleanup; } <S2SV_StartVul> ce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr); <S2SV_EndVul> lock_buffer(bh); if (HDR(bh)->h_refcount == cpu_to_le32(1)) { <S2SV_StartVul> if (ce) <S2SV_EndVul> <S2SV_StartVul> mb_cache_entry_free(ce); <S2SV_EndVul> ext2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1); get_bh(bh); bforget(bh); unlock_buffer(bh); } else { le32_add_cpu(&HDR(bh)->h_refcount, -1); <S2SV_StartVul> if (ce) <S2SV_EndVul> <S2SV_StartVul> mb_cache_entry_release(ce); <S2SV_EndVul> ea_bdebug(bh, ""refcount now=%d"", le32_to_cpu(HDR(bh)->h_refcount)); unlock_buffer(bh); mark_buffer_dirty(bh); if (IS_SYNC(inode)) sync_dirty_buffer(bh); dquot_free_block_nodirty(inode, 1); } EXT2_I(inode)->i_file_acl = 0; cleanup: brelse(bh); up_write(&EXT2_I(inode)->xattr_sem); }","- struct mb_cache_entry *ce;
- ce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);
- if (ce)
- mb_cache_entry_free(ce);
- if (ce)
- mb_cache_entry_release(ce);
+ __u32 hash = le32_to_cpu(HDR(bh)->h_hash);
+ mb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,
+ hash, bh->b_blocknr);","ext2_xattr_delete_inode(struct inode *inode) { struct buffer_head *bh = NULL; down_write(&EXT2_I(inode)->xattr_sem); if (!EXT2_I(inode)->i_file_acl) goto cleanup; bh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl); if (!bh) { ext2_error(inode->i_sb, ""ext2_xattr_delete_inode"", ""inode %ld: block %d read error"", inode->i_ino, EXT2_I(inode)->i_file_acl); goto cleanup; } ea_bdebug(bh, ""b_count=%d"", atomic_read(&(bh->b_count))); if (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) || HDR(bh)->h_blocks != cpu_to_le32(1)) { ext2_error(inode->i_sb, ""ext2_xattr_delete_inode"", ""inode %ld: bad block %d"", inode->i_ino, EXT2_I(inode)->i_file_acl); goto cleanup; } lock_buffer(bh); if (HDR(bh)->h_refcount == cpu_to_le32(1)) { __u32 hash = le32_to_cpu(HDR(bh)->h_hash); mb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache, hash, bh->b_blocknr); ext2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1); get_bh(bh); bforget(bh); unlock_buffer(bh); } else { le32_add_cpu(&HDR(bh)->h_refcount, -1); ea_bdebug(bh, ""refcount now=%d"", le32_to_cpu(HDR(bh)->h_refcount)); unlock_buffer(bh); mark_buffer_dirty(bh); if (IS_SYNC(inode)) sync_dirty_buffer(bh); dquot_free_block_nodirty(inode, 1); } EXT2_I(inode)->i_file_acl = 0; cleanup: brelse(bh); up_write(&EXT2_I(inode)->xattr_sem); }"
312,4699----CWE-913----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/reference_handle.cc----ivm::SetRunner::Phase2,"void Phase2() final { <S2SV_StartVul> Local<Context> context_handle = Deref(context); <S2SV_EndVul> <S2SV_StartVul> Context::Scope context_scope{context_handle}; <S2SV_EndVul> <S2SV_StartVul> Local<Value> key_inner = key->CopyInto(); <S2SV_EndVul> <S2SV_StartVul> Local<Object> object = Local<Object>::Cast(Deref(reference)); <S2SV_EndVul> <S2SV_StartVul> Unmaybe(object->Delete(context_handle, key_inner)); <S2SV_EndVul> <S2SV_StartVul> Local<Value> val_inner = val->TransferIn(); <S2SV_EndVul> <S2SV_StartVul> did_set = Unmaybe(object->Set(context_handle, key_inner, val_inner)); <S2SV_EndVul> }","- Local<Context> context_handle = Deref(context);
- Context::Scope context_scope{context_handle};
- Local<Value> key_inner = key->CopyInto();
- Local<Object> object = Local<Object>::Cast(Deref(reference));
- Unmaybe(object->Delete(context_handle, key_inner));
- Local<Value> val_inner = val->TransferIn();
- did_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));
+ auto context = Deref(this->context);
+ Context::Scope context_scope{context};
+ auto name = GetKey(context);
+ auto object = GetTargetAndAlsoCheckForProxy();
+ Unmaybe(object->Delete(context, name));
+ auto val_inner = val->TransferIn();
+ if (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) {
+ throw RuntimeTypeError(""Set failed"");
+ }","void Phase2() final { auto context = Deref(this->context); Context::Scope context_scope{context}; auto name = GetKey(context); auto object = GetTargetAndAlsoCheckForProxy(); Unmaybe(object->Delete(context, name)); auto val_inner = val->TransferIn(); if (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) { throw RuntimeTypeError(""Set failed""); } }"
313,2531----CWE-269----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5940--fs_home.c----copy_xauthority,"<S2SV_StartVul> static void copy_xauthority(void) { <S2SV_EndVul> char *src = RUN_XAUTHORITY_FILE ; <S2SV_StartVul> char *dest; <S2SV_EndVul> if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1) errExit(""asprintf""); <S2SV_StartVul> if (is_link(dest)) { <S2SV_EndVul> fprintf(stderr, ""Error: %s is a symbolic link\n"", dest); <S2SV_StartVul> exit(1); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> pid_t child = fork(); <S2SV_EndVul> if (child < 0) errExit(""fork""); if (child == 0) { drop_privs(0); int rv = copy_file(src, dest); if (rv) fprintf(stderr, ""Warning: cannot transfer .Xauthority in private home directory\n""); else { fs_logger2(""clone"", dest); } _exit(0); } waitpid(child, NULL, 0); if (chown(dest, getuid(), getgid()) < 0) errExit(""chown""); if (chmod(dest, S_IRUSR | S_IWUSR) < 0) errExit(""chmod""); unlink(src); }","- static void copy_xauthority(void) {
- char *dest;
- if (is_link(dest)) {
- exit(1);
- }
- 
- pid_t child = fork();
+ copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); // regular user
+ fs_logger2(""clone"", dest);","static void copy_xauthority(void) { char *src = RUN_XAUTHORITY_FILE ; char *dest; if (asprintf(&dest, ""%s/.Xauthority"", cfg.homedir) == -1) errExit(""asprintf""); if (is_link(dest)) { fprintf(stderr, ""Error: %s is a symbolic link\n"", dest); exit(1); } copy_file_as_user(src, dest, getuid(), getgid(), S_IRUSR | S_IWUSR); fs_logger2(""clone"", dest); unlink(src); }"
314,4517----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/QPDF_encryption.cc----QPDF::initializeEncryption,"QPDF::initializeEncryption() { if (this->m->encryption_initialized) { return; } this->m->encryption_initialized = true; if (! this->m->trailer.hasKey(""/Encrypt"")) { return; } this->m->encrypted = true; std::string id1; QPDFObjectHandle id_obj = this->m->trailer.getKey(""/ID""); if ((id_obj.isArray() && (id_obj.getArrayNItems() == 2) && id_obj.getArrayItem(0).isString())) { id1 = id_obj.getArrayItem(0).getStringValue(); } else { warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""trailer"", this->m->file->getLastOffset(), ""invalid /ID in trailer dictionary"")); } QPDFObjectHandle encryption_dict = this->m->trailer.getKey(""/Encrypt""); if (! encryption_dict.isDictionary()) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), this->m->last_object_description, this->m->file->getLastOffset(), ""/Encrypt in trailer dictionary is not a dictionary""); } if (! (encryption_dict.getKey(""/Filter"").isName() && (encryption_dict.getKey(""/Filter"").getName() == ""/Standard""))) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""unsupported encryption filter""); } if (! encryption_dict.getKey(""/SubFilter"").isNull()) { warn(QPDFExc(qpdf_e_unsupported, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""file uses encryption SubFilters,"" "" which qpdf does not support"")); } if (! (encryption_dict.getKey(""/V"").isInteger() && encryption_dict.getKey(""/R"").isInteger() && encryption_dict.getKey(""/O"").isString() && encryption_dict.getKey(""/U"").isString() && encryption_dict.getKey(""/P"").isInteger())) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""some encryption dictionary parameters are missing "" ""or the wrong type""); } int V = encryption_dict.getKey(""/V"").getIntValue(); int R = encryption_dict.getKey(""/R"").getIntValue(); std::string O = encryption_dict.getKey(""/O"").getStringValue(); std::string U = encryption_dict.getKey(""/U"").getStringValue(); unsigned int P = encryption_dict.getKey(""/P"").getIntValue(); if (! (((R >= 2) && (R <= 6)) && ((V == 1) || (V == 2) || (V == 4) || (V == 5)))) { throw QPDFExc(qpdf_e_unsupported, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""Unsupported /R or /V in encryption dictionary; R = "" + QUtil::int_to_string(R) + "" (max 6), V = "" + QUtil::int_to_string(V) + "" (max 5)""); } this->m->encryption_V = V; this->m->encryption_R = R; std::string OE; std::string UE; std::string Perms; if (V < 5) { pad_short_parameter(O, key_bytes); pad_short_parameter(U, key_bytes); if (! ((O.length() == key_bytes) && (U.length() == key_bytes))) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""incorrect length for /O and/or /U in "" ""encryption dictionary""); } } else { if (! (encryption_dict.getKey(""/OE"").isString() && encryption_dict.getKey(""/UE"").isString() && encryption_dict.getKey(""/Perms"").isString())) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""some V=5 encryption dictionary parameters are "" ""missing or the wrong type""); } OE = encryption_dict.getKey(""/OE"").getStringValue(); UE = encryption_dict.getKey(""/UE"").getStringValue(); Perms = encryption_dict.getKey(""/Perms"").getStringValue(); pad_short_parameter(O, OU_key_bytes_V5); pad_short_parameter(U, OU_key_bytes_V5); pad_short_parameter(OE, OUE_key_bytes_V5); pad_short_parameter(UE, OUE_key_bytes_V5); pad_short_parameter(Perms, Perms_key_bytes_V5); <S2SV_StartVul> if ((O.length() < OU_key_bytes_V5) || <S2SV_EndVul> <S2SV_StartVul> (U.length() < OU_key_bytes_V5) || <S2SV_EndVul> <S2SV_StartVul> (OE.length() < OUE_key_bytes_V5) || <S2SV_EndVul> <S2SV_StartVul> (UE.length() < OUE_key_bytes_V5) || <S2SV_EndVul> <S2SV_StartVul> (Perms.length() < Perms_key_bytes_V5)) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), <S2SV_EndVul> <S2SV_StartVul> ""encryption dictionary"", <S2SV_EndVul> <S2SV_StartVul> this->m->file->getLastOffset(), <S2SV_EndVul> <S2SV_StartVul> ""incorrect length for some of"" <S2SV_EndVul> <S2SV_StartVul> "" /O, /U, /OE, /UE, or /Perms in"" <S2SV_EndVul> <S2SV_StartVul> "" encryption dictionary""); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } int Length = 40; if (encryption_dict.getKey(""/Length"").isInteger()) { Length = encryption_dict.getKey(""/Length"").getIntValue(); if ((Length % 8) || (Length < 40) || (Length > 256)) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""invalid /Length value in encryption dictionary""); } } this->m->encrypt_metadata = true; if ((V >= 4) && (encryption_dict.getKey(""/EncryptMetadata"").isBool())) { this->m->encrypt_metadata = encryption_dict.getKey(""/EncryptMetadata"").getBoolValue(); } if ((V == 4) || (V == 5)) { QPDFObjectHandle CF = encryption_dict.getKey(""/CF""); std::set<std::string> keys = CF.getKeys(); for (std::set<std::string>::iterator iter = keys.begin(); iter != keys.end(); ++iter) { std::string const& filter = *iter; QPDFObjectHandle cdict = CF.getKey(filter); if (cdict.isDictionary()) { encryption_method_e method = e_none; if (cdict.getKey(""/CFM"").isName()) { std::string method_name = cdict.getKey(""/CFM"").getName(); if (method_name == ""/V2"") { QTC::TC(""qpdf"", ""QPDF_encryption CFM V2""); method = e_rc4; } else if (method_name == ""/AESV2"") { QTC::TC(""qpdf"", ""QPDF_encryption CFM AESV2""); method = e_aes; } else if (method_name == ""/AESV3"") { QTC::TC(""qpdf"", ""QPDF_encryption CFM AESV3""); method = e_aesv3; } else { method = e_unknown; } } this->m->crypt_filters[filter] = method; } } QPDFObjectHandle StmF = encryption_dict.getKey(""/StmF""); QPDFObjectHandle StrF = encryption_dict.getKey(""/StrF""); QPDFObjectHandle EFF = encryption_dict.getKey(""/EFF""); this->m->cf_stream = interpretCF(StmF); this->m->cf_string = interpretCF(StrF); if (EFF.isName()) { this->m->cf_file = interpretCF(EFF); } else { this->m->cf_file = this->m->cf_stream; } } EncryptionData data(V, R, Length / 8, P, O, U, OE, UE, Perms, id1, this->m->encrypt_metadata); if (check_owner_password( this->m->user_password, this->m->provided_password, data)) { } else if (check_user_password(this->m->provided_password, data)) { this->m->user_password = this->m->provided_password; } else { throw QPDFExc(qpdf_e_password, this->m->file->getName(), """", 0, ""invalid password""); } if (V < 5) { this->m->encryption_key = compute_encryption_key( this->m->user_password, data); } else { bool perms_valid; this->m->encryption_key = recover_encryption_key_with_password( this->m->provided_password, data, perms_valid); if (! perms_valid) { warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""/Perms field in encryption dictionary"" "" doesn't match expected value"")); } } }","- if ((O.length() < OU_key_bytes_V5) ||
- (U.length() < OU_key_bytes_V5) ||
- (OE.length() < OUE_key_bytes_V5) ||
- (UE.length() < OUE_key_bytes_V5) ||
- (Perms.length() < Perms_key_bytes_V5))
- {
- throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),
- ""encryption dictionary"",
- this->m->file->getLastOffset(),
- ""incorrect length for some of""
- "" /O, /U, /OE, /UE, or /Perms in""
- "" encryption dictionary"");
- }","QPDF::initializeEncryption() { if (this->m->encryption_initialized) { return; } this->m->encryption_initialized = true; if (! this->m->trailer.hasKey(""/Encrypt"")) { return; } this->m->encrypted = true; std::string id1; QPDFObjectHandle id_obj = this->m->trailer.getKey(""/ID""); if ((id_obj.isArray() && (id_obj.getArrayNItems() == 2) && id_obj.getArrayItem(0).isString())) { id1 = id_obj.getArrayItem(0).getStringValue(); } else { warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""trailer"", this->m->file->getLastOffset(), ""invalid /ID in trailer dictionary"")); } QPDFObjectHandle encryption_dict = this->m->trailer.getKey(""/Encrypt""); if (! encryption_dict.isDictionary()) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), this->m->last_object_description, this->m->file->getLastOffset(), ""/Encrypt in trailer dictionary is not a dictionary""); } if (! (encryption_dict.getKey(""/Filter"").isName() && (encryption_dict.getKey(""/Filter"").getName() == ""/Standard""))) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""unsupported encryption filter""); } if (! encryption_dict.getKey(""/SubFilter"").isNull()) { warn(QPDFExc(qpdf_e_unsupported, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""file uses encryption SubFilters,"" "" which qpdf does not support"")); } if (! (encryption_dict.getKey(""/V"").isInteger() && encryption_dict.getKey(""/R"").isInteger() && encryption_dict.getKey(""/O"").isString() && encryption_dict.getKey(""/U"").isString() && encryption_dict.getKey(""/P"").isInteger())) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""some encryption dictionary parameters are missing "" ""or the wrong type""); } int V = encryption_dict.getKey(""/V"").getIntValue(); int R = encryption_dict.getKey(""/R"").getIntValue(); std::string O = encryption_dict.getKey(""/O"").getStringValue(); std::string U = encryption_dict.getKey(""/U"").getStringValue(); unsigned int P = encryption_dict.getKey(""/P"").getIntValue(); if (! (((R >= 2) && (R <= 6)) && ((V == 1) || (V == 2) || (V == 4) || (V == 5)))) { throw QPDFExc(qpdf_e_unsupported, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""Unsupported /R or /V in encryption dictionary; R = "" + QUtil::int_to_string(R) + "" (max 6), V = "" + QUtil::int_to_string(V) + "" (max 5)""); } this->m->encryption_V = V; this->m->encryption_R = R; std::string OE; std::string UE; std::string Perms; if (V < 5) { pad_short_parameter(O, key_bytes); pad_short_parameter(U, key_bytes); if (! ((O.length() == key_bytes) && (U.length() == key_bytes))) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""incorrect length for /O and/or /U in "" ""encryption dictionary""); } } else { if (! (encryption_dict.getKey(""/OE"").isString() && encryption_dict.getKey(""/UE"").isString() && encryption_dict.getKey(""/Perms"").isString())) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""some V=5 encryption dictionary parameters are "" ""missing or the wrong type""); } OE = encryption_dict.getKey(""/OE"").getStringValue(); UE = encryption_dict.getKey(""/UE"").getStringValue(); Perms = encryption_dict.getKey(""/Perms"").getStringValue(); pad_short_parameter(O, OU_key_bytes_V5); pad_short_parameter(U, OU_key_bytes_V5); pad_short_parameter(OE, OUE_key_bytes_V5); pad_short_parameter(UE, OUE_key_bytes_V5); pad_short_parameter(Perms, Perms_key_bytes_V5); } int Length = 40; if (encryption_dict.getKey(""/Length"").isInteger()) { Length = encryption_dict.getKey(""/Length"").getIntValue(); if ((Length % 8) || (Length < 40) || (Length > 256)) { throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""invalid /Length value in encryption dictionary""); } } this->m->encrypt_metadata = true; if ((V >= 4) && (encryption_dict.getKey(""/EncryptMetadata"").isBool())) { this->m->encrypt_metadata = encryption_dict.getKey(""/EncryptMetadata"").getBoolValue(); } if ((V == 4) || (V == 5)) { QPDFObjectHandle CF = encryption_dict.getKey(""/CF""); std::set<std::string> keys = CF.getKeys(); for (std::set<std::string>::iterator iter = keys.begin(); iter != keys.end(); ++iter) { std::string const& filter = *iter; QPDFObjectHandle cdict = CF.getKey(filter); if (cdict.isDictionary()) { encryption_method_e method = e_none; if (cdict.getKey(""/CFM"").isName()) { std::string method_name = cdict.getKey(""/CFM"").getName(); if (method_name == ""/V2"") { QTC::TC(""qpdf"", ""QPDF_encryption CFM V2""); method = e_rc4; } else if (method_name == ""/AESV2"") { QTC::TC(""qpdf"", ""QPDF_encryption CFM AESV2""); method = e_aes; } else if (method_name == ""/AESV3"") { QTC::TC(""qpdf"", ""QPDF_encryption CFM AESV3""); method = e_aesv3; } else { method = e_unknown; } } this->m->crypt_filters[filter] = method; } } QPDFObjectHandle StmF = encryption_dict.getKey(""/StmF""); QPDFObjectHandle StrF = encryption_dict.getKey(""/StrF""); QPDFObjectHandle EFF = encryption_dict.getKey(""/EFF""); this->m->cf_stream = interpretCF(StmF); this->m->cf_string = interpretCF(StrF); if (EFF.isName()) { this->m->cf_file = interpretCF(EFF); } else { this->m->cf_file = this->m->cf_stream; } } EncryptionData data(V, R, Length / 8, P, O, U, OE, UE, Perms, id1, this->m->encrypt_metadata); if (check_owner_password( this->m->user_password, this->m->provided_password, data)) { } else if (check_user_password(this->m->provided_password, data)) { this->m->user_password = this->m->provided_password; } else { throw QPDFExc(qpdf_e_password, this->m->file->getName(), """", 0, ""invalid password""); } if (V < 5) { this->m->encryption_key = compute_encryption_key( this->m->user_password, data); } else { bool perms_valid; this->m->encryption_key = recover_encryption_key_with_password( this->m->provided_password, data, perms_valid); if (! perms_valid) { warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), ""encryption dictionary"", this->m->file->getLastOffset(), ""/Perms field in encryption dictionary"" "" doesn't match expected value"")); } } }"
315,179----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-0379--ecc.c----ecc_decrypt_raw,"ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms) { unsigned int nbits; gpg_err_code_t rc; struct pk_encoding_ctx ctx; gcry_sexp_t l1 = NULL; gcry_mpi_t data_e = NULL; ECC_secret_key sk; gcry_mpi_t mpi_g = NULL; char *curvename = NULL; mpi_ec_t ec = NULL; mpi_point_struct kG; mpi_point_struct R; gcry_mpi_t r = NULL; int flags = 0; memset (&sk, 0, sizeof sk); point_init (&kG); point_init (&R); _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT, (nbits = ecc_get_nbits (keyparms))); l1 = sexp_find_token (keyparms, ""flags"", 0); if (l1) { rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL); if (rc) goto leave; } sexp_release (l1); l1 = NULL; rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx); if (rc) goto leave; rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL); if (rc) goto leave; if (DBG_CIPHER) log_printmpi (""ecc_decrypt d_e"", data_e); if (mpi_is_opaque (data_e)) { rc = GPG_ERR_INV_DATA; goto leave; } rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"", &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n, &sk.E.h, &sk.d, NULL); if (rc) goto leave; if (mpi_g) { point_init (&sk.E.G); rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g); if (rc) goto leave; } sexp_release (l1); l1 = sexp_find_token (keyparms, ""curve"", 5); if (l1) { curvename = sexp_nth_string (l1, 1); if (curvename) { rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL); if (rc) goto leave; } } if (!curvename) { sk.E.model = MPI_EC_WEIERSTRASS; sk.E.dialect = ECC_DIALECT_STANDARD; if (!sk.E.h) sk.E.h = mpi_const (MPI_C_ONE); } if (DBG_CIPHER) { log_debug (""ecc_decrypt info: %s/%s\n"", _gcry_ecc_model2str (sk.E.model), _gcry_ecc_dialect2str (sk.E.dialect)); if (sk.E.name) log_debug (""ecc_decrypt name: %s\n"", sk.E.name); log_printmpi (""ecc_decrypt p"", sk.E.p); log_printmpi (""ecc_decrypt a"", sk.E.a); log_printmpi (""ecc_decrypt b"", sk.E.b); log_printpnt (""ecc_decrypt g"", &sk.E.G, NULL); log_printmpi (""ecc_decrypt n"", sk.E.n); log_printmpi (""ecc_decrypt h"", sk.E.h); if (!fips_mode ()) log_printmpi (""ecc_decrypt d"", sk.d); } if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d) { rc = GPG_ERR_NO_OBJ; goto leave; } ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags, sk.E.p, sk.E.a, sk.E.b); if (ec->model == MPI_EC_MONTGOMERY) rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG); else rc = _gcry_ecc_os2ec (&kG, data_e); if (rc) goto leave; if (DBG_CIPHER) log_printpnt (""ecc_decrypt kG"", &kG, NULL); <S2SV_StartVul> if (!(flags & PUBKEY_FLAG_DJB_TWEAK) <S2SV_EndVul> <S2SV_StartVul> && !_gcry_mpi_ec_curve_point (&kG, ec)) <S2SV_EndVul> { rc = GPG_ERR_INV_DATA; goto leave; y = mpi_new (0); if (_gcry_mpi_ec_get_affine (x, y, &R, ec)) { rc = GPG_ERR_INV_DATA; goto leave; } if (y) r = _gcry_ecc_ec2os (x, y, sk.E.p); else { unsigned char *rawmpi; unsigned int rawmpilen; rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1, &rawmpilen, NULL); if (!rawmpi) { rc = gpg_err_code_from_syserror (); goto leave; } else { rawmpi[0] = 0x40; rawmpilen++; r = mpi_new (0); mpi_set_opaque (r, rawmpi, rawmpilen*8); } } if (!r) rc = gpg_err_code_from_syserror (); else rc = 0; mpi_free (x); mpi_free (y); } if (DBG_CIPHER) log_printmpi (""ecc_decrypt res"", r); if (!rc) rc = sexp_build (r_plain, NULL, ""(value %m)"", r); leave: point_free (&R); point_free (&kG); _gcry_mpi_release (r); _gcry_mpi_release (sk.E.p); _gcry_mpi_release (sk.E.a); _gcry_mpi_release (sk.E.b); _gcry_mpi_release (mpi_g); point_free (&sk.E.G); _gcry_mpi_release (sk.E.n); _gcry_mpi_release (sk.E.h); _gcry_mpi_release (sk.d); _gcry_mpi_release (data_e); xfree (curvename); sexp_release (l1); _gcry_mpi_ec_free (ec); _gcry_pk_util_free_encoding_ctx (&ctx); if (DBG_CIPHER) log_debug (""ecc_decrypt => %s\n"", gpg_strerror (rc)); return rc; }","- if (!(flags & PUBKEY_FLAG_DJB_TWEAK)
- && !_gcry_mpi_ec_curve_point (&kG, ec))
+ if ((flags & PUBKEY_FLAG_DJB_TWEAK))
+ {
+ if (_gcry_mpi_ec_bad_point (&kG, ec))
+ {
+ rc = GPG_ERR_INV_DATA;
+ goto leave;
+ }
+ }
+ else if (!_gcry_mpi_ec_curve_point (&kG, ec))","ecc_decrypt_raw (gcry_sexp_t *r_plain, gcry_sexp_t s_data, gcry_sexp_t keyparms) { unsigned int nbits; gpg_err_code_t rc; struct pk_encoding_ctx ctx; gcry_sexp_t l1 = NULL; gcry_mpi_t data_e = NULL; ECC_secret_key sk; gcry_mpi_t mpi_g = NULL; char *curvename = NULL; mpi_ec_t ec = NULL; mpi_point_struct kG; mpi_point_struct R; gcry_mpi_t r = NULL; int flags = 0; memset (&sk, 0, sizeof sk); point_init (&kG); point_init (&R); _gcry_pk_util_init_encoding_ctx (&ctx, PUBKEY_OP_DECRYPT, (nbits = ecc_get_nbits (keyparms))); l1 = sexp_find_token (keyparms, ""flags"", 0); if (l1) { rc = _gcry_pk_util_parse_flaglist (l1, &flags, NULL); if (rc) goto leave; } sexp_release (l1); l1 = NULL; rc = _gcry_pk_util_preparse_encval (s_data, ecc_names, &l1, &ctx); if (rc) goto leave; rc = sexp_extract_param (l1, NULL, ""e"", &data_e, NULL); if (rc) goto leave; if (DBG_CIPHER) log_printmpi (""ecc_decrypt d_e"", data_e); if (mpi_is_opaque (data_e)) { rc = GPG_ERR_INV_DATA; goto leave; } rc = sexp_extract_param (keyparms, NULL, ""-p?a?b?g?n?h?+d"", &sk.E.p, &sk.E.a, &sk.E.b, &mpi_g, &sk.E.n, &sk.E.h, &sk.d, NULL); if (rc) goto leave; if (mpi_g) { point_init (&sk.E.G); rc = _gcry_ecc_os2ec (&sk.E.G, mpi_g); if (rc) goto leave; } sexp_release (l1); l1 = sexp_find_token (keyparms, ""curve"", 5); if (l1) { curvename = sexp_nth_string (l1, 1); if (curvename) { rc = _gcry_ecc_fill_in_curve (0, curvename, &sk.E, NULL); if (rc) goto leave; } } if (!curvename) { sk.E.model = MPI_EC_WEIERSTRASS; sk.E.dialect = ECC_DIALECT_STANDARD; if (!sk.E.h) sk.E.h = mpi_const (MPI_C_ONE); } if (DBG_CIPHER) { log_debug (""ecc_decrypt info: %s/%s\n"", _gcry_ecc_model2str (sk.E.model), _gcry_ecc_dialect2str (sk.E.dialect)); if (sk.E.name) log_debug (""ecc_decrypt name: %s\n"", sk.E.name); log_printmpi (""ecc_decrypt p"", sk.E.p); log_printmpi (""ecc_decrypt a"", sk.E.a); log_printmpi (""ecc_decrypt b"", sk.E.b); log_printpnt (""ecc_decrypt g"", &sk.E.G, NULL); log_printmpi (""ecc_decrypt n"", sk.E.n); log_printmpi (""ecc_decrypt h"", sk.E.h); if (!fips_mode ()) log_printmpi (""ecc_decrypt d"", sk.d); } if (!sk.E.p || !sk.E.a || !sk.E.b || !sk.E.G.x || !sk.E.n || !sk.E.h || !sk.d) { rc = GPG_ERR_NO_OBJ; goto leave; } ec = _gcry_mpi_ec_p_internal_new (sk.E.model, sk.E.dialect, flags, sk.E.p, sk.E.a, sk.E.b); if (ec->model == MPI_EC_MONTGOMERY) rc = _gcry_ecc_mont_decodepoint (data_e, ec, &kG); else rc = _gcry_ecc_os2ec (&kG, data_e); if (rc) goto leave; if (DBG_CIPHER) log_printpnt (""ecc_decrypt kG"", &kG, NULL); if ((flags & PUBKEY_FLAG_DJB_TWEAK)) { if (_gcry_mpi_ec_bad_point (&kG, ec)) { rc = GPG_ERR_INV_DATA; goto leave; } } else if (!_gcry_mpi_ec_curve_point (&kG, ec)) { rc = GPG_ERR_INV_DATA; goto leave; y = mpi_new (0); if (_gcry_mpi_ec_get_affine (x, y, &R, ec)) { rc = GPG_ERR_INV_DATA; goto leave; } if (y) r = _gcry_ecc_ec2os (x, y, sk.E.p); else { unsigned char *rawmpi; unsigned int rawmpilen; rawmpi = _gcry_mpi_get_buffer_extra (x, nbits/8, -1, &rawmpilen, NULL); if (!rawmpi) { rc = gpg_err_code_from_syserror (); goto leave; } else { rawmpi[0] = 0x40; rawmpilen++; r = mpi_new (0); mpi_set_opaque (r, rawmpi, rawmpilen*8); } } if (!r) rc = gpg_err_code_from_syserror (); else rc = 0; mpi_free (x); mpi_free (y); } if (DBG_CIPHER) log_printmpi (""ecc_decrypt res"", r); if (!rc) rc = sexp_build (r_plain, NULL, ""(value %m)"", r); leave: point_free (&R); point_free (&kG); _gcry_mpi_release (r); _gcry_mpi_release (sk.E.p); _gcry_mpi_release (sk.E.a); _gcry_mpi_release (sk.E.b); _gcry_mpi_release (mpi_g); point_free (&sk.E.G); _gcry_mpi_release (sk.E.n); _gcry_mpi_release (sk.E.h); _gcry_mpi_release (sk.d); _gcry_mpi_release (data_e); xfree (curvename); sexp_release (l1); _gcry_mpi_ec_free (ec); _gcry_pk_util_free_encoding_ctx (&ctx); if (DBG_CIPHER) log_debug (""ecc_decrypt => %s\n"", gpg_strerror (rc)); return rc; }"
316,913----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-7441--nbd-server.c----serveloop,"void serveloop(GArray* servers) { struct sockaddr_storage addrin; socklen_t addrinlen=sizeof(addrin); int i; int max; fd_set mset; fd_set rset; max=0; FD_ZERO(&mset); for(i=0;i<servers->len;i++) { int sock; if((sock=(g_array_index(servers, SERVER, i)).socket) >= 0) { FD_SET(sock, &mset); max=sock>max?sock:max; } } for(i=0;i<modernsocks->len;i++) { int sock = g_array_index(modernsocks, int, i); FD_SET(sock, &mset); max=sock>max?sock:max; } for(;;) { if (is_sighup_caught) { int n; GError *gerror = NULL; msg(LOG_INFO, ""reconfiguration request received""); is_sighup_caught = 0; n = append_new_servers(servers, &gerror); if (n == -1) msg(LOG_ERR, ""failed to append new servers: %s"", gerror->message); for (i = servers->len - n; i < servers->len; ++i) { const SERVER server = g_array_index(servers, SERVER, i); if (server.socket >= 0) { FD_SET(server.socket, &mset); max = server.socket > max ? server.socket : max; } msg(LOG_INFO, ""reconfigured new server: %s"", server.servename); } } memcpy(&rset, &mset, sizeof(fd_set)); if(select(max+1, &rset, NULL, NULL, NULL)>0) { <S2SV_StartVul> int net; <S2SV_EndVul> DEBUG(""accept, ""); for(i=0; i < modernsocks->len; i++) { int sock = g_array_index(modernsocks, int, i); if(!FD_ISSET(sock, &rset)) { continue; } <S2SV_StartVul> CLIENT *client; <S2SV_EndVul> <S2SV_StartVul> if((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) { <S2SV_EndVul> <S2SV_StartVul> err_nonfatal(""accept: %m""); <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN); <S2SV_EndVul> <S2SV_StartVul> if(!client) { <S2SV_EndVul> <S2SV_StartVul> close(net); <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> handle_connection(servers, net, client->server, client); <S2SV_EndVul> } for(i=0; i < servers->len; i++) { SERVER *serve; serve=&(g_array_index(servers, SERVER, i)); if(serve->socket < 0) { continue; } if(FD_ISSET(serve->socket, &rset)) { if ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0) { err_nonfatal(""accept: %m""); continue; } handle_connection(servers, net, serve, NULL); } } } } }","- int net;
- CLIENT *client;
- if((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {
- err_nonfatal(""accept: %m"");
- continue;
- }
- client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);
- if(!client) {
- close(net);
- continue;
- }
- handle_connection(servers, net, client->server, client);
+ handle_modern_connection(servers, sock);
+ int net;","void serveloop(GArray* servers) { struct sockaddr_storage addrin; socklen_t addrinlen=sizeof(addrin); int i; int max; fd_set mset; fd_set rset; max=0; FD_ZERO(&mset); for(i=0;i<servers->len;i++) { int sock; if((sock=(g_array_index(servers, SERVER, i)).socket) >= 0) { FD_SET(sock, &mset); max=sock>max?sock:max; } } for(i=0;i<modernsocks->len;i++) { int sock = g_array_index(modernsocks, int, i); FD_SET(sock, &mset); max=sock>max?sock:max; } for(;;) { if (is_sighup_caught) { int n; GError *gerror = NULL; msg(LOG_INFO, ""reconfiguration request received""); is_sighup_caught = 0; n = append_new_servers(servers, &gerror); if (n == -1) msg(LOG_ERR, ""failed to append new servers: %s"", gerror->message); for (i = servers->len - n; i < servers->len; ++i) { const SERVER server = g_array_index(servers, SERVER, i); if (server.socket >= 0) { FD_SET(server.socket, &mset); max = server.socket > max ? server.socket : max; } msg(LOG_INFO, ""reconfigured new server: %s"", server.servename); } } memcpy(&rset, &mset, sizeof(fd_set)); if(select(max+1, &rset, NULL, NULL, NULL)>0) { DEBUG(""accept, ""); for(i=0; i < modernsocks->len; i++) { int sock = g_array_index(modernsocks, int, i); if(!FD_ISSET(sock, &rset)) { continue; } handle_modern_connection(servers, sock); } for(i=0; i < servers->len; i++) { int net; SERVER *serve; serve=&(g_array_index(servers, SERVER, i)); if(serve->socket < 0) { continue; } if(FD_ISSET(serve->socket, &rset)) { if ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0) { err_nonfatal(""accept: %m""); continue; } handle_connection(servers, net, serve, NULL); } } } } }"
317,4931----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rose_timer.c----rose_start_idletimer,void rose_start_idletimer(struct sock *sk) { struct rose_sock *rose = rose_sk(sk); <S2SV_StartVul> del_timer(&rose->idletimer); <S2SV_EndVul> if (rose->idle > 0) { rose->idletimer.function = rose_idletimer_expiry; rose->idletimer.expires = jiffies + rose->idle; <S2SV_StartVul> add_timer(&rose->idletimer); <S2SV_EndVul> } },"- del_timer(&rose->idletimer);
- add_timer(&rose->idletimer);
+ sk_stop_timer(sk, &rose->idletimer);
+ sk_reset_timer(sk, &rose->idletimer, rose->idletimer.expires);","void rose_start_idletimer(struct sock *sk) { struct rose_sock *rose = rose_sk(sk); sk_stop_timer(sk, &rose->idletimer); if (rose->idle > 0) { rose->idletimer.function = rose_idletimer_expiry; rose->idletimer.expires = jiffies + rose->idle; sk_reset_timer(sk, &rose->idletimer, rose->idletimer.expires); } }"
318,7476----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/decoding.c----DDGifSlurp,"void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) { GifRecordType RecordType; GifByteType *ExtData; int ExtFunction; GifFileType *gifFilePtr; gifFilePtr = info->gifFilePtr; uint_fast32_t lastAllocatedGCBIndex = 0; do { if (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) { break; } bool isInitialPass = !decode && !exitAfterFrame; switch (RecordType) { case IMAGE_DESC_RECORD_TYPE: if (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) { break; } if (isInitialPass) { int_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth; int_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight; if (widthOverflow > 0 || heightOverflow > 0) { gifFilePtr->SWidth += widthOverflow; gifFilePtr->SHeight += heightOverflow; } SavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1]; int_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight; if (topOverflow > 0) { sp->ImageDesc.Top -= topOverflow; } int_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth; if (leftOverflow > 0) { sp->ImageDesc.Left -= leftOverflow; } if (!updateGCB(info, &lastAllocatedGCBIndex)) { break; } } if (decode) { <S2SV_StartVul> int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth; <S2SV_EndVul> <S2SV_StartVul> int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight; <S2SV_EndVul> const uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height; if (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) { void *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType)); if (tmpRasterBits == NULL) { gifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM; break; } info->rasterBits = tmpRasterBits; info->rasterSize = newRasterSize; } if (gifFilePtr->Image.Interlace) { uint_fast16_t i, j; uint_fast8_t InterlacedOffset[] = {0, 4, 2, 1}; uint_fast8_t InterlacedJumps[] = {8, 8, 4, 2}; for (i = 0; i < 4; i++) for (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) { if (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR) break; } } else { if (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) { break; } } if (info->sampleSize > 1) { unsigned char *dst = info->rasterBits; unsigned char *src = info->rasterBits; unsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height; do { unsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize; unsigned char *const srcEndLine = src + gifFilePtr->Image.Width; unsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize; do { *dst = *src; dst++; src += info->sampleSize; } while (src < srcEndLine); dst = dstEndLine; src = srcNextLineStart; } while (src < srcEndImage); } return; } else { do { if (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) { break; } } while (ExtData != NULL); if (exitAfterFrame) { return; } } break; case EXTENSION_RECORD_TYPE: if (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) { break; } if (isInitialPass) { updateGCB(info, &lastAllocatedGCBIndex); if (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) { break; } } while (ExtData != NULL) { if (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) { break; } if (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) { break; } } break; case TERMINATE_RECORD_TYPE: break; default: break; } } while (RecordType != TERMINATE_RECORD_TYPE); info->rewindFunction(info); }","- int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;
- int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;
+ if (newRasterSize == 0) {
+ free(info->rasterBits);
+ info->rasterBits = NULL;
+ info->rasterSize = newRasterSize;
+ return;
+ }
+ const int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;
+ const int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;","void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) { GifRecordType RecordType; GifByteType *ExtData; int ExtFunction; GifFileType *gifFilePtr; gifFilePtr = info->gifFilePtr; uint_fast32_t lastAllocatedGCBIndex = 0; do { if (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) { break; } bool isInitialPass = !decode && !exitAfterFrame; switch (RecordType) { case IMAGE_DESC_RECORD_TYPE: if (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) { break; } if (isInitialPass) { int_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth; int_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight; if (widthOverflow > 0 || heightOverflow > 0) { gifFilePtr->SWidth += widthOverflow; gifFilePtr->SHeight += heightOverflow; } SavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1]; int_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight; if (topOverflow > 0) { sp->ImageDesc.Top -= topOverflow; } int_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth; if (leftOverflow > 0) { sp->ImageDesc.Left -= leftOverflow; } if (!updateGCB(info, &lastAllocatedGCBIndex)) { break; } } if (decode) { const uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height; if (newRasterSize == 0) { free(info->rasterBits); info->rasterBits = NULL; info->rasterSize = newRasterSize; return; } const int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth; const int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight; if (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) { void *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType)); if (tmpRasterBits == NULL) { gifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM; break; } info->rasterBits = tmpRasterBits; info->rasterSize = newRasterSize; } if (gifFilePtr->Image.Interlace) { uint_fast16_t i, j; uint_fast8_t InterlacedOffset[] = {0, 4, 2, 1}; uint_fast8_t InterlacedJumps[] = {8, 8, 4, 2}; for (i = 0; i < 4; i++) for (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) { if (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR) break; } } else { if (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) { break; } } if (info->sampleSize > 1) { unsigned char *dst = info->rasterBits; unsigned char *src = info->rasterBits; unsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height; do { unsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize; unsigned char *const srcEndLine = src + gifFilePtr->Image.Width; unsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize; do { *dst = *src; dst++; src += info->sampleSize; } while (src < srcEndLine); dst = dstEndLine; src = srcNextLineStart; } while (src < srcEndImage); } return; } else { do { if (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) { break; } } while (ExtData != NULL); if (exitAfterFrame) { return; } } break; case EXTENSION_RECORD_TYPE: if (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) { break; } if (isInitialPass) { updateGCB(info, &lastAllocatedGCBIndex); if (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) { break; } } while (ExtData != NULL) { if (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) { break; } if (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) { break; } } break; case TERMINATE_RECORD_TYPE: break; default: break; } } while (RecordType != TERMINATE_RECORD_TYPE); info->rewindFunction(info); }"
319,6570----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/llcp_core.c----nfc_llcp_build_gb,"static int nfc_llcp_build_gb(struct nfc_llcp_local *local) { <S2SV_StartVul> u8 *gb_cur, *version_tlv, version, version_length; <S2SV_EndVul> <S2SV_StartVul> u8 *lto_tlv, lto_length; <S2SV_EndVul> <S2SV_StartVul> u8 *wks_tlv, wks_length; <S2SV_EndVul> <S2SV_StartVul> u8 *miux_tlv, miux_length; <S2SV_EndVul> __be16 wks = cpu_to_be16(local->local_wks); u8 gb_len = 0; int ret = 0; version = LLCP_VERSION_11; version_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version, 1, &version_length); gb_len += version_length; lto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length); gb_len += lto_length; pr_debug(""Local wks 0x%lx\n"", local->local_wks); wks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length); gb_len += wks_length; miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0, &miux_length); gb_len += miux_length; gb_len += ARRAY_SIZE(llcp_magic); if (gb_len > NFC_MAX_GT_LEN) { ret = -EINVAL; goto out; } gb_cur = local->gb; memcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic)); gb_cur += ARRAY_SIZE(llcp_magic); memcpy(gb_cur, version_tlv, version_length); gb_cur += version_length; memcpy(gb_cur, lto_tlv, lto_length); gb_cur += lto_length; memcpy(gb_cur, wks_tlv, wks_length); gb_cur += wks_length; memcpy(gb_cur, miux_tlv, miux_length); gb_cur += miux_length; local->gb_len = gb_len; out: kfree(version_tlv); kfree(lto_tlv); kfree(wks_tlv); kfree(miux_tlv); return ret; }","- u8 *gb_cur, *version_tlv, version, version_length;
- u8 *lto_tlv, lto_length;
- u8 *wks_tlv, wks_length;
- u8 *miux_tlv, miux_length;
+ u8 *gb_cur, version, version_length;
+ u8 lto_length, wks_length, miux_length;
+ u8 *version_tlv = NULL, *lto_tlv = NULL,
+ if (!version_tlv) {
+ ret = -ENOMEM;
+ goto out;
+ }
+ if (!lto_tlv) {
+ ret = -ENOMEM;
+ goto out;
+ }
+ if (!wks_tlv) {
+ ret = -ENOMEM;
+ goto out;
+ }
+ if (!miux_tlv) {
+ ret = -ENOMEM;
+ goto out;
+ }","static int nfc_llcp_build_gb(struct nfc_llcp_local *local) { u8 *gb_cur, version, version_length; u8 lto_length, wks_length, miux_length; u8 *version_tlv = NULL, *lto_tlv = NULL, *wks_tlv = NULL, *miux_tlv = NULL; __be16 wks = cpu_to_be16(local->local_wks); u8 gb_len = 0; int ret = 0; version = LLCP_VERSION_11; version_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version, 1, &version_length); if (!version_tlv) { ret = -ENOMEM; goto out; } gb_len += version_length; lto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length); if (!lto_tlv) { ret = -ENOMEM; goto out; } gb_len += lto_length; pr_debug(""Local wks 0x%lx\n"", local->local_wks); wks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length); if (!wks_tlv) { ret = -ENOMEM; goto out; } gb_len += wks_length; miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0, &miux_length); if (!miux_tlv) { ret = -ENOMEM; goto out; } gb_len += miux_length; gb_len += ARRAY_SIZE(llcp_magic); if (gb_len > NFC_MAX_GT_LEN) { ret = -EINVAL; goto out; } gb_cur = local->gb; memcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic)); gb_cur += ARRAY_SIZE(llcp_magic); memcpy(gb_cur, version_tlv, version_length); gb_cur += version_length; memcpy(gb_cur, lto_tlv, lto_length); gb_cur += lto_length; memcpy(gb_cur, wks_tlv, wks_length); gb_cur += wks_length; memcpy(gb_cur, miux_tlv, miux_length); gb_cur += miux_length; local->gb_len = gb_len; out: kfree(version_tlv); kfree(lto_tlv); kfree(wks_tlv); kfree(miux_tlv); return ret; }"
320,3668----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/usercmd.c----get_user_commands,"get_user_commands(expand_T *xp UNUSED, int idx) { <S2SV_StartVul> buf_T *buf = <S2SV_EndVul> <S2SV_StartVul> #ifdef FEAT_CMDWIN <S2SV_EndVul> <S2SV_StartVul> is_in_cmdwin() ? prevwin->w_buffer : <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> <S2SV_StartVul> curbuf; <S2SV_EndVul> if (idx < buf->b_ucmds.ga_len) return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name; idx -= buf->b_ucmds.ga_len; if (idx < ucmds.ga_len) return USER_CMD(idx)->uc_name; return NULL; }","- buf_T *buf =
- #ifdef FEAT_CMDWIN
- is_in_cmdwin() ? prevwin->w_buffer :
- #endif
- curbuf;
+ buf_T *buf = prevwin_curwin()->w_buffer;","get_user_commands(expand_T *xp UNUSED, int idx) { buf_T *buf = prevwin_curwin()->w_buffer; if (idx < buf->b_ucmds.ga_len) return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name; idx -= buf->b_ucmds.ga_len; if (idx < ucmds.ga_len) return USER_CMD(idx)->uc_name; return NULL; }"
321,5113----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/var_unserializer.c----process_nested_data,"static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops) { while (elements-- > 0) { zval *key, *data, **old_data; ALLOC_INIT_ZVAL(key); if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); return 0; } if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) { zval_dtor(key); FREE_ZVAL(key); return 0; } ALLOC_INIT_ZVAL(data); if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); zval_dtor(data); FREE_ZVAL(data); return 0; } if (!objprops) { switch (Z_TYPE_P(key)) { case IS_LONG: if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL); break; case IS_STRING: if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL); break; } } else { convert_to_string(key); <S2SV_StartVul> if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { <S2SV_EndVul> var_push_dtor(var_hash, old_data); } zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof data, NULL); } zval_dtor(key); FREE_ZVAL(key); if (elements && *(*p-1) != ';' && *(*p-1) != '}') { (*p)--; return 0; } } return 1; }","- if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
+ if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {","static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops) { while (elements-- > 0) { zval *key, *data, **old_data; ALLOC_INIT_ZVAL(key); if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); return 0; } if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) { zval_dtor(key); FREE_ZVAL(key); return 0; } ALLOC_INIT_ZVAL(data); if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); zval_dtor(data); FREE_ZVAL(data); return 0; } if (!objprops) { switch (Z_TYPE_P(key)) { case IS_LONG: if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL); break; case IS_STRING: if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL); break; } } else { convert_to_string(key); if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof data, NULL); } zval_dtor(key); FREE_ZVAL(key); if (elements && *(*p-1) != ';' && *(*p-1) != '}') { (*p)--; return 0; } } return 1; }"
322,5419----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/yurex.c----yurex_read,"static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos) { struct usb_yurex *dev; <S2SV_StartVul> int retval = 0; <S2SV_EndVul> <S2SV_StartVul> int bytes_read = 0; <S2SV_EndVul> char in_buffer[20]; unsigned long flags; dev = file->private_data; mutex_lock(&dev->io_mutex); if (!dev->interface) { <S2SV_StartVul> retval = -ENODEV; <S2SV_EndVul> <S2SV_StartVul> goto exit; <S2SV_EndVul> } spin_lock_irqsave(&dev->lock, flags); <S2SV_StartVul> bytes_read = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu); <S2SV_EndVul> spin_unlock_irqrestore(&dev->lock, flags); <S2SV_StartVul> if (*ppos < bytes_read) { <S2SV_EndVul> <S2SV_StartVul> if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos)) <S2SV_EndVul> <S2SV_StartVul> retval = -EFAULT; <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_EndVul> <S2SV_StartVul> retval = bytes_read - *ppos; <S2SV_EndVul> <S2SV_StartVul> *ppos += bytes_read; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> exit: <S2SV_EndVul> mutex_unlock(&dev->io_mutex); <S2SV_StartVul> return retval; <S2SV_EndVul> }","- int retval = 0;
- int bytes_read = 0;
- retval = -ENODEV;
- goto exit;
- bytes_read = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
- if (*ppos < bytes_read) {
- if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))
- retval = -EFAULT;
- else {
- retval = bytes_read - *ppos;
- }
- }
- exit:
- return retval;
+ int len = 0;
+ mutex_unlock(&dev->io_mutex);
+ return -ENODEV;
+ len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
+ return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);","static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos) { struct usb_yurex *dev; int len = 0; char in_buffer[20]; unsigned long flags; dev = file->private_data; mutex_lock(&dev->io_mutex); if (!dev->interface) { mutex_unlock(&dev->io_mutex); return -ENODEV; } spin_lock_irqsave(&dev->lock, flags); len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu); spin_unlock_irqrestore(&dev->lock, flags); mutex_unlock(&dev->io_mutex); return simple_read_from_buffer(buffer, count, ppos, in_buffer, len); }"
323,119----CWE-310----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2143--crypt-des.c----px_crypt_des,"px_crypt_des(const char *key, const char *setting) { int i; uint32 count, salt, l, r0, r1, keybuf[2]; char *p; uint8 *q; static char output[21]; if (!des_initialised) des_init(); q = (uint8 *) keybuf; while (q - (uint8 *) keybuf - 8) { <S2SV_StartVul> if ((*q++ = *key << 1)) <S2SV_EndVul> key++; } if (des_setkey((char *) keybuf)) #ifndef DISABLE_XDES if (*setting == _PASSWORD_EFMT1) { for (i = 1, count = 0L; i < 5; i++) count |= ascii_to_bin(setting[i]) << (i - 1) * 6; for (i = 5, salt = 0L; i < 9; i++) salt |= ascii_to_bin(setting[i]) << (i - 5) * 6; while (*key) { if (des_cipher((char *) keybuf, (char *) keybuf, 0L, 1)) return (NULL); q = (uint8 *) keybuf; while (q - (uint8 *) keybuf - 8 && *key) *q++ ^= *key++ << 1; if (des_setkey((char *) keybuf)) return (NULL); } strncpy(output, setting, 9); output[9] = '\0'; p = output + strlen(output); } else #endif { count = 25; salt = (ascii_to_bin(setting[1]) << 6) | ascii_to_bin(setting[0]); output[0] = setting[0]; output[1] = setting[1] ? setting[1] : output[0]; p = output + 2; } setup_salt(salt); if (do_des(0L, 0L, &r0, &r1, count)) return (NULL); l = (r0 >> 8); *p++ = _crypt_a64[(l >> 18) & 0x3f]; *p++ = _crypt_a64[(l >> 12) & 0x3f]; *p++ = _crypt_a64[(l >> 6) & 0x3f]; *p++ = _crypt_a64[l & 0x3f]; l = (r0 << 16) | ((r1 >> 16) & 0xffff); *p++ = _crypt_a64[(l >> 18) & 0x3f]; *p++ = _crypt_a64[(l >> 12) & 0x3f]; *p++ = _crypt_a64[(l >> 6) & 0x3f]; *p++ = _crypt_a64[l & 0x3f]; l = r1 << 2; *p++ = _crypt_a64[(l >> 12) & 0x3f]; *p++ = _crypt_a64[(l >> 6) & 0x3f]; *p++ = _crypt_a64[l & 0x3f]; *p = 0; return (output); }","- if ((*q++ = *key << 1))
+ if (*key != '\0')","px_crypt_des(const char *key, const char *setting) { int i; uint32 count, salt, l, r0, r1, keybuf[2]; char *p; uint8 *q; static char output[21]; if (!des_initialised) des_init(); q = (uint8 *) keybuf; while (q - (uint8 *) keybuf - 8) { *q++ = *key << 1; if (*key != '\0') key++; } if (des_setkey((char *) keybuf)) #ifndef DISABLE_XDES if (*setting == _PASSWORD_EFMT1) { for (i = 1, count = 0L; i < 5; i++) count |= ascii_to_bin(setting[i]) << (i - 1) * 6; for (i = 5, salt = 0L; i < 9; i++) salt |= ascii_to_bin(setting[i]) << (i - 5) * 6; while (*key) { if (des_cipher((char *) keybuf, (char *) keybuf, 0L, 1)) return (NULL); q = (uint8 *) keybuf; while (q - (uint8 *) keybuf - 8 && *key) *q++ ^= *key++ << 1; if (des_setkey((char *) keybuf)) return (NULL); } strncpy(output, setting, 9); output[9] = '\0'; p = output + strlen(output); } else #endif { count = 25; salt = (ascii_to_bin(setting[1]) << 6) | ascii_to_bin(setting[0]); output[0] = setting[0]; output[1] = setting[1] ? setting[1] : output[0]; p = output + 2; } setup_salt(salt); if (do_des(0L, 0L, &r0, &r1, count)) return (NULL); l = (r0 >> 8); *p++ = _crypt_a64[(l >> 18) & 0x3f]; *p++ = _crypt_a64[(l >> 12) & 0x3f]; *p++ = _crypt_a64[(l >> 6) & 0x3f]; *p++ = _crypt_a64[l & 0x3f]; l = (r0 << 16) | ((r1 >> 16) & 0xffff); *p++ = _crypt_a64[(l >> 18) & 0x3f]; *p++ = _crypt_a64[(l >> 12) & 0x3f]; *p++ = _crypt_a64[(l >> 6) & 0x3f]; *p++ = _crypt_a64[l & 0x3f]; l = r1 << 2; *p++ = _crypt_a64[(l >> 12) & 0x3f]; *p++ = _crypt_a64[(l >> 6) & 0x3f]; *p++ = _crypt_a64[l & 0x3f]; *p = 0; return (output); }"
324,3543----CWE-284----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs3acl.c----nfsd3_proc_setacl,"static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp, struct nfsd3_setaclargs *argp, struct nfsd3_attrstat *resp) { struct inode *inode; svc_fh *fh; __be32 nfserr = 0; int error; fh = fh_copy(&resp->fh, &argp->fh); nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR); if (nfserr) goto out; inode = d_inode(fh->fh_dentry); <S2SV_StartVul> if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) { <S2SV_EndVul> <S2SV_StartVul> error = -EOPNOTSUPP; <S2SV_EndVul> <S2SV_StartVul> goto out_errno; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> error = fh_want_write(fh); if (error) goto out_errno; <S2SV_StartVul> error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS); <S2SV_EndVul> if (error) <S2SV_StartVul> goto out_drop_write; <S2SV_EndVul> <S2SV_StartVul> error = inode->i_op->set_acl(inode, argp->acl_default, <S2SV_EndVul> <S2SV_StartVul> ACL_TYPE_DEFAULT); <S2SV_EndVul> <S2SV_StartVul> out_drop_write: <S2SV_EndVul> fh_drop_write(fh); out_errno: nfserr = nfserrno(error); out: posix_acl_release(argp->acl_access); posix_acl_release(argp->acl_default); RETURN_STATUS(nfserr); }","- if (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {
- error = -EOPNOTSUPP;
- goto out_errno;
- }
- error = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);
- goto out_drop_write;
- error = inode->i_op->set_acl(inode, argp->acl_default,
- ACL_TYPE_DEFAULT);
- out_drop_write:
+ fh_lock(fh);
+ error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);
+ goto out_drop_lock;
+ error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);
+ out_drop_lock:
+ fh_unlock(fh);","static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp, struct nfsd3_setaclargs *argp, struct nfsd3_attrstat *resp) { struct inode *inode; svc_fh *fh; __be32 nfserr = 0; int error; fh = fh_copy(&resp->fh, &argp->fh); nfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR); if (nfserr) goto out; inode = d_inode(fh->fh_dentry); error = fh_want_write(fh); if (error) goto out_errno; fh_lock(fh); error = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access); if (error) goto out_drop_lock; error = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default); out_drop_lock: fh_unlock(fh); fh_drop_write(fh); out_errno: nfserr = nfserrno(error); out: posix_acl_release(argp->acl_access); posix_acl_release(argp->acl_default); RETURN_STATUS(nfserr); }"
325,2007----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-13006--box_code_base.c----urn_Read,"GF_Err urn_Read(GF_Box *s, GF_BitStream *bs) { u32 i, to_read; char *tmpName; GF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s; if (! ptr->size ) return GF_OK; to_read = (u32) ptr->size; tmpName = (char*)gf_malloc(sizeof(char) * to_read); if (!tmpName) return GF_OUT_OF_MEM; gf_bs_read_data(bs, tmpName, to_read); i = 0; while ( (tmpName[i] != 0) && (i < to_read) ) { i++; } <S2SV_StartVul> if (i == to_read) { <S2SV_EndVul> gf_free(tmpName); return GF_ISOM_INVALID_FILE; } if (i == to_read - 1) { ptr->nameURN = tmpName; ptr->location = NULL; return GF_OK; } ptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1)); if (!ptr->nameURN) { gf_free(tmpName); return GF_OUT_OF_MEM; } ptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1)); if (!ptr->location) { gf_free(tmpName); gf_free(ptr->nameURN); ptr->nameURN = NULL; return GF_OUT_OF_MEM; } memcpy(ptr->nameURN, tmpName, i + 1); memcpy(ptr->location, tmpName + i + 1, (to_read - i - 1)); gf_free(tmpName); return GF_OK; }","- if (i == to_read) {
+ if (i == to_read) {","GF_Err urn_Read(GF_Box *s, GF_BitStream *bs) { u32 i, to_read; char *tmpName; GF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s; if (! ptr->size ) return GF_OK; to_read = (u32) ptr->size; tmpName = (char*)gf_malloc(sizeof(char) * to_read); if (!tmpName) return GF_OUT_OF_MEM; gf_bs_read_data(bs, tmpName, to_read); i = 0; while ( (i < to_read) && (tmpName[i] != 0) ) { i++; } if (i == to_read) { gf_free(tmpName); return GF_ISOM_INVALID_FILE; } if (i == to_read - 1) { ptr->nameURN = tmpName; ptr->location = NULL; return GF_OK; } ptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1)); if (!ptr->nameURN) { gf_free(tmpName); return GF_OUT_OF_MEM; } ptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1)); if (!ptr->location) { gf_free(tmpName); gf_free(ptr->nameURN); ptr->nameURN = NULL; return GF_OUT_OF_MEM; } memcpy(ptr->nameURN, tmpName, i + 1); memcpy(ptr->location, tmpName + i + 1, (to_read - i - 1)); gf_free(tmpName); return GF_OK; }"
326,123----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4353--ber-decoder.c----pop_decoder_state,"pop_decoder_state (DECODER_STATE ds) { if (!ds->idx) { <S2SV_StartVul> fprintf (stderr, ""ERROR: decoder stack underflow!\n""); <S2SV_EndVul> <S2SV_StartVul> abort (); <S2SV_EndVul> } ds->cur = ds->stack[--ds->idx]; }","- fprintf (stderr, ""ERROR: decoder stack underflow!\n"");
- abort ();
+ fprintf (stderr, ""ksba: ber-decoder: stack underflow!\n"");
+ return gpg_error (GPG_ERR_INTERNAL);
+ return 0;","pop_decoder_state (DECODER_STATE ds) { if (!ds->idx) { fprintf (stderr, ""ksba: ber-decoder: stack underflow!\n""); return gpg_error (GPG_ERR_INTERNAL); } ds->cur = ds->stack[--ds->idx]; return 0; }"
327,5289----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/adis_buffer.c----adis_update_scan_mode_burst,"static int adis_update_scan_mode_burst(struct iio_dev *indio_dev, const unsigned long *scan_mask) { struct adis *adis = iio_device_get_drvdata(indio_dev); unsigned int burst_length; u8 *tx; burst_length = (indio_dev->num_channels - 1) * sizeof(u16); burst_length += adis->burst->extra_len; adis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL); if (!adis->xfer) return -ENOMEM; adis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL); <S2SV_StartVul> if (!adis->buffer) <S2SV_EndVul> return -ENOMEM; tx = adis->buffer + burst_length; tx[0] = ADIS_READ_REG(adis->burst->reg_cmd); tx[1] = 0; adis->xfer[0].tx_buf = tx; adis->xfer[0].bits_per_word = 8; adis->xfer[0].len = 2; adis->xfer[1].rx_buf = adis->buffer; adis->xfer[1].bits_per_word = 8; adis->xfer[1].len = burst_length; spi_message_init(&adis->msg); spi_message_add_tail(&adis->xfer[0], &adis->msg); spi_message_add_tail(&adis->xfer[1], &adis->msg); return 0; }","- if (!adis->buffer)
+ if (!adis->buffer) {
+ kfree(adis->xfer);
+ adis->xfer = NULL;
+ }","static int adis_update_scan_mode_burst(struct iio_dev *indio_dev, const unsigned long *scan_mask) { struct adis *adis = iio_device_get_drvdata(indio_dev); unsigned int burst_length; u8 *tx; burst_length = (indio_dev->num_channels - 1) * sizeof(u16); burst_length += adis->burst->extra_len; adis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL); if (!adis->xfer) return -ENOMEM; adis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL); if (!adis->buffer) { kfree(adis->xfer); adis->xfer = NULL; return -ENOMEM; } tx = adis->buffer + burst_length; tx[0] = ADIS_READ_REG(adis->burst->reg_cmd); tx[1] = 0; adis->xfer[0].tx_buf = tx; adis->xfer[0].bits_per_word = 8; adis->xfer[0].len = 2; adis->xfer[1].rx_buf = adis->buffer; adis->xfer[1].bits_per_word = 8; adis->xfer[1].len = burst_length; spi_message_init(&adis->msg); spi_message_add_tail(&adis->xfer[0], &adis->msg); spi_message_add_tail(&adis->xfer[1], &adis->msg); return 0; }"
328,6547----CWE-667----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ds_xbstream.cc----xbstream_open,"xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat) { ds_file_t *file; ds_stream_file_t *stream_file; ds_stream_ctxt_t *stream_ctxt; ds_ctxt_t *dest_ctxt; xb_wstream_t *xbstream; xb_wstream_file_t *xbstream_file; xb_ad(ctxt->pipe_ctxt != NULL); dest_ctxt = ctxt->pipe_ctxt; stream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr; pthread_mutex_lock(&stream_ctxt->mutex); if (stream_ctxt->dest_file == NULL) { stream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat); <S2SV_StartVul> if (stream_ctxt->dest_file == NULL) { <S2SV_EndVul> <S2SV_StartVul> return NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } pthread_mutex_unlock(&stream_ctxt->mutex); file = (ds_file_t *) my_malloc(sizeof(ds_file_t) + sizeof(ds_stream_file_t), MYF(MY_FAE)); stream_file = (ds_stream_file_t *) (file + 1); xbstream = stream_ctxt->xbstream; xbstream_file = xb_stream_write_open(xbstream, path, mystat, stream_ctxt, my_xbstream_write_callback); if (xbstream_file == NULL) { msg(""xb_stream_write_open() failed.""); goto err; } stream_file->xbstream_file = xbstream_file; stream_file->stream_ctxt = stream_ctxt; file->ptr = stream_file; file->path = stream_ctxt->dest_file->path; return file; err: if (stream_ctxt->dest_file) { ds_close(stream_ctxt->dest_file); stream_ctxt->dest_file = NULL; } my_free(file); return NULL; }","- if (stream_ctxt->dest_file == NULL) {
- return NULL;
- }
+ if (stream_ctxt->dest_file == NULL) {
+ return NULL;
+ }
+ if (!file) {
+ msg(""my_malloc() failed."");
+ goto err;
+ }","xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat) { ds_file_t *file; ds_stream_file_t *stream_file; ds_stream_ctxt_t *stream_ctxt; ds_ctxt_t *dest_ctxt; xb_wstream_t *xbstream; xb_wstream_file_t *xbstream_file; xb_ad(ctxt->pipe_ctxt != NULL); dest_ctxt = ctxt->pipe_ctxt; stream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr; pthread_mutex_lock(&stream_ctxt->mutex); if (stream_ctxt->dest_file == NULL) { stream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat); } pthread_mutex_unlock(&stream_ctxt->mutex); if (stream_ctxt->dest_file == NULL) { return NULL; } file = (ds_file_t *) my_malloc(sizeof(ds_file_t) + sizeof(ds_stream_file_t), MYF(MY_FAE)); if (!file) { msg(""my_malloc() failed.""); goto err; } stream_file = (ds_stream_file_t *) (file + 1); xbstream = stream_ctxt->xbstream; xbstream_file = xb_stream_write_open(xbstream, path, mystat, stream_ctxt, my_xbstream_write_callback); if (xbstream_file == NULL) { msg(""xb_stream_write_open() failed.""); goto err; } stream_file->xbstream_file = xbstream_file; stream_file->stream_ctxt = stream_ctxt; file->ptr = stream_file; file->path = stream_ctxt->dest_file->path; return file; err: if (stream_ctxt->dest_file) { ds_close(stream_ctxt->dest_file); stream_ctxt->dest_file = NULL; } my_free(file); return NULL; }"
329,6311----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pci_core.h----pci_get_cfgdata16,"pci_get_cfgdata16(struct pci_vdev *dev, int offset) { <S2SV_StartVul> assert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0); <S2SV_EndVul> return (*(uint16_t *)(dev->cfgdata + offset)); }","- assert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);
+ if ((offset > PCI_REGMAX - 1) || (offset & 1) != 0) {
+ pr_err(""%s: out of range of PCI config space!\n"", __func__);
+ return 0xffff;
+ }","pci_get_cfgdata16(struct pci_vdev *dev, int offset) { if ((offset > PCI_REGMAX - 1) || (offset & 1) != 0) { pr_err(""%s: out of range of PCI config space!\n"", __func__); return 0xffff; } return (*(uint16_t *)(dev->cfgdata + offset)); }"
330,2287----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-13223--stb_vorbis.c----lookup1_values,"static int lookup1_values(int entries, int dim) { int r = (int) floor(exp((float) log((float) entries) / dim)); if ((int) floor(pow((float) r+1, dim)) <= entries) ++r; <S2SV_StartVul> assert(pow((float) r+1, dim) > entries); <S2SV_EndVul> <S2SV_StartVul> assert((int) floor(pow((float) r, dim)) <= entries); return r; }","- assert(pow((float) r+1, dim) > entries);
- assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above
+ if (pow((float) r+1, dim) <= entries)
+ return -1;
+ if ((int) floor(pow((float) r, dim)) > entries)
+ return -1;","static int lookup1_values(int entries, int dim) { int r = (int) floor(exp((float) log((float) entries) / dim)); if ((int) floor(pow((float) r+1, dim)) <= entries) ++r; if (pow((float) r+1, dim) <= entries) return -1; if ((int) floor(pow((float) r, dim)) > entries) return -1; return r; }"
331,6083----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/zend-string.cpp----HPHP::string_number_format,"String string_number_format(double d, int dec, const String& dec_point, const String& thousand_sep) { char *tmpbuf = nullptr, *resbuf; char *s, *t; char *dp; int integral; int tmplen, reslen=0; int count=0; int is_negative=0; if (d < 0) { is_negative = 1; d = -d; } if (dec < 0) dec = 0; d = php_math_round(d, dec); String tmpstr(63, ReserveString); tmpbuf = tmpstr.mutableData(); tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d); if (tmplen < 0) return empty_string(); <S2SV_StartVul> if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) { <S2SV_EndVul> tmpstr.setSize(tmplen); return tmpstr; } if (tmplen >= 64) { tmpstr = String(tmplen, ReserveString); tmpbuf = tmpstr.mutableData(); tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d); if (tmplen < 0) return empty_string(); if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) { tmpstr.setSize(tmplen); return tmpstr; } } if (dec) { dp = strpbrk(tmpbuf, "".,""); } else { dp = nullptr; } if (dp) { integral = dp - tmpbuf; } else { integral = tmplen; } if (!thousand_sep.empty()) { if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) { raise_error(""String overflow""); } integral += ((integral-1) / 3) * thousand_sep.size(); } reslen = integral; if (dec) { reslen += dec; if (!dec_point.empty()) { if (reslen + dec_point.size() < dec_point.size()) { raise_error(""String overflow""); } reslen += dec_point.size(); } } if (is_negative) { reslen++; } String resstr(reslen, ReserveString); resbuf = resstr.mutableData(); s = tmpbuf+tmplen-1; t = resbuf+reslen-1; if (dec) { int declen = dp ? s - dp : 0; int topad = dec > declen ? dec - declen : 0; while (topad--) { *t-- = '0'; } if (dp) { s -= declen + 1; t -= declen; memcpy(t + 1, dp + 1, declen); } if (!dec_point.empty()) { memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size()); t -= dec_point.size(); } } while(s >= tmpbuf) { *t-- = *s--; if (thousand_sep && (++count%3)==0 && s>=tmpbuf) { memcpy(t + (1 - thousand_sep.size()), thousand_sep.data(), thousand_sep.size()); t -= thousand_sep.size(); } } if (is_negative) { *t-- = '-'; } resstr.setSize(reslen); return resstr; }","- if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) {
+ if (tmplen < 64 && (tmpbuf == nullptr || !isdigit((int)tmpbuf[0]))) {","String string_number_format(double d, int dec, const String& dec_point, const String& thousand_sep) { char *tmpbuf = nullptr, *resbuf; char *s, *t; char *dp; int integral; int tmplen, reslen=0; int count=0; int is_negative=0; if (d < 0) { is_negative = 1; d = -d; } if (dec < 0) dec = 0; d = php_math_round(d, dec); String tmpstr(63, ReserveString); tmpbuf = tmpstr.mutableData(); tmplen = snprintf(tmpbuf, 64, ""%.*F"", dec, d); if (tmplen < 0) return empty_string(); if (tmplen < 64 && (tmpbuf == nullptr || !isdigit((int)tmpbuf[0]))) { tmpstr.setSize(tmplen); return tmpstr; } if (tmplen >= 64) { tmpstr = String(tmplen, ReserveString); tmpbuf = tmpstr.mutableData(); tmplen = snprintf(tmpbuf, tmplen + 1, ""%.*F"", dec, d); if (tmplen < 0) return empty_string(); if (tmpbuf == nullptr || !isdigit((int)tmpbuf[0])) { tmpstr.setSize(tmplen); return tmpstr; } } if (dec) { dp = strpbrk(tmpbuf, "".,""); } else { dp = nullptr; } if (dp) { integral = dp - tmpbuf; } else { integral = tmplen; } if (!thousand_sep.empty()) { if (integral + thousand_sep.size() * ((integral-1) / 3) < integral) { raise_error(""String overflow""); } integral += ((integral-1) / 3) * thousand_sep.size(); } reslen = integral; if (dec) { reslen += dec; if (!dec_point.empty()) { if (reslen + dec_point.size() < dec_point.size()) { raise_error(""String overflow""); } reslen += dec_point.size(); } } if (is_negative) { reslen++; } String resstr(reslen, ReserveString); resbuf = resstr.mutableData(); s = tmpbuf+tmplen-1; t = resbuf+reslen-1; if (dec) { int declen = dp ? s - dp : 0; int topad = dec > declen ? dec - declen : 0; while (topad--) { *t-- = '0'; } if (dp) { s -= declen + 1; t -= declen; memcpy(t + 1, dp + 1, declen); } if (!dec_point.empty()) { memcpy(t + (1 - dec_point.size()), dec_point.data(), dec_point.size()); t -= dec_point.size(); } } while(s >= tmpbuf) { *t-- = *s--; if (thousand_sep && (++count%3)==0 && s>=tmpbuf) { memcpy(t + (1 - thousand_sep.size()), thousand_sep.data(), thousand_sep.size()); t -= thousand_sep.size(); } } if (is_negative) { *t-- = '-'; } resstr.setSize(reslen); return resstr; }"
332,3996----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gup.c----follow_page_pte,"static struct page *follow_page_pte(struct vm_area_struct *vma, unsigned long address, pmd_t *pmd, unsigned int flags, struct dev_pagemap **pgmap) { struct mm_struct *mm = vma->vm_mm; struct page *page; spinlock_t *ptl; pte_t *ptep, pte; retry: if (unlikely(pmd_bad(*pmd))) return no_page_table(vma, flags); ptep = pte_offset_map_lock(mm, pmd, address, &ptl); pte = *ptep; if (!pte_present(pte)) { swp_entry_t entry; if (likely(!(flags & FOLL_MIGRATION))) goto no_page; if (pte_none(pte)) goto no_page; entry = pte_to_swp_entry(pte); if (!is_migration_entry(entry)) goto no_page; pte_unmap_unlock(ptep, ptl); migration_entry_wait(mm, pmd, address); goto retry; } if ((flags & FOLL_NUMA) && pte_protnone(pte)) goto no_page; if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) { pte_unmap_unlock(ptep, ptl); return NULL; } page = vm_normal_page(vma, address, pte); if (!page && pte_devmap(pte) && (flags & FOLL_GET)) { *pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap); if (*pgmap) page = pte_page(pte); else goto no_page; } else if (unlikely(!page)) { if (flags & FOLL_DUMP) { page = ERR_PTR(-EFAULT); goto out; } if (is_zero_pfn(pte_pfn(pte))) { page = pte_page(pte); } else { int ret; ret = follow_pfn_pte(vma, address, ptep, flags); page = ERR_PTR(ret); goto out; } } if (flags & FOLL_SPLIT && PageTransCompound(page)) { int ret; get_page(page); pte_unmap_unlock(ptep, ptl); lock_page(page); ret = split_huge_page(page); unlock_page(page); put_page(page); if (ret) return ERR_PTR(ret); goto retry; } <S2SV_StartVul> if (flags & FOLL_GET) <S2SV_EndVul> <S2SV_StartVul> get_page(page); <S2SV_EndVul> if (flags & FOLL_TOUCH) { if ((flags & FOLL_WRITE) && !pte_dirty(pte) && !PageDirty(page)) set_page_dirty(page); mark_page_accessed(page); } if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) { if (PageTransCompound(page)) goto out; if (page->mapping && trylock_page(page)) { lru_add_drain(); mlock_vma_page(page); unlock_page(page); } } out: pte_unmap_unlock(ptep, ptl); return page; no_page: pte_unmap_unlock(ptep, ptl); if (!pte_none(pte)) return NULL; return no_page_table(vma, flags); }","- if (flags & FOLL_GET)
- get_page(page);
+ if (flags & FOLL_GET) {
+ if (unlikely(!try_get_page(page))) {
+ page = ERR_PTR(-ENOMEM);
+ goto out;
+ }
+ }","static struct page *follow_page_pte(struct vm_area_struct *vma, unsigned long address, pmd_t *pmd, unsigned int flags, struct dev_pagemap **pgmap) { struct mm_struct *mm = vma->vm_mm; struct page *page; spinlock_t *ptl; pte_t *ptep, pte; retry: if (unlikely(pmd_bad(*pmd))) return no_page_table(vma, flags); ptep = pte_offset_map_lock(mm, pmd, address, &ptl); pte = *ptep; if (!pte_present(pte)) { swp_entry_t entry; if (likely(!(flags & FOLL_MIGRATION))) goto no_page; if (pte_none(pte)) goto no_page; entry = pte_to_swp_entry(pte); if (!is_migration_entry(entry)) goto no_page; pte_unmap_unlock(ptep, ptl); migration_entry_wait(mm, pmd, address); goto retry; } if ((flags & FOLL_NUMA) && pte_protnone(pte)) goto no_page; if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) { pte_unmap_unlock(ptep, ptl); return NULL; } page = vm_normal_page(vma, address, pte); if (!page && pte_devmap(pte) && (flags & FOLL_GET)) { *pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap); if (*pgmap) page = pte_page(pte); else goto no_page; } else if (unlikely(!page)) { if (flags & FOLL_DUMP) { page = ERR_PTR(-EFAULT); goto out; } if (is_zero_pfn(pte_pfn(pte))) { page = pte_page(pte); } else { int ret; ret = follow_pfn_pte(vma, address, ptep, flags); page = ERR_PTR(ret); goto out; } } if (flags & FOLL_SPLIT && PageTransCompound(page)) { int ret; get_page(page); pte_unmap_unlock(ptep, ptl); lock_page(page); ret = split_huge_page(page); unlock_page(page); put_page(page); if (ret) return ERR_PTR(ret); goto retry; } if (flags & FOLL_GET) { if (unlikely(!try_get_page(page))) { page = ERR_PTR(-ENOMEM); goto out; } } if (flags & FOLL_TOUCH) { if ((flags & FOLL_WRITE) && !pte_dirty(pte) && !PageDirty(page)) set_page_dirty(page); mark_page_accessed(page); } if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) { if (PageTransCompound(page)) goto out; if (page->mapping && trylock_page(page)) { lru_add_drain(); mlock_vma_page(page); unlock_page(page); } } out: pte_unmap_unlock(ptep, ptl); return page; no_page: pte_unmap_unlock(ptep, ptl); if (!pte_none(pte)) return NULL; return no_page_table(vma, flags); }"
333,1489----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-9605--vmwgfx_surface.c----vmw_gb_surface_define_ioctl,"int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv) { struct vmw_private *dev_priv = vmw_priv(dev); struct vmw_user_surface *user_srf; struct vmw_surface *srf; struct vmw_resource *res; struct vmw_resource *tmp; union drm_vmw_gb_surface_create_arg *arg = (union drm_vmw_gb_surface_create_arg *)data; struct drm_vmw_gb_surface_create_req *req = &arg->req; struct drm_vmw_gb_surface_create_rep *rep = &arg->rep; struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile; int ret; uint32_t size; <S2SV_StartVul> uint32_t backup_handle; <S2SV_EndVul> if (req->multisample_count != 0) return -EINVAL; if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS) return -EINVAL; if (unlikely(vmw_user_surface_size == 0)) vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) + 128; size = vmw_user_surface_size + 128; ret = vmw_surface_gb_priv_define(dev, size, req->svga3d_flags, req->format, req->drm_surface_flags & drm_vmw_surface_flag_scanout, req->mip_levels, req->multisample_count, req->array_size, req->base_size, &srf); if (unlikely(ret != 0)) return ret; user_srf = container_of(srf, struct vmw_user_surface, srf); if (drm_is_primary_client(file_priv)) user_srf->master = drm_master_get(file_priv->master); ret = ttm_read_lock(&dev_priv->reservation_sem, true); if (unlikely(ret != 0)) return ret; res = &user_srf->srf.res; if (req->buffer_handle != SVGA3D_INVALID_ID) { ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle, &res->backup, &user_srf->backup_base); <S2SV_StartVul> if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE < <S2SV_EndVul> <S2SV_StartVul> res->backup_size) { <S2SV_EndVul> <S2SV_StartVul> DRM_ERROR(""Surface backup buffer is too small.\n""); <S2SV_EndVul> <S2SV_StartVul> vmw_dmabuf_unreference(&res->backup); <S2SV_EndVul> <S2SV_StartVul> ret = -EINVAL; <S2SV_EndVul> <S2SV_StartVul> goto out_unlock; <S2SV_EndVul> } } else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer) ret = vmw_user_dmabuf_alloc(dev_priv, tfile, res->backup_size, req->drm_surface_flags & drm_vmw_surface_flag_shareable, &backup_handle, &res->backup, &user_srf->backup_base); if (unlikely(ret != 0)) { vmw_resource_unreference(&res); goto out_unlock; } tmp = vmw_resource_reference(res); ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime, req->drm_surface_flags & drm_vmw_surface_flag_shareable, VMW_RES_SURFACE, &vmw_user_surface_base_release, NULL); if (unlikely(ret != 0)) { vmw_resource_unreference(&tmp); vmw_resource_unreference(&res); goto out_unlock; } rep->handle = user_srf->prime.base.hash.key; rep->backup_size = res->backup_size; if (res->backup) { rep->buffer_map_handle = drm_vma_node_offset_addr(&res->backup->base.vma_node); rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE; rep->buffer_handle = backup_handle; } else { rep->buffer_map_handle = 0; rep->buffer_size = 0; rep->buffer_handle = SVGA3D_INVALID_ID; } vmw_resource_unreference(&res); out_unlock: ttm_read_unlock(&dev_priv->reservation_sem); return ret; }","- uint32_t backup_handle;
- if (ret == 0 && res->backup->base.num_pages * PAGE_SIZE <
- res->backup_size) {
- DRM_ERROR(""Surface backup buffer is too small.\n"");
- vmw_dmabuf_unreference(&res->backup);
- ret = -EINVAL;
- goto out_unlock;
+ uint32_t backup_handle = 0;
+ if (ret == 0) {
+ if (res->backup->base.num_pages * PAGE_SIZE <
+ res->backup_size) {
+ DRM_ERROR(""Surface backup buffer is too small.\n"");
+ vmw_dmabuf_unreference(&res->backup);
+ ret = -EINVAL;
+ goto out_unlock;
+ } else {
+ backup_handle = req->buffer_handle;
+ }","int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data, struct drm_file *file_priv) { struct vmw_private *dev_priv = vmw_priv(dev); struct vmw_user_surface *user_srf; struct vmw_surface *srf; struct vmw_resource *res; struct vmw_resource *tmp; union drm_vmw_gb_surface_create_arg *arg = (union drm_vmw_gb_surface_create_arg *)data; struct drm_vmw_gb_surface_create_req *req = &arg->req; struct drm_vmw_gb_surface_create_rep *rep = &arg->rep; struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile; int ret; uint32_t size; uint32_t backup_handle = 0; if (req->multisample_count != 0) return -EINVAL; if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS) return -EINVAL; if (unlikely(vmw_user_surface_size == 0)) vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) + 128; size = vmw_user_surface_size + 128; ret = vmw_surface_gb_priv_define(dev, size, req->svga3d_flags, req->format, req->drm_surface_flags & drm_vmw_surface_flag_scanout, req->mip_levels, req->multisample_count, req->array_size, req->base_size, &srf); if (unlikely(ret != 0)) return ret; user_srf = container_of(srf, struct vmw_user_surface, srf); if (drm_is_primary_client(file_priv)) user_srf->master = drm_master_get(file_priv->master); ret = ttm_read_lock(&dev_priv->reservation_sem, true); if (unlikely(ret != 0)) return ret; res = &user_srf->srf.res; if (req->buffer_handle != SVGA3D_INVALID_ID) { ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle, &res->backup, &user_srf->backup_base); if (ret == 0) { if (res->backup->base.num_pages * PAGE_SIZE < res->backup_size) { DRM_ERROR(""Surface backup buffer is too small.\n""); vmw_dmabuf_unreference(&res->backup); ret = -EINVAL; goto out_unlock; } else { backup_handle = req->buffer_handle; } } } else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer) ret = vmw_user_dmabuf_alloc(dev_priv, tfile, res->backup_size, req->drm_surface_flags & drm_vmw_surface_flag_shareable, &backup_handle, &res->backup, &user_srf->backup_base); if (unlikely(ret != 0)) { vmw_resource_unreference(&res); goto out_unlock; } tmp = vmw_resource_reference(res); ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime, req->drm_surface_flags & drm_vmw_surface_flag_shareable, VMW_RES_SURFACE, &vmw_user_surface_base_release, NULL); if (unlikely(ret != 0)) { vmw_resource_unreference(&tmp); vmw_resource_unreference(&res); goto out_unlock; } rep->handle = user_srf->prime.base.hash.key; rep->backup_size = res->backup_size; if (res->backup) { rep->buffer_map_handle = drm_vma_node_offset_addr(&res->backup->base.vma_node); rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE; rep->buffer_handle = backup_handle; } else { rep->buffer_map_handle = 0; rep->buffer_size = 0; rep->buffer_handle = SVGA3D_INVALID_ID; } vmw_resource_unreference(&res); out_unlock: ttm_read_unlock(&dev_priv->reservation_sem); return ret; }"
334,3191----CWE-285----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/acl.c----ext2_set_acl,"ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type) { int name_index; void *value = NULL; size_t size = 0; int error; switch(type) { case ACL_TYPE_ACCESS: name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS; if (acl) { <S2SV_StartVul> error = posix_acl_equiv_mode(acl, &inode->i_mode); <S2SV_EndVul> <S2SV_StartVul> if (error < 0) <S2SV_EndVul> return error; <S2SV_StartVul> else { <S2SV_EndVul> <S2SV_StartVul> inode->i_ctime = CURRENT_TIME_SEC; <S2SV_EndVul> <S2SV_StartVul> mark_inode_dirty(inode); <S2SV_EndVul> <S2SV_StartVul> if (error == 0) <S2SV_EndVul> <S2SV_StartVul> acl = NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } break; case ACL_TYPE_DEFAULT: name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT; if (!S_ISDIR(inode->i_mode)) return acl ? -EACCES : 0; break; default: return -EINVAL; } if (acl) { value = ext2_acl_to_disk(acl, &size); if (IS_ERR(value)) return (int)PTR_ERR(value); } error = ext2_xattr_set(inode, name_index, """", value, size, 0); kfree(value); if (!error) set_cached_acl(inode, type, acl); return error; }","- error = posix_acl_equiv_mode(acl, &inode->i_mode);
- if (error < 0)
- else {
- inode->i_ctime = CURRENT_TIME_SEC;
- mark_inode_dirty(inode);
- if (error == 0)
- acl = NULL;
- }
+ error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ if (error)
+ inode->i_ctime = CURRENT_TIME_SEC;
+ mark_inode_dirty(inode);","ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type) { int name_index; void *value = NULL; size_t size = 0; int error; switch(type) { case ACL_TYPE_ACCESS: name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS; if (acl) { error = posix_acl_update_mode(inode, &inode->i_mode, &acl); if (error) return error; inode->i_ctime = CURRENT_TIME_SEC; mark_inode_dirty(inode); } break; case ACL_TYPE_DEFAULT: name_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT; if (!S_ISDIR(inode->i_mode)) return acl ? -EACCES : 0; break; default: return -EINVAL; } if (acl) { value = ext2_acl_to_disk(acl, &size); if (IS_ERR(value)) return (int)PTR_ERR(value); } error = ext2_xattr_set(inode, name_index, """", value, size, 0); kfree(value); if (!error) set_cached_acl(inode, type, acl); return error; }"
335,5100----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/wasm.cc----Envoy::Extensions::Common::Wasm::Context::onUpstreamConnectionClose,"void Context::onUpstreamConnectionClose(PeerType peer_type) { <S2SV_StartVul> if (wasm_->onUpstreamConnectionClose_) { <S2SV_EndVul> wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type)); } }","- if (wasm_->onUpstreamConnectionClose_) {
+ if (in_vm_context_created_ && wasm_->onUpstreamConnectionClose_) {","void Context::onUpstreamConnectionClose(PeerType peer_type) { if (in_vm_context_created_ && wasm_->onUpstreamConnectionClose_) { wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type)); } }"
336,5563----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/scan.c----_yr_scan_verify_re_match,"int _yr_scan_verify_re_match( YR_SCAN_CONTEXT* context, YR_AC_MATCH* ac_match, uint8_t* data, size_t data_size, size_t data_base, size_t offset) { CALLBACK_ARGS callback_args; RE_EXEC_FUNC exec; int forward_matches = -1; int backward_matches = -1; int flags = 0; if (STRING_IS_GREEDY_REGEXP(ac_match->string)) flags |= RE_FLAGS_GREEDY; if (STRING_IS_NO_CASE(ac_match->string)) flags |= RE_FLAGS_NO_CASE; if (STRING_IS_DOT_ALL(ac_match->string)) flags |= RE_FLAGS_DOT_ALL; if (STRING_IS_FAST_REGEXP(ac_match->string)) exec = yr_re_fast_exec; else exec = yr_re_exec; if (STRING_IS_ASCII(ac_match->string)) { forward_matches = exec( ac_match->forward_code, data + offset, data_size - offset, <S2SV_StartVul> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags, <S2SV_EndVul> NULL, NULL); } if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1) { flags |= RE_FLAGS_WIDE; forward_matches = exec( ac_match->forward_code, data + offset, data_size - offset, <S2SV_StartVul> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags, <S2SV_EndVul> NULL, NULL); } switch(forward_matches) { case -1: return ERROR_SUCCESS; case -2: return ERROR_INSUFFICIENT_MEMORY; case -3: return ERROR_TOO_MANY_MATCHES; case -4: return ERROR_TOO_MANY_RE_FIBERS; case -5: return ERROR_INTERNAL_FATAL_ERROR; } if (forward_matches == 0 && ac_match->backward_code == NULL) return ERROR_SUCCESS; callback_args.string = ac_match->string; callback_args.context = context; callback_args.data = data; callback_args.data_size = data_size; callback_args.data_base = data_base; callback_args.forward_matches = forward_matches; callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string); if (ac_match->backward_code != NULL) { backward_matches = exec( ac_match->backward_code, data + offset, offset, flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE, _yr_scan_match_callback, (void*) &callback_args); switch(backward_matches) { case -2: return ERROR_INSUFFICIENT_MEMORY; case -3: return ERROR_TOO_MANY_MATCHES; case -4: return ERROR_TOO_MANY_RE_FIBERS; case -5: return ERROR_INTERNAL_FATAL_ERROR; } } else { FAIL_ON_ERROR(_yr_scan_match_callback( data + offset, 0, flags, &callback_args)); } return ERROR_SUCCESS; }","- offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
- offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,
+ offset,
+ flags,
+ offset,
+ flags,
+ data_size - offset,","int _yr_scan_verify_re_match( YR_SCAN_CONTEXT* context, YR_AC_MATCH* ac_match, uint8_t* data, size_t data_size, size_t data_base, size_t offset) { CALLBACK_ARGS callback_args; RE_EXEC_FUNC exec; int forward_matches = -1; int backward_matches = -1; int flags = 0; if (STRING_IS_GREEDY_REGEXP(ac_match->string)) flags |= RE_FLAGS_GREEDY; if (STRING_IS_NO_CASE(ac_match->string)) flags |= RE_FLAGS_NO_CASE; if (STRING_IS_DOT_ALL(ac_match->string)) flags |= RE_FLAGS_DOT_ALL; if (STRING_IS_FAST_REGEXP(ac_match->string)) exec = yr_re_fast_exec; else exec = yr_re_exec; if (STRING_IS_ASCII(ac_match->string)) { forward_matches = exec( ac_match->forward_code, data + offset, data_size - offset, offset, flags, NULL, NULL); } if (STRING_IS_WIDE(ac_match->string) && forward_matches == -1) { flags |= RE_FLAGS_WIDE; forward_matches = exec( ac_match->forward_code, data + offset, data_size - offset, offset, flags, NULL, NULL); } switch(forward_matches) { case -1: return ERROR_SUCCESS; case -2: return ERROR_INSUFFICIENT_MEMORY; case -3: return ERROR_TOO_MANY_MATCHES; case -4: return ERROR_TOO_MANY_RE_FIBERS; case -5: return ERROR_INTERNAL_FATAL_ERROR; } if (forward_matches == 0 && ac_match->backward_code == NULL) return ERROR_SUCCESS; callback_args.string = ac_match->string; callback_args.context = context; callback_args.data = data; callback_args.data_size = data_size; callback_args.data_base = data_base; callback_args.forward_matches = forward_matches; callback_args.full_word = STRING_IS_FULL_WORD(ac_match->string); if (ac_match->backward_code != NULL) { backward_matches = exec( ac_match->backward_code, data + offset, data_size - offset, offset, flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE, _yr_scan_match_callback, (void*) &callback_args); switch(backward_matches) { case -2: return ERROR_INSUFFICIENT_MEMORY; case -3: return ERROR_TOO_MANY_MATCHES; case -4: return ERROR_TOO_MANY_RE_FIBERS; case -5: return ERROR_INTERNAL_FATAL_ERROR; } } else { FAIL_ON_ERROR(_yr_scan_match_callback( data + offset, 0, flags, &callback_args)); } return ERROR_SUCCESS; }"
337,768----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3346--scsi-disk.c----scsi_send_command,"static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); int32_t len; uint8_t command; <S2SV_StartVul> uint8_t *outbuf; <S2SV_EndVul> int rc; command = buf[0]; <S2SV_StartVul> outbuf = (uint8_t *)r->iov.iov_base; <S2SV_EndVul> DPRINTF(""Command: lun=%d tag=0x%x data=0x%02x"", req->lun, req->tag, buf[0]); #ifdef DEBUG_SCSI { int i; for (i = 1; i < r->req.cmd.len; i++) { printf("" 0x%02x"", buf[i]); } printf(""\n""); } #endif switch (command) { case TEST_UNIT_READY: case INQUIRY: case MODE_SENSE: case MODE_SENSE_10: case RESERVE: case RESERVE_10: case RELEASE: case RELEASE_10: case START_STOP: case ALLOW_MEDIUM_REMOVAL: case READ_CAPACITY_10: case READ_TOC: case GET_CONFIGURATION: case SERVICE_ACTION_IN_16: case VERIFY_10: <S2SV_StartVul> rc = scsi_disk_emulate_command(r, outbuf); <S2SV_EndVul> if (rc < 0) { return 0; } r->iov.iov_len = rc; break; case SYNCHRONIZE_CACHE: bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH); r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r); if (r->req.aiocb == NULL) { scsi_flush_complete(r, -EIO); } return 0; case READ_6: case READ_10: case READ_12: case READ_16: len = r->req.cmd.xfer / s->qdev.blocksize; DPRINTF(""Read (sector %"" PRId64 "", count %d)\n"", r->req.cmd.lba, len); if (r->req.cmd.lba > s->max_lba) goto illegal_lba; r->sector = r->req.cmd.lba * s->cluster_size; r->sector_count = len * s->cluster_size; break; case WRITE_6: case WRITE_10: case WRITE_12: case WRITE_16: case WRITE_VERIFY_10: case WRITE_VERIFY_12: case WRITE_VERIFY_16: len = r->req.cmd.xfer / s->qdev.blocksize; DPRINTF(""Write %s(sector %"" PRId64 "", count %d)\n"", (command & 0xe) == 0xe ? ""And Verify "" : """", r->req.cmd.lba, len); if (r->req.cmd.lba > s->max_lba) goto illegal_lba; r->sector = r->req.cmd.lba * s->cluster_size; r->sector_count = len * s->cluster_size; break; case MODE_SELECT: DPRINTF(""Mode Select(6) (len %lu)\n"", (long)r->req.cmd.xfer); if (r->req.cmd.xfer > 12) { goto fail; } break; case MODE_SELECT_10: DPRINTF(""Mode Select(10) (len %lu)\n"", (long)r->req.cmd.xfer); if (r->req.cmd.xfer > 16) { goto fail; } break; case SEEK_6: case SEEK_10: DPRINTF(""Seek(%d) (sector %"" PRId64 "")\n"", command == SEEK_6 ? 6 : 10, r->req.cmd.lba); if (r->req.cmd.lba > s->max_lba) { goto illegal_lba; } break; case WRITE_SAME_16: len = r->req.cmd.xfer / s->qdev.blocksize; DPRINTF(""WRITE SAME(16) (sector %"" PRId64 "", count %d)\n"", r->req.cmd.lba, len); if (r->req.cmd.lba > s->max_lba) { goto illegal_lba; } if (!(buf[1] & 0x8)) { goto fail; } rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size, len * s->cluster_size); if (rc < 0) { goto fail; } break; case REQUEST_SENSE: abort(); default: DPRINTF(""Unknown SCSI command (%2.2x)\n"", buf[0]); scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return 0; fail: scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); return 0; illegal_lba: scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE)); return 0; } if (r->sector_count == 0 && r->iov.iov_len == 0) { scsi_req_complete(&r->req, GOOD); } len = r->sector_count * 512 + r->iov.iov_len; if (r->req.cmd.mode == SCSI_XFER_TO_DEV) { return -len; } else { if (!r->sector_count) r->sector_count = -1; return len; } }","- uint8_t *outbuf;
- outbuf = (uint8_t *)r->iov.iov_base;
- rc = scsi_disk_emulate_command(r, outbuf);
+ rc = scsi_disk_emulate_command(r);","static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); int32_t len; uint8_t command; int rc; command = buf[0]; DPRINTF(""Command: lun=%d tag=0x%x data=0x%02x"", req->lun, req->tag, buf[0]); #ifdef DEBUG_SCSI { int i; for (i = 1; i < r->req.cmd.len; i++) { printf("" 0x%02x"", buf[i]); } printf(""\n""); } #endif switch (command) { case TEST_UNIT_READY: case INQUIRY: case MODE_SENSE: case MODE_SENSE_10: case RESERVE: case RESERVE_10: case RELEASE: case RELEASE_10: case START_STOP: case ALLOW_MEDIUM_REMOVAL: case READ_CAPACITY_10: case READ_TOC: case GET_CONFIGURATION: case SERVICE_ACTION_IN_16: case VERIFY_10: rc = scsi_disk_emulate_command(r); if (rc < 0) { return 0; } r->iov.iov_len = rc; break; case SYNCHRONIZE_CACHE: bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH); r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r); if (r->req.aiocb == NULL) { scsi_flush_complete(r, -EIO); } return 0; case READ_6: case READ_10: case READ_12: case READ_16: len = r->req.cmd.xfer / s->qdev.blocksize; DPRINTF(""Read (sector %"" PRId64 "", count %d)\n"", r->req.cmd.lba, len); if (r->req.cmd.lba > s->max_lba) goto illegal_lba; r->sector = r->req.cmd.lba * s->cluster_size; r->sector_count = len * s->cluster_size; break; case WRITE_6: case WRITE_10: case WRITE_12: case WRITE_16: case WRITE_VERIFY_10: case WRITE_VERIFY_12: case WRITE_VERIFY_16: len = r->req.cmd.xfer / s->qdev.blocksize; DPRINTF(""Write %s(sector %"" PRId64 "", count %d)\n"", (command & 0xe) == 0xe ? ""And Verify "" : """", r->req.cmd.lba, len); if (r->req.cmd.lba > s->max_lba) goto illegal_lba; r->sector = r->req.cmd.lba * s->cluster_size; r->sector_count = len * s->cluster_size; break; case MODE_SELECT: DPRINTF(""Mode Select(6) (len %lu)\n"", (long)r->req.cmd.xfer); if (r->req.cmd.xfer > 12) { goto fail; } break; case MODE_SELECT_10: DPRINTF(""Mode Select(10) (len %lu)\n"", (long)r->req.cmd.xfer); if (r->req.cmd.xfer > 16) { goto fail; } break; case SEEK_6: case SEEK_10: DPRINTF(""Seek(%d) (sector %"" PRId64 "")\n"", command == SEEK_6 ? 6 : 10, r->req.cmd.lba); if (r->req.cmd.lba > s->max_lba) { goto illegal_lba; } break; case WRITE_SAME_16: len = r->req.cmd.xfer / s->qdev.blocksize; DPRINTF(""WRITE SAME(16) (sector %"" PRId64 "", count %d)\n"", r->req.cmd.lba, len); if (r->req.cmd.lba > s->max_lba) { goto illegal_lba; } if (!(buf[1] & 0x8)) { goto fail; } rc = bdrv_discard(s->bs, r->req.cmd.lba * s->cluster_size, len * s->cluster_size); if (rc < 0) { goto fail; } break; case REQUEST_SENSE: abort(); default: DPRINTF(""Unknown SCSI command (%2.2x)\n"", buf[0]); scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return 0; fail: scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); return 0; illegal_lba: scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE)); return 0; } if (r->sector_count == 0 && r->iov.iov_len == 0) { scsi_req_complete(&r->req, GOOD); } len = r->sector_count * 512 + r->iov.iov_len; if (r->req.cmd.mode == SCSI_XFER_TO_DEV) { return -len; } else { if (!r->sector_count) r->sector_count = -1; return len; } }"
338,1583----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7501--fsm.c----rpmPackageFilesInstall,"int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, rpmpsm psm, char ** failedFile) { FD_t payload = rpmtePayload(te); rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE); rpmfs fs = rpmteGetFileStates(te); rpmPlugins plugins = rpmtsPlugins(ts); struct stat sb; int saveerrno = errno; int rc = 0; int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0; int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0; int firsthardlink = -1; int skip; rpmFileAction action; char *tid = NULL; const char *suffix; char *fpath = NULL; if (fi == NULL) { rc = RPMERR_BAD_MAGIC; goto exit; } rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts)); rc = fsmMkdirs(files, fs, plugins); while (!rc) { rc = rpmfiNext(fi); if (rc < 0) { if (rc == RPMERR_ITER_END) rc = 0; break; } action = rpmfsGetAction(fs, rpmfiFX(fi)); skip = XFA_SKIPPING(action); suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid; if (action != FA_TOUCH) { fpath = fsmFsPath(fi, suffix); } else { fpath = fsmFsPath(fi, """"); } rc = rpmfiStat(fi, 1, &sb); fsmDebug(fpath, action, &sb); if (rc) break; rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath, sb.st_mode, action); if (rc) { skip = 1; } else { setFileState(fs, rpmfiFX(fi)); } if (!skip) { int setmeta = 1; if (!suffix) { rc = fsmBackup(fi, action); } if (!suffix) { rc = fsmVerify(fpath, fi); } else { rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT; } if (S_ISREG(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfile(fi, fpath, files, psm, nodigest, &setmeta, &firsthardlink); } } else if (S_ISDIR(sb.st_mode)) { if (rc == RPMERR_ENOENT) { mode_t mode = sb.st_mode; mode &= ~07777; mode |= 00700; rc = fsmMkdir(fpath, mode); } } else if (S_ISLNK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmSymlink(rpmfiFLink(fi), fpath); } } else if (S_ISFIFO(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfifo(fpath, 0000); } } else if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode) || S_ISSOCK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev); } } else { if (!IS_DEV_LOG(fpath)) rc = RPMERR_UNKNOWN_FILETYPE; } if (!rc && setmeta) { rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps); } } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) { char *fn = rpmfilesFN(files, firsthardlink); <S2SV_StartVul> rc = expandRegular(fi, fn, psm, nodigest, 0); <S2SV_EndVul> firsthardlink = -1; free(fn); } if (rc) { if (!skip) { if (suffix && (action != FA_TOUCH)) { (void) fsmRemove(fpath, sb.st_mode); } errno = saveerrno; } } else { rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi)); if (!skip) { if (suffix) rc = fsmBackup(fi, action); if (!rc) rc = fsmCommit(&fpath, fi, action, suffix); } } if (rc) *failedFile = xstrdup(fpath); rpmpluginsCallFsmFilePost(plugins, fi, fpath, sb.st_mode, action, rc); fpath = _free(fpath); } rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ)); rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST)); exit: rpmfiArchiveClose(fi); rpmfiFree(fi); Fclose(payload); free(tid); free(fpath); return rc; }","- rc = expandRegular(fi, fn, psm, nodigest, 0);
+ rc = expandRegular(fi, fn, psm, 0, nodigest, 0);","int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, rpmpsm psm, char ** failedFile) { FD_t payload = rpmtePayload(te); rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE); rpmfs fs = rpmteGetFileStates(te); rpmPlugins plugins = rpmtsPlugins(ts); struct stat sb; int saveerrno = errno; int rc = 0; int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0; int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0; int firsthardlink = -1; int skip; rpmFileAction action; char *tid = NULL; const char *suffix; char *fpath = NULL; if (fi == NULL) { rc = RPMERR_BAD_MAGIC; goto exit; } rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts)); rc = fsmMkdirs(files, fs, plugins); while (!rc) { rc = rpmfiNext(fi); if (rc < 0) { if (rc == RPMERR_ITER_END) rc = 0; break; } action = rpmfsGetAction(fs, rpmfiFX(fi)); skip = XFA_SKIPPING(action); suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid; if (action != FA_TOUCH) { fpath = fsmFsPath(fi, suffix); } else { fpath = fsmFsPath(fi, """"); } rc = rpmfiStat(fi, 1, &sb); fsmDebug(fpath, action, &sb); if (rc) break; rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath, sb.st_mode, action); if (rc) { skip = 1; } else { setFileState(fs, rpmfiFX(fi)); } if (!skip) { int setmeta = 1; if (!suffix) { rc = fsmBackup(fi, action); } if (!suffix) { rc = fsmVerify(fpath, fi); } else { rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT; } if (S_ISREG(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfile(fi, fpath, files, psm, nodigest, &setmeta, &firsthardlink); } } else if (S_ISDIR(sb.st_mode)) { if (rc == RPMERR_ENOENT) { mode_t mode = sb.st_mode; mode &= ~07777; mode |= 00700; rc = fsmMkdir(fpath, mode); } } else if (S_ISLNK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmSymlink(rpmfiFLink(fi), fpath); } } else if (S_ISFIFO(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfifo(fpath, 0000); } } else if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode) || S_ISSOCK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev); } } else { if (!IS_DEV_LOG(fpath)) rc = RPMERR_UNKNOWN_FILETYPE; } if (!rc && setmeta) { rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps); } } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) { char *fn = rpmfilesFN(files, firsthardlink); rc = expandRegular(fi, fn, psm, 0, nodigest, 0); firsthardlink = -1; free(fn); } if (rc) { if (!skip) { if (suffix && (action != FA_TOUCH)) { (void) fsmRemove(fpath, sb.st_mode); } errno = saveerrno; } } else { rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi)); if (!skip) { if (suffix) rc = fsmBackup(fi, action); if (!rc) rc = fsmCommit(&fpath, fi, action, suffix); } } if (rc) *failedFile = xstrdup(fpath); rpmpluginsCallFsmFilePost(plugins, fi, fpath, sb.st_mode, action, rc); fpath = _free(fpath); } rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ)); rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST)); exit: rpmfiArchiveClose(fi); rpmfiFree(fi); Fclose(payload); free(tid); free(fpath); return rc; }"
339,3108----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip_sockglue.c----do_ip_getsockopt,"static int do_ip_getsockopt(struct sock *sk, int level, int optname, char __user *optval, int __user *optlen) { struct inet_sock *inet = inet_sk(sk); int val; int len; if (level != SOL_IP) return -EOPNOTSUPP; if (ip_mroute_opt(optname)) return ip_mroute_getsockopt(sk, optname, optval, optlen); if (get_user(len, optlen)) return -EFAULT; if (len < 0) return -EINVAL; lock_sock(sk); switch (optname) { case IP_OPTIONS: { unsigned char optbuf[sizeof(struct ip_options)+40]; <S2SV_StartVul> struct ip_options * opt = (struct ip_options *)optbuf; <S2SV_EndVul> opt->optlen = 0; <S2SV_StartVul> if (inet->opt) <S2SV_EndVul> <S2SV_StartVul> memcpy(optbuf, inet->opt, <S2SV_EndVul> <S2SV_StartVul> sizeof(struct ip_options)+ <S2SV_EndVul> <S2SV_StartVul> inet->opt->optlen); <S2SV_EndVul> release_sock(sk); if (opt->optlen == 0) return put_user(0, optlen); ip_options_undo(opt); len = min_t(unsigned int, len, opt->optlen); if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, opt->__data, len)) return -EFAULT; return 0; } case IP_PKTINFO: val = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0; break; case IP_RECVTTL: val = (inet->cmsg_flags & IP_CMSG_TTL) != 0; break; case IP_RECVTOS: val = (inet->cmsg_flags & IP_CMSG_TOS) != 0; break; case IP_RECVOPTS: val = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0; break; case IP_RETOPTS: val = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0; break; case IP_PASSSEC: val = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0; break; case IP_RECVORIGDSTADDR: val = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0; break; case IP_TOS: val = inet->tos; break; case IP_TTL: val = (inet->uc_ttl == -1 ? sysctl_ip_default_ttl : inet->uc_ttl); break; case IP_HDRINCL: val = inet->hdrincl; break; case IP_NODEFRAG: val = inet->nodefrag; break; case IP_MTU_DISCOVER: val = inet->pmtudisc; break; case IP_MTU: { struct dst_entry *dst; val = 0; dst = sk_dst_get(sk); if (dst) { val = dst_mtu(dst); dst_release(dst); } if (!val) { release_sock(sk); return -ENOTCONN; } break; } case IP_RECVERR: val = inet->recverr; break; case IP_MULTICAST_TTL: val = inet->mc_ttl; break; case IP_MULTICAST_LOOP: val = inet->mc_loop; break; case IP_MULTICAST_IF: { struct in_addr addr; len = min_t(unsigned int, len, sizeof(struct in_addr)); addr.s_addr = inet->mc_addr; release_sock(sk); if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, &addr, len)) return -EFAULT; return 0; } case IP_MSFILTER: { struct ip_msfilter msf; int err; if (len < IP_MSFILTER_SIZE(0)) { release_sock(sk); return -EINVAL; } if (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) { release_sock(sk); return -EFAULT; } err = ip_mc_msfget(sk, &msf, (struct ip_msfilter __user *)optval, optlen); release_sock(sk); return err; } case MCAST_MSFILTER: { struct group_filter gsf; int err; if (len < GROUP_FILTER_SIZE(0)) { release_sock(sk); return -EINVAL; } if (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) { release_sock(sk); return -EFAULT; } err = ip_mc_gsfget(sk, &gsf, (struct group_filter __user *)optval, optlen); release_sock(sk); return err; } case IP_MULTICAST_ALL: val = inet->mc_all; break; case IP_PKTOPTIONS: { struct msghdr msg; release_sock(sk); if (sk->sk_type != SOCK_STREAM) return -ENOPROTOOPT; msg.msg_control = optval; msg.msg_controllen = len; msg.msg_flags = 0; if (inet->cmsg_flags & IP_CMSG_PKTINFO) { struct in_pktinfo info; info.ipi_addr.s_addr = inet->inet_rcv_saddr; info.ipi_spec_dst.s_addr = inet->inet_rcv_saddr; info.ipi_ifindex = inet->mc_index; put_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info); } if (inet->cmsg_flags & IP_CMSG_TTL) { int hlim = inet->mc_ttl; put_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim); } len -= msg.msg_controllen; return put_user(len, optlen); } case IP_FREEBIND: val = inet->freebind; break; case IP_TRANSPARENT: val = inet->transparent; break; case IP_MINTTL: val = inet->min_ttl; break; default: release_sock(sk); return -ENOPROTOOPT; } release_sock(sk); if (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) { unsigned char ucval = (unsigned char)val; len = 1; if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, &ucval, 1)) return -EFAULT; } else { len = min_t(unsigned int, sizeof(int), len); if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, &val, len)) return -EFAULT; } return 0; }","- struct ip_options * opt = (struct ip_options *)optbuf;
- if (inet->opt)
- memcpy(optbuf, inet->opt,
- sizeof(struct ip_options)+
- inet->opt->optlen);
+ struct ip_options *opt = (struct ip_options *)optbuf;
+ struct ip_options_rcu *inet_opt;
+ inet_opt = rcu_dereference_protected(inet->inet_opt,
+ sock_owned_by_user(sk));
+ if (inet_opt)
+ memcpy(optbuf, &inet_opt->opt,
+ sizeof(struct ip_options) +
+ inet_opt->opt.optlen);","static int do_ip_getsockopt(struct sock *sk, int level, int optname, char __user *optval, int __user *optlen) { struct inet_sock *inet = inet_sk(sk); int val; int len; if (level != SOL_IP) return -EOPNOTSUPP; if (ip_mroute_opt(optname)) return ip_mroute_getsockopt(sk, optname, optval, optlen); if (get_user(len, optlen)) return -EFAULT; if (len < 0) return -EINVAL; lock_sock(sk); switch (optname) { case IP_OPTIONS: { unsigned char optbuf[sizeof(struct ip_options)+40]; struct ip_options *opt = (struct ip_options *)optbuf; struct ip_options_rcu *inet_opt; inet_opt = rcu_dereference_protected(inet->inet_opt, sock_owned_by_user(sk)); opt->optlen = 0; if (inet_opt) memcpy(optbuf, &inet_opt->opt, sizeof(struct ip_options) + inet_opt->opt.optlen); release_sock(sk); if (opt->optlen == 0) return put_user(0, optlen); ip_options_undo(opt); len = min_t(unsigned int, len, opt->optlen); if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, opt->__data, len)) return -EFAULT; return 0; } case IP_PKTINFO: val = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0; break; case IP_RECVTTL: val = (inet->cmsg_flags & IP_CMSG_TTL) != 0; break; case IP_RECVTOS: val = (inet->cmsg_flags & IP_CMSG_TOS) != 0; break; case IP_RECVOPTS: val = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0; break; case IP_RETOPTS: val = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0; break; case IP_PASSSEC: val = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0; break; case IP_RECVORIGDSTADDR: val = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0; break; case IP_TOS: val = inet->tos; break; case IP_TTL: val = (inet->uc_ttl == -1 ? sysctl_ip_default_ttl : inet->uc_ttl); break; case IP_HDRINCL: val = inet->hdrincl; break; case IP_NODEFRAG: val = inet->nodefrag; break; case IP_MTU_DISCOVER: val = inet->pmtudisc; break; case IP_MTU: { struct dst_entry *dst; val = 0; dst = sk_dst_get(sk); if (dst) { val = dst_mtu(dst); dst_release(dst); } if (!val) { release_sock(sk); return -ENOTCONN; } break; } case IP_RECVERR: val = inet->recverr; break; case IP_MULTICAST_TTL: val = inet->mc_ttl; break; case IP_MULTICAST_LOOP: val = inet->mc_loop; break; case IP_MULTICAST_IF: { struct in_addr addr; len = min_t(unsigned int, len, sizeof(struct in_addr)); addr.s_addr = inet->mc_addr; release_sock(sk); if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, &addr, len)) return -EFAULT; return 0; } case IP_MSFILTER: { struct ip_msfilter msf; int err; if (len < IP_MSFILTER_SIZE(0)) { release_sock(sk); return -EINVAL; } if (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) { release_sock(sk); return -EFAULT; } err = ip_mc_msfget(sk, &msf, (struct ip_msfilter __user *)optval, optlen); release_sock(sk); return err; } case MCAST_MSFILTER: { struct group_filter gsf; int err; if (len < GROUP_FILTER_SIZE(0)) { release_sock(sk); return -EINVAL; } if (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) { release_sock(sk); return -EFAULT; } err = ip_mc_gsfget(sk, &gsf, (struct group_filter __user *)optval, optlen); release_sock(sk); return err; } case IP_MULTICAST_ALL: val = inet->mc_all; break; case IP_PKTOPTIONS: { struct msghdr msg; release_sock(sk); if (sk->sk_type != SOCK_STREAM) return -ENOPROTOOPT; msg.msg_control = optval; msg.msg_controllen = len; msg.msg_flags = 0; if (inet->cmsg_flags & IP_CMSG_PKTINFO) { struct in_pktinfo info; info.ipi_addr.s_addr = inet->inet_rcv_saddr; info.ipi_spec_dst.s_addr = inet->inet_rcv_saddr; info.ipi_ifindex = inet->mc_index; put_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info); } if (inet->cmsg_flags & IP_CMSG_TTL) { int hlim = inet->mc_ttl; put_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim); } len -= msg.msg_controllen; return put_user(len, optlen); } case IP_FREEBIND: val = inet->freebind; break; case IP_TRANSPARENT: val = inet->transparent; break; case IP_MINTTL: val = inet->min_ttl; break; default: release_sock(sk); return -ENOPROTOOPT; } release_sock(sk); if (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) { unsigned char ucval = (unsigned char)val; len = 1; if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, &ucval, 1)) return -EFAULT; } else { len = min_t(unsigned int, sizeof(int), len); if (put_user(len, optlen)) return -EFAULT; if (copy_to_user(optval, &val, len)) return -EFAULT; } return 0; }"
340,6215----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/http_common.c----httpCheckCharset,"error_t httpCheckCharset(const char_t *s, size_t length, uint_t charset) { error_t error; size_t i; uint8_t c; uint_t m; error = NO_ERROR; for(i = 0; i < length; i++) { c = (uint8_t) s[i]; m = HTTP_CHARSET_OCTET; if(iscntrl(c)) m |= HTTP_CHARSET_CTL; if(isprint(c) && c <= 126) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR; if(c == ' ' || c == '\t') m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS; if(isalpha(c)) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA; if(osIsdigit(c)) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT; if(isxdigit(c)) m |= HTTP_CHARSET_HEX; if(c >= 128) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT; <S2SV_StartVul> if(strchr(""!#$%&'*+-.^_`|~"", c)) <S2SV_EndVul> m |= HTTP_CHARSET_TCHAR; if((m & charset) == 0) error = ERROR_INVALID_SYNTAX; } return error; }","- if(strchr(""!#$%&'*+-.^_`|~"", c))
+ if(osStrchr(""!#$%&'*+-.^_`|~"", c))","error_t httpCheckCharset(const char_t *s, size_t length, uint_t charset) { error_t error; size_t i; uint8_t c; uint_t m; error = NO_ERROR; for(i = 0; i < length; i++) { c = (uint8_t) s[i]; m = HTTP_CHARSET_OCTET; if(iscntrl(c)) m |= HTTP_CHARSET_CTL; if(isprint(c) && c <= 126) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR; if(c == ' ' || c == '\t') m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS; if(isalpha(c)) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA; if(osIsdigit(c)) m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT; if(isxdigit(c)) m |= HTTP_CHARSET_HEX; if(c >= 128) m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT; if(osStrchr(""!#$%&'*+-.^_`|~"", c)) m |= HTTP_CHARSET_TCHAR; if((m & charset) == 0) error = ERROR_INVALID_SYNTAX; } return error; }"
341,7170----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/keyctl.c----keyctl_chown_key,"long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group) { struct key_user *newowner, *zapowner = NULL; struct key *key; key_ref_t key_ref; long ret; kuid_t uid; kgid_t gid; uid = make_kuid(current_user_ns(), user); gid = make_kgid(current_user_ns(), group); ret = -EINVAL; if ((user != (uid_t) -1) && !uid_valid(uid)) goto error; if ((group != (gid_t) -1) && !gid_valid(gid)) goto error; ret = 0; if (user == (uid_t) -1 && group == (gid_t) -1) goto error; key_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL, KEY_NEED_SETATTR); if (IS_ERR(key_ref)) { ret = PTR_ERR(key_ref); goto error; } key = key_ref_to_ptr(key_ref); ret = -EACCES; down_write(&key->sem); if (!capable(CAP_SYS_ADMIN)) { if (user != (uid_t) -1 && !uid_eq(key->uid, uid)) goto error_put; if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid)) goto error_put; } if (user != (uid_t) -1 && !uid_eq(uid, key->uid)) { ret = -ENOMEM; newowner = key_user_lookup(uid); if (!newowner) goto error_put; if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) { unsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ? key_quota_root_maxkeys : key_quota_maxkeys; unsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ? key_quota_root_maxbytes : key_quota_maxbytes; spin_lock(&newowner->lock); if (newowner->qnkeys + 1 >= maxkeys || newowner->qnbytes + key->quotalen >= maxbytes || newowner->qnbytes + key->quotalen < newowner->qnbytes) goto quota_overrun; newowner->qnkeys++; newowner->qnbytes += key->quotalen; spin_unlock(&newowner->lock); spin_lock(&key->user->lock); key->user->qnkeys--; key->user->qnbytes -= key->quotalen; spin_unlock(&key->user->lock); } atomic_dec(&key->user->nkeys); atomic_inc(&newowner->nkeys); <S2SV_StartVul> if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) { <S2SV_EndVul> atomic_dec(&key->user->nikeys); atomic_inc(&newowner->nikeys); } zapowner = key->user; key->user = newowner; key->uid = uid; } if (group != (gid_t) -1) key->gid = gid; ret = 0; error_put: up_write(&key->sem); key_put(key); if (zapowner) key_user_put(zapowner); error: return ret; quota_overrun: spin_unlock(&newowner->lock); zapowner = newowner; ret = -EDQUOT; goto error_put; }","- if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
+ if (key->state != KEY_IS_UNINSTANTIATED) {","long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group) { struct key_user *newowner, *zapowner = NULL; struct key *key; key_ref_t key_ref; long ret; kuid_t uid; kgid_t gid; uid = make_kuid(current_user_ns(), user); gid = make_kgid(current_user_ns(), group); ret = -EINVAL; if ((user != (uid_t) -1) && !uid_valid(uid)) goto error; if ((group != (gid_t) -1) && !gid_valid(gid)) goto error; ret = 0; if (user == (uid_t) -1 && group == (gid_t) -1) goto error; key_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL, KEY_NEED_SETATTR); if (IS_ERR(key_ref)) { ret = PTR_ERR(key_ref); goto error; } key = key_ref_to_ptr(key_ref); ret = -EACCES; down_write(&key->sem); if (!capable(CAP_SYS_ADMIN)) { if (user != (uid_t) -1 && !uid_eq(key->uid, uid)) goto error_put; if (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid)) goto error_put; } if (user != (uid_t) -1 && !uid_eq(uid, key->uid)) { ret = -ENOMEM; newowner = key_user_lookup(uid); if (!newowner) goto error_put; if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) { unsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ? key_quota_root_maxkeys : key_quota_maxkeys; unsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ? key_quota_root_maxbytes : key_quota_maxbytes; spin_lock(&newowner->lock); if (newowner->qnkeys + 1 >= maxkeys || newowner->qnbytes + key->quotalen >= maxbytes || newowner->qnbytes + key->quotalen < newowner->qnbytes) goto quota_overrun; newowner->qnkeys++; newowner->qnbytes += key->quotalen; spin_unlock(&newowner->lock); spin_lock(&key->user->lock); key->user->qnkeys--; key->user->qnbytes -= key->quotalen; spin_unlock(&key->user->lock); } atomic_dec(&key->user->nkeys); atomic_inc(&newowner->nkeys); if (key->state != KEY_IS_UNINSTANTIATED) { atomic_dec(&key->user->nikeys); atomic_inc(&newowner->nikeys); } zapowner = key->user; key->user = newowner; key->uid = uid; } if (group != (gid_t) -1) key->gid = gid; ret = 0; error_put: up_write(&key->sem); key_put(key); if (zapowner) key_user_put(zapowner); error: return ret; quota_overrun: spin_unlock(&newowner->lock); zapowner = newowner; ret = -EDQUOT; goto error_put; }"
342,4521----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event_fsl_emb.c----record_and_restart,"static void record_and_restart(struct perf_event *event, unsigned long val, <S2SV_StartVul> struct pt_regs *regs, int nmi) <S2SV_EndVul> { u64 period = event->hw.sample_period; s64 prev, delta, left; int record = 0; if (event->hw.state & PERF_HES_STOPPED) { write_pmc(event->hw.idx, 0); return; } prev = local64_read(&event->hw.prev_count); delta = (val - prev) & 0xfffffffful; local64_add(delta, &event->count); val = 0; left = local64_read(&event->hw.period_left) - delta; if (period) { if (left <= 0) { left += period; if (left <= 0) left = period; record = 1; event->hw.last_period = event->hw.sample_period; } if (left < 0x80000000LL) val = 0x80000000LL - left; } write_pmc(event->hw.idx, val); local64_set(&event->hw.prev_count, val); local64_set(&event->hw.period_left, left); perf_event_update_userpage(event); if (record) { struct perf_sample_data data; perf_sample_data_init(&data, 0); data.period = event->hw.last_period; <S2SV_StartVul> if (perf_event_overflow(event, nmi, &data, regs)) <S2SV_EndVul> fsl_emb_pmu_stop(event, 0); } }","- struct pt_regs *regs, int nmi)
- if (perf_event_overflow(event, nmi, &data, regs))
+ struct pt_regs *regs)
+ if (perf_event_overflow(event, &data, regs))","static void record_and_restart(struct perf_event *event, unsigned long val, struct pt_regs *regs) { u64 period = event->hw.sample_period; s64 prev, delta, left; int record = 0; if (event->hw.state & PERF_HES_STOPPED) { write_pmc(event->hw.idx, 0); return; } prev = local64_read(&event->hw.prev_count); delta = (val - prev) & 0xfffffffful; local64_add(delta, &event->count); val = 0; left = local64_read(&event->hw.period_left) - delta; if (period) { if (left <= 0) { left += period; if (left <= 0) left = period; record = 1; event->hw.last_period = event->hw.sample_period; } if (left < 0x80000000LL) val = 0x80000000LL - left; } write_pmc(event->hw.idx, val); local64_set(&event->hw.prev_count, val); local64_set(&event->hw.period_left, left); perf_event_update_userpage(event); if (record) { struct perf_sample_data data; perf_sample_data_init(&data, 0); data.period = event->hw.last_period; if (perf_event_overflow(event, &data, regs)) fsl_emb_pmu_stop(event, 0); } }"
343,5756----CWE-284----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/socket.c----socket_create,"int socket_create(uint16_t port) { int sfd = -1; int yes = 1; #ifdef WIN32 WSADATA wsa_data; if (!wsa_init) { if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) { fprintf(stderr, ""WSAStartup failed!\n""); ExitProcess(-1); } wsa_init = 1; } #endif struct sockaddr_in saddr; if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) { perror(""socket()""); return -1; } if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) { perror(""setsockopt()""); socket_close(sfd); return -1; } memset((void *) &saddr, 0, sizeof(saddr)); saddr.sin_family = AF_INET; <S2SV_StartVul> saddr.sin_addr.s_addr = htonl(INADDR_ANY); <S2SV_EndVul> saddr.sin_port = htons(port); if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) { perror(""bind()""); socket_close(sfd); return -1; } if (listen(sfd, 1) == -1) { perror(""listen()""); socket_close(sfd); return -1; } return sfd; }","- saddr.sin_addr.s_addr = htonl(INADDR_ANY);
+ saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);","int socket_create(uint16_t port) { int sfd = -1; int yes = 1; #ifdef WIN32 WSADATA wsa_data; if (!wsa_init) { if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) { fprintf(stderr, ""WSAStartup failed!\n""); ExitProcess(-1); } wsa_init = 1; } #endif struct sockaddr_in saddr; if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) { perror(""socket()""); return -1; } if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) { perror(""setsockopt()""); socket_close(sfd); return -1; } memset((void *) &saddr, 0, sizeof(saddr)); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK); saddr.sin_port = htons(port); if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) { perror(""bind()""); socket_close(sfd); return -1; } if (listen(sfd, 1) == -1) { perror(""listen()""); socket_close(sfd); return -1; } return sfd; }"
344,1017--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4817--connection.c----parse_input,"<S2SV_StartVul> static void parse_input(h2o_http2_conn_t *conn) <S2SV_EndVul> { size_t http2_max_concurrent_requests_per_connection = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection; int perform_early_exit = 0; if (conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed != http2_max_concurrent_requests_per_connection) perform_early_exit = 1; while (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn->sock->input->size != 0) { if (perform_early_exit == 1 && conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed == http2_max_concurrent_requests_per_connection) goto EarlyExit; const char *err_desc = NULL; ssize_t ret = conn->_read_expect(conn, (uint8_t *)conn->sock->input->bytes, conn->sock->input->size, &err_desc); if (ret == H2O_HTTP2_ERROR_INCOMPLETE) { break; } else if (ret < 0) { if (ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY) { enqueue_goaway(conn, (int)ret, err_desc != NULL ? (h2o_iovec_t){(char *)err_desc, strlen(err_desc)} : (h2o_iovec_t){}); } <S2SV_StartVul> close_connection(conn); <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> } h2o_buffer_consume(&conn->sock->input, ret); } if (!h2o_socket_is_reading(conn->sock)) h2o_socket_read_start(conn->sock, on_read); <S2SV_StartVul> return; <S2SV_EndVul> EarlyExit: if (h2o_socket_is_reading(conn->sock)) h2o_socket_read_stop(conn->sock); }","- static void parse_input(h2o_http2_conn_t *conn)
- close_connection(conn);
- return;
- return;
+ static void parse_input(h2o_http2_conn_t *conn)
+ }
+ h2o_socket_read_start(conn->sock, on_read);
+ h2o_socket_read_stop(conn->sock);","static void parse_input(h2o_http2_conn_t *conn) static int parse_input(h2o_http2_conn_t *conn) { size_t http2_max_concurrent_requests_per_connection = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection; int perform_early_exit = 0; if (conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed != http2_max_concurrent_requests_per_connection) perform_early_exit = 1; while (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn->sock->input->size != 0) { if (perform_early_exit == 1 && conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed == http2_max_concurrent_requests_per_connection) goto EarlyExit; const char *err_desc = NULL; ssize_t ret = conn->_read_expect(conn, (uint8_t *)conn->sock->input->bytes, conn->sock->input->size, &err_desc); if (ret == H2O_HTTP2_ERROR_INCOMPLETE) { break; } else if (ret < 0) { if (ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY) { enqueue_goaway(conn, (int)ret, err_desc != NULL ? (h2o_iovec_t){(char *)err_desc, strlen(err_desc)} : (h2o_iovec_t){}); } return close_connection(conn); } h2o_buffer_consume(&conn->sock->input, ret); } if (!h2o_socket_is_reading(conn->sock)) h2o_socket_read_start(conn->sock, on_read); return 0; EarlyExit: if (h2o_socket_is_reading(conn->sock)) h2o_socket_read_stop(conn->sock); return 0; }"
345,4736----CWE-129----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ne.c----r_bin_ne_get_relocs,"RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) { RList *segments = bin->segments; if (!segments) { return NULL; } RList *entries = bin->entries; if (!entries) { return NULL; } RList *symbols = bin->symbols; if (!symbols) { return NULL; } <S2SV_StartVul> ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16)); <S2SV_EndVul> if (!modref) { return NULL; } r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16)); RList *relocs = r_list_newf (free); if (!relocs) { free (modref); return NULL; } RListIter *it; RBinSection *seg; int index = -1; r_list_foreach (segments, it, seg) { index++; if (!(bin->segment_entries[index].flags & RELOCINFO)) { continue; } ut32 off, start = off = seg->paddr + seg->size; ut16 length = r_buf_read_le16_at (bin->buf, off); if (!length) { continue; } off += 2; <S2SV_StartVul> while (off < start + length * sizeof (NE_image_reloc_item)) { <S2SV_EndVul> RBinReloc *reloc = R_NEW0 (RBinReloc); if (!reloc) { return NULL; } NE_image_reloc_item rel; r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)); reloc->paddr = seg->paddr + rel.offset; switch (rel.type) { case LOBYTE: reloc->type = R_BIN_RELOC_8; break; case SEL_16: case OFF_16: reloc->type = R_BIN_RELOC_16; break; case POI_32: case OFF_32: reloc->type = R_BIN_RELOC_32; break; case POI_48: reloc->type = R_BIN_RELOC_64; break; } ut32 offset; if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) { RBinImport *imp = R_NEW0 (RBinImport); if (!imp) { free (reloc); break; } char *name; <S2SV_StartVul> if (rel.index > bin->ne_header->ModRefs) { <S2SV_EndVul> name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); } else { <S2SV_StartVul> offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable; <S2SV_EndVul> name = __read_nonnull_str_at (bin->buf, offset); } if (rel.flags & IMPORTED_ORD) { imp->ordinal = rel.func_ord; imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord)); } else { offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off; char *func = __read_nonnull_str_at (bin->buf, offset); imp->name = r_str_newf (""%s.%s"", name, func); free (func); } free (name); reloc->import = imp; } else if (rel.flags & OSFIXUP) { } else { if (strstr (seg->name, ""FIXED"")) { RBinSection *s = r_list_get_n (segments, rel.segnum - 1); if (s) { offset = s->paddr + rel.segoff; } else { offset = -1; } } else { RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1); if (entry) { offset = entry->paddr; } else { offset = -1; } } reloc->addend = offset; RBinSymbol *sym = NULL; RListIter *sit; r_list_foreach (symbols, sit, sym) { if (sym->paddr == reloc->addend) { reloc->symbol = sym; break; } } } if (rel.flags & ADDITIVE) { reloc->additive = 1; r_list_append (relocs, reloc); } else { do { r_list_append (relocs, reloc); offset = r_buf_read_le16_at (bin->buf, reloc->paddr); RBinReloc *tmp = reloc; reloc = R_NEW0 (RBinReloc); if (!reloc) { break; } *reloc = *tmp; reloc->paddr = seg->paddr + offset; } while (offset != 0xFFFF); free (reloc); } off += sizeof (NE_image_reloc_item); } } free (modref); return relocs; }","- ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16));
- while (off < start + length * sizeof (NE_image_reloc_item)) {
- if (rel.index > bin->ne_header->ModRefs) {
- offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;
+ ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16));
+ size_t buf_size = r_buf_size (bin->buf);
+ while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) {
+ if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) {
+ int index = rel.index;
+ offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable;","RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) { RList *segments = bin->segments; if (!segments) { return NULL; } RList *entries = bin->entries; if (!entries) { return NULL; } RList *symbols = bin->symbols; if (!symbols) { return NULL; } ut16 *modref = calloc (bin->ne_header->ModRefs, sizeof (ut16)); if (!modref) { return NULL; } r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16)); RList *relocs = r_list_newf (free); if (!relocs) { free (modref); return NULL; } RListIter *it; RBinSection *seg; int index = -1; r_list_foreach (segments, it, seg) { index++; if (!(bin->segment_entries[index].flags & RELOCINFO)) { continue; } ut32 off, start = off = seg->paddr + seg->size; ut16 length = r_buf_read_le16_at (bin->buf, off); if (!length) { continue; } off += 2; size_t buf_size = r_buf_size (bin->buf); while (off < start + length * sizeof (NE_image_reloc_item) && off < buf_size) { RBinReloc *reloc = R_NEW0 (RBinReloc); if (!reloc) { return NULL; } NE_image_reloc_item rel; r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)); reloc->paddr = seg->paddr + rel.offset; switch (rel.type) { case LOBYTE: reloc->type = R_BIN_RELOC_8; break; case SEL_16: case OFF_16: reloc->type = R_BIN_RELOC_16; break; case POI_32: case OFF_32: reloc->type = R_BIN_RELOC_32; break; case POI_48: reloc->type = R_BIN_RELOC_64; break; } ut32 offset; if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) { RBinImport *imp = R_NEW0 (RBinImport); if (!imp) { free (reloc); break; } char *name; if (rel.index < 1 || rel.index > bin->ne_header->ModRefs) { name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); } else { int index = rel.index; offset = modref[index - 1] + bin->header_offset + bin->ne_header->ImportNameTable; name = __read_nonnull_str_at (bin->buf, offset); } if (rel.flags & IMPORTED_ORD) { imp->ordinal = rel.func_ord; imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord)); } else { offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off; char *func = __read_nonnull_str_at (bin->buf, offset); imp->name = r_str_newf (""%s.%s"", name, func); free (func); } free (name); reloc->import = imp; } else if (rel.flags & OSFIXUP) { } else { if (strstr (seg->name, ""FIXED"")) { RBinSection *s = r_list_get_n (segments, rel.segnum - 1); if (s) { offset = s->paddr + rel.segoff; } else { offset = -1; } } else { RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1); if (entry) { offset = entry->paddr; } else { offset = -1; } } reloc->addend = offset; RBinSymbol *sym = NULL; RListIter *sit; r_list_foreach (symbols, sit, sym) { if (sym->paddr == reloc->addend) { reloc->symbol = sym; break; } } } if (rel.flags & ADDITIVE) { reloc->additive = 1; r_list_append (relocs, reloc); } else { do { r_list_append (relocs, reloc); offset = r_buf_read_le16_at (bin->buf, reloc->paddr); RBinReloc *tmp = reloc; reloc = R_NEW0 (RBinReloc); if (!reloc) { break; } *reloc = *tmp; reloc->paddr = seg->paddr + offset; } while (offset != 0xFFFF); free (reloc); } off += sizeof (NE_image_reloc_item); } } free (modref); return relocs; }"
346,6012----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/image.cxx----image_load_gif,"image_load_gif(image_t *img, FILE *fp, int gray, int load_data) { uchar buf[1024]; gif_cmap_t cmap; int ncolors, transparent; fread(buf, 13, 1, fp); img->width = (buf[7] << 8) | buf[6]; img->height = (buf[9] << 8) | buf[8]; ncolors = 2 << (buf[10] & 0x07); <S2SV_StartVul> if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767) <S2SV_EndVul> return (-1); if (Encryption) img->use ++; if (buf[10] & GIF_COLORMAP) if (gif_read_cmap(fp, ncolors, cmap, &gray)) return (-1); transparent = -1; while (1) { switch (getc(fp)) { case ';' : return (-1); case '!' : buf[0] = (uchar)getc(fp); if (buf[0] == 0xf9) { gif_get_block(fp, buf); if (buf[0] & 1) transparent = buf[3]; } while (gif_get_block(fp, buf) != 0); break; case ',' : fread(buf, 9, 1, fp); if (buf[8] & GIF_COLORMAP) { ncolors = 2 << (buf[8] & 0x07); if (gif_read_cmap(fp, ncolors, cmap, &gray)) return (-1); } img->width = (buf[5] << 8) | buf[4]; img->height = (buf[7] << 8) | buf[6]; img->depth = gray ? 1 : 3; <S2SV_StartVul> if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767) <S2SV_EndVul> return (-1); if (transparent >= 0) { if (BodyColor[0]) { float rgb[3]; get_color((uchar *)BodyColor, rgb); cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f); cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f); cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f); } else { cmap[transparent][0] = 255; cmap[transparent][1] = 255; cmap[transparent][2] = 255; } image_need_mask(img); } if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent)); } } }","- if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)
- if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767)
+ if (img->width <= 0 || img->width > IMAGE_MAX_DIM || img->height <= 0 || img->height > IMAGE_MAX_DIM)
+ if (img->width <= 0 || img->width > IMAGE_MAX_DIM || img->height <= 0 || img->height > IMAGE_MAX_DIM)","image_load_gif(image_t *img, FILE *fp, int gray, int load_data) { uchar buf[1024]; gif_cmap_t cmap; int ncolors, transparent; fread(buf, 13, 1, fp); img->width = (buf[7] << 8) | buf[6]; img->height = (buf[9] << 8) | buf[8]; ncolors = 2 << (buf[10] & 0x07); if (img->width <= 0 || img->width > IMAGE_MAX_DIM || img->height <= 0 || img->height > IMAGE_MAX_DIM) return (-1); if (Encryption) img->use ++; if (buf[10] & GIF_COLORMAP) if (gif_read_cmap(fp, ncolors, cmap, &gray)) return (-1); transparent = -1; while (1) { switch (getc(fp)) { case ';' : return (-1); case '!' : buf[0] = (uchar)getc(fp); if (buf[0] == 0xf9) { gif_get_block(fp, buf); if (buf[0] & 1) transparent = buf[3]; } while (gif_get_block(fp, buf) != 0); break; case ',' : fread(buf, 9, 1, fp); if (buf[8] & GIF_COLORMAP) { ncolors = 2 << (buf[8] & 0x07); if (gif_read_cmap(fp, ncolors, cmap, &gray)) return (-1); } img->width = (buf[5] << 8) | buf[4]; img->height = (buf[7] << 8) | buf[6]; img->depth = gray ? 1 : 3; if (img->width <= 0 || img->width > IMAGE_MAX_DIM || img->height <= 0 || img->height > IMAGE_MAX_DIM) return (-1); if (transparent >= 0) { if (BodyColor[0]) { float rgb[3]; get_color((uchar *)BodyColor, rgb); cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f); cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f); cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f); } else { cmap[transparent][0] = 255; cmap[transparent][1] = 255; cmap[transparent][2] = 255; } image_need_mask(img); } if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent)); } } }"
347,6238----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/main.c----check,"check(str, sub, should) char *str; my_regmatch_t sub; char *should; { register int len; register int shlen; register char *p; static char grump[500]; register char *at = NULL; if (should != NULL && strcmp(should, ""-"") == 0) should = NULL; if (should != NULL && should[0] == '@') { at = should + 1; should = (char*) """"; } if (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) || (sub.rm_so != -1 && sub.rm_eo == -1) || (sub.rm_so != -1 && sub.rm_so < 0) || (sub.rm_eo != -1 && sub.rm_eo < 0) ) { <S2SV_StartVul> sprintf(grump, ""start %ld end %ld"", (long)sub.rm_so, <S2SV_EndVul> (long)sub.rm_eo); return(grump); } if (sub.rm_so == -1 && should == NULL) return(NULL); if (sub.rm_so == -1) return((char*) ""did not match""); if ((int) sub.rm_eo > (int) strlen(str)) { <S2SV_StartVul> sprintf(grump, ""start %ld end %ld, past end of string"", <S2SV_EndVul> (long)sub.rm_so, (long)sub.rm_eo); return(grump); } len = (int)(sub.rm_eo - sub.rm_so); shlen = (int)strlen(should); p = str + sub.rm_so; if (should == NULL) { <S2SV_StartVul> sprintf(grump, ""matched `%.*s'"", len, p); <S2SV_EndVul> return(grump); } if (len != shlen || strncmp(p, should, (size_t)shlen) != 0) { <S2SV_StartVul> sprintf(grump, ""matched `%.*s' instead"", len, p); <S2SV_EndVul> return(grump); } if (shlen > 0) return(NULL); if (at == NULL) return(NULL); shlen = strlen(at); if (shlen == 0) shlen = 1; if (strncmp(p, at, shlen) != 0) { <S2SV_StartVul> sprintf(grump, ""matched null at `%.20s'"", p); <S2SV_EndVul> return(grump); } return(NULL); }","- sprintf(grump, ""start %ld end %ld"", (long)sub.rm_so,
- sprintf(grump, ""start %ld end %ld, past end of string"",
- sprintf(grump, ""matched `%.*s'"", len, p);
- sprintf(grump, ""matched `%.*s' instead"", len, p);
- sprintf(grump, ""matched null at `%.20s'"", p);
+ snprintf(grump, sizeof(grump),
+ ""start %ld end %ld"", (long)sub.rm_so,
+ snprintf(grump, sizeof(grump),
+ ""start %ld end %ld, past end of string"",
+ snprintf(grump, sizeof(grump),
+ ""matched `%.*s'"", len, p);
+ snprintf(grump, sizeof(grump),
+ ""matched `%.*s' instead"", len, p);
+ snprintf(grump, sizeof(grump),
+ ""matched null at `%.20s'"", p);","check(str, sub, should) char *str; my_regmatch_t sub; char *should; { register int len; register int shlen; register char *p; static char grump[500]; register char *at = NULL; if (should != NULL && strcmp(should, ""-"") == 0) should = NULL; if (should != NULL && should[0] == '@') { at = should + 1; should = (char*) """"; } if (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) || (sub.rm_so != -1 && sub.rm_eo == -1) || (sub.rm_so != -1 && sub.rm_so < 0) || (sub.rm_eo != -1 && sub.rm_eo < 0) ) { snprintf(grump, sizeof(grump), ""start %ld end %ld"", (long)sub.rm_so, (long)sub.rm_eo); return(grump); } if (sub.rm_so == -1 && should == NULL) return(NULL); if (sub.rm_so == -1) return((char*) ""did not match""); if ((int) sub.rm_eo > (int) strlen(str)) { snprintf(grump, sizeof(grump), ""start %ld end %ld, past end of string"", (long)sub.rm_so, (long)sub.rm_eo); return(grump); } len = (int)(sub.rm_eo - sub.rm_so); shlen = (int)strlen(should); p = str + sub.rm_so; if (should == NULL) { snprintf(grump, sizeof(grump), ""matched `%.*s'"", len, p); return(grump); } if (len != shlen || strncmp(p, should, (size_t)shlen) != 0) { snprintf(grump, sizeof(grump), ""matched `%.*s' instead"", len, p); return(grump); } if (shlen > 0) return(NULL); if (at == NULL) return(NULL); shlen = strlen(at); if (shlen == 0) shlen = 1; if (strncmp(p, at, shlen) != 0) { snprintf(grump, sizeof(grump), ""matched null at `%.20s'"", p); return(grump); } return(NULL); }"
348,6088----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/options.c----init_section,"NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) { char *errstr; #ifndef USE_WIN32 (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr; #endif if(*section_ptr==&new_service_options) { <S2SV_StartVul> errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL); <S2SV_EndVul> if(errstr) { s_log(LOG_ERR, ""Global options: %s"", errstr); return 1; } } if(*section_ptr!=&new_service_options || eof) { <S2SV_StartVul> if(*section_ptr==&new_service_options) <S2SV_EndVul> <S2SV_StartVul> s_log(LOG_INFO, ""Initializing inetd mode configuration""); <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> s_log(LOG_INFO, ""Initializing service [%s]"", <S2SV_EndVul> <S2SV_StartVul> (*section_ptr)->servname); <S2SV_EndVul> errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL); if(errstr) { if(*section_ptr==&new_service_options) s_log(LOG_ERR, ""Inetd mode: %s"", errstr); else s_log(LOG_ERR, ""Service [%s]: %s"", (*section_ptr)->servname, errstr); return 1; } } return 0; }","- errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);
- if(*section_ptr==&new_service_options)
- s_log(LOG_INFO, ""Initializing inetd mode configuration"");
- else
- s_log(LOG_INFO, ""Initializing service [%s]"",
- (*section_ptr)->servname);
+ errstr=parse_global_option(CMD_INITIALIZE, &new_global_options, NULL, NULL);","NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) { char *errstr; #ifndef USE_WIN32 (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr; #endif if(*section_ptr==&new_service_options) { errstr=parse_global_option(CMD_INITIALIZE, &new_global_options, NULL, NULL); if(errstr) { s_log(LOG_ERR, ""Global options: %s"", errstr); return 1; } } if(*section_ptr!=&new_service_options || eof) { errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL); if(errstr) { if(*section_ptr==&new_service_options) s_log(LOG_ERR, ""Inetd mode: %s"", errstr); else s_log(LOG_ERR, ""Service [%s]: %s"", (*section_ptr)->servname, errstr); return 1; } } return 0; }"
349,1571----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7854--wasm.c----*r_bin_wasm_get_global_entries,"static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) { RList *ret = NULL; RBinWasmGlobalEntry *ptr = NULL; <S2SV_StartVul> int buflen = bin->buf->length; <S2SV_EndVul> <S2SV_StartVul> if (sec->payload_data + 32 > buflen) { <S2SV_EndVul> <S2SV_StartVul> return NULL; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (!(ret = r_list_newf ((RListFree)free))) { return NULL; } ut8* buf = bin->buf->buf + (ut32)sec->payload_data; ut32 len = sec->payload_len; ut32 count = sec->count; ut32 i = 0, r = 0; while (i < len && len < buflen && r < count) { if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) { return ret; } if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) { goto beach; } if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) { goto beach; } if (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) { goto beach; } r_list_append (ret, ptr); r++; } return ret; beach: free (ptr); return ret; }","- int buflen = bin->buf->length;
- if (sec->payload_data + 32 > buflen) {
- return NULL;
- }
+ int buflen = bin->buf->length - (ut32)sec->payload_data;","static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) { RList *ret = NULL; RBinWasmGlobalEntry *ptr = NULL; if (!(ret = r_list_newf ((RListFree)free))) { return NULL; } ut8* buf = bin->buf->buf + (ut32)sec->payload_data; int buflen = bin->buf->length - (ut32)sec->payload_data; ut32 len = sec->payload_len; ut32 count = sec->count; ut32 i = 0, r = 0; while (i < len && len < buflen && r < count) { if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) { return ret; } if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) { goto beach; } if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) { goto beach; } if (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) { goto beach; } r_list_append (ret, ptr); r++; } return ret; beach: free (ptr); return ret; }"
350,6627----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/traps_64.c----misaligned_fpu_load,"static int misaligned_fpu_load(struct pt_regs *regs, __u32 opcode, int displacement_not_indexed, int width_shift, int do_paired_load) { int error; int destreg; __u64 address; error = generate_and_check_address(regs, opcode, displacement_not_indexed, width_shift, &address); if (error < 0) { return error; } <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address); <S2SV_EndVul> destreg = (opcode >> 4) & 0x3f; if (user_mode(regs)) { __u64 buffer; __u32 buflo, bufhi; if (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) { return -1; } if (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) { return -1; } if (last_task_used_math == current) { enable_fpu(); save_fpu(current); disable_fpu(); last_task_used_math = NULL; regs->sr |= SR_FD; } buflo = *(__u32*) &buffer; bufhi = *(1 + (__u32*) &buffer); switch (width_shift) { case 2: current->thread.xstate->hardfpu.fp_regs[destreg] = buflo; break; case 3: if (do_paired_load) { current->thread.xstate->hardfpu.fp_regs[destreg] = buflo; current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi; } else { #if defined(CONFIG_CPU_LITTLE_ENDIAN) current->thread.xstate->hardfpu.fp_regs[destreg] = bufhi; current->thread.xstate->hardfpu.fp_regs[destreg+1] = buflo; #else current->thread.xstate->hardfpu.fp_regs[destreg] = buflo; current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi; #endif } break; default: printk(""Unexpected width_shift %d in misaligned_fpu_load, PC=%08lx\n"", width_shift, (unsigned long) regs->pc); break; } return 0; } else { die (""Misaligned FPU load inside kernel"", regs, 0); return -1; } }","- perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);
+ perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);","static int misaligned_fpu_load(struct pt_regs *regs, __u32 opcode, int displacement_not_indexed, int width_shift, int do_paired_load) { int error; int destreg; __u64 address; error = generate_and_check_address(regs, opcode, displacement_not_indexed, width_shift, &address); if (error < 0) { return error; } perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address); destreg = (opcode >> 4) & 0x3f; if (user_mode(regs)) { __u64 buffer; __u32 buflo, bufhi; if (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) { return -1; } if (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) { return -1; } if (last_task_used_math == current) { enable_fpu(); save_fpu(current); disable_fpu(); last_task_used_math = NULL; regs->sr |= SR_FD; } buflo = *(__u32*) &buffer; bufhi = *(1 + (__u32*) &buffer); switch (width_shift) { case 2: current->thread.xstate->hardfpu.fp_regs[destreg] = buflo; break; case 3: if (do_paired_load) { current->thread.xstate->hardfpu.fp_regs[destreg] = buflo; current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi; } else { #if defined(CONFIG_CPU_LITTLE_ENDIAN) current->thread.xstate->hardfpu.fp_regs[destreg] = bufhi; current->thread.xstate->hardfpu.fp_regs[destreg+1] = buflo; #else current->thread.xstate->hardfpu.fp_regs[destreg] = buflo; current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi; #endif } break; default: printk(""Unexpected width_shift %d in misaligned_fpu_load, PC=%08lx\n"", width_shift, (unsigned long) regs->pc); break; } return 0; } else { die (""Misaligned FPU load inside kernel"", regs, 0); return -1; } }"
351,6873----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server_stubs.c----setkey_principal3_2_svc,"setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg; <S2SV_StartVul> gss_buffer_desc client_name, <S2SV_EndVul> <S2SV_StartVul> service_name; <S2SV_EndVul> OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) { ret.code = KADM5_BAD_PRINCIPAL; goto exit_func; } if (!(CHANGEPW_SERVICE(rqstp)) && kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_SETKEY, arg->princ, NULL)) { ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ, arg->keepold, arg->n_ks_tuple, arg->ks_tuple, arg->keyblocks, arg->n_keys); } else { log_unauth(""kadm5_setkey_principal"", prime_arg, &client_name, &service_name, rqstp); ret.code = KADM5_AUTH_SETKEY; } if(ret.code != KADM5_AUTH_SETKEY) { if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(""kadm5_setkey_principal"", prime_arg, errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } free(prime_arg); gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); <S2SV_StartVul> exit_func: <S2SV_EndVul> free_server_handle(handle); return &ret; }","- gss_buffer_desc client_name,
- service_name;
- exit_func:
+ gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER;
+ gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER;
+ exit_func:","setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER; OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) { ret.code = KADM5_BAD_PRINCIPAL; goto exit_func; } if (!(CHANGEPW_SERVICE(rqstp)) && kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_SETKEY, arg->princ, NULL)) { ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ, arg->keepold, arg->n_ks_tuple, arg->ks_tuple, arg->keyblocks, arg->n_keys); } else { log_unauth(""kadm5_setkey_principal"", prime_arg, &client_name, &service_name, rqstp); ret.code = KADM5_AUTH_SETKEY; } if(ret.code != KADM5_AUTH_SETKEY) { if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(""kadm5_setkey_principal"", prime_arg, errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } free(prime_arg); exit_func: gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); free_server_handle(handle); return &ret; }"
352,5226----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/garbage.c----unix_inflight,"<S2SV_StartVul> void unix_inflight(struct file *fp) <S2SV_EndVul> { struct sock *s = unix_get_socket(fp); spin_lock(&unix_gc_lock); if (s) { struct unix_sock *u = unix_sk(s); if (atomic_long_inc_return(&u->inflight) == 1) { BUG_ON(!list_empty(&u->link)); list_add_tail(&u->link, &gc_inflight_list); } else { BUG_ON(list_empty(&u->link)); } unix_tot_inflight++; } <S2SV_StartVul> fp->f_cred->user->unix_inflight++; <S2SV_EndVul> spin_unlock(&unix_gc_lock); }","- void unix_inflight(struct file *fp)
- fp->f_cred->user->unix_inflight++;
+ void unix_inflight(struct user_struct *user, struct file *fp)
+ user->unix_inflight++;","void unix_inflight(struct user_struct *user, struct file *fp) { struct sock *s = unix_get_socket(fp); spin_lock(&unix_gc_lock); if (s) { struct unix_sock *u = unix_sk(s); if (atomic_long_inc_return(&u->inflight) == 1) { BUG_ON(!list_empty(&u->link)); list_add_tail(&u->link, &gc_inflight_list); } else { BUG_ON(list_empty(&u->link)); } unix_tot_inflight++; } user->unix_inflight++; spin_unlock(&unix_gc_lock); }"
353,2556----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-3315--abrt-hook-ccpp.c----dump_fd_info,"static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid) { <S2SV_StartVul> FILE *fp = fopen(dest_filename, ""w""); <S2SV_EndVul> if (!fp) return false; unsigned fd = 0; while (fd <= 99999) { sprintf(source_filename + source_base_ofs, ""fd/%u"", fd); char *name = malloc_readlink(source_filename); if (!name) break; fprintf(fp, ""%u:%s\n"", fd, name); free(name); sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd); fd++; FILE *in = fopen(source_filename, ""r""); if (!in) continue; char buf[128]; while (fgets(buf, sizeof(buf)-1, in)) { char *eol = strchrnul(buf, '\n'); eol[0] = '\n'; eol[1] = '\0'; fputs(buf, fp); } fclose(in); } const int dest_fd = fileno(fp); if (fchown(dest_fd, uid, gid) < 0) { perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid); fclose(fp); unlink(dest_filename); return false; } fclose(fp); return true; }","- FILE *fp = fopen(dest_filename, ""w"");
+ FILE *fp = fopen(dest_filename, ""wx"");","static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid) { FILE *fp = fopen(dest_filename, ""wx""); if (!fp) return false; unsigned fd = 0; while (fd <= 99999) { sprintf(source_filename + source_base_ofs, ""fd/%u"", fd); char *name = malloc_readlink(source_filename); if (!name) break; fprintf(fp, ""%u:%s\n"", fd, name); free(name); sprintf(source_filename + source_base_ofs, ""fdinfo/%u"", fd); fd++; FILE *in = fopen(source_filename, ""r""); if (!in) continue; char buf[128]; while (fgets(buf, sizeof(buf)-1, in)) { char *eol = strchrnul(buf, '\n'); eol[0] = '\n'; eol[1] = '\0'; fputs(buf, fp); } fclose(in); } const int dest_fd = fileno(fp); if (fchown(dest_fd, uid, gid) < 0) { perror_msg(""Can't change '%s' ownership to %lu:%lu"", dest_filename, (long)uid, (long)gid); fclose(fp); unlink(dest_filename); return false; } fclose(fp); return true; }"
354,4890----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/super.c----f2fs_put_super,"static void f2fs_put_super(struct super_block *sb) { struct f2fs_sb_info *sbi = F2FS_SB(sb); int i; f2fs_quota_off_umount(sb); mutex_lock(&sbi->umount_mutex); if (is_sbi_flag_set(sbi, SBI_IS_DIRTY) || !is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) { struct cp_control cpc = { .reason = CP_UMOUNT, }; write_checkpoint(sbi, &cpc); } <S2SV_StartVul> f2fs_wait_discard_bios(sbi); <S2SV_EndVul> if (f2fs_discard_en(sbi) && !sbi->discard_blks) { struct cp_control cpc = { .reason = CP_UMOUNT | CP_TRIMMED, }; write_checkpoint(sbi, &cpc); } f2fs_destroy_stats(sbi); release_ino_entry(sbi, true); f2fs_leave_shrinker(sbi); mutex_unlock(&sbi->umount_mutex); f2fs_flush_merged_writes(sbi); iput(sbi->node_inode); iput(sbi->meta_inode); destroy_node_manager(sbi); destroy_segment_manager(sbi); kfree(sbi->ckpt); f2fs_unregister_sysfs(sbi); sb->s_fs_info = NULL; if (sbi->s_chksum_driver) crypto_free_shash(sbi->s_chksum_driver); kfree(sbi->raw_super); destroy_device_list(sbi); mempool_destroy(sbi->write_io_dummy); #ifdef CONFIG_QUOTA for (i = 0; i < MAXQUOTAS; i++) kfree(sbi->s_qf_names[i]); #endif destroy_percpu_info(sbi); for (i = 0; i < NR_PAGE_TYPE; i++) kfree(sbi->write_io[i]); kfree(sbi); }","- f2fs_wait_discard_bios(sbi);
+ f2fs_wait_discard_bios(sbi, true);","static void f2fs_put_super(struct super_block *sb) { struct f2fs_sb_info *sbi = F2FS_SB(sb); int i; f2fs_quota_off_umount(sb); mutex_lock(&sbi->umount_mutex); if (is_sbi_flag_set(sbi, SBI_IS_DIRTY) || !is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) { struct cp_control cpc = { .reason = CP_UMOUNT, }; write_checkpoint(sbi, &cpc); } f2fs_wait_discard_bios(sbi, true); if (f2fs_discard_en(sbi) && !sbi->discard_blks) { struct cp_control cpc = { .reason = CP_UMOUNT | CP_TRIMMED, }; write_checkpoint(sbi, &cpc); } f2fs_destroy_stats(sbi); release_ino_entry(sbi, true); f2fs_leave_shrinker(sbi); mutex_unlock(&sbi->umount_mutex); f2fs_flush_merged_writes(sbi); iput(sbi->node_inode); iput(sbi->meta_inode); destroy_node_manager(sbi); destroy_segment_manager(sbi); kfree(sbi->ckpt); f2fs_unregister_sysfs(sbi); sb->s_fs_info = NULL; if (sbi->s_chksum_driver) crypto_free_shash(sbi->s_chksum_driver); kfree(sbi->raw_super); destroy_device_list(sbi); mempool_destroy(sbi->write_io_dummy); #ifdef CONFIG_QUOTA for (i = 0; i < MAXQUOTAS; i++) kfree(sbi->s_qf_names[i]); #endif destroy_percpu_info(sbi); for (i = 0; i < NR_PAGE_TYPE; i++) kfree(sbi->write_io[i]); kfree(sbi); }"
355,3213----CWE-77----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sqlite_util_tests.cpp----osquery::getTestDBC,"std::shared_ptr<SQLiteDBInstance> getTestDBC() { auto dbc = SQLiteDBManager::getUnique(); char* err = nullptr; std::vector<std::string> queries = { <S2SV_StartVul> ""CREATE TABLE test_table (username varchar(30) primary key, age int)"", <S2SV_EndVul> ""INSERT INTO test_table VALUES (\""mike\"", 23)"", ""INSERT INTO test_table VALUES (\""matt\"", 24)""}; for (auto q : queries) { sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err); if (err != nullptr) { throw std::domain_error(std::string(""Cannot create testing DBC's db: "") + err); } } return dbc; }","- ""CREATE TABLE test_table (username varchar(30) primary key, age int)"",
+ ""CREATE TABLE test_table (username varchar(30), age int)"",","std::shared_ptr<SQLiteDBInstance> getTestDBC() { auto dbc = SQLiteDBManager::getUnique(); char* err = nullptr; std::vector<std::string> queries = { ""CREATE TABLE test_table (username varchar(30), age int)"", ""INSERT INTO test_table VALUES (\""mike\"", 23)"", ""INSERT INTO test_table VALUES (\""matt\"", 24)""}; for (auto q : queries) { sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err); if (err != nullptr) { throw std::domain_error(std::string(""Cannot create testing DBC's db: "") + err); } } return dbc; }"
356,6710----CWE-434----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/subexport.cpp----groupGenerate,"void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext) { std::string real_rule; if(startsWith(rule, ""[]"") && add_direct) { filtered_nodelist.emplace_back(rule.substr(2)); } #ifndef NO_JS_RUNTIME <S2SV_StartVul> else if(startsWith(rule, ""script:"")) <S2SV_EndVul> { script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){ std::string script = fileGet(rule.substr(7), true); try { ctx.eval(script); auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(""filter""); std::string result_list = filter(nodelist); filtered_nodelist = split(regTrim(result_list), ""\n""); } catch (qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } #endif else { for(Proxy &x : nodelist) { if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end()) filtered_nodelist.emplace_back(x.Remark); } } }","- else if(startsWith(rule, ""script:""))
+ else if(startsWith(rule, ""script:"") && ext.authorized)","void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext) { std::string real_rule; if(startsWith(rule, ""[]"") && add_direct) { filtered_nodelist.emplace_back(rule.substr(2)); } #ifndef NO_JS_RUNTIME else if(startsWith(rule, ""script:"") && ext.authorized) { script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){ std::string script = fileGet(rule.substr(7), true); try { ctx.eval(script); auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(""filter""); std::string result_list = filter(nodelist); filtered_nodelist = split(regTrim(result_list), ""\n""); } catch (qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } #endif else { for(Proxy &x : nodelist) { if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end()) filtered_nodelist.emplace_back(x.Remark); } } }"
357,2654----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/scene_dump.c----gf_dump_vrml_dyn_field,"static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist) { u32 i, sf_type; void *slot_ptr; if (gf_sg_vrml_is_sf_field(field.fieldType)) { DUMP_IND(sdump); if (sdump->XMLDump) { if (sdump->X3DDump) { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" accessType=\""%s\"""", field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1)); } else { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" vrml97Hint=\""%s\"""", field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0)); } if ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) { if (field.fieldType == GF_SG_VRML_SFNODE) { if (!sdump->X3DDump) { gf_fprintf(sdump->trace, "">\n""); sdump->indent++; gf_fprintf(sdump->trace, ""<node>""); gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); gf_fprintf(sdump->trace, ""</node>""); sdump->indent--; if (!has_sublist) gf_fprintf(sdump->trace, ""</field>\n""); } else { if (field.far_ptr) { gf_fprintf(sdump->trace, "">\n""); gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL); gf_fprintf(sdump->trace, ""</field>\n""); } else { gf_fprintf(sdump->trace, ""/>\n""); } } DUMP_IND(sdump); } else { if (sdump->X3DDump) { gf_fprintf(sdump->trace, "" value=\""""); } else { gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType)); } if (field.far_ptr) gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node); if (has_sublist) gf_fprintf(sdump->trace, ""\"">\n""); else gf_fprintf(sdump->trace, ""\""/>\n""); } } else { gf_fprintf(sdump->trace, ""/>\n""); } } else { gf_fprintf(sdump->trace, ""%s %s %s"", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name); if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) { gf_fprintf(sdump->trace, "" ""); if (field.fieldType == GF_SG_VRML_SFNODE) { gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); } else if (field.far_ptr) { gf_dump_vrml_simple_field(sdump, field, node); } } gf_fprintf(sdump->trace, ""\n""); } } else if (field.far_ptr) { GenMFField *mffield = (GenMFField *) field.far_ptr; sf_type = gf_sg_vrml_get_sf_type(field.fieldType); DUMP_IND(sdump); if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""%s %s %s"", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name); if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) { gf_fprintf(sdump->trace, "" [""); if (sf_type == GF_SG_VRML_SFNODE) { GF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr; gf_fprintf(sdump->trace, ""\n""); sdump->indent++; while (l) { gf_dump_vrml_node(sdump, l->node, 1, NULL); l = l->next; } sdump->indent--; DUMP_IND(sdump); } else { <S2SV_StartVul> for (i=0; i<mffield->count; i++) { <S2SV_EndVul> if (i) gf_fprintf(sdump->trace, "" ""); if (field.fieldType != GF_SG_VRML_MFNODE) { gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node); } } } gf_fprintf(sdump->trace, ""]""); } gf_fprintf(sdump->trace, ""\n""); } else { if (sdump->X3DDump) { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" accessType=\""%s\"""", field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1)); } else { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" vrml97Hint=\""%s\"""", field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0)); } if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) { if (sf_type == GF_SG_VRML_SFNODE) { GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr; gf_fprintf(sdump->trace, "">\n""); sdump->indent++; if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<nodes>""); while (list) { gf_dump_vrml_node(sdump, list->node, 1, NULL); list = list->next; } if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</nodes>""); sdump->indent++; DUMP_IND(sdump); if (!has_sublist) gf_fprintf(sdump->trace, ""</field>\n""); } else { if (sdump->X3DDump) { gf_fprintf(sdump->trace, "" value=\""""); } else { gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType)); } <S2SV_StartVul> for (i=0; i<mffield->count; i++) { <S2SV_EndVul> if (i) gf_fprintf(sdump->trace, "" ""); if (field.fieldType != GF_SG_VRML_MFNODE) { gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node); } } if (has_sublist) gf_fprintf(sdump->trace, ""\"">\n""); else gf_fprintf(sdump->trace, ""\""/>\n""); } } else { gf_fprintf(sdump->trace, ""/>\n""); } } } }","- for (i=0; i<mffield->count; i++) {
- for (i=0; i<mffield->count; i++) {
+ for (i=0; mffield && (i<mffield->count); i++) {
+ for (i=0; mffield && (i<mffield->count); i++) {","static void gf_dump_vrml_dyn_field(GF_SceneDumper *sdump, GF_Node *node, GF_FieldInfo field, Bool has_sublist) { u32 i, sf_type; void *slot_ptr; if (gf_sg_vrml_is_sf_field(field.fieldType)) { DUMP_IND(sdump); if (sdump->XMLDump) { if (sdump->X3DDump) { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" accessType=\""%s\"""", field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1)); } else { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" vrml97Hint=\""%s\"""", field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0)); } if ((field.eventType == GF_SG_EVENT_FIELD) || (field.eventType == GF_SG_EVENT_EXPOSED_FIELD)) { if (field.fieldType == GF_SG_VRML_SFNODE) { if (!sdump->X3DDump) { gf_fprintf(sdump->trace, "">\n""); sdump->indent++; gf_fprintf(sdump->trace, ""<node>""); gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); gf_fprintf(sdump->trace, ""</node>""); sdump->indent--; if (!has_sublist) gf_fprintf(sdump->trace, ""</field>\n""); } else { if (field.far_ptr) { gf_fprintf(sdump->trace, "">\n""); gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL); gf_fprintf(sdump->trace, ""</field>\n""); } else { gf_fprintf(sdump->trace, ""/>\n""); } } DUMP_IND(sdump); } else { if (sdump->X3DDump) { gf_fprintf(sdump->trace, "" value=\""""); } else { gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType)); } if (field.far_ptr) gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, node); if (has_sublist) gf_fprintf(sdump->trace, ""\"">\n""); else gf_fprintf(sdump->trace, ""\""/>\n""); } } else { gf_fprintf(sdump->trace, ""/>\n""); } } else { gf_fprintf(sdump->trace, ""%s %s %s"", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name); if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) { gf_fprintf(sdump->trace, "" ""); if (field.fieldType == GF_SG_VRML_SFNODE) { gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); } else if (field.far_ptr) { gf_dump_vrml_simple_field(sdump, field, node); } } gf_fprintf(sdump->trace, ""\n""); } } else if (field.far_ptr) { GenMFField *mffield = (GenMFField *) field.far_ptr; sf_type = gf_sg_vrml_get_sf_type(field.fieldType); DUMP_IND(sdump); if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""%s %s %s"", gf_sg_vrml_get_event_type_name(field.eventType, sdump->X3DDump), gf_sg_vrml_get_field_type_name(field.fieldType), field.name); if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) { gf_fprintf(sdump->trace, "" [""); if (sf_type == GF_SG_VRML_SFNODE) { GF_ChildNodeItem *l = *(GF_ChildNodeItem **)field.far_ptr; gf_fprintf(sdump->trace, ""\n""); sdump->indent++; while (l) { gf_dump_vrml_node(sdump, l->node, 1, NULL); l = l->next; } sdump->indent--; DUMP_IND(sdump); } else { for (i=0; mffield && (i<mffield->count); i++) { if (i) gf_fprintf(sdump->trace, "" ""); if (field.fieldType != GF_SG_VRML_MFNODE) { gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node); } } } gf_fprintf(sdump->trace, ""]""); } gf_fprintf(sdump->trace, ""\n""); } else { if (sdump->X3DDump) { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" accessType=\""%s\"""", field.name, gf_sg_vrml_get_field_type_name(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 1)); } else { gf_fprintf(sdump->trace, ""<field name=\""%s\"" type=\""%s\"" vrml97Hint=\""%s\"""", field.name, GetXMTFieldTypeName(field.fieldType), gf_sg_vrml_get_event_type_name(field.eventType, 0)); } if ((field.eventType==GF_SG_EVENT_FIELD) || (field.eventType==GF_SG_EVENT_EXPOSED_FIELD)) { if (sf_type == GF_SG_VRML_SFNODE) { GF_ChildNodeItem *list = *(GF_ChildNodeItem **)field.far_ptr; gf_fprintf(sdump->trace, "">\n""); sdump->indent++; if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""<nodes>""); while (list) { gf_dump_vrml_node(sdump, list->node, 1, NULL); list = list->next; } if (!sdump->X3DDump) gf_fprintf(sdump->trace, ""</nodes>""); sdump->indent++; DUMP_IND(sdump); if (!has_sublist) gf_fprintf(sdump->trace, ""</field>\n""); } else { if (sdump->X3DDump) { gf_fprintf(sdump->trace, "" value=\""""); } else { gf_fprintf(sdump->trace, "" %s=\"""", GetXMTFieldTypeValueName(field.fieldType)); } for (i=0; mffield && (i<mffield->count); i++) { if (i) gf_fprintf(sdump->trace, "" ""); if (field.fieldType != GF_SG_VRML_MFNODE) { gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node); } } if (has_sublist) gf_fprintf(sdump->trace, ""\"">\n""); else gf_fprintf(sdump->trace, ""\""/>\n""); } } else { gf_fprintf(sdump->trace, ""/>\n""); } } } }"
358,4750----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/deflate.c----deflate_huff,"local block_state deflate_huff(s, flush) deflate_state *s; int flush; { int bflush; for (;;) { if (s->lookahead == 0) { fill_window(s); if (s->lookahead == 0) { if (flush == Z_NO_FLUSH) return need_more; break; } } s->match_length = 0; Tracevv((stderr,""%c"", s->window[s->strstart])); _tr_tally_lit (s, s->window[s->strstart], bflush); s->lookahead--; s->strstart++; if (bflush) FLUSH_BLOCK(s, 0); } s->insert = 0; if (flush == Z_FINISH) { FLUSH_BLOCK(s, 1); return finish_done; } <S2SV_StartVul> if (s->last_lit) <S2SV_EndVul> FLUSH_BLOCK(s, 0); return block_done; }","- if (s->last_lit)
+ if (s->sym_next)","local block_state deflate_huff(s, flush) deflate_state *s; int flush; { int bflush; for (;;) { if (s->lookahead == 0) { fill_window(s); if (s->lookahead == 0) { if (flush == Z_NO_FLUSH) return need_more; break; } } s->match_length = 0; Tracevv((stderr,""%c"", s->window[s->strstart])); _tr_tally_lit (s, s->window[s->strstart], bflush); s->lookahead--; s->strstart++; if (bflush) FLUSH_BLOCK(s, 0); } s->insert = 0; if (flush == Z_FINISH) { FLUSH_BLOCK(s, 1); return finish_done; } if (s->sym_next) FLUSH_BLOCK(s, 0); return block_done; }"
359,7189----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pop.c----pop_fetch_message,"static int pop_fetch_message (CONTEXT* ctx, MESSAGE* msg, int msgno) { int ret; void *uidl; char buf[LONG_STRING]; char path[_POSIX_PATH_MAX]; progress_t progressbar; POP_DATA *pop_data = (POP_DATA *)ctx->data; POP_CACHE *cache; HEADER *h = ctx->hdrs[msgno]; unsigned short bcache = 1; <S2SV_StartVul> if ((msg->fp = mutt_bcache_get (pop_data->bcache, h->data))) <S2SV_EndVul> return 0; cache = &pop_data->cache[h->index % POP_CACHE_LEN]; if (cache->path) { if (cache->index == h->index) { msg->fp = fopen (cache->path, ""r""); if (msg->fp) return 0; mutt_perror (cache->path); mutt_sleep (2); return -1; } else { unlink (cache->path); FREE (&cache->path); } } FOREVER { if (pop_reconnect (ctx) < 0) return -1; if (h->refno < 0) { mutt_error _(""The message index is incorrect. Try reopening the mailbox.""); mutt_sleep (2); return -1; } mutt_progress_init (&progressbar, _(""Fetching message...""), MUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1); <S2SV_StartVul> if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1))) <S2SV_EndVul> { bcache = 0; mutt_mktemp (path, sizeof (path)); if (!(msg->fp = safe_fopen (path, ""w+""))) { mutt_perror (path); mutt_sleep (2); return -1; } } snprintf (buf, sizeof (buf), ""RETR %d\r\n"", h->refno); ret = pop_fetch_data (pop_data, buf, &progressbar, fetch_message, msg->fp); if (ret == 0) break; safe_fclose (&msg->fp); if (!bcache) unlink (path); if (ret == -2) { mutt_error (""%s"", pop_data->err_msg); mutt_sleep (2); return -1; } if (ret == -3) { mutt_error _(""Can't write message to temporary file!""); mutt_sleep (2); return -1; } } if (bcache) <S2SV_StartVul> mutt_bcache_commit (pop_data->bcache, h->data); <S2SV_EndVul> else { cache->index = h->index; cache->path = safe_strdup (path); } rewind (msg->fp); uidl = h->data; if (ctx->subj_hash && h->env->real_subj) hash_delete (ctx->subj_hash, h->env->real_subj, h, NULL); mutt_label_hash_remove (ctx, h); mutt_free_envelope (&h->env); h->env = mutt_read_rfc822_header (msg->fp, h, 0, 0); if (ctx->subj_hash && h->env->real_subj) hash_insert (ctx->subj_hash, h->env->real_subj, h); mutt_label_hash_add (ctx, h); h->data = uidl; h->lines = 0; fgets (buf, sizeof (buf), msg->fp); while (!feof (msg->fp)) { ctx->hdrs[msgno]->lines++; fgets (buf, sizeof (buf), msg->fp); } h->content->length = ftello (msg->fp) - h->content->offset; if (!WithCrypto) h->security = crypt_query (h->content); mutt_clear_error(); rewind (msg->fp); return 0; }","- if ((msg->fp = mutt_bcache_get (pop_data->bcache, h->data)))
- if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1)))
- mutt_bcache_commit (pop_data->bcache, h->data);
+ if ((msg->fp = mutt_bcache_get (pop_data->bcache, cache_id (h->data))))
+ if (!(msg->fp = mutt_bcache_put (pop_data->bcache, cache_id (h->data), 1)))
+ mutt_bcache_commit (pop_data->bcache, cache_id (h->data));","static int pop_fetch_message (CONTEXT* ctx, MESSAGE* msg, int msgno) { int ret; void *uidl; char buf[LONG_STRING]; char path[_POSIX_PATH_MAX]; progress_t progressbar; POP_DATA *pop_data = (POP_DATA *)ctx->data; POP_CACHE *cache; HEADER *h = ctx->hdrs[msgno]; unsigned short bcache = 1; if ((msg->fp = mutt_bcache_get (pop_data->bcache, cache_id (h->data)))) return 0; cache = &pop_data->cache[h->index % POP_CACHE_LEN]; if (cache->path) { if (cache->index == h->index) { msg->fp = fopen (cache->path, ""r""); if (msg->fp) return 0; mutt_perror (cache->path); mutt_sleep (2); return -1; } else { unlink (cache->path); FREE (&cache->path); } } FOREVER { if (pop_reconnect (ctx) < 0) return -1; if (h->refno < 0) { mutt_error _(""The message index is incorrect. Try reopening the mailbox.""); mutt_sleep (2); return -1; } mutt_progress_init (&progressbar, _(""Fetching message...""), MUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1); if (!(msg->fp = mutt_bcache_put (pop_data->bcache, cache_id (h->data), 1))) { bcache = 0; mutt_mktemp (path, sizeof (path)); if (!(msg->fp = safe_fopen (path, ""w+""))) { mutt_perror (path); mutt_sleep (2); return -1; } } snprintf (buf, sizeof (buf), ""RETR %d\r\n"", h->refno); ret = pop_fetch_data (pop_data, buf, &progressbar, fetch_message, msg->fp); if (ret == 0) break; safe_fclose (&msg->fp); if (!bcache) unlink (path); if (ret == -2) { mutt_error (""%s"", pop_data->err_msg); mutt_sleep (2); return -1; } if (ret == -3) { mutt_error _(""Can't write message to temporary file!""); mutt_sleep (2); return -1; } } if (bcache) mutt_bcache_commit (pop_data->bcache, cache_id (h->data)); else { cache->index = h->index; cache->path = safe_strdup (path); } rewind (msg->fp); uidl = h->data; if (ctx->subj_hash && h->env->real_subj) hash_delete (ctx->subj_hash, h->env->real_subj, h, NULL); mutt_label_hash_remove (ctx, h); mutt_free_envelope (&h->env); h->env = mutt_read_rfc822_header (msg->fp, h, 0, 0); if (ctx->subj_hash && h->env->real_subj) hash_insert (ctx->subj_hash, h->env->real_subj, h); mutt_label_hash_add (ctx, h); h->data = uidl; h->lines = 0; fgets (buf, sizeof (buf), msg->fp); while (!feof (msg->fp)) { ctx->hdrs[msgno]->lines++; fgets (buf, sizeof (buf), msg->fp); } h->content->length = ftello (msg->fp) - h->content->offset; if (!WithCrypto) h->security = crypt_query (h->content); mutt_clear_error(); rewind (msg->fp); return 0; }"
360,5509----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/util.c----get_devices_from_authfile,"int get_devices_from_authfile(const char *authfile, const char *username, unsigned max_devs, int verbose, FILE *debug_file, device_t *devices, unsigned *n_devs) { char *buf = NULL; char *s_user, *s_token; int retval = 0; int fd = -1; struct stat st; struct passwd *pw = NULL, pw_s; char buffer[BUFSIZE]; int gpu_ret; FILE *opwfile = NULL; unsigned i, j; *n_devs = 0; <S2SV_StartVul> fd = open(authfile, O_RDONLY, 0); <S2SV_EndVul> if (fd < 0) { if (verbose) D(debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno)); goto err; } if (fstat(fd, &st) < 0) { if (verbose) D(debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno)); goto err; } if (!S_ISREG(st.st_mode)) { if (verbose) D(debug_file, ""%s is not a regular file"", authfile); goto err; } if (st.st_size == 0) { if (verbose) D(debug_file, ""File %s is empty"", authfile); goto err; } gpu_ret = getpwuid_r(st.st_uid, &pw_s, buffer, sizeof(buffer), &pw); if (gpu_ret != 0 || pw == NULL) { D(debug_file, ""Unable to retrieve credentials for uid %u, (%s)"", st.st_uid, strerror(errno)); goto err; } if (strcmp(pw->pw_name, username) != 0 && strcmp(pw->pw_name, ""root"") != 0) { if (strcmp(username, ""root"") != 0) { D(debug_file, ""The owner of the authentication file is neither %s nor root"", username); } else { D(debug_file, ""The owner of the authentication file is not root""); } goto err; } opwfile = fdopen(fd, ""r""); if (opwfile == NULL) { if (verbose) D(debug_file, ""fdopen: %s"", strerror(errno)); goto err; } buf = malloc(sizeof(char) * (DEVSIZE * max_devs)); if (!buf) { if (verbose) D(debug_file, ""Unable to allocate memory""); goto err; } retval = -2; while (fgets(buf, (int)(DEVSIZE * (max_devs - 1)), opwfile)) { char *saveptr = NULL; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = '\0'; if (verbose) D(debug_file, ""Authorization line: %s"", buf); s_user = strtok_r(buf, "":"", &saveptr); if (s_user && strcmp(username, s_user) == 0) { if (verbose) D(debug_file, ""Matched user: %s"", s_user); retval = -1; for (i = 0; i < *n_devs; i++) { free(devices[i].keyHandle); free(devices[i].publicKey); devices[i].keyHandle = NULL; devices[i].publicKey = NULL; } *n_devs = 0; i = 0; while ((s_token = strtok_r(NULL, "","", &saveptr))) { devices[i].keyHandle = NULL; devices[i].publicKey = NULL; if ((*n_devs)++ > MAX_DEVS - 1) { *n_devs = MAX_DEVS; if (verbose) D(debug_file, ""Found more than %d devices, ignoring the remaining ones"", MAX_DEVS); break; } if (verbose) D(debug_file, ""KeyHandle for device number %d: %s"", i + 1, s_token); devices[i].keyHandle = strdup(s_token); if (!devices[i].keyHandle) { if (verbose) D(debug_file, ""Unable to allocate memory for keyHandle number %d"", i); goto err; } s_token = strtok_r(NULL, "":"", &saveptr); if (!s_token) { if (verbose) D(debug_file, ""Unable to retrieve publicKey number %d"", i + 1); goto err; } if (verbose) D(debug_file, ""publicKey for device number %d: %s"", i + 1, s_token); if (strlen(s_token) % 2 != 0) { if (verbose) D(debug_file, ""Length of key number %d not even"", i + 1); goto err; } devices[i].key_len = strlen(s_token) / 2; if (verbose) D(debug_file, ""Length of key number %d is %zu"", i + 1, devices[i].key_len); devices[i].publicKey = malloc((sizeof(unsigned char) * devices[i].key_len)); if (!devices[i].publicKey) { if (verbose) D(debug_file, ""Unable to allocate memory for publicKey number %d"", i); goto err; } for (j = 0; j < devices[i].key_len; j++) { unsigned int x; if (sscanf(&s_token[2 * j], ""%2x"", &x) != 1) { if (verbose) D(debug_file, ""Invalid hex number in key""); goto err; } devices[i].publicKey[j] = (unsigned char)x; } i++; } } } if (verbose) D(debug_file, ""Found %d device(s) for user %s"", *n_devs, username); retval = 1; goto out; err: for (i = 0; i < *n_devs; i++) { free(devices[i].keyHandle); free(devices[i].publicKey); devices[i].keyHandle = NULL; devices[i].publicKey = NULL; } *n_devs = 0; out: if (buf) { free(buf); buf = NULL; } if (opwfile) fclose(opwfile); <S2SV_StartVul> else if (fd >= 0) <S2SV_EndVul> close(fd); return retval; }","- fd = open(authfile, O_RDONLY, 0);
- else if (fd >= 0)
+ fd = open(authfile, O_RDONLY | O_CLOEXEC | O_NOCTTY);
+ } else {
+ if (fd != -1)","int get_devices_from_authfile(const char *authfile, const char *username, unsigned max_devs, int verbose, FILE *debug_file, device_t *devices, unsigned *n_devs) { char *buf = NULL; char *s_user, *s_token; int retval = 0; int fd = -1; struct stat st; struct passwd *pw = NULL, pw_s; char buffer[BUFSIZE]; int gpu_ret; FILE *opwfile = NULL; unsigned i, j; *n_devs = 0; fd = open(authfile, O_RDONLY | O_CLOEXEC | O_NOCTTY); if (fd < 0) { if (verbose) D(debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno)); goto err; } if (fstat(fd, &st) < 0) { if (verbose) D(debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno)); goto err; } if (!S_ISREG(st.st_mode)) { if (verbose) D(debug_file, ""%s is not a regular file"", authfile); goto err; } if (st.st_size == 0) { if (verbose) D(debug_file, ""File %s is empty"", authfile); goto err; } gpu_ret = getpwuid_r(st.st_uid, &pw_s, buffer, sizeof(buffer), &pw); if (gpu_ret != 0 || pw == NULL) { D(debug_file, ""Unable to retrieve credentials for uid %u, (%s)"", st.st_uid, strerror(errno)); goto err; } if (strcmp(pw->pw_name, username) != 0 && strcmp(pw->pw_name, ""root"") != 0) { if (strcmp(username, ""root"") != 0) { D(debug_file, ""The owner of the authentication file is neither %s nor root"", username); } else { D(debug_file, ""The owner of the authentication file is not root""); } goto err; } opwfile = fdopen(fd, ""r""); if (opwfile == NULL) { if (verbose) D(debug_file, ""fdopen: %s"", strerror(errno)); goto err; } else { fd = -1; } buf = malloc(sizeof(char) * (DEVSIZE * max_devs)); if (!buf) { if (verbose) D(debug_file, ""Unable to allocate memory""); goto err; } retval = -2; while (fgets(buf, (int)(DEVSIZE * (max_devs - 1)), opwfile)) { char *saveptr = NULL; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = '\0'; if (verbose) D(debug_file, ""Authorization line: %s"", buf); s_user = strtok_r(buf, "":"", &saveptr); if (s_user && strcmp(username, s_user) == 0) { if (verbose) D(debug_file, ""Matched user: %s"", s_user); retval = -1; for (i = 0; i < *n_devs; i++) { free(devices[i].keyHandle); free(devices[i].publicKey); devices[i].keyHandle = NULL; devices[i].publicKey = NULL; } *n_devs = 0; i = 0; while ((s_token = strtok_r(NULL, "","", &saveptr))) { devices[i].keyHandle = NULL; devices[i].publicKey = NULL; if ((*n_devs)++ > MAX_DEVS - 1) { *n_devs = MAX_DEVS; if (verbose) D(debug_file, ""Found more than %d devices, ignoring the remaining ones"", MAX_DEVS); break; } if (verbose) D(debug_file, ""KeyHandle for device number %d: %s"", i + 1, s_token); devices[i].keyHandle = strdup(s_token); if (!devices[i].keyHandle) { if (verbose) D(debug_file, ""Unable to allocate memory for keyHandle number %d"", i); goto err; } s_token = strtok_r(NULL, "":"", &saveptr); if (!s_token) { if (verbose) D(debug_file, ""Unable to retrieve publicKey number %d"", i + 1); goto err; } if (verbose) D(debug_file, ""publicKey for device number %d: %s"", i + 1, s_token); if (strlen(s_token) % 2 != 0) { if (verbose) D(debug_file, ""Length of key number %d not even"", i + 1); goto err; } devices[i].key_len = strlen(s_token) / 2; if (verbose) D(debug_file, ""Length of key number %d is %zu"", i + 1, devices[i].key_len); devices[i].publicKey = malloc((sizeof(unsigned char) * devices[i].key_len)); if (!devices[i].publicKey) { if (verbose) D(debug_file, ""Unable to allocate memory for publicKey number %d"", i); goto err; } for (j = 0; j < devices[i].key_len; j++) { unsigned int x; if (sscanf(&s_token[2 * j], ""%2x"", &x) != 1) { if (verbose) D(debug_file, ""Invalid hex number in key""); goto err; } devices[i].publicKey[j] = (unsigned char)x; } i++; } } } if (verbose) D(debug_file, ""Found %d device(s) for user %s"", *n_devs, username); retval = 1; goto out; err: for (i = 0; i < *n_devs; i++) { free(devices[i].keyHandle); free(devices[i].publicKey); devices[i].keyHandle = NULL; devices[i].publicKey = NULL; } *n_devs = 0; out: if (buf) { free(buf); buf = NULL; } if (opwfile) fclose(opwfile); if (fd != -1) close(fd); return retval; }"
361,5607----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/index.c----read_entry,"static int read_entry( git_index_entry **out, size_t *out_size, git_index *index, const void *buffer, size_t buffer_size, const char *last) { size_t path_length, entry_size; const char *path_ptr; struct entry_short source; git_index_entry entry = {{0}}; bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP; char *tmp_path = NULL; if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size) return -1; memcpy(&source, buffer, sizeof(struct entry_short)); entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds); entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds); entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds); entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds); entry.dev = ntohl(source.dev); entry.ino = ntohl(source.ino); entry.mode = ntohl(source.mode); entry.uid = ntohl(source.uid); entry.gid = ntohl(source.gid); entry.file_size = ntohl(source.file_size); git_oid_cpy(&entry.id, &source.oid); entry.flags = ntohs(source.flags); if (entry.flags & GIT_IDXENTRY_EXTENDED) { uint16_t flags_raw; size_t flags_offset; flags_offset = offsetof(struct entry_long, flags_extended); memcpy(&flags_raw, (const char *) buffer + flags_offset, sizeof(flags_raw)); flags_raw = ntohs(flags_raw); memcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw)); path_ptr = (const char *) buffer + offsetof(struct entry_long, path); } else path_ptr = (const char *) buffer + offsetof(struct entry_short, path); if (!compressed) { path_length = entry.flags & GIT_IDXENTRY_NAMEMASK; if (path_length == 0xFFF) { const char *path_end; path_end = memchr(path_ptr, '\0', buffer_size); if (path_end == NULL) return -1; path_length = path_end - path_ptr; } entry_size = index_entry_size(path_length, 0, entry.flags); entry.path = (char *)path_ptr; } else { <S2SV_StartVul> size_t varint_len; <S2SV_EndVul> <S2SV_StartVul> size_t strip_len = git_decode_varint((const unsigned char *)path_ptr, <S2SV_EndVul> <S2SV_StartVul> &varint_len); <S2SV_EndVul> <S2SV_StartVul> size_t last_len = strlen(last); <S2SV_EndVul> <S2SV_StartVul> size_t prefix_len = last_len - strip_len; <S2SV_EndVul> <S2SV_StartVul> size_t suffix_len = strlen(path_ptr + varint_len); <S2SV_EndVul> <S2SV_StartVul> size_t path_len; <S2SV_EndVul> <S2SV_StartVul> if (varint_len == 0) <S2SV_EndVul> return index_error_invalid(""incorrect prefix length""); GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len); GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1); tmp_path = git__malloc(path_len); GITERR_CHECK_ALLOC(tmp_path); memcpy(tmp_path, last, prefix_len); memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1); entry_size = index_entry_size(suffix_len, varint_len, entry.flags); entry.path = tmp_path; } if (entry_size == 0) return -1; if (INDEX_FOOTER_SIZE + entry_size > buffer_size) return -1; if (index_entry_dup(out, index, &entry) < 0) { git__free(tmp_path); return -1; } git__free(tmp_path); *out_size = entry_size; return 0; }","- size_t varint_len;
- size_t strip_len = git_decode_varint((const unsigned char *)path_ptr,
- &varint_len);
- size_t last_len = strlen(last);
- size_t prefix_len = last_len - strip_len;
- size_t suffix_len = strlen(path_ptr + varint_len);
- size_t path_len;
- if (varint_len == 0)
+ size_t varint_len, last_len, prefix_len, suffix_len, path_len;
+ uintmax_t strip_len;
+ strip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len);
+ last_len = strlen(last);
+ if (varint_len == 0 || last_len < strip_len)
+ prefix_len = last_len - strip_len;
+ suffix_len = strlen(path_ptr + varint_len);","static int read_entry( git_index_entry **out, size_t *out_size, git_index *index, const void *buffer, size_t buffer_size, const char *last) { size_t path_length, entry_size; const char *path_ptr; struct entry_short source; git_index_entry entry = {{0}}; bool compressed = index->version >= INDEX_VERSION_NUMBER_COMP; char *tmp_path = NULL; if (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size) return -1; memcpy(&source, buffer, sizeof(struct entry_short)); entry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds); entry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds); entry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds); entry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds); entry.dev = ntohl(source.dev); entry.ino = ntohl(source.ino); entry.mode = ntohl(source.mode); entry.uid = ntohl(source.uid); entry.gid = ntohl(source.gid); entry.file_size = ntohl(source.file_size); git_oid_cpy(&entry.id, &source.oid); entry.flags = ntohs(source.flags); if (entry.flags & GIT_IDXENTRY_EXTENDED) { uint16_t flags_raw; size_t flags_offset; flags_offset = offsetof(struct entry_long, flags_extended); memcpy(&flags_raw, (const char *) buffer + flags_offset, sizeof(flags_raw)); flags_raw = ntohs(flags_raw); memcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw)); path_ptr = (const char *) buffer + offsetof(struct entry_long, path); } else path_ptr = (const char *) buffer + offsetof(struct entry_short, path); if (!compressed) { path_length = entry.flags & GIT_IDXENTRY_NAMEMASK; if (path_length == 0xFFF) { const char *path_end; path_end = memchr(path_ptr, '\0', buffer_size); if (path_end == NULL) return -1; path_length = path_end - path_ptr; } entry_size = index_entry_size(path_length, 0, entry.flags); entry.path = (char *)path_ptr; } else { size_t varint_len, last_len, prefix_len, suffix_len, path_len; uintmax_t strip_len; strip_len = git_decode_varint((const unsigned char *)path_ptr, &varint_len); last_len = strlen(last); if (varint_len == 0 || last_len < strip_len) return index_error_invalid(""incorrect prefix length""); prefix_len = last_len - strip_len; suffix_len = strlen(path_ptr + varint_len); GITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len); GITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1); tmp_path = git__malloc(path_len); GITERR_CHECK_ALLOC(tmp_path); memcpy(tmp_path, last, prefix_len); memcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1); entry_size = index_entry_size(suffix_len, varint_len, entry.flags); entry.path = tmp_path; } if (entry_size == 0) return -1; if (INDEX_FOOTER_SIZE + entry_size > buffer_size) return -1; if (index_entry_dup(out, index, &entry) < 0) { git__free(tmp_path); return -1; } git__free(tmp_path); *out_size = entry_size; return 0; }"
362,6374----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sched.c----set_task_cpu,"void set_task_cpu(struct task_struct *p, unsigned int new_cpu) { #ifdef CONFIG_SCHED_DEBUG WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && !(task_thread_info(p)->preempt_count & PREEMPT_ACTIVE)); #ifdef CONFIG_LOCKDEP WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || lockdep_is_held(&task_rq(p)->lock))); #endif #endif trace_sched_migrate_task(p, new_cpu); if (task_cpu(p) != new_cpu) { p->se.nr_migrations++; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 1, NULL, 0); <S2SV_EndVul> } __set_task_cpu(p, new_cpu); }","- perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 1, NULL, 0);
+ perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);","void set_task_cpu(struct task_struct *p, unsigned int new_cpu) { #ifdef CONFIG_SCHED_DEBUG WARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING && !(task_thread_info(p)->preempt_count & PREEMPT_ACTIVE)); #ifdef CONFIG_LOCKDEP WARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) || lockdep_is_held(&task_rq(p)->lock))); #endif #endif trace_sched_migrate_task(p, new_cpu); if (task_cpu(p) != new_cpu) { p->se.nr_migrations++; perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0); } __set_task_cpu(p, new_cpu); }"
363,445----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4129--br_mdb.c----__br_mdb_del,"static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry) { struct net_bridge_mdb_htable *mdb; struct net_bridge_mdb_entry *mp; struct net_bridge_port_group *p; struct net_bridge_port_group __rcu **pp; struct br_ip ip; int err = -EINVAL; if (!netif_running(br->dev) || br->multicast_disabled) return -EINVAL; if (timer_pending(&br->multicast_querier_timer)) return -EBUSY; ip.proto = entry->addr.proto; if (ip.proto == htons(ETH_P_IP)) ip.u.ip4 = entry->addr.u.ip4; #if IS_ENABLED(CONFIG_IPV6) else ip.u.ip6 = entry->addr.u.ip6; #endif spin_lock_bh(&br->multicast_lock); mdb = mlock_dereference(br->mdb, br); mp = br_mdb_ip_get(mdb, &ip); if (!mp) goto unlock; for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL; pp = &p->next) { if (!p->port || p->port->dev->ifindex != entry->ifindex) continue; if (p->port->state == BR_STATE_DISABLED) goto unlock; rcu_assign_pointer(*pp, p->next); hlist_del_init(&p->mglist); del_timer(&p->timer); call_rcu_bh(&p->rcu, br_multicast_free_pg); err = 0; <S2SV_StartVul> if (!mp->ports && !mp->mglist && <S2SV_EndVul> netif_running(br->dev)) mod_timer(&mp->timer, jiffies); break; } unlock: spin_unlock_bh(&br->multicast_lock); return err; }","- if (!mp->ports && !mp->mglist &&
+ if (!mp->ports && !mp->mglist && mp->timer_armed &&","static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry) { struct net_bridge_mdb_htable *mdb; struct net_bridge_mdb_entry *mp; struct net_bridge_port_group *p; struct net_bridge_port_group __rcu **pp; struct br_ip ip; int err = -EINVAL; if (!netif_running(br->dev) || br->multicast_disabled) return -EINVAL; if (timer_pending(&br->multicast_querier_timer)) return -EBUSY; ip.proto = entry->addr.proto; if (ip.proto == htons(ETH_P_IP)) ip.u.ip4 = entry->addr.u.ip4; #if IS_ENABLED(CONFIG_IPV6) else ip.u.ip6 = entry->addr.u.ip6; #endif spin_lock_bh(&br->multicast_lock); mdb = mlock_dereference(br->mdb, br); mp = br_mdb_ip_get(mdb, &ip); if (!mp) goto unlock; for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL; pp = &p->next) { if (!p->port || p->port->dev->ifindex != entry->ifindex) continue; if (p->port->state == BR_STATE_DISABLED) goto unlock; rcu_assign_pointer(*pp, p->next); hlist_del_init(&p->mglist); del_timer(&p->timer); call_rcu_bh(&p->rcu, br_multicast_free_pg); err = 0; if (!mp->ports && !mp->mglist && mp->timer_armed && netif_running(br->dev)) mod_timer(&mp->timer, jiffies); break; } unlock: spin_unlock_bh(&br->multicast_lock); return err; }"
364,2514----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-9993--hls.c----open_url,"static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url, AVDictionary *opts, AVDictionary *opts2, int *is_http) { HLSContext *c = s->priv_data; AVDictionary *tmp = NULL; const char *proto_name = NULL; int ret; av_dict_copy(&tmp, opts, 0); av_dict_copy(&tmp, opts2, 0); if (av_strstart(url, ""crypto"", NULL)) { if (url[6] == '+' || url[6] == ':') proto_name = avio_find_protocol_name(url + 7); } if (!proto_name) proto_name = avio_find_protocol_name(url); if (!proto_name) return AVERROR_INVALIDDATA; if (!av_strstart(proto_name, ""http"", NULL) && !av_strstart(proto_name, ""file"", NULL)) <S2SV_StartVul> return AVERROR_INVALIDDATA; <S2SV_EndVul> if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':') ; else if (av_strstart(url, ""crypto"", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':') ; else if (strcmp(proto_name, ""file"") || !strncmp(url, ""file,"", 5)) return AVERROR_INVALIDDATA; ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp); if (ret >= 0) { char *new_cookies = NULL; if (!(s->flags & AVFMT_FLAG_CUSTOM_IO)) av_opt_get(*pb, ""cookies"", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies); if (new_cookies) { av_free(c->cookies); c->cookies = new_cookies; } av_dict_set(&opts, ""cookies"", c->cookies, 0); } av_dict_free(&tmp); if (is_http) *is_http = av_strstart(proto_name, ""http"", NULL); return ret; }","- return AVERROR_INVALIDDATA;
+ if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+ av_log(s, AV_LOG_ERROR,
+ ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+ ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+ url);
+ return AVERROR_INVALIDDATA;
+ }
+ } else if (av_strstart(proto_name, ""http"", NULL)) {
+ ;
+ } else
+ return AVERROR_INVALIDDATA;","static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url, AVDictionary *opts, AVDictionary *opts2, int *is_http) { HLSContext *c = s->priv_data; AVDictionary *tmp = NULL; const char *proto_name = NULL; int ret; av_dict_copy(&tmp, opts, 0); av_dict_copy(&tmp, opts2, 0); if (av_strstart(url, ""crypto"", NULL)) { if (url[6] == '+' || url[6] == ':') proto_name = avio_find_protocol_name(url + 7); } if (!proto_name) proto_name = avio_find_protocol_name(url); if (!proto_name) return AVERROR_INVALIDDATA; if (av_strstart(proto_name, ""file"", NULL)) { if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) { av_log(s, AV_LOG_ERROR, ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n"" ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"", url); return AVERROR_INVALIDDATA; } } else if (av_strstart(proto_name, ""http"", NULL)) { ; } else return AVERROR_INVALIDDATA; if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':') ; else if (av_strstart(url, ""crypto"", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':') ; else if (strcmp(proto_name, ""file"") || !strncmp(url, ""file,"", 5)) return AVERROR_INVALIDDATA; ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp); if (ret >= 0) { char *new_cookies = NULL; if (!(s->flags & AVFMT_FLAG_CUSTOM_IO)) av_opt_get(*pb, ""cookies"", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies); if (new_cookies) { av_free(c->cookies); c->cookies = new_cookies; } av_dict_set(&opts, ""cookies"", c->cookies, 0); } av_dict_free(&tmp); if (is_http) *is_http = av_strstart(proto_name, ""http"", NULL); return ret; }"
365,1918----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-18955--user_namespace.c----map_write,"static ssize_t map_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos, int cap_setid, struct uid_gid_map *map, struct uid_gid_map *parent_map) { struct seq_file *seq = file->private_data; struct user_namespace *ns = seq->private; struct uid_gid_map new_map; unsigned idx; struct uid_gid_extent extent; char *kbuf = NULL, *pos, *next_line; ssize_t ret; if ((*ppos != 0) || (count >= PAGE_SIZE)) return -EINVAL; kbuf = memdup_user_nul(buf, count); if (IS_ERR(kbuf)) return PTR_ERR(kbuf); mutex_lock(&userns_state_mutex); memset(&new_map, 0, sizeof(struct uid_gid_map)); ret = -EPERM; if (map->nr_extents != 0) goto out; if (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN)) goto out; ret = -EINVAL; pos = kbuf; for (; pos; pos = next_line) { next_line = strchr(pos, '\n'); if (next_line) { *next_line = '\0'; next_line++; if (*next_line == '\0') next_line = NULL; } pos = skip_spaces(pos); extent.first = simple_strtoul(pos, &pos, 10); if (!isspace(*pos)) goto out; pos = skip_spaces(pos); extent.lower_first = simple_strtoul(pos, &pos, 10); if (!isspace(*pos)) goto out; pos = skip_spaces(pos); extent.count = simple_strtoul(pos, &pos, 10); if (*pos && !isspace(*pos)) goto out; pos = skip_spaces(pos); if (*pos != '\0') goto out; if ((extent.first == (u32) -1) || (extent.lower_first == (u32) -1)) goto out; if ((extent.first + extent.count) <= extent.first) goto out; if ((extent.lower_first + extent.count) <= extent.lower_first) goto out; if (mappings_overlap(&new_map, &extent)) goto out; if ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS && (next_line != NULL)) goto out; ret = insert_extent(&new_map, &extent); if (ret < 0) goto out; ret = -EINVAL; } if (new_map.nr_extents == 0) goto out; ret = -EPERM; if (!new_idmap_permitted(file, ns, cap_setid, &new_map)) goto out; <S2SV_StartVul> ret = sort_idmaps(&new_map); <S2SV_EndVul> <S2SV_StartVul> if (ret < 0) <S2SV_EndVul> <S2SV_StartVul> goto out; <S2SV_EndVul> ret = -EPERM; for (idx = 0; idx < new_map.nr_extents; idx++) { struct uid_gid_extent *e; u32 lower_first; if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) e = &new_map.extent[idx]; else e = &new_map.forward[idx]; lower_first = map_id_range_down(parent_map, e->lower_first, e->count); if (lower_first == (u32) -1) goto out; e->lower_first = lower_first; } if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) { memcpy(map->extent, new_map.extent, new_map.nr_extents * sizeof(new_map.extent[0])); } else { map->forward = new_map.forward; map->reverse = new_map.reverse; } smp_wmb(); map->nr_extents = new_map.nr_extents; *ppos = count; ret = count; out: if (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) { kfree(new_map.forward); kfree(new_map.reverse); map->forward = NULL; map->reverse = NULL; map->nr_extents = 0; } mutex_unlock(&userns_state_mutex); kfree(kbuf); return ret; }","- ret = sort_idmaps(&new_map);
- if (ret < 0)
- goto out;
+ ret = sort_idmaps(&new_map);
+ if (ret < 0)
+ goto out;","static ssize_t map_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos, int cap_setid, struct uid_gid_map *map, struct uid_gid_map *parent_map) { struct seq_file *seq = file->private_data; struct user_namespace *ns = seq->private; struct uid_gid_map new_map; unsigned idx; struct uid_gid_extent extent; char *kbuf = NULL, *pos, *next_line; ssize_t ret; if ((*ppos != 0) || (count >= PAGE_SIZE)) return -EINVAL; kbuf = memdup_user_nul(buf, count); if (IS_ERR(kbuf)) return PTR_ERR(kbuf); mutex_lock(&userns_state_mutex); memset(&new_map, 0, sizeof(struct uid_gid_map)); ret = -EPERM; if (map->nr_extents != 0) goto out; if (cap_valid(cap_setid) && !file_ns_capable(file, ns, CAP_SYS_ADMIN)) goto out; ret = -EINVAL; pos = kbuf; for (; pos; pos = next_line) { next_line = strchr(pos, '\n'); if (next_line) { *next_line = '\0'; next_line++; if (*next_line == '\0') next_line = NULL; } pos = skip_spaces(pos); extent.first = simple_strtoul(pos, &pos, 10); if (!isspace(*pos)) goto out; pos = skip_spaces(pos); extent.lower_first = simple_strtoul(pos, &pos, 10); if (!isspace(*pos)) goto out; pos = skip_spaces(pos); extent.count = simple_strtoul(pos, &pos, 10); if (*pos && !isspace(*pos)) goto out; pos = skip_spaces(pos); if (*pos != '\0') goto out; if ((extent.first == (u32) -1) || (extent.lower_first == (u32) -1)) goto out; if ((extent.first + extent.count) <= extent.first) goto out; if ((extent.lower_first + extent.count) <= extent.lower_first) goto out; if (mappings_overlap(&new_map, &extent)) goto out; if ((new_map.nr_extents + 1) == UID_GID_MAP_MAX_EXTENTS && (next_line != NULL)) goto out; ret = insert_extent(&new_map, &extent); if (ret < 0) goto out; ret = -EINVAL; } if (new_map.nr_extents == 0) goto out; ret = -EPERM; if (!new_idmap_permitted(file, ns, cap_setid, &new_map)) goto out; ret = -EPERM; for (idx = 0; idx < new_map.nr_extents; idx++) { struct uid_gid_extent *e; u32 lower_first; if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) e = &new_map.extent[idx]; else e = &new_map.forward[idx]; lower_first = map_id_range_down(parent_map, e->lower_first, e->count); if (lower_first == (u32) -1) goto out; e->lower_first = lower_first; } ret = sort_idmaps(&new_map); if (ret < 0) goto out; if (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) { memcpy(map->extent, new_map.extent, new_map.nr_extents * sizeof(new_map.extent[0])); } else { map->forward = new_map.forward; map->reverse = new_map.reverse; } smp_wmb(); map->nr_extents = new_map.nr_extents; *ppos = count; ret = count; out: if (ret < 0 && new_map.nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS) { kfree(new_map.forward); kfree(new_map.reverse); map->forward = NULL; map->reverse = NULL; map->nr_extents = 0; } mutex_unlock(&userns_state_mutex); kfree(kbuf); return ret; }"
366,1162--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8324--extents.c----ext4_ext_handle_uninitialized_extents,"ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode, ext4_lblk_t iblock, unsigned int max_blocks, struct ext4_ext_path *path, int flags, unsigned int allocated, struct buffer_head *bh_result, ext4_fsblk_t newblock) { int ret = 0; int err = 0; ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio; ext_debug(""ext4_ext_handle_uninitialized_extents: inode %lu, logical"" ""block %llu, max_blocks %u, flags %d, allocated %u"", inode->i_ino, (unsigned long long)iblock, max_blocks, flags, allocated); ext4_ext_show_leaf(inode, path); <S2SV_StartVul> if (flags == EXT4_GET_BLOCKS_PRE_IO) { <S2SV_EndVul> ret = ext4_split_unwritten_extents(handle, inode, path, iblock, max_blocks, flags); if (io) io->flag = EXT4_IO_UNWRITTEN; else ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN); goto out; } <S2SV_StartVul> if (flags == EXT4_GET_BLOCKS_CONVERT) { <S2SV_EndVul> ret = ext4_convert_unwritten_extents_endio(handle, inode, path); if (ret >= 0) ext4_update_inode_fsync_trans(handle, inode, 1); goto out2; } if (flags & EXT4_GET_BLOCKS_UNINIT_EXT) goto map_out; if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) { set_buffer_unwritten(bh_result); goto out1; } ret = ext4_ext_convert_to_initialized(handle, inode, path, iblock, max_blocks); if (ret >= 0) ext4_update_inode_fsync_trans(handle, inode, 1); out: if (ret <= 0) { err = ret; goto out2; } else allocated = ret; set_buffer_new(bh_result); if (allocated > max_blocks) { unmap_underlying_metadata_blocks(inode->i_sb->s_bdev, newblock + max_blocks, allocated - max_blocks); allocated = max_blocks; } if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) ext4_da_update_reserve_space(inode, allocated, 0); map_out: set_buffer_mapped(bh_result); out1: if (allocated > max_blocks) allocated = max_blocks; ext4_ext_show_leaf(inode, path); bh_result->b_bdev = inode->i_sb->s_bdev; bh_result->b_blocknr = newblock; out2: if (path) { ext4_ext_drop_refs(path); kfree(path); } return err ? err : allocated; }","- if (flags == EXT4_GET_BLOCKS_PRE_IO) {
- if (flags == EXT4_GET_BLOCKS_CONVERT) {
+ if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {
+ if (ext4_should_dioread_nolock(inode))
+ set_buffer_uninit(bh_result);
+ if ((flags & EXT4_GET_BLOCKS_CONVERT)) {","ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode, ext4_lblk_t iblock, unsigned int max_blocks, struct ext4_ext_path *path, int flags, unsigned int allocated, struct buffer_head *bh_result, ext4_fsblk_t newblock) { int ret = 0; int err = 0; ext4_io_end_t *io = EXT4_I(inode)->cur_aio_dio; ext_debug(""ext4_ext_handle_uninitialized_extents: inode %lu, logical"" ""block %llu, max_blocks %u, flags %d, allocated %u"", inode->i_ino, (unsigned long long)iblock, max_blocks, flags, allocated); ext4_ext_show_leaf(inode, path); if ((flags & EXT4_GET_BLOCKS_PRE_IO)) { ret = ext4_split_unwritten_extents(handle, inode, path, iblock, max_blocks, flags); if (io) io->flag = EXT4_IO_UNWRITTEN; else ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN); if (ext4_should_dioread_nolock(inode)) set_buffer_uninit(bh_result); goto out; } if ((flags & EXT4_GET_BLOCKS_CONVERT)) { ret = ext4_convert_unwritten_extents_endio(handle, inode, path); if (ret >= 0) ext4_update_inode_fsync_trans(handle, inode, 1); goto out2; } if (flags & EXT4_GET_BLOCKS_UNINIT_EXT) goto map_out; if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) { set_buffer_unwritten(bh_result); goto out1; } ret = ext4_ext_convert_to_initialized(handle, inode, path, iblock, max_blocks); if (ret >= 0) ext4_update_inode_fsync_trans(handle, inode, 1); out: if (ret <= 0) { err = ret; goto out2; } else allocated = ret; set_buffer_new(bh_result); if (allocated > max_blocks) { unmap_underlying_metadata_blocks(inode->i_sb->s_bdev, newblock + max_blocks, allocated - max_blocks); allocated = max_blocks; } if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) ext4_da_update_reserve_space(inode, allocated, 0); map_out: set_buffer_mapped(bh_result); out1: if (allocated > max_blocks) allocated = max_blocks; ext4_ext_show_leaf(inode, path); bh_result->b_bdev = inode->i_sb->s_bdev; bh_result->b_blocknr = newblock; out2: if (path) { ext4_ext_drop_refs(path); kfree(path); } return err ? err : allocated; }"
367,3465----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/base64.c----mutt_from_base64,"<S2SV_StartVul> int mutt_from_base64 (char *out, const char *in) <S2SV_EndVul> { int len = 0; register unsigned char digit1, digit2, digit3, digit4; do { digit1 = in[0]; if (digit1 > 127 || base64val (digit1) == BAD) return -1; digit2 = in[1]; if (digit2 > 127 || base64val (digit2) == BAD) return -1; digit3 = in[2]; if (digit3 > 127 || ((digit3 != '=') && (base64val (digit3) == BAD))) return -1; digit4 = in[3]; if (digit4 > 127 || ((digit4 != '=') && (base64val (digit4) == BAD))) return -1; in += 4; *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4); len++; if (digit3 != '=') { *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2); len++; if (digit4 != '=') { *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4); len++; } } } while (*in && digit4 != '='); return len; }","- int mutt_from_base64 (char *out, const char *in)
+ int mutt_from_base64 (char *out, const char *in, size_t olen)
+ if (len == olen)
+ return len;
+ if (len == olen)
+ return len;
+ if (len == olen)
+ return len;","int mutt_from_base64 (char *out, const char *in, size_t olen) { int len = 0; register unsigned char digit1, digit2, digit3, digit4; do { digit1 = in[0]; if (digit1 > 127 || base64val (digit1) == BAD) return -1; digit2 = in[1]; if (digit2 > 127 || base64val (digit2) == BAD) return -1; digit3 = in[2]; if (digit3 > 127 || ((digit3 != '=') && (base64val (digit3) == BAD))) return -1; digit4 = in[3]; if (digit4 > 127 || ((digit4 != '=') && (base64val (digit4) == BAD))) return -1; in += 4; if (len == olen) return len; *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4); len++; if (digit3 != '=') { if (len == olen) return len; *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2); len++; if (digit4 != '=') { if (len == olen) return len; *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4); len++; } } } while (*in && digit4 != '='); return len; }"
368,6871----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server_stubs.c----rename_principal_2_svc,"rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp) { static generic_ret ret; <S2SV_StartVul> char *prime_arg1, <S2SV_EndVul> <S2SV_StartVul> *prime_arg2; <S2SV_EndVul> <S2SV_StartVul> gss_buffer_desc client_name, <S2SV_EndVul> <S2SV_StartVul> service_name; <S2SV_EndVul> OM_uint32 minor_stat; kadm5_server_handle_t handle; restriction_t *rp; const char *errmsg = NULL; size_t tlen1, tlen2, clen, slen; char *tdots1, *tdots2, *cdots, *sdots; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) || krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) { ret.code = KADM5_BAD_PRINCIPAL; goto exit_func; } tlen1 = strlen(prime_arg1); trunc_name(&tlen1, &tdots1); tlen2 = strlen(prime_arg2); trunc_name(&tlen2, &tdots2); clen = client_name.length; trunc_name(&clen, &cdots); slen = service_name.length; trunc_name(&slen, &sdots); ret.code = KADM5_OK; if (! CHANGEPW_SERVICE(rqstp)) { if (!kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE, arg->src, NULL)) ret.code = KADM5_AUTH_DELETE; if (!kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD, arg->dest, &rp) || rp) { if (ret.code == KADM5_AUTH_DELETE) ret.code = KADM5_AUTH_INSUFFICIENT; else ret.code = KADM5_AUTH_ADD; } } else ret.code = KADM5_AUTH_INSUFFICIENT; if (ret.code != KADM5_OK) { krb5_klog_syslog(LOG_NOTICE, _(""Unauthorized request: kadm5_rename_principal, "" ""%.*s%s to %.*s%s, "" ""client=%.*s%s, service=%.*s%s, addr=%s""), (int)tlen1, prime_arg1, tdots1, (int)tlen2, prime_arg2, tdots2, (int)clen, (char *)client_name.value, cdots, (int)slen, (char *)service_name.value, sdots, client_addr(rqstp->rq_xprt)); } else { ret.code = kadm5_rename_principal((void *)handle, arg->src, arg->dest); if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); krb5_klog_syslog(LOG_NOTICE, _(""Request: kadm5_rename_principal, "" ""%.*s%s to %.*s%s, %s, "" ""client=%.*s%s, service=%.*s%s, addr=%s""), (int)tlen1, prime_arg1, tdots1, (int)tlen2, prime_arg2, tdots2, errmsg ? errmsg : _(""success""), (int)clen, (char *)client_name.value, cdots, (int)slen, (char *)service_name.value, sdots, client_addr(rqstp->rq_xprt)); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } free(prime_arg1); free(prime_arg2); gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); <S2SV_StartVul> exit_func: <S2SV_EndVul> free_server_handle(handle); return &ret; }","- char *prime_arg1,
- gss_buffer_desc client_name,
- service_name;
- exit_func:
+ char *prime_arg1 = NULL, *prime_arg2 = NULL;
+ gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER;
+ gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER;
+ exit_func:","rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg1 = NULL, *prime_arg2 = NULL; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER; OM_uint32 minor_stat; kadm5_server_handle_t handle; restriction_t *rp; const char *errmsg = NULL; size_t tlen1, tlen2, clen, slen; char *tdots1, *tdots2, *cdots, *sdots; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) || krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) { ret.code = KADM5_BAD_PRINCIPAL; goto exit_func; } tlen1 = strlen(prime_arg1); trunc_name(&tlen1, &tdots1); tlen2 = strlen(prime_arg2); trunc_name(&tlen2, &tdots2); clen = client_name.length; trunc_name(&clen, &cdots); slen = service_name.length; trunc_name(&slen, &sdots); ret.code = KADM5_OK; if (! CHANGEPW_SERVICE(rqstp)) { if (!kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE, arg->src, NULL)) ret.code = KADM5_AUTH_DELETE; if (!kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD, arg->dest, &rp) || rp) { if (ret.code == KADM5_AUTH_DELETE) ret.code = KADM5_AUTH_INSUFFICIENT; else ret.code = KADM5_AUTH_ADD; } } else ret.code = KADM5_AUTH_INSUFFICIENT; if (ret.code != KADM5_OK) { krb5_klog_syslog(LOG_NOTICE, _(""Unauthorized request: kadm5_rename_principal, "" ""%.*s%s to %.*s%s, "" ""client=%.*s%s, service=%.*s%s, addr=%s""), (int)tlen1, prime_arg1, tdots1, (int)tlen2, prime_arg2, tdots2, (int)clen, (char *)client_name.value, cdots, (int)slen, (char *)service_name.value, sdots, client_addr(rqstp->rq_xprt)); } else { ret.code = kadm5_rename_principal((void *)handle, arg->src, arg->dest); if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); krb5_klog_syslog(LOG_NOTICE, _(""Request: kadm5_rename_principal, "" ""%.*s%s to %.*s%s, %s, "" ""client=%.*s%s, service=%.*s%s, addr=%s""), (int)tlen1, prime_arg1, tdots1, (int)tlen2, prime_arg2, tdots2, errmsg ? errmsg : _(""success""), (int)clen, (char *)client_name.value, cdots, (int)slen, (char *)service_name.value, sdots, client_addr(rqstp->rq_xprt)); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } exit_func: free(prime_arg1); free(prime_arg2); gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); free_server_handle(handle); return &ret; }"
369,5816----CWE-19----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xfs_attr_remote.c----xfs_attr_rmtval_get,"xfs_attr_rmtval_get( struct xfs_da_args *args) { struct xfs_bmbt_irec map[ATTR_RMTVALUE_MAPSIZE]; struct xfs_mount *mp = args->dp->i_mount; struct xfs_buf *bp; xfs_dablk_t lblkno = args->rmtblkno; __uint8_t *dst = args->value; <S2SV_StartVul> int valuelen = args->valuelen; <S2SV_EndVul> int nmap; int error; int blkcnt = args->rmtblkcnt; int i; int offset = 0; trace_xfs_attr_rmtval_get(args); ASSERT(!(args->flags & ATTR_KERNOVAL)); while (valuelen > 0) { nmap = ATTR_RMTVALUE_MAPSIZE; error = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno, blkcnt, map, &nmap, XFS_BMAPI_ATTRFORK); if (error) return error; ASSERT(nmap >= 1); for (i = 0; (i < nmap) && (valuelen > 0); i++) { xfs_daddr_t dblkno; int dblkcnt; ASSERT((map[i].br_startblock != DELAYSTARTBLOCK) && (map[i].br_startblock != HOLESTARTBLOCK)); dblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock); dblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount); error = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dblkno, dblkcnt, 0, &bp, &xfs_attr3_rmt_buf_ops); if (error) return error; error = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino, &offset, &valuelen, &dst); xfs_buf_relse(bp); if (error) return error; lblkno += map[i].br_blockcount; blkcnt -= map[i].br_blockcount; } } ASSERT(valuelen == 0); return 0; }","- int valuelen = args->valuelen;
+ int valuelen;
+ ASSERT(args->rmtvaluelen == args->valuelen);
+ valuelen = args->rmtvaluelen;","xfs_attr_rmtval_get( struct xfs_da_args *args) { struct xfs_bmbt_irec map[ATTR_RMTVALUE_MAPSIZE]; struct xfs_mount *mp = args->dp->i_mount; struct xfs_buf *bp; xfs_dablk_t lblkno = args->rmtblkno; __uint8_t *dst = args->value; int valuelen; int nmap; int error; int blkcnt = args->rmtblkcnt; int i; int offset = 0; trace_xfs_attr_rmtval_get(args); ASSERT(!(args->flags & ATTR_KERNOVAL)); ASSERT(args->rmtvaluelen == args->valuelen); valuelen = args->rmtvaluelen; while (valuelen > 0) { nmap = ATTR_RMTVALUE_MAPSIZE; error = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno, blkcnt, map, &nmap, XFS_BMAPI_ATTRFORK); if (error) return error; ASSERT(nmap >= 1); for (i = 0; (i < nmap) && (valuelen > 0); i++) { xfs_daddr_t dblkno; int dblkcnt; ASSERT((map[i].br_startblock != DELAYSTARTBLOCK) && (map[i].br_startblock != HOLESTARTBLOCK)); dblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock); dblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount); error = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dblkno, dblkcnt, 0, &bp, &xfs_attr3_rmt_buf_ops); if (error) return error; error = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino, &offset, &valuelen, &dst); xfs_buf_relse(bp); if (error) return error; lblkno += map[i].br_blockcount; blkcnt -= map[i].br_blockcount; } } ASSERT(valuelen == 0); return 0; }"
370,4713----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gif.c----EncodeImage,"static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image, const size_t data_size) { #define MaxCode(number_bits) ((one << (number_bits))-1) #define MaxHashTable 5003 #define MaxGIFBits 12UL #define MaxGIFTable (1UL << MaxGIFBits) #define GIFOutputCode(code) \ { \ \ if (bits > 0) \ datum|=(size_t) (code) << bits; \ else \ datum=(size_t) (code); \ bits+=number_bits; \ while (bits >= 8) \ { \ \ packet[length++]=(unsigned char) (datum & 0xff); \ if (length >= 254) \ { \ (void) WriteBlobByte(image,(unsigned char) length); \ (void) WriteBlob(image,length,packet); \ length=0; \ } \ datum>>=8; \ bits-=8; \ } \ if (free_code > max_code) \ { \ number_bits++; \ if (number_bits == MaxGIFBits) \ max_code=MaxGIFTable; \ else \ max_code=MaxCode(number_bits); \ } \ } IndexPacket index; short *hash_code, *hash_prefix, waiting_code; size_t bits, clear_code, datum, end_of_information_code, free_code, length, max_code, next_pixel, number_bits, one, pass; ssize_t displacement, offset, k, y; unsigned char *packet, *hash_suffix; assert(image != (Image *) NULL); one=1; packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet)); hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code)); hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix)); hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable, sizeof(*hash_suffix)); if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) || (hash_prefix == (short *) NULL) || (hash_suffix == (unsigned char *) NULL)) { if (packet != (unsigned char *) NULL) packet=(unsigned char *) RelinquishMagickMemory(packet); if (hash_code != (short *) NULL) hash_code=(short *) RelinquishMagickMemory(hash_code); if (hash_prefix != (short *) NULL) hash_prefix=(short *) RelinquishMagickMemory(hash_prefix); if (hash_suffix != (unsigned char *) NULL) hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix); return(MagickFalse); } (void) memset(packet,0,256*sizeof(*packet)); (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code)); (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix)); (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix)); number_bits=data_size; max_code=MaxCode(number_bits); clear_code=((short) one << (data_size-1)); end_of_information_code=clear_code+1; free_code=clear_code+2; length=0; datum=0; bits=0; GIFOutputCode(clear_code); offset=0; pass=0; waiting_code=0; for (y=0; y < (ssize_t) image->rows; y++) { register const IndexPacket *magick_restrict indexes; register const PixelPacket *magick_restrict p; register ssize_t x; p=GetVirtualPixels(image,0,offset,image->columns,1,&image->exception); if (p == (const PixelPacket *) NULL) break; indexes=GetVirtualIndexQueue(image); if (y == 0) { waiting_code=(short) (*indexes); p++; } for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++) { index=(IndexPacket) ((size_t) GetPixelIndex(indexes+x) & 0xff); p++; k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code); if (k >= MaxHashTable) k-=MaxHashTable; <S2SV_StartVul> next_pixel=MagickFalse; <S2SV_EndVul> <S2SV_StartVul> displacement=1; <S2SV_EndVul> if (hash_code[k] > 0) { if ((hash_prefix[k] == waiting_code) && (hash_suffix[k] == (unsigned char) index)) { waiting_code=hash_code[k]; continue; } if (k != 0) displacement=MaxHashTable-k; for ( ; ; ) { k-=displacement; if (k < 0) k+=MaxHashTable; if (hash_code[k] == 0) break; if ((hash_prefix[k] == waiting_code) && (hash_suffix[k] == (unsigned char) index)) { waiting_code=hash_code[k]; next_pixel=MagickTrue; break; } } if (next_pixel != MagickFalse) continue; } GIFOutputCode(waiting_code); if (free_code < MaxGIFTable) { hash_code[k]=(short) free_code++; hash_prefix[k]=waiting_code; hash_suffix[k]=(unsigned char) index; } else { for (k=0; k < MaxHashTable; k++) hash_code[k]=0; free_code=clear_code+2; GIFOutputCode(clear_code); number_bits=data_size; max_code=MaxCode(number_bits); } waiting_code=(short) index; } if (image_info->interlace == NoInterlace) offset++; else switch (pass) { case 0: default: { offset+=8; if (offset >= (ssize_t) image->rows) { pass++; offset=4; } break; } case 1: { offset+=8; if (offset >= (ssize_t) image->rows) { pass++; offset=2; } break; } case 2: { offset+=4; if (offset >= (ssize_t) image->rows) { pass++; offset=1; } break; } case 3: { offset+=2; break; } } } GIFOutputCode(waiting_code); GIFOutputCode(end_of_information_code); if (bits > 0) { packet[length++]=(unsigned char) (datum & 0xff); if (length >= 254) { (void) WriteBlobByte(image,(unsigned char) length); (void) WriteBlob(image,length,packet); length=0; } } if (length > 0) { (void) WriteBlobByte(image,(unsigned char) length); (void) WriteBlob(image,length,packet); } hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix); hash_prefix=(short *) RelinquishMagickMemory(hash_prefix); hash_code=(short *) RelinquishMagickMemory(hash_code); packet=(unsigned char *) RelinquishMagickMemory(packet); return(MagickTrue); }","- next_pixel=MagickFalse;
- displacement=1;
+ next_pixel=MagickFalse;
+ displacement=1;
+ if (k < 0)
+ continue;","static MagickBooleanType EncodeImage(const ImageInfo *image_info,Image *image, const size_t data_size) { #define MaxCode(number_bits) ((one << (number_bits))-1) #define MaxHashTable 5003 #define MaxGIFBits 12UL #define MaxGIFTable (1UL << MaxGIFBits) #define GIFOutputCode(code) \ { \ \ if (bits > 0) \ datum|=(size_t) (code) << bits; \ else \ datum=(size_t) (code); \ bits+=number_bits; \ while (bits >= 8) \ { \ \ packet[length++]=(unsigned char) (datum & 0xff); \ if (length >= 254) \ { \ (void) WriteBlobByte(image,(unsigned char) length); \ (void) WriteBlob(image,length,packet); \ length=0; \ } \ datum>>=8; \ bits-=8; \ } \ if (free_code > max_code) \ { \ number_bits++; \ if (number_bits == MaxGIFBits) \ max_code=MaxGIFTable; \ else \ max_code=MaxCode(number_bits); \ } \ } IndexPacket index; short *hash_code, *hash_prefix, waiting_code; size_t bits, clear_code, datum, end_of_information_code, free_code, length, max_code, next_pixel, number_bits, one, pass; ssize_t displacement, offset, k, y; unsigned char *packet, *hash_suffix; assert(image != (Image *) NULL); one=1; packet=(unsigned char *) AcquireQuantumMemory(256,sizeof(*packet)); hash_code=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_code)); hash_prefix=(short *) AcquireQuantumMemory(MaxHashTable,sizeof(*hash_prefix)); hash_suffix=(unsigned char *) AcquireQuantumMemory(MaxHashTable, sizeof(*hash_suffix)); if ((packet == (unsigned char *) NULL) || (hash_code == (short *) NULL) || (hash_prefix == (short *) NULL) || (hash_suffix == (unsigned char *) NULL)) { if (packet != (unsigned char *) NULL) packet=(unsigned char *) RelinquishMagickMemory(packet); if (hash_code != (short *) NULL) hash_code=(short *) RelinquishMagickMemory(hash_code); if (hash_prefix != (short *) NULL) hash_prefix=(short *) RelinquishMagickMemory(hash_prefix); if (hash_suffix != (unsigned char *) NULL) hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix); return(MagickFalse); } (void) memset(packet,0,256*sizeof(*packet)); (void) memset(hash_code,0,MaxHashTable*sizeof(*hash_code)); (void) memset(hash_prefix,0,MaxHashTable*sizeof(*hash_prefix)); (void) memset(hash_suffix,0,MaxHashTable*sizeof(*hash_suffix)); number_bits=data_size; max_code=MaxCode(number_bits); clear_code=((short) one << (data_size-1)); end_of_information_code=clear_code+1; free_code=clear_code+2; length=0; datum=0; bits=0; GIFOutputCode(clear_code); offset=0; pass=0; waiting_code=0; for (y=0; y < (ssize_t) image->rows; y++) { register const IndexPacket *magick_restrict indexes; register const PixelPacket *magick_restrict p; register ssize_t x; p=GetVirtualPixels(image,0,offset,image->columns,1,&image->exception); if (p == (const PixelPacket *) NULL) break; indexes=GetVirtualIndexQueue(image); if (y == 0) { waiting_code=(short) (*indexes); p++; } for (x=(ssize_t) (y == 0 ? 1 : 0); x < (ssize_t) image->columns; x++) { next_pixel=MagickFalse; displacement=1; index=(IndexPacket) ((size_t) GetPixelIndex(indexes+x) & 0xff); p++; k=(ssize_t) (((size_t) index << (MaxGIFBits-8))+waiting_code); if (k >= MaxHashTable) k-=MaxHashTable; if (k < 0) continue; if (hash_code[k] > 0) { if ((hash_prefix[k] == waiting_code) && (hash_suffix[k] == (unsigned char) index)) { waiting_code=hash_code[k]; continue; } if (k != 0) displacement=MaxHashTable-k; for ( ; ; ) { k-=displacement; if (k < 0) k+=MaxHashTable; if (hash_code[k] == 0) break; if ((hash_prefix[k] == waiting_code) && (hash_suffix[k] == (unsigned char) index)) { waiting_code=hash_code[k]; next_pixel=MagickTrue; break; } } if (next_pixel != MagickFalse) continue; } GIFOutputCode(waiting_code); if (free_code < MaxGIFTable) { hash_code[k]=(short) free_code++; hash_prefix[k]=waiting_code; hash_suffix[k]=(unsigned char) index; } else { for (k=0; k < MaxHashTable; k++) hash_code[k]=0; free_code=clear_code+2; GIFOutputCode(clear_code); number_bits=data_size; max_code=MaxCode(number_bits); } waiting_code=(short) index; } if (image_info->interlace == NoInterlace) offset++; else switch (pass) { case 0: default: { offset+=8; if (offset >= (ssize_t) image->rows) { pass++; offset=4; } break; } case 1: { offset+=8; if (offset >= (ssize_t) image->rows) { pass++; offset=2; } break; } case 2: { offset+=4; if (offset >= (ssize_t) image->rows) { pass++; offset=1; } break; } case 3: { offset+=2; break; } } } GIFOutputCode(waiting_code); GIFOutputCode(end_of_information_code); if (bits > 0) { packet[length++]=(unsigned char) (datum & 0xff); if (length >= 254) { (void) WriteBlobByte(image,(unsigned char) length); (void) WriteBlob(image,length,packet); length=0; } } if (length > 0) { (void) WriteBlobByte(image,(unsigned char) length); (void) WriteBlob(image,length,packet); } hash_suffix=(unsigned char *) RelinquishMagickMemory(hash_suffix); hash_prefix=(short *) RelinquishMagickMemory(hash_prefix); hash_code=(short *) RelinquishMagickMemory(hash_code); packet=(unsigned char *) RelinquishMagickMemory(packet); return(MagickTrue); }"
371,6524----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/config.c----r_config_set,"R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) { RConfigNode *node = NULL; char *ov = NULL; ut64 oi; if (!cfg || STRNULL (name)) { return NULL; } node = r_config_node_get (cfg, name); if (node) { if (node->flags & CN_RO) { eprintf (""(error: '%s' config key is read only)\n"", name); return node; } oi = node->i_value; if (node->value) { ov = strdup (node->value); if (!ov) { goto beach; } } else { free (node->value); node->value = strdup (""""); } if (node->flags & CN_BOOL) { bool b = is_true (value); node->i_value = (ut64) b? 1: 0; char *value = strdup (r_str_bool (b)); if (value) { free (node->value); node->value = value; } } else { if (!value) { free (node->value); node->value = strdup (""""); node->i_value = 0; } else { if (node->value == value) { goto beach; } <S2SV_StartVul> free (node->value); <S2SV_EndVul> node->value = strdup (value); if (IS_DIGIT (*value)) { if (strchr (value, '/')) { node->i_value = r_num_get (cfg->num, value); } else { node->i_value = r_num_math (cfg->num, value); } } else { node->i_value = 0; } node->flags |= CN_INT; } } } else { oi = UT64_MAX; if (!cfg->lock) { node = r_config_node_new (name, value); if (node) { if (value && is_bool (value)) { node->flags |= CN_BOOL; node->i_value = is_true (value)? 1: 0; } if (cfg->ht) { ht_insert (cfg->ht, node->name, node); r_list_append (cfg->nodes, node); cfg->n_nodes++; } } else { eprintf (""r_config_set: unable to create a new RConfigNode\n""); } } else { eprintf (""r_config_set: variable '%s' not found\n"", name); } } if (node && node->setter) { int ret = node->setter (cfg->user, node); if (ret == false) { if (oi != UT64_MAX) { node->i_value = oi; } free (node->value); node->value = strdup (ov? ov: """"); } } beach: free (ov); return node; }","- free (node->value);
+ char *tmp = node->value;
+ free (tmp);","R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) { RConfigNode *node = NULL; char *ov = NULL; ut64 oi; if (!cfg || STRNULL (name)) { return NULL; } node = r_config_node_get (cfg, name); if (node) { if (node->flags & CN_RO) { eprintf (""(error: '%s' config key is read only)\n"", name); return node; } oi = node->i_value; if (node->value) { ov = strdup (node->value); if (!ov) { goto beach; } } else { free (node->value); node->value = strdup (""""); } if (node->flags & CN_BOOL) { bool b = is_true (value); node->i_value = (ut64) b? 1: 0; char *value = strdup (r_str_bool (b)); if (value) { free (node->value); node->value = value; } } else { if (!value) { free (node->value); node->value = strdup (""""); node->i_value = 0; } else { if (node->value == value) { goto beach; } char *tmp = node->value; node->value = strdup (value); free (tmp); if (IS_DIGIT (*value)) { if (strchr (value, '/')) { node->i_value = r_num_get (cfg->num, value); } else { node->i_value = r_num_math (cfg->num, value); } } else { node->i_value = 0; } node->flags |= CN_INT; } } } else { oi = UT64_MAX; if (!cfg->lock) { node = r_config_node_new (name, value); if (node) { if (value && is_bool (value)) { node->flags |= CN_BOOL; node->i_value = is_true (value)? 1: 0; } if (cfg->ht) { ht_insert (cfg->ht, node->name, node); r_list_append (cfg->nodes, node); cfg->n_nodes++; } } else { eprintf (""r_config_set: unable to create a new RConfigNode\n""); } } else { eprintf (""r_config_set: variable '%s' not found\n"", name); } } if (node && node->setter) { int ret = node->setter (cfg->user, node); if (ret == false) { if (oi != UT64_MAX) { node->i_value = oi; } free (node->value); node->value = strdup (ov? ov: """"); } } beach: free (ov); return node; }"
372,2403----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10764--cadence-quadspi.c----cqspi_setup_flash,"static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np) { struct platform_device *pdev = cqspi->pdev; struct device *dev = &pdev->dev; struct cqspi_flash_pdata *f_pdata; struct spi_nor *nor; struct mtd_info *mtd; unsigned int cs; int i, ret; for_each_available_child_of_node(dev->of_node, np) { if (of_property_read_u32(np, ""reg"", &cs)) { dev_err(dev, ""Couldn't determine chip select.\n""); goto err; } <S2SV_StartVul> if (cs > CQSPI_MAX_CHIPSELECT) { <S2SV_EndVul> dev_err(dev, ""Chip select %d out of range.\n"", cs); goto err; } f_pdata = &cqspi->f_pdata[cs]; f_pdata->cqspi = cqspi; f_pdata->cs = cs; ret = cqspi_of_get_flash_pdata(pdev, f_pdata, np); if (ret) goto err; nor = &f_pdata->nor; mtd = &nor->mtd; mtd->priv = nor; nor->dev = dev; spi_nor_set_flash_node(nor, np); nor->priv = f_pdata; nor->read_reg = cqspi_read_reg; nor->write_reg = cqspi_write_reg; nor->read = cqspi_read; nor->write = cqspi_write; nor->erase = cqspi_erase; nor->prepare = cqspi_prep; nor->unprepare = cqspi_unprep; mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"", dev_name(dev), cs); if (!mtd->name) { ret = -ENOMEM; goto err; } ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD); if (ret) goto err; ret = mtd_device_register(mtd, NULL, 0); if (ret) goto err; f_pdata->registered = true; } return 0; err: for (i = 0; i < CQSPI_MAX_CHIPSELECT; i++) if (cqspi->f_pdata[i].registered) mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd); return ret; }","- if (cs > CQSPI_MAX_CHIPSELECT) {
+ if (cs >= CQSPI_MAX_CHIPSELECT) {","static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np) { struct platform_device *pdev = cqspi->pdev; struct device *dev = &pdev->dev; struct cqspi_flash_pdata *f_pdata; struct spi_nor *nor; struct mtd_info *mtd; unsigned int cs; int i, ret; for_each_available_child_of_node(dev->of_node, np) { if (of_property_read_u32(np, ""reg"", &cs)) { dev_err(dev, ""Couldn't determine chip select.\n""); goto err; } if (cs >= CQSPI_MAX_CHIPSELECT) { dev_err(dev, ""Chip select %d out of range.\n"", cs); goto err; } f_pdata = &cqspi->f_pdata[cs]; f_pdata->cqspi = cqspi; f_pdata->cs = cs; ret = cqspi_of_get_flash_pdata(pdev, f_pdata, np); if (ret) goto err; nor = &f_pdata->nor; mtd = &nor->mtd; mtd->priv = nor; nor->dev = dev; spi_nor_set_flash_node(nor, np); nor->priv = f_pdata; nor->read_reg = cqspi_read_reg; nor->write_reg = cqspi_write_reg; nor->read = cqspi_read; nor->write = cqspi_write; nor->erase = cqspi_erase; nor->prepare = cqspi_prep; nor->unprepare = cqspi_unprep; mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"", dev_name(dev), cs); if (!mtd->name) { ret = -ENOMEM; goto err; } ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD); if (ret) goto err; ret = mtd_device_register(mtd, NULL, 0); if (ret) goto err; f_pdata->registered = true; } return 0; err: for (i = 0; i < CQSPI_MAX_CHIPSELECT; i++) if (cqspi->f_pdata[i].registered) mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd); return ret; }"
373,1316----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-13689--print-isakmp.c----ikev1_id_print,"ikev1_id_print(netdissect_options *ndo, u_char tpay _U_, const struct isakmp_gen *ext, u_int item_len, const u_char *ep _U_, uint32_t phase, uint32_t doi _U_, uint32_t proto _U_, int depth _U_) { #define USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id *p; struct ikev1_pl_id id; static const char *idtypestr[] = { ""IPv4"", ""IPv4net"", ""IPv6"", ""IPv6net"", }; static const char *ipsecidtypestr[] = { NULL, ""IPv4"", ""FQDN"", ""user FQDN"", ""IPv4net"", ""IPv6"", ""IPv6net"", ""IPv4range"", ""IPv6range"", ""ASN1 DN"", ""ASN1 GN"", ""keyid"", }; int len; const u_char *data; ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_ID))); p = (const struct ikev1_pl_id *)ext; ND_TCHECK(*p); UNALIGNED_MEMCPY(&id, ext, sizeof(id)); if (sizeof(*p) < item_len) { data = (const u_char *)(p + 1); len = item_len - sizeof(*p); } else { data = NULL; len = 0; } #if 0 ND_PRINT((ndo,"" [phase=%d doi=%d proto=%d]"", phase, doi, proto)); #endif switch (phase) { #ifndef USE_IPSECDOI_IN_PHASE1 case 1: #endif default: ND_PRINT((ndo,"" idtype=%s"", STR_OR_ID(id.d.id_type, idtypestr))); ND_PRINT((ndo,"" doi_data=%u"", (uint32_t)(ntohl(id.d.doi_data) & 0xffffff))); break; #ifdef USE_IPSECDOI_IN_PHASE1 case 1: #endif case 2: { const struct ipsecdoi_id *doi_p; struct ipsecdoi_id doi_id; const char *p_name; doi_p = (const struct ipsecdoi_id *)ext; ND_TCHECK(*doi_p); UNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id)); ND_PRINT((ndo,"" idtype=%s"", STR_OR_ID(doi_id.type, ipsecidtypestr))); if (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL) ND_PRINT((ndo,"" protoid=%s"", p_name)); else ND_PRINT((ndo,"" protoid=%u"", doi_id.proto_id)); ND_PRINT((ndo,"" port=%d"", ntohs(doi_id.port))); if (!len) break; if (data == NULL) goto trunc; ND_TCHECK2(*data, len); switch (doi_id.type) { case IPSECDOI_ID_IPV4_ADDR: if (len < 4) ND_PRINT((ndo,"" len=%d [bad: < 4]"", len)); else ND_PRINT((ndo,"" len=%d %s"", len, ipaddr_string(ndo, data))); len = 0; break; case IPSECDOI_ID_FQDN: case IPSECDOI_ID_USER_FQDN: { int i; ND_PRINT((ndo,"" len=%d "", len)); for (i = 0; i < len; i++) safeputchar(ndo, data[i]); len = 0; break; } case IPSECDOI_ID_IPV4_ADDR_SUBNET: { const u_char *mask; if (len < 8) ND_PRINT((ndo,"" len=%d [bad: < 8]"", len)); else { mask = data + sizeof(struct in_addr); ND_PRINT((ndo,"" len=%d %s/%u.%u.%u.%u"", len, ipaddr_string(ndo, data), mask[0], mask[1], mask[2], mask[3])); } len = 0; break; } case IPSECDOI_ID_IPV6_ADDR: if (len < 16) ND_PRINT((ndo,"" len=%d [bad: < 16]"", len)); else ND_PRINT((ndo,"" len=%d %s"", len, ip6addr_string(ndo, data))); len = 0; break; case IPSECDOI_ID_IPV6_ADDR_SUBNET: { const u_char *mask; <S2SV_StartVul> if (len < 20) <S2SV_EndVul> <S2SV_StartVul> ND_PRINT((ndo,"" len=%d [bad: < 20]"", len)); <S2SV_EndVul> else { mask = (const u_char *)(data + sizeof(struct in6_addr)); ND_PRINT((ndo,"" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"", len, ip6addr_string(ndo, data), mask[0], mask[1], mask[2], mask[3], mask[4], mask[5], mask[6], mask[7], mask[8], mask[9], mask[10], mask[11], mask[12], mask[13], mask[14], mask[15])); } len = 0; break; } case IPSECDOI_ID_IPV4_ADDR_RANGE: if (len < 8) ND_PRINT((ndo,"" len=%d [bad: < 8]"", len)); else { ND_PRINT((ndo,"" len=%d %s-%s"", len, ipaddr_string(ndo, data), ipaddr_string(ndo, data + sizeof(struct in_addr)))); } len = 0; break; case IPSECDOI_ID_IPV6_ADDR_RANGE: if (len < 32) ND_PRINT((ndo,"" len=%d [bad: < 32]"", len)); else { ND_PRINT((ndo,"" len=%d %s-%s"", len, ip6addr_string(ndo, data), ip6addr_string(ndo, data + sizeof(struct in6_addr)))); } len = 0; break; case IPSECDOI_ID_DER_ASN1_DN: case IPSECDOI_ID_DER_ASN1_GN: case IPSECDOI_ID_KEY_ID: break; } break; } } if (data && len) { ND_PRINT((ndo,"" len=%d"", len)); if (2 < ndo->ndo_vflag) { ND_PRINT((ndo,"" "")); if (!rawprint(ndo, (const uint8_t *)data, len)) goto trunc; } } return (const u_char *)ext + item_len; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_ID))); return NULL; }","- if (len < 20)
- ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));
+ if (len < 32)
+ ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));","ikev1_id_print(netdissect_options *ndo, u_char tpay _U_, const struct isakmp_gen *ext, u_int item_len, const u_char *ep _U_, uint32_t phase, uint32_t doi _U_, uint32_t proto _U_, int depth _U_) { #define USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id *p; struct ikev1_pl_id id; static const char *idtypestr[] = { ""IPv4"", ""IPv4net"", ""IPv6"", ""IPv6net"", }; static const char *ipsecidtypestr[] = { NULL, ""IPv4"", ""FQDN"", ""user FQDN"", ""IPv4net"", ""IPv6"", ""IPv6net"", ""IPv4range"", ""IPv6range"", ""ASN1 DN"", ""ASN1 GN"", ""keyid"", }; int len; const u_char *data; ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_ID))); p = (const struct ikev1_pl_id *)ext; ND_TCHECK(*p); UNALIGNED_MEMCPY(&id, ext, sizeof(id)); if (sizeof(*p) < item_len) { data = (const u_char *)(p + 1); len = item_len - sizeof(*p); } else { data = NULL; len = 0; } #if 0 ND_PRINT((ndo,"" [phase=%d doi=%d proto=%d]"", phase, doi, proto)); #endif switch (phase) { #ifndef USE_IPSECDOI_IN_PHASE1 case 1: #endif default: ND_PRINT((ndo,"" idtype=%s"", STR_OR_ID(id.d.id_type, idtypestr))); ND_PRINT((ndo,"" doi_data=%u"", (uint32_t)(ntohl(id.d.doi_data) & 0xffffff))); break; #ifdef USE_IPSECDOI_IN_PHASE1 case 1: #endif case 2: { const struct ipsecdoi_id *doi_p; struct ipsecdoi_id doi_id; const char *p_name; doi_p = (const struct ipsecdoi_id *)ext; ND_TCHECK(*doi_p); UNALIGNED_MEMCPY(&doi_id, ext, sizeof(doi_id)); ND_PRINT((ndo,"" idtype=%s"", STR_OR_ID(doi_id.type, ipsecidtypestr))); if (!ndo->ndo_nflag && doi_id.proto_id && (p_name = netdb_protoname(doi_id.proto_id)) != NULL) ND_PRINT((ndo,"" protoid=%s"", p_name)); else ND_PRINT((ndo,"" protoid=%u"", doi_id.proto_id)); ND_PRINT((ndo,"" port=%d"", ntohs(doi_id.port))); if (!len) break; if (data == NULL) goto trunc; ND_TCHECK2(*data, len); switch (doi_id.type) { case IPSECDOI_ID_IPV4_ADDR: if (len < 4) ND_PRINT((ndo,"" len=%d [bad: < 4]"", len)); else ND_PRINT((ndo,"" len=%d %s"", len, ipaddr_string(ndo, data))); len = 0; break; case IPSECDOI_ID_FQDN: case IPSECDOI_ID_USER_FQDN: { int i; ND_PRINT((ndo,"" len=%d "", len)); for (i = 0; i < len; i++) safeputchar(ndo, data[i]); len = 0; break; } case IPSECDOI_ID_IPV4_ADDR_SUBNET: { const u_char *mask; if (len < 8) ND_PRINT((ndo,"" len=%d [bad: < 8]"", len)); else { mask = data + sizeof(struct in_addr); ND_PRINT((ndo,"" len=%d %s/%u.%u.%u.%u"", len, ipaddr_string(ndo, data), mask[0], mask[1], mask[2], mask[3])); } len = 0; break; } case IPSECDOI_ID_IPV6_ADDR: if (len < 16) ND_PRINT((ndo,"" len=%d [bad: < 16]"", len)); else ND_PRINT((ndo,"" len=%d %s"", len, ip6addr_string(ndo, data))); len = 0; break; case IPSECDOI_ID_IPV6_ADDR_SUBNET: { const u_char *mask; if (len < 32) ND_PRINT((ndo,"" len=%d [bad: < 32]"", len)); else { mask = (const u_char *)(data + sizeof(struct in6_addr)); ND_PRINT((ndo,"" len=%d %s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"", len, ip6addr_string(ndo, data), mask[0], mask[1], mask[2], mask[3], mask[4], mask[5], mask[6], mask[7], mask[8], mask[9], mask[10], mask[11], mask[12], mask[13], mask[14], mask[15])); } len = 0; break; } case IPSECDOI_ID_IPV4_ADDR_RANGE: if (len < 8) ND_PRINT((ndo,"" len=%d [bad: < 8]"", len)); else { ND_PRINT((ndo,"" len=%d %s-%s"", len, ipaddr_string(ndo, data), ipaddr_string(ndo, data + sizeof(struct in_addr)))); } len = 0; break; case IPSECDOI_ID_IPV6_ADDR_RANGE: if (len < 32) ND_PRINT((ndo,"" len=%d [bad: < 32]"", len)); else { ND_PRINT((ndo,"" len=%d %s-%s"", len, ip6addr_string(ndo, data), ip6addr_string(ndo, data + sizeof(struct in6_addr)))); } len = 0; break; case IPSECDOI_ID_DER_ASN1_DN: case IPSECDOI_ID_DER_ASN1_GN: case IPSECDOI_ID_KEY_ID: break; } break; } } if (data && len) { ND_PRINT((ndo,"" len=%d"", len)); if (2 < ndo->ndo_vflag) { ND_PRINT((ndo,"" "")); if (!rawprint(ndo, (const uint8_t *)data, len)) goto trunc; } } return (const u_char *)ext + item_len; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_ID))); return NULL; }"
374,1237----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-16805--dwarf.c----r_bin_dwarf_dump_debug_info,"static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) { size_t i, j, k; RBinDwarfDIE *dies; RBinDwarfAttrValue *values; if (!inf || !f) { return; } for (i = 0; i < inf->length; i++) { fprintf (f, "" Compilation Unit @ offset 0x%""PFMT64x"":\n"", inf->comp_units [i].offset); fprintf (f, "" Length: 0x%x\n"", inf->comp_units [i].hdr.length); fprintf (f, "" Version: %d\n"", inf->comp_units [i].hdr.version); fprintf (f, "" Abbrev Offset: 0x%x\n"", inf->comp_units [i].hdr.abbrev_offset); fprintf (f, "" Pointer Size: %d\n"", inf->comp_units [i].hdr.pointer_size); dies = inf->comp_units[i].dies; for (j = 0; j < inf->comp_units[i].length; j++) { fprintf (f, "" Abbrev Number: %""PFMT64u"" "", dies[j].abbrev_code); if (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings[dies[j].tag]) { fprintf (f, ""(%s)\n"", dwarf_tag_name_encodings[dies[j].tag]); } else { fprintf (f, ""(Unknown abbrev tag)\n""); } if (!dies[j].abbrev_code) { continue; } values = dies[j].attr_values; for (k = 0; k < dies[j].length; k++) { <S2SV_StartVul> if (!values[k].name) <S2SV_EndVul> continue; if (values[k].name < DW_AT_vtable_elem_location && dwarf_attr_encodings[values[k].name]) { fprintf (f, "" %-18s : "", dwarf_attr_encodings[values[k].name]); } else { fprintf (f, "" TODO\t""); } r_bin_dwarf_dump_attr_value (&values[k], f); fprintf (f, ""\n""); } } } }","- if (!values[k].name)
+ if (!values[k].name) {
+ }","static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) { size_t i, j, k; RBinDwarfDIE *dies; RBinDwarfAttrValue *values; if (!inf || !f) { return; } for (i = 0; i < inf->length; i++) { fprintf (f, "" Compilation Unit @ offset 0x%""PFMT64x"":\n"", inf->comp_units [i].offset); fprintf (f, "" Length: 0x%x\n"", inf->comp_units [i].hdr.length); fprintf (f, "" Version: %d\n"", inf->comp_units [i].hdr.version); fprintf (f, "" Abbrev Offset: 0x%x\n"", inf->comp_units [i].hdr.abbrev_offset); fprintf (f, "" Pointer Size: %d\n"", inf->comp_units [i].hdr.pointer_size); dies = inf->comp_units[i].dies; for (j = 0; j < inf->comp_units[i].length; j++) { fprintf (f, "" Abbrev Number: %""PFMT64u"" "", dies[j].abbrev_code); if (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type && dwarf_tag_name_encodings[dies[j].tag]) { fprintf (f, ""(%s)\n"", dwarf_tag_name_encodings[dies[j].tag]); } else { fprintf (f, ""(Unknown abbrev tag)\n""); } if (!dies[j].abbrev_code) { continue; } values = dies[j].attr_values; for (k = 0; k < dies[j].length; k++) { if (!values[k].name) { continue; } if (values[k].name < DW_AT_vtable_elem_location && dwarf_attr_encodings[values[k].name]) { fprintf (f, "" %-18s : "", dwarf_attr_encodings[values[k].name]); } else { fprintf (f, "" TODO\t""); } r_bin_dwarf_dump_attr_value (&values[k], f); fprintf (f, ""\n""); } } } }"
375,328----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3209--mmtimer.c----sgi_timer_get,"static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting) { if (timr->it.mmtimer.clock == TIMER_OFF) { cur_setting->it_interval.tv_nsec = 0; cur_setting->it_interval.tv_sec = 0; cur_setting->it_value.tv_nsec = 0; cur_setting->it_value.tv_sec =0; return; } <S2SV_StartVul> ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period); <S2SV_EndVul> <S2SV_StartVul> ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period); <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> }","- ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
- ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
- return;
+ cur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);
+ cur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);","static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting) { if (timr->it.mmtimer.clock == TIMER_OFF) { cur_setting->it_interval.tv_nsec = 0; cur_setting->it_interval.tv_sec = 0; cur_setting->it_value.tv_nsec = 0; cur_setting->it_value.tv_sec =0; return; } cur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period); cur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period); }"
376,1728----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10129--smart_protocol.c----add_push_report_sideband_pkt,"static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf) { git_pkt *pkt; const char *line, *line_end = NULL; size_t line_len; int error; int reading_from_buf = data_pkt_buf->size > 0; if (reading_from_buf) { git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len); line = data_pkt_buf->ptr; line_len = data_pkt_buf->size; } else { line = data_pkt->data; line_len = data_pkt->len; } while (line_len > 0) { error = git_pkt_parse_line(&pkt, line, &line_end, line_len); if (error == GIT_EBUFS) { if (!reading_from_buf) git_buf_put(data_pkt_buf, line, line_len); error = 0; goto done; } else if (error < 0) goto done; line_len -= (line_end - line); line = line_end; <S2SV_EndVul> <S2SV_StartVul> if (pkt == NULL) <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> error = add_push_report_pkt(push, pkt); git_pkt_free(pkt); if (error < 0 && error != GIT_ITEROVER) goto done; } error = 0; done: if (reading_from_buf) git_buf_consume(data_pkt_buf, line_end); return error; }","- if (pkt == NULL)
- continue;","static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf) { git_pkt *pkt; const char *line, *line_end = NULL; size_t line_len; int error; int reading_from_buf = data_pkt_buf->size > 0; if (reading_from_buf) { git_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len); line = data_pkt_buf->ptr; line_len = data_pkt_buf->size; } else { line = data_pkt->data; line_len = data_pkt->len; } while (line_len > 0) { error = git_pkt_parse_line(&pkt, line, &line_end, line_len); if (error == GIT_EBUFS) { if (!reading_from_buf) git_buf_put(data_pkt_buf, line, line_len); error = 0; goto done; } else if (error < 0) goto done; line_len -= (line_end - line); line = line_end; error = add_push_report_pkt(push, pkt); git_pkt_free(pkt); if (error < 0 && error != GIT_ITEROVER) goto done; } error = 0; done: if (reading_from_buf) git_buf_consume(data_pkt_buf, line_end); return error; }"
377,6895----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/virtio_rpmsg_bus.c----rpmsg_probe,"static int rpmsg_probe(struct virtio_device *vdev) { vq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done }; static const char * const names[] = { ""input"", ""output"" }; struct virtqueue *vqs[2]; struct virtproc_info *vrp; struct virtio_rpmsg_channel *vch = NULL; struct rpmsg_device *rpdev_ns, *rpdev_ctrl; void *bufs_va; int err = 0, i; size_t total_buf_space; bool notify; vrp = kzalloc(sizeof(*vrp), GFP_KERNEL); if (!vrp) return -ENOMEM; vrp->vdev = vdev; idr_init(&vrp->endpoints); mutex_init(&vrp->endpoints_lock); mutex_init(&vrp->tx_lock); init_waitqueue_head(&vrp->sendq); err = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL); if (err) goto free_vrp; vrp->rvq = vqs[0]; vrp->svq = vqs[1]; WARN_ON(virtqueue_get_vring_size(vrp->rvq) != virtqueue_get_vring_size(vrp->svq)); if (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2) vrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2; else vrp->num_bufs = MAX_RPMSG_NUM_BUFS; vrp->buf_size = MAX_RPMSG_BUF_SIZE; total_buf_space = vrp->num_bufs * vrp->buf_size; bufs_va = dma_alloc_coherent(vdev->dev.parent, total_buf_space, &vrp->bufs_dma, GFP_KERNEL); if (!bufs_va) { err = -ENOMEM; goto vqs_del; } dev_dbg(&vdev->dev, ""buffers: va %pK, dma %pad\n"", bufs_va, &vrp->bufs_dma); vrp->rbufs = bufs_va; vrp->sbufs = bufs_va + total_buf_space / 2; for (i = 0; i < vrp->num_bufs / 2; i++) { struct scatterlist sg; void *cpu_addr = vrp->rbufs + i * vrp->buf_size; rpmsg_sg_init(&sg, cpu_addr, vrp->buf_size); err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr, GFP_KERNEL); WARN_ON(err); } virtqueue_disable_cb(vrp->svq); vdev->priv = vrp; rpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev); if (IS_ERR(rpdev_ctrl)) { err = PTR_ERR(rpdev_ctrl); goto free_coherent; } if (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) { vch = kzalloc(sizeof(*vch), GFP_KERNEL); if (!vch) { err = -ENOMEM; goto free_ctrldev; } vch->vrp = vrp; rpdev_ns = &vch->rpdev; rpdev_ns->ops = &virtio_rpmsg_ops; rpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev); rpdev_ns->dev.parent = &vrp->vdev->dev; rpdev_ns->dev.release = virtio_rpmsg_release_device; err = rpmsg_ns_register_device(rpdev_ns); if (err) <S2SV_StartVul> goto free_vch; <S2SV_EndVul> } notify = virtqueue_kick_prepare(vrp->rvq); virtio_device_ready(vdev); if (notify) virtqueue_notify(vrp->rvq); dev_info(&vdev->dev, ""rpmsg host is online\n""); return 0; <S2SV_StartVul> free_vch: <S2SV_EndVul> <S2SV_StartVul> kfree(vch); <S2SV_EndVul> free_ctrldev: rpmsg_virtio_del_ctrl_dev(rpdev_ctrl); free_coherent: dma_free_coherent(vdev->dev.parent, total_buf_space, bufs_va, vrp->bufs_dma); vqs_del: vdev->config->del_vqs(vrp->vdev); free_vrp: kfree(vrp); return err; }","- goto free_vch;
- free_vch:
- kfree(vch);
+ goto free_ctrldev;","static int rpmsg_probe(struct virtio_device *vdev) { vq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done }; static const char * const names[] = { ""input"", ""output"" }; struct virtqueue *vqs[2]; struct virtproc_info *vrp; struct virtio_rpmsg_channel *vch = NULL; struct rpmsg_device *rpdev_ns, *rpdev_ctrl; void *bufs_va; int err = 0, i; size_t total_buf_space; bool notify; vrp = kzalloc(sizeof(*vrp), GFP_KERNEL); if (!vrp) return -ENOMEM; vrp->vdev = vdev; idr_init(&vrp->endpoints); mutex_init(&vrp->endpoints_lock); mutex_init(&vrp->tx_lock); init_waitqueue_head(&vrp->sendq); err = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL); if (err) goto free_vrp; vrp->rvq = vqs[0]; vrp->svq = vqs[1]; WARN_ON(virtqueue_get_vring_size(vrp->rvq) != virtqueue_get_vring_size(vrp->svq)); if (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2) vrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2; else vrp->num_bufs = MAX_RPMSG_NUM_BUFS; vrp->buf_size = MAX_RPMSG_BUF_SIZE; total_buf_space = vrp->num_bufs * vrp->buf_size; bufs_va = dma_alloc_coherent(vdev->dev.parent, total_buf_space, &vrp->bufs_dma, GFP_KERNEL); if (!bufs_va) { err = -ENOMEM; goto vqs_del; } dev_dbg(&vdev->dev, ""buffers: va %pK, dma %pad\n"", bufs_va, &vrp->bufs_dma); vrp->rbufs = bufs_va; vrp->sbufs = bufs_va + total_buf_space / 2; for (i = 0; i < vrp->num_bufs / 2; i++) { struct scatterlist sg; void *cpu_addr = vrp->rbufs + i * vrp->buf_size; rpmsg_sg_init(&sg, cpu_addr, vrp->buf_size); err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr, GFP_KERNEL); WARN_ON(err); } virtqueue_disable_cb(vrp->svq); vdev->priv = vrp; rpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev); if (IS_ERR(rpdev_ctrl)) { err = PTR_ERR(rpdev_ctrl); goto free_coherent; } if (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) { vch = kzalloc(sizeof(*vch), GFP_KERNEL); if (!vch) { err = -ENOMEM; goto free_ctrldev; } vch->vrp = vrp; rpdev_ns = &vch->rpdev; rpdev_ns->ops = &virtio_rpmsg_ops; rpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev); rpdev_ns->dev.parent = &vrp->vdev->dev; rpdev_ns->dev.release = virtio_rpmsg_release_device; err = rpmsg_ns_register_device(rpdev_ns); if (err) goto free_ctrldev; } notify = virtqueue_kick_prepare(vrp->rvq); virtio_device_ready(vdev); if (notify) virtqueue_notify(vrp->rvq); dev_info(&vdev->dev, ""rpmsg host is online\n""); return 0; free_ctrldev: rpmsg_virtio_del_ctrl_dev(rpdev_ctrl); free_coherent: dma_free_coherent(vdev->dev.parent, total_buf_space, bufs_va, vrp->bufs_dma); vqs_del: vdev->config->del_vqs(vrp->vdev); free_vrp: kfree(vrp); return err; }"
378,5614----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiCmds.c----DebugRemoveCmd_,"static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, int op) { Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0); if (interp->breakpointHash) { int num; <S2SV_StartVul> char nbuf[100]; <S2SV_EndVul> if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) return Jsi_LogError(""bad number""); snprintf(nbuf, sizeof(nbuf), ""%d"", num); Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf); jsi_BreakPoint* bptr; if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) { switch (op) { case 1: bptr->enabled = 0; break; case 2: bptr->enabled = 1; break; default: Jsi_HashEntryDelete(hPtr); } return JSI_OK; } } return Jsi_LogError(""unknown breakpoint""); }","- char nbuf[100];
+ char nbuf[JSI_MAX_NUMBER_STRING];","static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr, int op) { Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0); if (interp->breakpointHash) { int num; char nbuf[JSI_MAX_NUMBER_STRING]; if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) return Jsi_LogError(""bad number""); snprintf(nbuf, sizeof(nbuf), ""%d"", num); Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf); jsi_BreakPoint* bptr; if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) { switch (op) { case 1: bptr->enabled = 0; break; case 2: bptr->enabled = 1; break; default: Jsi_HashEntryDelete(hPtr); } return JSI_OK; } } return Jsi_LogError(""unknown breakpoint""); }"
379,704----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-2669--geo_ops.c----poly_in,"poly_in(PG_FUNCTION_ARGS) { char *str = PG_GETARG_CSTRING(0); POLYGON *poly; int npts; int size; int isopen; char *s; if ((npts = pair_count(str, ',')) <= 0) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type polygon: \""%s\"""", str))); <S2SV_StartVul> size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts; <S2SV_EndVul> poly = (POLYGON *) palloc0(size); SET_VARSIZE(poly, size); poly->npts = npts; if ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0]))) || (*s != '\0')) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type polygon: \""%s\"""", str))); make_bound_box(poly); PG_RETURN_POLYGON_P(poly); }","- size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;
+ int base_size;
+ base_size = sizeof(poly->p[0]) * npts;
+ size = offsetof(POLYGON, p[0]) + base_size;
+ if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)
+ ereport(ERROR,
+ (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
+ errmsg(""too many points requested"")));","poly_in(PG_FUNCTION_ARGS) { char *str = PG_GETARG_CSTRING(0); POLYGON *poly; int npts; int size; int base_size; int isopen; char *s; if ((npts = pair_count(str, ',')) <= 0) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type polygon: \""%s\"""", str))); base_size = sizeof(poly->p[0]) * npts; size = offsetof(POLYGON, p[0]) + base_size; if (base_size / npts != sizeof(poly->p[0]) || size <= base_size) ereport(ERROR, (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED), errmsg(""too many points requested""))); poly = (POLYGON *) palloc0(size); SET_VARSIZE(poly, size); poly->npts = npts; if ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0]))) || (*s != '\0')) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type polygon: \""%s\"""", str))); make_bound_box(poly); PG_RETURN_POLYGON_P(poly); }"
380,3576----CWE-78----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/socket.c----r_socket_block_time,"R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) { #if __UNIX__ int ret, flags; #endif if (!s) { return false; } #if __UNIX__ flags = fcntl (s->fd, F_GETFL, 0); if (flags < 0) { return false; } ret = fcntl (s->fd, F_SETFL, block? (flags & ~O_NONBLOCK): (flags | O_NONBLOCK)); if (ret < 0) { return false; } #elif __WINDOWS__ ioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block); #endif if (sec > 0 || usec > 0) { <S2SV_StartVul> struct timeval tv = {0}; <S2SV_EndVul> <S2SV_StartVul> tv.tv_sec = sec; <S2SV_EndVul> <S2SV_StartVul> tv.tv_usec = usec; <S2SV_EndVul> if (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) { return false; } } return true; }","- struct timeval tv = {0};
- tv.tv_sec = sec;
- tv.tv_usec = usec;
+ struct timeval tv = {sec, usec};","R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) { #if __UNIX__ int ret, flags; #endif if (!s) { return false; } #if __UNIX__ flags = fcntl (s->fd, F_GETFL, 0); if (flags < 0) { return false; } ret = fcntl (s->fd, F_SETFL, block? (flags & ~O_NONBLOCK): (flags | O_NONBLOCK)); if (ret < 0) { return false; } #elif __WINDOWS__ ioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block); #endif if (sec > 0 || usec > 0) { struct timeval tv = {sec, usec}; if (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) { return false; } } return true; }"
381,302----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-4914--af_rose.c----rose_rx_call_request,"int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci) { struct sock *sk; struct sock *make; struct rose_sock *make_rose; struct rose_facilities_struct facilities; <S2SV_StartVul> int n, len; <S2SV_EndVul> skb->sk = NULL; memset(&facilities, 0x00, sizeof(struct rose_facilities_struct)); <S2SV_StartVul> len = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1; <S2SV_EndVul> <S2SV_StartVul> len += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1; <S2SV_EndVul> <S2SV_StartVul> if (!rose_parse_facilities(skb->data + len + 4, &facilities)) { <S2SV_EndVul> rose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76); return 0; } sk = rose_find_listener(&facilities.source_addr, &facilities.source_call); if (sk == NULL || sk_acceptq_is_full(sk) || (make = rose_make_new(sk)) == NULL) { rose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120); return 0; } skb->sk = make; make->sk_state = TCP_ESTABLISHED; make_rose = rose_sk(make); make_rose->lci = lci; make_rose->dest_addr = facilities.dest_addr; make_rose->dest_call = facilities.dest_call; make_rose->dest_ndigis = facilities.dest_ndigis; for (n = 0 ; n < facilities.dest_ndigis ; n++) make_rose->dest_digis[n] = facilities.dest_digis[n]; make_rose->source_addr = facilities.source_addr; make_rose->source_call = facilities.source_call; make_rose->source_ndigis = facilities.source_ndigis; for (n = 0 ; n < facilities.source_ndigis ; n++) make_rose->source_digis[n]= facilities.source_digis[n]; make_rose->neighbour = neigh; make_rose->device = dev; make_rose->facilities = facilities; make_rose->neighbour->use++; if (rose_sk(sk)->defer) { make_rose->state = ROSE_STATE_5; } else { rose_write_internal(make, ROSE_CALL_ACCEPTED); make_rose->state = ROSE_STATE_3; rose_start_idletimer(make); } make_rose->condition = 0x00; make_rose->vs = 0; make_rose->va = 0; make_rose->vr = 0; make_rose->vl = 0; sk->sk_ack_backlog++; rose_insert_socket(make); skb_queue_head(&sk->sk_receive_queue, skb); rose_start_heartbeat(make); if (!sock_flag(sk, SOCK_DEAD)) sk->sk_data_ready(sk, skb->len); return 1; }","- int n, len;
- len = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;
- len += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;
- if (!rose_parse_facilities(skb->data + len + 4, &facilities)) {
+ int n;
+ if (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,
+ skb->len - ROSE_CALL_REQ_FACILITIES_OFF,
+ &facilities)) {","int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci) { struct sock *sk; struct sock *make; struct rose_sock *make_rose; struct rose_facilities_struct facilities; int n; skb->sk = NULL; memset(&facilities, 0x00, sizeof(struct rose_facilities_struct)); if (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF, skb->len - ROSE_CALL_REQ_FACILITIES_OFF, &facilities)) { rose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76); return 0; } sk = rose_find_listener(&facilities.source_addr, &facilities.source_call); if (sk == NULL || sk_acceptq_is_full(sk) || (make = rose_make_new(sk)) == NULL) { rose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120); return 0; } skb->sk = make; make->sk_state = TCP_ESTABLISHED; make_rose = rose_sk(make); make_rose->lci = lci; make_rose->dest_addr = facilities.dest_addr; make_rose->dest_call = facilities.dest_call; make_rose->dest_ndigis = facilities.dest_ndigis; for (n = 0 ; n < facilities.dest_ndigis ; n++) make_rose->dest_digis[n] = facilities.dest_digis[n]; make_rose->source_addr = facilities.source_addr; make_rose->source_call = facilities.source_call; make_rose->source_ndigis = facilities.source_ndigis; for (n = 0 ; n < facilities.source_ndigis ; n++) make_rose->source_digis[n]= facilities.source_digis[n]; make_rose->neighbour = neigh; make_rose->device = dev; make_rose->facilities = facilities; make_rose->neighbour->use++; if (rose_sk(sk)->defer) { make_rose->state = ROSE_STATE_5; } else { rose_write_internal(make, ROSE_CALL_ACCEPTED); make_rose->state = ROSE_STATE_3; rose_start_idletimer(make); } make_rose->condition = 0x00; make_rose->vs = 0; make_rose->va = 0; make_rose->vr = 0; make_rose->vl = 0; sk->sk_ack_backlog++; rose_insert_socket(make); skb_queue_head(&sk->sk_receive_queue, skb); rose_start_heartbeat(make); if (!sock_flag(sk, SOCK_DEAD)) sk->sk_data_ready(sk, skb->len); return 1; }"
382,6913----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mat.c----ReadMATImageV4,"static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { typedef struct { unsigned char Type[4]; unsigned int nRows; unsigned int nCols; unsigned int imagf; unsigned int nameLen; } MAT4_HDR; long ldblk; EndianType endian; Image *rotate_image; MagickBooleanType status; MAT4_HDR HDR; QuantumInfo *quantum_info; QuantumFormatType format_type; register ssize_t i; ssize_t count, y; unsigned char *pixels; unsigned int depth; (void) SeekBlob(image,0,SEEK_SET); while (EOFBlob(image) != MagickFalse) { ldblk=ReadBlobLSBLong(image); if ((ldblk > 9999) || (ldblk < 0)) break; HDR.Type[3]=ldblk % 10; ldblk /= 10; HDR.Type[2]=ldblk % 10; ldblk /= 10; HDR.Type[1]=ldblk % 10; ldblk /= 10; HDR.Type[0]=ldblk; if (HDR.Type[3] != 0) break; if (HDR.Type[2] != 0) break; if (HDR.Type[0] == 0) { HDR.nRows=ReadBlobLSBLong(image); HDR.nCols=ReadBlobLSBLong(image); HDR.imagf=ReadBlobLSBLong(image); HDR.nameLen=ReadBlobLSBLong(image); endian=LSBEndian; } else { HDR.nRows=ReadBlobMSBLong(image); HDR.nCols=ReadBlobMSBLong(image); HDR.imagf=ReadBlobMSBLong(image); HDR.nameLen=ReadBlobMSBLong(image); endian=MSBEndian; } if ((HDR.imagf != 0) && (HDR.imagf != 1)) break; if (HDR.nameLen > 0xFFFF) return((Image *) NULL); for (i=0; i < (ssize_t) HDR.nameLen; i++) { int byte; byte=ReadBlobByte(image); if (byte == EOF) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } } image->columns=(size_t) HDR.nRows; image->rows=(size_t) HDR.nCols; SetImageColorspace(image,GRAYColorspace,exception); if (image_info->ping != MagickFalse) { Swap(image->columns,image->rows); return(image); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return((Image *) NULL); quantum_info=AcquireQuantumInfo(image_info,image); if (quantum_info == (QuantumInfo *) NULL) return((Image *) NULL); switch(HDR.Type[1]) { case 0: format_type=FloatingPointQuantumFormat; depth=64; break; case 1: format_type=FloatingPointQuantumFormat; depth=32; break; case 2: format_type=UnsignedQuantumFormat; depth=16; break; case 3: format_type=SignedQuantumFormat; depth=16; break; case 4: format_type=UnsignedQuantumFormat; depth=8; break; default: format_type=UnsignedQuantumFormat; depth=8; break; } image->depth=depth; if (HDR.Type[0] != 0) SetQuantumEndian(image,quantum_info,MSBEndian); status=SetQuantumFormat(image,quantum_info,format_type); status=SetQuantumDepth(image,quantum_info,depth); status=SetQuantumEndian(image,quantum_info,endian); SetQuantumScale(quantum_info,1.0); pixels=(unsigned char *) GetQuantumPixels(quantum_info); for (y=0; y < (ssize_t) image->rows; y++) { int status; register Quantum *magick_restrict q; count=ReadBlob(image,depth/8*image->columns,(char *) pixels); if (count == -1) break; q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1, exception); if (q == (Quantum *) NULL) break; (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info, GrayQuantum,pixels,exception); if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3)) FixSignedValues(image,q,(int) image->columns); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } if (HDR.imagf == 1) for (y=0; y < (ssize_t) image->rows; y++) { count=ReadBlob(image,depth/8*image->columns,(char *) pixels); if (count == -1) break; if (HDR.Type[1] == 0) InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception); else InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception); } <S2SV_StartVul> quantum_info=DestroyQuantumInfo(quantum_info); <S2SV_EndVul> rotate_image=RotateImage(image,90.0,exception); if (rotate_image != (Image *) NULL) { image=DestroyImage(image); image=rotate_image; } if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } (void) CloseBlob(image); return(GetFirstImageInList(image)); }","- quantum_info=DestroyQuantumInfo(quantum_info);
+ quantum_info=(QuantumInfo *) NULL;
+ if (quantum_info != (QuantumInfo *) NULL)
+ quantum_info=DestroyQuantumInfo(quantum_info);","static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { typedef struct { unsigned char Type[4]; unsigned int nRows; unsigned int nCols; unsigned int imagf; unsigned int nameLen; } MAT4_HDR; long ldblk; EndianType endian; Image *rotate_image; MagickBooleanType status; MAT4_HDR HDR; QuantumInfo *quantum_info; QuantumFormatType format_type; register ssize_t i; ssize_t count, y; unsigned char *pixels; unsigned int depth; quantum_info=(QuantumInfo *) NULL; (void) SeekBlob(image,0,SEEK_SET); while (EOFBlob(image) != MagickFalse) { ldblk=ReadBlobLSBLong(image); if ((ldblk > 9999) || (ldblk < 0)) break; HDR.Type[3]=ldblk % 10; ldblk /= 10; HDR.Type[2]=ldblk % 10; ldblk /= 10; HDR.Type[1]=ldblk % 10; ldblk /= 10; HDR.Type[0]=ldblk; if (HDR.Type[3] != 0) break; if (HDR.Type[2] != 0) break; if (HDR.Type[0] == 0) { HDR.nRows=ReadBlobLSBLong(image); HDR.nCols=ReadBlobLSBLong(image); HDR.imagf=ReadBlobLSBLong(image); HDR.nameLen=ReadBlobLSBLong(image); endian=LSBEndian; } else { HDR.nRows=ReadBlobMSBLong(image); HDR.nCols=ReadBlobMSBLong(image); HDR.imagf=ReadBlobMSBLong(image); HDR.nameLen=ReadBlobMSBLong(image); endian=MSBEndian; } if ((HDR.imagf != 0) && (HDR.imagf != 1)) break; if (HDR.nameLen > 0xFFFF) return((Image *) NULL); for (i=0; i < (ssize_t) HDR.nameLen; i++) { int byte; byte=ReadBlobByte(image); if (byte == EOF) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } } image->columns=(size_t) HDR.nRows; image->rows=(size_t) HDR.nCols; SetImageColorspace(image,GRAYColorspace,exception); if (image_info->ping != MagickFalse) { Swap(image->columns,image->rows); return(image); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return((Image *) NULL); quantum_info=AcquireQuantumInfo(image_info,image); if (quantum_info == (QuantumInfo *) NULL) return((Image *) NULL); switch(HDR.Type[1]) { case 0: format_type=FloatingPointQuantumFormat; depth=64; break; case 1: format_type=FloatingPointQuantumFormat; depth=32; break; case 2: format_type=UnsignedQuantumFormat; depth=16; break; case 3: format_type=SignedQuantumFormat; depth=16; break; case 4: format_type=UnsignedQuantumFormat; depth=8; break; default: format_type=UnsignedQuantumFormat; depth=8; break; } image->depth=depth; if (HDR.Type[0] != 0) SetQuantumEndian(image,quantum_info,MSBEndian); status=SetQuantumFormat(image,quantum_info,format_type); status=SetQuantumDepth(image,quantum_info,depth); status=SetQuantumEndian(image,quantum_info,endian); SetQuantumScale(quantum_info,1.0); pixels=(unsigned char *) GetQuantumPixels(quantum_info); for (y=0; y < (ssize_t) image->rows; y++) { int status; register Quantum *magick_restrict q; count=ReadBlob(image,depth/8*image->columns,(char *) pixels); if (count == -1) break; q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1, exception); if (q == (Quantum *) NULL) break; (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info, GrayQuantum,pixels,exception); if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3)) FixSignedValues(image,q,(int) image->columns); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } if (HDR.imagf == 1) for (y=0; y < (ssize_t) image->rows; y++) { count=ReadBlob(image,depth/8*image->columns,(char *) pixels); if (count == -1) break; if (HDR.Type[1] == 0) InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception); else InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception); } if (quantum_info != (QuantumInfo *) NULL) quantum_info=DestroyQuantumInfo(quantum_info); rotate_image=RotateImage(image,90.0,exception); if (rotate_image != (Image *) NULL) { image=DestroyImage(image); image=rotate_image; } if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
383,915----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9888--gsf-infile-tar.c----tar_directory_for_file,"tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last) { const char *s = name; while (1) { const char *s0 = s; char *dirname; while (1) { if (*s == 0) { if (last && s != s0) break; else return dir; } if (*s == '/') break; s++; } dirname = g_strndup (s0, s - s0); while (*s == '/') s++; if (strcmp (dirname, ""."") != 0) { GsfInput *subdir = gsf_infile_child_by_name (GSF_INFILE (dir), dirname); if (subdir) { g_object_unref (subdir); <S2SV_StartVul> dir = GSF_INFILE_TAR (subdir); <S2SV_EndVul> } else dir = tar_create_dir (dir, dirname); } g_free (dirname); } }","- dir = GSF_INFILE_TAR (subdir);
+ dir = GSF_IS_INFILE_TAR (subdir)
+ ? GSF_INFILE_TAR (subdir)
+ : dir;","tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last) { const char *s = name; while (1) { const char *s0 = s; char *dirname; while (1) { if (*s == 0) { if (last && s != s0) break; else return dir; } if (*s == '/') break; s++; } dirname = g_strndup (s0, s - s0); while (*s == '/') s++; if (strcmp (dirname, ""."") != 0) { GsfInput *subdir = gsf_infile_child_by_name (GSF_INFILE (dir), dirname); if (subdir) { dir = GSF_IS_INFILE_TAR (subdir) ? GSF_INFILE_TAR (subdir) : dir; g_object_unref (subdir); } else dir = tar_create_dir (dir, dirname); } g_free (dirname); } }"
384,3792----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/vf_pad.c----filter_frame,"static int filter_frame(AVFilterLink *inlink, AVFrame *in) { PadContext *s = inlink->dst->priv; AVFrame *out; int needs_copy = frame_needs_copy(s, in); if (needs_copy) { av_log(inlink->dst, AV_LOG_DEBUG, ""Direct padding impossible allocating new frame\n""); out = ff_get_video_buffer(inlink->dst->outputs[0], FFMAX(inlink->w, s->w), FFMAX(inlink->h, s->h)); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } else { int i; out = in; <S2SV_StartVul> for (i = 0; i < 4 && out->data[i]; i++) { <S2SV_EndVul> int hsub = s->draw.hsub[i]; int vsub = s->draw.vsub[i]; out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] + (s->y >> vsub) * out->linesize[i]; } } if (s->y) { ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, 0, 0, s->w, s->y); } if (s->h > s->y + s->in_h) { ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, 0, s->y + s->in_h, s->w, s->h - s->y - s->in_h); } ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, 0, s->y, s->x, in->height); if (needs_copy) { ff_copy_rectangle2(&s->draw, out->data, out->linesize, in->data, in->linesize, s->x, s->y, 0, 0, in->width, in->height); } ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, s->x + s->in_w, s->y, s->w - s->x - s->in_w, in->height); out->width = s->w; out->height = s->h; if (in != out) av_frame_free(&in); return ff_filter_frame(inlink->dst->outputs[0], out); }","- for (i = 0; i < 4 && out->data[i]; i++) {
+ for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) {","static int filter_frame(AVFilterLink *inlink, AVFrame *in) { PadContext *s = inlink->dst->priv; AVFrame *out; int needs_copy = frame_needs_copy(s, in); if (needs_copy) { av_log(inlink->dst, AV_LOG_DEBUG, ""Direct padding impossible allocating new frame\n""); out = ff_get_video_buffer(inlink->dst->outputs[0], FFMAX(inlink->w, s->w), FFMAX(inlink->h, s->h)); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } else { int i; out = in; for (i = 0; i < 4 && out->data[i] && out->linesize[i]; i++) { int hsub = s->draw.hsub[i]; int vsub = s->draw.vsub[i]; out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] + (s->y >> vsub) * out->linesize[i]; } } if (s->y) { ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, 0, 0, s->w, s->y); } if (s->h > s->y + s->in_h) { ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, 0, s->y + s->in_h, s->w, s->h - s->y - s->in_h); } ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, 0, s->y, s->x, in->height); if (needs_copy) { ff_copy_rectangle2(&s->draw, out->data, out->linesize, in->data, in->linesize, s->x, s->y, 0, 0, in->width, in->height); } ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize, s->x + s->in_w, s->y, s->w - s->x - s->in_w, in->height); out->width = s->w; out->height = s->h; if (in != out) av_frame_free(&in); return ff_filter_frame(inlink->dst->outputs[0], out); }"
385,1092----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2546--timer.c----snd_timer_user_open,"static int snd_timer_user_open(struct inode *inode, struct file *file) { struct snd_timer_user *tu; int err; err = nonseekable_open(inode, file); if (err < 0) return err; tu = kzalloc(sizeof(*tu), GFP_KERNEL); if (tu == NULL) return -ENOMEM; spin_lock_init(&tu->qlock); init_waitqueue_head(&tu->qchange_sleep); <S2SV_StartVul> mutex_init(&tu->tread_sem); <S2SV_EndVul> tu->ticks = 1; tu->queue_size = 128; tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read), GFP_KERNEL); if (tu->queue == NULL) { kfree(tu); return -ENOMEM; } file->private_data = tu; return 0; }","- mutex_init(&tu->tread_sem);
+ mutex_init(&tu->ioctl_lock);","static int snd_timer_user_open(struct inode *inode, struct file *file) { struct snd_timer_user *tu; int err; err = nonseekable_open(inode, file); if (err < 0) return err; tu = kzalloc(sizeof(*tu), GFP_KERNEL); if (tu == NULL) return -ENOMEM; spin_lock_init(&tu->qlock); init_waitqueue_head(&tu->qchange_sleep); mutex_init(&tu->ioctl_lock); tu->ticks = 1; tu->queue_size = 128; tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read), GFP_KERNEL); if (tu->queue == NULL) { kfree(tu); return -ENOMEM; } file->private_data = tu; return 0; }"
386,317----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-4112--bond_main.c----bond_enslave,"int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev) { struct bonding *bond = netdev_priv(bond_dev); const struct net_device_ops *slave_ops = slave_dev->netdev_ops; struct slave *new_slave = NULL; struct netdev_hw_addr *ha; struct sockaddr addr; int link_reporting; int res = 0; if (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL && slave_ops->ndo_do_ioctl == NULL) { pr_warning(""%s: Warning: no link monitoring support for %s\n"", bond_dev->name, slave_dev->name); } if (slave_dev->flags & IFF_SLAVE) { pr_debug(""Error, Device was already enslaved\n""); return -EBUSY; } if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) { pr_debug(""%s: NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name); if (bond_vlan_used(bond)) { pr_err(""%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n"", bond_dev->name, slave_dev->name, bond_dev->name); return -EPERM; } else { pr_warning(""%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n"", bond_dev->name, slave_dev->name, slave_dev->name, bond_dev->name); } } else { pr_debug(""%s: ! NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name); } if ((slave_dev->flags & IFF_UP)) { pr_err(""%s is up. This may be due to an out of date ifenslave.\n"", slave_dev->name); res = -EPERM; goto err_undo_flags; } if (bond->slave_cnt == 0) { if (bond_dev->type != slave_dev->type) { pr_debug(""%s: change device type from %d to %d\n"", bond_dev->name, bond_dev->type, slave_dev->type); res = netdev_bonding_change(bond_dev, NETDEV_PRE_TYPE_CHANGE); res = notifier_to_errno(res); if (res) { pr_err(""%s: refused to change device type\n"", bond_dev->name); res = -EBUSY; goto err_undo_flags; } dev_uc_flush(bond_dev); dev_mc_flush(bond_dev); if (slave_dev->type != ARPHRD_ETHER) bond_setup_by_slave(bond_dev, slave_dev); <S2SV_StartVul> else <S2SV_EndVul> ether_setup(bond_dev); netdev_bonding_change(bond_dev, NETDEV_POST_TYPE_CHANGE); } } else if (bond_dev->type != slave_dev->type) { pr_err(""%s ether type (%d) is different from other slaves (%d), can not enslave it.\n"", slave_dev->name, slave_dev->type, bond_dev->type); res = -EINVAL; goto err_undo_flags; } if (slave_ops->ndo_set_mac_address == NULL) { if (bond->slave_cnt == 0) { pr_warning(""%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active."", bond_dev->name); bond->params.fail_over_mac = BOND_FOM_ACTIVE; } else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) { pr_err(""%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n"", bond_dev->name); res = -EOPNOTSUPP; goto err_undo_flags; } } call_netdevice_notifiers(NETDEV_JOIN, slave_dev); if (is_zero_ether_addr(bond->dev->dev_addr)) memcpy(bond->dev->dev_addr, slave_dev->dev_addr, slave_dev->addr_len); new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL); if (!new_slave) { res = -ENOMEM; goto err_undo_flags; } new_slave->queue_id = 0; new_slave->original_mtu = slave_dev->mtu; res = dev_set_mtu(slave_dev, bond->dev->mtu); if (res) { pr_debug(""Error %d calling dev_set_mtu\n"", res); goto err_free; } memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN); if (!bond->params.fail_over_mac) { memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len); addr.sa_family = slave_dev->type; res = dev_set_mac_address(slave_dev, &addr); if (res) { pr_debug(""Error %d calling set_mac_address\n"", res); goto err_restore_mtu; } } res = netdev_set_bond_master(slave_dev, bond_dev); if (res) { pr_debug(""Error %d calling netdev_set_bond_master\n"", res); goto err_restore_mac; } res = dev_open(slave_dev); if (res) { pr_debug(""Opening slave %s failed\n"", slave_dev->name); goto err_unset_master; } new_slave->bond = bond; new_slave->dev = slave_dev; slave_dev->priv_flags |= IFF_BONDING; if (bond_is_lb(bond)) { res = bond_alb_init_slave(bond, new_slave); if (res) goto err_close; } if (!USES_PRIMARY(bond->params.mode)) { if (bond_dev->flags & IFF_PROMISC) { res = dev_set_promiscuity(slave_dev, 1); if (res) goto err_close; } if (bond_dev->flags & IFF_ALLMULTI) { res = dev_set_allmulti(slave_dev, 1); if (res) goto err_close; } netif_addr_lock_bh(bond_dev); netdev_for_each_mc_addr(ha, bond_dev) dev_mc_add(slave_dev, ha->addr); netif_addr_unlock_bh(bond_dev); } if (bond->params.mode == BOND_MODE_8023AD) { u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR; dev_mc_add(slave_dev, lacpdu_multicast); } bond_add_vlans_on_slave(bond, slave_dev); write_lock_bh(&bond->lock); bond_attach_slave(bond, new_slave); new_slave->delay = 0; new_slave->link_failure_count = 0; write_unlock_bh(&bond->lock); bond_compute_features(bond); read_lock(&bond->lock); new_slave->last_arp_rx = jiffies; if (bond->params.miimon && !bond->params.use_carrier) { link_reporting = bond_check_dev_link(bond, slave_dev, 1); if ((link_reporting == -1) && !bond->params.arp_interval) { pr_warning(""%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\n"", bond_dev->name, slave_dev->name); } else if (link_reporting == -1) { pr_warning(""%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\n"", bond_dev->name, slave_dev->name); } } if (!bond->params.miimon || (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) { if (bond->params.updelay) { pr_debug(""Initial state of slave_dev is BOND_LINK_BACK\n""); new_slave->link = BOND_LINK_BACK; new_slave->delay = bond->params.updelay; } else { pr_debug(""Initial state of slave_dev is BOND_LINK_UP\n""); new_slave->link = BOND_LINK_UP; } new_slave->jiffies = jiffies; } else { pr_debug(""Initial state of slave_dev is BOND_LINK_DOWN\n""); new_slave->link = BOND_LINK_DOWN; } if (bond_update_speed_duplex(new_slave) && (new_slave->link != BOND_LINK_DOWN)) { pr_warning(""%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\n"", bond_dev->name, new_slave->dev->name); if (bond->params.mode == BOND_MODE_8023AD) { pr_warning(""%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\n"", bond_dev->name); } } if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) { if (strcmp(bond->params.primary, new_slave->dev->name) == 0) { bond->primary_slave = new_slave; bond->force_primary = true; } } write_lock_bh(&bond->curr_slave_lock); switch (bond->params.mode) { case BOND_MODE_ACTIVEBACKUP: bond_set_slave_inactive_flags(new_slave); bond_select_active_slave(bond); break; case BOND_MODE_8023AD: bond_set_slave_inactive_flags(new_slave); if (bond->slave_cnt == 1) { SLAVE_AD_INFO(new_slave).id = 1; bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL); } else { SLAVE_AD_INFO(new_slave).id = SLAVE_AD_INFO(new_slave->prev).id + 1; } bond_3ad_bind_slave(new_slave); break; case BOND_MODE_TLB: case BOND_MODE_ALB: bond_set_active_slave(new_slave); bond_set_slave_inactive_flags(new_slave); bond_select_active_slave(bond); break; default: pr_debug(""This slave is always active in trunk mode\n""); bond_set_active_slave(new_slave); if (!bond->curr_active_slave) bond->curr_active_slave = new_slave; break; } write_unlock_bh(&bond->curr_slave_lock); bond_set_carrier(bond); #ifdef CONFIG_NET_POLL_CONTROLLER slave_dev->npinfo = bond_netpoll_info(bond); if (slave_dev->npinfo) { if (slave_enable_netpoll(new_slave)) { read_unlock(&bond->lock); pr_info(""Error, %s: master_dev is using netpoll, "" ""but new slave device does not support netpoll.\n"", bond_dev->name); res = -EBUSY; goto err_close; } } #endif read_unlock(&bond->lock); res = bond_create_slave_symlinks(bond_dev, slave_dev); if (res) goto err_close; res = netdev_rx_handler_register(slave_dev, bond_handle_frame, new_slave); if (res) { pr_debug(""Error %d calling netdev_rx_handler_register\n"", res); goto err_dest_symlinks; } pr_info(""%s: enslaving %s as a%s interface with a%s link.\n"", bond_dev->name, slave_dev->name, bond_is_active_slave(new_slave) ? ""n active"" : "" backup"", new_slave->link != BOND_LINK_DOWN ? ""n up"" : "" down""); return 0; err_dest_symlinks: bond_destroy_slave_symlinks(bond_dev, slave_dev); err_close: dev_close(slave_dev); err_unset_master: netdev_set_bond_master(slave_dev, NULL); err_restore_mac: if (!bond->params.fail_over_mac) { memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN); addr.sa_family = slave_dev->type; dev_set_mac_address(slave_dev, &addr); } err_restore_mtu: dev_set_mtu(slave_dev, new_slave->original_mtu); err_free: kfree(new_slave); err_undo_flags: bond_compute_features(bond); return res; }","- else
+ else {
+ bond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ }","int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev) { struct bonding *bond = netdev_priv(bond_dev); const struct net_device_ops *slave_ops = slave_dev->netdev_ops; struct slave *new_slave = NULL; struct netdev_hw_addr *ha; struct sockaddr addr; int link_reporting; int res = 0; if (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL && slave_ops->ndo_do_ioctl == NULL) { pr_warning(""%s: Warning: no link monitoring support for %s\n"", bond_dev->name, slave_dev->name); } if (slave_dev->flags & IFF_SLAVE) { pr_debug(""Error, Device was already enslaved\n""); return -EBUSY; } if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) { pr_debug(""%s: NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name); if (bond_vlan_used(bond)) { pr_err(""%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n"", bond_dev->name, slave_dev->name, bond_dev->name); return -EPERM; } else { pr_warning(""%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n"", bond_dev->name, slave_dev->name, slave_dev->name, bond_dev->name); } } else { pr_debug(""%s: ! NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name); } if ((slave_dev->flags & IFF_UP)) { pr_err(""%s is up. This may be due to an out of date ifenslave.\n"", slave_dev->name); res = -EPERM; goto err_undo_flags; } if (bond->slave_cnt == 0) { if (bond_dev->type != slave_dev->type) { pr_debug(""%s: change device type from %d to %d\n"", bond_dev->name, bond_dev->type, slave_dev->type); res = netdev_bonding_change(bond_dev, NETDEV_PRE_TYPE_CHANGE); res = notifier_to_errno(res); if (res) { pr_err(""%s: refused to change device type\n"", bond_dev->name); res = -EBUSY; goto err_undo_flags; } dev_uc_flush(bond_dev); dev_mc_flush(bond_dev); if (slave_dev->type != ARPHRD_ETHER) bond_setup_by_slave(bond_dev, slave_dev); else { ether_setup(bond_dev); bond_dev->priv_flags &= ~IFF_TX_SKB_SHARING; } netdev_bonding_change(bond_dev, NETDEV_POST_TYPE_CHANGE); } } else if (bond_dev->type != slave_dev->type) { pr_err(""%s ether type (%d) is different from other slaves (%d), can not enslave it.\n"", slave_dev->name, slave_dev->type, bond_dev->type); res = -EINVAL; goto err_undo_flags; } if (slave_ops->ndo_set_mac_address == NULL) { if (bond->slave_cnt == 0) { pr_warning(""%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active."", bond_dev->name); bond->params.fail_over_mac = BOND_FOM_ACTIVE; } else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) { pr_err(""%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n"", bond_dev->name); res = -EOPNOTSUPP; goto err_undo_flags; } } call_netdevice_notifiers(NETDEV_JOIN, slave_dev); if (is_zero_ether_addr(bond->dev->dev_addr)) memcpy(bond->dev->dev_addr, slave_dev->dev_addr, slave_dev->addr_len); new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL); if (!new_slave) { res = -ENOMEM; goto err_undo_flags; } new_slave->queue_id = 0; new_slave->original_mtu = slave_dev->mtu; res = dev_set_mtu(slave_dev, bond->dev->mtu); if (res) { pr_debug(""Error %d calling dev_set_mtu\n"", res); goto err_free; } memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN); if (!bond->params.fail_over_mac) { memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len); addr.sa_family = slave_dev->type; res = dev_set_mac_address(slave_dev, &addr); if (res) { pr_debug(""Error %d calling set_mac_address\n"", res); goto err_restore_mtu; } } res = netdev_set_bond_master(slave_dev, bond_dev); if (res) { pr_debug(""Error %d calling netdev_set_bond_master\n"", res); goto err_restore_mac; } res = dev_open(slave_dev); if (res) { pr_debug(""Opening slave %s failed\n"", slave_dev->name); goto err_unset_master; } new_slave->bond = bond; new_slave->dev = slave_dev; slave_dev->priv_flags |= IFF_BONDING; if (bond_is_lb(bond)) { res = bond_alb_init_slave(bond, new_slave); if (res) goto err_close; } if (!USES_PRIMARY(bond->params.mode)) { if (bond_dev->flags & IFF_PROMISC) { res = dev_set_promiscuity(slave_dev, 1); if (res) goto err_close; } if (bond_dev->flags & IFF_ALLMULTI) { res = dev_set_allmulti(slave_dev, 1); if (res) goto err_close; } netif_addr_lock_bh(bond_dev); netdev_for_each_mc_addr(ha, bond_dev) dev_mc_add(slave_dev, ha->addr); netif_addr_unlock_bh(bond_dev); } if (bond->params.mode == BOND_MODE_8023AD) { u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR; dev_mc_add(slave_dev, lacpdu_multicast); } bond_add_vlans_on_slave(bond, slave_dev); write_lock_bh(&bond->lock); bond_attach_slave(bond, new_slave); new_slave->delay = 0; new_slave->link_failure_count = 0; write_unlock_bh(&bond->lock); bond_compute_features(bond); read_lock(&bond->lock); new_slave->last_arp_rx = jiffies; if (bond->params.miimon && !bond->params.use_carrier) { link_reporting = bond_check_dev_link(bond, slave_dev, 1); if ((link_reporting == -1) && !bond->params.arp_interval) { pr_warning(""%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\n"", bond_dev->name, slave_dev->name); } else if (link_reporting == -1) { pr_warning(""%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\n"", bond_dev->name, slave_dev->name); } } if (!bond->params.miimon || (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) { if (bond->params.updelay) { pr_debug(""Initial state of slave_dev is BOND_LINK_BACK\n""); new_slave->link = BOND_LINK_BACK; new_slave->delay = bond->params.updelay; } else { pr_debug(""Initial state of slave_dev is BOND_LINK_UP\n""); new_slave->link = BOND_LINK_UP; } new_slave->jiffies = jiffies; } else { pr_debug(""Initial state of slave_dev is BOND_LINK_DOWN\n""); new_slave->link = BOND_LINK_DOWN; } if (bond_update_speed_duplex(new_slave) && (new_slave->link != BOND_LINK_DOWN)) { pr_warning(""%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\n"", bond_dev->name, new_slave->dev->name); if (bond->params.mode == BOND_MODE_8023AD) { pr_warning(""%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\n"", bond_dev->name); } } if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) { if (strcmp(bond->params.primary, new_slave->dev->name) == 0) { bond->primary_slave = new_slave; bond->force_primary = true; } } write_lock_bh(&bond->curr_slave_lock); switch (bond->params.mode) { case BOND_MODE_ACTIVEBACKUP: bond_set_slave_inactive_flags(new_slave); bond_select_active_slave(bond); break; case BOND_MODE_8023AD: bond_set_slave_inactive_flags(new_slave); if (bond->slave_cnt == 1) { SLAVE_AD_INFO(new_slave).id = 1; bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL); } else { SLAVE_AD_INFO(new_slave).id = SLAVE_AD_INFO(new_slave->prev).id + 1; } bond_3ad_bind_slave(new_slave); break; case BOND_MODE_TLB: case BOND_MODE_ALB: bond_set_active_slave(new_slave); bond_set_slave_inactive_flags(new_slave); bond_select_active_slave(bond); break; default: pr_debug(""This slave is always active in trunk mode\n""); bond_set_active_slave(new_slave); if (!bond->curr_active_slave) bond->curr_active_slave = new_slave; break; } write_unlock_bh(&bond->curr_slave_lock); bond_set_carrier(bond); #ifdef CONFIG_NET_POLL_CONTROLLER slave_dev->npinfo = bond_netpoll_info(bond); if (slave_dev->npinfo) { if (slave_enable_netpoll(new_slave)) { read_unlock(&bond->lock); pr_info(""Error, %s: master_dev is using netpoll, "" ""but new slave device does not support netpoll.\n"", bond_dev->name); res = -EBUSY; goto err_close; } } #endif read_unlock(&bond->lock); res = bond_create_slave_symlinks(bond_dev, slave_dev); if (res) goto err_close; res = netdev_rx_handler_register(slave_dev, bond_handle_frame, new_slave); if (res) { pr_debug(""Error %d calling netdev_rx_handler_register\n"", res); goto err_dest_symlinks; } pr_info(""%s: enslaving %s as a%s interface with a%s link.\n"", bond_dev->name, slave_dev->name, bond_is_active_slave(new_slave) ? ""n active"" : "" backup"", new_slave->link != BOND_LINK_DOWN ? ""n up"" : "" down""); return 0; err_dest_symlinks: bond_destroy_slave_symlinks(bond_dev, slave_dev); err_close: dev_close(slave_dev); err_unset_master: netdev_set_bond_master(slave_dev, NULL); err_restore_mac: if (!bond->params.fail_over_mac) { memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN); addr.sa_family = slave_dev->type; dev_set_mac_address(slave_dev, &addr); } err_restore_mtu: dev_set_mtu(slave_dev, new_slave->original_mtu); err_free: kfree(new_slave); err_undo_flags: bond_compute_features(bond); return res; }"
387,562----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-6542--af_llc.c----llc_ui_getname,"static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddrlen, int peer) { struct sockaddr_llc sllc; struct sock *sk = sock->sk; struct llc_sock *llc = llc_sk(sk); <S2SV_StartVul> int rc = 0; <S2SV_EndVul> memset(&sllc, 0, sizeof(sllc)); lock_sock(sk); if (sock_flag(sk, SOCK_ZAPPED)) goto out; *uaddrlen = sizeof(sllc); <S2SV_StartVul> memset(uaddr, 0, *uaddrlen); <S2SV_EndVul> if (peer) { rc = -ENOTCONN; if (sk->sk_state != TCP_ESTABLISHED) goto out; if(llc->dev) sllc.sllc_arphrd = llc->dev->type; sllc.sllc_sap = llc->daddr.lsap; memcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN); } else { rc = -EINVAL; if (!llc->sap) goto out; sllc.sllc_sap = llc->sap->laddr.lsap; if (llc->dev) { sllc.sllc_arphrd = llc->dev->type; memcpy(&sllc.sllc_mac, llc->dev->dev_addr, IFHWADDRLEN); } } rc = 0; sllc.sllc_family = AF_LLC; memcpy(uaddr, &sllc, sizeof(sllc)); out: release_sock(sk); return rc; }","- int rc = 0;
- memset(uaddr, 0, *uaddrlen);
+ int rc = -EBADF;","static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddrlen, int peer) { struct sockaddr_llc sllc; struct sock *sk = sock->sk; struct llc_sock *llc = llc_sk(sk); int rc = -EBADF; memset(&sllc, 0, sizeof(sllc)); lock_sock(sk); if (sock_flag(sk, SOCK_ZAPPED)) goto out; *uaddrlen = sizeof(sllc); if (peer) { rc = -ENOTCONN; if (sk->sk_state != TCP_ESTABLISHED) goto out; if(llc->dev) sllc.sllc_arphrd = llc->dev->type; sllc.sllc_sap = llc->daddr.lsap; memcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN); } else { rc = -EINVAL; if (!llc->sap) goto out; sllc.sllc_sap = llc->sap->laddr.lsap; if (llc->dev) { sllc.sllc_arphrd = llc->dev->type; memcpy(&sllc.sllc_mac, llc->dev->dev_addr, IFHWADDRLEN); } } rc = 0; sllc.sllc_family = AF_LLC; memcpy(uaddr, &sllc, sizeof(sllc)); out: release_sock(sk); return rc; }"
388,2643----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cosine.c----cosine_read,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) { gint64 offset; <S2SV_StartVul> int pkt_len; <S2SV_EndVul> char line[COSINE_LINE_LENGTH]; offset = cosine_seek_next_packet(wth, err, err_info, line); if (offset < 0) return FALSE; *data_offset = offset; <S2SV_StartVul> pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info); <S2SV_EndVul> <S2SV_StartVul> if (pkt_len == -1) <S2SV_EndVul> <S2SV_StartVul> return FALSE; <S2SV_EndVul> <S2SV_StartVul> return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len, <S2SV_EndVul> <S2SV_StartVul> wth->frame_buffer, err, err_info); <S2SV_EndVul> }","- int pkt_len;
- pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
- if (pkt_len == -1)
- return FALSE;
- return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
- wth->frame_buffer, err, err_info);
+ return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer,
+ line, err, err_info);","static gboolean cosine_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset) { gint64 offset; char line[COSINE_LINE_LENGTH]; offset = cosine_seek_next_packet(wth, err, err_info, line); if (offset < 0) return FALSE; *data_offset = offset; return parse_cosine_packet(wth->fh, &wth->phdr, wth->frame_buffer, line, err, err_info); }"
389,4328----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ethereum.c----ethereum_extractThorchainData,"uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg, char *buffer) { uint16_t offset = 4 + (5 * 32); int16_t len = msg->data_length - offset; <S2SV_StartVul> if (msg->has_data_length && len > 0) { <S2SV_EndVul> memcpy(buffer, msg->data_initial_chunk.bytes + offset, len); <S2SV_StartVul> return len < 256 ? (uint8_t)len : 0; <S2SV_EndVul> } return 0; }","- if (msg->has_data_length && len > 0) {
- return len < 256 ? (uint8_t)len : 0;
+ if (msg->has_data_length && len > 0 && len < 256) {
+ return (uint8_t)len;","uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg, char *buffer) { uint16_t offset = 4 + (5 * 32); int16_t len = msg->data_length - offset; if (msg->has_data_length && len > 0 && len < 256) { memcpy(buffer, msg->data_initial_chunk.bytes + offset, len); return (uint8_t)len; } return 0; }"
390,7308----CWE-326----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/output_core.c----ipv6_select_ident,"__be32 ipv6_select_ident(struct net *net, const struct in6_addr *daddr, const struct in6_addr *saddr) { <S2SV_StartVul> static u32 ip6_idents_hashrnd __read_mostly; <S2SV_EndVul> u32 id; <S2SV_StartVul> net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd)); <S2SV_EndVul> <S2SV_StartVul> id = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr); <S2SV_EndVul> return htonl(id); }","- static u32 ip6_idents_hashrnd __read_mostly;
- net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));
- id = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);
+ id = __ipv6_select_ident(net, daddr, saddr);","__be32 ipv6_select_ident(struct net *net, const struct in6_addr *daddr, const struct in6_addr *saddr) { u32 id; id = __ipv6_select_ident(net, daddr, saddr); return htonl(id); }"
391,4229----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/indent.c----get_lisp_indent,"get_lisp_indent(void) { pos_T *pos, realpos, paren; int amount; char_u *that; colnr_T col; colnr_T firsttry; int parencount, quotecount; int vi_lisp; vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL); realpos = curwin->w_cursor; curwin->w_cursor.col = 0; if ((pos = findmatch(NULL, '(')) == NULL) pos = findmatch(NULL, '['); else { paren = *pos; pos = findmatch(NULL, '['); if (pos == NULL || LT_POSP(pos, &paren)) pos = &paren; } if (pos != NULL) { amount = -1; parencount = 0; while (--curwin->w_cursor.lnum >= pos->lnum) { if (linewhite(curwin->w_cursor.lnum)) continue; for (that = ml_get_curline(); *that != NUL; ++that) { if (*that == ';') { while (*(that + 1) != NUL) ++that; continue; } if (*that == '\\') { if (*(that + 1) != NUL) ++that; continue; } if (*that == '""' && *(that + 1) != NUL) { while (*++that && *that != '""') { if (*that == '\\') { if (*++that == NUL) break; if (that[1] == NUL) { ++that; break; } } } if (*that == NUL) break; } if (*that == '(' || *that == '[') ++parencount; else if (*that == ')' || *that == ']') --parencount; } if (parencount == 0) { amount = get_indent(); break; } } if (amount == -1) { curwin->w_cursor.lnum = pos->lnum; curwin->w_cursor.col = pos->col; col = pos->col; that = ml_get_curline(); if (vi_lisp && get_indent() == 0) amount = 2; else { char_u *line = that; amount = 0; while (*that && col) { amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount); col--; } if (!vi_lisp && (*that == '(' || *that == '[') && lisp_match(that + 1)) amount += 2; else { <S2SV_StartVul> that++; <S2SV_EndVul> <S2SV_StartVul> amount++; <S2SV_EndVul> firsttry = amount; while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize(line, that, (colnr_T)amount); ++that; } if (*that && *that != ';') { if (!vi_lisp && *that != '(' && *that != '[') firsttry++; parencount = 0; quotecount = 0; if (vi_lisp || (*that != '""' && *that != '\'' && *that != '#' && (*that < '0' || *that > '9'))) { while (*that && (!VIM_ISWHITE(*that) || quotecount || parencount) && (!((*that == '(' || *that == '[') && !quotecount && !parencount && vi_lisp))) { if (*that == '""') quotecount = !quotecount; if ((*that == '(' || *that == '[') && !quotecount) ++parencount; if ((*that == ')' || *that == ']') && !quotecount) --parencount; if (*that == '\\' && *(that+1) != NUL) amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); } } while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize( line, that, (colnr_T)amount); that++; } if (!*that || *that == ';') amount = firsttry; } } } } } else amount = 0; curwin->w_cursor = realpos; return amount; }","- that++;
- amount++;
+ if (*that != NUL)
+ {
+ that++;
+ amount++;
+ }","get_lisp_indent(void) { pos_T *pos, realpos, paren; int amount; char_u *that; colnr_T col; colnr_T firsttry; int parencount, quotecount; int vi_lisp; vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL); realpos = curwin->w_cursor; curwin->w_cursor.col = 0; if ((pos = findmatch(NULL, '(')) == NULL) pos = findmatch(NULL, '['); else { paren = *pos; pos = findmatch(NULL, '['); if (pos == NULL || LT_POSP(pos, &paren)) pos = &paren; } if (pos != NULL) { amount = -1; parencount = 0; while (--curwin->w_cursor.lnum >= pos->lnum) { if (linewhite(curwin->w_cursor.lnum)) continue; for (that = ml_get_curline(); *that != NUL; ++that) { if (*that == ';') { while (*(that + 1) != NUL) ++that; continue; } if (*that == '\\') { if (*(that + 1) != NUL) ++that; continue; } if (*that == '""' && *(that + 1) != NUL) { while (*++that && *that != '""') { if (*that == '\\') { if (*++that == NUL) break; if (that[1] == NUL) { ++that; break; } } } if (*that == NUL) break; } if (*that == '(' || *that == '[') ++parencount; else if (*that == ')' || *that == ']') --parencount; } if (parencount == 0) { amount = get_indent(); break; } } if (amount == -1) { curwin->w_cursor.lnum = pos->lnum; curwin->w_cursor.col = pos->col; col = pos->col; that = ml_get_curline(); if (vi_lisp && get_indent() == 0) amount = 2; else { char_u *line = that; amount = 0; while (*that && col) { amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount); col--; } if (!vi_lisp && (*that == '(' || *that == '[') && lisp_match(that + 1)) amount += 2; else { if (*that != NUL) { that++; amount++; } firsttry = amount; while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize(line, that, (colnr_T)amount); ++that; } if (*that && *that != ';') { if (!vi_lisp && *that != '(' && *that != '[') firsttry++; parencount = 0; quotecount = 0; if (vi_lisp || (*that != '""' && *that != '\'' && *that != '#' && (*that < '0' || *that > '9'))) { while (*that && (!VIM_ISWHITE(*that) || quotecount || parencount) && (!((*that == '(' || *that == '[') && !quotecount && !parencount && vi_lisp))) { if (*that == '""') quotecount = !quotecount; if ((*that == '(' || *that == '[') && !quotecount) ++parencount; if ((*that == ')' || *that == ']') && !quotecount) --parencount; if (*that == '\\' && *(that+1) != NUL) amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); } } while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize( line, that, (colnr_T)amount); that++; } if (!*that || *that == ';') amount = firsttry; } } } } } else amount = 0; curwin->w_cursor = realpos; return amount; }"
392,5365----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/userfunc.c----lambda_function_body,"lambda_function_body( char_u **arg, typval_T *rettv, evalarg_T *evalarg, garray_T *newargs, garray_T *argtypes, int varargs, garray_T *default_args, char_u *ret_type) { int evaluate = (evalarg->eval_flags & EVAL_EVALUATE); garray_T *gap = &evalarg->eval_ga; garray_T *freegap = &evalarg->eval_freega; ufunc_T *ufunc = NULL; exarg_T eap; garray_T newlines; char_u *cmdline = NULL; int ret = FAIL; char_u *line_to_free = NULL; partial_T *pt; char_u *name; int lnum_save = -1; linenr_T sourcing_lnum_top = SOURCING_LNUM; if (!ends_excmd2(*arg, skipwhite(*arg + 1))) { semsg(_(e_trailing_arg), *arg + 1); return FAIL; } CLEAR_FIELD(eap); eap.cmdidx = CMD_block; eap.forceit = FALSE; eap.cmdlinep = &cmdline; eap.skip = !evaluate; if (evalarg->eval_cctx != NULL) fill_exarg_from_cctx(&eap, evalarg->eval_cctx); else { eap.getline = evalarg->eval_getline; eap.cookie = evalarg->eval_cookie; } ga_init2(&newlines, (int)sizeof(char_u *), 10); if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL) { vim_free(cmdline); goto erret; } evalarg->eval_break_count += newlines.ga_len; if (gap->ga_itemsize > 0) { int idx; char_u *last; size_t plen; char_u *pnl; for (idx = 0; idx < newlines.ga_len; ++idx) { char_u *p = skipwhite(((char_u **)newlines.ga_data)[idx]); if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL) goto erret; if (*p == NUL || vim9_comment_start(p)) p = (char_u *)""""; plen = STRLEN(p); pnl = vim_strnsave((char_u *)""\n"", plen + 1); if (pnl != NULL) mch_memmove(pnl + 1, p, plen + 1); ((char_u **)gap->ga_data)[gap->ga_len++] = pnl; ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl; } if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL) goto erret; <S2SV_StartVul> if (cmdline != NULL) <S2SV_EndVul> last = cmdline; else last = (char_u *)""}""; plen = STRLEN(last); pnl = vim_strnsave((char_u *)""\n"", plen + 1); if (pnl != NULL) mch_memmove(pnl + 1, last, plen + 1); ((char_u **)gap->ga_data)[gap->ga_len++] = pnl; ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl; } <S2SV_StartVul> if (cmdline != NULL) <S2SV_EndVul> { garray_T *tfgap = &evalarg->eval_tofree_ga; *arg = eap.nextcmd; if (ga_grow(tfgap, 1) == OK) { ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline; evalarg->eval_using_cmdline = TRUE; } } else *arg = (char_u *)""""; if (!evaluate) { ret = OK; goto erret; } name = get_lambda_name(); ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1); if (ufunc == NULL) goto erret; set_ufunc_name(ufunc, name); if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL) goto erret; ufunc->uf_flags = FC_LAMBDA; ufunc->uf_refcount = 1; ufunc->uf_args = *newargs; newargs->ga_data = NULL; ufunc->uf_def_args = *default_args; default_args->ga_data = NULL; ufunc->uf_func_type = &t_func_any; lnum_save = SOURCING_LNUM; SOURCING_LNUM = sourcing_lnum_top; if (parse_argument_types(ufunc, argtypes, varargs) == FAIL) { SOURCING_LNUM = lnum_save; goto erret; } if (parse_return_type(ufunc, ret_type) == FAIL) goto erret; pt = ALLOC_CLEAR_ONE(partial_T); if (pt == NULL) goto erret; pt->pt_func = ufunc; pt->pt_refcount = 1; ufunc->uf_lines = newlines; newlines.ga_data = NULL; if (sandbox) ufunc->uf_flags |= FC_SANDBOX; if (!ASCII_ISUPPER(*ufunc->uf_name)) ufunc->uf_flags |= FC_VIM9; ufunc->uf_script_ctx = current_sctx; ufunc->uf_script_ctx_version = current_sctx.sc_version; ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top; set_function_type(ufunc); function_using_block_scopes(ufunc, evalarg->eval_cstack); rettv->vval.v_partial = pt; rettv->v_type = VAR_PARTIAL; ufunc = NULL; ret = OK; erret: if (lnum_save >= 0) SOURCING_LNUM = lnum_save; vim_free(line_to_free); ga_clear_strings(&newlines); if (newargs != NULL) ga_clear_strings(newargs); ga_clear_strings(default_args); if (ufunc != NULL) { func_clear(ufunc, TRUE); func_free(ufunc, TRUE); } return ret; }","- if (cmdline != NULL)
- if (cmdline != NULL)
+ if (eap.nextcmd != NULL)
+ if (eap.nextcmd != NULL)
+ if (cmdline == line_to_free)
+ line_to_free = NULL;","lambda_function_body( char_u **arg, typval_T *rettv, evalarg_T *evalarg, garray_T *newargs, garray_T *argtypes, int varargs, garray_T *default_args, char_u *ret_type) { int evaluate = (evalarg->eval_flags & EVAL_EVALUATE); garray_T *gap = &evalarg->eval_ga; garray_T *freegap = &evalarg->eval_freega; ufunc_T *ufunc = NULL; exarg_T eap; garray_T newlines; char_u *cmdline = NULL; int ret = FAIL; char_u *line_to_free = NULL; partial_T *pt; char_u *name; int lnum_save = -1; linenr_T sourcing_lnum_top = SOURCING_LNUM; if (!ends_excmd2(*arg, skipwhite(*arg + 1))) { semsg(_(e_trailing_arg), *arg + 1); return FAIL; } CLEAR_FIELD(eap); eap.cmdidx = CMD_block; eap.forceit = FALSE; eap.cmdlinep = &cmdline; eap.skip = !evaluate; if (evalarg->eval_cctx != NULL) fill_exarg_from_cctx(&eap, evalarg->eval_cctx); else { eap.getline = evalarg->eval_getline; eap.cookie = evalarg->eval_cookie; } ga_init2(&newlines, (int)sizeof(char_u *), 10); if (get_function_body(&eap, &newlines, NULL, &line_to_free) == FAIL) { vim_free(cmdline); goto erret; } evalarg->eval_break_count += newlines.ga_len; if (gap->ga_itemsize > 0) { int idx; char_u *last; size_t plen; char_u *pnl; for (idx = 0; idx < newlines.ga_len; ++idx) { char_u *p = skipwhite(((char_u **)newlines.ga_data)[idx]); if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL) goto erret; if (*p == NUL || vim9_comment_start(p)) p = (char_u *)""""; plen = STRLEN(p); pnl = vim_strnsave((char_u *)""\n"", plen + 1); if (pnl != NULL) mch_memmove(pnl + 1, p, plen + 1); ((char_u **)gap->ga_data)[gap->ga_len++] = pnl; ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl; } if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL) goto erret; if (eap.nextcmd != NULL) last = cmdline; else last = (char_u *)""}""; plen = STRLEN(last); pnl = vim_strnsave((char_u *)""\n"", plen + 1); if (pnl != NULL) mch_memmove(pnl + 1, last, plen + 1); ((char_u **)gap->ga_data)[gap->ga_len++] = pnl; ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl; } if (eap.nextcmd != NULL) { garray_T *tfgap = &evalarg->eval_tofree_ga; *arg = eap.nextcmd; if (ga_grow(tfgap, 1) == OK) { ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline; evalarg->eval_using_cmdline = TRUE; if (cmdline == line_to_free) line_to_free = NULL; } } else *arg = (char_u *)""""; if (!evaluate) { ret = OK; goto erret; } name = get_lambda_name(); ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1); if (ufunc == NULL) goto erret; set_ufunc_name(ufunc, name); if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL) goto erret; ufunc->uf_flags = FC_LAMBDA; ufunc->uf_refcount = 1; ufunc->uf_args = *newargs; newargs->ga_data = NULL; ufunc->uf_def_args = *default_args; default_args->ga_data = NULL; ufunc->uf_func_type = &t_func_any; lnum_save = SOURCING_LNUM; SOURCING_LNUM = sourcing_lnum_top; if (parse_argument_types(ufunc, argtypes, varargs) == FAIL) { SOURCING_LNUM = lnum_save; goto erret; } if (parse_return_type(ufunc, ret_type) == FAIL) goto erret; pt = ALLOC_CLEAR_ONE(partial_T); if (pt == NULL) goto erret; pt->pt_func = ufunc; pt->pt_refcount = 1; ufunc->uf_lines = newlines; newlines.ga_data = NULL; if (sandbox) ufunc->uf_flags |= FC_SANDBOX; if (!ASCII_ISUPPER(*ufunc->uf_name)) ufunc->uf_flags |= FC_VIM9; ufunc->uf_script_ctx = current_sctx; ufunc->uf_script_ctx_version = current_sctx.sc_version; ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top; set_function_type(ufunc); function_using_block_scopes(ufunc, evalarg->eval_cstack); rettv->vval.v_partial = pt; rettv->v_type = VAR_PARTIAL; ufunc = NULL; ret = OK; erret: if (lnum_save >= 0) SOURCING_LNUM = lnum_save; vim_free(line_to_free); ga_clear_strings(&newlines); if (newargs != NULL) ga_clear_strings(newargs); ga_clear_strings(default_args); if (ufunc != NULL) { func_clear(ufunc, TRUE); func_free(ufunc, TRUE); } return ret; }"
393,6490----CWE-358----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/defrag.c----DefragMfIpv6Test,"static int DefragMfIpv6Test(void) { int retval = 0; int ip_id = 9; Packet *p = NULL; DefragInit(); <S2SV_StartVul> Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8); <S2SV_EndVul> <S2SV_StartVul> Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8); <S2SV_EndVul> <S2SV_StartVul> Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8); <S2SV_EndVul> if (p1 == NULL || p2 == NULL || p3 == NULL) { goto end; } p = Defrag(NULL, NULL, p1, NULL); if (p != NULL) { goto end; } p = Defrag(NULL, NULL, p2, NULL); if (p != NULL) { goto end; } p = Defrag(NULL, NULL, p3, NULL); if (p == NULL) { goto end; } if (IPV6_GET_PLEN(p) != 16) { goto end; } retval = 1; end: if (p1 != NULL) { SCFree(p1); } if (p2 != NULL) { SCFree(p2); } if (p3 != NULL) { SCFree(p3); } if (p != NULL) { SCFree(p); } DefragDestroy(); return retval; }","- Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);
- Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);
- Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);
+ Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8);
+ Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8);
+ Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8);","static int DefragMfIpv6Test(void) { int retval = 0; int ip_id = 9; Packet *p = NULL; DefragInit(); Packet *p1 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 2, 1, 'C', 8); Packet *p2 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 0, 1, 'A', 8); Packet *p3 = IPV6BuildTestPacket(IPPROTO_ICMPV6, ip_id, 1, 0, 'B', 8); if (p1 == NULL || p2 == NULL || p3 == NULL) { goto end; } p = Defrag(NULL, NULL, p1, NULL); if (p != NULL) { goto end; } p = Defrag(NULL, NULL, p2, NULL); if (p != NULL) { goto end; } p = Defrag(NULL, NULL, p3, NULL); if (p == NULL) { goto end; } if (IPV6_GET_PLEN(p) != 16) { goto end; } retval = 1; end: if (p1 != NULL) { SCFree(p1); } if (p2 != NULL) { SCFree(p2); } if (p3 != NULL) { SCFree(p3); } if (p != NULL) { SCFree(p); } DefragDestroy(); return retval; }"
394,3650----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/op_level_cost_estimator.cc----tensorflow::grappler::OpLevelCostEstimator::CalculateTensorSize,"int64_t OpLevelCostEstimator::CalculateTensorSize( const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) { int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes); int size = DataTypeSize(BaseType(tensor.dtype())); VLOG(2) << ""Count: "" << count << "" DataTypeSize: "" << size; <S2SV_StartVul> return count * size; <S2SV_EndVul> }","- return count * size;
+ int64_t tensor_size = MultiplyWithoutOverflow(count, size);
+ if (tensor_size < 0) {
+ VLOG(1) << ""Overflow encountered when computing tensor size, multiplying ""
+ << count << "" with "" << size;
+ return -1;
+ }
+ return tensor_size;","int64_t OpLevelCostEstimator::CalculateTensorSize( const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) { int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes); int size = DataTypeSize(BaseType(tensor.dtype())); VLOG(2) << ""Count: "" << count << "" DataTypeSize: "" << size; int64_t tensor_size = MultiplyWithoutOverflow(count, size); if (tensor_size < 0) { VLOG(1) << ""Overflow encountered when computing tensor size, multiplying "" << count << "" with "" << size; return -1; } return tensor_size; }"
395,2456----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-9728--symlink.c----udf_symlink_filler,"static int udf_symlink_filler(struct file *file, struct page *page) { struct inode *inode = page->mapping->host; struct buffer_head *bh = NULL; unsigned char *symlink; <S2SV_StartVul> int err = -EIO; <S2SV_EndVul> unsigned char *p = kmap(page); struct udf_inode_info *iinfo; uint32_t pos; iinfo = UDF_I(inode); pos = udf_block_map(inode, 0); down_read(&iinfo->i_data_sem); if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) { symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr; } else { bh = sb_bread(inode->i_sb, pos); <S2SV_StartVul> if (!bh) <S2SV_EndVul> <S2SV_StartVul> goto out; <S2SV_EndVul> symlink = bh->b_data; } udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p); brelse(bh); up_read(&iinfo->i_data_sem); SetPageUptodate(page); kunmap(page); unlock_page(page); return 0; <S2SV_StartVul> out: <S2SV_EndVul> up_read(&iinfo->i_data_sem); SetPageError(page); kunmap(page); unlock_page(page); return err; }","- int err = -EIO;
- if (!bh)
- goto out;
- out:
+ int err;
+ if (inode->i_size > inode->i_sb->s_blocksize) {
+ err = -ENAMETOOLONG;
+ goto out_unmap;
+ }
+ if (!bh) {
+ err = -EIO;
+ goto out_unlock_inode;
+ }
+ out_unlock_inode:
+ out_unmap:","static int udf_symlink_filler(struct file *file, struct page *page) { struct inode *inode = page->mapping->host; struct buffer_head *bh = NULL; unsigned char *symlink; int err; unsigned char *p = kmap(page); struct udf_inode_info *iinfo; uint32_t pos; if (inode->i_size > inode->i_sb->s_blocksize) { err = -ENAMETOOLONG; goto out_unmap; } iinfo = UDF_I(inode); pos = udf_block_map(inode, 0); down_read(&iinfo->i_data_sem); if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) { symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr; } else { bh = sb_bread(inode->i_sb, pos); if (!bh) { err = -EIO; goto out_unlock_inode; } symlink = bh->b_data; } udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p); brelse(bh); up_read(&iinfo->i_data_sem); SetPageUptodate(page); kunmap(page); unlock_page(page); return 0; out_unlock_inode: up_read(&iinfo->i_data_sem); SetPageError(page); out_unmap: kunmap(page); unlock_page(page); return err; }"
396,7486----CWE-706----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/checkout.c----checkout_verify_paths,"static int checkout_verify_paths( git_repository *repo, int action, git_diff_delta *delta) { <S2SV_StartVul> unsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS; <S2SV_EndVul> if (action & CHECKOUT_ACTION__REMOVE) { if (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) { git_error_set(GIT_ERROR_CHECKOUT, ""cannot remove invalid path '%s'"", delta->old_file.path); return -1; } } if (action & ~CHECKOUT_ACTION__REMOVE) { if (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) { git_error_set(GIT_ERROR_CHECKOUT, ""cannot checkout to invalid path '%s'"", delta->new_file.path); return -1; } } return 0; }","- unsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;
+ unsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;","static int checkout_verify_paths( git_repository *repo, int action, git_diff_delta *delta) { unsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS; if (action & CHECKOUT_ACTION__REMOVE) { if (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) { git_error_set(GIT_ERROR_CHECKOUT, ""cannot remove invalid path '%s'"", delta->old_file.path); return -1; } } if (action & ~CHECKOUT_ACTION__REMOVE) { if (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) { git_error_set(GIT_ERROR_CHECKOUT, ""cannot checkout to invalid path '%s'"", delta->new_file.path); return -1; } } return 0; }"
397,5525----CWE-674----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/conn_pool_base.cc----Envoy::ConnectionPool::ConnPoolImplBase::onConnectionEvent,"void ConnPoolImplBase::onConnectionEvent(ActiveClient& client, absl::string_view failure_reason, Network::ConnectionEvent event) { if (client.state() == ActiveClient::State::CONNECTING) { ASSERT(connecting_stream_capacity_ >= client.effectiveConcurrentStreamLimit()); connecting_stream_capacity_ -= client.effectiveConcurrentStreamLimit(); } if (client.connect_timer_) { client.connect_timer_->disableTimer(); client.connect_timer_.reset(); } if (event == Network::ConnectionEvent::RemoteClose || event == Network::ConnectionEvent::LocalClose) { state_.decrConnectingAndConnectedStreamCapacity(client.currentUnusedCapacity()); client.remaining_streams_ = 0; ENVOY_CONN_LOG(debug, ""client disconnected, failure reason: {}"", client, failure_reason); Envoy::Upstream::reportUpstreamCxDestroy(host_, event); const bool incomplete_stream = client.closingWithIncompleteStream(); if (incomplete_stream) { Envoy::Upstream::reportUpstreamCxDestroyActiveRequest(host_, event); } if (client.state() == ActiveClient::State::CONNECTING) { host_->cluster().stats().upstream_cx_connect_fail_.inc(); host_->stats().cx_connect_fail_.inc(); ConnectionPool::PoolFailureReason reason; if (client.timed_out_) { reason = ConnectionPool::PoolFailureReason::Timeout; } else if (event == Network::ConnectionEvent::RemoteClose) { reason = ConnectionPool::PoolFailureReason::RemoteConnectionFailure; } else { reason = ConnectionPool::PoolFailureReason::LocalConnectionFailure; } purgePendingStreams(client.real_host_description_, failure_reason, reason); if (!is_draining_for_deletion_) { tryCreateNewConnections(); } } client.releaseResources(); if (client.connection_duration_timer_) { client.connection_duration_timer_->disableTimer(); client.connection_duration_timer_.reset(); } dispatcher_.deferredDelete(client.removeFromList(owningList(client.state()))); <S2SV_StartVul> checkForIdleAndCloseIdleConnsIfDraining(); <S2SV_EndVul> client.setState(ActiveClient::State::CLOSED); if (!pending_streams_.empty()) { tryCreateNewConnections(); } } else if (event == Network::ConnectionEvent::Connected) { client.conn_connect_ms_->complete(); client.conn_connect_ms_.reset(); ASSERT(client.state() == ActiveClient::State::CONNECTING); bool streams_available = client.currentUnusedCapacity() > 0; transitionActiveClientState(client, streams_available ? ActiveClient::State::READY : ActiveClient::State::BUSY); const absl::optional<std::chrono::milliseconds> max_connection_duration = client.parent_.host()->cluster().maxConnectionDuration(); if (max_connection_duration.has_value()) { client.connection_duration_timer_ = client.parent_.dispatcher().createTimer( [&client]() { client.onConnectionDurationTimeout(); }); client.connection_duration_timer_->enableTimer(max_connection_duration.value()); } onConnected(client); if (streams_available) { onUpstreamReady(); } checkForIdleAndCloseIdleConnsIfDraining(); } }","- checkForIdleAndCloseIdleConnsIfDraining();
+ checkForIdleAndNotify();","void ConnPoolImplBase::onConnectionEvent(ActiveClient& client, absl::string_view failure_reason, Network::ConnectionEvent event) { if (client.state() == ActiveClient::State::CONNECTING) { ASSERT(connecting_stream_capacity_ >= client.effectiveConcurrentStreamLimit()); connecting_stream_capacity_ -= client.effectiveConcurrentStreamLimit(); } if (client.connect_timer_) { client.connect_timer_->disableTimer(); client.connect_timer_.reset(); } if (event == Network::ConnectionEvent::RemoteClose || event == Network::ConnectionEvent::LocalClose) { state_.decrConnectingAndConnectedStreamCapacity(client.currentUnusedCapacity()); client.remaining_streams_ = 0; ENVOY_CONN_LOG(debug, ""client disconnected, failure reason: {}"", client, failure_reason); Envoy::Upstream::reportUpstreamCxDestroy(host_, event); const bool incomplete_stream = client.closingWithIncompleteStream(); if (incomplete_stream) { Envoy::Upstream::reportUpstreamCxDestroyActiveRequest(host_, event); } if (client.state() == ActiveClient::State::CONNECTING) { host_->cluster().stats().upstream_cx_connect_fail_.inc(); host_->stats().cx_connect_fail_.inc(); ConnectionPool::PoolFailureReason reason; if (client.timed_out_) { reason = ConnectionPool::PoolFailureReason::Timeout; } else if (event == Network::ConnectionEvent::RemoteClose) { reason = ConnectionPool::PoolFailureReason::RemoteConnectionFailure; } else { reason = ConnectionPool::PoolFailureReason::LocalConnectionFailure; } purgePendingStreams(client.real_host_description_, failure_reason, reason); if (!is_draining_for_deletion_) { tryCreateNewConnections(); } } client.releaseResources(); if (client.connection_duration_timer_) { client.connection_duration_timer_->disableTimer(); client.connection_duration_timer_.reset(); } dispatcher_.deferredDelete(client.removeFromList(owningList(client.state()))); checkForIdleAndNotify(); client.setState(ActiveClient::State::CLOSED); if (!pending_streams_.empty()) { tryCreateNewConnections(); } } else if (event == Network::ConnectionEvent::Connected) { client.conn_connect_ms_->complete(); client.conn_connect_ms_.reset(); ASSERT(client.state() == ActiveClient::State::CONNECTING); bool streams_available = client.currentUnusedCapacity() > 0; transitionActiveClientState(client, streams_available ? ActiveClient::State::READY : ActiveClient::State::BUSY); const absl::optional<std::chrono::milliseconds> max_connection_duration = client.parent_.host()->cluster().maxConnectionDuration(); if (max_connection_duration.has_value()) { client.connection_duration_timer_ = client.parent_.dispatcher().createTimer( [&client]() { client.onConnectionDurationTimeout(); }); client.connection_duration_timer_->enableTimer(max_connection_duration.value()); } onConnected(client); if (streams_available) { onUpstreamReady(); } checkForIdleAndCloseIdleConnsIfDraining(); } }"
398,5048----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/gd_jpeg.c----gdImageJpegPtr,"void *gdImageJpegPtr (gdImagePtr im, int *size, int quality) { void *rv; gdIOCtx *out = gdNewDynamicCtx (2048, NULL); <S2SV_StartVul> gdImageJpegCtx (im, out, quality); <S2SV_EndVul> <S2SV_StartVul> rv = gdDPExtractData (out, size); <S2SV_EndVul> out->gd_free (out); return rv; }","- gdImageJpegCtx (im, out, quality);
- rv = gdDPExtractData (out, size);
+ if (!_gdImageJpegCtx(im, out, quality)) {
+ rv = gdDPExtractData(out, size);
+ } else {
+ rv = NULL;
+ }","void *gdImageJpegPtr (gdImagePtr im, int *size, int quality) { void *rv; gdIOCtx *out = gdNewDynamicCtx (2048, NULL); if (!_gdImageJpegCtx(im, out, quality)) { rv = gdDPExtractData(out, size); } else { rv = NULL; } out->gd_free (out); return rv; }"
399,6509----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/common.c----TfLiteIntArrayCreate,TfLiteIntArray* TfLiteIntArrayCreate(int size) { <S2SV_StartVul> TfLiteIntArray* ret = <S2SV_EndVul> <S2SV_StartVul> (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size)); <S2SV_EndVul> ret->size = size; return ret; },"- TfLiteIntArray* ret =
- (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));
+ int alloc_size = TfLiteIntArrayGetSizeInBytes(size);
+ if (alloc_size <= 0) return NULL;
+ TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);
+ if (!ret) return ret;",TfLiteIntArray* TfLiteIntArrayCreate(int size) { int alloc_size = TfLiteIntArrayGetSizeInBytes(size); if (alloc_size <= 0) return NULL; TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size); if (!ret) return ret; ret->size = size; return ret; }
400,1724----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10146--caption.c----*ReadCAPTIONImage,"static Image *ReadCAPTIONImage(const ImageInfo *image_info, ExceptionInfo *exception) { char *caption, geometry[MaxTextExtent], *property, *text; const char *gravity, *option; DrawInfo *draw_info; Image *image; MagickBooleanType split, status; register ssize_t i; size_t height, width; TypeMetric metrics; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); (void) ResetImagePage(image,""0x0+0+0""); option=GetImageOption(image_info,""filename""); if (option == (const char *) NULL) property=InterpretImageProperties(image_info,image,image_info->filename); else if (LocaleNCompare(option,""caption:"",8) == 0) property=InterpretImageProperties(image_info,image,option+8); else property=InterpretImageProperties(image_info,image,option); (void) SetImageProperty(image,""caption"",property); property=DestroyString(property); caption=ConstantString(GetImageProperty(image,""caption"")); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); (void) CloneString(&draw_info->text,caption); gravity=GetImageOption(image_info,""gravity""); if (gravity != (char *) NULL) draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions, MagickFalse,gravity); split=MagickFalse; status=MagickTrue; if (image->columns == 0) { text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); image->columns=width; } if (image->rows == 0) { split=MagickTrue; text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+ draw_info->interline_spacing+draw_info->stroke_width)+0.5); } if (status != MagickFalse) status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); InheritException(exception,&image->exception); return(DestroyImageList(image)); } if (SetImageBackgroundColor(image) == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); InheritException(exception,&image->exception); image=DestroyImageList(image); return((Image *) NULL); } if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0)) { double high, low; for ( ; ; draw_info->pointsize*=2.0) { text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); (void) status; width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width >= image->columns) && (height >= image->rows)) break; } else if (((image->columns != 0) && (width >= image->columns)) || ((image->rows != 0) && (height >= image->rows))) break; } high=draw_info->pointsize; for (low=1.0; (high-low) > 0.5; ) { draw_info->pointsize=(low+high)/2.0; text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); (void) GetMultilineTypeMetrics(image,draw_info,&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } else if (((image->columns != 0) && (width < image->columns)) || ((image->rows != 0) && (height < image->rows))) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } draw_info->pointsize=floor((low+high)/2.0-0.5); } i=FormatMagickCaption(image,draw_info,split,&metrics,&caption); (void) CloneString(&draw_info->text,caption); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",MagickMax( draw_info->direction == RightToLeftDirection ? image->columns- metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity == UndefinedGravity ? metrics.ascent : 0.0); draw_info->geometry=AcquireString(geometry); status=AnnotateImage(image,draw_info); if (image_info->pointsize == 0.0) { char pointsize[MaxTextExtent]; (void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"", <S2SV_StartVul> draw_info->pointsize); <S2SV_EndVul> (void) SetImageProperty(image,""caption:pointsize"",pointsize); } draw_info=DestroyDrawInfo(draw_info); caption=DestroyString(caption); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } return(GetFirstImageInList(image)); }","- draw_info->pointsize);
+ }","static Image *ReadCAPTIONImage(const ImageInfo *image_info, ExceptionInfo *exception) { char *caption, geometry[MaxTextExtent], *property, *text; const char *gravity, *option; DrawInfo *draw_info; Image *image; MagickBooleanType split, status; register ssize_t i; size_t height, width; TypeMetric metrics; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); (void) ResetImagePage(image,""0x0+0+0""); option=GetImageOption(image_info,""filename""); if (option == (const char *) NULL) property=InterpretImageProperties(image_info,image,image_info->filename); else if (LocaleNCompare(option,""caption:"",8) == 0) property=InterpretImageProperties(image_info,image,option+8); else property=InterpretImageProperties(image_info,image,option); (void) SetImageProperty(image,""caption"",property); property=DestroyString(property); caption=ConstantString(GetImageProperty(image,""caption"")); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); (void) CloneString(&draw_info->text,caption); gravity=GetImageOption(image_info,""gravity""); if (gravity != (char *) NULL) draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions, MagickFalse,gravity); split=MagickFalse; status=MagickTrue; if (image->columns == 0) { text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); image->columns=width; } if (image->rows == 0) { split=MagickTrue; text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+ draw_info->interline_spacing+draw_info->stroke_width)+0.5); } if (status != MagickFalse) status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); InheritException(exception,&image->exception); return(DestroyImageList(image)); } if (SetImageBackgroundColor(image) == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); InheritException(exception,&image->exception); image=DestroyImageList(image); return((Image *) NULL); } if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0)) { double high, low; for ( ; ; draw_info->pointsize*=2.0) { text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); (void) status; width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width >= image->columns) && (height >= image->rows)) break; } else if (((image->columns != 0) && (width >= image->columns)) || ((image->rows != 0) && (height >= image->rows))) break; } high=draw_info->pointsize; for (low=1.0; (high-low) > 0.5; ) { draw_info->pointsize=(low+high)/2.0; text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); (void) GetMultilineTypeMetrics(image,draw_info,&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } else if (((image->columns != 0) && (width < image->columns)) || ((image->rows != 0) && (height < image->rows))) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } draw_info->pointsize=floor((low+high)/2.0-0.5); } i=FormatMagickCaption(image,draw_info,split,&metrics,&caption); (void) CloneString(&draw_info->text,caption); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",MagickMax( draw_info->direction == RightToLeftDirection ? image->columns- metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity == UndefinedGravity ? metrics.ascent : 0.0); (void) CloneString(&draw_info->geometry,geometry); status=AnnotateImage(image,draw_info); if (image_info->pointsize == 0.0) { char pointsize[MaxTextExtent]; (void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"", draw_info->pointsize); (void) SetImageProperty(image,""caption:pointsize"",pointsize); } draw_info=DestroyDrawInfo(draw_info); caption=DestroyString(caption); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } return(GetFirstImageInList(image)); }"
401,1929----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-17942--vasnprintf.c----convert_to_decimal,"convert_to_decimal (mpn_t a, size_t extra_zeroes) { mp_limb_t *a_ptr = a.limbs; size_t a_len = a.nlimbs; size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1); <S2SV_StartVul> char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes)); <S2SV_EndVul> if (c_ptr != NULL) { char *d_ptr = c_ptr; for (; extra_zeroes > 0; extra_zeroes--) *d_ptr++ = '0'; while (a_len > 0) { mp_limb_t remainder = 0; mp_limb_t *ptr = a_ptr + a_len; size_t count; for (count = a_len; count > 0; count--) { mp_twolimb_t num = ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr; *ptr = num / 1000000000; remainder = num % 1000000000; } for (count = 9; count > 0; count--) { *d_ptr++ = '0' + (remainder % 10); remainder = remainder / 10; } if (a_ptr[a_len - 1] == 0) a_len--; } while (d_ptr > c_ptr && d_ptr[-1] == '0') d_ptr--; if (d_ptr == c_ptr) *d_ptr++ = '0'; *d_ptr = '\0'; } return c_ptr; }","- char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));
+ char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1));","convert_to_decimal (mpn_t a, size_t extra_zeroes) { mp_limb_t *a_ptr = a.limbs; size_t a_len = a.nlimbs; size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1); char *c_ptr = (char *) malloc (xsum (xsum (extra_zeroes, c_len), 1)); if (c_ptr != NULL) { char *d_ptr = c_ptr; for (; extra_zeroes > 0; extra_zeroes--) *d_ptr++ = '0'; while (a_len > 0) { mp_limb_t remainder = 0; mp_limb_t *ptr = a_ptr + a_len; size_t count; for (count = a_len; count > 0; count--) { mp_twolimb_t num = ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr; *ptr = num / 1000000000; remainder = num % 1000000000; } for (count = 9; count > 0; count--) { *d_ptr++ = '0' + (remainder % 10); remainder = remainder / 10; } if (a_ptr[a_len - 1] == 0) a_len--; } while (d_ptr > c_ptr && d_ptr[-1] == '0') d_ptr--; if (d_ptr == c_ptr) *d_ptr++ = '0'; *d_ptr = '\0'; } return c_ptr; }"
402,1818----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-6561--smb2_flush.c----smb2_flush,"smb2_flush(smb_request_t *sr) { <S2SV_StartVul> smb_ofile_t *of = NULL; <S2SV_EndVul> uint16_t StructSize; uint16_t reserved1; uint32_t reserved2; smb2fid_t smb2fid; uint32_t status; int rc = 0; rc = smb_mbc_decodef( &sr->smb_data, ""wwlqq"", &StructSize, &reserved1, &reserved2, &smb2fid.persistent, &smb2fid.temporal); if (rc) return (SDRC_ERROR); if (StructSize != 24) return (SDRC_ERROR); status = smb2sr_lookup_fid(sr, &smb2fid); if (status) { smb2sr_put_error(sr, status); return (SDRC_SUCCESS); } <S2SV_StartVul> of = sr->fid_ofile; <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0) <S2SV_EndVul> <S2SV_StartVul> (void) smb_fsop_commit(sr, of->f_cr, of->f_node); <S2SV_EndVul> (void) smb_mbc_encodef( &sr->reply, ""wwl"", 4, 0); return (SDRC_SUCCESS); }","- smb_ofile_t *of = NULL;
- of = sr->fid_ofile;
- if ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)
- (void) smb_fsop_commit(sr, of->f_cr, of->f_node);
+ smb_ofile_flush(sr, sr->fid_ofile);","smb2_flush(smb_request_t *sr) { uint16_t StructSize; uint16_t reserved1; uint32_t reserved2; smb2fid_t smb2fid; uint32_t status; int rc = 0; rc = smb_mbc_decodef( &sr->smb_data, ""wwlqq"", &StructSize, &reserved1, &reserved2, &smb2fid.persistent, &smb2fid.temporal); if (rc) return (SDRC_ERROR); if (StructSize != 24) return (SDRC_ERROR); status = smb2sr_lookup_fid(sr, &smb2fid); if (status) { smb2sr_put_error(sr, status); return (SDRC_SUCCESS); } smb_ofile_flush(sr, sr->fid_ofile); (void) smb_mbc_encodef( &sr->reply, ""wwl"", 4, 0); return (SDRC_SUCCESS); }"
403,3530----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/network-openssl.c----net_connect_ip_ssl,"<S2SV_StartVul> GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify) <S2SV_EndVul> { GIOChannel *handle, *ssl_handle; handle = net_connect_ip(ip, port, my_ip); if (handle == NULL) return NULL; <S2SV_StartVul> ssl_handle = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify); <S2SV_EndVul> if (ssl_handle == NULL) g_io_channel_unref(handle); return ssl_handle; }","- GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)
- ssl_handle = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);
+ GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)
+ ssl_handle = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);","GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify) { GIOChannel *handle, *ssl_handle; handle = net_connect_ip(ip, port, my_ip); if (handle == NULL) return NULL; ssl_handle = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify); if (ssl_handle == NULL) g_io_channel_unref(handle); return ssl_handle; }"
404,5851----CWE-532----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/support.c----_pam_parse,"int _pam_parse(int argc, const char **argv) { int ctrl = 0; const char *current_secret = NULL; memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS); memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS); memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS); memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS); tac_srv_no = 0; tac_service[0] = 0; tac_protocol[0] = 0; tac_prompt[0] = 0; tac_login[0] = 0; for (ctrl = 0; argc-- > 0; ++argv) { if (!strcmp(*argv, ""debug"")) { ctrl |= PAM_TAC_DEBUG; } else if (!strcmp(*argv, ""use_first_pass"")) { ctrl |= PAM_TAC_USE_FIRST_PASS; } else if (!strcmp(*argv, ""try_first_pass"")) { ctrl |= PAM_TAC_TRY_FIRST_PASS; } else if (!strncmp(*argv, ""service="", 8)) { xstrcpy(tac_service, *argv + 8, sizeof(tac_service)); } else if (!strncmp(*argv, ""protocol="", 9)) { xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol)); } else if (!strncmp(*argv, ""prompt="", 7)) { xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt)); unsigned long chr; for (chr = 0; chr < strlen(tac_prompt); chr++) { if (tac_prompt[chr] == '_') { tac_prompt[chr] = ' '; } } } else if (!strncmp(*argv, ""login="", 6)) { xstrcpy(tac_login, *argv + 6, sizeof(tac_login)); } else if (!strcmp(*argv, ""acct_all"")) { ctrl |= PAM_TAC_ACCT; } else if (!strncmp(*argv, ""server="", 7)) { if (tac_srv_no < TAC_PLUS_MAXSERVERS) { struct addrinfo hints, *servers, *server; int rv; char *close_bracket, *server_name, *port, server_buf[256]; memset(&hints, 0, sizeof hints); memset(&server_buf, 0, sizeof(server_buf)); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; if (strlen(*argv + 7) >= sizeof(server_buf)) { _pam_log(LOG_ERR, ""server address too long, sorry""); continue; } strcpy(server_buf, *argv + 7); if (*server_buf == '[' && (close_bracket = strchr(server_buf, ']')) != NULL) { server_name = server_buf + 1; _pam_log (LOG_ERR, ""reading server address as: %s "", server_name); port = strchr(close_bracket, ':'); *close_bracket = '\0'; } else { server_name = server_buf; port = strchr(server_buf, ':'); } if (port != NULL) { *port = '\0'; port++; } _pam_log (LOG_DEBUG, ""sending server address to getaddrinfo as: %s "", server_name); if ((rv = getaddrinfo(server_name, (port == NULL) ? ""49"" : port, &hints, &servers)) == 0) { for (server = servers; server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) { set_tac_srv_addr(tac_srv_no, server); set_tac_srv_key(tac_srv_no, current_secret); tac_srv_no++; } _pam_log(LOG_DEBUG, ""%s: server index %d "", __FUNCTION__, tac_srv_no); freeaddrinfo (servers); } else { _pam_log(LOG_ERR, ""skip invalid server: %s (getaddrinfo: %s)"", server_name, gai_strerror(rv)); } } else { _pam_log(LOG_ERR, ""maximum number of servers (%d) exceeded, skipping"", TAC_PLUS_MAXSERVERS); } } else if (!strncmp(*argv, ""secret="", 7)) { current_secret = *argv + 7; if (tac_srv_no == 0) { _pam_log(LOG_ERR, ""secret set but no servers configured yet""); } else { set_tac_srv_key(tac_srv_no - 1, current_secret); } } else if (!strncmp(*argv, ""timeout="", 8)) { #ifdef HAVE_STRTOL tac_timeout = strtol(*argv + 8, NULL, 10); #else tac_timeout = atoi(*argv + 8); #endif if (tac_timeout == LONG_MAX) { _pam_log(LOG_ERR, ""timeout parameter cannot be parsed as integer: %s"", *argv); tac_timeout = 0; } else { tac_readtimeout_enable = 1; } } else { _pam_log(LOG_WARNING, ""unrecognized option: %s"", *argv); } } if (ctrl & PAM_TAC_DEBUG) { unsigned long n; _pam_log(LOG_DEBUG, ""%d servers defined"", tac_srv_no); for (n = 0; n < tac_srv_no; n++) { <S2SV_StartVul> _pam_log(LOG_DEBUG, ""server[%lu] { addr=%s, key='%s' }"", n, tac_ntop(tac_srv[n].addr->ai_addr), <S2SV_EndVul> <S2SV_StartVul> tac_srv[n].key); <S2SV_EndVul> } _pam_log(LOG_DEBUG, ""tac_service='%s'"", tac_service); _pam_log(LOG_DEBUG, ""tac_protocol='%s'"", tac_protocol); _pam_log(LOG_DEBUG, ""tac_prompt='%s'"", tac_prompt); _pam_log(LOG_DEBUG, ""tac_login='%s'"", tac_login); } return ctrl; }","- _pam_log(LOG_DEBUG, ""server[%lu] { addr=%s, key='%s' }"", n, tac_ntop(tac_srv[n].addr->ai_addr),
- tac_srv[n].key);
+ _pam_log(LOG_DEBUG, ""server[%lu] { addr=%s, key='********' }"", n,
+ tac_ntop(tac_srv[n].addr->ai_addr));","int _pam_parse(int argc, const char **argv) { int ctrl = 0; const char *current_secret = NULL; memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS); memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS); memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS); memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS); tac_srv_no = 0; tac_service[0] = 0; tac_protocol[0] = 0; tac_prompt[0] = 0; tac_login[0] = 0; for (ctrl = 0; argc-- > 0; ++argv) { if (!strcmp(*argv, ""debug"")) { ctrl |= PAM_TAC_DEBUG; } else if (!strcmp(*argv, ""use_first_pass"")) { ctrl |= PAM_TAC_USE_FIRST_PASS; } else if (!strcmp(*argv, ""try_first_pass"")) { ctrl |= PAM_TAC_TRY_FIRST_PASS; } else if (!strncmp(*argv, ""service="", 8)) { xstrcpy(tac_service, *argv + 8, sizeof(tac_service)); } else if (!strncmp(*argv, ""protocol="", 9)) { xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol)); } else if (!strncmp(*argv, ""prompt="", 7)) { xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt)); unsigned long chr; for (chr = 0; chr < strlen(tac_prompt); chr++) { if (tac_prompt[chr] == '_') { tac_prompt[chr] = ' '; } } } else if (!strncmp(*argv, ""login="", 6)) { xstrcpy(tac_login, *argv + 6, sizeof(tac_login)); } else if (!strcmp(*argv, ""acct_all"")) { ctrl |= PAM_TAC_ACCT; } else if (!strncmp(*argv, ""server="", 7)) { if (tac_srv_no < TAC_PLUS_MAXSERVERS) { struct addrinfo hints, *servers, *server; int rv; char *close_bracket, *server_name, *port, server_buf[256]; memset(&hints, 0, sizeof hints); memset(&server_buf, 0, sizeof(server_buf)); hints.ai_family = AF_UNSPEC; hints.ai_socktype = SOCK_STREAM; if (strlen(*argv + 7) >= sizeof(server_buf)) { _pam_log(LOG_ERR, ""server address too long, sorry""); continue; } strcpy(server_buf, *argv + 7); if (*server_buf == '[' && (close_bracket = strchr(server_buf, ']')) != NULL) { server_name = server_buf + 1; _pam_log (LOG_ERR, ""reading server address as: %s "", server_name); port = strchr(close_bracket, ':'); *close_bracket = '\0'; } else { server_name = server_buf; port = strchr(server_buf, ':'); } if (port != NULL) { *port = '\0'; port++; } _pam_log (LOG_DEBUG, ""sending server address to getaddrinfo as: %s "", server_name); if ((rv = getaddrinfo(server_name, (port == NULL) ? ""49"" : port, &hints, &servers)) == 0) { for (server = servers; server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) { set_tac_srv_addr(tac_srv_no, server); set_tac_srv_key(tac_srv_no, current_secret); tac_srv_no++; } _pam_log(LOG_DEBUG, ""%s: server index %d "", __FUNCTION__, tac_srv_no); freeaddrinfo (servers); } else { _pam_log(LOG_ERR, ""skip invalid server: %s (getaddrinfo: %s)"", server_name, gai_strerror(rv)); } } else { _pam_log(LOG_ERR, ""maximum number of servers (%d) exceeded, skipping"", TAC_PLUS_MAXSERVERS); } } else if (!strncmp(*argv, ""secret="", 7)) { current_secret = *argv + 7; if (tac_srv_no == 0) { _pam_log(LOG_ERR, ""secret set but no servers configured yet""); } else { set_tac_srv_key(tac_srv_no - 1, current_secret); } } else if (!strncmp(*argv, ""timeout="", 8)) { #ifdef HAVE_STRTOL tac_timeout = strtol(*argv + 8, NULL, 10); #else tac_timeout = atoi(*argv + 8); #endif if (tac_timeout == LONG_MAX) { _pam_log(LOG_ERR, ""timeout parameter cannot be parsed as integer: %s"", *argv); tac_timeout = 0; } else { tac_readtimeout_enable = 1; } } else { _pam_log(LOG_WARNING, ""unrecognized option: %s"", *argv); } } if (ctrl & PAM_TAC_DEBUG) { unsigned long n; _pam_log(LOG_DEBUG, ""%d servers defined"", tac_srv_no); for (n = 0; n < tac_srv_no; n++) { _pam_log(LOG_DEBUG, ""server[%lu] { addr=%s, key='********' }"", n, tac_ntop(tac_srv[n].addr->ai_addr)); } _pam_log(LOG_DEBUG, ""tac_service='%s'"", tac_service); _pam_log(LOG_DEBUG, ""tac_protocol='%s'"", tac_protocol); _pam_log(LOG_DEBUG, ""tac_prompt='%s'"", tac_prompt); _pam_log(LOG_DEBUG, ""tac_login='%s'"", tac_login); } return ctrl; }"
405,1770----CWE-190----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9557--jas_icc.c----jas_iccgetuint64,"static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val) <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> ulonglong tmp; <S2SV_EndVul> if (jas_iccgetuint(in, 8, &tmp)) return -1; *val = tmp; return 0; }","- {
- ulonglong tmp;
+ {
+ jas_ulonglong tmp;","static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val) { jas_ulonglong tmp; if (jas_iccgetuint(in, 8, &tmp)) return -1; *val = tmp; return 0; }"
406,7089----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-nfs.c----nfsreq_print_noaddr,"nfsreq_print_noaddr(netdissect_options *ndo, register const u_char *bp, u_int length, register const u_char *bp2) { register const struct sunrpc_msg *rp; register const uint32_t *dp; nfs_type type; int v3; uint32_t proc; uint32_t access_flags; struct nfsv3_sattr sa3; ND_PRINT((ndo, ""%d"", length)); nfserr = 0; rp = (const struct sunrpc_msg *)bp; if (!xid_map_enter(ndo, rp, bp2)) goto trunc; v3 = (EXTRACT_32BITS(&rp->rm_call.cb_vers) == NFS_VER3); proc = EXTRACT_32BITS(&rp->rm_call.cb_proc); if (!v3 && proc < NFS_NPROCS) proc = nfsv3_procid[proc]; ND_PRINT((ndo, "" %s"", tok2str(nfsproc_str, ""proc-%u"", proc))); switch (proc) { case NFSPROC_GETATTR: case NFSPROC_SETATTR: case NFSPROC_READLINK: case NFSPROC_FSSTAT: case NFSPROC_FSINFO: case NFSPROC_PATHCONF: if ((dp = parsereq(ndo, rp, length)) != NULL && parsefh(ndo, dp, v3) != NULL) return; break; case NFSPROC_LOOKUP: case NFSPROC_CREATE: case NFSPROC_MKDIR: case NFSPROC_REMOVE: case NFSPROC_RMDIR: if ((dp = parsereq(ndo, rp, length)) != NULL && parsefhn(ndo, dp, v3) != NULL) return; break; case NFSPROC_ACCESS: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_TCHECK(dp[0]); access_flags = EXTRACT_32BITS(&dp[0]); if (access_flags & ~NFSV3ACCESS_FULL) { ND_PRINT((ndo, "" %04x"", access_flags)); } else if ((access_flags & NFSV3ACCESS_FULL) == NFSV3ACCESS_FULL) { ND_PRINT((ndo, "" NFS_ACCESS_FULL"")); } else { char separator = ' '; if (access_flags & NFSV3ACCESS_READ) { ND_PRINT((ndo, "" NFS_ACCESS_READ"")); separator = '|'; } if (access_flags & NFSV3ACCESS_LOOKUP) { ND_PRINT((ndo, ""%cNFS_ACCESS_LOOKUP"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_MODIFY) { ND_PRINT((ndo, ""%cNFS_ACCESS_MODIFY"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_EXTEND) { ND_PRINT((ndo, ""%cNFS_ACCESS_EXTEND"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_DELETE) { ND_PRINT((ndo, ""%cNFS_ACCESS_DELETE"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_EXECUTE) ND_PRINT((ndo, ""%cNFS_ACCESS_EXECUTE"", separator)); } return; } break; case NFSPROC_READ: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { if (v3) { ND_TCHECK(dp[2]); ND_PRINT((ndo, "" %u bytes @ %"" PRIu64, EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))); } else { ND_TCHECK(dp[1]); ND_PRINT((ndo, "" %u bytes @ %u"", EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))); } return; } break; case NFSPROC_WRITE: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { if (v3) { <S2SV_StartVul> ND_TCHECK(dp[2]); <S2SV_EndVul> ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64, EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))); if (ndo->ndo_vflag) { <S2SV_StartVul> dp += 3; <S2SV_EndVul> <S2SV_StartVul> ND_TCHECK(dp[0]); <S2SV_EndVul> ND_PRINT((ndo, "" <%s>"", tok2str(nfsv3_writemodes, <S2SV_StartVul> NULL, EXTRACT_32BITS(dp)))); <S2SV_EndVul> } } else { ND_TCHECK(dp[3]); ND_PRINT((ndo, "" %u (%u) bytes @ %u (%u)"", EXTRACT_32BITS(&dp[3]), EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))); } return; } break; case NFSPROC_SYMLINK: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefhn(ndo, dp, v3)) != NULL) { ND_PRINT((ndo, "" ->"")); if (v3 && (dp = parse_sattr3(ndo, dp, &sa3)) == NULL) break; if (parsefn(ndo, dp) == NULL) break; if (v3 && ndo->ndo_vflag) print_sattr3(ndo, &sa3, ndo->ndo_vflag); return; } break; case NFSPROC_MKNOD: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefhn(ndo, dp, v3)) != NULL) { ND_TCHECK(*dp); type = (nfs_type)EXTRACT_32BITS(dp); dp++; if ((dp = parse_sattr3(ndo, dp, &sa3)) == NULL) break; ND_PRINT((ndo, "" %s"", tok2str(type2str, ""unk-ft %d"", type))); if (ndo->ndo_vflag && (type == NFCHR || type == NFBLK)) { ND_TCHECK(dp[1]); ND_PRINT((ndo, "" %u/%u"", EXTRACT_32BITS(&dp[0]), EXTRACT_32BITS(&dp[1]))); dp += 2; } if (ndo->ndo_vflag) print_sattr3(ndo, &sa3, ndo->ndo_vflag); return; } break; case NFSPROC_RENAME: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefhn(ndo, dp, v3)) != NULL) { ND_PRINT((ndo, "" ->"")); if (parsefhn(ndo, dp, v3) != NULL) return; } break; case NFSPROC_LINK: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_PRINT((ndo, "" ->"")); if (parsefhn(ndo, dp, v3) != NULL) return; } break; case NFSPROC_READDIR: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { if (v3) { ND_TCHECK(dp[4]); ND_PRINT((ndo, "" %u bytes @ %"" PRId64, EXTRACT_32BITS(&dp[4]), EXTRACT_64BITS(&dp[0]))); if (ndo->ndo_vflag) ND_PRINT((ndo, "" verf %08x%08x"", dp[2], dp[3])); } else { ND_TCHECK(dp[1]); ND_PRINT((ndo, "" %u bytes @ %d"", EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))); } return; } break; case NFSPROC_READDIRPLUS: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_TCHECK(dp[4]); ND_PRINT((ndo, "" %u bytes @ %"" PRId64, EXTRACT_32BITS(&dp[4]), EXTRACT_64BITS(&dp[0]))); if (ndo->ndo_vflag) { ND_TCHECK(dp[5]); ND_PRINT((ndo, "" max %u verf %08x%08x"", EXTRACT_32BITS(&dp[5]), dp[2], dp[3])); } return; } break; case NFSPROC_COMMIT: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_TCHECK(dp[2]); ND_PRINT((ndo, "" %u bytes @ %"" PRIu64, EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))); return; } break; default: return; } trunc: if (!nfserr) ND_PRINT((ndo, ""%s"", tstr)); }","- ND_TCHECK(dp[2]);
- dp += 3;
- ND_TCHECK(dp[0]);
- NULL, EXTRACT_32BITS(dp))));
+ ND_TCHECK(dp[4]);
+ NULL, EXTRACT_32BITS(&dp[3]))));","nfsreq_print_noaddr(netdissect_options *ndo, register const u_char *bp, u_int length, register const u_char *bp2) { register const struct sunrpc_msg *rp; register const uint32_t *dp; nfs_type type; int v3; uint32_t proc; uint32_t access_flags; struct nfsv3_sattr sa3; ND_PRINT((ndo, ""%d"", length)); nfserr = 0; rp = (const struct sunrpc_msg *)bp; if (!xid_map_enter(ndo, rp, bp2)) goto trunc; v3 = (EXTRACT_32BITS(&rp->rm_call.cb_vers) == NFS_VER3); proc = EXTRACT_32BITS(&rp->rm_call.cb_proc); if (!v3 && proc < NFS_NPROCS) proc = nfsv3_procid[proc]; ND_PRINT((ndo, "" %s"", tok2str(nfsproc_str, ""proc-%u"", proc))); switch (proc) { case NFSPROC_GETATTR: case NFSPROC_SETATTR: case NFSPROC_READLINK: case NFSPROC_FSSTAT: case NFSPROC_FSINFO: case NFSPROC_PATHCONF: if ((dp = parsereq(ndo, rp, length)) != NULL && parsefh(ndo, dp, v3) != NULL) return; break; case NFSPROC_LOOKUP: case NFSPROC_CREATE: case NFSPROC_MKDIR: case NFSPROC_REMOVE: case NFSPROC_RMDIR: if ((dp = parsereq(ndo, rp, length)) != NULL && parsefhn(ndo, dp, v3) != NULL) return; break; case NFSPROC_ACCESS: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_TCHECK(dp[0]); access_flags = EXTRACT_32BITS(&dp[0]); if (access_flags & ~NFSV3ACCESS_FULL) { ND_PRINT((ndo, "" %04x"", access_flags)); } else if ((access_flags & NFSV3ACCESS_FULL) == NFSV3ACCESS_FULL) { ND_PRINT((ndo, "" NFS_ACCESS_FULL"")); } else { char separator = ' '; if (access_flags & NFSV3ACCESS_READ) { ND_PRINT((ndo, "" NFS_ACCESS_READ"")); separator = '|'; } if (access_flags & NFSV3ACCESS_LOOKUP) { ND_PRINT((ndo, ""%cNFS_ACCESS_LOOKUP"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_MODIFY) { ND_PRINT((ndo, ""%cNFS_ACCESS_MODIFY"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_EXTEND) { ND_PRINT((ndo, ""%cNFS_ACCESS_EXTEND"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_DELETE) { ND_PRINT((ndo, ""%cNFS_ACCESS_DELETE"", separator)); separator = '|'; } if (access_flags & NFSV3ACCESS_EXECUTE) ND_PRINT((ndo, ""%cNFS_ACCESS_EXECUTE"", separator)); } return; } break; case NFSPROC_READ: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { if (v3) { ND_TCHECK(dp[2]); ND_PRINT((ndo, "" %u bytes @ %"" PRIu64, EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))); } else { ND_TCHECK(dp[1]); ND_PRINT((ndo, "" %u bytes @ %u"", EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))); } return; } break; case NFSPROC_WRITE: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { if (v3) { ND_TCHECK(dp[4]); ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64, EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))); if (ndo->ndo_vflag) { ND_PRINT((ndo, "" <%s>"", tok2str(nfsv3_writemodes, NULL, EXTRACT_32BITS(&dp[3])))); } } else { ND_TCHECK(dp[3]); ND_PRINT((ndo, "" %u (%u) bytes @ %u (%u)"", EXTRACT_32BITS(&dp[3]), EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))); } return; } break; case NFSPROC_SYMLINK: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefhn(ndo, dp, v3)) != NULL) { ND_PRINT((ndo, "" ->"")); if (v3 && (dp = parse_sattr3(ndo, dp, &sa3)) == NULL) break; if (parsefn(ndo, dp) == NULL) break; if (v3 && ndo->ndo_vflag) print_sattr3(ndo, &sa3, ndo->ndo_vflag); return; } break; case NFSPROC_MKNOD: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefhn(ndo, dp, v3)) != NULL) { ND_TCHECK(*dp); type = (nfs_type)EXTRACT_32BITS(dp); dp++; if ((dp = parse_sattr3(ndo, dp, &sa3)) == NULL) break; ND_PRINT((ndo, "" %s"", tok2str(type2str, ""unk-ft %d"", type))); if (ndo->ndo_vflag && (type == NFCHR || type == NFBLK)) { ND_TCHECK(dp[1]); ND_PRINT((ndo, "" %u/%u"", EXTRACT_32BITS(&dp[0]), EXTRACT_32BITS(&dp[1]))); dp += 2; } if (ndo->ndo_vflag) print_sattr3(ndo, &sa3, ndo->ndo_vflag); return; } break; case NFSPROC_RENAME: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefhn(ndo, dp, v3)) != NULL) { ND_PRINT((ndo, "" ->"")); if (parsefhn(ndo, dp, v3) != NULL) return; } break; case NFSPROC_LINK: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_PRINT((ndo, "" ->"")); if (parsefhn(ndo, dp, v3) != NULL) return; } break; case NFSPROC_READDIR: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { if (v3) { ND_TCHECK(dp[4]); ND_PRINT((ndo, "" %u bytes @ %"" PRId64, EXTRACT_32BITS(&dp[4]), EXTRACT_64BITS(&dp[0]))); if (ndo->ndo_vflag) ND_PRINT((ndo, "" verf %08x%08x"", dp[2], dp[3])); } else { ND_TCHECK(dp[1]); ND_PRINT((ndo, "" %u bytes @ %d"", EXTRACT_32BITS(&dp[1]), EXTRACT_32BITS(&dp[0]))); } return; } break; case NFSPROC_READDIRPLUS: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_TCHECK(dp[4]); ND_PRINT((ndo, "" %u bytes @ %"" PRId64, EXTRACT_32BITS(&dp[4]), EXTRACT_64BITS(&dp[0]))); if (ndo->ndo_vflag) { ND_TCHECK(dp[5]); ND_PRINT((ndo, "" max %u verf %08x%08x"", EXTRACT_32BITS(&dp[5]), dp[2], dp[3])); } return; } break; case NFSPROC_COMMIT: if ((dp = parsereq(ndo, rp, length)) != NULL && (dp = parsefh(ndo, dp, v3)) != NULL) { ND_TCHECK(dp[2]); ND_PRINT((ndo, "" %u bytes @ %"" PRIu64, EXTRACT_32BITS(&dp[2]), EXTRACT_64BITS(&dp[0]))); return; } break; default: return; } trunc: if (!nfserr) ND_PRINT((ndo, ""%s"", tstr)); }"
407,2417----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2673--malloc.c----calloc,"void * calloc(size_t n, size_t lb) { <S2SV_StartVul> if (lb && n > SIZE_MAX / lb) <S2SV_EndVul> <S2SV_StartVul> return NULL; <S2SV_EndVul> # if defined(GC_LINUX_THREADS) <S2SV_StartVul> { <S2SV_EndVul> static GC_bool lib_bounds_set = FALSE; ptr_t caller = (ptr_t)__builtin_return_address(0); if (!EXPECT(lib_bounds_set, TRUE)) { GC_init_lib_bounds(); lib_bounds_set = TRUE; } if (((word)caller >= (word)GC_libpthread_start && (word)caller < (word)GC_libpthread_end) || ((word)caller >= (word)GC_libld_start && (word)caller < (word)GC_libld_end)) return GC_malloc_uncollectable(n*lb); } # endif return((void *)REDIRECT_MALLOC(n*lb)); }","- if (lb && n > SIZE_MAX / lb)
- return NULL;
- {
+ void * calloc(size_t n, size_t lb)
+ {
+ if (lb && n > GC_SIZE_MAX / lb)
+ return NULL;
+ static GC_bool lib_bounds_set = FALSE;","void * calloc(size_t n, size_t lb) { if (lb && n > GC_SIZE_MAX / lb) return NULL; # if defined(GC_LINUX_THREADS) { static GC_bool lib_bounds_set = FALSE; ptr_t caller = (ptr_t)__builtin_return_address(0); if (!EXPECT(lib_bounds_set, TRUE)) { GC_init_lib_bounds(); lib_bounds_set = TRUE; } if (((word)caller >= (word)GC_libpthread_start && (word)caller < (word)GC_libpthread_end) || ((word)caller >= (word)GC_libld_start && (word)caller < (word)GC_libld_end)) return GC_malloc_uncollectable(n*lb); } # endif return((void *)REDIRECT_MALLOC(n*lb)); }"
408,4913----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inode.c----dev_config,"dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr) { struct dev_data *dev = fd->private_data; ssize_t value, length = len; unsigned total; u32 tag; char *kbuf; spin_lock_irq(&dev->lock); if (dev->state > STATE_DEV_OPENED) { value = ep0_write(fd, buf, len, ptr); spin_unlock_irq(&dev->lock); return value; } spin_unlock_irq(&dev->lock); if ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) || (len > PAGE_SIZE * 4)) return -EINVAL; if (copy_from_user (&tag, buf, 4)) return -EFAULT; if (tag != 0) return -EINVAL; buf += 4; length -= 4; kbuf = memdup_user(buf, length); if (IS_ERR(kbuf)) return PTR_ERR(kbuf); spin_lock_irq (&dev->lock); value = -EINVAL; if (dev->buf) { kfree(kbuf); <S2SV_StartVul> goto fail; <S2SV_EndVul> } dev->buf = kbuf; dev->config = (void *) kbuf; total = le16_to_cpu(dev->config->wTotalLength); if (!is_valid_config(dev->config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; if (kbuf [1] == USB_DT_CONFIG) { dev->hs_config = (void *) kbuf; total = le16_to_cpu(dev->hs_config->wTotalLength); if (!is_valid_config(dev->hs_config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; } else { dev->hs_config = NULL; } if (length != USB_DT_DEVICE_SIZE) goto fail; dev->dev = (void *)kbuf; if (dev->dev->bLength != USB_DT_DEVICE_SIZE || dev->dev->bDescriptorType != USB_DT_DEVICE || dev->dev->bNumConfigurations != 1) goto fail; dev->dev->bcdUSB = cpu_to_le16 (0x0200); spin_unlock_irq (&dev->lock); if (dev->hs_config) gadgetfs_driver.max_speed = USB_SPEED_HIGH; else gadgetfs_driver.max_speed = USB_SPEED_FULL; value = usb_gadget_probe_driver(&gadgetfs_driver); if (value != 0) { kfree (dev->buf); dev->buf = NULL; } else { value = len; dev->gadget_registered = true; } return value; fail: spin_unlock_irq (&dev->lock); pr_debug (""%s: %s fail %zd, %p\n"", shortname, __func__, value, dev); kfree (dev->buf); dev->buf = NULL; return value; }","- goto fail;
+ spin_unlock_irq(&dev->lock);
+ return value;","dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr) { struct dev_data *dev = fd->private_data; ssize_t value, length = len; unsigned total; u32 tag; char *kbuf; spin_lock_irq(&dev->lock); if (dev->state > STATE_DEV_OPENED) { value = ep0_write(fd, buf, len, ptr); spin_unlock_irq(&dev->lock); return value; } spin_unlock_irq(&dev->lock); if ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) || (len > PAGE_SIZE * 4)) return -EINVAL; if (copy_from_user (&tag, buf, 4)) return -EFAULT; if (tag != 0) return -EINVAL; buf += 4; length -= 4; kbuf = memdup_user(buf, length); if (IS_ERR(kbuf)) return PTR_ERR(kbuf); spin_lock_irq (&dev->lock); value = -EINVAL; if (dev->buf) { spin_unlock_irq(&dev->lock); kfree(kbuf); return value; } dev->buf = kbuf; dev->config = (void *) kbuf; total = le16_to_cpu(dev->config->wTotalLength); if (!is_valid_config(dev->config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; if (kbuf [1] == USB_DT_CONFIG) { dev->hs_config = (void *) kbuf; total = le16_to_cpu(dev->hs_config->wTotalLength); if (!is_valid_config(dev->hs_config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; } else { dev->hs_config = NULL; } if (length != USB_DT_DEVICE_SIZE) goto fail; dev->dev = (void *)kbuf; if (dev->dev->bLength != USB_DT_DEVICE_SIZE || dev->dev->bDescriptorType != USB_DT_DEVICE || dev->dev->bNumConfigurations != 1) goto fail; dev->dev->bcdUSB = cpu_to_le16 (0x0200); spin_unlock_irq (&dev->lock); if (dev->hs_config) gadgetfs_driver.max_speed = USB_SPEED_HIGH; else gadgetfs_driver.max_speed = USB_SPEED_FULL; value = usb_gadget_probe_driver(&gadgetfs_driver); if (value != 0) { kfree (dev->buf); dev->buf = NULL; } else { value = len; dev->gadget_registered = true; } return value; fail: spin_unlock_irq (&dev->lock); pr_debug (""%s: %s fail %zd, %p\n"", shortname, __func__, value, dev); kfree (dev->buf); dev->buf = NULL; return value; }"
409,625----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-5207--namespace.c----do_new_mount,"static int do_new_mount(struct path *path, const char *fstype, int flags, int mnt_flags, const char *name, void *data) { struct file_system_type *type; struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns; struct vfsmount *mnt; int err; if (!fstype) return -EINVAL; type = get_fs_type(fstype); if (!type) return -ENODEV; if (user_ns != &init_user_ns) { if (!(type->fs_flags & FS_USERNS_MOUNT)) { put_filesystem(type); return -EPERM; } if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) { flags |= MS_NODEV; <S2SV_StartVul> mnt_flags |= MNT_NODEV; <S2SV_EndVul> } } mnt = vfs_kern_mount(type, flags, name, data); if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) && !mnt->mnt_sb->s_subtype) mnt = fs_set_subtype(mnt, fstype); put_filesystem(type); if (IS_ERR(mnt)) return PTR_ERR(mnt); err = do_add_mount(real_mount(mnt), path, mnt_flags); if (err) mntput(mnt); return err; }","- mnt_flags |= MNT_NODEV;
+ mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;","static int do_new_mount(struct path *path, const char *fstype, int flags, int mnt_flags, const char *name, void *data) { struct file_system_type *type; struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns; struct vfsmount *mnt; int err; if (!fstype) return -EINVAL; type = get_fs_type(fstype); if (!type) return -ENODEV; if (user_ns != &init_user_ns) { if (!(type->fs_flags & FS_USERNS_MOUNT)) { put_filesystem(type); return -EPERM; } if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) { flags |= MS_NODEV; mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV; } } mnt = vfs_kern_mount(type, flags, name, data); if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) && !mnt->mnt_sb->s_subtype) mnt = fs_set_subtype(mnt, fstype); put_filesystem(type); if (IS_ERR(mnt)) return PTR_ERR(mnt); err = do_add_mount(real_mount(mnt), path, mnt_flags); if (err) mntput(mnt); return err; }"
410,3422----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/html.c----find_entity_for_char,"static inline void find_entity_for_char( unsigned int k, enum entity_charset charset, const entity_stage1_row *table, const unsigned char **entity, size_t *entity_len, unsigned char *old, size_t oldlen, size_t *cursor) { unsigned stage1_idx = ENT_STAGE1_INDEX(k); const entity_stage3_row *c; if (stage1_idx > 0x1D) { *entity = NULL; *entity_len = 0; return; } c = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)]; if (!c->ambiguous) { *entity = (const unsigned char *)c->data.ent.entity; *entity_len = c->data.ent.entity_len; } else { size_t cursor_before = *cursor; int status = SUCCESS; unsigned next_char; if (!(*cursor < oldlen)) goto no_suitable_2nd; <S2SV_StartVul> next_char = get_next_char(charset, old, oldlen, cursor, &status); <S2SV_EndVul> if (status == FAILURE) goto no_suitable_2nd; { const entity_multicodepoint_row *s, *e; s = &c->data.multicodepoint_table[1]; e = s - 1 + c->data.multicodepoint_table[0].leading_entry.size; for ( ; s <= e; s++) { if (s->normal_entry.second_cp == next_char) { *entity = s->normal_entry.entity; *entity_len = s->normal_entry.entity_len; return; } } } no_suitable_2nd: *cursor = cursor_before; *entity = (const unsigned char *) c->data.multicodepoint_table[0].leading_entry.default_entity; *entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len; <S2SV_StartVul> } <S2SV_EndVul> }","- next_char = get_next_char(charset, old, oldlen, cursor, &status);
- }
+ next_char = get_next_char(charset, old, oldlen, cursor, &status);
+ }","static inline void find_entity_for_char( unsigned int k, enum entity_charset charset, const entity_stage1_row *table, const unsigned char **entity, size_t *entity_len, unsigned char *old, size_t oldlen, size_t *cursor) { unsigned stage1_idx = ENT_STAGE1_INDEX(k); const entity_stage3_row *c; if (stage1_idx > 0x1D) { *entity = NULL; *entity_len = 0; return; } c = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)]; if (!c->ambiguous) { *entity = (const unsigned char *)c->data.ent.entity; *entity_len = c->data.ent.entity_len; } else { size_t cursor_before = *cursor; int status = SUCCESS; unsigned next_char; if (!(*cursor < oldlen)) goto no_suitable_2nd; next_char = get_next_char(charset, old, oldlen, cursor, &status); if (status == FAILURE) goto no_suitable_2nd; { const entity_multicodepoint_row *s, *e; s = &c->data.multicodepoint_table[1]; e = s - 1 + c->data.multicodepoint_table[0].leading_entry.size; for ( ; s <= e; s++) { if (s->normal_entry.second_cp == next_char) { *entity = s->normal_entry.entity; *entity_len = s->normal_entry.entity_len; return; } } } no_suitable_2nd: *cursor = cursor_before; *entity = (const unsigned char *) c->data.multicodepoint_table[0].leading_entry.default_entity; *entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len; } }"
411,3183----CWE-79----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/peerlistwidget.cpp----PeerListWidget::updatePeer,"void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer) { QStandardItem *item = m_peerItems.value(ip); int row = item->row(); if (m_resolveCountries) { const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country()); if (!ico.isNull()) { m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole); const QString countryName = Net::GeoIPManager::CountryName(peer.country()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole); m_missingFlags.remove(ip); } } m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole); <S2SV_StartVul> m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client()); <S2SV_EndVul> m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance()); QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex())); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String("";""))); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(""\n"")), Qt::ToolTipRole); }","- m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());
+ m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client()));","void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer) { QStandardItem *item = m_peerItems.value(ip); int row = item->row(); if (m_resolveCountries) { const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country()); if (!ico.isNull()) { m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole); const QString countryName = Net::GeoIPManager::CountryName(peer.country()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole); m_missingFlags.remove(ip); } } m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole); m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), Utils::String::toHtmlEscaped(peer.client())); m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload()); m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance()); QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex())); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String("";""))); m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(""\n"")), Qt::ToolTipRole); }"
412,4632----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inode.c----ext4_init_io_end,"<S2SV_StartVul> static ext4_io_end_t *ext4_init_io_end (struct inode *inode) <S2SV_EndVul> { ext4_io_end_t *io = NULL; <S2SV_StartVul> io = kmalloc(sizeof(*io), GFP_NOFS); <S2SV_EndVul> if (io) { igrab(inode); io->inode = inode; io->flag = 0; io->offset = 0; io->size = 0; <S2SV_StartVul> io->error = 0; <S2SV_EndVul> INIT_WORK(&io->work, ext4_end_io_work); INIT_LIST_HEAD(&io->list); } return io; }","- static ext4_io_end_t *ext4_init_io_end (struct inode *inode)
- io = kmalloc(sizeof(*io), GFP_NOFS);
- io->error = 0;
+ static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)
+ io = kmalloc(sizeof(*io), flags);
+ io->page = NULL;","static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags) { ext4_io_end_t *io = NULL; io = kmalloc(sizeof(*io), flags); if (io) { igrab(inode); io->inode = inode; io->flag = 0; io->offset = 0; io->size = 0; io->page = NULL; INIT_WORK(&io->work, ext4_end_io_work); INIT_LIST_HEAD(&io->list); } return io; }"
413,1450----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-11399--apedec.c----ape_decode_frame,"static int ape_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; APEContext *s = avctx->priv_data; uint8_t *sample8; int16_t *sample16; int32_t *sample24; int i, ch, ret; int blockstodecode; av_assert0(s->samples >= 0); if(!s->samples){ uint32_t nblocks, offset; int buf_size; if (!avpkt->size) { *got_frame_ptr = 0; return 0; } if (avpkt->size < 8) { av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n""); return AVERROR_INVALIDDATA; } buf_size = avpkt->size & ~3; if (buf_size != avpkt->size) { av_log(avctx, AV_LOG_WARNING, ""packet size is not a multiple of 4. "" ""extra bytes at the end will be skipped.\n""); } if (s->fileversion < 3950) buf_size += 2; av_fast_padded_malloc(&s->data, &s->data_size, buf_size); if (!s->data) return AVERROR(ENOMEM); s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf, buf_size >> 2); memset(s->data + (buf_size & ~3), 0, buf_size & 3); s->ptr = s->data; s->data_end = s->data + buf_size; nblocks = bytestream_get_be32(&s->ptr); offset = bytestream_get_be32(&s->ptr); if (s->fileversion >= 3900) { if (offset > 3) { av_log(avctx, AV_LOG_ERROR, ""Incorrect offset passed\n""); s->data = NULL; return AVERROR_INVALIDDATA; } if (s->data_end - s->ptr < offset) { av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n""); return AVERROR_INVALIDDATA; } s->ptr += offset; } else { if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0) return ret; if (s->fileversion > 3800) skip_bits_long(&s->gb, offset * 8); else skip_bits_long(&s->gb, offset); } <S2SV_StartVul> if (!nblocks || nblocks > INT_MAX) { <S2SV_EndVul> av_log(avctx, AV_LOG_ERROR, ""Invalid sample count: %""PRIu32"".\n"", nblocks); return AVERROR_INVALIDDATA; } if (init_frame_decoder(s) < 0) { av_log(avctx, AV_LOG_ERROR, ""Error reading frame header\n""); return AVERROR_INVALIDDATA; } s->samples = nblocks; } if (!s->data) { *got_frame_ptr = 0; return avpkt->size; } blockstodecode = FFMIN(s->blocks_per_loop, s->samples); if (s->fileversion < 3930) blockstodecode = s->samples; av_fast_malloc(&s->decoded_buffer, &s->decoded_size, 2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer)); <S2SV_StartVul> if (!s->decoded_buffer) <S2SV_EndVul> <S2SV_StartVul> return AVERROR(ENOMEM); <S2SV_EndVul> memset(s->decoded_buffer, 0, s->decoded_size); s->decoded[0] = s->decoded_buffer; s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8); frame->nb_samples = blockstodecode; if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) return ret; s->error=0; if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO)) ape_unpack_mono(s, blockstodecode); else ape_unpack_stereo(s, blockstodecode); emms_c(); if (s->error) { s->samples=0; av_log(avctx, AV_LOG_ERROR, ""Error decoding frame\n""); return AVERROR_INVALIDDATA; } switch (s->bps) { case 8: for (ch = 0; ch < s->channels; ch++) { sample8 = (uint8_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff; } break; case 16: for (ch = 0; ch < s->channels; ch++) { sample16 = (int16_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample16++ = s->decoded[ch][i]; } break; case 24: for (ch = 0; ch < s->channels; ch++) { sample24 = (int32_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample24++ = s->decoded[ch][i] << 8; } break; } s->samples -= blockstodecode; *got_frame_ptr = 1; return !s->samples ? avpkt->size : 0; }","- if (!nblocks || nblocks > INT_MAX) {
- if (!s->decoded_buffer)
- return AVERROR(ENOMEM);
+ uint64_t decoded_buffer_size;
+ if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {
+ av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);
+ if (!s->decoded_buffer)
+ return AVERROR(ENOMEM);","static int ape_decode_frame(AVCodecContext *avctx, void *data, int *got_frame_ptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8_t *buf = avpkt->data; APEContext *s = avctx->priv_data; uint8_t *sample8; int16_t *sample16; int32_t *sample24; int i, ch, ret; int blockstodecode; uint64_t decoded_buffer_size; av_assert0(s->samples >= 0); if(!s->samples){ uint32_t nblocks, offset; int buf_size; if (!avpkt->size) { *got_frame_ptr = 0; return 0; } if (avpkt->size < 8) { av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n""); return AVERROR_INVALIDDATA; } buf_size = avpkt->size & ~3; if (buf_size != avpkt->size) { av_log(avctx, AV_LOG_WARNING, ""packet size is not a multiple of 4. "" ""extra bytes at the end will be skipped.\n""); } if (s->fileversion < 3950) buf_size += 2; av_fast_padded_malloc(&s->data, &s->data_size, buf_size); if (!s->data) return AVERROR(ENOMEM); s->bdsp.bswap_buf((uint32_t *) s->data, (const uint32_t *) buf, buf_size >> 2); memset(s->data + (buf_size & ~3), 0, buf_size & 3); s->ptr = s->data; s->data_end = s->data + buf_size; nblocks = bytestream_get_be32(&s->ptr); offset = bytestream_get_be32(&s->ptr); if (s->fileversion >= 3900) { if (offset > 3) { av_log(avctx, AV_LOG_ERROR, ""Incorrect offset passed\n""); s->data = NULL; return AVERROR_INVALIDDATA; } if (s->data_end - s->ptr < offset) { av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n""); return AVERROR_INVALIDDATA; } s->ptr += offset; } else { if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0) return ret; if (s->fileversion > 3800) skip_bits_long(&s->gb, offset * 8); else skip_bits_long(&s->gb, offset); } if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) { av_log(avctx, AV_LOG_ERROR, ""Invalid sample count: %""PRIu32"".\n"", nblocks); return AVERROR_INVALIDDATA; } if (init_frame_decoder(s) < 0) { av_log(avctx, AV_LOG_ERROR, ""Error reading frame header\n""); return AVERROR_INVALIDDATA; } s->samples = nblocks; } if (!s->data) { *got_frame_ptr = 0; return avpkt->size; } blockstodecode = FFMIN(s->blocks_per_loop, s->samples); if (s->fileversion < 3930) blockstodecode = s->samples; decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer); av_assert0(decoded_buffer_size <= INT_MAX); av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size); if (!s->decoded_buffer) return AVERROR(ENOMEM); memset(s->decoded_buffer, 0, s->decoded_size); s->decoded[0] = s->decoded_buffer; s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8); frame->nb_samples = blockstodecode; if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) return ret; s->error=0; if ((s->channels == 1) || (s->frameflags & APE_FRAMECODE_PSEUDO_STEREO)) ape_unpack_mono(s, blockstodecode); else ape_unpack_stereo(s, blockstodecode); emms_c(); if (s->error) { s->samples=0; av_log(avctx, AV_LOG_ERROR, ""Error decoding frame\n""); return AVERROR_INVALIDDATA; } switch (s->bps) { case 8: for (ch = 0; ch < s->channels; ch++) { sample8 = (uint8_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample8++ = (s->decoded[ch][i] + 0x80) & 0xff; } break; case 16: for (ch = 0; ch < s->channels; ch++) { sample16 = (int16_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample16++ = s->decoded[ch][i]; } break; case 24: for (ch = 0; ch < s->channels; ch++) { sample24 = (int32_t *)frame->data[ch]; for (i = 0; i < blockstodecode; i++) *sample24++ = s->decoded[ch][i] << 8; } break; } s->samples -= blockstodecode; *got_frame_ptr = 1; return !s->samples ? avpkt->size : 0; }"
414,4501----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/uas-detect.h----uas_use_uas_driver,"static int uas_use_uas_driver(struct usb_interface *intf, const struct usb_device_id *id, unsigned long *flags_ret) { struct usb_host_endpoint *eps[4] = { }; struct usb_device *udev = interface_to_usbdev(intf); struct usb_hcd *hcd = bus_to_hcd(udev->bus); unsigned long flags = id->driver_info; <S2SV_StartVul> int r, alt; <S2SV_EndVul> alt = uas_find_uas_alt_setting(intf); <S2SV_StartVul> if (alt < 0) <S2SV_EndVul> return 0; <S2SV_StartVul> r = uas_find_endpoints(&intf->altsetting[alt], eps); <S2SV_EndVul> if (r < 0) return 0; if (le16_to_cpu(udev->descriptor.idVendor) == 0x174c && (le16_to_cpu(udev->descriptor.idProduct) == 0x5106 || le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) { if (udev->actconfig->desc.bMaxPower == 0) { } else if (udev->speed < USB_SPEED_SUPER) { flags |= US_FL_IGNORE_UAS; } else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) { flags |= US_FL_IGNORE_UAS; } else { flags |= US_FL_MAX_SECTORS_240; } } usb_stor_adjust_quirks(udev, &flags); if (flags & US_FL_IGNORE_UAS) { dev_warn(&udev->dev, ""UAS is blacklisted for this device, using usb-storage instead\n""); return 0; } if (udev->bus->sg_tablesize == 0) { dev_warn(&udev->dev, ""The driver for the USB controller %s does not support scatter-gather which is\n"", hcd->driver->description); dev_warn(&udev->dev, ""required by the UAS driver. Please try an other USB controller if you wish to use UAS.\n""); return 0; } if (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) { dev_warn(&udev->dev, ""USB controller %s does not support streams, which are required by the UAS driver.\n"", hcd_to_bus(hcd)->bus_name); dev_warn(&udev->dev, ""Please try an other USB controller if you wish to use UAS.\n""); return 0; } if (flags_ret) *flags_ret = flags; return 1; }","- int r, alt;
- if (alt < 0)
- r = uas_find_endpoints(&intf->altsetting[alt], eps);
+ struct usb_host_interface *alt;
+ int r;
+ if (!alt)
+ r = uas_find_endpoints(alt, eps);","static int uas_use_uas_driver(struct usb_interface *intf, const struct usb_device_id *id, unsigned long *flags_ret) { struct usb_host_endpoint *eps[4] = { }; struct usb_device *udev = interface_to_usbdev(intf); struct usb_hcd *hcd = bus_to_hcd(udev->bus); unsigned long flags = id->driver_info; struct usb_host_interface *alt; int r; alt = uas_find_uas_alt_setting(intf); if (!alt) return 0; r = uas_find_endpoints(alt, eps); if (r < 0) return 0; if (le16_to_cpu(udev->descriptor.idVendor) == 0x174c && (le16_to_cpu(udev->descriptor.idProduct) == 0x5106 || le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) { if (udev->actconfig->desc.bMaxPower == 0) { } else if (udev->speed < USB_SPEED_SUPER) { flags |= US_FL_IGNORE_UAS; } else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) { flags |= US_FL_IGNORE_UAS; } else { flags |= US_FL_MAX_SECTORS_240; } } usb_stor_adjust_quirks(udev, &flags); if (flags & US_FL_IGNORE_UAS) { dev_warn(&udev->dev, ""UAS is blacklisted for this device, using usb-storage instead\n""); return 0; } if (udev->bus->sg_tablesize == 0) { dev_warn(&udev->dev, ""The driver for the USB controller %s does not support scatter-gather which is\n"", hcd->driver->description); dev_warn(&udev->dev, ""required by the UAS driver. Please try an other USB controller if you wish to use UAS.\n""); return 0; } if (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) { dev_warn(&udev->dev, ""USB controller %s does not support streams, which are required by the UAS driver.\n"", hcd_to_bus(hcd)->bus_name); dev_warn(&udev->dev, ""Please try an other USB controller if you wish to use UAS.\n""); return 0; } if (flags_ret) *flags_ret = flags; return 1; }"
415,2163----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18203--dm.c----*dm_get_from_kobject,"struct mapped_device *dm_get_from_kobject(struct kobject *kobj) { struct mapped_device *md; md = container_of(kobj, struct mapped_device, kobj_holder.kobj); <S2SV_StartVul> if (test_bit(DMF_FREEING, &md->flags) || <S2SV_EndVul> <S2SV_StartVul> dm_deleting_md(md)) <S2SV_EndVul> <S2SV_StartVul> return NULL; <S2SV_EndVul> dm_get(md); return md; }","- if (test_bit(DMF_FREEING, &md->flags) ||
- dm_deleting_md(md))
- return NULL;
+ spin_lock(&_minor_lock);
+ if (test_bit(DMF_FREEING, &md->flags) || dm_deleting_md(md)) {
+ md = NULL;
+ goto out;
+ }
+ out:
+ spin_unlock(&_minor_lock);","struct mapped_device *dm_get_from_kobject(struct kobject *kobj) { struct mapped_device *md; md = container_of(kobj, struct mapped_device, kobj_holder.kobj); spin_lock(&_minor_lock); if (test_bit(DMF_FREEING, &md->flags) || dm_deleting_md(md)) { md = NULL; goto out; } dm_get(md); out: spin_unlock(&_minor_lock); return md; }"
416,5542----CWE-290----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/request_context.cc----google::api_manager::context::RequestContext::SetApiKeyHeader,"void RequestContext::SetApiKeyHeader() { <S2SV_StartVul> request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_); <S2SV_EndVul> }","- request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);
+ request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false);","void RequestContext::SetApiKeyHeader() { request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false); }"
417,5166----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----pci_msix_table_init,"pci_msix_table_init(struct pci_vdev *dev, int table_entries) { int i, table_size; <S2SV_StartVul> assert(table_entries > 0); <S2SV_EndVul> <S2SV_StartVul> assert(table_entries <= MAX_MSIX_TABLE_ENTRIES); <S2SV_EndVul> table_size = table_entries * MSIX_TABLE_ENTRY_SIZE; dev->msix.table = calloc(1, table_size); <S2SV_StartVul> assert(dev->msix.table != NULL); <S2SV_EndVul> for (i = 0; i < table_entries; i++) dev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK; }","- assert(table_entries > 0);
- assert(table_entries <= MAX_MSIX_TABLE_ENTRIES);
- assert(dev->msix.table != NULL);
+ if (!dev->msix.table) {
+ pr_err(""%s: Cannot alloc memory!\n"", __func__);
+ return -1;
+ }
+ return 0;","pci_msix_table_init(struct pci_vdev *dev, int table_entries) { int i, table_size; table_size = table_entries * MSIX_TABLE_ENTRY_SIZE; dev->msix.table = calloc(1, table_size); if (!dev->msix.table) { pr_err(""%s: Cannot alloc memory!\n"", __func__); return -1; } for (i = 0; i < table_entries; i++) dev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK; return 0; }"
418,5588----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/SDL_ttf.c----Create_Surface_Solid,"static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color) { const int alignment = Get_Alignement() - 1; SDL_Surface *textbuf; Sint64 size; void *pixels, *ptr; <S2SV_StartVul> Sint64 pitch = width + alignment; <S2SV_EndVul> pitch += alignment; pitch &= ~alignment; size = height * pitch + sizeof (void *) + alignment; if (size < 0 || size > SDL_MAX_SINT32) { return NULL; } ptr = SDL_malloc((size_t)size); if (ptr == NULL) { return NULL; } pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment); ((void **)pixels)[-1] = ptr; textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8); if (textbuf == NULL) { SDL_free(ptr); return NULL; } textbuf->flags &= ~SDL_PREALLOC; textbuf->flags |= SDL_SIMD_ALIGNED; SDL_memset(pixels, 0, height * pitch); *color = 1; { SDL_Palette *palette = textbuf->format->palette; palette->colors[0].r = 255 - fg.r; palette->colors[0].g = 255 - fg.g; palette->colors[0].b = 255 - fg.b; palette->colors[1].r = fg.r; palette->colors[1].g = fg.g; palette->colors[1].b = fg.b; palette->colors[1].a = fg.a; } SDL_SetColorKey(textbuf, SDL_TRUE, 0); return textbuf;","- Sint64 pitch = width + alignment;
+ Sint64 pitch = (Sint64)width + (Sint64)alignment;","static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color) { const int alignment = Get_Alignement() - 1; SDL_Surface *textbuf; Sint64 size; void *pixels, *ptr; Sint64 pitch = (Sint64)width + (Sint64)alignment; pitch += alignment; pitch &= ~alignment; size = height * pitch + sizeof (void *) + alignment; if (size < 0 || size > SDL_MAX_SINT32) { return NULL; } ptr = SDL_malloc((size_t)size); if (ptr == NULL) { return NULL; } pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment); ((void **)pixels)[-1] = ptr; textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8); if (textbuf == NULL) { SDL_free(ptr); return NULL; } textbuf->flags &= ~SDL_PREALLOC; textbuf->flags |= SDL_SIMD_ALIGNED; SDL_memset(pixels, 0, height * pitch); *color = 1; { SDL_Palette *palette = textbuf->format->palette; palette->colors[0].r = 255 - fg.r; palette->colors[0].g = 255 - fg.g; palette->colors[0].b = 255 - fg.b; palette->colors[1].r = fg.r; palette->colors[1].g = fg.g; palette->colors[1].b = fg.b; palette->colors[1].a = fg.a; } SDL_SetColorKey(textbuf, SDL_TRUE, 0); return textbuf;"
419,5314----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/adis_buffer.c----adis_update_scan_mode,"int adis_update_scan_mode(struct iio_dev *indio_dev, const unsigned long *scan_mask) { struct adis *adis = iio_device_get_drvdata(indio_dev); const struct iio_chan_spec *chan; unsigned int scan_count; unsigned int i, j; __be16 *tx, *rx; kfree(adis->xfer); kfree(adis->buffer); if (adis->burst && adis->burst->en) return adis_update_scan_mode_burst(indio_dev, scan_mask); scan_count = indio_dev->scan_bytes / 2; adis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL); if (!adis->xfer) return -ENOMEM; adis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL); <S2SV_StartVul> if (!adis->buffer) <S2SV_EndVul> return -ENOMEM; rx = adis->buffer; tx = rx + scan_count; spi_message_init(&adis->msg); for (j = 0; j <= scan_count; j++) { adis->xfer[j].bits_per_word = 8; if (j != scan_count) adis->xfer[j].cs_change = 1; adis->xfer[j].len = 2; adis->xfer[j].delay_usecs = adis->data->read_delay; if (j < scan_count) adis->xfer[j].tx_buf = &tx[j]; if (j >= 1) adis->xfer[j].rx_buf = &rx[j - 1]; spi_message_add_tail(&adis->xfer[j], &adis->msg); } chan = indio_dev->channels; for (i = 0; i < indio_dev->num_channels; i++, chan++) { if (!test_bit(chan->scan_index, scan_mask)) continue; if (chan->scan_type.storagebits == 32) *tx++ = cpu_to_be16((chan->address + 2) << 8); *tx++ = cpu_to_be16(chan->address << 8); } return 0; }","- if (!adis->buffer)
+ if (!adis->buffer) {
+ kfree(adis->xfer);
+ adis->xfer = NULL;
+ }","int adis_update_scan_mode(struct iio_dev *indio_dev, const unsigned long *scan_mask) { struct adis *adis = iio_device_get_drvdata(indio_dev); const struct iio_chan_spec *chan; unsigned int scan_count; unsigned int i, j; __be16 *tx, *rx; kfree(adis->xfer); kfree(adis->buffer); if (adis->burst && adis->burst->en) return adis_update_scan_mode_burst(indio_dev, scan_mask); scan_count = indio_dev->scan_bytes / 2; adis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL); if (!adis->xfer) return -ENOMEM; adis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL); if (!adis->buffer) { kfree(adis->xfer); adis->xfer = NULL; return -ENOMEM; } rx = adis->buffer; tx = rx + scan_count; spi_message_init(&adis->msg); for (j = 0; j <= scan_count; j++) { adis->xfer[j].bits_per_word = 8; if (j != scan_count) adis->xfer[j].cs_change = 1; adis->xfer[j].len = 2; adis->xfer[j].delay_usecs = adis->data->read_delay; if (j < scan_count) adis->xfer[j].tx_buf = &tx[j]; if (j >= 1) adis->xfer[j].rx_buf = &rx[j - 1]; spi_message_add_tail(&adis->xfer[j], &adis->msg); } chan = indio_dev->channels; for (i = 0; i < indio_dev->num_channels; i++, chan++) { if (!test_bit(chan->scan_index, scan_mask)) continue; if (chan->scan_type.storagebits == 32) *tx++ = cpu_to_be16((chan->address + 2) << 8); *tx++ = cpu_to_be16(chan->address << 8); } return 0; }"
420,6825----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cl_main.cpp----CL_InitRef,"void CL_InitRef( void ) { refexport_t *ret; static refimport_t rit; char dllName[MAX_OSPATH]; GetRefAPI_t GetRefAPI; Com_Printf( ""----- Initializing Renderer ----\n"" ); <S2SV_StartVul> cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH ); <S2SV_EndVul> Com_sprintf( dllName, sizeof( dllName ), ""%s_"" ARCH_STRING DLL_EXT, cl_renderer->string ); if( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) ) { Com_Printf( ""failed: trying to load fallback renderer\n"" ); Cvar_ForceReset( ""cl_renderer"" ); Com_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY ""_"" ARCH_STRING DLL_EXT ); rendererLib = Sys_LoadDll( dllName, qfalse ); } if ( !rendererLib ) { Com_Error( ERR_FATAL, ""Failed to load renderer\n"" ); } memset( &rit, 0, sizeof( rit ) ); GetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, ""GetRefAPI"" ); if ( !GetRefAPI ) Com_Error( ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"", Sys_LibraryError() ); #define RIT(y) rit.y = y RIT(CIN_PlayCinematic); RIT(CIN_RunCinematic); RIT(CIN_UploadCinematic); RIT(CL_IsRunningInGameCinematic); RIT(Cmd_AddCommand); RIT(Cmd_Argc); RIT(Cmd_ArgsBuffer); RIT(Cmd_Argv); RIT(Cmd_ExecuteString); RIT(Cmd_RemoveCommand); RIT(CM_ClusterPVS); RIT(CM_CullWorldBox); RIT(CM_DeleteCachedMap); RIT(CM_DrawDebugSurface); RIT(CM_PointContents); RIT(Cvar_Get); RIT(Cvar_Set); RIT(Cvar_SetValue); RIT(Cvar_CheckRange); RIT(Cvar_VariableIntegerValue); RIT(Cvar_VariableString); RIT(Cvar_VariableStringBuffer); RIT(Cvar_VariableValue); RIT(FS_FCloseFile); RIT(FS_FileIsInPAK); RIT(FS_FOpenFileByMode); RIT(FS_FOpenFileRead); RIT(FS_FOpenFileWrite); RIT(FS_FreeFile); RIT(FS_FreeFileList); RIT(FS_ListFiles); RIT(FS_Read); RIT(FS_ReadFile); RIT(FS_Write); RIT(FS_WriteFile); RIT(Hunk_ClearToMark); RIT(SND_RegisterAudio_LevelLoadEnd); RIT(SV_Trace); RIT(S_RestartMusic); RIT(Z_Free); rit.Malloc=CL_Malloc; RIT(Z_MemSize); RIT(Z_MorphMallocTag); RIT(Hunk_ClearToMark); rit.WIN_Init = WIN_Init; rit.WIN_SetGamma = WIN_SetGamma; rit.WIN_Shutdown = WIN_Shutdown; rit.WIN_Present = WIN_Present; rit.GL_GetProcAddress = WIN_GL_GetProcAddress; rit.GL_ExtensionSupported = WIN_GL_ExtensionSupported; rit.PD_Load = PD_Load; rit.PD_Store = PD_Store; rit.Error = Com_Error; rit.FS_FileExists = S_FileExists; rit.GetG2VertSpaceServer = GetG2VertSpaceServer; rit.LowPhysicalMemory = Sys_LowPhysicalMemory; rit.Milliseconds = Sys_Milliseconds2; rit.Printf = CL_RefPrintf; rit.SE_GetString = String_GetStringValue; rit.SV_Trace = SV_Trace; rit.gpvCachedMapDiskImage = get_gpvCachedMapDiskImage; rit.gsCachedMapDiskImage = get_gsCachedMapDiskImage; rit.gbUsingCachedMapDataRightNow = get_gbUsingCachedMapDataRightNow; rit.gbAlreadyDoingLoad = get_gbAlreadyDoingLoad; rit.com_frameTime = get_com_frameTime; rit.SV_PointContents = SV_PointContents; rit.saved_game = &ojk::SavedGame::get_instance(); ret = GetRefAPI( REF_API_VERSION, &rit ); if ( !ret ) { Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" ); } re = *ret; Com_Printf( ""-------------------------------\n""); Cvar_Set( ""cl_paused"", ""0"" ); }","- cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH );
+ cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED );","void CL_InitRef( void ) { refexport_t *ret; static refimport_t rit; char dllName[MAX_OSPATH]; GetRefAPI_t GetRefAPI; Com_Printf( ""----- Initializing Renderer ----\n"" ); cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED ); Com_sprintf( dllName, sizeof( dllName ), ""%s_"" ARCH_STRING DLL_EXT, cl_renderer->string ); if( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) ) { Com_Printf( ""failed: trying to load fallback renderer\n"" ); Cvar_ForceReset( ""cl_renderer"" ); Com_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY ""_"" ARCH_STRING DLL_EXT ); rendererLib = Sys_LoadDll( dllName, qfalse ); } if ( !rendererLib ) { Com_Error( ERR_FATAL, ""Failed to load renderer\n"" ); } memset( &rit, 0, sizeof( rit ) ); GetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, ""GetRefAPI"" ); if ( !GetRefAPI ) Com_Error( ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"", Sys_LibraryError() ); #define RIT(y) rit.y = y RIT(CIN_PlayCinematic); RIT(CIN_RunCinematic); RIT(CIN_UploadCinematic); RIT(CL_IsRunningInGameCinematic); RIT(Cmd_AddCommand); RIT(Cmd_Argc); RIT(Cmd_ArgsBuffer); RIT(Cmd_Argv); RIT(Cmd_ExecuteString); RIT(Cmd_RemoveCommand); RIT(CM_ClusterPVS); RIT(CM_CullWorldBox); RIT(CM_DeleteCachedMap); RIT(CM_DrawDebugSurface); RIT(CM_PointContents); RIT(Cvar_Get); RIT(Cvar_Set); RIT(Cvar_SetValue); RIT(Cvar_CheckRange); RIT(Cvar_VariableIntegerValue); RIT(Cvar_VariableString); RIT(Cvar_VariableStringBuffer); RIT(Cvar_VariableValue); RIT(FS_FCloseFile); RIT(FS_FileIsInPAK); RIT(FS_FOpenFileByMode); RIT(FS_FOpenFileRead); RIT(FS_FOpenFileWrite); RIT(FS_FreeFile); RIT(FS_FreeFileList); RIT(FS_ListFiles); RIT(FS_Read); RIT(FS_ReadFile); RIT(FS_Write); RIT(FS_WriteFile); RIT(Hunk_ClearToMark); RIT(SND_RegisterAudio_LevelLoadEnd); RIT(SV_Trace); RIT(S_RestartMusic); RIT(Z_Free); rit.Malloc=CL_Malloc; RIT(Z_MemSize); RIT(Z_MorphMallocTag); RIT(Hunk_ClearToMark); rit.WIN_Init = WIN_Init; rit.WIN_SetGamma = WIN_SetGamma; rit.WIN_Shutdown = WIN_Shutdown; rit.WIN_Present = WIN_Present; rit.GL_GetProcAddress = WIN_GL_GetProcAddress; rit.GL_ExtensionSupported = WIN_GL_ExtensionSupported; rit.PD_Load = PD_Load; rit.PD_Store = PD_Store; rit.Error = Com_Error; rit.FS_FileExists = S_FileExists; rit.GetG2VertSpaceServer = GetG2VertSpaceServer; rit.LowPhysicalMemory = Sys_LowPhysicalMemory; rit.Milliseconds = Sys_Milliseconds2; rit.Printf = CL_RefPrintf; rit.SE_GetString = String_GetStringValue; rit.SV_Trace = SV_Trace; rit.gpvCachedMapDiskImage = get_gpvCachedMapDiskImage; rit.gsCachedMapDiskImage = get_gsCachedMapDiskImage; rit.gbUsingCachedMapDataRightNow = get_gbUsingCachedMapDataRightNow; rit.gbAlreadyDoingLoad = get_gbAlreadyDoingLoad; rit.com_frameTime = get_com_frameTime; rit.SV_PointContents = SV_PointContents; rit.saved_game = &ojk::SavedGame::get_instance(); ret = GetRefAPI( REF_API_VERSION, &rit ); if ( !ret ) { Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" ); } re = *ret; Com_Printf( ""-------------------------------\n""); Cvar_Set( ""cl_paused"", ""0"" ); }"
421,634--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-4653--control.c----snd_ctl_replace,"int snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol, bool add_on_replace) { struct snd_ctl_elem_id id; unsigned int idx; struct snd_kcontrol *old; int ret; if (!kcontrol) return -EINVAL; if (snd_BUG_ON(!card || !kcontrol->info)) { ret = -EINVAL; goto error; } id = kcontrol->id; down_write(&card->controls_rwsem); old = snd_ctl_find_id(card, &id); if (!old) { if (add_on_replace) goto add; up_write(&card->controls_rwsem); ret = -EINVAL; goto error; } ret = snd_ctl_remove(card, old); if (ret < 0) { up_write(&card->controls_rwsem); goto error; } add: if (snd_ctl_find_hole(card, kcontrol->count) < 0) { up_write(&card->controls_rwsem); ret = -ENOMEM; goto error; } list_add_tail(&kcontrol->list, &card->controls); card->controls_count += kcontrol->count; kcontrol->id.numid = card->last_numid + 1; card->last_numid += kcontrol->count; up_write(&card->controls_rwsem); <S2SV_StartVul> for (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++) <S2SV_EndVul> snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id); return 0; error: snd_ctl_free_one(kcontrol); return ret; }","- for (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)
+ unsigned int count;
+ count = kcontrol->count;
+ for (idx = 0; idx < count; idx++, id.index++, id.numid++)","int snd_ctl_replace(struct snd_card *card, struct snd_kcontrol *kcontrol, bool add_on_replace) { struct snd_ctl_elem_id id; unsigned int count; unsigned int idx; struct snd_kcontrol *old; int ret; if (!kcontrol) return -EINVAL; if (snd_BUG_ON(!card || !kcontrol->info)) { ret = -EINVAL; goto error; } id = kcontrol->id; down_write(&card->controls_rwsem); old = snd_ctl_find_id(card, &id); if (!old) { if (add_on_replace) goto add; up_write(&card->controls_rwsem); ret = -EINVAL; goto error; } ret = snd_ctl_remove(card, old); if (ret < 0) { up_write(&card->controls_rwsem); goto error; } add: if (snd_ctl_find_hole(card, kcontrol->count) < 0) { up_write(&card->controls_rwsem); ret = -ENOMEM; goto error; } list_add_tail(&kcontrol->list, &card->controls); card->controls_count += kcontrol->count; kcontrol->id.numid = card->last_numid + 1; card->last_numid += kcontrol->count; count = kcontrol->count; up_write(&card->controls_rwsem); for (idx = 0; idx < count; idx++, id.index++, id.numid++) snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id); return 0; error: snd_ctl_free_one(kcontrol); return ret; }"
422,573----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-3364--ntf.c----*nci_extract_rf_params_nfca_passive_poll,"static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev, struct rf_tech_specific_params_nfca_poll *nfca_poll, __u8 *data) { nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data)); data += 2; <S2SV_StartVul> nfca_poll->nfcid1_len = *data++; <S2SV_EndVul> pr_debug(""sens_res 0x%x, nfcid1_len %d\n"", nfca_poll->sens_res, nfca_poll->nfcid1_len); memcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len); data += nfca_poll->nfcid1_len; nfca_poll->sel_res_len = *data++; if (nfca_poll->sel_res_len != 0) nfca_poll->sel_res = *data++; pr_debug(""sel_res_len %d, sel_res 0x%x\n"", nfca_poll->sel_res_len, nfca_poll->sel_res); return data; }","- nfca_poll->nfcid1_len = *data++;
+ nfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);","static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev, struct rf_tech_specific_params_nfca_poll *nfca_poll, __u8 *data) { nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data)); data += 2; nfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE); pr_debug(""sens_res 0x%x, nfcid1_len %d\n"", nfca_poll->sens_res, nfca_poll->nfcid1_len); memcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len); data += nfca_poll->nfcid1_len; nfca_poll->sel_res_len = *data++; if (nfca_poll->sel_res_len != 0) nfca_poll->sel_res = *data++; pr_debug(""sel_res_len %d, sel_res 0x%x\n"", nfca_poll->sel_res_len, nfca_poll->sel_res); return data; }"
423,2400----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18509--ip6mr.c----ip6_mroute_setsockopt,"int ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, unsigned int optlen) { int ret, parent = 0; struct mif6ctl vif; struct mf6cctl mfc; mifi_t mifi; struct net *net = sock_net(sk); struct mr6_table *mrt; mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT); if (!mrt) return -ENOENT; if (optname != MRT6_INIT) { if (sk != mrt->mroute6_sk && !ns_capable(net->user_ns, CAP_NET_ADMIN)) return -EACCES; } switch (optname) { case MRT6_INIT: <S2SV_StartVul> if (sk->sk_type != SOCK_RAW || <S2SV_EndVul> <S2SV_StartVul> inet_sk(sk)->inet_num != IPPROTO_ICMPV6) <S2SV_EndVul> <S2SV_StartVul> return -EOPNOTSUPP; <S2SV_EndVul> if (optlen < sizeof(int)) return -EINVAL; return ip6mr_sk_init(mrt, sk); case MRT6_DONE: return ip6mr_sk_done(sk); case MRT6_ADD_MIF: if (optlen < sizeof(vif)) return -EINVAL; if (copy_from_user(&vif, optval, sizeof(vif))) return -EFAULT; if (vif.mif6c_mifi >= MAXMIFS) return -ENFILE; rtnl_lock(); ret = mif6_add(net, mrt, &vif, sk == mrt->mroute6_sk); rtnl_unlock(); return ret; case MRT6_DEL_MIF: if (optlen < sizeof(mifi_t)) return -EINVAL; if (copy_from_user(&mifi, optval, sizeof(mifi_t))) return -EFAULT; rtnl_lock(); ret = mif6_delete(mrt, mifi, NULL); rtnl_unlock(); return ret; case MRT6_ADD_MFC: case MRT6_DEL_MFC: parent = -1; case MRT6_ADD_MFC_PROXY: case MRT6_DEL_MFC_PROXY: if (optlen < sizeof(mfc)) return -EINVAL; if (copy_from_user(&mfc, optval, sizeof(mfc))) return -EFAULT; if (parent == 0) parent = mfc.mf6cc_parent; rtnl_lock(); if (optname == MRT6_DEL_MFC || optname == MRT6_DEL_MFC_PROXY) ret = ip6mr_mfc_delete(mrt, &mfc, parent); else ret = ip6mr_mfc_add(net, mrt, &mfc, sk == mrt->mroute6_sk, parent); rtnl_unlock(); return ret; case MRT6_ASSERT: { int v; if (optlen != sizeof(v)) return -EINVAL; if (get_user(v, (int __user *)optval)) return -EFAULT; mrt->mroute_do_assert = v; return 0; } #ifdef CONFIG_IPV6_PIMSM_V2 case MRT6_PIM: { int v; if (optlen != sizeof(v)) return -EINVAL; if (get_user(v, (int __user *)optval)) return -EFAULT; v = !!v; rtnl_lock(); ret = 0; if (v != mrt->mroute_do_pim) { mrt->mroute_do_pim = v; mrt->mroute_do_assert = v; } rtnl_unlock(); return ret; } #endif #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES case MRT6_TABLE: { u32 v; if (optlen != sizeof(u32)) return -EINVAL; if (get_user(v, (u32 __user *)optval)) return -EFAULT; if (v != RT_TABLE_DEFAULT && v >= 100000000) return -EINVAL; if (sk == mrt->mroute6_sk) return -EBUSY; rtnl_lock(); ret = 0; if (!ip6mr_new_table(net, v)) ret = -ENOMEM; raw6_sk(sk)->ip6mr_table = v; rtnl_unlock(); return ret; } #endif default: return -ENOPROTOOPT; } }","- if (sk->sk_type != SOCK_RAW ||
- inet_sk(sk)->inet_num != IPPROTO_ICMPV6)
- return -EOPNOTSUPP;
+ if (sk->sk_type != SOCK_RAW ||
+ inet_sk(sk)->inet_num != IPPROTO_ICMPV6)
+ return -EOPNOTSUPP;","int ip6_mroute_setsockopt(struct sock *sk, int optname, char __user *optval, unsigned int optlen) { int ret, parent = 0; struct mif6ctl vif; struct mf6cctl mfc; mifi_t mifi; struct net *net = sock_net(sk); struct mr6_table *mrt; if (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num != IPPROTO_ICMPV6) return -EOPNOTSUPP; mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT); if (!mrt) return -ENOENT; if (optname != MRT6_INIT) { if (sk != mrt->mroute6_sk && !ns_capable(net->user_ns, CAP_NET_ADMIN)) return -EACCES; } switch (optname) { case MRT6_INIT: if (optlen < sizeof(int)) return -EINVAL; return ip6mr_sk_init(mrt, sk); case MRT6_DONE: return ip6mr_sk_done(sk); case MRT6_ADD_MIF: if (optlen < sizeof(vif)) return -EINVAL; if (copy_from_user(&vif, optval, sizeof(vif))) return -EFAULT; if (vif.mif6c_mifi >= MAXMIFS) return -ENFILE; rtnl_lock(); ret = mif6_add(net, mrt, &vif, sk == mrt->mroute6_sk); rtnl_unlock(); return ret; case MRT6_DEL_MIF: if (optlen < sizeof(mifi_t)) return -EINVAL; if (copy_from_user(&mifi, optval, sizeof(mifi_t))) return -EFAULT; rtnl_lock(); ret = mif6_delete(mrt, mifi, NULL); rtnl_unlock(); return ret; case MRT6_ADD_MFC: case MRT6_DEL_MFC: parent = -1; case MRT6_ADD_MFC_PROXY: case MRT6_DEL_MFC_PROXY: if (optlen < sizeof(mfc)) return -EINVAL; if (copy_from_user(&mfc, optval, sizeof(mfc))) return -EFAULT; if (parent == 0) parent = mfc.mf6cc_parent; rtnl_lock(); if (optname == MRT6_DEL_MFC || optname == MRT6_DEL_MFC_PROXY) ret = ip6mr_mfc_delete(mrt, &mfc, parent); else ret = ip6mr_mfc_add(net, mrt, &mfc, sk == mrt->mroute6_sk, parent); rtnl_unlock(); return ret; case MRT6_ASSERT: { int v; if (optlen != sizeof(v)) return -EINVAL; if (get_user(v, (int __user *)optval)) return -EFAULT; mrt->mroute_do_assert = v; return 0; } #ifdef CONFIG_IPV6_PIMSM_V2 case MRT6_PIM: { int v; if (optlen != sizeof(v)) return -EINVAL; if (get_user(v, (int __user *)optval)) return -EFAULT; v = !!v; rtnl_lock(); ret = 0; if (v != mrt->mroute_do_pim) { mrt->mroute_do_pim = v; mrt->mroute_do_assert = v; } rtnl_unlock(); return ret; } #endif #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES case MRT6_TABLE: { u32 v; if (optlen != sizeof(u32)) return -EINVAL; if (get_user(v, (u32 __user *)optval)) return -EFAULT; if (v != RT_TABLE_DEFAULT && v >= 100000000) return -EINVAL; if (sk == mrt->mroute6_sk) return -EBUSY; rtnl_lock(); ret = 0; if (!ip6mr_new_table(net, v)) ret = -ENOMEM; raw6_sk(sk)->ip6mr_table = v; rtnl_unlock(); return ret; } #endif default: return -ENOPROTOOPT; } }"
424,6316----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pci_core.h----pci_set_cfgdata8,"pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val) { <S2SV_StartVul> assert(offset <= PCI_REGMAX); <S2SV_EndVul> *(uint8_t *)(dev->cfgdata + offset) = val; }","- assert(offset <= PCI_REGMAX);
+ if (offset > PCI_REGMAX) {
+ pr_err(""%s: out of range of PCI config space!\n"", __func__);
+ return;
+ }","pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val) { if (offset > PCI_REGMAX) { pr_err(""%s: out of range of PCI config space!\n"", __func__); return; } *(uint8_t *)(dev->cfgdata + offset) = val; }"
425,3651----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/drawscreen.c----win_redr_status,"win_redr_status(win_T *wp, int ignore_pum UNUSED) { int row; char_u *p; int len; int fillchar; int attr; int this_ru_col; static int busy = FALSE; if (busy) return; busy = TRUE; row = statusline_row(wp); wp->w_redr_status = FALSE; if (wp->w_status_height == 0) { redraw_cmdline = TRUE; } else if (!redrawing() || (!ignore_pum && pum_visible())) { wp->w_redr_status = TRUE; } #ifdef FEAT_STL_OPT else if (*p_stl != NUL || *wp->w_p_stl != NUL) { redraw_custom_statusline(wp); } #endif else { fillchar = fillchar_status(&attr, wp); get_trans_bufname(wp->w_buffer); p = NameBuff; len = (int)STRLEN(p); <S2SV_StartVul> if (bt_help(wp->w_buffer) <S2SV_EndVul> #ifdef FEAT_QUICKFIX <S2SV_StartVul> || wp->w_p_pvw <S2SV_EndVul> #endif <S2SV_StartVul> || bufIsChanged(wp->w_buffer) <S2SV_EndVul> <S2SV_StartVul> || wp->w_buffer->b_p_ro) <S2SV_EndVul> *(p + len++) = ' '; if (bt_help(wp->w_buffer)) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]"")); len += (int)STRLEN(p + len); } #ifdef FEAT_QUICKFIX if (wp->w_p_pvw) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]"")); len += (int)STRLEN(p + len); } #endif if (bufIsChanged(wp->w_buffer) #ifdef FEAT_TERMINAL && !bt_terminal(wp->w_buffer) #endif ) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]""); len += (int)STRLEN(p + len); } if (wp->w_buffer->b_p_ro) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]"")); len += (int)STRLEN(p + len); } this_ru_col = ru_col - (Columns - wp->w_width); if (this_ru_col < (wp->w_width + 1) / 2) this_ru_col = (wp->w_width + 1) / 2; if (this_ru_col <= 1) { p = (char_u *)""<""; len = 1; } else if (has_mbyte) { int clen = 0, i; clen = mb_string2cells(p, -1); for (i = 0; p[i] != NUL && clen >= this_ru_col - 1; i += (*mb_ptr2len)(p + i)) clen -= (*mb_ptr2cells)(p + i); len = clen; if (i > 0) { p = p + i - 1; *p = '<'; ++len; } } else if (len > this_ru_col - 1) { p += len - (this_ru_col - 1); *p = '<'; len = this_ru_col - 1; } screen_puts(p, row, wp->w_wincol, attr); screen_fill(row, row + 1, len + wp->w_wincol, this_ru_col + wp->w_wincol, fillchar, fillchar, attr); if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL) && (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1)) screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff) - 1 + wp->w_wincol), attr); #ifdef FEAT_CMDL_INFO win_redr_ruler(wp, TRUE, ignore_pum); #endif } if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing()) { if (stl_connected(wp)) fillchar = fillchar_status(&attr, wp); else fillchar = fillchar_vsep(&attr); screen_putchar(fillchar, row, W_ENDCOL(wp), attr); } busy = FALSE; }","- if (bt_help(wp->w_buffer)
- || wp->w_p_pvw
- || bufIsChanged(wp->w_buffer)
- || wp->w_buffer->b_p_ro)
+ if ((bt_help(wp->w_buffer)
+ || wp->w_p_pvw
+ || bufIsChanged(wp->w_buffer)
+ || wp->w_buffer->b_p_ro)
+ && len < MAXPATHL - 1)","win_redr_status(win_T *wp, int ignore_pum UNUSED) { int row; char_u *p; int len; int fillchar; int attr; int this_ru_col; static int busy = FALSE; if (busy) return; busy = TRUE; row = statusline_row(wp); wp->w_redr_status = FALSE; if (wp->w_status_height == 0) { redraw_cmdline = TRUE; } else if (!redrawing() || (!ignore_pum && pum_visible())) { wp->w_redr_status = TRUE; } #ifdef FEAT_STL_OPT else if (*p_stl != NUL || *wp->w_p_stl != NUL) { redraw_custom_statusline(wp); } #endif else { fillchar = fillchar_status(&attr, wp); get_trans_bufname(wp->w_buffer); p = NameBuff; len = (int)STRLEN(p); if ((bt_help(wp->w_buffer) #ifdef FEAT_QUICKFIX || wp->w_p_pvw #endif || bufIsChanged(wp->w_buffer) || wp->w_buffer->b_p_ro) && len < MAXPATHL - 1) *(p + len++) = ' '; if (bt_help(wp->w_buffer)) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Help]"")); len += (int)STRLEN(p + len); } #ifdef FEAT_QUICKFIX if (wp->w_p_pvw) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[Preview]"")); len += (int)STRLEN(p + len); } #endif if (bufIsChanged(wp->w_buffer) #ifdef FEAT_TERMINAL && !bt_terminal(wp->w_buffer) #endif ) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", ""[+]""); len += (int)STRLEN(p + len); } if (wp->w_buffer->b_p_ro) { vim_snprintf((char *)p + len, MAXPATHL - len, ""%s"", _(""[RO]"")); len += (int)STRLEN(p + len); } this_ru_col = ru_col - (Columns - wp->w_width); if (this_ru_col < (wp->w_width + 1) / 2) this_ru_col = (wp->w_width + 1) / 2; if (this_ru_col <= 1) { p = (char_u *)""<""; len = 1; } else if (has_mbyte) { int clen = 0, i; clen = mb_string2cells(p, -1); for (i = 0; p[i] != NUL && clen >= this_ru_col - 1; i += (*mb_ptr2len)(p + i)) clen -= (*mb_ptr2cells)(p + i); len = clen; if (i > 0) { p = p + i - 1; *p = '<'; ++len; } } else if (len > this_ru_col - 1) { p += len - (this_ru_col - 1); *p = '<'; len = this_ru_col - 1; } screen_puts(p, row, wp->w_wincol, attr); screen_fill(row, row + 1, len + wp->w_wincol, this_ru_col + wp->w_wincol, fillchar, fillchar, attr); if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL) && (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1)) screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff) - 1 + wp->w_wincol), attr); #ifdef FEAT_CMDL_INFO win_redr_ruler(wp, TRUE, ignore_pum); #endif } if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing()) { if (stl_connected(wp)) fillchar = fillchar_status(&attr, wp); else fillchar = fillchar_vsep(&attr); screen_putchar(fillchar, row, W_ENDCOL(wp), attr); } busy = FALSE; }"
426,2762----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----perf_swevent_overflow,"static void perf_swevent_overflow(struct perf_event *event, u64 overflow, <S2SV_StartVul> int nmi, struct perf_sample_data *data, <S2SV_EndVul> struct pt_regs *regs) { struct hw_perf_event *hwc = &event->hw; int throttle = 0; data->period = event->hw.last_period; if (!overflow) overflow = perf_swevent_set_period(event); if (hwc->interrupts == MAX_INTERRUPTS) return; for (; overflow; overflow--) { <S2SV_StartVul> if (__perf_event_overflow(event, nmi, throttle, <S2SV_EndVul> data, regs)) { break; } throttle = 1; } }","- int nmi, struct perf_sample_data *data,
- if (__perf_event_overflow(event, nmi, throttle,
+ struct perf_sample_data *data,
+ if (__perf_event_overflow(event, throttle,","static void perf_swevent_overflow(struct perf_event *event, u64 overflow, struct perf_sample_data *data, struct pt_regs *regs) { struct hw_perf_event *hwc = &event->hw; int throttle = 0; data->period = event->hw.last_period; if (!overflow) overflow = perf_swevent_set_period(event); if (hwc->interrupts == MAX_INTERRUPTS) return; for (; overflow; overflow--) { if (__perf_event_overflow(event, throttle, data, regs)) { break; } throttle = 1; } }"
427,5027----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bond_main.c----bond_setup,"static void bond_setup(struct net_device *bond_dev) { struct bonding *bond = netdev_priv(bond_dev); rwlock_init(&bond->lock); rwlock_init(&bond->curr_slave_lock); bond->params = bonding_defaults; bond->dev = bond_dev; INIT_LIST_HEAD(&bond->vlan_list); ether_setup(bond_dev); bond_dev->netdev_ops = &bond_netdev_ops; bond_dev->ethtool_ops = &bond_ethtool_ops; bond_set_mode_ops(bond, bond->params.mode); bond_dev->destructor = bond_destructor; bond_dev->tx_queue_len = 0; bond_dev->flags |= IFF_MASTER|IFF_MULTICAST; bond_dev->priv_flags |= IFF_BONDING; <S2SV_StartVul> bond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE; <S2SV_EndVul> bond_dev->features |= NETIF_F_VLAN_CHALLENGED; bond_dev->features |= NETIF_F_LLTX; bond_dev->hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER; bond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM); bond_dev->features |= bond_dev->hw_features; }","- bond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
+ bond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);","static void bond_setup(struct net_device *bond_dev) { struct bonding *bond = netdev_priv(bond_dev); rwlock_init(&bond->lock); rwlock_init(&bond->curr_slave_lock); bond->params = bonding_defaults; bond->dev = bond_dev; INIT_LIST_HEAD(&bond->vlan_list); ether_setup(bond_dev); bond_dev->netdev_ops = &bond_netdev_ops; bond_dev->ethtool_ops = &bond_ethtool_ops; bond_set_mode_ops(bond, bond->params.mode); bond_dev->destructor = bond_destructor; bond_dev->tx_queue_len = 0; bond_dev->flags |= IFF_MASTER|IFF_MULTICAST; bond_dev->priv_flags |= IFF_BONDING; bond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING); bond_dev->features |= NETIF_F_VLAN_CHALLENGED; bond_dev->features |= NETIF_F_LLTX; bond_dev->hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER; bond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM); bond_dev->features |= bond_dev->hw_features; }"
428,117----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-6269--proto_http.c----http_request_forward_body,"int http_request_forward_body(struct session *s, struct channel *req, int an_bit) { struct http_txn *txn = &s->txn; struct http_msg *msg = &s->txn.req; if (unlikely(msg->msg_state < HTTP_MSG_BODY)) return 0; if ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) || ((req->flags & CF_SHUTW) && (req->to_forward || req->buf->o))) { msg->msg_state = HTTP_MSG_ERROR; http_resync_states(s); return 1; } if (msg->sov > 0) { b_adv(req->buf, msg->sov); msg->next -= msg->sov; msg->sov = 0; if (msg->msg_state < HTTP_MSG_CHUNK_SIZE) { if (msg->flags & HTTP_MSGF_TE_CHNK) msg->msg_state = HTTP_MSG_CHUNK_SIZE; else msg->msg_state = HTTP_MSG_DATA; } } if (unlikely(msg->flags & HTTP_MSGF_WAIT_CONN)) { if (!(s->rep->flags & CF_READ_ATTACHED)) { channel_auto_connect(req); req->flags |= CF_WAKE_CONNECT; goto missing_data; } msg->flags &= ~HTTP_MSGF_WAIT_CONN; } channel_auto_close(req); if (req->to_forward) { req->flags |= CF_WAKE_WRITE; goto missing_data; } while (1) { if (msg->msg_state == HTTP_MSG_DATA) { if (msg->chunk_len > req->buf->i - msg->next) { req->flags |= CF_WAKE_WRITE; goto missing_data; } msg->next += msg->chunk_len; msg->chunk_len = 0; if (msg->flags & HTTP_MSGF_TE_CHNK) msg->msg_state = HTTP_MSG_CHUNK_CRLF; else msg->msg_state = HTTP_MSG_DONE; } else if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) { int ret = http_parse_chunk_size(msg); if (ret == 0) goto missing_data; else if (ret < 0) { session_inc_http_err_ctr(s); if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_SIZE, s->be); goto return_bad_req; } } else if (msg->msg_state == HTTP_MSG_CHUNK_CRLF) { int ret = http_skip_chunk_crlf(msg); if (ret == 0) goto missing_data; else if (ret < 0) { session_inc_http_err_ctr(s); if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_CRLF, s->be); goto return_bad_req; } } else if (msg->msg_state == HTTP_MSG_TRAILERS) { int ret = http_forward_trailers(msg); if (ret == 0) goto missing_data; else if (ret < 0) { session_inc_http_err_ctr(s); if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_TRAILERS, s->be); goto return_bad_req; } } else { int old_state = msg->msg_state; b_adv(req->buf, msg->next); <S2SV_StartVul> if (unlikely(!(s->rep->flags & CF_READ_ATTACHED))) <S2SV_EndVul> msg->sov -= msg->next; msg->next = 0; if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL || (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) channel_dont_close(req); if (http_resync_states(s)) { if (unlikely(msg->msg_state == HTTP_MSG_ERROR)) { if (req->flags & CF_SHUTW) { goto aborted_xfer; } if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, old_state, s->be); goto return_bad_req; } return 1; } if (s->be->options & PR_O_ABRT_CLOSE) { channel_auto_read(req); channel_auto_close(req); } else if (s->txn.meth == HTTP_METH_POST) { channel_auto_read(req); } return 0; } } missing_data: b_adv(req->buf, msg->next); <S2SV_StartVul> if (unlikely(!(s->rep->flags & CF_READ_ATTACHED))) <S2SV_EndVul> msg->sov -= msg->next + MIN(msg->chunk_len, req->buf->i); msg->next = 0; msg->chunk_len -= channel_forward(req, msg->chunk_len); if (req->flags & CF_SHUTR) { if (!(s->flags & SN_ERR_MASK)) s->flags |= SN_ERR_CLICL; if (!(s->flags & SN_FINST_MASK)) { if (txn->rsp.msg_state < HTTP_MSG_ERROR) s->flags |= SN_FINST_H; else s->flags |= SN_FINST_D; } s->fe->fe_counters.cli_aborts++; s->be->be_counters.cli_aborts++; if (objt_server(s->target)) objt_server(s->target)->counters.cli_aborts++; goto return_bad_req_stats_ok; } if (req->flags & CF_SHUTW) goto aborted_xfer; if (msg->flags & HTTP_MSGF_TE_CHNK) channel_dont_close(req); if (msg->flags & HTTP_MSGF_TE_CHNK) req->flags |= CF_EXPECT_MORE; return 0; return_bad_req: s->fe->fe_counters.failed_req++; if (s->listener->counters) s->listener->counters->failed_req++; return_bad_req_stats_ok: b_adv(req->buf, msg->next); msg->next = 0; txn->req.msg_state = HTTP_MSG_ERROR; if (txn->status) { stream_int_retnclose(req->prod, NULL); } else { txn->status = 400; stream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400)); } req->analysers = 0; s->rep->analysers = 0; if (!(s->flags & SN_ERR_MASK)) s->flags |= SN_ERR_PRXCOND; if (!(s->flags & SN_FINST_MASK)) { if (txn->rsp.msg_state < HTTP_MSG_ERROR) s->flags |= SN_FINST_H; else s->flags |= SN_FINST_D; } return 0; aborted_xfer: txn->req.msg_state = HTTP_MSG_ERROR; if (txn->status) { stream_int_retnclose(req->prod, NULL); } else { txn->status = 502; stream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_502)); } req->analysers = 0; s->rep->analysers = 0; s->fe->fe_counters.srv_aborts++; s->be->be_counters.srv_aborts++; if (objt_server(s->target)) objt_server(s->target)->counters.srv_aborts++; if (!(s->flags & SN_ERR_MASK)) s->flags |= SN_ERR_SRVCL; if (!(s->flags & SN_FINST_MASK)) { if (txn->rsp.msg_state < HTTP_MSG_ERROR) s->flags |= SN_FINST_H; else s->flags |= SN_FINST_D; } return 0; }","- if (unlikely(!(s->rep->flags & CF_READ_ATTACHED)))
- if (unlikely(!(s->rep->flags & CF_READ_ATTACHED)))
+ if (unlikely(!(s->req->flags & CF_WROTE_DATA)))
+ if (unlikely(!(s->req->flags & CF_WROTE_DATA)))","int http_request_forward_body(struct session *s, struct channel *req, int an_bit) { struct http_txn *txn = &s->txn; struct http_msg *msg = &s->txn.req; if (unlikely(msg->msg_state < HTTP_MSG_BODY)) return 0; if ((req->flags & (CF_READ_ERROR|CF_READ_TIMEOUT|CF_WRITE_ERROR|CF_WRITE_TIMEOUT)) || ((req->flags & CF_SHUTW) && (req->to_forward || req->buf->o))) { msg->msg_state = HTTP_MSG_ERROR; http_resync_states(s); return 1; } if (msg->sov > 0) { b_adv(req->buf, msg->sov); msg->next -= msg->sov; msg->sov = 0; if (msg->msg_state < HTTP_MSG_CHUNK_SIZE) { if (msg->flags & HTTP_MSGF_TE_CHNK) msg->msg_state = HTTP_MSG_CHUNK_SIZE; else msg->msg_state = HTTP_MSG_DATA; } } if (unlikely(msg->flags & HTTP_MSGF_WAIT_CONN)) { if (!(s->rep->flags & CF_READ_ATTACHED)) { channel_auto_connect(req); req->flags |= CF_WAKE_CONNECT; goto missing_data; } msg->flags &= ~HTTP_MSGF_WAIT_CONN; } channel_auto_close(req); if (req->to_forward) { req->flags |= CF_WAKE_WRITE; goto missing_data; } while (1) { if (msg->msg_state == HTTP_MSG_DATA) { if (msg->chunk_len > req->buf->i - msg->next) { req->flags |= CF_WAKE_WRITE; goto missing_data; } msg->next += msg->chunk_len; msg->chunk_len = 0; if (msg->flags & HTTP_MSGF_TE_CHNK) msg->msg_state = HTTP_MSG_CHUNK_CRLF; else msg->msg_state = HTTP_MSG_DONE; } else if (msg->msg_state == HTTP_MSG_CHUNK_SIZE) { int ret = http_parse_chunk_size(msg); if (ret == 0) goto missing_data; else if (ret < 0) { session_inc_http_err_ctr(s); if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_SIZE, s->be); goto return_bad_req; } } else if (msg->msg_state == HTTP_MSG_CHUNK_CRLF) { int ret = http_skip_chunk_crlf(msg); if (ret == 0) goto missing_data; else if (ret < 0) { session_inc_http_err_ctr(s); if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_CHUNK_CRLF, s->be); goto return_bad_req; } } else if (msg->msg_state == HTTP_MSG_TRAILERS) { int ret = http_forward_trailers(msg); if (ret == 0) goto missing_data; else if (ret < 0) { session_inc_http_err_ctr(s); if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, HTTP_MSG_TRAILERS, s->be); goto return_bad_req; } } else { int old_state = msg->msg_state; b_adv(req->buf, msg->next); if (unlikely(!(s->req->flags & CF_WROTE_DATA))) msg->sov -= msg->next; msg->next = 0; if ((txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_KAL || (txn->flags & TX_CON_WANT_MSK) == TX_CON_WANT_SCL) channel_dont_close(req); if (http_resync_states(s)) { if (unlikely(msg->msg_state == HTTP_MSG_ERROR)) { if (req->flags & CF_SHUTW) { goto aborted_xfer; } if (msg->err_pos >= 0) http_capture_bad_message(&s->fe->invalid_req, s, msg, old_state, s->be); goto return_bad_req; } return 1; } if (s->be->options & PR_O_ABRT_CLOSE) { channel_auto_read(req); channel_auto_close(req); } else if (s->txn.meth == HTTP_METH_POST) { channel_auto_read(req); } return 0; } } missing_data: b_adv(req->buf, msg->next); if (unlikely(!(s->req->flags & CF_WROTE_DATA))) msg->sov -= msg->next + MIN(msg->chunk_len, req->buf->i); msg->next = 0; msg->chunk_len -= channel_forward(req, msg->chunk_len); if (req->flags & CF_SHUTR) { if (!(s->flags & SN_ERR_MASK)) s->flags |= SN_ERR_CLICL; if (!(s->flags & SN_FINST_MASK)) { if (txn->rsp.msg_state < HTTP_MSG_ERROR) s->flags |= SN_FINST_H; else s->flags |= SN_FINST_D; } s->fe->fe_counters.cli_aborts++; s->be->be_counters.cli_aborts++; if (objt_server(s->target)) objt_server(s->target)->counters.cli_aborts++; goto return_bad_req_stats_ok; } if (req->flags & CF_SHUTW) goto aborted_xfer; if (msg->flags & HTTP_MSGF_TE_CHNK) channel_dont_close(req); if (msg->flags & HTTP_MSGF_TE_CHNK) req->flags |= CF_EXPECT_MORE; return 0; return_bad_req: s->fe->fe_counters.failed_req++; if (s->listener->counters) s->listener->counters->failed_req++; return_bad_req_stats_ok: b_adv(req->buf, msg->next); msg->next = 0; txn->req.msg_state = HTTP_MSG_ERROR; if (txn->status) { stream_int_retnclose(req->prod, NULL); } else { txn->status = 400; stream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_400)); } req->analysers = 0; s->rep->analysers = 0; if (!(s->flags & SN_ERR_MASK)) s->flags |= SN_ERR_PRXCOND; if (!(s->flags & SN_FINST_MASK)) { if (txn->rsp.msg_state < HTTP_MSG_ERROR) s->flags |= SN_FINST_H; else s->flags |= SN_FINST_D; } return 0; aborted_xfer: txn->req.msg_state = HTTP_MSG_ERROR; if (txn->status) { stream_int_retnclose(req->prod, NULL); } else { txn->status = 502; stream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_502)); } req->analysers = 0; s->rep->analysers = 0; s->fe->fe_counters.srv_aborts++; s->be->be_counters.srv_aborts++; if (objt_server(s->target)) objt_server(s->target)->counters.srv_aborts++; if (!(s->flags & SN_ERR_MASK)) s->flags |= SN_ERR_SRVCL; if (!(s->flags & SN_FINST_MASK)) { if (txn->rsp.msg_state < HTTP_MSG_ERROR) s->flags |= SN_FINST_H; else s->flags |= SN_FINST_D; } return 0; }"
429,6465----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/SQLSetDescField.c----SQLSetDescField,"SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle, SQLSMALLINT rec_number, SQLSMALLINT field_identifier, SQLPOINTER value, SQLINTEGER buffer_length ) { DMHDESC descriptor = (DMHDESC) descriptor_handle; SQLRETURN ret; SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ]; int isStrField = 0; if ( !__validate_desc( descriptor )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: SQL_INVALID_HANDLE"" ); return SQL_INVALID_HANDLE; } function_entry( descriptor ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tEntry:\ \n\t\t\tDescriptor = %p\ \n\t\t\tRec Number = %d\ \n\t\t\tField Ident = %s\ \n\t\t\tValue = %p\ \n\t\t\tBuffer Length = %d"", descriptor, rec_number, __desc_attr_as_string( s1, field_identifier ), value, (int)buffer_length ); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } thread_protect( SQL_HANDLE_DESC, descriptor ); if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if( __check_stmt_from_desc( descriptor, STATE_S8 ) || __check_stmt_from_desc( descriptor, STATE_S9 ) || __check_stmt_from_desc( descriptor, STATE_S10 ) || __check_stmt_from_desc( descriptor, STATE_S11 ) || __check_stmt_from_desc( descriptor, STATE_S12 ) || __check_stmt_from_desc( descriptor, STATE_S13 ) || __check_stmt_from_desc( descriptor, STATE_S14 ) || __check_stmt_from_desc( descriptor, STATE_S15 )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( rec_number < 0 ) { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE: case SQL_DESC_ARRAY_SIZE: case SQL_DESC_ARRAY_STATUS_PTR: case SQL_DESC_BIND_OFFSET_PTR: case SQL_DESC_BIND_TYPE: case SQL_DESC_COUNT: case SQL_DESC_ROWS_PROCESSED_PTR: case SQL_DESC_AUTO_UNIQUE_VALUE: case SQL_DESC_CASE_SENSITIVE: case SQL_DESC_CONCISE_TYPE: case SQL_DESC_DATA_PTR: case SQL_DESC_DATETIME_INTERVAL_CODE: case SQL_DESC_DATETIME_INTERVAL_PRECISION: case SQL_DESC_DISPLAY_SIZE: case SQL_DESC_FIXED_PREC_SCALE: case SQL_DESC_INDICATOR_PTR: case SQL_DESC_LENGTH: case SQL_DESC_NULLABLE: case SQL_DESC_NUM_PREC_RADIX: case SQL_DESC_OCTET_LENGTH: case SQL_DESC_OCTET_LENGTH_PTR: case SQL_DESC_PARAMETER_TYPE: case SQL_DESC_PRECISION: case SQL_DESC_ROWVER: case SQL_DESC_SCALE: case SQL_DESC_SEARCHABLE: case SQL_DESC_TYPE: case SQL_DESC_UNNAMED: case SQL_DESC_UNSIGNED: case SQL_DESC_UPDATABLE: isStrField = 0; break; case SQL_DESC_BASE_COLUMN_NAME: case SQL_DESC_BASE_TABLE_NAME: case SQL_DESC_CATALOG_NAME: case SQL_DESC_LABEL: case SQL_DESC_LITERAL_PREFIX: case SQL_DESC_LITERAL_SUFFIX: case SQL_DESC_LOCAL_TYPE_NAME: case SQL_DESC_NAME: case SQL_DESC_SCHEMA_NAME: case SQL_DESC_TABLE_NAME: case SQL_DESC_TYPE_NAME: isStrField = 1; break; default: isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS) { __post_internal_error( &descriptor -> error, ERROR_HY090, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } <S2SV_StartVul> if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 ) <S2SV_EndVul> { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } <S2SV_StartVul> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndVul> <S2SV_StartVul> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndVul> <S2SV_StartVul> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndVul> { __post_internal_error( &descriptor -> error, ERROR_HY105, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( CHECK_SQLSETDESCFIELD( descriptor -> connection )) { ret = SQLSETDESCFIELD( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, value, buffer_length ); } else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection )) { SQLWCHAR *s1 = NULL; if (isStrField) { s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL ); if (SQL_NTS != buffer_length) { buffer_length *= sizeof(SQLWCHAR); } } else { s1 = value; } ret = SQLSETDESCFIELDW( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, s1, buffer_length ); if (isStrField) { if (s1) free(s1); } } else { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: IM001"" ); __post_internal_error( &descriptor -> error, ERROR_IM001, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tExit:[%s]"", __get_return_status( ret, s1 )); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } return function_return( SQL_HANDLE_DESC, descriptor, ret ); }","- if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )
- if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT
- && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&
- value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )
+ if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )
+ if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT
+ && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&
+ (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )","SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle, SQLSMALLINT rec_number, SQLSMALLINT field_identifier, SQLPOINTER value, SQLINTEGER buffer_length ) { DMHDESC descriptor = (DMHDESC) descriptor_handle; SQLRETURN ret; SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ]; int isStrField = 0; if ( !__validate_desc( descriptor )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: SQL_INVALID_HANDLE"" ); return SQL_INVALID_HANDLE; } function_entry( descriptor ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tEntry:\ \n\t\t\tDescriptor = %p\ \n\t\t\tRec Number = %d\ \n\t\t\tField Ident = %s\ \n\t\t\tValue = %p\ \n\t\t\tBuffer Length = %d"", descriptor, rec_number, __desc_attr_as_string( s1, field_identifier ), value, (int)buffer_length ); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } thread_protect( SQL_HANDLE_DESC, descriptor ); if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if( __check_stmt_from_desc( descriptor, STATE_S8 ) || __check_stmt_from_desc( descriptor, STATE_S9 ) || __check_stmt_from_desc( descriptor, STATE_S10 ) || __check_stmt_from_desc( descriptor, STATE_S11 ) || __check_stmt_from_desc( descriptor, STATE_S12 ) || __check_stmt_from_desc( descriptor, STATE_S13 ) || __check_stmt_from_desc( descriptor, STATE_S14 ) || __check_stmt_from_desc( descriptor, STATE_S15 )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( rec_number < 0 ) { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE: case SQL_DESC_ARRAY_SIZE: case SQL_DESC_ARRAY_STATUS_PTR: case SQL_DESC_BIND_OFFSET_PTR: case SQL_DESC_BIND_TYPE: case SQL_DESC_COUNT: case SQL_DESC_ROWS_PROCESSED_PTR: case SQL_DESC_AUTO_UNIQUE_VALUE: case SQL_DESC_CASE_SENSITIVE: case SQL_DESC_CONCISE_TYPE: case SQL_DESC_DATA_PTR: case SQL_DESC_DATETIME_INTERVAL_CODE: case SQL_DESC_DATETIME_INTERVAL_PRECISION: case SQL_DESC_DISPLAY_SIZE: case SQL_DESC_FIXED_PREC_SCALE: case SQL_DESC_INDICATOR_PTR: case SQL_DESC_LENGTH: case SQL_DESC_NULLABLE: case SQL_DESC_NUM_PREC_RADIX: case SQL_DESC_OCTET_LENGTH: case SQL_DESC_OCTET_LENGTH_PTR: case SQL_DESC_PARAMETER_TYPE: case SQL_DESC_PRECISION: case SQL_DESC_ROWVER: case SQL_DESC_SCALE: case SQL_DESC_SEARCHABLE: case SQL_DESC_TYPE: case SQL_DESC_UNNAMED: case SQL_DESC_UNSIGNED: case SQL_DESC_UPDATABLE: isStrField = 0; break; case SQL_DESC_BASE_COLUMN_NAME: case SQL_DESC_BASE_TABLE_NAME: case SQL_DESC_CATALOG_NAME: case SQL_DESC_LABEL: case SQL_DESC_LITERAL_PREFIX: case SQL_DESC_LITERAL_SUFFIX: case SQL_DESC_LOCAL_TYPE_NAME: case SQL_DESC_NAME: case SQL_DESC_SCHEMA_NAME: case SQL_DESC_TABLE_NAME: case SQL_DESC_TYPE_NAME: isStrField = 1; break; default: isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS) { __post_internal_error( &descriptor -> error, ERROR_HY090, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 ) { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM ) { __post_internal_error( &descriptor -> error, ERROR_HY105, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( CHECK_SQLSETDESCFIELD( descriptor -> connection )) { ret = SQLSETDESCFIELD( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, value, buffer_length ); } else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection )) { SQLWCHAR *s1 = NULL; if (isStrField) { s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL ); if (SQL_NTS != buffer_length) { buffer_length *= sizeof(SQLWCHAR); } } else { s1 = value; } ret = SQLSETDESCFIELDW( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, s1, buffer_length ); if (isStrField) { if (s1) free(s1); } } else { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: IM001"" ); __post_internal_error( &descriptor -> error, ERROR_IM001, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tExit:[%s]"", __get_return_status( ret, s1 )); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } return function_return( SQL_HANDLE_DESC, descriptor, ret ); }"
430,6276----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/httpLib.c----httpGetIntParam,"PUBLIC int httpGetIntParam(HttpConn *conn, cchar *var, int defaultValue) { cchar *value; <S2SV_StartVul> value = mprLookupJson(httpGetParams(conn), var); <S2SV_EndVul> return (value) ? (int) stoi(value) : defaultValue; }","- value = mprLookupJson(httpGetParams(conn), var);
+ value = mprReadJson(httpGetParams(conn), var);","PUBLIC int httpGetIntParam(HttpConn *conn, cchar *var, int defaultValue) { cchar *value; value = mprReadJson(httpGetParams(conn), var); return (value) ? (int) stoi(value) : defaultValue; }"
431,4108----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/visor.c----clie_5_attach,"static int clie_5_attach(struct usb_serial *serial) { struct usb_serial_port *port; unsigned int pipe; int j; <S2SV_StartVul> if (serial->num_ports < 2) <S2SV_EndVul> <S2SV_StartVul> return -1; <S2SV_EndVul> port = serial->port[0]; port->bulk_out_endpointAddress = serial->port[1]->bulk_out_endpointAddress; pipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress); for (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j) port->write_urbs[j]->pipe = pipe; return 0; }","- if (serial->num_ports < 2)
- return -1;
+ if (serial->num_bulk_out < 2) {
+ dev_err(&serial->interface->dev, ""missing bulk out endpoints\n"");
+ return -ENODEV;
+ }","static int clie_5_attach(struct usb_serial *serial) { struct usb_serial_port *port; unsigned int pipe; int j; if (serial->num_bulk_out < 2) { dev_err(&serial->interface->dev, ""missing bulk out endpoints\n""); return -ENODEV; } port = serial->port[0]; port->bulk_out_endpointAddress = serial->port[1]->bulk_out_endpointAddress; pipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress); for (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j) port->write_urbs[j]->pipe = pipe; return 0; }"
432,4959----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-gre.c----gre_print_0,"gre_print_0(netdissect_options *ndo, const u_char *bp, u_int length) { u_int len = length; uint16_t flags, prot; flags = EXTRACT_16BITS(bp); if (ndo->ndo_vflag) ND_PRINT((ndo, "", Flags [%s]"", bittok2str(gre_flag_values,""none"",flags))); len -= 2; bp += 2; ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; prot = EXTRACT_16BITS(bp); len -= 2; bp += 2; if ((flags & GRE_CP) | (flags & GRE_RP)) { ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; if (ndo->ndo_vflag) ND_PRINT((ndo, "", sum 0x%x"", EXTRACT_16BITS(bp))); bp += 2; len -= 2; ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; ND_PRINT((ndo, "", off 0x%x"", EXTRACT_16BITS(bp))); bp += 2; len -= 2; } if (flags & GRE_KP) { ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; ND_PRINT((ndo, "", key=0x%x"", EXTRACT_32BITS(bp))); bp += 4; len -= 4; } if (flags & GRE_SP) { ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; ND_PRINT((ndo, "", seq %u"", EXTRACT_32BITS(bp))); bp += 4; len -= 4; } if (flags & GRE_RP) { for (;;) { uint16_t af; uint8_t sreoff; uint8_t srelen; ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; af = EXTRACT_16BITS(bp); sreoff = *(bp + 2); srelen = *(bp + 3); bp += 4; len -= 4; if (af == 0 && srelen == 0) break; if (!gre_sre_print(ndo, af, sreoff, srelen, bp, len)) goto trunc; if (len < srelen) goto trunc; bp += srelen; len -= srelen; } } if (ndo->ndo_eflag) ND_PRINT((ndo, "", proto %s (0x%04x)"", tok2str(ethertype_values,""unknown"",prot), prot)); ND_PRINT((ndo, "", length %u"",length)); if (ndo->ndo_vflag < 1) ND_PRINT((ndo, "": "")); else ND_PRINT((ndo, ""\n\t"")); switch (prot) { case ETHERTYPE_IP: ip_print(ndo, bp, len); break; case ETHERTYPE_IPV6: ip6_print(ndo, bp, len); break; case ETHERTYPE_MPLS: mpls_print(ndo, bp, len); break; case ETHERTYPE_IPX: ipx_print(ndo, bp, len); break; case ETHERTYPE_ATALK: atalk_print(ndo, bp, len); break; case ETHERTYPE_GRE_ISO: <S2SV_StartVul> isoclns_print(ndo, bp, len, ndo->ndo_snapend - bp); <S2SV_EndVul> break; case ETHERTYPE_TEB: ether_print(ndo, bp, len, ndo->ndo_snapend - bp, NULL, NULL); break; default: ND_PRINT((ndo, ""gre-proto-0x%x"", prot)); } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }","- isoclns_print(ndo, bp, len, ndo->ndo_snapend - bp);
+ isoclns_print(ndo, bp, len);","gre_print_0(netdissect_options *ndo, const u_char *bp, u_int length) { u_int len = length; uint16_t flags, prot; flags = EXTRACT_16BITS(bp); if (ndo->ndo_vflag) ND_PRINT((ndo, "", Flags [%s]"", bittok2str(gre_flag_values,""none"",flags))); len -= 2; bp += 2; ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; prot = EXTRACT_16BITS(bp); len -= 2; bp += 2; if ((flags & GRE_CP) | (flags & GRE_RP)) { ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; if (ndo->ndo_vflag) ND_PRINT((ndo, "", sum 0x%x"", EXTRACT_16BITS(bp))); bp += 2; len -= 2; ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; ND_PRINT((ndo, "", off 0x%x"", EXTRACT_16BITS(bp))); bp += 2; len -= 2; } if (flags & GRE_KP) { ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; ND_PRINT((ndo, "", key=0x%x"", EXTRACT_32BITS(bp))); bp += 4; len -= 4; } if (flags & GRE_SP) { ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; ND_PRINT((ndo, "", seq %u"", EXTRACT_32BITS(bp))); bp += 4; len -= 4; } if (flags & GRE_RP) { for (;;) { uint16_t af; uint8_t sreoff; uint8_t srelen; ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; af = EXTRACT_16BITS(bp); sreoff = *(bp + 2); srelen = *(bp + 3); bp += 4; len -= 4; if (af == 0 && srelen == 0) break; if (!gre_sre_print(ndo, af, sreoff, srelen, bp, len)) goto trunc; if (len < srelen) goto trunc; bp += srelen; len -= srelen; } } if (ndo->ndo_eflag) ND_PRINT((ndo, "", proto %s (0x%04x)"", tok2str(ethertype_values,""unknown"",prot), prot)); ND_PRINT((ndo, "", length %u"",length)); if (ndo->ndo_vflag < 1) ND_PRINT((ndo, "": "")); else ND_PRINT((ndo, ""\n\t"")); switch (prot) { case ETHERTYPE_IP: ip_print(ndo, bp, len); break; case ETHERTYPE_IPV6: ip6_print(ndo, bp, len); break; case ETHERTYPE_MPLS: mpls_print(ndo, bp, len); break; case ETHERTYPE_IPX: ipx_print(ndo, bp, len); break; case ETHERTYPE_ATALK: atalk_print(ndo, bp, len); break; case ETHERTYPE_GRE_ISO: isoclns_print(ndo, bp, len); break; case ETHERTYPE_TEB: ether_print(ndo, bp, len, ndo->ndo_snapend - bp, NULL, NULL); break; default: ND_PRINT((ndo, ""gre-proto-0x%x"", prot)); } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }"
433,1458----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-11176--mqueue.c----do_mq_notify,"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification) { int ret; struct fd f; struct sock *sock; struct inode *inode; struct mqueue_inode_info *info; struct sk_buff *nc; audit_mq_notify(mqdes, notification); nc = NULL; sock = NULL; if (notification != NULL) { if (unlikely(notification->sigev_notify != SIGEV_NONE && notification->sigev_notify != SIGEV_SIGNAL && notification->sigev_notify != SIGEV_THREAD)) return -EINVAL; if (notification->sigev_notify == SIGEV_SIGNAL && !valid_signal(notification->sigev_signo)) { return -EINVAL; } if (notification->sigev_notify == SIGEV_THREAD) { long timeo; nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL); if (!nc) { ret = -ENOMEM; goto out; } if (copy_from_user(nc->data, notification->sigev_value.sival_ptr, NOTIFY_COOKIE_LEN)) { ret = -EFAULT; goto out; } skb_put(nc, NOTIFY_COOKIE_LEN); retry: f = fdget(notification->sigev_signo); if (!f.file) { ret = -EBADF; goto out; } sock = netlink_getsockbyfilp(f.file); fdput(f); if (IS_ERR(sock)) { ret = PTR_ERR(sock); sock = NULL; goto out; } timeo = MAX_SCHEDULE_TIMEOUT; ret = netlink_attachskb(sock, nc, &timeo, NULL); <S2SV_StartVul> if (ret == 1) <S2SV_EndVul> goto retry; if (ret) { sock = NULL; nc = NULL; goto out; } } } f = fdget(mqdes); if (!f.file) { ret = -EBADF; goto out; } inode = file_inode(f.file); if (unlikely(f.file->f_op != &mqueue_file_operations)) { ret = -EBADF; goto out_fput; } info = MQUEUE_I(inode); ret = 0; spin_lock(&info->lock); if (notification == NULL) { if (info->notify_owner == task_tgid(current)) { remove_notification(info); inode->i_atime = inode->i_ctime = current_time(inode); } } else if (info->notify_owner != NULL) { ret = -EBUSY; } else { switch (notification->sigev_notify) { case SIGEV_NONE: info->notify.sigev_notify = SIGEV_NONE; break; case SIGEV_THREAD: info->notify_sock = sock; info->notify_cookie = nc; sock = NULL; nc = NULL; info->notify.sigev_notify = SIGEV_THREAD; break; case SIGEV_SIGNAL: info->notify.sigev_signo = notification->sigev_signo; info->notify.sigev_value = notification->sigev_value; info->notify.sigev_notify = SIGEV_SIGNAL; break; } info->notify_owner = get_pid(task_tgid(current)); info->notify_user_ns = get_user_ns(current_user_ns()); inode->i_atime = inode->i_ctime = current_time(inode); } spin_unlock(&info->lock); out_fput: fdput(f); out: if (sock) netlink_detachskb(sock, nc); else if (nc) dev_kfree_skb(nc); return ret; }","- if (ret == 1)
+ if (ret == 1) {
+ sock = NULL;
+ }","static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification) { int ret; struct fd f; struct sock *sock; struct inode *inode; struct mqueue_inode_info *info; struct sk_buff *nc; audit_mq_notify(mqdes, notification); nc = NULL; sock = NULL; if (notification != NULL) { if (unlikely(notification->sigev_notify != SIGEV_NONE && notification->sigev_notify != SIGEV_SIGNAL && notification->sigev_notify != SIGEV_THREAD)) return -EINVAL; if (notification->sigev_notify == SIGEV_SIGNAL && !valid_signal(notification->sigev_signo)) { return -EINVAL; } if (notification->sigev_notify == SIGEV_THREAD) { long timeo; nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL); if (!nc) { ret = -ENOMEM; goto out; } if (copy_from_user(nc->data, notification->sigev_value.sival_ptr, NOTIFY_COOKIE_LEN)) { ret = -EFAULT; goto out; } skb_put(nc, NOTIFY_COOKIE_LEN); retry: f = fdget(notification->sigev_signo); if (!f.file) { ret = -EBADF; goto out; } sock = netlink_getsockbyfilp(f.file); fdput(f); if (IS_ERR(sock)) { ret = PTR_ERR(sock); sock = NULL; goto out; } timeo = MAX_SCHEDULE_TIMEOUT; ret = netlink_attachskb(sock, nc, &timeo, NULL); if (ret == 1) { sock = NULL; goto retry; } if (ret) { sock = NULL; nc = NULL; goto out; } } } f = fdget(mqdes); if (!f.file) { ret = -EBADF; goto out; } inode = file_inode(f.file); if (unlikely(f.file->f_op != &mqueue_file_operations)) { ret = -EBADF; goto out_fput; } info = MQUEUE_I(inode); ret = 0; spin_lock(&info->lock); if (notification == NULL) { if (info->notify_owner == task_tgid(current)) { remove_notification(info); inode->i_atime = inode->i_ctime = current_time(inode); } } else if (info->notify_owner != NULL) { ret = -EBUSY; } else { switch (notification->sigev_notify) { case SIGEV_NONE: info->notify.sigev_notify = SIGEV_NONE; break; case SIGEV_THREAD: info->notify_sock = sock; info->notify_cookie = nc; sock = NULL; nc = NULL; info->notify.sigev_notify = SIGEV_THREAD; break; case SIGEV_SIGNAL: info->notify.sigev_signo = notification->sigev_signo; info->notify.sigev_value = notification->sigev_value; info->notify.sigev_notify = SIGEV_SIGNAL; break; } info->notify_owner = get_pid(task_tgid(current)); info->notify_user_ns = get_user_ns(current_user_ns()); inode->i_atime = inode->i_ctime = current_time(inode); } spin_unlock(&info->lock); out_fput: fdput(f); out: if (sock) netlink_detachskb(sock, nc); else if (nc) dev_kfree_skb(nc); return ret; }"
434,6807----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/skbuff.c----__skb_tstamp_tx,"void __skb_tstamp_tx(struct sk_buff *orig_skb, struct skb_shared_hwtstamps *hwtstamps, struct sock *sk, int tstype) { struct sk_buff *skb; <S2SV_StartVul> bool tsonly; <S2SV_EndVul> if (!sk) return; tsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY; if (!skb_may_tx_timestamp(sk, tsonly)) return; if (tsonly) { #ifdef CONFIG_INET if ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) && sk->sk_protocol == IPPROTO_TCP && <S2SV_StartVul> sk->sk_type == SOCK_STREAM) <S2SV_EndVul> skb = tcp_get_timestamping_opt_stats(sk); <S2SV_StartVul> else <S2SV_EndVul> #endif skb = alloc_skb(0, GFP_ATOMIC); } else { skb = skb_clone(orig_skb, GFP_ATOMIC); } if (!skb) return; if (tsonly) { skb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags; skb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey; } if (hwtstamps) *skb_hwtstamps(skb) = *hwtstamps; else skb->tstamp = ktime_get_real(); <S2SV_StartVul> __skb_complete_tx_timestamp(skb, sk, tstype); <S2SV_EndVul>","- bool tsonly;
- sk->sk_type == SOCK_STREAM)
- else
- __skb_complete_tx_timestamp(skb, sk, tstype);
+ bool tsonly, opt_stats = false;
+ sk->sk_type == SOCK_STREAM) {
+ opt_stats = true;
+ } else
+ __skb_complete_tx_timestamp(skb, sk, tstype, opt_stats);","void __skb_tstamp_tx(struct sk_buff *orig_skb, struct skb_shared_hwtstamps *hwtstamps, struct sock *sk, int tstype) { struct sk_buff *skb; bool tsonly, opt_stats = false; if (!sk) return; tsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY; if (!skb_may_tx_timestamp(sk, tsonly)) return; if (tsonly) { #ifdef CONFIG_INET if ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) && sk->sk_protocol == IPPROTO_TCP && sk->sk_type == SOCK_STREAM) { skb = tcp_get_timestamping_opt_stats(sk); opt_stats = true; } else #endif skb = alloc_skb(0, GFP_ATOMIC); } else { skb = skb_clone(orig_skb, GFP_ATOMIC); } if (!skb) return; if (tsonly) { skb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags; skb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey; } if (hwtstamps) *skb_hwtstamps(skb) = *hwtstamps; else skb->tstamp = ktime_get_real(); __skb_complete_tx_timestamp(skb, sk, tstype, opt_stats);"
435,249----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-4467--socket.c----do_siocgstamp,"static int do_siocgstamp(struct net *net, struct socket *sock, unsigned int cmd, void __user *up) { mm_segment_t old_fs = get_fs(); struct timeval ktv; int err; set_fs(KERNEL_DS); err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv); set_fs(old_fs); if (!err) <S2SV_StartVul> err = compat_put_timeval(up, &ktv); <S2SV_EndVul> return err; }","- err = compat_put_timeval(up, &ktv);
+ err = compat_put_timeval(&ktv, up);","static int do_siocgstamp(struct net *net, struct socket *sock, unsigned int cmd, void __user *up) { mm_segment_t old_fs = get_fs(); struct timeval ktv; int err; set_fs(KERNEL_DS); err = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv); set_fs(old_fs); if (!err) err = compat_put_timeval(&ktv, up); return err; }"
436,1906--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-19854--crypto_user_base.c----crypto_report_comp,"static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_comp rcomp; <S2SV_StartVul> strlcpy(rcomp.type, ""compression"", sizeof(rcomp.type)); <S2SV_EndVul> if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS, sizeof(struct crypto_report_comp), &rcomp)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }","- strlcpy(rcomp.type, ""compression"", sizeof(rcomp.type));
+ strncpy(rcomp.type, ""compression"", sizeof(rcomp.type));","static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_comp rcomp; strncpy(rcomp.type, ""compression"", sizeof(rcomp.type)); if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS, sizeof(struct crypto_report_comp), &rcomp)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }"
437,2719----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sw-offload.cpp----ParaNdis_CheckSumVerify,"tTcpIpPacketParsingResult ParaNdis_CheckSumVerify( tCompletePhysicalAddress *pDataPages, ULONG ulDataLength, ULONG ulStartOffset, ULONG flags, LPCSTR caller) { IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset); <S2SV_StartVul> tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength); <S2SV_EndVul> if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort) return res; if (res.ipStatus == ppresIPV4) { if (flags & pcrIpChecksum) res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0); if(res.xxpStatus == ppresXxpKnown) { if (res.TcpUdp == ppresIsTCP) { if(flags & pcrTcpV4Checksum) { res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum)); } } else { if (flags & pcrUdpV4Checksum) { res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum)); } } } } else if (res.ipStatus == ppresIPV6) { if(res.xxpStatus == ppresXxpKnown) { if (res.TcpUdp == ppresIsTCP) { if(flags & pcrTcpV6Checksum) { res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum)); } } else { if (flags & pcrUdpV6Checksum) { res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum)); } } } } PrintOutParsingResult(res, 1, caller); return res; }","- tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);
+ BOOLEAN verifyLength,
+ tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);","tTcpIpPacketParsingResult ParaNdis_CheckSumVerify( tCompletePhysicalAddress *pDataPages, ULONG ulDataLength, ULONG ulStartOffset, ULONG flags, BOOLEAN verifyLength, LPCSTR caller) { IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset); tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength); if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort) return res; if (res.ipStatus == ppresIPV4) { if (flags & pcrIpChecksum) res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0); if(res.xxpStatus == ppresXxpKnown) { if (res.TcpUdp == ppresIsTCP) { if(flags & pcrTcpV4Checksum) { res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum)); } } else { if (flags & pcrUdpV4Checksum) { res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum)); } } } } else if (res.ipStatus == ppresIPV6) { if(res.xxpStatus == ppresXxpKnown) { if (res.TcpUdp == ppresIsTCP) { if(flags & pcrTcpV6Checksum) { res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum)); } } else { if (flags & pcrUdpV6Checksum) { res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum)); } } } } PrintOutParsingResult(res, 1, caller); return res; }"
438,6672----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/unpackinline.cpp----Unpack::CopyString,"_forceinline void Unpack::CopyString(uint Length,uint Distance) { size_t SrcPtr=UnpPtr-Distance; <S2SV_StartVul> if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH) <S2SV_EndVul> { byte *Src=Window+SrcPtr; byte *Dest=Window+UnpPtr; UnpPtr+=Length; #ifdef FAST_MEMCPY if (Distance<Length) #endif while (Length>=8) { Dest[0]=Src[0]; Dest[1]=Src[1]; Dest[2]=Src[2]; Dest[3]=Src[3]; Dest[4]=Src[4]; Dest[5]=Src[5]; Dest[6]=Src[6]; Dest[7]=Src[7]; Src+=8; Dest+=8; Length-=8; } #ifdef FAST_MEMCPY else while (Length>=8) { memcpy(Dest,Src,8); Src+=8; Dest+=8; Length-=8; } #endif if (Length>0) { Dest[0]=Src[0]; if (Length>1) { Dest[1]=Src[1]; if (Length>2) { Dest[2]=Src[2]; if (Length>3) { Dest[3]=Src[3]; if (Length>4) { Dest[4]=Src[4]; if (Length>5) { Dest[5]=Src[5]; if (Length>6) { Dest[6]=Src[6]; } } } } } } } } else while (Length-- > 0) { Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask]; UnpPtr=(UnpPtr+1) & MaxWinMask; } }","- if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)
+ if (SrcPtr<MaxWinSize-MAX_INC_LZ_MATCH && UnpPtr<MaxWinSize-MAX_INC_LZ_MATCH)","_forceinline void Unpack::CopyString(uint Length,uint Distance) { size_t SrcPtr=UnpPtr-Distance; if (SrcPtr<MaxWinSize-MAX_INC_LZ_MATCH && UnpPtr<MaxWinSize-MAX_INC_LZ_MATCH) { byte *Src=Window+SrcPtr; byte *Dest=Window+UnpPtr; UnpPtr+=Length; #ifdef FAST_MEMCPY if (Distance<Length) #endif while (Length>=8) { Dest[0]=Src[0]; Dest[1]=Src[1]; Dest[2]=Src[2]; Dest[3]=Src[3]; Dest[4]=Src[4]; Dest[5]=Src[5]; Dest[6]=Src[6]; Dest[7]=Src[7]; Src+=8; Dest+=8; Length-=8; } #ifdef FAST_MEMCPY else while (Length>=8) { memcpy(Dest,Src,8); Src+=8; Dest+=8; Length-=8; } #endif if (Length>0) { Dest[0]=Src[0]; if (Length>1) { Dest[1]=Src[1]; if (Length>2) { Dest[2]=Src[2]; if (Length>3) { Dest[3]=Src[3]; if (Length>4) { Dest[4]=Src[4]; if (Length>5) { Dest[5]=Src[5]; if (Length>6) { Dest[6]=Src[6]; } } } } } } } } else while (Length-- > 0) { Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask]; UnpPtr=(UnpPtr+1) & MaxWinMask; } }"
439,2546----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-7514--psd.c----WriteImageChannels,"static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info, const ImageInfo *image_info,Image *image,Image *next_image, const MagickBooleanType separate,ExceptionInfo *exception) { size_t channels, packet_size; unsigned char *compact_pixels; <S2SV_StartVul> channels=1; packet_size=next_image->depth > 8UL ? 2UL : 1UL; compact_pixels=(unsigned char *) NULL; if (next_image->compression == RLECompression) { compact_pixels=(unsigned char *) AcquireQuantumMemory(2*channels* next_image->columns,packet_size*sizeof(*compact_pixels)); if (compact_pixels == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); } if (IsImageGray(next_image) != MagickFalse) { if (next_image->compression == RLECompression) { (void) WriteBlobMSBShort(image,1); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,GrayQuantum,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,AlphaQuantum,exception); } WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, GrayQuantum,MagickTrue,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, AlphaQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,0,1); } else if (next_image->storage_class == PseudoClass) { if (next_image->compression == RLECompression) { (void) WriteBlobMSBShort(image,1); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,IndexQuantum,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,AlphaQuantum,exception); } WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, IndexQuantum,MagickTrue,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, AlphaQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,0,1); } else { if (next_image->colorspace == CMYKColorspace) (void) NegateCMYK(next_image,exception); if (next_image->compression == RLECompression) { (void) WriteBlobMSBShort(image,1); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,RedQuantum,exception); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,GreenQuantum,exception); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,BlueQuantum,exception); if (next_image->colorspace == CMYKColorspace) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,BlackQuantum,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,AlphaQuantum,exception); } (void) SetImageProgress(image,SaveImagesTag,0,6); WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, RedQuantum,MagickTrue,exception); (void) SetImageProgress(image,SaveImagesTag,1,6); WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, GreenQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,2,6); WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, BlueQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,3,6); if (next_image->colorspace == CMYKColorspace) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, BlackQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,4,6); if (next_image->alpha_trait != UndefinedPixelTrait) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, AlphaQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,5,6); if (next_image->colorspace == CMYKColorspace) (void) NegateCMYK(next_image,exception); } if (next_image->compression == RLECompression) compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels); return(MagickTrue); }","- /*
- Write uncompressed pixels as separate planes.
+ {
+ compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*","static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info, const ImageInfo *image_info,Image *image,Image *next_image, const MagickBooleanType separate,ExceptionInfo *exception) { size_t channels, packet_size; unsigned char *compact_pixels; channels=1; packet_size=next_image->depth > 8UL ? 2UL : 1UL; compact_pixels=(unsigned char *) NULL; if (next_image->compression == RLECompression) { compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels* next_image->columns)+1,packet_size*sizeof(*compact_pixels)); if (compact_pixels == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); } if (IsImageGray(next_image) != MagickFalse) { if (next_image->compression == RLECompression) { (void) WriteBlobMSBShort(image,1); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,GrayQuantum,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,AlphaQuantum,exception); } WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, GrayQuantum,MagickTrue,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, AlphaQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,0,1); } else if (next_image->storage_class == PseudoClass) { if (next_image->compression == RLECompression) { (void) WriteBlobMSBShort(image,1); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,IndexQuantum,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,AlphaQuantum,exception); } WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, IndexQuantum,MagickTrue,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, AlphaQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,0,1); } else { if (next_image->colorspace == CMYKColorspace) (void) NegateCMYK(next_image,exception); if (next_image->compression == RLECompression) { (void) WriteBlobMSBShort(image,1); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,RedQuantum,exception); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,GreenQuantum,exception); WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,BlueQuantum,exception); if (next_image->colorspace == CMYKColorspace) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,BlackQuantum,exception); if (next_image->alpha_trait != UndefinedPixelTrait) WritePackbitsLength(psd_info,image_info,image,next_image, compact_pixels,AlphaQuantum,exception); } (void) SetImageProgress(image,SaveImagesTag,0,6); WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, RedQuantum,MagickTrue,exception); (void) SetImageProgress(image,SaveImagesTag,1,6); WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, GreenQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,2,6); WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, BlueQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,3,6); if (next_image->colorspace == CMYKColorspace) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, BlackQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,4,6); if (next_image->alpha_trait != UndefinedPixelTrait) WriteOneChannel(psd_info,image_info,image,next_image,compact_pixels, AlphaQuantum,separate,exception); (void) SetImageProgress(image,SaveImagesTag,5,6); if (next_image->colorspace == CMYKColorspace) (void) NegateCMYK(next_image,exception); } if (next_image->compression == RLECompression) compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels); return(MagickTrue); }"
440,4393----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/image-fit.c----fit_image_load,"int fit_image_load(bootm_headers_t *images, ulong addr, const char **fit_unamep, const char **fit_uname_configp, int arch, int image_type, int bootstage_id, enum fit_load_op load_op, ulong *datap, ulong *lenp) { int cfg_noffset, noffset; const char *fit_uname; const char *fit_uname_config; const char *fit_base_uname_config; const void *fit; void *buf; void *loadbuf; size_t size; int type_ok, os_ok; ulong load, load_end, data, len; uint8_t os, comp; #ifndef USE_HOSTCC uint8_t os_arch; #endif const char *prop_name; int ret; fit = map_sysmem(addr, 0); fit_uname = fit_unamep ? *fit_unamep : NULL; fit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL; fit_base_uname_config = NULL; prop_name = fit_get_image_type_property(image_type); printf(""## Loading %s from FIT Image at %08lx ...\n"", prop_name, addr); bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT); <S2SV_StartVul> if (fit_check_format(fit, IMAGE_SIZE_INVAL)) { <S2SV_EndVul> <S2SV_StartVul> printf(""Bad FIT %s image format!\n"", prop_name); <S2SV_EndVul> bootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT); <S2SV_StartVul> return -ENOEXEC; <S2SV_EndVul> } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK); if (fit_uname) { bootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME); noffset = fit_image_get_node(fit, fit_uname); } else { bootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME); if (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) { cfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob()); } else { cfg_noffset = fit_conf_get_node(fit, fit_uname_config); } if (cfg_noffset < 0) { puts(""Could not find configuration node\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME); return -ENOENT; } fit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL); printf("" Using '%s' configuration\n"", fit_base_uname_config); if (image_type == IH_TYPE_KERNEL) images->fit_uname_cfg = fit_base_uname_config; if (FIT_IMAGE_ENABLE_VERIFY && images->verify) { puts("" Verifying Hash Integrity ... ""); if (fit_config_verify(fit, cfg_noffset)) { puts(""Bad Data Hash\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH); return -EACCES; } puts(""OK\n""); } bootstage_mark(BOOTSTAGE_ID_FIT_CONFIG); noffset = fit_conf_get_prop_node(fit, cfg_noffset, prop_name); fit_uname = fit_get_name(fit, noffset, NULL); } if (noffset < 0) { printf(""Could not find subimage node type '%s'\n"", prop_name); bootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE); return -ENOENT; } printf("" Trying '%s' %s subimage\n"", fit_uname, prop_name); ret = fit_image_select(fit, noffset, images->verify); if (ret) { bootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH); return ret; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH); if (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) { if (!fit_image_check_target_arch(fit, noffset)) { puts(""Unsupported Architecture\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH); return -ENOEXEC; } } #ifndef USE_HOSTCC fit_image_get_arch(fit, noffset, &os_arch); images->os.arch = os_arch; #endif bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL); type_ok = fit_image_check_type(fit, noffset, image_type) || fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) || (image_type == IH_TYPE_KERNEL && fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD)); os_ok = image_type == IH_TYPE_FLATDT || image_type == IH_TYPE_FPGA || fit_image_check_os(fit, noffset, IH_OS_LINUX) || fit_image_check_os(fit, noffset, IH_OS_U_BOOT) || fit_image_check_os(fit, noffset, IH_OS_OPENRTOS) || fit_image_check_os(fit, noffset, IH_OS_EFI) || fit_image_check_os(fit, noffset, IH_OS_VXWORKS); if ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) { fit_image_get_os(fit, noffset, &os); printf(""No %s %s %s Image\n"", genimg_get_os_name(os), genimg_get_arch_name(arch), genimg_get_type_name(image_type)); bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL); return -EIO; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK); if (fit_image_get_data_and_size(fit, noffset, (const void **)&buf, &size)) { printf(""Could not find %s subimage data!\n"", prop_name); bootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA); return -ENOENT; } if (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) { puts("" Decrypting Data ... ""); if (fit_image_uncipher(fit, noffset, &buf, &size)) { puts(""Error\n""); return -EACCES; } puts(""OK\n""); } if (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS)) board_fit_image_post_process(&buf, &size); len = (ulong)size; bootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK); data = map_to_sysmem(buf); load = data; if (load_op == FIT_LOAD_IGNORED) { } else if (fit_image_get_load(fit, noffset, &load)) { if (load_op == FIT_LOAD_REQUIRED) { printf(""Can't get %s subimage load address!\n"", prop_name); bootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD); return -EBADF; } } else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) { ulong image_start, image_end; image_start = addr; image_end = addr + fit_get_size(fit); load_end = load + len; if (image_type != IH_TYPE_KERNEL && load < image_end && load_end > image_start) { printf(""Error: %s overwritten\n"", prop_name); return -EXDEV; } printf("" Loading %s from 0x%08lx to 0x%08lx\n"", prop_name, data, load); } else { load = data; } comp = IH_COMP_NONE; loadbuf = buf; if (!fit_image_get_comp(fit, noffset, &comp) && comp != IH_COMP_NONE && !(image_type == IH_TYPE_KERNEL || image_type == IH_TYPE_KERNEL_NOLOAD || image_type == IH_TYPE_RAMDISK)) { ulong max_decomp_len = len * 20; if (load == data) { loadbuf = malloc(max_decomp_len); load = map_to_sysmem(loadbuf); } else { loadbuf = map_sysmem(load, max_decomp_len); } if (image_decomp(comp, load, data, image_type, loadbuf, buf, len, max_decomp_len, &load_end)) { printf(""Error decompressing %s\n"", prop_name); return -ENOEXEC; } len = load_end - load; } else if (load != data) { loadbuf = map_sysmem(load, len); memcpy(loadbuf, buf, len); } if (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE) puts(""WARNING: 'compression' nodes for ramdisks are deprecated,"" "" please fix your .its file!\n""); if (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) { puts(""Subimage data is not a FDT""); return -ENOEXEC; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD); *datap = load; *lenp = len; if (fit_unamep) *fit_unamep = (char *)fit_uname; if (fit_uname_configp) *fit_uname_configp = (char *)(fit_uname_config ? : fit_base_uname_config); return noffset; }","- if (fit_check_format(fit, IMAGE_SIZE_INVAL)) {
- printf(""Bad FIT %s image format!\n"", prop_name);
- return -ENOEXEC;
+ ret = fit_check_format(fit, IMAGE_SIZE_INVAL);
+ if (ret) {
+ printf(""Bad FIT %s image format! (err=%d)\n"", prop_name, ret);
+ if (CONFIG_IS_ENABLED(FIT_SIGNATURE) && ret == -EADDRNOTAVAIL)
+ printf(""Signature checking prevents use of unit addresses (@) in nodes\n"");
+ return ret;","int fit_image_load(bootm_headers_t *images, ulong addr, const char **fit_unamep, const char **fit_uname_configp, int arch, int image_type, int bootstage_id, enum fit_load_op load_op, ulong *datap, ulong *lenp) { int cfg_noffset, noffset; const char *fit_uname; const char *fit_uname_config; const char *fit_base_uname_config; const void *fit; void *buf; void *loadbuf; size_t size; int type_ok, os_ok; ulong load, load_end, data, len; uint8_t os, comp; #ifndef USE_HOSTCC uint8_t os_arch; #endif const char *prop_name; int ret; fit = map_sysmem(addr, 0); fit_uname = fit_unamep ? *fit_unamep : NULL; fit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL; fit_base_uname_config = NULL; prop_name = fit_get_image_type_property(image_type); printf(""## Loading %s from FIT Image at %08lx ...\n"", prop_name, addr); bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT); ret = fit_check_format(fit, IMAGE_SIZE_INVAL); if (ret) { printf(""Bad FIT %s image format! (err=%d)\n"", prop_name, ret); if (CONFIG_IS_ENABLED(FIT_SIGNATURE) && ret == -EADDRNOTAVAIL) printf(""Signature checking prevents use of unit addresses (@) in nodes\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT); return ret; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK); if (fit_uname) { bootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME); noffset = fit_image_get_node(fit, fit_uname); } else { bootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME); if (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) { cfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob()); } else { cfg_noffset = fit_conf_get_node(fit, fit_uname_config); } if (cfg_noffset < 0) { puts(""Could not find configuration node\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME); return -ENOENT; } fit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL); printf("" Using '%s' configuration\n"", fit_base_uname_config); if (image_type == IH_TYPE_KERNEL) images->fit_uname_cfg = fit_base_uname_config; if (FIT_IMAGE_ENABLE_VERIFY && images->verify) { puts("" Verifying Hash Integrity ... ""); if (fit_config_verify(fit, cfg_noffset)) { puts(""Bad Data Hash\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH); return -EACCES; } puts(""OK\n""); } bootstage_mark(BOOTSTAGE_ID_FIT_CONFIG); noffset = fit_conf_get_prop_node(fit, cfg_noffset, prop_name); fit_uname = fit_get_name(fit, noffset, NULL); } if (noffset < 0) { printf(""Could not find subimage node type '%s'\n"", prop_name); bootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE); return -ENOENT; } printf("" Trying '%s' %s subimage\n"", fit_uname, prop_name); ret = fit_image_select(fit, noffset, images->verify); if (ret) { bootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH); return ret; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH); if (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) { if (!fit_image_check_target_arch(fit, noffset)) { puts(""Unsupported Architecture\n""); bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH); return -ENOEXEC; } } #ifndef USE_HOSTCC fit_image_get_arch(fit, noffset, &os_arch); images->os.arch = os_arch; #endif bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL); type_ok = fit_image_check_type(fit, noffset, image_type) || fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) || (image_type == IH_TYPE_KERNEL && fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD)); os_ok = image_type == IH_TYPE_FLATDT || image_type == IH_TYPE_FPGA || fit_image_check_os(fit, noffset, IH_OS_LINUX) || fit_image_check_os(fit, noffset, IH_OS_U_BOOT) || fit_image_check_os(fit, noffset, IH_OS_OPENRTOS) || fit_image_check_os(fit, noffset, IH_OS_EFI) || fit_image_check_os(fit, noffset, IH_OS_VXWORKS); if ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) { fit_image_get_os(fit, noffset, &os); printf(""No %s %s %s Image\n"", genimg_get_os_name(os), genimg_get_arch_name(arch), genimg_get_type_name(image_type)); bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL); return -EIO; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK); if (fit_image_get_data_and_size(fit, noffset, (const void **)&buf, &size)) { printf(""Could not find %s subimage data!\n"", prop_name); bootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA); return -ENOENT; } if (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) { puts("" Decrypting Data ... ""); if (fit_image_uncipher(fit, noffset, &buf, &size)) { puts(""Error\n""); return -EACCES; } puts(""OK\n""); } if (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS)) board_fit_image_post_process(&buf, &size); len = (ulong)size; bootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK); data = map_to_sysmem(buf); load = data; if (load_op == FIT_LOAD_IGNORED) { } else if (fit_image_get_load(fit, noffset, &load)) { if (load_op == FIT_LOAD_REQUIRED) { printf(""Can't get %s subimage load address!\n"", prop_name); bootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD); return -EBADF; } } else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) { ulong image_start, image_end; image_start = addr; image_end = addr + fit_get_size(fit); load_end = load + len; if (image_type != IH_TYPE_KERNEL && load < image_end && load_end > image_start) { printf(""Error: %s overwritten\n"", prop_name); return -EXDEV; } printf("" Loading %s from 0x%08lx to 0x%08lx\n"", prop_name, data, load); } else { load = data; } comp = IH_COMP_NONE; loadbuf = buf; if (!fit_image_get_comp(fit, noffset, &comp) && comp != IH_COMP_NONE && !(image_type == IH_TYPE_KERNEL || image_type == IH_TYPE_KERNEL_NOLOAD || image_type == IH_TYPE_RAMDISK)) { ulong max_decomp_len = len * 20; if (load == data) { loadbuf = malloc(max_decomp_len); load = map_to_sysmem(loadbuf); } else { loadbuf = map_sysmem(load, max_decomp_len); } if (image_decomp(comp, load, data, image_type, loadbuf, buf, len, max_decomp_len, &load_end)) { printf(""Error decompressing %s\n"", prop_name); return -ENOEXEC; } len = load_end - load; } else if (load != data) { loadbuf = map_sysmem(load, len); memcpy(loadbuf, buf, len); } if (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE) puts(""WARNING: 'compression' nodes for ramdisks are deprecated,"" "" please fix your .its file!\n""); if (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) { puts(""Subimage data is not a FDT""); return -ENOEXEC; } bootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD); *datap = load; *lenp = len; if (fit_unamep) *fit_unamep = (char *)fit_uname; if (fit_uname_configp) *fit_uname_configp = (char *)(fit_uname_config ? : fit_base_uname_config); return noffset; }"
441,4667----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/apeproperties.cpp----APE::Properties::analyzeCurrent,"void APE::Properties::analyzeCurrent() { d->file->seek(2, File::Current); ByteVector descriptor = d->file->readBlock(44); uint descriptorBytes = descriptor.mid(0,4).toUInt(false); if ((descriptorBytes - 52) > 0) d->file->seek(descriptorBytes - 52, File::Current); ByteVector header = d->file->readBlock(24); d->channels = header.mid(18, 2).toShort(false); d->sampleRate = header.mid(20, 4).toUInt(false); d->bitsPerSample = header.mid(16, 2).toShort(false); uint totalFrames = header.mid(12, 4).toUInt(false); uint blocksPerFrame = header.mid(4, 4).toUInt(false); uint finalFrameBlocks = header.mid(8, 4).toUInt(false); uint totalBlocks = totalFrames > 0 ? (totalFrames - 1) * blocksPerFrame + finalFrameBlocks : 0; <S2SV_StartVul> d->length = totalBlocks / d->sampleRate; <S2SV_EndVul> d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0; }","- d->length = totalBlocks / d->sampleRate;
+ d->length = d->sampleRate > 0 ? totalBlocks / d->sampleRate : 0;","void APE::Properties::analyzeCurrent() { d->file->seek(2, File::Current); ByteVector descriptor = d->file->readBlock(44); uint descriptorBytes = descriptor.mid(0,4).toUInt(false); if ((descriptorBytes - 52) > 0) d->file->seek(descriptorBytes - 52, File::Current); ByteVector header = d->file->readBlock(24); d->channels = header.mid(18, 2).toShort(false); d->sampleRate = header.mid(20, 4).toUInt(false); d->bitsPerSample = header.mid(16, 2).toShort(false); uint totalFrames = header.mid(12, 4).toUInt(false); uint blocksPerFrame = header.mid(4, 4).toUInt(false); uint finalFrameBlocks = header.mid(8, 4).toUInt(false); uint totalBlocks = totalFrames > 0 ? (totalFrames - 1) * blocksPerFrame + finalFrameBlocks : 0; d->length = d->sampleRate > 0 ? totalBlocks / d->sampleRate : 0; d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0; }"
442,4162----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spnego_mech.c----spnego_gss_get_mic_iov_length,"spnego_gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count) { <S2SV_StartVul> return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov, <S2SV_EndVul> iov_count); }","- return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,
+ spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+ if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+ return (GSS_S_NO_CONTEXT);
+ return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,","spnego_gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count) { spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle; if (sc->ctx_handle == GSS_C_NO_CONTEXT) return (GSS_S_NO_CONTEXT); return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov, iov_count); }"
443,6475----CWE-79----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mod_auth_openidc.c----oidc_request_post_preserved_restore,"static int oidc_request_post_preserved_restore(request_rec *r, const char *original_url) { oidc_debug(r, ""enter: original_url=%s"", original_url); const char *method = ""postOnLoad""; const char *script = apr_psprintf(r->pool, "" <script type=\""text/javascript\"">\n"" "" function str_decode(string) {\n"" "" try {\n"" "" result = decodeURIComponent(string);\n"" "" } catch (e) {\n"" "" result = unescape(string);\n"" "" }\n"" "" return result;\n"" "" }\n"" "" function %s() {\n"" "" var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\n"" "" sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\n"" "" for (var key in mod_auth_openidc_preserve_post_params) {\n"" "" var input = document.createElement(\""input\"");\n"" "" input.name = str_decode(key);\n"" "" input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\n"" "" input.type = \""hidden\"";\n"" "" document.forms[0].appendChild(input);\n"" "" }\n"" "" document.forms[0].action = \""%s\"";\n"" "" document.forms[0].submit();\n"" "" }\n"" <S2SV_StartVul> "" </script>\n"", method, original_url); <S2SV_EndVul> const char *body = "" <p>Restoring...</p>\n"" "" <form method=\""post\""></form>\n""; return oidc_util_html_send(r, ""Restoring..."", script, method, body, OK); }","- "" </script>\n"", method, original_url);
+ "" </script>\n"", method, oidc_util_javascript_escape(r->pool, original_url));","static int oidc_request_post_preserved_restore(request_rec *r, const char *original_url) { oidc_debug(r, ""enter: original_url=%s"", original_url); const char *method = ""postOnLoad""; const char *script = apr_psprintf(r->pool, "" <script type=\""text/javascript\"">\n"" "" function str_decode(string) {\n"" "" try {\n"" "" result = decodeURIComponent(string);\n"" "" } catch (e) {\n"" "" result = unescape(string);\n"" "" }\n"" "" return result;\n"" "" }\n"" "" function %s() {\n"" "" var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\n"" "" sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\n"" "" for (var key in mod_auth_openidc_preserve_post_params) {\n"" "" var input = document.createElement(\""input\"");\n"" "" input.name = str_decode(key);\n"" "" input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\n"" "" input.type = \""hidden\"";\n"" "" document.forms[0].appendChild(input);\n"" "" }\n"" "" document.forms[0].action = \""%s\"";\n"" "" document.forms[0].submit();\n"" "" }\n"" "" </script>\n"", method, oidc_util_javascript_escape(r->pool, original_url)); const char *body = "" <p>Restoring...</p>\n"" "" <form method=\""post\""></form>\n""; return oidc_util_html_send(r, ""Restoring..."", script, method, body, OK); }"
444,5434----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rtl8150.c----set_registers,"<S2SV_StartVul> static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data) <S2SV_EndVul> { <S2SV_StartVul> return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0), <S2SV_EndVul> <S2SV_StartVul> RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE, <S2SV_EndVul> <S2SV_StartVul> indx, 0, data, size, 500); <S2SV_EndVul> }","- static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
- return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
- RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
- indx, 0, data, size, 500);
+ static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)
+ void *buf;
+ int ret;
+ buf = kmemdup(data, size, GFP_NOIO);
+ if (!buf)
+ return -ENOMEM;
+ ret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
+ RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
+ indx, 0, buf, size, 500);
+ kfree(buf);
+ return ret;","static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data) { void *buf; int ret; buf = kmemdup(data, size, GFP_NOIO); if (!buf) return -ENOMEM; ret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0), RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE, indx, 0, buf, size, 500); kfree(buf); return ret; }"
445,1145--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8816--hub.c----hub_activate,"static void hub_activate(struct usb_hub *hub, enum hub_activation_type type) { struct usb_device *hdev = hub->hdev; struct usb_hcd *hcd; int ret; int port1; int status; bool need_debounce_delay = false; unsigned delay; <S2SV_StartVul> if (type == HUB_INIT2) <S2SV_EndVul> <S2SV_StartVul> goto init2; <S2SV_EndVul> <S2SV_StartVul> if (type == HUB_INIT3) <S2SV_EndVul> goto init3; if (type != HUB_RESUME) { if (hdev->parent && hub_is_superspeed(hdev)) { ret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0), HUB_SET_DEPTH, USB_RT_HUB, hdev->level - 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT); if (ret < 0) dev_err(hub->intfdev, ""set hub depth failed\n""); } if (type == HUB_INIT) { delay = hub_power_on_good_delay(hub); hub_power_on(hub, false); INIT_DELAYED_WORK(&hub->init_work, hub_init_func2); queue_delayed_work(system_power_efficient_wq, &hub->init_work, msecs_to_jiffies(delay)); usb_autopm_get_interface_no_resume( to_usb_interface(hub->intfdev)); return; } else if (type == HUB_RESET_RESUME) { hcd = bus_to_hcd(hdev->bus); if (hcd->driver->update_hub_device) { ret = hcd->driver->update_hub_device(hcd, hdev, &hub->tt, GFP_NOIO); if (ret < 0) { dev_err(hub->intfdev, ""Host not "" ""accepting hub info "" ""update.\n""); dev_err(hub->intfdev, ""LS/FS devices "" ""and hubs may not work "" ""under this hub\n.""); } } hub_power_on(hub, true); } else { hub_power_on(hub, true); } } init2: for (port1 = 1; port1 <= hdev->maxchild; ++port1) { struct usb_port *port_dev = hub->ports[port1 - 1]; struct usb_device *udev = port_dev->child; u16 portstatus, portchange; portstatus = portchange = 0; status = hub_port_status(hub, port1, &portstatus, &portchange); if (udev || (portstatus & USB_PORT_STAT_CONNECTION)) dev_dbg(&port_dev->dev, ""status %04x change %04x\n"", portstatus, portchange); if ((portstatus & USB_PORT_STAT_ENABLE) && ( type != HUB_RESUME || !(portstatus & USB_PORT_STAT_CONNECTION) || !udev || udev->state == USB_STATE_NOTATTACHED)) { portstatus &= ~USB_PORT_STAT_ENABLE; if (!hub_is_superspeed(hdev)) usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE); } if (portchange & USB_PORT_STAT_C_CONNECTION) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_CONNECTION); } if (portchange & USB_PORT_STAT_C_ENABLE) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_ENABLE); } if (portchange & USB_PORT_STAT_C_RESET) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_RESET); } if ((portchange & USB_PORT_STAT_C_BH_RESET) && hub_is_superspeed(hub->hdev)) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_BH_PORT_RESET); } if (!(portstatus & USB_PORT_STAT_CONNECTION) || (portchange & USB_PORT_STAT_C_CONNECTION)) clear_bit(port1, hub->removed_bits); if (!udev || udev->state == USB_STATE_NOTATTACHED) { if (udev || (portstatus & USB_PORT_STAT_CONNECTION) || (portstatus & USB_PORT_STAT_OVERCURRENT)) set_bit(port1, hub->change_bits); } else if (portstatus & USB_PORT_STAT_ENABLE) { bool port_resumed = (portstatus & USB_PORT_STAT_LINK_STATE) == USB_SS_PORT_LS_U0; if (portchange || (hub_is_superspeed(hub->hdev) && port_resumed)) set_bit(port1, hub->change_bits); } else if (udev->persist_enabled) { #ifdef CONFIG_PM udev->reset_resume = 1; #endif if (test_bit(port1, hub->power_bits)) set_bit(port1, hub->change_bits); } else { usb_set_device_state(udev, USB_STATE_NOTATTACHED); set_bit(port1, hub->change_bits); } } if (need_debounce_delay) { delay = HUB_DEBOUNCE_STABLE; if (type == HUB_INIT2) { INIT_DELAYED_WORK(&hub->init_work, hub_init_func3); queue_delayed_work(system_power_efficient_wq, &hub->init_work, msecs_to_jiffies(delay)); return; } else { msleep(delay); } } init3: hub->quiescing = 0; status = usb_submit_urb(hub->urb, GFP_NOIO); if (status < 0) dev_err(hub->intfdev, ""activate --> %d\n"", status); if (hub->has_indicators && blinkenlights) queue_delayed_work(system_power_efficient_wq, &hub->leds, LED_CYCLE_PERIOD); kick_hub_wq(hub); if (type <= HUB_INIT3) usb_autopm_put_interface_async(to_usb_interface(hub->intfdev)); }","- if (type == HUB_INIT2)
- goto init2;
- if (type == HUB_INIT3)
+ if (type == HUB_INIT2 || type == HUB_INIT3) {
+ device_lock(hub->intfdev);
+ if (hub->disconnected) {
+ device_unlock(hub->intfdev);
+ kref_put(&hub->kref, hub_release);
+ return;
+ }
+ if (type == HUB_INIT2)
+ goto init2;
+ }
+ kref_get(&hub->kref);
+ device_unlock(hub->intfdev);
+ if (type == HUB_INIT2 || type == HUB_INIT3)
+ device_unlock(hub->intfdev);
+ kref_put(&hub->kref, hub_release);","static void hub_activate(struct usb_hub *hub, enum hub_activation_type type) { struct usb_device *hdev = hub->hdev; struct usb_hcd *hcd; int ret; int port1; int status; bool need_debounce_delay = false; unsigned delay; if (type == HUB_INIT2 || type == HUB_INIT3) { device_lock(hub->intfdev); if (hub->disconnected) { device_unlock(hub->intfdev); kref_put(&hub->kref, hub_release); return; } if (type == HUB_INIT2) goto init2; goto init3; } kref_get(&hub->kref); if (type != HUB_RESUME) { if (hdev->parent && hub_is_superspeed(hdev)) { ret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0), HUB_SET_DEPTH, USB_RT_HUB, hdev->level - 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT); if (ret < 0) dev_err(hub->intfdev, ""set hub depth failed\n""); } if (type == HUB_INIT) { delay = hub_power_on_good_delay(hub); hub_power_on(hub, false); INIT_DELAYED_WORK(&hub->init_work, hub_init_func2); queue_delayed_work(system_power_efficient_wq, &hub->init_work, msecs_to_jiffies(delay)); usb_autopm_get_interface_no_resume( to_usb_interface(hub->intfdev)); return; } else if (type == HUB_RESET_RESUME) { hcd = bus_to_hcd(hdev->bus); if (hcd->driver->update_hub_device) { ret = hcd->driver->update_hub_device(hcd, hdev, &hub->tt, GFP_NOIO); if (ret < 0) { dev_err(hub->intfdev, ""Host not "" ""accepting hub info "" ""update.\n""); dev_err(hub->intfdev, ""LS/FS devices "" ""and hubs may not work "" ""under this hub\n.""); } } hub_power_on(hub, true); } else { hub_power_on(hub, true); } } init2: for (port1 = 1; port1 <= hdev->maxchild; ++port1) { struct usb_port *port_dev = hub->ports[port1 - 1]; struct usb_device *udev = port_dev->child; u16 portstatus, portchange; portstatus = portchange = 0; status = hub_port_status(hub, port1, &portstatus, &portchange); if (udev || (portstatus & USB_PORT_STAT_CONNECTION)) dev_dbg(&port_dev->dev, ""status %04x change %04x\n"", portstatus, portchange); if ((portstatus & USB_PORT_STAT_ENABLE) && ( type != HUB_RESUME || !(portstatus & USB_PORT_STAT_CONNECTION) || !udev || udev->state == USB_STATE_NOTATTACHED)) { portstatus &= ~USB_PORT_STAT_ENABLE; if (!hub_is_superspeed(hdev)) usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE); } if (portchange & USB_PORT_STAT_C_CONNECTION) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_CONNECTION); } if (portchange & USB_PORT_STAT_C_ENABLE) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_ENABLE); } if (portchange & USB_PORT_STAT_C_RESET) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_RESET); } if ((portchange & USB_PORT_STAT_C_BH_RESET) && hub_is_superspeed(hub->hdev)) { need_debounce_delay = true; usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_C_BH_PORT_RESET); } if (!(portstatus & USB_PORT_STAT_CONNECTION) || (portchange & USB_PORT_STAT_C_CONNECTION)) clear_bit(port1, hub->removed_bits); if (!udev || udev->state == USB_STATE_NOTATTACHED) { if (udev || (portstatus & USB_PORT_STAT_CONNECTION) || (portstatus & USB_PORT_STAT_OVERCURRENT)) set_bit(port1, hub->change_bits); } else if (portstatus & USB_PORT_STAT_ENABLE) { bool port_resumed = (portstatus & USB_PORT_STAT_LINK_STATE) == USB_SS_PORT_LS_U0; if (portchange || (hub_is_superspeed(hub->hdev) && port_resumed)) set_bit(port1, hub->change_bits); } else if (udev->persist_enabled) { #ifdef CONFIG_PM udev->reset_resume = 1; #endif if (test_bit(port1, hub->power_bits)) set_bit(port1, hub->change_bits); } else { usb_set_device_state(udev, USB_STATE_NOTATTACHED); set_bit(port1, hub->change_bits); } } if (need_debounce_delay) { delay = HUB_DEBOUNCE_STABLE; if (type == HUB_INIT2) { INIT_DELAYED_WORK(&hub->init_work, hub_init_func3); queue_delayed_work(system_power_efficient_wq, &hub->init_work, msecs_to_jiffies(delay)); device_unlock(hub->intfdev); return; } else { msleep(delay); } } init3: hub->quiescing = 0; status = usb_submit_urb(hub->urb, GFP_NOIO); if (status < 0) dev_err(hub->intfdev, ""activate --> %d\n"", status); if (hub->has_indicators && blinkenlights) queue_delayed_work(system_power_efficient_wq, &hub->leds, LED_CYCLE_PERIOD); kick_hub_wq(hub); if (type <= HUB_INIT3) usb_autopm_put_interface_async(to_usb_interface(hub->intfdev)); if (type == HUB_INIT2 || type == HUB_INIT3) device_unlock(hub->intfdev); kref_put(&hub->kref, hub_release); }"
446,3438----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/libmeshb7.c----GmfOpenMesh,"int64_t GmfOpenMesh(const char *FilNam, int mod, ...) { int KwdCod, res, *PtrVer, *PtrDim, err; int64_t MshIdx; char str[ GmfStrSiz ]; va_list VarArg; GmfMshSct *msh; if(!(msh = calloc(1, sizeof(GmfMshSct)))) return(0); MshIdx = (int64_t)msh; if( (err = setjmp(msh->err)) != 0) { #ifdef GMFDEBUG printf(""libMeshb : mesh %p : error %d\n"", msh, err); #endif if(msh->hdl != NULL) fclose(msh->hdl); if(msh->FilDes != 0) #ifdef GMF_WINDOWS _close(msh->FilDes); #else close(msh->FilDes); #endif free(msh); return(0); } if(strlen(FilNam) + 7 >= GmfStrSiz) longjmp(msh->err, -4); strcpy(msh->FilNam, FilNam); msh->mod = mod; msh->buf = (void *)msh->DblBuf; msh->FltBuf = (void *)msh->DblBuf; msh->IntBuf = (void *)msh->DblBuf; if(strstr(msh->FilNam, "".meshb"")) msh->typ |= (Bin | MshFil); else if(strstr(msh->FilNam, "".mesh"")) msh->typ |= (Asc | MshFil); else if(strstr(msh->FilNam, "".solb"")) msh->typ |= (Bin | SolFil); else if(strstr(msh->FilNam, "".sol"")) msh->typ |= (Asc | SolFil); else longjmp(msh->err, -5); if(msh->mod == GmfRead) { va_start(VarArg, mod); PtrVer = va_arg(VarArg, int *); PtrDim = va_arg(VarArg, int *); va_end(VarArg); if(msh->typ & Bin) { #ifdef WITH_GMF_AIO msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE); if(msh->FilDes <= 0) longjmp(msh->err, -6); if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz) longjmp(msh->err, -7); #else if(!(msh->hdl = fopen(msh->FilNam, ""rb""))) longjmp(msh->err, -8); safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err); #endif if( (msh->cod != 1) && (msh->cod != 16777216) ) longjmp(msh->err, -9); ScaWrd(msh, (unsigned char *)&msh->ver); if( (msh->ver < 1) || (msh->ver > 4) ) longjmp(msh->err, -10); if( (msh->ver >= 3) && (sizeof(int64_t) != 8) ) longjmp(msh->err, -11); ScaWrd(msh, (unsigned char *)&KwdCod); if(KwdCod != GmfDimension) longjmp(msh->err, -12); GetPos(msh); ScaWrd(msh, (unsigned char *)&msh->dim); } else { if(!(msh->hdl = fopen(msh->FilNam, ""rb""))) longjmp(msh->err, -13); do { <S2SV_StartVul> res = fscanf(msh->hdl, ""%s"", str); <S2SV_EndVul> }while( (res != EOF) && strcmp(str, ""MeshVersionFormatted"") ); if(res == EOF) longjmp(msh->err, -14); safe_fscanf(msh->hdl, ""%d"", &msh->ver, msh->err); if( (msh->ver < 1) || (msh->ver > 4) ) longjmp(msh->err, -15); do { <S2SV_StartVul> res = fscanf(msh->hdl, ""%s"", str); <S2SV_EndVul> }while( (res != EOF) && strcmp(str, ""Dimension"") ); if(res == EOF) longjmp(msh->err, -16); safe_fscanf(msh->hdl, ""%d"", &msh->dim, msh->err); } if( (msh->dim != 2) && (msh->dim != 3) ) longjmp(msh->err, -17); (*PtrVer) = msh->ver; (*PtrDim) = msh->dim; if(msh->ver == 1) msh->FltSiz = 32; else msh->FltSiz = 64; if(!ScaKwdTab(msh)) return(0); return(MshIdx); } else if(msh->mod == GmfWrite) { msh->cod = 1; va_start(VarArg, mod); msh->ver = va_arg(VarArg, int); msh->dim = va_arg(VarArg, int); va_end(VarArg); if( (msh->ver < 1) || (msh->ver > 4) ) longjmp(msh->err, -18); if( (msh->ver >= 3) && (sizeof(int64_t) != 8) ) longjmp(msh->err, -19); if( (msh->dim != 2) && (msh->dim != 3) ) longjmp(msh->err, -20); if(msh->ver == 1) msh->FltSiz = 32; else msh->FltSiz = 64; if(msh->typ & Bin) { #ifdef WITH_GMF_AIO msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE); if(msh->FilDes <= 0) longjmp(msh->err, -21); #else if(!(msh->hdl = fopen(msh->FilNam, ""wb""))) longjmp(msh->err, -22); #endif } else if(!(msh->hdl = fopen(msh->FilNam, ""wb""))) longjmp(msh->err, -23); if(msh->typ & Asc) { fprintf(msh->hdl, ""%s %d\n\n"", GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver); fprintf(msh->hdl, ""%s %d\n"", GmfKwdFmt[ GmfDimension ][0], msh->dim); } else { RecWrd(msh, (unsigned char *)&msh->cod); RecWrd(msh, (unsigned char *)&msh->ver); GmfSetKwd(MshIdx, GmfDimension, 0); RecWrd(msh, (unsigned char *)&msh->dim); } return(MshIdx); } else { free(msh); return(0); } }","- res = fscanf(msh->hdl, ""%s"", str);
- res = fscanf(msh->hdl, ""%s"", str);
+ res = fscanf(msh->hdl, ""%100s"", str);
+ res = fscanf(msh->hdl, ""%100s"", str);","int64_t GmfOpenMesh(const char *FilNam, int mod, ...) { int KwdCod, res, *PtrVer, *PtrDim, err; int64_t MshIdx; char str[ GmfStrSiz ]; va_list VarArg; GmfMshSct *msh; if(!(msh = calloc(1, sizeof(GmfMshSct)))) return(0); MshIdx = (int64_t)msh; if( (err = setjmp(msh->err)) != 0) { #ifdef GMFDEBUG printf(""libMeshb : mesh %p : error %d\n"", msh, err); #endif if(msh->hdl != NULL) fclose(msh->hdl); if(msh->FilDes != 0) #ifdef GMF_WINDOWS _close(msh->FilDes); #else close(msh->FilDes); #endif free(msh); return(0); } if(strlen(FilNam) + 7 >= GmfStrSiz) longjmp(msh->err, -4); strcpy(msh->FilNam, FilNam); msh->mod = mod; msh->buf = (void *)msh->DblBuf; msh->FltBuf = (void *)msh->DblBuf; msh->IntBuf = (void *)msh->DblBuf; if(strstr(msh->FilNam, "".meshb"")) msh->typ |= (Bin | MshFil); else if(strstr(msh->FilNam, "".mesh"")) msh->typ |= (Asc | MshFil); else if(strstr(msh->FilNam, "".solb"")) msh->typ |= (Bin | SolFil); else if(strstr(msh->FilNam, "".sol"")) msh->typ |= (Asc | SolFil); else longjmp(msh->err, -5); if(msh->mod == GmfRead) { va_start(VarArg, mod); PtrVer = va_arg(VarArg, int *); PtrDim = va_arg(VarArg, int *); va_end(VarArg); if(msh->typ & Bin) { #ifdef WITH_GMF_AIO msh->FilDes = open(msh->FilNam, OPEN_READ_FLAGS, OPEN_READ_MODE); if(msh->FilDes <= 0) longjmp(msh->err, -6); if(read(msh->FilDes, &msh->cod, WrdSiz) != WrdSiz) longjmp(msh->err, -7); #else if(!(msh->hdl = fopen(msh->FilNam, ""rb""))) longjmp(msh->err, -8); safe_fread(&msh->cod, WrdSiz, 1, msh->hdl, msh->err); #endif if( (msh->cod != 1) && (msh->cod != 16777216) ) longjmp(msh->err, -9); ScaWrd(msh, (unsigned char *)&msh->ver); if( (msh->ver < 1) || (msh->ver > 4) ) longjmp(msh->err, -10); if( (msh->ver >= 3) && (sizeof(int64_t) != 8) ) longjmp(msh->err, -11); ScaWrd(msh, (unsigned char *)&KwdCod); if(KwdCod != GmfDimension) longjmp(msh->err, -12); GetPos(msh); ScaWrd(msh, (unsigned char *)&msh->dim); } else { if(!(msh->hdl = fopen(msh->FilNam, ""rb""))) longjmp(msh->err, -13); do { res = fscanf(msh->hdl, ""%100s"", str); }while( (res != EOF) && strcmp(str, ""MeshVersionFormatted"") ); if(res == EOF) longjmp(msh->err, -14); safe_fscanf(msh->hdl, ""%d"", &msh->ver, msh->err); if( (msh->ver < 1) || (msh->ver > 4) ) longjmp(msh->err, -15); do { res = fscanf(msh->hdl, ""%100s"", str); }while( (res != EOF) && strcmp(str, ""Dimension"") ); if(res == EOF) longjmp(msh->err, -16); safe_fscanf(msh->hdl, ""%d"", &msh->dim, msh->err); } if( (msh->dim != 2) && (msh->dim != 3) ) longjmp(msh->err, -17); (*PtrVer) = msh->ver; (*PtrDim) = msh->dim; if(msh->ver == 1) msh->FltSiz = 32; else msh->FltSiz = 64; if(!ScaKwdTab(msh)) return(0); return(MshIdx); } else if(msh->mod == GmfWrite) { msh->cod = 1; va_start(VarArg, mod); msh->ver = va_arg(VarArg, int); msh->dim = va_arg(VarArg, int); va_end(VarArg); if( (msh->ver < 1) || (msh->ver > 4) ) longjmp(msh->err, -18); if( (msh->ver >= 3) && (sizeof(int64_t) != 8) ) longjmp(msh->err, -19); if( (msh->dim != 2) && (msh->dim != 3) ) longjmp(msh->err, -20); if(msh->ver == 1) msh->FltSiz = 32; else msh->FltSiz = 64; if(msh->typ & Bin) { #ifdef WITH_GMF_AIO msh->FilDes = open(msh->FilNam, OPEN_WRITE_FLAGS, OPEN_WRITE_MODE); if(msh->FilDes <= 0) longjmp(msh->err, -21); #else if(!(msh->hdl = fopen(msh->FilNam, ""wb""))) longjmp(msh->err, -22); #endif } else if(!(msh->hdl = fopen(msh->FilNam, ""wb""))) longjmp(msh->err, -23); if(msh->typ & Asc) { fprintf(msh->hdl, ""%s %d\n\n"", GmfKwdFmt[ GmfVersionFormatted ][0], msh->ver); fprintf(msh->hdl, ""%s %d\n"", GmfKwdFmt[ GmfDimension ][0], msh->dim); } else { RecWrd(msh, (unsigned char *)&msh->cod); RecWrd(msh, (unsigned char *)&msh->ver); GmfSetKwd(MshIdx, GmfDimension, 0); RecWrd(msh, (unsigned char *)&msh->dim); } return(MshIdx); } else { free(msh); return(0); } }"
447,4891----CWE-200----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/main.c----set_umask,"set_umask(const char *optarg) { long umask_long; mode_t umask_val; char *endptr; umask_long = strtoll(optarg, &endptr, 0); if (*endptr || umask_long < 0 || umask_long & ~0777L) { fprintf(stderr, ""Invalid --umask option %s"", optarg); <S2SV_StartVul> return; <S2SV_EndVul> } umask_val = umask_long & 0777; umask(umask_val); umask_cmdline = true; return umask_val; }","- return;
+ return 0;","set_umask(const char *optarg) { long umask_long; mode_t umask_val; char *endptr; umask_long = strtoll(optarg, &endptr, 0); if (*endptr || umask_long < 0 || umask_long & ~0777L) { fprintf(stderr, ""Invalid --umask option %s"", optarg); return 0; } umask_val = umask_long & 0777; umask(umask_val); umask_cmdline = true; return umask_val; }"
448,4332----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/option.c----paste_option_changed,"paste_option_changed(void) { static int old_p_paste = FALSE; static int save_sm = 0; static int save_sta = 0; #ifdef FEAT_CMDL_INFO static int save_ru = 0; #endif #ifdef FEAT_RIGHTLEFT static int save_ri = 0; static int save_hkmap = 0; #endif buf_T *buf; if (p_paste) { if (!old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw_nopaste = buf->b_p_tw; buf->b_p_wm_nopaste = buf->b_p_wm; buf->b_p_sts_nopaste = buf->b_p_sts; buf->b_p_ai_nopaste = buf->b_p_ai; buf->b_p_et_nopaste = buf->b_p_et; #ifdef FEAT_VARTABS if (buf->b_p_vsts_nopaste) vim_free(buf->b_p_vsts_nopaste); buf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option ? vim_strsave(buf->b_p_vsts) : NULL; #endif } save_sm = p_sm; save_sta = p_sta; #ifdef FEAT_CMDL_INFO save_ru = p_ru; #endif #ifdef FEAT_RIGHTLEFT save_ri = p_ri; save_hkmap = p_hkmap; #endif p_ai_nopaste = p_ai; p_et_nopaste = p_et; p_sts_nopaste = p_sts; p_tw_nopaste = p_tw; p_wm_nopaste = p_wm; #ifdef FEAT_VARTABS if (p_vsts_nopaste) vim_free(p_vsts_nopaste); p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL; #endif } FOR_ALL_BUFFERS(buf) { buf->b_p_tw = 0; buf->b_p_wm = 0; buf->b_p_sts = 0; buf->b_p_ai = 0; buf->b_p_et = 0; #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = empty_option; <S2SV_StartVul> if (buf->b_p_vsts_array) <S2SV_EndVul> <S2SV_StartVul> vim_free(buf->b_p_vsts_array); <S2SV_EndVul> <S2SV_StartVul> buf->b_p_vsts_array = 0; <S2SV_EndVul> #endif } p_sm = 0; p_sta = 0; #ifdef FEAT_CMDL_INFO if (p_ru) status_redraw_all(); p_ru = 0; #endif #ifdef FEAT_RIGHTLEFT p_ri = 0; p_hkmap = 0; #endif p_tw = 0; p_wm = 0; p_sts = 0; p_ai = 0; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = empty_option; #endif } else if (old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw = buf->b_p_tw_nopaste; buf->b_p_wm = buf->b_p_wm_nopaste; buf->b_p_sts = buf->b_p_sts_nopaste; buf->b_p_ai = buf->b_p_ai_nopaste; buf->b_p_et = buf->b_p_et_nopaste; #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = buf->b_p_vsts_nopaste ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option; <S2SV_StartVul> if (buf->b_p_vsts_array) <S2SV_EndVul> <S2SV_StartVul> vim_free(buf->b_p_vsts_array); <S2SV_EndVul> if (buf->b_p_vsts && buf->b_p_vsts != empty_option) (void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array); else <S2SV_StartVul> buf->b_p_vsts_array = 0; <S2SV_EndVul> #endif } p_sm = save_sm; p_sta = save_sta; #ifdef FEAT_CMDL_INFO if (p_ru != save_ru) status_redraw_all(); p_ru = save_ru; #endif #ifdef FEAT_RIGHTLEFT p_ri = save_ri; p_hkmap = save_hkmap; #endif p_ai = p_ai_nopaste; p_et = p_et_nopaste; p_sts = p_sts_nopaste; p_tw = p_tw_nopaste; p_wm = p_wm_nopaste; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option; #endif } old_p_paste = p_paste; }","- if (buf->b_p_vsts_array)
- vim_free(buf->b_p_vsts_array);
- buf->b_p_vsts_array = 0;
- if (buf->b_p_vsts_array)
- vim_free(buf->b_p_vsts_array);
- buf->b_p_vsts_array = 0;
+ VIM_CLEAR(buf->b_p_vsts_array);
+ vim_free(buf->b_p_vsts_array);
+ buf->b_p_vsts_array = NULL;","paste_option_changed(void) { static int old_p_paste = FALSE; static int save_sm = 0; static int save_sta = 0; #ifdef FEAT_CMDL_INFO static int save_ru = 0; #endif #ifdef FEAT_RIGHTLEFT static int save_ri = 0; static int save_hkmap = 0; #endif buf_T *buf; if (p_paste) { if (!old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw_nopaste = buf->b_p_tw; buf->b_p_wm_nopaste = buf->b_p_wm; buf->b_p_sts_nopaste = buf->b_p_sts; buf->b_p_ai_nopaste = buf->b_p_ai; buf->b_p_et_nopaste = buf->b_p_et; #ifdef FEAT_VARTABS if (buf->b_p_vsts_nopaste) vim_free(buf->b_p_vsts_nopaste); buf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option ? vim_strsave(buf->b_p_vsts) : NULL; #endif } save_sm = p_sm; save_sta = p_sta; #ifdef FEAT_CMDL_INFO save_ru = p_ru; #endif #ifdef FEAT_RIGHTLEFT save_ri = p_ri; save_hkmap = p_hkmap; #endif p_ai_nopaste = p_ai; p_et_nopaste = p_et; p_sts_nopaste = p_sts; p_tw_nopaste = p_tw; p_wm_nopaste = p_wm; #ifdef FEAT_VARTABS if (p_vsts_nopaste) vim_free(p_vsts_nopaste); p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL; #endif } FOR_ALL_BUFFERS(buf) { buf->b_p_tw = 0; buf->b_p_wm = 0; buf->b_p_sts = 0; buf->b_p_ai = 0; buf->b_p_et = 0; #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = empty_option; VIM_CLEAR(buf->b_p_vsts_array); #endif } p_sm = 0; p_sta = 0; #ifdef FEAT_CMDL_INFO if (p_ru) status_redraw_all(); p_ru = 0; #endif #ifdef FEAT_RIGHTLEFT p_ri = 0; p_hkmap = 0; #endif p_tw = 0; p_wm = 0; p_sts = 0; p_ai = 0; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = empty_option; #endif } else if (old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw = buf->b_p_tw_nopaste; buf->b_p_wm = buf->b_p_wm_nopaste; buf->b_p_sts = buf->b_p_sts_nopaste; buf->b_p_ai = buf->b_p_ai_nopaste; buf->b_p_et = buf->b_p_et_nopaste; #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = buf->b_p_vsts_nopaste ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option; vim_free(buf->b_p_vsts_array); if (buf->b_p_vsts && buf->b_p_vsts != empty_option) (void)tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array); else buf->b_p_vsts_array = NULL; #endif } p_sm = save_sm; p_sta = save_sta; #ifdef FEAT_CMDL_INFO if (p_ru != save_ru) status_redraw_all(); p_ru = save_ru; #endif #ifdef FEAT_RIGHTLEFT p_ri = save_ri; p_hkmap = save_hkmap; #endif p_ai = p_ai_nopaste; p_et = p_et_nopaste; p_sts = p_sts_nopaste; p_tw = p_tw_nopaste; p_wm = p_wm_nopaste; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option; #endif } old_p_paste = p_paste; }"
449,9----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-1000037--pdf-interpret.c----pdf_process_extgstate,"pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict) { pdf_obj *obj; obj = pdf_dict_get(ctx, dict, PDF_NAME_LW); if (pdf_is_number(ctx, obj) && proc->op_w) proc->op_w(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_LC); if (pdf_is_int(ctx, obj) && proc->op_J) proc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2)); obj = pdf_dict_get(ctx, dict, PDF_NAME_LJ); if (pdf_is_int(ctx, obj) && proc->op_j) proc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2)); obj = pdf_dict_get(ctx, dict, PDF_NAME_ML); if (pdf_is_number(ctx, obj) && proc->op_M) proc->op_M(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_D); if (pdf_is_array(ctx, obj) && proc->op_d) { pdf_obj *dash_array = pdf_array_get(ctx, obj, 0); pdf_obj *dash_phase = pdf_array_get(ctx, obj, 1); proc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase)); } obj = pdf_dict_get(ctx, dict, PDF_NAME_RI); if (pdf_is_name(ctx, obj) && proc->op_ri) proc->op_ri(ctx, proc, pdf_to_name(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_FL); if (pdf_is_number(ctx, obj) && proc->op_i) proc->op_i(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_Font); if (pdf_is_array(ctx, obj) && proc->op_Tf) { pdf_obj *font_ref = pdf_array_get(ctx, obj, 0); pdf_obj *font_size = pdf_array_get(ctx, obj, 1); pdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie); fz_try(ctx) proc->op_Tf(ctx, proc, ""ExtGState"", font, pdf_to_real(ctx, font_size)); fz_always(ctx) pdf_drop_font(ctx, font); fz_catch(ctx) fz_rethrow(ctx); } obj = pdf_dict_get(ctx, dict, PDF_NAME_OP); if (pdf_is_bool(ctx, obj) && proc->op_gs_OP) proc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_op); if (pdf_is_bool(ctx, obj) && proc->op_gs_op) proc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_OPM); if (pdf_is_int(ctx, obj) && proc->op_gs_OPM) proc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp); if (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp) proc->op_gs_UseBlackPtComp(ctx, proc, obj); obj = pdf_dict_get(ctx, dict, PDF_NAME_TR2); if (pdf_is_name(ctx, obj)) if (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default)) fz_warn(ctx, ""ignoring transfer function""); if (!obj) { pdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR); if (pdf_is_name(ctx, tr)) if (!pdf_name_eq(ctx, tr, PDF_NAME_Identity)) fz_warn(ctx, ""ignoring transfer function""); } obj = pdf_dict_get(ctx, dict, PDF_NAME_CA); if (pdf_is_number(ctx, obj) && proc->op_gs_CA) proc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_ca); if (pdf_is_number(ctx, obj) && proc->op_gs_ca) proc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_BM); if (pdf_is_array(ctx, obj)) obj = pdf_array_get(ctx, obj, 0); if (pdf_is_name(ctx, obj) && proc->op_gs_BM) proc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_SMask); if (proc->op_gs_SMask) { if (pdf_is_dict(ctx, obj)) { pdf_xobject *xobj; pdf_obj *group, *s, *bc, *tr; float softmask_bc[FZ_MAX_COLORS]; fz_colorspace *colorspace; int colorspace_n = 1; int k, luminosity; fz_var(xobj); group = pdf_dict_get(ctx, obj, PDF_NAME_G); <S2SV_StartVul> if (!group) <S2SV_EndVul> <S2SV_StartVul> fz_throw(ctx, FZ_ERROR_SYNTAX, ""cannot load softmask xobject (%d 0 R)"", pdf_to_num(ctx, obj)); <S2SV_EndVul> xobj = pdf_load_xobject(ctx, csi->doc, group); fz_try(ctx) { colorspace = pdf_xobject_colorspace(ctx, xobj); if (colorspace) colorspace_n = fz_colorspace_n(ctx, colorspace); for (k = 0; k < colorspace_n; k++) softmask_bc[k] = 0; if (fz_colorspace_is_cmyk(ctx, colorspace)) softmask_bc[3] = 1.0f; fz_drop_colorspace(ctx, colorspace); bc = pdf_dict_get(ctx, obj, PDF_NAME_BC); if (pdf_is_array(ctx, bc)) { for (k = 0; k < colorspace_n; k++) softmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k)); } s = pdf_dict_get(ctx, obj, PDF_NAME_S); if (pdf_name_eq(ctx, s, PDF_NAME_Luminosity)) luminosity = 1; else luminosity = 0; tr = pdf_dict_get(ctx, obj, PDF_NAME_TR); if (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity)) fz_warn(ctx, ""ignoring transfer function""); proc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity); } fz_always(ctx) { pdf_drop_xobject(ctx, xobj); } fz_catch(ctx) { fz_rethrow(ctx); } } else if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None)) { proc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0); } } }","- if (!group)
- fz_throw(ctx, FZ_ERROR_SYNTAX, ""cannot load softmask xobject (%d 0 R)"", pdf_to_num(ctx, obj));","pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict) { pdf_obj *obj; obj = pdf_dict_get(ctx, dict, PDF_NAME_LW); if (pdf_is_number(ctx, obj) && proc->op_w) proc->op_w(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_LC); if (pdf_is_int(ctx, obj) && proc->op_J) proc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2)); obj = pdf_dict_get(ctx, dict, PDF_NAME_LJ); if (pdf_is_int(ctx, obj) && proc->op_j) proc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2)); obj = pdf_dict_get(ctx, dict, PDF_NAME_ML); if (pdf_is_number(ctx, obj) && proc->op_M) proc->op_M(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_D); if (pdf_is_array(ctx, obj) && proc->op_d) { pdf_obj *dash_array = pdf_array_get(ctx, obj, 0); pdf_obj *dash_phase = pdf_array_get(ctx, obj, 1); proc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase)); } obj = pdf_dict_get(ctx, dict, PDF_NAME_RI); if (pdf_is_name(ctx, obj) && proc->op_ri) proc->op_ri(ctx, proc, pdf_to_name(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_FL); if (pdf_is_number(ctx, obj) && proc->op_i) proc->op_i(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_Font); if (pdf_is_array(ctx, obj) && proc->op_Tf) { pdf_obj *font_ref = pdf_array_get(ctx, obj, 0); pdf_obj *font_size = pdf_array_get(ctx, obj, 1); pdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie); fz_try(ctx) proc->op_Tf(ctx, proc, ""ExtGState"", font, pdf_to_real(ctx, font_size)); fz_always(ctx) pdf_drop_font(ctx, font); fz_catch(ctx) fz_rethrow(ctx); } obj = pdf_dict_get(ctx, dict, PDF_NAME_OP); if (pdf_is_bool(ctx, obj) && proc->op_gs_OP) proc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_op); if (pdf_is_bool(ctx, obj) && proc->op_gs_op) proc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_OPM); if (pdf_is_int(ctx, obj) && proc->op_gs_OPM) proc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp); if (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp) proc->op_gs_UseBlackPtComp(ctx, proc, obj); obj = pdf_dict_get(ctx, dict, PDF_NAME_TR2); if (pdf_is_name(ctx, obj)) if (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default)) fz_warn(ctx, ""ignoring transfer function""); if (!obj) { pdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR); if (pdf_is_name(ctx, tr)) if (!pdf_name_eq(ctx, tr, PDF_NAME_Identity)) fz_warn(ctx, ""ignoring transfer function""); } obj = pdf_dict_get(ctx, dict, PDF_NAME_CA); if (pdf_is_number(ctx, obj) && proc->op_gs_CA) proc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_ca); if (pdf_is_number(ctx, obj) && proc->op_gs_ca) proc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_BM); if (pdf_is_array(ctx, obj)) obj = pdf_array_get(ctx, obj, 0); if (pdf_is_name(ctx, obj) && proc->op_gs_BM) proc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_SMask); if (proc->op_gs_SMask) { if (pdf_is_dict(ctx, obj)) { pdf_xobject *xobj; pdf_obj *group, *s, *bc, *tr; float softmask_bc[FZ_MAX_COLORS]; fz_colorspace *colorspace; int colorspace_n = 1; int k, luminosity; fz_var(xobj); group = pdf_dict_get(ctx, obj, PDF_NAME_G); xobj = pdf_load_xobject(ctx, csi->doc, group); fz_try(ctx) { colorspace = pdf_xobject_colorspace(ctx, xobj); if (colorspace) colorspace_n = fz_colorspace_n(ctx, colorspace); for (k = 0; k < colorspace_n; k++) softmask_bc[k] = 0; if (fz_colorspace_is_cmyk(ctx, colorspace)) softmask_bc[3] = 1.0f; fz_drop_colorspace(ctx, colorspace); bc = pdf_dict_get(ctx, obj, PDF_NAME_BC); if (pdf_is_array(ctx, bc)) { for (k = 0; k < colorspace_n; k++) softmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k)); } s = pdf_dict_get(ctx, obj, PDF_NAME_S); if (pdf_name_eq(ctx, s, PDF_NAME_Luminosity)) luminosity = 1; else luminosity = 0; tr = pdf_dict_get(ctx, obj, PDF_NAME_TR); if (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity)) fz_warn(ctx, ""ignoring transfer function""); proc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity); } fz_always(ctx) { pdf_drop_xobject(ctx, xobj); } fz_catch(ctx) { fz_rethrow(ctx); } } else if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None)) { proc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0); } } }"
450,6689----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/math.c----do_fpu_inst,"int do_fpu_inst(unsigned short inst, struct pt_regs *regs) { struct task_struct *tsk = current; struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu); <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0); <S2SV_EndVul> if (!(task_thread_info(tsk)->status & TS_USEDFPU)) { fpu_init(fpu); task_thread_info(tsk)->status |= TS_USEDFPU; } return fpu_emulate(inst, fpu, regs); }","- perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);
+ perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);","int do_fpu_inst(unsigned short inst, struct pt_regs *regs) { struct task_struct *tsk = current; struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu); perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0); if (!(task_thread_info(tsk)->status & TS_USEDFPU)) { fpu_init(fpu); task_thread_info(tsk)->status |= TS_USEDFPU; } return fpu_emulate(inst, fpu, regs); }"
451,2375----CWE-674----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-16300--print-bgp.c----bgp_update_print,"bgp_update_print(netdissect_options *ndo, const u_char *dat, int length) { struct bgp bgp; const u_char *p; int withdrawn_routes_len; int len; int i; ND_TCHECK2(dat[0], BGP_SIZE); if (length < BGP_SIZE) goto trunc; memcpy(&bgp, dat, BGP_SIZE); p = dat + BGP_SIZE; length -= BGP_SIZE; ND_TCHECK2(p[0], 2); if (length < 2) goto trunc; withdrawn_routes_len = EXTRACT_16BITS(p); p += 2; length -= 2; if (withdrawn_routes_len) { ND_TCHECK2(p[0], withdrawn_routes_len); if (length < withdrawn_routes_len) goto trunc; ND_PRINT((ndo, ""\n\t Withdrawn routes: %d bytes"", withdrawn_routes_len)); p += withdrawn_routes_len; length -= withdrawn_routes_len; } ND_TCHECK2(p[0], 2); if (length < 2) goto trunc; len = EXTRACT_16BITS(p); p += 2; length -= 2; if (withdrawn_routes_len == 0 && len == 0 && length == 0) { ND_PRINT((ndo, ""\n\t End-of-Rib Marker (empty NLRI)"")); return; } if (len) { while (len) { int aflags, atype, alenlen, alen; ND_TCHECK2(p[0], 2); if (len < 2) goto trunc; if (length < 2) goto trunc; aflags = *p; atype = *(p + 1); p += 2; len -= 2; length -= 2; alenlen = bgp_attr_lenlen(aflags, p); ND_TCHECK2(p[0], alenlen); if (len < alenlen) goto trunc; if (length < alenlen) goto trunc; alen = bgp_attr_len(aflags, p); p += alenlen; len -= alenlen; length -= alenlen; ND_PRINT((ndo, ""\n\t %s (%u), length: %u"", tok2str(bgp_attr_values, ""Unknown Attribute"", atype), atype, alen)); if (aflags) { ND_PRINT((ndo, "", Flags [%s%s%s%s"", aflags & 0x80 ? ""O"" : """", aflags & 0x40 ? ""T"" : """", aflags & 0x20 ? ""P"" : """", aflags & 0x10 ? ""E"" : """")); if (aflags & 0xf) ND_PRINT((ndo, ""+%x"", aflags & 0xf)); ND_PRINT((ndo, ""]: "")); } if (len < alen) goto trunc; if (length < alen) goto trunc; <S2SV_StartVul> if (!bgp_attr_print(ndo, atype, p, alen)) <S2SV_EndVul> goto trunc; p += alen; len -= alen; length -= alen; } } if (length) { ND_PRINT((ndo, ""\n\t Updated routes:"")); while (length) { char buf[MAXHOSTNAMELEN + 100]; i = decode_prefix4(ndo, p, length, buf, sizeof(buf)); if (i == -1) { ND_PRINT((ndo, ""\n\t (illegal prefix length)"")); break; } else if (i == -2) goto trunc; else if (i == -3) goto trunc; else { ND_PRINT((ndo, ""\n\t %s"", buf)); p += i; length -= i; } } } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }","- if (!bgp_attr_print(ndo, atype, p, alen))
+ if (!bgp_attr_print(ndo, atype, p, alen, 0))","bgp_update_print(netdissect_options *ndo, const u_char *dat, int length) { struct bgp bgp; const u_char *p; int withdrawn_routes_len; int len; int i; ND_TCHECK2(dat[0], BGP_SIZE); if (length < BGP_SIZE) goto trunc; memcpy(&bgp, dat, BGP_SIZE); p = dat + BGP_SIZE; length -= BGP_SIZE; ND_TCHECK2(p[0], 2); if (length < 2) goto trunc; withdrawn_routes_len = EXTRACT_16BITS(p); p += 2; length -= 2; if (withdrawn_routes_len) { ND_TCHECK2(p[0], withdrawn_routes_len); if (length < withdrawn_routes_len) goto trunc; ND_PRINT((ndo, ""\n\t Withdrawn routes: %d bytes"", withdrawn_routes_len)); p += withdrawn_routes_len; length -= withdrawn_routes_len; } ND_TCHECK2(p[0], 2); if (length < 2) goto trunc; len = EXTRACT_16BITS(p); p += 2; length -= 2; if (withdrawn_routes_len == 0 && len == 0 && length == 0) { ND_PRINT((ndo, ""\n\t End-of-Rib Marker (empty NLRI)"")); return; } if (len) { while (len) { int aflags, atype, alenlen, alen; ND_TCHECK2(p[0], 2); if (len < 2) goto trunc; if (length < 2) goto trunc; aflags = *p; atype = *(p + 1); p += 2; len -= 2; length -= 2; alenlen = bgp_attr_lenlen(aflags, p); ND_TCHECK2(p[0], alenlen); if (len < alenlen) goto trunc; if (length < alenlen) goto trunc; alen = bgp_attr_len(aflags, p); p += alenlen; len -= alenlen; length -= alenlen; ND_PRINT((ndo, ""\n\t %s (%u), length: %u"", tok2str(bgp_attr_values, ""Unknown Attribute"", atype), atype, alen)); if (aflags) { ND_PRINT((ndo, "", Flags [%s%s%s%s"", aflags & 0x80 ? ""O"" : """", aflags & 0x40 ? ""T"" : """", aflags & 0x20 ? ""P"" : """", aflags & 0x10 ? ""E"" : """")); if (aflags & 0xf) ND_PRINT((ndo, ""+%x"", aflags & 0xf)); ND_PRINT((ndo, ""]: "")); } if (len < alen) goto trunc; if (length < alen) goto trunc; if (!bgp_attr_print(ndo, atype, p, alen, 0)) goto trunc; p += alen; len -= alen; length -= alen; } } if (length) { ND_PRINT((ndo, ""\n\t Updated routes:"")); while (length) { char buf[MAXHOSTNAMELEN + 100]; i = decode_prefix4(ndo, p, length, buf, sizeof(buf)); if (i == -1) { ND_PRINT((ndo, ""\n\t (illegal prefix length)"")); break; } else if (i == -2) goto trunc; else if (i == -3) goto trunc; else { ND_PRINT((ndo, ""\n\t %s"", buf)); p += i; length -= i; } } } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }"
452,3785----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dcraw.cc----ljpeg_start,"int CLASS ljpeg_start (struct jhead *jh, int info_only) { <S2SV_StartVul> int c, tag, len; <S2SV_EndVul> uchar data[0x10000]; const uchar *dp; memset (jh, 0, sizeof *jh); jh->restart = INT_MAX; fread (data, 2, 1, ifp); if (data[1] != 0xd8) return 0; do { fread (data, 2, 2, ifp); tag = data[0] << 8 | data[1]; len = (data[2] << 8 | data[3]) - 2; if (tag <= 0xff00) return 0; fread (data, 1, len, ifp); switch (tag) { case 0xffc3: jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3; case 0xffc0: jh->bits = data[0]; jh->high = data[1] << 8 | data[2]; jh->wide = data[3] << 8 | data[4]; jh->clrs = data[5] + jh->sraw; if (len == 9 && !dng_version) getc(ifp); break; case 0xffc4: if (info_only) break; for (dp = data; dp < data+len && (c = *dp++) < 4; ) jh->free[c] = jh->huff[c] = make_decoder_ref (&dp); break; case 0xffda: jh->psv = data[1+data[0]*2]; jh->bits -= data[3+data[0]*2] & 15; break; case 0xffdd: jh->restart = data[0] << 8 | data[1]; } } while (tag != 0xffda); if (info_only) return 1; FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c]; if (jh->sraw) { FORC(4) jh->huff[2+c] = jh->huff[1]; FORC(jh->sraw) jh->huff[1+c] = jh->huff[0]; } jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4); merror (jh->row, ""ljpeg_start()""); return zero_after_ff = 1; }","- int c, tag, len;
+ int c, tag;
+ ushort len;","int CLASS ljpeg_start (struct jhead *jh, int info_only) { int c, tag; ushort len; uchar data[0x10000]; const uchar *dp; memset (jh, 0, sizeof *jh); jh->restart = INT_MAX; fread (data, 2, 1, ifp); if (data[1] != 0xd8) return 0; do { fread (data, 2, 2, ifp); tag = data[0] << 8 | data[1]; len = (data[2] << 8 | data[3]) - 2; if (tag <= 0xff00) return 0; fread (data, 1, len, ifp); switch (tag) { case 0xffc3: jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3; case 0xffc0: jh->bits = data[0]; jh->high = data[1] << 8 | data[2]; jh->wide = data[3] << 8 | data[4]; jh->clrs = data[5] + jh->sraw; if (len == 9 && !dng_version) getc(ifp); break; case 0xffc4: if (info_only) break; for (dp = data; dp < data+len && (c = *dp++) < 4; ) jh->free[c] = jh->huff[c] = make_decoder_ref (&dp); break; case 0xffda: jh->psv = data[1+data[0]*2]; jh->bits -= data[3+data[0]*2] & 15; break; case 0xffdd: jh->restart = data[0] << 8 | data[1]; } } while (tag != 0xffda); if (info_only) return 1; FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c]; if (jh->sraw) { FORC(4) jh->huff[2+c] = jh->huff[1]; FORC(jh->sraw) jh->huff[1+c] = jh->huff[0]; } jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4); merror (jh->row, ""ljpeg_start()""); return zero_after_ff = 1; }"
453,3196----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tja1100_driver.c----tja1100Init,"error_t tja1100Init(NetInterface *interface) { uint16_t value; TRACE_INFO(""Initializing TJA1100...\r\n""); if(interface->phyAddr >= 32) { interface->phyAddr = TJA1100_PHY_ADDR; } if(interface->smiDriver != NULL) { interface->smiDriver->init(); } if(interface->extIntDriver != NULL) { interface->extIntDriver->init(); } tja1100WritePhyReg(interface, TJA1100_BASIC_CTRL, TJA1100_BASIC_CTRL_RESET); while(tja1100ReadPhyReg(interface, TJA1100_BASIC_CTRL) & TJA1100_BASIC_CTRL_RESET) { } tja1100DumpPhyReg(interface); value = tja1100ReadPhyReg(interface, TJA1100_EXTENDED_CTRL); value |= TJA1100_EXTENDED_CTRL_CONFIG_EN; tja1100WritePhyReg(interface, TJA1100_EXTENDED_CTRL, value); value = tja1100ReadPhyReg(interface, TJA1100_CONFIG1); value &= ~TJA1100_CONFIG1_MII_MODE; <S2SV_StartVul> value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ; <S2SV_EndVul> tja1100WritePhyReg(interface, TJA1100_CONFIG1, value); value = tja1100ReadPhyReg(interface, TJA1100_CONFIG1); value |= TJA1100_CONFIG1_AUTO_OP; tja1100WritePhyReg(interface, TJA1100_CONFIG1, value); interface->phyEvent = TRUE; osSetEvent(&netEvent); return NO_ERROR; }","- value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ;
+ value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL;","error_t tja1100Init(NetInterface *interface) { uint16_t value; TRACE_INFO(""Initializing TJA1100...\r\n""); if(interface->phyAddr >= 32) { interface->phyAddr = TJA1100_PHY_ADDR; } if(interface->smiDriver != NULL) { interface->smiDriver->init(); } if(interface->extIntDriver != NULL) { interface->extIntDriver->init(); } tja1100WritePhyReg(interface, TJA1100_BASIC_CTRL, TJA1100_BASIC_CTRL_RESET); while(tja1100ReadPhyReg(interface, TJA1100_BASIC_CTRL) & TJA1100_BASIC_CTRL_RESET) { } tja1100DumpPhyReg(interface); value = tja1100ReadPhyReg(interface, TJA1100_EXTENDED_CTRL); value |= TJA1100_EXTENDED_CTRL_CONFIG_EN; tja1100WritePhyReg(interface, TJA1100_EXTENDED_CTRL, value); value = tja1100ReadPhyReg(interface, TJA1100_CONFIG1); value &= ~TJA1100_CONFIG1_MII_MODE; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL; tja1100WritePhyReg(interface, TJA1100_CONFIG1, value); value = tja1100ReadPhyReg(interface, TJA1100_CONFIG1); value |= TJA1100_CONFIG1_AUTO_OP; tja1100WritePhyReg(interface, TJA1100_CONFIG1, value); interface->phyEvent = TRUE; osSetEvent(&netEvent); return NO_ERROR; }"
454,5328----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/SQLSetDescFieldW.c----SQLSetDescFieldW,"SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle, SQLSMALLINT rec_number, SQLSMALLINT field_identifier, SQLPOINTER value, SQLINTEGER buffer_length ) { DMHDESC descriptor = (DMHDESC) descriptor_handle; SQLRETURN ret; SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ]; int isStrField = 0; if ( !__validate_desc( descriptor )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: SQL_INVALID_HANDLE"" ); #ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc; parent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC ); if ( parent_desc ) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Info: found parent handle"" ); if ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Info: calling redirected driver function"" ); return SQLSETDESCFIELDW( parent_desc -> connection, descriptor, rec_number, field_identifier, value, buffer_length ); } } } #endif return SQL_INVALID_HANDLE; } function_entry( descriptor ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tEntry:\ \n\t\t\tDescriptor = %p\ \n\t\t\tRec Number = %d\ \n\t\t\tField Ident = %s\ \n\t\t\tValue = %p\ \n\t\t\tBuffer Length = %d"", descriptor, rec_number, __desc_attr_as_string( s1, field_identifier ), value, (int)buffer_length ); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } thread_protect( SQL_HANDLE_DESC, descriptor ); if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if( __check_stmt_from_desc( descriptor, STATE_S8 ) || __check_stmt_from_desc( descriptor, STATE_S9 ) || __check_stmt_from_desc( descriptor, STATE_S10 ) || __check_stmt_from_desc( descriptor, STATE_S11 ) || __check_stmt_from_desc( descriptor, STATE_S12 ) || __check_stmt_from_desc( descriptor, STATE_S13 ) || __check_stmt_from_desc( descriptor, STATE_S14 ) || __check_stmt_from_desc( descriptor, STATE_S15 )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( rec_number < 0 ) { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE: case SQL_DESC_ARRAY_SIZE: case SQL_DESC_ARRAY_STATUS_PTR: case SQL_DESC_BIND_OFFSET_PTR: case SQL_DESC_BIND_TYPE: case SQL_DESC_COUNT: case SQL_DESC_ROWS_PROCESSED_PTR: case SQL_DESC_AUTO_UNIQUE_VALUE: case SQL_DESC_CASE_SENSITIVE: case SQL_DESC_CONCISE_TYPE: case SQL_DESC_DATA_PTR: case SQL_DESC_DATETIME_INTERVAL_CODE: case SQL_DESC_DATETIME_INTERVAL_PRECISION: case SQL_DESC_DISPLAY_SIZE: case SQL_DESC_FIXED_PREC_SCALE: case SQL_DESC_INDICATOR_PTR: case SQL_DESC_LENGTH: case SQL_DESC_NULLABLE: case SQL_DESC_NUM_PREC_RADIX: case SQL_DESC_OCTET_LENGTH: case SQL_DESC_OCTET_LENGTH_PTR: case SQL_DESC_PARAMETER_TYPE: case SQL_DESC_PRECISION: case SQL_DESC_ROWVER: case SQL_DESC_SCALE: case SQL_DESC_SEARCHABLE: case SQL_DESC_TYPE: case SQL_DESC_UNNAMED: case SQL_DESC_UNSIGNED: case SQL_DESC_UPDATABLE: isStrField = 0; break; case SQL_DESC_BASE_COLUMN_NAME: case SQL_DESC_BASE_TABLE_NAME: case SQL_DESC_CATALOG_NAME: case SQL_DESC_LABEL: case SQL_DESC_LITERAL_PREFIX: case SQL_DESC_LITERAL_SUFFIX: case SQL_DESC_LOCAL_TYPE_NAME: case SQL_DESC_NAME: case SQL_DESC_SCHEMA_NAME: case SQL_DESC_TABLE_NAME: case SQL_DESC_TYPE_NAME: isStrField = 1; break; default: isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS) { __post_internal_error( &descriptor -> error, ERROR_HY090, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } <S2SV_StartVul> if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 ) <S2SV_EndVul> { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } <S2SV_StartVul> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndVul> <S2SV_StartVul> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndVul> <S2SV_StartVul> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndVul> { __post_internal_error( &descriptor -> error, ERROR_HY105, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW( descriptor -> connection )) { if ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: IM001"" ); __post_internal_error( &descriptor -> error, ERROR_IM001, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } ret = SQLSETDESCFIELDW( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, value, buffer_length ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tExit:[%s]"", __get_return_status( ret, s1 )); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } } else { SQLCHAR *ascii_str = NULL; if ( !CHECK_SQLSETDESCFIELD( descriptor -> connection )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: IM001"" ); __post_internal_error( &descriptor -> error, ERROR_IM001, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } switch ( field_identifier ) { case SQL_DESC_NAME: ascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL ); value = ascii_str; buffer_length = strlen((char*) ascii_str ); break; default: break; } ret = SQLSETDESCFIELD( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, value, buffer_length ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tExit:[%s]"", __get_return_status( ret, s1 )); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } if ( ascii_str ) { free( ascii_str ); } } return function_return( SQL_HANDLE_DESC, descriptor, ret ); }","- if ( field_identifier == SQL_DESC_COUNT && (SQLINTEGER)value < 0 )
- if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT
- && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT &&
- value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM )
+ if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )
+ if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT
+ && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&
+ (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )","SQLRETURN SQLSetDescFieldW( SQLHDESC descriptor_handle, SQLSMALLINT rec_number, SQLSMALLINT field_identifier, SQLPOINTER value, SQLINTEGER buffer_length ) { DMHDESC descriptor = (DMHDESC) descriptor_handle; SQLRETURN ret; SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ]; int isStrField = 0; if ( !__validate_desc( descriptor )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: SQL_INVALID_HANDLE"" ); #ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc; parent_desc = find_parent_handle( descriptor, SQL_HANDLE_DESC ); if ( parent_desc ) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Info: found parent handle"" ); if ( CHECK_SQLSETDESCFIELDW( parent_desc -> connection )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Info: calling redirected driver function"" ); return SQLSETDESCFIELDW( parent_desc -> connection, descriptor, rec_number, field_identifier, value, buffer_length ); } } } #endif return SQL_INVALID_HANDLE; } function_entry( descriptor ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tEntry:\ \n\t\t\tDescriptor = %p\ \n\t\t\tRec Number = %d\ \n\t\t\tField Ident = %s\ \n\t\t\tValue = %p\ \n\t\t\tBuffer Length = %d"", descriptor, rec_number, __desc_attr_as_string( s1, field_identifier ), value, (int)buffer_length ); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } thread_protect( SQL_HANDLE_DESC, descriptor ); if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if( __check_stmt_from_desc( descriptor, STATE_S8 ) || __check_stmt_from_desc( descriptor, STATE_S9 ) || __check_stmt_from_desc( descriptor, STATE_S10 ) || __check_stmt_from_desc( descriptor, STATE_S11 ) || __check_stmt_from_desc( descriptor, STATE_S12 ) || __check_stmt_from_desc( descriptor, STATE_S13 ) || __check_stmt_from_desc( descriptor, STATE_S14 ) || __check_stmt_from_desc( descriptor, STATE_S15 )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: HY010"" ); __post_internal_error( &descriptor -> error, ERROR_HY010, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( rec_number < 0 ) { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE: case SQL_DESC_ARRAY_SIZE: case SQL_DESC_ARRAY_STATUS_PTR: case SQL_DESC_BIND_OFFSET_PTR: case SQL_DESC_BIND_TYPE: case SQL_DESC_COUNT: case SQL_DESC_ROWS_PROCESSED_PTR: case SQL_DESC_AUTO_UNIQUE_VALUE: case SQL_DESC_CASE_SENSITIVE: case SQL_DESC_CONCISE_TYPE: case SQL_DESC_DATA_PTR: case SQL_DESC_DATETIME_INTERVAL_CODE: case SQL_DESC_DATETIME_INTERVAL_PRECISION: case SQL_DESC_DISPLAY_SIZE: case SQL_DESC_FIXED_PREC_SCALE: case SQL_DESC_INDICATOR_PTR: case SQL_DESC_LENGTH: case SQL_DESC_NULLABLE: case SQL_DESC_NUM_PREC_RADIX: case SQL_DESC_OCTET_LENGTH: case SQL_DESC_OCTET_LENGTH_PTR: case SQL_DESC_PARAMETER_TYPE: case SQL_DESC_PRECISION: case SQL_DESC_ROWVER: case SQL_DESC_SCALE: case SQL_DESC_SEARCHABLE: case SQL_DESC_TYPE: case SQL_DESC_UNNAMED: case SQL_DESC_UNSIGNED: case SQL_DESC_UPDATABLE: isStrField = 0; break; case SQL_DESC_BASE_COLUMN_NAME: case SQL_DESC_BASE_TABLE_NAME: case SQL_DESC_CATALOG_NAME: case SQL_DESC_LABEL: case SQL_DESC_LITERAL_PREFIX: case SQL_DESC_LITERAL_SUFFIX: case SQL_DESC_LOCAL_TYPE_NAME: case SQL_DESC_NAME: case SQL_DESC_SCHEMA_NAME: case SQL_DESC_TABLE_NAME: case SQL_DESC_TYPE_NAME: isStrField = 1; break; default: isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS) { __post_internal_error( &descriptor -> error, ERROR_HY090, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 ) { __post_internal_error( &descriptor -> error, ERROR_07009, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM ) { __post_internal_error( &descriptor -> error, ERROR_HY105, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW( descriptor -> connection )) { if ( !CHECK_SQLSETDESCFIELDW( descriptor -> connection )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: IM001"" ); __post_internal_error( &descriptor -> error, ERROR_IM001, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } ret = SQLSETDESCFIELDW( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, value, buffer_length ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tExit:[%s]"", __get_return_status( ret, s1 )); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } } else { SQLCHAR *ascii_str = NULL; if ( !CHECK_SQLSETDESCFIELD( descriptor -> connection )) { dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, ""Error: IM001"" ); __post_internal_error( &descriptor -> error, ERROR_IM001, NULL, descriptor -> connection -> environment -> requested_version ); return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR ); } switch ( field_identifier ) { case SQL_DESC_NAME: ascii_str = (SQLCHAR*) unicode_to_ansi_alloc( value, buffer_length, descriptor -> connection, NULL ); value = ascii_str; buffer_length = strlen((char*) ascii_str ); break; default: break; } ret = SQLSETDESCFIELD( descriptor -> connection, descriptor -> driver_desc, rec_number, field_identifier, value, buffer_length ); if ( log_info.log_flag ) { sprintf( descriptor -> msg, ""\n\t\tExit:[%s]"", __get_return_status( ret, s1 )); dm_log_write( __FILE__, __LINE__, LOG_INFO, LOG_INFO, descriptor -> msg ); } if ( ascii_str ) { free( ascii_str ); } } return function_return( SQL_HANDLE_DESC, descriptor, ret ); }"
455,3886----CWE-863----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/adapter.c----update_discovery_filter,"static int update_discovery_filter(struct btd_adapter *adapter) { struct mgmt_cp_start_service_discovery *sd_cp; <S2SV_StartVul> GSList *l; <S2SV_EndVul> DBG(""""); if (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) { btd_error(adapter->dev_id, ""discovery_filter_to_mgmt_cp returned error""); return -ENOMEM; } <S2SV_StartVul> for (l = adapter->discovery_list; l; l = g_slist_next(l)) { <S2SV_EndVul> <S2SV_StartVul> struct discovery_client *client = l->data; <S2SV_EndVul> <S2SV_StartVul> if (!client->discovery_filter) <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> <S2SV_StartVul> if (client->discovery_filter->discoverable) <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> set_discovery_discoverable(adapter, l ? true : false); <S2SV_EndVul> if (filters_equal(adapter->current_discovery_filter, sd_cp) && adapter->discovering != 0) { DBG(""filters were equal, deciding to not restart the scan.""); g_free(sd_cp); return 0; } g_free(adapter->current_discovery_filter); adapter->current_discovery_filter = sd_cp; trigger_start_discovery(adapter, 0); return -EINPROGRESS; }","- GSList *l;
- for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
- struct discovery_client *client = l->data;
- if (!client->discovery_filter)
- continue;
- if (client->discovery_filter->discoverable)
- break;
- }
- set_discovery_discoverable(adapter, l ? true : false);
+ if (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) {
+ GSList *l;
+ for (l = adapter->discovery_list; l; l = g_slist_next(l)) {
+ struct discovery_client *client = l->data;
+ if (!client->discovery_filter)
+ continue;
+ if (client->discovery_filter->discoverable) {
+ set_discovery_discoverable(adapter, true);
+ break;
+ }
+ }
+ }","static int update_discovery_filter(struct btd_adapter *adapter) { struct mgmt_cp_start_service_discovery *sd_cp; DBG(""""); if (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) { btd_error(adapter->dev_id, ""discovery_filter_to_mgmt_cp returned error""); return -ENOMEM; } if (!(adapter->current_settings & MGMT_OP_SET_DISCOVERABLE)) { GSList *l; for (l = adapter->discovery_list; l; l = g_slist_next(l)) { struct discovery_client *client = l->data; if (!client->discovery_filter) continue; if (client->discovery_filter->discoverable) { set_discovery_discoverable(adapter, true); break; } } } if (filters_equal(adapter->current_discovery_filter, sd_cp) && adapter->discovering != 0) { DBG(""filters were equal, deciding to not restart the scan.""); g_free(sd_cp); return 0; } g_free(adapter->current_discovery_filter); adapter->current_discovery_filter = sd_cp; trigger_start_discovery(adapter, 0); return -EINPROGRESS; }"
456,1811----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-7521--psd.c----DecodePSDPixels,"static ssize_t DecodePSDPixels(const size_t number_compact_pixels, const unsigned char *compact_pixels,const ssize_t depth, const size_t number_pixels,unsigned char *pixels) { #define CheckNumberCompactPixels \ if (packets == 0) \ return(i); \ packets-- #define CheckNumberPixels(count) \ if (((ssize_t) i + count) > (ssize_t) number_pixels) \ return(i); \ i+=count int pixel; register ssize_t i, j; size_t length; ssize_t packets; packets=(ssize_t) number_compact_pixels; for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); ) { packets--; length=(size_t) (*compact_pixels++); if (length == 128) continue; if (length > 128) { length=256-length+1; CheckNumberCompactPixels; pixel=(*compact_pixels++); for (j=0; j < (ssize_t) length; j++) { switch (depth) { case 1: { CheckNumberPixels(8); *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U; break; } case 2: { CheckNumberPixels(4); *pixels++=(unsigned char) ((pixel >> 6) & 0x03); *pixels++=(unsigned char) ((pixel >> 4) & 0x03); *pixels++=(unsigned char) ((pixel >> 2) & 0x03); *pixels++=(unsigned char) ((pixel & 0x03) & 0x03); break; } case 4: { CheckNumberPixels(2); *pixels++=(unsigned char) ((pixel >> 4) & 0xff); *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff); break; } default: { CheckNumberPixels(1); *pixels++=(unsigned char) pixel; break; } } } continue; } length++; for (j=0; j < (ssize_t) length; j++) { switch (depth) { case 1: { CheckNumberPixels(8); *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U; break; } case 2: { CheckNumberPixels(4); *pixels++=(*compact_pixels >> 6) & 0x03; *pixels++=(*compact_pixels >> 4) & 0x03; *pixels++=(*compact_pixels >> 2) & 0x03; *pixels++=(*compact_pixels & 0x03) & 0x03; break; } case 4: { CheckNumberPixels(2); *pixels++=(*compact_pixels >> 4) & 0xff; *pixels++=(*compact_pixels & 0x0f) & 0xff; break; } default: { <S2SV_StartVul> CheckNumberPixels(1); <S2SV_EndVul> *pixels++=(*compact_pixels); break; } } CheckNumberCompactPixels; compact_pixels++; } } return(i); }","- CheckNumberPixels(1);
+ CheckNumberCompactPixels;","static ssize_t DecodePSDPixels(const size_t number_compact_pixels, const unsigned char *compact_pixels,const ssize_t depth, const size_t number_pixels,unsigned char *pixels) { #define CheckNumberCompactPixels \ if (packets == 0) \ return(i); \ packets-- #define CheckNumberPixels(count) \ if (((ssize_t) i + count) > (ssize_t) number_pixels) \ return(i); \ i+=count int pixel; register ssize_t i, j; size_t length; ssize_t packets; packets=(ssize_t) number_compact_pixels; for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); ) { packets--; length=(size_t) (*compact_pixels++); if (length == 128) continue; if (length > 128) { length=256-length+1; CheckNumberCompactPixels; pixel=(*compact_pixels++); for (j=0; j < (ssize_t) length; j++) { switch (depth) { case 1: { CheckNumberPixels(8); *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U; *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U; break; } case 2: { CheckNumberPixels(4); *pixels++=(unsigned char) ((pixel >> 6) & 0x03); *pixels++=(unsigned char) ((pixel >> 4) & 0x03); *pixels++=(unsigned char) ((pixel >> 2) & 0x03); *pixels++=(unsigned char) ((pixel & 0x03) & 0x03); break; } case 4: { CheckNumberPixels(2); *pixels++=(unsigned char) ((pixel >> 4) & 0xff); *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff); break; } default: { CheckNumberPixels(1); *pixels++=(unsigned char) pixel; break; } } } continue; } length++; for (j=0; j < (ssize_t) length; j++) { CheckNumberCompactPixels; switch (depth) { case 1: { CheckNumberPixels(8); *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U; *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U; break; } case 2: { CheckNumberPixels(4); *pixels++=(*compact_pixels >> 6) & 0x03; *pixels++=(*compact_pixels >> 4) & 0x03; *pixels++=(*compact_pixels >> 2) & 0x03; *pixels++=(*compact_pixels & 0x03) & 0x03; break; } case 4: { CheckNumberPixels(2); *pixels++=(*compact_pixels >> 4) & 0xff; *pixels++=(*compact_pixels & 0x0f) & 0xff; break; } default: { CheckNumberPixels(1); *pixels++=(*compact_pixels); break; } } compact_pixels++; } } return(i); }"
457,6856----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server_stubs.c----create_policy_2_svc,"create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg; <S2SV_StartVul> gss_buffer_desc client_name, <S2SV_EndVul> <S2SV_StartVul> service_name; <S2SV_EndVul> OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } prime_arg = arg->rec.policy; if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD, NULL, NULL)) { ret.code = KADM5_AUTH_ADD; log_unauth(""kadm5_create_policy"", prime_arg, &client_name, &service_name, rqstp); } else { ret.code = kadm5_create_policy((void *)handle, &arg->rec, arg->mask); if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(""kadm5_create_policy"", ((prime_arg == NULL) ? ""(null)"" : prime_arg), errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); <S2SV_StartVul> exit_func: <S2SV_EndVul> free_server_handle(handle); return &ret; }","- gss_buffer_desc client_name,
- service_name;
- exit_func:
+ gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER;
+ gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER;
+ exit_func:","create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER; OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } prime_arg = arg->rec.policy; if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD, NULL, NULL)) { ret.code = KADM5_AUTH_ADD; log_unauth(""kadm5_create_policy"", prime_arg, &client_name, &service_name, rqstp); } else { ret.code = kadm5_create_policy((void *)handle, &arg->rec, arg->mask); if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(""kadm5_create_policy"", ((prime_arg == NULL) ? ""(null)"" : prime_arg), errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } exit_func: gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); free_server_handle(handle); return &ret; }"
458,2103----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-7648--opj_mj2_extract.c----main,"int main(int argc, char *argv[]) { opj_dinfo_t* dinfo; opj_event_mgr_t event_mgr; int tnum; unsigned int snum; opj_mj2_t *movie; mj2_tk_t *track; mj2_sample_t *sample; unsigned char* frame_codestream; FILE *file, *outfile; char outfilename[50]; mj2_dparameters_t parameters; if (argc != 3) { printf(""Usage: %s mj2filename output_location\n"", argv[0]); printf(""Example: %s foreman.mj2 output/foreman\n"", argv[0]); return 1; } file = fopen(argv[1], ""rb""); if (!file) { fprintf(stderr, ""failed to open %s for reading\n"", argv[1]); return 1; } memset(&event_mgr, 0, sizeof(opj_event_mgr_t)); event_mgr.error_handler = error_callback; event_mgr.warning_handler = warning_callback; event_mgr.info_handler = info_callback; dinfo = mj2_create_decompress(); opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr); memset(&parameters, 0, sizeof(mj2_dparameters_t)); movie = (opj_mj2_t*) dinfo->mj2_handle; mj2_setup_decoder(movie, &parameters); if (mj2_read_struct(file, movie)) { return 1; } tnum = 0; while (movie->tk[tnum].track_type != 0) { tnum ++; } track = &movie->tk[tnum]; fprintf(stdout, ""Extracting %d frames from file...\n"", track->num_samples); for (snum = 0; snum < track->num_samples; snum++) { sample = &track->sample[snum]; frame_codestream = (unsigned char*) malloc(sample->sample_size - 8); fseek(file, sample->offset + 8, SEEK_SET); fread(frame_codestream, sample->sample_size - 8, 1, file); <S2SV_StartVul> sprintf(outfilename, ""%s_%05d.j2k"", argv[2], snum); <S2SV_EndVul> outfile = fopen(outfilename, ""wb""); if (!outfile) { fprintf(stderr, ""failed to open %s for writing\n"", outfilename); return 1; } fwrite(frame_codestream, sample->sample_size - 8, 1, outfile); fclose(outfile); free(frame_codestream); } fclose(file); fprintf(stdout, ""%d frames correctly extracted\n"", snum); if (dinfo) { mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle); } return 0; }","- sprintf(outfilename, ""%s_%05d.j2k"", argv[2], snum);
+ int num = snprintf(outfilename, sizeof(outfilename), ""%s_%05d.j2k"", argv[2], snum);
+ if (num >= sizeof(outfilename)) {
+ fprintf(stderr, ""maximum length of output prefix exceeded\n"");
+ return 1;
+ }","int main(int argc, char *argv[]) { opj_dinfo_t* dinfo; opj_event_mgr_t event_mgr; int tnum; unsigned int snum; opj_mj2_t *movie; mj2_tk_t *track; mj2_sample_t *sample; unsigned char* frame_codestream; FILE *file, *outfile; char outfilename[50]; mj2_dparameters_t parameters; if (argc != 3) { printf(""Usage: %s mj2filename output_location\n"", argv[0]); printf(""Example: %s foreman.mj2 output/foreman\n"", argv[0]); return 1; } file = fopen(argv[1], ""rb""); if (!file) { fprintf(stderr, ""failed to open %s for reading\n"", argv[1]); return 1; } memset(&event_mgr, 0, sizeof(opj_event_mgr_t)); event_mgr.error_handler = error_callback; event_mgr.warning_handler = warning_callback; event_mgr.info_handler = info_callback; dinfo = mj2_create_decompress(); opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr); memset(&parameters, 0, sizeof(mj2_dparameters_t)); movie = (opj_mj2_t*) dinfo->mj2_handle; mj2_setup_decoder(movie, &parameters); if (mj2_read_struct(file, movie)) { return 1; } tnum = 0; while (movie->tk[tnum].track_type != 0) { tnum ++; } track = &movie->tk[tnum]; fprintf(stdout, ""Extracting %d frames from file...\n"", track->num_samples); for (snum = 0; snum < track->num_samples; snum++) { sample = &track->sample[snum]; frame_codestream = (unsigned char*) malloc(sample->sample_size - 8); fseek(file, sample->offset + 8, SEEK_SET); fread(frame_codestream, sample->sample_size - 8, 1, file); int num = snprintf(outfilename, sizeof(outfilename), ""%s_%05d.j2k"", argv[2], snum); if (num >= sizeof(outfilename)) { fprintf(stderr, ""maximum length of output prefix exceeded\n""); return 1; } outfile = fopen(outfilename, ""wb""); if (!outfile) { fprintf(stderr, ""failed to open %s for writing\n"", outfilename); return 1; } fwrite(frame_codestream, sample->sample_size - 8, 1, outfile); fclose(outfile); free(frame_codestream); } fclose(file); fprintf(stdout, ""%d frames correctly extracted\n"", snum); if (dinfo) { mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle); } return 0; }"
459,1153----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8767--sm_sideeffect.c----sctp_generate_t3_rtx_event,"void sctp_generate_t3_rtx_event(unsigned long peer) { int error; struct sctp_transport *transport = (struct sctp_transport *) peer; struct sctp_association *asoc = transport->asoc; <S2SV_StartVul> struct net *net = sock_net(asoc->base.sk); <S2SV_EndVul> <S2SV_StartVul> bh_lock_sock(asoc->base.sk); <S2SV_EndVul> <S2SV_StartVul> if (sock_owned_by_user(asoc->base.sk)) { <S2SV_EndVul> pr_debug(""%s: sock is busy\n"", __func__); if (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20))) sctp_transport_hold(transport); goto out_unlock; } if (transport->dead) goto out_unlock; error = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT, SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX), asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC); if (error) <S2SV_StartVul> asoc->base.sk->sk_err = -error; <S2SV_EndVul> out_unlock: <S2SV_StartVul> bh_unlock_sock(asoc->base.sk); <S2SV_EndVul> sctp_transport_put(transport); }","- struct net *net = sock_net(asoc->base.sk);
- bh_lock_sock(asoc->base.sk);
- if (sock_owned_by_user(asoc->base.sk)) {
- asoc->base.sk->sk_err = -error;
- bh_unlock_sock(asoc->base.sk);
+ struct sock *sk = asoc->base.sk;
+ struct net *net = sock_net(sk);
+ bh_lock_sock(sk);
+ if (sock_owned_by_user(sk)) {
+ sk->sk_err = -error;
+ bh_unlock_sock(sk);","void sctp_generate_t3_rtx_event(unsigned long peer) { int error; struct sctp_transport *transport = (struct sctp_transport *) peer; struct sctp_association *asoc = transport->asoc; struct sock *sk = asoc->base.sk; struct net *net = sock_net(sk); bh_lock_sock(sk); if (sock_owned_by_user(sk)) { pr_debug(""%s: sock is busy\n"", __func__); if (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20))) sctp_transport_hold(transport); goto out_unlock; } if (transport->dead) goto out_unlock; error = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT, SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX), asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC); if (error) sk->sk_err = -error; out_unlock: bh_unlock_sock(sk); sctp_transport_put(transport); }"
460,5659----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/i8042.c----i8042_interrupt,"static irqreturn_t i8042_interrupt(int irq, void *dev_id) { struct i8042_port *port; struct serio *serio; unsigned long flags; unsigned char str, data; unsigned int dfl; unsigned int port_no; bool filtered; int ret = 1; spin_lock_irqsave(&i8042_lock, flags); str = i8042_read_status(); if (unlikely(~str & I8042_STR_OBF)) { spin_unlock_irqrestore(&i8042_lock, flags); if (irq) dbg(""Interrupt %d, without any data\n"", irq); ret = 0; goto out; } data = i8042_read_data(); if (i8042_mux_present && (str & I8042_STR_AUXDATA)) { static unsigned long last_transmit; static unsigned char last_str; dfl = 0; if (str & I8042_STR_MUXERR) { dbg(""MUX error, status is %02x, data is %02x\n"", str, data); switch (data) { default: if (time_before(jiffies, last_transmit + HZ/10)) { str = last_str; break; } case 0xfc: case 0xfd: case 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break; case 0xff: dfl = SERIO_PARITY; data = 0xfe; break; } } port_no = I8042_MUX_PORT_NO + ((str >> 6) & 3); last_str = str; last_transmit = jiffies; } else { dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) | ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0); port_no = (str & I8042_STR_AUXDATA) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO; } port = &i8042_ports[port_no]; serio = port->exists ? port->serio : NULL; filter_dbg(port->driver_bound, data, ""<- i8042 (interrupt, %d, %d%s%s)\n"", port_no, irq, dfl & SERIO_PARITY ? "", bad parity"" : """", dfl & SERIO_TIMEOUT ? "", timeout"" : """"); filtered = i8042_filter(data, str, serio); spin_unlock_irqrestore(&i8042_lock, flags); <S2SV_StartVul> if (likely(port->exists && !filtered)) <S2SV_EndVul> serio_interrupt(serio, data, dfl); out: return IRQ_RETVAL(ret); }","- if (likely(port->exists && !filtered))
+ if (likely(serio && !filtered))","static irqreturn_t i8042_interrupt(int irq, void *dev_id) { struct i8042_port *port; struct serio *serio; unsigned long flags; unsigned char str, data; unsigned int dfl; unsigned int port_no; bool filtered; int ret = 1; spin_lock_irqsave(&i8042_lock, flags); str = i8042_read_status(); if (unlikely(~str & I8042_STR_OBF)) { spin_unlock_irqrestore(&i8042_lock, flags); if (irq) dbg(""Interrupt %d, without any data\n"", irq); ret = 0; goto out; } data = i8042_read_data(); if (i8042_mux_present && (str & I8042_STR_AUXDATA)) { static unsigned long last_transmit; static unsigned char last_str; dfl = 0; if (str & I8042_STR_MUXERR) { dbg(""MUX error, status is %02x, data is %02x\n"", str, data); switch (data) { default: if (time_before(jiffies, last_transmit + HZ/10)) { str = last_str; break; } case 0xfc: case 0xfd: case 0xfe: dfl = SERIO_TIMEOUT; data = 0xfe; break; case 0xff: dfl = SERIO_PARITY; data = 0xfe; break; } } port_no = I8042_MUX_PORT_NO + ((str >> 6) & 3); last_str = str; last_transmit = jiffies; } else { dfl = ((str & I8042_STR_PARITY) ? SERIO_PARITY : 0) | ((str & I8042_STR_TIMEOUT && !i8042_notimeout) ? SERIO_TIMEOUT : 0); port_no = (str & I8042_STR_AUXDATA) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO; } port = &i8042_ports[port_no]; serio = port->exists ? port->serio : NULL; filter_dbg(port->driver_bound, data, ""<- i8042 (interrupt, %d, %d%s%s)\n"", port_no, irq, dfl & SERIO_PARITY ? "", bad parity"" : """", dfl & SERIO_TIMEOUT ? "", timeout"" : """"); filtered = i8042_filter(data, str, serio); spin_unlock_irqrestore(&i8042_lock, flags); if (likely(serio && !filtered)) serio_interrupt(serio, data, dfl); out: return IRQ_RETVAL(ret); }"
461,1700----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10195--evdns.c----name_parse,"name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) { int name_end = -1; int j = *idx; int ptr_count = 0; #define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0) #define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0) #define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0) char *cp = name_out; const char *const end = name_out + name_out_len; for (;;) { u8 label_len; <S2SV_StartVul> if (j >= length) return -1; <S2SV_EndVul> GET8(label_len); if (!label_len) break; if (label_len & 0xc0) { u8 ptr_low; GET8(ptr_low); if (name_end < 0) name_end = j; j = (((int)label_len & 0x3f) << 8) + ptr_low; if (j < 0 || j >= length) return -1; if (++ptr_count > length) return -1; continue; } if (label_len > 63) return -1; if (cp != name_out) { if (cp + 1 >= end) return -1; *cp++ = '.'; } if (cp + label_len >= end) return -1; memcpy(cp, packet + j, label_len); cp += label_len; j += label_len; } if (cp >= end) return -1; *cp = '\0'; if (name_end < 0) *idx = j; else *idx = name_end; return 0; err: return -1; }","- if (j >= length) return -1;
+ if (j + label_len > length) return -1;","name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) { int name_end = -1; int j = *idx; int ptr_count = 0; #define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0) #define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0) #define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0) char *cp = name_out; const char *const end = name_out + name_out_len; for (;;) { u8 label_len; GET8(label_len); if (!label_len) break; if (label_len & 0xc0) { u8 ptr_low; GET8(ptr_low); if (name_end < 0) name_end = j; j = (((int)label_len & 0x3f) << 8) + ptr_low; if (j < 0 || j >= length) return -1; if (++ptr_count > length) return -1; continue; } if (label_len > 63) return -1; if (cp != name_out) { if (cp + 1 >= end) return -1; *cp++ = '.'; } if (cp + label_len >= end) return -1; if (j + label_len > length) return -1; memcpy(cp, packet + j, label_len); cp += label_len; j += label_len; } if (cp >= end) return -1; *cp = '\0'; if (name_end < 0) *idx = j; else *idx = name_end; return 0; err: return -1; }"
462,6542----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ParaNdis-Common.cpp----ParaNdis_CheckRxChecksum,"tChecksumCheckResult ParaNdis_CheckRxChecksum( PARANDIS_ADAPTER *pContext, ULONG virtioFlags, tCompletePhysicalAddress *pPacketPages, ULONG ulPacketLength, <S2SV_StartVul> ULONG ulDataOffset) <S2SV_EndVul> { tOffloadSettingsFlags f = pContext->Offload.flags; tChecksumCheckResult res; tTcpIpPacketParsingResult ppr; ULONG flagsToCalculate = 0; res.value = 0; if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum; if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)) { if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM) { flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum; } else { if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum; if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum; if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum; if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum; } } <S2SV_StartVul> ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__); <S2SV_EndVul> if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete) { res.flags.IpOK = FALSE; res.flags.IpFailed = TRUE; return res; } if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID) { pContext->extraStatistics.framesRxCSHwOK++; ppr.xxpCheckSum = ppresCSOK; } if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment) { if (f.fRxIPChecksum) { res.flags.IpOK = ppr.ipCheckSum == ppresCSOK; res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad; } if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP) { if (f.fRxTCPChecksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else { if (f.fRxUDPChecksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } else if (ppr.ipStatus == ppresIPV6) { if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP) { if (f.fRxTCPv6Checksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else { if (f.fRxUDPv6Checksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } return res; }","- ULONG ulDataOffset)
- ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);
+ ULONG ulDataOffset,
+ BOOLEAN verifyLength)
+ ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate,
+ verifyLength, __FUNCTION__);","tChecksumCheckResult ParaNdis_CheckRxChecksum( PARANDIS_ADAPTER *pContext, ULONG virtioFlags, tCompletePhysicalAddress *pPacketPages, ULONG ulPacketLength, ULONG ulDataOffset, BOOLEAN verifyLength) { tOffloadSettingsFlags f = pContext->Offload.flags; tChecksumCheckResult res; tTcpIpPacketParsingResult ppr; ULONG flagsToCalculate = 0; res.value = 0; if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum; if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)) { if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM) { flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum; } else { if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum; if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum; if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum; if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum; } } ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, verifyLength, __FUNCTION__); if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete) { res.flags.IpOK = FALSE; res.flags.IpFailed = TRUE; return res; } if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID) { pContext->extraStatistics.framesRxCSHwOK++; ppr.xxpCheckSum = ppresCSOK; } if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment) { if (f.fRxIPChecksum) { res.flags.IpOK = ppr.ipCheckSum == ppresCSOK; res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad; } if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP) { if (f.fRxTCPChecksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else { if (f.fRxUDPChecksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } else if (ppr.ipStatus == ppresIPV6) { if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP) { if (f.fRxTCPv6Checksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else { if (f.fRxUDPv6Checksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } return res; }"
463,5396----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bin_dyldcache.c----estimate_slide,"static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) { ut64 slide = 0; if (cache->n_hdr > 1) { return slide; } ut64 *classlist = malloc (64); if (!classlist) { goto beach; } RListIter *iter; RDyldBinImage *bin; r_list_foreach (cache->bins, iter, bin) { bool found_sample = false; struct MACH0_(opts_t) opts = {0}; opts.verbose = bf->rbin->verbose; opts.header_at = bin->header_at; opts.symbols_off = 0; struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts); if (!mach0) { goto beach; } struct section_t *sections = NULL; if (!(sections = MACH0_(get_sections) (mach0))) { MACH0_(mach0_free) (mach0); goto beach; } int i; int incomplete = 2; int classlist_idx = 0, data_idx = 0; for (i = 0; !sections[i].last && incomplete; i++) { if (sections[i].size == 0) { continue; } if (strstr (sections[i].name, ""__objc_classlist"")) { incomplete--; classlist_idx = i; continue; } if (strstr (sections[i].name, ""__objc_data"")) { incomplete--; data_idx = i; continue; } } if (incomplete) { goto next_bin; } int classlist_sample_size = R_MIN (64, sections[classlist_idx].size); int n_classes = classlist_sample_size / 8; ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset; <S2SV_StartVul> if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) { <S2SV_EndVul> goto next_bin; } ut64 data_addr = sections[data_idx].addr; ut64 data_tail = data_addr & 0xfff; ut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff; for (i = 0; i < n_classes; i++) { ut64 cl_addr = (classlist[i] & value_mask) + value_add; ut64 cl_tail = cl_addr & 0xfff; if (cl_tail >= data_tail && cl_tail < data_tail_end) { ut64 off = cl_tail - data_tail; slide = ((cl_addr - off) & value_mask) - (data_addr & value_mask); found_sample = true; break; } } next_bin: MACH0_(mach0_free) (mach0); R_FREE (sections); if (found_sample) { break; } } beach: R_FREE (classlist); return slide; }","- if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) < classlist_sample_size) {
+ if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) {","static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) { ut64 slide = 0; if (cache->n_hdr > 1) { return slide; } ut64 *classlist = malloc (64); if (!classlist) { goto beach; } RListIter *iter; RDyldBinImage *bin; r_list_foreach (cache->bins, iter, bin) { bool found_sample = false; struct MACH0_(opts_t) opts = {0}; opts.verbose = bf->rbin->verbose; opts.header_at = bin->header_at; opts.symbols_off = 0; struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts); if (!mach0) { goto beach; } struct section_t *sections = NULL; if (!(sections = MACH0_(get_sections) (mach0))) { MACH0_(mach0_free) (mach0); goto beach; } int i; int incomplete = 2; int classlist_idx = 0, data_idx = 0; for (i = 0; !sections[i].last && incomplete; i++) { if (sections[i].size == 0) { continue; } if (strstr (sections[i].name, ""__objc_classlist"")) { incomplete--; classlist_idx = i; continue; } if (strstr (sections[i].name, ""__objc_data"")) { incomplete--; data_idx = i; continue; } } if (incomplete) { goto next_bin; } int classlist_sample_size = R_MIN (64, sections[classlist_idx].size); int n_classes = classlist_sample_size / 8; ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset; if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, ""l"", n_classes) != classlist_sample_size) { goto next_bin; } ut64 data_addr = sections[data_idx].addr; ut64 data_tail = data_addr & 0xfff; ut64 data_tail_end = (data_addr + sections[data_idx].size) & 0xfff; for (i = 0; i < n_classes; i++) { ut64 cl_addr = (classlist[i] & value_mask) + value_add; ut64 cl_tail = cl_addr & 0xfff; if (cl_tail >= data_tail && cl_tail < data_tail_end) { ut64 off = cl_tail - data_tail; slide = ((cl_addr - off) & value_mask) - (data_addr & value_mask); found_sample = true; break; } } next_bin: MACH0_(mach0_free) (mach0); R_FREE (sections); if (found_sample) { break; } } beach: R_FREE (classlist); return slide; }"
464,4797----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pdf.c----pdf_get_version,"void pdf_get_version(FILE *fp, pdf_t *pdf) { <S2SV_StartVul> char *header, *c; <S2SV_EndVul> <S2SV_StartVul> header = get_header(fp); <S2SV_EndVul> if ((c = strstr(header, ""%PDF-"")) && <S2SV_StartVul> (c + strlen(""%PDF-M.m"") + 2)) <S2SV_EndVul> { pdf->pdf_major_version = atoi(c + strlen(""%PDF-"")); pdf->pdf_minor_version = atoi(c + strlen(""%PDF-M."")); } free(header); }","- char *header, *c;
- header = get_header(fp);
- (c + strlen(""%PDF-M.m"") + 2))
+ char *header = get_header(fp);
+ const char *c;
+ ((c + 6)[0] == '.') && // Separator
+ isdigit((c + 5)[0]) && // Major number
+ isdigit((c + 7)[0])) // Minor number","void pdf_get_version(FILE *fp, pdf_t *pdf) { char *header = get_header(fp); const char *c; if ((c = strstr(header, ""%PDF-"")) && ((c + 6)[0] == '.') && isdigit((c + 5)[0]) && isdigit((c + 7)[0])) { pdf->pdf_major_version = atoi(c + strlen(""%PDF-"")); pdf->pdf_minor_version = atoi(c + strlen(""%PDF-M."")); } free(header); }"
465,1726----CWE-284----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10130--http.c----http_connect,"static int http_connect(http_subtransport *t) { int error; if (t->connected && http_should_keep_alive(&t->parser) && t->parse_finished) return 0; if (t->io) { git_stream_close(t->io); git_stream_free(t->io); t->io = NULL; t->connected = 0; } if (t->connection_data.use_ssl) { error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port); } else { #ifdef GIT_CURL error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port); #else error = git_socket_stream_new(&t->io, t->connection_data.host, t->connection_data.port); #endif } if (error < 0) return error; GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream""); apply_proxy_config(t); error = git_stream_connect(t->io); if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL && git_stream_is_encrypted(t->io)) { git_cert *cert; <S2SV_StartVul> int is_valid; <S2SV_EndVul> if ((error = git_stream_certificate(&cert, t->io)) < 0) return error; giterr_clear(); <S2SV_StartVul> is_valid = error != GIT_ECERTIFICATE; <S2SV_EndVul> error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload); if (error < 0) { if (!giterr_last()) giterr_set(GITERR_NET, ""user cancelled certificate check""); return error; } } if (error < 0) return error; t->connected = 1; return 0; }","- int is_valid;
- is_valid = error != GIT_ECERTIFICATE;
+ int is_valid = (error == GIT_OK);","static int http_connect(http_subtransport *t) { int error; if (t->connected && http_should_keep_alive(&t->parser) && t->parse_finished) return 0; if (t->io) { git_stream_close(t->io); git_stream_free(t->io); t->io = NULL; t->connected = 0; } if (t->connection_data.use_ssl) { error = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port); } else { #ifdef GIT_CURL error = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port); #else error = git_socket_stream_new(&t->io, t->connection_data.host, t->connection_data.port); #endif } if (error < 0) return error; GITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, ""git_stream""); apply_proxy_config(t); error = git_stream_connect(t->io); if ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL && git_stream_is_encrypted(t->io)) { git_cert *cert; int is_valid = (error == GIT_OK); if ((error = git_stream_certificate(&cert, t->io)) < 0) return error; giterr_clear(); error = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload); if (error < 0) { if (!giterr_last()) giterr_set(GITERR_NET, ""user cancelled certificate check""); return error; } } if (error < 0) return error; t->connected = 1; return 0; }"
466,5528----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dds.c----SkipRGBMipmaps,"static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info, int pixel_size,ExceptionInfo *exception) { MagickOffsetType offset; register ssize_t i; size_t h, w; if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); return(MagickFalse); } if (dds_info->ddscaps1 & DDSCAPS_MIPMAP && (dds_info->ddscaps1 & DDSCAPS_TEXTURE || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP)) { w = DIV2(dds_info->width); h = DIV2(dds_info->height); for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++) { offset = (MagickOffsetType) w * h * pixel_size; <S2SV_StartVul> (void) SeekBlob(image, offset, SEEK_CUR); <S2SV_EndVul> w = DIV2(w); h = DIV2(h); } } return(MagickTrue); }","- (void) SeekBlob(image, offset, SEEK_CUR);
+ if (SeekBlob(image, offset, SEEK_CUR) < 0)
+ break;","static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info, int pixel_size,ExceptionInfo *exception) { MagickOffsetType offset; register ssize_t i; size_t h, w; if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); return(MagickFalse); } if (dds_info->ddscaps1 & DDSCAPS_MIPMAP && (dds_info->ddscaps1 & DDSCAPS_TEXTURE || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP)) { w = DIV2(dds_info->width); h = DIV2(dds_info->height); for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++) { offset = (MagickOffsetType) w * h * pixel_size; if (SeekBlob(image, offset, SEEK_CUR) < 0) break; w = DIV2(w); h = DIV2(h); } } return(MagickTrue); }"
467,1268----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-15385--elf.c----*store_versioninfo_gnu_verdef,"static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { const char *section_name = """"; const char *link_section_name = """"; char *end = NULL; Elf_(Shdr) *link_shdr = NULL; ut8 dfs[sizeof (Elf_(Verdef))] = {0}; Sdb *sdb; int cnt, i; if (shdr->sh_link > bin->ehdr.e_shnum) { return false; } link_shdr = &bin->shdr[shdr->sh_link]; if (shdr->sh_size < 1) { return false; } Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char)); if (!defs) { return false; } if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!defs) { bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n""); return NULL; } sdb = sdb_new0 (); end = (char *)defs + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); <S2SV_StartVul> for (cnt = 0, i = 0; cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) { <S2SV_EndVul> Sdb *sdb_verdef = sdb_new0 (); char *vstart = ((char*)defs) + i; char key[32] = {0}; Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart; Elf_(Verdaux) aux = {0}; int j = 0; int isum = 0; r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef))); verdef->vd_version = READ16 (dfs, j) verdef->vd_flags = READ16 (dfs, j) verdef->vd_ndx = READ16 (dfs, j) verdef->vd_cnt = READ16 (dfs, j) verdef->vd_hash = READ32 (dfs, j) verdef->vd_aux = READ32 (dfs, j) verdef->vd_next = READ32 (dfs, j) vstart += verdef->vd_aux; if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); goto out_error; } j = 0; aux.vda_name = READ32 (vstart, j) aux.vda_next = READ32 (vstart, j) isum = i + verdef->vd_aux; if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); goto out_error; } sdb_num_set (sdb_verdef, ""idx"", i, 0); sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0); sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0); sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0); sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0); sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0); for (j = 1; j < verdef->vd_cnt; ++j) { int k; Sdb *sdb_parent = sdb_new0 (); isum += aux.vda_next; vstart += aux.vda_next; if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } k = 0; aux.vda_name = READ32 (vstart, k) aux.vda_next = READ32 (vstart, k) if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } sdb_num_set (sdb_parent, ""idx"", isum, 0); sdb_num_set (sdb_parent, ""parent"", j, 0); sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0); snprintf (key, sizeof (key), ""parent%d"", j - 1); sdb_ns_set (sdb_verdef, key, sdb_parent); } snprintf (key, sizeof (key), ""verdef%d"", cnt); sdb_ns_set (sdb, key, sdb_verdef); if (!verdef->vd_next) { sdb_free (sdb_verdef); goto out_error; } i += verdef->vd_next; } free (defs); return sdb; out_error: free (defs); sdb_free (sdb); return NULL; }","- for (cnt = 0, i = 0; cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
+ for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {
+ if ((st32)verdef->vd_next < 1) {
+ eprintf (""Warning: Invalid vd_next in the ELF version\n"");
+ break;
+ }","static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { const char *section_name = """"; const char *link_section_name = """"; char *end = NULL; Elf_(Shdr) *link_shdr = NULL; ut8 dfs[sizeof (Elf_(Verdef))] = {0}; Sdb *sdb; int cnt, i; if (shdr->sh_link > bin->ehdr.e_shnum) { return false; } link_shdr = &bin->shdr[shdr->sh_link]; if (shdr->sh_size < 1) { return false; } Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char)); if (!defs) { return false; } if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!defs) { bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n""); return NULL; } sdb = sdb_new0 (); end = (char *)defs + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) { Sdb *sdb_verdef = sdb_new0 (); char *vstart = ((char*)defs) + i; char key[32] = {0}; Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart; Elf_(Verdaux) aux = {0}; int j = 0; int isum = 0; r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef))); verdef->vd_version = READ16 (dfs, j) verdef->vd_flags = READ16 (dfs, j) verdef->vd_ndx = READ16 (dfs, j) verdef->vd_cnt = READ16 (dfs, j) verdef->vd_hash = READ32 (dfs, j) verdef->vd_aux = READ32 (dfs, j) verdef->vd_next = READ32 (dfs, j) vstart += verdef->vd_aux; if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); goto out_error; } j = 0; aux.vda_name = READ32 (vstart, j) aux.vda_next = READ32 (vstart, j) isum = i + verdef->vd_aux; if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); goto out_error; } sdb_num_set (sdb_verdef, ""idx"", i, 0); sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0); sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0); sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0); sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0); sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0); for (j = 1; j < verdef->vd_cnt; ++j) { int k; Sdb *sdb_parent = sdb_new0 (); isum += aux.vda_next; vstart += aux.vda_next; if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } k = 0; aux.vda_name = READ32 (vstart, k) aux.vda_next = READ32 (vstart, k) if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } sdb_num_set (sdb_parent, ""idx"", isum, 0); sdb_num_set (sdb_parent, ""parent"", j, 0); sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0); snprintf (key, sizeof (key), ""parent%d"", j - 1); sdb_ns_set (sdb_verdef, key, sdb_parent); } snprintf (key, sizeof (key), ""verdef%d"", cnt); sdb_ns_set (sdb, key, sdb_verdef); if (!verdef->vd_next) { sdb_free (sdb_verdef); goto out_error; } if ((st32)verdef->vd_next < 1) { eprintf (""Warning: Invalid vd_next in the ELF version\n""); break; } i += verdef->vd_next; } free (defs); return sdb; out_error: free (defs); sdb_free (sdb); return NULL; }"
468,6870----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server_stubs.c----purgekeys_2_svc,"purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg, *funcname; <S2SV_StartVul> gss_buffer_desc client_name, service_name; <S2SV_EndVul> OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; funcname = ""kadm5_purgekeys""; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) { ret.code = KADM5_BAD_PRINCIPAL; goto exit_func; } if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) && (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY, arg->princ, NULL))) { ret.code = KADM5_AUTH_MODIFY; log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp); } else { ret.code = kadm5_purgekeys((void *)handle, arg->princ, arg->keepkvno); if (ret.code != 0) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(funcname, prime_arg, errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } free(prime_arg); gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); <S2SV_StartVul> exit_func: <S2SV_EndVul> free_server_handle(handle); return &ret; }","- gss_buffer_desc client_name, service_name;
- exit_func:
+ gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER;
+ gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER;
+ exit_func:","purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp) { static generic_ret ret; char *prime_arg, *funcname; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER; OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_generic_ret, &ret); if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; funcname = ""kadm5_purgekeys""; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) { ret.code = KADM5_BAD_PRINCIPAL; goto exit_func; } if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) && (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY, arg->princ, NULL))) { ret.code = KADM5_AUTH_MODIFY; log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp); } else { ret.code = kadm5_purgekeys((void *)handle, arg->princ, arg->keepkvno); if (ret.code != 0) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(funcname, prime_arg, errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); } free(prime_arg); exit_func: gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); free_server_handle(handle); return &ret; }"
469,6199----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/register.c----yank_copy_line,"yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space) { char_u *pnew; if (exclude_trailing_space) bd->endspaces = 0; if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1)) == NULL) return FAIL; y_current->y_array[y_idx] = pnew; vim_memset(pnew, ' ', (size_t)bd->startspaces); pnew += bd->startspaces; mch_memmove(pnew, bd->textstart, (size_t)bd->textlen); pnew += bd->textlen; vim_memset(pnew, ' ', (size_t)bd->endspaces); pnew += bd->endspaces; if (exclude_trailing_space) { int s = bd->textlen + bd->endspaces; <S2SV_StartVul> while (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0) <S2SV_EndVul> { s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1; pnew--; } } *pnew = NUL; return OK; }","- while (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)
+ while (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))","yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space) { char_u *pnew; if (exclude_trailing_space) bd->endspaces = 0; if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1)) == NULL) return FAIL; y_current->y_array[y_idx] = pnew; vim_memset(pnew, ' ', (size_t)bd->startspaces); pnew += bd->startspaces; mch_memmove(pnew, bd->textstart, (size_t)bd->textlen); pnew += bd->textlen; vim_memset(pnew, ' ', (size_t)bd->endspaces); pnew += bd->endspaces; if (exclude_trailing_space) { int s = bd->textlen + bd->endspaces; while (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1))) { s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1; pnew--; } } *pnew = NUL; return OK; }"
470,4334----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/time.c----jiffies_to_timespec,"jiffies_to_timespec(const unsigned long jiffies, struct timespec *value) { <S2SV_StartVul> u64 nsec = (u64)jiffies * TICK_NSEC; <S2SV_EndVul> <S2SV_StartVul> value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec); <S2SV_EndVul> }","- u64 nsec = (u64)jiffies * TICK_NSEC;
- value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);
+ u32 rem;
+ value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,
+ NSEC_PER_SEC, &rem);
+ value->tv_nsec = rem;","jiffies_to_timespec(const unsigned long jiffies, struct timespec *value) { u32 rem; value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC, NSEC_PER_SEC, &rem); value->tv_nsec = rem; }"
471,2787----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/reflection.c----mono_reflection_create_dynamic_method,"void mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb) { ReflectionMethodBuilder rmb; MonoMethodSignature *sig; MonoClass *klass; GSList *l; int i; sig = dynamic_method_to_signature (mb); reflection_methodbuilder_from_dynamic_method (&rmb, mb); rmb.nrefs = mb->nrefs; rmb.refs = g_new0 (gpointer, mb->nrefs + 1); for (i = 0; i < mb->nrefs; i += 2) { MonoClass *handle_class; gpointer ref; MonoObject *obj = mono_array_get (mb->refs, MonoObject*, i); if (strcmp (obj->vtable->klass->name, ""DynamicMethod"") == 0) { MonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj; if (method->mhandle) { ref = method->mhandle; } else { ref = method; method->referenced_by = g_slist_append (method->referenced_by, mb); } handle_class = mono_defaults.methodhandle_class; } else { MonoException *ex = NULL; ref = resolve_object (mb->module->image, obj, &handle_class, NULL); if (!ref) ex = mono_get_exception_type_load (NULL, NULL); else if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR) ex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class); if (ex) { g_free (rmb.refs); mono_raise_exception (ex); return; } } rmb.refs [i] = ref; rmb.refs [i + 1] = handle_class; } klass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class; <S2SV_StartVul> mb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig); <S2SV_EndVul> for (l = mb->referenced_by; l; l = l->next) { MonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data; MonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle; gpointer *data; g_assert (method->mhandle); data = (gpointer*)wrapper->method_data; for (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) { if ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class)) data [i + 1] = mb->mhandle; } } g_slist_free (mb->referenced_by); g_free (rmb.refs); mb->ilgen = NULL;","- mb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);
+ MonoReferenceQueue *queue;
+ MonoMethod *handle;
+ DynamicMethodReleaseData *release_data;
+ if (mono_runtime_is_shutting_down ())
+ mono_raise_exception (mono_get_exception_invalid_operation (""""));
+ if (!(queue = dynamic_method_queue)) {
+ mono_loader_lock ();
+ if (!(queue = dynamic_method_queue))
+ queue = dynamic_method_queue = mono_gc_reference_queue_new (free_dynamic_method);
+ mono_loader_unlock ();
+ }
+ mb->mhandle = handle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);
+ release_data = g_new (DynamicMethodReleaseData, 1);
+ release_data->handle = handle;
+ release_data->domain = mono_object_get_domain ((MonoObject*)mb);
+ if (!mono_gc_reference_queue_add (queue, (MonoObject*)mb, release_data))
+ g_free (release_data);","void mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb) { MonoReferenceQueue *queue; MonoMethod *handle; DynamicMethodReleaseData *release_data; ReflectionMethodBuilder rmb; MonoMethodSignature *sig; MonoClass *klass; GSList *l; int i; if (mono_runtime_is_shutting_down ()) mono_raise_exception (mono_get_exception_invalid_operation ("""")); if (!(queue = dynamic_method_queue)) { mono_loader_lock (); if (!(queue = dynamic_method_queue)) queue = dynamic_method_queue = mono_gc_reference_queue_new (free_dynamic_method); mono_loader_unlock (); } sig = dynamic_method_to_signature (mb); reflection_methodbuilder_from_dynamic_method (&rmb, mb); rmb.nrefs = mb->nrefs; rmb.refs = g_new0 (gpointer, mb->nrefs + 1); for (i = 0; i < mb->nrefs; i += 2) { MonoClass *handle_class; gpointer ref; MonoObject *obj = mono_array_get (mb->refs, MonoObject*, i); if (strcmp (obj->vtable->klass->name, ""DynamicMethod"") == 0) { MonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)obj; if (method->mhandle) { ref = method->mhandle; } else { ref = method; method->referenced_by = g_slist_append (method->referenced_by, mb); } handle_class = mono_defaults.methodhandle_class; } else { MonoException *ex = NULL; ref = resolve_object (mb->module->image, obj, &handle_class, NULL); if (!ref) ex = mono_get_exception_type_load (NULL, NULL); else if (mono_security_get_mode () == MONO_SECURITY_MODE_CORE_CLR) ex = mono_security_core_clr_ensure_dynamic_method_resolved_object (ref, handle_class); if (ex) { g_free (rmb.refs); mono_raise_exception (ex); return; } } rmb.refs [i] = ref; rmb.refs [i + 1] = handle_class; } klass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class; mb->mhandle = handle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig); release_data = g_new (DynamicMethodReleaseData, 1); release_data->handle = handle; release_data->domain = mono_object_get_domain ((MonoObject*)mb); if (!mono_gc_reference_queue_add (queue, (MonoObject*)mb, release_data)) g_free (release_data); for (l = mb->referenced_by; l; l = l->next) { MonoReflectionDynamicMethod *method = (MonoReflectionDynamicMethod*)l->data; MonoMethodWrapper *wrapper = (MonoMethodWrapper*)method->mhandle; gpointer *data; g_assert (method->mhandle); data = (gpointer*)wrapper->method_data; for (i = 0; i < GPOINTER_TO_UINT (data [0]); i += 2) { if ((data [i + 1] == mb) && (data [i + 1 + 1] == mono_defaults.methodhandle_class)) data [i + 1] = mb->mhandle; } } g_slist_free (mb->referenced_by); g_free (rmb.refs); mb->ilgen = NULL;"
472,6828----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/file.c----ext4_dax_fault,"static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf) { int result; handle_t *handle = NULL; <S2SV_StartVul> struct super_block *sb = file_inode(vma->vm_file)->i_sb; <S2SV_EndVul> bool write = vmf->flags & FAULT_FLAG_WRITE; if (write) { sb_start_pagefault(sb); file_update_time(vma->vm_file); handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE, EXT4_DATA_TRANS_BLOCKS(sb)); <S2SV_StartVul> } <S2SV_EndVul> if (IS_ERR(handle)) result = VM_FAULT_SIGBUS; else result = __dax_fault(vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten); if (write) { if (!IS_ERR(handle)) ext4_journal_stop(handle); sb_end_pagefault(sb); <S2SV_StartVul> } <S2SV_EndVul> return result; }","- struct super_block *sb = file_inode(vma->vm_file)->i_sb;
- }
- }
+ struct inode *inode = file_inode(vma->vm_file);
+ struct super_block *sb = inode->i_sb;
+ down_read(&EXT4_I(inode)->i_mmap_sem);
+ } else
+ down_read(&EXT4_I(inode)->i_mmap_sem);
+ up_read(&EXT4_I(inode)->i_mmap_sem);
+ } else
+ up_read(&EXT4_I(inode)->i_mmap_sem);","static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf) { int result; handle_t *handle = NULL; struct inode *inode = file_inode(vma->vm_file); struct super_block *sb = inode->i_sb; bool write = vmf->flags & FAULT_FLAG_WRITE; if (write) { sb_start_pagefault(sb); file_update_time(vma->vm_file); down_read(&EXT4_I(inode)->i_mmap_sem); handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE, EXT4_DATA_TRANS_BLOCKS(sb)); } else down_read(&EXT4_I(inode)->i_mmap_sem); if (IS_ERR(handle)) result = VM_FAULT_SIGBUS; else result = __dax_fault(vma, vmf, ext4_get_block_dax, ext4_end_io_unwritten); if (write) { if (!IS_ERR(handle)) ext4_journal_stop(handle); up_read(&EXT4_I(inode)->i_mmap_sem); sb_end_pagefault(sb); } else up_read(&EXT4_I(inode)->i_mmap_sem); return result; }"
473,1622----CWE-190----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-6308--alloc.c----alloc_limit_assert,"alloc_limit_assert (char *fn_name, size_t size) { if (alloc_limit && size > alloc_limit) { <S2SV_StartVul> alloc_limit_failure (fn_name, size); <S2SV_EndVul> <S2SV_StartVul> exit (-1); <S2SV_EndVul> } }","- alloc_limit_failure (fn_name, size);
- exit (-1);
+ alloc_limit_failure (fn_name, size);
+ exit (-1);","alloc_limit_assert (char *fn_name, size_t size) { if (alloc_limit && size > alloc_limit) { alloc_limit_failure (fn_name, size); exit (-1); } }"
474,1942----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-16658--cdrom.c----cdrom_ioctl_drive_status,"static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi, unsigned long arg) { cd_dbg(CD_DO_IOCTL, ""entering CDROM_DRIVE_STATUS\n""); if (!(cdi->ops->capability & CDC_DRIVE_STATUS)) return -ENOSYS; if (!CDROM_CAN(CDC_SELECT_DISC) || (arg == CDSL_CURRENT || arg == CDSL_NONE)) return cdi->ops->drive_status(cdi, CDSL_CURRENT); <S2SV_StartVul> if (((int)arg >= cdi->capacity)) <S2SV_EndVul> return -EINVAL; return cdrom_slot_status(cdi, arg); }","- if (((int)arg >= cdi->capacity))
+ if (arg >= cdi->capacity)","static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi, unsigned long arg) { cd_dbg(CD_DO_IOCTL, ""entering CDROM_DRIVE_STATUS\n""); if (!(cdi->ops->capability & CDC_DRIVE_STATUS)) return -ENOSYS; if (!CDROM_CAN(CDC_SELECT_DISC) || (arg == CDSL_CURRENT || arg == CDSL_NONE)) return cdi->ops->drive_status(cdi, CDSL_CURRENT); if (arg >= cdi->capacity) return -EINVAL; return cdrom_slot_status(cdi, arg); }"
475,3717----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/muraster.c----initialise_banding,"initialise_banding(fz_context *ctx, render_details *render, int color) { size_t min_band_mem; int bpp, h, w, reps; render->colorspace = output_cs; render->format = output_format; #if GREY_FALLBACK != 0 if (color == 0) { if (render->colorspace == CS_RGB) { render->colorspace = CS_GRAY; render->format = OUT_PGM; } else if (render->colorspace == CS_CMYK) { render->colorspace = CS_GRAY; if (render->format == OUT_PKM) render->format = OUT_PBM; else render->format = OUT_PGM; } } #endif switch (render->colorspace) { case CS_GRAY: bpp = 1; break; case CS_RGB: bpp = 2; break; default: case CS_CMYK: bpp = 3; break; } w = render->ibounds.x1 - render->ibounds.x0; min_band_mem = (size_t)bpp * w * min_band_height; <S2SV_StartVul> reps = (int)(max_band_memory / min_band_mem); <S2SV_EndVul> <S2SV_StartVul> if (reps < 1) <S2SV_EndVul> reps = 1; if (render->num_workers > 0) { int runs, num_bands; h = render->ibounds.y1 - render->ibounds.y0; num_bands = (h + min_band_height - 1) / min_band_height; runs = (num_bands + reps-1) / reps; runs = ((runs + render->num_workers - 1) / render->num_workers) * render->num_workers; reps = (num_bands + runs - 1) / runs; } render->band_height_multiple = reps; render->bands_rendered = 0; if (output_format == OUT_PGM || output_format == OUT_PPM) { render->bander = fz_new_pnm_band_writer(ctx, out); render->n = output_format == OUT_PGM ? 1 : 3; } else if (output_format == OUT_PAM) { render->bander = fz_new_pam_band_writer(ctx, out); render->n = 4; } else if (output_format == OUT_PBM) { render->bander = fz_new_pbm_band_writer(ctx, out); render->n = 1; } else if (output_format == OUT_PKM) { render->bander = fz_new_pkm_band_writer(ctx, out); render->n = 4; } }","- reps = (int)(max_band_memory / min_band_mem);
- if (reps < 1)
+ if (min_band_mem > 0)
+ reps = (int)(max_band_memory / min_band_mem);
+ if (min_band_mem == 0 || reps < 1)","initialise_banding(fz_context *ctx, render_details *render, int color) { size_t min_band_mem; int bpp, h, w, reps; render->colorspace = output_cs; render->format = output_format; #if GREY_FALLBACK != 0 if (color == 0) { if (render->colorspace == CS_RGB) { render->colorspace = CS_GRAY; render->format = OUT_PGM; } else if (render->colorspace == CS_CMYK) { render->colorspace = CS_GRAY; if (render->format == OUT_PKM) render->format = OUT_PBM; else render->format = OUT_PGM; } } #endif switch (render->colorspace) { case CS_GRAY: bpp = 1; break; case CS_RGB: bpp = 2; break; default: case CS_CMYK: bpp = 3; break; } w = render->ibounds.x1 - render->ibounds.x0; min_band_mem = (size_t)bpp * w * min_band_height; if (min_band_mem > 0) reps = (int)(max_band_memory / min_band_mem); if (min_band_mem == 0 || reps < 1) reps = 1; if (render->num_workers > 0) { int runs, num_bands; h = render->ibounds.y1 - render->ibounds.y0; num_bands = (h + min_band_height - 1) / min_band_height; runs = (num_bands + reps-1) / reps; runs = ((runs + render->num_workers - 1) / render->num_workers) * render->num_workers; reps = (num_bands + runs - 1) / runs; } render->band_height_multiple = reps; render->bands_rendered = 0; if (output_format == OUT_PGM || output_format == OUT_PPM) { render->bander = fz_new_pnm_band_writer(ctx, out); render->n = output_format == OUT_PGM ? 1 : 3; } else if (output_format == OUT_PAM) { render->bander = fz_new_pam_band_writer(ctx, out); render->n = 4; } else if (output_format == OUT_PBM) { render->bander = fz_new_pbm_band_writer(ctx, out); render->n = 1; } else if (output_format == OUT_PKM) { render->bander = fz_new_pkm_band_writer(ctx, out); render->n = 4; } }"
476,5432----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/notify.c----fifo_open,"fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type) { int ret; int sav_errno; if (fifo->name) { sav_errno = 0; if (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) fifo->created_fifo = true; else { sav_errno = errno; if (sav_errno != EEXIST) log_message(LOG_INFO, ""Unable to create %snotify fifo %s"", type, fifo->name); } if (!sav_errno || sav_errno == EEXIST) { if (fifo->script) notify_fifo_exec(master, script_exit, fifo, fifo->script); <S2SV_StartVul> if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) { <S2SV_EndVul> log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno); if (fifo->created_fifo) { unlink(fifo->name); fifo->created_fifo = false; } } } if (fifo->fd == -1) { FREE(fifo->name); fifo->name = NULL; } } }","- if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {
+ if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {","fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type) { int ret; int sav_errno; if (fifo->name) { sav_errno = 0; if (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) fifo->created_fifo = true; else { sav_errno = errno; if (sav_errno != EEXIST) log_message(LOG_INFO, ""Unable to create %snotify fifo %s"", type, fifo->name); } if (!sav_errno || sav_errno == EEXIST) { if (fifo->script) notify_fifo_exec(master, script_exit, fifo, fifo->script); if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) { log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno); if (fifo->created_fifo) { unlink(fifo->name); fifo->created_fifo = false; } } } if (fifo->fd == -1) { FREE(fifo->name); fifo->name = NULL; } } }"
477,2990----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dm9000_driver.c----dm9000UpdateMacAddrFilter,"error_t dm9000UpdateMacAddrFilter(NetInterface *interface) { uint_t i; uint_t k; uint32_t crc; uint8_t hashTable[8]; MacFilterEntry *entry; TRACE_DEBUG(""Updating MAC filter...\r\n""); osMemset(hashTable, 0, sizeof(hashTable)); hashTable[7] = 0x80; for(i = 0; i < MAC_ADDR_FILTER_SIZE; i++) { entry = &interface->macAddrFilter[i]; if(entry->refCount > 0) { crc = dm9000CalcCrc(&entry->addr, sizeof(MacAddr)); k = crc & 0x3F; hashTable[k / 8] |= (1 << (k % 8)); } } for(i = 0; i < 8; i++) { <S2SV_StartVul> dm9000WriteReg(DM9000_REG_MAR0 + i, hashTable[i]); <S2SV_EndVul> } TRACE_DEBUG("" MAR = %02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 "" "" ""%02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 ""\r\n"", <S2SV_StartVul> dm9000ReadReg(DM9000_REG_MAR0), dm9000ReadReg(DM9000_REG_MAR1), <S2SV_EndVul> <S2SV_StartVul> dm9000ReadReg(DM9000_REG_MAR2), dm9000ReadReg(DM9000_REG_MAR3), <S2SV_EndVul> <S2SV_StartVul> dm9000ReadReg(DM9000_REG_MAR4), dm9000ReadReg(DM9000_REG_MAR5), <S2SV_EndVul> <S2SV_StartVul> dm9000ReadReg(DM9000_REG_MAR6), dm9000ReadReg(DM9000_REG_MAR7)); <S2SV_EndVul> return NO_ERROR; }","- dm9000WriteReg(DM9000_REG_MAR0 + i, hashTable[i]);
- dm9000ReadReg(DM9000_REG_MAR0), dm9000ReadReg(DM9000_REG_MAR1),
- dm9000ReadReg(DM9000_REG_MAR2), dm9000ReadReg(DM9000_REG_MAR3),
- dm9000ReadReg(DM9000_REG_MAR4), dm9000ReadReg(DM9000_REG_MAR5),
- dm9000ReadReg(DM9000_REG_MAR6), dm9000ReadReg(DM9000_REG_MAR7));
+ dm9000WriteReg(DM9000_MAR0 + i, hashTable[i]);
+ dm9000ReadReg(DM9000_MAR0), dm9000ReadReg(DM9000_MAR1),
+ dm9000ReadReg(DM9000_MAR2), dm9000ReadReg(DM9000_MAR3),
+ dm9000ReadReg(DM9000_MAR4), dm9000ReadReg(DM9000_MAR5),
+ dm9000ReadReg(DM9000_MAR6), dm9000ReadReg(DM9000_MAR7));","error_t dm9000UpdateMacAddrFilter(NetInterface *interface) { uint_t i; uint_t k; uint32_t crc; uint8_t hashTable[8]; MacFilterEntry *entry; TRACE_DEBUG(""Updating MAC filter...\r\n""); osMemset(hashTable, 0, sizeof(hashTable)); hashTable[7] = 0x80; for(i = 0; i < MAC_ADDR_FILTER_SIZE; i++) { entry = &interface->macAddrFilter[i]; if(entry->refCount > 0) { crc = dm9000CalcCrc(&entry->addr, sizeof(MacAddr)); k = crc & 0x3F; hashTable[k / 8] |= (1 << (k % 8)); } } for(i = 0; i < 8; i++) { dm9000WriteReg(DM9000_MAR0 + i, hashTable[i]); } TRACE_DEBUG("" MAR = %02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 "" "" ""%02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 "" %02"" PRIX8 ""\r\n"", dm9000ReadReg(DM9000_MAR0), dm9000ReadReg(DM9000_MAR1), dm9000ReadReg(DM9000_MAR2), dm9000ReadReg(DM9000_MAR3), dm9000ReadReg(DM9000_MAR4), dm9000ReadReg(DM9000_MAR5), dm9000ReadReg(DM9000_MAR6), dm9000ReadReg(DM9000_MAR7)); return NO_ERROR; }"
478,2991----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dm9000_driver.c----dm9000WritePhyReg,"void dm9000WritePhyReg(uint8_t address, uint16_t data) { <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address); <S2SV_EndVul> <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPDRL, LSB(data)); <S2SV_EndVul> <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPDRH, MSB(data)); <S2SV_EndVul> <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRW); <S2SV_EndVul> <S2SV_StartVul> while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0) <S2SV_EndVul> { } usleep(5); <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS); <S2SV_EndVul> }","- dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);
- dm9000WriteReg(DM9000_REG_EPDRL, LSB(data));
- dm9000WriteReg(DM9000_REG_EPDRH, MSB(data));
- dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRW);
- while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)
- dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);
+ dm9000WriteReg(DM9000_EPAR, 0x40 | address);
+ dm9000WriteReg(DM9000_EPDRL, LSB(data));
+ dm9000WriteReg(DM9000_EPDRH, MSB(data));
+ dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW);
+ while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0)
+ dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS);","void dm9000WritePhyReg(uint8_t address, uint16_t data) { dm9000WriteReg(DM9000_EPAR, 0x40 | address); dm9000WriteReg(DM9000_EPDRL, LSB(data)); dm9000WriteReg(DM9000_EPDRH, MSB(data)); dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW); while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0) { } usleep(5); dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS); }"
479,988----CWE-190----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-5844--archive_read_support_format_iso9660.c----choose_volume,"choose_volume(struct archive_read *a, struct iso9660 *iso9660) { struct file_info *file; int64_t skipsize; struct vd *vd; const void *block; char seenJoliet; vd = &(iso9660->primary); if (!iso9660->opt_support_joliet) iso9660->seenJoliet = 0; if (iso9660->seenJoliet && vd->location > iso9660->joliet.location) vd = &(iso9660->joliet); <S2SV_StartVul> skipsize = LOGICAL_BLOCK_SIZE * vd->location; <S2SV_EndVul> skipsize = __archive_read_consume(a, skipsize); if (skipsize < 0) return ((int)skipsize); iso9660->current_position = skipsize; block = __archive_read_ahead(a, vd->size, NULL); if (block == NULL) { archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Failed to read full block when scanning "" ""ISO9660 directory list""); return (ARCHIVE_FATAL); } seenJoliet = iso9660->seenJoliet; iso9660->seenJoliet = 0; file = parse_file_info(a, NULL, block); if (file == NULL) return (ARCHIVE_FATAL); iso9660->seenJoliet = seenJoliet; if (vd == &(iso9660->primary) && iso9660->seenRockridge && iso9660->seenJoliet) iso9660->seenJoliet = 0; if (vd == &(iso9660->primary) && !iso9660->seenRockridge && iso9660->seenJoliet) { vd = &(iso9660->joliet); <S2SV_StartVul> skipsize = LOGICAL_BLOCK_SIZE * vd->location; <S2SV_EndVul> skipsize -= iso9660->current_position; skipsize = __archive_read_consume(a, skipsize); if (skipsize < 0) return ((int)skipsize); iso9660->current_position += skipsize; block = __archive_read_ahead(a, vd->size, NULL); if (block == NULL) { archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Failed to read full block when scanning "" ""ISO9660 directory list""); return (ARCHIVE_FATAL); } iso9660->seenJoliet = 0; file = parse_file_info(a, NULL, block); if (file == NULL) return (ARCHIVE_FATAL); iso9660->seenJoliet = seenJoliet; } if (add_entry(a, iso9660, file) != ARCHIVE_OK) return (ARCHIVE_FATAL); if (iso9660->seenRockridge) { a->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE; a->archive.archive_format_name = ""ISO9660 with Rockridge extensions""; } return (ARCHIVE_OK); }","- skipsize = LOGICAL_BLOCK_SIZE * vd->location;
- skipsize = LOGICAL_BLOCK_SIZE * vd->location;
+ skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
+ skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;","choose_volume(struct archive_read *a, struct iso9660 *iso9660) { struct file_info *file; int64_t skipsize; struct vd *vd; const void *block; char seenJoliet; vd = &(iso9660->primary); if (!iso9660->opt_support_joliet) iso9660->seenJoliet = 0; if (iso9660->seenJoliet && vd->location > iso9660->joliet.location) vd = &(iso9660->joliet); skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location; skipsize = __archive_read_consume(a, skipsize); if (skipsize < 0) return ((int)skipsize); iso9660->current_position = skipsize; block = __archive_read_ahead(a, vd->size, NULL); if (block == NULL) { archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Failed to read full block when scanning "" ""ISO9660 directory list""); return (ARCHIVE_FATAL); } seenJoliet = iso9660->seenJoliet; iso9660->seenJoliet = 0; file = parse_file_info(a, NULL, block); if (file == NULL) return (ARCHIVE_FATAL); iso9660->seenJoliet = seenJoliet; if (vd == &(iso9660->primary) && iso9660->seenRockridge && iso9660->seenJoliet) iso9660->seenJoliet = 0; if (vd == &(iso9660->primary) && !iso9660->seenRockridge && iso9660->seenJoliet) { vd = &(iso9660->joliet); skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location; skipsize -= iso9660->current_position; skipsize = __archive_read_consume(a, skipsize); if (skipsize < 0) return ((int)skipsize); iso9660->current_position += skipsize; block = __archive_read_ahead(a, vd->size, NULL); if (block == NULL) { archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Failed to read full block when scanning "" ""ISO9660 directory list""); return (ARCHIVE_FATAL); } iso9660->seenJoliet = 0; file = parse_file_info(a, NULL, block); if (file == NULL) return (ARCHIVE_FATAL); iso9660->seenJoliet = seenJoliet; } if (add_entry(a, iso9660, file) != ARCHIVE_OK) return (ARCHIVE_FATAL); if (iso9660->seenRockridge) { a->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE; a->archive.archive_format_name = ""ISO9660 with Rockridge extensions""; } return (ARCHIVE_OK); }"
480,941----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9120--ion.c----ion_free,"<S2SV_StartVul> void ion_free(struct ion_client *client, struct ion_handle *handle) <S2SV_EndVul> { bool valid_handle; BUG_ON(client != handle->client); <S2SV_StartVul> mutex_lock(&client->lock); <S2SV_EndVul> valid_handle = ion_handle_validate(client, handle); if (!valid_handle) { WARN(1, ""%s: invalid handle passed to free.\n"", __func__); <S2SV_StartVul> mutex_unlock(&client->lock); <S2SV_EndVul> return; } mutex_unlock(&client->lock); <S2SV_StartVul> ion_handle_put(handle); <S2SV_EndVul> }","- void ion_free(struct ion_client *client, struct ion_handle *handle)
- mutex_lock(&client->lock);
- mutex_unlock(&client->lock);
- ion_handle_put(handle);
+ void ion_free(struct ion_client *client, struct ion_handle *handle)
+ }
+ ion_handle_put_nolock(handle);
+ 
+ void ion_free(struct ion_client *client, struct ion_handle *handle)
+ {
+ 
+ mutex_lock(&client->lock);","void ion_free(struct ion_client *client, struct ion_handle *handle) static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle) { bool valid_handle; BUG_ON(client != handle->client); valid_handle = ion_handle_validate(client, handle); if (!valid_handle) { WARN(1, ""%s: invalid handle passed to free.\n"", __func__); return; } ion_handle_put_nolock(handle); } void ion_free(struct ion_client *client, struct ion_handle *handle) { BUG_ON(client != handle->client); mutex_lock(&client->lock); ion_free_nolock(client, handle); mutex_unlock(&client->lock); }"
481,1731----CWE-190----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10093--tiffcp.c----cpStripToTile,"cpStripToTile(uint8* out, uint8* in, <S2SV_StartVul> uint32 rows, uint32 cols, int outskew, int inskew) <S2SV_EndVul> { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) *out++ = *in++; out += outskew; in += inskew; } }","- uint32 rows, uint32 cols, int outskew, int inskew)
+ uint32 rows, uint32 cols, int outskew, int64 inskew)","cpStripToTile(uint8* out, uint8* in, uint32 rows, uint32 cols, int outskew, int64 inskew) { while (rows-- > 0) { uint32 j = cols; while (j-- > 0) *out++ = *in++; out += outskew; in += inskew; } }"
482,6613----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/OpenJPEGImage.cc----OpenJPEGImage::getRegion,"RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){ unsigned int obpc = bpc; if( bpc <= 16 && bpc > 8 ) obpc = 16; else if( bpc <= 8 ) obpc = 8; #ifdef DEBUG Timer timer; timer.start(); #endif RawTile rawtile( 0, res, ha, va, w, h, channels, obpc ); <S2SV_StartVul> if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels]; <S2SV_EndVul> <S2SV_StartVul> else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels]; <S2SV_EndVul> else throw file_error( ""OpenJPEG :: Unsupported number of bits"" ); <S2SV_StartVul> rawtile.dataLength = w*h*channels*(obpc/8); <S2SV_EndVul> rawtile.filename = getImagePath(); rawtile.timestamp = timestamp; process( res, layers, x, y, w, h, rawtile.data ); #ifdef DEBUG logfile << ""OpenJPEG :: getRegion() :: "" << timer.getTime() << "" microseconds"" << endl; #endif return rawtile; }","- if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];
- else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];
- rawtile.dataLength = w*h*channels*(obpc/8);
+ size_t np = (size_t) w * (size_t) h * (size_t) channels;
+ if( obpc == 16 ) rawtile.data = new unsigned short[np];
+ else if( obpc == 8 ) rawtile.data = new unsigned char[np];
+ rawtile.dataLength = np*(obpc/8);","RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){ unsigned int obpc = bpc; if( bpc <= 16 && bpc > 8 ) obpc = 16; else if( bpc <= 8 ) obpc = 8; #ifdef DEBUG Timer timer; timer.start(); #endif RawTile rawtile( 0, res, ha, va, w, h, channels, obpc ); size_t np = (size_t) w * (size_t) h * (size_t) channels; if( obpc == 16 ) rawtile.data = new unsigned short[np]; else if( obpc == 8 ) rawtile.data = new unsigned char[np]; else throw file_error( ""OpenJPEG :: Unsupported number of bits"" ); rawtile.dataLength = np*(obpc/8); rawtile.filename = getImagePath(); rawtile.timestamp = timestamp; process( res, layers, x, y, w, h, rawtile.data ); #ifdef DEBUG logfile << ""OpenJPEG :: getRegion() :: "" << timer.getTime() << "" microseconds"" << endl; #endif return rawtile; }"
483,3274----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cjson.c----suffix_object,"<S2SV_StartVul> static void suffix_object( cJSON *prev, cJSON *item ) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> prev->next = item; <S2SV_EndVul> <S2SV_StartVul> item->prev = prev; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- static void suffix_object( cJSON *prev, cJSON *item )
- {
- prev->next = item;
- item->prev = prev;
- }
+ static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}","static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}"
484,6785----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hsm_com_client.c----unix_client_connect,"unix_client_connect(hsm_com_client_hdl_t *hdl) { int fd, len; struct sockaddr_un unix_addr; if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) { return HSM_COM_ERROR; } memset(&unix_addr,0,sizeof(unix_addr)); unix_addr.sun_family = AF_UNIX; if(strlen(hdl->c_path) >= sizeof(unix_addr.sun_path)) { <S2SV_StartVul> close(fd); <S2SV_EndVul> <S2SV_StartVul> return HSM_COM_PATH_ERR; <S2SV_EndVul> } snprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path), ""%s"", hdl->c_path); len = SUN_LEN(&unix_addr); unlink(unix_addr.sun_path); if(bind(fd, (struct sockaddr *)&unix_addr, len) < 0) { <S2SV_StartVul> unlink(hdl->c_path); <S2SV_EndVul> <S2SV_StartVul> close(fd); <S2SV_EndVul> <S2SV_StartVul> return HSM_COM_BIND_ERR; <S2SV_EndVul> } if(chmod(unix_addr.sun_path, S_IRWXU) < 0) { <S2SV_StartVul> unlink(hdl->c_path); <S2SV_EndVul> <S2SV_StartVul> close(fd); <S2SV_EndVul> <S2SV_StartVul> return HSM_COM_CHMOD_ERR; <S2SV_EndVul> } memset(&unix_addr,0,sizeof(unix_addr)); unix_addr.sun_family = AF_UNIX; strncpy(unix_addr.sun_path, hdl->s_path, sizeof(unix_addr.sun_path)); unix_addr.sun_path[sizeof(unix_addr.sun_path)-1] = 0; len = SUN_LEN(&unix_addr); if (connect(fd, (struct sockaddr *) &unix_addr, len) < 0) { <S2SV_StartVul> unlink(hdl->c_path); <S2SV_EndVul> <S2SV_StartVul> close(fd); <S2SV_EndVul> <S2SV_StartVul> return HSM_COM_CONX_ERR; <S2SV_EndVul> } hdl->client_fd = fd; hdl->client_state = HSM_COM_C_STATE_CT; if(unix_sck_send_conn(hdl, 2) != HSM_COM_OK) { hdl->client_state = HSM_COM_C_STATE_IN; <S2SV_StartVul> return HSM_COM_SEND_ERR; <S2SV_EndVul> } <S2SV_StartVul> return HSM_COM_OK; <S2SV_EndVul> }","- close(fd);
- return HSM_COM_PATH_ERR;
- unlink(hdl->c_path);
- close(fd);
- return HSM_COM_BIND_ERR;
- unlink(hdl->c_path);
- close(fd);
- return HSM_COM_CHMOD_ERR;
- unlink(hdl->c_path);
- close(fd);
- return HSM_COM_CONX_ERR;
- return HSM_COM_SEND_ERR;
- return HSM_COM_OK;
+ hsm_com_errno_t res = HSM_COM_OK;
+ res = HSM_COM_PATH_ERR;
+ goto cleanup;
+ res = HSM_COM_BIND_ERR;
+ goto cleanup;
+ res = HSM_COM_CHMOD_ERR;
+ goto cleanup;
+ res = HSM_COM_CONX_ERR;
+ goto cleanup;
+ res = HSM_COM_SEND_ERR;
+ return res;
+ cleanup:
+ close(fd);
+ return res;","unix_client_connect(hsm_com_client_hdl_t *hdl) { int fd, len; struct sockaddr_un unix_addr; hsm_com_errno_t res = HSM_COM_OK; if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) { return HSM_COM_ERROR; } memset(&unix_addr,0,sizeof(unix_addr)); unix_addr.sun_family = AF_UNIX; if(strlen(hdl->c_path) >= sizeof(unix_addr.sun_path)) { res = HSM_COM_PATH_ERR; goto cleanup; } snprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path), ""%s"", hdl->c_path); len = SUN_LEN(&unix_addr); unlink(unix_addr.sun_path); if(bind(fd, (struct sockaddr *)&unix_addr, len) < 0) { res = HSM_COM_BIND_ERR; goto cleanup; } if(chmod(unix_addr.sun_path, S_IRWXU) < 0) { res = HSM_COM_CHMOD_ERR; goto cleanup; } memset(&unix_addr,0,sizeof(unix_addr)); unix_addr.sun_family = AF_UNIX; strncpy(unix_addr.sun_path, hdl->s_path, sizeof(unix_addr.sun_path)); unix_addr.sun_path[sizeof(unix_addr.sun_path)-1] = 0; len = SUN_LEN(&unix_addr); if (connect(fd, (struct sockaddr *) &unix_addr, len) < 0) { res = HSM_COM_CONX_ERR; goto cleanup; } hdl->client_fd = fd; hdl->client_state = HSM_COM_C_STATE_CT; if(unix_sck_send_conn(hdl, 2) != HSM_COM_OK) { hdl->client_state = HSM_COM_C_STATE_IN; res = HSM_COM_SEND_ERR; } return res; cleanup: close(fd); return res; }"
485,3498----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/key.c----key_reject_and_link,"int key_reject_and_link(struct key *key, unsigned timeout, unsigned error, struct key *keyring, struct key *authkey) { struct assoc_array_edit *edit; struct timespec now; int ret, awaken, link_ret = 0; key_check(key); key_check(keyring); awaken = 0; ret = -EBUSY; if (keyring) { if (keyring->restrict_link) return -EPERM; link_ret = __key_link_begin(keyring, &key->index_key, &edit); } mutex_lock(&key_construction_mutex); <S2SV_StartVul> if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) { <S2SV_EndVul> atomic_inc(&key->user->nikeys); <S2SV_StartVul> key->reject_error = -error; <S2SV_EndVul> <S2SV_StartVul> smp_wmb(); <S2SV_EndVul> <S2SV_StartVul> set_bit(KEY_FLAG_NEGATIVE, &key->flags); <S2SV_EndVul> <S2SV_StartVul> set_bit(KEY_FLAG_INSTANTIATED, &key->flags); <S2SV_EndVul> now = current_kernel_time(); key->expiry = now.tv_sec + timeout; key_schedule_gc(key->expiry + key_gc_delay); if (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) awaken = 1; ret = 0; if (keyring && link_ret == 0) __key_link(key, &edit); if (authkey) key_revoke(authkey); } mutex_unlock(&key_construction_mutex); if (keyring && link_ret == 0) __key_link_end(keyring, &key->index_key, edit); if (awaken) wake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT); return ret == 0 ? link_ret : ret; }","- if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {
- key->reject_error = -error;
- smp_wmb();
- set_bit(KEY_FLAG_NEGATIVE, &key->flags);
- set_bit(KEY_FLAG_INSTANTIATED, &key->flags);
+ if (key->state == KEY_IS_UNINSTANTIATED) {
+ mark_key_instantiated(key, -error);","int key_reject_and_link(struct key *key, unsigned timeout, unsigned error, struct key *keyring, struct key *authkey) { struct assoc_array_edit *edit; struct timespec now; int ret, awaken, link_ret = 0; key_check(key); key_check(keyring); awaken = 0; ret = -EBUSY; if (keyring) { if (keyring->restrict_link) return -EPERM; link_ret = __key_link_begin(keyring, &key->index_key, &edit); } mutex_lock(&key_construction_mutex); if (key->state == KEY_IS_UNINSTANTIATED) { atomic_inc(&key->user->nikeys); mark_key_instantiated(key, -error); now = current_kernel_time(); key->expiry = now.tv_sec + timeout; key_schedule_gc(key->expiry + key_gc_delay); if (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) awaken = 1; ret = 0; if (keyring && link_ret == 0) __key_link(key, &edit); if (authkey) key_revoke(authkey); } mutex_unlock(&key_construction_mutex); if (keyring && link_ret == 0) __key_link_end(keyring, &key->index_key, edit); if (awaken) wake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT); return ret == 0 ? link_ret : ret; }"
486,2325----CWE-400----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-11413--jsstring.c----Sp_replace_regexp,"static void Sp_replace_regexp(js_State *J) { js_Regexp *re; const char *source, *s, *r; js_Buffer *sb = NULL; int n, x; Resub m; source = checkstring(J, 0); re = js_toregexp(J, 1); <S2SV_StartVul> if (js_regexec(re->prog, source, &m, 0)) { <S2SV_EndVul> js_copy(J, 0); return; } re->last = 0; loop: s = m.sub[0].sp; n = m.sub[0].ep - m.sub[0].sp; if (js_iscallable(J, 2)) { js_copy(J, 2); js_pushundefined(J); for (x = 0; m.sub[x].sp; ++x) js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp); js_pushnumber(J, s - source); js_copy(J, 0); js_call(J, 2 + x); r = js_tostring(J, -1); js_putm(J, &sb, source, s); js_puts(J, &sb, r); js_pop(J, 1); } else { r = js_tostring(J, 2); js_putm(J, &sb, source, s); while (*r) { if (*r == '$') { switch (*(++r)) { case 0: --r; case '$': js_putc(J, &sb, '$'); break; case '`': js_putm(J, &sb, source, s); break; case '\'': js_puts(J, &sb, s + n); break; case '&': js_putm(J, &sb, s, s + n); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': x = *r - '0'; if (r[1] >= '0' && r[1] <= '9') x = x * 10 + *(++r) - '0'; if (x > 0 && x < m.nsub) { js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep); } else { js_putc(J, &sb, '$'); if (x > 10) { js_putc(J, &sb, '0' + x / 10); js_putc(J, &sb, '0' + x % 10); } else { js_putc(J, &sb, '0' + x); } } break; default: js_putc(J, &sb, '$'); js_putc(J, &sb, *r); break; } ++r; } else { js_putc(J, &sb, *r++); } } } if (re->flags & JS_REGEXP_G) { source = m.sub[0].ep; if (n == 0) { if (*source) js_putc(J, &sb, *source++); else goto end; } <S2SV_StartVul> if (!js_regexec(re->prog, source, &m, REG_NOTBOL)) <S2SV_EndVul> goto loop; } end: js_puts(J, &sb, s + n); js_putc(J, &sb, 0); if (js_try(J)) { js_free(J, sb); js_throw(J); } js_pushstring(J, sb ? sb->s : """"); js_endtry(J); js_free(J, sb); }","- if (js_regexec(re->prog, source, &m, 0)) {
- if (!js_regexec(re->prog, source, &m, REG_NOTBOL))
+ if (js_doregexec(J, re->prog, source, &m, 0)) {
+ if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))","static void Sp_replace_regexp(js_State *J) { js_Regexp *re; const char *source, *s, *r; js_Buffer *sb = NULL; int n, x; Resub m; source = checkstring(J, 0); re = js_toregexp(J, 1); if (js_doregexec(J, re->prog, source, &m, 0)) { js_copy(J, 0); return; } re->last = 0; loop: s = m.sub[0].sp; n = m.sub[0].ep - m.sub[0].sp; if (js_iscallable(J, 2)) { js_copy(J, 2); js_pushundefined(J); for (x = 0; m.sub[x].sp; ++x) js_pushlstring(J, m.sub[x].sp, m.sub[x].ep - m.sub[x].sp); js_pushnumber(J, s - source); js_copy(J, 0); js_call(J, 2 + x); r = js_tostring(J, -1); js_putm(J, &sb, source, s); js_puts(J, &sb, r); js_pop(J, 1); } else { r = js_tostring(J, 2); js_putm(J, &sb, source, s); while (*r) { if (*r == '$') { switch (*(++r)) { case 0: --r; case '$': js_putc(J, &sb, '$'); break; case '`': js_putm(J, &sb, source, s); break; case '\'': js_puts(J, &sb, s + n); break; case '&': js_putm(J, &sb, s, s + n); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': x = *r - '0'; if (r[1] >= '0' && r[1] <= '9') x = x * 10 + *(++r) - '0'; if (x > 0 && x < m.nsub) { js_putm(J, &sb, m.sub[x].sp, m.sub[x].ep); } else { js_putc(J, &sb, '$'); if (x > 10) { js_putc(J, &sb, '0' + x / 10); js_putc(J, &sb, '0' + x % 10); } else { js_putc(J, &sb, '0' + x); } } break; default: js_putc(J, &sb, '$'); js_putc(J, &sb, *r); break; } ++r; } else { js_putc(J, &sb, *r++); } } } if (re->flags & JS_REGEXP_G) { source = m.sub[0].ep; if (n == 0) { if (*source) js_putc(J, &sb, *source++); else goto end; } if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL)) goto loop; } end: js_puts(J, &sb, s + n); js_putc(J, &sb, 0); if (js_try(J)) { js_free(J, sb); js_throw(J); } js_pushstring(J, sb ? sb->s : """"); js_endtry(J); js_free(J, sb); }"
487,2742----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/output_core.c----ip6_find_1stfragopt,"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr) { u16 offset = sizeof(struct ipv6hdr); <S2SV_StartVul> struct ipv6_opt_hdr *exthdr = <S2SV_EndVul> <S2SV_StartVul> (struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1); <S2SV_EndVul> unsigned int packet_len = skb_tail_pointer(skb) - skb_network_header(skb); int found_rhdr = 0; *nexthdr = &ipv6_hdr(skb)->nexthdr; <S2SV_StartVul> while (offset + 1 <= packet_len) { <S2SV_EndVul> switch (**nexthdr) { case NEXTHDR_HOP: break; case NEXTHDR_ROUTING: found_rhdr = 1; break; case NEXTHDR_DEST: #if IS_ENABLED(CONFIG_IPV6_MIP6) if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0) break; #endif if (found_rhdr) return offset; break; default: return offset; } <S2SV_StartVul> offset += ipv6_optlen(exthdr); <S2SV_EndVul> <S2SV_StartVul> *nexthdr = &exthdr->nexthdr; <S2SV_EndVul> exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) + offset); } <S2SV_StartVul> return offset; <S2SV_EndVul> }","- struct ipv6_opt_hdr *exthdr =
- (struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
- while (offset + 1 <= packet_len) {
- offset += ipv6_optlen(exthdr);
- return offset;
+ while (offset <= packet_len) {
+ struct ipv6_opt_hdr *exthdr;
+ if (offset + sizeof(struct ipv6_opt_hdr) > packet_len)
+ return -EINVAL;
+ offset += ipv6_optlen(exthdr);
+ return -EINVAL;","int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr) { u16 offset = sizeof(struct ipv6hdr); unsigned int packet_len = skb_tail_pointer(skb) - skb_network_header(skb); int found_rhdr = 0; *nexthdr = &ipv6_hdr(skb)->nexthdr; while (offset <= packet_len) { struct ipv6_opt_hdr *exthdr; switch (**nexthdr) { case NEXTHDR_HOP: break; case NEXTHDR_ROUTING: found_rhdr = 1; break; case NEXTHDR_DEST: #if IS_ENABLED(CONFIG_IPV6_MIP6) if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0) break; #endif if (found_rhdr) return offset; break; default: return offset; } if (offset + sizeof(struct ipv6_opt_hdr) > packet_len) return -EINVAL; exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) + offset); offset += ipv6_optlen(exthdr); *nexthdr = &exthdr->nexthdr; } return -EINVAL; }"
488,3727----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/unaligned.c----emulate_load_store_insn,"static void emulate_load_store_insn(struct pt_regs *regs, void __user *addr, unsigned int __user *pc) { union mips_instruction insn; unsigned long value; unsigned int res; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, <S2SV_EndVul> <S2SV_StartVul> 1, 0, regs, 0); <S2SV_EndVul> __get_user(insn.word, pc); switch (insn.i_format.opcode) { case ll_op: case lld_op: case sc_op: case scd_op: case ldl_op: case ldr_op: case lwl_op: case lwr_op: case sdl_op: case sdr_op: case swl_op: case swr_op: case lb_op: case lbu_op: case sb_op: goto sigbus; case lh_op: if (!access_ok(VERIFY_READ, addr, 2)) goto sigbus; __asm__ __volatile__ ("".set\tnoat\n"" #ifdef __BIG_ENDIAN ""1:\tlb\t%0, 0(%2)\n"" ""2:\tlbu\t$1, 1(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlb\t%0, 1(%2)\n"" ""2:\tlbu\t$1, 0(%2)\n\t"" #endif ""sll\t%0, 0x8\n\t"" ""or\t%0, $1\n\t"" ""li\t%1, 0\n"" ""3:\t.set\tat\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; case lw_op: if (!access_ok(VERIFY_READ, addr, 4)) goto sigbus; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tlwl\t%0, (%2)\n"" ""2:\tlwr\t%0, 3(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlwl\t%0, 3(%2)\n"" ""2:\tlwr\t%0, (%2)\n\t"" #endif ""li\t%1, 0\n"" ""3:\t.section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; case lhu_op: if (!access_ok(VERIFY_READ, addr, 2)) goto sigbus; __asm__ __volatile__ ( "".set\tnoat\n"" #ifdef __BIG_ENDIAN ""1:\tlbu\t%0, 0(%2)\n"" ""2:\tlbu\t$1, 1(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlbu\t%0, 1(%2)\n"" ""2:\tlbu\t$1, 0(%2)\n\t"" #endif ""sll\t%0, 0x8\n\t"" ""or\t%0, $1\n\t"" ""li\t%1, 0\n"" ""3:\t.set\tat\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; case lwu_op: #ifdef CONFIG_64BIT if (!access_ok(VERIFY_READ, addr, 4)) goto sigbus; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tlwl\t%0, (%2)\n"" ""2:\tlwr\t%0, 3(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlwl\t%0, 3(%2)\n"" ""2:\tlwr\t%0, (%2)\n\t"" #endif ""dsll\t%0, %0, 32\n\t"" ""dsrl\t%0, %0, 32\n\t"" ""li\t%1, 0\n"" ""3:\t.section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; #endif goto sigill; case ld_op: #ifdef CONFIG_64BIT if (!access_ok(VERIFY_READ, addr, 8)) goto sigbus; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tldl\t%0, (%2)\n"" ""2:\tldr\t%0, 7(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tldl\t%0, 7(%2)\n"" ""2:\tldr\t%0, (%2)\n\t"" #endif ""li\t%1, 0\n"" ""3:\t.section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; #endif goto sigill; case sh_op: if (!access_ok(VERIFY_WRITE, addr, 2)) goto sigbus; value = regs->regs[insn.i_format.rt]; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN "".set\tnoat\n"" ""1:\tsb\t%1, 1(%2)\n\t"" ""srl\t$1, %1, 0x8\n"" ""2:\tsb\t$1, 0(%2)\n\t"" "".set\tat\n\t"" #endif #ifdef __LITTLE_ENDIAN "".set\tnoat\n"" ""1:\tsb\t%1, 0(%2)\n\t"" ""srl\t$1,%1, 0x8\n"" ""2:\tsb\t$1, 1(%2)\n\t"" "".set\tat\n\t"" #endif ""li\t%0, 0\n"" ""3:\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%0, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=r"" (res) : ""r"" (value), ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); break; case sw_op: if (!access_ok(VERIFY_WRITE, addr, 4)) goto sigbus; value = regs->regs[insn.i_format.rt]; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tswl\t%1,(%2)\n"" ""2:\tswr\t%1, 3(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tswl\t%1, 3(%2)\n"" ""2:\tswr\t%1, (%2)\n\t"" #endif ""li\t%0, 0\n"" ""3:\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%0, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=r"" (res) : ""r"" (value), ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); break; case sd_op: #ifdef CONFIG_64BIT if (!access_ok(VERIFY_WRITE, addr, 8)) goto sigbus; value = regs->regs[insn.i_format.rt]; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tsdl\t%1,(%2)\n"" ""2:\tsdr\t%1, 7(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tsdl\t%1, 7(%2)\n"" ""2:\tsdr\t%1, (%2)\n\t"" #endif ""li\t%0, 0\n"" ""3:\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%0, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=r"" (res) : ""r"" (value), ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); break; #endif goto sigill; case lwc1_op: case ldc1_op: case swc1_op: case sdc1_op: goto sigbus; case lwc2_op: cu2_notifier_call_chain(CU2_LWC2_OP, regs); break; case ldc2_op: cu2_notifier_call_chain(CU2_LDC2_OP, regs); break; case swc2_op: cu2_notifier_call_chain(CU2_SWC2_OP, regs); break; case sdc2_op: cu2_notifier_call_chain(CU2_SDC2_OP, regs); break; default: goto sigill; } #ifdef CONFIG_DEBUG_FS unaligned_instructions++; #endif return; fault: if (fixup_exception(regs)) return; die_if_kernel(""Unhandled kernel unaligned access"", regs); force_sig(SIGSEGV, current); return; sigbus: die_if_kernel(""Unhandled kernel unaligned access"", regs); force_sig(SIGBUS, current); return; sigill: die_if_kernel(""Unhandled kernel unaligned access or invalid instruction"", regs); force_sig(SIGILL, current); }","- perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,
- 1, 0, regs, 0);
+ perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);","static void emulate_load_store_insn(struct pt_regs *regs, void __user *addr, unsigned int __user *pc) { union mips_instruction insn; unsigned long value; unsigned int res; perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0); __get_user(insn.word, pc); switch (insn.i_format.opcode) { case ll_op: case lld_op: case sc_op: case scd_op: case ldl_op: case ldr_op: case lwl_op: case lwr_op: case sdl_op: case sdr_op: case swl_op: case swr_op: case lb_op: case lbu_op: case sb_op: goto sigbus; case lh_op: if (!access_ok(VERIFY_READ, addr, 2)) goto sigbus; __asm__ __volatile__ ("".set\tnoat\n"" #ifdef __BIG_ENDIAN ""1:\tlb\t%0, 0(%2)\n"" ""2:\tlbu\t$1, 1(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlb\t%0, 1(%2)\n"" ""2:\tlbu\t$1, 0(%2)\n\t"" #endif ""sll\t%0, 0x8\n\t"" ""or\t%0, $1\n\t"" ""li\t%1, 0\n"" ""3:\t.set\tat\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; case lw_op: if (!access_ok(VERIFY_READ, addr, 4)) goto sigbus; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tlwl\t%0, (%2)\n"" ""2:\tlwr\t%0, 3(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlwl\t%0, 3(%2)\n"" ""2:\tlwr\t%0, (%2)\n\t"" #endif ""li\t%1, 0\n"" ""3:\t.section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; case lhu_op: if (!access_ok(VERIFY_READ, addr, 2)) goto sigbus; __asm__ __volatile__ ( "".set\tnoat\n"" #ifdef __BIG_ENDIAN ""1:\tlbu\t%0, 0(%2)\n"" ""2:\tlbu\t$1, 1(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlbu\t%0, 1(%2)\n"" ""2:\tlbu\t$1, 0(%2)\n\t"" #endif ""sll\t%0, 0x8\n\t"" ""or\t%0, $1\n\t"" ""li\t%1, 0\n"" ""3:\t.set\tat\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; case lwu_op: #ifdef CONFIG_64BIT if (!access_ok(VERIFY_READ, addr, 4)) goto sigbus; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tlwl\t%0, (%2)\n"" ""2:\tlwr\t%0, 3(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tlwl\t%0, 3(%2)\n"" ""2:\tlwr\t%0, (%2)\n\t"" #endif ""dsll\t%0, %0, 32\n\t"" ""dsrl\t%0, %0, 32\n\t"" ""li\t%1, 0\n"" ""3:\t.section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; #endif goto sigill; case ld_op: #ifdef CONFIG_64BIT if (!access_ok(VERIFY_READ, addr, 8)) goto sigbus; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tldl\t%0, (%2)\n"" ""2:\tldr\t%0, 7(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tldl\t%0, 7(%2)\n"" ""2:\tldr\t%0, (%2)\n\t"" #endif ""li\t%1, 0\n"" ""3:\t.section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%1, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=&r"" (value), ""=r"" (res) : ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); regs->regs[insn.i_format.rt] = value; break; #endif goto sigill; case sh_op: if (!access_ok(VERIFY_WRITE, addr, 2)) goto sigbus; value = regs->regs[insn.i_format.rt]; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN "".set\tnoat\n"" ""1:\tsb\t%1, 1(%2)\n\t"" ""srl\t$1, %1, 0x8\n"" ""2:\tsb\t$1, 0(%2)\n\t"" "".set\tat\n\t"" #endif #ifdef __LITTLE_ENDIAN "".set\tnoat\n"" ""1:\tsb\t%1, 0(%2)\n\t"" ""srl\t$1,%1, 0x8\n"" ""2:\tsb\t$1, 1(%2)\n\t"" "".set\tat\n\t"" #endif ""li\t%0, 0\n"" ""3:\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%0, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=r"" (res) : ""r"" (value), ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); break; case sw_op: if (!access_ok(VERIFY_WRITE, addr, 4)) goto sigbus; value = regs->regs[insn.i_format.rt]; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tswl\t%1,(%2)\n"" ""2:\tswr\t%1, 3(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tswl\t%1, 3(%2)\n"" ""2:\tswr\t%1, (%2)\n\t"" #endif ""li\t%0, 0\n"" ""3:\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%0, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=r"" (res) : ""r"" (value), ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); break; case sd_op: #ifdef CONFIG_64BIT if (!access_ok(VERIFY_WRITE, addr, 8)) goto sigbus; value = regs->regs[insn.i_format.rt]; __asm__ __volatile__ ( #ifdef __BIG_ENDIAN ""1:\tsdl\t%1,(%2)\n"" ""2:\tsdr\t%1, 7(%2)\n\t"" #endif #ifdef __LITTLE_ENDIAN ""1:\tsdl\t%1, 7(%2)\n"" ""2:\tsdr\t%1, (%2)\n\t"" #endif ""li\t%0, 0\n"" ""3:\n\t"" "".section\t.fixup,\""ax\""\n\t"" ""4:\tli\t%0, %3\n\t"" ""j\t3b\n\t"" "".previous\n\t"" "".section\t__ex_table,\""a\""\n\t"" STR(PTR)""\t1b, 4b\n\t"" STR(PTR)""\t2b, 4b\n\t"" "".previous"" : ""=r"" (res) : ""r"" (value), ""r"" (addr), ""i"" (-EFAULT)); if (res) goto fault; compute_return_epc(regs); break; #endif goto sigill; case lwc1_op: case ldc1_op: case swc1_op: case sdc1_op: goto sigbus; case lwc2_op: cu2_notifier_call_chain(CU2_LWC2_OP, regs); break; case ldc2_op: cu2_notifier_call_chain(CU2_LDC2_OP, regs); break; case swc2_op: cu2_notifier_call_chain(CU2_SWC2_OP, regs); break; case sdc2_op: cu2_notifier_call_chain(CU2_SDC2_OP, regs); break; default: goto sigill; } #ifdef CONFIG_DEBUG_FS unaligned_instructions++; #endif return; fault: if (fixup_exception(regs)) return; die_if_kernel(""Unhandled kernel unaligned access"", regs); force_sig(SIGSEGV, current); return; sigbus: die_if_kernel(""Unhandled kernel unaligned access"", regs); force_sig(SIGBUS, current); return; sigill: die_if_kernel(""Unhandled kernel unaligned access or invalid instruction"", regs); force_sig(SIGILL, current); }"
489,5726----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fair.c----do_sched_cfs_period_timer,"static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags) { <S2SV_StartVul> u64 runtime, runtime_expires; <S2SV_EndVul> int throttled; if (cfs_b->quota == RUNTIME_INF) goto out_deactivate; throttled = !list_empty(&cfs_b->throttled_cfs_rq); cfs_b->nr_periods += overrun; if (cfs_b->idle && !throttled) goto out_deactivate; __refill_cfs_bandwidth_runtime(cfs_b); if (!throttled) { cfs_b->idle = 1; return 0; } cfs_b->nr_throttled += overrun; <S2SV_StartVul> runtime_expires = cfs_b->runtime_expires; <S2SV_EndVul> while (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) { runtime = cfs_b->runtime; cfs_b->distribute_running = 1; raw_spin_unlock_irqrestore(&cfs_b->lock, flags); <S2SV_StartVul> runtime = distribute_cfs_runtime(cfs_b, runtime, <S2SV_EndVul> <S2SV_StartVul> runtime_expires); <S2SV_EndVul> raw_spin_lock_irqsave(&cfs_b->lock, flags); cfs_b->distribute_running = 0; throttled = !list_empty(&cfs_b->throttled_cfs_rq); lsub_positive(&cfs_b->runtime, runtime); } cfs_b->idle = 0; return 0; out_deactivate: return 1; }","- u64 runtime, runtime_expires;
- runtime_expires = cfs_b->runtime_expires;
- runtime = distribute_cfs_runtime(cfs_b, runtime,
- runtime_expires);
+ u64 runtime;
+ runtime = distribute_cfs_runtime(cfs_b, runtime);","static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags) { u64 runtime; int throttled; if (cfs_b->quota == RUNTIME_INF) goto out_deactivate; throttled = !list_empty(&cfs_b->throttled_cfs_rq); cfs_b->nr_periods += overrun; if (cfs_b->idle && !throttled) goto out_deactivate; __refill_cfs_bandwidth_runtime(cfs_b); if (!throttled) { cfs_b->idle = 1; return 0; } cfs_b->nr_throttled += overrun; while (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) { runtime = cfs_b->runtime; cfs_b->distribute_running = 1; raw_spin_unlock_irqrestore(&cfs_b->lock, flags); runtime = distribute_cfs_runtime(cfs_b, runtime); raw_spin_lock_irqsave(&cfs_b->lock, flags); cfs_b->distribute_running = 0; throttled = !list_empty(&cfs_b->throttled_cfs_rq); lsub_positive(&cfs_b->runtime, runtime); } cfs_b->idle = 0; return 0; out_deactivate: return 1; }"
490,1274----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-15265--seq_clientmgr.c----snd_seq_ioctl_create_port,"static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg) { struct snd_seq_port_info *info = arg; struct snd_seq_client_port *port; struct snd_seq_port_callback *callback; if (info->addr.client != client->number) return -EPERM; port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1); if (port == NULL) return -ENOMEM; if (client->type == USER_CLIENT && info->kernel) { <S2SV_StartVul> snd_seq_delete_port(client, port->addr.port); <S2SV_EndVul> return -EINVAL; } if (client->type == KERNEL_CLIENT) { if ((callback = info->kernel) != NULL) { if (callback->owner) port->owner = callback->owner; port->private_data = callback->private_data; port->private_free = callback->private_free; port->event_input = callback->event_input; port->c_src.open = callback->subscribe; port->c_src.close = callback->unsubscribe; port->c_dest.open = callback->use; port->c_dest.close = callback->unuse; } } info->addr = port->addr; snd_seq_set_port_info(port, info); snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port); return 0; }","- snd_seq_delete_port(client, port->addr.port);
+ int port_idx;
+ port_idx = port->addr.port;
+ snd_seq_port_unlock(port);
+ snd_seq_delete_port(client, port_idx);
+ snd_seq_port_unlock(port);","static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg) { struct snd_seq_port_info *info = arg; struct snd_seq_client_port *port; struct snd_seq_port_callback *callback; int port_idx; if (info->addr.client != client->number) return -EPERM; port = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1); if (port == NULL) return -ENOMEM; if (client->type == USER_CLIENT && info->kernel) { port_idx = port->addr.port; snd_seq_port_unlock(port); snd_seq_delete_port(client, port_idx); return -EINVAL; } if (client->type == KERNEL_CLIENT) { if ((callback = info->kernel) != NULL) { if (callback->owner) port->owner = callback->owner; port->private_data = callback->private_data; port->private_free = callback->private_free; port->event_input = callback->event_input; port->c_src.open = callback->subscribe; port->c_src.close = callback->unsubscribe; port->c_dest.open = callback->use; port->c_dest.close = callback->unuse; } } info->addr = port->addr; snd_seq_set_port_info(port, info); snd_seq_system_client_ev_port_start(port->addr.client, port->addr.port); snd_seq_port_unlock(port); return 0; }"
491,3510----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/vf_gradfun.c----filter_frame,"static int filter_frame(AVFilterLink *inlink, AVFrame *in) { GradFunContext *s = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFrame *out; int p, direct; if (av_frame_is_writable(in)) { direct = 1; out = in; } else { direct = 0; out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } <S2SV_StartVul> for (p = 0; p < 4 && in->data[p]; p++) { <S2SV_EndVul> int w = inlink->w; int h = inlink->h; int r = s->radius; if (p) { w = s->chroma_w; h = s->chroma_h; r = s->chroma_r; } if (FFMIN(w, h) > 2 * r) filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r); else if (out->data[p] != in->data[p]) av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h); } if (!direct) av_frame_free(&in); return ff_filter_frame(outlink, out); }","- for (p = 0; p < 4 && in->data[p]; p++) {
+ for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {","static int filter_frame(AVFilterLink *inlink, AVFrame *in) { GradFunContext *s = inlink->dst->priv; AVFilterLink *outlink = inlink->dst->outputs[0]; AVFrame *out; int p, direct; if (av_frame_is_writable(in)) { direct = 1; out = in; } else { direct = 0; out = ff_get_video_buffer(outlink, outlink->w, outlink->h); if (!out) { av_frame_free(&in); return AVERROR(ENOMEM); } av_frame_copy_props(out, in); } for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) { int w = inlink->w; int h = inlink->h; int r = s->radius; if (p) { w = s->chroma_w; h = s->chroma_h; r = s->chroma_r; } if (FFMIN(w, h) > 2 * r) filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r); else if (out->data[p] != in->data[p]) av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h); } if (!direct) av_frame_free(&in); return ff_filter_frame(outlink, out); }"
492,6244----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-isoclns.c----esis_print,"esis_print(netdissect_options *ndo, const uint8_t *pptr, u_int length) { const uint8_t *optr; u_int li,esis_pdu_type,source_address_length, source_address_number; const struct esis_header_t *esis_header; if (!ndo->ndo_eflag) ND_PRINT((ndo, ""ES-IS"")); if (length <= 2) { ND_PRINT((ndo, ndo->ndo_qflag ? ""bad pkt!"" : ""no header at all!"")); return; } esis_header = (const struct esis_header_t *) pptr; ND_TCHECK(*esis_header); li = esis_header->length_indicator; optr = pptr; if (esis_header->nlpid != NLPID_ESIS) { ND_PRINT((ndo, "" nlpid 0x%02x packet not supported"", esis_header->nlpid)); return; } if (esis_header->version != ESIS_VERSION) { ND_PRINT((ndo, "" version %d packet not supported"", esis_header->version)); return; } if (li > length) { ND_PRINT((ndo, "" length indicator(%u) > PDU size (%u)!"", li, length)); return; } if (li < sizeof(struct esis_header_t) + 2) { ND_PRINT((ndo, "" length indicator %u < min PDU size:"", li)); while (pptr < ndo->ndo_snapend) ND_PRINT((ndo, ""%02X"", *pptr++)); return; } esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK; if (ndo->ndo_vflag < 1) { ND_PRINT((ndo, ""%s%s, length %u"", ndo->ndo_eflag ? """" : "", "", tok2str(esis_pdu_values,""unknown type (%u)"",esis_pdu_type), length)); return; } else ND_PRINT((ndo, ""%slength %u\n\t%s (%u)"", ndo->ndo_eflag ? """" : "", "", length, tok2str(esis_pdu_values,""unknown type: %u"", esis_pdu_type), esis_pdu_type)); ND_PRINT((ndo, "", v: %u%s"", esis_header->version, esis_header->version == ESIS_VERSION ? """" : ""unsupported"" )); ND_PRINT((ndo, "", checksum: 0x%04x"", EXTRACT_16BITS(esis_header->cksum))); osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li); ND_PRINT((ndo, "", holding time: %us, length indicator: %u"", EXTRACT_16BITS(esis_header->holdtime), li)); if (ndo->ndo_vflag > 1) print_unknown_data(ndo, optr, ""\n\t"", sizeof(struct esis_header_t)); pptr += sizeof(struct esis_header_t); li -= sizeof(struct esis_header_t); switch (esis_pdu_type) { case ESIS_PDU_REDIRECT: { const uint8_t *dst, *snpa, *neta; u_int dstl, snpal, netal; ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } dstl = *pptr; pptr++; li--; ND_TCHECK2(*pptr, dstl); if (li < dstl) { ND_PRINT((ndo, "", bad redirect/li"")); return; } dst = pptr; pptr += dstl; li -= dstl; ND_PRINT((ndo, ""\n\t %s"", isonsap_string(ndo, dst, dstl))); ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } snpal = *pptr; pptr++; li--; ND_TCHECK2(*pptr, snpal); if (li < snpal) { ND_PRINT((ndo, "", bad redirect/li"")); return; } snpa = pptr; pptr += snpal; li -= snpal; ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } netal = *pptr; pptr++; ND_TCHECK2(*pptr, netal); if (li < netal) { ND_PRINT((ndo, "", bad redirect/li"")); return; } neta = pptr; pptr += netal; li -= netal; <S2SV_StartVul> if (netal == 0) <S2SV_EndVul> <S2SV_StartVul> ND_PRINT((ndo, ""\n\t %s"", etheraddr_string(ndo, snpa))); <S2SV_EndVul> else <S2SV_StartVul> ND_PRINT((ndo, ""\n\t %s"", isonsap_string(ndo, neta, netal))); <S2SV_EndVul> break; } case ESIS_PDU_ESH: ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad esh/li"")); return; } source_address_number = *pptr; pptr++; li--; ND_PRINT((ndo, ""\n\t Number of Source Addresses: %u"", source_address_number)); while (source_address_number > 0) { ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad esh/li"")); return; } source_address_length = *pptr; pptr++; li--; ND_TCHECK2(*pptr, source_address_length); if (li < source_address_length) { ND_PRINT((ndo, "", bad esh/li"")); return; } ND_PRINT((ndo, ""\n\t NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length))); pptr += source_address_length; li -= source_address_length; source_address_number--; } break; case ESIS_PDU_ISH: { ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad ish/li"")); return; } source_address_length = *pptr; pptr++; li--; ND_TCHECK2(*pptr, source_address_length); if (li < source_address_length) { ND_PRINT((ndo, "", bad ish/li"")); return; } ND_PRINT((ndo, ""\n\t NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length))); pptr += source_address_length; li -= source_address_length; break; } default: if (ndo->ndo_vflag <= 1) { if (pptr < ndo->ndo_snapend) print_unknown_data(ndo, pptr, ""\n\t "", ndo->ndo_snapend - pptr); } return; } while (li != 0) { u_int op, opli; const uint8_t *tptr; if (li < 2) { ND_PRINT((ndo, "", bad opts/li"")); return; } ND_TCHECK2(*pptr, 2); op = *pptr++; opli = *pptr++; li -= 2; if (opli > li) { ND_PRINT((ndo, "", opt (%d) too long"", op)); return; } li -= opli; tptr = pptr; ND_PRINT((ndo, ""\n\t %s Option #%u, length %u, value: "", tok2str(esis_option_values,""Unknown"",op), op, opli)); switch (op) { case ESIS_OPTION_ES_CONF_TIME: if (opli == 2) { ND_TCHECK2(*pptr, 2); ND_PRINT((ndo, ""%us"", EXTRACT_16BITS(tptr))); } else ND_PRINT((ndo, ""(bad length)"")); break; case ESIS_OPTION_PROTOCOLS: while (opli>0) { ND_TCHECK(*pptr); ND_PRINT((ndo, ""%s (0x%02x)"", tok2str(nlpid_values, ""unknown"", *tptr), *tptr)); if (opli>1) ND_PRINT((ndo, "", "")); tptr++; opli--; } break; case ESIS_OPTION_QOS_MAINTENANCE: case ESIS_OPTION_SECURITY: case ESIS_OPTION_PRIORITY: case ESIS_OPTION_ADDRESS_MASK: case ESIS_OPTION_SNPA_MASK: default: print_unknown_data(ndo, tptr, ""\n\t "", opli); break; } if (ndo->ndo_vflag > 1) print_unknown_data(ndo, pptr, ""\n\t "", opli); pptr += opli; } trunc: return; }","- if (netal == 0)
- ND_PRINT((ndo, ""\n\t %s"", etheraddr_string(ndo, snpa)));
- ND_PRINT((ndo, ""\n\t %s"", isonsap_string(ndo, neta, netal)));
+ if (snpal == 6)
+ ND_PRINT((ndo, ""\n\t SNPA (length: %u): %s"",
+ snpal,
+ etheraddr_string(ndo, snpa)));
+ ND_PRINT((ndo, ""\n\t SNPA (length: %u): %s"",
+ snpal,
+ linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));
+ if (netal != 0)
+ ND_PRINT((ndo, ""\n\t NET (length: %u) %s"",
+ netal,
+ isonsap_string(ndo, neta, netal)));","esis_print(netdissect_options *ndo, const uint8_t *pptr, u_int length) { const uint8_t *optr; u_int li,esis_pdu_type,source_address_length, source_address_number; const struct esis_header_t *esis_header; if (!ndo->ndo_eflag) ND_PRINT((ndo, ""ES-IS"")); if (length <= 2) { ND_PRINT((ndo, ndo->ndo_qflag ? ""bad pkt!"" : ""no header at all!"")); return; } esis_header = (const struct esis_header_t *) pptr; ND_TCHECK(*esis_header); li = esis_header->length_indicator; optr = pptr; if (esis_header->nlpid != NLPID_ESIS) { ND_PRINT((ndo, "" nlpid 0x%02x packet not supported"", esis_header->nlpid)); return; } if (esis_header->version != ESIS_VERSION) { ND_PRINT((ndo, "" version %d packet not supported"", esis_header->version)); return; } if (li > length) { ND_PRINT((ndo, "" length indicator(%u) > PDU size (%u)!"", li, length)); return; } if (li < sizeof(struct esis_header_t) + 2) { ND_PRINT((ndo, "" length indicator %u < min PDU size:"", li)); while (pptr < ndo->ndo_snapend) ND_PRINT((ndo, ""%02X"", *pptr++)); return; } esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK; if (ndo->ndo_vflag < 1) { ND_PRINT((ndo, ""%s%s, length %u"", ndo->ndo_eflag ? """" : "", "", tok2str(esis_pdu_values,""unknown type (%u)"",esis_pdu_type), length)); return; } else ND_PRINT((ndo, ""%slength %u\n\t%s (%u)"", ndo->ndo_eflag ? """" : "", "", length, tok2str(esis_pdu_values,""unknown type: %u"", esis_pdu_type), esis_pdu_type)); ND_PRINT((ndo, "", v: %u%s"", esis_header->version, esis_header->version == ESIS_VERSION ? """" : ""unsupported"" )); ND_PRINT((ndo, "", checksum: 0x%04x"", EXTRACT_16BITS(esis_header->cksum))); osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li); ND_PRINT((ndo, "", holding time: %us, length indicator: %u"", EXTRACT_16BITS(esis_header->holdtime), li)); if (ndo->ndo_vflag > 1) print_unknown_data(ndo, optr, ""\n\t"", sizeof(struct esis_header_t)); pptr += sizeof(struct esis_header_t); li -= sizeof(struct esis_header_t); switch (esis_pdu_type) { case ESIS_PDU_REDIRECT: { const uint8_t *dst, *snpa, *neta; u_int dstl, snpal, netal; ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } dstl = *pptr; pptr++; li--; ND_TCHECK2(*pptr, dstl); if (li < dstl) { ND_PRINT((ndo, "", bad redirect/li"")); return; } dst = pptr; pptr += dstl; li -= dstl; ND_PRINT((ndo, ""\n\t %s"", isonsap_string(ndo, dst, dstl))); ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } snpal = *pptr; pptr++; li--; ND_TCHECK2(*pptr, snpal); if (li < snpal) { ND_PRINT((ndo, "", bad redirect/li"")); return; } snpa = pptr; pptr += snpal; li -= snpal; ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } netal = *pptr; pptr++; ND_TCHECK2(*pptr, netal); if (li < netal) { ND_PRINT((ndo, "", bad redirect/li"")); return; } neta = pptr; pptr += netal; li -= netal; if (snpal == 6) ND_PRINT((ndo, ""\n\t SNPA (length: %u): %s"", snpal, etheraddr_string(ndo, snpa))); else ND_PRINT((ndo, ""\n\t SNPA (length: %u): %s"", snpal, linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal))); if (netal != 0) ND_PRINT((ndo, ""\n\t NET (length: %u) %s"", netal, isonsap_string(ndo, neta, netal))); break; } case ESIS_PDU_ESH: ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad esh/li"")); return; } source_address_number = *pptr; pptr++; li--; ND_PRINT((ndo, ""\n\t Number of Source Addresses: %u"", source_address_number)); while (source_address_number > 0) { ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad esh/li"")); return; } source_address_length = *pptr; pptr++; li--; ND_TCHECK2(*pptr, source_address_length); if (li < source_address_length) { ND_PRINT((ndo, "", bad esh/li"")); return; } ND_PRINT((ndo, ""\n\t NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length))); pptr += source_address_length; li -= source_address_length; source_address_number--; } break; case ESIS_PDU_ISH: { ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad ish/li"")); return; } source_address_length = *pptr; pptr++; li--; ND_TCHECK2(*pptr, source_address_length); if (li < source_address_length) { ND_PRINT((ndo, "", bad ish/li"")); return; } ND_PRINT((ndo, ""\n\t NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length))); pptr += source_address_length; li -= source_address_length; break; } default: if (ndo->ndo_vflag <= 1) { if (pptr < ndo->ndo_snapend) print_unknown_data(ndo, pptr, ""\n\t "", ndo->ndo_snapend - pptr); } return; } while (li != 0) { u_int op, opli; const uint8_t *tptr; if (li < 2) { ND_PRINT((ndo, "", bad opts/li"")); return; } ND_TCHECK2(*pptr, 2); op = *pptr++; opli = *pptr++; li -= 2; if (opli > li) { ND_PRINT((ndo, "", opt (%d) too long"", op)); return; } li -= opli; tptr = pptr; ND_PRINT((ndo, ""\n\t %s Option #%u, length %u, value: "", tok2str(esis_option_values,""Unknown"",op), op, opli)); switch (op) { case ESIS_OPTION_ES_CONF_TIME: if (opli == 2) { ND_TCHECK2(*pptr, 2); ND_PRINT((ndo, ""%us"", EXTRACT_16BITS(tptr))); } else ND_PRINT((ndo, ""(bad length)"")); break; case ESIS_OPTION_PROTOCOLS: while (opli>0) { ND_TCHECK(*pptr); ND_PRINT((ndo, ""%s (0x%02x)"", tok2str(nlpid_values, ""unknown"", *tptr), *tptr)); if (opli>1) ND_PRINT((ndo, "", "")); tptr++; opli--; } break; case ESIS_OPTION_QOS_MAINTENANCE: case ESIS_OPTION_SECURITY: case ESIS_OPTION_PRIORITY: case ESIS_OPTION_ADDRESS_MASK: case ESIS_OPTION_SNPA_MASK: default: print_unknown_data(ndo, tptr, ""\n\t "", opli); break; } if (ndo->ndo_vflag > 1) print_unknown_data(ndo, pptr, ""\n\t "", opli); pptr += opli; } trunc: return; }"
493,2589----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-13307--statistic.c----**AcquirePixelThreadSet,"static PixelChannels **AcquirePixelThreadSet(const Image *images) { const Image *next; PixelChannels **pixels; register ssize_t i; size_t columns, <S2SV_StartVul> number_threads; <S2SV_EndVul> <S2SV_StartVul> number_threads=(size_t) GetMagickResourceLimit(ThreadResource); <S2SV_EndVul> <S2SV_StartVul> pixels=(PixelChannels **) AcquireQuantumMemory(number_threads, <S2SV_EndVul> <S2SV_StartVul> sizeof(*pixels)); <S2SV_EndVul> if (pixels == (PixelChannels **) NULL) return((PixelChannels **) NULL); <S2SV_StartVul> (void) memset(pixels,0,number_threads*sizeof(*pixels)); <S2SV_EndVul> <S2SV_StartVul> columns=images->columns; <S2SV_EndVul> for (next=images; next != (Image *) NULL; next=next->next) columns=MagickMax(next->columns,columns); <S2SV_StartVul> for (i=0; i < (ssize_t) number_threads; i++) <S2SV_EndVul> { register ssize_t j; pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels)); if (pixels[i] == (PixelChannels *) NULL) return(DestroyPixelThreadSet(pixels)); for (j=0; j < (ssize_t) columns; j++) { register ssize_t k; for (k=0; k < MaxPixelChannels; k++) pixels[i][j].channel[k]=0.0; } } return(pixels); }","- number_threads;
- number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
- pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,
- sizeof(*pixels));
- (void) memset(pixels,0,number_threads*sizeof(*pixels));
- columns=images->columns;
- for (i=0; i < (ssize_t) number_threads; i++)
+ 
+ (size_t) GetMagickResourceLimit(ThreadResource));
+ pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels));
+ if (pixels == (PixelChannels **) NULL)
+ for (next=images; next != (Image *) NULL; next=next->next)
+ {","static PixelChannels **AcquirePixelThreadSet(const Image *images) { const Image *next; PixelChannels **pixels; register ssize_t i; size_t columns, rows; rows=MagickMax(GetImageListLength(images), (size_t) GetMagickResourceLimit(ThreadResource)); pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels)); if (pixels == (PixelChannels **) NULL) return((PixelChannels **) NULL); columns=MaxPixelChannels; for (next=images; next != (Image *) NULL; next=next->next) columns=MagickMax(next->columns,columns); for (i=0; i < (ssize_t) rows; i++) { register ssize_t j; pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels)); if (pixels[i] == (PixelChannels *) NULL) return(DestroyPixelThreadSet(pixels)); for (j=0; j < (ssize_t) columns; j++) { register ssize_t k; for (k=0; k < MaxPixelChannels; k++) pixels[i][j].channel[k]=0.0; } } return(pixels); }"
494,1047----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4301--archive_read_support_format_mtree.c----parse_device,"parse_device(dev_t *pdev, struct archive *a, char *val) { #define MAX_PACK_ARGS 3 unsigned long numbers[MAX_PACK_ARGS]; char *p, *dev; int argc; pack_t *pack; dev_t result; const char *error = NULL; memset(pdev, 0, sizeof(*pdev)); if ((dev = strchr(val, ',')) != NULL) { *dev++ = '\0'; if ((pack = pack_find(val)) == NULL) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Unknown format `%s'"", val); return ARCHIVE_WARN; } argc = 0; while ((p = la_strsep(&dev, "","")) != NULL) { if (*p == '\0') { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Missing number""); return ARCHIVE_WARN; } <S2SV_StartVul> numbers[argc++] = (unsigned long)mtree_atol(&p); <S2SV_EndVul> <S2SV_StartVul> if (argc > MAX_PACK_ARGS) { <S2SV_EndVul> archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Too many arguments""); return ARCHIVE_WARN; } } if (argc < 2) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Not enough arguments""); return ARCHIVE_WARN; } result = (*pack)(argc, numbers, &error); if (error != NULL) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""%s"", error); return ARCHIVE_WARN; } } else { result = (dev_t)mtree_atol(&val); } *pdev = result; return ARCHIVE_OK; #undef MAX_PACK_ARGS }","- numbers[argc++] = (unsigned long)mtree_atol(&p);
- if (argc > MAX_PACK_ARGS) {
+ if (argc >= MAX_PACK_ARGS) {
+ numbers[argc++] = (unsigned long)mtree_atol(&p);","parse_device(dev_t *pdev, struct archive *a, char *val) { #define MAX_PACK_ARGS 3 unsigned long numbers[MAX_PACK_ARGS]; char *p, *dev; int argc; pack_t *pack; dev_t result; const char *error = NULL; memset(pdev, 0, sizeof(*pdev)); if ((dev = strchr(val, ',')) != NULL) { *dev++ = '\0'; if ((pack = pack_find(val)) == NULL) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Unknown format `%s'"", val); return ARCHIVE_WARN; } argc = 0; while ((p = la_strsep(&dev, "","")) != NULL) { if (*p == '\0') { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Missing number""); return ARCHIVE_WARN; } if (argc >= MAX_PACK_ARGS) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Too many arguments""); return ARCHIVE_WARN; } numbers[argc++] = (unsigned long)mtree_atol(&p); } if (argc < 2) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""Not enough arguments""); return ARCHIVE_WARN; } result = (*pack)(argc, numbers, &error); if (error != NULL) { archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT, ""%s"", error); return ARCHIVE_WARN; } } else { result = (dev_t)mtree_atol(&val); } *pdev = result; return ARCHIVE_OK; #undef MAX_PACK_ARGS }"
495,4779----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/StarWriterStruct.cxx----StarWriterStruct::DatabaseName::read,"bool DatabaseName::read(StarZone &zone) { STOFFInputStreamPtr input=zone.input(); libstoff::DebugFile &ascFile=zone.ascii(); libstoff::DebugStream f; long pos=input->tell(); char type; if (input->peek()!='D' || !zone.openSWRecord(type)) { input->seek(pos, librevenge::RVNG_SEEK_SET); STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a databaseName\n"")); return false; } f << ""Entries(StarDatabaseName)["" << zone.getRecordLevel() << ""]:""; std::vector<uint32_t> text; if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a string\n"")); f << ""###string""; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord('D', ""StarDatabaseName""); return true; } librevenge::RVNGString delim, dbName, tableName; libstoff::appendUnicode(0xff, delim); libstoff::splitString(libstoff::getString(text),delim, dbName, tableName); if (tableName.empty()) { if (zone.isCompatibleWith(0x11,0x22)) m_names[0]=dbName; else m_names[1]=dbName; } else { m_names[0]=dbName; m_names[1]=tableName; } if (zone.isCompatibleWith(0xf,0x101)) { if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a SQL string\n"")); f << *this << ""###SQL""; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord('D', ""StarDatabaseName""); return true; } m_sql=libstoff::getString(text); } if (zone.isCompatibleWith(0x11,0x22)) { if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a table name string\n"")); f << ""###tableName""; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord('D', ""StarDatabaseName""); return true; } m_names[1]=libstoff::getString(text); } if (zone.isCompatibleWith(0x12,0x22, 0x101)) { int nCount=int(input->readULong(2)); if (nCount>0 && zone.isCompatibleWith(0x28)) { for (int i=0; i<nCount; ++i) { if (input->tell()>=zone.getRecordLastPosition()) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a DBData\n"")); f << ""###""; break; } Data data; if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a table name string\n"")); f << ""###dbDataName""; break; } data.m_name=libstoff::getString(text); int positions[2]; <S2SV_StartVul> for (int j=0; j<2; ++j) positions[i]=int(input->readULong(4)); <S2SV_EndVul> data.m_selection=STOFFVec2i(positions[0],positions[1]); m_dataList.push_back(data); } } } f << *this; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord(type, ""StarDatabaseName""); return true; }","- for (int j=0; j<2; ++j) positions[i]=int(input->readULong(4));
+ for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4));","bool DatabaseName::read(StarZone &zone) { STOFFInputStreamPtr input=zone.input(); libstoff::DebugFile &ascFile=zone.ascii(); libstoff::DebugStream f; long pos=input->tell(); char type; if (input->peek()!='D' || !zone.openSWRecord(type)) { input->seek(pos, librevenge::RVNG_SEEK_SET); STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a databaseName\n"")); return false; } f << ""Entries(StarDatabaseName)["" << zone.getRecordLevel() << ""]:""; std::vector<uint32_t> text; if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a string\n"")); f << ""###string""; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord('D', ""StarDatabaseName""); return true; } librevenge::RVNGString delim, dbName, tableName; libstoff::appendUnicode(0xff, delim); libstoff::splitString(libstoff::getString(text),delim, dbName, tableName); if (tableName.empty()) { if (zone.isCompatibleWith(0x11,0x22)) m_names[0]=dbName; else m_names[1]=dbName; } else { m_names[0]=dbName; m_names[1]=tableName; } if (zone.isCompatibleWith(0xf,0x101)) { if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a SQL string\n"")); f << *this << ""###SQL""; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord('D', ""StarDatabaseName""); return true; } m_sql=libstoff::getString(text); } if (zone.isCompatibleWith(0x11,0x22)) { if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a table name string\n"")); f << ""###tableName""; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord('D', ""StarDatabaseName""); return true; } m_names[1]=libstoff::getString(text); } if (zone.isCompatibleWith(0x12,0x22, 0x101)) { int nCount=int(input->readULong(2)); if (nCount>0 && zone.isCompatibleWith(0x28)) { for (int i=0; i<nCount; ++i) { if (input->tell()>=zone.getRecordLastPosition()) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a DBData\n"")); f << ""###""; break; } Data data; if (!zone.readString(text)) { STOFF_DEBUG_MSG((""StarWriterStruct::DatabaseName::read: can not read a table name string\n"")); f << ""###dbDataName""; break; } data.m_name=libstoff::getString(text); int positions[2]; for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4)); data.m_selection=STOFFVec2i(positions[0],positions[1]); m_dataList.push_back(data); } } } f << *this; ascFile.addPos(pos); ascFile.addNote(f.str().c_str()); zone.closeSWRecord(type, ""StarDatabaseName""); return true; }"
496,3066----CWE-908----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/kvaser_usb_leaf.c----kvaser_usb_leaf_simple_cmd_async,"static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv, u8 cmd_id) { struct kvaser_cmd *cmd; int err; <S2SV_StartVul> cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC); <S2SV_EndVul> if (!cmd) return -ENOMEM; cmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple); cmd->id = cmd_id; cmd->u.simple.channel = priv->channel; err = kvaser_usb_send_cmd_async(priv, cmd, cmd->len); if (err) kfree(cmd); return err; }","- cmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);
+ cmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);","static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv, u8 cmd_id) { struct kvaser_cmd *cmd; int err; cmd = kzalloc(sizeof(*cmd), GFP_ATOMIC); if (!cmd) return -ENOMEM; cmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple); cmd->id = cmd_id; cmd->u.simple.channel = priv->channel; err = kvaser_usb_send_cmd_async(priv, cmd, cmd->len); if (err) kfree(cmd); return err; }"
497,6591----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/http.c----http_read_header,"static int http_read_header(URLContext *h, int *new_location) { HTTPContext *s = h->priv_data; char line[MAX_URL_SIZE]; int err = 0; <S2SV_StartVul> s->chunksize = -1; <S2SV_EndVul> for (;;) { if ((err = http_get_line(s, line, sizeof(line))) < 0) return err; av_log(h, AV_LOG_TRACE, ""header='%s'\n"", line); err = process_line(h, line, s->line_count, new_location); if (err < 0) return err; if (err == 0) break; s->line_count++; } if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000) h->is_streamed = 1; cookie_string(s->cookie_dict, &s->cookies); av_dict_free(&s->cookie_dict); return err; }","- s->chunksize = -1;
+ s->chunksize = UINT64_MAX;","static int http_read_header(URLContext *h, int *new_location) { HTTPContext *s = h->priv_data; char line[MAX_URL_SIZE]; int err = 0; s->chunksize = UINT64_MAX; for (;;) { if ((err = http_get_line(s, line, sizeof(line))) < 0) return err; av_log(h, AV_LOG_TRACE, ""header='%s'\n"", line); err = process_line(h, line, s->line_count, new_location); if (err < 0) return err; if (err == 0) break; s->line_count++; } if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000) h->is_streamed = 1; cookie_string(s->cookie_dict, &s->cookies); av_dict_free(&s->cookie_dict); return err; }"
498,7375----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hb-set.cc----hb_set_symmetric_difference,"hb_set_symmetric_difference (hb_set_t *set, const hb_set_t *other) { <S2SV_StartVul> if (unlikely (hb_object_is_immutable (set))) <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> set->symmetric_difference (*other); }","- if (unlikely (hb_object_is_immutable (set)))
- return;","hb_set_symmetric_difference (hb_set_t *set, const hb_set_t *other) { set->symmetric_difference (*other); }"
499,3350----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/trusted.c----trusted_update,"static int trusted_update(struct key *key, struct key_preparsed_payload *prep) { struct trusted_key_payload *p; struct trusted_key_payload *new_p; struct trusted_key_options *new_o; size_t datalen = prep->datalen; char *datablob; int ret = 0; <S2SV_StartVul> if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) <S2SV_EndVul> return -ENOKEY; p = key->payload.data[0]; if (!p->migratable) return -EPERM; if (datalen <= 0 || datalen > 32767 || !prep->data) return -EINVAL; datablob = kmalloc(datalen + 1, GFP_KERNEL); if (!datablob) return -ENOMEM; new_o = trusted_options_alloc(); if (!new_o) { ret = -ENOMEM; goto out; } new_p = trusted_payload_alloc(key); if (!new_p) { ret = -ENOMEM; goto out; } memcpy(datablob, prep->data, datalen); datablob[datalen] = '\0'; ret = datablob_parse(datablob, new_p, new_o); if (ret != Opt_update) { ret = -EINVAL; kzfree(new_p); goto out; } if (!new_o->keyhandle) { ret = -EINVAL; kzfree(new_p); goto out; } new_p->migratable = p->migratable; new_p->key_len = p->key_len; memcpy(new_p->key, p->key, p->key_len); dump_payload(p); dump_payload(new_p); ret = key_seal(new_p, new_o); if (ret < 0) { pr_info(""trusted_key: key_seal failed (%d)\n"", ret); kzfree(new_p); goto out; } if (new_o->pcrlock) { ret = pcrlock(new_o->pcrlock); if (ret < 0) { pr_info(""trusted_key: pcrlock failed (%d)\n"", ret); kzfree(new_p); goto out; } } rcu_assign_keypointer(key, new_p); call_rcu(&p->rcu, trusted_rcu_free); out: kzfree(datablob); kzfree(new_o); return ret; }","- if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
+ if (key_is_negative(key))","static int trusted_update(struct key *key, struct key_preparsed_payload *prep) { struct trusted_key_payload *p; struct trusted_key_payload *new_p; struct trusted_key_options *new_o; size_t datalen = prep->datalen; char *datablob; int ret = 0; if (key_is_negative(key)) return -ENOKEY; p = key->payload.data[0]; if (!p->migratable) return -EPERM; if (datalen <= 0 || datalen > 32767 || !prep->data) return -EINVAL; datablob = kmalloc(datalen + 1, GFP_KERNEL); if (!datablob) return -ENOMEM; new_o = trusted_options_alloc(); if (!new_o) { ret = -ENOMEM; goto out; } new_p = trusted_payload_alloc(key); if (!new_p) { ret = -ENOMEM; goto out; } memcpy(datablob, prep->data, datalen); datablob[datalen] = '\0'; ret = datablob_parse(datablob, new_p, new_o); if (ret != Opt_update) { ret = -EINVAL; kzfree(new_p); goto out; } if (!new_o->keyhandle) { ret = -EINVAL; kzfree(new_p); goto out; } new_p->migratable = p->migratable; new_p->key_len = p->key_len; memcpy(new_p->key, p->key, p->key_len); dump_payload(p); dump_payload(new_p); ret = key_seal(new_p, new_o); if (ret < 0) { pr_info(""trusted_key: key_seal failed (%d)\n"", ret); kzfree(new_p); goto out; } if (new_o->pcrlock) { ret = pcrlock(new_o->pcrlock); if (ret < 0) { pr_info(""trusted_key: pcrlock failed (%d)\n"", ret); kzfree(new_p); goto out; } } rcu_assign_keypointer(key, new_p); call_rcu(&p->rcu, trusted_rcu_free); out: kzfree(datablob); kzfree(new_o); return ret; }"
500,5785----CWE-835----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/avi_player.c----avi_get_frame,"static pj_status_t avi_get_frame(pjmedia_port *this_port, pjmedia_frame *frame) { struct avi_reader_port *fport = (struct avi_reader_port*)this_port; pj_status_t status = PJ_SUCCESS; pj_ssize_t size_read = 0, size_to_read = 0; pj_assert(fport->base.info.signature == SIGNATURE); if (fport->eof) { PJ_LOG(5,(THIS_FILE, ""File port %.*s EOF"", (int)fport->base.info.name.slen, fport->base.info.name.ptr)); if (fport->cb2) { pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP); if (!fport->subscribed) { status = pjmedia_event_subscribe(NULL, &file_on_event, fport, fport); fport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE: PJ_FALSE; } if (fport->subscribed && fport->eof != 2) { pjmedia_event event; if (no_loop) { fport->eof = 2; } else { fport->eof = PJ_FALSE; pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET); } pjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK, NULL, fport); pjmedia_event_publish(NULL, fport, &event, PJMEDIA_EVENT_PUBLISH_POST_EVENT); } frame->type = PJMEDIA_FRAME_TYPE_NONE; frame->size = 0; return (no_loop? PJ_EEOF: PJ_SUCCESS); } else if (fport->cb) { status = (*fport->cb)(this_port, fport->base.port_data.pdata); } if ((status != PJ_SUCCESS) || (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) { frame->type = PJMEDIA_FRAME_TYPE_NONE; frame->size = 0; return PJ_EEOF; } PJ_LOG(5,(THIS_FILE, ""File port %.*s rewinding.."", (int)fport->base.info.name.slen, fport->base.info.name.ptr)); fport->eof = PJ_FALSE; pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET); } if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO && (fport->fmt_id == PJMEDIA_FORMAT_PCMA || fport->fmt_id == PJMEDIA_FORMAT_PCMU)) { frame->size >>= 1; } size_to_read = frame->size; do { pjmedia_avi_subchunk ch = {0, 0}; char *cid; unsigned stream_id; if (fport->size_left > 0 && fport->size_left < size_to_read) { status = file_read3(fport->fd, frame->buf, fport->size_left, fport->bits_per_sample, &size_read); if (status != PJ_SUCCESS) goto on_error2; size_to_read -= fport->size_left; fport->size_left = 0; } if (fport->size_left == 0) { pj_off_t pos; pj_file_getpos(fport->fd, &pos); if (fport->pad) { status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR); fport->pad = 0; } status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk)); if (status != PJ_SUCCESS) { size_read = 0; goto on_error2; } cid = (char *)&ch.id; if (cid[0] >= '0' && cid[0] <= '9' && cid[1] >= '0' && cid[1] <= '9') { stream_id = (cid[0] - '0') * 10 + (cid[1] - '0'); } else stream_id = 100; fport->pad = (pj_uint8_t)ch.len & 1; TRACE_((THIS_FILE, ""Reading movi data at pos %u (%x), id: %.*s, "" ""length: %u"", (unsigned long)pos, (unsigned long)pos, 4, cid, ch.len)); if (stream_id != fport->stream_id) { if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG)) PJ_LOG(5, (THIS_FILE, ""Unsupported LIST tag found in "" ""the movi data."")); else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) { PJ_LOG(3, (THIS_FILE, ""Unsupported format: multiple "" ""AVIs in a single file."")); status = AVI_EOF; goto on_error2; } <S2SV_StartVul> status = pj_file_setpos(fport->fd, ch.len, <S2SV_EndVul> <S2SV_StartVul> PJ_SEEK_CUR); <S2SV_EndVul> continue; } fport->size_left = ch.len; } frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ? PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO); if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) { if (size_to_read > fport->size_left) size_to_read = fport->size_left; status = file_read3(fport->fd, (char *)frame->buf + frame->size - size_to_read, size_to_read, fport->bits_per_sample, &size_read); if (status != PJ_SUCCESS) goto on_error2; fport->size_left -= size_to_read; } else { pj_assert(frame->size >= ch.len); status = file_read3(fport->fd, frame->buf, ch.len, 0, &size_read); if (status != PJ_SUCCESS) goto on_error2; frame->size = ch.len; fport->size_left = 0; } break; } while(1); frame->timestamp.u64 = fport->next_ts.u64; if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) { if (fport->fmt_id == PJMEDIA_FORMAT_PCMA || fport->fmt_id == PJMEDIA_FORMAT_PCMU) { unsigned i; pj_uint16_t *dst; pj_uint8_t *src; dst = (pj_uint16_t*)frame->buf + frame->size - 1; src = (pj_uint8_t*)frame->buf + frame->size - 1; if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) { for (i = 0; i < frame->size; ++i) { *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--); } } else { for (i = 0; i < frame->size; ++i) { *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--); } } frame->size <<= 1; } if (fport->usec_per_frame) { fport->next_ts.u64 += (fport->usec_per_frame * fport->base.info.fmt.det.aud.clock_rate / 1000000); } else { fport->next_ts.u64 += (frame->size * fport->base.info.fmt.det.aud.clock_rate / (fport->base.info.fmt.det.aud.avg_bps / 8)); } } else { if (fport->usec_per_frame) { fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE / 1000000); } else { fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE / (fport->base.info.fmt.det.vid.avg_bps / 8)); } } return PJ_SUCCESS; on_error2: if (status == AVI_EOF) { fport->eof = PJ_TRUE; size_to_read -= size_read; if (size_to_read == (pj_ssize_t)frame->size) { frame->type = PJMEDIA_FRAME_TYPE_NONE; frame->size = 0; return PJ_EEOF; } pj_bzero((char *)frame->buf + frame->size - size_to_read, size_to_read); return PJ_SUCCESS; } return status; }","- status = pj_file_setpos(fport->fd, ch.len,
- PJ_SEEK_CUR);
+ pj_off_t ch_len;
+ PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len,
+ status = PJ_EINVAL; goto on_error2;);
+ ch_len = ch.len;
+ status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);","static pj_status_t avi_get_frame(pjmedia_port *this_port, pjmedia_frame *frame) { struct avi_reader_port *fport = (struct avi_reader_port*)this_port; pj_status_t status = PJ_SUCCESS; pj_ssize_t size_read = 0, size_to_read = 0; pj_assert(fport->base.info.signature == SIGNATURE); if (fport->eof) { PJ_LOG(5,(THIS_FILE, ""File port %.*s EOF"", (int)fport->base.info.name.slen, fport->base.info.name.ptr)); if (fport->cb2) { pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP); if (!fport->subscribed) { status = pjmedia_event_subscribe(NULL, &file_on_event, fport, fport); fport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE: PJ_FALSE; } if (fport->subscribed && fport->eof != 2) { pjmedia_event event; if (no_loop) { fport->eof = 2; } else { fport->eof = PJ_FALSE; pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET); } pjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK, NULL, fport); pjmedia_event_publish(NULL, fport, &event, PJMEDIA_EVENT_PUBLISH_POST_EVENT); } frame->type = PJMEDIA_FRAME_TYPE_NONE; frame->size = 0; return (no_loop? PJ_EEOF: PJ_SUCCESS); } else if (fport->cb) { status = (*fport->cb)(this_port, fport->base.port_data.pdata); } if ((status != PJ_SUCCESS) || (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) { frame->type = PJMEDIA_FRAME_TYPE_NONE; frame->size = 0; return PJ_EEOF; } PJ_LOG(5,(THIS_FILE, ""File port %.*s rewinding.."", (int)fport->base.info.name.slen, fport->base.info.name.ptr)); fport->eof = PJ_FALSE; pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET); } if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO && (fport->fmt_id == PJMEDIA_FORMAT_PCMA || fport->fmt_id == PJMEDIA_FORMAT_PCMU)) { frame->size >>= 1; } size_to_read = frame->size; do { pjmedia_avi_subchunk ch = {0, 0}; char *cid; unsigned stream_id; if (fport->size_left > 0 && fport->size_left < size_to_read) { status = file_read3(fport->fd, frame->buf, fport->size_left, fport->bits_per_sample, &size_read); if (status != PJ_SUCCESS) goto on_error2; size_to_read -= fport->size_left; fport->size_left = 0; } if (fport->size_left == 0) { pj_off_t pos; pj_off_t ch_len; pj_file_getpos(fport->fd, &pos); if (fport->pad) { status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR); fport->pad = 0; } status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk)); if (status != PJ_SUCCESS) { size_read = 0; goto on_error2; } PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, status = PJ_EINVAL; goto on_error2;); ch_len = ch.len; cid = (char *)&ch.id; if (cid[0] >= '0' && cid[0] <= '9' && cid[1] >= '0' && cid[1] <= '9') { stream_id = (cid[0] - '0') * 10 + (cid[1] - '0'); } else stream_id = 100; fport->pad = (pj_uint8_t)ch.len & 1; TRACE_((THIS_FILE, ""Reading movi data at pos %u (%x), id: %.*s, "" ""length: %u"", (unsigned long)pos, (unsigned long)pos, 4, cid, ch.len)); if (stream_id != fport->stream_id) { if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG)) PJ_LOG(5, (THIS_FILE, ""Unsupported LIST tag found in "" ""the movi data."")); else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) { PJ_LOG(3, (THIS_FILE, ""Unsupported format: multiple "" ""AVIs in a single file."")); status = AVI_EOF; goto on_error2; } status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR); continue; } fport->size_left = ch.len; } frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ? PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO); if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) { if (size_to_read > fport->size_left) size_to_read = fport->size_left; status = file_read3(fport->fd, (char *)frame->buf + frame->size - size_to_read, size_to_read, fport->bits_per_sample, &size_read); if (status != PJ_SUCCESS) goto on_error2; fport->size_left -= size_to_read; } else { pj_assert(frame->size >= ch.len); status = file_read3(fport->fd, frame->buf, ch.len, 0, &size_read); if (status != PJ_SUCCESS) goto on_error2; frame->size = ch.len; fport->size_left = 0; } break; } while(1); frame->timestamp.u64 = fport->next_ts.u64; if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) { if (fport->fmt_id == PJMEDIA_FORMAT_PCMA || fport->fmt_id == PJMEDIA_FORMAT_PCMU) { unsigned i; pj_uint16_t *dst; pj_uint8_t *src; dst = (pj_uint16_t*)frame->buf + frame->size - 1; src = (pj_uint8_t*)frame->buf + frame->size - 1; if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) { for (i = 0; i < frame->size; ++i) { *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--); } } else { for (i = 0; i < frame->size; ++i) { *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--); } } frame->size <<= 1; } if (fport->usec_per_frame) { fport->next_ts.u64 += (fport->usec_per_frame * fport->base.info.fmt.det.aud.clock_rate / 1000000); } else { fport->next_ts.u64 += (frame->size * fport->base.info.fmt.det.aud.clock_rate / (fport->base.info.fmt.det.aud.avg_bps / 8)); } } else { if (fport->usec_per_frame) { fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE / 1000000); } else { fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE / (fport->base.info.fmt.det.vid.avg_bps / 8)); } } return PJ_SUCCESS; on_error2: if (status == AVI_EOF) { fport->eof = PJ_TRUE; size_to_read -= size_read; if (size_to_read == (pj_ssize_t)frame->size) { frame->type = PJMEDIA_FRAME_TYPE_NONE; frame->size = 0; return PJ_EEOF; } pj_bzero((char *)frame->buf + frame->size - size_to_read, size_to_read); return PJ_SUCCESS; } return status; }"
501,5479----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/snmp.c----PROCESS_THREAD,"PROCESS_THREAD(snmp_process, ev, data) { PROCESS_BEGIN(); snmp_udp_conn = udp_new(NULL, 0, NULL); udp_bind(snmp_udp_conn, SNMP_SERVER_PORT); LOG_DBG(""Listening on port %u\n"", uip_ntohs(snmp_udp_conn->lport)); while(1) { PROCESS_YIELD(); <S2SV_StartVul> if(ev == tcpip_event) { <S2SV_EndVul> <S2SV_StartVul> if(uip_newdata()) { <S2SV_EndVul> <S2SV_StartVul> snmp_process_data(); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } } PROCESS_END(); }","- if(ev == tcpip_event) {
- if(uip_newdata()) {
- snmp_process_data();
- }
+ snmp_packet_t snmp_packet;
+ if(ev != tcpip_event) {
+ continue;
+ }
+ if(!uip_newdata()) {
+ continue;
+ LOG_DBG(""receiving UDP datagram from ["");
+ LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);
+ LOG_DBG_(""]:%u"", uip_ntohs(UIP_UDP_BUF->srcport));
+ LOG_DBG_("" Length: %u\n"", uip_datalen());
+ snmp_packet.in = (uint8_t *)uip_appdata;
+ snmp_packet.used = uip_datalen();
+ snmp_packet.out = (uint8_t *)(uip_appdata + UIP_BUFSIZE - UIP_IPUDPH_LEN);
+ snmp_packet.max = UIP_BUFSIZE - UIP_IPUDPH_LEN;
+ if(!snmp_engine(&snmp_packet)) {
+ LOG_DBG(""Error while handling the request\n"");
+ continue;
+ }
+ LOG_DBG(""Sending response\n"");
+ uip_udp_packet_sendto(snmp_udp_conn, snmp_packet.out, snmp_packet.used, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);","PROCESS_THREAD(snmp_process, ev, data) { PROCESS_BEGIN(); snmp_packet_t snmp_packet; snmp_udp_conn = udp_new(NULL, 0, NULL); udp_bind(snmp_udp_conn, SNMP_SERVER_PORT); LOG_DBG(""Listening on port %u\n"", uip_ntohs(snmp_udp_conn->lport)); while(1) { PROCESS_YIELD(); if(ev != tcpip_event) { continue; } if(!uip_newdata()) { continue; } LOG_DBG(""receiving UDP datagram from [""); LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr); LOG_DBG_(""]:%u"", uip_ntohs(UIP_UDP_BUF->srcport)); LOG_DBG_("" Length: %u\n"", uip_datalen()); snmp_packet.in = (uint8_t *)uip_appdata; snmp_packet.used = uip_datalen(); snmp_packet.out = (uint8_t *)(uip_appdata + UIP_BUFSIZE - UIP_IPUDPH_LEN); snmp_packet.max = UIP_BUFSIZE - UIP_IPUDPH_LEN; if(!snmp_engine(&snmp_packet)) { LOG_DBG(""Error while handling the request\n""); continue; } LOG_DBG(""Sending response\n""); uip_udp_packet_sendto(snmp_udp_conn, snmp_packet.out, snmp_packet.used, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport); } PROCESS_END(); }"
502,1614----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-6347--ip_sockglue.c----ip_cmsg_recv_checksum,"static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb, int tlen, int offset) { __wsum csum = skb->csum; if (skb->ip_summed != CHECKSUM_COMPLETE) return; <S2SV_StartVul> if (offset != 0) <S2SV_EndVul> <S2SV_StartVul> csum = csum_sub(csum, <S2SV_EndVul> <S2SV_StartVul> csum_partial(skb_transport_header(skb) + tlen, <S2SV_EndVul> <S2SV_StartVul> offset, 0)); <S2SV_EndVul> put_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum); }","- if (offset != 0)
- csum = csum_sub(csum,
- csum_partial(skb_transport_header(skb) + tlen,
- offset, 0));
+ if (offset != 0) {
+ int tend_off = skb_transport_offset(skb) + tlen;
+ csum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0));
+ }","static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb, int tlen, int offset) { __wsum csum = skb->csum; if (skb->ip_summed != CHECKSUM_COMPLETE) return; if (offset != 0) { int tend_off = skb_transport_offset(skb) + tlen; csum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0)); } put_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum); }"
503,7428----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/Client.cpp----CClient::ReadLine,"void CClient::ReadLine(const CString& sData) { CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : """"); CString sLine = sData; <S2SV_StartVul> sLine.TrimRight(""\n\r""); <S2SV_EndVul> DEBUG(""("" << GetFullName() << "") CLI -> ZNC ["" << CDebug::Filter(sLine) << ""]""); bool bReturn = false; if (IsAttached()) { NETWORKMODULECALL(OnUserRaw(sLine), m_pUser, m_pNetwork, this, &bReturn); } else { GLOBALMODULECALL(OnUnknownUserRaw(this, sLine), &bReturn); } if (bReturn) return; CMessage Message(sLine); Message.SetClient(this); if (IsAttached()) { NETWORKMODULECALL(OnUserRawMessage(Message), m_pUser, m_pNetwork, this, &bReturn); } else { GLOBALMODULECALL(OnUnknownUserRawMessage(Message), &bReturn); } if (bReturn) return; CString sCommand = Message.GetCommand(); if (!IsAttached()) { if (sCommand.Equals(""PASS"")) { m_bGotPass = true; CString sAuthLine = Message.GetParam(0); ParsePass(sAuthLine); AuthUser(); return; } else if (sCommand.Equals(""NICK"")) { CString sNick = Message.GetParam(0); m_sNick = sNick; m_bGotNick = true; AuthUser(); return; } else if (sCommand.Equals(""USER"")) { CString sAuthLine = Message.GetParam(0); if (m_sUser.empty() && !sAuthLine.empty()) { ParseUser(sAuthLine); } m_bGotUser = true; if (m_bGotPass) { AuthUser(); } else if (!m_bInCap) { SendRequiredPasswordNotice(); } return; } } if (Message.GetType() == CMessage::Type::Capability) { HandleCap(Message); return; } if (!m_pUser) { return; } switch (Message.GetType()) { case CMessage::Type::Action: bReturn = OnActionMessage(Message); break; case CMessage::Type::CTCP: bReturn = OnCTCPMessage(Message); break; case CMessage::Type::Join: bReturn = OnJoinMessage(Message); break; case CMessage::Type::Mode: bReturn = OnModeMessage(Message); break; case CMessage::Type::Notice: bReturn = OnNoticeMessage(Message); break; case CMessage::Type::Part: bReturn = OnPartMessage(Message); break; case CMessage::Type::Ping: bReturn = OnPingMessage(Message); break; case CMessage::Type::Pong: bReturn = OnPongMessage(Message); break; case CMessage::Type::Quit: bReturn = OnQuitMessage(Message); break; case CMessage::Type::Text: bReturn = OnTextMessage(Message); break; case CMessage::Type::Topic: bReturn = OnTopicMessage(Message); break; default: bReturn = OnOtherMessage(Message); break; } if (bReturn) return; PutIRC(Message.ToString(CMessage::ExcludePrefix | CMessage::ExcludeTags)); }","- sLine.TrimRight(""\n\r"");
+ sLine.Replace(""\n"", """");
+ sLine.Replace(""\r"", """");","void CClient::ReadLine(const CString& sData) { CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : """"); CString sLine = sData; sLine.Replace(""\n"", """"); sLine.Replace(""\r"", """"); DEBUG(""("" << GetFullName() << "") CLI -> ZNC ["" << CDebug::Filter(sLine) << ""]""); bool bReturn = false; if (IsAttached()) { NETWORKMODULECALL(OnUserRaw(sLine), m_pUser, m_pNetwork, this, &bReturn); } else { GLOBALMODULECALL(OnUnknownUserRaw(this, sLine), &bReturn); } if (bReturn) return; CMessage Message(sLine); Message.SetClient(this); if (IsAttached()) { NETWORKMODULECALL(OnUserRawMessage(Message), m_pUser, m_pNetwork, this, &bReturn); } else { GLOBALMODULECALL(OnUnknownUserRawMessage(Message), &bReturn); } if (bReturn) return; CString sCommand = Message.GetCommand(); if (!IsAttached()) { if (sCommand.Equals(""PASS"")) { m_bGotPass = true; CString sAuthLine = Message.GetParam(0); ParsePass(sAuthLine); AuthUser(); return; } else if (sCommand.Equals(""NICK"")) { CString sNick = Message.GetParam(0); m_sNick = sNick; m_bGotNick = true; AuthUser(); return; } else if (sCommand.Equals(""USER"")) { CString sAuthLine = Message.GetParam(0); if (m_sUser.empty() && !sAuthLine.empty()) { ParseUser(sAuthLine); } m_bGotUser = true; if (m_bGotPass) { AuthUser(); } else if (!m_bInCap) { SendRequiredPasswordNotice(); } return; } } if (Message.GetType() == CMessage::Type::Capability) { HandleCap(Message); return; } if (!m_pUser) { return; } switch (Message.GetType()) { case CMessage::Type::Action: bReturn = OnActionMessage(Message); break; case CMessage::Type::CTCP: bReturn = OnCTCPMessage(Message); break; case CMessage::Type::Join: bReturn = OnJoinMessage(Message); break; case CMessage::Type::Mode: bReturn = OnModeMessage(Message); break; case CMessage::Type::Notice: bReturn = OnNoticeMessage(Message); break; case CMessage::Type::Part: bReturn = OnPartMessage(Message); break; case CMessage::Type::Ping: bReturn = OnPingMessage(Message); break; case CMessage::Type::Pong: bReturn = OnPongMessage(Message); break; case CMessage::Type::Quit: bReturn = OnQuitMessage(Message); break; case CMessage::Type::Text: bReturn = OnTextMessage(Message); break; case CMessage::Type::Topic: bReturn = OnTopicMessage(Message); break; default: bReturn = OnOtherMessage(Message); break; } if (bReturn) return; PutIRC(Message.ToString(CMessage::ExcludePrefix | CMessage::ExcludeTags)); }"
504,7126----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/emulate.c----em_call,"static int em_call(struct x86_emulate_ctxt *ctxt) { long rel = ctxt->src.val; ctxt->src.val = (unsigned long)ctxt->_eip; <S2SV_StartVul> jmp_rel(ctxt, rel); <S2SV_EndVul> return em_push(ctxt); }","- jmp_rel(ctxt, rel);
+ int rc;
+ rc = jmp_rel(ctxt, rel);
+ if (rc != X86EMUL_CONTINUE)
+ return rc;","static int em_call(struct x86_emulate_ctxt *ctxt) { int rc; long rel = ctxt->src.val; ctxt->src.val = (unsigned long)ctxt->_eip; rc = jmp_rel(ctxt, rel); if (rc != X86EMUL_CONTINUE) return rc; return em_push(ctxt); }"
505,3145----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mib.c----netsnmp_init_mib,"netsnmp_init_mib(void) { const char *prefix; char *env_var, *entry; PrefixListPtr pp = &mib_prefixes[0]; char *st = NULL; if (Mib) return; netsnmp_init_mib_internals(); netsnmp_fixup_mib_directory(); env_var = strdup(netsnmp_get_mib_directory()); if (!env_var) return; <S2SV_StartVul> netsnmp_mibindex_load(); <S2SV_EndVul> DEBUGMSGTL((""init_mib"", ""Seen MIBDIRS: Looking in '%s' for mib dirs ...\n"", env_var)); entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { add_mibdir(entry); entry = strtok_r(NULL, ENV_SEPARATOR, &st); } SNMP_FREE(env_var); env_var = netsnmp_getenv(""MIBFILES""); if (env_var != NULL) { if (*env_var == '+') entry = strtok_r(env_var+1, ENV_SEPARATOR, &st); else entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { <S2SV_StartVul> add_mibfile(entry, NULL, NULL); <S2SV_EndVul> entry = strtok_r(NULL, ENV_SEPARATOR, &st); } } netsnmp_init_mib_internals(); env_var = netsnmp_getenv(""MIBS""); if (env_var == NULL) { if (confmibs != NULL) env_var = strdup(confmibs); else env_var = strdup(NETSNMP_DEFAULT_MIBS); } else { env_var = strdup(env_var); } if (env_var && ((*env_var == '+') || (*env_var == '-'))) { entry = (char *) malloc(strlen(NETSNMP_DEFAULT_MIBS) + strlen(env_var) + 2); if (!entry) { DEBUGMSGTL((""init_mib"", ""env mibs malloc failed"")); SNMP_FREE(env_var); return; } else { if (*env_var == '+') sprintf(entry, ""%s%c%s"", NETSNMP_DEFAULT_MIBS, ENV_SEPARATOR_CHAR, env_var+1); else sprintf(entry, ""%s%c%s"", env_var+1, ENV_SEPARATOR_CHAR, NETSNMP_DEFAULT_MIBS ); } SNMP_FREE(env_var); env_var = entry; } DEBUGMSGTL((""init_mib"", ""Seen MIBS: Looking in '%s' for mib files ...\n"", env_var)); entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { if (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) { read_all_mibs(); } else if (strstr(entry, ""/"") != NULL) { read_mib(entry); } else { netsnmp_read_module(entry); } entry = strtok_r(NULL, ENV_SEPARATOR, &st); } adopt_orphans(); SNMP_FREE(env_var); env_var = netsnmp_getenv(""MIBFILES""); if (env_var != NULL) { if ((*env_var == '+') || (*env_var == '-')) { #ifdef NETSNMP_DEFAULT_MIBFILES entry = (char *) malloc(strlen(NETSNMP_DEFAULT_MIBFILES) + strlen(env_var) + 2); if (!entry) { DEBUGMSGTL((""init_mib"", ""env mibfiles malloc failed"")); } else { if (*env_var++ == '+') sprintf(entry, ""%s%c%s"", NETSNMP_DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR, env_var ); else sprintf(entry, ""%s%c%s"", env_var, ENV_SEPARATOR_CHAR, NETSNMP_DEFAULT_MIBFILES ); } SNMP_FREE(env_var); env_var = entry; #else env_var = strdup(env_var + 1); #endif } else { env_var = strdup(env_var); } } else { #ifdef NETSNMP_DEFAULT_MIBFILES env_var = strdup(NETSNMP_DEFAULT_MIBFILES); #endif } if (env_var != NULL) { DEBUGMSGTL((""init_mib"", ""Seen MIBFILES: Looking in '%s' for mib files ...\n"", env_var)); entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { read_mib(entry); entry = strtok_r(NULL, ENV_SEPARATOR, &st); } SNMP_FREE(env_var); } prefix = netsnmp_getenv(""PREFIX""); if (!prefix) prefix = Standard_Prefix; Prefix = (char *) malloc(strlen(prefix) + 2); if (!Prefix) DEBUGMSGTL((""init_mib"", ""Prefix malloc failed"")); else strcpy(Prefix, prefix); DEBUGMSGTL((""init_mib"", ""Seen PREFIX: Looking in '%s' for prefix ...\n"", Prefix)); if (Prefix) { env_var = &Prefix[strlen(Prefix) - 1]; if (*env_var == '.') *env_var = '\0'; } pp->str = Prefix; while (pp->str) { pp->len = strlen(pp->str); pp++; } Mib = tree_head; tree_top = (struct tree *) calloc(1, sizeof(struct tree)); if (tree_top) { tree_top->label = strdup(""(top)""); tree_top->child_list = tree_head; } }","- netsnmp_mibindex_load();
- add_mibfile(entry, NULL, NULL);
+ add_mibfile(entry, NULL);","netsnmp_init_mib(void) { const char *prefix; char *env_var, *entry; PrefixListPtr pp = &mib_prefixes[0]; char *st = NULL; if (Mib) return; netsnmp_init_mib_internals(); netsnmp_fixup_mib_directory(); env_var = strdup(netsnmp_get_mib_directory()); if (!env_var) return; DEBUGMSGTL((""init_mib"", ""Seen MIBDIRS: Looking in '%s' for mib dirs ...\n"", env_var)); entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { add_mibdir(entry); entry = strtok_r(NULL, ENV_SEPARATOR, &st); } SNMP_FREE(env_var); env_var = netsnmp_getenv(""MIBFILES""); if (env_var != NULL) { if (*env_var == '+') entry = strtok_r(env_var+1, ENV_SEPARATOR, &st); else entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { add_mibfile(entry, NULL); entry = strtok_r(NULL, ENV_SEPARATOR, &st); } } netsnmp_init_mib_internals(); env_var = netsnmp_getenv(""MIBS""); if (env_var == NULL) { if (confmibs != NULL) env_var = strdup(confmibs); else env_var = strdup(NETSNMP_DEFAULT_MIBS); } else { env_var = strdup(env_var); } if (env_var && ((*env_var == '+') || (*env_var == '-'))) { entry = (char *) malloc(strlen(NETSNMP_DEFAULT_MIBS) + strlen(env_var) + 2); if (!entry) { DEBUGMSGTL((""init_mib"", ""env mibs malloc failed"")); SNMP_FREE(env_var); return; } else { if (*env_var == '+') sprintf(entry, ""%s%c%s"", NETSNMP_DEFAULT_MIBS, ENV_SEPARATOR_CHAR, env_var+1); else sprintf(entry, ""%s%c%s"", env_var+1, ENV_SEPARATOR_CHAR, NETSNMP_DEFAULT_MIBS ); } SNMP_FREE(env_var); env_var = entry; } DEBUGMSGTL((""init_mib"", ""Seen MIBS: Looking in '%s' for mib files ...\n"", env_var)); entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { if (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) { read_all_mibs(); } else if (strstr(entry, ""/"") != NULL) { read_mib(entry); } else { netsnmp_read_module(entry); } entry = strtok_r(NULL, ENV_SEPARATOR, &st); } adopt_orphans(); SNMP_FREE(env_var); env_var = netsnmp_getenv(""MIBFILES""); if (env_var != NULL) { if ((*env_var == '+') || (*env_var == '-')) { #ifdef NETSNMP_DEFAULT_MIBFILES entry = (char *) malloc(strlen(NETSNMP_DEFAULT_MIBFILES) + strlen(env_var) + 2); if (!entry) { DEBUGMSGTL((""init_mib"", ""env mibfiles malloc failed"")); } else { if (*env_var++ == '+') sprintf(entry, ""%s%c%s"", NETSNMP_DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR, env_var ); else sprintf(entry, ""%s%c%s"", env_var, ENV_SEPARATOR_CHAR, NETSNMP_DEFAULT_MIBFILES ); } SNMP_FREE(env_var); env_var = entry; #else env_var = strdup(env_var + 1); #endif } else { env_var = strdup(env_var); } } else { #ifdef NETSNMP_DEFAULT_MIBFILES env_var = strdup(NETSNMP_DEFAULT_MIBFILES); #endif } if (env_var != NULL) { DEBUGMSGTL((""init_mib"", ""Seen MIBFILES: Looking in '%s' for mib files ...\n"", env_var)); entry = strtok_r(env_var, ENV_SEPARATOR, &st); while (entry) { read_mib(entry); entry = strtok_r(NULL, ENV_SEPARATOR, &st); } SNMP_FREE(env_var); } prefix = netsnmp_getenv(""PREFIX""); if (!prefix) prefix = Standard_Prefix; Prefix = (char *) malloc(strlen(prefix) + 2); if (!Prefix) DEBUGMSGTL((""init_mib"", ""Prefix malloc failed"")); else strcpy(Prefix, prefix); DEBUGMSGTL((""init_mib"", ""Seen PREFIX: Looking in '%s' for prefix ...\n"", Prefix)); if (Prefix) { env_var = &Prefix[strlen(Prefix) - 1]; if (*env_var == '.') *env_var = '\0'; } pp->str = Prefix; while (pp->str) { pp->len = strlen(pp->str); pp++; } Mib = tree_head; tree_top = (struct tree *) calloc(1, sizeof(struct tree)); if (tree_top) { tree_top->label = strdup(""(top)""); tree_top->child_list = tree_head; } }"
506,5229----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/netscreen.c----parse_netscreen_packet,"parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf, char *line, int *err, gchar **err_info) { int sec; int dsec; char cap_int[NETSCREEN_MAX_INT_NAME_LENGTH]; char direction[2]; <S2SV_StartVul> guint pkt_len; <S2SV_EndVul> char cap_src[13]; char cap_dst[13]; guint8 *pd; gchar *p; int n, i = 0; <S2SV_StartVul> guint offset = 0; <S2SV_EndVul> gchar dststr[13]; phdr->rec_type = REC_TYPE_PACKET; phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN; <S2SV_StartVul> if (sscanf(line, ""%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/"", <S2SV_EndVul> &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: Can't parse packet-header""); return -1; } if (pkt_len > WTAP_MAX_PACKET_SIZE) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""netscreen: File has %u-byte packet, bigger than maximum of %u"", pkt_len, WTAP_MAX_PACKET_SIZE); return FALSE; } phdr->ts.secs = sec; phdr->ts.nsecs = dsec * 100000000; phdr->len = pkt_len; ws_buffer_assure_space(buf, pkt_len); pd = ws_buffer_start_ptr(buf); while(1) { if (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) { break; } for (p = &line[0]; g_ascii_isspace(*p); p++) ; if (*p == '\0') { break; } n = parse_single_hex_dump_line(p, pd, offset); if (offset == 0 && n < 6) { if (info_line(line)) { if (++i <= NETSCREEN_MAX_INFOLINES) { continue; } } else { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: cannot parse hex-data""); return FALSE; } } if (n == -1) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: cannot parse hex-data""); return FALSE; } offset += n; if (offset > pkt_len) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: too much hex-data""); return FALSE; } } if (strncmp(cap_int, ""adsl"", 4) == 0) { g_snprintf(dststr, 13, ""%02x%02x%02x%02x%02x%02x"", pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]); if (strncmp(dststr, cap_dst, 12) == 0) phdr->pkt_encap = WTAP_ENCAP_ETHERNET; else phdr->pkt_encap = WTAP_ENCAP_PPP; } else if (strncmp(cap_int, ""seri"", 4) == 0) phdr->pkt_encap = WTAP_ENCAP_PPP; else phdr->pkt_encap = WTAP_ENCAP_ETHERNET; phdr->caplen = offset; return TRUE; }","- guint pkt_len;
- guint offset = 0;
- if (sscanf(line, ""%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9u:%12s->%12s/"",
+ int pkt_len;
+ int offset = 0;
+ if (sscanf(line, ""%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/"",
+ if (pkt_len < 0) {
+ return FALSE;
+ }","parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf, char *line, int *err, gchar **err_info) { int pkt_len; int sec; int dsec; char cap_int[NETSCREEN_MAX_INT_NAME_LENGTH]; char direction[2]; char cap_src[13]; char cap_dst[13]; guint8 *pd; gchar *p; int n, i = 0; int offset = 0; gchar dststr[13]; phdr->rec_type = REC_TYPE_PACKET; phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN; if (sscanf(line, ""%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/"", &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: Can't parse packet-header""); return -1; } if (pkt_len < 0) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: packet header has a negative packet length""); return FALSE; } if (pkt_len > WTAP_MAX_PACKET_SIZE) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""netscreen: File has %u-byte packet, bigger than maximum of %u"", pkt_len, WTAP_MAX_PACKET_SIZE); return FALSE; } phdr->ts.secs = sec; phdr->ts.nsecs = dsec * 100000000; phdr->len = pkt_len; ws_buffer_assure_space(buf, pkt_len); pd = ws_buffer_start_ptr(buf); while(1) { if (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) { break; } for (p = &line[0]; g_ascii_isspace(*p); p++) ; if (*p == '\0') { break; } n = parse_single_hex_dump_line(p, pd, offset); if (offset == 0 && n < 6) { if (info_line(line)) { if (++i <= NETSCREEN_MAX_INFOLINES) { continue; } } else { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: cannot parse hex-data""); return FALSE; } } if (n == -1) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: cannot parse hex-data""); return FALSE; } offset += n; if (offset > pkt_len) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""netscreen: too much hex-data""); return FALSE; } } if (strncmp(cap_int, ""adsl"", 4) == 0) { g_snprintf(dststr, 13, ""%02x%02x%02x%02x%02x%02x"", pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]); if (strncmp(dststr, cap_dst, 12) == 0) phdr->pkt_encap = WTAP_ENCAP_ETHERNET; else phdr->pkt_encap = WTAP_ENCAP_PPP; } else if (strncmp(cap_int, ""seri"", 4) == 0) phdr->pkt_encap = WTAP_ENCAP_PPP; else phdr->pkt_encap = WTAP_ENCAP_ETHERNET; phdr->caplen = offset; return TRUE; }"
507,4279----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hostsock.c----_hostsock_getsockopt,"static int _hostsock_getsockopt( oe_fd_t* sock_, int level, int optname, void* optval, oe_socklen_t* optlen) { int ret = -1; sock_t* sock = _cast_sock(sock_); oe_socklen_t optlen_in = 0; oe_errno = 0; <S2SV_StartVul> if (!sock) <S2SV_EndVul> OE_RAISE_ERRNO(OE_EINVAL); <S2SV_StartVul> if (optlen) <S2SV_EndVul> <S2SV_StartVul> optlen_in = *optlen; <S2SV_EndVul> if (oe_syscall_getsockopt_ocall( <S2SV_StartVul> &ret, sock->host_fd, level, optname, optval, optlen_in, optlen) != <S2SV_EndVul> <S2SV_StartVul> OE_OK) <S2SV_EndVul> { OE_RAISE_ERRNO(OE_EINVAL); } done: return ret; }","- if (!sock)
- if (optlen)
- optlen_in = *optlen;
- &ret, sock->host_fd, level, optname, optval, optlen_in, optlen) !=
- OE_OK)
+ oe_socklen_t optlen_out = 0;
+ if (!sock || !optval || !optlen)
+ optlen_in = *optlen;
+ &ret,
+ sock->host_fd,
+ level,
+ optname,
+ optval,
+ optlen_in,
+ &optlen_out) != OE_OK)
+ if (optlen_out > optlen_in)
+ optlen_out = optlen_in;","static int _hostsock_getsockopt( oe_fd_t* sock_, int level, int optname, void* optval, oe_socklen_t* optlen) { int ret = -1; sock_t* sock = _cast_sock(sock_); oe_socklen_t optlen_in = 0; oe_socklen_t optlen_out = 0; oe_errno = 0; if (!sock || !optval || !optlen) OE_RAISE_ERRNO(OE_EINVAL); optlen_in = *optlen; if (oe_syscall_getsockopt_ocall( &ret, sock->host_fd, level, optname, optval, optlen_in, &optlen_out) != OE_OK) { OE_RAISE_ERRNO(OE_EINVAL); } if (optlen_out > optlen_in) optlen_out = optlen_in; *optlen = optlen_out; done: return ret; }"
508,6956----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jas_stream.c----mem_read,"static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt) { <S2SV_StartVul> int n; <S2SV_EndVul> assert(cnt >= 0); assert(buf); JAS_DBGLOG(100, (""mem_read(%p, %p, %d)\n"", obj, buf, cnt)); jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; n = m->len_ - m->pos_; cnt = JAS_MIN(n, cnt); memcpy(buf, &m->buf_[m->pos_], cnt); m->pos_ += cnt; return cnt; }","- int n;
+ ssize_t n;","static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt) { ssize_t n; assert(cnt >= 0); assert(buf); JAS_DBGLOG(100, (""mem_read(%p, %p, %d)\n"", obj, buf, cnt)); jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; n = m->len_ - m->pos_; cnt = JAS_MIN(n, cnt); memcpy(buf, &m->buf_[m->pos_], cnt); m->pos_ += cnt; return cnt; }"
509,4970----CWE-369----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/conv.cc----tflite::ops::builtin::conv::EvalHybridPerChannel,"TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node, TfLiteConvParams* params, OpData* data, const TfLiteTensor* input, const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* im2col, TfLiteTensor* output) { float output_activation_min, output_activation_max; CalculateActivationRange(params->activation, &output_activation_min, &output_activation_max); <S2SV_StartVul> const int input_size = NumElements(input) / SizeOfDimension(input, 0); <S2SV_EndVul> const int batch_size = SizeOfDimension(input, 0); TfLiteTensor* quantized_input_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_quantized_index, &quantized_input_tensor)); int8_t* quantized_input_ptr_batch = GetTensorData<int8_t>(quantized_input_tensor); TfLiteTensor* scaling_factors_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors_tensor)); float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor); TfLiteTensor* input_offset_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_offset_index, &input_offset_tensor)); int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor); for (int b = 0; b < batch_size; ++b) { const int offset = b * input_size; tensor_utils::AsymmetricQuantizeFloats( GetTensorData<float>(input) + offset, input_size, quantized_input_ptr_batch + offset, &scaling_factors_ptr[b], &input_offset_ptr[b]); } int8_t* im2col_ptr = nullptr; int8_t* filter_ptr = nullptr; if (im2col != nullptr) { im2col_ptr = im2col->data.int8; } filter_ptr = filter->data.int8; const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params); KernelType effective_kernel_type = kernel_type; if (data->im2col_oversized) { effective_kernel_type = kReference; } ConvParams op_params; op_params.padding_type = PaddingType::kSame; op_params.padding_values.width = data->padding.width; op_params.padding_values.height = data->padding.height; op_params.dilation_width_factor = params->dilation_width_factor; op_params.dilation_height_factor = params->dilation_height_factor; op_params.stride_width = params->stride_width; op_params.stride_height = params->stride_height; op_params.float_activation_min = output_activation_min; op_params.float_activation_max = output_activation_max; switch (effective_kernel_type) { case kReference: reference_ops::HybridConvPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr, GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data, input_offset_ptr); break; case kGenericOptimized: case kMultithreadOptimized: case kCblasOptimized: { TfLiteTensor* row_sums; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->row_sums_index, &row_sums)); TfLiteTensor* scratch; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->accum_scratch_index, &scratch)); optimized_ops::HybridConvPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr, GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data, input_offset_ptr, GetTensorShape(scratch), GetTensorData<int32>(scratch), GetTensorData<int32_t>(row_sums), &data->compute_hybrid_row_sums, CpuBackendContext::GetFromContext(context)); data->compute_hybrid_row_sums = false; break; } } return kTfLiteOk; }","- const int input_size = NumElements(input) / SizeOfDimension(input, 0);
+ TF_LITE_ENSURE(context, batch_size != 0);
+ const int input_size = NumElements(input) / batch_size;","TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node, TfLiteConvParams* params, OpData* data, const TfLiteTensor* input, const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* im2col, TfLiteTensor* output) { float output_activation_min, output_activation_max; CalculateActivationRange(params->activation, &output_activation_min, &output_activation_max); const int batch_size = SizeOfDimension(input, 0); TF_LITE_ENSURE(context, batch_size != 0); const int input_size = NumElements(input) / batch_size; TfLiteTensor* quantized_input_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_quantized_index, &quantized_input_tensor)); int8_t* quantized_input_ptr_batch = GetTensorData<int8_t>(quantized_input_tensor); TfLiteTensor* scaling_factors_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors_tensor)); float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor); TfLiteTensor* input_offset_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_offset_index, &input_offset_tensor)); int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor); for (int b = 0; b < batch_size; ++b) { const int offset = b * input_size; tensor_utils::AsymmetricQuantizeFloats( GetTensorData<float>(input) + offset, input_size, quantized_input_ptr_batch + offset, &scaling_factors_ptr[b], &input_offset_ptr[b]); } int8_t* im2col_ptr = nullptr; int8_t* filter_ptr = nullptr; if (im2col != nullptr) { im2col_ptr = im2col->data.int8; } filter_ptr = filter->data.int8; const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params); KernelType effective_kernel_type = kernel_type; if (data->im2col_oversized) { effective_kernel_type = kReference; } ConvParams op_params; op_params.padding_type = PaddingType::kSame; op_params.padding_values.width = data->padding.width; op_params.padding_values.height = data->padding.height; op_params.dilation_width_factor = params->dilation_width_factor; op_params.dilation_height_factor = params->dilation_height_factor; op_params.stride_width = params->stride_width; op_params.stride_height = params->stride_height; op_params.float_activation_min = output_activation_min; op_params.float_activation_max = output_activation_max; switch (effective_kernel_type) { case kReference: reference_ops::HybridConvPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr, GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data, input_offset_ptr); break; case kGenericOptimized: case kMultithreadOptimized: case kCblasOptimized: { TfLiteTensor* row_sums; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->row_sums_index, &row_sums)); TfLiteTensor* scratch; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->accum_scratch_index, &scratch)); optimized_ops::HybridConvPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), filter_ptr, GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), GetTensorShape(im2col), im2col_ptr, affine_quantization->scale->data, input_offset_ptr, GetTensorShape(scratch), GetTensorData<int32>(scratch), GetTensorData<int32_t>(row_sums), &data->compute_hybrid_row_sums, CpuBackendContext::GetFromContext(context)); data->compute_hybrid_row_sums = false; break; } } return kTfLiteOk; }"
510,159----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2179--d1_lib.c----dtls1_free,"void dtls1_free(SSL *s) { DTLS_RECORD_LAYER_free(&s->rlayer); { pqueue *buffered_messages; pqueue *sent_messages; unsigned int mtu; unsigned int link_mtu; DTLS_RECORD_LAYER_clear(&s->rlayer); if (s->d1) { buffered_messages = s->d1->buffered_messages; sent_messages = s->d1->sent_messages; mtu = s->d1->mtu; link_mtu = s->d1->link_mtu; dtls1_clear_queues(s); memset(s->d1, 0, sizeof(*s->d1)); if (s->server) { s->d1->cookie_len = sizeof(s->d1->cookie); } if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU) { s->d1->mtu = mtu; s->d1->link_mtu = link_mtu; } s->d1->buffered_messages = buffered_messages; s->d1->sent_messages = sent_messages; } ssl3_clear(s); if (s->method->version == DTLS_ANY_VERSION) s->version = DTLS_MAX_VERSION; #ifndef OPENSSL_NO_DTLS1_METHOD else if (s->options & SSL_OP_CISCO_ANYCONNECT) s->client_version = s->version = DTLS1_BAD_VER; #endif else s->version = s->method->version; } long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg) { int ret = 0; switch (cmd) { case DTLS_CTRL_GET_TIMEOUT: if (dtls1_get_timeout(s, (struct timeval *)parg) != NULL) { ret = 1; } break; case DTLS_CTRL_HANDLE_TIMEOUT: ret = dtls1_handle_timeout(s); break; case DTLS_CTRL_SET_LINK_MTU: if (larg < (long)dtls1_link_min_mtu()) return 0; s->d1->link_mtu = larg; return 1; case DTLS_CTRL_GET_LINK_MIN_MTU: return (long)dtls1_link_min_mtu(); case SSL_CTRL_SET_MTU: if (larg < (long)dtls1_link_min_mtu() - DTLS1_MAX_MTU_OVERHEAD) return 0; s->d1->mtu = larg; return larg; default: ret = ssl3_ctrl(s, cmd, larg, parg); break; } return (ret); } void dtls1_start_timer(SSL *s) { #ifndef OPENSSL_NO_SCTP if (BIO_dgram_is_sctp(SSL_get_wbio(s))) { memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout)); return; } #endif if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) { s->d1->timeout_duration = 1; } get_current_time(&(s->d1->next_timeout)); s->d1->next_timeout.tv_sec += s->d1->timeout_duration; BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout)); } struct timeval *dtls1_get_timeout(SSL *s, struct timeval *timeleft) { struct timeval timenow; if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) { return NULL; } get_current_time(&timenow); if (s->d1->next_timeout.tv_sec < timenow.tv_sec || (s->d1->next_timeout.tv_sec == timenow.tv_sec && s->d1->next_timeout.tv_usec <= timenow.tv_usec)) { memset(timeleft, 0, sizeof(*timeleft)); return timeleft; } memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval)); timeleft->tv_sec -= timenow.tv_sec; timeleft->tv_usec -= timenow.tv_usec; if (timeleft->tv_usec < 0) { timeleft->tv_sec--; timeleft->tv_usec += 1000000; } if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000) { memset(timeleft, 0, sizeof(*timeleft)); } return timeleft; } int dtls1_is_timer_expired(SSL *s) { struct timeval timeleft; if (dtls1_get_timeout(s, &timeleft) == NULL) { return 0; } if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0) { return 0; } return 1; } void dtls1_double_timeout(SSL *s) { s->d1->timeout_duration *= 2; if (s->d1->timeout_duration > 60) s->d1->timeout_duration = 60; dtls1_start_timer(s); } void dtls1_stop_timer(SSL *s) { memset(&s->d1->timeout, 0, sizeof(s->d1->timeout)); memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout)); s->d1->timeout_duration = 1; BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout)); dtls1_clear_record_buffer(s); } int dtls1_check_timeout_num(SSL *s) { unsigned int mtu; s->d1->timeout.num_alerts++; BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout)); <S2SV_StartVul> dtls1_clear_record_buffer(s); <S2SV_EndVul> } int dtls1_check_timeout_num(SSL *s) if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT) { SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM, SSL_R_READ_TIMEOUT_EXPIRED); return -1; } return 0; }","- dtls1_clear_record_buffer(s);
+ dtls1_clear_sent_buffer(s);","void dtls1_free(SSL *s) { DTLS_RECORD_LAYER_free(&s->rlayer); { pqueue *buffered_messages; pqueue *sent_messages; unsigned int mtu; unsigned int link_mtu; DTLS_RECORD_LAYER_clear(&s->rlayer); if (s->d1) { buffered_messages = s->d1->buffered_messages; sent_messages = s->d1->sent_messages; mtu = s->d1->mtu; link_mtu = s->d1->link_mtu; dtls1_clear_queues(s); memset(s->d1, 0, sizeof(*s->d1)); if (s->server) { s->d1->cookie_len = sizeof(s->d1->cookie); } if (SSL_get_options(s) & SSL_OP_NO_QUERY_MTU) { s->d1->mtu = mtu; s->d1->link_mtu = link_mtu; } s->d1->buffered_messages = buffered_messages; s->d1->sent_messages = sent_messages; } ssl3_clear(s); if (s->method->version == DTLS_ANY_VERSION) s->version = DTLS_MAX_VERSION; #ifndef OPENSSL_NO_DTLS1_METHOD else if (s->options & SSL_OP_CISCO_ANYCONNECT) s->client_version = s->version = DTLS1_BAD_VER; #endif else s->version = s->method->version; } long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg) { int ret = 0; switch (cmd) { case DTLS_CTRL_GET_TIMEOUT: if (dtls1_get_timeout(s, (struct timeval *)parg) != NULL) { ret = 1; } break; case DTLS_CTRL_HANDLE_TIMEOUT: ret = dtls1_handle_timeout(s); break; case DTLS_CTRL_SET_LINK_MTU: if (larg < (long)dtls1_link_min_mtu()) return 0; s->d1->link_mtu = larg; return 1; case DTLS_CTRL_GET_LINK_MIN_MTU: return (long)dtls1_link_min_mtu(); case SSL_CTRL_SET_MTU: if (larg < (long)dtls1_link_min_mtu() - DTLS1_MAX_MTU_OVERHEAD) return 0; s->d1->mtu = larg; return larg; default: ret = ssl3_ctrl(s, cmd, larg, parg); break; } return (ret); } void dtls1_start_timer(SSL *s) { #ifndef OPENSSL_NO_SCTP if (BIO_dgram_is_sctp(SSL_get_wbio(s))) { memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout)); return; } #endif if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) { s->d1->timeout_duration = 1; } get_current_time(&(s->d1->next_timeout)); s->d1->next_timeout.tv_sec += s->d1->timeout_duration; BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout)); } struct timeval *dtls1_get_timeout(SSL *s, struct timeval *timeleft) { struct timeval timenow; if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) { return NULL; } get_current_time(&timenow); if (s->d1->next_timeout.tv_sec < timenow.tv_sec || (s->d1->next_timeout.tv_sec == timenow.tv_sec && s->d1->next_timeout.tv_usec <= timenow.tv_usec)) { memset(timeleft, 0, sizeof(*timeleft)); return timeleft; } memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval)); timeleft->tv_sec -= timenow.tv_sec; timeleft->tv_usec -= timenow.tv_usec; if (timeleft->tv_usec < 0) { timeleft->tv_sec--; timeleft->tv_usec += 1000000; } if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000) { memset(timeleft, 0, sizeof(*timeleft)); } return timeleft; } int dtls1_is_timer_expired(SSL *s) { struct timeval timeleft; if (dtls1_get_timeout(s, &timeleft) == NULL) { return 0; } if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0) { return 0; } return 1; } void dtls1_double_timeout(SSL *s) { s->d1->timeout_duration *= 2; if (s->d1->timeout_duration > 60) s->d1->timeout_duration = 60; dtls1_start_timer(s); } void dtls1_stop_timer(SSL *s) { memset(&s->d1->timeout, 0, sizeof(s->d1->timeout)); memset(&s->d1->next_timeout, 0, sizeof(s->d1->next_timeout)); s->d1->timeout_duration = 1; BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout)); dtls1_clear_record_buffer(s); } int dtls1_check_timeout_num(SSL *s) { unsigned int mtu; s->d1->timeout.num_alerts++; BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0, &(s->d1->next_timeout)); dtls1_clear_sent_buffer(s); } int dtls1_check_timeout_num(SSL *s) if (s->d1->timeout.num_alerts > DTLS1_TMO_ALERT_COUNT) { SSLerr(SSL_F_DTLS1_CHECK_TIMEOUT_NUM, SSL_R_READ_TIMEOUT_EXPIRED); return -1; } return 0; }"
511,5012----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/stbl_write.c----stbl_AppendTime,"GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack) { GF_TimeToSampleBox *stts = stbl->TimeToSample; <S2SV_StartVul> if (!nb_pack) nb_pack = 1; <S2SV_EndVul> if (stts->nb_entries) { if (stts->entries[stts->nb_entries-1].sampleDelta == duration) { stts->entries[stts->nb_entries-1].sampleCount += nb_pack; return GF_OK; } } if (stts->nb_entries==stts->alloc_size) { ALLOC_INC(stts->alloc_size); stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size); if (!stts->entries) return GF_OUT_OF_MEM; memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) ); } stts->entries[stts->nb_entries].sampleCount = nb_pack; stts->entries[stts->nb_entries].sampleDelta = duration; stts->nb_entries++; if (stts->max_ts_delta < duration ) stts->max_ts_delta = duration; return GF_OK; }","- if (!nb_pack) nb_pack = 1;
+ CHECK_PACK(GF_ISOM_INVALID_FILE)","GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack) { GF_TimeToSampleBox *stts = stbl->TimeToSample; CHECK_PACK(GF_ISOM_INVALID_FILE) if (stts->nb_entries) { if (stts->entries[stts->nb_entries-1].sampleDelta == duration) { stts->entries[stts->nb_entries-1].sampleCount += nb_pack; return GF_OK; } } if (stts->nb_entries==stts->alloc_size) { ALLOC_INC(stts->alloc_size); stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size); if (!stts->entries) return GF_OUT_OF_MEM; memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) ); } stts->entries[stts->nb_entries].sampleCount = nb_pack; stts->entries[stts->nb_entries].sampleDelta = duration; stts->nb_entries++; if (stts->max_ts_delta < duration ) stts->max_ts_delta = duration; return GF_OK; }"
512,838--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-1790--pk7_doit.c----*PKCS7_dataDecode,"BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert) { int i, j; BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL; X509_ALGOR *xa; ASN1_OCTET_STRING *data_body = NULL; const EVP_MD *evp_md; const EVP_CIPHER *evp_cipher = NULL; EVP_CIPHER_CTX *evp_ctx = NULL; X509_ALGOR *enc_alg = NULL; STACK_OF(X509_ALGOR) *md_sk = NULL; STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL; PKCS7_RECIP_INFO *ri = NULL; unsigned char *ek = NULL, *tkey = NULL; int eklen = 0, tkeylen = 0; if (p7 == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER); return NULL; } if (p7->d.ptr == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT); return NULL; } i = OBJ_obj2nid(p7->type); p7->state = PKCS7_S_HEADER; switch (i) { case NID_pkcs7_signed: data_body = PKCS7_get_octet_string(p7->d.sign->contents); if (!PKCS7_is_detached(p7) && data_body == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_SIGNED_DATA_TYPE); goto err; } md_sk = p7->d.sign->md_algs; break; case NID_pkcs7_signedAndEnveloped: rsk = p7->d.signed_and_enveloped->recipientinfo; md_sk = p7->d.signed_and_enveloped->md_algs; data_body = p7->d.signed_and_enveloped->enc_data->enc_data; enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm; evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm); if (evp_cipher == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CIPHER_TYPE); goto err; } break; case NID_pkcs7_enveloped: rsk = p7->d.enveloped->recipientinfo; enc_alg = p7->d.enveloped->enc_data->algorithm; data_body = p7->d.enveloped->enc_data->enc_data; evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm); if (evp_cipher == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CIPHER_TYPE); goto err; } break; default: PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE); goto err; } if (md_sk != NULL) { for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) { xa = sk_X509_ALGOR_value(md_sk, i); if ((btmp = BIO_new(BIO_f_md())) == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB); goto err; } j = OBJ_obj2nid(xa->algorithm); evp_md = EVP_get_digestbynid(j); if (evp_md == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNKNOWN_DIGEST_TYPE); goto err; } BIO_set_md(btmp, evp_md); if (out == NULL) out = btmp; else BIO_push(out, btmp); btmp = NULL; } } if (evp_cipher != NULL) { if ((etmp = BIO_new(BIO_f_cipher())) == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB); goto err; } if (pcert) { for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) { ri = sk_PKCS7_RECIP_INFO_value(rsk, i); if (!pkcs7_cmp_ri(ri, pcert)) break; ri = NULL; } if (ri == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE); goto err; } } if (pcert == NULL) { for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) { ri = sk_PKCS7_RECIP_INFO_value(rsk, i); if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0) goto err; ERR_clear_error(); } } else { if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0) goto err; ERR_clear_error(); } evp_ctx = NULL; BIO_get_cipher_ctx(etmp, &evp_ctx); if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0) goto err; if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0) goto err; tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx); tkey = OPENSSL_malloc(tkeylen); if (!tkey) goto err; if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0) goto err; if (ek == NULL) { ek = tkey; eklen = tkeylen; tkey = NULL; } if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) { if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) { OPENSSL_clear_free(ek, eklen); ek = tkey; eklen = tkeylen; tkey = NULL; } } ERR_clear_error(); if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0) goto err; OPENSSL_clear_free(ek, eklen); ek = NULL; OPENSSL_clear_free(tkey, tkeylen); tkey = NULL; if (out == NULL) out = etmp; else BIO_push(out, etmp); etmp = NULL; } <S2SV_StartVul> if (PKCS7_is_detached(p7) || (in_bio != NULL)) { <S2SV_EndVul> bio = in_bio; } else { if (data_body->length > 0) bio = BIO_new_mem_buf(data_body->data, data_body->length); else { bio = BIO_new(BIO_s_mem()); BIO_set_mem_eof_return(bio, 0); } if (bio == NULL) goto err; } BIO_push(out, bio); bio = NULL; return out; err: OPENSSL_clear_free(ek, eklen); OPENSSL_clear_free(tkey, tkeylen); BIO_free_all(out); BIO_free_all(btmp); BIO_free_all(etmp); BIO_free_all(bio); return NULL; }","- if (PKCS7_is_detached(p7) || (in_bio != NULL)) {
+ if (data_body == NULL && in_bio == NULL) {
+ PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);
+ goto err;
+ }
+ if (in_bio != NULL) {","BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert) { int i, j; BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL; X509_ALGOR *xa; ASN1_OCTET_STRING *data_body = NULL; const EVP_MD *evp_md; const EVP_CIPHER *evp_cipher = NULL; EVP_CIPHER_CTX *evp_ctx = NULL; X509_ALGOR *enc_alg = NULL; STACK_OF(X509_ALGOR) *md_sk = NULL; STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL; PKCS7_RECIP_INFO *ri = NULL; unsigned char *ek = NULL, *tkey = NULL; int eklen = 0, tkeylen = 0; if (p7 == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER); return NULL; } if (p7->d.ptr == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT); return NULL; } i = OBJ_obj2nid(p7->type); p7->state = PKCS7_S_HEADER; switch (i) { case NID_pkcs7_signed: data_body = PKCS7_get_octet_string(p7->d.sign->contents); if (!PKCS7_is_detached(p7) && data_body == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_SIGNED_DATA_TYPE); goto err; } md_sk = p7->d.sign->md_algs; break; case NID_pkcs7_signedAndEnveloped: rsk = p7->d.signed_and_enveloped->recipientinfo; md_sk = p7->d.signed_and_enveloped->md_algs; data_body = p7->d.signed_and_enveloped->enc_data->enc_data; enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm; evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm); if (evp_cipher == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CIPHER_TYPE); goto err; } break; case NID_pkcs7_enveloped: rsk = p7->d.enveloped->recipientinfo; enc_alg = p7->d.enveloped->enc_data->algorithm; data_body = p7->d.enveloped->enc_data->enc_data; evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm); if (evp_cipher == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CIPHER_TYPE); goto err; } break; default: PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE); goto err; } if (data_body == NULL && in_bio == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT); goto err; } if (md_sk != NULL) { for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) { xa = sk_X509_ALGOR_value(md_sk, i); if ((btmp = BIO_new(BIO_f_md())) == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB); goto err; } j = OBJ_obj2nid(xa->algorithm); evp_md = EVP_get_digestbynid(j); if (evp_md == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNKNOWN_DIGEST_TYPE); goto err; } BIO_set_md(btmp, evp_md); if (out == NULL) out = btmp; else BIO_push(out, btmp); btmp = NULL; } } if (evp_cipher != NULL) { if ((etmp = BIO_new(BIO_f_cipher())) == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB); goto err; } if (pcert) { for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) { ri = sk_PKCS7_RECIP_INFO_value(rsk, i); if (!pkcs7_cmp_ri(ri, pcert)) break; ri = NULL; } if (ri == NULL) { PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE); goto err; } } if (pcert == NULL) { for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) { ri = sk_PKCS7_RECIP_INFO_value(rsk, i); if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0) goto err; ERR_clear_error(); } } else { if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0) goto err; ERR_clear_error(); } evp_ctx = NULL; BIO_get_cipher_ctx(etmp, &evp_ctx); if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0) goto err; if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0) goto err; tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx); tkey = OPENSSL_malloc(tkeylen); if (!tkey) goto err; if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0) goto err; if (ek == NULL) { ek = tkey; eklen = tkeylen; tkey = NULL; } if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) { if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) { OPENSSL_clear_free(ek, eklen); ek = tkey; eklen = tkeylen; tkey = NULL; } } ERR_clear_error(); if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0) goto err; OPENSSL_clear_free(ek, eklen); ek = NULL; OPENSSL_clear_free(tkey, tkeylen); tkey = NULL; if (out == NULL) out = etmp; else BIO_push(out, etmp); etmp = NULL; } if (in_bio != NULL) { bio = in_bio; } else { if (data_body->length > 0) bio = BIO_new_mem_buf(data_body->data, data_body->length); else { bio = BIO_new(BIO_s_mem()); BIO_set_mem_eof_return(bio, 0); } if (bio == NULL) goto err; } BIO_push(out, bio); bio = NULL; return out; err: OPENSSL_clear_free(ek, eklen); OPENSSL_clear_free(tkey, tkeylen); BIO_free_all(out); BIO_free_all(btmp); BIO_free_all(etmp); BIO_free_all(bio); return NULL; }"
513,6159----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiValue.c----Jsi_ValueArrayIndex,"Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index) { Jsi_Obj *obj = args->d.obj; Jsi_Value *v; assert(args->vt == JSI_VT_OBJECT); if (obj->isarrlist && obj->arr) return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]); <S2SV_StartVul> char unibuf[100]; <S2SV_EndVul> Jsi_NumberItoA10(index, unibuf, sizeof(unibuf)); v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0); return v; }","- char unibuf[100];
+ char unibuf[JSI_MAX_NUMBER_STRING];","Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index) { Jsi_Obj *obj = args->d.obj; Jsi_Value *v; assert(args->vt == JSI_VT_OBJECT); if (obj->isarrlist && obj->arr) return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]); char unibuf[JSI_MAX_NUMBER_STRING]; Jsi_NumberItoA10(index, unibuf, sizeof(unibuf)); v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0); return v; }"
514,2775----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/default_validator.cc----Envoy::Extensions::TransportSockets::Tls::DefaultCertValidator::matchSubjectAltName,"bool DefaultCertValidator::matchSubjectAltName( <S2SV_StartVul> X509* cert, <S2SV_EndVul> <S2SV_StartVul> const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>& <S2SV_EndVul> <S2SV_StartVul> subject_alt_name_matchers) { <S2SV_EndVul> bssl::UniquePtr<GENERAL_NAMES> san_names( static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr))); if (san_names == nullptr) { return false; } <S2SV_StartVul> for (const GENERAL_NAME* general_name : san_names.get()) { <S2SV_EndVul> <S2SV_StartVul> const std::string san = Utility::generalNameAsString(general_name); <S2SV_EndVul> <S2SV_StartVul> for (auto& config_san_matcher : subject_alt_name_matchers) { <S2SV_EndVul> <S2SV_StartVul> if (general_name->type == GEN_DNS && <S2SV_EndVul> <S2SV_StartVul> config_san_matcher.matcher().match_pattern_case() == <S2SV_EndVul> <S2SV_StartVul> envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact <S2SV_EndVul> <S2SV_StartVul> ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san)) <S2SV_EndVul> <S2SV_StartVul> : config_san_matcher.match(san)) { <S2SV_EndVul> return true; } } } return false; }","- X509* cert,
- const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&
- subject_alt_name_matchers) {
- for (const GENERAL_NAME* general_name : san_names.get()) {
- const std::string san = Utility::generalNameAsString(general_name);
- for (auto& config_san_matcher : subject_alt_name_matchers) {
- if (general_name->type == GEN_DNS &&
- config_san_matcher.matcher().match_pattern_case() ==
- envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact
- ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))
- : config_san_matcher.match(san)) {
+ X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) {
+ for (const auto& config_san_matcher : subject_alt_name_matchers) {
+ for (const GENERAL_NAME* general_name : san_names.get()) {
+ if (config_san_matcher->match(general_name)) {","bool DefaultCertValidator::matchSubjectAltName( X509* cert, const std::vector<SanMatcherPtr>& subject_alt_name_matchers) { bssl::UniquePtr<GENERAL_NAMES> san_names( static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr))); if (san_names == nullptr) { return false; } for (const auto& config_san_matcher : subject_alt_name_matchers) { for (const GENERAL_NAME* general_name : san_names.get()) { if (config_san_matcher->match(general_name)) { return true; } } } return false; }"
515,7073----CWE-754----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/shape_inference.cc----tensorflow::shape_inference::InferenceContext::PreInputInit,"void InferenceContext::PreInputInit( const OpDef& op_def, const std::vector<const Tensor*>& input_tensors, const std::vector<ShapeHandle>& input_tensors_as_shapes) { const auto ret = full_type::SpecializeType(attrs_, op_def); <S2SV_StartVul> DCHECK(ret.status().ok()) << ""while instantiating types: "" << ret.status(); <S2SV_EndVul> ret_types_ = ret.ValueOrDie(); input_tensors_ = input_tensors; input_tensors_as_shapes_ = input_tensors_as_shapes; construction_status_ = NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_); if (!construction_status_.ok()) return; int num_outputs = 0; for (const auto& e : output_name_map_) { num_outputs = std::max(num_outputs, e.second.second); } outputs_.assign(num_outputs, nullptr); output_handle_shapes_and_types_.resize(num_outputs); }","- DCHECK(ret.status().ok()) << ""while instantiating types: "" << ret.status();
+ if (!ret.status().ok()) {
+ construction_status_ = ret.status();
+ return;
+ }","void InferenceContext::PreInputInit( const OpDef& op_def, const std::vector<const Tensor*>& input_tensors, const std::vector<ShapeHandle>& input_tensors_as_shapes) { const auto ret = full_type::SpecializeType(attrs_, op_def); if (!ret.status().ok()) { construction_status_ = ret.status(); return; } ret_types_ = ret.ValueOrDie(); input_tensors_ = input_tensors; input_tensors_as_shapes_ = input_tensors_as_shapes; construction_status_ = NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_); if (!construction_status_.ok()) return; int num_outputs = 0; for (const auto& e : output_name_map_) { num_outputs = std::max(num_outputs, e.second.second); } outputs_.assign(num_outputs, nullptr); output_handle_shapes_and_types_.resize(num_outputs); }"
516,4998----CWE-823----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/eval.c----eval_lambda,"eval_lambda( char_u **arg, typval_T *rettv, evalarg_T *evalarg, int verbose) { int evaluate = evalarg != NULL && (evalarg->eval_flags & EVAL_EVALUATE); typval_T base = *rettv; int ret; rettv->v_type = VAR_UNKNOWN; if (**arg == '{') { ret = get_lambda_tv(arg, rettv, FALSE, evalarg); } else { ++*arg; ret = eval1(arg, rettv, evalarg); *arg = skipwhite_and_linebreak(*arg, evalarg); <S2SV_StartVul> if (**arg == ')') <S2SV_EndVul> { <S2SV_StartVul> ++*arg; <S2SV_EndVul> } <S2SV_StartVul> else <S2SV_EndVul> { <S2SV_StartVul> emsg(_(e_missing_closing_paren)); <S2SV_EndVul> <S2SV_StartVul> ret = FAIL; <S2SV_EndVul> } } if (ret != OK) return FAIL; <S2SV_StartVul> else if (**arg != '(') <S2SV_EndVul> { if (verbose) { if (*skipwhite(*arg) == '(') emsg(_(e_no_white_space_allowed_before_parenthesis)); else semsg(_(e_missing_parenthesis_str), ""lambda""); } clear_tv(rettv); ret = FAIL; } else ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base); if (evaluate) clear_tv(&base); return ret; }","- if (**arg == ')')
- ++*arg;
- else
- emsg(_(e_missing_closing_paren));
- ret = FAIL;
- else if (**arg != '(')
+ if (**arg != ')')
+ emsg(_(e_missing_closing_paren));
+ return FAIL;
+ if (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC
+ && rettv->v_type != VAR_PARTIAL)
+ emsg(_(e_string_or_function_required_for_arrow_parens_expr));
+ return FAIL;
+ ++*arg;
+ if (**arg != '(')","eval_lambda( char_u **arg, typval_T *rettv, evalarg_T *evalarg, int verbose) { int evaluate = evalarg != NULL && (evalarg->eval_flags & EVAL_EVALUATE); typval_T base = *rettv; int ret; rettv->v_type = VAR_UNKNOWN; if (**arg == '{') { ret = get_lambda_tv(arg, rettv, FALSE, evalarg); } else { ++*arg; ret = eval1(arg, rettv, evalarg); *arg = skipwhite_and_linebreak(*arg, evalarg); if (**arg != ')') { emsg(_(e_missing_closing_paren)); return FAIL; } if (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC && rettv->v_type != VAR_PARTIAL) { emsg(_(e_string_or_function_required_for_arrow_parens_expr)); return FAIL; } ++*arg; } if (ret != OK) return FAIL; if (**arg != '(') { if (verbose) { if (*skipwhite(*arg) == '(') emsg(_(e_no_white_space_allowed_before_parenthesis)); else semsg(_(e_missing_parenthesis_str), ""lambda""); } clear_tv(rettv); ret = FAIL; } else ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base); if (evaluate) clear_tv(&base); return ret; }"
517,5642----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spk_ttyio.c----spk_ttyio_ldisc_open,"static int spk_ttyio_ldisc_open(struct tty_struct *tty) { struct spk_ldisc_data *ldisc_data; if (!tty->ops->write) return -EOPNOTSUPP; speakup_tty = tty; ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL); <S2SV_StartVul> if (!ldisc_data) <S2SV_EndVul> return -ENOMEM; init_completion(&ldisc_data->completion); ldisc_data->buf_free = true; speakup_tty->disc_data = ldisc_data; return 0; }","- if (!ldisc_data)
+ mutex_lock(&speakup_tty_mutex);
+ if (speakup_tty) {
+ mutex_unlock(&speakup_tty_mutex);
+ return -EBUSY;
+ }
+ if (!ldisc_data) {
+ speakup_tty = NULL;
+ mutex_unlock(&speakup_tty_mutex);
+ }
+ mutex_unlock(&speakup_tty_mutex);","static int spk_ttyio_ldisc_open(struct tty_struct *tty) { struct spk_ldisc_data *ldisc_data; if (!tty->ops->write) return -EOPNOTSUPP; mutex_lock(&speakup_tty_mutex); if (speakup_tty) { mutex_unlock(&speakup_tty_mutex); return -EBUSY; } speakup_tty = tty; ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL); if (!ldisc_data) { speakup_tty = NULL; mutex_unlock(&speakup_tty_mutex); return -ENOMEM; } init_completion(&ldisc_data->completion); ldisc_data->buf_free = true; speakup_tty->disc_data = ldisc_data; mutex_unlock(&speakup_tty_mutex); return 0; }"
518,5962----CWE-126----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/edit.c----display_dollar,"<S2SV_StartVul> display_dollar(colnr_T col) <S2SV_EndVul> { colnr_T save_col; if (!redrawing()) return; cursor_off(); save_col = curwin->w_cursor.col; curwin->w_cursor.col = col; if (has_mbyte) { char_u *p; p = ml_get_curline(); curwin->w_cursor.col -= (*mb_head_off)(p, p + col); } curs_columns(FALSE); if (curwin->w_wcol < curwin->w_width) { edit_putchar('$', FALSE); dollar_vcol = curwin->w_virtcol; } curwin->w_cursor.col = save_col; }","- display_dollar(colnr_T col)
+ display_dollar(colnr_T col_arg)
+ colnr_T col = col_arg < 0 ? 0 : col_arg;","display_dollar(colnr_T col_arg) { colnr_T col = col_arg < 0 ? 0 : col_arg; colnr_T save_col; if (!redrawing()) return; cursor_off(); save_col = curwin->w_cursor.col; curwin->w_cursor.col = col; if (has_mbyte) { char_u *p; p = ml_get_curline(); curwin->w_cursor.col -= (*mb_head_off)(p, p + col); } curs_columns(FALSE); if (curwin->w_wcol < curwin->w_width) { edit_putchar('$', FALSE); dollar_vcol = curwin->w_virtcol; } curwin->w_cursor.col = save_col; }"
519,2977----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/espLib.c----updateFields,"PUBLIC bool updateFields(cchar *tableName, MprJson *params) { EdiRec *rec; cchar *key; <S2SV_StartVul> key = mprLookupJson(params, ""id""); <S2SV_EndVul> if ((rec = ediSetFields(ediReadRec(getDatabase(), tableName, key), params)) == 0) { return 0; } return updateRec(rec); }","- key = mprLookupJson(params, ""id"");
+ key = mprReadJson(params, ""id"");","PUBLIC bool updateFields(cchar *tableName, MprJson *params) { EdiRec *rec; cchar *key; key = mprReadJson(params, ""id""); if ((rec = ediSetFields(ediReadRec(getDatabase(), tableName, key), params)) == 0) { return 0; } return updateRec(rec); }"
520,4386----CWE-134----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cbr_detector_remote.cpp----wire::CbrDetectorRemote::Decrypt,"CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type, const std::vector<uint32_t>& csrcs, rtc::ArrayView<const uint8_t> additional_data, rtc::ArrayView<const uint8_t> encrypted_frame, rtc::ArrayView<uint8_t> frame) { const uint8_t *src = encrypted_frame.data(); uint8_t *dst = frame.data(); uint32_t data_len = encrypted_frame.size(); if (media_type == cricket::MEDIA_TYPE_AUDIO) { if (data_len == frame_size && frame_size >= 40) { frame_count++; <S2SV_StartVul> if (frame_count > 200 && !detected) { <S2SV_EndVul> info(""CBR detector: remote cbr detected\n""); detected = true; } } else { <S2SV_StartVul> frame_count = 0; <S2SV_EndVul> <S2SV_StartVul> frame_size = data_len; <S2SV_EndVul> <S2SV_StartVul> if (detected) { <S2SV_EndVul> <S2SV_StartVul> info(""CBR detector: remote cbr detected disabled\n""); <S2SV_EndVul> <S2SV_StartVul> detected = false; <S2SV_EndVul> } } } memcpy(dst, src, data_len); out: return CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len); }","- if (frame_count > 200 && !detected) {
- frame_count = 0;
- frame_size = data_len;
- if (detected) {
- info(""CBR detector: remote cbr detected disabled\n"");
- detected = false;
+ missmatch_count = 0;
+ if (frame_count > MIN_MATCH && !detected) {
+ missmatch_count++;
+ if (!detected
+ || (detected && missmatch_count > MAX_MISSMATCH)) {
+ frame_count = 0;
+ frame_size = data_len;
+ missmatch_count = 0;
+ if (detected) {
+ info(""CBR detector: remote cbr detected disabled\n"");
+ detected = false;
+ }","CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type, const std::vector<uint32_t>& csrcs, rtc::ArrayView<const uint8_t> additional_data, rtc::ArrayView<const uint8_t> encrypted_frame, rtc::ArrayView<uint8_t> frame) { const uint8_t *src = encrypted_frame.data(); uint8_t *dst = frame.data(); uint32_t data_len = encrypted_frame.size(); if (media_type == cricket::MEDIA_TYPE_AUDIO) { if (data_len == frame_size && frame_size >= 40) { missmatch_count = 0; frame_count++; if (frame_count > MIN_MATCH && !detected) { info(""CBR detector: remote cbr detected\n""); detected = true; } } else { missmatch_count++; if (!detected || (detected && missmatch_count > MAX_MISSMATCH)) { frame_count = 0; frame_size = data_len; missmatch_count = 0; if (detected) { info(""CBR detector: remote cbr detected disabled\n""); detected = false; } } } } memcpy(dst, src, data_len); out: return CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len); }"
521,2772----CWE-770----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xfile.h----DLL_EXPCxFile::~CxFile,<S2SV_StartVul> virtual ~CxFile() { }; <S2SV_EndVul>,"- virtual ~CxFile() { };
+ virtual ~CxFile() { }",virtual ~CxFile() { }
522,5507----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/index.c----mobi_decode_infl,"MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) { int pos = *decoded_size; char mod = 'i'; char dir = '<'; char olddir; unsigned char c; while ((c = *rule++)) { if (c <= 4) { mod = (c <= 2) ? 'i' : 'd'; olddir = dir; dir = (c & 2) ? '<' : '>'; if (olddir != dir && olddir) { pos = (c & 2) ? *decoded_size : 0; } } else if (c > 10 && c < 20) { if (dir == '>') { pos = *decoded_size; } pos -= c - 10; dir = 0; <S2SV_StartVul> if (pos < 0 || pos > *decoded_size) { <S2SV_EndVul> <S2SV_StartVul> debug_print(""Position setting failed (%s)\n"", decoded); <S2SV_EndVul> <S2SV_StartVul> return MOBI_DATA_CORRUPT; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } else { if (mod == 'i') { const unsigned char *s = decoded + pos; unsigned char *d = decoded + pos + 1; const int l = *decoded_size - pos; <S2SV_StartVul> if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) { <S2SV_EndVul> debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos); return MOBI_DATA_CORRUPT; } memmove(d, s, (size_t) l); decoded[pos] = c; (*decoded_size)++; if (dir == '>') { pos++; } } else { if (dir == '<') { pos--; } const unsigned char *s = decoded + pos + 1; unsigned char *d = decoded + pos; const int l = *decoded_size - pos; <S2SV_StartVul> if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) { <S2SV_EndVul> debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos); return MOBI_DATA_CORRUPT; } if (decoded[pos] != c) { debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", decoded, pos, decoded[pos], c); return MOBI_DATA_CORRUPT; } memmove(d, s, (size_t) l); (*decoded_size)--; } } } return MOBI_SUCCESS; }","- if (pos < 0 || pos > *decoded_size) {
- debug_print(""Position setting failed (%s)\n"", decoded);
- return MOBI_DATA_CORRUPT;
- }
- if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
- if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
+ if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {
+ if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) {","MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) { int pos = *decoded_size; char mod = 'i'; char dir = '<'; char olddir; unsigned char c; while ((c = *rule++)) { if (c <= 4) { mod = (c <= 2) ? 'i' : 'd'; olddir = dir; dir = (c & 2) ? '<' : '>'; if (olddir != dir && olddir) { pos = (c & 2) ? *decoded_size : 0; } } else if (c > 10 && c < 20) { if (dir == '>') { pos = *decoded_size; } pos -= c - 10; dir = 0; } else { if (mod == 'i') { const unsigned char *s = decoded + pos; unsigned char *d = decoded + pos + 1; const int l = *decoded_size - pos; if (pos < 0 || l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) { debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos); return MOBI_DATA_CORRUPT; } memmove(d, s, (size_t) l); decoded[pos] = c; (*decoded_size)++; if (dir == '>') { pos++; } } else { if (dir == '<') { pos--; } const unsigned char *s = decoded + pos + 1; unsigned char *d = decoded + pos; const int l = *decoded_size - pos; if (pos < 0 || l < 0 || s + l > decoded + INDX_INFLBUF_SIZEMAX) { debug_print(""Out of buffer in %s at pos: %i\n"", decoded, pos); return MOBI_DATA_CORRUPT; } if (decoded[pos] != c) { debug_print(""Character mismatch in %s at pos: %i (%c != %c)\n"", decoded, pos, decoded[pos], c); return MOBI_DATA_CORRUPT; } memmove(d, s, (size_t) l); (*decoded_size)--; } } } return MOBI_SUCCESS; }"
523,5456----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/edit.c----bracketed_paste,"bracketed_paste(paste_mode_T mode, int drop, garray_T *gap) { int c; char_u buf[NUMBUFLEN + MB_MAXBYTES]; int idx = 0; char_u *end = find_termcode((char_u *)""PE""); int ret_char = -1; int save_allow_keys = allow_keys; int save_paste = p_paste; if (end != NULL && STRLEN(end) >= NUMBUFLEN) end = NULL; ++no_mapping; allow_keys = 0; if (!p_paste) set_option_value((char_u *)""paste"", TRUE, NULL, 0); for (;;) { if (end == NULL && vpeekc() == NUL) break; do c = vgetc(); while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR); if (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C)) break; if (has_mbyte) idx += (*mb_char2bytes)(c, buf + idx); else buf[idx++] = c; buf[idx] = NUL; if (end != NULL && STRNCMP(buf, end, idx) == 0) { if (end[idx] == NUL) break; continue; } if (!drop) { switch (mode) { case PASTE_CMDLINE: put_on_cmdline(buf, idx, TRUE); break; case PASTE_EX: <S2SV_StartVul> if (gap != NULL && ga_grow(gap, idx) == OK) <S2SV_EndVul> { mch_memmove((char *)gap->ga_data + gap->ga_len, buf, (size_t)idx); gap->ga_len += idx; } break; case PASTE_INSERT: if (stop_arrow() == OK) { c = buf[0]; if (idx == 1 && (c == CAR || c == K_KENTER || c == NL)) ins_eol(c); else { ins_char_bytes(buf, idx); AppendToRedobuffLit(buf, idx); } } break; case PASTE_ONE_CHAR: if (ret_char == -1) { if (has_mbyte) ret_char = (*mb_ptr2char)(buf); else ret_char = buf[0]; } break; } } idx = 0; } --no_mapping; allow_keys = save_allow_keys; if (!save_paste) set_option_value((char_u *)""paste"", FALSE, NULL, 0); return ret_char; }","- if (gap != NULL && ga_grow(gap, idx) == OK)
+ if (gap != NULL && ga_grow(gap, idx + 1) == OK)","bracketed_paste(paste_mode_T mode, int drop, garray_T *gap) { int c; char_u buf[NUMBUFLEN + MB_MAXBYTES]; int idx = 0; char_u *end = find_termcode((char_u *)""PE""); int ret_char = -1; int save_allow_keys = allow_keys; int save_paste = p_paste; if (end != NULL && STRLEN(end) >= NUMBUFLEN) end = NULL; ++no_mapping; allow_keys = 0; if (!p_paste) set_option_value((char_u *)""paste"", TRUE, NULL, 0); for (;;) { if (end == NULL && vpeekc() == NUL) break; do c = vgetc(); while (c == K_IGNORE || c == K_VER_SCROLLBAR || c == K_HOR_SCROLLBAR); if (c == NUL || got_int || (ex_normal_busy > 0 && c == Ctrl_C)) break; if (has_mbyte) idx += (*mb_char2bytes)(c, buf + idx); else buf[idx++] = c; buf[idx] = NUL; if (end != NULL && STRNCMP(buf, end, idx) == 0) { if (end[idx] == NUL) break; continue; } if (!drop) { switch (mode) { case PASTE_CMDLINE: put_on_cmdline(buf, idx, TRUE); break; case PASTE_EX: if (gap != NULL && ga_grow(gap, idx + 1) == OK) { mch_memmove((char *)gap->ga_data + gap->ga_len, buf, (size_t)idx); gap->ga_len += idx; } break; case PASTE_INSERT: if (stop_arrow() == OK) { c = buf[0]; if (idx == 1 && (c == CAR || c == K_KENTER || c == NL)) ins_eol(c); else { ins_char_bytes(buf, idx); AppendToRedobuffLit(buf, idx); } } break; case PASTE_ONE_CHAR: if (ret_char == -1) { if (has_mbyte) ret_char = (*mb_ptr2char)(buf); else ret_char = buf[0]; } break; } } idx = 0; } --no_mapping; allow_keys = save_allow_keys; if (!save_paste) set_option_value((char_u *)""paste"", FALSE, NULL, 0); return ret_char; }"
524,7165----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/filedump.c----print_udta,"} void print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags) { u32 i, count; count = gf_isom_get_udta_count(file, track_number); if (!count) return; if (has_itags) { for (i=0; i<count; i++) { u32 type; bin128 uuid; gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid); if (type == GF_ISOM_BOX_TYPE_META) { count--; break; } } if (!count) return; } fprintf(stderr, ""%d UDTA types: "", count); for (i=0; i<count; i++) { u32 j, type, nb_items, first=GF_TRUE; bin128 uuid; gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid); nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid); fprintf(stderr, ""%s (%d) "", gf_4cc_to_str(type), nb_items); for (j=0; j<nb_items; j++) { u8 *udta=NULL; u32 udta_size; gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size); if (!udta) continue; <S2SV_StartVul> if (gf_utf8_is_legal(udta, udta_size)) { <S2SV_EndVul> if (first) { fprintf(stderr, ""\n""); first = GF_FALSE; } <S2SV_StartVul> fprintf(stderr, ""\t%s\n"", (char *) udta); <S2SV_EndVul> } gf_free(udta); } }","- if (gf_utf8_is_legal(udta, udta_size)) {
- fprintf(stderr, ""\t%s\n"", (char *) udta);
+ if (udta_size && gf_utf8_is_legal(udta, udta_size)) {
+ u32 idx;
+ fprintf(stderr, ""\t"");
+ for (idx=0; idx<udta_size; idx++) {
+ if (!udta[idx]) break;
+ fprintf(stderr, ""%c"", udta[idx]);
+ }
+ fprintf(stderr, ""\n"");","} void print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags) { u32 i, count; count = gf_isom_get_udta_count(file, track_number); if (!count) return; if (has_itags) { for (i=0; i<count; i++) { u32 type; bin128 uuid; gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid); if (type == GF_ISOM_BOX_TYPE_META) { count--; break; } } if (!count) return; } fprintf(stderr, ""%d UDTA types: "", count); for (i=0; i<count; i++) { u32 j, type, nb_items, first=GF_TRUE; bin128 uuid; gf_isom_get_udta_type(file, track_number, i+1, &type, &uuid); nb_items = gf_isom_get_user_data_count(file, track_number, type, uuid); fprintf(stderr, ""%s (%d) "", gf_4cc_to_str(type), nb_items); for (j=0; j<nb_items; j++) { u8 *udta=NULL; u32 udta_size; gf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size); if (!udta) continue; if (udta_size && gf_utf8_is_legal(udta, udta_size)) { u32 idx; if (first) { fprintf(stderr, ""\n""); first = GF_FALSE; } fprintf(stderr, ""\t""); for (idx=0; idx<udta_size; idx++) { if (!udta[idx]) break; fprintf(stderr, ""%c"", udta[idx]); } fprintf(stderr, ""\n""); } gf_free(udta); } }"
525,2156----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18218--hns_enet.c----hns_nic_net_xmit_hw,"<S2SV_StartVul> int hns_nic_net_xmit_hw(struct net_device *ndev, <S2SV_EndVul> <S2SV_StartVul> struct sk_buff *skb, <S2SV_EndVul> <S2SV_StartVul> struct hns_nic_ring_data *ring_data) <S2SV_EndVul> { struct hns_nic_priv *priv = netdev_priv(ndev); struct hnae_ring *ring = ring_data->ring; struct device *dev = ring_to_dev(ring); struct netdev_queue *dev_queue; struct skb_frag_struct *frag; int buf_num; int seg_num; dma_addr_t dma; int size, next_to_use; int i; switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) { case -EBUSY: ring->stats.tx_busy++; goto out_net_tx_busy; case -ENOMEM: ring->stats.sw_err_cnt++; netdev_err(ndev, ""no memory to xmit!\n""); goto out_err_tx_ok; default: break; } seg_num = skb_shinfo(skb)->nr_frags + 1; next_to_use = ring->next_to_use; size = skb_headlen(skb); dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE); if (dma_mapping_error(dev, dma)) { netdev_err(ndev, ""TX head DMA map failed\n""); ring->stats.sw_err_cnt++; goto out_err_tx_ok; } priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0, buf_num, DESC_TYPE_SKB, ndev->mtu); for (i = 1; i < seg_num; i++) { frag = &skb_shinfo(skb)->frags[i - 1]; size = skb_frag_size(frag); dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE); if (dma_mapping_error(dev, dma)) { netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i); ring->stats.sw_err_cnt++; goto out_map_frag_fail; } priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma, seg_num - 1 == i ? 1 : 0, buf_num, DESC_TYPE_PAGE, ndev->mtu); } dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping); netdev_tx_sent_queue(dev_queue, skb->len); wmb(); assert(skb->queue_mapping < priv->ae_handle->q_num); hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num); ring->stats.tx_pkts++; ring->stats.tx_bytes += skb->len; return NETDEV_TX_OK; out_map_frag_fail: while (ring->next_to_use != next_to_use) { unfill_desc(ring); if (ring->next_to_use != next_to_use) dma_unmap_page(dev, ring->desc_cb[ring->next_to_use].dma, ring->desc_cb[ring->next_to_use].length, DMA_TO_DEVICE); else dma_unmap_single(dev, ring->desc_cb[next_to_use].dma, ring->desc_cb[next_to_use].length, DMA_TO_DEVICE); } out_err_tx_ok: dev_kfree_skb_any(skb); return NETDEV_TX_OK; out_net_tx_busy: netif_stop_subqueue(ndev, skb->queue_mapping); smp_mb(); return NETDEV_TX_BUSY; }","- int hns_nic_net_xmit_hw(struct net_device *ndev,
- struct sk_buff *skb,
- struct hns_nic_ring_data *ring_data)
+ int hns_nic_net_xmit_hw(struct net_device *ndev,
+ netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev,
+ struct sk_buff *skb,
+ 
+ netif_trans_update(ndev);
+ ndev->stats.tx_bytes += skb->len;","int hns_nic_net_xmit_hw(struct net_device *ndev, netdev_tx_t hns_nic_net_xmit_hw(struct net_device *ndev, struct sk_buff *skb, struct hns_nic_ring_data *ring_data) { struct hns_nic_priv *priv = netdev_priv(ndev); struct hnae_ring *ring = ring_data->ring; struct device *dev = ring_to_dev(ring); struct netdev_queue *dev_queue; struct skb_frag_struct *frag; int buf_num; int seg_num; dma_addr_t dma; int size, next_to_use; int i; switch (priv->ops.maybe_stop_tx(&skb, &buf_num, ring)) { case -EBUSY: ring->stats.tx_busy++; goto out_net_tx_busy; case -ENOMEM: ring->stats.sw_err_cnt++; netdev_err(ndev, ""no memory to xmit!\n""); goto out_err_tx_ok; default: break; } seg_num = skb_shinfo(skb)->nr_frags + 1; next_to_use = ring->next_to_use; size = skb_headlen(skb); dma = dma_map_single(dev, skb->data, size, DMA_TO_DEVICE); if (dma_mapping_error(dev, dma)) { netdev_err(ndev, ""TX head DMA map failed\n""); ring->stats.sw_err_cnt++; goto out_err_tx_ok; } priv->ops.fill_desc(ring, skb, size, dma, seg_num == 1 ? 1 : 0, buf_num, DESC_TYPE_SKB, ndev->mtu); for (i = 1; i < seg_num; i++) { frag = &skb_shinfo(skb)->frags[i - 1]; size = skb_frag_size(frag); dma = skb_frag_dma_map(dev, frag, 0, size, DMA_TO_DEVICE); if (dma_mapping_error(dev, dma)) { netdev_err(ndev, ""TX frag(%d) DMA map failed\n"", i); ring->stats.sw_err_cnt++; goto out_map_frag_fail; } priv->ops.fill_desc(ring, skb_frag_page(frag), size, dma, seg_num - 1 == i ? 1 : 0, buf_num, DESC_TYPE_PAGE, ndev->mtu); } dev_queue = netdev_get_tx_queue(ndev, skb->queue_mapping); netdev_tx_sent_queue(dev_queue, skb->len); netif_trans_update(ndev); ndev->stats.tx_bytes += skb->len; ndev->stats.tx_packets++; wmb(); assert(skb->queue_mapping < priv->ae_handle->q_num); hnae_queue_xmit(priv->ae_handle->qs[skb->queue_mapping], buf_num); ring->stats.tx_pkts++; ring->stats.tx_bytes += skb->len; return NETDEV_TX_OK; out_map_frag_fail: while (ring->next_to_use != next_to_use) { unfill_desc(ring); if (ring->next_to_use != next_to_use) dma_unmap_page(dev, ring->desc_cb[ring->next_to_use].dma, ring->desc_cb[ring->next_to_use].length, DMA_TO_DEVICE); else dma_unmap_single(dev, ring->desc_cb[next_to_use].dma, ring->desc_cb[next_to_use].length, DMA_TO_DEVICE); } out_err_tx_ok: dev_kfree_skb_any(skb); return NETDEV_TX_OK; out_net_tx_busy: netif_stop_subqueue(ndev, skb->queue_mapping); smp_mb(); return NETDEV_TX_BUSY; }"
526,4558----CWE-200----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dsa.cpp----Botan::DSA_Signature_Operation::raw_sign,"DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len, RandomNumberGenerator& rng) { const BigInt& q = m_group.get_q(); <S2SV_StartVul> BigInt i(msg, msg_len, q.bits()); <S2SV_EndVul> <S2SV_StartVul> while(i >= q) <S2SV_EndVul> <S2SV_StartVul> i -= q; <S2SV_EndVul> #if defined(BOTAN_HAS_RFC6979_GENERATOR) BOTAN_UNUSED(rng); <S2SV_StartVul> const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash); <S2SV_EndVul> #else const BigInt k = BigInt::random_integer(rng, 1, q); #endif <S2SV_StartVul> BigInt s = inverse_mod(k, q); <S2SV_EndVul> const BigInt r = m_mod_q.reduce(m_group.power_g_p(k)); <S2SV_StartVul> s = m_mod_q.multiply(s, mul_add(m_x, r, i)); <S2SV_EndVul> if(r.is_zero() || s.is_zero()) throw Internal_Error(""Computed zero r/s during DSA signature""); return BigInt::encode_fixed_length_int_pair(r, s, q.bytes()); }","- BigInt i(msg, msg_len, q.bits());
- while(i >= q)
- i -= q;
- const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);
- BigInt s = inverse_mod(k, q);
- s = m_mod_q.multiply(s, mul_add(m_x, r, i));
+ BigInt m(msg, msg_len, q.bits());
+ while(m >= q)
+ m -= q;
+ const BigInt k = generate_rfc6979_nonce(m_x, q, m, m_rfc6979_hash);
+ const BigInt k_inv = inverse_mod(k, q);
+ m_b = m_mod_q.square(m_b);
+ m_b_inv = m_mod_q.square(m_b_inv);
+ m = m_mod_q.multiply(m_b, m);
+ const BigInt xr = m_mod_q.multiply(m_mod_q.multiply(m_x, m_b), r);
+ const BigInt s = m_mod_q.multiply(m_b_inv, m_mod_q.multiply(k_inv, xr + m));","DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len, RandomNumberGenerator& rng) { const BigInt& q = m_group.get_q(); BigInt m(msg, msg_len, q.bits()); while(m >= q) m -= q; #if defined(BOTAN_HAS_RFC6979_GENERATOR) BOTAN_UNUSED(rng); const BigInt k = generate_rfc6979_nonce(m_x, q, m, m_rfc6979_hash); #else const BigInt k = BigInt::random_integer(rng, 1, q); #endif const BigInt k_inv = inverse_mod(k, q); const BigInt r = m_mod_q.reduce(m_group.power_g_p(k)); m_b = m_mod_q.square(m_b); m_b_inv = m_mod_q.square(m_b_inv); m = m_mod_q.multiply(m_b, m); const BigInt xr = m_mod_q.multiply(m_mod_q.multiply(m_x, m_b), r); const BigInt s = m_mod_q.multiply(m_b_inv, m_mod_q.multiply(k_inv, xr + m)); if(r.is_zero() || s.is_zero()) throw Internal_Error(""Computed zero r/s during DSA signature""); return BigInt::encode_fixed_length_int_pair(r, s, q.bytes()); }"
527,5728----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/Pl_ASCIIHexDecoder.cc----Pl_ASCIIHexDecoder::flush,"Pl_ASCIIHexDecoder::flush() { if (this->pos == 0) { QTC::TC(""libtests"", ""Pl_ASCIIHexDecoder no-op flush""); return; } int b[2]; for (int i = 0; i < 2; ++i) { if (this->inbuf[i] >= 'A') { b[i] = this->inbuf[i] - 'A' + 10; } else { b[i] = this->inbuf[i] - '0'; } } unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]); QTC::TC(""libtests"", ""Pl_ASCIIHexDecoder partial flush"", (this->pos == 2) ? 0 : 1); <S2SV_StartVul> getNext()->write(&ch, 1); <S2SV_EndVul> this->pos = 0; this->inbuf[0] = '0'; this->inbuf[1] = '0'; this->inbuf[2] = '\0'; }","- getNext()->write(&ch, 1);
+ getNext()->write(&ch, 1);","Pl_ASCIIHexDecoder::flush() { if (this->pos == 0) { QTC::TC(""libtests"", ""Pl_ASCIIHexDecoder no-op flush""); return; } int b[2]; for (int i = 0; i < 2; ++i) { if (this->inbuf[i] >= 'A') { b[i] = this->inbuf[i] - 'A' + 10; } else { b[i] = this->inbuf[i] - '0'; } } unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]); QTC::TC(""libtests"", ""Pl_ASCIIHexDecoder partial flush"", (this->pos == 2) ? 0 : 1); this->pos = 0; this->inbuf[0] = '0'; this->inbuf[1] = '0'; this->inbuf[2] = '\0'; getNext()->write(&ch, 1); }"
528,4278----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hostsock.c----_hostsock_getsockname,"static int _hostsock_getsockname( oe_fd_t* sock_, struct oe_sockaddr* addr, oe_socklen_t* addrlen) { int ret = -1; sock_t* sock = _cast_sock(sock_); oe_socklen_t addrlen_in = 0; oe_errno = 0; <S2SV_StartVul> if (!sock) <S2SV_EndVul> OE_RAISE_ERRNO(OE_EINVAL); <S2SV_StartVul> if (addrlen) <S2SV_EndVul> <S2SV_StartVul> addrlen_in = *addrlen; <S2SV_EndVul> if (oe_syscall_getsockname_ocall( <S2SV_StartVul> &ret, <S2SV_EndVul> <S2SV_StartVul> sock->host_fd, <S2SV_EndVul> <S2SV_StartVul> (struct oe_sockaddr*)addr, <S2SV_EndVul> <S2SV_StartVul> addrlen_in, <S2SV_EndVul> <S2SV_StartVul> addrlen) != OE_OK) <S2SV_EndVul> { OE_RAISE_ERRNO(OE_EINVAL); } done: return ret; }","- if (!sock)
- if (addrlen)
- addrlen_in = *addrlen;
- &ret,
- sock->host_fd,
- (struct oe_sockaddr*)addr,
- addrlen_in,
- addrlen) != OE_OK)
+ oe_socklen_t addrlen_out = 0;
+ if (!sock || !addr || !addrlen)
+ addrlen_in = *addrlen;
+ if (addrlen_in < 0)
+ OE_RAISE_ERRNO(OE_EINVAL);
+ &ret, sock->host_fd, addr, addrlen_in, &addrlen_out) != OE_OK)
+ if (addrlen_out > sizeof(struct oe_sockaddr_storage))
+ OE_RAISE_ERRNO(OE_EINVAL);
+ if (addrlen_in >= addrlen_out)","static int _hostsock_getsockname( oe_fd_t* sock_, struct oe_sockaddr* addr, oe_socklen_t* addrlen) { int ret = -1; sock_t* sock = _cast_sock(sock_); oe_socklen_t addrlen_in = 0; oe_socklen_t addrlen_out = 0; oe_errno = 0; if (!sock || !addr || !addrlen) OE_RAISE_ERRNO(OE_EINVAL); addrlen_in = *addrlen; if (addrlen_in < 0) OE_RAISE_ERRNO(OE_EINVAL); if (oe_syscall_getsockname_ocall( &ret, sock->host_fd, addr, addrlen_in, &addrlen_out) != OE_OK) { OE_RAISE_ERRNO(OE_EINVAL); } if (addrlen_out > sizeof(struct oe_sockaddr_storage)) OE_RAISE_ERRNO(OE_EINVAL); if (addrlen_in >= addrlen_out) *addrlen = addrlen_out; done: return ret; }"
529,3618----CWE-276----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/flatpak-transaction.c----resolve_op_end,"resolve_op_end (FlatpakTransaction *self, FlatpakTransactionOperation *op, const char *checksum, GFile *sideload_path, <S2SV_StartVul> GBytes *metadata_bytes) <S2SV_EndVul> { g_autoptr(GBytes) old_metadata_bytes = NULL; old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL); <S2SV_StartVul> mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes); <S2SV_EndVul> emit_eol_and_maybe_skip (self, op); }","- GBytes *metadata_bytes)
- mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);
+ GBytes *metadata_bytes,
+ GError **error)
+ if (!mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes, error))
+ return FALSE;
+ return TRUE;","resolve_op_end (FlatpakTransaction *self, FlatpakTransactionOperation *op, const char *checksum, GFile *sideload_path, GBytes *metadata_bytes, GError **error) { g_autoptr(GBytes) old_metadata_bytes = NULL; old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL); if (!mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes, error)) return FALSE; emit_eol_and_maybe_skip (self, op); return TRUE; }"
530,5222----CWE-354----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/recovery_cipher.c----recovery_cipher_finalize,"void recovery_cipher_finalize(void) { static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = """"; static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF]; volatile bool auto_completed = true; char *tok = strtok(mnemonic, "" ""); while(tok) { strlcpy(temp_word, tok, CURRENT_WORD_BUF); auto_completed &= attempt_auto_complete(temp_word); strlcat(new_mnemonic, temp_word, MNEMONIC_BUF); strlcat(new_mnemonic, "" "", MNEMONIC_BUF); tok = strtok(NULL, "" ""); } memzero(temp_word, sizeof(temp_word)); if (!auto_completed && !enforce_wordlist) { if (!dry_run) { storage_reset(); } fsm_sendFailure(FailureType_Failure_SyntaxError, ""Words were not entered correctly. Make sure you are using the substition cipher.""); awaiting_character = false; layoutHome(); return; } <S2SV_StartVul> new_mnemonic[strlen(new_mnemonic) - 1] = '\0'; <S2SV_EndVul> if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) { storage_setMnemonic(new_mnemonic); memzero(new_mnemonic, sizeof(new_mnemonic)); if (!enforce_wordlist) { storage_setImported(true); } storage_commit(); fsm_sendSuccess(""Device recovered""); } else if (dry_run) { bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic); if (match) { review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"", ""The seed is valid and MATCHES the one in the device.""); fsm_sendSuccess(""The seed is valid and matches the one in the device.""); } else if (mnemonic_check(new_mnemonic)) { review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"", ""The seed is valid, but DOES NOT MATCH the one in the device.""); fsm_sendFailure(FailureType_Failure_Other, ""The seed is valid, but does not match the one in the device.""); } else { review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"", ""The seed is INVALID, and DOES NOT MATCH the one in the device.""); fsm_sendFailure(FailureType_Failure_Other, ""The seed is invalid, and does not match the one in the device.""); } memzero(new_mnemonic, sizeof(new_mnemonic)); } else { session_clear(true); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Invalid mnemonic, are words in correct order?""); recovery_abort(); } memzero(new_mnemonic, sizeof(new_mnemonic)); awaiting_character = false; memzero(mnemonic, sizeof(mnemonic)); memzero(cipher, sizeof(cipher)); layoutHome(); }","- new_mnemonic[strlen(new_mnemonic) - 1] = '\0';
+ if (!recovery_started) {
+ recovery_abort();
+ fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Not in Recovery mode"");
+ layoutHome();
+ return;
+ }
+ new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\0';","void recovery_cipher_finalize(void) { if (!recovery_started) { recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Not in Recovery mode""); layoutHome(); return; } static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = """"; static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF]; volatile bool auto_completed = true; char *tok = strtok(mnemonic, "" ""); while(tok) { strlcpy(temp_word, tok, CURRENT_WORD_BUF); auto_completed &= attempt_auto_complete(temp_word); strlcat(new_mnemonic, temp_word, MNEMONIC_BUF); strlcat(new_mnemonic, "" "", MNEMONIC_BUF); tok = strtok(NULL, "" ""); } memzero(temp_word, sizeof(temp_word)); if (!auto_completed && !enforce_wordlist) { if (!dry_run) { storage_reset(); } fsm_sendFailure(FailureType_Failure_SyntaxError, ""Words were not entered correctly. Make sure you are using the substition cipher.""); awaiting_character = false; layoutHome(); return; } new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\0'; if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) { storage_setMnemonic(new_mnemonic); memzero(new_mnemonic, sizeof(new_mnemonic)); if (!enforce_wordlist) { storage_setImported(true); } storage_commit(); fsm_sendSuccess(""Device recovered""); } else if (dry_run) { bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic); if (match) { review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"", ""The seed is valid and MATCHES the one in the device.""); fsm_sendSuccess(""The seed is valid and matches the one in the device.""); } else if (mnemonic_check(new_mnemonic)) { review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"", ""The seed is valid, but DOES NOT MATCH the one in the device.""); fsm_sendFailure(FailureType_Failure_Other, ""The seed is valid, but does not match the one in the device.""); } else { review(ButtonRequestType_ButtonRequest_Other, ""Recovery Dry Run"", ""The seed is INVALID, and DOES NOT MATCH the one in the device.""); fsm_sendFailure(FailureType_Failure_Other, ""The seed is invalid, and does not match the one in the device.""); } memzero(new_mnemonic, sizeof(new_mnemonic)); } else { session_clear(true); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Invalid mnemonic, are words in correct order?""); recovery_abort(); } memzero(new_mnemonic, sizeof(new_mnemonic)); awaiting_character = false; memzero(mnemonic, sizeof(mnemonic)); memzero(cipher, sizeof(cipher)); layoutHome(); }"
531,2900----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/image.cxx----image_load_bmp,"image_load_bmp(image_t *img, FILE *fp, int gray, int load_data) { int info_size, depth, compression, colors_used, x, y, color, count, temp, align; uchar bit, byte; uchar *ptr; uchar colormap[256][4]; getc(fp); getc(fp); read_dword(fp); read_word(fp); read_word(fp); read_dword(fp); info_size = (int)read_dword(fp); img->width = read_long(fp); img->height = read_long(fp); read_word(fp); depth = read_word(fp); compression = (int)read_dword(fp); read_dword(fp); read_long(fp); read_long(fp); colors_used = (int)read_dword(fp); read_dword(fp); if (info_size > 40) for (info_size -= 40; info_size > 0; info_size --) getc(fp); if (colors_used == 0 && depth <= 8) colors_used = 1 << depth; fread(colormap, (size_t)colors_used, 4, fp); <S2SV_StartVul> img->depth = gray ? 1 : 3; <S2SV_EndVul> if (depth <= 8 && Encryption) img->use ++; if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); if (gray && depth <= 8) { for (color = colors_used - 1; color >= 0; color --) colormap[color][0] = (colormap[color][2] * 31 + colormap[color][1] * 61 + colormap[color][0] * 8) / 100; } color = 0; count = 0; align = 0; byte = 0; temp = 0; for (y = img->height - 1; y >= 0; y --) { ptr = img->pixels + y * img->width * img->depth; switch (depth) { case 1 : for (x = img->width, bit = 128; x > 0; x --) { if (bit == 128) byte = (uchar)getc(fp); if (byte & bit) { if (!gray) { *ptr++ = colormap[1][2]; *ptr++ = colormap[1][1]; } *ptr++ = colormap[1][0]; } else { if (!gray) { *ptr++ = colormap[0][2]; *ptr++ = colormap[0][1]; } *ptr++ = colormap[0][0]; } if (bit > 1) bit >>= 1; else bit = 128; } for (temp = (img->width + 7) / 8; temp & 3; temp ++) getc(fp); break; case 4 : for (x = img->width, bit = 0xf0; x > 0; x --) { if (compression != BI_RLE4 && count == 0) { count = 2; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = ((4 - (count & 3)) / 2) & 1; } } else color = getc(fp); } count --; if (bit == 0xf0) { if (color < 0) <S2SV_StartVul> temp = getc(fp); <S2SV_EndVul> else temp = color; if (!gray) { *ptr++ = colormap[temp >> 4][2]; *ptr++ = colormap[temp >> 4][1]; } *ptr++ = colormap[temp >> 4][0]; bit = 0x0f; } else { if (!gray) { *ptr++ = colormap[temp & 15][2]; *ptr++ = colormap[temp & 15][1]; } *ptr++ = colormap[temp & 15][0]; bit = 0xf0; } } break; case 8 : for (x = img->width; x > 0; x --) { if (compression != BI_RLE8) { count = 1; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = (2 - (count & 1)) & 1; } } else color = getc(fp); } if (color < 0) temp = getc(fp); else temp = color; count --; if (!gray) { *ptr++ = colormap[temp][2]; *ptr++ = colormap[temp][1]; } *ptr++ = colormap[temp][0]; } break; case 24 : if (gray) { for (x = img->width; x > 0; x --) { temp = getc(fp) * 8; temp += getc(fp) * 61; temp += getc(fp) * 31; *ptr++ = (uchar)(temp / 100); } } else { for (x = img->width; x > 0; x --, ptr += 3) { ptr[2] = (uchar)getc(fp); ptr[1] = (uchar)getc(fp); ptr[0] = (uchar)getc(fp); } } for (temp = img->width * 3; temp & 3; temp ++) getc(fp); break; } } return (0); }","- img->depth = gray ? 1 : 3;
- temp = getc(fp);
+ if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192)
+ return (-1);
+ img->depth = gray ? 1 : 3;
+ temp = getc(fp) & 255;","image_load_bmp(image_t *img, FILE *fp, int gray, int load_data) { int info_size, depth, compression, colors_used, x, y, color, count, temp, align; uchar bit, byte; uchar *ptr; uchar colormap[256][4]; getc(fp); getc(fp); read_dword(fp); read_word(fp); read_word(fp); read_dword(fp); info_size = (int)read_dword(fp); img->width = read_long(fp); img->height = read_long(fp); read_word(fp); depth = read_word(fp); compression = (int)read_dword(fp); read_dword(fp); read_long(fp); read_long(fp); colors_used = (int)read_dword(fp); read_dword(fp); if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192) return (-1); if (info_size > 40) for (info_size -= 40; info_size > 0; info_size --) getc(fp); if (colors_used == 0 && depth <= 8) colors_used = 1 << depth; fread(colormap, (size_t)colors_used, 4, fp); img->depth = gray ? 1 : 3; if (depth <= 8 && Encryption) img->use ++; if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); if (gray && depth <= 8) { for (color = colors_used - 1; color >= 0; color --) colormap[color][0] = (colormap[color][2] * 31 + colormap[color][1] * 61 + colormap[color][0] * 8) / 100; } color = 0; count = 0; align = 0; byte = 0; temp = 0; for (y = img->height - 1; y >= 0; y --) { ptr = img->pixels + y * img->width * img->depth; switch (depth) { case 1 : for (x = img->width, bit = 128; x > 0; x --) { if (bit == 128) byte = (uchar)getc(fp); if (byte & bit) { if (!gray) { *ptr++ = colormap[1][2]; *ptr++ = colormap[1][1]; } *ptr++ = colormap[1][0]; } else { if (!gray) { *ptr++ = colormap[0][2]; *ptr++ = colormap[0][1]; } *ptr++ = colormap[0][0]; } if (bit > 1) bit >>= 1; else bit = 128; } for (temp = (img->width + 7) / 8; temp & 3; temp ++) getc(fp); break; case 4 : for (x = img->width, bit = 0xf0; x > 0; x --) { if (compression != BI_RLE4 && count == 0) { count = 2; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = ((4 - (count & 3)) / 2) & 1; } } else color = getc(fp); } count --; if (bit == 0xf0) { if (color < 0) temp = getc(fp) & 255; else temp = color; if (!gray) { *ptr++ = colormap[temp >> 4][2]; *ptr++ = colormap[temp >> 4][1]; } *ptr++ = colormap[temp >> 4][0]; bit = 0x0f; } else { if (!gray) { *ptr++ = colormap[temp & 15][2]; *ptr++ = colormap[temp & 15][1]; } *ptr++ = colormap[temp & 15][0]; bit = 0xf0; } } break; case 8 : for (x = img->width; x > 0; x --) { if (compression != BI_RLE8) { count = 1; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = (2 - (count & 1)) & 1; } } else color = getc(fp); } if (color < 0) temp = getc(fp); else temp = color; count --; if (!gray) { *ptr++ = colormap[temp][2]; *ptr++ = colormap[temp][1]; } *ptr++ = colormap[temp][0]; } break; case 24 : if (gray) { for (x = img->width; x > 0; x --) { temp = getc(fp) * 8; temp += getc(fp) * 61; temp += getc(fp) * 31; *ptr++ = (uchar)(temp / 100); } } else { for (x = img->width; x > 0; x --, ptr += 3) { ptr[2] = (uchar)getc(fp); ptr[1] = (uchar)getc(fp); ptr[0] = (uchar)getc(fp); } } for (temp = img->width * 3; temp & 3; temp ++) getc(fp); break; } } return (0); }"
532,2818----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bin_dyldcache.c----load_buffer,"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) { RDyldCache *cache = R_NEW0 (RDyldCache); memcpy (cache->magic, ""dyldcac"", 7); cache->buf = r_buf_ref (buf); populate_cache_headers (cache); if (!cache->hdr) { r_dyldcache_free (cache); return false; } populate_cache_maps (cache); if (!cache->maps) { r_dyldcache_free (cache); return false; } <S2SV_StartVul> cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps); <S2SV_EndVul> cache->bins = create_cache_bins (bf, cache); if (!cache->bins) { r_dyldcache_free (cache); return false; } cache->locsym = r_dyld_locsym_new (cache); cache->rebase_infos = get_rebase_infos (bf, cache); if (cache->rebase_infos) { if (!rebase_infos_get_slide (cache)) { if (!pending_bin_files) { pending_bin_files = r_list_new (); if (!pending_bin_files) { r_dyldcache_free (cache); return false; } } r_list_push (pending_bin_files, bf); swizzle_io_read (cache, bf->rbin->iob.io); } } *bin_obj = cache; return true; }","- cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);
+ cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);","static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) { RDyldCache *cache = R_NEW0 (RDyldCache); memcpy (cache->magic, ""dyldcac"", 7); cache->buf = r_buf_ref (buf); populate_cache_headers (cache); if (!cache->hdr) { r_dyldcache_free (cache); return false; } populate_cache_maps (cache); if (!cache->maps) { r_dyldcache_free (cache); return false; } cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps); cache->bins = create_cache_bins (bf, cache); if (!cache->bins) { r_dyldcache_free (cache); return false; } cache->locsym = r_dyld_locsym_new (cache); cache->rebase_infos = get_rebase_infos (bf, cache); if (cache->rebase_infos) { if (!rebase_infos_get_slide (cache)) { if (!pending_bin_files) { pending_bin_files = r_list_new (); if (!pending_bin_files) { r_dyldcache_free (cache); return false; } } r_list_push (pending_bin_files, bf); swizzle_io_read (cache, bf->rbin->iob.io); } } *bin_obj = cache; return true; }"
533,4899----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tif_overview.c----TIFF_WriteOverview,"uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize, int nBitsPerPixel, int nPlanarConfig, int nSamples, int nBlockXSize, int nBlockYSize, int bTiled, int nCompressFlag, int nPhotometric, int nSampleFormat, unsigned short *panRed, unsigned short *panGreen, unsigned short *panBlue, int bUseSubIFDs, int nHorSubsampling, int nVerSubsampling ) { toff_t nBaseDirOffset; toff_t nOffset; (void) bUseSubIFDs; nBaseDirOffset = TIFFCurrentDirOffset( hTIFF ); TIFFCreateDirectory( hTIFF ); TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize ); TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize ); if( nSamples == 1 ) TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG ); else TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig ); TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel ); TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples ); TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag ); TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric ); TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat ); if( bTiled ) { TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize ); TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize ); } else TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize ); TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE ); if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB ) { TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling); } if( panRed != NULL ) { TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue ); } if( TIFFWriteCheck( hTIFF, bTiled, ""TIFFBuildOverviews"" ) == 0 ) return 0; TIFFWriteDirectory( hTIFF ); <S2SV_StartVul> TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) ); <S2SV_EndVul> nOffset = TIFFCurrentDirOffset( hTIFF ); TIFFSetSubDirectory( hTIFF, nBaseDirOffset ); return nOffset; }","- TIFFSetDirectory( hTIFF, (tdir_t) (TIFFNumberOfDirectories(hTIFF)-1) );
+ tdir_t iNumDir;
+ iNumDir = TIFFNumberOfDirectories(hTIFF);
+ if( iNumDir > TIFF_DIR_MAX )
+ {
+ TIFFErrorExt( TIFFClientdata(hTIFF),
+ ""TIFF_WriteOverview"",
+ ""File `%s' has too many directories.\n"",
+ TIFFFileName(hTIFF) );
+ exit(-1);
+ }
+ TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) );","uint32 TIFF_WriteOverview( TIFF *hTIFF, uint32 nXSize, uint32 nYSize, int nBitsPerPixel, int nPlanarConfig, int nSamples, int nBlockXSize, int nBlockYSize, int bTiled, int nCompressFlag, int nPhotometric, int nSampleFormat, unsigned short *panRed, unsigned short *panGreen, unsigned short *panBlue, int bUseSubIFDs, int nHorSubsampling, int nVerSubsampling ) { toff_t nBaseDirOffset; toff_t nOffset; tdir_t iNumDir; (void) bUseSubIFDs; nBaseDirOffset = TIFFCurrentDirOffset( hTIFF ); TIFFCreateDirectory( hTIFF ); TIFFSetField( hTIFF, TIFFTAG_IMAGEWIDTH, nXSize ); TIFFSetField( hTIFF, TIFFTAG_IMAGELENGTH, nYSize ); if( nSamples == 1 ) TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG ); else TIFFSetField( hTIFF, TIFFTAG_PLANARCONFIG, nPlanarConfig ); TIFFSetField( hTIFF, TIFFTAG_BITSPERSAMPLE, nBitsPerPixel ); TIFFSetField( hTIFF, TIFFTAG_SAMPLESPERPIXEL, nSamples ); TIFFSetField( hTIFF, TIFFTAG_COMPRESSION, nCompressFlag ); TIFFSetField( hTIFF, TIFFTAG_PHOTOMETRIC, nPhotometric ); TIFFSetField( hTIFF, TIFFTAG_SAMPLEFORMAT, nSampleFormat ); if( bTiled ) { TIFFSetField( hTIFF, TIFFTAG_TILEWIDTH, nBlockXSize ); TIFFSetField( hTIFF, TIFFTAG_TILELENGTH, nBlockYSize ); } else TIFFSetField( hTIFF, TIFFTAG_ROWSPERSTRIP, nBlockYSize ); TIFFSetField( hTIFF, TIFFTAG_SUBFILETYPE, FILETYPE_REDUCEDIMAGE ); if( nPhotometric == PHOTOMETRIC_YCBCR || nPhotometric == PHOTOMETRIC_ITULAB ) { TIFFSetField( hTIFF, TIFFTAG_YCBCRSUBSAMPLING, nHorSubsampling, nVerSubsampling); } if( panRed != NULL ) { TIFFSetField( hTIFF, TIFFTAG_COLORMAP, panRed, panGreen, panBlue ); } if( TIFFWriteCheck( hTIFF, bTiled, ""TIFFBuildOverviews"" ) == 0 ) return 0; TIFFWriteDirectory( hTIFF ); iNumDir = TIFFNumberOfDirectories(hTIFF); if( iNumDir > TIFF_DIR_MAX ) { TIFFErrorExt( TIFFClientdata(hTIFF), ""TIFF_WriteOverview"", ""File `%s' has too many directories.\n"", TIFFFileName(hTIFF) ); exit(-1); } TIFFSetDirectory( hTIFF, (tdir_t) (iNumDir - 1) ); nOffset = TIFFCurrentDirOffset( hTIFF ); TIFFSetSubDirectory( hTIFF, nBaseDirOffset ); return nOffset; }"
534,2905----CWE-434----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ftpd.c----dostor,"void dostor(char *name, const int append, const int autorename) { ULHandler ulhandler; int f; const char *ul_name = NULL; const char *atomic_file = NULL; off_t filesize = (off_t) 0U; struct stat st; double started = 0.0; signed char overwrite = 0; int overflow = 0; int ret = -1; off_t max_filesize = (off_t) -1; #ifdef QUOTAS Quota quota; #endif const char *name2 = NULL; if (type < 1 || (type == 1 && restartat > (off_t) 1)) { addreply_noformat(503, MSG_NO_ASCII_RESUME); goto end; } #ifndef ANON_CAN_RESUME if (guest != 0 && anon_noupload != 0) { addreply_noformat(550, MSG_ANON_CANT_OVERWRITE); goto end; } #endif if (ul_check_free_space(name, -1.0) == 0) { addreply_noformat(552, MSG_NO_DISK_SPACE); goto end; } if (checknamesanity(name, dot_write_ok) != 0) { addreply(553, MSG_SANITY_FILE_FAILURE, name); goto end; } if (autorename != 0) { no_truncate = 1; } if (restartat > (off_t) 0 || no_truncate != 0) { if ((atomic_file = get_atomic_file(name)) == NULL) { addreply(553, MSG_SANITY_FILE_FAILURE, name); goto end; } if (restartat > (off_t) 0 && rename(name, atomic_file) != 0 && errno != ENOENT) { error(553, MSG_RENAME_FAILURE); atomic_file = NULL; goto end; } } if (atomic_file != NULL) { ul_name = atomic_file; } else { ul_name = name; } if (atomic_file == NULL && (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) { overwrite++; } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW, (mode_t) 0777 & ~u_mask)) == -1) { error(553, MSG_OPEN_FAILURE2); goto end; } if (fstat(f, &st) < 0) { (void) close(f); error(553, MSG_STAT_FAILURE2); goto end; } if (!S_ISREG(st.st_mode)) { (void) close(f); addreply_noformat(550, MSG_NOT_REGULAR_FILE); goto end; } alarm(MAX_SESSION_XFER_IDLE); if (st.st_size > (off_t) 0) { #ifndef ANON_CAN_RESUME if (guest != 0) { addreply_noformat(550, MSG_ANON_CANT_OVERWRITE); (void) close(f); goto end; } #endif if (append != 0) { restartat = st.st_size; } } else { restartat = (off_t) 0; } if (restartat > st.st_size) { restartat = st.st_size; } if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) { (void) close(f); error(451, ""seek""); goto end; } if (restartat < st.st_size) { if (ftruncate(f, restartat) < 0) { (void) close(f); error(451, ""ftruncate""); goto end; } #ifdef QUOTAS if (restartat != st.st_size) { (void) quota_update(NULL, 0LL, (long long) (restartat - st.st_size), &overflow); } #endif } #ifdef QUOTAS if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 && (overflow > 0 || quota.files >= user_quota_files || quota.size > user_quota_size || <S2SV_StartVul> (max_filesize >= (off_t) 0 && <S2SV_EndVul> <S2SV_StartVul> (max_filesize = user_quota_size - quota.size) < (off_t) 0))) { <S2SV_EndVul> overflow = 1; (void) close(f); goto afterquota; } #endif opendata(); if (xferfd == -1) { (void) close(f); goto end; } doreply(); # ifdef WITH_TLS if (data_protection_level == CPL_PRIVATE) { tls_init_data_session(xferfd, passive); } # endif state_needs_update = 1; setprocessname(""pure-ftpd (UPLOAD)""); filesize = restartat; #ifdef FTPWHO if (shm_data_cur != NULL) { const size_t sl = strlen(name); ftpwho_lock(); shm_data_cur->state = FTPWHO_STATE_UPLOAD; shm_data_cur->download_total_size = (off_t) 0U; shm_data_cur->download_current_size = (off_t) filesize; shm_data_cur->restartat = restartat; (void) time(&shm_data_cur->xfer_date); if (sl < sizeof shm_data_cur->filename) { memcpy(shm_data_cur->filename, name, sl); shm_data_cur->filename[sl] = 0; } else { memcpy(shm_data_cur->filename, &name[sl - sizeof shm_data_cur->filename - 1U], sizeof shm_data_cur->filename); } ftpwho_unlock(); } #endif started = get_usec_time(); if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx, restartat, type == 1, throttling_bandwidth_ul, max_filesize) == 0) { ret = ul_send(&ulhandler); ul_exit(&ulhandler); } else { ret = -1; } (void) close(f); closedata(); #ifdef SHOW_REAL_DISK_SPACE if (FSTATFS(f, &statfsbuf) == 0) { double space; space = (double) STATFS_BAVAIL(statfsbuf) * (double) STATFS_FRSIZE(statfsbuf); if (space > 524288.0) { addreply(0, MSG_SPACE_FREE_M, space / 1048576.0); } else { addreply(0, MSG_SPACE_FREE_K, space / 1024.0); } } #endif uploaded += (unsigned long long) ulhandler.total_uploaded; { off_t atomic_file_size; off_t original_file_size; int files_count; if (overwrite == 0) { files_count = 1; } else { files_count = 0; } if (autorename != 0 && restartat == (off_t) 0) { if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) { goto afterquota; } if (tryautorename(atomic_file, name, &name2) != 0) { error(553, MSG_RENAME_FAILURE); goto afterquota; } else { #ifdef QUOTAS ul_quota_update(name2 ? name2 : name, 1, atomic_file_size); #endif atomic_file = NULL; } } else if (atomic_file != NULL) { if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) { goto afterquota; } if ((original_file_size = get_file_size(name)) < (off_t) 0 || restartat > original_file_size) { original_file_size = restartat; } if (rename(atomic_file, name) != 0) { error(553, MSG_RENAME_FAILURE); goto afterquota; } else { #ifdef QUOTAS overflow = ul_quota_update (name, files_count, atomic_file_size - original_file_size); #endif atomic_file = NULL; } } else { #ifdef QUOTAS overflow = ul_quota_update (name, files_count, ulhandler.total_uploaded); #endif } } afterquota: if (overflow > 0) { addreply(552, MSG_QUOTA_EXCEEDED, name); } else { if (ret == 0) { addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL); } else { addreply_noformat(451, MSG_ABORTED); } displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started, name2 ? name2 : name, 1); } end: restartat = (off_t) 0; if (atomic_file != NULL) { unlink(atomic_file); atomic_file = NULL; } }","- (max_filesize >= (off_t) 0 &&
- (max_filesize = user_quota_size - quota.size) < (off_t) 0))) {
+ (max_filesize = user_quota_size - quota.size) < (off_t) 0)) {","void dostor(char *name, const int append, const int autorename) { ULHandler ulhandler; int f; const char *ul_name = NULL; const char *atomic_file = NULL; off_t filesize = (off_t) 0U; struct stat st; double started = 0.0; signed char overwrite = 0; int overflow = 0; int ret = -1; off_t max_filesize = (off_t) -1; #ifdef QUOTAS Quota quota; #endif const char *name2 = NULL; if (type < 1 || (type == 1 && restartat > (off_t) 1)) { addreply_noformat(503, MSG_NO_ASCII_RESUME); goto end; } #ifndef ANON_CAN_RESUME if (guest != 0 && anon_noupload != 0) { addreply_noformat(550, MSG_ANON_CANT_OVERWRITE); goto end; } #endif if (ul_check_free_space(name, -1.0) == 0) { addreply_noformat(552, MSG_NO_DISK_SPACE); goto end; } if (checknamesanity(name, dot_write_ok) != 0) { addreply(553, MSG_SANITY_FILE_FAILURE, name); goto end; } if (autorename != 0) { no_truncate = 1; } if (restartat > (off_t) 0 || no_truncate != 0) { if ((atomic_file = get_atomic_file(name)) == NULL) { addreply(553, MSG_SANITY_FILE_FAILURE, name); goto end; } if (restartat > (off_t) 0 && rename(name, atomic_file) != 0 && errno != ENOENT) { error(553, MSG_RENAME_FAILURE); atomic_file = NULL; goto end; } } if (atomic_file != NULL) { ul_name = atomic_file; } else { ul_name = name; } if (atomic_file == NULL && (f = open(ul_name, O_WRONLY | O_NOFOLLOW)) != -1) { overwrite++; } else if ((f = open(ul_name, O_CREAT | O_WRONLY | O_NOFOLLOW, (mode_t) 0777 & ~u_mask)) == -1) { error(553, MSG_OPEN_FAILURE2); goto end; } if (fstat(f, &st) < 0) { (void) close(f); error(553, MSG_STAT_FAILURE2); goto end; } if (!S_ISREG(st.st_mode)) { (void) close(f); addreply_noformat(550, MSG_NOT_REGULAR_FILE); goto end; } alarm(MAX_SESSION_XFER_IDLE); if (st.st_size > (off_t) 0) { #ifndef ANON_CAN_RESUME if (guest != 0) { addreply_noformat(550, MSG_ANON_CANT_OVERWRITE); (void) close(f); goto end; } #endif if (append != 0) { restartat = st.st_size; } } else { restartat = (off_t) 0; } if (restartat > st.st_size) { restartat = st.st_size; } if (restartat > (off_t) 0 && lseek(f, restartat, SEEK_SET) < (off_t) 0) { (void) close(f); error(451, ""seek""); goto end; } if (restartat < st.st_size) { if (ftruncate(f, restartat) < 0) { (void) close(f); error(451, ""ftruncate""); goto end; } #ifdef QUOTAS if (restartat != st.st_size) { (void) quota_update(NULL, 0LL, (long long) (restartat - st.st_size), &overflow); } #endif } #ifdef QUOTAS if (quota_update(&quota, 0LL, 0LL, &overflow) == 0 && (overflow > 0 || quota.files >= user_quota_files || quota.size > user_quota_size || (max_filesize = user_quota_size - quota.size) < (off_t) 0)) { overflow = 1; (void) close(f); goto afterquota; } #endif opendata(); if (xferfd == -1) { (void) close(f); goto end; } doreply(); # ifdef WITH_TLS if (data_protection_level == CPL_PRIVATE) { tls_init_data_session(xferfd, passive); } # endif state_needs_update = 1; setprocessname(""pure-ftpd (UPLOAD)""); filesize = restartat; #ifdef FTPWHO if (shm_data_cur != NULL) { const size_t sl = strlen(name); ftpwho_lock(); shm_data_cur->state = FTPWHO_STATE_UPLOAD; shm_data_cur->download_total_size = (off_t) 0U; shm_data_cur->download_current_size = (off_t) filesize; shm_data_cur->restartat = restartat; (void) time(&shm_data_cur->xfer_date); if (sl < sizeof shm_data_cur->filename) { memcpy(shm_data_cur->filename, name, sl); shm_data_cur->filename[sl] = 0; } else { memcpy(shm_data_cur->filename, &name[sl - sizeof shm_data_cur->filename - 1U], sizeof shm_data_cur->filename); } ftpwho_unlock(); } #endif started = get_usec_time(); if (ul_init(&ulhandler, clientfd, tls_cnx, xferfd, name, f, tls_data_cnx, restartat, type == 1, throttling_bandwidth_ul, max_filesize) == 0) { ret = ul_send(&ulhandler); ul_exit(&ulhandler); } else { ret = -1; } (void) close(f); closedata(); #ifdef SHOW_REAL_DISK_SPACE if (FSTATFS(f, &statfsbuf) == 0) { double space; space = (double) STATFS_BAVAIL(statfsbuf) * (double) STATFS_FRSIZE(statfsbuf); if (space > 524288.0) { addreply(0, MSG_SPACE_FREE_M, space / 1048576.0); } else { addreply(0, MSG_SPACE_FREE_K, space / 1024.0); } } #endif uploaded += (unsigned long long) ulhandler.total_uploaded; { off_t atomic_file_size; off_t original_file_size; int files_count; if (overwrite == 0) { files_count = 1; } else { files_count = 0; } if (autorename != 0 && restartat == (off_t) 0) { if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) { goto afterquota; } if (tryautorename(atomic_file, name, &name2) != 0) { error(553, MSG_RENAME_FAILURE); goto afterquota; } else { #ifdef QUOTAS ul_quota_update(name2 ? name2 : name, 1, atomic_file_size); #endif atomic_file = NULL; } } else if (atomic_file != NULL) { if ((atomic_file_size = get_file_size(atomic_file)) < (off_t) 0) { goto afterquota; } if ((original_file_size = get_file_size(name)) < (off_t) 0 || restartat > original_file_size) { original_file_size = restartat; } if (rename(atomic_file, name) != 0) { error(553, MSG_RENAME_FAILURE); goto afterquota; } else { #ifdef QUOTAS overflow = ul_quota_update (name, files_count, atomic_file_size - original_file_size); #endif atomic_file = NULL; } } else { #ifdef QUOTAS overflow = ul_quota_update (name, files_count, ulhandler.total_uploaded); #endif } } afterquota: if (overflow > 0) { addreply(552, MSG_QUOTA_EXCEEDED, name); } else { if (ret == 0) { addreply_noformat(226, MSG_TRANSFER_SUCCESSFUL); } else { addreply_noformat(451, MSG_ABORTED); } displayrate(MSG_UPLOADED, ulhandler.total_uploaded, started, name2 ? name2 : name, 1); } end: restartat = (off_t) 0; if (atomic_file != NULL) { unlink(atomic_file); atomic_file = NULL; } }"
535,4898----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inode.c----dev_config,"dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr) { struct dev_data *dev = fd->private_data; ssize_t value, length = len; unsigned total; u32 tag; char *kbuf; spin_lock_irq(&dev->lock); if (dev->state > STATE_DEV_OPENED) { value = ep0_write(fd, buf, len, ptr); spin_unlock_irq(&dev->lock); return value; } spin_unlock_irq(&dev->lock); if ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) || (len > PAGE_SIZE * 4)) return -EINVAL; if (copy_from_user (&tag, buf, 4)) return -EFAULT; if (tag != 0) return -EINVAL; buf += 4; length -= 4; kbuf = memdup_user(buf, length); if (IS_ERR(kbuf)) return PTR_ERR(kbuf); spin_lock_irq (&dev->lock); value = -EINVAL; if (dev->buf) { spin_unlock_irq(&dev->lock); kfree(kbuf); return value; } dev->buf = kbuf; dev->config = (void *) kbuf; total = le16_to_cpu(dev->config->wTotalLength); if (!is_valid_config(dev->config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; if (kbuf [1] == USB_DT_CONFIG) { dev->hs_config = (void *) kbuf; total = le16_to_cpu(dev->hs_config->wTotalLength); if (!is_valid_config(dev->hs_config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; } else { dev->hs_config = NULL; } if (length != USB_DT_DEVICE_SIZE) goto fail; dev->dev = (void *)kbuf; if (dev->dev->bLength != USB_DT_DEVICE_SIZE || dev->dev->bDescriptorType != USB_DT_DEVICE || dev->dev->bNumConfigurations != 1) goto fail; dev->dev->bcdUSB = cpu_to_le16 (0x0200); spin_unlock_irq (&dev->lock); if (dev->hs_config) gadgetfs_driver.max_speed = USB_SPEED_HIGH; else gadgetfs_driver.max_speed = USB_SPEED_FULL; value = usb_gadget_probe_driver(&gadgetfs_driver); if (value != 0) { <S2SV_StartVul> kfree (dev->buf); <S2SV_EndVul> <S2SV_StartVul> dev->buf = NULL; <S2SV_EndVul> } else { value = len; dev->gadget_registered = true; } return value; fail: spin_unlock_irq (&dev->lock); pr_debug (""%s: %s fail %zd, %p\n"", shortname, __func__, value, dev); kfree (dev->buf); dev->buf = NULL; return value; }","- kfree (dev->buf);
- dev->buf = NULL;
+ spin_lock_irq(&dev->lock);
+ goto fail;
+ dev->config = NULL;
+ dev->hs_config = NULL;
+ dev->dev = NULL;","dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr) { struct dev_data *dev = fd->private_data; ssize_t value, length = len; unsigned total; u32 tag; char *kbuf; spin_lock_irq(&dev->lock); if (dev->state > STATE_DEV_OPENED) { value = ep0_write(fd, buf, len, ptr); spin_unlock_irq(&dev->lock); return value; } spin_unlock_irq(&dev->lock); if ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) || (len > PAGE_SIZE * 4)) return -EINVAL; if (copy_from_user (&tag, buf, 4)) return -EFAULT; if (tag != 0) return -EINVAL; buf += 4; length -= 4; kbuf = memdup_user(buf, length); if (IS_ERR(kbuf)) return PTR_ERR(kbuf); spin_lock_irq (&dev->lock); value = -EINVAL; if (dev->buf) { spin_unlock_irq(&dev->lock); kfree(kbuf); return value; } dev->buf = kbuf; dev->config = (void *) kbuf; total = le16_to_cpu(dev->config->wTotalLength); if (!is_valid_config(dev->config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; if (kbuf [1] == USB_DT_CONFIG) { dev->hs_config = (void *) kbuf; total = le16_to_cpu(dev->hs_config->wTotalLength); if (!is_valid_config(dev->hs_config, total) || total > length - USB_DT_DEVICE_SIZE) goto fail; kbuf += total; length -= total; } else { dev->hs_config = NULL; } if (length != USB_DT_DEVICE_SIZE) goto fail; dev->dev = (void *)kbuf; if (dev->dev->bLength != USB_DT_DEVICE_SIZE || dev->dev->bDescriptorType != USB_DT_DEVICE || dev->dev->bNumConfigurations != 1) goto fail; dev->dev->bcdUSB = cpu_to_le16 (0x0200); spin_unlock_irq (&dev->lock); if (dev->hs_config) gadgetfs_driver.max_speed = USB_SPEED_HIGH; else gadgetfs_driver.max_speed = USB_SPEED_FULL; value = usb_gadget_probe_driver(&gadgetfs_driver); if (value != 0) { spin_lock_irq(&dev->lock); goto fail; } else { value = len; dev->gadget_registered = true; } return value; fail: dev->config = NULL; dev->hs_config = NULL; dev->dev = NULL; spin_unlock_irq (&dev->lock); pr_debug (""%s: %s fail %zd, %p\n"", shortname, __func__, value, dev); kfree (dev->buf); dev->buf = NULL; return value; }"
536,3115----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sem.c----find_alloc_undo,"static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid) { struct sem_array *sma; struct sem_undo_list *ulp; struct sem_undo *un, *new; <S2SV_StartVul> int nsems; <S2SV_EndVul> <S2SV_StartVul> int error; <S2SV_EndVul> error = get_undo_list(&ulp); if (error) return ERR_PTR(error); rcu_read_lock(); spin_lock(&ulp->lock); un = lookup_undo(ulp, semid); spin_unlock(&ulp->lock); if (likely(un!=NULL)) goto out; sma = sem_obtain_object_check(ns, semid); if (IS_ERR(sma)) { rcu_read_unlock(); return ERR_CAST(sma); } nsems = sma->sem_nsems; <S2SV_StartVul> ipc_rcu_getref(sma); <S2SV_EndVul> rcu_read_unlock(); new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL); if (!new) { sem_putref(sma); return ERR_PTR(-ENOMEM); } sem_lock_and_putref(sma); if (sma->sem_perm.deleted) { <S2SV_StartVul> sem_unlock(sma); <S2SV_EndVul> kfree(new); un = ERR_PTR(-EIDRM); goto out; } spin_lock(&ulp->lock); un = lookup_undo(ulp, semid); if (un) { kfree(new); goto success; } new->semadj = (short *) &new[1]; new->ulp = ulp; new->semid = semid; assert_spin_locked(&ulp->lock); list_add_rcu(&new->list_proc, &ulp->list_proc); assert_spin_locked(&sma->sem_perm.lock); list_add(&new->list_id, &sma->list_id); un = new; success: spin_unlock(&ulp->lock); rcu_read_lock(); <S2SV_StartVul> sem_unlock(sma); <S2SV_EndVul> out: return un; }","- int nsems;
- int error;
- ipc_rcu_getref(sma);
- sem_unlock(sma);
- sem_unlock(sma);
+ int nsems, error;
+ if (!ipc_rcu_getref(sma)) {
+ rcu_read_unlock();
+ un = ERR_PTR(-EIDRM);
+ goto out;
+ }
+ sem_unlock(sma, -1);
+ sem_unlock(sma, -1);","static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid) { struct sem_array *sma; struct sem_undo_list *ulp; struct sem_undo *un, *new; int nsems, error; error = get_undo_list(&ulp); if (error) return ERR_PTR(error); rcu_read_lock(); spin_lock(&ulp->lock); un = lookup_undo(ulp, semid); spin_unlock(&ulp->lock); if (likely(un!=NULL)) goto out; sma = sem_obtain_object_check(ns, semid); if (IS_ERR(sma)) { rcu_read_unlock(); return ERR_CAST(sma); } nsems = sma->sem_nsems; if (!ipc_rcu_getref(sma)) { rcu_read_unlock(); un = ERR_PTR(-EIDRM); goto out; } rcu_read_unlock(); new = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL); if (!new) { sem_putref(sma); return ERR_PTR(-ENOMEM); } sem_lock_and_putref(sma); if (sma->sem_perm.deleted) { sem_unlock(sma, -1); kfree(new); un = ERR_PTR(-EIDRM); goto out; } spin_lock(&ulp->lock); un = lookup_undo(ulp, semid); if (un) { kfree(new); goto success; } new->semadj = (short *) &new[1]; new->ulp = ulp; new->semid = semid; assert_spin_locked(&ulp->lock); list_add_rcu(&new->list_proc, &ulp->list_proc); assert_spin_locked(&sma->sem_perm.lock); list_add(&new->list_id, &sma->list_id); un = new; success: spin_unlock(&ulp->lock); rcu_read_lock(); sem_unlock(sma, -1); out: return un; }"
537,6171----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/OutStream.h----rdr::OutStream::copyBytes,"<S2SV_StartVul> void copyBytes(InStream* is, int length) { <S2SV_EndVul> while (length > 0) { <S2SV_StartVul> int n = check(1, length); <S2SV_EndVul> is->readBytes(ptr, n); ptr += n; length -= n; } }","- void copyBytes(InStream* is, int length) {
- int n = check(1, length);
+ void copyBytes(InStream* is, size_t length) {
+ size_t n = check(1, length);","void copyBytes(InStream* is, size_t length) { while (length > 0) { size_t n = check(1, length); is->readBytes(ptr, n); ptr += n; length -= n; } }"
538,5099----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/wasm.cc----Envoy::Extensions::Common::Wasm::Context::onResponseTrailers,"Http::FilterTrailersStatus Context::onResponseTrailers() { <S2SV_StartVul> if (!wasm_->onResponseTrailers_) { <S2SV_EndVul> return Http::FilterTrailersStatus::Continue; } if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) { return Http::FilterTrailersStatus::Continue; } return Http::FilterTrailersStatus::StopIteration; }","- if (!wasm_->onResponseTrailers_) {
+ if (!in_vm_context_created_ || !wasm_->onResponseTrailers_) {","Http::FilterTrailersStatus Context::onResponseTrailers() { if (!in_vm_context_created_ || !wasm_->onResponseTrailers_) { return Http::FilterTrailersStatus::Continue; } if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) { return Http::FilterTrailersStatus::Continue; } return Http::FilterTrailersStatus::StopIteration; }"
539,2657----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/scene_dump.c----gf_dump_vrml_simple_field,"static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent) { u32 i, sf_type; GF_ChildNodeItem *list; void *slot_ptr; switch (field.fieldType) { case GF_SG_VRML_SFNODE: gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); return; case GF_SG_VRML_MFNODE: list = * ((GF_ChildNodeItem **) field.far_ptr); assert( list ); sdump->indent++; while (list) { gf_dump_vrml_node(sdump, list->node, 1, NULL); list = list->next; } sdump->indent--; return; case GF_SG_VRML_SFCOMMANDBUFFER: return; } if (gf_sg_vrml_is_sf_field(field.fieldType)) { if (sdump->XMLDump) StartAttribute(sdump, ""value""); gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent); if (sdump->XMLDump) EndAttribute(sdump); } else { GenMFField *mffield; mffield = (GenMFField *) field.far_ptr; sf_type = gf_sg_vrml_get_sf_type(field.fieldType); if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""[""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, "" value=\'""); } else { StartAttribute(sdump, ""value""); } <S2SV_StartVul> for (i=0; i<mffield->count; i++) { <S2SV_EndVul> if (i) gf_fprintf(sdump->trace, "" ""); gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent); } if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""]""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, ""\'""); } else { EndAttribute(sdump); } } }","- for (i=0; i<mffield->count; i++) {
+ for (i=0; mffield && (i<mffield->count); i++) {","static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent) { u32 i, sf_type; GF_ChildNodeItem *list; void *slot_ptr; switch (field.fieldType) { case GF_SG_VRML_SFNODE: gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); return; case GF_SG_VRML_MFNODE: list = * ((GF_ChildNodeItem **) field.far_ptr); assert( list ); sdump->indent++; while (list) { gf_dump_vrml_node(sdump, list->node, 1, NULL); list = list->next; } sdump->indent--; return; case GF_SG_VRML_SFCOMMANDBUFFER: return; } if (gf_sg_vrml_is_sf_field(field.fieldType)) { if (sdump->XMLDump) StartAttribute(sdump, ""value""); gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent); if (sdump->XMLDump) EndAttribute(sdump); } else { GenMFField *mffield; mffield = (GenMFField *) field.far_ptr; sf_type = gf_sg_vrml_get_sf_type(field.fieldType); if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""[""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, "" value=\'""); } else { StartAttribute(sdump, ""value""); } for (i=0; mffield && (i<mffield->count); i++) { if (i) gf_fprintf(sdump->trace, "" ""); gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent); } if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""]""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, ""\'""); } else { EndAttribute(sdump); } } }"
540,6365----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/orders.c----update_write_brush,"static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags) { if (fieldFlags & ORDER_FIELD_01) { Stream_Write_UINT8(s, brush->x); } if (fieldFlags & ORDER_FIELD_02) { Stream_Write_UINT8(s, brush->y); } if (fieldFlags & ORDER_FIELD_03) { Stream_Write_UINT8(s, brush->style); } if (brush->style & CACHED_BRUSH) { brush->hatch = brush->index; <S2SV_StartVul> brush->bpp = BMF_BPP[brush->style & 0x07]; <S2SV_EndVul> if (brush->bpp == 0) brush->bpp = 1; } if (fieldFlags & ORDER_FIELD_04) { Stream_Write_UINT8(s, brush->hatch); } if (fieldFlags & ORDER_FIELD_05) { brush->data = (BYTE*)brush->p8x8; Stream_Write_UINT8(s, brush->data[7]); Stream_Write_UINT8(s, brush->data[6]); Stream_Write_UINT8(s, brush->data[5]); Stream_Write_UINT8(s, brush->data[4]); Stream_Write_UINT8(s, brush->data[3]); Stream_Write_UINT8(s, brush->data[2]); Stream_Write_UINT8(s, brush->data[1]); brush->data[0] = brush->hatch; } return TRUE; }","- brush->bpp = BMF_BPP[brush->style & 0x07];
+ BOOL rc;
+ brush->bpp = get_bmf_bpp(brush->style, &rc);
+ if (!rc)
+ return FALSE;","static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags) { if (fieldFlags & ORDER_FIELD_01) { Stream_Write_UINT8(s, brush->x); } if (fieldFlags & ORDER_FIELD_02) { Stream_Write_UINT8(s, brush->y); } if (fieldFlags & ORDER_FIELD_03) { Stream_Write_UINT8(s, brush->style); } if (brush->style & CACHED_BRUSH) { BOOL rc; brush->hatch = brush->index; brush->bpp = get_bmf_bpp(brush->style, &rc); if (!rc) return FALSE; if (brush->bpp == 0) brush->bpp = 1; } if (fieldFlags & ORDER_FIELD_04) { Stream_Write_UINT8(s, brush->hatch); } if (fieldFlags & ORDER_FIELD_05) { brush->data = (BYTE*)brush->p8x8; Stream_Write_UINT8(s, brush->data[7]); Stream_Write_UINT8(s, brush->data[6]); Stream_Write_UINT8(s, brush->data[5]); Stream_Write_UINT8(s, brush->data[4]); Stream_Write_UINT8(s, brush->data[3]); Stream_Write_UINT8(s, brush->data[2]); Stream_Write_UINT8(s, brush->data[1]); brush->data[0] = brush->hatch; } return TRUE; }"
541,4662----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dcraw.c----panasonic_load_raw,"void CLASS panasonic_load_raw() { int row, col, i, j, sh = 0, pred[2], nonz[2]; pana_bits(0); <S2SV_StartVul> for (row = 0; row < height; row++) <S2SV_EndVul> { #ifdef LIBRAW_LIBRARY_BUILD checkCancel(); #endif for (col = 0; col < raw_width; col++) { if ((i = col % 14) == 0) pred[0] = pred[1] = nonz[0] = nonz[1] = 0; if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2)); if (nonz[i & 1]) { if ((j = pana_bits(8))) { if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4) pred[i & 1] &= ~((~0u) << sh); pred[i & 1] += j << sh; } } else if ((nonz[i & 1] = pana_bits(8)) || i > 11) pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4); <S2SV_StartVul> if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width) <S2SV_EndVul> derror(); } } }","- for (row = 0; row < height; row++)
- if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)
+ for (row = 0; row < raw_height; row++)
+ if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height)","void CLASS panasonic_load_raw() { int row, col, i, j, sh = 0, pred[2], nonz[2]; pana_bits(0); for (row = 0; row < raw_height; row++) { #ifdef LIBRAW_LIBRARY_BUILD checkCancel(); #endif for (col = 0; col < raw_width; col++) { if ((i = col % 14) == 0) pred[0] = pred[1] = nonz[0] = nonz[1] = 0; if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2)); if (nonz[i & 1]) { if ((j = pana_bits(8))) { if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4) pred[i & 1] &= ~((~0u) << sh); pred[i & 1] += j << sh; } } else if ((nonz[i & 1] = pana_bits(8)) || i > 11) pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4); if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width && row < height) derror(); } } }"
542,6662----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/IRCNetwork.cpp----CIRCNetwork::SetEncoding,void CIRCNetwork::SetEncoding(const CString& s) { <S2SV_StartVul> m_sEncoding = s; <S2SV_EndVul> if (GetIRCSock()) { <S2SV_StartVul> GetIRCSock()->SetEncoding(s); <S2SV_EndVul> } },"- m_sEncoding = s;
- GetIRCSock()->SetEncoding(s);
+ m_sEncoding = CZNC::Get().FixupEncoding(s);
+ GetIRCSock()->SetEncoding(m_sEncoding);",void CIRCNetwork::SetEncoding(const CString& s) { m_sEncoding = CZNC::Get().FixupEncoding(s); if (GetIRCSock()) { GetIRCSock()->SetEncoding(m_sEncoding); } }
543,6280----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/httpLib.c----httpSetIntParam,"PUBLIC void httpSetIntParam(HttpConn *conn, cchar *var, int value) { <S2SV_StartVul> mprSetJson(httpGetParams(conn), var, sfmt(""%d"", value)); <S2SV_EndVul> }","- mprSetJson(httpGetParams(conn), var, sfmt(""%d"", value));
+ mprWriteJson(httpGetParams(conn), var, sfmt(""%d"", value));","PUBLIC void httpSetIntParam(HttpConn *conn, cchar *var, int value) { mprWriteJson(httpGetParams(conn), var, sfmt(""%d"", value)); }"
544,5724----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fair.c----assign_cfs_rq_runtime,"static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq) { struct task_group *tg = cfs_rq->tg; struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg); <S2SV_StartVul> u64 amount = 0, min_amount, expires; <S2SV_EndVul> <S2SV_StartVul> int expires_seq; <S2SV_EndVul> min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining; raw_spin_lock(&cfs_b->lock); if (cfs_b->quota == RUNTIME_INF) amount = min_amount; else { start_cfs_bandwidth(cfs_b); if (cfs_b->runtime > 0) { amount = min(cfs_b->runtime, min_amount); cfs_b->runtime -= amount; cfs_b->idle = 0; } } <S2SV_StartVul> expires_seq = cfs_b->expires_seq; <S2SV_EndVul> <S2SV_StartVul> expires = cfs_b->runtime_expires; <S2SV_EndVul> raw_spin_unlock(&cfs_b->lock); cfs_rq->runtime_remaining += amount; <S2SV_EndVul> <S2SV_StartVul> if (cfs_rq->expires_seq != expires_seq) { <S2SV_EndVul> <S2SV_StartVul> cfs_rq->expires_seq = expires_seq; <S2SV_EndVul> <S2SV_StartVul> cfs_rq->runtime_expires = expires; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> return cfs_rq->runtime_remaining > 0; }","- u64 amount = 0, min_amount, expires;
- int expires_seq;
- expires_seq = cfs_b->expires_seq;
- expires = cfs_b->runtime_expires;
- if (cfs_rq->expires_seq != expires_seq) {
- cfs_rq->expires_seq = expires_seq;
- cfs_rq->runtime_expires = expires;
- }
+ u64 amount = 0, min_amount;","static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq) { struct task_group *tg = cfs_rq->tg; struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg); u64 amount = 0, min_amount; min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining; raw_spin_lock(&cfs_b->lock); if (cfs_b->quota == RUNTIME_INF) amount = min_amount; else { start_cfs_bandwidth(cfs_b); if (cfs_b->runtime > 0) { amount = min(cfs_b->runtime, min_amount); cfs_b->runtime -= amount; cfs_b->idle = 0; } } raw_spin_unlock(&cfs_b->lock); cfs_rq->runtime_remaining += amount; return cfs_rq->runtime_remaining > 0; }"
545,1550----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-8062--dw2102.c----m88rs2000_frontend_attach,"<S2SV_StartVul> static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d) <S2SV_EndVul> { <S2SV_StartVul> u8 obuf[] = { 0x51 }; <S2SV_EndVul> <S2SV_StartVul> u8 ibuf[] = { 0 }; <S2SV_EndVul> <S2SV_StartVul> if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0) <S2SV_EndVul> err(""command 0x51 transfer failed.""); <S2SV_StartVul> d->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config, <S2SV_EndVul> <S2SV_StartVul> &d->dev->i2c_adap); <S2SV_EndVul> <S2SV_StartVul> if (d->fe_adap[0].fe == NULL) <S2SV_EndVul> return -EIO; <S2SV_StartVul> if (dvb_attach(ts2020_attach, d->fe_adap[0].fe, <S2SV_EndVul> &dw2104_ts2020_config, <S2SV_StartVul> &d->dev->i2c_adap)) { <S2SV_EndVul> info(""Attached RS2000/TS2020!""); return 0; } info(""Failed to attach RS2000/TS2020!""); return -EIO; }","- static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)
- u8 obuf[] = { 0x51 };
- u8 ibuf[] = { 0 };
- if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)
- d->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,
- &d->dev->i2c_adap);
- if (d->fe_adap[0].fe == NULL)
- if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
- &d->dev->i2c_adap)) {
+ static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)
+ {
+ struct dvb_usb_device *d = adap->dev;
+ 
+ 
+ 
+ 
+ 
+ adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
+ &s421_m88rs2000_config,
+ 
+ 
+ &dw2104_ts2020_config,","static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d) static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap) { struct dvb_usb_device *d = adap->dev; struct dw2102_state *state = d->priv; mutex_lock(&d->data_mutex); state->data[0] = 0x51; if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0) err(""command 0x51 transfer failed.""); mutex_unlock(&d->data_mutex); adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config, &d->i2c_adap); if (adap->fe_adap[0].fe == NULL) return -EIO; if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe, &dw2104_ts2020_config, &d->i2c_adap)) { info(""Attached RS2000/TS2020!""); return 0; } info(""Failed to attach RS2000/TS2020!""); return -EIO; }"
546,828----CWE-18----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-2696--gssapi_krb5.c----gss_iakerbmechglue_init,"static int gss_iakerbmechglue_init(void) { struct gss_mech_config mech_iakerb; <S2SV_StartVul> struct gss_config iakerb_mechanism = krb5_mechanism; <S2SV_EndVul> iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context; <S2SV_StartVul> iakerb_mechanism.gss_init_sec_context = iakerb_gss_init_sec_context; <S2SV_EndVul> <S2SV_StartVul> iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context; <S2SV_EndVul> <S2SV_StartVul> iakerb_mechanism.gss_acquire_cred = iakerb_gss_acquire_cred; <S2SV_EndVul> <S2SV_StartVul> iakerb_mechanism.gssspi_acquire_cred_with_password <S2SV_EndVul> <S2SV_StartVul> = iakerb_gss_acquire_cred_with_password; <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> memset(&mech_iakerb, 0, sizeof(mech_iakerb)); mech_iakerb.mech = &iakerb_mechanism; mech_iakerb.mechNameStr = ""iakerb""; mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb; gssint_register_mechinfo(&mech_iakerb); return 0; }","- struct gss_config iakerb_mechanism = krb5_mechanism;
- iakerb_mechanism.gss_init_sec_context = iakerb_gss_init_sec_context;
- iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;
- iakerb_mechanism.gss_acquire_cred = iakerb_gss_acquire_cred;
- iakerb_mechanism.gssspi_acquire_cred_with_password
- = iakerb_gss_acquire_cred_with_password;
- ","static int gss_iakerbmechglue_init(void) { struct gss_mech_config mech_iakerb; memset(&mech_iakerb, 0, sizeof(mech_iakerb)); mech_iakerb.mech = &iakerb_mechanism; mech_iakerb.mechNameStr = ""iakerb""; mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb; gssint_register_mechinfo(&mech_iakerb); return 0; }"
547,5282----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/context.cc----Envoy::Extensions::Filters::Common::Expr::RequestWrapper::operator [ ],"absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const { if (!key.IsString()) { return {}; } auto value = key.StringOrDie().value(); if (value == Headers) { return CelValue::CreateMap(&headers_); } else if (value == Time) { return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime())); } else if (value == Size) { if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) { int64_t length; if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) { return CelValue::CreateInt64(length); } } else { return CelValue::CreateInt64(info_.bytesReceived()); } } else if (value == Duration) { auto duration = info_.requestComplete(); if (duration.has_value()) { return CelValue::CreateDuration(absl::FromChrono(duration.value())); } } if (headers_.value_ != nullptr) { if (value == Path) { return convertHeaderEntry(headers_.value_->Path()); } else if (value == UrlPath) { absl::string_view path = headers_.value_->Path()->value().getStringView(); size_t query_offset = path.find('?'); if (query_offset == absl::string_view::npos) { return CelValue::CreateString(path); } return CelValue::CreateString(path.substr(0, query_offset)); } else if (value == Host) { return convertHeaderEntry(headers_.value_->Host()); } else if (value == Scheme) { return convertHeaderEntry(headers_.value_->Scheme()); } else if (value == Method) { return convertHeaderEntry(headers_.value_->Method()); } else if (value == Referer) { return convertHeaderEntry(headers_.value_->Referer()); } else if (value == ID) { return convertHeaderEntry(headers_.value_->RequestId()); } else if (value == UserAgent) { return convertHeaderEntry(headers_.value_->UserAgent()); } else if (value == TotalSize) { <S2SV_StartVul> return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize()); <S2SV_EndVul> } } return {}; }","- return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());
+ return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value());","absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const { if (!key.IsString()) { return {}; } auto value = key.StringOrDie().value(); if (value == Headers) { return CelValue::CreateMap(&headers_); } else if (value == Time) { return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime())); } else if (value == Size) { if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) { int64_t length; if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) { return CelValue::CreateInt64(length); } } else { return CelValue::CreateInt64(info_.bytesReceived()); } } else if (value == Duration) { auto duration = info_.requestComplete(); if (duration.has_value()) { return CelValue::CreateDuration(absl::FromChrono(duration.value())); } } if (headers_.value_ != nullptr) { if (value == Path) { return convertHeaderEntry(headers_.value_->Path()); } else if (value == UrlPath) { absl::string_view path = headers_.value_->Path()->value().getStringView(); size_t query_offset = path.find('?'); if (query_offset == absl::string_view::npos) { return CelValue::CreateString(path); } return CelValue::CreateString(path.substr(0, query_offset)); } else if (value == Host) { return convertHeaderEntry(headers_.value_->Host()); } else if (value == Scheme) { return convertHeaderEntry(headers_.value_->Scheme()); } else if (value == Method) { return convertHeaderEntry(headers_.value_->Method()); } else if (value == Referer) { return convertHeaderEntry(headers_.value_->Referer()); } else if (value == ID) { return convertHeaderEntry(headers_.value_->RequestId()); } else if (value == UserAgent) { return convertHeaderEntry(headers_.value_->UserAgent()); } else if (value == TotalSize) { return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize().value()); } } return {}; }"
548,6946----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/guest.c----set_core_reg,"static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg) { __u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr; struct kvm_regs *regs = vcpu_gp_regs(vcpu); int nr_regs = sizeof(*regs) / sizeof(__u32); __uint128_t tmp; void *valp = &tmp; u64 off; int err = 0; off = core_reg_offset_from_id(reg->id); if (off >= nr_regs || (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs) return -ENOENT; if (validate_core_offset(reg)) return -EINVAL; if (KVM_REG_SIZE(reg->id) > sizeof(tmp)) return -EINVAL; if (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) { err = -EFAULT; goto out; } if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) { <S2SV_StartVul> u32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK; <S2SV_EndVul> switch (mode) { case PSR_AA32_MODE_USR: case PSR_AA32_MODE_FIQ: case PSR_AA32_MODE_IRQ: case PSR_AA32_MODE_SVC: case PSR_AA32_MODE_ABT: case PSR_AA32_MODE_UND: case PSR_MODE_EL0t: case PSR_MODE_EL1t: case PSR_MODE_EL1h: break; default: err = -EINVAL; goto out; } } memcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id)); out: return err; }","- u32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;
+ u64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;
+ if (!system_supports_32bit_el0())
+ return -EINVAL;
+ break;
+ if (!vcpu_el1_is_32bit(vcpu))
+ return -EINVAL;
+ break;
+ if (vcpu_el1_is_32bit(vcpu))
+ return -EINVAL;","static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg) { __u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr; struct kvm_regs *regs = vcpu_gp_regs(vcpu); int nr_regs = sizeof(*regs) / sizeof(__u32); __uint128_t tmp; void *valp = &tmp; u64 off; int err = 0; off = core_reg_offset_from_id(reg->id); if (off >= nr_regs || (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs) return -ENOENT; if (validate_core_offset(reg)) return -EINVAL; if (KVM_REG_SIZE(reg->id) > sizeof(tmp)) return -EINVAL; if (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) { err = -EFAULT; goto out; } if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) { u64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK; switch (mode) { case PSR_AA32_MODE_USR: if (!system_supports_32bit_el0()) return -EINVAL; break; case PSR_AA32_MODE_FIQ: case PSR_AA32_MODE_IRQ: case PSR_AA32_MODE_SVC: case PSR_AA32_MODE_ABT: case PSR_AA32_MODE_UND: if (!vcpu_el1_is_32bit(vcpu)) return -EINVAL; break; case PSR_MODE_EL0t: case PSR_MODE_EL1t: case PSR_MODE_EL1h: if (vcpu_el1_is_32bit(vcpu)) return -EINVAL; break; default: err = -EINVAL; goto out; } } memcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id)); out: return err; }"
549,2672----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/resource_handle.cc----tensorflow::DecodeResourceHandleList,"bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d, ResourceHandle* ps, int64_t n) { std::vector<uint32> sizes(n); if (!d->ReadSizes(&sizes)) return false; ResourceHandleProto proto; for (int i = 0; i < n; ++i) { if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) { return false; } <S2SV_StartVul> ps[i].FromProto(proto); <S2SV_EndVul> } return true; }","- ps[i].FromProto(proto);
+ if (!ps[i].FromProto(proto).ok()) {
+ return false;
+ }","bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d, ResourceHandle* ps, int64_t n) { std::vector<uint32> sizes(n); if (!d->ReadSizes(&sizes)) return false; ResourceHandleProto proto; for (int i = 0; i < n; ++i) { if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) { return false; } if (!ps[i].FromProto(proto).ok()) { return false; } } return true; }"
550,5300----CWE-668----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/supervise.c----svhandler_flash_pgm_word,"void svhandler_flash_pgm_word(void) { uint32_t dst = _param_1; uint32_t src = _param_2; <S2SV_StartVul> if ((dst >= BSTRP_FLASH_SECT_START) && <S2SV_EndVul> <S2SV_StartVul> (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) { <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if ((dst >= BLDR_FLASH_SECT_START) && <S2SV_EndVul> <S2SV_StartVul> (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) { <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> flash_clear_status_flags(); flash_unlock(); flash_program_word(dst, src); _param_1 = !!flash_chk_status(); _param_2 = 0; _param_3 = 0; flash_wait_for_last_operation(); FLASH_CR &= ~FLASH_CR_PG; FLASH_CR |= FLASH_CR_LOCK; }","- if ((dst >= BSTRP_FLASH_SECT_START) &&
- (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
- return;
- }
- if ((dst >= BLDR_FLASH_SECT_START) &&
- (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
- return;
- }
+ if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;","void svhandler_flash_pgm_word(void) { uint32_t dst = _param_1; uint32_t src = _param_2; if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return; flash_clear_status_flags(); flash_unlock(); flash_program_word(dst, src); _param_1 = !!flash_chk_status(); _param_2 = 0; _param_3 = 0; flash_wait_for_last_operation(); FLASH_CR &= ~FLASH_CR_PG; FLASH_CR |= FLASH_CR_LOCK; }"
551,3647----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/codegen.c----gen_assignment,"gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) { int idx; int type = nint(tree->car); switch (type) { case NODE_GVAR: case NODE_ARG: case NODE_LVAR: case NODE_IVAR: case NODE_CVAR: case NODE_CONST: case NODE_NIL: case NODE_MASGN: if (rhs) { codegen(s, rhs, VAL); pop(); sp = cursp(); } break; case NODE_COLON2: case NODE_CALL: case NODE_SCALL: break; case NODE_NVAR: codegen_error(s, ""Can't assign to numbered parameter""); break; default: codegen_error(s, ""unknown lhs""); break; } tree = tree->cdr; switch (type) { case NODE_GVAR: gen_setxv(s, OP_SETGV, sp, nsym(tree), val); break; case NODE_ARG: case NODE_LVAR: idx = lv_idx(s, nsym(tree)); if (idx > 0) { if (idx != sp) { gen_move(s, idx, sp, val); } break; } else { gen_setupvar(s, sp, nsym(tree)); } break; case NODE_IVAR: gen_setxv(s, OP_SETIV, sp, nsym(tree), val); break; case NODE_CVAR: gen_setxv(s, OP_SETCV, sp, nsym(tree), val); break; case NODE_CONST: gen_setxv(s, OP_SETCONST, sp, nsym(tree), val); break; case NODE_COLON2: if (sp) { gen_move(s, cursp(), sp, 0); } sp = cursp(); push(); codegen(s, tree->car, VAL); if (rhs) { codegen(s, rhs, VAL); pop(); gen_move(s, sp, cursp(), 0); } pop_n(2); idx = new_sym(s, nsym(tree->cdr)); genop_2(s, OP_SETMCNST, sp, idx); break; case NODE_CALL: case NODE_SCALL: { int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0; mrb_sym mid = nsym(tree->cdr->car); top = cursp(); if (val || sp == cursp()) { push(); } call = cursp(); if (!tree->car) { noself = 1; push(); } else { codegen(s, tree->car, VAL); } if (safe) { int recv = cursp()-1; gen_move(s, cursp(), recv, 1); skip = genjmp2_0(s, OP_JMPNIL, cursp(), val); } tree = tree->cdr->cdr->car; if (tree) { if (tree->car) { n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14); if (n < 0) { n = 15; push(); } } if (tree->cdr->car) { gen_hash(s, tree->cdr->car->cdr, VAL, 0); if (n < 14) { n++; <S2SV_StartVul> push(); <S2SV_EndVul> } else { <S2SV_StartVul> pop(); <S2SV_EndVul> genop_2(s, OP_ARYPUSH, cursp(), 1); } } } if (rhs) { codegen(s, rhs, VAL); pop(); } else { gen_move(s, cursp(), sp, 0); } if (val) { gen_move(s, top, cursp(), 1); } if (n < 14) { n++; } else { pop(); genop_2(s, OP_ARYPUSH, cursp(), 1); } s->sp = call; if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) { genop_1(s, OP_SETIDX, cursp()); } else { genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n); } if (safe) { dispatch(s, skip); } s->sp = top; } break; case NODE_MASGN: gen_vmassignment(s, tree->car, sp, val); break; case NODE_NIL: break; default: codegen_error(s, ""unknown lhs""); break; } if (val) push(); }","- push();
- pop();
+ if (n == 14) {
+ pop_n(n);
+ genop_2(s, OP_ARRAY, cursp(), n);
+ push();
+ n = 15;
+ }
+ pop_n(2);
+ push();","gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) { int idx; int type = nint(tree->car); switch (type) { case NODE_GVAR: case NODE_ARG: case NODE_LVAR: case NODE_IVAR: case NODE_CVAR: case NODE_CONST: case NODE_NIL: case NODE_MASGN: if (rhs) { codegen(s, rhs, VAL); pop(); sp = cursp(); } break; case NODE_COLON2: case NODE_CALL: case NODE_SCALL: break; case NODE_NVAR: codegen_error(s, ""Can't assign to numbered parameter""); break; default: codegen_error(s, ""unknown lhs""); break; } tree = tree->cdr; switch (type) { case NODE_GVAR: gen_setxv(s, OP_SETGV, sp, nsym(tree), val); break; case NODE_ARG: case NODE_LVAR: idx = lv_idx(s, nsym(tree)); if (idx > 0) { if (idx != sp) { gen_move(s, idx, sp, val); } break; } else { gen_setupvar(s, sp, nsym(tree)); } break; case NODE_IVAR: gen_setxv(s, OP_SETIV, sp, nsym(tree), val); break; case NODE_CVAR: gen_setxv(s, OP_SETCV, sp, nsym(tree), val); break; case NODE_CONST: gen_setxv(s, OP_SETCONST, sp, nsym(tree), val); break; case NODE_COLON2: if (sp) { gen_move(s, cursp(), sp, 0); } sp = cursp(); push(); codegen(s, tree->car, VAL); if (rhs) { codegen(s, rhs, VAL); pop(); gen_move(s, sp, cursp(), 0); } pop_n(2); idx = new_sym(s, nsym(tree->cdr)); genop_2(s, OP_SETMCNST, sp, idx); break; case NODE_CALL: case NODE_SCALL: { int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0; mrb_sym mid = nsym(tree->cdr->car); top = cursp(); if (val || sp == cursp()) { push(); } call = cursp(); if (!tree->car) { noself = 1; push(); } else { codegen(s, tree->car, VAL); } if (safe) { int recv = cursp()-1; gen_move(s, cursp(), recv, 1); skip = genjmp2_0(s, OP_JMPNIL, cursp(), val); } tree = tree->cdr->cdr->car; if (tree) { if (tree->car) { n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14); if (n < 0) { n = 15; push(); } } if (tree->cdr->car) { if (n == 14) { pop_n(n); genop_2(s, OP_ARRAY, cursp(), n); push(); n = 15; } gen_hash(s, tree->cdr->car->cdr, VAL, 0); if (n < 14) { n++; } else { pop_n(2); genop_2(s, OP_ARYPUSH, cursp(), 1); } push(); } } if (rhs) { codegen(s, rhs, VAL); pop(); } else { gen_move(s, cursp(), sp, 0); } if (val) { gen_move(s, top, cursp(), 1); } if (n < 14) { n++; } else { pop(); genop_2(s, OP_ARYPUSH, cursp(), 1); } s->sp = call; if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) { genop_1(s, OP_SETIDX, cursp()); } else { genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n); } if (safe) { dispatch(s, skip); } s->sp = top; } break; case NODE_MASGN: gen_vmassignment(s, tree->car, sp, val); break; case NODE_NIL: break; default: codegen_error(s, ""unknown lhs""); break; } if (val) push(); }"
552,2987----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dm9000_driver.c----dm9000ReadPhyReg,"uint16_t dm9000ReadPhyReg(uint8_t address) { <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address); <S2SV_EndVul> <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRR); <S2SV_EndVul> <S2SV_StartVul> while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0) <S2SV_EndVul> { } <S2SV_StartVul> dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS); <S2SV_EndVul> usleep(5); <S2SV_StartVul> return (dm9000ReadReg(DM9000_REG_EPDRH) << 8) | dm9000ReadReg(DM9000_REG_EPDRL); <S2SV_EndVul> }","- dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);
- dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRR);
- while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)
- dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);
- return (dm9000ReadReg(DM9000_REG_EPDRH) << 8) | dm9000ReadReg(DM9000_REG_EPDRL);
+ dm9000WriteReg(DM9000_EPAR, 0x40 | address);
+ dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR);
+ while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0)
+ dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS);
+ return (dm9000ReadReg(DM9000_EPDRH) << 8) | dm9000ReadReg(DM9000_EPDRL);","uint16_t dm9000ReadPhyReg(uint8_t address) { dm9000WriteReg(DM9000_EPAR, 0x40 | address); dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR); while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0) { } dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS); usleep(5); return (dm9000ReadReg(DM9000_EPDRH) << 8) | dm9000ReadReg(DM9000_EPDRL); }"
553,146----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3513--t1_lib.c----ssl_parse_clienthello_tlsext,"int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) { unsigned short type; unsigned short size; unsigned short len; unsigned char *data = *p; int renegotiate_seen = 0; int sigalg_seen = 0; s->servername_done = 0; s->tlsext_status_type = -1; #ifndef OPENSSL_NO_NEXTPROTONEG s->s3->next_proto_neg_seen = 0; #endif #ifndef OPENSSL_NO_HEARTBEATS s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS); #endif #ifndef OPENSSL_NO_EC if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG) ssl_check_for_safari(s, data, d, n); #endif if (data >= (d+n-2)) goto ri_check; n2s(data,len); if (data > (d+n-len)) goto ri_check; while (data <= (d+n-4)) { n2s(data,type); n2s(data,size); if (data+size > (d+n)) goto ri_check; #if 0 fprintf(stderr,""Received extension type %d size %d\n"",type,size); #endif if (s->tlsext_debug_cb) s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg); if (type == TLSEXT_TYPE_server_name) { unsigned char *sdata; int servname_type; int dsize; if (size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(data,dsize); size -= 2; if (dsize > size ) { *al = SSL_AD_DECODE_ERROR; return 0; } sdata = data; while (dsize > 3) { servname_type = *(sdata++); n2s(sdata,len); dsize -= 3; if (len > dsize) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->servername_done == 0) switch (servname_type) { case TLSEXT_NAMETYPE_host_name: if (!s->hit) { if(s->session->tlsext_hostname) { *al = SSL_AD_DECODE_ERROR; return 0; } if (len > TLSEXT_MAXLEN_host_name) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } if ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } memcpy(s->session->tlsext_hostname, sdata, len); s->session->tlsext_hostname[len]='\0'; if (strlen(s->session->tlsext_hostname) != len) { OPENSSL_free(s->session->tlsext_hostname); s->session->tlsext_hostname = NULL; *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } s->servername_done = 1; } else s->servername_done = s->session->tlsext_hostname && strlen(s->session->tlsext_hostname) == len && strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0; break; default: break; } dsize -= len; } if (dsize != 0) { *al = SSL_AD_DECODE_ERROR; return 0; } } #ifndef OPENSSL_NO_SRP else if (type == TLSEXT_TYPE_srp) { if (size <= 0 || ((len = data[0])) != (size -1)) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->srp_ctx.login != NULL) { *al = SSL_AD_DECODE_ERROR; return 0; } if ((s->srp_ctx.login = OPENSSL_malloc(len+1)) == NULL) return -1; memcpy(s->srp_ctx.login, &data[1], len); s->srp_ctx.login[len]='\0'; if (strlen(s->srp_ctx.login) != len) { *al = SSL_AD_DECODE_ERROR; return 0; } } #endif #ifndef OPENSSL_NO_EC else if (type == TLSEXT_TYPE_ec_point_formats) { unsigned char *sdata = data; int ecpointformatlist_length = *(sdata++); if (ecpointformatlist_length != size - 1) { *al = TLS1_AD_DECODE_ERROR; return 0; } if (!s->hit) { if(s->session->tlsext_ecpointformatlist) { OPENSSL_free(s->session->tlsext_ecpointformatlist); s->session->tlsext_ecpointformatlist = NULL; } s->session->tlsext_ecpointformatlist_length = 0; if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length; memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length); } #if 0 fprintf(stderr,""ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) "", s->session->tlsext_ecpointformatlist_length); sdata = s->session->tlsext_ecpointformatlist; for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) fprintf(stderr,""%i "",*(sdata++)); fprintf(stderr,""\n""); #endif } else if (type == TLSEXT_TYPE_elliptic_curves) { unsigned char *sdata = data; int ellipticcurvelist_length = (*(sdata++) << 8); ellipticcurvelist_length += (*(sdata++)); if (ellipticcurvelist_length != size - 2 || ellipticcurvelist_length < 1) { *al = TLS1_AD_DECODE_ERROR; return 0; } if (!s->hit) { if(s->session->tlsext_ellipticcurvelist) { *al = TLS1_AD_DECODE_ERROR; return 0; } s->session->tlsext_ellipticcurvelist_length = 0; if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length; memcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length); } #if 0 fprintf(stderr,""ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) "", s->session->tlsext_ellipticcurvelist_length); sdata = s->session->tlsext_ellipticcurvelist; for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) fprintf(stderr,""%i "",*(sdata++)); fprintf(stderr,""\n""); #endif } #endif #ifdef TLSEXT_TYPE_opaque_prf_input else if (type == TLSEXT_TYPE_opaque_prf_input && s->version != DTLS1_VERSION) { unsigned char *sdata = data; if (size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(sdata, s->s3->client_opaque_prf_input_len); if (s->s3->client_opaque_prf_input_len != size - 2) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->s3->client_opaque_prf_input != NULL) OPENSSL_free(s->s3->client_opaque_prf_input); if (s->s3->client_opaque_prf_input_len == 0) s->s3->client_opaque_prf_input = OPENSSL_malloc(1); else s->s3->client_opaque_prf_input = BUF_memdup(sdata, s->s3->client_opaque_prf_input_len); if (s->s3->client_opaque_prf_input == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } #endif else if (type == TLSEXT_TYPE_session_ticket) { if (s->tls_session_ticket_ext_cb && !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } else if (type == TLSEXT_TYPE_renegotiate) { if(!ssl_parse_clienthello_renegotiate_ext(s, data, size, al)) return 0; renegotiate_seen = 1; } else if (type == TLSEXT_TYPE_signature_algorithms) { int dsize; if (sigalg_seen || size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } sigalg_seen = 1; n2s(data,dsize); size -= 2; if (dsize != size || dsize & 1) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!tls1_process_sigalgs(s, data, dsize)) { *al = SSL_AD_DECODE_ERROR; return 0; } } else if (type == TLSEXT_TYPE_status_request && s->version != DTLS1_VERSION) { if (size < 5) { *al = SSL_AD_DECODE_ERROR; return 0; } s->tlsext_status_type = *data++; size--; if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) { const unsigned char *sdata; int dsize; n2s(data,dsize); size -= 2; if (dsize > size ) { *al = SSL_AD_DECODE_ERROR; return 0; } while (dsize > 0) { OCSP_RESPID *id; int idsize; if (dsize < 4) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(data, idsize); dsize -= 2 + idsize; size -= 2 + idsize; if (dsize < 0) { *al = SSL_AD_DECODE_ERROR; return 0; } sdata = data; data += idsize; id = d2i_OCSP_RESPID(NULL, &sdata, idsize); if (!id) { *al = SSL_AD_DECODE_ERROR; return 0; } if (data != sdata) { OCSP_RESPID_free(id); *al = SSL_AD_DECODE_ERROR; return 0; } if (!s->tlsext_ocsp_ids && !(s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null())) { OCSP_RESPID_free(id); *al = SSL_AD_INTERNAL_ERROR; return 0; } if (!sk_OCSP_RESPID_push( s->tlsext_ocsp_ids, id)) { OCSP_RESPID_free(id); *al = SSL_AD_INTERNAL_ERROR; return 0; } } if (size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(data,dsize); size -= 2; if (dsize != size) { *al = SSL_AD_DECODE_ERROR; return 0; } sdata = data; if (dsize > 0) { if (s->tlsext_ocsp_exts) { sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts, X509_EXTENSION_free); } s->tlsext_ocsp_exts = d2i_X509_EXTENSIONS(NULL, &sdata, dsize); if (!s->tlsext_ocsp_exts || (data + dsize != sdata)) { *al = SSL_AD_DECODE_ERROR; return 0; } } } else s->tlsext_status_type = -1; } #ifndef OPENSSL_NO_HEARTBEATS else if (type == TLSEXT_TYPE_heartbeat) { switch(data[0]) { case 0x01: s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; break; case 0x02: s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; break; default: *al = SSL_AD_ILLEGAL_PARAMETER; return 0; } } #endif #ifndef OPENSSL_NO_NEXTPROTONEG else if (type == TLSEXT_TYPE_next_proto_neg && s->s3->tmp.finish_md_len == 0) { s->s3->next_proto_neg_seen = 1; } #endif #ifndef OPENSSL_NO_SRTP <S2SV_StartVul> else if (type == TLSEXT_TYPE_use_srtp) <S2SV_EndVul> { if(ssl_parse_clienthello_use_srtp_ext(s, data, size, al)) } #endif data+=size; } *p = data; ri_check: if (!renegotiate_seen && s->renegotiate && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { *al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); return 0; } return 1; }","- else if (type == TLSEXT_TYPE_use_srtp)
+ else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)
+ && type == TLSEXT_TYPE_use_srtp)","int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, int n, int *al) { unsigned short type; unsigned short size; unsigned short len; unsigned char *data = *p; int renegotiate_seen = 0; int sigalg_seen = 0; s->servername_done = 0; s->tlsext_status_type = -1; #ifndef OPENSSL_NO_NEXTPROTONEG s->s3->next_proto_neg_seen = 0; #endif #ifndef OPENSSL_NO_HEARTBEATS s->tlsext_heartbeat &= ~(SSL_TLSEXT_HB_ENABLED | SSL_TLSEXT_HB_DONT_SEND_REQUESTS); #endif #ifndef OPENSSL_NO_EC if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG) ssl_check_for_safari(s, data, d, n); #endif if (data >= (d+n-2)) goto ri_check; n2s(data,len); if (data > (d+n-len)) goto ri_check; while (data <= (d+n-4)) { n2s(data,type); n2s(data,size); if (data+size > (d+n)) goto ri_check; #if 0 fprintf(stderr,""Received extension type %d size %d\n"",type,size); #endif if (s->tlsext_debug_cb) s->tlsext_debug_cb(s, 0, type, data, size, s->tlsext_debug_arg); if (type == TLSEXT_TYPE_server_name) { unsigned char *sdata; int servname_type; int dsize; if (size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(data,dsize); size -= 2; if (dsize > size ) { *al = SSL_AD_DECODE_ERROR; return 0; } sdata = data; while (dsize > 3) { servname_type = *(sdata++); n2s(sdata,len); dsize -= 3; if (len > dsize) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->servername_done == 0) switch (servname_type) { case TLSEXT_NAMETYPE_host_name: if (!s->hit) { if(s->session->tlsext_hostname) { *al = SSL_AD_DECODE_ERROR; return 0; } if (len > TLSEXT_MAXLEN_host_name) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } if ((s->session->tlsext_hostname = OPENSSL_malloc(len+1)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } memcpy(s->session->tlsext_hostname, sdata, len); s->session->tlsext_hostname[len]='\0'; if (strlen(s->session->tlsext_hostname) != len) { OPENSSL_free(s->session->tlsext_hostname); s->session->tlsext_hostname = NULL; *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } s->servername_done = 1; } else s->servername_done = s->session->tlsext_hostname && strlen(s->session->tlsext_hostname) == len && strncmp(s->session->tlsext_hostname, (char *)sdata, len) == 0; break; default: break; } dsize -= len; } if (dsize != 0) { *al = SSL_AD_DECODE_ERROR; return 0; } } #ifndef OPENSSL_NO_SRP else if (type == TLSEXT_TYPE_srp) { if (size <= 0 || ((len = data[0])) != (size -1)) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->srp_ctx.login != NULL) { *al = SSL_AD_DECODE_ERROR; return 0; } if ((s->srp_ctx.login = OPENSSL_malloc(len+1)) == NULL) return -1; memcpy(s->srp_ctx.login, &data[1], len); s->srp_ctx.login[len]='\0'; if (strlen(s->srp_ctx.login) != len) { *al = SSL_AD_DECODE_ERROR; return 0; } } #endif #ifndef OPENSSL_NO_EC else if (type == TLSEXT_TYPE_ec_point_formats) { unsigned char *sdata = data; int ecpointformatlist_length = *(sdata++); if (ecpointformatlist_length != size - 1) { *al = TLS1_AD_DECODE_ERROR; return 0; } if (!s->hit) { if(s->session->tlsext_ecpointformatlist) { OPENSSL_free(s->session->tlsext_ecpointformatlist); s->session->tlsext_ecpointformatlist = NULL; } s->session->tlsext_ecpointformatlist_length = 0; if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length; memcpy(s->session->tlsext_ecpointformatlist, sdata, ecpointformatlist_length); } #if 0 fprintf(stderr,""ssl_parse_clienthello_tlsext s->session->tlsext_ecpointformatlist (length=%i) "", s->session->tlsext_ecpointformatlist_length); sdata = s->session->tlsext_ecpointformatlist; for (i = 0; i < s->session->tlsext_ecpointformatlist_length; i++) fprintf(stderr,""%i "",*(sdata++)); fprintf(stderr,""\n""); #endif } else if (type == TLSEXT_TYPE_elliptic_curves) { unsigned char *sdata = data; int ellipticcurvelist_length = (*(sdata++) << 8); ellipticcurvelist_length += (*(sdata++)); if (ellipticcurvelist_length != size - 2 || ellipticcurvelist_length < 1) { *al = TLS1_AD_DECODE_ERROR; return 0; } if (!s->hit) { if(s->session->tlsext_ellipticcurvelist) { *al = TLS1_AD_DECODE_ERROR; return 0; } s->session->tlsext_ellipticcurvelist_length = 0; if ((s->session->tlsext_ellipticcurvelist = OPENSSL_malloc(ellipticcurvelist_length)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->session->tlsext_ellipticcurvelist_length = ellipticcurvelist_length; memcpy(s->session->tlsext_ellipticcurvelist, sdata, ellipticcurvelist_length); } #if 0 fprintf(stderr,""ssl_parse_clienthello_tlsext s->session->tlsext_ellipticcurvelist (length=%i) "", s->session->tlsext_ellipticcurvelist_length); sdata = s->session->tlsext_ellipticcurvelist; for (i = 0; i < s->session->tlsext_ellipticcurvelist_length; i++) fprintf(stderr,""%i "",*(sdata++)); fprintf(stderr,""\n""); #endif } #endif #ifdef TLSEXT_TYPE_opaque_prf_input else if (type == TLSEXT_TYPE_opaque_prf_input && s->version != DTLS1_VERSION) { unsigned char *sdata = data; if (size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(sdata, s->s3->client_opaque_prf_input_len); if (s->s3->client_opaque_prf_input_len != size - 2) { *al = SSL_AD_DECODE_ERROR; return 0; } if (s->s3->client_opaque_prf_input != NULL) OPENSSL_free(s->s3->client_opaque_prf_input); if (s->s3->client_opaque_prf_input_len == 0) s->s3->client_opaque_prf_input = OPENSSL_malloc(1); else s->s3->client_opaque_prf_input = BUF_memdup(sdata, s->s3->client_opaque_prf_input_len); if (s->s3->client_opaque_prf_input == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } #endif else if (type == TLSEXT_TYPE_session_ticket) { if (s->tls_session_ticket_ext_cb && !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } else if (type == TLSEXT_TYPE_renegotiate) { if(!ssl_parse_clienthello_renegotiate_ext(s, data, size, al)) return 0; renegotiate_seen = 1; } else if (type == TLSEXT_TYPE_signature_algorithms) { int dsize; if (sigalg_seen || size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } sigalg_seen = 1; n2s(data,dsize); size -= 2; if (dsize != size || dsize & 1) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!tls1_process_sigalgs(s, data, dsize)) { *al = SSL_AD_DECODE_ERROR; return 0; } } else if (type == TLSEXT_TYPE_status_request && s->version != DTLS1_VERSION) { if (size < 5) { *al = SSL_AD_DECODE_ERROR; return 0; } s->tlsext_status_type = *data++; size--; if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) { const unsigned char *sdata; int dsize; n2s(data,dsize); size -= 2; if (dsize > size ) { *al = SSL_AD_DECODE_ERROR; return 0; } while (dsize > 0) { OCSP_RESPID *id; int idsize; if (dsize < 4) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(data, idsize); dsize -= 2 + idsize; size -= 2 + idsize; if (dsize < 0) { *al = SSL_AD_DECODE_ERROR; return 0; } sdata = data; data += idsize; id = d2i_OCSP_RESPID(NULL, &sdata, idsize); if (!id) { *al = SSL_AD_DECODE_ERROR; return 0; } if (data != sdata) { OCSP_RESPID_free(id); *al = SSL_AD_DECODE_ERROR; return 0; } if (!s->tlsext_ocsp_ids && !(s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null())) { OCSP_RESPID_free(id); *al = SSL_AD_INTERNAL_ERROR; return 0; } if (!sk_OCSP_RESPID_push( s->tlsext_ocsp_ids, id)) { OCSP_RESPID_free(id); *al = SSL_AD_INTERNAL_ERROR; return 0; } } if (size < 2) { *al = SSL_AD_DECODE_ERROR; return 0; } n2s(data,dsize); size -= 2; if (dsize != size) { *al = SSL_AD_DECODE_ERROR; return 0; } sdata = data; if (dsize > 0) { if (s->tlsext_ocsp_exts) { sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts, X509_EXTENSION_free); } s->tlsext_ocsp_exts = d2i_X509_EXTENSIONS(NULL, &sdata, dsize); if (!s->tlsext_ocsp_exts || (data + dsize != sdata)) { *al = SSL_AD_DECODE_ERROR; return 0; } } } else s->tlsext_status_type = -1; } #ifndef OPENSSL_NO_HEARTBEATS else if (type == TLSEXT_TYPE_heartbeat) { switch(data[0]) { case 0x01: s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; break; case 0x02: s->tlsext_heartbeat |= SSL_TLSEXT_HB_ENABLED; s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_SEND_REQUESTS; break; default: *al = SSL_AD_ILLEGAL_PARAMETER; return 0; } } #endif #ifndef OPENSSL_NO_NEXTPROTONEG else if (type == TLSEXT_TYPE_next_proto_neg && s->s3->tmp.finish_md_len == 0) { s->s3->next_proto_neg_seen = 1; } #endif #ifndef OPENSSL_NO_SRTP else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s) && type == TLSEXT_TYPE_use_srtp) { if(ssl_parse_clienthello_use_srtp_ext(s, data, size, al)) } #endif data+=size; } *p = data; ri_check: if (!renegotiate_seen && s->renegotiate && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { *al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); return 0; } return 1; }"
554,5640----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/class.c----r_bin_java_rti_annotations_attr_new,"R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut32 i = 0; <S2SV_StartVul> RBinJavaAttrInfo *attr = NULL; <S2SV_EndVul> ut64 offset = 0; <S2SV_StartVul> attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); <S2SV_EndVul> offset += 6; if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR; attr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free); for (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) { if (offset >= sz) { break; } RBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset); if (annotation) { offset += annotation->size; } r_list_append (attr->info.annotation_array.annotations, (void *) annotation); } attr->size = offset; } return attr; }","- RBinJavaAttrInfo *attr = NULL;
- attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);
+ if (buf_offset + 32 >= sz) {
+ return NULL;
+ }
+ RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);","R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut32 i = 0; ut64 offset = 0; if (buf_offset + 32 >= sz) { return NULL; } RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); offset += 6; if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR; attr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free); for (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) { if (offset >= sz) { break; } RBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset); if (annotation) { offset += annotation->size; } r_list_append (attr->info.annotation_array.annotations, (void *) annotation); } attr->size = offset; } return attr; }"
555,2709----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event_v6.c----armv6pmu_handle_irq,"armv6pmu_handle_irq(int irq_num, void *dev) { unsigned long pmcr = armv6_pmcr_read(); struct perf_sample_data data; struct cpu_hw_events *cpuc; struct pt_regs *regs; int idx; if (!armv6_pmcr_has_overflowed(pmcr)) return IRQ_NONE; regs = get_irq_regs(); armv6_pmcr_write(pmcr); perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); for (idx = 0; idx <= armpmu->num_events; ++idx) { struct perf_event *event = cpuc->events[idx]; struct hw_perf_event *hwc; if (!test_bit(idx, cpuc->active_mask)) continue; if (!armv6_pmcr_counter_has_overflowed(pmcr, idx)) continue; hwc = &event->hw; armpmu_event_update(event, hwc, idx, 1); data.period = event->hw.last_period; if (!armpmu_event_set_period(event, hwc, idx)) continue; <S2SV_StartVul> if (perf_event_overflow(event, 0, &data, regs)) <S2SV_EndVul> armpmu->disable(hwc, idx); } irq_work_run(); return IRQ_HANDLED; }","- if (perf_event_overflow(event, 0, &data, regs))
+ if (perf_event_overflow(event, &data, regs))","armv6pmu_handle_irq(int irq_num, void *dev) { unsigned long pmcr = armv6_pmcr_read(); struct perf_sample_data data; struct cpu_hw_events *cpuc; struct pt_regs *regs; int idx; if (!armv6_pmcr_has_overflowed(pmcr)) return IRQ_NONE; regs = get_irq_regs(); armv6_pmcr_write(pmcr); perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); for (idx = 0; idx <= armpmu->num_events; ++idx) { struct perf_event *event = cpuc->events[idx]; struct hw_perf_event *hwc; if (!test_bit(idx, cpuc->active_mask)) continue; if (!armv6_pmcr_counter_has_overflowed(pmcr, idx)) continue; hwc = &event->hw; armpmu_event_update(event, hwc, idx, 1); data.period = event->hw.last_period; if (!armpmu_event_set_period(event, hwc, idx)) continue; if (perf_event_overflow(event, &data, regs)) armpmu->disable(hwc, idx); } irq_work_run(); return IRQ_HANDLED; }"
556,550----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-0216--interface.c----xenvif_disconnect,"<S2SV_StartVul> void xenvif_disconnect(struct xenvif *vif) <S2SV_EndVul> { struct net_device *dev = vif->dev; <S2SV_StartVul> if (netif_carrier_ok(dev)) { <S2SV_EndVul> <S2SV_StartVul> rtnl_lock(); <S2SV_EndVul> <S2SV_StartVul> netif_carrier_off(dev); <S2SV_EndVul> <S2SV_StartVul> if (netif_running(dev)) <S2SV_EndVul> <S2SV_StartVul> xenvif_down(vif); <S2SV_EndVul> <S2SV_StartVul> rtnl_unlock(); <S2SV_EndVul> <S2SV_StartVul> xenvif_put(vif); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> atomic_dec(&vif->refcnt); wait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0); del_timer_sync(&vif->credit_timeout); if (vif->irq) unbind_from_irqhandler(vif->irq, vif); unregister_netdev(vif->dev); xen_netbk_unmap_frontend_rings(vif); free_netdev(vif->dev); }","- void xenvif_disconnect(struct xenvif *vif)
- if (netif_carrier_ok(dev)) {
- rtnl_lock();
- if (netif_running(dev))
- xenvif_down(vif);
- rtnl_unlock();
- xenvif_put(vif);
- }
+ void xenvif_disconnect(struct xenvif *vif)
+ void xenvif_carrier_off(struct xenvif *vif)
+ {
+ struct net_device *dev = vif->dev;","void xenvif_disconnect(struct xenvif *vif) void xenvif_carrier_off(struct xenvif *vif) { struct net_device *dev = vif->dev; rtnl_lock(); netif_carrier_off(dev); if (netif_running(dev)) xenvif_down(vif); rtnl_unlock(); xenvif_put(vif); } void xenvif_disconnect(struct xenvif *vif) { if (netif_carrier_ok(vif->dev)) xenvif_carrier_off(vif); atomic_dec(&vif->refcnt); wait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0); del_timer_sync(&vif->credit_timeout); if (vif->irq) unbind_from_irqhandler(vif->irq, vif); unregister_netdev(vif->dev); xen_netbk_unmap_frontend_rings(vif); free_netdev(vif->dev); }"
557,"2902----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/parameterized_truncated_normal_op.cc----tensorflow::functor::TruncatedNormalFunctorV2<CPUDevice,T>::operator ( )","void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches, int64 samples_per_batch, int64 num_elements, const BCastList<4>& bcast, typename TTypes<T>::ConstFlat means, typename TTypes<T>::ConstFlat stddevs, typename TTypes<T>::ConstFlat minvals, typename TTypes<T>::ConstFlat maxvals, const random::PhiloxRandom& gen, typename TTypes<T>::Flat output) { const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3); auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means, &stddevs, &minvals, &maxvals, &gen, &output, <S2SV_StartVul> kStdDevsInsideBoundsToUseRandnSampler](int start_output, <S2SV_EndVul> <S2SV_StartVul> int limit_output) { <S2SV_EndVul> random::PhiloxRandom gen_copy = gen; using Uniform = random::UniformDistribution<random::PhiloxRandom, T>; Uniform dist; using Normal = random::NormalDistribution<random::PhiloxRandom, T>; Normal normal_dist; gen_copy.Skip((start_output * 2 * kMaxIterations + Uniform::kResultElementCount - 1) / Uniform::kResultElementCount); Eigen::array<T, Uniform::kResultElementCount> z; Eigen::array<T, Uniform::kResultElementCount> g; const bool should_bcast = bcast.IsBroadcastingRequired(); const auto& means_batch_indices = bcast.batch_indices(0); const auto& stddevs_batch_indices = bcast.batch_indices(1); const auto& minvals_batch_indices = bcast.batch_indices(2); const auto& maxvals_batch_indices = bcast.batch_indices(3); auto output_flat = output.data(); for (int64 output_idx = start_output; output_idx < limit_output; ) { int64 batch_idx = output_idx / samples_per_batch; T* const output_batch_offset = output_flat + batch_idx; T mean, stddev, minval, maxval; if (should_bcast) { mean = means(means_batch_indices[batch_idx]); stddev = stddevs(stddevs_batch_indices[batch_idx]); minval = minvals(minvals_batch_indices[batch_idx]); maxval = maxvals(maxvals_batch_indices[batch_idx]); } else { mean = means(batch_idx); stddev = stddevs(batch_idx); minval = minvals(batch_idx); maxval = maxvals(batch_idx); } OP_REQUIRES(ctx, stddev > T(0) && minval < maxval && (Eigen::numext::isfinite(minval) || Eigen::numext::isfinite(maxval)), errors::InvalidArgument(""Invalid parameters"")); int num_iterations = 0; if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) { std::swap(minval, maxval); stddev = -stddev; } const T normMin = (minval - mean) / stddev; const T normMax = (maxval - mean) / stddev; const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4)); const T cutoff = T(2) * Eigen::numext::exp(T(0.5) + (normMin * (normMin - sqrtFactor)) / T(4)) / (normMin + sqrtFactor); const T diff = normMax - normMin; if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) && (normMax >= T(0.))) || ((normMax > kStdDevsInsideBoundsToUseRandnSampler) && (normMin <= T(0.)))) { for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { const auto randn_sample = normal_dist(&gen_copy); const int size = randn_sample.size(); for (int i = 0; i < size; ++i) { if ((randn_sample[i] >= normMin) && (randn_sample[i] <= normMax)) { output_batch_offset[sample_idx * num_batches] = randn_sample[i] * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { ++num_iterations; if (num_iterations > kMaxIterations) { LOG(ERROR) << ""TruncatedNormal randn rejection sampler "" << ""exceeded maximum iterations for "" << ""normMin="" << normMin << "" normMax="" << normMax << "" kMaxIterations="" << kMaxIterations; ctx->SetStatus(errors::Internal( ""TruncatedNormal randn rejection sampler failed to accept"" "" a sample."")); return; } } } } } else if (diff < cutoff) { const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin; for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { const auto rand = dist(&gen_copy); const int size = rand.size(); for (int i = 0; i < size; i++) { z[i] = rand[i] * diff + normMin; g[i] = (plusFactor - z[i] * z[i]) / T(2.0); } const auto u = dist(&gen_copy); for (int i = 0; i < size; i++) { auto accept = u[i] <= Eigen::numext::exp(g[i]); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal uniform rejection sampler "" << ""exceeded max iterations. Sample may contain "" << ""outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal uniform rejection sampler failed to "" "" accept a sample."")); return; } output_batch_offset[sample_idx * num_batches] = z[i] * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { num_iterations++; } } } } else { const T alpha = (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) / T(2); for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { auto rand = dist(&gen_copy); const int size = rand.size(); int i = 0; while (i < size) { const T z = -Eigen::numext::log(rand[i]) / alpha + normMin; i++; const T x = normMin < alpha ? alpha - z : normMin - alpha; const T g = Eigen::numext::exp(-x * x / T(2.0)); const T u = rand[i]; i++; auto accept = (u <= g && z < normMax); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal exponential distribution "" << ""rejection sampler exceeds max iterations. "" << ""Sample may contain outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal exponential distribution rejection"" "" sampler failed to accept a sample."")); return; } output_batch_offset[sample_idx * num_batches] = z * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { num_iterations++; } } } } } }; const int64 batchInitCost = (Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>()) * 2 + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() + Eigen::internal::functor_traits< Eigen::internal::scalar_sqrt_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() * 4 + Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::AddCost<T>(); const int64 uniformSampleCost = random::PhiloxRandom::kElementCost + random::UniformDistribution<random::PhiloxRandom, T>::kElementCost; const int64 uniformRejectionSamplingCost = uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() * 2 + Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost + Eigen::internal::functor_traits< Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>(); const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2; Shard(worker_threads.num_threads, worker_threads.workers, num_elements, batchCost, do_work); }","- kStdDevsInsideBoundsToUseRandnSampler](int start_output,
- int limit_output) {
+ kStdDevsInsideBoundsToUseRandnSampler](int64 start_output,
+ int64 limit_output) {","void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches, int64 samples_per_batch, int64 num_elements, const BCastList<4>& bcast, typename TTypes<T>::ConstFlat means, typename TTypes<T>::ConstFlat stddevs, typename TTypes<T>::ConstFlat minvals, typename TTypes<T>::ConstFlat maxvals, const random::PhiloxRandom& gen, typename TTypes<T>::Flat output) { const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3); auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means, &stddevs, &minvals, &maxvals, &gen, &output, kStdDevsInsideBoundsToUseRandnSampler](int64 start_output, int64 limit_output) { random::PhiloxRandom gen_copy = gen; using Uniform = random::UniformDistribution<random::PhiloxRandom, T>; Uniform dist; using Normal = random::NormalDistribution<random::PhiloxRandom, T>; Normal normal_dist; gen_copy.Skip((start_output * 2 * kMaxIterations + Uniform::kResultElementCount - 1) / Uniform::kResultElementCount); Eigen::array<T, Uniform::kResultElementCount> z; Eigen::array<T, Uniform::kResultElementCount> g; const bool should_bcast = bcast.IsBroadcastingRequired(); const auto& means_batch_indices = bcast.batch_indices(0); const auto& stddevs_batch_indices = bcast.batch_indices(1); const auto& minvals_batch_indices = bcast.batch_indices(2); const auto& maxvals_batch_indices = bcast.batch_indices(3); auto output_flat = output.data(); for (int64 output_idx = start_output; output_idx < limit_output; ) { int64 batch_idx = output_idx / samples_per_batch; T* const output_batch_offset = output_flat + batch_idx; T mean, stddev, minval, maxval; if (should_bcast) { mean = means(means_batch_indices[batch_idx]); stddev = stddevs(stddevs_batch_indices[batch_idx]); minval = minvals(minvals_batch_indices[batch_idx]); maxval = maxvals(maxvals_batch_indices[batch_idx]); } else { mean = means(batch_idx); stddev = stddevs(batch_idx); minval = minvals(batch_idx); maxval = maxvals(batch_idx); } OP_REQUIRES(ctx, stddev > T(0) && minval < maxval && (Eigen::numext::isfinite(minval) || Eigen::numext::isfinite(maxval)), errors::InvalidArgument(""Invalid parameters"")); int num_iterations = 0; if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) { std::swap(minval, maxval); stddev = -stddev; } const T normMin = (minval - mean) / stddev; const T normMax = (maxval - mean) / stddev; const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4)); const T cutoff = T(2) * Eigen::numext::exp(T(0.5) + (normMin * (normMin - sqrtFactor)) / T(4)) / (normMin + sqrtFactor); const T diff = normMax - normMin; if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) && (normMax >= T(0.))) || ((normMax > kStdDevsInsideBoundsToUseRandnSampler) && (normMin <= T(0.)))) { for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { const auto randn_sample = normal_dist(&gen_copy); const int size = randn_sample.size(); for (int i = 0; i < size; ++i) { if ((randn_sample[i] >= normMin) && (randn_sample[i] <= normMax)) { output_batch_offset[sample_idx * num_batches] = randn_sample[i] * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { ++num_iterations; if (num_iterations > kMaxIterations) { LOG(ERROR) << ""TruncatedNormal randn rejection sampler "" << ""exceeded maximum iterations for "" << ""normMin="" << normMin << "" normMax="" << normMax << "" kMaxIterations="" << kMaxIterations; ctx->SetStatus(errors::Internal( ""TruncatedNormal randn rejection sampler failed to accept"" "" a sample."")); return; } } } } } else if (diff < cutoff) { const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin; for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { const auto rand = dist(&gen_copy); const int size = rand.size(); for (int i = 0; i < size; i++) { z[i] = rand[i] * diff + normMin; g[i] = (plusFactor - z[i] * z[i]) / T(2.0); } const auto u = dist(&gen_copy); for (int i = 0; i < size; i++) { auto accept = u[i] <= Eigen::numext::exp(g[i]); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal uniform rejection sampler "" << ""exceeded max iterations. Sample may contain "" << ""outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal uniform rejection sampler failed to "" "" accept a sample."")); return; } output_batch_offset[sample_idx * num_batches] = z[i] * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { num_iterations++; } } } } else { const T alpha = (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) / T(2); for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { auto rand = dist(&gen_copy); const int size = rand.size(); int i = 0; while (i < size) { const T z = -Eigen::numext::log(rand[i]) / alpha + normMin; i++; const T x = normMin < alpha ? alpha - z : normMin - alpha; const T g = Eigen::numext::exp(-x * x / T(2.0)); const T u = rand[i]; i++; auto accept = (u <= g && z < normMax); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal exponential distribution "" << ""rejection sampler exceeds max iterations. "" << ""Sample may contain outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal exponential distribution rejection"" "" sampler failed to accept a sample."")); return; } output_batch_offset[sample_idx * num_batches] = z * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { num_iterations++; } } } } } }; const int64 batchInitCost = (Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>()) * 2 + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() + Eigen::internal::functor_traits< Eigen::internal::scalar_sqrt_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() * 4 + Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::AddCost<T>(); const int64 uniformSampleCost = random::PhiloxRandom::kElementCost + random::UniformDistribution<random::PhiloxRandom, T>::kElementCost; const int64 uniformRejectionSamplingCost = uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() * 2 + Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost + Eigen::internal::functor_traits< Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>(); const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2; Shard(worker_threads.num_threads, worker_threads.workers, num_elements, batchCost, do_work); }"
558,4954----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/f_hmp.c----_WM_ParseNewHmp,"_WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) { uint8_t is_hmp2 = 0; uint32_t zero_cnt = 0; uint32_t i = 0; uint32_t hmp_file_length = 0; uint32_t hmp_chunks = 0; uint32_t hmp_divisions = 0; uint32_t hmp_unknown = 0; uint32_t hmp_bpm = 0; uint32_t hmp_song_time = 0; struct _mdi *hmp_mdi; uint8_t **hmp_chunk; uint32_t *chunk_length; uint32_t *chunk_ofs; uint32_t *chunk_delta; uint8_t *chunk_end; uint32_t chunk_num = 0; uint32_t hmp_track = 0; uint32_t smallest_delta = 0; uint32_t subtract_delta = 0; uint32_t end_of_chunks = 0; uint32_t var_len_shift = 0; float tempo_f = 500000.0; float samples_per_delta_f = 0.0; uint32_t sample_count = 0; float sample_count_f = 0; float sample_remainder = 0; if (memcmp(hmp_data, ""HMIMIDIP"", 8)) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0); return NULL; } hmp_data += 8; hmp_size -= 8; if (!memcmp(hmp_data, ""013195"", 6)) { hmp_data += 6; hmp_size -= 6; is_hmp2 = 1; } if (is_hmp2) { zero_cnt = 18; } else { zero_cnt = 24; } for (i = 0; i < zero_cnt; i++) { if (hmp_data[i] != 0) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0); return NULL; } } hmp_data += zero_cnt; hmp_size -= zero_cnt; hmp_file_length = *hmp_data++; hmp_file_length += (*hmp_data++ << 8); hmp_file_length += (*hmp_data++ << 16); hmp_file_length += (*hmp_data++ << 24); hmp_size -= 4; UNUSED(hmp_file_length); hmp_data += 12; hmp_size -= 12; hmp_chunks = *hmp_data++; hmp_chunks += (*hmp_data++ << 8); hmp_chunks += (*hmp_data++ << 16); hmp_chunks += (*hmp_data++ << 24); hmp_size -= 4; hmp_unknown = *hmp_data++; hmp_unknown += (*hmp_data++ << 8); hmp_unknown += (*hmp_data++ << 16); hmp_unknown += (*hmp_data++ << 24); hmp_size -= 4; UNUSED(hmp_unknown); hmp_divisions = 60; hmp_bpm = *hmp_data++; hmp_bpm += (*hmp_data++ << 8); hmp_bpm += (*hmp_data++ << 16); hmp_bpm += (*hmp_data++ << 24); hmp_size -= 4; if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) { tempo_f = (float) (60000000 / hmp_bpm) + 0.5f; } else { tempo_f = (float) (60000000 / hmp_bpm); } samples_per_delta_f = _WM_GetSamplesPerTick(hmp_divisions, tempo_f); hmp_song_time = *hmp_data++; hmp_song_time += (*hmp_data++ << 8); hmp_song_time += (*hmp_data++ << 16); hmp_song_time += (*hmp_data++ << 24); hmp_size -= 4; UNUSED(hmp_song_time); if (is_hmp2) { hmp_data += 840; hmp_size -= 840; } else { hmp_data += 712; hmp_size -= 712; } hmp_mdi = _WM_initMDI(); _WM_midi_setup_divisions(hmp_mdi, hmp_divisions); _WM_midi_setup_tempo(hmp_mdi, (uint32_t)tempo_f); hmp_chunk = malloc(sizeof(uint8_t *) * hmp_chunks); chunk_length = malloc(sizeof(uint32_t) * hmp_chunks); chunk_delta = malloc(sizeof(uint32_t) * hmp_chunks); chunk_ofs = malloc(sizeof(uint32_t) * hmp_chunks); chunk_end = malloc(sizeof(uint8_t) * hmp_chunks); smallest_delta = 0xffffffff; for (i = 0; i < hmp_chunks; i++) { hmp_chunk[i] = hmp_data; chunk_ofs[i] = 0; chunk_num = *hmp_data++; chunk_num += (*hmp_data++ << 8); chunk_num += (*hmp_data++ << 16); chunk_num += (*hmp_data++ << 24); chunk_ofs[i] += 4; UNUSED(chunk_num); chunk_length[i] = *hmp_data++; chunk_length[i] += (*hmp_data++ << 8); chunk_length[i] += (*hmp_data++ << 16); chunk_length[i] += (*hmp_data++ << 24); chunk_ofs[i] += 4; if (chunk_length[i] > hmp_size) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, ""file too short"", 0); goto _hmp_end; } hmp_size -= chunk_length[i]; hmp_track = *hmp_data++; hmp_track += (*hmp_data++ << 8); hmp_track += (*hmp_data++ << 16); hmp_track += (*hmp_data++ << 24); chunk_ofs[i] += 4; UNUSED(hmp_track); chunk_delta[i] = 0; var_len_shift = 0; if (*hmp_data < 0x80) { do { chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift); var_len_shift += 7; chunk_ofs[i]++; } while (*hmp_data < 0x80); } chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift); chunk_ofs[i]++; if (chunk_delta[i] < smallest_delta) { smallest_delta = chunk_delta[i]; } hmp_data = hmp_chunk[i] + chunk_length[i]; hmp_chunk[i] += chunk_ofs[i]++; chunk_end[i] = 0; } subtract_delta = smallest_delta; sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder); sample_count = (uint32_t) sample_count_f; sample_remainder = sample_count_f - (float) sample_count; hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count; hmp_mdi->extra_info.approx_total_samples += sample_count; while (end_of_chunks < hmp_chunks) { smallest_delta = 0; for (i = 0; i < hmp_chunks; i++) { if (chunk_end[i]) continue; if (chunk_delta[i]) { chunk_delta[i] -= subtract_delta; if (chunk_delta[i]) { if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) { smallest_delta = chunk_delta[i]; } continue; } } do { if (((hmp_chunk[i][0] & 0xf0) == 0xb0 ) && ((hmp_chunk[i][1] == 110) || (hmp_chunk[i][1] == 111)) && (hmp_chunk[i][2] > 0x7f)) { hmp_chunk[i] += 3; } else { uint32_t setup_ret = 0; <S2SV_StartVul> if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], 0)) == 0) { <S2SV_EndVul> goto _hmp_end; } if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x2f) && (hmp_chunk[i][2] == 0x00)) { end_of_chunks++; chunk_end[i] = 1; hmp_chunk[i] += 3; goto NEXT_CHUNK; } else if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x51) && (hmp_chunk[i][2] == 0x03)) { tempo_f = (float)((hmp_chunk[i][3] << 16) + (hmp_chunk[i][4] << 8)+ hmp_chunk[i][5]); if (tempo_f == 0.0) tempo_f = 500000.0; fprintf(stderr,""DEBUG: Tempo change %f\r\n"", tempo_f); } hmp_chunk[i] += setup_ret; } var_len_shift = 0; chunk_delta[i] = 0; <S2SV_StartVul> if (*hmp_chunk[i] < 0x80) { <S2SV_EndVul> do { chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift); var_len_shift += 7; hmp_chunk[i]++; } while (*hmp_chunk[i] < 0x80); } chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift); hmp_chunk[i]++; } while (!chunk_delta[i]); if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) { smallest_delta = chunk_delta[i]; } NEXT_CHUNK: continue; } subtract_delta = smallest_delta; sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder); sample_count = (uint32_t) sample_count_f; sample_remainder = sample_count_f - (float) sample_count; hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count; hmp_mdi->extra_info.approx_total_samples += sample_count; } if ((hmp_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, ""to init reverb"", 0); goto _hmp_end; } hmp_mdi->extra_info.current_sample = 0; hmp_mdi->current_event = &hmp_mdi->events[0]; hmp_mdi->samples_to_mix = 0; hmp_mdi->note = NULL; _WM_ResetToStart(hmp_mdi); _hmp_end: free(hmp_chunk); free(chunk_length); free(chunk_delta); free(chunk_ofs); free(chunk_end); if (hmp_mdi->reverb) return (hmp_mdi); _WM_freeMDI(hmp_mdi); return NULL; }","- if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], 0)) == 0) {
- if (*hmp_chunk[i] < 0x80) {
+ chunk_length[i] -= chunk_ofs[i];
+ chunk_length[i] -= 3;
+ if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], chunk_length[i], 0)) == 0) {
+ chunk_length[i] -= 3;
+ chunk_length[i] -= setup_ret;
+ if (chunk_length[i] && *hmp_chunk[i] < 0x80) {
+ if (! chunk_length[i]) break;
+ chunk_length[i]--;
+ if (! chunk_length[i]) {
+ _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, ""file too short"", 0);
+ goto _hmp_end;
+ }
+ chunk_length[i]--;","_WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) { uint8_t is_hmp2 = 0; uint32_t zero_cnt = 0; uint32_t i = 0; uint32_t hmp_file_length = 0; uint32_t hmp_chunks = 0; uint32_t hmp_divisions = 0; uint32_t hmp_unknown = 0; uint32_t hmp_bpm = 0; uint32_t hmp_song_time = 0; struct _mdi *hmp_mdi; uint8_t **hmp_chunk; uint32_t *chunk_length; uint32_t *chunk_ofs; uint32_t *chunk_delta; uint8_t *chunk_end; uint32_t chunk_num = 0; uint32_t hmp_track = 0; uint32_t smallest_delta = 0; uint32_t subtract_delta = 0; uint32_t end_of_chunks = 0; uint32_t var_len_shift = 0; float tempo_f = 500000.0; float samples_per_delta_f = 0.0; uint32_t sample_count = 0; float sample_count_f = 0; float sample_remainder = 0; if (memcmp(hmp_data, ""HMIMIDIP"", 8)) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0); return NULL; } hmp_data += 8; hmp_size -= 8; if (!memcmp(hmp_data, ""013195"", 6)) { hmp_data += 6; hmp_size -= 6; is_hmp2 = 1; } if (is_hmp2) { zero_cnt = 18; } else { zero_cnt = 24; } for (i = 0; i < zero_cnt; i++) { if (hmp_data[i] != 0) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, NULL, 0); return NULL; } } hmp_data += zero_cnt; hmp_size -= zero_cnt; hmp_file_length = *hmp_data++; hmp_file_length += (*hmp_data++ << 8); hmp_file_length += (*hmp_data++ << 16); hmp_file_length += (*hmp_data++ << 24); hmp_size -= 4; UNUSED(hmp_file_length); hmp_data += 12; hmp_size -= 12; hmp_chunks = *hmp_data++; hmp_chunks += (*hmp_data++ << 8); hmp_chunks += (*hmp_data++ << 16); hmp_chunks += (*hmp_data++ << 24); hmp_size -= 4; hmp_unknown = *hmp_data++; hmp_unknown += (*hmp_data++ << 8); hmp_unknown += (*hmp_data++ << 16); hmp_unknown += (*hmp_data++ << 24); hmp_size -= 4; UNUSED(hmp_unknown); hmp_divisions = 60; hmp_bpm = *hmp_data++; hmp_bpm += (*hmp_data++ << 8); hmp_bpm += (*hmp_data++ << 16); hmp_bpm += (*hmp_data++ << 24); hmp_size -= 4; if ((_WM_MixerOptions & WM_MO_ROUNDTEMPO)) { tempo_f = (float) (60000000 / hmp_bpm) + 0.5f; } else { tempo_f = (float) (60000000 / hmp_bpm); } samples_per_delta_f = _WM_GetSamplesPerTick(hmp_divisions, tempo_f); hmp_song_time = *hmp_data++; hmp_song_time += (*hmp_data++ << 8); hmp_song_time += (*hmp_data++ << 16); hmp_song_time += (*hmp_data++ << 24); hmp_size -= 4; UNUSED(hmp_song_time); if (is_hmp2) { hmp_data += 840; hmp_size -= 840; } else { hmp_data += 712; hmp_size -= 712; } hmp_mdi = _WM_initMDI(); _WM_midi_setup_divisions(hmp_mdi, hmp_divisions); _WM_midi_setup_tempo(hmp_mdi, (uint32_t)tempo_f); hmp_chunk = malloc(sizeof(uint8_t *) * hmp_chunks); chunk_length = malloc(sizeof(uint32_t) * hmp_chunks); chunk_delta = malloc(sizeof(uint32_t) * hmp_chunks); chunk_ofs = malloc(sizeof(uint32_t) * hmp_chunks); chunk_end = malloc(sizeof(uint8_t) * hmp_chunks); smallest_delta = 0xffffffff; for (i = 0; i < hmp_chunks; i++) { hmp_chunk[i] = hmp_data; chunk_ofs[i] = 0; chunk_num = *hmp_data++; chunk_num += (*hmp_data++ << 8); chunk_num += (*hmp_data++ << 16); chunk_num += (*hmp_data++ << 24); chunk_ofs[i] += 4; UNUSED(chunk_num); chunk_length[i] = *hmp_data++; chunk_length[i] += (*hmp_data++ << 8); chunk_length[i] += (*hmp_data++ << 16); chunk_length[i] += (*hmp_data++ << 24); chunk_ofs[i] += 4; if (chunk_length[i] > hmp_size) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, ""file too short"", 0); goto _hmp_end; } hmp_size -= chunk_length[i]; hmp_track = *hmp_data++; hmp_track += (*hmp_data++ << 8); hmp_track += (*hmp_data++ << 16); hmp_track += (*hmp_data++ << 24); chunk_ofs[i] += 4; UNUSED(hmp_track); chunk_delta[i] = 0; var_len_shift = 0; if (*hmp_data < 0x80) { do { chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift); var_len_shift += 7; chunk_ofs[i]++; } while (*hmp_data < 0x80); } chunk_delta[i] = chunk_delta[i] | ((*hmp_data++ & 0x7F) << var_len_shift); chunk_ofs[i]++; if (chunk_delta[i] < smallest_delta) { smallest_delta = chunk_delta[i]; } hmp_data = hmp_chunk[i] + chunk_length[i]; chunk_length[i] -= chunk_ofs[i]; hmp_chunk[i] += chunk_ofs[i]++; chunk_end[i] = 0; } subtract_delta = smallest_delta; sample_count_f = (((float) smallest_delta * samples_per_delta_f) + sample_remainder); sample_count = (uint32_t) sample_count_f; sample_remainder = sample_count_f - (float) sample_count; hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count; hmp_mdi->extra_info.approx_total_samples += sample_count; while (end_of_chunks < hmp_chunks) { smallest_delta = 0; for (i = 0; i < hmp_chunks; i++) { if (chunk_end[i]) continue; if (chunk_delta[i]) { chunk_delta[i] -= subtract_delta; if (chunk_delta[i]) { if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) { smallest_delta = chunk_delta[i]; } continue; } } do { if (((hmp_chunk[i][0] & 0xf0) == 0xb0 ) && ((hmp_chunk[i][1] == 110) || (hmp_chunk[i][1] == 111)) && (hmp_chunk[i][2] > 0x7f)) { hmp_chunk[i] += 3; chunk_length[i] -= 3; } else { uint32_t setup_ret = 0; if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], chunk_length[i], 0)) == 0) { goto _hmp_end; } if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x2f) && (hmp_chunk[i][2] == 0x00)) { end_of_chunks++; chunk_end[i] = 1; chunk_length[i] -= 3; hmp_chunk[i] += 3; goto NEXT_CHUNK; } else if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x51) && (hmp_chunk[i][2] == 0x03)) { tempo_f = (float)((hmp_chunk[i][3] << 16) + (hmp_chunk[i][4] << 8)+ hmp_chunk[i][5]); if (tempo_f == 0.0) tempo_f = 500000.0; fprintf(stderr,""DEBUG: Tempo change %f\r\n"", tempo_f); } hmp_chunk[i] += setup_ret; chunk_length[i] -= setup_ret; } var_len_shift = 0; chunk_delta[i] = 0; if (chunk_length[i] && *hmp_chunk[i] < 0x80) { do { if (! chunk_length[i]) break; chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift); var_len_shift += 7; hmp_chunk[i]++; chunk_length[i]--; } while (*hmp_chunk[i] < 0x80); } if (! chunk_length[i]) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, ""file too short"", 0); goto _hmp_end; } chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift); hmp_chunk[i]++; chunk_length[i]--; } while (!chunk_delta[i]); if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) { smallest_delta = chunk_delta[i]; } NEXT_CHUNK: continue; } subtract_delta = smallest_delta; sample_count_f= (((float) smallest_delta * samples_per_delta_f) + sample_remainder); sample_count = (uint32_t) sample_count_f; sample_remainder = sample_count_f - (float) sample_count; hmp_mdi->events[hmp_mdi->event_count - 1].samples_to_next += sample_count; hmp_mdi->extra_info.approx_total_samples += sample_count; } if ((hmp_mdi->reverb = _WM_init_reverb(_WM_SampleRate, _WM_reverb_room_width, _WM_reverb_room_length, _WM_reverb_listen_posx, _WM_reverb_listen_posy)) == NULL) { _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_MEM, ""to init reverb"", 0); goto _hmp_end; } hmp_mdi->extra_info.current_sample = 0; hmp_mdi->current_event = &hmp_mdi->events[0]; hmp_mdi->samples_to_mix = 0; hmp_mdi->note = NULL; _WM_ResetToStart(hmp_mdi); _hmp_end: free(hmp_chunk); free(chunk_length); free(chunk_delta); free(chunk_ofs); free(chunk_end); if (hmp_mdi->reverb) return (hmp_mdi); _WM_freeMDI(hmp_mdi); return NULL; }"
559,2182----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7500--verify.c----rpmfilesVerify,"rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask) { rpm_mode_t fmode = rpmfilesFMode(fi, ix); rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix); rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix); const char * fn = rpmfilesFN(fi, ix); struct stat sb; rpmVerifyAttrs vfy = RPMVERIFY_NONE; switch (rpmfilesFState(fi, ix)) { case RPMFILE_STATE_NETSHARED: case RPMFILE_STATE_NOTINSTALLED: goto exit; break; case RPMFILE_STATE_REPLACED: flags = RPMVERIFY_LSTATFAIL; break; case RPMFILE_STATE_WRONGCOLOR: flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV); break; case RPMFILE_STATE_NORMAL: case RPMFILE_STATE_MISSING: break; } if (fn == NULL || lstat(fn, &sb) != 0) { vfy |= RPMVERIFY_LSTATFAIL; goto exit; } <S2SV_StartVul> if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) { <S2SV_EndVul> <S2SV_StartVul> vfy |= RPMVERIFY_LSTATFAIL; <S2SV_EndVul> <S2SV_StartVul> goto exit; <S2SV_EndVul> } if (S_ISLNK(sb.st_mode)) flags &= ~(RPMVERIFY_MODE); else flags &= ~(RPMVERIFY_LINKTO); if (!S_ISREG(sb.st_mode)) flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS); if (fileAttrs & RPMFILE_GHOST) flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO); flags &= ~(omitMask | RPMVERIFY_FAILURES); if (flags & RPMVERIFY_FILEDIGEST) { const unsigned char *digest; int algo; size_t diglen; if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) { unsigned char fdigest[diglen]; rpm_loff_t fsize; if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) { vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST); } else { sb.st_size = fsize; if (memcmp(fdigest, digest, diglen)) vfy |= RPMVERIFY_FILEDIGEST; } } else { vfy |= RPMVERIFY_FILEDIGEST; } } if (flags & RPMVERIFY_LINKTO) { char linkto[1024+1]; int size = 0; if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1) vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO); else { const char * flink = rpmfilesFLink(fi, ix); linkto[size] = '\0'; if (flink == NULL || !rstreq(linkto, flink)) vfy |= RPMVERIFY_LINKTO; } } if (flags & RPMVERIFY_FILESIZE) { if (sb.st_size != rpmfilesFSize(fi, ix)) vfy |= RPMVERIFY_FILESIZE; } if (flags & RPMVERIFY_MODE) { rpm_mode_t metamode = fmode; rpm_mode_t filemode; filemode = (rpm_mode_t)sb.st_mode; if (fileAttrs & RPMFILE_GHOST) { metamode &= ~0xf000; filemode &= ~0xf000; } if (metamode != filemode) vfy |= RPMVERIFY_MODE; #if WITH_ACL acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS); if (facl) { if (acl_equiv_mode(facl, NULL) == 1) { vfy |= RPMVERIFY_MODE; } acl_free(facl); } #endif } if (flags & RPMVERIFY_RDEV) { if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode) || S_ISBLK(fmode) != S_ISBLK(sb.st_mode)) { vfy |= RPMVERIFY_RDEV; } else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) { rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff); rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff); if (st_rdev != frdev) vfy |= RPMVERIFY_RDEV; } } #if WITH_CAP if (flags & RPMVERIFY_CAPS) { cap_t cap, fcap; cap = cap_from_text(rpmfilesFCaps(fi, ix)); if (!cap) { cap = cap_from_text(""=""); } fcap = cap_get_file(fn); if (!fcap) { fcap = cap_from_text(""=""); } if (cap_compare(cap, fcap) != 0) vfy |= RPMVERIFY_CAPS; cap_free(fcap); cap_free(cap); } #endif if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) { vfy |= RPMVERIFY_MTIME; } if (flags & RPMVERIFY_USER) { const char * name = rpmugUname(sb.st_uid); const char * fuser = rpmfilesFUser(fi, ix); uid_t uid; int namematch = 0; int idmatch = 0; if (name && fuser) namematch = rstreq(name, fuser); if (fuser && rpmugUid(fuser, &uid) == 0) idmatch = (uid == sb.st_uid); if (namematch != idmatch) { rpmlog(RPMLOG_WARNING, _(""Duplicate username or UID for user %s\n""), fuser); } if (!(namematch || idmatch)) vfy |= RPMVERIFY_USER; } if (flags & RPMVERIFY_GROUP) { const char * name = rpmugGname(sb.st_gid); const char * fgroup = rpmfilesFGroup(fi, ix); gid_t gid; int namematch = 0; int idmatch = 0; if (name && fgroup) namematch = rstreq(name, fgroup); if (fgroup && rpmugGid(fgroup, &gid) == 0) idmatch = (gid == sb.st_gid); if (namematch != idmatch) { rpmlog(RPMLOG_WARNING, _(""Duplicate groupname or GID for group %s\n""), fgroup); } if (!(namematch || idmatch)) vfy |= RPMVERIFY_GROUP; } exit: return vfy; }","- if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {
- vfy |= RPMVERIFY_LSTATFAIL;
- goto exit;
+ if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {
+ struct stat dsb;
+ if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {
+ uid_t fuid;
+ if (sb.st_uid == 0 ||
+ (rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&
+ sb.st_uid == fuid)) {
+ }
+ }","rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask) { rpm_mode_t fmode = rpmfilesFMode(fi, ix); rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix); rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix); const char * fn = rpmfilesFN(fi, ix); struct stat sb; rpmVerifyAttrs vfy = RPMVERIFY_NONE; switch (rpmfilesFState(fi, ix)) { case RPMFILE_STATE_NETSHARED: case RPMFILE_STATE_NOTINSTALLED: goto exit; break; case RPMFILE_STATE_REPLACED: flags = RPMVERIFY_LSTATFAIL; break; case RPMFILE_STATE_WRONGCOLOR: flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_RDEV); break; case RPMFILE_STATE_NORMAL: case RPMFILE_STATE_MISSING: break; } if (fn == NULL || lstat(fn, &sb) != 0) { vfy |= RPMVERIFY_LSTATFAIL; goto exit; } if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) { struct stat dsb; if (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) { uid_t fuid; if (sb.st_uid == 0 || (rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 && sb.st_uid == fuid)) { sb = dsb; } } } if (S_ISLNK(sb.st_mode)) flags &= ~(RPMVERIFY_MODE); else flags &= ~(RPMVERIFY_LINKTO); if (!S_ISREG(sb.st_mode)) flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_CAPS); if (fileAttrs & RPMFILE_GHOST) flags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE | RPMVERIFY_MTIME | RPMVERIFY_LINKTO); flags &= ~(omitMask | RPMVERIFY_FAILURES); if (flags & RPMVERIFY_FILEDIGEST) { const unsigned char *digest; int algo; size_t diglen; if ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) { unsigned char fdigest[diglen]; rpm_loff_t fsize; if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) { vfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST); } else { sb.st_size = fsize; if (memcmp(fdigest, digest, diglen)) vfy |= RPMVERIFY_FILEDIGEST; } } else { vfy |= RPMVERIFY_FILEDIGEST; } } if (flags & RPMVERIFY_LINKTO) { char linkto[1024+1]; int size = 0; if ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1) vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO); else { const char * flink = rpmfilesFLink(fi, ix); linkto[size] = '\0'; if (flink == NULL || !rstreq(linkto, flink)) vfy |= RPMVERIFY_LINKTO; } } if (flags & RPMVERIFY_FILESIZE) { if (sb.st_size != rpmfilesFSize(fi, ix)) vfy |= RPMVERIFY_FILESIZE; } if (flags & RPMVERIFY_MODE) { rpm_mode_t metamode = fmode; rpm_mode_t filemode; filemode = (rpm_mode_t)sb.st_mode; if (fileAttrs & RPMFILE_GHOST) { metamode &= ~0xf000; filemode &= ~0xf000; } if (metamode != filemode) vfy |= RPMVERIFY_MODE; #if WITH_ACL acl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS); if (facl) { if (acl_equiv_mode(facl, NULL) == 1) { vfy |= RPMVERIFY_MODE; } acl_free(facl); } #endif } if (flags & RPMVERIFY_RDEV) { if (S_ISCHR(fmode) != S_ISCHR(sb.st_mode) || S_ISBLK(fmode) != S_ISBLK(sb.st_mode)) { vfy |= RPMVERIFY_RDEV; } else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) { rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff); rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff); if (st_rdev != frdev) vfy |= RPMVERIFY_RDEV; } } #if WITH_CAP if (flags & RPMVERIFY_CAPS) { cap_t cap, fcap; cap = cap_from_text(rpmfilesFCaps(fi, ix)); if (!cap) { cap = cap_from_text(""=""); } fcap = cap_get_file(fn); if (!fcap) { fcap = cap_from_text(""=""); } if (cap_compare(cap, fcap) != 0) vfy |= RPMVERIFY_CAPS; cap_free(fcap); cap_free(cap); } #endif if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) { vfy |= RPMVERIFY_MTIME; } if (flags & RPMVERIFY_USER) { const char * name = rpmugUname(sb.st_uid); const char * fuser = rpmfilesFUser(fi, ix); uid_t uid; int namematch = 0; int idmatch = 0; if (name && fuser) namematch = rstreq(name, fuser); if (fuser && rpmugUid(fuser, &uid) == 0) idmatch = (uid == sb.st_uid); if (namematch != idmatch) { rpmlog(RPMLOG_WARNING, _(""Duplicate username or UID for user %s\n""), fuser); } if (!(namematch || idmatch)) vfy |= RPMVERIFY_USER; } if (flags & RPMVERIFY_GROUP) { const char * name = rpmugGname(sb.st_gid); const char * fgroup = rpmfilesFGroup(fi, ix); gid_t gid; int namematch = 0; int idmatch = 0; if (name && fgroup) namematch = rstreq(name, fgroup); if (fgroup && rpmugGid(fgroup, &gid) == 0) idmatch = (gid == sb.st_gid); if (namematch != idmatch) { rpmlog(RPMLOG_WARNING, _(""Duplicate groupname or GID for group %s\n""), fgroup); } if (!(namematch || idmatch)) vfy |= RPMVERIFY_GROUP; } exit: return vfy; }"
560,5987----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cmd_api.c----r_cmd_alias_get,"R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) { r_return_val_if_fail (cmd && cmd->aliases && k, NULL); <S2SV_StartVul> return ht_pp_find(cmd->aliases, k, NULL); <S2SV_EndVul> }","- return ht_pp_find(cmd->aliases, k, NULL);
+ return ht_pp_find (cmd->aliases, k, NULL);","R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) { r_return_val_if_fail (cmd && cmd->aliases && k, NULL); return ht_pp_find (cmd->aliases, k, NULL); }"
561,6995----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/utils.c----mount_proc_if_needed,"int mount_proc_if_needed(const char *rootfs) { char path[MAXPATHLEN]; char link[20]; int linklen, ret; int mypid; ret = snprintf(path, MAXPATHLEN, ""%s/proc/self"", rootfs); if (ret < 0 || ret >= MAXPATHLEN) { SYSERROR(""proc path name too long""); return -1; } memset(link, 0, 20); linklen = readlink(path, link, 20); mypid = (int)getpid(); INFO(""I am %d, /proc/self points to '%s'"", mypid, link); ret = snprintf(path, MAXPATHLEN, ""%s/proc"", rootfs); if (ret < 0 || ret >= MAXPATHLEN) { SYSERROR(""proc path name too long""); return -1; } if (linklen < 0) goto domount; if (atoi(link) != mypid) { umount2(path, MNT_DETACH); goto domount; } return 0; domount: <S2SV_StartVul> if (mount(""proc"", path, ""proc"", 0, NULL)) <S2SV_EndVul> return -1; INFO(""Mounted /proc in container for security transition""); return 1; }","- if (mount(""proc"", path, ""proc"", 0, NULL))
+ if (safe_mount(""proc"", path, ""proc"", 0, NULL, rootfs) < 0)","int mount_proc_if_needed(const char *rootfs) { char path[MAXPATHLEN]; char link[20]; int linklen, ret; int mypid; ret = snprintf(path, MAXPATHLEN, ""%s/proc/self"", rootfs); if (ret < 0 || ret >= MAXPATHLEN) { SYSERROR(""proc path name too long""); return -1; } memset(link, 0, 20); linklen = readlink(path, link, 20); mypid = (int)getpid(); INFO(""I am %d, /proc/self points to '%s'"", mypid, link); ret = snprintf(path, MAXPATHLEN, ""%s/proc"", rootfs); if (ret < 0 || ret >= MAXPATHLEN) { SYSERROR(""proc path name too long""); return -1; } if (linklen < 0) goto domount; if (atoi(link) != mypid) { umount2(path, MNT_DETACH); goto domount; } return 0; domount: if (safe_mount(""proc"", path, ""proc"", 0, NULL, rootfs) < 0) return -1; INFO(""Mounted /proc in container for security transition""); return 1; }"
562,943----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9120--ion.c----ion_handle_put,"<S2SV_StartVul> static int ion_handle_put(struct ion_handle *handle) <S2SV_EndVul> { struct ion_client *client = handle->client; int ret; mutex_lock(&client->lock); <S2SV_StartVul> ret = kref_put(&handle->ref, ion_handle_destroy); <S2SV_EndVul> mutex_unlock(&client->lock); return ret; }","- static int ion_handle_put(struct ion_handle *handle)
- ret = kref_put(&handle->ref, ion_handle_destroy);
+ static int ion_handle_put(struct ion_handle *handle)
+ static int ion_handle_put_nolock(struct ion_handle *handle)
+ {
+ 
+ 
+ return ret;
+ 
+ mutex_lock(&client->lock);","static int ion_handle_put(struct ion_handle *handle) static int ion_handle_put_nolock(struct ion_handle *handle) { int ret; ret = kref_put(&handle->ref, ion_handle_destroy); return ret; } int ion_handle_put(struct ion_handle *handle) { struct ion_client *client = handle->client; int ret; mutex_lock(&client->lock); ret = ion_handle_put_nolock(handle); mutex_unlock(&client->lock); return ret; }"
563,3897----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pegasus.c----set_register,"static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data) { int ret; ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0), PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data, <S2SV_StartVul> indx, &data, 1, 1000); <S2SV_EndVul> if (ret < 0) netif_dbg(pegasus, drv, pegasus->net, ""%s returned %d\n"", __func__, ret); return ret; }","- indx, &data, 1, 1000);
+ u8 *buf;
+ buf = kmemdup(&data, 1, GFP_NOIO);
+ if (!buf)
+ return -ENOMEM;
+ indx, buf, 1, 1000);
+ kfree(buf);","static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data) { u8 *buf; int ret; buf = kmemdup(&data, 1, GFP_NOIO); if (!buf) return -ENOMEM; ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0), PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data, indx, buf, 1, 1000); if (ret < 0) netif_dbg(pegasus, drv, pegasus->net, ""%s returned %d\n"", __func__, ret); kfree(buf); return ret; }"
564,6707----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inotify_user.c----inotify_new_group,"<S2SV_StartVul> static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events) <S2SV_EndVul> { struct fsnotify_group *group; group = fsnotify_alloc_group(&inotify_fsnotify_ops); if (IS_ERR(group)) return group; group->max_events = max_events; spin_lock_init(&group->inotify_data.idr_lock); idr_init(&group->inotify_data.idr); group->inotify_data.last_wd = 0; <S2SV_StartVul> group->inotify_data.user = user; <S2SV_EndVul> group->inotify_data.fa = NULL; return group; }","- static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)
- group->inotify_data.user = user;
+ static struct fsnotify_group *inotify_new_group(unsigned int max_events)
+ group->inotify_data.user = get_current_user();
+ if (atomic_inc_return(&group->inotify_data.user->inotify_devs) >
+ inotify_max_user_instances) {
+ fsnotify_put_group(group);
+ return ERR_PTR(-EMFILE);
+ }",static struct fsnotify_group *inotify_new_group(unsigned int max_events) { struct fsnotify_group *group; group = fsnotify_alloc_group(&inotify_fsnotify_ops); if (IS_ERR(group)) return group; group->max_events = max_events; spin_lock_init(&group->inotify_data.idr_lock); idr_init(&group->inotify_data.idr); group->inotify_data.last_wd = 0; group->inotify_data.fa = NULL; group->inotify_data.user = get_current_user(); if (atomic_inc_return(&group->inotify_data.user->inotify_devs) > inotify_max_user_instances) { fsnotify_put_group(group); return ERR_PTR(-EMFILE); } return group; }
565,3915----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/quantum-export.c----ExportRedQuantum,"static void ExportRedQuantum(QuantumInfo *quantum_info, const MagickSizeType number_pixels,const PixelPacket *magick_restrict p, unsigned char *magick_restrict q) { QuantumAny range; ssize_t x; switch (quantum_info->depth) { case 8: { unsigned char pixel; for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToChar(GetPixelRed(p)); q=PopCharPixel(pixel,q); p++; q+=quantum_info->pad; } break; } case 16: { unsigned short pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToShort(GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 32: { unsigned int pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToLong(GetPixelRed(p)); q=PopLongPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 64: { if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q); p++; q+=quantum_info->pad; } break; } } default: { range=GetQuantumRange(quantum_info->depth); for (x=0; x < (ssize_t) number_pixels; x++) { <S2SV_StartVul> q=PopQuantumPixel(quantum_info, <S2SV_EndVul> <S2SV_StartVul> ScaleQuantumToAny(GetPixelRed(p),range),q); <S2SV_EndVul> p++; q+=quantum_info->pad; } break; } } }","- q=PopQuantumPixel(quantum_info,
- ScaleQuantumToAny(GetPixelRed(p),range),q);
+ q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(p),range),
+ q);","static void ExportRedQuantum(QuantumInfo *quantum_info, const MagickSizeType number_pixels,const PixelPacket *magick_restrict p, unsigned char *magick_restrict q) { QuantumAny range; ssize_t x; switch (quantum_info->depth) { case 8: { unsigned char pixel; for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToChar(GetPixelRed(p)); q=PopCharPixel(pixel,q); p++; q+=quantum_info->pad; } break; } case 16: { unsigned short pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToShort(GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 32: { unsigned int pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToLong(GetPixelRed(p)); q=PopLongPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 64: { if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q); p++; q+=quantum_info->pad; } break; } } default: { range=GetQuantumRange(quantum_info->depth); for (x=0; x < (ssize_t) number_pixels; x++) { q=PopQuantumPixel(quantum_info,ScaleQuantumToAny(GetPixelRed(p),range), q); p++; q+=quantum_info->pad; } break; } } }"
566,4327----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/udp.c----udpSendDatagram,"error_t udpSendDatagram(Socket *socket, const SocketMsg *message, uint_t flags) { error_t error; size_t offset; NetBuffer *buffer; NetTxAncillary ancillary; buffer = udpAllocBuffer(0, &offset); if(buffer == NULL) return ERROR_OUT_OF_MEMORY; error = netBufferAppend(buffer, message->data, message->length); if(!error) { ancillary = NET_DEFAULT_TX_ANCILLARY; if(message->ttl != 0) { ancillary.ttl = message->ttl; } else if(ipIsMulticastAddr(&message->destIpAddr)) { ancillary.ttl = socket->multicastTtl; } else { ancillary.ttl = socket->ttl; } if(flags & SOCKET_FLAG_DONT_ROUTE) { ancillary.dontRoute = TRUE; } #if (IP_DIFF_SERV_SUPPORT == ENABLED) ancillary.dscp = socket->dscp; #endif #if (ETH_SUPPORT == ENABLED) ancillary.srcMacAddr = message->srcMacAddr; ancillary.destMacAddr = message->destMacAddr; #endif #if (ETH_VLAN_SUPPORT == ENABLED) ancillary.vlanPcp = socket->vlanPcp; ancillary.vlanDei = socket->vlanDei; #endif #if (ETH_VMAN_SUPPORT == ENABLED) ancillary.vmanPcp = socket->vmanPcp; ancillary.vmanDei = socket->vmanDei; #endif #if (ETH_PORT_TAGGING_SUPPORT == ENABLED) ancillary.port = message->switchPort; #endif #if (ETH_TIMESTAMP_SUPPORT == ENABLED) ancillary.timestampId = message->timestampId; #endif <S2SV_StartVul> error = udpSendBuffer(socket->interface, &message->srcIpAddr, <S2SV_EndVul> <S2SV_StartVul> socket->localPort, &message->destIpAddr, message->destPort, buffer, <S2SV_EndVul> <S2SV_StartVul> offset, &ancillary); <S2SV_EndVul> } netBufferFree(buffer); return error; }","- error = udpSendBuffer(socket->interface, &message->srcIpAddr,
- socket->localPort, &message->destIpAddr, message->destPort, buffer,
- offset, &ancillary);
+ NetInterface *interface;
+ if(message->interface != NULL)
+ {
+ interface = message->interface;
+ }
+ else
+ {
+ interface = socket->interface;
+ }
+ error = udpSendBuffer(interface, &message->srcIpAddr, socket->localPort,
+ &message->destIpAddr, message->destPort, buffer, offset, &ancillary);","error_t udpSendDatagram(Socket *socket, const SocketMsg *message, uint_t flags) { error_t error; size_t offset; NetBuffer *buffer; NetInterface *interface; NetTxAncillary ancillary; if(message->interface != NULL) { interface = message->interface; } else { interface = socket->interface; } buffer = udpAllocBuffer(0, &offset); if(buffer == NULL) return ERROR_OUT_OF_MEMORY; error = netBufferAppend(buffer, message->data, message->length); if(!error) { ancillary = NET_DEFAULT_TX_ANCILLARY; if(message->ttl != 0) { ancillary.ttl = message->ttl; } else if(ipIsMulticastAddr(&message->destIpAddr)) { ancillary.ttl = socket->multicastTtl; } else { ancillary.ttl = socket->ttl; } if(flags & SOCKET_FLAG_DONT_ROUTE) { ancillary.dontRoute = TRUE; } #if (IP_DIFF_SERV_SUPPORT == ENABLED) ancillary.dscp = socket->dscp; #endif #if (ETH_SUPPORT == ENABLED) ancillary.srcMacAddr = message->srcMacAddr; ancillary.destMacAddr = message->destMacAddr; #endif #if (ETH_VLAN_SUPPORT == ENABLED) ancillary.vlanPcp = socket->vlanPcp; ancillary.vlanDei = socket->vlanDei; #endif #if (ETH_VMAN_SUPPORT == ENABLED) ancillary.vmanPcp = socket->vmanPcp; ancillary.vmanDei = socket->vmanDei; #endif #if (ETH_PORT_TAGGING_SUPPORT == ENABLED) ancillary.port = message->switchPort; #endif #if (ETH_TIMESTAMP_SUPPORT == ENABLED) ancillary.timestampId = message->timestampId; #endif error = udpSendBuffer(interface, &message->srcIpAddr, socket->localPort, &message->destIpAddr, message->destPort, buffer, offset, &ancillary); } netBufferFree(buffer); return error; }"
567,3137----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/events_base.c----__xen_evtchn_do_upcall,static void __xen_evtchn_do_upcall(void) { struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu); int cpu = smp_processor_id(); read_lock(&evtchn_rwlock); do { vcpu_info->evtchn_upcall_pending = 0; <S2SV_StartVul> xen_evtchn_handle_events(cpu); <S2SV_EndVul> BUG_ON(!irqs_disabled()); virt_rmb(); } while (vcpu_info->evtchn_upcall_pending); read_unlock(&evtchn_rwlock); },"- xen_evtchn_handle_events(cpu);
+ struct evtchn_loop_ctrl ctrl = { 0 };
+ xen_evtchn_handle_events(cpu, &ctrl);
+ __this_cpu_inc(irq_epoch);","static void __xen_evtchn_do_upcall(void) { struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu); int cpu = smp_processor_id(); struct evtchn_loop_ctrl ctrl = { 0 }; read_lock(&evtchn_rwlock); do { vcpu_info->evtchn_upcall_pending = 0; xen_evtchn_handle_events(cpu, &ctrl); BUG_ON(!irqs_disabled()); virt_rmb(); } while (vcpu_info->evtchn_upcall_pending); read_unlock(&evtchn_rwlock); __this_cpu_inc(irq_epoch); }"
568,1751----CWE-284----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10030--req.c----_prolog_error,"_prolog_error(batch_job_launch_msg_t *req, int rc) { char *err_name_ptr, err_name[256], path_name[MAXPATHLEN]; char *fmt_char; int fd; if (req->std_err || req->std_out) { if (req->std_err) strncpy(err_name, req->std_err, sizeof(err_name)); else strncpy(err_name, req->std_out, sizeof(err_name)); if ((fmt_char = strchr(err_name, (int) '%')) && (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) { char tmp_name[256]; fmt_char[1] = 'u'; snprintf(tmp_name, sizeof(tmp_name), err_name, req->job_id); strncpy(err_name, tmp_name, sizeof(err_name)); } } else { snprintf(err_name, sizeof(err_name), ""slurm-%u.out"", req->job_id); } err_name_ptr = err_name; if (err_name_ptr[0] == '/') snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr); else if (req->work_dir) snprintf(path_name, MAXPATHLEN, ""%s/%s"", req->work_dir, err_name_ptr); else snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr); if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) { <S2SV_StartVul> error(""Unable to open %s: %s"", path_name, <S2SV_EndVul> <S2SV_StartVul> slurm_strerror(errno)); <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> } snprintf(err_name, sizeof(err_name), ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc)); safe_write(fd, err_name, strlen(err_name)); if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) { snprintf(err_name, sizeof(err_name), ""Couldn't change fd owner to %u:%u: %m\n"", req->uid, req->gid); } rwfail: close(fd); }","- error(""Unable to open %s: %s"", path_name,
- slurm_strerror(errno));
- return;
+ if ((fd = _open_as_other(path_name, req)) == -1) {
+ error(""Unable to open %s: Permission denied"", path_name);","_prolog_error(batch_job_launch_msg_t *req, int rc) { char *err_name_ptr, err_name[256], path_name[MAXPATHLEN]; char *fmt_char; int fd; if (req->std_err || req->std_out) { if (req->std_err) strncpy(err_name, req->std_err, sizeof(err_name)); else strncpy(err_name, req->std_out, sizeof(err_name)); if ((fmt_char = strchr(err_name, (int) '%')) && (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) { char tmp_name[256]; fmt_char[1] = 'u'; snprintf(tmp_name, sizeof(tmp_name), err_name, req->job_id); strncpy(err_name, tmp_name, sizeof(err_name)); } } else { snprintf(err_name, sizeof(err_name), ""slurm-%u.out"", req->job_id); } err_name_ptr = err_name; if (err_name_ptr[0] == '/') snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr); else if (req->work_dir) snprintf(path_name, MAXPATHLEN, ""%s/%s"", req->work_dir, err_name_ptr); else snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr); if ((fd = _open_as_other(path_name, req)) == -1) { error(""Unable to open %s: Permission denied"", path_name); return; } snprintf(err_name, sizeof(err_name), ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc)); safe_write(fd, err_name, strlen(err_name)); if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) { snprintf(err_name, sizeof(err_name), ""Couldn't change fd owner to %u:%u: %m\n"", req->uid, req->gid); } rwfail: close(fd); }"
569,"6400----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/random_poisson_op.cc----tensorflow::functor::PoissonFunctor<CPUDevice,T,U>::operator ( )","void operator()(OpKernelContext* ctx, const CPUDevice& d, const T* rate_flat, int num_rate, int num_samples, const random::PhiloxRandom& rng, U* samples_flat) { typedef random::UniformDistribution<random::PhiloxRandom, CT> Uniform; auto DoWork = [num_samples, num_rate, &rng, samples_flat, rate_flat]( <S2SV_StartVul> int start_output, int limit_output) { <S2SV_EndVul> Uniform uniform; typename Uniform::ResultType uniform_result; for (int64 output_idx = start_output; output_idx < limit_output; ) { const int64 rate_idx = output_idx / num_samples; const CT rate = CT(rate_flat[rate_idx]); auto samples_rate_output = samples_flat + rate_idx; if (rate < CT(10)) { const CT exp_neg_rate = Eigen::numext::exp(-rate); for (int64 sample_idx = output_idx % num_samples; sample_idx < num_samples && output_idx < limit_output; sample_idx++, output_idx++) { random::PhiloxRandom gen = rng; gen.Skip(kReservedSamplesPerOutput * output_idx); int16 uniform_remaining = 0; CT prod = 1; CT x = 0; while (true) { UNIFORM(u); prod = prod * u; if (prod <= exp_neg_rate && x <= CT(Eigen::NumTraits<U>::highest())) { samples_rate_output[sample_idx * num_rate] = U(x); break; } x += 1; } } continue; } using Eigen::numext::log; const CT log_rate = log(rate); const CT b = CT(0.931) + CT(2.53) * Eigen::numext::sqrt(rate); const CT a = CT(-0.059) + CT(0.02483) * b; const CT inv_alpha = CT(1.1239) + CT(1.1328) / (b - CT(3.4)); for (int64 sample_idx = output_idx % num_samples; sample_idx < num_samples && output_idx < limit_output; sample_idx++, output_idx++) { random::PhiloxRandom gen = rng; gen.Skip(kReservedSamplesPerOutput * output_idx); int16 uniform_remaining = 0; while (true) { UNIFORM(u); u -= CT(0.5); UNIFORM(v); CT u_shifted = CT(0.5) - Eigen::numext::abs(u); CT k = Eigen::numext::floor((CT(2) * a / u_shifted + b) * u + rate + CT(0.43)); if (k > CT(Eigen::NumTraits<U>::highest())) { continue; } if (u_shifted >= CT(0.07) && v <= CT(0.9277) - CT(3.6224) / (b - CT(2))) { samples_rate_output[sample_idx * num_rate] = U(k); break; } if (k < 0 || (u_shifted < CT(0.013) && v > u_shifted)) { continue; } CT s = log(v * inv_alpha / (a / (u_shifted * u_shifted) + b)); CT t = -rate + k * log_rate - Eigen::numext::lgamma(k + 1); if (s <= t) { samples_rate_output[sample_idx * num_rate] = U(k); break; } } } } }; static const int kElementCost = 165 + 6 * Uniform::kElementCost + 6 * random::PhiloxRandom::kElementCost; auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); Shard(worker_threads.num_threads, worker_threads.workers, num_rate * num_samples, kElementCost, DoWork); }","- int start_output, int limit_output) {
+ int64 start_output, int64 limit_output) {","void operator()(OpKernelContext* ctx, const CPUDevice& d, const T* rate_flat, int num_rate, int num_samples, const random::PhiloxRandom& rng, U* samples_flat) { typedef random::UniformDistribution<random::PhiloxRandom, CT> Uniform; auto DoWork = [num_samples, num_rate, &rng, samples_flat, rate_flat]( int64 start_output, int64 limit_output) { Uniform uniform; typename Uniform::ResultType uniform_result; for (int64 output_idx = start_output; output_idx < limit_output; ) { const int64 rate_idx = output_idx / num_samples; const CT rate = CT(rate_flat[rate_idx]); auto samples_rate_output = samples_flat + rate_idx; if (rate < CT(10)) { const CT exp_neg_rate = Eigen::numext::exp(-rate); for (int64 sample_idx = output_idx % num_samples; sample_idx < num_samples && output_idx < limit_output; sample_idx++, output_idx++) { random::PhiloxRandom gen = rng; gen.Skip(kReservedSamplesPerOutput * output_idx); int16 uniform_remaining = 0; CT prod = 1; CT x = 0; while (true) { UNIFORM(u); prod = prod * u; if (prod <= exp_neg_rate && x <= CT(Eigen::NumTraits<U>::highest())) { samples_rate_output[sample_idx * num_rate] = U(x); break; } x += 1; } } continue; } using Eigen::numext::log; const CT log_rate = log(rate); const CT b = CT(0.931) + CT(2.53) * Eigen::numext::sqrt(rate); const CT a = CT(-0.059) + CT(0.02483) * b; const CT inv_alpha = CT(1.1239) + CT(1.1328) / (b - CT(3.4)); for (int64 sample_idx = output_idx % num_samples; sample_idx < num_samples && output_idx < limit_output; sample_idx++, output_idx++) { random::PhiloxRandom gen = rng; gen.Skip(kReservedSamplesPerOutput * output_idx); int16 uniform_remaining = 0; while (true) { UNIFORM(u); u -= CT(0.5); UNIFORM(v); CT u_shifted = CT(0.5) - Eigen::numext::abs(u); CT k = Eigen::numext::floor((CT(2) * a / u_shifted + b) * u + rate + CT(0.43)); if (k > CT(Eigen::NumTraits<U>::highest())) { continue; } if (u_shifted >= CT(0.07) && v <= CT(0.9277) - CT(3.6224) / (b - CT(2))) { samples_rate_output[sample_idx * num_rate] = U(k); break; } if (k < 0 || (u_shifted < CT(0.013) && v > u_shifted)) { continue; } CT s = log(v * inv_alpha / (a / (u_shifted * u_shifted) + b)); CT t = -rate + k * log_rate - Eigen::numext::lgamma(k + 1); if (s <= t) { samples_rate_output[sample_idx * num_rate] = U(k); break; } } } } }; static const int kElementCost = 165 + 6 * Uniform::kElementCost + 6 * random::PhiloxRandom::kElementCost; auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); Shard(worker_threads.num_threads, worker_threads.workers, num_rate * num_samples, kElementCost, DoWork); }"
570,7294----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/FileInStream.cxx----FileInStream::pos,"<S2SV_StartVul> int FileInStream::pos() <S2SV_EndVul> { if (!file) throw Exception(""File is not open""); return ftell(file) + ptr - b; }","- int FileInStream::pos()
+ size_t FileInStream::pos()","size_t FileInStream::pos() { if (!file) throw Exception(""File is not open""); return ftell(file) + ptr - b; }"
571,6684----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/LoRaMac.c----ProcessRadioRxDone,"static void ProcessRadioRxDone( void ) { LoRaMacHeader_t macHdr; ApplyCFListParams_t applyCFList; GetPhyParams_t getPhy; PhyParam_t phyParam; LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR; LoRaMacMessageData_t macMsgData; LoRaMacMessageJoinAccept_t macMsgJoinAccept; uint8_t *payload = RxDoneParams.Payload; uint16_t size = RxDoneParams.Size; int16_t rssi = RxDoneParams.Rssi; int8_t snr = RxDoneParams.Snr; uint8_t pktHeaderLen = 0; uint32_t downLinkCounter = 0; uint32_t address = MacCtx.NvmCtx->DevAddr; uint8_t multicast = 0; AddressIdentifier_t addrID = UNICAST_DEV_ADDR; FCntIdentifier_t fCntID; MacCtx.McpsConfirm.AckReceived = false; MacCtx.McpsIndication.Rssi = rssi; MacCtx.McpsIndication.Snr = snr; MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot; MacCtx.McpsIndication.Port = 0; MacCtx.McpsIndication.Multicast = 0; MacCtx.McpsIndication.FramePending = 0; MacCtx.McpsIndication.Buffer = NULL; MacCtx.McpsIndication.BufferSize = 0; MacCtx.McpsIndication.RxData = false; MacCtx.McpsIndication.AckReceived = false; MacCtx.McpsIndication.DownLinkCounter = 0; MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED; MacCtx.McpsIndication.DevAddress = 0; MacCtx.McpsIndication.DeviceTimeAnsReceived = false; Radio.Sleep( ); TimerStop( &MacCtx.RxWindowTimer2 ); if( LoRaMacClassBRxBeacon( payload, size ) == true ) { MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi; MacCtx.MlmeIndication.BeaconInfo.Snr = snr; return; } if( MacCtx.NvmCtx->DeviceClass == CLASS_B ) { if( LoRaMacClassBIsPingExpected( ) == true ) { LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET ); LoRaMacClassBPingSlotTimerEvent( NULL ); MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT; } else if( LoRaMacClassBIsMulticastExpected( ) == true ) { LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET ); LoRaMacClassBMulticastSlotTimerEvent( NULL ); MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT; } } macHdr.Value = payload[pktHeaderLen++]; switch( macHdr.Bits.MType ) { case FRAME_TYPE_JOIN_ACCEPT: macMsgJoinAccept.Buffer = payload; macMsgJoinAccept.BufSize = size; if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept ); if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) { MacCtx.NvmCtx->NetID = ( uint32_t ) macMsgJoinAccept.NetID[0]; MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 ); MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 ); MacCtx.NvmCtx->DevAddr = macMsgJoinAccept.DevAddr; MacCtx.NvmCtx->MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset; MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate; MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate; MacCtx.NvmCtx->MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay; if( MacCtx.NvmCtx->MacParams.ReceiveDelay1 == 0 ) { MacCtx.NvmCtx->MacParams.ReceiveDelay1 = 1; } MacCtx.NvmCtx->MacParams.ReceiveDelay1 *= 1000; MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000; MacCtx.NvmCtx->Version.Fields.Minor = 0; applyCFList.Payload = macMsgJoinAccept.CFList; applyCFList.Size = size - 17; RegionApplyCFList( MacCtx.NvmCtx->Region, &applyCFList ); MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_OTAA; if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) { LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN ); } } else { if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) { LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN ); } } break; case FRAME_TYPE_DATA_CONFIRMED_DOWN: MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED; case FRAME_TYPE_DATA_UNCONFIRMED_DOWN: getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime; getPhy.Datarate = MacCtx.McpsIndication.RxDatarate; getPhy.Attribute = PHY_MAX_PAYLOAD; phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy ); <S2SV_StartVul> if( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t )phyParam.Value ) <S2SV_EndVul> { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } macMsgData.Buffer = payload; macMsgData.BufSize = size; macMsgData.FRMPayload = MacCtx.RxPayload; macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD; if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr; FType_t fType; if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } multicast = 0; downLinkCounter = 0; for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ ) { if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) && ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true ) ) { multicast = 1; addrID = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.GroupID; downLinkCounter = *( MacCtx.NvmCtx->MulticastChannelList[i].DownLinkCounter ); address = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address; if( MacCtx.NvmCtx->DeviceClass == CLASS_C ) { MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST; } break; } } if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) || ( macMsgData.FHDR.FCtrl.Bits.Ack == true ) || ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq == true ) ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } getPhy.Attribute = PHY_MAX_FCNT_GAP; phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy ); macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, MacCtx.NvmCtx->Version, phyParam.Value, &fCntID, &downLinkCounter ); if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS ) { if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED; if( ( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx.NvmCtx->LastRxMic == macMsgData.MIC ) ) { MacCtx.NvmCtx->SrvAckRequested = true; } } else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS; } else { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; } MacCtx.McpsIndication.DownLinkCounter = downLinkCounter; PrepareRxDoneAbort( ); return; } macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData ); if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS ) { if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL; } else { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL; } PrepareRxDoneAbort( ); return; } MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK; MacCtx.McpsIndication.Multicast = multicast; MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending; MacCtx.McpsIndication.Buffer = NULL; MacCtx.McpsIndication.BufferSize = 0; MacCtx.McpsIndication.DownLinkCounter = downLinkCounter; MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack; MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK; MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack; if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) || ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) ) { MacCtx.NvmCtx->AdrAckCounter = 0; } if( multicast == 1 ) { MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST; } else { if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) { MacCtx.NvmCtx->SrvAckRequested = true; if( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) { MacCtx.NvmCtx->LastRxMic = macMsgData.MIC; } MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED; } else { MacCtx.NvmCtx->SrvAckRequested = false; MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED; } } RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest ); switch( fType ) { case FRAME_TYPE_A: { ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot ); MacCtx.McpsIndication.Port = macMsgData.FPort; MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload; MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize; MacCtx.McpsIndication.RxData = true; break; } case FRAME_TYPE_B: { ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot ); MacCtx.McpsIndication.Port = macMsgData.FPort; break; } case FRAME_TYPE_C: { ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot ); MacCtx.McpsIndication.Port = macMsgData.FPort; break; } case FRAME_TYPE_D: { MacCtx.McpsIndication.Port = macMsgData.FPort; MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload; MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize; MacCtx.McpsIndication.RxData = true; break; } default: MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); break; } MacCtx.MacFlags.Bits.McpsInd = 1; break; case FRAME_TYPE_PROPRIETARY: memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen ); MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY; MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK; MacCtx.McpsIndication.Buffer = MacCtx.RxPayload; MacCtx.McpsIndication.BufferSize = size - pktHeaderLen; MacCtx.MacFlags.Bits.McpsInd = 1; break; default: MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); break; } if( MacCtx.NodeAckRequested == true ) { if( MacCtx.McpsConfirm.AckReceived == true ) { OnAckTimeoutTimerEvent( NULL ); } } else { if( MacCtx.NvmCtx->DeviceClass == CLASS_C ) { OnAckTimeoutTimerEvent( NULL ); } } MacCtx.MacFlags.Bits.MacDone = 1; UpdateRxSlotIdleState( ); }","- if( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t )phyParam.Value )
+ if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
+ {
+ MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
+ PrepareRxDoneAbort( );
+ return;
+ }
+ if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
+ ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) )","static void ProcessRadioRxDone( void ) { LoRaMacHeader_t macHdr; ApplyCFListParams_t applyCFList; GetPhyParams_t getPhy; PhyParam_t phyParam; LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR; LoRaMacMessageData_t macMsgData; LoRaMacMessageJoinAccept_t macMsgJoinAccept; uint8_t *payload = RxDoneParams.Payload; uint16_t size = RxDoneParams.Size; int16_t rssi = RxDoneParams.Rssi; int8_t snr = RxDoneParams.Snr; uint8_t pktHeaderLen = 0; uint32_t downLinkCounter = 0; uint32_t address = MacCtx.NvmCtx->DevAddr; uint8_t multicast = 0; AddressIdentifier_t addrID = UNICAST_DEV_ADDR; FCntIdentifier_t fCntID; MacCtx.McpsConfirm.AckReceived = false; MacCtx.McpsIndication.Rssi = rssi; MacCtx.McpsIndication.Snr = snr; MacCtx.McpsIndication.RxSlot = MacCtx.RxSlot; MacCtx.McpsIndication.Port = 0; MacCtx.McpsIndication.Multicast = 0; MacCtx.McpsIndication.FramePending = 0; MacCtx.McpsIndication.Buffer = NULL; MacCtx.McpsIndication.BufferSize = 0; MacCtx.McpsIndication.RxData = false; MacCtx.McpsIndication.AckReceived = false; MacCtx.McpsIndication.DownLinkCounter = 0; MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED; MacCtx.McpsIndication.DevAddress = 0; MacCtx.McpsIndication.DeviceTimeAnsReceived = false; Radio.Sleep( ); TimerStop( &MacCtx.RxWindowTimer2 ); if( LoRaMacClassBRxBeacon( payload, size ) == true ) { MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi; MacCtx.MlmeIndication.BeaconInfo.Snr = snr; return; } if( MacCtx.NvmCtx->DeviceClass == CLASS_B ) { if( LoRaMacClassBIsPingExpected( ) == true ) { LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET ); LoRaMacClassBPingSlotTimerEvent( NULL ); MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT; } else if( LoRaMacClassBIsMulticastExpected( ) == true ) { LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET ); LoRaMacClassBMulticastSlotTimerEvent( NULL ); MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT; } } macHdr.Value = payload[pktHeaderLen++]; switch( macHdr.Bits.MType ) { case FRAME_TYPE_JOIN_ACCEPT: if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } macMsgJoinAccept.Buffer = payload; macMsgJoinAccept.BufSize = size; if( MacCtx.NvmCtx->NetworkActivation != ACTIVATION_TYPE_NONE ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept ); if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) { MacCtx.NvmCtx->NetID = ( uint32_t ) macMsgJoinAccept.NetID[0]; MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 ); MacCtx.NvmCtx->NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 ); MacCtx.NvmCtx->DevAddr = macMsgJoinAccept.DevAddr; MacCtx.NvmCtx->MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset; MacCtx.NvmCtx->MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate; MacCtx.NvmCtx->MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate; MacCtx.NvmCtx->MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay; if( MacCtx.NvmCtx->MacParams.ReceiveDelay1 == 0 ) { MacCtx.NvmCtx->MacParams.ReceiveDelay1 = 1; } MacCtx.NvmCtx->MacParams.ReceiveDelay1 *= 1000; MacCtx.NvmCtx->MacParams.ReceiveDelay2 = MacCtx.NvmCtx->MacParams.ReceiveDelay1 + 1000; MacCtx.NvmCtx->Version.Fields.Minor = 0; applyCFList.Payload = macMsgJoinAccept.CFList; applyCFList.Size = size - 17; RegionApplyCFList( MacCtx.NvmCtx->Region, &applyCFList ); MacCtx.NvmCtx->NetworkActivation = ACTIVATION_TYPE_OTAA; if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) { LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN ); } } else { if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true ) { LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN ); } } break; case FRAME_TYPE_DATA_CONFIRMED_DOWN: MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED; case FRAME_TYPE_DATA_UNCONFIRMED_DOWN: getPhy.UplinkDwellTime = MacCtx.NvmCtx->MacParams.DownlinkDwellTime; getPhy.Datarate = MacCtx.McpsIndication.RxDatarate; getPhy.Attribute = PHY_MAX_PAYLOAD; phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy ); if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) || ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } macMsgData.Buffer = payload; macMsgData.BufSize = size; macMsgData.FRMPayload = MacCtx.RxPayload; macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD; if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr; FType_t fType; if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } multicast = 0; downLinkCounter = 0; for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ ) { if( ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) && ( MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.IsEnabled == true ) ) { multicast = 1; addrID = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.GroupID; downLinkCounter = *( MacCtx.NvmCtx->MulticastChannelList[i].DownLinkCounter ); address = MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address; if( MacCtx.NvmCtx->DeviceClass == CLASS_C ) { MacCtx.McpsIndication.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST; } break; } } if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) || ( macMsgData.FHDR.FCtrl.Bits.Ack == true ) || ( macMsgData.FHDR.FCtrl.Bits.AdrAckReq == true ) ) ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); return; } getPhy.Attribute = PHY_MAX_FCNT_GAP; phyParam = RegionGetPhyParam( MacCtx.NvmCtx->Region, &getPhy ); macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, MacCtx.NvmCtx->Version, phyParam.Value, &fCntID, &downLinkCounter ); if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS ) { if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED; if( ( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx.NvmCtx->LastRxMic == macMsgData.MIC ) ) { MacCtx.NvmCtx->SrvAckRequested = true; } } else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS; } else { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; } MacCtx.McpsIndication.DownLinkCounter = downLinkCounter; PrepareRxDoneAbort( ); return; } macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData ); if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS ) { if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS ) { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL; } else { MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL; } PrepareRxDoneAbort( ); return; } MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK; MacCtx.McpsIndication.Multicast = multicast; MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending; MacCtx.McpsIndication.Buffer = NULL; MacCtx.McpsIndication.BufferSize = 0; MacCtx.McpsIndication.DownLinkCounter = downLinkCounter; MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack; MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK; MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack; if( ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_1 ) || ( MacCtx.McpsIndication.RxSlot == RX_SLOT_WIN_2 ) ) { MacCtx.NvmCtx->AdrAckCounter = 0; } if( multicast == 1 ) { MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST; } else { if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) { MacCtx.NvmCtx->SrvAckRequested = true; if( MacCtx.NvmCtx->Version.Fields.Minor == 0 ) { MacCtx.NvmCtx->LastRxMic = macMsgData.MIC; } MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED; } else { MacCtx.NvmCtx->SrvAckRequested = false; MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED; } } RemoveMacCommands( MacCtx.McpsIndication.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest ); switch( fType ) { case FRAME_TYPE_A: { ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot ); MacCtx.McpsIndication.Port = macMsgData.FPort; MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload; MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize; MacCtx.McpsIndication.RxData = true; break; } case FRAME_TYPE_B: { ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.McpsIndication.RxSlot ); MacCtx.McpsIndication.Port = macMsgData.FPort; break; } case FRAME_TYPE_C: { ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.McpsIndication.RxSlot ); MacCtx.McpsIndication.Port = macMsgData.FPort; break; } case FRAME_TYPE_D: { MacCtx.McpsIndication.Port = macMsgData.FPort; MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload; MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize; MacCtx.McpsIndication.RxData = true; break; } default: MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); break; } MacCtx.MacFlags.Bits.McpsInd = 1; break; case FRAME_TYPE_PROPRIETARY: memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen ); MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY; MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK; MacCtx.McpsIndication.Buffer = MacCtx.RxPayload; MacCtx.McpsIndication.BufferSize = size - pktHeaderLen; MacCtx.MacFlags.Bits.McpsInd = 1; break; default: MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR; PrepareRxDoneAbort( ); break; } if( MacCtx.NodeAckRequested == true ) { if( MacCtx.McpsConfirm.AckReceived == true ) { OnAckTimeoutTimerEvent( NULL ); } } else { if( MacCtx.NvmCtx->DeviceClass == CLASS_C ) { OnAckTimeoutTimerEvent( NULL ); } } MacCtx.MacFlags.Bits.MacDone = 1; UpdateRxSlotIdleState( ); }"
572,6372----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/diskstore.c----dsOpen,"int dsOpen(void) { struct stat sb; int retval; <S2SV_StartVul> char *path = server.diskstore_path; <S2SV_EndVul> if ((retval = stat(path,&sb) == -1) && errno != ENOENT) { redisLog(REDIS_WARNING, ""Error opening disk store at %s: %s"", path, strerror(errno)); return REDIS_ERR; } if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK; if (retval == 0 && !S_ISDIR(sb.st_mode)) { redisLog(REDIS_WARNING,""Disk store at %s is not a directory"", path); return REDIS_ERR; } if (mkdir(path) == -1) { redisLog(REDIS_WARNING,""Disk store init failed creating dir %s: %s"", path, strerror(errno)); return REDIS_ERR; } return REDIS_OK; }","- char *path = server.diskstore_path;
+ char *path = server.ds_path;","int dsOpen(void) { struct stat sb; int retval; char *path = server.ds_path; if ((retval = stat(path,&sb) == -1) && errno != ENOENT) { redisLog(REDIS_WARNING, ""Error opening disk store at %s: %s"", path, strerror(errno)); return REDIS_ERR; } if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK; if (retval == 0 && !S_ISDIR(sb.st_mode)) { redisLog(REDIS_WARNING,""Disk store at %s is not a directory"", path); return REDIS_ERR; } if (mkdir(path) == -1) { redisLog(REDIS_WARNING,""Disk store init failed creating dir %s: %s"", path, strerror(errno)); return REDIS_ERR; } return REDIS_OK; }"
573,2354--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-5892--bgp_attr.c----bgp_packet_attribute,"bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer, struct stream *s, struct attr *attr, struct bpacket_attr_vec_arr *vecarr, struct prefix *p, afi_t afi, safi_t safi, struct peer *from, struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, int addpath_encode, uint32_t addpath_tx_id) { size_t cp; size_t aspath_sizep; struct aspath *aspath; int send_as4_path = 0; int send_as4_aggregator = 0; int use32bit = (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0; if (!bgp) bgp = peer->bgp; cp = stream_get_endp(s); if (p && !((afi == AFI_IP && safi == SAFI_UNICAST) && !peer_cap_enhe(peer, afi, safi))) { size_t mpattrlen_pos = 0; mpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi, vecarr, attr); bgp_packet_mpattr_prefix(s, afi, safi, p, prd, label, num_labels, addpath_encode, addpath_tx_id, attr); bgp_packet_mpattr_end(s, mpattrlen_pos); } stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_ORIGIN); stream_putc(s, 1); stream_putc(s, attr->origin); if (peer->sort == BGP_PEER_EBGP && (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED) || attr->aspath->segments == NULL) && (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))) { aspath = aspath_dup(attr->aspath); aspath = aspath_delete_confed_seq(aspath); if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) { aspath = aspath_add_seq(aspath, bgp->confed_id); } else { if (peer->change_local_as) { if (!CHECK_FLAG( peer->flags, PEER_FLAG_LOCAL_AS_REPLACE_AS)) { aspath = aspath_add_seq(aspath, peer->local_as); } aspath = aspath_add_seq(aspath, peer->change_local_as); } else { aspath = aspath_add_seq(aspath, peer->local_as); } } } else if (peer->sort == BGP_PEER_CONFED) { aspath = aspath_dup(attr->aspath); aspath = aspath_add_confed_seq(aspath, peer->local_as); } else aspath = attr->aspath; stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_AS_PATH); aspath_sizep = stream_get_endp(s); stream_putw(s, 0); stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit)); if (!use32bit && aspath_has_as4(aspath)) send_as4_path = 1; if (afi == AFI_IP && safi == SAFI_UNICAST && !peer_cap_enhe(peer, afi, safi)) { if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_NEXT_HOP); bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, attr); stream_putc(s, 4); stream_put_ipv4(s, attr->nexthop.s_addr); } else if (peer_cap_enhe(from, afi, safi)) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_NEXT_HOP); bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, NULL); stream_putc(s, 4); stream_put_ipv4(s, 0); } } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC) || bgp->maxmed_active) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); stream_putc(s, BGP_ATTR_MULTI_EXIT_DISC); stream_putc(s, 4); stream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value : attr->med)); } if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_LOCAL_PREF); stream_putc(s, 4); stream_putl(s, attr->local_pref); } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE); stream_putc(s, 0); } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_AGGREGATOR); if (use32bit) { stream_putc(s, 8); stream_putl(s, attr->aggregator_as); } else { stream_putc(s, 6); if (attr->aggregator_as > 65535) { stream_putw(s, BGP_AS_TRANS); send_as4_aggregator = 1; } else stream_putw(s, (uint16_t)attr->aggregator_as); } stream_put_ipv4(s, attr->aggregator_addr.s_addr); } if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY) && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) { if (attr->community->size * 4 > 255) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_COMMUNITIES); stream_putw(s, attr->community->size * 4); } else { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_COMMUNITIES); stream_putc(s, attr->community->size * 4); } stream_put(s, attr->community->val, attr->community->size * 4); } if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_LARGE_COMMUNITY) && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) { if (lcom_length(attr->lcommunity) > 255) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES); stream_putw(s, lcom_length(attr->lcommunity)); } else { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES); stream_putc(s, lcom_length(attr->lcommunity)); } stream_put(s, attr->lcommunity->val, lcom_length(attr->lcommunity)); } if (peer->sort == BGP_PEER_IBGP && from && from->sort == BGP_PEER_IBGP) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); stream_putc(s, BGP_ATTR_ORIGINATOR_ID); stream_putc(s, 4); if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID)) stream_put_in_addr(s, &attr->originator_id); else stream_put_in_addr(s, &from->remote_id); stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); stream_putc(s, BGP_ATTR_CLUSTER_LIST); if (attr->cluster) { stream_putc(s, attr->cluster->length + 4); if (bgp->config & BGP_CONFIG_CLUSTER_ID) stream_put_in_addr(s, &bgp->cluster_id); else stream_put_in_addr(s, &bgp->router_id); stream_put(s, attr->cluster->list, attr->cluster->length); } else { stream_putc(s, 4); if (bgp->config & BGP_CONFIG_CLUSTER_ID) stream_put_in_addr(s, &bgp->cluster_id); else stream_put_in_addr(s, &bgp->router_id); } } if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY) && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) { if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) { if (attr->ecommunity->size * 8 > 255) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putw(s, attr->ecommunity->size * 8); } else { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putc(s, attr->ecommunity->size * 8); } stream_put(s, attr->ecommunity->val, attr->ecommunity->size * 8); } else { uint8_t *pnt; int tbit; int ecom_tr_size = 0; int i; for (i = 0; i < attr->ecommunity->size; i++) { pnt = attr->ecommunity->val + (i * 8); tbit = *pnt; if (CHECK_FLAG(tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE)) continue; ecom_tr_size++; } if (ecom_tr_size) { if (ecom_tr_size * 8 > 255) { stream_putc( s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putw(s, ecom_tr_size * 8); } else { stream_putc( s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putc(s, ecom_tr_size * 8); } for (i = 0; i < attr->ecommunity->size; i++) { pnt = attr->ecommunity->val + (i * 8); tbit = *pnt; if (CHECK_FLAG( tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE)) continue; stream_put(s, pnt, 8); } } } } if (safi == SAFI_LABELED_UNICAST) { if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) { uint32_t label_index; label_index = attr->label_index; if (label_index != BGP_INVALID_LABEL_INDEX) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_PREFIX_SID); stream_putc(s, 10); stream_putc(s, BGP_PREFIX_SID_LABEL_INDEX); stream_putw(s, BGP_PREFIX_SID_LABEL_INDEX_LENGTH); stream_putc(s, 0); stream_putw(s, 0); stream_putl(s, label_index); } } } if (send_as4_path) { aspath = aspath_delete_confed_seq(aspath); stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_AS4_PATH); aspath_sizep = stream_get_endp(s); stream_putw(s, 0); stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1)); } if (aspath != attr->aspath) aspath_free(aspath); if (send_as4_aggregator) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_AS4_AGGREGATOR); stream_putc(s, 8); stream_putl(s, attr->aggregator_as); stream_put_ipv4(s, attr->aggregator_addr.s_addr); } if (((afi == AFI_IP || afi == AFI_IP6) && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN)) || (afi == AFI_L2VPN && safi == SAFI_EVPN)) { bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP); <S2SV_StartVul> #if ENABLE_BGP_VNC <S2SV_EndVul> bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC); #endif } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_PMSI_TUNNEL); stream_putc(s, 9); stream_putc(s, 0); stream_putc(s, PMSI_TNLTYPE_INGR_REPL); stream_put(s, &(attr->label), BGP_LABEL_BYTES); stream_put_ipv4(s, attr->nexthop.s_addr); } if (attr->transit) stream_put(s, attr->transit->val, attr->transit->length); return stream_get_endp(s) - cp; }","- #if ENABLE_BGP_VNC
+ #if ENABLE_BGP_VNC_ATTR","bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer, struct stream *s, struct attr *attr, struct bpacket_attr_vec_arr *vecarr, struct prefix *p, afi_t afi, safi_t safi, struct peer *from, struct prefix_rd *prd, mpls_label_t *label, uint32_t num_labels, int addpath_encode, uint32_t addpath_tx_id) { size_t cp; size_t aspath_sizep; struct aspath *aspath; int send_as4_path = 0; int send_as4_aggregator = 0; int use32bit = (CHECK_FLAG(peer->cap, PEER_CAP_AS4_RCV)) ? 1 : 0; if (!bgp) bgp = peer->bgp; cp = stream_get_endp(s); if (p && !((afi == AFI_IP && safi == SAFI_UNICAST) && !peer_cap_enhe(peer, afi, safi))) { size_t mpattrlen_pos = 0; mpattrlen_pos = bgp_packet_mpattr_start(s, peer, afi, safi, vecarr, attr); bgp_packet_mpattr_prefix(s, afi, safi, p, prd, label, num_labels, addpath_encode, addpath_tx_id, attr); bgp_packet_mpattr_end(s, mpattrlen_pos); } stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_ORIGIN); stream_putc(s, 1); stream_putc(s, attr->origin); if (peer->sort == BGP_PEER_EBGP && (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED) || attr->aspath->segments == NULL) && (!CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))) { aspath = aspath_dup(attr->aspath); aspath = aspath_delete_confed_seq(aspath); if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)) { aspath = aspath_add_seq(aspath, bgp->confed_id); } else { if (peer->change_local_as) { if (!CHECK_FLAG( peer->flags, PEER_FLAG_LOCAL_AS_REPLACE_AS)) { aspath = aspath_add_seq(aspath, peer->local_as); } aspath = aspath_add_seq(aspath, peer->change_local_as); } else { aspath = aspath_add_seq(aspath, peer->local_as); } } } else if (peer->sort == BGP_PEER_CONFED) { aspath = aspath_dup(attr->aspath); aspath = aspath_add_confed_seq(aspath, peer->local_as); } else aspath = attr->aspath; stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_AS_PATH); aspath_sizep = stream_get_endp(s); stream_putw(s, 0); stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, use32bit)); if (!use32bit && aspath_has_as4(aspath)) send_as4_path = 1; if (afi == AFI_IP && safi == SAFI_UNICAST && !peer_cap_enhe(peer, afi, safi)) { if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_NEXT_HOP); bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, attr); stream_putc(s, 4); stream_put_ipv4(s, attr->nexthop.s_addr); } else if (peer_cap_enhe(from, afi, safi)) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_NEXT_HOP); bpacket_attr_vec_arr_set_vec(vecarr, BGP_ATTR_VEC_NH, s, NULL); stream_putc(s, 4); stream_put_ipv4(s, 0); } } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC) || bgp->maxmed_active) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); stream_putc(s, BGP_ATTR_MULTI_EXIT_DISC); stream_putc(s, 4); stream_putl(s, (bgp->maxmed_active ? bgp->maxmed_value : attr->med)); } if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_LOCAL_PREF); stream_putc(s, 4); stream_putl(s, attr->local_pref); } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE)) { stream_putc(s, BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_ATOMIC_AGGREGATE); stream_putc(s, 0); } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_AGGREGATOR); if (use32bit) { stream_putc(s, 8); stream_putl(s, attr->aggregator_as); } else { stream_putc(s, 6); if (attr->aggregator_as > 65535) { stream_putw(s, BGP_AS_TRANS); send_as4_aggregator = 1; } else stream_putw(s, (uint16_t)attr->aggregator_as); } stream_put_ipv4(s, attr->aggregator_addr.s_addr); } if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY) && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_COMMUNITIES))) { if (attr->community->size * 4 > 255) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_COMMUNITIES); stream_putw(s, attr->community->size * 4); } else { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_COMMUNITIES); stream_putc(s, attr->community->size * 4); } stream_put(s, attr->community->val, attr->community->size * 4); } if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_LARGE_COMMUNITY) && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LARGE_COMMUNITIES))) { if (lcom_length(attr->lcommunity) > 255) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES); stream_putw(s, lcom_length(attr->lcommunity)); } else { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_LARGE_COMMUNITIES); stream_putc(s, lcom_length(attr->lcommunity)); } stream_put(s, attr->lcommunity->val, lcom_length(attr->lcommunity)); } if (peer->sort == BGP_PEER_IBGP && from && from->sort == BGP_PEER_IBGP) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); stream_putc(s, BGP_ATTR_ORIGINATOR_ID); stream_putc(s, 4); if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID)) stream_put_in_addr(s, &attr->originator_id); else stream_put_in_addr(s, &from->remote_id); stream_putc(s, BGP_ATTR_FLAG_OPTIONAL); stream_putc(s, BGP_ATTR_CLUSTER_LIST); if (attr->cluster) { stream_putc(s, attr->cluster->length + 4); if (bgp->config & BGP_CONFIG_CLUSTER_ID) stream_put_in_addr(s, &bgp->cluster_id); else stream_put_in_addr(s, &bgp->router_id); stream_put(s, attr->cluster->list, attr->cluster->length); } else { stream_putc(s, 4); if (bgp->config & BGP_CONFIG_CLUSTER_ID) stream_put_in_addr(s, &bgp->cluster_id); else stream_put_in_addr(s, &bgp->router_id); } } if (CHECK_FLAG(peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY) && (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))) { if (peer->sort == BGP_PEER_IBGP || peer->sort == BGP_PEER_CONFED) { if (attr->ecommunity->size * 8 > 255) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putw(s, attr->ecommunity->size * 8); } else { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putc(s, attr->ecommunity->size * 8); } stream_put(s, attr->ecommunity->val, attr->ecommunity->size * 8); } else { uint8_t *pnt; int tbit; int ecom_tr_size = 0; int i; for (i = 0; i < attr->ecommunity->size; i++) { pnt = attr->ecommunity->val + (i * 8); tbit = *pnt; if (CHECK_FLAG(tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE)) continue; ecom_tr_size++; } if (ecom_tr_size) { if (ecom_tr_size * 8 > 255) { stream_putc( s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putw(s, ecom_tr_size * 8); } else { stream_putc( s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_EXT_COMMUNITIES); stream_putc(s, ecom_tr_size * 8); } for (i = 0; i < attr->ecommunity->size; i++) { pnt = attr->ecommunity->val + (i * 8); tbit = *pnt; if (CHECK_FLAG( tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE)) continue; stream_put(s, pnt, 8); } } } } if (safi == SAFI_LABELED_UNICAST) { if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PREFIX_SID)) { uint32_t label_index; label_index = attr->label_index; if (label_index != BGP_INVALID_LABEL_INDEX) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_PREFIX_SID); stream_putc(s, 10); stream_putc(s, BGP_PREFIX_SID_LABEL_INDEX); stream_putw(s, BGP_PREFIX_SID_LABEL_INDEX_LENGTH); stream_putc(s, 0); stream_putw(s, 0); stream_putl(s, label_index); } } } if (send_as4_path) { aspath = aspath_delete_confed_seq(aspath); stream_putc(s, BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN); stream_putc(s, BGP_ATTR_AS4_PATH); aspath_sizep = stream_get_endp(s); stream_putw(s, 0); stream_putw_at(s, aspath_sizep, aspath_put(s, aspath, 1)); } if (aspath != attr->aspath) aspath_free(aspath); if (send_as4_aggregator) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_AS4_AGGREGATOR); stream_putc(s, 8); stream_putl(s, attr->aggregator_as); stream_put_ipv4(s, attr->aggregator_addr.s_addr); } if (((afi == AFI_IP || afi == AFI_IP6) && (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN)) || (afi == AFI_L2VPN && safi == SAFI_EVPN)) { bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP); #if ENABLE_BGP_VNC_ATTR bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC); #endif } if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_PMSI_TUNNEL)) { stream_putc(s, BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS); stream_putc(s, BGP_ATTR_PMSI_TUNNEL); stream_putc(s, 9); stream_putc(s, 0); stream_putc(s, PMSI_TNLTYPE_INGR_REPL); stream_put(s, &(attr->label), BGP_LABEL_BYTES); stream_put_ipv4(s, attr->nexthop.s_addr); } if (attr->transit) stream_put(s, attr->transit->val, attr->transit->length); return stream_get_endp(s) - cp; }"
574,6824----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ffprobe.c----show_stream,"static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program) { AVStream *stream = ist->st; AVCodecParameters *par; AVCodecContext *dec_ctx; char val_str[128]; const char *s; AVRational sar, dar; AVBPrint pbuf; const AVCodecDescriptor *cd; int ret = 0; const char *profile = NULL; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int(""index"", stream->index); par = stream->codecpar; dec_ctx = ist->dec_ctx; if (cd = avcodec_descriptor_get(par->codec_id)) { print_str(""codec_name"", cd->name); if (!do_bitexact) { print_str(""codec_long_name"", cd->long_name ? cd->long_name : ""unknown""); } } else { print_str_opt(""codec_name"", ""unknown""); if (!do_bitexact) { print_str_opt(""codec_long_name"", ""unknown""); } } if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile))) print_str(""profile"", profile); else { if (par->profile != FF_PROFILE_UNKNOWN) { char profile_num[12]; snprintf(profile_num, sizeof(profile_num), ""%d"", par->profile); print_str(""profile"", profile_num); } else print_str_opt(""profile"", ""unknown""); } s = av_get_media_type_string(par->codec_type); if (s) print_str (""codec_type"", s); else print_str_opt(""codec_type"", ""unknown""); #if FF_API_LAVF_AVCTX if (dec_ctx) print_q(""codec_time_base"", dec_ctx->time_base, '/'); #endif print_str(""codec_tag_string"", av_fourcc2str(par->codec_tag)); print_fmt(""codec_tag"", ""0x%04""PRIx32, par->codec_tag); switch (par->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int(""width"", par->width); print_int(""height"", par->height); if (dec_ctx) { print_int(""coded_width"", dec_ctx->coded_width); print_int(""coded_height"", dec_ctx->coded_height); } print_int(""has_b_frames"", par->video_delay); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q(""sample_aspect_ratio"", sar, ':'); av_reduce(&dar.num, &dar.den, par->width * sar.num, par->height * sar.den, 1024*1024); print_q(""display_aspect_ratio"", dar, ':'); } else { print_str_opt(""sample_aspect_ratio"", ""N/A""); print_str_opt(""display_aspect_ratio"", ""N/A""); } s = av_get_pix_fmt_name(par->format); if (s) print_str (""pix_fmt"", s); else print_str_opt(""pix_fmt"", ""unknown""); print_int(""level"", par->level); if (par->color_range != AVCOL_RANGE_UNSPECIFIED) print_str (""color_range"", av_color_range_name(par->color_range)); else print_str_opt(""color_range"", ""N/A""); if (par->color_space != AVCOL_SPC_UNSPECIFIED) print_str(""color_space"", av_color_space_name(par->color_space)); else print_str_opt(""color_space"", av_color_space_name(par->color_space)); if (par->color_trc != AVCOL_TRC_UNSPECIFIED) print_str(""color_transfer"", av_color_transfer_name(par->color_trc)); else print_str_opt(""color_transfer"", av_color_transfer_name(par->color_trc)); <S2SV_StartVul> if (par->color_primaries != AVCOL_PRI_UNSPECIFIED) <S2SV_EndVul> <S2SV_StartVul> print_str(""color_primaries"", av_color_primaries_name(par->color_primaries)); <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> print_str_opt(""color_primaries"", av_color_primaries_name(par->color_primaries)); <S2SV_EndVul> if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED) print_str(""chroma_location"", av_chroma_location_name(par->chroma_location)); else print_str_opt(""chroma_location"", av_chroma_location_name(par->chroma_location)); if (par->field_order == AV_FIELD_PROGRESSIVE) print_str(""field_order"", ""progressive""); else if (par->field_order == AV_FIELD_TT) print_str(""field_order"", ""tt""); else if (par->field_order == AV_FIELD_BB) print_str(""field_order"", ""bb""); else if (par->field_order == AV_FIELD_TB) print_str(""field_order"", ""tb""); else if (par->field_order == AV_FIELD_BT) print_str(""field_order"", ""bt""); else print_str_opt(""field_order"", ""unknown""); #if FF_API_PRIVATE_OPT if (dec_ctx && dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str(""timecode"", tcbuf); } else { print_str_opt(""timecode"", ""N/A""); } #endif if (dec_ctx) print_int(""refs"", dec_ctx->refs); break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(par->format); if (s) print_str (""sample_fmt"", s); else print_str_opt(""sample_fmt"", ""unknown""); print_val(""sample_rate"", par->sample_rate, unit_hertz_str); print_int(""channels"", par->channels); if (par->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout); print_str (""channel_layout"", pbuf.str); } else { print_str_opt(""channel_layout"", ""unknown""); } print_int(""bits_per_sample"", av_get_bits_per_sample(par->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (par->width) print_int(""width"", par->width); else print_str_opt(""width"", ""N/A""); if (par->height) print_int(""height"", par->height); else print_str_opt(""height"", ""N/A""); break; } if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt (""id"", ""0x%x"", stream->id); else print_str_opt(""id"", ""N/A""); print_q(""r_frame_rate"", stream->r_frame_rate, '/'); print_q(""avg_frame_rate"", stream->avg_frame_rate, '/'); print_q(""time_base"", stream->time_base, '/'); print_ts (""start_pts"", stream->start_time); print_time(""start_time"", stream->start_time, &stream->time_base); print_ts (""duration_ts"", stream->duration); print_time(""duration"", stream->duration, &stream->time_base); if (par->bit_rate > 0) print_val (""bit_rate"", par->bit_rate, unit_bit_per_second_str); else print_str_opt(""bit_rate"", ""N/A""); #if FF_API_LAVF_AVCTX if (stream->codec->rc_max_rate > 0) print_val (""max_bit_rate"", stream->codec->rc_max_rate, unit_bit_per_second_str); else print_str_opt(""max_bit_rate"", ""N/A""); #endif if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(""bits_per_raw_sample"", ""%d"", dec_ctx->bits_per_raw_sample); else print_str_opt(""bits_per_raw_sample"", ""N/A""); if (stream->nb_frames) print_fmt (""nb_frames"", ""%""PRId64, stream->nb_frames); else print_str_opt(""nb_frames"", ""N/A""); if (nb_streams_frames[stream_idx]) print_fmt (""nb_read_frames"", ""%""PRIu64, nb_streams_frames[stream_idx]); else print_str_opt(""nb_read_frames"", ""N/A""); if (nb_streams_packets[stream_idx]) print_fmt (""nb_read_packets"", ""%""PRIu64, nb_streams_packets[stream_idx]); else print_str_opt(""nb_read_packets"", ""N/A""); if (do_show_data) writer_print_data(w, ""extradata"", par->extradata, par->extradata_size); writer_print_data_hash(w, ""extradata_hash"", par->extradata, par->extradata_size); #define PRINT_DISPOSITION(flagname,name) do { \ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT, ""default""); PRINT_DISPOSITION(DUB, ""dub""); PRINT_DISPOSITION(ORIGINAL, ""original""); PRINT_DISPOSITION(COMMENT, ""comment""); PRINT_DISPOSITION(LYRICS, ""lyrics""); PRINT_DISPOSITION(KARAOKE, ""karaoke""); PRINT_DISPOSITION(FORCED, ""forced""); PRINT_DISPOSITION(HEARING_IMPAIRED, ""hearing_impaired""); PRINT_DISPOSITION(VISUAL_IMPAIRED, ""visual_impaired""); PRINT_DISPOSITION(CLEAN_EFFECTS, ""clean_effects""); PRINT_DISPOSITION(ATTACHED_PIC, ""attached_pic""); PRINT_DISPOSITION(TIMED_THUMBNAILS, ""timed_thumbnails""); writer_print_section_footer(w); } if (do_show_stream_tags) ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS); if (stream->nb_side_data) { print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data, SECTION_ID_STREAM_SIDE_DATA_LIST, SECTION_ID_STREAM_SIDE_DATA); } writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); return ret; }","- if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)
- print_str(""color_primaries"", av_color_primaries_name(par->color_primaries));
- else
- print_str_opt(""color_primaries"", av_color_primaries_name(par->color_primaries));
+ print_primaries(w, par->color_primaries);","static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, InputStream *ist, int in_program) { AVStream *stream = ist->st; AVCodecParameters *par; AVCodecContext *dec_ctx; char val_str[128]; const char *s; AVRational sar, dar; AVBPrint pbuf; const AVCodecDescriptor *cd; int ret = 0; const char *profile = NULL; av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED); writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM); print_int(""index"", stream->index); par = stream->codecpar; dec_ctx = ist->dec_ctx; if (cd = avcodec_descriptor_get(par->codec_id)) { print_str(""codec_name"", cd->name); if (!do_bitexact) { print_str(""codec_long_name"", cd->long_name ? cd->long_name : ""unknown""); } } else { print_str_opt(""codec_name"", ""unknown""); if (!do_bitexact) { print_str_opt(""codec_long_name"", ""unknown""); } } if (!do_bitexact && (profile = avcodec_profile_name(par->codec_id, par->profile))) print_str(""profile"", profile); else { if (par->profile != FF_PROFILE_UNKNOWN) { char profile_num[12]; snprintf(profile_num, sizeof(profile_num), ""%d"", par->profile); print_str(""profile"", profile_num); } else print_str_opt(""profile"", ""unknown""); } s = av_get_media_type_string(par->codec_type); if (s) print_str (""codec_type"", s); else print_str_opt(""codec_type"", ""unknown""); #if FF_API_LAVF_AVCTX if (dec_ctx) print_q(""codec_time_base"", dec_ctx->time_base, '/'); #endif print_str(""codec_tag_string"", av_fourcc2str(par->codec_tag)); print_fmt(""codec_tag"", ""0x%04""PRIx32, par->codec_tag); switch (par->codec_type) { case AVMEDIA_TYPE_VIDEO: print_int(""width"", par->width); print_int(""height"", par->height); if (dec_ctx) { print_int(""coded_width"", dec_ctx->coded_width); print_int(""coded_height"", dec_ctx->coded_height); } print_int(""has_b_frames"", par->video_delay); sar = av_guess_sample_aspect_ratio(fmt_ctx, stream, NULL); if (sar.den) { print_q(""sample_aspect_ratio"", sar, ':'); av_reduce(&dar.num, &dar.den, par->width * sar.num, par->height * sar.den, 1024*1024); print_q(""display_aspect_ratio"", dar, ':'); } else { print_str_opt(""sample_aspect_ratio"", ""N/A""); print_str_opt(""display_aspect_ratio"", ""N/A""); } s = av_get_pix_fmt_name(par->format); if (s) print_str (""pix_fmt"", s); else print_str_opt(""pix_fmt"", ""unknown""); print_int(""level"", par->level); if (par->color_range != AVCOL_RANGE_UNSPECIFIED) print_str (""color_range"", av_color_range_name(par->color_range)); else print_str_opt(""color_range"", ""N/A""); if (par->color_space != AVCOL_SPC_UNSPECIFIED) print_str(""color_space"", av_color_space_name(par->color_space)); else print_str_opt(""color_space"", av_color_space_name(par->color_space)); if (par->color_trc != AVCOL_TRC_UNSPECIFIED) print_str(""color_transfer"", av_color_transfer_name(par->color_trc)); else print_str_opt(""color_transfer"", av_color_transfer_name(par->color_trc)); print_primaries(w, par->color_primaries); if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED) print_str(""chroma_location"", av_chroma_location_name(par->chroma_location)); else print_str_opt(""chroma_location"", av_chroma_location_name(par->chroma_location)); if (par->field_order == AV_FIELD_PROGRESSIVE) print_str(""field_order"", ""progressive""); else if (par->field_order == AV_FIELD_TT) print_str(""field_order"", ""tt""); else if (par->field_order == AV_FIELD_BB) print_str(""field_order"", ""bb""); else if (par->field_order == AV_FIELD_TB) print_str(""field_order"", ""tb""); else if (par->field_order == AV_FIELD_BT) print_str(""field_order"", ""bt""); else print_str_opt(""field_order"", ""unknown""); #if FF_API_PRIVATE_OPT if (dec_ctx && dec_ctx->timecode_frame_start >= 0) { char tcbuf[AV_TIMECODE_STR_SIZE]; av_timecode_make_mpeg_tc_string(tcbuf, dec_ctx->timecode_frame_start); print_str(""timecode"", tcbuf); } else { print_str_opt(""timecode"", ""N/A""); } #endif if (dec_ctx) print_int(""refs"", dec_ctx->refs); break; case AVMEDIA_TYPE_AUDIO: s = av_get_sample_fmt_name(par->format); if (s) print_str (""sample_fmt"", s); else print_str_opt(""sample_fmt"", ""unknown""); print_val(""sample_rate"", par->sample_rate, unit_hertz_str); print_int(""channels"", par->channels); if (par->channel_layout) { av_bprint_clear(&pbuf); av_bprint_channel_layout(&pbuf, par->channels, par->channel_layout); print_str (""channel_layout"", pbuf.str); } else { print_str_opt(""channel_layout"", ""unknown""); } print_int(""bits_per_sample"", av_get_bits_per_sample(par->codec_id)); break; case AVMEDIA_TYPE_SUBTITLE: if (par->width) print_int(""width"", par->width); else print_str_opt(""width"", ""N/A""); if (par->height) print_int(""height"", par->height); else print_str_opt(""height"", ""N/A""); break; } if (dec_ctx && dec_ctx->codec && dec_ctx->codec->priv_class && show_private_data) { const AVOption *opt = NULL; while (opt = av_opt_next(dec_ctx->priv_data,opt)) { uint8_t *str; if (opt->flags) continue; if (av_opt_get(dec_ctx->priv_data, opt->name, 0, &str) >= 0) { print_str(opt->name, str); av_free(str); } } } if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS) print_fmt (""id"", ""0x%x"", stream->id); else print_str_opt(""id"", ""N/A""); print_q(""r_frame_rate"", stream->r_frame_rate, '/'); print_q(""avg_frame_rate"", stream->avg_frame_rate, '/'); print_q(""time_base"", stream->time_base, '/'); print_ts (""start_pts"", stream->start_time); print_time(""start_time"", stream->start_time, &stream->time_base); print_ts (""duration_ts"", stream->duration); print_time(""duration"", stream->duration, &stream->time_base); if (par->bit_rate > 0) print_val (""bit_rate"", par->bit_rate, unit_bit_per_second_str); else print_str_opt(""bit_rate"", ""N/A""); #if FF_API_LAVF_AVCTX if (stream->codec->rc_max_rate > 0) print_val (""max_bit_rate"", stream->codec->rc_max_rate, unit_bit_per_second_str); else print_str_opt(""max_bit_rate"", ""N/A""); #endif if (dec_ctx && dec_ctx->bits_per_raw_sample > 0) print_fmt(""bits_per_raw_sample"", ""%d"", dec_ctx->bits_per_raw_sample); else print_str_opt(""bits_per_raw_sample"", ""N/A""); if (stream->nb_frames) print_fmt (""nb_frames"", ""%""PRId64, stream->nb_frames); else print_str_opt(""nb_frames"", ""N/A""); if (nb_streams_frames[stream_idx]) print_fmt (""nb_read_frames"", ""%""PRIu64, nb_streams_frames[stream_idx]); else print_str_opt(""nb_read_frames"", ""N/A""); if (nb_streams_packets[stream_idx]) print_fmt (""nb_read_packets"", ""%""PRIu64, nb_streams_packets[stream_idx]); else print_str_opt(""nb_read_packets"", ""N/A""); if (do_show_data) writer_print_data(w, ""extradata"", par->extradata, par->extradata_size); writer_print_data_hash(w, ""extradata_hash"", par->extradata, par->extradata_size); #define PRINT_DISPOSITION(flagname,name) do { \ print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \ } while (0) if (do_show_stream_disposition) { writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION); PRINT_DISPOSITION(DEFAULT, ""default""); PRINT_DISPOSITION(DUB, ""dub""); PRINT_DISPOSITION(ORIGINAL, ""original""); PRINT_DISPOSITION(COMMENT, ""comment""); PRINT_DISPOSITION(LYRICS, ""lyrics""); PRINT_DISPOSITION(KARAOKE, ""karaoke""); PRINT_DISPOSITION(FORCED, ""forced""); PRINT_DISPOSITION(HEARING_IMPAIRED, ""hearing_impaired""); PRINT_DISPOSITION(VISUAL_IMPAIRED, ""visual_impaired""); PRINT_DISPOSITION(CLEAN_EFFECTS, ""clean_effects""); PRINT_DISPOSITION(ATTACHED_PIC, ""attached_pic""); PRINT_DISPOSITION(TIMED_THUMBNAILS, ""timed_thumbnails""); writer_print_section_footer(w); } if (do_show_stream_tags) ret = show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS); if (stream->nb_side_data) { print_pkt_side_data(w, stream->codecpar, stream->side_data, stream->nb_side_data, SECTION_ID_STREAM_SIDE_DATA_LIST, SECTION_ID_STREAM_SIDE_DATA); } writer_print_section_footer(w); av_bprint_finalize(&pbuf, NULL); fflush(stdout); return ret; }"
575,5270----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dhcps.c----mark_ip_in_table,"static void mark_ip_in_table(uint8_t d) { #if (debug_dhcps) printf(""\r\nmark ip %d\r\n"",d); #endif xSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY); if (0 < d && d <= 32) { ip_table.ip_range[0] = MARK_RANGE1_IP_BIT(ip_table, d); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[0] = 0x%x\r\n"",ip_table.ip_range[0]); #endif } else if (32 < d && d <= 64) { ip_table.ip_range[1] = MARK_RANGE2_IP_BIT(ip_table, (d - 32)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[1] = 0x%x\r\n"",ip_table.ip_range[1]); #endif } else if (64 < d && d <= 96) { ip_table.ip_range[2] = MARK_RANGE3_IP_BIT(ip_table, (d - 64)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[2] = 0x%x\r\n"",ip_table.ip_range[2]); #endif } else if (96 < d && d <= 128) { ip_table.ip_range[3] = MARK_RANGE4_IP_BIT(ip_table, (d - 96)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[3] = 0x%x\r\n"",ip_table.ip_range[3]); #endif } else if(128 < d && d <= 160) { <S2SV_StartVul> ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d); <S2SV_EndVul> #if (debug_dhcps) printf(""\r\n ip_table.ip_range[4] = 0x%x\r\n"",ip_table.ip_range[4]); #endif } else if (160 < d && d <= 192) { ip_table.ip_range[5] = MARK_RANGE6_IP_BIT(ip_table, (d - 160)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[5] = 0x%x\r\n"",ip_table.ip_range[5]); #endif } else if (192 < d && d <= 224) { ip_table.ip_range[6] = MARK_RANGE7_IP_BIT(ip_table, (d - 192)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[6] = 0x%x\r\n"",ip_table.ip_range[6]); #endif } else if (224 < d) { ip_table.ip_range[7] = MARK_RANGE8_IP_BIT(ip_table, (d - 224)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[7] = 0x%x\r\n"",ip_table.ip_range[7]); #endif } else { printf(""\r\n Request ip over the range(1-128) \r\n""); } xSemaphoreGive(dhcps_ip_table_semaphore); }","- ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, d);
+ ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, (d - 128));","static void mark_ip_in_table(uint8_t d) { #if (debug_dhcps) printf(""\r\nmark ip %d\r\n"",d); #endif xSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY); if (0 < d && d <= 32) { ip_table.ip_range[0] = MARK_RANGE1_IP_BIT(ip_table, d); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[0] = 0x%x\r\n"",ip_table.ip_range[0]); #endif } else if (32 < d && d <= 64) { ip_table.ip_range[1] = MARK_RANGE2_IP_BIT(ip_table, (d - 32)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[1] = 0x%x\r\n"",ip_table.ip_range[1]); #endif } else if (64 < d && d <= 96) { ip_table.ip_range[2] = MARK_RANGE3_IP_BIT(ip_table, (d - 64)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[2] = 0x%x\r\n"",ip_table.ip_range[2]); #endif } else if (96 < d && d <= 128) { ip_table.ip_range[3] = MARK_RANGE4_IP_BIT(ip_table, (d - 96)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[3] = 0x%x\r\n"",ip_table.ip_range[3]); #endif } else if(128 < d && d <= 160) { ip_table.ip_range[4] = MARK_RANGE5_IP_BIT(ip_table, (d - 128)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[4] = 0x%x\r\n"",ip_table.ip_range[4]); #endif } else if (160 < d && d <= 192) { ip_table.ip_range[5] = MARK_RANGE6_IP_BIT(ip_table, (d - 160)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[5] = 0x%x\r\n"",ip_table.ip_range[5]); #endif } else if (192 < d && d <= 224) { ip_table.ip_range[6] = MARK_RANGE7_IP_BIT(ip_table, (d - 192)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[6] = 0x%x\r\n"",ip_table.ip_range[6]); #endif } else if (224 < d) { ip_table.ip_range[7] = MARK_RANGE8_IP_BIT(ip_table, (d - 224)); #if (debug_dhcps) printf(""\r\n ip_table.ip_range[7] = 0x%x\r\n"",ip_table.ip_range[7]); #endif } else { printf(""\r\n Request ip over the range(1-128) \r\n""); } xSemaphoreGive(dhcps_ip_table_semaphore); }"
576,4391----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/memory_hotplug.c----online_pages,"int __ref online_pages(unsigned long pfn, unsigned long nr_pages) { unsigned long onlined_pages = 0; struct zone *zone; int need_zonelists_rebuild = 0; int nid; int ret; struct memory_notify arg; lock_memory_hotplug(); arg.start_pfn = pfn; arg.nr_pages = nr_pages; arg.status_change_nid = -1; nid = page_to_nid(pfn_to_page(pfn)); if (node_present_pages(nid) == 0) arg.status_change_nid = nid; ret = memory_notify(MEM_GOING_ONLINE, &arg); ret = notifier_to_errno(ret); if (ret) { memory_notify(MEM_CANCEL_ONLINE, &arg); unlock_memory_hotplug(); return ret; } zone = page_zone(pfn_to_page(pfn)); mutex_lock(&zonelists_mutex); if (!populated_zone(zone)) need_zonelists_rebuild = 1; ret = walk_system_ram_range(pfn, nr_pages, &onlined_pages, online_pages_range); if (ret) { mutex_unlock(&zonelists_mutex); printk(KERN_DEBUG ""online_pages [mem %#010llx-%#010llx] failed\n"", (unsigned long long) pfn << PAGE_SHIFT, (((unsigned long long) pfn + nr_pages) << PAGE_SHIFT) - 1); memory_notify(MEM_CANCEL_ONLINE, &arg); unlock_memory_hotplug(); return ret; } zone->present_pages += onlined_pages; zone->zone_pgdat->node_present_pages += onlined_pages; <S2SV_StartVul> if (need_zonelists_rebuild) <S2SV_EndVul> <S2SV_StartVul> build_all_zonelists(NULL, zone); <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> zone_pcp_update(zone); <S2SV_EndVul> mutex_unlock(&zonelists_mutex); init_per_zone_wmark_min(); <S2SV_StartVul> if (onlined_pages) { <S2SV_EndVul> kswapd_run(zone_to_nid(zone)); <S2SV_StartVul> node_set_state(zone_to_nid(zone), N_HIGH_MEMORY); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> vm_total_pages = nr_free_pagecache_pages(); writeback_set_ratelimit(); if (onlined_pages) memory_notify(MEM_ONLINE, &arg); unlock_memory_hotplug(); return 0; }","- if (need_zonelists_rebuild)
- build_all_zonelists(NULL, zone);
- else
- zone_pcp_update(zone);
- if (onlined_pages) {
- node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
- }
+ if (onlined_pages) {
+ node_set_state(zone_to_nid(zone), N_HIGH_MEMORY);
+ if (need_zonelists_rebuild)
+ build_all_zonelists(NULL, zone);
+ else
+ zone_pcp_update(zone);
+ }
+ if (onlined_pages)","int __ref online_pages(unsigned long pfn, unsigned long nr_pages) { unsigned long onlined_pages = 0; struct zone *zone; int need_zonelists_rebuild = 0; int nid; int ret; struct memory_notify arg; lock_memory_hotplug(); arg.start_pfn = pfn; arg.nr_pages = nr_pages; arg.status_change_nid = -1; nid = page_to_nid(pfn_to_page(pfn)); if (node_present_pages(nid) == 0) arg.status_change_nid = nid; ret = memory_notify(MEM_GOING_ONLINE, &arg); ret = notifier_to_errno(ret); if (ret) { memory_notify(MEM_CANCEL_ONLINE, &arg); unlock_memory_hotplug(); return ret; } zone = page_zone(pfn_to_page(pfn)); mutex_lock(&zonelists_mutex); if (!populated_zone(zone)) need_zonelists_rebuild = 1; ret = walk_system_ram_range(pfn, nr_pages, &onlined_pages, online_pages_range); if (ret) { mutex_unlock(&zonelists_mutex); printk(KERN_DEBUG ""online_pages [mem %#010llx-%#010llx] failed\n"", (unsigned long long) pfn << PAGE_SHIFT, (((unsigned long long) pfn + nr_pages) << PAGE_SHIFT) - 1); memory_notify(MEM_CANCEL_ONLINE, &arg); unlock_memory_hotplug(); return ret; } zone->present_pages += onlined_pages; zone->zone_pgdat->node_present_pages += onlined_pages; if (onlined_pages) { node_set_state(zone_to_nid(zone), N_HIGH_MEMORY); if (need_zonelists_rebuild) build_all_zonelists(NULL, zone); else zone_pcp_update(zone); } mutex_unlock(&zonelists_mutex); init_per_zone_wmark_min(); if (onlined_pages) kswapd_run(zone_to_nid(zone)); vm_total_pages = nr_free_pagecache_pages(); writeback_set_ratelimit(); if (onlined_pages) memory_notify(MEM_ONLINE, &arg); unlock_memory_hotplug(); return 0; }"
577,527----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-1792--process_keys.c----install_user_keyrings,"int install_user_keyrings(void) { struct user_struct *user; const struct cred *cred; struct key *uid_keyring, *session_keyring; key_perm_t user_keyring_perm; char buf[20]; int ret; uid_t uid; user_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL; cred = current_cred(); user = cred->user; uid = from_kuid(cred->user_ns, user->uid); kenter(""%p{%u}"", user, uid); <S2SV_StartVul> if (user->uid_keyring) { <S2SV_EndVul> kleave("" = 0 [exist]""); return 0; } mutex_lock(&key_user_keyring_mutex); ret = 0; if (!user->uid_keyring) { sprintf(buf, ""_uid.%u"", uid); uid_keyring = find_keyring_by_name(buf, true); if (IS_ERR(uid_keyring)) { uid_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_IN_QUOTA, NULL); if (IS_ERR(uid_keyring)) { ret = PTR_ERR(uid_keyring); goto error; } } sprintf(buf, ""_uid_ses.%u"", uid); session_keyring = find_keyring_by_name(buf, true); if (IS_ERR(session_keyring)) { session_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_IN_QUOTA, NULL); if (IS_ERR(session_keyring)) { ret = PTR_ERR(session_keyring); goto error_release; } ret = key_link(session_keyring, uid_keyring); if (ret < 0) goto error_release_both; } user->uid_keyring = uid_keyring; user->session_keyring = session_keyring; } mutex_unlock(&key_user_keyring_mutex); kleave("" = 0""); return 0; error_release_both: key_put(session_keyring); error_release: key_put(uid_keyring); error: mutex_unlock(&key_user_keyring_mutex); kleave("" = %d"", ret); return ret; }","- if (user->uid_keyring) {
+ if (user->uid_keyring && user->session_keyring) {","int install_user_keyrings(void) { struct user_struct *user; const struct cred *cred; struct key *uid_keyring, *session_keyring; key_perm_t user_keyring_perm; char buf[20]; int ret; uid_t uid; user_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL; cred = current_cred(); user = cred->user; uid = from_kuid(cred->user_ns, user->uid); kenter(""%p{%u}"", user, uid); if (user->uid_keyring && user->session_keyring) { kleave("" = 0 [exist]""); return 0; } mutex_lock(&key_user_keyring_mutex); ret = 0; if (!user->uid_keyring) { sprintf(buf, ""_uid.%u"", uid); uid_keyring = find_keyring_by_name(buf, true); if (IS_ERR(uid_keyring)) { uid_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_IN_QUOTA, NULL); if (IS_ERR(uid_keyring)) { ret = PTR_ERR(uid_keyring); goto error; } } sprintf(buf, ""_uid_ses.%u"", uid); session_keyring = find_keyring_by_name(buf, true); if (IS_ERR(session_keyring)) { session_keyring = keyring_alloc(buf, user->uid, INVALID_GID, cred, user_keyring_perm, KEY_ALLOC_IN_QUOTA, NULL); if (IS_ERR(session_keyring)) { ret = PTR_ERR(session_keyring); goto error_release; } ret = key_link(session_keyring, uid_keyring); if (ret < 0) goto error_release_both; } user->uid_keyring = uid_keyring; user->session_keyring = session_keyring; } mutex_unlock(&key_user_keyring_mutex); kleave("" = 0""); return 0; error_release_both: key_put(session_keyring); error_release: key_put(uid_keyring); error: mutex_unlock(&key_user_keyring_mutex); kleave("" = %d"", ret); return ret; }"
578,5397----CWE-276----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/serverpackethandler.cpp----Server::handleCommand_InventoryAction,"void Server::handleCommand_InventoryAction(NetworkPacket* pkt) { session_t peer_id = pkt->getPeerId(); RemotePlayer *player = m_env->getPlayer(peer_id); if (player == NULL) { errorstream << ""Server::ProcessData(): Canceling: No player for peer_id="" << peer_id << "" disconnecting peer!"" << std::endl; DisconnectPeer(peer_id); return; } PlayerSAO *playersao = player->getPlayerSAO(); if (playersao == NULL) { errorstream << ""Server::ProcessData(): Canceling: No player object for peer_id="" << peer_id << "" disconnecting peer!"" << std::endl; DisconnectPeer(peer_id); return; } std::string datastring(pkt->getString(0), pkt->getSize()); verbosestream << ""TOSERVER_INVENTORY_ACTION: data="" << datastring << std::endl; std::istringstream is(datastring, std::ios_base::binary); InventoryAction *a = InventoryAction::deSerialize(is); if (!a) { infostream << ""TOSERVER_INVENTORY_ACTION: "" << ""InventoryAction::deSerialize() returned NULL"" << std::endl; return; } RollbackScopeActor rollback_scope(m_rollback, std::string(""player:"")+player->getName()); if (a->getType() == IAction::Move) { IMoveAction *ma = (IMoveAction*)a; ma->from_inv.applyCurrentPlayer(player->getName()); ma->to_inv.applyCurrentPlayer(player->getName()); m_inventory_mgr->setInventoryModified(ma->from_inv); if (ma->from_inv != ma->to_inv) m_inventory_mgr->setInventoryModified(ma->to_inv); <S2SV_StartVul> bool from_inv_is_current_player = <S2SV_EndVul> <S2SV_StartVul> (ma->from_inv.type == InventoryLocation::PLAYER) && <S2SV_EndVul> <S2SV_StartVul> (ma->from_inv.name == player->getName()); <S2SV_EndVul> <S2SV_StartVul> bool to_inv_is_current_player = <S2SV_EndVul> <S2SV_StartVul> (ma->to_inv.type == InventoryLocation::PLAYER) && <S2SV_EndVul> <S2SV_StartVul> (ma->to_inv.name == player->getName()); <S2SV_EndVul> InventoryLocation *remote = from_inv_is_current_player ? &ma->to_inv : &ma->from_inv; if (remote->type == InventoryLocation::NODEMETA) { v3f node_pos = intToFloat(remote->p, BS); v3f player_pos = player->getPlayerSAO()->getEyePosition(); f32 d = player_pos.getDistanceFrom(node_pos); if (!checkInteractDistance(player, d, ""inventory"")) return; } if (ma->from_list == ""craftpreview"") { infostream << ""Ignoring IMoveAction from "" << (ma->from_inv.dump()) << "":"" << ma->from_list << "" to "" << (ma->to_inv.dump()) << "":"" << ma->to_list << "" because src is "" << ma->from_list << std::endl; delete a; return; } if (ma->to_list == ""craftpreview"" || ma->to_list == ""craftresult"") { infostream << ""Ignoring IMoveAction from "" << (ma->from_inv.dump()) << "":"" << ma->from_list << "" to "" << (ma->to_inv.dump()) << "":"" << ma->to_list << "" because dst is "" << ma->to_list << std::endl; delete a; return; } if (!checkPriv(player->getName(), ""interact"") && (!from_inv_is_current_player || !to_inv_is_current_player)) { infostream << ""Cannot move outside of player's inventory: "" << ""No interact privilege"" << std::endl; delete a; return; } } else if (a->getType() == IAction::Drop) { IDropAction *da = (IDropAction*)a; da->from_inv.applyCurrentPlayer(player->getName()); m_inventory_mgr->setInventoryModified(da->from_inv); if (da->from_list == ""craftpreview"") { infostream << ""Ignoring IDropAction from "" << (da->from_inv.dump()) << "":"" << da->from_list << "" because src is "" << da->from_list << std::endl; delete a; return; } if (!checkPriv(player->getName(), ""interact"")) { delete a; return; } if (playersao->isDead()) { infostream << ""Ignoring IDropAction from "" << (da->from_inv.dump()) << "":"" << da->from_list << "" because player is dead."" << std::endl; delete a; return; } } else if (a->getType() == IAction::Craft) { ICraftAction *ca = (ICraftAction*)a; ca->craft_inv.applyCurrentPlayer(player->getName()); m_inventory_mgr->setInventoryModified(ca->craft_inv); if (!checkPriv(player->getName(), ""interact"")) { infostream << ""Cannot craft: "" << ""No interact privilege"" << std::endl; delete a; return; } } a->apply(m_inventory_mgr.get(), playersao, this); delete a; }","- bool from_inv_is_current_player =
- (ma->from_inv.type == InventoryLocation::PLAYER) &&
- (ma->from_inv.name == player->getName());
- bool to_inv_is_current_player =
- (ma->to_inv.type == InventoryLocation::PLAYER) &&
- (ma->to_inv.name == player->getName());
+ bool from_inv_is_current_player = false;
+ if (ma->from_inv.type == InventoryLocation::PLAYER) {
+ if (ma->from_inv.name != player->getName())
+ return;
+ from_inv_is_current_player = true;
+ }
+ bool to_inv_is_current_player = false;
+ if (ma->to_inv.type == InventoryLocation::PLAYER) {
+ if (ma->to_inv.name != player->getName())
+ return;
+ to_inv_is_current_player = true;
+ }","void Server::handleCommand_InventoryAction(NetworkPacket* pkt) { session_t peer_id = pkt->getPeerId(); RemotePlayer *player = m_env->getPlayer(peer_id); if (player == NULL) { errorstream << ""Server::ProcessData(): Canceling: No player for peer_id="" << peer_id << "" disconnecting peer!"" << std::endl; DisconnectPeer(peer_id); return; } PlayerSAO *playersao = player->getPlayerSAO(); if (playersao == NULL) { errorstream << ""Server::ProcessData(): Canceling: No player object for peer_id="" << peer_id << "" disconnecting peer!"" << std::endl; DisconnectPeer(peer_id); return; } std::string datastring(pkt->getString(0), pkt->getSize()); verbosestream << ""TOSERVER_INVENTORY_ACTION: data="" << datastring << std::endl; std::istringstream is(datastring, std::ios_base::binary); InventoryAction *a = InventoryAction::deSerialize(is); if (!a) { infostream << ""TOSERVER_INVENTORY_ACTION: "" << ""InventoryAction::deSerialize() returned NULL"" << std::endl; return; } RollbackScopeActor rollback_scope(m_rollback, std::string(""player:"")+player->getName()); if (a->getType() == IAction::Move) { IMoveAction *ma = (IMoveAction*)a; ma->from_inv.applyCurrentPlayer(player->getName()); ma->to_inv.applyCurrentPlayer(player->getName()); m_inventory_mgr->setInventoryModified(ma->from_inv); if (ma->from_inv != ma->to_inv) m_inventory_mgr->setInventoryModified(ma->to_inv); bool from_inv_is_current_player = false; if (ma->from_inv.type == InventoryLocation::PLAYER) { if (ma->from_inv.name != player->getName()) return; from_inv_is_current_player = true; } bool to_inv_is_current_player = false; if (ma->to_inv.type == InventoryLocation::PLAYER) { if (ma->to_inv.name != player->getName()) return; to_inv_is_current_player = true; } InventoryLocation *remote = from_inv_is_current_player ? &ma->to_inv : &ma->from_inv; if (remote->type == InventoryLocation::NODEMETA) { v3f node_pos = intToFloat(remote->p, BS); v3f player_pos = player->getPlayerSAO()->getEyePosition(); f32 d = player_pos.getDistanceFrom(node_pos); if (!checkInteractDistance(player, d, ""inventory"")) return; } if (ma->from_list == ""craftpreview"") { infostream << ""Ignoring IMoveAction from "" << (ma->from_inv.dump()) << "":"" << ma->from_list << "" to "" << (ma->to_inv.dump()) << "":"" << ma->to_list << "" because src is "" << ma->from_list << std::endl; delete a; return; } if (ma->to_list == ""craftpreview"" || ma->to_list == ""craftresult"") { infostream << ""Ignoring IMoveAction from "" << (ma->from_inv.dump()) << "":"" << ma->from_list << "" to "" << (ma->to_inv.dump()) << "":"" << ma->to_list << "" because dst is "" << ma->to_list << std::endl; delete a; return; } if (!checkPriv(player->getName(), ""interact"") && (!from_inv_is_current_player || !to_inv_is_current_player)) { infostream << ""Cannot move outside of player's inventory: "" << ""No interact privilege"" << std::endl; delete a; return; } } else if (a->getType() == IAction::Drop) { IDropAction *da = (IDropAction*)a; da->from_inv.applyCurrentPlayer(player->getName()); m_inventory_mgr->setInventoryModified(da->from_inv); if (da->from_list == ""craftpreview"") { infostream << ""Ignoring IDropAction from "" << (da->from_inv.dump()) << "":"" << da->from_list << "" because src is "" << da->from_list << std::endl; delete a; return; } if (!checkPriv(player->getName(), ""interact"")) { delete a; return; } if (playersao->isDead()) { infostream << ""Ignoring IDropAction from "" << (da->from_inv.dump()) << "":"" << da->from_list << "" because player is dead."" << std::endl; delete a; return; } } else if (a->getType() == IAction::Craft) { ICraftAction *ca = (ICraftAction*)a; ca->craft_inv.applyCurrentPlayer(player->getName()); m_inventory_mgr->setInventoryModified(ca->craft_inv); if (!checkPriv(player->getName(), ""interact"")) { infostream << ""Cannot craft: "" << ""No interact privilege"" << std::endl; delete a; return; } } a->apply(m_inventory_mgr.get(), playersao, this); delete a; }"
579,3561----CWE-674----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/FBSerialize-inl.h----HPHP::serialize::FBUnserializer<V>::unserializeThing,"<S2SV_StartVul> inline typename V::VariantType FBUnserializer<V>::unserializeThing() { <S2SV_EndVul> size_t code = nextCode(); switch (code) { case FB_SERIALIZE_BYTE: case FB_SERIALIZE_I16: case FB_SERIALIZE_I32: case FB_SERIALIZE_I64: return V::fromInt64(unserializeInt64()); case FB_SERIALIZE_VARCHAR: case FB_SERIALIZE_STRING: return V::fromString(unserializeString()); case FB_SERIALIZE_STRUCT: <S2SV_StartVul> return V::fromMap(unserializeMap()); <S2SV_EndVul> case FB_SERIALIZE_NULL: ++p_; return V::createNull(); case FB_SERIALIZE_DOUBLE: return V::fromDouble(unserializeDouble()); case FB_SERIALIZE_BOOLEAN: return V::fromBool(unserializeBoolean()); case FB_SERIALIZE_VECTOR: <S2SV_StartVul> return V::fromVector(unserializeVector()); <S2SV_EndVul> case FB_SERIALIZE_LIST: <S2SV_StartVul> return V::fromVector(unserializeList()); <S2SV_EndVul> case FB_SERIALIZE_SET: <S2SV_StartVul> return V::fromSet(unserializeSet()); <S2SV_EndVul> default: throw UnserializeError(""Invalid code: "" + folly::to<std::string>(code) + "" at location "" + folly::to<std::string>(p_)); } }","- inline typename V::VariantType FBUnserializer<V>::unserializeThing() {
- return V::fromMap(unserializeMap());
- return V::fromVector(unserializeVector());
- return V::fromVector(unserializeList());
- return V::fromSet(unserializeSet());
+ FBUnserializer<V>::unserializeThing(size_t depth) {
+ if (UNLIKELY(depth > 1024)) {
+ throw UnserializeError(""depth > 1024"");
+ }
+ return V::fromMap(unserializeMap(depth));
+ return V::fromVector(unserializeVector(depth));
+ return V::fromVector(unserializeList(depth));
+ return V::fromSet(unserializeSet(depth));","FBUnserializer<V>::unserializeThing(size_t depth) { if (UNLIKELY(depth > 1024)) { throw UnserializeError(""depth > 1024""); } size_t code = nextCode(); switch (code) { case FB_SERIALIZE_BYTE: case FB_SERIALIZE_I16: case FB_SERIALIZE_I32: case FB_SERIALIZE_I64: return V::fromInt64(unserializeInt64()); case FB_SERIALIZE_VARCHAR: case FB_SERIALIZE_STRING: return V::fromString(unserializeString()); case FB_SERIALIZE_STRUCT: return V::fromMap(unserializeMap(depth)); case FB_SERIALIZE_NULL: ++p_; return V::createNull(); case FB_SERIALIZE_DOUBLE: return V::fromDouble(unserializeDouble()); case FB_SERIALIZE_BOOLEAN: return V::fromBool(unserializeBoolean()); case FB_SERIALIZE_VECTOR: return V::fromVector(unserializeVector(depth)); case FB_SERIALIZE_LIST: return V::fromVector(unserializeList(depth)); case FB_SERIALIZE_SET: return V::fromSet(unserializeSet(depth)); default: throw UnserializeError(""Invalid code: "" + folly::to<std::string>(code) + "" at location "" + folly::to<std::string>(p_)); } }"
580,2450----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3346--scsi-disk.c----scsi_read_data,"static void scsi_read_data(SCSIRequest *req) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; if (r->sector_count == (uint32_t)-1) { DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len); r->sector_count = 0; scsi_req_data(&r->req, r->iov.iov_len); return; } DPRINTF(""Read sector_count=%d\n"", r->sector_count); if (r->sector_count == 0) { scsi_req_complete(&r->req, GOOD); return; } assert(r->req.aiocb == NULL); <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> if (r->req.cmd.mode == SCSI_XFER_TO_DEV) { <S2SV_EndVul> <S2SV_StartVul> DPRINTF(""Data transfer direction invalid\n""); <S2SV_EndVul> scsi_read_complete(r, -EINVAL); return; } <S2SV_StartVul> n = r->sector_count; <S2SV_EndVul> <S2SV_StartVul> if (n > SCSI_DMA_BUF_SIZE / 512) <S2SV_EndVul> n = SCSI_DMA_BUF_SIZE / 512; if (s->tray_open) { scsi_read_complete(r, -ENOMEDIUM); } r->iov.iov_len = n * 512; qemu_iovec_init_external(&r->qiov, &r->iov, 1); bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ); r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n, scsi_read_complete, r); if (r->req.aiocb == NULL) { scsi_read_complete(r, -EIO); } }","- 
- if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {
- DPRINTF(""Data transfer direction invalid\n"");
- n = r->sector_count;
- if (n > SCSI_DMA_BUF_SIZE / 512)
+ if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {","static void scsi_read_data(SCSIRequest *req) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; if (r->sector_count == (uint32_t)-1) { DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len); r->sector_count = 0; scsi_req_data(&r->req, r->iov.iov_len); return; } DPRINTF(""Read sector_count=%d\n"", r->sector_count); if (r->sector_count == 0) { scsi_req_complete(&r->req, GOOD); return; } assert(r->req.aiocb == NULL); if (r->req.cmd.mode == SCSI_XFER_TO_DEV) { DPRINTF(""Data transfer direction invalid\n""); scsi_read_complete(r, -EINVAL); return; } if (s->tray_open) { scsi_read_complete(r, -ENOMEDIUM); } n = scsi_init_iovec(r); bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ); r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n, scsi_read_complete, r); if (r->req.aiocb == NULL) { scsi_read_complete(r, -EIO); } }"
581,1043--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4470--key.c----key_reject_and_link,"int key_reject_and_link(struct key *key, unsigned timeout, unsigned error, struct key *keyring, struct key *authkey) { struct assoc_array_edit *edit; struct timespec now; int ret, awaken, link_ret = 0; key_check(key); key_check(keyring); awaken = 0; ret = -EBUSY; if (keyring) { if (keyring->restrict_link) return -EPERM; link_ret = __key_link_begin(keyring, &key->index_key, &edit); } mutex_lock(&key_construction_mutex); if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) { atomic_inc(&key->user->nikeys); key->reject_error = -error; smp_wmb(); set_bit(KEY_FLAG_NEGATIVE, &key->flags); set_bit(KEY_FLAG_INSTANTIATED, &key->flags); now = current_kernel_time(); key->expiry = now.tv_sec + timeout; key_schedule_gc(key->expiry + key_gc_delay); if (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) awaken = 1; ret = 0; if (keyring && link_ret == 0) __key_link(key, &edit); if (authkey) key_revoke(authkey); } mutex_unlock(&key_construction_mutex); <S2SV_StartVul> if (keyring) <S2SV_EndVul> __key_link_end(keyring, &key->index_key, edit); if (awaken) wake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT); return ret == 0 ? link_ret : ret; }","- if (keyring)
+ if (keyring && link_ret == 0)","int key_reject_and_link(struct key *key, unsigned timeout, unsigned error, struct key *keyring, struct key *authkey) { struct assoc_array_edit *edit; struct timespec now; int ret, awaken, link_ret = 0; key_check(key); key_check(keyring); awaken = 0; ret = -EBUSY; if (keyring) { if (keyring->restrict_link) return -EPERM; link_ret = __key_link_begin(keyring, &key->index_key, &edit); } mutex_lock(&key_construction_mutex); if (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) { atomic_inc(&key->user->nikeys); key->reject_error = -error; smp_wmb(); set_bit(KEY_FLAG_NEGATIVE, &key->flags); set_bit(KEY_FLAG_INSTANTIATED, &key->flags); now = current_kernel_time(); key->expiry = now.tv_sec + timeout; key_schedule_gc(key->expiry + key_gc_delay); if (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) awaken = 1; ret = 0; if (keyring && link_ret == 0) __key_link(key, &edit); if (authkey) key_revoke(authkey); } mutex_unlock(&key_construction_mutex); if (keyring && link_ret == 0) __key_link_end(keyring, &key->index_key, edit); if (awaken) wake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT); return ret == 0 ? link_ret : ret; }"
582,3420----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sas_expander.c----sas_ex_revalidate_domain,"int sas_ex_revalidate_domain(struct domain_device *port_dev) { int res; struct domain_device *dev = NULL; res = sas_find_bcast_dev(port_dev, &dev); <S2SV_StartVul> while (res == 0 && dev) { <S2SV_EndVul> struct expander_device *ex = &dev->ex_dev; int i = 0, phy_id; do { phy_id = -1; res = sas_find_bcast_phy(dev, &phy_id, i, true); if (phy_id == -1) break; res = sas_rediscover(dev, phy_id); i = phy_id + 1; } while (i < ex->num_phys); <S2SV_StartVul> dev = NULL; <S2SV_EndVul> <S2SV_StartVul> res = sas_find_bcast_dev(port_dev, &dev); <S2SV_EndVul> } return res; }","- while (res == 0 && dev) {
- dev = NULL;
- res = sas_find_bcast_dev(port_dev, &dev);
+ if (res == 0 && dev) {","int sas_ex_revalidate_domain(struct domain_device *port_dev) { int res; struct domain_device *dev = NULL; res = sas_find_bcast_dev(port_dev, &dev); if (res == 0 && dev) { struct expander_device *ex = &dev->ex_dev; int i = 0, phy_id; do { phy_id = -1; res = sas_find_bcast_phy(dev, &phy_id, i, true); if (phy_id == -1) break; res = sas_rediscover(dev, phy_id); i = phy_id + 1; } while (i < ex->num_phys); } return res; }"
583,5373----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/http.c----addFormVars,"static void addFormVars(cchar *buf) { char *pair, *tok; pair = stok(sclone(buf), ""&"", &tok); <S2SV_StartVul> while (pair != 0) { <S2SV_EndVul> mprAddItem(app->formData, sclone(pair)); pair = stok(0, ""&"", &tok); } }","- while (pair != 0) {
+ while (pair) {","static void addFormVars(cchar *buf) { char *pair, *tok; pair = stok(sclone(buf), ""&"", &tok); while (pair) { mprAddItem(app->formData, sclone(pair)); pair = stok(0, ""&"", &tok); } }"
584,702----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-2669--geo_ops.c----path_in,"path_in(PG_FUNCTION_ARGS) { char *str = PG_GETARG_CSTRING(0); PATH *path; int isopen; char *s; int npts; int size; int depth = 0; if ((npts = pair_count(str, ',')) <= 0) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type path: \""%s\"""", str))); s = str; while (isspace((unsigned char) *s)) s++; if ((*s == LDELIM) && (strrchr(s, LDELIM) == s)) { s++; depth++; } <S2SV_StartVul> size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts; <S2SV_EndVul> path = (PATH *) palloc(size); SET_VARSIZE(path, size); path->npts = npts; if ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0]))) && (!((depth == 0) && (*s == '\0'))) && !((depth >= 1) && (*s == RDELIM))) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type path: \""%s\"""", str))); path->closed = (!isopen); path->dummy = 0; PG_RETURN_PATH_P(path); }","- size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;
+ int base_size;
+ base_size = sizeof(path->p[0]) * npts;
+ size = offsetof(PATH, p[0]) + base_size;
+ if (base_size / npts != sizeof(path->p[0]) || size <= base_size)
+ ereport(ERROR,
+ (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),
+ errmsg(""too many points requested"")));","path_in(PG_FUNCTION_ARGS) { char *str = PG_GETARG_CSTRING(0); PATH *path; int isopen; char *s; int npts; int size; int base_size; int depth = 0; if ((npts = pair_count(str, ',')) <= 0) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type path: \""%s\"""", str))); s = str; while (isspace((unsigned char) *s)) s++; if ((*s == LDELIM) && (strrchr(s, LDELIM) == s)) { s++; depth++; } base_size = sizeof(path->p[0]) * npts; size = offsetof(PATH, p[0]) + base_size; if (base_size / npts != sizeof(path->p[0]) || size <= base_size) ereport(ERROR, (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED), errmsg(""too many points requested""))); path = (PATH *) palloc(size); SET_VARSIZE(path, size); path->npts = npts; if ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0]))) && (!((depth == 0) && (*s == '\0'))) && !((depth >= 1) && (*s == RDELIM))) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION), errmsg(""invalid input syntax for type path: \""%s\"""", str))); path->closed = (!isopen); path->dummy = 0; PG_RETURN_PATH_P(path); }"
585,4233----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cl_main.cpp----CL_InitRef,"void CL_InitRef( void ) { static refimport_t ri; refexport_t *ret; GetRefAPI_t GetRefAPI; char dllName[MAX_OSPATH]; Com_Printf( ""----- Initializing Renderer ----\n"" ); <S2SV_StartVul> cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH, ""Which renderer library to use"" ); <S2SV_EndVul> Com_sprintf( dllName, sizeof( dllName ), ""%s_"" ARCH_STRING DLL_EXT, cl_renderer->string ); if( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) ) { Com_Printf( ""failed: trying to load fallback renderer\n"" ); Cvar_ForceReset( ""cl_renderer"" ); Com_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY ""_"" ARCH_STRING DLL_EXT ); rendererLib = Sys_LoadDll( dllName, qfalse ); } if ( !rendererLib ) { Com_Error( ERR_FATAL, ""Failed to load renderer\n"" ); } memset( &ri, 0, sizeof( ri ) ); GetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, ""GetRefAPI"" ); if ( !GetRefAPI ) Com_Error( ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"", Sys_LibraryError() ); ri.Printf = CL_RefPrintf; ri.Error = Com_Error; ri.OPrintf = Com_OPrintf; ri.Milliseconds = Sys_Milliseconds2; ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory; ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory; ri.Hunk_Alloc = Hunk_Alloc; ri.Hunk_MemoryRemaining = Hunk_MemoryRemaining; ri.Z_Malloc = Z_Malloc; ri.Z_Free = Z_Free; ri.Z_MemSize = Z_MemSize; ri.Z_MorphMallocTag = Z_MorphMallocTag; ri.Cmd_ExecuteString = Cmd_ExecuteString; ri.Cmd_Argc = Cmd_Argc; ri.Cmd_Argv = Cmd_Argv; ri.Cmd_ArgsBuffer = Cmd_ArgsBuffer; ri.Cmd_AddCommand = Cmd_AddCommand; ri.Cmd_RemoveCommand = Cmd_RemoveCommand; ri.Cvar_Set = Cvar_Set; ri.Cvar_Get = Cvar_Get; ri.Cvar_SetValue = Cvar_SetValue; ri.Cvar_CheckRange = Cvar_CheckRange; ri.Cvar_VariableStringBuffer = Cvar_VariableStringBuffer; ri.Cvar_VariableString = Cvar_VariableString; ri.Cvar_VariableValue = Cvar_VariableValue; ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue; ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory; ri.SE_GetString = SE_GetString; ri.FS_FreeFile = FS_FreeFile; ri.FS_FreeFileList = FS_FreeFileList; ri.FS_Read = FS_Read; ri.FS_ReadFile = FS_ReadFile; ri.FS_FCloseFile = FS_FCloseFile; ri.FS_FOpenFileRead = FS_FOpenFileRead; ri.FS_FOpenFileWrite = FS_FOpenFileWrite; ri.FS_FOpenFileByMode = FS_FOpenFileByMode; ri.FS_FileExists = FS_FileExists; ri.FS_FileIsInPAK = FS_FileIsInPAK; ri.FS_ListFiles = FS_ListFiles; ri.FS_Write = FS_Write; ri.FS_WriteFile = FS_WriteFile; ri.CM_BoxTrace = CM_BoxTrace; ri.CM_DrawDebugSurface = CM_DrawDebugSurface; ri.CM_CullWorldBox = CM_CullWorldBox; ri.CM_ClusterPVS = CM_ClusterPVS; ri.CM_LeafArea = CM_LeafArea; ri.CM_LeafCluster = CM_LeafCluster; ri.CM_PointLeafnum = CM_PointLeafnum; ri.CM_PointContents = CM_PointContents; ri.Com_TheHunkMarkHasBeenMade = Com_TheHunkMarkHasBeenMade; ri.S_RestartMusic = S_RestartMusic; ri.SND_RegisterAudio_LevelLoadEnd = SND_RegisterAudio_LevelLoadEnd; ri.CIN_RunCinematic = CIN_RunCinematic; ri.CIN_PlayCinematic = CIN_PlayCinematic; ri.CIN_UploadCinematic = CIN_UploadCinematic; ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame; ri.GetSharedMemory = GetSharedMemory; ri.GetCurrentVM = GetCurrentVM; ri.CGVMLoaded = CGVMLoaded; ri.CGVM_RagCallback = CGVM_RagCallback; ri.WIN_Init = WIN_Init; ri.WIN_SetGamma = WIN_SetGamma; ri.WIN_Shutdown = WIN_Shutdown; ri.WIN_Present = WIN_Present; ri.GL_GetProcAddress = WIN_GL_GetProcAddress; ri.GL_ExtensionSupported = WIN_GL_ExtensionSupported; ri.CM_GetCachedMapDiskImage = CM_GetCachedMapDiskImage; ri.CM_SetCachedMapDiskImage = CM_SetCachedMapDiskImage; ri.CM_SetUsingCache = CM_SetUsingCache; ri.GetG2VertSpaceServer = GetG2VertSpaceServer; G2VertSpaceServer = &IHeapAllocator_singleton; ri.PD_Store = PD_Store; ri.PD_Load = PD_Load; ret = GetRefAPI( REF_API_VERSION, &ri ); if ( !ret ) { Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" ); } re = ret; Cvar_Set( ""cl_paused"", ""0"" ); }","- cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH, ""Which renderer library to use"" );
+ cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED, ""Which renderer library to use"" );","void CL_InitRef( void ) { static refimport_t ri; refexport_t *ret; GetRefAPI_t GetRefAPI; char dllName[MAX_OSPATH]; Com_Printf( ""----- Initializing Renderer ----\n"" ); cl_renderer = Cvar_Get( ""cl_renderer"", DEFAULT_RENDER_LIBRARY, CVAR_ARCHIVE|CVAR_LATCH|CVAR_PROTECTED, ""Which renderer library to use"" ); Com_sprintf( dllName, sizeof( dllName ), ""%s_"" ARCH_STRING DLL_EXT, cl_renderer->string ); if( !(rendererLib = Sys_LoadDll( dllName, qfalse )) && strcmp( cl_renderer->string, cl_renderer->resetString ) ) { Com_Printf( ""failed: trying to load fallback renderer\n"" ); Cvar_ForceReset( ""cl_renderer"" ); Com_sprintf( dllName, sizeof( dllName ), DEFAULT_RENDER_LIBRARY ""_"" ARCH_STRING DLL_EXT ); rendererLib = Sys_LoadDll( dllName, qfalse ); } if ( !rendererLib ) { Com_Error( ERR_FATAL, ""Failed to load renderer\n"" ); } memset( &ri, 0, sizeof( ri ) ); GetRefAPI = (GetRefAPI_t)Sys_LoadFunction( rendererLib, ""GetRefAPI"" ); if ( !GetRefAPI ) Com_Error( ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"", Sys_LibraryError() ); ri.Printf = CL_RefPrintf; ri.Error = Com_Error; ri.OPrintf = Com_OPrintf; ri.Milliseconds = Sys_Milliseconds2; ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory; ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory; ri.Hunk_Alloc = Hunk_Alloc; ri.Hunk_MemoryRemaining = Hunk_MemoryRemaining; ri.Z_Malloc = Z_Malloc; ri.Z_Free = Z_Free; ri.Z_MemSize = Z_MemSize; ri.Z_MorphMallocTag = Z_MorphMallocTag; ri.Cmd_ExecuteString = Cmd_ExecuteString; ri.Cmd_Argc = Cmd_Argc; ri.Cmd_Argv = Cmd_Argv; ri.Cmd_ArgsBuffer = Cmd_ArgsBuffer; ri.Cmd_AddCommand = Cmd_AddCommand; ri.Cmd_RemoveCommand = Cmd_RemoveCommand; ri.Cvar_Set = Cvar_Set; ri.Cvar_Get = Cvar_Get; ri.Cvar_SetValue = Cvar_SetValue; ri.Cvar_CheckRange = Cvar_CheckRange; ri.Cvar_VariableStringBuffer = Cvar_VariableStringBuffer; ri.Cvar_VariableString = Cvar_VariableString; ri.Cvar_VariableValue = Cvar_VariableValue; ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue; ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory; ri.SE_GetString = SE_GetString; ri.FS_FreeFile = FS_FreeFile; ri.FS_FreeFileList = FS_FreeFileList; ri.FS_Read = FS_Read; ri.FS_ReadFile = FS_ReadFile; ri.FS_FCloseFile = FS_FCloseFile; ri.FS_FOpenFileRead = FS_FOpenFileRead; ri.FS_FOpenFileWrite = FS_FOpenFileWrite; ri.FS_FOpenFileByMode = FS_FOpenFileByMode; ri.FS_FileExists = FS_FileExists; ri.FS_FileIsInPAK = FS_FileIsInPAK; ri.FS_ListFiles = FS_ListFiles; ri.FS_Write = FS_Write; ri.FS_WriteFile = FS_WriteFile; ri.CM_BoxTrace = CM_BoxTrace; ri.CM_DrawDebugSurface = CM_DrawDebugSurface; ri.CM_CullWorldBox = CM_CullWorldBox; ri.CM_ClusterPVS = CM_ClusterPVS; ri.CM_LeafArea = CM_LeafArea; ri.CM_LeafCluster = CM_LeafCluster; ri.CM_PointLeafnum = CM_PointLeafnum; ri.CM_PointContents = CM_PointContents; ri.Com_TheHunkMarkHasBeenMade = Com_TheHunkMarkHasBeenMade; ri.S_RestartMusic = S_RestartMusic; ri.SND_RegisterAudio_LevelLoadEnd = SND_RegisterAudio_LevelLoadEnd; ri.CIN_RunCinematic = CIN_RunCinematic; ri.CIN_PlayCinematic = CIN_PlayCinematic; ri.CIN_UploadCinematic = CIN_UploadCinematic; ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame; ri.GetSharedMemory = GetSharedMemory; ri.GetCurrentVM = GetCurrentVM; ri.CGVMLoaded = CGVMLoaded; ri.CGVM_RagCallback = CGVM_RagCallback; ri.WIN_Init = WIN_Init; ri.WIN_SetGamma = WIN_SetGamma; ri.WIN_Shutdown = WIN_Shutdown; ri.WIN_Present = WIN_Present; ri.GL_GetProcAddress = WIN_GL_GetProcAddress; ri.GL_ExtensionSupported = WIN_GL_ExtensionSupported; ri.CM_GetCachedMapDiskImage = CM_GetCachedMapDiskImage; ri.CM_SetCachedMapDiskImage = CM_SetCachedMapDiskImage; ri.CM_SetUsingCache = CM_SetUsingCache; ri.GetG2VertSpaceServer = GetG2VertSpaceServer; G2VertSpaceServer = &IHeapAllocator_singleton; ri.PD_Store = PD_Store; ri.PD_Load = PD_Load; ret = GetRefAPI( REF_API_VERSION, &ri ); if ( !ret ) { Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" ); } re = ret; Cvar_Set( ""cl_paused"", ""0"" ); }"
586,2206----CWE-120----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-17113--libopenmpt_modplug.c----ModPlug_SampleName,"LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff) { const char* str; <S2SV_StartVul> unsigned int retval; <S2SV_EndVul> <S2SV_StartVul> size_t tmpretval; <S2SV_EndVul> if(!file) return 0; str = openmpt_module_get_sample_name(file->mod,qual-1); <S2SV_StartVul> if(!str){ <S2SV_EndVul> <S2SV_StartVul> if(buff){ <S2SV_EndVul> <S2SV_StartVul> *buff = '\0'; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> tmpretval = strlen(str); <S2SV_EndVul> <S2SV_StartVul> if(tmpretval>=INT_MAX){ <S2SV_EndVul> <S2SV_StartVul> tmpretval = INT_MAX-1; <S2SV_EndVul> } <S2SV_StartVul> retval = (int)tmpretval; <S2SV_EndVul> if(buff){ <S2SV_StartVul> memcpy(buff,str,retval+1); <S2SV_EndVul> <S2SV_StartVul> buff[retval] = '\0'; <S2SV_EndVul> } <S2SV_StartVul> openmpt_free_string(str); <S2SV_EndVul> <S2SV_StartVul> return retval; <S2SV_EndVul> }","- unsigned int retval;
- size_t tmpretval;
- if(!str){
- if(buff){
- }
- return 0;
- }
- tmpretval = strlen(str);
- if(tmpretval>=INT_MAX){
- tmpretval = INT_MAX-1;
- retval = (int)tmpretval;
- memcpy(buff,str,retval+1);
- buff[retval] = '\0';
- openmpt_free_string(str);
- return retval;
+ char buf[32];
+ memset(buf,0,32);
+ if(str){
+ strncpy(buf,str,31);
+ openmpt_free_string(str);
+ strncpy(buff,buf,32);
+ return (unsigned int)strlen(buf);","LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff) { const char* str; char buf[32]; if(!file) return 0; str = openmpt_module_get_sample_name(file->mod,qual-1); memset(buf,0,32); if(str){ strncpy(buf,str,31); openmpt_free_string(str); } if(buff){ strncpy(buff,buf,32); } return (unsigned int)strlen(buf); }"
587,6284----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/httpLib.c----httpWriteUploadData,"PUBLIC ssize httpWriteUploadData(HttpConn *conn, MprList *fileData, MprList *formData) { char *path, *pair, *key, *value, *name; cchar *type; ssize rc; int next; rc = 0; if (formData) { for (rc = next = 0; rc >= 0 && (pair = mprGetNextItem(formData, &next)) != 0; ) { <S2SV_StartVul> key = stok(sclone(pair), ""="", &value); <S2SV_EndVul> rc += httpWrite(conn->writeq, ""%s\r\nContent-Disposition: form-data; name=\""%s\"";\r\n"", conn->boundary, key); rc += httpWrite(conn->writeq, ""Content-Type: application/x-www-form-urlencoded\r\n\r\n%s\r\n"", value); } } if (fileData) { for (rc = next = 0; rc >= 0 && (path = mprGetNextItem(fileData, &next)) != 0; ) { if (!mprPathExists(path, R_OK)) { httpError(conn, HTTP_CODE_NOT_FOUND, ""Cannot open %s"", path); return MPR_ERR_CANT_OPEN; } name = mprGetPathBase(path); rc += httpWrite(conn->writeq, ""%s\r\nContent-Disposition: form-data; name=\""file%d\""; filename=\""%s\""\r\n"", conn->boundary, next - 1, name); if ((type = mprLookupMime(MPR->mimeTypes, path)) != 0) { rc += httpWrite(conn->writeq, ""Content-Type: %s\r\n"", mprLookupMime(MPR->mimeTypes, path)); } httpWrite(conn->writeq, ""\r\n""); if (blockingFileCopy(conn, path) < 0) { return MPR_ERR_CANT_WRITE; } rc += httpWrite(conn->writeq, ""\r\n""); } } rc += httpWrite(conn->writeq, ""%s--\r\n--"", conn->boundary); return rc; }","- key = stok(sclone(pair), ""="", &value);
+ key = ssplit(sclone(pair), ""="", &value);","PUBLIC ssize httpWriteUploadData(HttpConn *conn, MprList *fileData, MprList *formData) { char *path, *pair, *key, *value, *name; cchar *type; ssize rc; int next; rc = 0; if (formData) { for (rc = next = 0; rc >= 0 && (pair = mprGetNextItem(formData, &next)) != 0; ) { key = ssplit(sclone(pair), ""="", &value); rc += httpWrite(conn->writeq, ""%s\r\nContent-Disposition: form-data; name=\""%s\"";\r\n"", conn->boundary, key); rc += httpWrite(conn->writeq, ""Content-Type: application/x-www-form-urlencoded\r\n\r\n%s\r\n"", value); } } if (fileData) { for (rc = next = 0; rc >= 0 && (path = mprGetNextItem(fileData, &next)) != 0; ) { if (!mprPathExists(path, R_OK)) { httpError(conn, HTTP_CODE_NOT_FOUND, ""Cannot open %s"", path); return MPR_ERR_CANT_OPEN; } name = mprGetPathBase(path); rc += httpWrite(conn->writeq, ""%s\r\nContent-Disposition: form-data; name=\""file%d\""; filename=\""%s\""\r\n"", conn->boundary, next - 1, name); if ((type = mprLookupMime(MPR->mimeTypes, path)) != 0) { rc += httpWrite(conn->writeq, ""Content-Type: %s\r\n"", mprLookupMime(MPR->mimeTypes, path)); } httpWrite(conn->writeq, ""\r\n""); if (blockingFileCopy(conn, path) < 0) { return MPR_ERR_CANT_WRITE; } rc += httpWrite(conn->writeq, ""\r\n""); } } rc += httpWrite(conn->writeq, ""%s--\r\n--"", conn->boundary); return rc; }"
588,2508----CWE-772----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-12190--bio.c----*bio_map_user_iov,"struct bio *bio_map_user_iov(struct request_queue *q, const struct iov_iter *iter, gfp_t gfp_mask) { int j; int nr_pages = 0; struct page **pages; struct bio *bio; int cur_page = 0; int ret, offset; struct iov_iter i; struct iovec iov; iov_for_each(iov, i, *iter) { unsigned long uaddr = (unsigned long) iov.iov_base; unsigned long len = iov.iov_len; unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT; unsigned long start = uaddr >> PAGE_SHIFT; if (end < start) return ERR_PTR(-EINVAL); nr_pages += end - start; if (uaddr & queue_dma_alignment(q)) return ERR_PTR(-EINVAL); } if (!nr_pages) return ERR_PTR(-EINVAL); bio = bio_kmalloc(gfp_mask, nr_pages); if (!bio) return ERR_PTR(-ENOMEM); ret = -ENOMEM; pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask); if (!pages) goto out; iov_for_each(iov, i, *iter) { unsigned long uaddr = (unsigned long) iov.iov_base; unsigned long len = iov.iov_len; unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT; unsigned long start = uaddr >> PAGE_SHIFT; const int local_nr_pages = end - start; const int page_limit = cur_page + local_nr_pages; ret = get_user_pages_fast(uaddr, local_nr_pages, (iter->type & WRITE) != WRITE, &pages[cur_page]); <S2SV_StartVul> if (ret < local_nr_pages) { <S2SV_EndVul> ret = -EFAULT; goto out_unmap; } offset = offset_in_page(uaddr); for (j = cur_page; j < page_limit; j++) { unsigned int bytes = PAGE_SIZE - offset; unsigned short prev_bi_vcnt = bio->bi_vcnt; if (len <= 0) break; if (bytes > len) bytes = len; if (bio_add_pc_page(q, bio, pages[j], bytes, offset) < bytes) break; if (bio->bi_vcnt == prev_bi_vcnt) put_page(pages[j]); len -= bytes; offset = 0; } cur_page = j; while (j < page_limit) put_page(pages[j++]); } kfree(pages); bio_set_flag(bio, BIO_USER_MAPPED); bio_get(bio); return bio; out_unmap: <S2SV_StartVul> for (j = 0; j < nr_pages; j++) { <S2SV_EndVul> <S2SV_StartVul> if (!pages[j]) <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> put_page(pages[j]); <S2SV_EndVul> } out: kfree(pages); bio_put(bio); return ERR_PTR(ret); }","- if (ret < local_nr_pages) {
- for (j = 0; j < nr_pages; j++) {
- if (!pages[j])
- break;
- put_page(pages[j]);
+ struct bio_vec *bvec;
+ if (unlikely(ret < local_nr_pages)) {
+ for (j = cur_page; j < page_limit; j++) {
+ if (!pages[j])
+ break;
+ put_page(pages[j]);
+ }
+ bio_for_each_segment_all(bvec, bio, j) {
+ put_page(bvec->bv_page);","struct bio *bio_map_user_iov(struct request_queue *q, const struct iov_iter *iter, gfp_t gfp_mask) { int j; int nr_pages = 0; struct page **pages; struct bio *bio; int cur_page = 0; int ret, offset; struct iov_iter i; struct iovec iov; struct bio_vec *bvec; iov_for_each(iov, i, *iter) { unsigned long uaddr = (unsigned long) iov.iov_base; unsigned long len = iov.iov_len; unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT; unsigned long start = uaddr >> PAGE_SHIFT; if (end < start) return ERR_PTR(-EINVAL); nr_pages += end - start; if (uaddr & queue_dma_alignment(q)) return ERR_PTR(-EINVAL); } if (!nr_pages) return ERR_PTR(-EINVAL); bio = bio_kmalloc(gfp_mask, nr_pages); if (!bio) return ERR_PTR(-ENOMEM); ret = -ENOMEM; pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask); if (!pages) goto out; iov_for_each(iov, i, *iter) { unsigned long uaddr = (unsigned long) iov.iov_base; unsigned long len = iov.iov_len; unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT; unsigned long start = uaddr >> PAGE_SHIFT; const int local_nr_pages = end - start; const int page_limit = cur_page + local_nr_pages; ret = get_user_pages_fast(uaddr, local_nr_pages, (iter->type & WRITE) != WRITE, &pages[cur_page]); if (unlikely(ret < local_nr_pages)) { for (j = cur_page; j < page_limit; j++) { if (!pages[j]) break; put_page(pages[j]); } ret = -EFAULT; goto out_unmap; } offset = offset_in_page(uaddr); for (j = cur_page; j < page_limit; j++) { unsigned int bytes = PAGE_SIZE - offset; unsigned short prev_bi_vcnt = bio->bi_vcnt; if (len <= 0) break; if (bytes > len) bytes = len; if (bio_add_pc_page(q, bio, pages[j], bytes, offset) < bytes) break; if (bio->bi_vcnt == prev_bi_vcnt) put_page(pages[j]); len -= bytes; offset = 0; } cur_page = j; while (j < page_limit) put_page(pages[j++]); } kfree(pages); bio_set_flag(bio, BIO_USER_MAPPED); bio_get(bio); return bio; out_unmap: bio_for_each_segment_all(bvec, bio, j) { put_page(bvec->bv_page); } out: kfree(pages); bio_put(bio); return ERR_PTR(ret); }"
589,6065----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/p_lx_elf.cpp----PackLinuxElf64::elf_find_dynamic,PackLinuxElf64::elf_find_dynamic(unsigned int key) const { Elf64_Dyn const *dynp= dynseg; if (dynp) for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) { upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val)); <S2SV_StartVul> if (t) { <S2SV_EndVul> <S2SV_StartVul> return &((unsigned char const *)file_image)[(size_t)t]; <S2SV_EndVul> } break; } return 0; },"- if (t) {
- return &((unsigned char const *)file_image)[(size_t)t];
+ if (t && t < (upx_uint64_t)file_size) {
+ return t + file_image;",PackLinuxElf64::elf_find_dynamic(unsigned int key) const { Elf64_Dyn const *dynp= dynseg; if (dynp) for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) { upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val)); if (t && t < (upx_uint64_t)file_size) { return t + file_image; } break; } return 0; }
590,3692----CWE-252----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/adtsenc.c----adts_decode_extradata,"static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size) { GetBitContext gb; PutBitContext pb; MPEG4AudioConfig m4ac; <S2SV_StartVul> int off; <S2SV_EndVul> <S2SV_StartVul> init_get_bits(&gb, buf, size * 8); <S2SV_EndVul> off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s); if (off < 0) return off; skip_bits_long(&gb, off); adts->objecttype = m4ac.object_type - 1; adts->sample_rate_index = m4ac.sampling_index; adts->channel_conf = m4ac.chan_config; if (adts->objecttype > 3U) { av_log(s, AV_LOG_ERROR, ""MPEG-4 AOT %d is not allowed in ADTS\n"", adts->objecttype+1); return AVERROR_INVALIDDATA; } if (adts->sample_rate_index == 15) { av_log(s, AV_LOG_ERROR, ""Escape sample rate index illegal in ADTS\n""); return AVERROR_INVALIDDATA; } if (get_bits(&gb, 1)) { av_log(s, AV_LOG_ERROR, ""960/120 MDCT window is not allowed in ADTS\n""); return AVERROR_INVALIDDATA; } if (get_bits(&gb, 1)) { av_log(s, AV_LOG_ERROR, ""Scalable configurations are not allowed in ADTS\n""); return AVERROR_INVALIDDATA; } if (get_bits(&gb, 1)) { av_log(s, AV_LOG_ERROR, ""Extension flag is not allowed in ADTS\n""); return AVERROR_INVALIDDATA; } if (!adts->channel_conf) { init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE); put_bits(&pb, 3, 5); adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8; flush_put_bits(&pb); } adts->write_adts = 1; return 0; }","- int off;
- init_get_bits(&gb, buf, size * 8);
+ int off, ret;
+ ret = init_get_bits8(&gb, buf, size);
+ if (ret < 0)
+ return ret;","static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size) { GetBitContext gb; PutBitContext pb; MPEG4AudioConfig m4ac; int off, ret; ret = init_get_bits8(&gb, buf, size); if (ret < 0) return ret; off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s); if (off < 0) return off; skip_bits_long(&gb, off); adts->objecttype = m4ac.object_type - 1; adts->sample_rate_index = m4ac.sampling_index; adts->channel_conf = m4ac.chan_config; if (adts->objecttype > 3U) { av_log(s, AV_LOG_ERROR, ""MPEG-4 AOT %d is not allowed in ADTS\n"", adts->objecttype+1); return AVERROR_INVALIDDATA; } if (adts->sample_rate_index == 15) { av_log(s, AV_LOG_ERROR, ""Escape sample rate index illegal in ADTS\n""); return AVERROR_INVALIDDATA; } if (get_bits(&gb, 1)) { av_log(s, AV_LOG_ERROR, ""960/120 MDCT window is not allowed in ADTS\n""); return AVERROR_INVALIDDATA; } if (get_bits(&gb, 1)) { av_log(s, AV_LOG_ERROR, ""Scalable configurations are not allowed in ADTS\n""); return AVERROR_INVALIDDATA; } if (get_bits(&gb, 1)) { av_log(s, AV_LOG_ERROR, ""Extension flag is not allowed in ADTS\n""); return AVERROR_INVALIDDATA; } if (!adts->channel_conf) { init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE); put_bits(&pb, 3, 5); adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8; flush_put_bits(&pb); } adts->write_adts = 1; return 0; }"
591,6298----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/httpLib.c----parseRoutes,"static void parseRoutes(HttpRoute *route, cchar *key, MprJson *prop) { MprJson *child; HttpRoute *newRoute; cchar *pattern; int ji; if (route->loaded) { mprLog(""warn http config"", 1, ""Skip reloading routes - must reboot if routes are modified""); return; } if (prop->type & MPR_JSON_STRING) { httpAddRouteSet(route, prop->value); } else if (prop->type & MPR_JSON_ARRAY) { key = sreplace(key, "".routes"", """"); for (ITERATE_CONFIG(route, prop, child, ji)) { if (child->type & MPR_JSON_STRING) { httpAddRouteSet(route, child->value); } else if (child->type & MPR_JSON_OBJ) { newRoute = 0; <S2SV_StartVul> pattern = mprLookupJson(child, ""pattern""); <S2SV_EndVul> if (pattern) { newRoute = httpLookupRouteByPattern(route->host, pattern); if (!newRoute) { newRoute = httpCreateInheritedRoute(route); httpSetRouteHost(newRoute, route->host); } } else { newRoute = route; } parseAll(newRoute, key, child); if (newRoute->error) { break; } if (pattern) { httpFinalizeRoute(newRoute); } } } } }","- pattern = mprLookupJson(child, ""pattern"");
+ pattern = mprReadJson(child, ""pattern"");","static void parseRoutes(HttpRoute *route, cchar *key, MprJson *prop) { MprJson *child; HttpRoute *newRoute; cchar *pattern; int ji; if (route->loaded) { mprLog(""warn http config"", 1, ""Skip reloading routes - must reboot if routes are modified""); return; } if (prop->type & MPR_JSON_STRING) { httpAddRouteSet(route, prop->value); } else if (prop->type & MPR_JSON_ARRAY) { key = sreplace(key, "".routes"", """"); for (ITERATE_CONFIG(route, prop, child, ji)) { if (child->type & MPR_JSON_STRING) { httpAddRouteSet(route, child->value); } else if (child->type & MPR_JSON_OBJ) { newRoute = 0; pattern = mprReadJson(child, ""pattern""); if (pattern) { newRoute = httpLookupRouteByPattern(route->host, pattern); if (!newRoute) { newRoute = httpCreateInheritedRoute(route); httpSetRouteHost(newRoute, route->host); } } else { newRoute = route; } parseAll(newRoute, key, child); if (newRoute->error) { break; } if (pattern) { httpFinalizeRoute(newRoute); } } } } }"
592,3810----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/memcached.c----try_read_command,"static int try_read_command(conn *c) { assert(c != NULL); assert(c->rcurr <= (c->rbuf + c->rsize)); assert(c->rbytes > 0); if (c->protocol == negotiating_prot || c->transport == udp_transport) { if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) { c->protocol = binary_prot; } else { c->protocol = ascii_prot; } if (settings.verbose > 1) { fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd, prot_text(c->protocol)); } } if (c->protocol == binary_prot) { if (c->rbytes < sizeof(c->binary_header)) { return 0; } else { #ifdef NEED_ALIGN if (((long)(c->rcurr)) % 8 != 0) { memmove(c->rbuf, c->rcurr, c->rbytes); c->rcurr = c->rbuf; if (settings.verbose > 1) { fprintf(stderr, ""%d: Realign input buffer\n"", c->sfd); } } #endif protocol_binary_request_header* req; req = (protocol_binary_request_header*)c->rcurr; if (settings.verbose > 1) { int ii; fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd); for (ii = 0; ii < sizeof(req->bytes); ++ii) { if (ii % 4 == 0) { fprintf(stderr, ""\n<%d "", c->sfd); } fprintf(stderr, "" 0x%02x"", req->bytes[ii]); } fprintf(stderr, ""\n""); } c->binary_header = *req; c->binary_header.request.keylen = ntohs(req->request.keylen); c->binary_header.request.bodylen = ntohl(req->request.bodylen); c->binary_header.request.cas = ntohll(req->request.cas); if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) { if (settings.verbose) { fprintf(stderr, ""Invalid magic: %x\n"", c->binary_header.request.magic); } conn_set_state(c, conn_closing); return -1; } c->msgcurr = 0; c->msgused = 0; c->iovused = 0; if (add_msghdr(c) != 0) { out_string(c, ""SERVER_ERROR out of memory""); return 0; } c->cmd = c->binary_header.request.opcode; c->keylen = c->binary_header.request.keylen; c->opaque = c->binary_header.request.opaque; c->cas = 0; dispatch_bin_command(c); c->rbytes -= sizeof(c->binary_header); c->rcurr += sizeof(c->binary_header); } } else { char *el, *cont; if (c->rbytes == 0) return 0; el = memchr(c->rcurr, '\n', c->rbytes); if (!el) { if (c->rbytes > 1024) { char *ptr = c->rcurr; while (*ptr == ' ') { ++ptr; } <S2SV_StartVul> if (strcmp(ptr, ""get "") && strcmp(ptr, ""gets "")) { <S2SV_EndVul> conn_set_state(c, conn_closing); return 1; } } return 0; } cont = el + 1; if ((el - c->rcurr) > 1 && *(el - 1) == '\r') { el--; } *el = '\0'; assert(cont <= (c->rcurr + c->rbytes)); process_command(c, c->rcurr); c->rbytes -= (cont - c->rcurr); c->rcurr = cont; assert(c->rcurr <= (c->rbuf + c->rsize)); } return 1; }","- if (strcmp(ptr, ""get "") && strcmp(ptr, ""gets "")) {
+ if (ptr - c->rcurr > 100 ||
+ (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {","static int try_read_command(conn *c) { assert(c != NULL); assert(c->rcurr <= (c->rbuf + c->rsize)); assert(c->rbytes > 0); if (c->protocol == negotiating_prot || c->transport == udp_transport) { if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) { c->protocol = binary_prot; } else { c->protocol = ascii_prot; } if (settings.verbose > 1) { fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd, prot_text(c->protocol)); } } if (c->protocol == binary_prot) { if (c->rbytes < sizeof(c->binary_header)) { return 0; } else { #ifdef NEED_ALIGN if (((long)(c->rcurr)) % 8 != 0) { memmove(c->rbuf, c->rcurr, c->rbytes); c->rcurr = c->rbuf; if (settings.verbose > 1) { fprintf(stderr, ""%d: Realign input buffer\n"", c->sfd); } } #endif protocol_binary_request_header* req; req = (protocol_binary_request_header*)c->rcurr; if (settings.verbose > 1) { int ii; fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd); for (ii = 0; ii < sizeof(req->bytes); ++ii) { if (ii % 4 == 0) { fprintf(stderr, ""\n<%d "", c->sfd); } fprintf(stderr, "" 0x%02x"", req->bytes[ii]); } fprintf(stderr, ""\n""); } c->binary_header = *req; c->binary_header.request.keylen = ntohs(req->request.keylen); c->binary_header.request.bodylen = ntohl(req->request.bodylen); c->binary_header.request.cas = ntohll(req->request.cas); if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) { if (settings.verbose) { fprintf(stderr, ""Invalid magic: %x\n"", c->binary_header.request.magic); } conn_set_state(c, conn_closing); return -1; } c->msgcurr = 0; c->msgused = 0; c->iovused = 0; if (add_msghdr(c) != 0) { out_string(c, ""SERVER_ERROR out of memory""); return 0; } c->cmd = c->binary_header.request.opcode; c->keylen = c->binary_header.request.keylen; c->opaque = c->binary_header.request.opaque; c->cas = 0; dispatch_bin_command(c); c->rbytes -= sizeof(c->binary_header); c->rcurr += sizeof(c->binary_header); } } else { char *el, *cont; if (c->rbytes == 0) return 0; el = memchr(c->rcurr, '\n', c->rbytes); if (!el) { if (c->rbytes > 1024) { char *ptr = c->rcurr; while (*ptr == ' ') { ++ptr; } if (ptr - c->rcurr > 100 || (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) { conn_set_state(c, conn_closing); return 1; } } return 0; } cont = el + 1; if ((el - c->rcurr) > 1 && *(el - 1) == '\r') { el--; } *el = '\0'; assert(cont <= (c->rcurr + c->rbytes)); process_command(c, c->rcurr); c->rbytes -= (cont - c->rcurr); c->rcurr = cont; assert(c->rcurr <= (c->rbuf + c->rsize)); } return 1; }"
593,954----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-8633--net.c----fwnet_receive_broadcast,"static void fwnet_receive_broadcast(struct fw_iso_context *context, u32 cycle, size_t header_length, void *header, void *data) { struct fwnet_device *dev; struct fw_iso_packet packet; __be16 *hdr_ptr; __be32 *buf_ptr; int retval; u32 length; <S2SV_StartVul> u16 source_node_id; <S2SV_EndVul> <S2SV_StartVul> u32 specifier_id; <S2SV_EndVul> <S2SV_StartVul> u32 ver; <S2SV_EndVul> unsigned long offset; unsigned long flags; dev = data; hdr_ptr = header; length = be16_to_cpup(hdr_ptr); spin_lock_irqsave(&dev->lock, flags); offset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr; buf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++]; if (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs) dev->broadcast_rcv_next_ptr = 0; spin_unlock_irqrestore(&dev->lock, flags); <S2SV_StartVul> specifier_id = (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8 <S2SV_EndVul> <S2SV_StartVul> | (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24; <S2SV_EndVul> <S2SV_StartVul> ver = be32_to_cpu(buf_ptr[1]) & 0xffffff; <S2SV_EndVul> <S2SV_StartVul> source_node_id = be32_to_cpu(buf_ptr[0]) >> 16; <S2SV_EndVul> if (specifier_id == IANA_SPECIFIER_ID && <S2SV_StartVul> (ver == RFC2734_SW_VERSION <S2SV_EndVul> <S2SV_StartVul> #if IS_ENABLED(CONFIG_IPV6) <S2SV_EndVul> || ver == RFC3146_SW_VERSION <S2SV_StartVul> #endif <S2SV_EndVul> )) { <S2SV_StartVul> buf_ptr += 2; <S2SV_EndVul> <S2SV_StartVul> length -= IEEE1394_GASP_HDR_SIZE; <S2SV_EndVul> <S2SV_StartVul> fwnet_incoming_packet(dev, buf_ptr, length, source_node_id, <S2SV_EndVul> <S2SV_StartVul> context->card->generation, true); <S2SV_EndVul> } <S2SV_StartVul> <S2SV_EndVul> packet.payload_length = dev->rcv_buffer_size; packet.interrupt = 1; packet.skip = 0; packet.tag = 3; packet.sy = 0; packet.header_length = IEEE1394_GASP_HDR_SIZE; spin_lock_irqsave(&dev->lock, flags); retval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet, &dev->broadcast_rcv_buffer, offset); spin_unlock_irqrestore(&dev->lock, flags); if (retval >= 0) fw_iso_context_queue_flush(dev->broadcast_rcv_context); else dev_err(&dev->netdev->dev, ""requeue failed\n""); }","- u16 source_node_id;
- u32 specifier_id;
- u32 ver;
- specifier_id = (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8
- | (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;
- ver = be32_to_cpu(buf_ptr[1]) & 0xffffff;
- source_node_id = be32_to_cpu(buf_ptr[0]) >> 16;
- (ver == RFC2734_SW_VERSION
- #if IS_ENABLED(CONFIG_IPV6)
- #endif
- buf_ptr += 2;
- length -= IEEE1394_GASP_HDR_SIZE;
- fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,
- context->card->generation, true);
- 
+ if (length > IEEE1394_GASP_HDR_SIZE &&
+ gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&
+ (gasp_version(buf_ptr) == RFC2734_SW_VERSION
+ || gasp_version(buf_ptr) == RFC3146_SW_VERSION
+ ))
+ fwnet_incoming_packet(dev, buf_ptr + 2,
+ length - IEEE1394_GASP_HDR_SIZE,
+ gasp_source_id(buf_ptr),","static void fwnet_receive_broadcast(struct fw_iso_context *context, u32 cycle, size_t header_length, void *header, void *data) { struct fwnet_device *dev; struct fw_iso_packet packet; __be16 *hdr_ptr; __be32 *buf_ptr; int retval; u32 length; unsigned long offset; unsigned long flags; dev = data; hdr_ptr = header; length = be16_to_cpup(hdr_ptr); spin_lock_irqsave(&dev->lock, flags); offset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr; buf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++]; if (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs) dev->broadcast_rcv_next_ptr = 0; spin_unlock_irqrestore(&dev->lock, flags); if (length > IEEE1394_GASP_HDR_SIZE && gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID && (gasp_version(buf_ptr) == RFC2734_SW_VERSION #if IS_ENABLED(CONFIG_IPV6) || gasp_version(buf_ptr) == RFC3146_SW_VERSION #endif )) fwnet_incoming_packet(dev, buf_ptr + 2, length - IEEE1394_GASP_HDR_SIZE, gasp_source_id(buf_ptr), context->card->generation, true); packet.payload_length = dev->rcv_buffer_size; packet.interrupt = 1; packet.skip = 0; packet.tag = 3; packet.sy = 0; packet.header_length = IEEE1394_GASP_HDR_SIZE; spin_lock_irqsave(&dev->lock, flags); retval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet, &dev->broadcast_rcv_buffer, offset); spin_unlock_irqrestore(&dev->lock, flags); if (retval >= 0) fw_iso_context_queue_flush(dev->broadcast_rcv_context); else dev_err(&dev->netdev->dev, ""requeue failed\n""); }"
594,763----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3346--scsi-disk.c----scsi_disk_emulate_command,"<S2SV_StartVul> static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf) <S2SV_EndVul> { SCSIRequest *req = &r->req; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); uint64_t nb_sectors; int buflen = 0; <S2SV_StartVul> <S2SV_EndVul> switch (req->cmd.buf[0]) { case TEST_UNIT_READY: if (s->tray_open || !bdrv_is_inserted(s->bs)) goto not_ready; break; case INQUIRY: buflen = scsi_disk_emulate_inquiry(req, outbuf); if (buflen < 0) goto illegal_request; break; case MODE_SENSE: case MODE_SENSE_10: buflen = scsi_disk_emulate_mode_sense(r, outbuf); if (buflen < 0) goto illegal_request; break; case READ_TOC: buflen = scsi_disk_emulate_read_toc(req, outbuf); if (buflen < 0) goto illegal_request; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegal_request; break; <S2SV_StartVul> case RESERVE_10: <S2SV_EndVul> if (req->cmd.buf[1] & 3) goto illegal_request; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RELEASE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case START_STOP: if (scsi_disk_emulate_start_stop(r) < 0) { return -1; } break; case ALLOW_MEDIUM_REMOVAL: s->tray_locked = req->cmd.buf[4] & 1; bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1); break; case READ_CAPACITY_10: memset(outbuf, 0, 8); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; if (nb_sectors > UINT32_MAX) nb_sectors = UINT32_MAX; outbuf[0] = (nb_sectors >> 24) & 0xff; outbuf[1] = (nb_sectors >> 16) & 0xff; outbuf[2] = (nb_sectors >> 8) & 0xff; outbuf[3] = nb_sectors & 0xff; outbuf[4] = 0; outbuf[5] = 0; outbuf[6] = s->cluster_size * 2; outbuf[7] = 0; buflen = 8; break; case GET_CONFIGURATION: memset(outbuf, 0, 8); outbuf[7] = 8; buflen = 8; break; case SERVICE_ACTION_IN_16: if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) { DPRINTF(""SAI READ CAPACITY(16)\n""); memset(outbuf, 0, req->cmd.xfer); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; outbuf[0] = (nb_sectors >> 56) & 0xff; outbuf[1] = (nb_sectors >> 48) & 0xff; outbuf[2] = (nb_sectors >> 40) & 0xff; outbuf[3] = (nb_sectors >> 32) & 0xff; outbuf[4] = (nb_sectors >> 24) & 0xff; outbuf[5] = (nb_sectors >> 16) & 0xff; outbuf[6] = (nb_sectors >> 8) & 0xff; outbuf[7] = nb_sectors & 0xff; outbuf[8] = 0; outbuf[9] = 0; outbuf[10] = s->cluster_size * 2; outbuf[11] = 0; outbuf[12] = 0; outbuf[13] = get_physical_block_exp(&s->qdev.conf); if (s->qdev.conf.discard_granularity) { outbuf[14] = 0x80; } buflen = req->cmd.xfer; break; } DPRINTF(""Unsupported Service Action In\n""); goto illegal_request; case VERIFY_10: break; default: scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return -1; } return buflen; not_ready: if (s->tray_open || !bdrv_is_inserted(s->bs)) { scsi_check_condition(r, SENSE_CODE(NO_MEDIUM)); } else { scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY)); } return -1; illegal_request: if (r->req.status == -1) { scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); } return -1; }","- static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)
- 
- case RESERVE_10:
+ static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)
+ uint8_t *outbuf;
+ int buflen = 0;
+ 
+ goto illegal_request;
+ case MODE_SENSE:
+ case MODE_SENSE_10:
+ buflen = scsi_disk_emulate_mode_sense(r, outbuf);
+ if (buflen < 0)
+ goto illegal_request;","static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf) static int scsi_disk_emulate_command(SCSIDiskReq *r) { SCSIRequest *req = &r->req; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev); uint64_t nb_sectors; uint8_t *outbuf; int buflen = 0; if (!r->iov.iov_base) { if (req->cmd.xfer > 65536) { goto illegal_request; } r->buflen = MAX(4096, req->cmd.xfer); r->iov.iov_base = qemu_blockalign(s->bs, r->buflen); } outbuf = r->iov.iov_base; switch (req->cmd.buf[0]) { case TEST_UNIT_READY: if (s->tray_open || !bdrv_is_inserted(s->bs)) goto not_ready; break; case INQUIRY: buflen = scsi_disk_emulate_inquiry(req, outbuf); if (buflen < 0) goto illegal_request; break; case MODE_SENSE: case MODE_SENSE_10: buflen = scsi_disk_emulate_mode_sense(r, outbuf); if (buflen < 0) goto illegal_request; break; case READ_TOC: buflen = scsi_disk_emulate_read_toc(req, outbuf); if (buflen < 0) goto illegal_request; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RESERVE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegal_request; break; case RELEASE_10: if (req->cmd.buf[1] & 3) goto illegal_request; break; case START_STOP: if (scsi_disk_emulate_start_stop(r) < 0) { return -1; } break; case ALLOW_MEDIUM_REMOVAL: s->tray_locked = req->cmd.buf[4] & 1; bdrv_lock_medium(s->bs, req->cmd.buf[4] & 1); break; case READ_CAPACITY_10: memset(outbuf, 0, 8); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; if (nb_sectors > UINT32_MAX) nb_sectors = UINT32_MAX; outbuf[0] = (nb_sectors >> 24) & 0xff; outbuf[1] = (nb_sectors >> 16) & 0xff; outbuf[2] = (nb_sectors >> 8) & 0xff; outbuf[3] = nb_sectors & 0xff; outbuf[4] = 0; outbuf[5] = 0; outbuf[6] = s->cluster_size * 2; outbuf[7] = 0; buflen = 8; break; case GET_CONFIGURATION: memset(outbuf, 0, 8); outbuf[7] = 8; buflen = 8; break; case SERVICE_ACTION_IN_16: if ((req->cmd.buf[1] & 31) == SAI_READ_CAPACITY_16) { DPRINTF(""SAI READ CAPACITY(16)\n""); memset(outbuf, 0, req->cmd.xfer); bdrv_get_geometry(s->bs, &nb_sectors); if (!nb_sectors) goto not_ready; nb_sectors /= s->cluster_size; nb_sectors--; s->max_lba = nb_sectors; outbuf[0] = (nb_sectors >> 56) & 0xff; outbuf[1] = (nb_sectors >> 48) & 0xff; outbuf[2] = (nb_sectors >> 40) & 0xff; outbuf[3] = (nb_sectors >> 32) & 0xff; outbuf[4] = (nb_sectors >> 24) & 0xff; outbuf[5] = (nb_sectors >> 16) & 0xff; outbuf[6] = (nb_sectors >> 8) & 0xff; outbuf[7] = nb_sectors & 0xff; outbuf[8] = 0; outbuf[9] = 0; outbuf[10] = s->cluster_size * 2; outbuf[11] = 0; outbuf[12] = 0; outbuf[13] = get_physical_block_exp(&s->qdev.conf); if (s->qdev.conf.discard_granularity) { outbuf[14] = 0x80; } buflen = req->cmd.xfer; break; } DPRINTF(""Unsupported Service Action In\n""); goto illegal_request; case VERIFY_10: break; default: scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE)); return -1; } return buflen; not_ready: if (s->tray_open || !bdrv_is_inserted(s->bs)) { scsi_check_condition(r, SENSE_CODE(NO_MEDIUM)); } else { scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY)); } return -1; illegal_request: if (r->req.status == -1) { scsi_check_condition(r, SENSE_CODE(INVALID_FIELD)); } return -1; }"
595,1200--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-6701--aio.c----aio_setup_single_vector,<S2SV_StartVul> static ssize_t aio_setup_single_vector(struct kiocb *kiocb) <S2SV_EndVul> { kiocb->ki_iovec = &kiocb->ki_inline_vec; kiocb->ki_iovec->iov_base = kiocb->ki_buf; <S2SV_StartVul> kiocb->ki_iovec->iov_len = kiocb->ki_left; <S2SV_EndVul> kiocb->ki_nr_segs = 1; kiocb->ki_cur_seg = 0; return 0; },"- static ssize_t aio_setup_single_vector(struct kiocb *kiocb)
- kiocb->ki_iovec->iov_len = kiocb->ki_left;
+ static ssize_t aio_setup_single_vector(struct kiocb *kiocb)
+ {
+ 
+ bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
+ if (bytes < 0)
+ kiocb->ki_iovec->iov_base = kiocb->ki_buf;","static ssize_t aio_setup_single_vector(struct kiocb *kiocb) static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb) { int bytes; bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left); if (bytes < 0) return bytes; kiocb->ki_iovec = &kiocb->ki_inline_vec; kiocb->ki_iovec->iov_base = kiocb->ki_buf; kiocb->ki_iovec->iov_len = bytes; kiocb->ki_nr_segs = 1; kiocb->ki_cur_seg = 0; return 0; }"
596,7430----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/Password.cxx----PlainPasswd::PlainPasswd,<S2SV_StartVul> PlainPasswd::PlainPasswd(int len) : CharArray(len) { <S2SV_EndVul> },"- PlainPasswd::PlainPasswd(int len) : CharArray(len) {
+ PlainPasswd::PlainPasswd(size_t len) : CharArray(len) {",PlainPasswd::PlainPasswd(size_t len) : CharArray(len) { }
597,6906----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event.c----perf_event_nmi_handler,"static int __kprobes perf_event_nmi_handler(struct notifier_block *self, unsigned long cmd, void *__args) { struct die_args *args = __args; struct perf_sample_data data; struct cpu_hw_events *cpuc; struct pt_regs *regs; int i; if (!atomic_read(&active_events)) return NOTIFY_DONE; switch (cmd) { case DIE_NMI: break; default: return NOTIFY_DONE; } regs = args->regs; perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); if (sparc_pmu->irq_bit) pcr_ops->write(cpuc->pcr); for (i = 0; i < cpuc->n_events; i++) { struct perf_event *event = cpuc->event[i]; int idx = cpuc->current_idx[i]; struct hw_perf_event *hwc; u64 val; hwc = &event->hw; val = sparc_perf_event_update(event, hwc, idx); if (val & (1ULL << 31)) continue; data.period = event->hw.last_period; if (!sparc_perf_event_set_period(event, hwc, idx)) continue; <S2SV_StartVul> if (perf_event_overflow(event, 1, &data, regs)) <S2SV_EndVul> sparc_pmu_stop(event, 0); } return NOTIFY_STOP; }","- if (perf_event_overflow(event, 1, &data, regs))
+ if (perf_event_overflow(event, &data, regs))","static int __kprobes perf_event_nmi_handler(struct notifier_block *self, unsigned long cmd, void *__args) { struct die_args *args = __args; struct perf_sample_data data; struct cpu_hw_events *cpuc; struct pt_regs *regs; int i; if (!atomic_read(&active_events)) return NOTIFY_DONE; switch (cmd) { case DIE_NMI: break; default: return NOTIFY_DONE; } regs = args->regs; perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); if (sparc_pmu->irq_bit) pcr_ops->write(cpuc->pcr); for (i = 0; i < cpuc->n_events; i++) { struct perf_event *event = cpuc->event[i]; int idx = cpuc->current_idx[i]; struct hw_perf_event *hwc; u64 val; hwc = &event->hw; val = sparc_perf_event_update(event, hwc, idx); if (val & (1ULL << 31)) continue; data.period = event->hw.last_period; if (!sparc_perf_event_set_period(event, hwc, idx)) continue; if (perf_event_overflow(event, &data, regs)) sparc_pmu_stop(event, 0); } return NOTIFY_STOP; }"
598,378----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-7022--g2meet.c----g2m_init_buffers,"static int g2m_init_buffers(G2MContext *c) { int aligned_height; if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) { <S2SV_StartVul> c->framebuf_stride = FFALIGN(c->width * 3, 16); <S2SV_EndVul> <S2SV_StartVul> aligned_height = FFALIGN(c->height, 16); <S2SV_EndVul> av_free(c->framebuf); c->framebuf = av_mallocz(c->framebuf_stride * aligned_height); if (!c->framebuf) return AVERROR(ENOMEM); } if (!c->synth_tile || !c->jpeg_tile || c->old_tile_w < c->tile_width || c->old_tile_h < c->tile_height) { c->tile_stride = FFALIGN(c->tile_width, 16) * 3; aligned_height = FFALIGN(c->tile_height, 16); av_free(c->synth_tile); av_free(c->jpeg_tile); av_free(c->kempf_buf); av_free(c->kempf_flags); c->synth_tile = av_mallocz(c->tile_stride * aligned_height); c->jpeg_tile = av_mallocz(c->tile_stride * aligned_height); c->kempf_buf = av_mallocz((c->tile_width + 1) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE); c->kempf_flags = av_mallocz( c->tile_width * aligned_height); if (!c->synth_tile || !c->jpeg_tile || !c->kempf_buf || !c->kempf_flags) return AVERROR(ENOMEM); } return 0; }","- c->framebuf_stride = FFALIGN(c->width * 3, 16);
- aligned_height = FFALIGN(c->height, 16);
+ c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;
+ aligned_height = c->height + 15;","static int g2m_init_buffers(G2MContext *c) { int aligned_height; if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) { c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3; aligned_height = c->height + 15; av_free(c->framebuf); c->framebuf = av_mallocz(c->framebuf_stride * aligned_height); if (!c->framebuf) return AVERROR(ENOMEM); } if (!c->synth_tile || !c->jpeg_tile || c->old_tile_w < c->tile_width || c->old_tile_h < c->tile_height) { c->tile_stride = FFALIGN(c->tile_width, 16) * 3; aligned_height = FFALIGN(c->tile_height, 16); av_free(c->synth_tile); av_free(c->jpeg_tile); av_free(c->kempf_buf); av_free(c->kempf_flags); c->synth_tile = av_mallocz(c->tile_stride * aligned_height); c->jpeg_tile = av_mallocz(c->tile_stride * aligned_height); c->kempf_buf = av_mallocz((c->tile_width + 1) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE); c->kempf_flags = av_mallocz( c->tile_width * aligned_height); if (!c->synth_tile || !c->jpeg_tile || !c->kempf_buf || !c->kempf_flags) return AVERROR(ENOMEM); } return 0; }"
599,4905----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/indent.c----ex_retab,"ex_retab(exarg_T *eap) { linenr_T lnum; int got_tab = FALSE; long num_spaces = 0; long num_tabs; long len; long col; long vcol; long start_col = 0; long start_vcol = 0; long old_len; char_u *ptr; char_u *new_line = (char_u *)1; int did_undo; #ifdef FEAT_VARTABS int *new_vts_array = NULL; char_u *new_ts_str; #else int temp; int new_ts; #endif int save_list; linenr_T first_line = 0; linenr_T last_line = 0; save_list = curwin->w_p_list; curwin->w_p_list = 0; #ifdef FEAT_VARTABS new_ts_str = eap->arg; if (tabstop_set(eap->arg, &new_vts_array) == FAIL) return; while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',') ++(eap->arg); if (new_vts_array == NULL) { new_vts_array = curbuf->b_p_vts_array; new_ts_str = NULL; } else new_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str); #else ptr = eap->arg; new_ts = getdigits(&ptr); if (new_ts < 0 && *eap->arg == '-') { emsg(_(e_argument_must_be_positive)); return; } <S2SV_StartVul> if (new_ts < 0 || new_ts > 9999) <S2SV_EndVul> { semsg(_(e_invalid_argument_str), eap->arg); return; } if (new_ts == 0) new_ts = curbuf->b_p_ts; #endif for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum) { ptr = ml_get(lnum); col = 0; vcol = 0; did_undo = FALSE; for (;;) { if (VIM_ISWHITE(ptr[col])) { if (!got_tab && num_spaces == 0) { start_vcol = vcol; start_col = col; } if (ptr[col] == ' ') num_spaces++; else got_tab = TRUE; } else { if (got_tab || (eap->forceit && num_spaces > 1)) { len = num_spaces = vcol - start_vcol; num_tabs = 0; if (!curbuf->b_p_et) { #ifdef FEAT_VARTABS int t, s; tabstop_fromto(start_vcol, vcol, curbuf->b_p_ts, new_vts_array, &t, &s); num_tabs = t; num_spaces = s; #else temp = new_ts - (start_vcol % new_ts); if (num_spaces >= temp) { num_spaces -= temp; num_tabs++; } num_tabs += num_spaces / new_ts; num_spaces -= (num_spaces / new_ts) * new_ts; #endif } if (curbuf->b_p_et || got_tab || (num_spaces + num_tabs < len)) { if (did_undo == FALSE) { did_undo = TRUE; if (u_save((linenr_T)(lnum - 1), (linenr_T)(lnum + 1)) == FAIL) { new_line = NULL; break; } } len = num_spaces + num_tabs; old_len = (long)STRLEN(ptr); new_line = alloc(old_len - col + start_col + len + 1); if (new_line == NULL) break; if (start_col > 0) mch_memmove(new_line, ptr, (size_t)start_col); mch_memmove(new_line + start_col + len, ptr + col, (size_t)(old_len - col + 1)); ptr = new_line + start_col; for (col = 0; col < len; col++) ptr[col] = (col < num_tabs) ? '\t' : ' '; if (ml_replace(lnum, new_line, FALSE) == OK) new_line = curbuf->b_ml.ml_line_ptr; if (first_line == 0) first_line = lnum; last_line = lnum; ptr = new_line; col = start_col + len; } } got_tab = FALSE; num_spaces = 0; } if (ptr[col] == NUL) break; vcol += chartabsize(ptr + col, (colnr_T)vcol); if (has_mbyte) col += (*mb_ptr2len)(ptr + col); else ++col; } if (new_line == NULL) break; line_breakcheck(); } if (got_int) emsg(_(e_interrupted)); #ifdef FEAT_VARTABS if (tabstop_count(curbuf->b_p_vts_array) == 0 && tabstop_count(new_vts_array) == 1 && curbuf->b_p_ts == tabstop_first(new_vts_array)) ; else if (tabstop_count(curbuf->b_p_vts_array) > 0 && tabstop_eq(curbuf->b_p_vts_array, new_vts_array)) ; else redraw_curbuf_later(NOT_VALID); #else if (curbuf->b_p_ts != new_ts) redraw_curbuf_later(NOT_VALID); #endif if (first_line != 0) changed_lines(first_line, 0, last_line + 1, 0L); curwin->w_p_list = save_list; #ifdef FEAT_VARTABS if (new_ts_str != NULL) { int *old_vts_ary = curbuf->b_p_vts_array; if (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1) { set_string_option_direct((char_u *)""vts"", -1, new_ts_str, OPT_FREE|OPT_LOCAL, 0); curbuf->b_p_vts_array = new_vts_array; vim_free(old_vts_ary); } else { curbuf->b_p_ts = tabstop_first(new_vts_array); vim_free(new_vts_array); } vim_free(new_ts_str); } #else curbuf->b_p_ts = new_ts; #endif coladvance(curwin->w_curswant); u_clearline(); }","- if (new_ts < 0 || new_ts > 9999)
+ if (new_ts < 0 || new_ts > TABSTOP_MAX)","ex_retab(exarg_T *eap) { linenr_T lnum; int got_tab = FALSE; long num_spaces = 0; long num_tabs; long len; long col; long vcol; long start_col = 0; long start_vcol = 0; long old_len; char_u *ptr; char_u *new_line = (char_u *)1; int did_undo; #ifdef FEAT_VARTABS int *new_vts_array = NULL; char_u *new_ts_str; #else int temp; int new_ts; #endif int save_list; linenr_T first_line = 0; linenr_T last_line = 0; save_list = curwin->w_p_list; curwin->w_p_list = 0; #ifdef FEAT_VARTABS new_ts_str = eap->arg; if (tabstop_set(eap->arg, &new_vts_array) == FAIL) return; while (vim_isdigit(*(eap->arg)) || *(eap->arg) == ',') ++(eap->arg); if (new_vts_array == NULL) { new_vts_array = curbuf->b_p_vts_array; new_ts_str = NULL; } else new_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str); #else ptr = eap->arg; new_ts = getdigits(&ptr); if (new_ts < 0 && *eap->arg == '-') { emsg(_(e_argument_must_be_positive)); return; } if (new_ts < 0 || new_ts > TABSTOP_MAX) { semsg(_(e_invalid_argument_str), eap->arg); return; } if (new_ts == 0) new_ts = curbuf->b_p_ts; #endif for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum) { ptr = ml_get(lnum); col = 0; vcol = 0; did_undo = FALSE; for (;;) { if (VIM_ISWHITE(ptr[col])) { if (!got_tab && num_spaces == 0) { start_vcol = vcol; start_col = col; } if (ptr[col] == ' ') num_spaces++; else got_tab = TRUE; } else { if (got_tab || (eap->forceit && num_spaces > 1)) { len = num_spaces = vcol - start_vcol; num_tabs = 0; if (!curbuf->b_p_et) { #ifdef FEAT_VARTABS int t, s; tabstop_fromto(start_vcol, vcol, curbuf->b_p_ts, new_vts_array, &t, &s); num_tabs = t; num_spaces = s; #else temp = new_ts - (start_vcol % new_ts); if (num_spaces >= temp) { num_spaces -= temp; num_tabs++; } num_tabs += num_spaces / new_ts; num_spaces -= (num_spaces / new_ts) * new_ts; #endif } if (curbuf->b_p_et || got_tab || (num_spaces + num_tabs < len)) { if (did_undo == FALSE) { did_undo = TRUE; if (u_save((linenr_T)(lnum - 1), (linenr_T)(lnum + 1)) == FAIL) { new_line = NULL; break; } } len = num_spaces + num_tabs; old_len = (long)STRLEN(ptr); new_line = alloc(old_len - col + start_col + len + 1); if (new_line == NULL) break; if (start_col > 0) mch_memmove(new_line, ptr, (size_t)start_col); mch_memmove(new_line + start_col + len, ptr + col, (size_t)(old_len - col + 1)); ptr = new_line + start_col; for (col = 0; col < len; col++) ptr[col] = (col < num_tabs) ? '\t' : ' '; if (ml_replace(lnum, new_line, FALSE) == OK) new_line = curbuf->b_ml.ml_line_ptr; if (first_line == 0) first_line = lnum; last_line = lnum; ptr = new_line; col = start_col + len; } } got_tab = FALSE; num_spaces = 0; } if (ptr[col] == NUL) break; vcol += chartabsize(ptr + col, (colnr_T)vcol); if (has_mbyte) col += (*mb_ptr2len)(ptr + col); else ++col; } if (new_line == NULL) break; line_breakcheck(); } if (got_int) emsg(_(e_interrupted)); #ifdef FEAT_VARTABS if (tabstop_count(curbuf->b_p_vts_array) == 0 && tabstop_count(new_vts_array) == 1 && curbuf->b_p_ts == tabstop_first(new_vts_array)) ; else if (tabstop_count(curbuf->b_p_vts_array) > 0 && tabstop_eq(curbuf->b_p_vts_array, new_vts_array)) ; else redraw_curbuf_later(NOT_VALID); #else if (curbuf->b_p_ts != new_ts) redraw_curbuf_later(NOT_VALID); #endif if (first_line != 0) changed_lines(first_line, 0, last_line + 1, 0L); curwin->w_p_list = save_list; #ifdef FEAT_VARTABS if (new_ts_str != NULL) { int *old_vts_ary = curbuf->b_p_vts_array; if (tabstop_count(old_vts_ary) > 0 || tabstop_count(new_vts_array) > 1) { set_string_option_direct((char_u *)""vts"", -1, new_ts_str, OPT_FREE|OPT_LOCAL, 0); curbuf->b_p_vts_array = new_vts_array; vim_free(old_vts_ary); } else { curbuf->b_p_ts = tabstop_first(new_vts_array); vim_free(new_vts_array); } vim_free(new_ts_str); } #else curbuf->b_p_ts = new_ts; #endif coladvance(curwin->w_curswant); u_clearline(); }"
600,5357----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/getdata.cpp----acommon::unescape,"char * unescape(char * dest, const char * src) { while (*src) { <S2SV_StartVul> if (*src == '\\') { <S2SV_EndVul> ++src; switch (*src) { case 'n': *dest = '\n'; break; case 'r': *dest = '\r'; break; case 't': *dest = '\t'; break; case 'f': *dest = '\f'; break; case 'v': *dest = '\v'; break; default: *dest = *src; } } else { *dest = *src; } ++src; ++dest; } *dest = '\0'; return dest; }","- if (*src == '\\') {
+ if (*src == '\\' && src[1]) {","char * unescape(char * dest, const char * src) { while (*src) { if (*src == '\\' && src[1]) { ++src; switch (*src) { case 'n': *dest = '\n'; break; case 'r': *dest = '\r'; break; case 't': *dest = '\t'; break; case 'f': *dest = '\f'; break; case 'v': *dest = '\v'; break; default: *dest = *src; } } else { *dest = *src; } ++src; ++dest; } *dest = '\0'; return dest; }"
601,4197----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/stv06xx.c----stv06xx_isoc_init,static int stv06xx_isoc_init(struct gspca_dev *gspca_dev) { struct usb_host_interface *alt; struct sd *sd = (struct sd *) gspca_dev; <S2SV_StartVul> alt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1]; <S2SV_EndVul> alt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]); return 0; },"- alt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];
+ struct usb_interface_cache *intfc;
+ intfc = gspca_dev->dev->actconfig->intf_cache[0];
+ if (intfc->num_altsetting < 2)
+ return -ENODEV;
+ alt = &intfc->altsetting[1];
+ if (alt->desc.bNumEndpoints < 1)
+ return -ENODEV;",static int stv06xx_isoc_init(struct gspca_dev *gspca_dev) { struct usb_interface_cache *intfc; struct usb_host_interface *alt; struct sd *sd = (struct sd *) gspca_dev; intfc = gspca_dev->dev->actconfig->intf_cache[0]; if (intfc->num_altsetting < 2) return -ENODEV; alt = &intfc->altsetting[1]; if (alt->desc.bNumEndpoints < 1) return -ENODEV; alt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]); return 0; }
602,3018----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/icmp.c----icmp_route_lookup,"static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in, const struct iphdr *iph, __be32 saddr, u8 tos, int type, int code, struct icmp_bxm *param) { struct flowi4 fl4 = { <S2SV_StartVul> .daddr = (param->replyopts.srr ? <S2SV_EndVul> <S2SV_StartVul> param->replyopts.faddr : iph->saddr), <S2SV_EndVul> .saddr = saddr, .flowi4_tos = RT_TOS(tos), .flowi4_proto = IPPROTO_ICMP, .fl4_icmp_type = type, .fl4_icmp_code = code, }; struct rtable *rt, *rt2; int err; security_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4)); rt = __ip_route_output_key(net, &fl4); if (IS_ERR(rt)) return rt; rt2 = rt; if (!fl4.saddr) fl4.saddr = rt->rt_src; rt = (struct rtable *) xfrm_lookup(net, &rt->dst, flowi4_to_flowi(&fl4), NULL, 0); if (!IS_ERR(rt)) { if (rt != rt2) return rt; } else if (PTR_ERR(rt) == -EPERM) { rt = NULL; } else return rt; err = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET); if (err) goto relookup_failed; if (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) { rt2 = __ip_route_output_key(net, &fl4); if (IS_ERR(rt2)) err = PTR_ERR(rt2); } else { struct flowi4 fl4_2 = {}; unsigned long orefdst; fl4_2.daddr = fl4.saddr; rt2 = ip_route_output_key(net, &fl4_2); if (IS_ERR(rt2)) { err = PTR_ERR(rt2); goto relookup_failed; } orefdst = skb_in->_skb_refdst; err = ip_route_input(skb_in, fl4.daddr, fl4.saddr, RT_TOS(tos), rt2->dst.dev); dst_release(&rt2->dst); rt2 = skb_rtable(skb_in); skb_in->_skb_refdst = orefdst; } if (err) goto relookup_failed; rt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst, flowi4_to_flowi(&fl4), NULL, XFRM_LOOKUP_ICMP); if (!IS_ERR(rt2)) { dst_release(&rt->dst); rt = rt2; } else if (PTR_ERR(rt2) == -EPERM) { if (rt) dst_release(&rt->dst); return rt2; } else { err = PTR_ERR(rt2); goto relookup_failed; } return rt; relookup_failed: if (rt) return rt; return ERR_PTR(err); }","- .daddr = (param->replyopts.srr ?
- param->replyopts.faddr : iph->saddr),
+ .daddr = (param->replyopts.opt.opt.srr ?
+ param->replyopts.opt.opt.faddr : iph->saddr),","static struct rtable *icmp_route_lookup(struct net *net, struct sk_buff *skb_in, const struct iphdr *iph, __be32 saddr, u8 tos, int type, int code, struct icmp_bxm *param) { struct flowi4 fl4 = { .daddr = (param->replyopts.opt.opt.srr ? param->replyopts.opt.opt.faddr : iph->saddr), .saddr = saddr, .flowi4_tos = RT_TOS(tos), .flowi4_proto = IPPROTO_ICMP, .fl4_icmp_type = type, .fl4_icmp_code = code, }; struct rtable *rt, *rt2; int err; security_skb_classify_flow(skb_in, flowi4_to_flowi(&fl4)); rt = __ip_route_output_key(net, &fl4); if (IS_ERR(rt)) return rt; rt2 = rt; if (!fl4.saddr) fl4.saddr = rt->rt_src; rt = (struct rtable *) xfrm_lookup(net, &rt->dst, flowi4_to_flowi(&fl4), NULL, 0); if (!IS_ERR(rt)) { if (rt != rt2) return rt; } else if (PTR_ERR(rt) == -EPERM) { rt = NULL; } else return rt; err = xfrm_decode_session_reverse(skb_in, flowi4_to_flowi(&fl4), AF_INET); if (err) goto relookup_failed; if (inet_addr_type(net, fl4.saddr) == RTN_LOCAL) { rt2 = __ip_route_output_key(net, &fl4); if (IS_ERR(rt2)) err = PTR_ERR(rt2); } else { struct flowi4 fl4_2 = {}; unsigned long orefdst; fl4_2.daddr = fl4.saddr; rt2 = ip_route_output_key(net, &fl4_2); if (IS_ERR(rt2)) { err = PTR_ERR(rt2); goto relookup_failed; } orefdst = skb_in->_skb_refdst; err = ip_route_input(skb_in, fl4.daddr, fl4.saddr, RT_TOS(tos), rt2->dst.dev); dst_release(&rt2->dst); rt2 = skb_rtable(skb_in); skb_in->_skb_refdst = orefdst; } if (err) goto relookup_failed; rt2 = (struct rtable *) xfrm_lookup(net, &rt2->dst, flowi4_to_flowi(&fl4), NULL, XFRM_LOOKUP_ICMP); if (!IS_ERR(rt2)) { dst_release(&rt->dst); rt = rt2; } else if (PTR_ERR(rt2) == -EPERM) { if (rt) dst_release(&rt->dst); return rt2; } else { err = PTR_ERR(rt2); goto relookup_failed; } return rt; relookup_failed: if (rt) return rt; return ERR_PTR(err); }"
603,3781----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xdelta3-main.h----main_get_appheader,"main_get_appheader (xd3_stream *stream, main_file *ifile, main_file *output, main_file *sfile) { uint8_t *apphead; usize_t appheadsz; int ret; if (! option_use_appheader) { return; } ret = xd3_get_appheader (stream, & apphead, & appheadsz); if (ret != 0) { return; } if (appheadsz > 0) { char *start = (char*)apphead; char *slash; int place = 0; <S2SV_StartVul> char *parsed[4]; <S2SV_EndVul> memset (parsed, 0, sizeof (parsed)); <S2SV_StartVul> while ((slash = strchr (start, '/')) != NULL) <S2SV_EndVul> { *slash = 0; parsed[place++] = start; start = slash + 1; } parsed[place++] = start; if (place == 2 || place == 4) { main_get_appheader_params (output, parsed, 1, ""output"", ifile); } if (place == 4) { main_get_appheader_params (sfile, parsed+2, 0, ""source"", ifile); } } option_use_appheader = 0; return; }","- char *parsed[4];
- while ((slash = strchr (start, '/')) != NULL)
+ const int kMaxArgs = 4;
+ char *parsed[kMaxArgs];
+ while ((slash = strchr (start, '/')) != NULL && place < (kMaxArgs-1))","main_get_appheader (xd3_stream *stream, main_file *ifile, main_file *output, main_file *sfile) { uint8_t *apphead; usize_t appheadsz; int ret; if (! option_use_appheader) { return; } ret = xd3_get_appheader (stream, & apphead, & appheadsz); if (ret != 0) { return; } if (appheadsz > 0) { const int kMaxArgs = 4; char *start = (char*)apphead; char *slash; int place = 0; char *parsed[kMaxArgs]; memset (parsed, 0, sizeof (parsed)); while ((slash = strchr (start, '/')) != NULL && place < (kMaxArgs-1)) { *slash = 0; parsed[place++] = start; start = slash + 1; } parsed[place++] = start; if (place == 2 || place == 4) { main_get_appheader_params (output, parsed, 1, ""output"", ifile); } if (place == 4) { main_get_appheader_params (sfile, parsed+2, 0, ""source"", ifile); } } option_use_appheader = 0; return; }"
604,914----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9919--icmp.c----icmp6_send,"static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info, const struct in6_addr *force_saddr) { struct net *net = dev_net(skb->dev); struct inet6_dev *idev = NULL; struct ipv6hdr *hdr = ipv6_hdr(skb); struct sock *sk; struct ipv6_pinfo *np; const struct in6_addr *saddr = NULL; struct dst_entry *dst; struct icmp6hdr tmp_hdr; struct flowi6 fl6; struct icmpv6_msg msg; struct sockcm_cookie sockc_unused = {0}; struct ipcm6_cookie ipc6; int iif = 0; int addr_type = 0; int len; int err = 0; u32 mark = IP6_REPLY_MARK(net, skb->mark); if ((u8 *)hdr < skb->head || (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb)) return; addr_type = ipv6_addr_type(&hdr->daddr); if (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) || ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr)) saddr = &hdr->daddr; if (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) { if (type != ICMPV6_PKT_TOOBIG && !(type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && (opt_unrec(skb, info)))) return; saddr = NULL; } addr_type = ipv6_addr_type(&hdr->saddr); if (__ipv6_addr_needs_scope_id(addr_type)) iif = skb->dev->ifindex; else iif = l3mdev_master_ifindex(skb_dst(skb)->dev); if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) { net_dbg_ratelimited(""icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } if (is_ineligible(skb)) { net_dbg_ratelimited(""icmp6_send: no reply to icmp error [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } mip6_addr_swap(skb); memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_ICMPV6; fl6.daddr = hdr->saddr; if (force_saddr) saddr = force_saddr; if (saddr) fl6.saddr = *saddr; fl6.flowi6_mark = mark; fl6.flowi6_oif = iif; fl6.fl6_icmp_type = type; fl6.fl6_icmp_code = code; security_skb_classify_flow(skb, flowi6_to_flowi(&fl6)); sk = icmpv6_xmit_lock(net); if (!sk) return; sk->sk_mark = mark; np = inet6_sk(sk); if (!icmpv6_xrlim_allow(sk, type, &fl6)) goto out; tmp_hdr.icmp6_type = type; <S2SV_StartVul> tmp_hdr.icmp6_code = code; <S2SV_EndVul> <S2SV_StartVul> tmp_hdr.icmp6_cksum = 0; <S2SV_EndVul> tmp_hdr.icmp6_pointer = htonl(info); if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) fl6.flowi6_oif = np->mcast_oif; else if (!fl6.flowi6_oif) fl6.flowi6_oif = np->ucast_oif; ipc6.tclass = np->tclass; fl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel); dst = icmpv6_route_lookup(net, skb, sk, &fl6); if (IS_ERR(dst)) goto out; ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst); ipc6.dontfrag = np->dontfrag; ipc6.opt = NULL; msg.skb = skb; msg.offset = skb_network_offset(skb); msg.type = type; len = skb->len - msg.offset; len = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr)); if (len < 0) { net_dbg_ratelimited(""icmp: len problem [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); goto out_dst_release; } rcu_read_lock(); idev = __in6_dev_get(skb->dev); err = ip6_append_data(sk, icmpv6_getfrag, &msg, len + sizeof(struct icmp6hdr), sizeof(struct icmp6hdr), &ipc6, &fl6, (struct rt6_info *)dst, MSG_DONTWAIT, &sockc_unused); if (err) { ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS); ip6_flush_pending_frames(sk); } else { err = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr, len + sizeof(struct icmp6hdr)); } rcu_read_unlock(); out_dst_release: dst_release(dst); out: icmpv6_xmit_unlock(sk); }","- tmp_hdr.icmp6_code = code;
- tmp_hdr.icmp6_cksum = 0;
+ 
+ tmp_hdr.icmp6_type = type;
+ tmp_hdr.icmp6_code = code;
+ tmp_hdr.icmp6_cksum = 0;","static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info, const struct in6_addr *force_saddr) { struct net *net = dev_net(skb->dev); struct inet6_dev *idev = NULL; struct ipv6hdr *hdr = ipv6_hdr(skb); struct sock *sk; struct ipv6_pinfo *np; const struct in6_addr *saddr = NULL; struct dst_entry *dst; struct icmp6hdr tmp_hdr; struct flowi6 fl6; struct icmpv6_msg msg; struct sockcm_cookie sockc_unused = {0}; struct ipcm6_cookie ipc6; int iif = 0; int addr_type = 0; int len; int err = 0; u32 mark = IP6_REPLY_MARK(net, skb->mark); if ((u8 *)hdr < skb->head || (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb)) return; addr_type = ipv6_addr_type(&hdr->daddr); if (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) || ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr)) saddr = &hdr->daddr; if (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) { if (type != ICMPV6_PKT_TOOBIG && !(type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && (opt_unrec(skb, info)))) return; saddr = NULL; } addr_type = ipv6_addr_type(&hdr->saddr); if (__ipv6_addr_needs_scope_id(addr_type)) iif = skb->dev->ifindex; else { dst = skb_dst(skb); iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev); } if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) { net_dbg_ratelimited(""icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } if (is_ineligible(skb)) { net_dbg_ratelimited(""icmp6_send: no reply to icmp error [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } mip6_addr_swap(skb); memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_ICMPV6; fl6.daddr = hdr->saddr; if (force_saddr) saddr = force_saddr; if (saddr) fl6.saddr = *saddr; fl6.flowi6_mark = mark; fl6.flowi6_oif = iif; fl6.fl6_icmp_type = type; fl6.fl6_icmp_code = code; security_skb_classify_flow(skb, flowi6_to_flowi(&fl6)); sk = icmpv6_xmit_lock(net); if (!sk) return; sk->sk_mark = mark; np = inet6_sk(sk); if (!icmpv6_xrlim_allow(sk, type, &fl6)) goto out; tmp_hdr.icmp6_type = type; tmp_hdr.icmp6_code = code; tmp_hdr.icmp6_cksum = 0; tmp_hdr.icmp6_pointer = htonl(info); if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) fl6.flowi6_oif = np->mcast_oif; else if (!fl6.flowi6_oif) fl6.flowi6_oif = np->ucast_oif; ipc6.tclass = np->tclass; fl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel); dst = icmpv6_route_lookup(net, skb, sk, &fl6); if (IS_ERR(dst)) goto out; ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst); ipc6.dontfrag = np->dontfrag; ipc6.opt = NULL; msg.skb = skb; msg.offset = skb_network_offset(skb); msg.type = type; len = skb->len - msg.offset; len = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr)); if (len < 0) { net_dbg_ratelimited(""icmp: len problem [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); goto out_dst_release; } rcu_read_lock(); idev = __in6_dev_get(skb->dev); err = ip6_append_data(sk, icmpv6_getfrag, &msg, len + sizeof(struct icmp6hdr), sizeof(struct icmp6hdr), &ipc6, &fl6, (struct rt6_info *)dst, MSG_DONTWAIT, &sockc_unused); if (err) { ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS); ip6_flush_pending_frames(sk); } else { err = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr, len + sizeof(struct icmp6hdr)); } rcu_read_unlock(); out_dst_release: dst_release(dst); out: icmpv6_xmit_unlock(sk); }"
605,7422----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/axohelp.c----SetDashSize,"void SetDashSize(double dashsize,double phase) { <S2SV_StartVul> if ( dashsize ) outpos += sprintf(outpos,"" [%12.3f] %12.3f d"",dashsize,phase); <S2SV_EndVul> <S2SV_StartVul> else outpos += sprintf(outpos,"" [] 0 d""); <S2SV_EndVul> }","- if ( dashsize ) outpos += sprintf(outpos,"" [%12.3f] %12.3f d"",dashsize,phase);
- else outpos += sprintf(outpos,"" [] 0 d"");
+ if ( dashsize ) {
+ sprintf(outputbuffer,"" [%12.3f] %12.3f d"",dashsize,phase);
+ sendClean(outputbuffer);
+ }
+ else send("" [] 0 d"");","void SetDashSize(double dashsize,double phase) { if ( dashsize ) { sprintf(outputbuffer,"" [%12.3f] %12.3f d"",dashsize,phase); sendClean(outputbuffer); } else send("" [] 0 d""); }"
606,4412----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bufferedreader.c----__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_6read_one,"static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_6read_one(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) { unsigned char __pyx_v_rv; PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations int __pyx_t_1; PyObject *__pyx_t_2 = NULL; PyObject *__pyx_t_3 = NULL; PyObject *__pyx_t_4 = NULL; int __pyx_t_5; __Pyx_RefNannySetupContext(""read_one"", 0); __pyx_t_1 = ((__pyx_v_self->position == __pyx_v_self->current_buffer_size) != 0); if (__pyx_t_1) { __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_read_into_buffer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 55, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __pyx_t_4 = NULL; if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) { __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3); if (likely(__pyx_t_4)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); __Pyx_INCREF(__pyx_t_4); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_3, function); } } __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_self->position = 0; } <S2SV_StartVul> __pyx_t_5 = __Pyx_GetItemInt_ByteArray(__pyx_v_self->buffer, __pyx_v_self->position, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 1, 1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 58, __pyx_L1_error) <S2SV_EndVul> __pyx_v_rv = __pyx_t_5; __pyx_v_self->position = (__pyx_v_self->position + 1); __Pyx_XDECREF(__pyx_r); __pyx_t_2 = __Pyx_PyInt_From_unsigned_char(__pyx_v_rv); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 60, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_r = __pyx_t_2; __pyx_t_2 = 0; goto __pyx_L0; __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_2); __Pyx_XDECREF(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __Pyx_AddTraceback(""clickhouse_driver.bufferedreader.BufferedReader.read_one"", __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; }","- __pyx_t_5 = __Pyx_GetItemInt_ByteArray(__pyx_v_self->buffer, __pyx_v_self->position, Py_ssize_t, 1, PyInt_FromSsize_t, 0, 1, 1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 58, __pyx_L1_error)
+ int __pyx_lineno = 0;
+ const char *__pyx_filename = NULL;
+ int __pyx_clineno = 0;
+ __pyx_t_5 = __Pyx_GetItemInt_ByteArray(__pyx_v_self->buffer, __pyx_v_self->position, unsigned PY_LONG_LONG, 0, __Pyx_PyInt_From_unsigned_PY_LONG_LONG, 0, 0, 1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 58, __pyx_L1_error)","static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_6read_one(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) { unsigned char __pyx_v_rv; PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations int __pyx_t_1; PyObject *__pyx_t_2 = NULL; PyObject *__pyx_t_3 = NULL; PyObject *__pyx_t_4 = NULL; int __pyx_t_5; int __pyx_lineno = 0; const char *__pyx_filename = NULL; int __pyx_clineno = 0; __Pyx_RefNannySetupContext(""read_one"", 0); __pyx_t_1 = ((__pyx_v_self->position == __pyx_v_self->current_buffer_size) != 0); if (__pyx_t_1) { __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_read_into_buffer); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 55, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __pyx_t_4 = NULL; if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) { __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3); if (likely(__pyx_t_4)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); __Pyx_INCREF(__pyx_t_4); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_3, function); } } __pyx_t_2 = (__pyx_t_4) ? __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4) : __Pyx_PyObject_CallNoArg(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 55, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_self->position = 0; } __pyx_t_5 = __Pyx_GetItemInt_ByteArray(__pyx_v_self->buffer, __pyx_v_self->position, unsigned PY_LONG_LONG, 0, __Pyx_PyInt_From_unsigned_PY_LONG_LONG, 0, 0, 1); if (unlikely(__pyx_t_5 == -1)) __PYX_ERR(0, 58, __pyx_L1_error) __pyx_v_rv = __pyx_t_5; __pyx_v_self->position = (__pyx_v_self->position + 1); __Pyx_XDECREF(__pyx_r); __pyx_t_2 = __Pyx_PyInt_From_unsigned_char(__pyx_v_rv); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 60, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_r = __pyx_t_2; __pyx_t_2 = 0; goto __pyx_L0; __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_2); __Pyx_XDECREF(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __Pyx_AddTraceback(""clickhouse_driver.bufferedreader.BufferedReader.read_one"", __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; }"
607,5996----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiRegexp.c----Jsi_RegExpMatch,"Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr) { Jsi_Regex *re; int regexec_flags = 0; if (rc) *rc = 0; if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) return Jsi_LogError(""expected pattern""); re = pattern->d.obj->d.robj; regex_t *reg = &re->reg; regmatch_t pos = {}; if (dStr) Jsi_DSInit(dStr); int r = regexec(reg, v, 1, &pos, regexec_flags); if (r >= REG_BADPAT) { <S2SV_StartVul> char buf[100]; <S2SV_EndVul> regerror(r, reg, buf, sizeof(buf)); return Jsi_LogError(""error while matching pattern: %s"", buf); } if (r != REG_NOMATCH) { if (rc) *rc = 1; if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 && pos.rm_eo >= pos.rm_so) Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so); } return JSI_OK; }","- char buf[100];
+ char buf[JSI_MAX_NUMBER_STRING];","Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr) { Jsi_Regex *re; int regexec_flags = 0; if (rc) *rc = 0; if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) return Jsi_LogError(""expected pattern""); re = pattern->d.obj->d.robj; regex_t *reg = &re->reg; regmatch_t pos = {}; if (dStr) Jsi_DSInit(dStr); int r = regexec(reg, v, 1, &pos, regexec_flags); if (r >= REG_BADPAT) { char buf[JSI_MAX_NUMBER_STRING]; regerror(r, reg, buf, sizeof(buf)); return Jsi_LogError(""error while matching pattern: %s"", buf); } if (r != REG_NOMATCH) { if (rc) *rc = 1; if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 && pos.rm_eo >= pos.rm_so) Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so); } return JSI_OK; }"
608,6191----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/PlayerGeneric.cpp----PlayerGeneric::~PlayerGeneric,PlayerGeneric::~PlayerGeneric() { <S2SV_StartVul> if (mixer) <S2SV_EndVul> <S2SV_StartVul> delete mixer; <S2SV_EndVul> if (player) { <S2SV_StartVul> if (mixer->isActive() && !mixer->isDeviceRemoved(player)) <S2SV_EndVul> mixer->removeDevice(player); delete player; } delete[] audioDriverName; delete listener; },"- if (mixer)
- delete mixer;
- if (mixer->isActive() && !mixer->isDeviceRemoved(player))
+ if (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))
+ if (mixer)
+ delete mixer;",PlayerGeneric::~PlayerGeneric() { if (player) { if (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player)) mixer->removeDevice(player); delete player; } if (mixer) delete mixer; delete[] audioDriverName; delete listener; }
609,1804----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-7532--psd.c----RemoveResolutionFromResourceBlock,"static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile) { register const unsigned char *p; size_t length; unsigned char *datum; unsigned int count, long_sans; unsigned short id, short_sans; length=GetStringInfoLength(bim_profile); if (length < 16) return; <S2SV_StartVul> datum=GetStringInfoDatum(bim_profile); <S2SV_EndVul> for (p=datum; (p >= datum) && (p < (datum+length-16)); ) { register unsigned char *q; <S2SV_StartVul> <S2SV_EndVul> q=(unsigned char *) p; <S2SV_StartVul> if (LocaleNCompare((const char *) p,""8BIM"",4) != 0) <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> p=PushLongPixel(MSBEndian,p,&long_sans); <S2SV_EndVul> p=PushShortPixel(MSBEndian,p,&id); p=PushShortPixel(MSBEndian,p,&short_sans); p=PushLongPixel(MSBEndian,p,&count); if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12))) { (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length- (PSDQuantum(count)+12)-(q-datum)); SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12)); <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> p+=count; if ((count & 0x01) != 0) p++; } }","- datum=GetStringInfoDatum(bim_profile);
- 
- if (LocaleNCompare((const char *) p,""8BIM"",4) != 0)
- break;
- p=PushLongPixel(MSBEndian,p,&long_sans);
- break;
- }
+ ssize_t
+ cnt;
+ return;
+ cnt=PSDQuantum(count);
+ if (cnt < 0)
+ return;
+ if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))
+ (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));
+ SetStringInfoLength(bim_profile,length-(cnt+12));","static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile) { register const unsigned char *p; size_t length; unsigned char *datum; unsigned int count, long_sans; unsigned short id, short_sans; length=GetStringInfoLength(bim_profile); if (length < 16) return; datum=GetStringInfoDatum(bim_profile); for (p=datum; (p >= datum) && (p < (datum+length-16)); ) { register unsigned char *q; ssize_t cnt; q=(unsigned char *) p; if (LocaleNCompare((const char *) p,""8BIM"",4) != 0) return; p=PushLongPixel(MSBEndian,p,&long_sans); p=PushShortPixel(MSBEndian,p,&id); p=PushShortPixel(MSBEndian,p,&short_sans); p=PushLongPixel(MSBEndian,p,&count); cnt=PSDQuantum(count); if (cnt < 0) return; if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12))) { (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum)); SetStringInfoLength(bim_profile,length-(cnt+12)); break; } p+=count; if ((count & 0x01) != 0) p++; } }"
610,254----CWE-287----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-3520--af_netlink.c----netlink_sendmsg,"static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) { struct sock_iocb *siocb = kiocb_to_siocb(kiocb); struct sock *sk = sock->sk; struct netlink_sock *nlk = nlk_sk(sk); struct sockaddr_nl *addr = msg->msg_name; u32 dst_pid; u32 dst_group; struct sk_buff *skb; int err; struct scm_cookie scm; if (msg->msg_flags&MSG_OOB) return -EOPNOTSUPP; if (NULL == siocb->scm) siocb->scm = &scm; <S2SV_StartVul> err = scm_send(sock, msg, siocb->scm); <S2SV_EndVul> if (err < 0) return err; if (msg->msg_namelen) { err = -EINVAL; if (addr->nl_family != AF_NETLINK) goto out; dst_pid = addr->nl_pid; dst_group = ffs(addr->nl_groups); err = -EPERM; if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND)) goto out; } else { dst_pid = nlk->dst_pid; dst_group = nlk->dst_group; } if (!nlk->pid) { err = netlink_autobind(sock); if (err) goto out; } err = -EMSGSIZE; if (len > sk->sk_sndbuf - 32) goto out; err = -ENOBUFS; skb = alloc_skb(len, GFP_KERNEL); if (skb == NULL) goto out; NETLINK_CB(skb).pid = nlk->pid; NETLINK_CB(skb).dst_group = dst_group; memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred)); err = -EFAULT; if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) { kfree_skb(skb); goto out; } err = security_netlink_send(sk, skb); if (err) { kfree_skb(skb); goto out; } if (dst_group) { atomic_inc(&skb->users); netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL); } err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT); out: scm_destroy(siocb->scm); return err; }","- err = scm_send(sock, msg, siocb->scm);
+ err = scm_send(sock, msg, siocb->scm, true);","static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock, struct msghdr *msg, size_t len) { struct sock_iocb *siocb = kiocb_to_siocb(kiocb); struct sock *sk = sock->sk; struct netlink_sock *nlk = nlk_sk(sk); struct sockaddr_nl *addr = msg->msg_name; u32 dst_pid; u32 dst_group; struct sk_buff *skb; int err; struct scm_cookie scm; if (msg->msg_flags&MSG_OOB) return -EOPNOTSUPP; if (NULL == siocb->scm) siocb->scm = &scm; err = scm_send(sock, msg, siocb->scm, true); if (err < 0) return err; if (msg->msg_namelen) { err = -EINVAL; if (addr->nl_family != AF_NETLINK) goto out; dst_pid = addr->nl_pid; dst_group = ffs(addr->nl_groups); err = -EPERM; if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND)) goto out; } else { dst_pid = nlk->dst_pid; dst_group = nlk->dst_group; } if (!nlk->pid) { err = netlink_autobind(sock); if (err) goto out; } err = -EMSGSIZE; if (len > sk->sk_sndbuf - 32) goto out; err = -ENOBUFS; skb = alloc_skb(len, GFP_KERNEL); if (skb == NULL) goto out; NETLINK_CB(skb).pid = nlk->pid; NETLINK_CB(skb).dst_group = dst_group; memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred)); err = -EFAULT; if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) { kfree_skb(skb); goto out; } err = security_netlink_send(sk, skb); if (err) { kfree_skb(skb); goto out; } if (dst_group) { atomic_inc(&skb->users); netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL); } err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT); out: scm_destroy(siocb->scm); return err; }"
611,4808----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/test-conf-files.c----setup_test_dir,"static void setup_test_dir(char *tmp_dir, const char *files, ...) { va_list ap; assert_se(mkdtemp(tmp_dir) != NULL); va_start(ap, files); while (files != NULL) { _cleanup_free_ char *path = strappend(tmp_dir, files); <S2SV_StartVul> assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0); <S2SV_EndVul> files = va_arg(ap, const char *); } va_end(ap); }","- assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);
+ assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID) == 0);","static void setup_test_dir(char *tmp_dir, const char *files, ...) { va_list ap; assert_se(mkdtemp(tmp_dir) != NULL); va_start(ap, files); while (files != NULL) { _cleanup_free_ char *path = strappend(tmp_dir, files); assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID) == 0); files = va_arg(ap, const char *); } va_end(ap); }"
612,6326----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jpc_t2cod.c----jpc_pi_nextrlcp,"static int jpc_pi_nextrlcp(register jpc_pi_t *pi) { jpc_pchg_t *pchg; int *prclyrno; pchg = pi->pchg; if (!pi->prgvolfirst) { assert(pi->prcno < pi->pirlvl->numprcs); prclyrno = &pi->pirlvl->prclyrnos[pi->prcno]; goto skip; } else { pi->prgvolfirst = 0; } for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls && pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) { for (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) { for (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno]; pi->compno < pi->numcomps && <S2SV_StartVul> pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) { <S2SV_EndVul> if (pi->rlvlno >= pi->picomp->numrlvls) { continue; } pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno]; for (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos; pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) { if (pi->lyrno >= *prclyrno) { *prclyrno = pi->lyrno; ++(*prclyrno); return 0; } skip: ; } } } } return 1; }","- pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) {
+ pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,
+ ++pi->picomp) {","static int jpc_pi_nextrlcp(register jpc_pi_t *pi) { jpc_pchg_t *pchg; int *prclyrno; pchg = pi->pchg; if (!pi->prgvolfirst) { assert(pi->prcno < pi->pirlvl->numprcs); prclyrno = &pi->pirlvl->prclyrnos[pi->prcno]; goto skip; } else { pi->prgvolfirst = 0; } for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pi->maxrlvls && pi->rlvlno < pchg->rlvlnoend; ++pi->rlvlno) { for (pi->lyrno = 0; pi->lyrno < pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) { for (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno]; pi->compno < pi->numcomps && pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) { if (pi->rlvlno >= pi->picomp->numrlvls) { continue; } pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno]; for (pi->prcno = 0, prclyrno = pi->pirlvl->prclyrnos; pi->prcno < pi->pirlvl->numprcs; ++pi->prcno, ++prclyrno) { if (pi->lyrno >= *prclyrno) { *prclyrno = pi->lyrno; ++(*prclyrno); return 0; } skip: ; } } } } return 1; }"
613,2612----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-2821--xpath.c----xmlXPathCompOpEvalPositionalPredicate,"xmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op, xmlNodeSetPtr set, int contextSize, int minPos, int maxPos, int hasNsNodes) { if (op->ch1 != -1) { xmlXPathCompExprPtr comp = ctxt->comp; if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) { } contextSize = xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set, contextSize, hasNsNodes); CHECK_ERROR0; if (contextSize <= 0) return(0); } if (contextSize < minPos) { xmlXPathNodeSetClear(set, hasNsNodes); return(0); } if (op->ch2 == -1) { return (contextSize); } else { xmlDocPtr oldContextDoc; int i, pos = 0, newContextSize = 0, contextPos = 0, res; xmlXPathStepOpPtr exprOp; xmlXPathObjectPtr contextObj = NULL, exprRes = NULL; xmlNodePtr oldContextNode, contextNode = NULL; xmlXPathContextPtr xpctxt = ctxt->context; #ifdef LIBXML_XPTR_ENABLED #endif oldContextNode = xpctxt->node; oldContextDoc = xpctxt->doc; exprOp = &ctxt->comp->steps[op->ch2]; for (i = 0; i < set->nodeNr; i++) { if (set->nodeTab[i] == NULL) continue; contextNode = set->nodeTab[i]; xpctxt->node = contextNode; xpctxt->contextSize = contextSize; xpctxt->proximityPosition = ++contextPos; if ((contextNode->type != XML_NAMESPACE_DECL) && (contextNode->doc != NULL)) xpctxt->doc = contextNode->doc; if (contextObj == NULL) contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode); else xmlXPathNodeSetAddUnique(contextObj->nodesetval, contextNode); valuePush(ctxt, contextObj); res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1); if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) { xmlXPathObjectPtr tmp; tmp = valuePop(ctxt); <S2SV_StartVul> if (tmp != contextObj) <S2SV_EndVul> xmlXPathReleaseObject(xpctxt, tmp); <S2SV_StartVul> valuePop(ctxt); <S2SV_EndVul> goto evaluation_error; } if (res) pos++; if (res && (pos >= minPos) && (pos <= maxPos)) { newContextSize++; if (minPos == maxPos) { if (contextNode->type == XML_NAMESPACE_DECL) { set->nodeTab[i] = NULL; } xmlXPathNodeSetClear(set, hasNsNodes); set->nodeNr = 1; set->nodeTab[0] = contextNode; goto evaluation_exit; } if (pos == maxPos) { xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes); goto evaluation_exit; } } else { set->nodeTab[i] = NULL; if (contextNode->type == XML_NAMESPACE_DECL) xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode); } if (exprRes != NULL) { xmlXPathReleaseObject(ctxt->context, exprRes); exprRes = NULL; } if (ctxt->value == contextObj) { valuePop(ctxt); xmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes); } else { contextObj = NULL; } } goto evaluation_exit; evaluation_error: xmlXPathNodeSetClear(set, hasNsNodes); newContextSize = 0; evaluation_exit: if (contextObj != NULL) { if (ctxt->value == contextObj) valuePop(ctxt); xmlXPathReleaseObject(xpctxt, contextObj); } if (exprRes != NULL) xmlXPathReleaseObject(ctxt->context, exprRes); xpctxt->node = oldContextNode; xpctxt->doc = oldContextDoc; xpctxt->contextSize = -1; xpctxt->proximityPosition = -1; return(newContextSize); } return(contextSize); }","- if (tmp != contextObj)
- valuePop(ctxt);
+ while (tmp != contextObj) {
+ tmp = valuePop(ctxt);
+ }","xmlXPathCompOpEvalPositionalPredicate(xmlXPathParserContextPtr ctxt, xmlXPathStepOpPtr op, xmlNodeSetPtr set, int contextSize, int minPos, int maxPos, int hasNsNodes) { if (op->ch1 != -1) { xmlXPathCompExprPtr comp = ctxt->comp; if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) { } contextSize = xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set, contextSize, hasNsNodes); CHECK_ERROR0; if (contextSize <= 0) return(0); } if (contextSize < minPos) { xmlXPathNodeSetClear(set, hasNsNodes); return(0); } if (op->ch2 == -1) { return (contextSize); } else { xmlDocPtr oldContextDoc; int i, pos = 0, newContextSize = 0, contextPos = 0, res; xmlXPathStepOpPtr exprOp; xmlXPathObjectPtr contextObj = NULL, exprRes = NULL; xmlNodePtr oldContextNode, contextNode = NULL; xmlXPathContextPtr xpctxt = ctxt->context; #ifdef LIBXML_XPTR_ENABLED #endif oldContextNode = xpctxt->node; oldContextDoc = xpctxt->doc; exprOp = &ctxt->comp->steps[op->ch2]; for (i = 0; i < set->nodeNr; i++) { if (set->nodeTab[i] == NULL) continue; contextNode = set->nodeTab[i]; xpctxt->node = contextNode; xpctxt->contextSize = contextSize; xpctxt->proximityPosition = ++contextPos; if ((contextNode->type != XML_NAMESPACE_DECL) && (contextNode->doc != NULL)) xpctxt->doc = contextNode->doc; if (contextObj == NULL) contextObj = xmlXPathCacheNewNodeSet(xpctxt, contextNode); else xmlXPathNodeSetAddUnique(contextObj->nodesetval, contextNode); valuePush(ctxt, contextObj); res = xmlXPathCompOpEvalToBoolean(ctxt, exprOp, 1); if ((ctxt->error != XPATH_EXPRESSION_OK) || (res == -1)) { xmlXPathObjectPtr tmp; tmp = valuePop(ctxt); while (tmp != contextObj) { xmlXPathReleaseObject(xpctxt, tmp); tmp = valuePop(ctxt); } goto evaluation_error; } if (res) pos++; if (res && (pos >= minPos) && (pos <= maxPos)) { newContextSize++; if (minPos == maxPos) { if (contextNode->type == XML_NAMESPACE_DECL) { set->nodeTab[i] = NULL; } xmlXPathNodeSetClear(set, hasNsNodes); set->nodeNr = 1; set->nodeTab[0] = contextNode; goto evaluation_exit; } if (pos == maxPos) { xmlXPathNodeSetClearFromPos(set, i +1, hasNsNodes); goto evaluation_exit; } } else { set->nodeTab[i] = NULL; if (contextNode->type == XML_NAMESPACE_DECL) xmlXPathNodeSetFreeNs((xmlNsPtr) contextNode); } if (exprRes != NULL) { xmlXPathReleaseObject(ctxt->context, exprRes); exprRes = NULL; } if (ctxt->value == contextObj) { valuePop(ctxt); xmlXPathNodeSetClear(contextObj->nodesetval, hasNsNodes); } else { contextObj = NULL; } } goto evaluation_exit; evaluation_error: xmlXPathNodeSetClear(set, hasNsNodes); newContextSize = 0; evaluation_exit: if (contextObj != NULL) { if (ctxt->value == contextObj) valuePop(ctxt); xmlXPathReleaseObject(xpctxt, contextObj); } if (exprRes != NULL) xmlXPathReleaseObject(ctxt->context, exprRes); xpctxt->node = oldContextNode; xpctxt->doc = oldContextDoc; xpctxt->contextSize = -1; xpctxt->proximityPosition = -1; return(newContextSize); } return(contextSize); }"
614,6622----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/snmp-engine.c----snmp_engine_get,"<S2SV_StartVul> snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length) <S2SV_EndVul> { snmp_mib_resource_t *resource; <S2SV_StartVul> uint32_t i; <S2SV_EndVul> <S2SV_StartVul> for(i = 0; i < varbinds_length; i++) { <S2SV_EndVul> <S2SV_StartVul> resource = snmp_mib_find(varbinds[i].oid); <S2SV_EndVul> if(!resource) { switch(header->version) { case SNMP_VERSION_1: <S2SV_StartVul> header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME; <S2SV_EndVul> <S2SV_StartVul> header->error_index_max_repetitions.error_index = i + 1; <S2SV_EndVul> break; case SNMP_VERSION_2C: <S2SV_StartVul> (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE; <S2SV_EndVul> break; default: <S2SV_StartVul> header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME; <S2SV_EndVul> <S2SV_StartVul> header->error_index_max_repetitions.error_index = 0; <S2SV_EndVul> } } else { <S2SV_StartVul> resource->handler(&varbinds[i], resource->oid); <S2SV_EndVul> } } return 0; }","- snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)
- uint32_t i;
- for(i = 0; i < varbinds_length; i++) {
- resource = snmp_mib_find(varbinds[i].oid);
- header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
- header->error_index_max_repetitions.error_index = i + 1;
- (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;
- header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
- header->error_index_max_repetitions.error_index = 0;
- resource->handler(&varbinds[i], resource->oid);
+ snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds)
+ uint8_t i;
+ i = 0;
+ while(varbinds[i].value_type != BER_DATA_TYPE_EOC && i < SNMP_MAX_NR_VALUES) {
+ resource = snmp_mib_find(&varbinds[i].oid);
+ header->error_status = SNMP_STATUS_NO_SUCH_NAME;
+ header->error_index = i + 1;
+ (&varbinds[i])->value_type = BER_DATA_TYPE_NO_SUCH_INSTANCE;
+ header->error_status = SNMP_STATUS_NO_SUCH_NAME;
+ header->error_index = 0;
+ resource->handler(&varbinds[i], &resource->oid);
+ i++;","snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds) { snmp_mib_resource_t *resource; uint8_t i; i = 0; while(varbinds[i].value_type != BER_DATA_TYPE_EOC && i < SNMP_MAX_NR_VALUES) { resource = snmp_mib_find(&varbinds[i].oid); if(!resource) { switch(header->version) { case SNMP_VERSION_1: header->error_status = SNMP_STATUS_NO_SUCH_NAME; header->error_index = i + 1; break; case SNMP_VERSION_2C: (&varbinds[i])->value_type = BER_DATA_TYPE_NO_SUCH_INSTANCE; break; default: header->error_status = SNMP_STATUS_NO_SUCH_NAME; header->error_index = 0; } } else { resource->handler(&varbinds[i], &resource->oid); } i++; } return 0; }"
615,124----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4353--ber-decoder.c----push_decoder_state,"push_decoder_state (DECODER_STATE ds) { if (ds->idx >= ds->stacksize) { <S2SV_StartVul> fprintf (stderr, ""ERROR: decoder stack overflow!\n""); <S2SV_EndVul> <S2SV_StartVul> abort (); <S2SV_EndVul> } ds->stack[ds->idx++] = ds->cur; }","- fprintf (stderr, ""ERROR: decoder stack overflow!\n"");
- abort ();
+ fprintf (stderr, ""ksba: ber-decoder: stack overflow!\n"");
+ return gpg_error (GPG_ERR_LIMIT_REACHED);
+ return 0;","push_decoder_state (DECODER_STATE ds) { if (ds->idx >= ds->stacksize) { fprintf (stderr, ""ksba: ber-decoder: stack overflow!\n""); return gpg_error (GPG_ERR_LIMIT_REACHED); } ds->stack[ds->idx++] = ds->cur; return 0; }"
616,2892----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/archive_write_disk_posix.c----_archive_write_disk_close,"_archive_write_disk_close(struct archive *_a) { struct archive_write_disk *a = (struct archive_write_disk *)_a; struct fixup_entry *next, *p; int fd, ret; archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC, ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA, ""archive_write_disk_close""); ret = _archive_write_disk_finish_entry(&a->archive); p = sort_dir_list(a->fixup_list); while (p != NULL) { fd = -1; a->pst = NULL; if (p->fixup & (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) { fd = open(p->name, O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC); } if (p->fixup & TODO_TIMES) { set_times(a, fd, p->mode, p->name, p->atime, p->atime_nanos, p->birthtime, p->birthtime_nanos, p->mtime, p->mtime_nanos, p->ctime, p->ctime_nanos); } if (p->fixup & TODO_MODE_BASE) { #ifdef HAVE_FCHMOD if (fd >= 0) fchmod(fd, p->mode); else #endif <S2SV_StartVul> chmod(p->name, p->mode); <S2SV_EndVul> } if (p->fixup & TODO_ACLS) archive_write_disk_set_acls(&a->archive, fd, p->name, &p->acl, p->mode); if (p->fixup & TODO_FFLAGS) set_fflags_platform(a, fd, p->name, p->mode, p->fflags_set, 0); if (p->fixup & TODO_MAC_METADATA) set_mac_metadata(a, p->name, p->mac_metadata, p->mac_metadata_size); next = p->next; archive_acl_clear(&p->acl); free(p->mac_metadata); free(p->name); if (fd >= 0) close(fd); free(p); p = next; } a->fixup_list = NULL; return (ret); }","- chmod(p->name, p->mode);
+ struct stat st;
+ if (fd == -1) {
+ if (lstat(p->name, &st) != 0)
+ goto skip_fixup_entry;
+ if (S_ISLNK(st.st_mode)) {
+ p->mode &= ~S_IFMT;
+ p->mode |= S_IFLNK;
+ }
+ }
+ #ifdef HAVE_LCHMOD
+ lchmod(p->name, p->mode);
+ #else
+ if (!S_ISLNK(p->mode))
+ chmod(p->name, p->mode);
+ #endif
+ skip_fixup_entry:","_archive_write_disk_close(struct archive *_a) { struct archive_write_disk *a = (struct archive_write_disk *)_a; struct fixup_entry *next, *p; struct stat st; int fd, ret; archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC, ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA, ""archive_write_disk_close""); ret = _archive_write_disk_finish_entry(&a->archive); p = sort_dir_list(a->fixup_list); while (p != NULL) { fd = -1; a->pst = NULL; if (p->fixup & (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) { fd = open(p->name, O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC); if (fd == -1) { if (lstat(p->name, &st) != 0) goto skip_fixup_entry; if (S_ISLNK(st.st_mode)) { p->mode &= ~S_IFMT; p->mode |= S_IFLNK; } } } if (p->fixup & TODO_TIMES) { set_times(a, fd, p->mode, p->name, p->atime, p->atime_nanos, p->birthtime, p->birthtime_nanos, p->mtime, p->mtime_nanos, p->ctime, p->ctime_nanos); } if (p->fixup & TODO_MODE_BASE) { #ifdef HAVE_FCHMOD if (fd >= 0) fchmod(fd, p->mode); else #endif #ifdef HAVE_LCHMOD lchmod(p->name, p->mode); #else if (!S_ISLNK(p->mode)) chmod(p->name, p->mode); #endif } if (p->fixup & TODO_ACLS) archive_write_disk_set_acls(&a->archive, fd, p->name, &p->acl, p->mode); if (p->fixup & TODO_FFLAGS) set_fflags_platform(a, fd, p->name, p->mode, p->fflags_set, 0); if (p->fixup & TODO_MAC_METADATA) set_mac_metadata(a, p->name, p->mac_metadata, p->mac_metadata_size); skip_fixup_entry: next = p->next; archive_acl_clear(&p->acl); free(p->mac_metadata); free(p->name); if (fd >= 0) close(fd); free(p); p = next; } a->fixup_list = NULL; return (ret); }"
617,933----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9535--tif_predict.c----horDiff32,"<S2SV_StartVul> horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> TIFFPredictorState* sp = PredictorState(tif); <S2SV_EndVul> <S2SV_StartVul> tmsize_t stride = sp->stride; <S2SV_EndVul> <S2SV_StartVul> uint32 *wp = (uint32*) cp0; <S2SV_EndVul> tmsize_t wc = cc/4; assert((cc%(4*stride))==0); if (wc > stride) { wc -= stride; wp += wc - 1; do { REPEAT4(stride, wp[stride] -= wp[0]; wp--) wc -= stride; } while (wc > 0); } }","- horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)
- {
- TIFFPredictorState* sp = PredictorState(tif);
- tmsize_t stride = sp->stride;
- uint32 *wp = (uint32*) cp0;
+ horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)
+ {
+ TIFFPredictorState* sp = PredictorState(tif);
+ tmsize_t stride = sp->stride;
+ uint32 *wp = (uint32*) cp0;","horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; uint32 *wp = (uint32*) cp0; tmsize_t wc = cc/4; if((cc%(4*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, ""horDiff32"", ""%s"", ""(cc%(4*stride))!=0""); return 0; } if (wc > stride) { wc -= stride; wp += wc - 1; do { REPEAT4(stride, wp[stride] -= wp[0]; wp--) wc -= stride; } while (wc > 0); } return 1; }"
618,1142----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8844--signal_32.c----restore_tm_user_regs,"static long restore_tm_user_regs(struct pt_regs *regs, struct mcontext __user *sr, struct mcontext __user *tm_sr) { long err; unsigned long msr, msr_hi; #ifdef CONFIG_VSX int i; #endif err = restore_general_regs(regs, tm_sr); err |= restore_general_regs(&current->thread.ckpt_regs, sr); err |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]); err |= __get_user(msr, &sr->mc_gregs[PT_MSR]); if (err) return 1; regs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE); discard_lazy_cpu_state(); #ifdef CONFIG_ALTIVEC regs->msr &= ~MSR_VEC; if (msr & MSR_VEC) { if (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs, sizeof(sr->mc_vregs)) || __copy_from_user(&current->thread.transact_vr, &tm_sr->mc_vregs, sizeof(sr->mc_vregs))) return 1; } else if (current->thread.used_vr) { memset(&current->thread.vr_state, 0, ELF_NVRREG * sizeof(vector128)); memset(&current->thread.transact_vr, 0, ELF_NVRREG * sizeof(vector128)); } if (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]) || __get_user(current->thread.transact_vrsave, (u32 __user *)&tm_sr->mc_vregs[32])) return 1; if (cpu_has_feature(CPU_FTR_ALTIVEC)) mtspr(SPRN_VRSAVE, current->thread.vrsave); #endif regs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1); if (copy_fpr_from_user(current, &sr->mc_fregs) || copy_transact_fpr_from_user(current, &tm_sr->mc_fregs)) return 1; #ifdef CONFIG_VSX regs->msr &= ~MSR_VSX; if (msr & MSR_VSX) { if (copy_vsx_from_user(current, &sr->mc_vsregs) || copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs)) return 1; } else if (current->thread.used_vsr) for (i = 0; i < 32 ; i++) { current->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0; current->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0; } #endif #ifdef CONFIG_SPE regs->msr &= ~MSR_SPE; if (msr & MSR_SPE) { if (__copy_from_user(current->thread.evr, &sr->mc_vregs, ELF_NEVRREG * sizeof(u32))) return 1; } else if (current->thread.used_spe) memset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32)); if (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG)) return 1; #endif tm_enable(); current->thread.tm_texasr |= TEXASR_FS; tm_recheckpoint(&current->thread, msr); <S2SV_StartVul> if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR])) <S2SV_EndVul> <S2SV_StartVul> return 1; <S2SV_EndVul> <S2SV_StartVul> regs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK); <S2SV_EndVul> if (msr & MSR_FP) { do_load_up_transact_fpu(&current->thread); regs->msr |= (MSR_FP | current->thread.fpexc_mode); } #ifdef CONFIG_ALTIVEC if (msr & MSR_VEC) { do_load_up_transact_altivec(&current->thread); regs->msr |= MSR_VEC; } #endif return 0; }","- if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
- return 1;
- regs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);
+ if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
+ return 1;
+ msr_hi <<= 32;
+ if (MSR_TM_RESV(msr_hi))
+ return 1;
+ regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);","static long restore_tm_user_regs(struct pt_regs *regs, struct mcontext __user *sr, struct mcontext __user *tm_sr) { long err; unsigned long msr, msr_hi; #ifdef CONFIG_VSX int i; #endif err = restore_general_regs(regs, tm_sr); err |= restore_general_regs(&current->thread.ckpt_regs, sr); err |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]); err |= __get_user(msr, &sr->mc_gregs[PT_MSR]); if (err) return 1; regs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE); discard_lazy_cpu_state(); #ifdef CONFIG_ALTIVEC regs->msr &= ~MSR_VEC; if (msr & MSR_VEC) { if (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs, sizeof(sr->mc_vregs)) || __copy_from_user(&current->thread.transact_vr, &tm_sr->mc_vregs, sizeof(sr->mc_vregs))) return 1; } else if (current->thread.used_vr) { memset(&current->thread.vr_state, 0, ELF_NVRREG * sizeof(vector128)); memset(&current->thread.transact_vr, 0, ELF_NVRREG * sizeof(vector128)); } if (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]) || __get_user(current->thread.transact_vrsave, (u32 __user *)&tm_sr->mc_vregs[32])) return 1; if (cpu_has_feature(CPU_FTR_ALTIVEC)) mtspr(SPRN_VRSAVE, current->thread.vrsave); #endif regs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1); if (copy_fpr_from_user(current, &sr->mc_fregs) || copy_transact_fpr_from_user(current, &tm_sr->mc_fregs)) return 1; #ifdef CONFIG_VSX regs->msr &= ~MSR_VSX; if (msr & MSR_VSX) { if (copy_vsx_from_user(current, &sr->mc_vsregs) || copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs)) return 1; } else if (current->thread.used_vsr) for (i = 0; i < 32 ; i++) { current->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0; current->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0; } #endif #ifdef CONFIG_SPE regs->msr &= ~MSR_SPE; if (msr & MSR_SPE) { if (__copy_from_user(current->thread.evr, &sr->mc_vregs, ELF_NEVRREG * sizeof(u32))) return 1; } else if (current->thread.used_spe) memset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32)); if (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG)) return 1; #endif if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR])) return 1; msr_hi <<= 32; if (MSR_TM_RESV(msr_hi)) return 1; regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK); tm_enable(); current->thread.tm_texasr |= TEXASR_FS; tm_recheckpoint(&current->thread, msr); if (msr & MSR_FP) { do_load_up_transact_fpu(&current->thread); regs->msr |= (MSR_FP | current->thread.fpexc_mode); } #ifdef CONFIG_ALTIVEC if (msr & MSR_VEC) { do_load_up_transact_altivec(&current->thread); regs->msr |= MSR_VEC; } #endif return 0; }"
619,3076----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/raw_socket.c----rawSocketSendEthPacket,"error_t rawSocketSendEthPacket(Socket *socket, const SocketMsg *message, uint_t flags) { error_t error; #if (ETH_SUPPORT == ENABLED) size_t length; NetBuffer *buffer; NetInterface *interface; <S2SV_StartVul> if(socket->interface != NULL) <S2SV_EndVul> { interface = socket->interface; } else { interface = netGetDefaultInterface(); } interface = nicGetPhysicalInterface(interface); if(interface->nicDriver != NULL && interface->nicDriver->type == NIC_TYPE_ETHERNET) { buffer = netBufferAlloc(0); if(buffer == NULL) return ERROR_OUT_OF_MEMORY; length = message->length; error = netBufferAppend(buffer, message->data, length); if(!error) { if(!interface->nicDriver->autoPadding) { if(length < (ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE)) { size_t n; n = (ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE) - length; error = netBufferAppend(buffer, ethPadding, n); length += n; } } } if(!error) { if(!interface->nicDriver->autoCrcCalc) { uint32_t crc; crc = ethCalcCrcEx(buffer, 0, length); crc = htole32(crc); error = netBufferAppend(buffer, &crc, sizeof(crc)); length += sizeof(crc); } } if(!error) { NetTxAncillary ancillary; ancillary = NET_DEFAULT_TX_ANCILLARY; #if (ETH_PORT_TAGGING_SUPPORT == ENABLED) ancillary.port = message->switchPort; #endif #if (ETH_TIMESTAMP_SUPPORT == ENABLED) ancillary.timestampId = message->timestampId; #endif TRACE_DEBUG(""Sending raw Ethernet frame (%"" PRIuSIZE "" bytes)...\r\n"", length); error = nicSendPacket(interface, buffer, 0, &ancillary); } netBufferFree(buffer); } else #endif { error = ERROR_INVALID_INTERFACE; } return error; }","- if(socket->interface != NULL)
+ if(message->interface != NULL)
+ {
+ interface = message->interface;
+ }
+ else if(socket->interface != NULL)","error_t rawSocketSendEthPacket(Socket *socket, const SocketMsg *message, uint_t flags) { error_t error; #if (ETH_SUPPORT == ENABLED) size_t length; NetBuffer *buffer; NetInterface *interface; if(message->interface != NULL) { interface = message->interface; } else if(socket->interface != NULL) { interface = socket->interface; } else { interface = netGetDefaultInterface(); } interface = nicGetPhysicalInterface(interface); if(interface->nicDriver != NULL && interface->nicDriver->type == NIC_TYPE_ETHERNET) { buffer = netBufferAlloc(0); if(buffer == NULL) return ERROR_OUT_OF_MEMORY; length = message->length; error = netBufferAppend(buffer, message->data, length); if(!error) { if(!interface->nicDriver->autoPadding) { if(length < (ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE)) { size_t n; n = (ETH_MIN_FRAME_SIZE - ETH_CRC_SIZE) - length; error = netBufferAppend(buffer, ethPadding, n); length += n; } } } if(!error) { if(!interface->nicDriver->autoCrcCalc) { uint32_t crc; crc = ethCalcCrcEx(buffer, 0, length); crc = htole32(crc); error = netBufferAppend(buffer, &crc, sizeof(crc)); length += sizeof(crc); } } if(!error) { NetTxAncillary ancillary; ancillary = NET_DEFAULT_TX_ANCILLARY; #if (ETH_PORT_TAGGING_SUPPORT == ENABLED) ancillary.port = message->switchPort; #endif #if (ETH_TIMESTAMP_SUPPORT == ENABLED) ancillary.timestampId = message->timestampId; #endif TRACE_DEBUG(""Sending raw Ethernet frame (%"" PRIuSIZE "" bytes)...\r\n"", length); error = nicSendPacket(interface, buffer, 0, &ancillary); } netBufferFree(buffer); } else #endif { error = ERROR_INVALID_INTERFACE; } return error; }"
620,1887----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-1999013--rmdec.c----rm_read_multi,"static int rm_read_multi(AVFormatContext *s, AVIOContext *pb, AVStream *st, char *mime) { int number_of_streams = avio_rb16(pb); int number_of_mdpr; int i, ret; unsigned size2; for (i = 0; i<number_of_streams; i++) avio_rb16(pb); number_of_mdpr = avio_rb16(pb); if (number_of_mdpr != 1) { avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr); } for (i = 0; i < number_of_mdpr; i++) { AVStream *st2; if (i > 0) { st2 = avformat_new_stream(s, NULL); if (!st2) { ret = AVERROR(ENOMEM); return ret; } st2->id = st->id + (i<<16); st2->codecpar->bit_rate = st->codecpar->bit_rate; st2->start_time = st->start_time; st2->duration = st->duration; st2->codecpar->codec_type = AVMEDIA_TYPE_DATA; st2->priv_data = ff_rm_alloc_rmstream(); if (!st2->priv_data) return AVERROR(ENOMEM); } else st2 = st; size2 = avio_rb32(pb); ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data, <S2SV_StartVul> size2, mime); <S2SV_EndVul> if (ret < 0) return ret; } return 0; }","- size2, mime);
+ size2, NULL);","static int rm_read_multi(AVFormatContext *s, AVIOContext *pb, AVStream *st, char *mime) { int number_of_streams = avio_rb16(pb); int number_of_mdpr; int i, ret; unsigned size2; for (i = 0; i<number_of_streams; i++) avio_rb16(pb); number_of_mdpr = avio_rb16(pb); if (number_of_mdpr != 1) { avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr); } for (i = 0; i < number_of_mdpr; i++) { AVStream *st2; if (i > 0) { st2 = avformat_new_stream(s, NULL); if (!st2) { ret = AVERROR(ENOMEM); return ret; } st2->id = st->id + (i<<16); st2->codecpar->bit_rate = st->codecpar->bit_rate; st2->start_time = st->start_time; st2->duration = st->duration; st2->codecpar->codec_type = AVMEDIA_TYPE_DATA; st2->priv_data = ff_rm_alloc_rmstream(); if (!st2->priv_data) return AVERROR(ENOMEM); } else st2 = st; size2 = avio_rb32(pb); ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data, size2, NULL); if (ret < 0) return ret; } return 0; }"
621,1994----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-14015--dwarf.c----*r_bin_dwarf_parse_comp_unit,"static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf, RBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da, size_t offset, const ut8 *debug_str, size_t debug_str_len) { const ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7); ut64 abbr_code; size_t i; if (cu->hdr.length > debug_str_len) { return NULL; } while (buf && buf < buf_end && buf >= obuf) { if (cu->length && cu->capacity == cu->length) { r_bin_dwarf_expand_cu (cu); } buf = r_uleb128 (buf, buf_end - buf, &abbr_code); if (abbr_code > da->length || !buf) { return NULL; } r_bin_dwarf_init_die (&cu->dies[cu->length]); if (!abbr_code) { cu->dies[cu->length].abbrev_code = 0; cu->length++; buf++; continue; } cu->dies[cu->length].abbrev_code = abbr_code; cu->dies[cu->length].tag = da->decls[abbr_code - 1].tag; abbr_code += offset; if (da->capacity < abbr_code) { return NULL; } for (i = 0; i < da->decls[abbr_code - 1].length; i++) { if (cu->dies[cu->length].length == cu->dies[cu->length].capacity) { r_bin_dwarf_expand_die (&cu->dies[cu->length]); } if (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) { eprintf (""Warning: malformed dwarf attribute capacity doesn't match length\n""); break; } memset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i])); buf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf, &da->decls[abbr_code - 1].specs[i], &cu->dies[cu->length].attr_values[i], &cu->hdr, debug_str, debug_str_len); if (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) { const char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string; sdb_set (s, ""DW_AT_comp_dir"", name, 0); <S2SV_StartVul> } <S2SV_EndVul> cu->dies[cu->length].length++; } cu->length++; } return buf; }","- }
+ sdb_set (s, ""DW_AT_comp_dir"", name, 0);
+ } else {
+ eprintf (""Invalid string pointer at %p\n"", name);
+ }
+ }","static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf, RBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da, size_t offset, const ut8 *debug_str, size_t debug_str_len) { const ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7); ut64 abbr_code; size_t i; if (cu->hdr.length > debug_str_len) { return NULL; } while (buf && buf < buf_end && buf >= obuf) { if (cu->length && cu->capacity == cu->length) { r_bin_dwarf_expand_cu (cu); } buf = r_uleb128 (buf, buf_end - buf, &abbr_code); if (abbr_code > da->length || !buf) { return NULL; } r_bin_dwarf_init_die (&cu->dies[cu->length]); if (!abbr_code) { cu->dies[cu->length].abbrev_code = 0; cu->length++; buf++; continue; } cu->dies[cu->length].abbrev_code = abbr_code; cu->dies[cu->length].tag = da->decls[abbr_code - 1].tag; abbr_code += offset; if (da->capacity < abbr_code) { return NULL; } for (i = 0; i < da->decls[abbr_code - 1].length; i++) { if (cu->dies[cu->length].length == cu->dies[cu->length].capacity) { r_bin_dwarf_expand_die (&cu->dies[cu->length]); } if (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) { eprintf (""Warning: malformed dwarf attribute capacity doesn't match length\n""); break; } memset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i])); buf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf, &da->decls[abbr_code - 1].specs[i], &cu->dies[cu->length].attr_values[i], &cu->hdr, debug_str, debug_str_len); if (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) { const char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string; if (name > 1024) { sdb_set (s, ""DW_AT_comp_dir"", name, 0); } else { eprintf (""Invalid string pointer at %p\n"", name); } } cu->dies[cu->length].length++; } cu->length++; } return buf; }"
622,919----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9756--emulate.c----em_jmp_far,"static int em_jmp_far(struct x86_emulate_ctxt *ctxt) { int rc; <S2SV_StartVul> unsigned short sel, old_sel; <S2SV_EndVul> <S2SV_StartVul> struct desc_struct old_desc, new_desc; <S2SV_EndVul> <S2SV_StartVul> const struct x86_emulate_ops *ops = ctxt->ops; <S2SV_EndVul> u8 cpl = ctxt->ops->cpl(ctxt); <S2SV_StartVul> if (ctxt->mode == X86EMUL_MODE_PROT64) <S2SV_EndVul> <S2SV_StartVul> ops->get_segment(ctxt, &old_sel, &old_desc, NULL, <S2SV_EndVul> <S2SV_StartVul> VCPU_SREG_CS); <S2SV_EndVul> memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2); rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, X86_TRANSFER_CALL_JMP, &new_desc); if (rc != X86EMUL_CONTINUE) return rc; rc = assign_eip_far(ctxt, ctxt->src.val, &new_desc); if (rc != X86EMUL_CONTINUE) { <S2SV_StartVul> WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64); <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> ops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS); <S2SV_StartVul> return rc; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return rc; <S2SV_EndVul> }","- unsigned short sel, old_sel;
- struct desc_struct old_desc, new_desc;
- const struct x86_emulate_ops *ops = ctxt->ops;
- if (ctxt->mode == X86EMUL_MODE_PROT64)
- ops->get_segment(ctxt, &old_sel, &old_desc, NULL,
- VCPU_SREG_CS);
- WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);
- return rc;
- }
- return rc;
+ unsigned short sel;
+ struct desc_struct new_desc;
+ if (rc != X86EMUL_CONTINUE)
+ return X86EMUL_UNHANDLEABLE;","static int em_jmp_far(struct x86_emulate_ctxt *ctxt) { int rc; unsigned short sel; struct desc_struct new_desc; u8 cpl = ctxt->ops->cpl(ctxt); memcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2); rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, X86_TRANSFER_CALL_JMP, &new_desc); if (rc != X86EMUL_CONTINUE) return rc; rc = assign_eip_far(ctxt, ctxt->src.val, &new_desc); if (rc != X86EMUL_CONTINUE) return X86EMUL_UNHANDLEABLE; return rc; }"
623,6535----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event.c----x86_pmu_handle_irq,"static int x86_pmu_handle_irq(struct pt_regs *regs) { struct perf_sample_data data; struct cpu_hw_events *cpuc; struct perf_event *event; int idx, handled = 0; u64 val; perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); apic_write(APIC_LVTPC, APIC_DM_NMI); for (idx = 0; idx < x86_pmu.num_counters; idx++) { if (!test_bit(idx, cpuc->active_mask)) { if (__test_and_clear_bit(idx, cpuc->running)) handled++; continue; } event = cpuc->events[idx]; val = x86_perf_event_update(event); if (val & (1ULL << (x86_pmu.cntval_bits - 1))) continue; handled++; data.period = event->hw.last_period; if (!x86_perf_event_set_period(event)) continue; <S2SV_StartVul> if (perf_event_overflow(event, 1, &data, regs)) <S2SV_EndVul> x86_pmu_stop(event, 0); } if (handled) inc_irq_stat(apic_perf_irqs); return handled; }","- if (perf_event_overflow(event, 1, &data, regs))
+ if (perf_event_overflow(event, &data, regs))","static int x86_pmu_handle_irq(struct pt_regs *regs) { struct perf_sample_data data; struct cpu_hw_events *cpuc; struct perf_event *event; int idx, handled = 0; u64 val; perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); apic_write(APIC_LVTPC, APIC_DM_NMI); for (idx = 0; idx < x86_pmu.num_counters; idx++) { if (!test_bit(idx, cpuc->active_mask)) { if (__test_and_clear_bit(idx, cpuc->running)) handled++; continue; } event = cpuc->events[idx]; val = x86_perf_event_update(event); if (val & (1ULL << (x86_pmu.cntval_bits - 1))) continue; handled++; data.period = event->hw.last_period; if (!x86_perf_event_set_period(event)) continue; if (perf_event_overflow(event, &data, regs)) x86_pmu_stop(event, 0); } if (handled) inc_irq_stat(apic_perf_irqs); return handled; }"
624,4312----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiEval.c----jsi_evalcode,"Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, jsi_ScopeChain *scope, Jsi_Value *fargs, Jsi_Value *_this, Jsi_Value **vret) { Jsi_Interp *interp = ps->interp; if (interp->exited) return JSI_ERROR; Jsi_RC rc; jsi_Frame frame = *interp->framePtr; frame.parent = interp->framePtr; interp->framePtr = &frame; frame.parent->child = interp->framePtr = &frame; frame.ps = ps; frame.ingsc = scope; frame.incsc = fargs; frame.inthis = _this; frame.opcodes = opcodes; frame.fileName = ((func && func->script)?func->script:interp->curFile); frame.funcName = interp->curFunction; frame.dirName = interp->curDir; if (frame.fileName && frame.fileName == frame.parent->fileName) frame.logflag = frame.parent->logflag; else frame.logflag = 0; frame.level = frame.parent->level+1; frame.evalFuncPtr = func; frame.arguments = NULL; if (interp->curIp) frame.parent->line = interp->curIp->Line; frame.ip = interp->curIp; interp->refCount++; interp->level++; Jsi_IncrRefCount(interp, fargs); rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret); Jsi_DecrRefCount(interp, fargs); <S2SV_StartVul> if (interp->didReturn == 0 && !interp->exited) { <S2SV_EndVul> if ((interp->evalFlags&JSI_EVAL_RETURN)==0) Jsi_ValueMakeUndef(interp, vret); } if (frame.arguments) Jsi_DecrRefCount(interp, frame.arguments); interp->didReturn = 0; interp->refCount--; interp->level--; interp->framePtr = frame.parent; interp->framePtr->child = NULL; interp->curIp = frame.ip; if (interp->exited) rc = JSI_ERROR; return rc; }","- if (interp->didReturn == 0 && !interp->exited) {
+ if (interp->didReturn == 0 && !interp->exited && rc == JSI_OK) {","Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, jsi_ScopeChain *scope, Jsi_Value *fargs, Jsi_Value *_this, Jsi_Value **vret) { Jsi_Interp *interp = ps->interp; if (interp->exited) return JSI_ERROR; Jsi_RC rc; jsi_Frame frame = *interp->framePtr; frame.parent = interp->framePtr; interp->framePtr = &frame; frame.parent->child = interp->framePtr = &frame; frame.ps = ps; frame.ingsc = scope; frame.incsc = fargs; frame.inthis = _this; frame.opcodes = opcodes; frame.fileName = ((func && func->script)?func->script:interp->curFile); frame.funcName = interp->curFunction; frame.dirName = interp->curDir; if (frame.fileName && frame.fileName == frame.parent->fileName) frame.logflag = frame.parent->logflag; else frame.logflag = 0; frame.level = frame.parent->level+1; frame.evalFuncPtr = func; frame.arguments = NULL; if (interp->curIp) frame.parent->line = interp->curIp->Line; frame.ip = interp->curIp; interp->refCount++; interp->level++; Jsi_IncrRefCount(interp, fargs); rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret); Jsi_DecrRefCount(interp, fargs); if (interp->didReturn == 0 && !interp->exited && rc == JSI_OK) { if ((interp->evalFlags&JSI_EVAL_RETURN)==0) Jsi_ValueMakeUndef(interp, vret); } if (frame.arguments) Jsi_DecrRefCount(interp, frame.arguments); interp->didReturn = 0; interp->refCount--; interp->level--; interp->framePtr = frame.parent; interp->framePtr->child = NULL; interp->curIp = frame.ip; if (interp->exited) rc = JSI_ERROR; return rc; }"
625,6756----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hugetlb.c----free_huge_page,"static void free_huge_page(struct page *page) { struct hstate *h = page_hstate(page); int nid = page_to_nid(page); <S2SV_StartVul> struct address_space *mapping; <S2SV_EndVul> <S2SV_StartVul> mapping = (struct address_space *) page_private(page); <S2SV_EndVul> set_page_private(page, 0); page->mapping = NULL; BUG_ON(page_count(page)); BUG_ON(page_mapcount(page)); INIT_LIST_HEAD(&page->lru); spin_lock(&hugetlb_lock); if (h->surplus_huge_pages_node[nid] && huge_page_order(h) < MAX_ORDER) { update_and_free_page(h, page); h->surplus_huge_pages--; h->surplus_huge_pages_node[nid]--; } else { enqueue_huge_page(h, page); } spin_unlock(&hugetlb_lock); <S2SV_StartVul> if (mapping) <S2SV_EndVul> <S2SV_StartVul> hugetlb_put_quota(mapping, 1); <S2SV_EndVul> }","- struct address_space *mapping;
- mapping = (struct address_space *) page_private(page);
- if (mapping)
- hugetlb_put_quota(mapping, 1);
+ struct hugepage_subpool *spool =
+ (struct hugepage_subpool *)page_private(page);
+ hugepage_subpool_put_pages(spool, 1);","static void free_huge_page(struct page *page) { struct hstate *h = page_hstate(page); int nid = page_to_nid(page); struct hugepage_subpool *spool = (struct hugepage_subpool *)page_private(page); set_page_private(page, 0); page->mapping = NULL; BUG_ON(page_count(page)); BUG_ON(page_mapcount(page)); INIT_LIST_HEAD(&page->lru); spin_lock(&hugetlb_lock); if (h->surplus_huge_pages_node[nid] && huge_page_order(h) < MAX_ORDER) { update_and_free_page(h, page); h->surplus_huge_pages--; h->surplus_huge_pages_node[nid]--; } else { enqueue_huge_page(h, page); } spin_unlock(&hugetlb_lock); hugepage_subpool_put_pages(spool, 1); }"
626,3634----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/redis.c----processCommand,"int processCommand(redisClient *c) { struct redisCommand *cmd; if (!strcasecmp(c->argv[0]->ptr,""quit"")) { addReply(c,shared.ok); c->flags |= REDIS_CLOSE_AFTER_REPLY; return REDIS_ERR; } cmd = lookupCommand(c->argv[0]->ptr); if (!cmd) { addReplyErrorFormat(c,""unknown command '%s'"", (char*)c->argv[0]->ptr); return REDIS_OK; } else if ((cmd->arity > 0 && cmd->arity != c->argc) || (c->argc < -cmd->arity)) { addReplyErrorFormat(c,""wrong number of arguments for '%s' command"", cmd->name); return REDIS_OK; } if (server.requirepass && !c->authenticated && cmd->proc != authCommand) { addReplyError(c,""operation not permitted""); return REDIS_OK; } if (server.maxmemory) freeMemoryIfNeeded(); if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) && zmalloc_used_memory() > server.maxmemory) { addReplyError(c,""command not allowed when used memory > 'maxmemory'""); return REDIS_OK; } if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0) && cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand && cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) { addReplyError(c,""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context""); return REDIS_OK; } if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED && server.repl_serve_stale_data == 0 && cmd->proc != infoCommand && cmd->proc != slaveofCommand) { addReplyError(c, ""link with MASTER is down and slave-serve-stale-data is set to no""); return REDIS_OK; } if (server.loading && cmd->proc != infoCommand) { addReply(c, shared.loadingerr); return REDIS_OK; } if (c->flags & REDIS_MULTI && cmd->proc != execCommand && cmd->proc != discardCommand && cmd->proc != multiCommand && cmd->proc != watchCommand) { queueMultiCommand(c,cmd); addReply(c,shared.queued); } else { <S2SV_StartVul> if (server.vm_enabled && server.vm_max_threads > 0 && <S2SV_EndVul> <S2SV_StartVul> blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR; <S2SV_EndVul> call(c,cmd); } return REDIS_OK; }","- if (server.vm_enabled && server.vm_max_threads > 0 &&
- blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR;
+ if (server.ds_enabled && blockClientOnSwappedKeys(c,cmd))
+ return REDIS_ERR;","int processCommand(redisClient *c) { struct redisCommand *cmd; if (!strcasecmp(c->argv[0]->ptr,""quit"")) { addReply(c,shared.ok); c->flags |= REDIS_CLOSE_AFTER_REPLY; return REDIS_ERR; } cmd = lookupCommand(c->argv[0]->ptr); if (!cmd) { addReplyErrorFormat(c,""unknown command '%s'"", (char*)c->argv[0]->ptr); return REDIS_OK; } else if ((cmd->arity > 0 && cmd->arity != c->argc) || (c->argc < -cmd->arity)) { addReplyErrorFormat(c,""wrong number of arguments for '%s' command"", cmd->name); return REDIS_OK; } if (server.requirepass && !c->authenticated && cmd->proc != authCommand) { addReplyError(c,""operation not permitted""); return REDIS_OK; } if (server.maxmemory) freeMemoryIfNeeded(); if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) && zmalloc_used_memory() > server.maxmemory) { addReplyError(c,""command not allowed when used memory > 'maxmemory'""); return REDIS_OK; } if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0) && cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand && cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) { addReplyError(c,""only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context""); return REDIS_OK; } if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED && server.repl_serve_stale_data == 0 && cmd->proc != infoCommand && cmd->proc != slaveofCommand) { addReplyError(c, ""link with MASTER is down and slave-serve-stale-data is set to no""); return REDIS_OK; } if (server.loading && cmd->proc != infoCommand) { addReply(c, shared.loadingerr); return REDIS_OK; } if (c->flags & REDIS_MULTI && cmd->proc != execCommand && cmd->proc != discardCommand && cmd->proc != multiCommand && cmd->proc != watchCommand) { queueMultiCommand(c,cmd); addReply(c,shared.queued); } else { if (server.ds_enabled && blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR; call(c,cmd); } return REDIS_OK; }"
627,7306----CWE-326----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/output_core.c----__ipv6_select_ident,"<S2SV_StartVul> static u32 __ipv6_select_ident(struct net *net, u32 hashrnd, <S2SV_EndVul> const struct in6_addr *dst, const struct in6_addr *src) { u32 hash, id; <S2SV_StartVul> hash = __ipv6_addr_jhash(dst, hashrnd); <S2SV_EndVul> <S2SV_StartVul> hash = __ipv6_addr_jhash(src, hash); <S2SV_EndVul> <S2SV_StartVul> hash ^= net_hash_mix(net); <S2SV_EndVul> id = ip_idents_reserve(hash, 1); if (unlikely(!id)) id = 1 << 31; return id; }","- static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,
- hash = __ipv6_addr_jhash(dst, hashrnd);
- hash = __ipv6_addr_jhash(src, hash);
- hash ^= net_hash_mix(net);
+ static u32 __ipv6_select_ident(struct net *net,
+ const struct {
+ struct in6_addr dst;
+ struct in6_addr src;
+ } __aligned(SIPHASH_ALIGNMENT) combined = {
+ .dst = *dst,
+ .src = *src,
+ };
+ if (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))
+ get_random_bytes(&net->ipv4.ip_id_key,
+ sizeof(net->ipv4.ip_id_key));
+ hash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);","static u32 __ipv6_select_ident(struct net *net, const struct in6_addr *dst, const struct in6_addr *src) { const struct { struct in6_addr dst; struct in6_addr src; } __aligned(SIPHASH_ALIGNMENT) combined = { .dst = *dst, .src = *src, }; u32 hash, id; if (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key))) get_random_bytes(&net->ipv4.ip_id_key, sizeof(net->ipv4.ip_id_key)); hash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key); id = ip_idents_reserve(hash, 1); if (unlikely(!id)) id = 1 << 31; return id; }"
628,3446----CWE-129----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/packets.cpp----AOClient::pktEditEvidence,"void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet) { if (!checkEvidenceAccess(area)) return; bool is_int = false; int idx = argv[0].toInt(&is_int); AreaData::Evidence evi = {argv[1], argv[2], argv[3]}; <S2SV_StartVul> if (is_int && idx <= area->evidence().size() && idx >= 0) { <S2SV_EndVul> area->replaceEvidence(idx, evi); } sendEvidenceList(area); }","- if (is_int && idx <= area->evidence().size() && idx >= 0) {
+ if (is_int && idx < area->evidence().size() && idx >= 0) {","void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet) { if (!checkEvidenceAccess(area)) return; bool is_int = false; int idx = argv[0].toInt(&is_int); AreaData::Evidence evi = {argv[1], argv[2], argv[3]}; if (is_int && idx < area->evidence().size() && idx >= 0) { area->replaceEvidence(idx, evi); } sendEvidenceList(area); }"
629,7406----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/x_tables.c----xt_compat_check_entry_offsets,"<S2SV_StartVul> int xt_compat_check_entry_offsets(const void *base, <S2SV_EndVul> unsigned int target_offset, unsigned int next_offset) { const struct compat_xt_entry_target *t; const char *e = base; if (target_offset + sizeof(*t) > next_offset) return -EINVAL; t = (void *)(e + target_offset); if (t->u.target_size < sizeof(*t)) return -EINVAL; if (target_offset + t->u.target_size > next_offset) return -EINVAL; if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 && target_offset + sizeof(struct compat_xt_standard_target) != next_offset) return -EINVAL; return 0; }","- int xt_compat_check_entry_offsets(const void *base,
+ int xt_compat_check_entry_offsets(const void *base, const char *elems,
+ long size_of_base_struct = elems - (const char *)base;
+ if (target_offset < size_of_base_struct)
+ return -EINVAL;","int xt_compat_check_entry_offsets(const void *base, const char *elems, unsigned int target_offset, unsigned int next_offset) { long size_of_base_struct = elems - (const char *)base; const struct compat_xt_entry_target *t; const char *e = base; if (target_offset < size_of_base_struct) return -EINVAL; if (target_offset + sizeof(*t) > next_offset) return -EINVAL; t = (void *)(e + target_offset); if (t->u.target_size < sizeof(*t)) return -EINVAL; if (target_offset + t->u.target_size > next_offset) return -EINVAL; if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 && target_offset + sizeof(struct compat_xt_standard_target) != next_offset) return -EINVAL; return 0; }"
630,2258----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-14763--gadget.c----__dwc3_gadget_kick_transfer,"static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep) { struct dwc3_gadget_ep_cmd_params params; struct dwc3_request *req; int starting; int ret; u32 cmd; if (!dwc3_calc_trbs_left(dep)) return 0; starting = !(dep->flags & DWC3_EP_BUSY); dwc3_prepare_trbs(dep); req = next_request(&dep->started_list); if (!req) { dep->flags |= DWC3_EP_PENDING_REQUEST; return 0; } memset(&params, 0, sizeof(params)); if (starting) { params.param0 = upper_32_bits(req->trb_dma); params.param1 = lower_32_bits(req->trb_dma); cmd = DWC3_DEPCMD_STARTTRANSFER; if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) cmd |= DWC3_DEPCMD_PARAM(dep->frame_number); } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM(dep->resource_index); } ret = dwc3_send_gadget_ep_cmd(dep, cmd, &params); if (ret < 0) { if (req->trb) memset(req->trb, 0, sizeof(struct dwc3_trb)); dep->queued_requests--; <S2SV_StartVul> dwc3_gadget_giveback(dep, req, ret); <S2SV_EndVul> return ret; } dep->flags |= DWC3_EP_BUSY; if (starting) { dep->resource_index = dwc3_gadget_ep_get_transfer_index(dep); WARN_ON_ONCE(!dep->resource_index); } return 0; }","- dwc3_gadget_giveback(dep, req, ret);
+ dwc3_gadget_del_and_unmap_request(dep, req, ret);","static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep) { struct dwc3_gadget_ep_cmd_params params; struct dwc3_request *req; int starting; int ret; u32 cmd; if (!dwc3_calc_trbs_left(dep)) return 0; starting = !(dep->flags & DWC3_EP_BUSY); dwc3_prepare_trbs(dep); req = next_request(&dep->started_list); if (!req) { dep->flags |= DWC3_EP_PENDING_REQUEST; return 0; } memset(&params, 0, sizeof(params)); if (starting) { params.param0 = upper_32_bits(req->trb_dma); params.param1 = lower_32_bits(req->trb_dma); cmd = DWC3_DEPCMD_STARTTRANSFER; if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) cmd |= DWC3_DEPCMD_PARAM(dep->frame_number); } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM(dep->resource_index); } ret = dwc3_send_gadget_ep_cmd(dep, cmd, &params); if (ret < 0) { if (req->trb) memset(req->trb, 0, sizeof(struct dwc3_trb)); dep->queued_requests--; dwc3_gadget_del_and_unmap_request(dep, req, ret); return ret; } dep->flags |= DWC3_EP_BUSY; if (starting) { dep->resource_index = dwc3_gadget_ep_get_transfer_index(dep); WARN_ON_ONCE(!dep->resource_index); } return 0; }"
631,2857----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/common.c----header_put_be_short,"header_put_be_short (SF_PRIVATE *psf, int x) <S2SV_StartVul> { if (psf->headindex < SIGNED_SIZEOF (psf->header) - 2) <S2SV_EndVul> <S2SV_StartVul> { psf->header [psf->headindex++] = (x >> 8) ; <S2SV_EndVul> <S2SV_StartVul> psf->header [psf->headindex++] = x ; <S2SV_EndVul> <S2SV_StartVul> } ; <S2SV_EndVul> }","- { if (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)
- { psf->header [psf->headindex++] = (x >> 8) ;
- psf->header [psf->headindex++] = x ;
- } ;
+ { psf->header.ptr [psf->header.indx++] = (x >> 8) ;
+ psf->header.ptr [psf->header.indx++] = x ;","header_put_be_short (SF_PRIVATE *psf, int x) { psf->header.ptr [psf->header.indx++] = (x >> 8) ; psf->header.ptr [psf->header.indx++] = x ; }"
632,1421----CWE-772----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-12664--palm.c----WritePALMImage,"static MagickBooleanType WritePALMImage(const ImageInfo *image_info, Image *image) { ExceptionInfo *exception; MagickBooleanType status; MagickOffsetType currentOffset, offset, scene; MagickSizeType cc; PixelPacket transpix; QuantizeInfo *quantize_info; register IndexPacket *indexes; register ssize_t x; register PixelPacket *p; ssize_t y; size_t count, bits_per_pixel, bytes_per_row, nextDepthOffset, one; unsigned char bit, byte, color, *lastrow, *one_row, *ptr, version; unsigned int transparentIndex; unsigned short color16, flags; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); exception=AcquireExceptionInfo(); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); quantize_info=AcquireQuantizeInfo(image_info); flags=0; currentOffset=0; transparentIndex=0; transpix.red=0; transpix.green=0; transpix.blue=0; transpix.opacity=0; one=1; version=0; scene=0; do { (void) TransformImageColorspace(image,sRGBColorspace); count=GetNumberColors(image,NULL,exception); for (bits_per_pixel=1; (one << bits_per_pixel) < count; bits_per_pixel*=2) ; if (bits_per_pixel > 16) bits_per_pixel=16; else if (bits_per_pixel < 16) (void) TransformImageColorspace(image,image->colorspace); if (bits_per_pixel < 8) { (void) TransformImageColorspace(image,GRAYColorspace); (void) SetImageType(image,PaletteType); (void) SortColormapByIntensity(image); } if ((image->storage_class == PseudoClass) && (image->colors > 256)) (void) SetImageStorageClass(image,DirectClass); if (image->storage_class == PseudoClass) flags|=PALM_HAS_COLORMAP_FLAG; else flags|=PALM_IS_DIRECT_COLOR; (void) WriteBlobMSBShort(image,(unsigned short) image->columns); (void) WriteBlobMSBShort(image,(unsigned short) image->rows); bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/ bits_per_pixel))*2; (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row); if ((image_info->compression == RLECompression) || (image_info->compression == FaxCompression)) flags|=PALM_IS_COMPRESSED_FLAG; (void) WriteBlobMSBShort(image, flags); (void) WriteBlobByte(image,(unsigned char) bits_per_pixel); if (bits_per_pixel > 1) <S2SV_StartVul> version=1; <S2SV_EndVul> if ((image_info->compression == RLECompression) || (image_info->compression == FaxCompression)) version=2; (void) WriteBlobByte(image,version); (void) WriteBlobMSBShort(image,0); (void) WriteBlobByte(image,(unsigned char) transparentIndex); if (image_info->compression == RLECompression) (void) WriteBlobByte(image,PALM_COMPRESSION_RLE); else if (image_info->compression == FaxCompression) (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE); else (void) WriteBlobByte(image,PALM_COMPRESSION_NONE); (void) WriteBlobMSBShort(image,0); offset=16; if (bits_per_pixel == 16) { (void) WriteBlobByte(image,5); (void) WriteBlobByte(image,6); (void) WriteBlobByte(image,5); (void) WriteBlobByte(image,0); (void) WriteBlobMSBLong(image,0); offset+=8; } if (bits_per_pixel == 8) { if (flags & PALM_HAS_COLORMAP_FLAG) { quantize_info->dither=IsPaletteImage(image,&image->exception); quantize_info->number_colors=image->colors; (void) QuantizeImage(quantize_info,image); (void) WriteBlobMSBShort(image,(unsigned short) image->colors); for (count = 0; count < image->colors; count++) { (void) WriteBlobByte(image,(unsigned char) count); (void) WriteBlobByte(image,ScaleQuantumToChar( image->colormap[count].red)); (void) WriteBlobByte(image, ScaleQuantumToChar(image->colormap[count].green)); (void) WriteBlobByte(image, ScaleQuantumToChar(image->colormap[count].blue)); } offset+=2+count*4; } else { Image *affinity_image; affinity_image=ConstituteImage(256,1,""RGB"",CharPixel,&PalmPalette, exception); (void) TransformImageColorspace(affinity_image, affinity_image->colorspace); (void) RemapImage(quantize_info,image,affinity_image); for (y=0; y < (ssize_t) image->rows; y++) { p=GetAuthenticPixels(image,0,y,image->columns,1,exception); indexes=GetAuthenticIndexQueue(image); for (x=0; x < (ssize_t) image->columns; x++) SetPixelIndex(indexes+x,FindColor(&image->colormap[ (ssize_t) GetPixelIndex(indexes+x)])); } affinity_image=DestroyImage(affinity_image); } } if (flags & PALM_IS_COMPRESSED_FLAG) (void) WriteBlobMSBShort(image,0); lastrow=(unsigned char *) NULL; if (image_info->compression == FaxCompression) lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row, sizeof(*lastrow)); one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row, sizeof(*one_row)); if (one_row == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); for (y=0; y < (ssize_t) image->rows; y++) { ptr=one_row; (void) ResetMagickMemory(ptr,0,bytes_per_row); p=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (p == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(image); if (bits_per_pixel == 16) { for (x=0; x < (ssize_t) image->columns; x++) { color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/ (size_t) QuantumRange) << 11) | (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) | ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange)); if (GetPixelOpacity(p) == (Quantum) TransparentOpacity) { transpix.red=GetPixelRed(p); transpix.green=GetPixelGreen(p); transpix.blue=GetPixelBlue(p); transpix.opacity=GetPixelOpacity(p); flags|=PALM_HAS_TRANSPARENCY_FLAG; } *ptr++=(unsigned char) ((color16 >> 8) & 0xff); *ptr++=(unsigned char) (color16 & 0xff); p++; } } else { byte=0x00; bit=(unsigned char) (8-bits_per_pixel); for (x=0; x < (ssize_t) image->columns; x++) { if (bits_per_pixel >= 8) color=(unsigned char) GetPixelIndex(indexes+x); else color=(unsigned char) (GetPixelIndex(indexes+x)* ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1)); byte|=color << bit; if (bit != 0) bit-=(unsigned char) bits_per_pixel; else { *ptr++=byte; byte=0x00; bit=(unsigned char) (8-bits_per_pixel); } } if ((image->columns % (8/bits_per_pixel)) != 0) *ptr++=byte; } if (image_info->compression == RLECompression) { x=0; while (x < (ssize_t) bytes_per_row) { byte=one_row[x]; <S2SV_StartVul> count=1; <S2SV_EndVul> while ((one_row[++x] == byte) && (count < 255) && (x < (ssize_t) bytes_per_row)) <S2SV_StartVul> count++; <S2SV_EndVul> <S2SV_StartVul> (void) WriteBlobByte(image,(unsigned char) count); <S2SV_EndVul> <S2SV_StartVul> (void) WriteBlobByte(image,(unsigned char) byte); <S2SV_EndVul> } } else if (image_info->compression == FaxCompression) { char tmpbuf[8], *tptr; for (x = 0; x < (ssize_t) bytes_per_row; x += 8) { tptr = tmpbuf; for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++) { if ((y == 0) || (lastrow[x + bit] != one_row[x + bit])) { byte |= (1 << (7 - bit)); *tptr++ = (char) one_row[x + bit]; } } (void) WriteBlobByte(image, byte); (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf); } (void) CopyMagickMemory(lastrow,one_row,bytes_per_row); } else (void) WriteBlob(image,bytes_per_row,one_row); } if (flags & PALM_HAS_TRANSPARENCY_FLAG) { offset=SeekBlob(image,currentOffset+6,SEEK_SET); (void) WriteBlobMSBShort(image,flags); offset=SeekBlob(image,currentOffset+12,SEEK_SET); (void) WriteBlobByte(image,(unsigned char) transparentIndex); } if (bits_per_pixel == 16) { offset=SeekBlob(image,currentOffset+20,SEEK_SET); (void) WriteBlobByte(image,0); (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange)); (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange)); (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange)); } if (flags & PALM_IS_COMPRESSED_FLAG) { offset=SeekBlob(image,currentOffset+offset,SEEK_SET); (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)- currentOffset-offset)); } if (one_row != (unsigned char *) NULL) <S2SV_StartVul> one_row=(unsigned char *) RelinquishMagickMemory(one_row); <S2SV_EndVul> if (lastrow != (unsigned char *) NULL) lastrow=(unsigned char *) RelinquishMagickMemory(lastrow); <S2SV_StartVul> if (GetNextImageInList(image) == (Image *) NULL) <S2SV_EndVul> break; for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--) (void) WriteBlobByte(image,0); (void) SeekBlob(image,currentOffset+10,SEEK_SET); nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4); (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset); currentOffset=(MagickOffsetType) GetBlobSize(image); (void) SeekBlob(image,currentOffset,SEEK_SET); image=SyncNextImageInList(image); status=SetImageProgress(image,SaveImagesTag,scene++, GetImageListLength(image)); <S2SV_StartVul> if (status == MagickFalse) <S2SV_EndVul> break; } while (image_info->adjoin != MagickFalse); quantize_info=DestroyQuantizeInfo(quantize_info); (void) CloseBlob(image); (void) DestroyExceptionInfo(exception); return(MagickTrue); }","- version=1;
- count=1;
- count++;
- (void) WriteBlobByte(image,(unsigned char) count);
- (void) WriteBlobByte(image,(unsigned char) byte);
- one_row=(unsigned char *) RelinquishMagickMemory(one_row);
- if (GetNextImageInList(image) == (Image *) NULL)
- if (status == MagickFalse)
+ (void) WriteBlobByte(image,version);
+ {
+ {
+ byte=one_row[x];
+ count=1;
+ }
+ offset=SeekBlob(image,currentOffset+offset,SEEK_SET);
+ (void) SeekBlob(image,currentOffset+10,SEEK_SET);","static MagickBooleanType WritePALMImage(const ImageInfo *image_info, Image *image) { ExceptionInfo *exception; MagickBooleanType status; MagickOffsetType currentOffset, offset, scene; MagickSizeType cc; PixelPacket transpix; QuantizeInfo *quantize_info; register IndexPacket *indexes; register ssize_t x; register PixelPacket *p; ssize_t y; size_t count, bits_per_pixel, bytes_per_row, nextDepthOffset, one; unsigned char bit, byte, color, *last_row, *one_row, *ptr, version; unsigned int transparentIndex; unsigned short color16, flags; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); exception=AcquireExceptionInfo(); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); quantize_info=AcquireQuantizeInfo(image_info); flags=0; currentOffset=0; transparentIndex=0; transpix.red=0; transpix.green=0; transpix.blue=0; transpix.opacity=0; one=1; version=0; scene=0; do { (void) TransformImageColorspace(image,sRGBColorspace); count=GetNumberColors(image,NULL,exception); for (bits_per_pixel=1; (one << bits_per_pixel) < count; bits_per_pixel*=2) ; if (bits_per_pixel > 16) bits_per_pixel=16; else if (bits_per_pixel < 16) (void) TransformImageColorspace(image,image->colorspace); if (bits_per_pixel < 8) { (void) TransformImageColorspace(image,GRAYColorspace); (void) SetImageType(image,PaletteType); (void) SortColormapByIntensity(image); } if ((image->storage_class == PseudoClass) && (image->colors > 256)) (void) SetImageStorageClass(image,DirectClass); if (image->storage_class == PseudoClass) flags|=PALM_HAS_COLORMAP_FLAG; else flags|=PALM_IS_DIRECT_COLOR; (void) WriteBlobMSBShort(image,(unsigned short) image->columns); (void) WriteBlobMSBShort(image,(unsigned short) image->rows); bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/ bits_per_pixel))*2; (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row); if ((image_info->compression == RLECompression) || (image_info->compression == FaxCompression)) flags|=PALM_IS_COMPRESSED_FLAG; (void) WriteBlobMSBShort(image, flags); (void) WriteBlobByte(image,(unsigned char) bits_per_pixel); if (bits_per_pixel > 1) version=1; if ((image_info->compression == RLECompression) || (image_info->compression == FaxCompression)) version=2; (void) WriteBlobByte(image,version); (void) WriteBlobMSBShort(image,0); (void) WriteBlobByte(image,(unsigned char) transparentIndex); if (image_info->compression == RLECompression) (void) WriteBlobByte(image,PALM_COMPRESSION_RLE); else if (image_info->compression == FaxCompression) (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE); else (void) WriteBlobByte(image,PALM_COMPRESSION_NONE); (void) WriteBlobMSBShort(image,0); offset=16; if (bits_per_pixel == 16) { (void) WriteBlobByte(image,5); (void) WriteBlobByte(image,6); (void) WriteBlobByte(image,5); (void) WriteBlobByte(image,0); (void) WriteBlobMSBLong(image,0); offset+=8; } if (bits_per_pixel == 8) { if (flags & PALM_HAS_COLORMAP_FLAG) { quantize_info->dither=IsPaletteImage(image,&image->exception); quantize_info->number_colors=image->colors; (void) QuantizeImage(quantize_info,image); (void) WriteBlobMSBShort(image,(unsigned short) image->colors); for (count = 0; count < image->colors; count++) { (void) WriteBlobByte(image,(unsigned char) count); (void) WriteBlobByte(image,ScaleQuantumToChar( image->colormap[count].red)); (void) WriteBlobByte(image, ScaleQuantumToChar(image->colormap[count].green)); (void) WriteBlobByte(image, ScaleQuantumToChar(image->colormap[count].blue)); } offset+=2+count*4; } else { Image *affinity_image; affinity_image=ConstituteImage(256,1,""RGB"",CharPixel,&PalmPalette, exception); (void) TransformImageColorspace(affinity_image, affinity_image->colorspace); (void) RemapImage(quantize_info,image,affinity_image); for (y=0; y < (ssize_t) image->rows; y++) { p=GetAuthenticPixels(image,0,y,image->columns,1,exception); indexes=GetAuthenticIndexQueue(image); for (x=0; x < (ssize_t) image->columns; x++) SetPixelIndex(indexes+x,FindColor(&image->colormap[ (ssize_t) GetPixelIndex(indexes+x)])); } affinity_image=DestroyImage(affinity_image); } } if (flags & PALM_IS_COMPRESSED_FLAG) (void) WriteBlobMSBShort(image,0); last_row=(unsigned char *) NULL; if (image_info->compression == FaxCompression) { last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row, sizeof(*last_row)); if (last_row == (unsigned char *) NULL) { quantize_info=DestroyQuantizeInfo(quantize_info); ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); } } one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row, sizeof(*one_row)); if (one_row == (unsigned char *) NULL) { quantize_info=DestroyQuantizeInfo(quantize_info); ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); } for (y=0; y < (ssize_t) image->rows; y++) { ptr=one_row; (void) ResetMagickMemory(ptr,0,bytes_per_row); p=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (p == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(image); if (bits_per_pixel == 16) { for (x=0; x < (ssize_t) image->columns; x++) { color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/ (size_t) QuantumRange) << 11) | (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) | ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange)); if (GetPixelOpacity(p) == (Quantum) TransparentOpacity) { transpix.red=GetPixelRed(p); transpix.green=GetPixelGreen(p); transpix.blue=GetPixelBlue(p); transpix.opacity=GetPixelOpacity(p); flags|=PALM_HAS_TRANSPARENCY_FLAG; } *ptr++=(unsigned char) ((color16 >> 8) & 0xff); *ptr++=(unsigned char) (color16 & 0xff); p++; } } else { byte=0x00; bit=(unsigned char) (8-bits_per_pixel); for (x=0; x < (ssize_t) image->columns; x++) { if (bits_per_pixel >= 8) color=(unsigned char) GetPixelIndex(indexes+x); else color=(unsigned char) (GetPixelIndex(indexes+x)* ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1)); byte|=color << bit; if (bit != 0) bit-=(unsigned char) bits_per_pixel; else { *ptr++=byte; byte=0x00; bit=(unsigned char) (8-bits_per_pixel); } } if ((image->columns % (8/bits_per_pixel)) != 0) *ptr++=byte; } if (image_info->compression == RLECompression) { x=0; while (x < (ssize_t) bytes_per_row) { byte=one_row[x]; count=1; while ((one_row[++x] == byte) && (count < 255) && (x < (ssize_t) bytes_per_row)) count++; (void) WriteBlobByte(image,(unsigned char) count); (void) WriteBlobByte(image,(unsigned char) byte); } } else if (image_info->compression == FaxCompression) { char tmpbuf[8], *tptr; for (x = 0; x < (ssize_t) bytes_per_row; x += 8) { tptr = tmpbuf; for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++) { if ((y == 0) || (last_row[x + bit] != one_row[x + bit])) { byte |= (1 << (7 - bit)); *tptr++ = (char) one_row[x + bit]; } } (void) WriteBlobByte(image, byte); (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf); } (void) CopyMagickMemory(last_row,one_row,bytes_per_row); } else (void) WriteBlob(image,bytes_per_row,one_row); } if (flags & PALM_HAS_TRANSPARENCY_FLAG) { offset=SeekBlob(image,currentOffset+6,SEEK_SET); (void) WriteBlobMSBShort(image,flags); offset=SeekBlob(image,currentOffset+12,SEEK_SET); (void) WriteBlobByte(image,(unsigned char) transparentIndex); } if (bits_per_pixel == 16) { offset=SeekBlob(image,currentOffset+20,SEEK_SET); (void) WriteBlobByte(image,0); (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/ QuantumRange)); (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/ QuantumRange)); (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/ QuantumRange)); } if (flags & PALM_IS_COMPRESSED_FLAG) { offset=SeekBlob(image,currentOffset+offset,SEEK_SET); (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)- currentOffset-offset)); } if (one_row != (unsigned char *) NULL) one_row=(unsigned char *) RelinquishMagickMemory(one_row); if (last_row != (unsigned char *) NULL) last_row=(unsigned char *) RelinquishMagickMemory(last_row); if (GetNextImageInList(image) == (Image *) NULL) break; for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--) (void) WriteBlobByte(image,0); (void) SeekBlob(image,currentOffset+10,SEEK_SET); nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4); (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset); currentOffset=(MagickOffsetType) GetBlobSize(image); (void) SeekBlob(image,currentOffset,SEEK_SET); image=SyncNextImageInList(image); status=SetImageProgress(image,SaveImagesTag,scene++, GetImageListLength(image)); if (status == MagickFalse) break; } while (image_info->adjoin != MagickFalse); quantize_info=DestroyQuantizeInfo(quantize_info); (void) CloseBlob(image); (void) DestroyExceptionInfo(exception); return(MagickTrue); }"
633,3173----CWE-78----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/evalfunc.c----f_setbufvar,"f_setbufvar(typval_T *argvars, typval_T *rettv UNUSED) { buf_T *buf; char_u *varname, *bufvarname; typval_T *varp; char_u nbuf[NUMBUFLEN]; <S2SV_StartVul> if (check_restricted() || check_secure()) <S2SV_EndVul> return; (void)tv_get_number(&argvars[0]); varname = tv_get_string_chk(&argvars[1]); buf = tv_get_buf(&argvars[0], FALSE); varp = &argvars[2]; if (buf != NULL && varname != NULL && varp != NULL) { if (*varname == '&') { long numval; char_u *strval; int error = FALSE; aco_save_T aco; aucmd_prepbuf(&aco, buf); ++varname; numval = (long)tv_get_number_chk(varp, &error); strval = tv_get_string_buf_chk(varp, nbuf); if (!error && strval != NULL) set_option_value(varname, numval, strval, OPT_LOCAL); aucmd_restbuf(&aco); } else { buf_T *save_curbuf = curbuf; bufvarname = alloc((unsigned)STRLEN(varname) + 3); if (bufvarname != NULL) { curbuf = buf; STRCPY(bufvarname, ""b:""); STRCPY(bufvarname + 2, varname); set_var(bufvarname, varp, TRUE); vim_free(bufvarname); curbuf = save_curbuf; } } } }","- if (check_restricted() || check_secure())
+ if (check_secure())","f_setbufvar(typval_T *argvars, typval_T *rettv UNUSED) { buf_T *buf; char_u *varname, *bufvarname; typval_T *varp; char_u nbuf[NUMBUFLEN]; if (check_secure()) return; (void)tv_get_number(&argvars[0]); varname = tv_get_string_chk(&argvars[1]); buf = tv_get_buf(&argvars[0], FALSE); varp = &argvars[2]; if (buf != NULL && varname != NULL && varp != NULL) { if (*varname == '&') { long numval; char_u *strval; int error = FALSE; aco_save_T aco; aucmd_prepbuf(&aco, buf); ++varname; numval = (long)tv_get_number_chk(varp, &error); strval = tv_get_string_buf_chk(varp, nbuf); if (!error && strval != NULL) set_option_value(varname, numval, strval, OPT_LOCAL); aucmd_restbuf(&aco); } else { buf_T *save_curbuf = curbuf; bufvarname = alloc((unsigned)STRLEN(varname) + 3); if (bufvarname != NULL) { curbuf = buf; STRCPY(bufvarname, ""b:""); STRCPY(bufvarname + 2, varname); set_var(bufvarname, varp, TRUE); vim_free(bufvarname); curbuf = save_curbuf; } } } }"
634,1348----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-13039--print-isakmp.c----ikev2_t_print,"ikev2_t_print(netdissect_options *ndo, int tcount, const struct isakmp_gen *ext, u_int item_len, const u_char *ep) { const struct ikev2_t *p; struct ikev2_t t; uint16_t t_id; const u_char *cp; const char *idstr; const struct attrmap *map; size_t nmap; const u_char *ep2; p = (const struct ikev2_t *)ext; ND_TCHECK(*p); UNALIGNED_MEMCPY(&t, ext, sizeof(t)); ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_T), t.h.critical); t_id = ntohs(t.t_id); map = NULL; nmap = 0; switch (t.t_type) { case IV2_T_ENCR: idstr = STR_OR_ID(t_id, esp_p_map); map = encr_t_map; nmap = sizeof(encr_t_map)/sizeof(encr_t_map[0]); break; case IV2_T_PRF: idstr = STR_OR_ID(t_id, prf_p_map); break; case IV2_T_INTEG: idstr = STR_OR_ID(t_id, integ_p_map); break; case IV2_T_DH: idstr = STR_OR_ID(t_id, dh_p_map); break; case IV2_T_ESN: idstr = STR_OR_ID(t_id, esn_p_map); break; default: idstr = NULL; break; } if (idstr) ND_PRINT((ndo,"" #%u type=%s id=%s "", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), idstr)); else ND_PRINT((ndo,"" #%u type=%s id=%u "", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), t.t_id)); cp = (const u_char *)(p + 1); ep2 = (const u_char *)p + item_len; while (cp < ep && cp < ep2) { if (map && nmap) { <S2SV_StartVul> cp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2, <S2SV_EndVul> <S2SV_StartVul> map, nmap); <S2SV_EndVul> } else <S2SV_StartVul> cp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2); <S2SV_EndVul> } if (ep < ep2) ND_PRINT((ndo,""..."")); return cp; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_T))); return NULL; }","- cp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,
- map, nmap);
- cp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);
+ cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);
+ cp = ikev1_attr_print(ndo, cp, ep2);
+ if (cp == NULL)
+ goto trunc;","ikev2_t_print(netdissect_options *ndo, int tcount, const struct isakmp_gen *ext, u_int item_len, const u_char *ep) { const struct ikev2_t *p; struct ikev2_t t; uint16_t t_id; const u_char *cp; const char *idstr; const struct attrmap *map; size_t nmap; const u_char *ep2; p = (const struct ikev2_t *)ext; ND_TCHECK(*p); UNALIGNED_MEMCPY(&t, ext, sizeof(t)); ikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_T), t.h.critical); t_id = ntohs(t.t_id); map = NULL; nmap = 0; switch (t.t_type) { case IV2_T_ENCR: idstr = STR_OR_ID(t_id, esp_p_map); map = encr_t_map; nmap = sizeof(encr_t_map)/sizeof(encr_t_map[0]); break; case IV2_T_PRF: idstr = STR_OR_ID(t_id, prf_p_map); break; case IV2_T_INTEG: idstr = STR_OR_ID(t_id, integ_p_map); break; case IV2_T_DH: idstr = STR_OR_ID(t_id, dh_p_map); break; case IV2_T_ESN: idstr = STR_OR_ID(t_id, esn_p_map); break; default: idstr = NULL; break; } if (idstr) ND_PRINT((ndo,"" #%u type=%s id=%s "", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), idstr)); else ND_PRINT((ndo,"" #%u type=%s id=%u "", tcount, STR_OR_ID(t.t_type, ikev2_t_type_map), t.t_id)); cp = (const u_char *)(p + 1); ep2 = (const u_char *)p + item_len; while (cp < ep && cp < ep2) { if (map && nmap) { cp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap); } else cp = ikev1_attr_print(ndo, cp, ep2); if (cp == NULL) goto trunc; } if (ep < ep2) ND_PRINT((ndo,""..."")); return cp; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_T))); return NULL; }"
635,2773----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/parser.c----dump_keywords,"dump_keywords(vector_t *keydump, int level, FILE *fp) { unsigned int i; keyword_t *keyword_vec; <S2SV_StartVul> char file_name[21]; <S2SV_EndVul> if (!level) { snprintf(file_name, sizeof(file_name), ""/tmp/keywords.%d"", getpid()); <S2SV_StartVul> fp = fopen(file_name, ""w""); <S2SV_EndVul> if (!fp) return; } for (i = 0; i < vector_size(keydump); i++) { keyword_vec = vector_slot(keydump, i); fprintf(fp, ""%*sKeyword : %s (%s)\n"", level * 2, """", keyword_vec->string, keyword_vec->active ? ""active"": ""disabled""); if (keyword_vec->sub) dump_keywords(keyword_vec->sub, level + 1, fp); } if (!level) fclose(fp); }","- char file_name[21];
- fp = fopen(file_name, ""w"");
+ char file_name[22];
+ fp = fopen_safe(file_name, ""w"");","dump_keywords(vector_t *keydump, int level, FILE *fp) { unsigned int i; keyword_t *keyword_vec; char file_name[22]; if (!level) { snprintf(file_name, sizeof(file_name), ""/tmp/keywords.%d"", getpid()); fp = fopen_safe(file_name, ""w""); if (!fp) return; } for (i = 0; i < vector_size(keydump); i++) { keyword_vec = vector_slot(keydump, i); fprintf(fp, ""%*sKeyword : %s (%s)\n"", level * 2, """", keyword_vec->string, keyword_vec->active ? ""active"": ""disabled""); if (keyword_vec->sub) dump_keywords(keyword_vec->sub, level + 1, fp); } if (!level) fclose(fp); }"
636,3950----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tif_predict.c----PredictorEncodeTile,"PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s) { static const char module[] = ""PredictorEncodeTile""; TIFFPredictorState *sp = PredictorState(tif); uint8 *working_copy; tmsize_t cc = cc0, rowsize; unsigned char* bp; int result_code; assert(sp != NULL); assert(sp->encodepfunc != NULL); assert(sp->encodetile != NULL); working_copy = (uint8*) _TIFFmalloc(cc0); if( working_copy == NULL ) { TIFFErrorExt(tif->tif_clientdata, module, ""Out of memory allocating "" TIFF_SSIZE_FORMAT "" byte temp buffer."", cc0 ); return 0; } memcpy( working_copy, bp0, cc0 ); bp = working_copy; rowsize = sp->rowsize; assert(rowsize > 0); <S2SV_StartVul> assert((cc0%rowsize)==0); <S2SV_EndVul> while (cc > 0) { (*sp->encodepfunc)(tif, bp, rowsize); cc -= rowsize; bp += rowsize; } result_code = (*sp->encodetile)(tif, working_copy, cc0, s); _TIFFfree( working_copy ); return result_code; }","- assert((cc0%rowsize)==0);
+ if((cc0%rowsize)!=0)
+ {
+ TIFFErrorExt(tif->tif_clientdata, ""PredictorEncodeTile"",
+ ""%s"", ""(cc0%rowsize)!=0"");
+ return 0;
+ }","PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s) { static const char module[] = ""PredictorEncodeTile""; TIFFPredictorState *sp = PredictorState(tif); uint8 *working_copy; tmsize_t cc = cc0, rowsize; unsigned char* bp; int result_code; assert(sp != NULL); assert(sp->encodepfunc != NULL); assert(sp->encodetile != NULL); working_copy = (uint8*) _TIFFmalloc(cc0); if( working_copy == NULL ) { TIFFErrorExt(tif->tif_clientdata, module, ""Out of memory allocating "" TIFF_SSIZE_FORMAT "" byte temp buffer."", cc0 ); return 0; } memcpy( working_copy, bp0, cc0 ); bp = working_copy; rowsize = sp->rowsize; assert(rowsize > 0); if((cc0%rowsize)!=0) { TIFFErrorExt(tif->tif_clientdata, ""PredictorEncodeTile"", ""%s"", ""(cc0%rowsize)!=0""); return 0; } while (cc > 0) { (*sp->encodepfunc)(tif, bp, rowsize); cc -= rowsize; bp += rowsize; } result_code = (*sp->encodetile)(tif, working_copy, cc0, s); _TIFFfree( working_copy ); return result_code; }"
637,1148--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8787--nf_nat_redirect.c----nf_nat_redirect_ipv4,"nf_nat_redirect_ipv4(struct sk_buff *skb, const struct nf_nat_ipv4_multi_range_compat *mr, unsigned int hooknum) { struct nf_conn *ct; enum ip_conntrack_info ctinfo; __be32 newdst; struct nf_nat_range newrange; NF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_LOCAL_OUT); ct = nf_ct_get(skb, &ctinfo); NF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED)); if (hooknum == NF_INET_LOCAL_OUT) { newdst = htonl(0x7F000001); } else { struct in_device *indev; struct in_ifaddr *ifa; newdst = 0; rcu_read_lock(); indev = __in_dev_get_rcu(skb->dev); <S2SV_StartVul> if (indev != NULL) { <S2SV_EndVul> ifa = indev->ifa_list; newdst = ifa->ifa_local; } rcu_read_unlock(); if (!newdst) return NF_DROP; } memset(&newrange.min_addr, 0, sizeof(newrange.min_addr)); memset(&newrange.max_addr, 0, sizeof(newrange.max_addr)); newrange.flags = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS; newrange.min_addr.ip = newdst; newrange.max_addr.ip = newdst; newrange.min_proto = mr->range[0].min; newrange.max_proto = mr->range[0].max; return nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST); }","- if (indev != NULL) {
+ if (indev && indev->ifa_list) {","nf_nat_redirect_ipv4(struct sk_buff *skb, const struct nf_nat_ipv4_multi_range_compat *mr, unsigned int hooknum) { struct nf_conn *ct; enum ip_conntrack_info ctinfo; __be32 newdst; struct nf_nat_range newrange; NF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_LOCAL_OUT); ct = nf_ct_get(skb, &ctinfo); NF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED)); if (hooknum == NF_INET_LOCAL_OUT) { newdst = htonl(0x7F000001); } else { struct in_device *indev; struct in_ifaddr *ifa; newdst = 0; rcu_read_lock(); indev = __in_dev_get_rcu(skb->dev); if (indev && indev->ifa_list) { ifa = indev->ifa_list; newdst = ifa->ifa_local; } rcu_read_unlock(); if (!newdst) return NF_DROP; } memset(&newrange.min_addr, 0, sizeof(newrange.min_addr)); memset(&newrange.max_addr, 0, sizeof(newrange.max_addr)); newrange.flags = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS; newrange.min_addr.ip = newdst; newrange.max_addr.ip = newdst; newrange.min_proto = mr->range[0].min; newrange.max_proto = mr->range[0].max; return nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST); }"
638,4692----CWE-913----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/reference_handle.cc----ivm::DeleteRunner::DeleteRunner,"DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) : <S2SV_StartVul> key{ExternalCopy::CopyIfPrimitive(key_handle)}, <S2SV_EndVul> <S2SV_StartVul> context{that.context}, <S2SV_EndVul> <S2SV_StartVul> reference{that.reference} { <S2SV_EndVul> <S2SV_StartVul> that.CheckDisposed(); <S2SV_EndVul> <S2SV_StartVul> if (!key) { <S2SV_EndVul> <S2SV_StartVul> throw RuntimeTypeError(""Invalid `key`""); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- key{ExternalCopy::CopyIfPrimitive(key_handle)},
- context{that.context},
- reference{that.reference} {
- that.CheckDisposed();
- if (!key) {
- throw RuntimeTypeError(""Invalid `key`"");
- }
- }
+ AccessorRunner{that, key_handle} {}","DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) : AccessorRunner{that, key_handle} {}"
639,169----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2176--x509_obj.c----*X509_NAME_oneline,"char *X509_NAME_oneline(X509_NAME *a, char *buf, int len) { X509_NAME_ENTRY *ne; int i; int n, lold, l, l1, l2, num, j, type; const char *s; char *p; unsigned char *q; BUF_MEM *b = NULL; static const char hex[17] = ""0123456789ABCDEF""; int gs_doit[4]; char tmp_buf[80]; #ifdef CHARSET_EBCDIC char ebcdic_buf[1024]; #endif if (buf == NULL) { if ((b = BUF_MEM_new()) == NULL) goto err; if (!BUF_MEM_grow(b, 200)) goto err; b->data[0] = '\0'; len = 200; } else if (len == 0) { return NULL; } if (a == NULL) { if (b) { buf = b->data; OPENSSL_free(b); } strncpy(buf, ""NO X509_NAME"", len); buf[len - 1] = '\0'; return buf; } len--; l = 0; for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) { ne = sk_X509_NAME_ENTRY_value(a->entries, i); n = OBJ_obj2nid(ne->object); if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) { i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object); s = tmp_buf; } l1 = strlen(s); type = ne->value->type; num = ne->value->length; if (num > NAME_ONELINE_MAX) { X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG); goto end; } q = ne->value->data; #ifdef CHARSET_EBCDIC if (type == V_ASN1_GENERALSTRING || type == V_ASN1_VISIBLESTRING || type == V_ASN1_PRINTABLESTRING || type == V_ASN1_TELETEXSTRING || type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) { <S2SV_StartVul> ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf) <S2SV_EndVul> <S2SV_StartVul> ? sizeof ebcdic_buf : num); <S2SV_EndVul> q = ebcdic_buf; } #endif if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) { gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0; for (j = 0; j < num; j++) if (q[j] != 0) gs_doit[j & 3] = 1; if (gs_doit[0] | gs_doit[1] | gs_doit[2]) gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1; else { gs_doit[0] = gs_doit[1] = gs_doit[2] = 0; gs_doit[3] = 1; } } else gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1; for (l2 = j = 0; j < num; j++) { if (!gs_doit[j & 3]) continue; l2++; #ifndef CHARSET_EBCDIC if ((q[j] < ' ') || (q[j] > '~')) l2 += 3; #else if ((os_toascii[q[j]] < os_toascii[' ']) || (os_toascii[q[j]] > os_toascii['~'])) l2 += 3; #endif } lold = l; l += 1 + l1 + 1 + l2; if (l > NAME_ONELINE_MAX) { X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG); goto end; } if (b != NULL) { if (!BUF_MEM_grow(b, l + 1)) goto err; p = &(b->data[lold]); } else if (l > len) { break; } else p = &(buf[lold]); *(p++) = '/'; memcpy(p, s, (unsigned int)l1); p += l1; *(p++) = '='; #ifndef CHARSET_EBCDIC q = ne->value->data; #endif for (j = 0; j < num; j++) { if (!gs_doit[j & 3]) continue; #ifndef CHARSET_EBCDIC n = q[j]; if ((n < ' ') || (n > '~')) { *(p++) = '\\'; *(p++) = 'x'; *(p++) = hex[(n >> 4) & 0x0f]; *(p++) = hex[n & 0x0f]; } else *(p++) = n; #else n = os_toascii[q[j]]; if ((n < os_toascii[' ']) || (n > os_toascii['~'])) { *(p++) = '\\'; *(p++) = 'x'; *(p++) = hex[(n >> 4) & 0x0f]; *(p++) = hex[n & 0x0f]; } else *(p++) = q[j]; #endif } *p = '\0'; } if (b != NULL) { p = b->data; OPENSSL_free(b); } else p = buf; if (i == 0) *p = '\0'; return (p); err: X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE); end: BUF_MEM_free(b); return (NULL); }","- ascii2ebcdic(ebcdic_buf, q, (num > sizeof ebcdic_buf)
- ? sizeof ebcdic_buf : num);
+ if (num > (int)sizeof(ebcdic_buf))
+ num = sizeof(ebcdic_buf);
+ ascii2ebcdic(ebcdic_buf, q, num);","char *X509_NAME_oneline(X509_NAME *a, char *buf, int len) { X509_NAME_ENTRY *ne; int i; int n, lold, l, l1, l2, num, j, type; const char *s; char *p; unsigned char *q; BUF_MEM *b = NULL; static const char hex[17] = ""0123456789ABCDEF""; int gs_doit[4]; char tmp_buf[80]; #ifdef CHARSET_EBCDIC char ebcdic_buf[1024]; #endif if (buf == NULL) { if ((b = BUF_MEM_new()) == NULL) goto err; if (!BUF_MEM_grow(b, 200)) goto err; b->data[0] = '\0'; len = 200; } else if (len == 0) { return NULL; } if (a == NULL) { if (b) { buf = b->data; OPENSSL_free(b); } strncpy(buf, ""NO X509_NAME"", len); buf[len - 1] = '\0'; return buf; } len--; l = 0; for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) { ne = sk_X509_NAME_ENTRY_value(a->entries, i); n = OBJ_obj2nid(ne->object); if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) { i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object); s = tmp_buf; } l1 = strlen(s); type = ne->value->type; num = ne->value->length; if (num > NAME_ONELINE_MAX) { X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG); goto end; } q = ne->value->data; #ifdef CHARSET_EBCDIC if (type == V_ASN1_GENERALSTRING || type == V_ASN1_VISIBLESTRING || type == V_ASN1_PRINTABLESTRING || type == V_ASN1_TELETEXSTRING || type == V_ASN1_VISIBLESTRING || type == V_ASN1_IA5STRING) { if (num > (int)sizeof(ebcdic_buf)) num = sizeof(ebcdic_buf); ascii2ebcdic(ebcdic_buf, q, num); q = ebcdic_buf; } #endif if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) { gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0; for (j = 0; j < num; j++) if (q[j] != 0) gs_doit[j & 3] = 1; if (gs_doit[0] | gs_doit[1] | gs_doit[2]) gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1; else { gs_doit[0] = gs_doit[1] = gs_doit[2] = 0; gs_doit[3] = 1; } } else gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1; for (l2 = j = 0; j < num; j++) { if (!gs_doit[j & 3]) continue; l2++; #ifndef CHARSET_EBCDIC if ((q[j] < ' ') || (q[j] > '~')) l2 += 3; #else if ((os_toascii[q[j]] < os_toascii[' ']) || (os_toascii[q[j]] > os_toascii['~'])) l2 += 3; #endif } lold = l; l += 1 + l1 + 1 + l2; if (l > NAME_ONELINE_MAX) { X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG); goto end; } if (b != NULL) { if (!BUF_MEM_grow(b, l + 1)) goto err; p = &(b->data[lold]); } else if (l > len) { break; } else p = &(buf[lold]); *(p++) = '/'; memcpy(p, s, (unsigned int)l1); p += l1; *(p++) = '='; #ifndef CHARSET_EBCDIC q = ne->value->data; #endif for (j = 0; j < num; j++) { if (!gs_doit[j & 3]) continue; #ifndef CHARSET_EBCDIC n = q[j]; if ((n < ' ') || (n > '~')) { *(p++) = '\\'; *(p++) = 'x'; *(p++) = hex[(n >> 4) & 0x0f]; *(p++) = hex[n & 0x0f]; } else *(p++) = n; #else n = os_toascii[q[j]]; if ((n < os_toascii[' ']) || (n > os_toascii['~'])) { *(p++) = '\\'; *(p++) = 'x'; *(p++) = hex[(n >> 4) & 0x0f]; *(p++) = hex[n & 0x0f]; } else *(p++) = q[j]; #endif } *p = '\0'; } if (b != NULL) { p = b->data; OPENSSL_free(b); } else p = buf; if (i == 0) *p = '\0'; return (p); err: X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE); end: BUF_MEM_free(b); return (NULL); }"
640,4110----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bits.c----bit_write_UMC,"bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val) { int i, j; int negative; unsigned char byte[5]; BITCODE_UMC mask; BITCODE_UMC value; value = val; mask = 0x0000007f; for (i = 4, j = 0; i >= 0; i--, j += 7) { byte[i] = (unsigned char)((value & mask) >> j); byte[i] |= 0x80; mask = mask << 7; } for (i = 0; i < 4; i++) if (byte[i] & 0x7f) break; <S2SV_StartVul> if (byte[i] & 0x40) <S2SV_EndVul> i--; byte[i] &= 0x7f; for (j = 4; j >= i; j--) bit_write_RC (dat, byte[j]); }","- if (byte[i] & 0x40)
+ if (byte[i] & 0x40 && i > 0)","bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val) { int i, j; int negative; unsigned char byte[5]; BITCODE_UMC mask; BITCODE_UMC value; value = val; mask = 0x0000007f; for (i = 4, j = 0; i >= 0; i--, j += 7) { byte[i] = (unsigned char)((value & mask) >> j); byte[i] |= 0x80; mask = mask << 7; } for (i = 0; i < 4; i++) if (byte[i] & 0x7f) break; if (byte[i] & 0x40 && i > 0) i--; byte[i] &= 0x7f; for (j = 4; j >= i; j--) bit_write_RC (dat, byte[j]); }"
641,3597----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/extents.c----ext4_ext_handle_uninitialized_extents,"ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags, unsigned int allocated, ext4_fsblk_t newblock) { int ret = 0; int err = 0; ext4_io_end_t *io = ext4_inode_aio(inode); ext_debug(""ext4_ext_handle_uninitialized_extents: inode %lu, logical "" ""block %llu, max_blocks %u, flags %x, allocated %u\n"", inode->i_ino, (unsigned long long)map->m_lblk, map->m_len, flags, allocated); ext4_ext_show_leaf(inode, path); trace_ext4_ext_handle_uninitialized_extents(inode, map, allocated, newblock); if ((flags & EXT4_GET_BLOCKS_PRE_IO)) { ret = ext4_split_unwritten_extents(handle, inode, map, path, flags); if (ret <= 0) goto out; if (io) ext4_set_io_unwritten_flag(inode, io); else ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN); if (ext4_should_dioread_nolock(inode)) map->m_flags |= EXT4_MAP_UNINIT; goto out; } if ((flags & EXT4_GET_BLOCKS_CONVERT)) { <S2SV_StartVul> ret = ext4_convert_unwritten_extents_endio(handle, inode, <S2SV_EndVul> path); if (ret >= 0) { ext4_update_inode_fsync_trans(handle, inode, 1); err = check_eofblocks_fl(handle, inode, map->m_lblk, path, map->m_len); } else err = ret; goto out2; } if (flags & EXT4_GET_BLOCKS_UNINIT_EXT) goto map_out; if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) { map->m_flags |= EXT4_MAP_UNWRITTEN; goto out1; } ret = ext4_ext_convert_to_initialized(handle, inode, map, path); if (ret >= 0) ext4_update_inode_fsync_trans(handle, inode, 1); out: if (ret <= 0) { err = ret; goto out2; } else allocated = ret; map->m_flags |= EXT4_MAP_NEW; if (allocated > map->m_len) { unmap_underlying_metadata_blocks(inode->i_sb->s_bdev, newblock + map->m_len, allocated - map->m_len); allocated = map->m_len; } if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) { unsigned int reserved_clusters; reserved_clusters = get_reserved_cluster_alloc(inode, map->m_lblk, map->m_len); if (reserved_clusters) ext4_da_update_reserve_space(inode, reserved_clusters, 0); } map_out: map->m_flags |= EXT4_MAP_MAPPED; if ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) { err = check_eofblocks_fl(handle, inode, map->m_lblk, path, map->m_len); if (err < 0) goto out2; } out1: if (allocated > map->m_len) allocated = map->m_len; ext4_ext_show_leaf(inode, path); map->m_pblk = newblock; map->m_len = allocated; out2: if (path) { ext4_ext_drop_refs(path); kfree(path); } return err ? err : allocated; }","- ret = ext4_convert_unwritten_extents_endio(handle, inode,
+ ret = ext4_convert_unwritten_extents_endio(handle, inode, map,","ext4_ext_handle_uninitialized_extents(handle_t *handle, struct inode *inode, struct ext4_map_blocks *map, struct ext4_ext_path *path, int flags, unsigned int allocated, ext4_fsblk_t newblock) { int ret = 0; int err = 0; ext4_io_end_t *io = ext4_inode_aio(inode); ext_debug(""ext4_ext_handle_uninitialized_extents: inode %lu, logical "" ""block %llu, max_blocks %u, flags %x, allocated %u\n"", inode->i_ino, (unsigned long long)map->m_lblk, map->m_len, flags, allocated); ext4_ext_show_leaf(inode, path); trace_ext4_ext_handle_uninitialized_extents(inode, map, allocated, newblock); if ((flags & EXT4_GET_BLOCKS_PRE_IO)) { ret = ext4_split_unwritten_extents(handle, inode, map, path, flags); if (ret <= 0) goto out; if (io) ext4_set_io_unwritten_flag(inode, io); else ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN); if (ext4_should_dioread_nolock(inode)) map->m_flags |= EXT4_MAP_UNINIT; goto out; } if ((flags & EXT4_GET_BLOCKS_CONVERT)) { ret = ext4_convert_unwritten_extents_endio(handle, inode, map, path); if (ret >= 0) { ext4_update_inode_fsync_trans(handle, inode, 1); err = check_eofblocks_fl(handle, inode, map->m_lblk, path, map->m_len); } else err = ret; goto out2; } if (flags & EXT4_GET_BLOCKS_UNINIT_EXT) goto map_out; if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) { map->m_flags |= EXT4_MAP_UNWRITTEN; goto out1; } ret = ext4_ext_convert_to_initialized(handle, inode, map, path); if (ret >= 0) ext4_update_inode_fsync_trans(handle, inode, 1); out: if (ret <= 0) { err = ret; goto out2; } else allocated = ret; map->m_flags |= EXT4_MAP_NEW; if (allocated > map->m_len) { unmap_underlying_metadata_blocks(inode->i_sb->s_bdev, newblock + map->m_len, allocated - map->m_len); allocated = map->m_len; } if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) { unsigned int reserved_clusters; reserved_clusters = get_reserved_cluster_alloc(inode, map->m_lblk, map->m_len); if (reserved_clusters) ext4_da_update_reserve_space(inode, reserved_clusters, 0); } map_out: map->m_flags |= EXT4_MAP_MAPPED; if ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) { err = check_eofblocks_fl(handle, inode, map->m_lblk, path, map->m_len); if (err < 0) goto out2; } out1: if (allocated > map->m_len) allocated = map->m_len; ext4_ext_show_leaf(inode, path); map->m_pblk = newblock; map->m_len = allocated; out2: if (path) { ext4_ext_drop_refs(path); kfree(path); } return err ? err : allocated; }"
642,1132----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-8953--copy_up.c----ovl_copy_up_locked,"static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir, struct dentry *dentry, struct path *lowerpath, struct kstat *stat, struct iattr *attr, const char *link) { struct inode *wdir = workdir->d_inode; struct inode *udir = upperdir->d_inode; struct dentry *newdentry = NULL; struct dentry *upper = NULL; umode_t mode = stat->mode; int err; newdentry = ovl_lookup_temp(workdir, dentry); err = PTR_ERR(newdentry); if (IS_ERR(newdentry)) goto out; upper = lookup_one_len(dentry->d_name.name, upperdir, dentry->d_name.len); err = PTR_ERR(upper); if (IS_ERR(upper)) goto out1; stat->mode &= S_IFMT; err = ovl_create_real(wdir, newdentry, stat, link, NULL, true); stat->mode = mode; if (err) goto out2; if (S_ISREG(stat->mode)) { struct path upperpath; ovl_path_upper(dentry, &upperpath); BUG_ON(upperpath.dentry != NULL); upperpath.dentry = newdentry; err = ovl_copy_up_data(lowerpath, &upperpath, stat->size); if (err) goto out_cleanup; } err = ovl_copy_xattr(lowerpath->dentry, newdentry); if (err) goto out_cleanup; mutex_lock(&newdentry->d_inode->i_mutex); err = ovl_set_attr(newdentry, stat); if (!err && attr) err = notify_change(newdentry, attr, NULL); mutex_unlock(&newdentry->d_inode->i_mutex); if (err) goto out_cleanup; err = ovl_do_rename(wdir, newdentry, udir, upper, 0); if (err) goto out_cleanup; ovl_dentry_update(dentry, newdentry); newdentry = NULL; if (!S_ISDIR(stat->mode)) ovl_dentry_set_opaque(dentry, true); out2: dput(upper); out1: dput(newdentry); out: return err; out_cleanup: ovl_cleanup(wdir, newdentry); <S2SV_StartVul> goto out; <S2SV_EndVul> }","- goto out;
+ goto out2;","static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir, struct dentry *dentry, struct path *lowerpath, struct kstat *stat, struct iattr *attr, const char *link) { struct inode *wdir = workdir->d_inode; struct inode *udir = upperdir->d_inode; struct dentry *newdentry = NULL; struct dentry *upper = NULL; umode_t mode = stat->mode; int err; newdentry = ovl_lookup_temp(workdir, dentry); err = PTR_ERR(newdentry); if (IS_ERR(newdentry)) goto out; upper = lookup_one_len(dentry->d_name.name, upperdir, dentry->d_name.len); err = PTR_ERR(upper); if (IS_ERR(upper)) goto out1; stat->mode &= S_IFMT; err = ovl_create_real(wdir, newdentry, stat, link, NULL, true); stat->mode = mode; if (err) goto out2; if (S_ISREG(stat->mode)) { struct path upperpath; ovl_path_upper(dentry, &upperpath); BUG_ON(upperpath.dentry != NULL); upperpath.dentry = newdentry; err = ovl_copy_up_data(lowerpath, &upperpath, stat->size); if (err) goto out_cleanup; } err = ovl_copy_xattr(lowerpath->dentry, newdentry); if (err) goto out_cleanup; mutex_lock(&newdentry->d_inode->i_mutex); err = ovl_set_attr(newdentry, stat); if (!err && attr) err = notify_change(newdentry, attr, NULL); mutex_unlock(&newdentry->d_inode->i_mutex); if (err) goto out_cleanup; err = ovl_do_rename(wdir, newdentry, udir, upper, 0); if (err) goto out_cleanup; ovl_dentry_update(dentry, newdentry); newdentry = NULL; if (!S_ISDIR(stat->mode)) ovl_dentry_set_opaque(dentry, true); out2: dput(upper); out1: dput(newdentry); out: return err; out_cleanup: ovl_cleanup(wdir, newdentry); goto out2; }"
643,4421----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bufferedreader.c----__pyx_pf_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader,"static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) { PyObject *__pyx_v___pyx_PickleError = 0; PyObject *__pyx_v___pyx_result = 0; PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations int __pyx_t_1; PyObject *__pyx_t_2 = NULL; PyObject *__pyx_t_3 = NULL; PyObject *__pyx_t_4 = NULL; PyObject *__pyx_t_5 = NULL; int __pyx_t_6; __Pyx_RefNannySetupContext(""__pyx_unpickle_BufferedReader"", 0); __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x2a8a945) != 0); if (__pyx_t_1) { __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_INCREF(__pyx_n_s_PickleError); __Pyx_GIVEREF(__pyx_n_s_PickleError); PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError); <S2SV_StartVul> __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error) <S2SV_EndVul> __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_INCREF(__pyx_t_2); __pyx_v___pyx_PickleError = __pyx_t_2; __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x2a, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __Pyx_INCREF(__pyx_v___pyx_PickleError); __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL; if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) { __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2); if (likely(__pyx_t_5)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2); __Pyx_INCREF(__pyx_t_5); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_2, function); } } __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __Pyx_Raise(__pyx_t_3, 0, 0, 0); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __PYX_ERR(1, 6, __pyx_L1_error) } __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedReader), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_t_4 = NULL; if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) { __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2); if (likely(__pyx_t_4)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2); __Pyx_INCREF(__pyx_t_4); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_2, function); } } __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type); __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v___pyx_result = __pyx_t_3; __pyx_t_3 = 0; __pyx_t_1 = (__pyx_v___pyx_state != Py_None); __pyx_t_6 = (__pyx_t_1 != 0); if (__pyx_t_6) { if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, ""Expected %.16s, got %.200s"", ""tuple"", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error) __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; } __Pyx_XDECREF(__pyx_r); __Pyx_INCREF(__pyx_v___pyx_result); __pyx_r = __pyx_v___pyx_result; goto __pyx_L0; __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_2); __Pyx_XDECREF(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __Pyx_AddTraceback(""clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedReader"", __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XDECREF(__pyx_v___pyx_PickleError); __Pyx_XDECREF(__pyx_v___pyx_result); __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; }","- __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, 0); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)
+ int __pyx_lineno = 0;
+ const char *__pyx_filename = NULL;
+ int __pyx_clineno = 0;
+ __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)","static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v___pyx_type, long __pyx_v___pyx_checksum, PyObject *__pyx_v___pyx_state) { PyObject *__pyx_v___pyx_PickleError = 0; PyObject *__pyx_v___pyx_result = 0; PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations int __pyx_t_1; PyObject *__pyx_t_2 = NULL; PyObject *__pyx_t_3 = NULL; PyObject *__pyx_t_4 = NULL; PyObject *__pyx_t_5 = NULL; int __pyx_t_6; int __pyx_lineno = 0; const char *__pyx_filename = NULL; int __pyx_clineno = 0; __Pyx_RefNannySetupContext(""__pyx_unpickle_BufferedReader"", 0); __pyx_t_1 = ((__pyx_v___pyx_checksum != 0x2a8a945) != 0); if (__pyx_t_1) { __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_INCREF(__pyx_n_s_PickleError); __Pyx_GIVEREF(__pyx_n_s_PickleError); PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_PickleError); __pyx_t_3 = __Pyx_Import(__pyx_n_s_pickle, __pyx_t_2, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_t_2 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_PickleError); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_INCREF(__pyx_t_2); __pyx_v___pyx_PickleError = __pyx_t_2; __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v___pyx_checksum); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 6, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_Incompatible_checksums_s_vs_0x2a, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 6, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __Pyx_INCREF(__pyx_v___pyx_PickleError); __pyx_t_2 = __pyx_v___pyx_PickleError; __pyx_t_5 = NULL; if (CYTHON_UNPACK_METHODS && unlikely(PyMethod_Check(__pyx_t_2))) { __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_2); if (likely(__pyx_t_5)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2); __Pyx_INCREF(__pyx_t_5); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_2, function); } } __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 6, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __Pyx_Raise(__pyx_t_3, 0, 0, 0); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __PYX_ERR(1, 6, __pyx_L1_error) } __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_17clickhouse_driver_14bufferedreader_BufferedReader), __pyx_n_s_new); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_t_4 = NULL; if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) { __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2); if (likely(__pyx_t_4)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2); __Pyx_INCREF(__pyx_t_4); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_2, function); } } __pyx_t_3 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_v___pyx_type) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v___pyx_type); __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v___pyx_result = __pyx_t_3; __pyx_t_3 = 0; __pyx_t_1 = (__pyx_v___pyx_state != Py_None); __pyx_t_6 = (__pyx_t_1 != 0); if (__pyx_t_6) { if (!(likely(PyTuple_CheckExact(__pyx_v___pyx_state))||((__pyx_v___pyx_state) == Py_None)||(PyErr_Format(PyExc_TypeError, ""Expected %.16s, got %.200s"", ""tuple"", Py_TYPE(__pyx_v___pyx_state)->tp_name), 0))) __PYX_ERR(1, 9, __pyx_L1_error) __pyx_t_3 = __pyx_f_17clickhouse_driver_14bufferedreader___pyx_unpickle_BufferedReader__set_state(((struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *)__pyx_v___pyx_result), ((PyObject*)__pyx_v___pyx_state)); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 9, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; } __Pyx_XDECREF(__pyx_r); __Pyx_INCREF(__pyx_v___pyx_result); __pyx_r = __pyx_v___pyx_result; goto __pyx_L0; __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_2); __Pyx_XDECREF(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __Pyx_AddTraceback(""clickhouse_driver.bufferedreader.__pyx_unpickle_BufferedReader"", __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XDECREF(__pyx_v___pyx_PickleError); __Pyx_XDECREF(__pyx_v___pyx_result); __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; }"
644,1023--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4581--pnode.c----propagate_one,"static int propagate_one(struct mount *m) { struct mount *child; int type; if (IS_MNT_NEW(m)) return 0; if (!is_subdir(mp->m_dentry, m->mnt.mnt_root)) return 0; if (peers(m, last_dest)) { type = CL_MAKE_SHARED; } else { struct mount *n, *p; for (n = m; ; n = p) { p = n->mnt_master; <S2SV_StartVul> if (p == dest_master || IS_MNT_MARKED(p)) { <S2SV_EndVul> <S2SV_StartVul> while (last_dest->mnt_master != p) { <S2SV_EndVul> <S2SV_StartVul> last_source = last_source->mnt_master; <S2SV_EndVul> <S2SV_StartVul> last_dest = last_source->mnt_parent; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (!peers(n, last_dest)) { <S2SV_EndVul> <S2SV_StartVul> last_source = last_source->mnt_master; <S2SV_EndVul> <S2SV_StartVul> last_dest = last_source->mnt_parent; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> break; <S2SV_StartVul> } <S2SV_EndVul> } type = CL_SLAVE; if (IS_MNT_SHARED(m)) type |= CL_MAKE_SHARED; } if (m->mnt_ns->user_ns != user_ns) type |= CL_UNPRIVILEGED; child = copy_tree(last_source, last_source->mnt.mnt_root, type); if (IS_ERR(child)) return PTR_ERR(child); child->mnt.mnt_flags &= ~MNT_LOCKED; mnt_set_mountpoint(m, mp, child); last_dest = m; last_source = child; if (m->mnt_master != dest_master) { read_seqlock_excl(&mount_lock); SET_MNT_MARK(m->mnt_master); read_sequnlock_excl(&mount_lock); } hlist_add_head(&child->mnt_hash, list); return 0; }","- if (p == dest_master || IS_MNT_MARKED(p)) {
- while (last_dest->mnt_master != p) {
- last_source = last_source->mnt_master;
- last_dest = last_source->mnt_parent;
- }
- if (!peers(n, last_dest)) {
- last_source = last_source->mnt_master;
- last_dest = last_source->mnt_parent;
- }
- }
+ bool done;
+ if (p == dest_master || IS_MNT_MARKED(p))
+ do {
+ struct mount *parent = last_source->mnt_parent;
+ if (last_source == first_source)
+ break;
+ done = parent->mnt_master == p;
+ if (done && peers(n, parent))
+ break;
+ last_source = last_source->mnt_master;
+ } while (!done);","static int propagate_one(struct mount *m) { struct mount *child; int type; if (IS_MNT_NEW(m)) return 0; if (!is_subdir(mp->m_dentry, m->mnt.mnt_root)) return 0; if (peers(m, last_dest)) { type = CL_MAKE_SHARED; } else { struct mount *n, *p; bool done; for (n = m; ; n = p) { p = n->mnt_master; if (p == dest_master || IS_MNT_MARKED(p)) break; } do { struct mount *parent = last_source->mnt_parent; if (last_source == first_source) break; done = parent->mnt_master == p; if (done && peers(n, parent)) break; last_source = last_source->mnt_master; } while (!done); type = CL_SLAVE; if (IS_MNT_SHARED(m)) type |= CL_MAKE_SHARED; } if (m->mnt_ns->user_ns != user_ns) type |= CL_UNPRIVILEGED; child = copy_tree(last_source, last_source->mnt.mnt_root, type); if (IS_ERR(child)) return PTR_ERR(child); child->mnt.mnt_flags &= ~MNT_LOCKED; mnt_set_mountpoint(m, mp, child); last_dest = m; last_source = child; if (m->mnt_master != dest_master) { read_seqlock_excl(&mount_lock); SET_MNT_MARK(m->mnt_master); read_sequnlock_excl(&mount_lock); } hlist_add_head(&child->mnt_hash, list); return 0; }"
645,6646----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bson.c----bson_append_finish_object,"MONGO_EXPORT int bson_append_finish_object( bson *b ) { char *start; int i; if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR; bson_append_byte( b , 0 ); start = b->data + b->stack[ --b->stackPos ]; <S2SV_StartVul> i = b->cur - start; <S2SV_EndVul> bson_little_endian32( start, &i ); return BSON_OK; }","- i = b->cur - start;
+ i = ( int )( b->cur - start );","MONGO_EXPORT int bson_append_finish_object( bson *b ) { char *start; int i; if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR; bson_append_byte( b , 0 ); start = b->data + b->stack[ --b->stackPos ]; i = ( int )( b->cur - start ); bson_little_endian32( start, &i ); return BSON_OK; }"
646,6865----CWE-772----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server_stubs.c----get_privs_2_svc,"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp) { static getprivs_ret ret; <S2SV_StartVul> gss_buffer_desc client_name, service_name; <S2SV_EndVul> OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_getprivs_ret, &ret); if ((ret.code = new_server_handle(*arg, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } ret.code = kadm5_get_privs((void *)handle, &ret.privs); if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(""kadm5_get_privs"", client_name.value, errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); <S2SV_StartVul> exit_func: <S2SV_EndVul> free_server_handle(handle); return &ret; }","- gss_buffer_desc client_name, service_name;
- exit_func:
+ gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER;
+ gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER;
+ exit_func:","getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp) { static getprivs_ret ret; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER; OM_uint32 minor_stat; kadm5_server_handle_t handle; const char *errmsg = NULL; xdr_free(xdr_getprivs_ret, &ret); if ((ret.code = new_server_handle(*arg, rqstp, &handle))) goto exit_func; if ((ret.code = check_handle((void *)handle))) goto exit_func; ret.api_version = handle->api_version; if (setup_gss_names(rqstp, &client_name, &service_name) < 0) { ret.code = KADM5_FAILURE; goto exit_func; } ret.code = kadm5_get_privs((void *)handle, &ret.privs); if( ret.code != 0 ) errmsg = krb5_get_error_message(handle->context, ret.code); log_done(""kadm5_get_privs"", client_name.value, errmsg, &client_name, &service_name, rqstp); if (errmsg != NULL) krb5_free_error_message(handle->context, errmsg); exit_func: gss_release_buffer(&minor_stat, &client_name); gss_release_buffer(&minor_stat, &service_name); free_server_handle(handle); return &ret; }"
647,3255----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cjson.c----cJSON_Print,"<S2SV_StartVul> char *cJSON_Print( cJSON *item ) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> return print_value( item, 0, 1 ); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- char *cJSON_Print( cJSON *item )
- {
- return print_value( item, 0, 1 );
- }
+ char *cJSON_Print(cJSON *item) {return print_value(item,0,1,0);}","char *cJSON_Print(cJSON *item) {return print_value(item,0,1,0);}"
648,2366----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-20836--sas_expander.c----smp_task_done,static void smp_task_done(struct sas_task *task) { <S2SV_StartVul> if (!del_timer(&task->slow_task->timer)) <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> complete(&task->slow_task->completion); },"- if (!del_timer(&task->slow_task->timer))
- return;
+ del_timer(&task->slow_task->timer);",static void smp_task_done(struct sas_task *task) { del_timer(&task->slow_task->timer); complete(&task->slow_task->completion); }
649,3757----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mptctl.c----mptctl_do_reset,"<S2SV_StartVul> static int mptctl_do_reset(unsigned long arg) <S2SV_EndVul> { struct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg; struct mpt_ioctl_diag_reset krinfo; <S2SV_StartVul> MPT_ADAPTER *iocp; <S2SV_EndVul> if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) { printk(KERN_ERR MYNAM ""%s@%d::mptctl_do_reset - "" ""Unable to copy mpt_ioctl_diag_reset struct @ %p\n"", __FILE__, __LINE__, urinfo); return -EFAULT; } <S2SV_StartVul> if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) { <S2SV_EndVul> <S2SV_StartVul> printk(KERN_DEBUG MYNAM ""%s@%d::mptctl_do_reset - ioc%d not found!\n"", <S2SV_EndVul> <S2SV_StartVul> __FILE__, __LINE__, krinfo.hdr.iocnum); <S2SV_EndVul> <S2SV_StartVul> return -ENODEV; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT ""mptctl_do_reset called.\n"", iocp->name)); if (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) { printk (MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_reset - reset failed.\n"", iocp->name, __FILE__, __LINE__); return -1; } return 0; }","- static int mptctl_do_reset(unsigned long arg)
- MPT_ADAPTER *iocp;
- if (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {
- printk(KERN_DEBUG MYNAM ""%s@%d::mptctl_do_reset - ioc%d not found!\n"",
- __FILE__, __LINE__, krinfo.hdr.iocnum);
- }
+ static int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg)","static int mptctl_do_reset(MPT_ADAPTER *iocp, unsigned long arg) { struct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg; struct mpt_ioctl_diag_reset krinfo; if (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) { printk(KERN_ERR MYNAM ""%s@%d::mptctl_do_reset - "" ""Unable to copy mpt_ioctl_diag_reset struct @ %p\n"", __FILE__, __LINE__, urinfo); return -EFAULT; } dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT ""mptctl_do_reset called.\n"", iocp->name)); if (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) { printk (MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_reset - reset failed.\n"", iocp->name, __FILE__, __LINE__); return -1; } return 0; }"
650,6438----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fat.c----set_fat,"void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new) { unsigned char *data = NULL; int size; loff_t offs; if (new == -1) new = FAT_EOF(fs); else if ((long)new == -2) new = FAT_BAD(fs); switch (fs->fat_bits) { case 12: data = fs->fat + cluster * 3 / 2; offs = fs->fat_start + cluster * 3 / 2; if (cluster & 1) { FAT_ENTRY prevEntry; get_fat(&prevEntry, fs->fat, cluster - 1, fs); data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8); data[1] = new >> 4; } else { FAT_ENTRY subseqEntry; <S2SV_StartVul> if (cluster != fs->clusters - 1) <S2SV_EndVul> get_fat(&subseqEntry, fs->fat, cluster + 1, fs); else subseqEntry.value = 0; data[0] = new & 0xff; data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4); } size = 2; break; case 16: data = fs->fat + cluster * 2; offs = fs->fat_start + cluster * 2; *(unsigned short *)data = htole16(new); size = 2; break; case 32: { FAT_ENTRY curEntry; get_fat(&curEntry, fs->fat, cluster, fs); data = fs->fat + cluster * 4; offs = fs->fat_start + cluster * 4; *(uint32_t *)data = htole32((new & 0xfffffff) | (curEntry.reserved << 28)); size = 4; } break; default: die(""Bad FAT entry size: %d bits."", fs->fat_bits); } fs_write(offs, size, data); if (fs->nfats > 1) { fs_write(offs + fs->fat_size, size, data); } }","- if (cluster != fs->clusters - 1)
+ if (cluster != fs->clusters + 1)","void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new) { unsigned char *data = NULL; int size; loff_t offs; if (new == -1) new = FAT_EOF(fs); else if ((long)new == -2) new = FAT_BAD(fs); switch (fs->fat_bits) { case 12: data = fs->fat + cluster * 3 / 2; offs = fs->fat_start + cluster * 3 / 2; if (cluster & 1) { FAT_ENTRY prevEntry; get_fat(&prevEntry, fs->fat, cluster - 1, fs); data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8); data[1] = new >> 4; } else { FAT_ENTRY subseqEntry; if (cluster != fs->clusters + 1) get_fat(&subseqEntry, fs->fat, cluster + 1, fs); else subseqEntry.value = 0; data[0] = new & 0xff; data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4); } size = 2; break; case 16: data = fs->fat + cluster * 2; offs = fs->fat_start + cluster * 2; *(unsigned short *)data = htole16(new); size = 2; break; case 32: { FAT_ENTRY curEntry; get_fat(&curEntry, fs->fat, cluster, fs); data = fs->fat + cluster * 4; offs = fs->fat_start + cluster * 4; *(uint32_t *)data = htole32((new & 0xfffffff) | (curEntry.reserved << 28)); size = 4; } break; default: die(""Bad FAT entry size: %d bits."", fs->fat_bits); } fs_write(offs, size, data); if (fs->nfats > 1) { fs_write(offs + fs->fat_size, size, data); } }"
651,4612----CWE-908----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/FixedPointTypes.h----Eigen::QUInt16::QUInt16,<S2SV_StartVul> QUInt16() {} <S2SV_EndVul>,"- QUInt16() {}
+ QUInt16() : value(0) {}",QUInt16() : value(0) {}
652,1090----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2548--timer.c----snd_timer_start_slave,"static int snd_timer_start_slave(struct snd_timer_instance *timeri) { unsigned long flags; spin_lock_irqsave(&slave_active_lock, flags); timeri->flags |= SNDRV_TIMER_IFLG_RUNNING; <S2SV_StartVul> if (timeri->master) <S2SV_EndVul> list_add_tail(&timeri->active_list, &timeri->master->slave_active_head); spin_unlock_irqrestore(&slave_active_lock, flags); return 1; }","- if (timeri->master)
+ if (timeri->master && timeri->timer) {
+ spin_lock(&timeri->timer->lock);
+ spin_unlock(&timeri->timer->lock);
+ }","static int snd_timer_start_slave(struct snd_timer_instance *timeri) { unsigned long flags; spin_lock_irqsave(&slave_active_lock, flags); timeri->flags |= SNDRV_TIMER_IFLG_RUNNING; if (timeri->master && timeri->timer) { spin_lock(&timeri->timer->lock); list_add_tail(&timeri->active_list, &timeri->master->slave_active_head); spin_unlock(&timeri->timer->lock); } spin_unlock_irqrestore(&slave_active_lock, flags); return 1; }"
653,7434----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xfs_da_btree.c----xfs_da3_fixhashpath,"xfs_da3_fixhashpath( struct xfs_da_state *state, struct xfs_da_state_path *path) { struct xfs_da_state_blk *blk; struct xfs_da_intnode *node; struct xfs_da_node_entry *btree; xfs_dahash_t lasthash=0; int level; int count; struct xfs_inode *dp = state->args->dp; trace_xfs_da_fixhashpath(state->args); level = path->active-1; blk = &path->blk[ level ]; switch (blk->magic) { case XFS_ATTR_LEAF_MAGIC: lasthash = xfs_attr_leaf_lasthash(blk->bp, &count); if (count == 0) return; break; case XFS_DIR2_LEAFN_MAGIC: lasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count); if (count == 0) return; break; case XFS_DA_NODE_MAGIC: lasthash = xfs_da3_node_lasthash(dp, blk->bp, &count); if (count == 0) return; break; } for (blk--, level--; level >= 0; blk--, level--) { struct xfs_da3_icnode_hdr nodehdr; node = blk->bp->b_addr; dp->d_ops->node_hdr_from_disk(&nodehdr, node); btree = dp->d_ops->node_tree_p(node); <S2SV_StartVul> if (be32_to_cpu(btree->hashval) == lasthash) <S2SV_EndVul> break; blk->hashval = lasthash; btree[blk->index].hashval = cpu_to_be32(lasthash); xfs_trans_log_buf(state->args->trans, blk->bp, XFS_DA_LOGRANGE(node, &btree[blk->index], sizeof(*btree))); lasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval); } }","- if (be32_to_cpu(btree->hashval) == lasthash)
+ if (be32_to_cpu(btree[blk->index].hashval) == lasthash)","xfs_da3_fixhashpath( struct xfs_da_state *state, struct xfs_da_state_path *path) { struct xfs_da_state_blk *blk; struct xfs_da_intnode *node; struct xfs_da_node_entry *btree; xfs_dahash_t lasthash=0; int level; int count; struct xfs_inode *dp = state->args->dp; trace_xfs_da_fixhashpath(state->args); level = path->active-1; blk = &path->blk[ level ]; switch (blk->magic) { case XFS_ATTR_LEAF_MAGIC: lasthash = xfs_attr_leaf_lasthash(blk->bp, &count); if (count == 0) return; break; case XFS_DIR2_LEAFN_MAGIC: lasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count); if (count == 0) return; break; case XFS_DA_NODE_MAGIC: lasthash = xfs_da3_node_lasthash(dp, blk->bp, &count); if (count == 0) return; break; } for (blk--, level--; level >= 0; blk--, level--) { struct xfs_da3_icnode_hdr nodehdr; node = blk->bp->b_addr; dp->d_ops->node_hdr_from_disk(&nodehdr, node); btree = dp->d_ops->node_tree_p(node); if (be32_to_cpu(btree[blk->index].hashval) == lasthash) break; blk->hashval = lasthash; btree[blk->index].hashval = cpu_to_be32(lasthash); xfs_trans_log_buf(state->args->trans, blk->bp, XFS_DA_LOGRANGE(node, &btree[blk->index], sizeof(*btree))); lasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval); } }"
654,2177----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-15128--hugetlb.c----hugetlb_mcopy_atomic_pte,"int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm, pte_t *dst_pte, struct vm_area_struct *dst_vma, unsigned long dst_addr, unsigned long src_addr, struct page **pagep) { int vm_shared = dst_vma->vm_flags & VM_SHARED; struct hstate *h = hstate_vma(dst_vma); pte_t _dst_pte; spinlock_t *ptl; int ret; struct page *page; if (!*pagep) { ret = -ENOMEM; page = alloc_huge_page(dst_vma, dst_addr, 0); if (IS_ERR(page)) goto out; ret = copy_huge_page_from_user(page, (const void __user *) src_addr, pages_per_huge_page(h), false); if (unlikely(ret)) { ret = -EFAULT; *pagep = page; goto out; } } else { page = *pagep; *pagep = NULL; } __SetPageUptodate(page); set_page_huge_active(page); if (vm_shared) { <S2SV_StartVul> struct address_space *mapping = dst_vma->vm_file->f_mapping; <S2SV_EndVul> <S2SV_StartVul> pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr); <S2SV_EndVul> ret = huge_add_to_page_cache(page, mapping, idx); if (ret) goto out_release_nounlock; } ptl = huge_pte_lockptr(h, dst_mm, dst_pte); spin_lock(ptl); ret = -EEXIST; if (!huge_pte_none(huge_ptep_get(dst_pte))) goto out_release_unlock; if (vm_shared) { page_dup_rmap(page, true); } else { ClearPagePrivate(page); hugepage_add_new_anon_rmap(page, dst_vma, dst_addr); } _dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE); if (dst_vma->vm_flags & VM_WRITE) _dst_pte = huge_pte_mkdirty(_dst_pte); _dst_pte = pte_mkyoung(_dst_pte); set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte); (void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte, dst_vma->vm_flags & VM_WRITE); hugetlb_count_add(pages_per_huge_page(h), dst_mm); update_mmu_cache(dst_vma, dst_addr, dst_pte); spin_unlock(ptl); if (vm_shared) unlock_page(page); ret = 0; out: return ret; out_release_unlock: spin_unlock(ptl); if (vm_shared) unlock_page(page); out_release_nounlock: put_page(page); goto out; }","- struct address_space *mapping = dst_vma->vm_file->f_mapping;
- pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr);
+ struct address_space *mapping;
+ pgoff_t idx;
+ unsigned long size;
+ mapping = dst_vma->vm_file->f_mapping;
+ idx = vma_hugecache_offset(h, dst_vma, dst_addr);
+ size = i_size_read(mapping->host) >> huge_page_shift(h);
+ ret = -EFAULT;
+ if (idx >= size)
+ goto out_release_nounlock;
+ size = i_size_read(mapping->host) >> huge_page_shift(h);
+ ret = -EFAULT;
+ if (idx >= size)
+ goto out_release_unlock;","int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm, pte_t *dst_pte, struct vm_area_struct *dst_vma, unsigned long dst_addr, unsigned long src_addr, struct page **pagep) { struct address_space *mapping; pgoff_t idx; unsigned long size; int vm_shared = dst_vma->vm_flags & VM_SHARED; struct hstate *h = hstate_vma(dst_vma); pte_t _dst_pte; spinlock_t *ptl; int ret; struct page *page; if (!*pagep) { ret = -ENOMEM; page = alloc_huge_page(dst_vma, dst_addr, 0); if (IS_ERR(page)) goto out; ret = copy_huge_page_from_user(page, (const void __user *) src_addr, pages_per_huge_page(h), false); if (unlikely(ret)) { ret = -EFAULT; *pagep = page; goto out; } } else { page = *pagep; *pagep = NULL; } __SetPageUptodate(page); set_page_huge_active(page); mapping = dst_vma->vm_file->f_mapping; idx = vma_hugecache_offset(h, dst_vma, dst_addr); if (vm_shared) { size = i_size_read(mapping->host) >> huge_page_shift(h); ret = -EFAULT; if (idx >= size) goto out_release_nounlock; ret = huge_add_to_page_cache(page, mapping, idx); if (ret) goto out_release_nounlock; } ptl = huge_pte_lockptr(h, dst_mm, dst_pte); spin_lock(ptl); size = i_size_read(mapping->host) >> huge_page_shift(h); ret = -EFAULT; if (idx >= size) goto out_release_unlock; ret = -EEXIST; if (!huge_pte_none(huge_ptep_get(dst_pte))) goto out_release_unlock; if (vm_shared) { page_dup_rmap(page, true); } else { ClearPagePrivate(page); hugepage_add_new_anon_rmap(page, dst_vma, dst_addr); } _dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE); if (dst_vma->vm_flags & VM_WRITE) _dst_pte = huge_pte_mkdirty(_dst_pte); _dst_pte = pte_mkyoung(_dst_pte); set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte); (void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte, dst_vma->vm_flags & VM_WRITE); hugetlb_count_add(pages_per_huge_page(h), dst_mm); update_mmu_cache(dst_vma, dst_addr, dst_pte); spin_unlock(ptl); if (vm_shared) unlock_page(page); ret = 0; out: return ret; out_release_unlock: spin_unlock(ptl); if (vm_shared) unlock_page(page); out_release_nounlock: put_page(page); goto out; }"
655,7381----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jpc_dec.c----jpc_dec_tileinit,"static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile) { jpc_dec_tcomp_t *tcomp; int compno; int rlvlno; jpc_dec_rlvl_t *rlvl; jpc_dec_band_t *band; jpc_dec_prc_t *prc; int bndno; jpc_tsfb_band_t *bnd; int bandno; jpc_dec_ccp_t *ccp; int prccnt; jpc_dec_cblk_t *cblk; int cblkcnt; uint_fast32_t tlprcxstart; uint_fast32_t tlprcystart; uint_fast32_t brprcxend; uint_fast32_t brprcyend; uint_fast32_t tlcbgxstart; uint_fast32_t tlcbgystart; uint_fast32_t brcbgxend; uint_fast32_t brcbgyend; uint_fast32_t cbgxstart; uint_fast32_t cbgystart; uint_fast32_t cbgxend; uint_fast32_t cbgyend; uint_fast32_t tlcblkxstart; uint_fast32_t tlcblkystart; uint_fast32_t brcblkxend; uint_fast32_t brcblkyend; uint_fast32_t cblkxstart; uint_fast32_t cblkystart; uint_fast32_t cblkxend; uint_fast32_t cblkyend; uint_fast32_t tmpxstart; uint_fast32_t tmpystart; uint_fast32_t tmpxend; uint_fast32_t tmpyend; jpc_dec_cp_t *cp; <S2SV_StartVul> jpc_tsfb_band_t bnds[64]; <S2SV_EndVul> jpc_pchg_t *pchg; int pchgno; jpc_dec_cmpt_t *cmpt; cp = tile->cp; tile->realmode = 0; if (cp->mctid == JPC_MCT_ICT) { tile->realmode = 1; } for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++tcomp, ++cmpt) { ccp = &tile->cp->ccps[compno]; if (ccp->qmfbid == JPC_COX_INS) { tile->realmode = 1; } tcomp->numrlvls = ccp->numrlvls; if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls, sizeof(jpc_dec_rlvl_t)))) { return -1; } if (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart, cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep), JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend, cmpt->vstep)))) { return -1; } if (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid, tcomp->numrlvls - 1))) { return -1; } { jpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds); } for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls; ++rlvlno, ++rlvl) { rlvl->bands = 0; rlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart, tcomp->numrlvls - 1 - rlvlno); rlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart, tcomp->numrlvls - 1 - rlvlno); rlvl->xend = JPC_CEILDIVPOW2(tcomp->xend, tcomp->numrlvls - 1 - rlvlno); rlvl->yend = JPC_CEILDIVPOW2(tcomp->yend, tcomp->numrlvls - 1 - rlvlno); rlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno]; rlvl->prcheightexpn = ccp->prcheightexpns[rlvlno]; tlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart, rlvl->prcwidthexpn) << rlvl->prcwidthexpn; tlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart, rlvl->prcheightexpn) << rlvl->prcheightexpn; brprcxend = JPC_CEILDIVPOW2(rlvl->xend, rlvl->prcwidthexpn) << rlvl->prcwidthexpn; brprcyend = JPC_CEILDIVPOW2(rlvl->yend, rlvl->prcheightexpn) << rlvl->prcheightexpn; rlvl->numhprcs = (brprcxend - tlprcxstart) >> rlvl->prcwidthexpn; rlvl->numvprcs = (brprcyend - tlprcystart) >> rlvl->prcheightexpn; rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs; if (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) { rlvl->bands = 0; rlvl->numprcs = 0; rlvl->numhprcs = 0; rlvl->numvprcs = 0; continue; } if (!rlvlno) { tlcbgxstart = tlprcxstart; tlcbgystart = tlprcystart; brcbgxend = brprcxend; brcbgyend = brprcyend; rlvl->cbgwidthexpn = rlvl->prcwidthexpn; rlvl->cbgheightexpn = rlvl->prcheightexpn; } else { tlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1); tlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1); brcbgxend = JPC_CEILDIVPOW2(brprcxend, 1); brcbgyend = JPC_CEILDIVPOW2(brprcyend, 1); rlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1; rlvl->cbgheightexpn = rlvl->prcheightexpn - 1; } rlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn, rlvl->cbgwidthexpn); rlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn, rlvl->cbgheightexpn); rlvl->numbands = (!rlvlno) ? 1 : 3; if (!(rlvl->bands = jas_alloc2(rlvl->numbands, sizeof(jpc_dec_band_t)))) { return -1; } for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; ++bandno, ++band) { bndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) + bandno + 1); bnd = &bnds[bndno]; band->orient = bnd->orient; band->stepsize = ccp->stepsizes[bndno]; band->analgain = JPC_NOMINALGAIN(ccp->qmfbid, tcomp->numrlvls - 1, rlvlno, band->orient); band->absstepsize = jpc_calcabsstepsize(band->stepsize, cmpt->prec + band->analgain); band->numbps = ccp->numguardbits + JPC_QCX_GETEXPN(band->stepsize) - 1; band->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ? (JPC_PREC - 1 - band->numbps) : ccp->roishift; band->data = 0; band->prcs = 0; if (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) { continue; } if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) { return -1; } jas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend); jas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart); assert(rlvl->numprcs); if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_dec_prc_t)))) { return -1; } cbgxstart = tlcbgxstart; cbgystart = tlcbgystart; for (prccnt = rlvl->numprcs, prc = band->prcs; prccnt > 0; --prccnt, ++prc) { cbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn); cbgyend = cbgystart + (1 << rlvl->cbgheightexpn); prc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data))); prc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data))); prc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data))); prc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data))); if (prc->xend > prc->xstart && prc->yend > prc->ystart) { tlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart, rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn; tlcblkystart = JPC_FLOORDIVPOW2(prc->ystart, rlvl->cblkheightexpn) << rlvl->cblkheightexpn; brcblkxend = JPC_CEILDIVPOW2(prc->xend, rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn; brcblkyend = JPC_CEILDIVPOW2(prc->yend, rlvl->cblkheightexpn) << rlvl->cblkheightexpn; prc->numhcblks = (brcblkxend - tlcblkxstart) >> rlvl->cblkwidthexpn; prc->numvcblks = (brcblkyend - tlcblkystart) >> rlvl->cblkheightexpn; prc->numcblks = prc->numhcblks * prc->numvcblks; assert(prc->numcblks > 0); if (!(prc->incltagtree = jpc_tagtree_create( prc->numhcblks, prc->numvcblks))) { return -1; } if (!(prc->numimsbstagtree = jpc_tagtree_create( prc->numhcblks, prc->numvcblks))) { return -1; } if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_dec_cblk_t)))) { return -1; } cblkxstart = cbgxstart; cblkystart = cbgystart; for (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) { cblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn); cblkyend = cblkystart + (1 << rlvl->cblkheightexpn); tmpxstart = JAS_MAX(cblkxstart, prc->xstart); tmpystart = JAS_MAX(cblkystart, prc->ystart); tmpxend = JAS_MIN(cblkxend, prc->xend); tmpyend = JAS_MIN(cblkyend, prc->yend); if (tmpxend > tmpxstart && tmpyend > tmpystart) { cblk->firstpassno = -1; cblk->mqdec = 0; cblk->nulldec = 0; cblk->flags = 0; cblk->numpasses = 0; cblk->segs.head = 0; cblk->segs.tail = 0; cblk->curseg = 0; cblk->numimsbs = 0; cblk->numlenbits = 3; cblk->flags = 0; if (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) { return -1; } jas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend); ++cblk; --cblkcnt; } cblkxstart += 1 << rlvl->cblkwidthexpn; if (cblkxstart >= cbgxend) { cblkxstart = cbgxstart; cblkystart += 1 << rlvl->cblkheightexpn; } } } else { prc->cblks = 0; prc->incltagtree = 0; prc->numimsbstagtree = 0; } cbgxstart += 1 << rlvl->cbgwidthexpn; if (cbgxstart >= brcbgxend) { cbgxstart = tlcbgxstart; cbgystart += 1 << rlvl->cbgheightexpn; } } } } } if (!(tile->pi = jpc_dec_pi_create(dec, tile))) { return -1; } for (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist); ++pchgno) { pchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno)); assert(pchg); jpc_pi_addpchg(tile->pi, pchg); } jpc_pi_init(tile->pi); return 0; }","- jpc_tsfb_band_t bnds[64];
+ jpc_tsfb_band_t bnds[JPC_MAXBANDS];","static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile) { jpc_dec_tcomp_t *tcomp; int compno; int rlvlno; jpc_dec_rlvl_t *rlvl; jpc_dec_band_t *band; jpc_dec_prc_t *prc; int bndno; jpc_tsfb_band_t *bnd; int bandno; jpc_dec_ccp_t *ccp; int prccnt; jpc_dec_cblk_t *cblk; int cblkcnt; uint_fast32_t tlprcxstart; uint_fast32_t tlprcystart; uint_fast32_t brprcxend; uint_fast32_t brprcyend; uint_fast32_t tlcbgxstart; uint_fast32_t tlcbgystart; uint_fast32_t brcbgxend; uint_fast32_t brcbgyend; uint_fast32_t cbgxstart; uint_fast32_t cbgystart; uint_fast32_t cbgxend; uint_fast32_t cbgyend; uint_fast32_t tlcblkxstart; uint_fast32_t tlcblkystart; uint_fast32_t brcblkxend; uint_fast32_t brcblkyend; uint_fast32_t cblkxstart; uint_fast32_t cblkystart; uint_fast32_t cblkxend; uint_fast32_t cblkyend; uint_fast32_t tmpxstart; uint_fast32_t tmpystart; uint_fast32_t tmpxend; uint_fast32_t tmpyend; jpc_dec_cp_t *cp; jpc_tsfb_band_t bnds[JPC_MAXBANDS]; jpc_pchg_t *pchg; int pchgno; jpc_dec_cmpt_t *cmpt; cp = tile->cp; tile->realmode = 0; if (cp->mctid == JPC_MCT_ICT) { tile->realmode = 1; } for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++tcomp, ++cmpt) { ccp = &tile->cp->ccps[compno]; if (ccp->qmfbid == JPC_COX_INS) { tile->realmode = 1; } tcomp->numrlvls = ccp->numrlvls; if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls, sizeof(jpc_dec_rlvl_t)))) { return -1; } if (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart, cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep), JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend, cmpt->vstep)))) { return -1; } if (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid, tcomp->numrlvls - 1))) { return -1; } { jpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds); } for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls; ++rlvlno, ++rlvl) { rlvl->bands = 0; rlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart, tcomp->numrlvls - 1 - rlvlno); rlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart, tcomp->numrlvls - 1 - rlvlno); rlvl->xend = JPC_CEILDIVPOW2(tcomp->xend, tcomp->numrlvls - 1 - rlvlno); rlvl->yend = JPC_CEILDIVPOW2(tcomp->yend, tcomp->numrlvls - 1 - rlvlno); rlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno]; rlvl->prcheightexpn = ccp->prcheightexpns[rlvlno]; tlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart, rlvl->prcwidthexpn) << rlvl->prcwidthexpn; tlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart, rlvl->prcheightexpn) << rlvl->prcheightexpn; brprcxend = JPC_CEILDIVPOW2(rlvl->xend, rlvl->prcwidthexpn) << rlvl->prcwidthexpn; brprcyend = JPC_CEILDIVPOW2(rlvl->yend, rlvl->prcheightexpn) << rlvl->prcheightexpn; rlvl->numhprcs = (brprcxend - tlprcxstart) >> rlvl->prcwidthexpn; rlvl->numvprcs = (brprcyend - tlprcystart) >> rlvl->prcheightexpn; rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs; if (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) { rlvl->bands = 0; rlvl->numprcs = 0; rlvl->numhprcs = 0; rlvl->numvprcs = 0; continue; } if (!rlvlno) { tlcbgxstart = tlprcxstart; tlcbgystart = tlprcystart; brcbgxend = brprcxend; brcbgyend = brprcyend; rlvl->cbgwidthexpn = rlvl->prcwidthexpn; rlvl->cbgheightexpn = rlvl->prcheightexpn; } else { tlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1); tlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1); brcbgxend = JPC_CEILDIVPOW2(brprcxend, 1); brcbgyend = JPC_CEILDIVPOW2(brprcyend, 1); rlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1; rlvl->cbgheightexpn = rlvl->prcheightexpn - 1; } rlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn, rlvl->cbgwidthexpn); rlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn, rlvl->cbgheightexpn); rlvl->numbands = (!rlvlno) ? 1 : 3; if (!(rlvl->bands = jas_alloc2(rlvl->numbands, sizeof(jpc_dec_band_t)))) { return -1; } for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; ++bandno, ++band) { bndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) + bandno + 1); bnd = &bnds[bndno]; band->orient = bnd->orient; band->stepsize = ccp->stepsizes[bndno]; band->analgain = JPC_NOMINALGAIN(ccp->qmfbid, tcomp->numrlvls - 1, rlvlno, band->orient); band->absstepsize = jpc_calcabsstepsize(band->stepsize, cmpt->prec + band->analgain); band->numbps = ccp->numguardbits + JPC_QCX_GETEXPN(band->stepsize) - 1; band->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ? (JPC_PREC - 1 - band->numbps) : ccp->roishift; band->data = 0; band->prcs = 0; if (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) { continue; } if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) { return -1; } jas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend); jas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart); assert(rlvl->numprcs); if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_dec_prc_t)))) { return -1; } cbgxstart = tlcbgxstart; cbgystart = tlcbgystart; for (prccnt = rlvl->numprcs, prc = band->prcs; prccnt > 0; --prccnt, ++prc) { cbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn); cbgyend = cbgystart + (1 << rlvl->cbgheightexpn); prc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data))); prc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data))); prc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data))); prc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data))); if (prc->xend > prc->xstart && prc->yend > prc->ystart) { tlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart, rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn; tlcblkystart = JPC_FLOORDIVPOW2(prc->ystart, rlvl->cblkheightexpn) << rlvl->cblkheightexpn; brcblkxend = JPC_CEILDIVPOW2(prc->xend, rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn; brcblkyend = JPC_CEILDIVPOW2(prc->yend, rlvl->cblkheightexpn) << rlvl->cblkheightexpn; prc->numhcblks = (brcblkxend - tlcblkxstart) >> rlvl->cblkwidthexpn; prc->numvcblks = (brcblkyend - tlcblkystart) >> rlvl->cblkheightexpn; prc->numcblks = prc->numhcblks * prc->numvcblks; assert(prc->numcblks > 0); if (!(prc->incltagtree = jpc_tagtree_create( prc->numhcblks, prc->numvcblks))) { return -1; } if (!(prc->numimsbstagtree = jpc_tagtree_create( prc->numhcblks, prc->numvcblks))) { return -1; } if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_dec_cblk_t)))) { return -1; } cblkxstart = cbgxstart; cblkystart = cbgystart; for (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) { cblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn); cblkyend = cblkystart + (1 << rlvl->cblkheightexpn); tmpxstart = JAS_MAX(cblkxstart, prc->xstart); tmpystart = JAS_MAX(cblkystart, prc->ystart); tmpxend = JAS_MIN(cblkxend, prc->xend); tmpyend = JAS_MIN(cblkyend, prc->yend); if (tmpxend > tmpxstart && tmpyend > tmpystart) { cblk->firstpassno = -1; cblk->mqdec = 0; cblk->nulldec = 0; cblk->flags = 0; cblk->numpasses = 0; cblk->segs.head = 0; cblk->segs.tail = 0; cblk->curseg = 0; cblk->numimsbs = 0; cblk->numlenbits = 3; cblk->flags = 0; if (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) { return -1; } jas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend); ++cblk; --cblkcnt; } cblkxstart += 1 << rlvl->cblkwidthexpn; if (cblkxstart >= cbgxend) { cblkxstart = cbgxstart; cblkystart += 1 << rlvl->cblkheightexpn; } } } else { prc->cblks = 0; prc->incltagtree = 0; prc->numimsbstagtree = 0; } cbgxstart += 1 << rlvl->cbgwidthexpn; if (cbgxstart >= brcbgxend) { cbgxstart = tlcbgxstart; cbgystart += 1 << rlvl->cbgheightexpn; } } } } } if (!(tile->pi = jpc_dec_pi_create(dec, tile))) { return -1; } for (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist); ++pchgno) { pchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno)); assert(pchg); jpc_pi_addpchg(tile->pi, pchg); } jpc_pi_init(tile->pi); return 0; }"
656,4199----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/parser.c----xmlParseNameComplex,"xmlParseNameComplex(xmlParserCtxtPtr ctxt) { int len = 0, l; int c; int count = 0; #ifdef DEBUG nbParseNameComplex++; #endif GROW; if (ctxt->instate == XML_PARSER_EOF) return(NULL); c = CUR_CHAR(l); if ((ctxt->options & XML_PARSE_OLD10) == 0) { if ((c == ' ') || (c == '>') || (c == '/') || (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || (c == '_') || (c == ':') || ((c >= 0xC0) && (c <= 0xD6)) || ((c >= 0xD8) && (c <= 0xF6)) || ((c >= 0xF8) && (c <= 0x2FF)) || ((c >= 0x370) && (c <= 0x37D)) || ((c >= 0x37F) && (c <= 0x1FFF)) || ((c >= 0x200C) && (c <= 0x200D)) || ((c >= 0x2070) && (c <= 0x218F)) || ((c >= 0x2C00) && (c <= 0x2FEF)) || ((c >= 0x3001) && (c <= 0xD7FF)) || ((c >= 0xF900) && (c <= 0xFDCF)) || ((c >= 0xFDF0) && (c <= 0xFFFD)) || ((c >= 0x10000) && (c <= 0xEFFFF))))) { return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); while ((c != ' ') && (c != '>') && (c != '/') && (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || ((c >= '0') && (c <= '9')) || (c == '_') || (c == ':') || (c == '-') || (c == '.') || (c == 0xB7) || ((c >= 0xC0) && (c <= 0xD6)) || ((c >= 0xD8) && (c <= 0xF6)) || ((c >= 0xF8) && (c <= 0x2FF)) || ((c >= 0x300) && (c <= 0x36F)) || ((c >= 0x370) && (c <= 0x37D)) || ((c >= 0x37F) && (c <= 0x1FFF)) || ((c >= 0x200C) && (c <= 0x200D)) || ((c >= 0x203F) && (c <= 0x2040)) || ((c >= 0x2070) && (c <= 0x218F)) || ((c >= 0x2C00) && (c <= 0x2FEF)) || ((c >= 0x3001) && (c <= 0xD7FF)) || ((c >= 0xF900) && (c <= 0xFDCF)) || ((c >= 0xFDF0) && (c <= 0xFFFD)) || ((c >= 0x10000) && (c <= 0xEFFFF)) )) { if (count++ > XML_PARSER_CHUNK_SIZE) { count = 0; GROW; if (ctxt->instate == XML_PARSER_EOF) return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); } } else { if ((c == ' ') || (c == '>') || (c == '/') || (!IS_LETTER(c) && (c != '_') && (c != ':'))) { return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); while ((c != ' ') && (c != '>') && (c != '/') && ((IS_LETTER(c)) || (IS_DIGIT(c)) || (c == '.') || (c == '-') || (c == '_') || (c == ':') || (IS_COMBINING(c)) || (IS_EXTENDER(c)))) { if (count++ > XML_PARSER_CHUNK_SIZE) { count = 0; GROW; if (ctxt->instate == XML_PARSER_EOF) return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); <S2SV_StartVul> if (c == 0) { <S2SV_EndVul> <S2SV_StartVul> count = 0; <S2SV_EndVul> <S2SV_StartVul> GROW; <S2SV_EndVul> <S2SV_StartVul> if (ctxt->instate == XML_PARSER_EOF) <S2SV_EndVul> <S2SV_StartVul> return(NULL); <S2SV_EndVul> <S2SV_StartVul> c = CUR_CHAR(l); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } } if ((len > XML_MAX_NAME_LENGTH) && ((ctxt->options & XML_PARSE_HUGE) == 0)) { xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, ""Name""); return(NULL); } if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r')) return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len)); return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len)); }","- if (c == 0) {
- count = 0;
- GROW;
- if (ctxt->instate == XML_PARSER_EOF)
- return(NULL);
- c = CUR_CHAR(l);
- }
+ if (ctxt->input->cur - ctxt->input->base < len) {
+ xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
+ ""unexpected change of input buffer"");
+ return (NULL);
+ }","xmlParseNameComplex(xmlParserCtxtPtr ctxt) { int len = 0, l; int c; int count = 0; #ifdef DEBUG nbParseNameComplex++; #endif GROW; if (ctxt->instate == XML_PARSER_EOF) return(NULL); c = CUR_CHAR(l); if ((ctxt->options & XML_PARSE_OLD10) == 0) { if ((c == ' ') || (c == '>') || (c == '/') || (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || (c == '_') || (c == ':') || ((c >= 0xC0) && (c <= 0xD6)) || ((c >= 0xD8) && (c <= 0xF6)) || ((c >= 0xF8) && (c <= 0x2FF)) || ((c >= 0x370) && (c <= 0x37D)) || ((c >= 0x37F) && (c <= 0x1FFF)) || ((c >= 0x200C) && (c <= 0x200D)) || ((c >= 0x2070) && (c <= 0x218F)) || ((c >= 0x2C00) && (c <= 0x2FEF)) || ((c >= 0x3001) && (c <= 0xD7FF)) || ((c >= 0xF900) && (c <= 0xFDCF)) || ((c >= 0xFDF0) && (c <= 0xFFFD)) || ((c >= 0x10000) && (c <= 0xEFFFF))))) { return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); while ((c != ' ') && (c != '>') && (c != '/') && (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || ((c >= '0') && (c <= '9')) || (c == '_') || (c == ':') || (c == '-') || (c == '.') || (c == 0xB7) || ((c >= 0xC0) && (c <= 0xD6)) || ((c >= 0xD8) && (c <= 0xF6)) || ((c >= 0xF8) && (c <= 0x2FF)) || ((c >= 0x300) && (c <= 0x36F)) || ((c >= 0x370) && (c <= 0x37D)) || ((c >= 0x37F) && (c <= 0x1FFF)) || ((c >= 0x200C) && (c <= 0x200D)) || ((c >= 0x203F) && (c <= 0x2040)) || ((c >= 0x2070) && (c <= 0x218F)) || ((c >= 0x2C00) && (c <= 0x2FEF)) || ((c >= 0x3001) && (c <= 0xD7FF)) || ((c >= 0xF900) && (c <= 0xFDCF)) || ((c >= 0xFDF0) && (c <= 0xFFFD)) || ((c >= 0x10000) && (c <= 0xEFFFF)) )) { if (count++ > XML_PARSER_CHUNK_SIZE) { count = 0; GROW; if (ctxt->instate == XML_PARSER_EOF) return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); } } else { if ((c == ' ') || (c == '>') || (c == '/') || (!IS_LETTER(c) && (c != '_') && (c != ':'))) { return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); while ((c != ' ') && (c != '>') && (c != '/') && ((IS_LETTER(c)) || (IS_DIGIT(c)) || (c == '.') || (c == '-') || (c == '_') || (c == ':') || (IS_COMBINING(c)) || (IS_EXTENDER(c)))) { if (count++ > XML_PARSER_CHUNK_SIZE) { count = 0; GROW; if (ctxt->instate == XML_PARSER_EOF) return(NULL); } len += l; NEXTL(l); c = CUR_CHAR(l); } } if ((len > XML_MAX_NAME_LENGTH) && ((ctxt->options & XML_PARSE_HUGE) == 0)) { xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, ""Name""); return(NULL); } if (ctxt->input->cur - ctxt->input->base < len) { xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, ""unexpected change of input buffer""); return (NULL); } if ((*ctxt->input->cur == '\n') && (ctxt->input->cur[-1] == '\r')) return(xmlDictLookup(ctxt->dict, ctxt->input->cur - (len + 1), len)); return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len)); }"
657,5883----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ext2.c----grub_ext2_iterate_dir,"grub_ext2_iterate_dir (grub_fshelp_node_t dir, int (*hook) (const char *filename, enum grub_fshelp_filetype filetype, grub_fshelp_node_t node, void *closure), void *closure) { unsigned int fpos = 0; struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir; if (! diro->inode_read) { grub_ext2_read_inode (diro->data, diro->ino, &diro->inode); if (grub_errno) return 0; } if (hook) while (fpos < grub_le_to_cpu32 (diro->inode.size)) { struct ext2_dirent dirent; grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent), (char *) &dirent); if (grub_errno) return 0; if (dirent.direntlen == 0) return 0; if (dirent.namelen != 0) { <S2SV_StartVul> #ifndef _MSC_VER <S2SV_EndVul> <S2SV_StartVul> char filename[dirent.namelen + 1]; <S2SV_EndVul> <S2SV_StartVul> #else <S2SV_EndVul> char * filename = grub_malloc (dirent.namelen + 1); <S2SV_StartVul> #endif <S2SV_EndVul> struct grub_fshelp_node *fdiro; enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN; grub_ext2_read_file (diro, 0, 0, 0, fpos + sizeof (struct ext2_dirent), dirent.namelen, filename); <S2SV_StartVul> if (grub_errno) <S2SV_EndVul> return 0; fdiro = grub_malloc (sizeof (struct grub_fshelp_node)); <S2SV_StartVul> if (! fdiro) <S2SV_EndVul> return 0; fdiro->data = diro->data; fdiro->ino = grub_le_to_cpu32 (dirent.inode); filename[dirent.namelen] = '\0'; if (dirent.filetype != FILETYPE_UNKNOWN) { fdiro->inode_read = 0; if (dirent.filetype == FILETYPE_DIRECTORY) type = GRUB_FSHELP_DIR; else if (dirent.filetype == FILETYPE_SYMLINK) type = GRUB_FSHELP_SYMLINK; else if (dirent.filetype == FILETYPE_REG) type = GRUB_FSHELP_REG; } else { grub_ext2_read_inode (diro->data, grub_le_to_cpu32 (dirent.inode), &fdiro->inode); <S2SV_StartVul> if (grub_errno) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> grub_free (fdiro); return 0; } fdiro->inode_read = 1; if ((grub_le_to_cpu16 (fdiro->inode.mode) & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY) type = GRUB_FSHELP_DIR; else if ((grub_le_to_cpu16 (fdiro->inode.mode) & FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK) type = GRUB_FSHELP_SYMLINK; else if ((grub_le_to_cpu16 (fdiro->inode.mode) & FILETYPE_INO_MASK) == FILETYPE_INO_REG) type = GRUB_FSHELP_REG; } <S2SV_StartVul> if (hook (filename, type, fdiro, closure)) <S2SV_EndVul> return 1; } fpos += grub_le_to_cpu16 (dirent.direntlen); } return 0; }","- #ifndef _MSC_VER
- char filename[dirent.namelen + 1];
- #else
- #endif
- if (grub_errno)
- if (! fdiro)
- if (grub_errno)
- {
- if (hook (filename, type, fdiro, closure))
+ if (!filename) {
+ break;
+ }
+ if (grub_errno) {
+ free (filename);
+ }
+ if (! fdiro) {
+ free (filename);
+ }
+ if (grub_errno) {
+ free (filename);
+ if (hook (filename, type, fdiro, closure)) {
+ free (filename);
+ }
+ free (filename);","grub_ext2_iterate_dir (grub_fshelp_node_t dir, int (*hook) (const char *filename, enum grub_fshelp_filetype filetype, grub_fshelp_node_t node, void *closure), void *closure) { unsigned int fpos = 0; struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir; if (! diro->inode_read) { grub_ext2_read_inode (diro->data, diro->ino, &diro->inode); if (grub_errno) return 0; } if (hook) while (fpos < grub_le_to_cpu32 (diro->inode.size)) { struct ext2_dirent dirent; grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent), (char *) &dirent); if (grub_errno) return 0; if (dirent.direntlen == 0) return 0; if (dirent.namelen != 0) { char * filename = grub_malloc (dirent.namelen + 1); struct grub_fshelp_node *fdiro; enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN; if (!filename) { break; } grub_ext2_read_file (diro, 0, 0, 0, fpos + sizeof (struct ext2_dirent), dirent.namelen, filename); if (grub_errno) { free (filename); return 0; } fdiro = grub_malloc (sizeof (struct grub_fshelp_node)); if (! fdiro) { free (filename); return 0; } fdiro->data = diro->data; fdiro->ino = grub_le_to_cpu32 (dirent.inode); filename[dirent.namelen] = '\0'; if (dirent.filetype != FILETYPE_UNKNOWN) { fdiro->inode_read = 0; if (dirent.filetype == FILETYPE_DIRECTORY) type = GRUB_FSHELP_DIR; else if (dirent.filetype == FILETYPE_SYMLINK) type = GRUB_FSHELP_SYMLINK; else if (dirent.filetype == FILETYPE_REG) type = GRUB_FSHELP_REG; } else { grub_ext2_read_inode (diro->data, grub_le_to_cpu32 (dirent.inode), &fdiro->inode); if (grub_errno) { free (filename); grub_free (fdiro); return 0; } fdiro->inode_read = 1; if ((grub_le_to_cpu16 (fdiro->inode.mode) & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY) type = GRUB_FSHELP_DIR; else if ((grub_le_to_cpu16 (fdiro->inode.mode) & FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK) type = GRUB_FSHELP_SYMLINK; else if ((grub_le_to_cpu16 (fdiro->inode.mode) & FILETYPE_INO_MASK) == FILETYPE_INO_REG) type = GRUB_FSHELP_REG; } if (hook (filename, type, fdiro, closure)) { free (filename); return 1; } free (filename); } fpos += grub_le_to_cpu16 (dirent.direntlen); } return 0; }"
658,3937----CWE-326----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/flash.c----flash_option_bytes_init,void flash_option_bytes_init(int boot_from_dfu) { uint32_t val = 0xfffff8aa; if (boot_from_dfu){ val &= ~(1<<27); } else { if (solo_is_locked()) { val = 0xfffff8cc; } } val &= ~(1<<26); val &= ~(1<<25); val &= ~(1<<24); if (FLASH->OPTR == val) { return; } __disable_irq(); while (FLASH->SR & (1<<16)) ; flash_unlock(); if (FLASH->CR & (1<<30)) { FLASH->OPTKEYR = 0x08192A3B; FLASH->OPTKEYR = 0x4C5D6E7F; } FLASH->OPTR =val; FLASH->CR |= (1<<17); while (FLASH->SR & (1<<16)) ; flash_lock(); <S2SV_StartVul> __enable_irq(); <S2SV_EndVul> },"- __enable_irq();
+ FLASH->CR |= FLASH_CR_OBL_LAUNCH;
+ while (true);",void flash_option_bytes_init(int boot_from_dfu) { uint32_t val = 0xfffff8aa; if (boot_from_dfu){ val &= ~(1<<27); } else { if (solo_is_locked()) { val = 0xfffff8cc; } } val &= ~(1<<26); val &= ~(1<<25); val &= ~(1<<24); if (FLASH->OPTR == val) { return; } __disable_irq(); while (FLASH->SR & (1<<16)) ; flash_unlock(); if (FLASH->CR & (1<<30)) { FLASH->OPTKEYR = 0x08192A3B; FLASH->OPTKEYR = 0x4C5D6E7F; } FLASH->OPTR =val; FLASH->CR |= (1<<17); while (FLASH->SR & (1<<16)) ; flash_lock(); FLASH->CR |= FLASH_CR_OBL_LAUNCH; while (true); }
659,6508----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-juniper.c----juniper_mlppp_print,"juniper_mlppp_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { struct juniper_l2info_t l2info; l2info.pictype = DLT_JUNIPER_MLPPP; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; if (ndo->ndo_eflag && EXTRACT_16BITS(&l2info.cookie) != PPP_OSI && EXTRACT_16BITS(&l2info.cookie) != (PPP_ADDRESS << 8 | PPP_CONTROL)) ND_PRINT((ndo, ""Bundle-ID %u: "", l2info.bundle)); p+=l2info.header_len; switch(l2info.proto) { case JUNIPER_LSQ_L3_PROTO_IPV4: if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR)) ppp_print(ndo, p, l2info.length); else ip_print(ndo, p, l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_IPV6: ip6_print(ndo, p,l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_MPLS: mpls_print(ndo, p, l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_ISO: <S2SV_StartVul> isoclns_print(ndo, p, l2info.length, l2info.caplen); <S2SV_EndVul> return l2info.header_len; default: break; } switch (EXTRACT_16BITS(&l2info.cookie)) { case PPP_OSI: ppp_print(ndo, p - 2, l2info.length + 2); break; case (PPP_ADDRESS << 8 | PPP_CONTROL): default: ppp_print(ndo, p, l2info.length); break; } return l2info.header_len; }","- isoclns_print(ndo, p, l2info.length, l2info.caplen);
+ isoclns_print(ndo, p, l2info.length);","juniper_mlppp_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { struct juniper_l2info_t l2info; l2info.pictype = DLT_JUNIPER_MLPPP; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; if (ndo->ndo_eflag && EXTRACT_16BITS(&l2info.cookie) != PPP_OSI && EXTRACT_16BITS(&l2info.cookie) != (PPP_ADDRESS << 8 | PPP_CONTROL)) ND_PRINT((ndo, ""Bundle-ID %u: "", l2info.bundle)); p+=l2info.header_len; switch(l2info.proto) { case JUNIPER_LSQ_L3_PROTO_IPV4: if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR)) ppp_print(ndo, p, l2info.length); else ip_print(ndo, p, l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_IPV6: ip6_print(ndo, p,l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_MPLS: mpls_print(ndo, p, l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_ISO: isoclns_print(ndo, p, l2info.length); return l2info.header_len; default: break; } switch (EXTRACT_16BITS(&l2info.cookie)) { case PPP_OSI: ppp_print(ndo, p - 2, l2info.length + 2); break; case (PPP_ADDRESS << 8 | PPP_CONTROL): default: ppp_print(ndo, p, l2info.length); break; } return l2info.header_len; }"
660,3925----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ntlm_av_pairs.c----ntlm_av_pair_get_id,"<S2SV_StartVul> static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair) <S2SV_EndVul> { UINT16 AvId; Data_Read_UINT16(&pAvPair->AvId, AvId); <S2SV_StartVul> return AvId; <S2SV_EndVul> }","- static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)
- return AvId;
+ static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)
+ if (!pAvPair || !pair)
+ return FALSE;
+ if (size < sizeof(NTLM_AV_PAIR))
+ return FALSE;
+ return TRUE;","static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair) { UINT16 AvId; if (!pAvPair || !pair) return FALSE; if (size < sizeof(NTLM_AV_PAIR)) return FALSE; Data_Read_UINT16(&pAvPair->AvId, AvId); *pair = AvId; return TRUE; }"
661,5982----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ZlibOutStream.cxx----ZlibOutStream::overrun,"<S2SV_StartVul> int ZlibOutStream::overrun(int itemSize, int nItems) <S2SV_EndVul> { #ifdef ZLIBOUT_DEBUG vlog.debug(""overrun""); #endif if (itemSize > bufSize) throw Exception(""ZlibOutStream overrun: max itemSize exceeded""); checkCompressionLevel(); <S2SV_StartVul> while (end - ptr < itemSize) { <S2SV_EndVul> zs->next_in = start; zs->avail_in = ptr - start; deflate(Z_NO_FLUSH); if (zs->avail_in == 0) { offset += ptr - start; ptr = start; } else { vlog.info(""z out buf not full, but in data not consumed""); memmove(start, zs->next_in, ptr - zs->next_in); offset += zs->next_in - start; ptr -= zs->next_in - start; } } <S2SV_StartVul> if (itemSize * nItems > end - ptr) <S2SV_EndVul> nItems = (end - ptr) / itemSize; return nItems; }","- int ZlibOutStream::overrun(int itemSize, int nItems)
- while (end - ptr < itemSize) {
- if (itemSize * nItems > end - ptr)
+ size_t ZlibOutStream::overrun(size_t itemSize, size_t nItems)
+ while ((size_t)(end - ptr) < itemSize) {
+ if (itemSize * nItems > (size_t)(end - ptr))","size_t ZlibOutStream::overrun(size_t itemSize, size_t nItems) { #ifdef ZLIBOUT_DEBUG vlog.debug(""overrun""); #endif if (itemSize > bufSize) throw Exception(""ZlibOutStream overrun: max itemSize exceeded""); checkCompressionLevel(); while ((size_t)(end - ptr) < itemSize) { zs->next_in = start; zs->avail_in = ptr - start; deflate(Z_NO_FLUSH); if (zs->avail_in == 0) { offset += ptr - start; ptr = start; } else { vlog.info(""z out buf not full, but in data not consumed""); memmove(start, zs->next_in, ptr - zs->next_in); offset += zs->next_in - start; ptr -= zs->next_in - start; } } if (itemSize * nItems > (size_t)(end - ptr)) nItems = (end - ptr) / itemSize; return nItems; }"
662,5568----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/FontFileBase.h----NSFontConverter::CFontFileBase::CFontFileBase,"CFontFileBase(char *sFile, int nLen, bool bFreeFileData) { m_sFileData = m_sFile = (unsigned char *)sFile; <S2SV_StartVul> m_nLen = nLen; <S2SV_EndVul> <S2SV_StartVul> m_bFreeFileData = bFreeFileData; <S2SV_EndVul> m_nPos = 0; }","- m_nLen = nLen;
- m_bFreeFileData = bFreeFileData;
+ m_nLen = (nLen > 0) ? 0 : (unsigned int)nLen;
+ m_bFreeFileData = bFreeFileData;","CFontFileBase(char *sFile, int nLen, bool bFreeFileData) { m_sFileData = m_sFile = (unsigned char *)sFile; m_nLen = (nLen > 0) ? 0 : (unsigned int)nLen; m_nPos = 0; m_bFreeFileData = bFreeFileData; }"
663,4711----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/envoy_quic_proof_source_test.cc----Envoy::Quic::SignatureVerifier::SignatureVerifier,"SignatureVerifier() { ON_CALL(client_context_config_, cipherSuites) .WillByDefault(ReturnRef( Extensions::TransportSockets::Tls::ClientContextConfigImpl::DEFAULT_CIPHER_SUITES)); ON_CALL(client_context_config_, ecdhCurves) .WillByDefault( ReturnRef(Extensions::TransportSockets::Tls::ClientContextConfigImpl::DEFAULT_CURVES)); const std::string alpn(""h2,http/1.1""); ON_CALL(client_context_config_, alpnProtocols()).WillByDefault(ReturnRef(alpn)); const std::string empty_string; ON_CALL(client_context_config_, serverNameIndication()).WillByDefault(ReturnRef(empty_string)); ON_CALL(client_context_config_, signingAlgorithmsForTest()) .WillByDefault(ReturnRef(empty_string)); ON_CALL(client_context_config_, certificateValidationContext()) .WillByDefault(Return(&cert_validation_ctx_config_)); std::string cert_chain(quic::test::kTestCertificateChainPem); const std::string& root_ca_cert = cert_chain.substr(cert_chain.rfind(""-----BEGIN CERTIFICATE-----"")); const std::string path_string(""some_path""); ON_CALL(cert_validation_ctx_config_, caCert()).WillByDefault(ReturnRef(root_ca_cert)); ON_CALL(cert_validation_ctx_config_, caCertPath()).WillByDefault(ReturnRef(path_string)); ON_CALL(cert_validation_ctx_config_, trustChainVerification) .WillByDefault(Return(envoy::extensions::transport_sockets::tls::v3:: CertificateValidationContext::VERIFY_TRUST_CHAIN)); ON_CALL(cert_validation_ctx_config_, allowExpiredCertificate()).WillByDefault(Return(true)); const std::string crl_list; ON_CALL(cert_validation_ctx_config_, certificateRevocationList()) .WillByDefault(ReturnRef(crl_list)); ON_CALL(cert_validation_ctx_config_, certificateRevocationListPath()) .WillByDefault(ReturnRef(path_string)); const std::vector<std::string> empty_string_list; <S2SV_StartVul> const std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers; <S2SV_EndVul> ON_CALL(cert_validation_ctx_config_, subjectAltNameMatchers()) .WillByDefault(ReturnRef(san_matchers)); ON_CALL(cert_validation_ctx_config_, verifyCertificateHashList()) .WillByDefault(ReturnRef(empty_string_list)); ON_CALL(cert_validation_ctx_config_, verifyCertificateSpkiList()) .WillByDefault(ReturnRef(empty_string_list)); const absl::optional<envoy::config::core::v3::TypedExtensionConfig> nullopt = absl::nullopt; ON_CALL(cert_validation_ctx_config_, customValidatorConfig()).WillByDefault(ReturnRef(nullopt)); auto context = std::make_shared<Extensions::TransportSockets::Tls::ClientContextImpl>( store_, client_context_config_, time_system_); verifier_ = std::make_unique<EnvoyQuicProofVerifier>(std::move(context)); }","- const std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers;
+ const std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>
+ san_matchers;","SignatureVerifier() { ON_CALL(client_context_config_, cipherSuites) .WillByDefault(ReturnRef( Extensions::TransportSockets::Tls::ClientContextConfigImpl::DEFAULT_CIPHER_SUITES)); ON_CALL(client_context_config_, ecdhCurves) .WillByDefault( ReturnRef(Extensions::TransportSockets::Tls::ClientContextConfigImpl::DEFAULT_CURVES)); const std::string alpn(""h2,http/1.1""); ON_CALL(client_context_config_, alpnProtocols()).WillByDefault(ReturnRef(alpn)); const std::string empty_string; ON_CALL(client_context_config_, serverNameIndication()).WillByDefault(ReturnRef(empty_string)); ON_CALL(client_context_config_, signingAlgorithmsForTest()) .WillByDefault(ReturnRef(empty_string)); ON_CALL(client_context_config_, certificateValidationContext()) .WillByDefault(Return(&cert_validation_ctx_config_)); std::string cert_chain(quic::test::kTestCertificateChainPem); const std::string& root_ca_cert = cert_chain.substr(cert_chain.rfind(""-----BEGIN CERTIFICATE-----"")); const std::string path_string(""some_path""); ON_CALL(cert_validation_ctx_config_, caCert()).WillByDefault(ReturnRef(root_ca_cert)); ON_CALL(cert_validation_ctx_config_, caCertPath()).WillByDefault(ReturnRef(path_string)); ON_CALL(cert_validation_ctx_config_, trustChainVerification) .WillByDefault(Return(envoy::extensions::transport_sockets::tls::v3:: CertificateValidationContext::VERIFY_TRUST_CHAIN)); ON_CALL(cert_validation_ctx_config_, allowExpiredCertificate()).WillByDefault(Return(true)); const std::string crl_list; ON_CALL(cert_validation_ctx_config_, certificateRevocationList()) .WillByDefault(ReturnRef(crl_list)); ON_CALL(cert_validation_ctx_config_, certificateRevocationListPath()) .WillByDefault(ReturnRef(path_string)); const std::vector<std::string> empty_string_list; const std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher> san_matchers; ON_CALL(cert_validation_ctx_config_, subjectAltNameMatchers()) .WillByDefault(ReturnRef(san_matchers)); ON_CALL(cert_validation_ctx_config_, verifyCertificateHashList()) .WillByDefault(ReturnRef(empty_string_list)); ON_CALL(cert_validation_ctx_config_, verifyCertificateSpkiList()) .WillByDefault(ReturnRef(empty_string_list)); const absl::optional<envoy::config::core::v3::TypedExtensionConfig> nullopt = absl::nullopt; ON_CALL(cert_validation_ctx_config_, customValidatorConfig()).WillByDefault(ReturnRef(nullopt)); auto context = std::make_shared<Extensions::TransportSockets::Tls::ClientContextImpl>( store_, client_context_config_, time_system_); verifier_ = std::make_unique<EnvoyQuicProofVerifier>(std::move(context)); }"
664,2755----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----perf_event_output,"<S2SV_StartVul> static void perf_event_output(struct perf_event *event, int nmi, <S2SV_EndVul> struct perf_sample_data *data, struct pt_regs *regs) { struct perf_output_handle handle; struct perf_event_header header; rcu_read_lock(); perf_prepare_sample(&header, data, event, regs); <S2SV_StartVul> if (perf_output_begin(&handle, event, header.size, nmi, 1)) <S2SV_EndVul> goto exit; perf_output_sample(&handle, &header, data, event); perf_output_end(&handle); exit: rcu_read_unlock(); }","- static void perf_event_output(struct perf_event *event, int nmi,
- if (perf_output_begin(&handle, event, header.size, nmi, 1))
+ static void perf_event_output(struct perf_event *event,
+ if (perf_output_begin(&handle, event, header.size, 1))","static void perf_event_output(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { struct perf_output_handle handle; struct perf_event_header header; rcu_read_lock(); perf_prepare_sample(&header, data, event, regs); if (perf_output_begin(&handle, event, header.size, 1)) goto exit; perf_output_sample(&handle, &header, data, event); perf_output_end(&handle); exit: rcu_read_unlock(); }"
665,2044----CWE-190----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-11219--lua_struct.c----b_unpack,"static int b_unpack (lua_State *L) { Header h; const char *fmt = luaL_checkstring(L, 1); size_t ld; const char *data = luaL_checklstring(L, 2, &ld); <S2SV_StartVul> size_t pos = luaL_optinteger(L, 3, 1) - 1; <S2SV_EndVul> int n = 0; defaultoptions(&h); while (*fmt) { int opt = *fmt++; size_t size = optsize(L, opt, &fmt); pos += gettoalign(pos, &h, opt, size); <S2SV_StartVul> luaL_argcheck(L, pos+size <= ld, 2, ""data string too short""); <S2SV_EndVul> luaL_checkstack(L, 2, ""too many results""); switch (opt) { case 'b': case 'B': case 'h': case 'H': case 'l': case 'L': case 'T': case 'i': case 'I': { int issigned = islower(opt); lua_Number res = getinteger(data+pos, h.endian, issigned, size); lua_pushnumber(L, res); n++; break; } case 'x': { break; } case 'f': { float f; memcpy(&f, data+pos, size); correctbytes((char *)&f, sizeof(f), h.endian); lua_pushnumber(L, f); n++; break; } case 'd': { double d; memcpy(&d, data+pos, size); correctbytes((char *)&d, sizeof(d), h.endian); lua_pushnumber(L, d); n++; break; } case 'c': { if (size == 0) { if (n == 0 || !lua_isnumber(L, -1)) luaL_error(L, ""format 'c0' needs a previous size""); size = lua_tonumber(L, -1); lua_pop(L, 1); n--; luaL_argcheck(L, size <= ld && pos <= ld - size, 2, ""data string too short""); } lua_pushlstring(L, data+pos, size); n++; break; } case 's': { const char *e = (const char *)memchr(data+pos, '\0', ld - pos); if (e == NULL) luaL_error(L, ""unfinished string in data""); size = (e - (data+pos)) + 1; lua_pushlstring(L, data+pos, size - 1); n++; break; } default: controloptions(L, opt, &fmt, &h); } pos += size; } lua_pushinteger(L, pos + 1); return n + 1; }","- size_t pos = luaL_optinteger(L, 3, 1) - 1;
- luaL_argcheck(L, pos+size <= ld, 2, ""data string too short"");
+ size_t pos = luaL_optinteger(L, 3, 1);
+ luaL_argcheck(L, pos > 0, 3, ""offset must be 1 or greater"");
+ pos--; /* Lua indexes are 1-based, but here we want 0-based for C
+ luaL_argcheck(L, size <= ld && pos <= ld - size,
+ 2, ""data string too short"");","static int b_unpack (lua_State *L) { Header h; const char *fmt = luaL_checkstring(L, 1); size_t ld; const char *data = luaL_checklstring(L, 2, &ld); size_t pos = luaL_optinteger(L, 3, 1); luaL_argcheck(L, pos > 0, 3, ""offset must be 1 or greater""); pos--; int n = 0; defaultoptions(&h); while (*fmt) { int opt = *fmt++; size_t size = optsize(L, opt, &fmt); pos += gettoalign(pos, &h, opt, size); luaL_argcheck(L, size <= ld && pos <= ld - size, 2, ""data string too short""); luaL_checkstack(L, 2, ""too many results""); switch (opt) { case 'b': case 'B': case 'h': case 'H': case 'l': case 'L': case 'T': case 'i': case 'I': { int issigned = islower(opt); lua_Number res = getinteger(data+pos, h.endian, issigned, size); lua_pushnumber(L, res); n++; break; } case 'x': { break; } case 'f': { float f; memcpy(&f, data+pos, size); correctbytes((char *)&f, sizeof(f), h.endian); lua_pushnumber(L, f); n++; break; } case 'd': { double d; memcpy(&d, data+pos, size); correctbytes((char *)&d, sizeof(d), h.endian); lua_pushnumber(L, d); n++; break; } case 'c': { if (size == 0) { if (n == 0 || !lua_isnumber(L, -1)) luaL_error(L, ""format 'c0' needs a previous size""); size = lua_tonumber(L, -1); lua_pop(L, 1); n--; luaL_argcheck(L, size <= ld && pos <= ld - size, 2, ""data string too short""); } lua_pushlstring(L, data+pos, size); n++; break; } case 's': { const char *e = (const char *)memchr(data+pos, '\0', ld - pos); if (e == NULL) luaL_error(L, ""unfinished string in data""); size = (e - (data+pos)) + 1; lua_pushlstring(L, data+pos, size - 1); n++; break; } default: controloptions(L, opt, &fmt, &h); } pos += size; } lua_pushinteger(L, pos + 1); return n + 1; }"
666,4352----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/squidclamav.c----squidclamav_check_preview_handler,"int squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req) { ci_headers_list_t *req_header; struct http_info httpinf; av_req_data_t *data = ci_service_data(req); char *clientip; struct hostent *clientname; unsigned long ip; char *username; char *content_type; ci_off_t content_length; char *chain_ret = NULL; char *ret = NULL; int chkipdone = 0; ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: processing preview header.\n""); if (preview_data_len) ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: preview data size is %d\n"", preview_data_len); if ((req_header = ci_http_request_headers(req)) == NULL) { ci_debug_printf(0, ""ERROR squidclamav_check_preview_handler: bad http header, aborting.\n""); return CI_ERROR; } if ((username = ci_headers_value(req->request_header, ""X-Authenticated-User"")) != NULL) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\n"", username); if (simple_pattern_compare(username, TRUSTUSER) == 1) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\n"", username); return CI_MOD_ALLOW204; } } else { username = (char *)malloc(sizeof(char)*2); strcpy(username, ""-""); } if ((clientip = ci_headers_value(req->request_header, ""X-Client-IP"")) != NULL) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\n"", clientip); ip = inet_addr(clientip); chkipdone = 0; if (dnslookup == 1) { if ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) { if (clientname->h_name != NULL) { if (client_pattern_compare(clientip, clientname->h_name) > 0) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\n"", clientname->h_name, clientip); return CI_MOD_ALLOW204; } chkipdone = 1; } } } if (chkipdone == 0) { if (client_pattern_compare(clientip, NULL) > 0) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\n"", clientip); return CI_MOD_ALLOW204; } } } else { clientip = (char *)malloc(sizeof(char)*2); strcpy(clientip, ""-""); } if (!extract_http_info(req, req_header, &httpinf)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: bad http header, aborting.\n""); return CI_MOD_ALLOW204; } ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: URL requested: %s\n"", httpinf.url); if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\n"", httpinf.url); return CI_MOD_ALLOW204; } if (usepipe == 1) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\n"", squidguard); ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\n"", httpinf.url,clientip,username,httpinf.method); <S2SV_StartVul> fprintf(sgfpw,""%s %s %s %s\n"",httpinf.url,clientip,username,httpinf.method); <S2SV_EndVul> fflush(sgfpw); chain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE); if (chain_ret != NULL) { ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr); if ((ret != NULL) && (strlen(chain_ret) > 1)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\n"", chain_ret); if (logredir) ci_debug_printf(0, ""INFO Chained program redirection received: %s\n"", chain_ret); data->blocked = 1; generate_redirect_page(strtok(chain_ret, "" ""), req, data); xfree(chain_ret); chain_ret = NULL; return CI_MOD_CONTINUE; } xfree(chain_ret); chain_ret = NULL; } } if (strcmp(httpinf.method, ""CONNECT"") == 0) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\n"", httpinf.method); return CI_MOD_ALLOW204; } if (simple_pattern_compare(httpinf.url, ABORT) == 1) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\n"", httpinf.url); return CI_MOD_ALLOW204; } content_length = ci_http_content_length(req); ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Content-Length: %d\n"", (int)content_length); if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\n"", content_length, (int)maxsize); return CI_MOD_ALLOW204; } if ((content_type = http_content_type(req)) != NULL) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Content-Type: %s\n"", content_type); if (simple_pattern_compare(content_type, ABORTCONTENT)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\n"", content_type); return CI_MOD_ALLOW204; } } if (!data || !ci_req_hasbody(req)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No body data, allow 204\n""); return CI_MOD_ALLOW204; } if (preview_data_len == 0) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\n""); return CI_MOD_ALLOW204; } data->url = ci_buffer_alloc(strlen(httpinf.url)+1); strcpy(data->url, httpinf.url); if (username != NULL) { data->user = ci_buffer_alloc(strlen(username)+1); strcpy(data->user, username); } else { data->user = NULL; } if (clientip != NULL) { data->clientip = ci_buffer_alloc(strlen(clientip)+1); strcpy(data->clientip, clientip); } else { ci_debug_printf(0, ""ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\n""); data->clientip = NULL; } data->body = ci_simple_file_new(0); if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) { ci_req_unlock_data(req); ci_simple_file_lock_all(data->body); } if (!data->body) return CI_ERROR; if (preview_data_len) { if (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR) return CI_ERROR; } return CI_MOD_CONTINUE; }","- fprintf(sgfpw,""%s %s %s %s\n"",httpinf.url,clientip,username,httpinf.method);
+ char *rbuff = NULL;
+ rbuff = replace(httpinf.url, ""%"", ""%25"");
+ fprintf(sgfpw,""%s %s %s %s\n"",rbuff,clientip,username,httpinf.method);
+ xfree(rbuff);","int squidclamav_check_preview_handler(char *preview_data, int preview_data_len, ci_request_t * req) { ci_headers_list_t *req_header; struct http_info httpinf; av_req_data_t *data = ci_service_data(req); char *clientip; struct hostent *clientname; unsigned long ip; char *username; char *content_type; ci_off_t content_length; char *chain_ret = NULL; char *ret = NULL; int chkipdone = 0; ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: processing preview header.\n""); if (preview_data_len) ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: preview data size is %d\n"", preview_data_len); if ((req_header = ci_http_request_headers(req)) == NULL) { ci_debug_printf(0, ""ERROR squidclamav_check_preview_handler: bad http header, aborting.\n""); return CI_ERROR; } if ((username = ci_headers_value(req->request_header, ""X-Authenticated-User"")) != NULL) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: X-Authenticated-User: %s\n"", username); if (simple_pattern_compare(username, TRUSTUSER) == 1) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTUSER match) for user: %s\n"", username); return CI_MOD_ALLOW204; } } else { username = (char *)malloc(sizeof(char)*2); strcpy(username, ""-""); } if ((clientip = ci_headers_value(req->request_header, ""X-Client-IP"")) != NULL) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: X-Client-IP: %s\n"", clientip); ip = inet_addr(clientip); chkipdone = 0; if (dnslookup == 1) { if ( (clientname = gethostbyaddr((char *)&ip, sizeof(ip), AF_INET)) != NULL) { if (clientname->h_name != NULL) { if (client_pattern_compare(clientip, clientname->h_name) > 0) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s(%s)\n"", clientname->h_name, clientip); return CI_MOD_ALLOW204; } chkipdone = 1; } } } if (chkipdone == 0) { if (client_pattern_compare(clientip, NULL) > 0) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (TRUSTCLIENT match) for client: %s\n"", clientip); return CI_MOD_ALLOW204; } } } else { clientip = (char *)malloc(sizeof(char)*2); strcpy(clientip, ""-""); } if (!extract_http_info(req, req_header, &httpinf)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: bad http header, aborting.\n""); return CI_MOD_ALLOW204; } ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: URL requested: %s\n"", httpinf.url); if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\n"", httpinf.url); return CI_MOD_ALLOW204; } if (usepipe == 1) { char *rbuff = NULL; ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\n"", squidguard); ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\n"", httpinf.url,clientip,username,httpinf.method); rbuff = replace(httpinf.url, ""%"", ""%25""); fprintf(sgfpw,""%s %s %s %s\n"",rbuff,clientip,username,httpinf.method); fflush(sgfpw); xfree(rbuff); chain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE); if (chain_ret != NULL) { ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr); if ((ret != NULL) && (strlen(chain_ret) > 1)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\n"", chain_ret); if (logredir) ci_debug_printf(0, ""INFO Chained program redirection received: %s\n"", chain_ret); data->blocked = 1; generate_redirect_page(strtok(chain_ret, "" ""), req, data); xfree(chain_ret); chain_ret = NULL; return CI_MOD_CONTINUE; } xfree(chain_ret); chain_ret = NULL; } } if (strcmp(httpinf.method, ""CONNECT"") == 0) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: method %s can't be scanned.\n"", httpinf.method); return CI_MOD_ALLOW204; } if (simple_pattern_compare(httpinf.url, ABORT) == 1) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No antivir check (ABORT match) for url: %s\n"", httpinf.url); return CI_MOD_ALLOW204; } content_length = ci_http_content_length(req); ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Content-Length: %d\n"", (int)content_length); if ((content_length > 0) && (maxsize > 0) && (content_length >= maxsize)) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: No antivir check, content-length upper than maxsize (%d > %d)\n"", content_length, (int)maxsize); return CI_MOD_ALLOW204; } if ((content_type = http_content_type(req)) != NULL) { ci_debug_printf(2, ""DEBUG squidclamav_check_preview_handler: Content-Type: %s\n"", content_type); if (simple_pattern_compare(content_type, ABORTCONTENT)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No antivir check (ABORTCONTENT match) for content-type: %s\n"", content_type); return CI_MOD_ALLOW204; } } if (!data || !ci_req_hasbody(req)) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: No body data, allow 204\n""); return CI_MOD_ALLOW204; } if (preview_data_len == 0) { ci_debug_printf(1, ""DEBUG squidclamav_check_preview_handler: can not begin to scan url: No preview data.\n""); return CI_MOD_ALLOW204; } data->url = ci_buffer_alloc(strlen(httpinf.url)+1); strcpy(data->url, httpinf.url); if (username != NULL) { data->user = ci_buffer_alloc(strlen(username)+1); strcpy(data->user, username); } else { data->user = NULL; } if (clientip != NULL) { data->clientip = ci_buffer_alloc(strlen(clientip)+1); strcpy(data->clientip, clientip); } else { ci_debug_printf(0, ""ERROR squidclamav_check_preview_handler: clientip is null, you must set 'icap_send_client_ip on' into squid.conf\n""); data->clientip = NULL; } data->body = ci_simple_file_new(0); if ((SEND_PERCENT_BYTES >= 0) && (START_SEND_AFTER == 0)) { ci_req_unlock_data(req); ci_simple_file_lock_all(data->body); } if (!data->body) return CI_ERROR; if (preview_data_len) { if (ci_simple_file_write(data->body, preview_data, preview_data_len, ci_req_hasalldata(req)) == CI_ERROR) return CI_ERROR; } return CI_MOD_CONTINUE; }"
667,6430----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/compression_utils.cc----tensorflow::data::CompressElement,"Status CompressElement(const std::vector<Tensor>& element, CompressedElement* out) { std::vector<TensorProto> non_memcpy_components; int64 total_size = 0; for (auto& component : element) { if (DataTypeCanUseMemcpy(component.dtype())) { <S2SV_StartVul> total_size += DMAHelper::buffer(&component)->size(); <S2SV_EndVul> } else { non_memcpy_components.emplace_back(); component.AsProtoTensorContent(&non_memcpy_components.back()); total_size += non_memcpy_components.back().ByteSizeLong(); } } tstring uncompressed; uncompressed.resize_uninitialized(total_size); char* position = uncompressed.mdata(); int non_memcpy_component_index = 0; for (auto& component : element) { CompressedComponentMetadata* metadata = out->mutable_component_metadata()->Add(); metadata->set_dtype(component.dtype()); component.shape().AsProto(metadata->mutable_tensor_shape()); if (DataTypeCanUseMemcpy(component.dtype())) { const TensorBuffer* buffer = DMAHelper::buffer(&component); <S2SV_StartVul> memcpy(position, buffer->data(), buffer->size()); <S2SV_EndVul> <S2SV_StartVul> metadata->set_tensor_size_bytes(buffer->size()); <S2SV_EndVul> } else { TensorProto& proto = non_memcpy_components[non_memcpy_component_index++]; proto.SerializeToArray(position, proto.ByteSizeLong()); metadata->set_tensor_size_bytes(proto.ByteSizeLong()); } position += metadata->tensor_size_bytes(); } DCHECK_EQ(position, uncompressed.mdata() + total_size); if (!port::Snappy_Compress(uncompressed.mdata(), total_size, out->mutable_data())) { return errors::Internal(""Failed to compress using snappy.""); } VLOG(3) << ""Compressed element from "" << total_size << "" bytes to "" << out->data().size() << "" bytes""; return Status::OK(); }","- total_size += DMAHelper::buffer(&component)->size();
- memcpy(position, buffer->data(), buffer->size());
- metadata->set_tensor_size_bytes(buffer->size());
+ const TensorBuffer* buffer = DMAHelper::buffer(&component);
+ if (buffer) {
+ total_size += buffer->size();
+ }
+ if (buffer) {
+ memcpy(position, buffer->data(), buffer->size());
+ metadata->set_tensor_size_bytes(buffer->size());
+ }","Status CompressElement(const std::vector<Tensor>& element, CompressedElement* out) { std::vector<TensorProto> non_memcpy_components; int64 total_size = 0; for (auto& component : element) { if (DataTypeCanUseMemcpy(component.dtype())) { const TensorBuffer* buffer = DMAHelper::buffer(&component); if (buffer) { total_size += buffer->size(); } } else { non_memcpy_components.emplace_back(); component.AsProtoTensorContent(&non_memcpy_components.back()); total_size += non_memcpy_components.back().ByteSizeLong(); } } tstring uncompressed; uncompressed.resize_uninitialized(total_size); char* position = uncompressed.mdata(); int non_memcpy_component_index = 0; for (auto& component : element) { CompressedComponentMetadata* metadata = out->mutable_component_metadata()->Add(); metadata->set_dtype(component.dtype()); component.shape().AsProto(metadata->mutable_tensor_shape()); if (DataTypeCanUseMemcpy(component.dtype())) { const TensorBuffer* buffer = DMAHelper::buffer(&component); if (buffer) { memcpy(position, buffer->data(), buffer->size()); metadata->set_tensor_size_bytes(buffer->size()); } } else { TensorProto& proto = non_memcpy_components[non_memcpy_component_index++]; proto.SerializeToArray(position, proto.ByteSizeLong()); metadata->set_tensor_size_bytes(proto.ByteSizeLong()); } position += metadata->tensor_size_bytes(); } DCHECK_EQ(position, uncompressed.mdata() + total_size); if (!port::Snappy_Compress(uncompressed.mdata(), total_size, out->mutable_data())) { return errors::Internal(""Failed to compress using snappy.""); } VLOG(3) << ""Compressed element from "" << total_size << "" bytes to "" << out->data().size() << "" bytes""; return Status::OK(); }"
668,6335----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/HexOutStream.cxx----HexOutStream::HexOutStream,"<S2SV_StartVul> HexOutStream::HexOutStream(OutStream& os, int buflen) <S2SV_EndVul> : out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN) { if (bufSize % 2) bufSize--; ptr = start = new U8[bufSize]; end = start + bufSize; }","- HexOutStream::HexOutStream(OutStream& os, int buflen)
+ HexOutStream::HexOutStream(OutStream& os, size_t buflen)","HexOutStream::HexOutStream(OutStream& os, size_t buflen) : out_stream(os), offset(0), bufSize(buflen ? buflen : DEFAULT_BUF_LEN) { if (bufSize % 2) bufSize--; ptr = start = new U8[bufSize]; end = start + bufSize; }"
669,6210----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/extents.c----ext4_zero_range,"static long ext4_zero_range(struct file *file, loff_t offset, loff_t len, int mode) { struct inode *inode = file_inode(file); handle_t *handle = NULL; unsigned int max_blocks; loff_t new_size = 0; int ret = 0; int flags; int credits; int partial_begin, partial_end; loff_t start, end; ext4_lblk_t lblk; <S2SV_StartVul> struct address_space *mapping = inode->i_mapping; <S2SV_EndVul> unsigned int blkbits = inode->i_blkbits; trace_ext4_zero_range(inode, offset, len, mode); if (!S_ISREG(inode->i_mode)) return -EINVAL; if (ext4_should_journal_data(inode)) { ret = ext4_force_commit(inode->i_sb); if (ret) return ret; } <S2SV_EndVul> <S2SV_StartVul> if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) { <S2SV_EndVul> <S2SV_StartVul> ret = filemap_write_and_wait_range(mapping, offset, <S2SV_EndVul> <S2SV_StartVul> offset + len - 1); <S2SV_EndVul> <S2SV_StartVul> if (ret) <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> start = round_up(offset, 1 << blkbits); end = round_down((offset + len), 1 << blkbits); if (start < offset || end > offset + len) return -EINVAL; partial_begin = offset & ((1 << blkbits) - 1); partial_end = (offset + len) & ((1 << blkbits) - 1); lblk = start >> blkbits; max_blocks = (end >> blkbits); if (max_blocks < lblk) max_blocks = 0; else max_blocks -= lblk; mutex_lock(&inode->i_mutex); if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) { ret = -EOPNOTSUPP; goto out_mutex; } if (!(mode & FALLOC_FL_KEEP_SIZE) && offset + len > i_size_read(inode)) { new_size = offset + len; ret = inode_newsize_ok(inode, new_size); if (ret) goto out_mutex; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT; if (mode & FALLOC_FL_KEEP_SIZE) flags |= EXT4_GET_BLOCKS_KEEP_SIZE; if (partial_begin || partial_end) { ret = ext4_alloc_file_blocks(file, round_down(offset, 1 << blkbits) >> blkbits, (round_up((offset + len), 1 << blkbits) - round_down(offset, 1 << blkbits)) >> blkbits, new_size, flags, mode); if (ret) goto out_mutex; } if (max_blocks > 0) { flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE); <S2SV_StartVul> truncate_pagecache_range(inode, start, end - 1); <S2SV_EndVul> <S2SV_StartVul> inode->i_mtime = inode->i_ctime = ext4_current_time(inode); <S2SV_EndVul> ext4_inode_block_unlocked_dio(inode); inode_dio_wait(inode); ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size, flags, mode); if (ret) goto out_dio; } if (!partial_begin && !partial_end) goto out_dio; credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1; if (ext4_should_journal_data(inode)) credits += 2; handle = ext4_journal_start(inode, EXT4_HT_MISC, credits); if (IS_ERR(handle)) { ret = PTR_ERR(handle); ext4_std_error(inode->i_sb, ret); goto out_dio; } inode->i_mtime = inode->i_ctime = ext4_current_time(inode); if (new_size) { ext4_update_inode_size(inode, new_size); } else { if ((offset + len) > i_size_read(inode)) ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS); } ext4_mark_inode_dirty(handle, inode); ret = ext4_zero_partial_blocks(handle, inode, offset, len); if (file->f_flags & O_SYNC) ext4_handle_sync(handle); ext4_journal_stop(handle); out_dio: ext4_inode_resume_unlocked_dio(inode); out_mutex: mutex_unlock(&inode->i_mutex); return ret; }","- struct address_space *mapping = inode->i_mapping;
- if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {
- ret = filemap_write_and_wait_range(mapping, offset,
- offset + len - 1);
- if (ret)
- return ret;
- }
- truncate_pagecache_range(inode, start, end - 1);
- inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
+ down_write(&EXT4_I(inode)->i_mmap_sem);
+ truncate_pagecache_range(inode, start, end - 1);
+ inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
+ up_write(&EXT4_I(inode)->i_mmap_sem);","static long ext4_zero_range(struct file *file, loff_t offset, loff_t len, int mode) { struct inode *inode = file_inode(file); handle_t *handle = NULL; unsigned int max_blocks; loff_t new_size = 0; int ret = 0; int flags; int credits; int partial_begin, partial_end; loff_t start, end; ext4_lblk_t lblk; unsigned int blkbits = inode->i_blkbits; trace_ext4_zero_range(inode, offset, len, mode); if (!S_ISREG(inode->i_mode)) return -EINVAL; if (ext4_should_journal_data(inode)) { ret = ext4_force_commit(inode->i_sb); if (ret) return ret; } start = round_up(offset, 1 << blkbits); end = round_down((offset + len), 1 << blkbits); if (start < offset || end > offset + len) return -EINVAL; partial_begin = offset & ((1 << blkbits) - 1); partial_end = (offset + len) & ((1 << blkbits) - 1); lblk = start >> blkbits; max_blocks = (end >> blkbits); if (max_blocks < lblk) max_blocks = 0; else max_blocks -= lblk; mutex_lock(&inode->i_mutex); if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) { ret = -EOPNOTSUPP; goto out_mutex; } if (!(mode & FALLOC_FL_KEEP_SIZE) && offset + len > i_size_read(inode)) { new_size = offset + len; ret = inode_newsize_ok(inode, new_size); if (ret) goto out_mutex; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT; if (mode & FALLOC_FL_KEEP_SIZE) flags |= EXT4_GET_BLOCKS_KEEP_SIZE; if (partial_begin || partial_end) { ret = ext4_alloc_file_blocks(file, round_down(offset, 1 << blkbits) >> blkbits, (round_up((offset + len), 1 << blkbits) - round_down(offset, 1 << blkbits)) >> blkbits, new_size, flags, mode); if (ret) goto out_mutex; } if (max_blocks > 0) { flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE); ext4_inode_block_unlocked_dio(inode); inode_dio_wait(inode); down_write(&EXT4_I(inode)->i_mmap_sem); truncate_pagecache_range(inode, start, end - 1); inode->i_mtime = inode->i_ctime = ext4_current_time(inode); ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size, flags, mode); up_write(&EXT4_I(inode)->i_mmap_sem); if (ret) goto out_dio; } if (!partial_begin && !partial_end) goto out_dio; credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1; if (ext4_should_journal_data(inode)) credits += 2; handle = ext4_journal_start(inode, EXT4_HT_MISC, credits); if (IS_ERR(handle)) { ret = PTR_ERR(handle); ext4_std_error(inode->i_sb, ret); goto out_dio; } inode->i_mtime = inode->i_ctime = ext4_current_time(inode); if (new_size) { ext4_update_inode_size(inode, new_size); } else { if ((offset + len) > i_size_read(inode)) ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS); } ext4_mark_inode_dirty(handle, inode); ret = ext4_zero_partial_blocks(handle, inode, offset, len); if (file->f_flags & O_SYNC) ext4_handle_sync(handle); ext4_journal_stop(handle); out_dio: ext4_inode_resume_unlocked_dio(inode); out_mutex: mutex_unlock(&inode->i_mutex); return ret; }"
670,5427----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mainwindow.cpp----MainWindow::on_actionUpgrade_triggered,"void MainWindow::on_actionUpgrade_triggered() { if (Settings.askUpgradeAutmatic()) { QMessageBox dialog(QMessageBox::Question, qApp->applicationName(), tr(""Do you want to automatically check for updates in the future?""), QMessageBox::No | QMessageBox::Yes, this); dialog.setWindowModality(QmlApplication::dialogModality()); dialog.setDefaultButton(QMessageBox::Yes); dialog.setEscapeButton(QMessageBox::No); dialog.setCheckBox(new QCheckBox(tr(""Do not show this anymore."", ""Automatic upgrade check dialog""))); Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes); if (dialog.checkBox()->isChecked()) Settings.setAskUpgradeAutomatic(false); } showStatusMessage(""Checking for upgrade...""); <S2SV_StartVul> m_network.get(QNetworkRequest(QUrl(""http://check.shotcut.org/version.json""))); <S2SV_EndVul> }","- m_network.get(QNetworkRequest(QUrl(""http://check.shotcut.org/version.json"")));
+ m_network.get(QNetworkRequest(QUrl(""https://check.shotcut.org/version.json"")));","void MainWindow::on_actionUpgrade_triggered() { if (Settings.askUpgradeAutmatic()) { QMessageBox dialog(QMessageBox::Question, qApp->applicationName(), tr(""Do you want to automatically check for updates in the future?""), QMessageBox::No | QMessageBox::Yes, this); dialog.setWindowModality(QmlApplication::dialogModality()); dialog.setDefaultButton(QMessageBox::Yes); dialog.setEscapeButton(QMessageBox::No); dialog.setCheckBox(new QCheckBox(tr(""Do not show this anymore."", ""Automatic upgrade check dialog""))); Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes); if (dialog.checkBox()->isChecked()) Settings.setAskUpgradeAutomatic(false); } showStatusMessage(""Checking for upgrade...""); m_network.get(QNetworkRequest(QUrl(""https://check.shotcut.org/version.json""))); }"
671,7037----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/svr_principal.c----kadm5_create_principal_3,"kadm5_create_principal_3(void *server_handle, kadm5_principal_ent_t entry, long mask, int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char *password) { krb5_db_entry *kdb; osa_princ_ent_rec adb; kadm5_policy_ent_rec polent; krb5_boolean have_polent = FALSE; krb5_int32 now; krb5_tl_data *tl_data_tail; unsigned int ret; kadm5_server_handle_t handle = server_handle; krb5_keyblock *act_mkey; krb5_kvno act_kvno; int new_n_ks_tuple = 0; krb5_key_salt_tuple *new_ks_tuple = NULL; CHECK_HANDLE(server_handle); krb5_clear_error_message(handle->context); check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password); if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) || (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) || (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) || (mask & KADM5_FAIL_AUTH_COUNT)) return KADM5_BAD_MASK; if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0) return KADM5_BAD_MASK; if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR)) return KADM5_BAD_MASK; if((mask & ~ALL_PRINC_MASK)) return KADM5_BAD_MASK; <S2SV_StartVul> if (entry == NULL) <S2SV_EndVul> <S2SV_StartVul> return EINVAL; <S2SV_EndVul> ret = kdb_get_entry(handle, entry->principal, &kdb, &adb); switch(ret) { case KADM5_UNK_PRINC: break; case 0: kdb_free_entry(handle, kdb, &adb); return KADM5_DUP; default: return ret; } kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb)); if (kdb == NULL) return ENOMEM; memset(kdb, 0, sizeof(*kdb)); memset(&adb, 0, sizeof(osa_princ_ent_rec)); if ((mask & KADM5_POLICY)) { ret = get_policy(handle, entry->policy, &polent, &have_polent); if (ret) goto cleanup; } if (password) { ret = passwd_check(handle, password, have_polent ? &polent : NULL, entry->principal); if (ret) goto cleanup; } if ((ret = krb5_timeofday(handle->context, &now))) goto cleanup; kdb->magic = KRB5_KDB_MAGIC_NUMBER; kdb->len = KRB5_KDB_V1_BASE_LENGTH; if ((mask & KADM5_ATTRIBUTES)) kdb->attributes = entry->attributes; else kdb->attributes = handle->params.flags; if ((mask & KADM5_MAX_LIFE)) kdb->max_life = entry->max_life; else kdb->max_life = handle->params.max_life; if (mask & KADM5_MAX_RLIFE) kdb->max_renewable_life = entry->max_renewable_life; else kdb->max_renewable_life = handle->params.max_rlife; if ((mask & KADM5_PRINC_EXPIRE_TIME)) kdb->expiration = entry->princ_expire_time; else kdb->expiration = handle->params.expiration; kdb->pw_expiration = 0; if (have_polent) { if(polent.pw_max_life) kdb->pw_expiration = now + polent.pw_max_life; else kdb->pw_expiration = 0; } if ((mask & KADM5_PW_EXPIRATION)) kdb->pw_expiration = entry->pw_expiration; kdb->last_success = 0; kdb->last_failed = 0; kdb->fail_auth_count = 0; if ((ret = kadm5_copy_principal(handle->context, entry->principal, &(kdb->princ)))) goto cleanup; if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now))) goto cleanup; if (mask & KADM5_TL_DATA) { for (tl_data_tail = entry->tl_data; tl_data_tail; tl_data_tail = tl_data_tail->tl_data_next) { ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail); if( ret ) goto cleanup; } } ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple, &new_n_ks_tuple, &new_ks_tuple); if (ret) goto cleanup; ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey); if (ret) goto cleanup; if (mask & KADM5_KEY_DATA) { assert(entry->n_key_data == 0); } else if (password) { ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple, password, (mask & KADM5_KVNO)?entry->kvno:1, FALSE, kdb); } else { ret = krb5_dbe_crk(handle->context, &master_keyblock, new_ks_tuple, new_n_ks_tuple, FALSE, kdb); } if (ret) goto cleanup; ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno); if (ret) goto cleanup; ret = k5_kadm5_hook_create(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_PRECOMMIT, entry, mask, new_n_ks_tuple, new_ks_tuple, password); if (ret) goto cleanup; adb.admin_history_kvno = INITIAL_HIST_KVNO; if (mask & KADM5_POLICY) { adb.aux_attributes = KADM5_POLICY; adb.policy = entry->policy; } kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry(handle, kdb, &adb); (void) k5_kadm5_hook_create(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask, new_n_ks_tuple, new_ks_tuple, password); cleanup: free(new_ks_tuple); krb5_db_free_principal(handle->context, kdb); if (have_polent) (void) kadm5_free_policy_ent(handle->lhandle, &polent); return ret; }","- if (entry == NULL)
- return EINVAL;
+ if (entry == NULL)
+ return EINVAL;
+ if((mask & KADM5_POLICY) && entry->policy == NULL)
+ return KADM5_BAD_MASK;","kadm5_create_principal_3(void *server_handle, kadm5_principal_ent_t entry, long mask, int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char *password) { krb5_db_entry *kdb; osa_princ_ent_rec adb; kadm5_policy_ent_rec polent; krb5_boolean have_polent = FALSE; krb5_int32 now; krb5_tl_data *tl_data_tail; unsigned int ret; kadm5_server_handle_t handle = server_handle; krb5_keyblock *act_mkey; krb5_kvno act_kvno; int new_n_ks_tuple = 0; krb5_key_salt_tuple *new_ks_tuple = NULL; CHECK_HANDLE(server_handle); krb5_clear_error_message(handle->context); check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password); if (entry == NULL) return EINVAL; if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) || (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) || (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) || (mask & KADM5_FAIL_AUTH_COUNT)) return KADM5_BAD_MASK; if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0) return KADM5_BAD_MASK; if((mask & KADM5_POLICY) && entry->policy == NULL) return KADM5_BAD_MASK; if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR)) return KADM5_BAD_MASK; if((mask & ~ALL_PRINC_MASK)) return KADM5_BAD_MASK; ret = kdb_get_entry(handle, entry->principal, &kdb, &adb); switch(ret) { case KADM5_UNK_PRINC: break; case 0: kdb_free_entry(handle, kdb, &adb); return KADM5_DUP; default: return ret; } kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb)); if (kdb == NULL) return ENOMEM; memset(kdb, 0, sizeof(*kdb)); memset(&adb, 0, sizeof(osa_princ_ent_rec)); if ((mask & KADM5_POLICY)) { ret = get_policy(handle, entry->policy, &polent, &have_polent); if (ret) goto cleanup; } if (password) { ret = passwd_check(handle, password, have_polent ? &polent : NULL, entry->principal); if (ret) goto cleanup; } if ((ret = krb5_timeofday(handle->context, &now))) goto cleanup; kdb->magic = KRB5_KDB_MAGIC_NUMBER; kdb->len = KRB5_KDB_V1_BASE_LENGTH; if ((mask & KADM5_ATTRIBUTES)) kdb->attributes = entry->attributes; else kdb->attributes = handle->params.flags; if ((mask & KADM5_MAX_LIFE)) kdb->max_life = entry->max_life; else kdb->max_life = handle->params.max_life; if (mask & KADM5_MAX_RLIFE) kdb->max_renewable_life = entry->max_renewable_life; else kdb->max_renewable_life = handle->params.max_rlife; if ((mask & KADM5_PRINC_EXPIRE_TIME)) kdb->expiration = entry->princ_expire_time; else kdb->expiration = handle->params.expiration; kdb->pw_expiration = 0; if (have_polent) { if(polent.pw_max_life) kdb->pw_expiration = now + polent.pw_max_life; else kdb->pw_expiration = 0; } if ((mask & KADM5_PW_EXPIRATION)) kdb->pw_expiration = entry->pw_expiration; kdb->last_success = 0; kdb->last_failed = 0; kdb->fail_auth_count = 0; if ((ret = kadm5_copy_principal(handle->context, entry->principal, &(kdb->princ)))) goto cleanup; if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now))) goto cleanup; if (mask & KADM5_TL_DATA) { for (tl_data_tail = entry->tl_data; tl_data_tail; tl_data_tail = tl_data_tail->tl_data_next) { ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail); if( ret ) goto cleanup; } } ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple, &new_n_ks_tuple, &new_ks_tuple); if (ret) goto cleanup; ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey); if (ret) goto cleanup; if (mask & KADM5_KEY_DATA) { assert(entry->n_key_data == 0); } else if (password) { ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple, password, (mask & KADM5_KVNO)?entry->kvno:1, FALSE, kdb); } else { ret = krb5_dbe_crk(handle->context, &master_keyblock, new_ks_tuple, new_n_ks_tuple, FALSE, kdb); } if (ret) goto cleanup; ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno); if (ret) goto cleanup; ret = k5_kadm5_hook_create(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_PRECOMMIT, entry, mask, new_n_ks_tuple, new_ks_tuple, password); if (ret) goto cleanup; adb.admin_history_kvno = INITIAL_HIST_KVNO; if (mask & KADM5_POLICY) { adb.aux_attributes = KADM5_POLICY; adb.policy = entry->policy; } kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry(handle, kdb, &adb); (void) k5_kadm5_hook_create(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask, new_n_ks_tuple, new_ks_tuple, password); cleanup: free(new_ks_tuple); krb5_db_free_principal(handle->context, kdb); if (have_polent) (void) kadm5_free_policy_ent(handle->lhandle, &polent); return ret; }"
672,6890----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/_pickle.c----_Unpickler_MemoGet,"<S2SV_StartVul> _Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx) <S2SV_EndVul> { <S2SV_StartVul> if (idx < 0 || idx >= self->memo_size) <S2SV_EndVul> return NULL; return self->memo[idx]; }","- _Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)
- if (idx < 0 || idx >= self->memo_size)
+ _Unpickler_MemoGet(UnpicklerObject *self, size_t idx)
+ if (idx >= self->memo_size)","_Unpickler_MemoGet(UnpicklerObject *self, size_t idx) { if (idx >= self->memo_size) return NULL; return self->memo[idx]; }"
673,3138----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/events_base.c----xen_irq_lateeoi_locked,static void xen_irq_lateeoi_locked(struct irq_info *info) { evtchn_port_t evtchn; evtchn = info->evtchn; <S2SV_StartVul> if (!VALID_EVTCHN(evtchn)) <S2SV_EndVul> return; unmask_evtchn(evtchn); },"- if (!VALID_EVTCHN(evtchn))
+ unsigned int cpu;
+ if (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list))
+ cpu = info->eoi_cpu;
+ if (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) {
+ lateeoi_list_add(info);
+ return;
+ }
+ info->eoi_time = 0;","static void xen_irq_lateeoi_locked(struct irq_info *info) { evtchn_port_t evtchn; unsigned int cpu; evtchn = info->evtchn; if (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list)) return; cpu = info->eoi_cpu; if (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) { lateeoi_list_add(info); return; } info->eoi_time = 0; unmask_evtchn(evtchn); }"
674,6794----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/eval.c----eval_next_line,"eval_next_line(char_u *arg, evalarg_T *evalarg) { garray_T *gap = &evalarg->eval_ga; char_u *line; if (arg != NULL) { if (*arg == NL) return newline_skip_comments(arg); if (*skipwhite(arg) == '#') *arg = NUL; } if (evalarg->eval_cookie != NULL) line = evalarg->eval_getline(0, evalarg->eval_cookie, 0, GETLINE_CONCAT_ALL); else line = next_line_from_context(evalarg->eval_cctx, TRUE); if (line == NULL) return NULL; ++evalarg->eval_break_count; if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK) { char_u *p = skipwhite(line); if (*p == NUL || vim9_comment_start(p)) { vim_free(line); line = vim_strsave((char_u *)""""); } ((char_u **)gap->ga_data)[gap->ga_len] = line; ++gap->ga_len; } else if (evalarg->eval_cookie != NULL) { <S2SV_StartVul> vim_free(evalarg->eval_tofree); <S2SV_EndVul> evalarg->eval_tofree = line; } evalarg->eval_using_cmdline = FALSE; return skipwhite(line); }","- vim_free(evalarg->eval_tofree);
+ free_eval_tofree_later(evalarg);","eval_next_line(char_u *arg, evalarg_T *evalarg) { garray_T *gap = &evalarg->eval_ga; char_u *line; if (arg != NULL) { if (*arg == NL) return newline_skip_comments(arg); if (*skipwhite(arg) == '#') *arg = NUL; } if (evalarg->eval_cookie != NULL) line = evalarg->eval_getline(0, evalarg->eval_cookie, 0, GETLINE_CONCAT_ALL); else line = next_line_from_context(evalarg->eval_cctx, TRUE); if (line == NULL) return NULL; ++evalarg->eval_break_count; if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK) { char_u *p = skipwhite(line); if (*p == NUL || vim9_comment_start(p)) { vim_free(line); line = vim_strsave((char_u *)""""); } ((char_u **)gap->ga_data)[gap->ga_len] = line; ++gap->ga_len; } else if (evalarg->eval_cookie != NULL) { free_eval_tofree_later(evalarg); evalarg->eval_tofree = line; } evalarg->eval_using_cmdline = FALSE; return skipwhite(line); }"
675,3956----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tif_predict.c----horDiff16,"horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; uint16 *wp = (uint16*) cp0; tmsize_t wc = cc/2; <S2SV_StartVul> assert((cc%(2*stride))==0); <S2SV_EndVul> if (wc > stride) { wc -= stride; wp += wc - 1; do { REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--) wc -= stride; } while (wc > 0); } }","- assert((cc%(2*stride))==0);
+ if((cc%(2*stride))!=0)
+ {
+ TIFFErrorExt(tif->tif_clientdata, ""horDiff8"",
+ ""%s"", ""(cc%(2*stride))!=0"");
+ return 0;
+ }
+ return 1;","horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc) { TIFFPredictorState* sp = PredictorState(tif); tmsize_t stride = sp->stride; uint16 *wp = (uint16*) cp0; tmsize_t wc = cc/2; if((cc%(2*stride))!=0) { TIFFErrorExt(tif->tif_clientdata, ""horDiff8"", ""%s"", ""(cc%(2*stride))!=0""); return 0; } if (wc > stride) { wc -= stride; wp += wc - 1; do { REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--) wc -= stride; } while (wc > 0); } return 1; }"
676,"2901----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/parameterized_truncated_normal_op.cc----tensorflow::functor::TruncatedNormalFunctor<CPUDevice,T>::operator ( )","void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches, int64 samples_per_batch, int64 num_elements, typename TTypes<T>::ConstFlat means, typename TTypes<T>::ConstFlat stddevs, typename TTypes<T>::ConstFlat minvals, typename TTypes<T>::ConstFlat maxvals, const random::PhiloxRandom& gen, typename TTypes<T>::Flat output) { const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3); auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs, &minvals, &maxvals, &gen, &output, <S2SV_StartVul> kStdDevsInsideBoundsToUseRandnSampler](int start_batch, <S2SV_EndVul> <S2SV_StartVul> int limit_batch) { <S2SV_EndVul> random::PhiloxRandom gen_copy = gen; gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) / 4); using Uniform = random::UniformDistribution<random::PhiloxRandom, T>; Uniform dist; using Normal = random::NormalDistribution<random::PhiloxRandom, T>; Normal normal_dist; Eigen::array<T, 4> z; Eigen::array<T, 4> g; for (int64 b = start_batch; b < limit_batch; ++b) { T mean = means((means.dimension(0) == 1) ? 0 : b); T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b); T minval = minvals((minvals.dimension(0) == 1) ? 0 : b); T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b); const int64 limit_sample = std::min((b + 1) * samples_per_batch, num_elements); int64 sample = b * samples_per_batch; OP_REQUIRES(ctx, stddev > T(0) && minval < maxval && (Eigen::numext::isfinite(minval) || Eigen::numext::isfinite(maxval)), errors::InvalidArgument(""Invalid parameters"")); int num_iterations = 0; if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) { std::swap(minval, maxval); stddev = -stddev; } const T normMin = (minval - mean) / stddev; const T normMax = (maxval - mean) / stddev; const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4)); const T cutoff = T(2) * Eigen::numext::exp(T(0.5) + (normMin * (normMin - sqrtFactor)) / T(4)) / (normMin + sqrtFactor); const T diff = normMax - normMin; if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) && (normMax >= T(0.))) || ((normMax > kStdDevsInsideBoundsToUseRandnSampler) && (normMin <= T(0.)))) { while (sample < limit_sample) { const auto randn_sample = normal_dist(&gen_copy); const int size = randn_sample.size(); for (int i = 0; i < size; i++) { if ((randn_sample[i] >= normMin) && (randn_sample[i] <= normMax)) { output(sample) = randn_sample[i] * stddev + mean; sample++; if (sample >= limit_sample) { break; } num_iterations = 0; } else { num_iterations++; if (num_iterations > kMaxIterations) { LOG(ERROR) << ""TruncatedNormal randn rejection sampler "" << ""exceeded maximum iterations for "" << ""normMin="" << normMin << "" normMax="" << normMax << "" kMaxIterations="" << kMaxIterations; ctx->SetStatus(errors::Internal( ""TruncatedNormal randn rejection sampler failed to accept"" "" a sample."")); return; } } } } } else if (diff < cutoff) { const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin; while (sample < limit_sample) { const auto rand = dist(&gen_copy); const int size = rand.size(); for (int i = 0; i < size; i++) { z[i] = rand[i] * diff + normMin; } for (int i = 0; i < size; i++) { g[i] = (plusFactor - z[i] * z[i]) / T(2.0); } const auto u = dist(&gen_copy); for (int i = 0; i < size; i++) { auto accept = u[i] <= Eigen::numext::exp(g[i]); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal uniform rejection sampler "" << ""exceeded max iterations. Sample may contain "" << ""outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal uniform rejection sampler failed to "" "" accept a sample."")); return; } output(sample) = z[i] * stddev + mean; sample++; if (sample >= limit_sample) { break; } num_iterations = 0; } else { num_iterations++; } } } } else { const T alpha = (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) / T(2); while (sample < limit_sample) { auto rand = dist(&gen_copy); const int size = rand.size(); int i = 0; while (i < size) { const T z = -Eigen::numext::log(rand[i]) / alpha + normMin; i++; const T x = normMin < alpha ? alpha - z : normMin - alpha; const T g = Eigen::numext::exp(-x * x / T(2.0)); const T u = rand[i]; i++; auto accept = (u <= g && z < normMax); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal exponential distribution "" << ""rejection sampler exceeds max iterations. "" << ""Sample may contain outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal exponential distribution rejection"" "" sampler failed to accept a sample."")); return; } output(sample) = z * stddev + mean; sample++; if (sample >= limit_sample) { break; } num_iterations = 0; } else { num_iterations++; } } } } } }; const int64 batchInitCost = (Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>()) * 2 + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() + Eigen::internal::functor_traits< Eigen::internal::scalar_sqrt_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() * 4 + Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::AddCost<T>(); const int64 uniformSampleCost = random::PhiloxRandom::kElementCost + random::UniformDistribution<random::PhiloxRandom, T>::kElementCost; const int64 uniformRejectionSamplingCost = uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() * 2 + Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost + Eigen::internal::functor_traits< Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>(); const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch; Shard(worker_threads.num_threads, worker_threads.workers, num_batches, batchCost, do_work); }","- kStdDevsInsideBoundsToUseRandnSampler](int start_batch,
- int limit_batch) {
+ kStdDevsInsideBoundsToUseRandnSampler](int64 start_batch,
+ int64 limit_batch) {","void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches, int64 samples_per_batch, int64 num_elements, typename TTypes<T>::ConstFlat means, typename TTypes<T>::ConstFlat stddevs, typename TTypes<T>::ConstFlat minvals, typename TTypes<T>::ConstFlat maxvals, const random::PhiloxRandom& gen, typename TTypes<T>::Flat output) { const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3); auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); auto do_work = [samples_per_batch, num_elements, &ctx, &means, &stddevs, &minvals, &maxvals, &gen, &output, kStdDevsInsideBoundsToUseRandnSampler](int64 start_batch, int64 limit_batch) { random::PhiloxRandom gen_copy = gen; gen_copy.Skip(start_batch * 2 * kMaxIterations * (samples_per_batch + 3) / 4); using Uniform = random::UniformDistribution<random::PhiloxRandom, T>; Uniform dist; using Normal = random::NormalDistribution<random::PhiloxRandom, T>; Normal normal_dist; Eigen::array<T, 4> z; Eigen::array<T, 4> g; for (int64 b = start_batch; b < limit_batch; ++b) { T mean = means((means.dimension(0) == 1) ? 0 : b); T stddev = stddevs((stddevs.dimension(0) == 1) ? 0 : b); T minval = minvals((minvals.dimension(0) == 1) ? 0 : b); T maxval = maxvals((maxvals.dimension(0) == 1) ? 0 : b); const int64 limit_sample = std::min((b + 1) * samples_per_batch, num_elements); int64 sample = b * samples_per_batch; OP_REQUIRES(ctx, stddev > T(0) && minval < maxval && (Eigen::numext::isfinite(minval) || Eigen::numext::isfinite(maxval)), errors::InvalidArgument(""Invalid parameters"")); int num_iterations = 0; if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) { std::swap(minval, maxval); stddev = -stddev; } const T normMin = (minval - mean) / stddev; const T normMax = (maxval - mean) / stddev; const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4)); const T cutoff = T(2) * Eigen::numext::exp(T(0.5) + (normMin * (normMin - sqrtFactor)) / T(4)) / (normMin + sqrtFactor); const T diff = normMax - normMin; if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) && (normMax >= T(0.))) || ((normMax > kStdDevsInsideBoundsToUseRandnSampler) && (normMin <= T(0.)))) { while (sample < limit_sample) { const auto randn_sample = normal_dist(&gen_copy); const int size = randn_sample.size(); for (int i = 0; i < size; i++) { if ((randn_sample[i] >= normMin) && (randn_sample[i] <= normMax)) { output(sample) = randn_sample[i] * stddev + mean; sample++; if (sample >= limit_sample) { break; } num_iterations = 0; } else { num_iterations++; if (num_iterations > kMaxIterations) { LOG(ERROR) << ""TruncatedNormal randn rejection sampler "" << ""exceeded maximum iterations for "" << ""normMin="" << normMin << "" normMax="" << normMax << "" kMaxIterations="" << kMaxIterations; ctx->SetStatus(errors::Internal( ""TruncatedNormal randn rejection sampler failed to accept"" "" a sample."")); return; } } } } } else if (diff < cutoff) { const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin; while (sample < limit_sample) { const auto rand = dist(&gen_copy); const int size = rand.size(); for (int i = 0; i < size; i++) { z[i] = rand[i] * diff + normMin; } for (int i = 0; i < size; i++) { g[i] = (plusFactor - z[i] * z[i]) / T(2.0); } const auto u = dist(&gen_copy); for (int i = 0; i < size; i++) { auto accept = u[i] <= Eigen::numext::exp(g[i]); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal uniform rejection sampler "" << ""exceeded max iterations. Sample may contain "" << ""outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal uniform rejection sampler failed to "" "" accept a sample."")); return; } output(sample) = z[i] * stddev + mean; sample++; if (sample >= limit_sample) { break; } num_iterations = 0; } else { num_iterations++; } } } } else { const T alpha = (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) / T(2); while (sample < limit_sample) { auto rand = dist(&gen_copy); const int size = rand.size(); int i = 0; while (i < size) { const T z = -Eigen::numext::log(rand[i]) / alpha + normMin; i++; const T x = normMin < alpha ? alpha - z : normMin - alpha; const T g = Eigen::numext::exp(-x * x / T(2.0)); const T u = rand[i]; i++; auto accept = (u <= g && z < normMax); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal exponential distribution "" << ""rejection sampler exceeds max iterations. "" << ""Sample may contain outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal exponential distribution rejection"" "" sampler failed to accept a sample."")); return; } output(sample) = z * stddev + mean; sample++; if (sample >= limit_sample) { break; } num_iterations = 0; } else { num_iterations++; } } } } } }; const int64 batchInitCost = (Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>()) * 2 + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() + Eigen::internal::functor_traits< Eigen::internal::scalar_sqrt_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() * 4 + Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::AddCost<T>(); const int64 uniformSampleCost = random::PhiloxRandom::kElementCost + random::UniformDistribution<random::PhiloxRandom, T>::kElementCost; const int64 uniformRejectionSamplingCost = uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() * 2 + Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost + Eigen::internal::functor_traits< Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>(); const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2 * samples_per_batch; Shard(worker_threads.num_threads, worker_threads.workers, num_batches, batchCost, do_work); }"
677,5262----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ib_verbs.c----bnxt_re_create_srq,"int bnxt_re_create_srq(struct ib_srq *ib_srq, struct ib_srq_init_attr *srq_init_attr, struct ib_udata *udata) { struct ib_pd *ib_pd = ib_srq->pd; struct bnxt_re_pd *pd = container_of(ib_pd, struct bnxt_re_pd, ib_pd); struct bnxt_re_dev *rdev = pd->rdev; struct bnxt_qplib_dev_attr *dev_attr = &rdev->dev_attr; struct bnxt_re_srq *srq = container_of(ib_srq, struct bnxt_re_srq, ib_srq); struct bnxt_qplib_nq *nq = NULL; int rc, entries; if (srq_init_attr->attr.max_wr >= dev_attr->max_srq_wqes) { dev_err(rdev_to_dev(rdev), ""Create CQ failed - max exceeded""); rc = -EINVAL; goto exit; } if (srq_init_attr->srq_type != IB_SRQT_BASIC) { rc = -EOPNOTSUPP; goto exit; } srq->rdev = rdev; srq->qplib_srq.pd = &pd->qplib_pd; srq->qplib_srq.dpi = &rdev->dpi_privileged; entries = roundup_pow_of_two(srq_init_attr->attr.max_wr + 1); if (entries > dev_attr->max_srq_wqes + 1) entries = dev_attr->max_srq_wqes + 1; srq->qplib_srq.max_wqe = entries; srq->qplib_srq.max_sge = srq_init_attr->attr.max_sge; srq->qplib_srq.threshold = srq_init_attr->attr.srq_limit; srq->srq_limit = srq_init_attr->attr.srq_limit; srq->qplib_srq.eventq_hw_ring_id = rdev->nq[0].ring_id; nq = &rdev->nq[0]; if (udata) { rc = bnxt_re_init_user_srq(rdev, pd, srq, udata); if (rc) goto fail; } rc = bnxt_qplib_create_srq(&rdev->qplib_res, &srq->qplib_srq); if (rc) { dev_err(rdev_to_dev(rdev), ""Create HW SRQ failed!""); goto fail; } if (udata) { struct bnxt_re_srq_resp resp; resp.srqid = srq->qplib_srq.id; rc = ib_copy_to_udata(udata, &resp, sizeof(resp)); if (rc) { dev_err(rdev_to_dev(rdev), ""SRQ copy to udata failed!""); bnxt_qplib_destroy_srq(&rdev->qplib_res, &srq->qplib_srq); <S2SV_StartVul> goto exit; <S2SV_EndVul> } } if (nq) nq->budget++; atomic_inc(&rdev->srq_count); return 0; fail: ib_umem_release(srq->umem); exit: return rc; }","- goto exit;
+ goto fail;","int bnxt_re_create_srq(struct ib_srq *ib_srq, struct ib_srq_init_attr *srq_init_attr, struct ib_udata *udata) { struct ib_pd *ib_pd = ib_srq->pd; struct bnxt_re_pd *pd = container_of(ib_pd, struct bnxt_re_pd, ib_pd); struct bnxt_re_dev *rdev = pd->rdev; struct bnxt_qplib_dev_attr *dev_attr = &rdev->dev_attr; struct bnxt_re_srq *srq = container_of(ib_srq, struct bnxt_re_srq, ib_srq); struct bnxt_qplib_nq *nq = NULL; int rc, entries; if (srq_init_attr->attr.max_wr >= dev_attr->max_srq_wqes) { dev_err(rdev_to_dev(rdev), ""Create CQ failed - max exceeded""); rc = -EINVAL; goto exit; } if (srq_init_attr->srq_type != IB_SRQT_BASIC) { rc = -EOPNOTSUPP; goto exit; } srq->rdev = rdev; srq->qplib_srq.pd = &pd->qplib_pd; srq->qplib_srq.dpi = &rdev->dpi_privileged; entries = roundup_pow_of_two(srq_init_attr->attr.max_wr + 1); if (entries > dev_attr->max_srq_wqes + 1) entries = dev_attr->max_srq_wqes + 1; srq->qplib_srq.max_wqe = entries; srq->qplib_srq.max_sge = srq_init_attr->attr.max_sge; srq->qplib_srq.threshold = srq_init_attr->attr.srq_limit; srq->srq_limit = srq_init_attr->attr.srq_limit; srq->qplib_srq.eventq_hw_ring_id = rdev->nq[0].ring_id; nq = &rdev->nq[0]; if (udata) { rc = bnxt_re_init_user_srq(rdev, pd, srq, udata); if (rc) goto fail; } rc = bnxt_qplib_create_srq(&rdev->qplib_res, &srq->qplib_srq); if (rc) { dev_err(rdev_to_dev(rdev), ""Create HW SRQ failed!""); goto fail; } if (udata) { struct bnxt_re_srq_resp resp; resp.srqid = srq->qplib_srq.id; rc = ib_copy_to_udata(udata, &resp, sizeof(resp)); if (rc) { dev_err(rdev_to_dev(rdev), ""SRQ copy to udata failed!""); bnxt_qplib_destroy_srq(&rdev->qplib_res, &srq->qplib_srq); goto fail; } } if (nq) nq->budget++; atomic_inc(&rdev->srq_count); return 0; fail: ib_umem_release(srq->umem); exit: return rc; }"
678,273----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2127--root.c----pid_ns_release_proc,void pid_ns_release_proc(struct pid_namespace *ns) { <S2SV_StartVul> mntput(ns->proc_mnt); <S2SV_EndVul> },"- mntput(ns->proc_mnt);
+ kern_unmount(ns->proc_mnt);",void pid_ns_release_proc(struct pid_namespace *ns) { kern_unmount(ns->proc_mnt); }
679,1247----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-16531--config.c----usb_parse_configuration,"static int usb_parse_configuration(struct usb_device *dev, int cfgidx, struct usb_host_config *config, unsigned char *buffer, int size) { struct device *ddev = &dev->dev; unsigned char *buffer0 = buffer; int cfgno; int nintf, nintf_orig; int i, j, n; struct usb_interface_cache *intfc; unsigned char *buffer2; int size2; struct usb_descriptor_header *header; int len, retval; u8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES]; unsigned iad_num = 0; memcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE); if (config->desc.bDescriptorType != USB_DT_CONFIG || config->desc.bLength < USB_DT_CONFIG_SIZE || config->desc.bLength > size) { dev_err(ddev, ""invalid descriptor for config index %d: "" ""type = 0x%X, length = %d\n"", cfgidx, config->desc.bDescriptorType, config->desc.bLength); return -EINVAL; } cfgno = config->desc.bConfigurationValue; buffer += config->desc.bLength; size -= config->desc.bLength; nintf = nintf_orig = config->desc.bNumInterfaces; if (nintf > USB_MAXINTERFACES) { dev_warn(ddev, ""config %d has too many interfaces: %d, "" ""using maximum allowed: %d\n"", cfgno, nintf, USB_MAXINTERFACES); nintf = USB_MAXINTERFACES; } n = 0; for ((buffer2 = buffer, size2 = size); size2 > 0; (buffer2 += header->bLength, size2 -= header->bLength)) { if (size2 < sizeof(struct usb_descriptor_header)) { dev_warn(ddev, ""config %d descriptor has %d excess "" ""byte%s, ignoring\n"", cfgno, size2, plural(size2)); break; } header = (struct usb_descriptor_header *) buffer2; if ((header->bLength > size2) || (header->bLength < 2)) { dev_warn(ddev, ""config %d has an invalid descriptor "" ""of length %d, skipping remainder of the config\n"", cfgno, header->bLength); break; } if (header->bDescriptorType == USB_DT_INTERFACE) { struct usb_interface_descriptor *d; int inum; d = (struct usb_interface_descriptor *) header; if (d->bLength < USB_DT_INTERFACE_SIZE) { dev_warn(ddev, ""config %d has an invalid "" ""interface descriptor of length %d, "" ""skipping\n"", cfgno, d->bLength); continue; } inum = d->bInterfaceNumber; if ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) && n >= nintf_orig) { dev_warn(ddev, ""config %d has more interface "" ""descriptors, than it declares in "" ""bNumInterfaces, ignoring interface "" ""number: %d\n"", cfgno, inum); continue; } if (inum >= nintf_orig) dev_warn(ddev, ""config %d has an invalid "" ""interface number: %d but max is %d\n"", cfgno, inum, nintf_orig - 1); for (i = 0; i < n; ++i) { if (inums[i] == inum) break; } if (i < n) { if (nalts[i] < 255) ++nalts[i]; } else if (n < USB_MAXINTERFACES) { inums[n] = inum; nalts[n] = 1; ++n; } } else if (header->bDescriptorType == USB_DT_INTERFACE_ASSOCIATION) { if (iad_num == USB_MAXIADS) { dev_warn(ddev, ""found more Interface "" ""Association Descriptors "" ""than allocated for in "" ""configuration %d\n"", cfgno); } else { <S2SV_StartVul> config->intf_assoc[iad_num] = <S2SV_EndVul> <S2SV_StartVul> (struct usb_interface_assoc_descriptor <S2SV_EndVul> <S2SV_StartVul> *)header; <S2SV_EndVul> iad_num++; } } else if (header->bDescriptorType == USB_DT_DEVICE || header->bDescriptorType == USB_DT_CONFIG) dev_warn(ddev, ""config %d contains an unexpected "" ""descriptor of type 0x%X, skipping\n"", cfgno, header->bDescriptorType); } size = buffer2 - buffer; config->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0); if (n != nintf) dev_warn(ddev, ""config %d has %d interface%s, different from "" ""the descriptor's value: %d\n"", cfgno, n, plural(n), nintf_orig); else if (n == 0) dev_warn(ddev, ""config %d has no interfaces?\n"", cfgno); config->desc.bNumInterfaces = nintf = n; for (i = 0; i < nintf; ++i) { for (j = 0; j < nintf; ++j) { if (inums[j] == i) break; } if (j >= nintf) dev_warn(ddev, ""config %d has no interface number "" ""%d\n"", cfgno, i); } for (i = 0; i < nintf; ++i) { j = nalts[i]; if (j > USB_MAXALTSETTING) { dev_warn(ddev, ""too many alternate settings for "" ""config %d interface %d: %d, "" ""using maximum allowed: %d\n"", cfgno, inums[i], j, USB_MAXALTSETTING); nalts[i] = j = USB_MAXALTSETTING; } len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j; config->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL); if (!intfc) return -ENOMEM; kref_init(&intfc->ref); } config->extra = buffer; i = find_next_descriptor(buffer, size, USB_DT_INTERFACE, USB_DT_INTERFACE, &n); config->extralen = i; if (n > 0) dev_dbg(ddev, ""skipped %d descriptor%s after %s\n"", n, plural(n), ""configuration""); buffer += i; size -= i; while (size > 0) { retval = usb_parse_interface(ddev, cfgno, config, buffer, size, inums, nalts); if (retval < 0) return retval; buffer += retval; size -= retval; } for (i = 0; i < nintf; ++i) { intfc = config->intf_cache[i]; for (j = 0; j < intfc->num_altsetting; ++j) { for (n = 0; n < intfc->num_altsetting; ++n) { if (intfc->altsetting[n].desc. bAlternateSetting == j) break; } if (n >= intfc->num_altsetting) dev_warn(ddev, ""config %d interface %d has no "" ""altsetting %d\n"", cfgno, inums[i], j); } } return 0; }","- config->intf_assoc[iad_num] =
- (struct usb_interface_assoc_descriptor
+ struct usb_interface_assoc_descriptor *d;
+ d = (struct usb_interface_assoc_descriptor *)header;
+ if (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {
+ dev_warn(ddev,
+ ""config %d has an invalid interface association descriptor of length %d, skipping\n"",
+ cfgno, d->bLength);
+ continue;
+ }
+ config->intf_assoc[iad_num] = d;","static int usb_parse_configuration(struct usb_device *dev, int cfgidx, struct usb_host_config *config, unsigned char *buffer, int size) { struct device *ddev = &dev->dev; unsigned char *buffer0 = buffer; int cfgno; int nintf, nintf_orig; int i, j, n; struct usb_interface_cache *intfc; unsigned char *buffer2; int size2; struct usb_descriptor_header *header; int len, retval; u8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES]; unsigned iad_num = 0; memcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE); if (config->desc.bDescriptorType != USB_DT_CONFIG || config->desc.bLength < USB_DT_CONFIG_SIZE || config->desc.bLength > size) { dev_err(ddev, ""invalid descriptor for config index %d: "" ""type = 0x%X, length = %d\n"", cfgidx, config->desc.bDescriptorType, config->desc.bLength); return -EINVAL; } cfgno = config->desc.bConfigurationValue; buffer += config->desc.bLength; size -= config->desc.bLength; nintf = nintf_orig = config->desc.bNumInterfaces; if (nintf > USB_MAXINTERFACES) { dev_warn(ddev, ""config %d has too many interfaces: %d, "" ""using maximum allowed: %d\n"", cfgno, nintf, USB_MAXINTERFACES); nintf = USB_MAXINTERFACES; } n = 0; for ((buffer2 = buffer, size2 = size); size2 > 0; (buffer2 += header->bLength, size2 -= header->bLength)) { if (size2 < sizeof(struct usb_descriptor_header)) { dev_warn(ddev, ""config %d descriptor has %d excess "" ""byte%s, ignoring\n"", cfgno, size2, plural(size2)); break; } header = (struct usb_descriptor_header *) buffer2; if ((header->bLength > size2) || (header->bLength < 2)) { dev_warn(ddev, ""config %d has an invalid descriptor "" ""of length %d, skipping remainder of the config\n"", cfgno, header->bLength); break; } if (header->bDescriptorType == USB_DT_INTERFACE) { struct usb_interface_descriptor *d; int inum; d = (struct usb_interface_descriptor *) header; if (d->bLength < USB_DT_INTERFACE_SIZE) { dev_warn(ddev, ""config %d has an invalid "" ""interface descriptor of length %d, "" ""skipping\n"", cfgno, d->bLength); continue; } inum = d->bInterfaceNumber; if ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) && n >= nintf_orig) { dev_warn(ddev, ""config %d has more interface "" ""descriptors, than it declares in "" ""bNumInterfaces, ignoring interface "" ""number: %d\n"", cfgno, inum); continue; } if (inum >= nintf_orig) dev_warn(ddev, ""config %d has an invalid "" ""interface number: %d but max is %d\n"", cfgno, inum, nintf_orig - 1); for (i = 0; i < n; ++i) { if (inums[i] == inum) break; } if (i < n) { if (nalts[i] < 255) ++nalts[i]; } else if (n < USB_MAXINTERFACES) { inums[n] = inum; nalts[n] = 1; ++n; } } else if (header->bDescriptorType == USB_DT_INTERFACE_ASSOCIATION) { struct usb_interface_assoc_descriptor *d; d = (struct usb_interface_assoc_descriptor *)header; if (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) { dev_warn(ddev, ""config %d has an invalid interface association descriptor of length %d, skipping\n"", cfgno, d->bLength); continue; } if (iad_num == USB_MAXIADS) { dev_warn(ddev, ""found more Interface "" ""Association Descriptors "" ""than allocated for in "" ""configuration %d\n"", cfgno); } else { config->intf_assoc[iad_num] = d; iad_num++; } } else if (header->bDescriptorType == USB_DT_DEVICE || header->bDescriptorType == USB_DT_CONFIG) dev_warn(ddev, ""config %d contains an unexpected "" ""descriptor of type 0x%X, skipping\n"", cfgno, header->bDescriptorType); } size = buffer2 - buffer; config->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0); if (n != nintf) dev_warn(ddev, ""config %d has %d interface%s, different from "" ""the descriptor's value: %d\n"", cfgno, n, plural(n), nintf_orig); else if (n == 0) dev_warn(ddev, ""config %d has no interfaces?\n"", cfgno); config->desc.bNumInterfaces = nintf = n; for (i = 0; i < nintf; ++i) { for (j = 0; j < nintf; ++j) { if (inums[j] == i) break; } if (j >= nintf) dev_warn(ddev, ""config %d has no interface number "" ""%d\n"", cfgno, i); } for (i = 0; i < nintf; ++i) { j = nalts[i]; if (j > USB_MAXALTSETTING) { dev_warn(ddev, ""too many alternate settings for "" ""config %d interface %d: %d, "" ""using maximum allowed: %d\n"", cfgno, inums[i], j, USB_MAXALTSETTING); nalts[i] = j = USB_MAXALTSETTING; } len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j; config->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL); if (!intfc) return -ENOMEM; kref_init(&intfc->ref); } config->extra = buffer; i = find_next_descriptor(buffer, size, USB_DT_INTERFACE, USB_DT_INTERFACE, &n); config->extralen = i; if (n > 0) dev_dbg(ddev, ""skipped %d descriptor%s after %s\n"", n, plural(n), ""configuration""); buffer += i; size -= i; while (size > 0) { retval = usb_parse_interface(ddev, cfgno, config, buffer, size, inums, nalts); if (retval < 0) return retval; buffer += retval; size -= retval; } for (i = 0; i < nintf; ++i) { intfc = config->intf_cache[i]; for (j = 0; j < intfc->num_altsetting; ++j) { for (n = 0; n < intfc->num_altsetting; ++n) { if (intfc->altsetting[n].desc. bAlternateSetting == j) break; } if (n >= intfc->num_altsetting) dev_warn(ddev, ""config %d interface %d has no "" ""altsetting %d\n"", cfgno, inums[i], j); } } return 0; }"
680,503----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-1958--scm.c----scm_check_creds,"static __inline__ int scm_check_creds(struct ucred *creds) { const struct cred *cred = current_cred(); kuid_t uid = make_kuid(cred->user_ns, creds->uid); kgid_t gid = make_kgid(cred->user_ns, creds->gid); if (!uid_valid(uid) || !gid_valid(gid)) return -EINVAL; <S2SV_StartVul> if ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) && <S2SV_EndVul> ((uid_eq(uid, cred->uid) || uid_eq(uid, cred->euid) || uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) && ((gid_eq(gid, cred->gid) || gid_eq(gid, cred->egid) || gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) { return 0; } return -EPERM; }","- if ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&
+ if ((creds->pid == task_tgid_vnr(current) ||
+ ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&","static __inline__ int scm_check_creds(struct ucred *creds) { const struct cred *cred = current_cred(); kuid_t uid = make_kuid(cred->user_ns, creds->uid); kgid_t gid = make_kgid(cred->user_ns, creds->gid); if (!uid_valid(uid) || !gid_valid(gid)) return -EINVAL; if ((creds->pid == task_tgid_vnr(current) || ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) && ((uid_eq(uid, cred->uid) || uid_eq(uid, cred->euid) || uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) && ((gid_eq(gid, cred->gid) || gid_eq(gid, cred->egid) || gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) { return 0; } return -EPERM; }"
681,4088----CWE-908----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/auto_parallel.cc----tensorflow::grappler::AutoParallel::Initialize,"Status AutoParallel::Initialize(const GrapplerItem& item) { num_gpus_ = GetNumAvailableGPUs(); LOG(INFO) << ""Number of GPUs: "" << num_gpus_; item_ = &item; graph_ = item.graph; LOG(INFO) << ""Original graph size: "" << graph_.node_size(); if (item.fetch.empty()) { return Status(error::INVALID_ARGUMENT, ""No fetch nodes provided.""); } if (item.MainVariables().empty()) { return Status(error::INVALID_ARGUMENT, ""No variables provided.""); } for (const auto& init : item.init_ops) { VLOG(1) << ""Init node: "" << init; } for (const auto& fetch : item.fetch) { VLOG(1) << ""Fetch node: "" << fetch; } for (const auto& var : item.MainVariables()) { VLOG(2) << ""Variable: "" << var->name(); } const std::set<string> apply_gradients_ops = {""ApplyGradientDescent"", ""ApplyProximalGradientDescent"", ""ApplyAdadelta"", ""ApplyAdagrad"", ""ApplyProximalAdagrad"", ""ApplyAdagradDA"", ""ApplyFtrl"", ""ApplyMomentum"", ""ApplyAdam"", ""ApplyRMSProp"", ""ApplyCenteredRMSProp""}; for (int i = 0; i < graph_.node_size(); i++) { all_nodes_.insert( std::make_pair(graph_.node(i).name(), graph_.mutable_node(i))); if (apply_gradients_ops.find(graph_.node(i).op()) != apply_gradients_ops.end()) { apply_gradients_nodes_.insert(graph_.node(i).name()); VLOG(2) << ""Apply gradients node: "" << graph_.node(i).name(); } } auto div_const_node = AddNodeDivConst(); all_nodes_.insert(std::make_pair(div_const_node->name(), div_const_node)); std::map<string, int> gradient_pos = {{""ApplyGradientDescent"", 2}, {""ApplyProximalGradientDescent"", 4}, {""ApplyAdadelta"", 6}, {""ApplyAdagrad"", 3}, {""ApplyProximalAdagrad"", 5}, {""ApplyAdagradDA"", 3}, {""ApplyFtrl"", 3}, {""ApplyMomentum"", 3}, {""ApplyAdam"", 9}, {""ApplyRMSProp"", 7}, {""ApplyCenteredRMSProp"", 8}}; for (const auto& apply_gradient_node_name : apply_gradients_nodes_) { auto apply_gradients_op = all_nodes_[apply_gradient_node_name]->op(); auto apply_gradients_node = all_nodes_[apply_gradient_node_name]; auto div_node = AddNodeDiv( apply_gradient_node_name, apply_gradients_node->input(gradient_pos[apply_gradients_op]), div_const_node->name()); all_nodes_.insert(std::make_pair(div_node->name(), div_node)); *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) = div_node->name(); } LOG(INFO) << ""Graph size after adding div nodes: "" << all_nodes_.size(); std::vector<const NodeDef*> train_nodes; TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes)); LOG(INFO) << ""Number of training nodes: "" << train_nodes.size(); <S2SV_StartVul> const NodeDef* dequeue_node; <S2SV_EndVul> for (const auto& train_node : train_nodes) { if (IsDequeueOp(*train_node)) { dequeue_node = train_node; break; } } std::vector<const NodeDef*> input_nodes; if (dequeue_node) { LOG(INFO) << ""Dequeue node: "" << dequeue_node->name(); TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, {dequeue_node->name()}, {}, &input_nodes)); } LOG(INFO) << ""Number of input nodes: "" << input_nodes.size(); std::set<string> dont_replicate_nodes; for (const auto& variable : item.MainVariables()) { dont_replicate_nodes.insert(variable->name()); } for (const auto& init : item.init_ops) { dont_replicate_nodes.insert(NodeName(init)); } for (const auto& input_node : input_nodes) { if (input_node->name() != dequeue_node->name()) { dont_replicate_nodes.insert(input_node->name()); } } for (const auto& node : train_nodes) { if (dont_replicate_nodes.find(node->name()) == dont_replicate_nodes.end()) { replica_nodes_.insert(node->name()); } } LOG(INFO) << ""Number of replica nodes: "" << replica_nodes_.size(); for (const auto& node : all_nodes_) { if (replica_nodes_.find(node.first) == replica_nodes_.end()) { shared_nodes_.insert(node.first); } } LOG(INFO) << ""Number of shared nodes: "" << shared_nodes_.size(); return Status::OK(); }","- const NodeDef* dequeue_node;
+ const NodeDef* dequeue_node = nullptr;","Status AutoParallel::Initialize(const GrapplerItem& item) { num_gpus_ = GetNumAvailableGPUs(); LOG(INFO) << ""Number of GPUs: "" << num_gpus_; item_ = &item; graph_ = item.graph; LOG(INFO) << ""Original graph size: "" << graph_.node_size(); if (item.fetch.empty()) { return Status(error::INVALID_ARGUMENT, ""No fetch nodes provided.""); } if (item.MainVariables().empty()) { return Status(error::INVALID_ARGUMENT, ""No variables provided.""); } for (const auto& init : item.init_ops) { VLOG(1) << ""Init node: "" << init; } for (const auto& fetch : item.fetch) { VLOG(1) << ""Fetch node: "" << fetch; } for (const auto& var : item.MainVariables()) { VLOG(2) << ""Variable: "" << var->name(); } const std::set<string> apply_gradients_ops = {""ApplyGradientDescent"", ""ApplyProximalGradientDescent"", ""ApplyAdadelta"", ""ApplyAdagrad"", ""ApplyProximalAdagrad"", ""ApplyAdagradDA"", ""ApplyFtrl"", ""ApplyMomentum"", ""ApplyAdam"", ""ApplyRMSProp"", ""ApplyCenteredRMSProp""}; for (int i = 0; i < graph_.node_size(); i++) { all_nodes_.insert( std::make_pair(graph_.node(i).name(), graph_.mutable_node(i))); if (apply_gradients_ops.find(graph_.node(i).op()) != apply_gradients_ops.end()) { apply_gradients_nodes_.insert(graph_.node(i).name()); VLOG(2) << ""Apply gradients node: "" << graph_.node(i).name(); } } auto div_const_node = AddNodeDivConst(); all_nodes_.insert(std::make_pair(div_const_node->name(), div_const_node)); std::map<string, int> gradient_pos = {{""ApplyGradientDescent"", 2}, {""ApplyProximalGradientDescent"", 4}, {""ApplyAdadelta"", 6}, {""ApplyAdagrad"", 3}, {""ApplyProximalAdagrad"", 5}, {""ApplyAdagradDA"", 3}, {""ApplyFtrl"", 3}, {""ApplyMomentum"", 3}, {""ApplyAdam"", 9}, {""ApplyRMSProp"", 7}, {""ApplyCenteredRMSProp"", 8}}; for (const auto& apply_gradient_node_name : apply_gradients_nodes_) { auto apply_gradients_op = all_nodes_[apply_gradient_node_name]->op(); auto apply_gradients_node = all_nodes_[apply_gradient_node_name]; auto div_node = AddNodeDiv( apply_gradient_node_name, apply_gradients_node->input(gradient_pos[apply_gradients_op]), div_const_node->name()); all_nodes_.insert(std::make_pair(div_node->name(), div_node)); *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) = div_node->name(); } LOG(INFO) << ""Graph size after adding div nodes: "" << all_nodes_.size(); std::vector<const NodeDef*> train_nodes; TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes)); LOG(INFO) << ""Number of training nodes: "" << train_nodes.size(); const NodeDef* dequeue_node = nullptr; for (const auto& train_node : train_nodes) { if (IsDequeueOp(*train_node)) { dequeue_node = train_node; break; } } std::vector<const NodeDef*> input_nodes; if (dequeue_node) { LOG(INFO) << ""Dequeue node: "" << dequeue_node->name(); TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, {dequeue_node->name()}, {}, &input_nodes)); } LOG(INFO) << ""Number of input nodes: "" << input_nodes.size(); std::set<string> dont_replicate_nodes; for (const auto& variable : item.MainVariables()) { dont_replicate_nodes.insert(variable->name()); } for (const auto& init : item.init_ops) { dont_replicate_nodes.insert(NodeName(init)); } for (const auto& input_node : input_nodes) { if (input_node->name() != dequeue_node->name()) { dont_replicate_nodes.insert(input_node->name()); } } for (const auto& node : train_nodes) { if (dont_replicate_nodes.find(node->name()) == dont_replicate_nodes.end()) { replica_nodes_.insert(node->name()); } } LOG(INFO) << ""Number of replica nodes: "" << replica_nodes_.size(); for (const auto& node : all_nodes_) { if (replica_nodes_.find(node.first) == replica_nodes_.end()) { shared_nodes_.insert(node.first); } } LOG(INFO) << ""Number of shared nodes: "" << shared_nodes_.size(); return Status::OK(); }"
682,1454----CWE-617----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-11368--kdc_util.c----kdc_process_s4u_x509_user,"kdc_process_s4u_x509_user(krb5_context context, krb5_kdc_req *request, krb5_pa_data *pa_data, krb5_keyblock *tgs_subkey, krb5_keyblock *tgs_session, krb5_pa_s4u_x509_user **s4u_x509_user, const char **status) { krb5_error_code code; krb5_data req_data; req_data.length = pa_data->length; req_data.data = (char *)pa_data->contents; code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user); <S2SV_StartVul> if (code) <S2SV_EndVul> return code; code = verify_s4u_x509_user_checksum(context, tgs_subkey ? tgs_subkey : tgs_session, &req_data, request->nonce, *s4u_x509_user); if (code) { *status = ""INVALID_S4U2SELF_CHECKSUM""; krb5_free_pa_s4u_x509_user(context, *s4u_x509_user); *s4u_x509_user = NULL; return code; } if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 || (*s4u_x509_user)->user_id.subject_cert.length != 0) { *status = ""INVALID_S4U2SELF_REQUEST""; krb5_free_pa_s4u_x509_user(context, *s4u_x509_user); *s4u_x509_user = NULL; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; } return 0; }","- if (code)
+ if (code) {
+ }","kdc_process_s4u_x509_user(krb5_context context, krb5_kdc_req *request, krb5_pa_data *pa_data, krb5_keyblock *tgs_subkey, krb5_keyblock *tgs_session, krb5_pa_s4u_x509_user **s4u_x509_user, const char **status) { krb5_error_code code; krb5_data req_data; req_data.length = pa_data->length; req_data.data = (char *)pa_data->contents; code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user); if (code) { *status = ""DECODE_PA_S4U_X509_USER""; return code; } code = verify_s4u_x509_user_checksum(context, tgs_subkey ? tgs_subkey : tgs_session, &req_data, request->nonce, *s4u_x509_user); if (code) { *status = ""INVALID_S4U2SELF_CHECKSUM""; krb5_free_pa_s4u_x509_user(context, *s4u_x509_user); *s4u_x509_user = NULL; return code; } if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 || (*s4u_x509_user)->user_id.subject_cert.length != 0) { *status = ""INVALID_S4U2SELF_REQUEST""; krb5_free_pa_s4u_x509_user(context, *s4u_x509_user); *s4u_x509_user = NULL; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; } return 0; }"
683,1534----CWE-388----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-8072--hid-cp2112.c----cp2112_gpio_direction_input,"static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; int ret; mutex_lock(&dev->lock); ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_CONFIG_LENGTH) { hid_err(hdev, ""error requesting GPIO config: %d\n"", ret); goto exit; } buf[1] &= ~(1 << offset); buf[2] = gpio_push_pull; ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_SET_REPORT); if (ret < 0) { hid_err(hdev, ""error setting GPIO config: %d\n"", ret); goto exit; } ret = 0; exit: mutex_unlock(&dev->lock); <S2SV_StartVul> return ret <= 0 ? ret : -EIO; <S2SV_EndVul> }","- return ret <= 0 ? ret : -EIO;
+ return ret < 0 ? ret : -EIO;","static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; int ret; mutex_lock(&dev->lock); ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_CONFIG_LENGTH) { hid_err(hdev, ""error requesting GPIO config: %d\n"", ret); goto exit; } buf[1] &= ~(1 << offset); buf[2] = gpio_push_pull; ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_SET_REPORT); if (ret < 0) { hid_err(hdev, ""error setting GPIO config: %d\n"", ret); goto exit; } ret = 0; exit: mutex_unlock(&dev->lock); return ret < 0 ? ret : -EIO; }"
684,4171----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spnego_mech.c----spnego_gss_unwrap_aead,"spnego_gss_unwrap_aead(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_buffer_t input_message_buffer, gss_buffer_t input_assoc_buffer, gss_buffer_t output_payload_buffer, int *conf_state, gss_qop_t *qop_state) { OM_uint32 ret; ret = gss_unwrap_aead(minor_status, <S2SV_StartVul> context_handle, <S2SV_EndVul> input_message_buffer, input_assoc_buffer, output_payload_buffer, conf_state, qop_state); return (ret); }","- context_handle,
+ spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+ if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+ return (GSS_S_NO_CONTEXT);
+ sc->ctx_handle,","spnego_gss_unwrap_aead(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_buffer_t input_message_buffer, gss_buffer_t input_assoc_buffer, gss_buffer_t output_payload_buffer, int *conf_state, gss_qop_t *qop_state) { OM_uint32 ret; spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle; if (sc->ctx_handle == GSS_C_NO_CONTEXT) return (GSS_S_NO_CONTEXT); ret = gss_unwrap_aead(minor_status, sc->ctx_handle, input_message_buffer, input_assoc_buffer, output_payload_buffer, conf_state, qop_state); return (ret); }"
685,3101----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/archive_disk_acl_freebsd.c----set_acl,"set_acl(struct archive *a, int fd, const char *name, <S2SV_StartVul> struct archive_acl *abstract_acl, <S2SV_EndVul> int ae_requested_type, const char *tname) { int acl_type = 0; acl_t acl; acl_entry_t acl_entry; acl_permset_t acl_permset; #if ARCHIVE_ACL_FREEBSD_NFS4 acl_flagset_t acl_flagset; int r; #endif int ret; int ae_type, ae_permset, ae_tag, ae_id; int perm_map_size; const acl_perm_map_t *perm_map; uid_t ae_uid; gid_t ae_gid; const char *ae_name; int entries; int i; ret = ARCHIVE_OK; entries = archive_acl_reset(abstract_acl, ae_requested_type); if (entries == 0) return (ARCHIVE_OK); switch (ae_requested_type) { case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: acl_type = ACL_TYPE_ACCESS; break; case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: acl_type = ACL_TYPE_DEFAULT; break; #if ARCHIVE_ACL_FREEBSD_NFS4 case ARCHIVE_ENTRY_ACL_TYPE_NFS4: acl_type = ACL_TYPE_NFS4; break; #endif default: errno = ENOENT; archive_set_error(a, errno, ""Unsupported ACL type""); return (ARCHIVE_FAILED); } acl = acl_init(entries); if (acl == (acl_t)NULL) { archive_set_error(a, errno, ""Failed to initialize ACL working storage""); return (ARCHIVE_FAILED); } while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type, &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) { if (acl_create_entry(&acl, &acl_entry) != 0) { archive_set_error(a, errno, ""Failed to create a new ACL entry""); ret = ARCHIVE_FAILED; goto exit_free; } switch (ae_tag) { case ARCHIVE_ENTRY_ACL_USER: ae_uid = archive_write_disk_uid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_USER); acl_set_qualifier(acl_entry, &ae_uid); break; case ARCHIVE_ENTRY_ACL_GROUP: ae_gid = archive_write_disk_gid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_GROUP); acl_set_qualifier(acl_entry, &ae_gid); break; case ARCHIVE_ENTRY_ACL_USER_OBJ: acl_set_tag_type(acl_entry, ACL_USER_OBJ); break; case ARCHIVE_ENTRY_ACL_GROUP_OBJ: acl_set_tag_type(acl_entry, ACL_GROUP_OBJ); break; case ARCHIVE_ENTRY_ACL_MASK: acl_set_tag_type(acl_entry, ACL_MASK); break; case ARCHIVE_ENTRY_ACL_OTHER: acl_set_tag_type(acl_entry, ACL_OTHER); break; #if ARCHIVE_ACL_FREEBSD_NFS4 case ARCHIVE_ENTRY_ACL_EVERYONE: acl_set_tag_type(acl_entry, ACL_EVERYONE); break; #endif default: archive_set_error(a, ARCHIVE_ERRNO_MISC, ""Unsupported ACL tag""); ret = ARCHIVE_FAILED; goto exit_free; } #if ARCHIVE_ACL_FREEBSD_NFS4 r = 0; switch (ae_type) { case ARCHIVE_ENTRY_ACL_TYPE_ALLOW: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_ALLOW); break; case ARCHIVE_ENTRY_ACL_TYPE_DENY: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_DENY); break; case ARCHIVE_ENTRY_ACL_TYPE_AUDIT: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_AUDIT); break; case ARCHIVE_ENTRY_ACL_TYPE_ALARM: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_ALARM); break; case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: break; default: archive_set_error(a, ARCHIVE_ERRNO_MISC, ""Unsupported ACL entry type""); ret = ARCHIVE_FAILED; goto exit_free; } if (r != 0) { archive_set_error(a, errno, ""Failed to set ACL entry type""); ret = ARCHIVE_FAILED; goto exit_free; } #endif if (acl_get_permset(acl_entry, &acl_permset) != 0) { archive_set_error(a, errno, ""Failed to get ACL permission set""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_clear_perms(acl_permset) != 0) { archive_set_error(a, errno, ""Failed to clear ACL permissions""); ret = ARCHIVE_FAILED; goto exit_free; } #if ARCHIVE_ACL_FREEBSD_NFS4 if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) { perm_map_size = acl_nfs4_perm_map_size; perm_map = acl_nfs4_perm_map; } else { #endif perm_map_size = acl_posix_perm_map_size; perm_map = acl_posix_perm_map; #if ARCHIVE_ACL_FREEBSD_NFS4 } #endif for (i = 0; i < perm_map_size; ++i) { if (ae_permset & perm_map[i].a_perm) { if (acl_add_perm(acl_permset, perm_map[i].p_perm) != 0) { archive_set_error(a, errno, ""Failed to add ACL permission""); ret = ARCHIVE_FAILED; goto exit_free; } } } #if ARCHIVE_ACL_FREEBSD_NFS4 if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) { if (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) { archive_set_error(a, errno, ""Failed to get flagset from an NFSv4 "" ""ACL entry""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_clear_flags_np(acl_flagset) != 0) { archive_set_error(a, errno, ""Failed to clear flags from an NFSv4 "" ""ACL flagset""); ret = ARCHIVE_FAILED; goto exit_free; } for (i = 0; i < acl_nfs4_flag_map_size; ++i) { if (ae_permset & acl_nfs4_flag_map[i].a_perm) { if (acl_add_flag_np(acl_flagset, acl_nfs4_flag_map[i].p_perm) != 0) { archive_set_error(a, errno, ""Failed to add flag to "" ""NFSv4 ACL flagset""); ret = ARCHIVE_FAILED; goto exit_free; } } } } #endif } if (fd >= 0) { if (acl_set_fd_np(fd, acl, acl_type) == 0) ret = ARCHIVE_OK; else { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl on fd: %s"", tname); ret = ARCHIVE_WARN; } } } #if HAVE_ACL_SET_LINK_NP else if (acl_set_link_np(name, acl_type, acl) != 0) #else <S2SV_StartVul> else if (acl_set_file(name, acl_type, acl) != 0) <S2SV_EndVul> #endif { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl: %s"", tname); ret = ARCHIVE_WARN; } } exit_free: acl_free(acl); return (ret); }","- struct archive_acl *abstract_acl,
- else if (acl_set_file(name, acl_type, acl) != 0)
+ struct archive_acl *abstract_acl, __LA_MODE_T mode,
+ if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {
+ errno = EINVAL;
+ archive_set_error(a, errno,
+ ""Cannot set default ACL on non-directory"");
+ return (ARCHIVE_WARN);
+ }
+ else if (S_ISLNK(mode)) {
+ ret = ARCHIVE_OK;
+ } else if (acl_set_file(name, acl_type, acl) != 0)","set_acl(struct archive *a, int fd, const char *name, struct archive_acl *abstract_acl, __LA_MODE_T mode, int ae_requested_type, const char *tname) { int acl_type = 0; acl_t acl; acl_entry_t acl_entry; acl_permset_t acl_permset; #if ARCHIVE_ACL_FREEBSD_NFS4 acl_flagset_t acl_flagset; int r; #endif int ret; int ae_type, ae_permset, ae_tag, ae_id; int perm_map_size; const acl_perm_map_t *perm_map; uid_t ae_uid; gid_t ae_gid; const char *ae_name; int entries; int i; ret = ARCHIVE_OK; entries = archive_acl_reset(abstract_acl, ae_requested_type); if (entries == 0) return (ARCHIVE_OK); switch (ae_requested_type) { case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: acl_type = ACL_TYPE_ACCESS; break; case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: acl_type = ACL_TYPE_DEFAULT; break; #if ARCHIVE_ACL_FREEBSD_NFS4 case ARCHIVE_ENTRY_ACL_TYPE_NFS4: acl_type = ACL_TYPE_NFS4; break; #endif default: errno = ENOENT; archive_set_error(a, errno, ""Unsupported ACL type""); return (ARCHIVE_FAILED); } if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) { errno = EINVAL; archive_set_error(a, errno, ""Cannot set default ACL on non-directory""); return (ARCHIVE_WARN); } acl = acl_init(entries); if (acl == (acl_t)NULL) { archive_set_error(a, errno, ""Failed to initialize ACL working storage""); return (ARCHIVE_FAILED); } while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type, &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) { if (acl_create_entry(&acl, &acl_entry) != 0) { archive_set_error(a, errno, ""Failed to create a new ACL entry""); ret = ARCHIVE_FAILED; goto exit_free; } switch (ae_tag) { case ARCHIVE_ENTRY_ACL_USER: ae_uid = archive_write_disk_uid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_USER); acl_set_qualifier(acl_entry, &ae_uid); break; case ARCHIVE_ENTRY_ACL_GROUP: ae_gid = archive_write_disk_gid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_GROUP); acl_set_qualifier(acl_entry, &ae_gid); break; case ARCHIVE_ENTRY_ACL_USER_OBJ: acl_set_tag_type(acl_entry, ACL_USER_OBJ); break; case ARCHIVE_ENTRY_ACL_GROUP_OBJ: acl_set_tag_type(acl_entry, ACL_GROUP_OBJ); break; case ARCHIVE_ENTRY_ACL_MASK: acl_set_tag_type(acl_entry, ACL_MASK); break; case ARCHIVE_ENTRY_ACL_OTHER: acl_set_tag_type(acl_entry, ACL_OTHER); break; #if ARCHIVE_ACL_FREEBSD_NFS4 case ARCHIVE_ENTRY_ACL_EVERYONE: acl_set_tag_type(acl_entry, ACL_EVERYONE); break; #endif default: archive_set_error(a, ARCHIVE_ERRNO_MISC, ""Unsupported ACL tag""); ret = ARCHIVE_FAILED; goto exit_free; } #if ARCHIVE_ACL_FREEBSD_NFS4 r = 0; switch (ae_type) { case ARCHIVE_ENTRY_ACL_TYPE_ALLOW: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_ALLOW); break; case ARCHIVE_ENTRY_ACL_TYPE_DENY: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_DENY); break; case ARCHIVE_ENTRY_ACL_TYPE_AUDIT: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_AUDIT); break; case ARCHIVE_ENTRY_ACL_TYPE_ALARM: r = acl_set_entry_type_np(acl_entry, ACL_ENTRY_TYPE_ALARM); break; case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: break; default: archive_set_error(a, ARCHIVE_ERRNO_MISC, ""Unsupported ACL entry type""); ret = ARCHIVE_FAILED; goto exit_free; } if (r != 0) { archive_set_error(a, errno, ""Failed to set ACL entry type""); ret = ARCHIVE_FAILED; goto exit_free; } #endif if (acl_get_permset(acl_entry, &acl_permset) != 0) { archive_set_error(a, errno, ""Failed to get ACL permission set""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_clear_perms(acl_permset) != 0) { archive_set_error(a, errno, ""Failed to clear ACL permissions""); ret = ARCHIVE_FAILED; goto exit_free; } #if ARCHIVE_ACL_FREEBSD_NFS4 if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) { perm_map_size = acl_nfs4_perm_map_size; perm_map = acl_nfs4_perm_map; } else { #endif perm_map_size = acl_posix_perm_map_size; perm_map = acl_posix_perm_map; #if ARCHIVE_ACL_FREEBSD_NFS4 } #endif for (i = 0; i < perm_map_size; ++i) { if (ae_permset & perm_map[i].a_perm) { if (acl_add_perm(acl_permset, perm_map[i].p_perm) != 0) { archive_set_error(a, errno, ""Failed to add ACL permission""); ret = ARCHIVE_FAILED; goto exit_free; } } } #if ARCHIVE_ACL_FREEBSD_NFS4 if (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) { if (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) { archive_set_error(a, errno, ""Failed to get flagset from an NFSv4 "" ""ACL entry""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_clear_flags_np(acl_flagset) != 0) { archive_set_error(a, errno, ""Failed to clear flags from an NFSv4 "" ""ACL flagset""); ret = ARCHIVE_FAILED; goto exit_free; } for (i = 0; i < acl_nfs4_flag_map_size; ++i) { if (ae_permset & acl_nfs4_flag_map[i].a_perm) { if (acl_add_flag_np(acl_flagset, acl_nfs4_flag_map[i].p_perm) != 0) { archive_set_error(a, errno, ""Failed to add flag to "" ""NFSv4 ACL flagset""); ret = ARCHIVE_FAILED; goto exit_free; } } } } #endif } if (fd >= 0) { if (acl_set_fd_np(fd, acl, acl_type) == 0) ret = ARCHIVE_OK; else { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl on fd: %s"", tname); ret = ARCHIVE_WARN; } } } #if HAVE_ACL_SET_LINK_NP else if (acl_set_link_np(name, acl_type, acl) != 0) #else else if (S_ISLNK(mode)) { ret = ARCHIVE_OK; } else if (acl_set_file(name, acl_type, acl) != 0) #endif { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl: %s"", tname); ret = ARCHIVE_WARN; } } exit_free: acl_free(acl); return (ret); }"
686,5417----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/br_multicast.c----br_multicast_del_pg,"static void br_multicast_del_pg(struct net_bridge *br, struct net_bridge_port_group *pg) { struct net_bridge_mdb_htable *mdb; struct net_bridge_mdb_entry *mp; struct net_bridge_port_group *p; struct net_bridge_port_group __rcu **pp; mdb = mlock_dereference(br->mdb, br); mp = br_mdb_ip_get(mdb, &pg->addr); if (WARN_ON(!mp)) return; for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL; pp = &p->next) { if (p != pg) continue; rcu_assign_pointer(*pp, p->next); hlist_del_init(&p->mglist); del_timer(&p->timer); call_rcu_bh(&p->rcu, br_multicast_free_pg); <S2SV_StartVul> if (!mp->ports && !mp->mglist && <S2SV_EndVul> netif_running(br->dev)) mod_timer(&mp->timer, jiffies); return; } WARN_ON(1); }","- if (!mp->ports && !mp->mglist &&
+ if (!mp->ports && !mp->mglist && mp->timer_armed &&","static void br_multicast_del_pg(struct net_bridge *br, struct net_bridge_port_group *pg) { struct net_bridge_mdb_htable *mdb; struct net_bridge_mdb_entry *mp; struct net_bridge_port_group *p; struct net_bridge_port_group __rcu **pp; mdb = mlock_dereference(br->mdb, br); mp = br_mdb_ip_get(mdb, &pg->addr); if (WARN_ON(!mp)) return; for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL; pp = &p->next) { if (p != pg) continue; rcu_assign_pointer(*pp, p->next); hlist_del_init(&p->mglist); del_timer(&p->timer); call_rcu_bh(&p->rcu, br_multicast_free_pg); if (!mp->ports && !mp->mglist && mp->timer_armed && netif_running(br->dev)) mod_timer(&mp->timer, jiffies); return; } WARN_ON(1); }"
687,2241----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-15139--xwd.c----*ReadXWDImage,"static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define CheckOverflowException(length,width,height) \ (((height) != 0) && ((length)/((size_t) height) != ((size_t) width))) char *comment; Image *image; int x_status; MagickBooleanType authentic_colormap; MagickStatusType status; Quantum index; register ssize_t x; register Quantum *q; register ssize_t i; register size_t pixel; size_t length; ssize_t count, y; unsigned long lsb_first; XColor *colors; XImage *ximage; XWDFileHeader header; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header); if (count != sz_XWDheader) ThrowReaderException(CorruptImageError,""UnableToReadImageHeader""); lsb_first=1; if ((int) (*(char *) &lsb_first) != 0) MSBOrderLong((unsigned char *) &header,sz_XWDheader); if (header.file_version != XWD_FILE_VERSION) ThrowReaderException(CorruptImageError,""FileFormatVersionMismatch""); if (header.header_size < sz_XWDheader) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); switch (header.visual_class) { case StaticGray: case GrayScale: { if (header.bits_per_pixel != 1) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } case StaticColor: case PseudoColor: { if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) || (header.ncolors == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } case TrueColor: case DirectColor: <S2SV_StartVul> { <S2SV_EndVul> if ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) && (header.bits_per_pixel != 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.pixmap_format) { case XYBitmap: { if (header.pixmap_depth != 1) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } case XYPixmap: case ZPixmap: { if ((header.pixmap_depth < 1) || (header.pixmap_depth > 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); switch (header.bitmap_pad) { case 8: case 16: case 32: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.bitmap_unit) { case 8: case 16: case 32: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.byte_order) { case LSBFirst: case MSBFirst: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.bitmap_bit_order) { case LSBFirst: case MSBFirst: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if (header.ncolors > 65535) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); length=(size_t) (header.header_size-sz_XWDheader); comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment)); <S2SV_StartVul> if (comment == (char *) NULL) <S2SV_EndVul> <S2SV_StartVul> ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); <S2SV_EndVul> count=ReadBlob(image,length,(unsigned char *) comment); comment[length]='\0'; (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); if (count != (ssize_t) length) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage)); if (ximage == (XImage *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); ximage->depth=(int) header.pixmap_depth; ximage->format=(int) header.pixmap_format; ximage->xoffset=(int) header.xoffset; ximage->data=(char *) NULL; ximage->width=(int) header.pixmap_width; ximage->height=(int) header.pixmap_height; ximage->bitmap_pad=(int) header.bitmap_pad; ximage->bytes_per_line=(int) header.bytes_per_line; ximage->byte_order=(int) header.byte_order; ximage->bitmap_unit=(int) header.bitmap_unit; ximage->bitmap_bit_order=(int) header.bitmap_bit_order; ximage->bits_per_pixel=(int) header.bits_per_pixel; ximage->red_mask=header.red_mask; ximage->green_mask=header.green_mask; ximage->blue_mask=header.blue_mask; if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || (ximage->format < 0) || (ximage->byte_order < 0) || (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) || (ximage->bytes_per_line < 0)) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if ((ximage->width > 65535) || (ximage->height > 65535)) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32)) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } x_status=XInitImage(ximage); if (x_status == 0) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); } authentic_colormap=MagickFalse; colors=(XColor *) NULL; if (header.ncolors != 0) { XWDColor color; colors=(XColor *) AcquireQuantumMemory((size_t) header.ncolors, sizeof(*colors)); if (colors == (XColor *) NULL) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> for (i=0; i < (ssize_t) header.ncolors; i++) <S2SV_EndVul> { count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color); if (count != sz_XWDColor) { colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); } colors[i].pixel=color.pixel; colors[i].red=color.red; colors[i].green=color.green; colors[i].blue=color.blue; colors[i].flags=(char) color.flags; if (color.flags != 0) authentic_colormap=MagickTrue; } lsb_first=1; if ((int) (*(char *) &lsb_first) != 0) for (i=0; i < (ssize_t) header.ncolors; i++) { MSBOrderLong((unsigned char *) &colors[i].pixel, sizeof(colors[i].pixel)); MSBOrderShort((unsigned char *) &colors[i].red,3* sizeof(colors[i].red)); } } length=(size_t) ximage->bytes_per_line*ximage->height; if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height)) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if (ximage->format != ZPixmap) { size_t extent; extent=length; length*=ximage->depth; if (CheckOverflowException(length,extent,ximage->depth)) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } } ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data)); if (ximage->data == (char *) NULL) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } count=ReadBlob(image,length,(unsigned char *) ximage->data); if (count != (ssize_t) length) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""UnableToReadImageData""); } image->columns=(size_t) ximage->width; image->rows=(size_t) ximage->height; image->depth=8; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); return(DestroyImageList(image)); } if ((header.ncolors == 0U) || (ximage->red_mask != 0) || (ximage->green_mask != 0) || (ximage->blue_mask != 0)) image->storage_class=DirectClass; else image->storage_class=PseudoClass; image->colors=header.ncolors; if (image_info->ping == MagickFalse) switch (image->storage_class) { case DirectClass: default: { register size_t color; size_t blue_mask, blue_shift, green_mask, green_shift, red_mask, red_shift; red_mask=ximage->red_mask; red_shift=0; while ((red_mask != 0) && ((red_mask & 0x01) == 0)) { red_mask>>=1; red_shift++; } green_mask=ximage->green_mask; green_shift=0; while ((green_mask != 0) && ((green_mask & 0x01) == 0)) { green_mask>>=1; green_shift++; } blue_mask=ximage->blue_mask; blue_shift=0; while ((blue_mask != 0) && ((blue_mask & 0x01) == 0)) { blue_mask>>=1; blue_shift++; } if ((image->colors != 0) && (authentic_colormap != MagickFalse)) for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { pixel=XGetPixel(ximage,(int) x,(int) y); index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >> red_shift) & red_mask,exception); SetPixelRed(image,ScaleShortToQuantum( colors[(ssize_t) index].red),q); index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >> green_shift) & green_mask,exception); SetPixelGreen(image,ScaleShortToQuantum( colors[(ssize_t) index].green),q); index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >> blue_shift) & blue_mask,exception); SetPixelBlue(image,ScaleShortToQuantum( colors[(ssize_t) index].blue),q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } else for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { pixel=XGetPixel(ximage,(int) x,(int) y); color=(pixel >> red_shift) & red_mask; if (red_mask != 0) color=(color*65535UL)/red_mask; SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q); color=(pixel >> green_shift) & green_mask; if (green_mask != 0) color=(color*65535UL)/green_mask; SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color), q); color=(pixel >> blue_shift) & blue_mask; if (blue_mask != 0) color=(color*65535UL)/blue_mask; SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } break; } case PseudoClass: { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } for (i=0; i < (ssize_t) image->colors; i++) { image->colormap[i].red=(MagickRealType) ScaleShortToQuantum( colors[i].red); image->colormap[i].green=(MagickRealType) ScaleShortToQuantum( colors[i].green); image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum( colors[i].blue); } for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { index=(Quantum) ConstrainColormapIndex(image,(ssize_t) XGetPixel(ximage,(int) x,(int) y),exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } break; } } if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); }","- {
- if (comment == (char *) NULL)
- ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
- }
- for (i=0; i < (ssize_t) header.ncolors; i++)
+ }
+ case StaticColor:
+ break;
+ {
+ count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);
+ if (count != sz_XWDColor)
+ {","static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception) { #define CheckOverflowException(length,width,height) \ (((height) != 0) && ((length)/((size_t) height) != ((size_t) width))) char *comment; Image *image; int x_status; MagickBooleanType authentic_colormap; MagickStatusType status; Quantum index; register ssize_t x; register Quantum *q; register ssize_t i; register size_t pixel; size_t length; ssize_t count, y; unsigned long lsb_first; XColor *colors; XImage *ximage; XWDFileHeader header; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header); if (count != sz_XWDheader) ThrowReaderException(CorruptImageError,""UnableToReadImageHeader""); lsb_first=1; if ((int) (*(char *) &lsb_first) != 0) MSBOrderLong((unsigned char *) &header,sz_XWDheader); if (header.file_version != XWD_FILE_VERSION) ThrowReaderException(CorruptImageError,""FileFormatVersionMismatch""); if (header.header_size < sz_XWDheader) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((MagickSizeType) header.xoffset >= GetBlobSize(image)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); switch (header.visual_class) { case StaticGray: case GrayScale: { if (header.bits_per_pixel != 1) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } case StaticColor: case PseudoColor: { if ((header.bits_per_pixel < 1) || (header.bits_per_pixel > 15) || (header.colormap_entries == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } case TrueColor: case DirectColor: { if ((header.bits_per_pixel != 16) && (header.bits_per_pixel != 24) && (header.bits_per_pixel != 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.pixmap_format) { case XYBitmap: { if (header.pixmap_depth != 1) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); break; } case XYPixmap: case ZPixmap: { if ((header.pixmap_depth < 1) || (header.pixmap_depth > 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); switch (header.bitmap_pad) { case 8: case 16: case 32: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.bitmap_unit) { case 8: case 16: case 32: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.byte_order) { case LSBFirst: case MSBFirst: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } switch (header.bitmap_bit_order) { case LSBFirst: case MSBFirst: break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if (((header.bitmap_pad % 8) != 0) || (header.bitmap_pad > 32)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); length=(size_t) (header.header_size-sz_XWDheader); comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment)); if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,length,(unsigned char *) comment); comment[length]='\0'; (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); if (count != (ssize_t) length) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage)); if (ximage == (XImage *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); ximage->depth=(int) header.pixmap_depth; ximage->format=(int) header.pixmap_format; ximage->xoffset=(int) header.xoffset; ximage->data=(char *) NULL; ximage->width=(int) header.pixmap_width; ximage->height=(int) header.pixmap_height; ximage->bitmap_pad=(int) header.bitmap_pad; ximage->bytes_per_line=(int) header.bytes_per_line; ximage->byte_order=(int) header.byte_order; ximage->bitmap_unit=(int) header.bitmap_unit; ximage->bitmap_bit_order=(int) header.bitmap_bit_order; ximage->bits_per_pixel=(int) header.bits_per_pixel; ximage->red_mask=header.red_mask; ximage->green_mask=header.green_mask; ximage->blue_mask=header.blue_mask; if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || (ximage->format < 0) || (ximage->byte_order < 0) || (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) || (ximage->bytes_per_line < 0)) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if ((ximage->width > 65535) || (ximage->height > 65535)) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32)) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } x_status=XInitImage(ximage); if (x_status == 0) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); } authentic_colormap=MagickFalse; colors=(XColor *) NULL; if (header.ncolors != 0) { XWDColor color; length=(size_t) header.ncolors; if (length > ((~0UL)/sizeof(*colors))) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors)); if (colors == (XColor *) NULL) { ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } for (i=0; i < (ssize_t) header.ncolors; i++) { count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color); if (count != sz_XWDColor) { colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); } colors[i].pixel=color.pixel; colors[i].red=color.red; colors[i].green=color.green; colors[i].blue=color.blue; colors[i].flags=(char) color.flags; if (color.flags != 0) authentic_colormap=MagickTrue; } lsb_first=1; if ((int) (*(char *) &lsb_first) != 0) for (i=0; i < (ssize_t) header.ncolors; i++) { MSBOrderLong((unsigned char *) &colors[i].pixel, sizeof(colors[i].pixel)); MSBOrderShort((unsigned char *) &colors[i].red,3* sizeof(colors[i].red)); } } length=(size_t) ximage->bytes_per_line*ximage->height; if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height)) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if (ximage->format != ZPixmap) { size_t extent; extent=length; length*=ximage->depth; if (CheckOverflowException(length,extent,ximage->depth)) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } } ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data)); if (ximage->data == (char *) NULL) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } count=ReadBlob(image,length,(unsigned char *) ximage->data); if (count != (ssize_t) length) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(CorruptImageError,""UnableToReadImageData""); } image->columns=(size_t) ximage->width; image->rows=(size_t) ximage->height; image->depth=8; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); return(DestroyImageList(image)); } if ((header.ncolors == 0U) || (ximage->red_mask != 0) || (ximage->green_mask != 0) || (ximage->blue_mask != 0)) image->storage_class=DirectClass; else image->storage_class=PseudoClass; image->colors=header.ncolors; if (image_info->ping == MagickFalse) switch (image->storage_class) { case DirectClass: default: { register size_t color; size_t blue_mask, blue_shift, green_mask, green_shift, red_mask, red_shift; red_mask=ximage->red_mask; red_shift=0; while ((red_mask != 0) && ((red_mask & 0x01) == 0)) { red_mask>>=1; red_shift++; } green_mask=ximage->green_mask; green_shift=0; while ((green_mask != 0) && ((green_mask & 0x01) == 0)) { green_mask>>=1; green_shift++; } blue_mask=ximage->blue_mask; blue_shift=0; while ((blue_mask != 0) && ((blue_mask & 0x01) == 0)) { blue_mask>>=1; blue_shift++; } if ((image->colors != 0) && (authentic_colormap != MagickFalse)) for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { pixel=XGetPixel(ximage,(int) x,(int) y); index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >> red_shift) & red_mask,exception); SetPixelRed(image,ScaleShortToQuantum( colors[(ssize_t) index].red),q); index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >> green_shift) & green_mask,exception); SetPixelGreen(image,ScaleShortToQuantum( colors[(ssize_t) index].green),q); index=(Quantum) ConstrainColormapIndex(image,(ssize_t) (pixel >> blue_shift) & blue_mask,exception); SetPixelBlue(image,ScaleShortToQuantum( colors[(ssize_t) index].blue),q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } else for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { pixel=XGetPixel(ximage,(int) x,(int) y); color=(pixel >> red_shift) & red_mask; if (red_mask != 0) color=(color*65535UL)/red_mask; SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q); color=(pixel >> green_shift) & green_mask; if (green_mask != 0) color=(color*65535UL)/green_mask; SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color), q); color=(pixel >> blue_shift) & blue_mask; if (blue_mask != 0) color=(color*65535UL)/blue_mask; SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } break; } case PseudoClass: { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) { if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } for (i=0; i < (ssize_t) image->colors; i++) { image->colormap[i].red=(MagickRealType) ScaleShortToQuantum( colors[i].red); image->colormap[i].green=(MagickRealType) ScaleShortToQuantum( colors[i].green); image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum( colors[i].blue); } for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { index=(Quantum) ConstrainColormapIndex(image,(ssize_t) XGetPixel(ximage,(int) x,(int) y),exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } break; } } if (header.ncolors != 0) colors=(XColor *) RelinquishMagickMemory(colors); ximage->data=DestroyString(ximage->data); ximage=(XImage *) RelinquishMagickMemory(ximage); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
688,1985----CWE-77----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-14354--imap.c----imap_subscribe,"int imap_subscribe(char *path, bool subscribe) { struct ImapData *idata = NULL; char buf[LONG_STRING]; char mbox[LONG_STRING]; char errstr[STRING]; struct Buffer err, token; struct ImapMbox mx; if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox) { mutt_error(_(""Bad mailbox name"")); return -1; } idata = imap_conn_find(&(mx.account), 0); if (!idata) goto fail; imap_fix_path(idata, mx.mbox, buf, sizeof(buf)); if (!*buf) mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf)); if (ImapCheckSubscribed) { mutt_buffer_init(&token); mutt_buffer_init(&err); err.data = errstr; err.dsize = sizeof(errstr); <S2SV_StartVul> snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path); <S2SV_EndVul> if (mutt_parse_rc_line(mbox, &token, &err)) mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr); FREE(&token.data); } if (subscribe) mutt_message(_(""Subscribing to %s...""), buf); else mutt_message(_(""Unsubscribing from %s...""), buf); imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf); snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox); if (imap_exec(idata, buf, 0) < 0) goto fail; imap_unmunge_mbox_name(idata, mx.mbox); if (subscribe) mutt_message(_(""Subscribed to %s""), mx.mbox); else mutt_message(_(""Unsubscribed from %s""), mx.mbox); FREE(&mx.mbox); return 0; fail: FREE(&mx.mbox); return -1; }","- snprintf(mbox, sizeof(mbox), ""%smailboxes \""%s\"""", subscribe ? """" : ""un"", path);
+ size_t len = 0;
+ len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un"");
+ imap_quote_string(mbox + len, sizeof(mbox) - len, path, true);","int imap_subscribe(char *path, bool subscribe) { struct ImapData *idata = NULL; char buf[LONG_STRING]; char mbox[LONG_STRING]; char errstr[STRING]; struct Buffer err, token; struct ImapMbox mx; size_t len = 0; if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox) { mutt_error(_(""Bad mailbox name"")); return -1; } idata = imap_conn_find(&(mx.account), 0); if (!idata) goto fail; imap_fix_path(idata, mx.mbox, buf, sizeof(buf)); if (!*buf) mutt_str_strfcpy(buf, ""INBOX"", sizeof(buf)); if (ImapCheckSubscribed) { mutt_buffer_init(&token); mutt_buffer_init(&err); err.data = errstr; err.dsize = sizeof(errstr); len = snprintf(mbox, sizeof(mbox), ""%smailboxes "", subscribe ? """" : ""un""); imap_quote_string(mbox + len, sizeof(mbox) - len, path, true); if (mutt_parse_rc_line(mbox, &token, &err)) mutt_debug(1, ""Error adding subscribed mailbox: %s\n"", errstr); FREE(&token.data); } if (subscribe) mutt_message(_(""Subscribing to %s...""), buf); else mutt_message(_(""Unsubscribing from %s...""), buf); imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf); snprintf(buf, sizeof(buf), ""%sSUBSCRIBE %s"", subscribe ? """" : ""UN"", mbox); if (imap_exec(idata, buf, 0) < 0) goto fail; imap_unmunge_mbox_name(idata, mx.mbox); if (subscribe) mutt_message(_(""Subscribed to %s""), mx.mbox); else mutt_message(_(""Unsubscribed from %s""), mx.mbox); FREE(&mx.mbox); return 0; fail: FREE(&mx.mbox); return -1; }"
689,1951----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-16276--yurex.c----yurex_read,"static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos) { struct usb_yurex *dev; <S2SV_StartVul> int retval = 0; <S2SV_EndVul> <S2SV_StartVul> int bytes_read = 0; <S2SV_EndVul> char in_buffer[20]; unsigned long flags; dev = file->private_data; mutex_lock(&dev->io_mutex); if (!dev->interface) { <S2SV_StartVul> retval = -ENODEV; <S2SV_EndVul> <S2SV_StartVul> goto exit; <S2SV_EndVul> } spin_lock_irqsave(&dev->lock, flags); <S2SV_StartVul> bytes_read = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu); <S2SV_EndVul> spin_unlock_irqrestore(&dev->lock, flags); if (*ppos < bytes_read) { <S2SV_StartVul> if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos)) <S2SV_EndVul> <S2SV_StartVul> retval = -EFAULT; <S2SV_EndVul> <S2SV_StartVul> else { <S2SV_EndVul> <S2SV_StartVul> retval = bytes_read - *ppos; <S2SV_EndVul> <S2SV_StartVul> *ppos += bytes_read; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> exit: <S2SV_EndVul> mutex_unlock(&dev->io_mutex); <S2SV_StartVul> return retval; <S2SV_EndVul> } <S2SV_StartVul> <S2SV_EndVul>","- int retval = 0;
- int bytes_read = 0;
- retval = -ENODEV;
- goto exit;
- bytes_read = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
- if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))
- retval = -EFAULT;
- else {
- retval = bytes_read - *ppos;
- }
- }
- exit:
- return retval;
- 
+ int len = 0;
+ mutex_unlock(&dev->io_mutex);
+ return -ENODEV;
+ len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);
+ return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);","static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos) { struct usb_yurex *dev; int len = 0; char in_buffer[20]; unsigned long flags; dev = file->private_data; mutex_lock(&dev->io_mutex); if (!dev->interface) { mutex_unlock(&dev->io_mutex); return -ENODEV; } spin_lock_irqsave(&dev->lock, flags); len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu); spin_unlock_irqrestore(&dev->lock, flags); mutex_unlock(&dev->io_mutex); return simple_read_from_buffer(buffer, count, ppos, in_buffer, len); }"
690,2949----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dns.c----get_name_len,"static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len, int *name_len) { const pj_uint8_t *p; pj_status_t status; if (rec_counter > 10) { return PJLIB_UTIL_EDNSINNAMEPTR; } *name_len = *parsed_len = 0; p = start; while (*p) { if ((*p & 0xc0) == 0xc0) { int ptr_len = 0; int dummy; pj_uint16_t offset; pj_memcpy(&offset, p, 2); offset ^= pj_htons((pj_uint16_t)(0xc0 << 8)); offset = pj_ntohs(offset); if (offset >= max - pkt) return PJLIB_UTIL_EDNSINNAMEPTR; status = get_name_len(rec_counter+1, pkt, pkt + offset, max, &dummy, &ptr_len); if (status != PJ_SUCCESS) return status; *parsed_len += 2; *name_len += ptr_len; return PJ_SUCCESS; } else { unsigned label_len = *p; <S2SV_StartVul> if (pkt+label_len > max) <S2SV_EndVul> return PJLIB_UTIL_EDNSINNAMEPTR; p += (label_len + 1); *parsed_len += (label_len + 1); if (*p != 0) ++label_len; *name_len += label_len; <S2SV_StartVul> if (p >= max) <S2SV_EndVul> <S2SV_StartVul> return PJLIB_UTIL_EDNSINSIZE; <S2SV_EndVul> } } ++p; (*parsed_len)++; return PJ_SUCCESS; }","- if (pkt+label_len > max)
- if (p >= max)
- return PJLIB_UTIL_EDNSINSIZE;
+ if (p+1+label_len+1 > max)","static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len, int *name_len) { const pj_uint8_t *p; pj_status_t status; if (rec_counter > 10) { return PJLIB_UTIL_EDNSINNAMEPTR; } *name_len = *parsed_len = 0; p = start; while (*p) { if ((*p & 0xc0) == 0xc0) { int ptr_len = 0; int dummy; pj_uint16_t offset; pj_memcpy(&offset, p, 2); offset ^= pj_htons((pj_uint16_t)(0xc0 << 8)); offset = pj_ntohs(offset); if (offset >= max - pkt) return PJLIB_UTIL_EDNSINNAMEPTR; status = get_name_len(rec_counter+1, pkt, pkt + offset, max, &dummy, &ptr_len); if (status != PJ_SUCCESS) return status; *parsed_len += 2; *name_len += ptr_len; return PJ_SUCCESS; } else { unsigned label_len = *p; if (p+1+label_len+1 > max) return PJLIB_UTIL_EDNSINNAMEPTR; p += (label_len + 1); *parsed_len += (label_len + 1); if (*p != 0) ++label_len; *name_len += label_len; } } ++p; (*parsed_len)++; return PJ_SUCCESS; }"
691,265----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2669--hv_kvp_daemon.c----main,"int main(void) { int fd, len, sock_opt; int error; struct cn_msg *message; struct pollfd pfd; struct nlmsghdr *incoming_msg; struct cn_msg *incoming_cn_msg; struct hv_kvp_msg *hv_msg; char *p; char *key_value; char *key_name; daemon(1, 0); openlog(""KVP"", 0, LOG_USER); syslog(LOG_INFO, ""KVP starting; pid is:%d"", getpid()); kvp_get_os_info(); if (kvp_file_init()) { syslog(LOG_ERR, ""Failed to initialize the pools""); exit(-1); } fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR); if (fd < 0) { syslog(LOG_ERR, ""netlink socket creation failed; error:%d"", fd); exit(-1); } addr.nl_family = AF_NETLINK; addr.nl_pad = 0; addr.nl_pid = 0; addr.nl_groups = CN_KVP_IDX; error = bind(fd, (struct sockaddr *)&addr, sizeof(addr)); if (error < 0) { syslog(LOG_ERR, ""bind failed; error:%d"", error); close(fd); exit(-1); } sock_opt = addr.nl_groups; setsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt)); message = (struct cn_msg *)kvp_send_buffer; message->id.idx = CN_KVP_IDX; message->id.val = CN_KVP_VAL; hv_msg = (struct hv_kvp_msg *)message->data; hv_msg->kvp_hdr.operation = KVP_OP_REGISTER; message->ack = 0; message->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, message); if (len < 0) { syslog(LOG_ERR, ""netlink_send failed; error:%d"", len); close(fd); exit(-1); } pfd.fd = fd; while (1) { pfd.events = POLLIN; pfd.revents = 0; poll(&pfd, 1, -1); len = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0); if (len < 0) { syslog(LOG_ERR, ""recv failed; error:%d"", len); close(fd); return -1; } incoming_msg = (struct nlmsghdr *)kvp_recv_buffer; incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg); hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; switch (hv_msg->kvp_hdr.operation) { case KVP_OP_REGISTER: p = (char *)hv_msg->body.kvp_register.version; lic_version = malloc(strlen(p) + 1); if (lic_version) { strcpy(lic_version, p); syslog(LOG_INFO, ""KVP LIC Version: %s"", lic_version); } else { syslog(LOG_ERR, ""malloc failed""); } continue; case KVP_OP_SET: if (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_GET: if (kvp_get_value(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; <S2SV_StartVul> case KVP_OP_DELETE: <S2SV_EndVul> if (kvp_key_delete(hv_msg->kvp_hdr.pool, <S2SV_StartVul> hv_msg->body.kvp_delete.key, <S2SV_EndVul> <S2SV_StartVul> hv_msg->body.kvp_delete.key_size)) <S2SV_EndVul> strcpy(hv_msg->body.kvp_delete.key, """"); break; default: break; } if (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE) goto kvp_done; if (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) { kvp_pool_enumerate(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_enum_data.index, hv_msg->body.kvp_enum_data.data.key, HV_KVP_EXCHANGE_MAX_KEY_SIZE, hv_msg->body.kvp_enum_data.data.value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); goto kvp_done; } hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; key_name = (char *)hv_msg->body.kvp_enum_data.data.key; key_value = (char *)hv_msg->body.kvp_enum_data.data.value; switch (hv_msg->body.kvp_enum_data.index) { case FullyQualifiedDomainName: kvp_get_domain_name(key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""FullyQualifiedDomainName""); break; case IntegrationServicesVersion: strcpy(key_name, ""IntegrationServicesVersion""); strcpy(key_value, lic_version); break; case NetworkAddressIPv4: kvp_get_ip_address(AF_INET, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv4""); break; case NetworkAddressIPv6: kvp_get_ip_address(AF_INET6, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv6""); break; case OSBuildNumber: strcpy(key_value, os_build); strcpy(key_name, ""OSBuildNumber""); break; case OSName: strcpy(key_value, os_name); strcpy(key_name, ""OSName""); break; case OSMajorVersion: strcpy(key_value, os_major); strcpy(key_name, ""OSMajorVersion""); break; case OSMinorVersion: strcpy(key_value, os_minor); strcpy(key_name, ""OSMinorVersion""); break; case OSVersion: strcpy(key_value, os_build); strcpy(key_name, ""OSVersion""); break; case ProcessorArchitecture: strcpy(key_value, processor_arch); strcpy(key_name, ""ProcessorArchitecture""); break; default: strcpy(key_value, ""Unknown Key""); strcpy(key_name, """"); break; } kvp_done: incoming_cn_msg->id.idx = CN_KVP_IDX; incoming_cn_msg->id.val = CN_KVP_VAL; incoming_cn_msg->ack = 0; incoming_cn_msg->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, incoming_cn_msg); if (len < 0) { syslog(LOG_ERR, ""net_link send failed; error:%d"", len); exit(-1); } } }","- case KVP_OP_DELETE:
- hv_msg->body.kvp_delete.key,
- hv_msg->body.kvp_delete.key_size))
+ if (kvp_get_value(hv_msg->kvp_hdr.pool,
+ hv_msg->body.kvp_set.data.key,
+ break;
+ 
+ if (kvp_key_delete(hv_msg->kvp_hdr.pool,
+ hv_msg->body.kvp_delete.key,
+ hv_msg->body.kvp_delete.key_size))","int main(void) { int fd, len, sock_opt; int error; struct cn_msg *message; struct pollfd pfd; struct nlmsghdr *incoming_msg; struct cn_msg *incoming_cn_msg; struct hv_kvp_msg *hv_msg; char *p; char *key_value; char *key_name; daemon(1, 0); openlog(""KVP"", 0, LOG_USER); syslog(LOG_INFO, ""KVP starting; pid is:%d"", getpid()); kvp_get_os_info(); if (kvp_file_init()) { syslog(LOG_ERR, ""Failed to initialize the pools""); exit(-1); } fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR); if (fd < 0) { syslog(LOG_ERR, ""netlink socket creation failed; error:%d"", fd); exit(-1); } addr.nl_family = AF_NETLINK; addr.nl_pad = 0; addr.nl_pid = 0; addr.nl_groups = CN_KVP_IDX; error = bind(fd, (struct sockaddr *)&addr, sizeof(addr)); if (error < 0) { syslog(LOG_ERR, ""bind failed; error:%d"", error); close(fd); exit(-1); } sock_opt = addr.nl_groups; setsockopt(fd, 270, 1, &sock_opt, sizeof(sock_opt)); message = (struct cn_msg *)kvp_send_buffer; message->id.idx = CN_KVP_IDX; message->id.val = CN_KVP_VAL; hv_msg = (struct hv_kvp_msg *)message->data; hv_msg->kvp_hdr.operation = KVP_OP_REGISTER; message->ack = 0; message->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, message); if (len < 0) { syslog(LOG_ERR, ""netlink_send failed; error:%d"", len); close(fd); exit(-1); } pfd.fd = fd; while (1) { struct sockaddr *addr_p = (struct sockaddr *) &addr; socklen_t addr_l = sizeof(addr); pfd.events = POLLIN; pfd.revents = 0; poll(&pfd, 1, -1); len = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0, addr_p, &addr_l); if (len < 0 || addr.nl_pid) { syslog(LOG_ERR, ""recvfrom failed; pid:%u error:%d %s"", addr.nl_pid, errno, strerror(errno)); close(fd); return -1; } incoming_msg = (struct nlmsghdr *)kvp_recv_buffer; incoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg); hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; switch (hv_msg->kvp_hdr.operation) { case KVP_OP_REGISTER: p = (char *)hv_msg->body.kvp_register.version; lic_version = malloc(strlen(p) + 1); if (lic_version) { strcpy(lic_version, p); syslog(LOG_INFO, ""KVP LIC Version: %s"", lic_version); } else { syslog(LOG_ERR, ""malloc failed""); } continue; case KVP_OP_SET: if (kvp_key_add_or_modify(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_GET: if (kvp_get_value(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_set.data.key, hv_msg->body.kvp_set.data.key_size, hv_msg->body.kvp_set.data.value, hv_msg->body.kvp_set.data.value_size)) strcpy(hv_msg->body.kvp_set.data.key, """"); break; case KVP_OP_DELETE: if (kvp_key_delete(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_delete.key, hv_msg->body.kvp_delete.key_size)) strcpy(hv_msg->body.kvp_delete.key, """"); break; default: break; } if (hv_msg->kvp_hdr.operation != KVP_OP_ENUMERATE) goto kvp_done; if (hv_msg->kvp_hdr.pool != KVP_POOL_AUTO) { kvp_pool_enumerate(hv_msg->kvp_hdr.pool, hv_msg->body.kvp_enum_data.index, hv_msg->body.kvp_enum_data.data.key, HV_KVP_EXCHANGE_MAX_KEY_SIZE, hv_msg->body.kvp_enum_data.data.value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); goto kvp_done; } hv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data; key_name = (char *)hv_msg->body.kvp_enum_data.data.key; key_value = (char *)hv_msg->body.kvp_enum_data.data.value; switch (hv_msg->body.kvp_enum_data.index) { case FullyQualifiedDomainName: kvp_get_domain_name(key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""FullyQualifiedDomainName""); break; case IntegrationServicesVersion: strcpy(key_name, ""IntegrationServicesVersion""); strcpy(key_value, lic_version); break; case NetworkAddressIPv4: kvp_get_ip_address(AF_INET, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv4""); break; case NetworkAddressIPv6: kvp_get_ip_address(AF_INET6, key_value, HV_KVP_EXCHANGE_MAX_VALUE_SIZE); strcpy(key_name, ""NetworkAddressIPv6""); break; case OSBuildNumber: strcpy(key_value, os_build); strcpy(key_name, ""OSBuildNumber""); break; case OSName: strcpy(key_value, os_name); strcpy(key_name, ""OSName""); break; case OSMajorVersion: strcpy(key_value, os_major); strcpy(key_name, ""OSMajorVersion""); break; case OSMinorVersion: strcpy(key_value, os_minor); strcpy(key_name, ""OSMinorVersion""); break; case OSVersion: strcpy(key_value, os_build); strcpy(key_name, ""OSVersion""); break; case ProcessorArchitecture: strcpy(key_value, processor_arch); strcpy(key_name, ""ProcessorArchitecture""); break; default: strcpy(key_value, ""Unknown Key""); strcpy(key_name, """"); break; } kvp_done: incoming_cn_msg->id.idx = CN_KVP_IDX; incoming_cn_msg->id.val = CN_KVP_VAL; incoming_cn_msg->ack = 0; incoming_cn_msg->len = sizeof(struct hv_kvp_msg); len = netlink_send(fd, incoming_cn_msg); if (len < 0) { syslog(LOG_ERR, ""net_link send failed; error:%d"", len); exit(-1); } } }"
692,2363----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-20855--qp.c----create_qp_common,"static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd, struct ib_qp_init_attr *init_attr, struct ib_udata *udata, struct mlx5_ib_qp *qp) { struct mlx5_ib_resources *devr = &dev->devr; int inlen = MLX5_ST_SZ_BYTES(create_qp_in); struct mlx5_core_dev *mdev = dev->mdev; <S2SV_StartVul> struct mlx5_ib_create_qp_resp resp; <S2SV_EndVul> struct mlx5_ib_cq *send_cq; struct mlx5_ib_cq *recv_cq; unsigned long flags; u32 uidx = MLX5_IB_DEFAULT_UIDX; struct mlx5_ib_create_qp ucmd; struct mlx5_ib_qp_base *base; int mlx5_st; void *qpc; u32 *in; int err; mutex_init(&qp->mutex); spin_lock_init(&qp->sq.lock); spin_lock_init(&qp->rq.lock); mlx5_st = to_mlx5_st(init_attr->qp_type); if (mlx5_st < 0) return -EINVAL; if (init_attr->rwq_ind_tbl) { if (!udata) return -ENOSYS; err = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata); return err; } if (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) { if (!MLX5_CAP_GEN(mdev, block_lb_mc)) { mlx5_ib_dbg(dev, ""block multicast loopback isn't supported\n""); return -EINVAL; } else { qp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK; } } if (init_attr->create_flags & (IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV)) { if (!MLX5_CAP_GEN(mdev, cd)) { mlx5_ib_dbg(dev, ""cross-channel isn't supported\n""); return -EINVAL; } if (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL) qp->flags |= MLX5_IB_QP_CROSS_CHANNEL; if (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND) qp->flags |= MLX5_IB_QP_MANAGED_SEND; if (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV) qp->flags |= MLX5_IB_QP_MANAGED_RECV; } if (init_attr->qp_type == IB_QPT_UD && (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) { mlx5_ib_dbg(dev, ""ipoib UD lso qp isn't supported\n""); return -EOPNOTSUPP; } if (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) { if (init_attr->qp_type != IB_QPT_RAW_PACKET) { mlx5_ib_dbg(dev, ""Scatter FCS is supported only for Raw Packet QPs""); return -EOPNOTSUPP; } if (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) || !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) { mlx5_ib_dbg(dev, ""Scatter FCS isn't supported\n""); return -EOPNOTSUPP; } qp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS; } if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE; if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) { if (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) && MLX5_CAP_ETH(dev->mdev, vlan_cap)) || (init_attr->qp_type != IB_QPT_RAW_PACKET)) return -EOPNOTSUPP; qp->flags |= MLX5_IB_QP_CVLAN_STRIPPING; } if (pd && pd->uobject) { if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) { mlx5_ib_dbg(dev, ""copy failed\n""); return -EFAULT; } err = get_qp_user_index(to_mucontext(pd->uobject->context), &ucmd, udata->inlen, &uidx); if (err) return err; qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE); qp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE); if (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) { if (init_attr->qp_type != IB_QPT_RAW_PACKET || !tunnel_offload_supported(mdev)) { mlx5_ib_dbg(dev, ""Tunnel offload isn't supported\n""); return -EOPNOTSUPP; } qp->tunnel_offload_en = true; } if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) { if (init_attr->qp_type != IB_QPT_UD || (MLX5_CAP_GEN(dev->mdev, port_type) != MLX5_CAP_PORT_TYPE_IB) || !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) { mlx5_ib_dbg(dev, ""Source QP option isn't supported\n""); return -EOPNOTSUPP; } qp->flags |= MLX5_IB_QP_UNDERLAY; qp->underlay_qpn = init_attr->source_qpn; } } else { qp->wq_sig = !!wq_signature; } base = (init_attr->qp_type == IB_QPT_RAW_PACKET || qp->flags & MLX5_IB_QP_UNDERLAY) ? &qp->raw_packet_qp.rq.base : &qp->trans_qp.base; qp->has_rq = qp_has_rq(init_attr); err = set_rq_size(dev, &init_attr->cap, qp->has_rq, qp, (pd && pd->uobject) ? &ucmd : NULL); if (err) { mlx5_ib_dbg(dev, ""err %d\n"", err); return err; } if (pd) { if (pd->uobject) { __u32 max_wqes = 1 << MLX5_CAP_GEN(mdev, log_max_qp_sz); mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d)\n"", ucmd.sq_wqe_count); if (ucmd.rq_wqe_shift != qp->rq.wqe_shift || ucmd.rq_wqe_count != qp->rq.wqe_cnt) { mlx5_ib_dbg(dev, ""invalid rq params\n""); return -EINVAL; } if (ucmd.sq_wqe_count > max_wqes) { mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d) > max allowed (%d)\n"", ucmd.sq_wqe_count, max_wqes); return -EINVAL; } if (init_attr->create_flags & mlx5_ib_create_qp_sqpn_qp1()) { mlx5_ib_dbg(dev, ""user-space is not allowed to create UD QPs spoofing as QP1\n""); return -EINVAL; } err = create_user_qp(dev, pd, qp, udata, init_attr, &in, &resp, &inlen, base); if (err) mlx5_ib_dbg(dev, ""err %d\n"", err); } else { err = create_kernel_qp(dev, init_attr, qp, &in, &inlen, base); if (err) mlx5_ib_dbg(dev, ""err %d\n"", err); } if (err) return err; } else { in = kvzalloc(inlen, GFP_KERNEL); if (!in) return -ENOMEM; qp->create_type = MLX5_QP_EMPTY; } if (is_sqp(init_attr->qp_type)) qp->port = init_attr->port_num; qpc = MLX5_ADDR_OF(create_qp_in, in, qpc); MLX5_SET(qpc, qpc, st, mlx5_st); MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED); if (init_attr->qp_type != MLX5_IB_QPT_REG_UMR) MLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn); else MLX5_SET(qpc, qpc, latency_sensitive, 1); if (qp->wq_sig) MLX5_SET(qpc, qpc, wq_signature, 1); if (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK) MLX5_SET(qpc, qpc, block_lb_mc, 1); if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL) MLX5_SET(qpc, qpc, cd_master, 1); if (qp->flags & MLX5_IB_QP_MANAGED_SEND) MLX5_SET(qpc, qpc, cd_slave_send, 1); if (qp->flags & MLX5_IB_QP_MANAGED_RECV) MLX5_SET(qpc, qpc, cd_slave_receive, 1); if (qp->scat_cqe && is_connected(init_attr->qp_type)) { int rcqe_sz; int scqe_sz; rcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq); scqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq); if (rcqe_sz == 128) MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE); else MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE); if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) { if (scqe_sz == 128) MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE); else MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE); } } if (qp->rq.wqe_cnt) { MLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4); MLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt)); } MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr)); if (qp->sq.wqe_cnt) { MLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt)); } else { MLX5_SET(qpc, qpc, no_sq, 1); if (init_attr->srq && init_attr->srq->srq_type == IB_SRQT_TM) MLX5_SET(qpc, qpc, offload_type, MLX5_QPC_OFFLOAD_TYPE_RNDV); } switch (init_attr->qp_type) { case IB_QPT_XRC_TGT: MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn); MLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn); MLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn); break; case IB_QPT_XRC_INI: MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn); MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn); break; default: if (init_attr->srq) { MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn); } else { MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn); } } if (init_attr->send_cq) MLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn); if (init_attr->recv_cq) MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn); MLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma); if (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1) MLX5_SET(qpc, qpc, user_index, uidx); if (init_attr->qp_type == IB_QPT_UD && (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) { MLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1); qp->flags |= MLX5_IB_QP_LSO; } if (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) { if (!MLX5_CAP_GEN(dev->mdev, end_pad)) { mlx5_ib_dbg(dev, ""scatter end padding is not supported\n""); err = -EOPNOTSUPP; goto err; } else if (init_attr->qp_type != IB_QPT_RAW_PACKET) { MLX5_SET(qpc, qpc, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN); } else { qp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING; } } if (inlen < 0) { err = -EINVAL; goto err; } if (init_attr->qp_type == IB_QPT_RAW_PACKET || qp->flags & MLX5_IB_QP_UNDERLAY) { qp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr; raw_packet_qp_copy_info(qp, &qp->raw_packet_qp); err = create_raw_packet_qp(dev, qp, in, inlen, pd); } else { err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen); } if (err) { mlx5_ib_dbg(dev, ""create qp failed\n""); goto err_create; } kvfree(in); base->container_mibqp = qp; base->mqp.event = mlx5_ib_qp_event; get_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq, &send_cq, &recv_cq); spin_lock_irqsave(&dev->reset_flow_resource_lock, flags); mlx5_ib_lock_cqs(send_cq, recv_cq); list_add_tail(&qp->qps_list, &dev->qp_list); if (send_cq) list_add_tail(&qp->cq_send_list, &send_cq->list_send_qp); if (recv_cq) list_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp); mlx5_ib_unlock_cqs(send_cq, recv_cq); spin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags); return 0; err_create: if (qp->create_type == MLX5_QP_USER) destroy_qp_user(dev, pd, qp, base); else if (qp->create_type == MLX5_QP_KERNEL) destroy_qp_kernel(dev, qp); err: kvfree(in); return err; }","- struct mlx5_ib_create_qp_resp resp;
+ struct mlx5_ib_create_qp_resp resp = {};","static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd, struct ib_qp_init_attr *init_attr, struct ib_udata *udata, struct mlx5_ib_qp *qp) { struct mlx5_ib_resources *devr = &dev->devr; int inlen = MLX5_ST_SZ_BYTES(create_qp_in); struct mlx5_core_dev *mdev = dev->mdev; struct mlx5_ib_create_qp_resp resp = {}; struct mlx5_ib_cq *send_cq; struct mlx5_ib_cq *recv_cq; unsigned long flags; u32 uidx = MLX5_IB_DEFAULT_UIDX; struct mlx5_ib_create_qp ucmd; struct mlx5_ib_qp_base *base; int mlx5_st; void *qpc; u32 *in; int err; mutex_init(&qp->mutex); spin_lock_init(&qp->sq.lock); spin_lock_init(&qp->rq.lock); mlx5_st = to_mlx5_st(init_attr->qp_type); if (mlx5_st < 0) return -EINVAL; if (init_attr->rwq_ind_tbl) { if (!udata) return -ENOSYS; err = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata); return err; } if (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) { if (!MLX5_CAP_GEN(mdev, block_lb_mc)) { mlx5_ib_dbg(dev, ""block multicast loopback isn't supported\n""); return -EINVAL; } else { qp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK; } } if (init_attr->create_flags & (IB_QP_CREATE_CROSS_CHANNEL | IB_QP_CREATE_MANAGED_SEND | IB_QP_CREATE_MANAGED_RECV)) { if (!MLX5_CAP_GEN(mdev, cd)) { mlx5_ib_dbg(dev, ""cross-channel isn't supported\n""); return -EINVAL; } if (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL) qp->flags |= MLX5_IB_QP_CROSS_CHANNEL; if (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND) qp->flags |= MLX5_IB_QP_MANAGED_SEND; if (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV) qp->flags |= MLX5_IB_QP_MANAGED_RECV; } if (init_attr->qp_type == IB_QPT_UD && (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) { mlx5_ib_dbg(dev, ""ipoib UD lso qp isn't supported\n""); return -EOPNOTSUPP; } if (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) { if (init_attr->qp_type != IB_QPT_RAW_PACKET) { mlx5_ib_dbg(dev, ""Scatter FCS is supported only for Raw Packet QPs""); return -EOPNOTSUPP; } if (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) || !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) { mlx5_ib_dbg(dev, ""Scatter FCS isn't supported\n""); return -EOPNOTSUPP; } qp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS; } if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE; if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) { if (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) && MLX5_CAP_ETH(dev->mdev, vlan_cap)) || (init_attr->qp_type != IB_QPT_RAW_PACKET)) return -EOPNOTSUPP; qp->flags |= MLX5_IB_QP_CVLAN_STRIPPING; } if (pd && pd->uobject) { if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) { mlx5_ib_dbg(dev, ""copy failed\n""); return -EFAULT; } err = get_qp_user_index(to_mucontext(pd->uobject->context), &ucmd, udata->inlen, &uidx); if (err) return err; qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE); qp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE); if (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) { if (init_attr->qp_type != IB_QPT_RAW_PACKET || !tunnel_offload_supported(mdev)) { mlx5_ib_dbg(dev, ""Tunnel offload isn't supported\n""); return -EOPNOTSUPP; } qp->tunnel_offload_en = true; } if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) { if (init_attr->qp_type != IB_QPT_UD || (MLX5_CAP_GEN(dev->mdev, port_type) != MLX5_CAP_PORT_TYPE_IB) || !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) { mlx5_ib_dbg(dev, ""Source QP option isn't supported\n""); return -EOPNOTSUPP; } qp->flags |= MLX5_IB_QP_UNDERLAY; qp->underlay_qpn = init_attr->source_qpn; } } else { qp->wq_sig = !!wq_signature; } base = (init_attr->qp_type == IB_QPT_RAW_PACKET || qp->flags & MLX5_IB_QP_UNDERLAY) ? &qp->raw_packet_qp.rq.base : &qp->trans_qp.base; qp->has_rq = qp_has_rq(init_attr); err = set_rq_size(dev, &init_attr->cap, qp->has_rq, qp, (pd && pd->uobject) ? &ucmd : NULL); if (err) { mlx5_ib_dbg(dev, ""err %d\n"", err); return err; } if (pd) { if (pd->uobject) { __u32 max_wqes = 1 << MLX5_CAP_GEN(mdev, log_max_qp_sz); mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d)\n"", ucmd.sq_wqe_count); if (ucmd.rq_wqe_shift != qp->rq.wqe_shift || ucmd.rq_wqe_count != qp->rq.wqe_cnt) { mlx5_ib_dbg(dev, ""invalid rq params\n""); return -EINVAL; } if (ucmd.sq_wqe_count > max_wqes) { mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d) > max allowed (%d)\n"", ucmd.sq_wqe_count, max_wqes); return -EINVAL; } if (init_attr->create_flags & mlx5_ib_create_qp_sqpn_qp1()) { mlx5_ib_dbg(dev, ""user-space is not allowed to create UD QPs spoofing as QP1\n""); return -EINVAL; } err = create_user_qp(dev, pd, qp, udata, init_attr, &in, &resp, &inlen, base); if (err) mlx5_ib_dbg(dev, ""err %d\n"", err); } else { err = create_kernel_qp(dev, init_attr, qp, &in, &inlen, base); if (err) mlx5_ib_dbg(dev, ""err %d\n"", err); } if (err) return err; } else { in = kvzalloc(inlen, GFP_KERNEL); if (!in) return -ENOMEM; qp->create_type = MLX5_QP_EMPTY; } if (is_sqp(init_attr->qp_type)) qp->port = init_attr->port_num; qpc = MLX5_ADDR_OF(create_qp_in, in, qpc); MLX5_SET(qpc, qpc, st, mlx5_st); MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED); if (init_attr->qp_type != MLX5_IB_QPT_REG_UMR) MLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn); else MLX5_SET(qpc, qpc, latency_sensitive, 1); if (qp->wq_sig) MLX5_SET(qpc, qpc, wq_signature, 1); if (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK) MLX5_SET(qpc, qpc, block_lb_mc, 1); if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL) MLX5_SET(qpc, qpc, cd_master, 1); if (qp->flags & MLX5_IB_QP_MANAGED_SEND) MLX5_SET(qpc, qpc, cd_slave_send, 1); if (qp->flags & MLX5_IB_QP_MANAGED_RECV) MLX5_SET(qpc, qpc, cd_slave_receive, 1); if (qp->scat_cqe && is_connected(init_attr->qp_type)) { int rcqe_sz; int scqe_sz; rcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq); scqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq); if (rcqe_sz == 128) MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE); else MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE); if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) { if (scqe_sz == 128) MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE); else MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE); } } if (qp->rq.wqe_cnt) { MLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4); MLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt)); } MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr)); if (qp->sq.wqe_cnt) { MLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt)); } else { MLX5_SET(qpc, qpc, no_sq, 1); if (init_attr->srq && init_attr->srq->srq_type == IB_SRQT_TM) MLX5_SET(qpc, qpc, offload_type, MLX5_QPC_OFFLOAD_TYPE_RNDV); } switch (init_attr->qp_type) { case IB_QPT_XRC_TGT: MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn); MLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn); MLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn); break; case IB_QPT_XRC_INI: MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn); MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn); break; default: if (init_attr->srq) { MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn); } else { MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn); MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn); } } if (init_attr->send_cq) MLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn); if (init_attr->recv_cq) MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn); MLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma); if (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1) MLX5_SET(qpc, qpc, user_index, uidx); if (init_attr->qp_type == IB_QPT_UD && (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) { MLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1); qp->flags |= MLX5_IB_QP_LSO; } if (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) { if (!MLX5_CAP_GEN(dev->mdev, end_pad)) { mlx5_ib_dbg(dev, ""scatter end padding is not supported\n""); err = -EOPNOTSUPP; goto err; } else if (init_attr->qp_type != IB_QPT_RAW_PACKET) { MLX5_SET(qpc, qpc, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN); } else { qp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING; } } if (inlen < 0) { err = -EINVAL; goto err; } if (init_attr->qp_type == IB_QPT_RAW_PACKET || qp->flags & MLX5_IB_QP_UNDERLAY) { qp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr; raw_packet_qp_copy_info(qp, &qp->raw_packet_qp); err = create_raw_packet_qp(dev, qp, in, inlen, pd); } else { err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen); } if (err) { mlx5_ib_dbg(dev, ""create qp failed\n""); goto err_create; } kvfree(in); base->container_mibqp = qp; base->mqp.event = mlx5_ib_qp_event; get_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq, &send_cq, &recv_cq); spin_lock_irqsave(&dev->reset_flow_resource_lock, flags); mlx5_ib_lock_cqs(send_cq, recv_cq); list_add_tail(&qp->qps_list, &dev->qp_list); if (send_cq) list_add_tail(&qp->cq_send_list, &send_cq->list_send_qp); if (recv_cq) list_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp); mlx5_ib_unlock_cqs(send_cq, recv_cq); spin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags); return 0; err_create: if (qp->create_type == MLX5_QP_USER) destroy_qp_user(dev, pd, qp, base); else if (qp->create_type == MLX5_QP_KERNEL) destroy_qp_kernel(dev, qp); err: kvfree(in); return err; }"
693,5840----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hsm_config_client.c----fm_mgr_config_mgr_connect,"fm_mgr_config_mgr_connect ( fm_config_conx_hdl *hdl, fm_mgr_type_t mgr ) { char s_path[256]; char c_path[256]; char *mgr_prefix; p_hsm_com_client_hdl_t *mgr_hdl; <S2SV_StartVul> pid_t pid; <S2SV_EndVul> memset(s_path,0,sizeof(s_path)); memset(c_path,0,sizeof(c_path)); <S2SV_StartVul> pid = getpid(); <S2SV_EndVul> switch ( mgr ) { case FM_MGR_SM: mgr_prefix = HSM_FM_SCK_SM; mgr_hdl = &hdl->sm_hdl; break; case FM_MGR_PM: mgr_prefix = HSM_FM_SCK_PM; mgr_hdl = &hdl->pm_hdl; break; case FM_MGR_FE: mgr_prefix = HSM_FM_SCK_FE; mgr_hdl = &hdl->fe_hdl; break; default: return FM_CONF_INIT_ERR; } sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance); <S2SV_StartVul> sprintf(c_path,""%s%s%d_C_%lu"",HSM_FM_SCK_PREFIX,mgr_prefix, <S2SV_EndVul> <S2SV_StartVul> hdl->instance, (long unsigned)pid); <S2SV_EndVul> if ( *mgr_hdl == NULL ) { if ( hcom_client_init(mgr_hdl,s_path,c_path,32768) != HSM_COM_OK ) { return FM_CONF_INIT_ERR; } } if ( hcom_client_connect(*mgr_hdl) == HSM_COM_OK ) { hdl->conx_mask |= mgr; return FM_CONF_OK; } return FM_CONF_CONX_ERR; }","- pid_t pid;
- pid = getpid();
- sprintf(c_path,""%s%s%d_C_%lu"",HSM_FM_SCK_PREFIX,mgr_prefix,
- hdl->instance, (long unsigned)pid);
+ sprintf(c_path,""%s%s%d_C_XXXXXX"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);","fm_mgr_config_mgr_connect ( fm_config_conx_hdl *hdl, fm_mgr_type_t mgr ) { char s_path[256]; char c_path[256]; char *mgr_prefix; p_hsm_com_client_hdl_t *mgr_hdl; memset(s_path,0,sizeof(s_path)); memset(c_path,0,sizeof(c_path)); switch ( mgr ) { case FM_MGR_SM: mgr_prefix = HSM_FM_SCK_SM; mgr_hdl = &hdl->sm_hdl; break; case FM_MGR_PM: mgr_prefix = HSM_FM_SCK_PM; mgr_hdl = &hdl->pm_hdl; break; case FM_MGR_FE: mgr_prefix = HSM_FM_SCK_FE; mgr_hdl = &hdl->fe_hdl; break; default: return FM_CONF_INIT_ERR; } sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance); sprintf(c_path,""%s%s%d_C_XXXXXX"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance); if ( *mgr_hdl == NULL ) { if ( hcom_client_init(mgr_hdl,s_path,c_path,32768) != HSM_COM_OK ) { return FM_CONF_INIT_ERR; } } if ( hcom_client_connect(*mgr_hdl) == HSM_COM_OK ) { hdl->conx_mask |= mgr; return FM_CONF_OK; } return FM_CONF_CONX_ERR; }"
694,4025----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/asm_x86_nz.c----getToken,"static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) { <S2SV_StartVul> while (begin && isspace ((ut8)str[*begin])) { <S2SV_EndVul> ++(*begin); } if (!str[*begin]) { *end = *begin; return TT_EOF; <S2SV_StartVul> } else if (isalpha ((ut8)str[*begin])) { *end = *begin; <S2SV_StartVul> while (end && isalnum ((ut8)str[*end])) { <S2SV_EndVul> ++(*end); } return TT_WORD; <S2SV_StartVul> } else if (isdigit ((ut8)str[*begin])) { *end = *begin; while (end && isalnum ((ut8)str[*end])) { ++(*end); } return TT_NUMBER; } else { *end = *begin + 1; return TT_SPECIAL; } }","- while (begin && isspace ((ut8)str[*begin])) {
- } else if (isalpha ((ut8)str[*begin])) { // word token
- while (end && isalnum ((ut8)str[*end])) {
- } else if (isdigit ((ut8)str[*begin])) { // number token
+ if (*begin > strlen (str)) {
+ return TT_EOF;
+ }
+ while (begin && str[*begin] && isspace ((ut8)str[*begin])) {
+ }
+ if (isalpha ((ut8)str[*begin])) { // word token
+ while (end && str[*end] && isalnum ((ut8)str[*end])) {
+ }
+ if (isdigit ((ut8)str[*begin])) { // number token","static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) { if (*begin > strlen (str)) { return TT_EOF; } while (begin && str[*begin] && isspace ((ut8)str[*begin])) { ++(*begin); } if (!str[*begin]) { *end = *begin; return TT_EOF; } if (isalpha ((ut8)str[*begin])) { *end = *begin; while (end && str[*end] && isalnum ((ut8)str[*end])) { ++(*end); } return TT_WORD; } if (isdigit ((ut8)str[*begin])) { *end = *begin; while (end && isalnum ((ut8)str[*end])) { ++(*end); } return TT_NUMBER; } else { *end = *begin + 1; return TT_SPECIAL; } }"
695,6257----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-nfs.c----nfs_printfh,"nfs_printfh(netdissect_options *ndo, register const uint32_t *dp, const u_int len) { my_fsid fsid; uint32_t ino; const char *sfsname = NULL; char *spacep; if (ndo->ndo_uflag) { u_int i; char const *sep = """"; ND_PRINT((ndo, "" fh["")); for (i=0; i<len; i++) { ND_PRINT((ndo, ""%s%x"", sep, dp[i])); sep = "":""; } ND_PRINT((ndo, ""]"")); return; } Parse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0); if (sfsname) { <S2SV_StartVul> static char temp[NFSX_V3FHMAX+1]; <S2SV_EndVul> <S2SV_StartVul> strncpy(temp, sfsname, NFSX_V3FHMAX); <S2SV_EndVul> <S2SV_StartVul> temp[sizeof(temp) - 1] = '\0'; <S2SV_EndVul> spacep = strchr(temp, ' '); if (spacep) *spacep = '\0'; ND_PRINT((ndo, "" fh %s/"", temp)); } else { ND_PRINT((ndo, "" fh %d,%d/"", fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor)); } if(fsid.Fsid_dev.Minor == 257) ND_PRINT((ndo, ""%s"", fsid.Opaque_Handle)); else ND_PRINT((ndo, ""%ld"", (long) ino)); }","- static char temp[NFSX_V3FHMAX+1];
- strncpy(temp, sfsname, NFSX_V3FHMAX);
- temp[sizeof(temp) - 1] = '\0';
+ char temp[NFSX_V3FHMAX+1];
+ u_int stringlen;
+ stringlen = len;
+ if (stringlen > NFSX_V3FHMAX)
+ stringlen = NFSX_V3FHMAX;
+ strncpy(temp, sfsname, stringlen);
+ temp[stringlen] = '\0';","nfs_printfh(netdissect_options *ndo, register const uint32_t *dp, const u_int len) { my_fsid fsid; uint32_t ino; const char *sfsname = NULL; char *spacep; if (ndo->ndo_uflag) { u_int i; char const *sep = """"; ND_PRINT((ndo, "" fh["")); for (i=0; i<len; i++) { ND_PRINT((ndo, ""%s%x"", sep, dp[i])); sep = "":""; } ND_PRINT((ndo, ""]"")); return; } Parse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0); if (sfsname) { char temp[NFSX_V3FHMAX+1]; u_int stringlen; stringlen = len; if (stringlen > NFSX_V3FHMAX) stringlen = NFSX_V3FHMAX; strncpy(temp, sfsname, stringlen); temp[stringlen] = '\0'; spacep = strchr(temp, ' '); if (spacep) *spacep = '\0'; ND_PRINT((ndo, "" fh %s/"", temp)); } else { ND_PRINT((ndo, "" fh %d,%d/"", fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor)); } if(fsid.Fsid_dev.Minor == 257) ND_PRINT((ndo, ""%s"", fsid.Opaque_Handle)); else ND_PRINT((ndo, ""%ld"", (long) ino)); }"
696,3850----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/config.c----errorLogDirective,"static int errorLogDirective(MaState *state, cchar *key, cchar *value) { MprTicks stamp; char *option, *ovalue, *tok, *path; ssize size; int level, flags, backup; if (mprGetCmdlineLogging()) { mprLog(""info appweb config"", 4, ""Already logging. Ignoring ErrorLog directive""); return 0; } size = MAXINT; stamp = 0; level = 0; backup = 0; path = 0; flags = 0; for (option = maGetNextArg(sclone(value), &tok); option; option = maGetNextArg(tok, &tok)) { if (!path) { path = mprJoinPath(httpGetRouteVar(state->route, ""LOG_DIR""), httpExpandRouteVars(state->route, option)); } else { <S2SV_StartVul> option = stok(option, "" =\t,"", &ovalue); <S2SV_EndVul> ovalue = strim(ovalue, ""\""'"", MPR_TRIM_BOTH); if (smatch(option, ""size"")) { size = (ssize) getnum(ovalue); } else if (smatch(option, ""level"")) { level = atoi(ovalue); } else if (smatch(option, ""backup"")) { backup = atoi(ovalue); } else if (smatch(option, ""anew"")) { flags |= MPR_LOG_ANEW; } else if (smatch(option, ""stamp"")) { stamp = httpGetTicks(ovalue); } else { mprLog(""error appweb config"", 0, ""Unknown ErrorLog option %s"", option); } } } if (size < (10 * 1000)) { mprLog(""error appweb config"", 0, ""Size is too small. Must be larger than 10K""); return MPR_ERR_BAD_SYNTAX; } if (path == 0) { mprLog(""error appweb config"", 0, ""Missing filename""); return MPR_ERR_BAD_SYNTAX; } mprSetLogBackup(size, backup, flags); if (!smatch(path, ""stdout"") && !smatch(path, ""stderr"")) { path = httpMakePath(state->route, state->configDir, path); } if (mprStartLogging(path, MPR_LOG_DETAILED) < 0) { mprLog(""error appweb config"", 0, ""Cannot write to ErrorLog: %s"", path); return MPR_ERR_BAD_SYNTAX; } mprSetLogLevel(level); mprLogHeader(); if (stamp) { httpSetTimestamp(stamp); } return 0; }","- option = stok(option, "" =\t,"", &ovalue);
+ option = ssplit(option, "" =\t,"", &ovalue);","static int errorLogDirective(MaState *state, cchar *key, cchar *value) { MprTicks stamp; char *option, *ovalue, *tok, *path; ssize size; int level, flags, backup; if (mprGetCmdlineLogging()) { mprLog(""info appweb config"", 4, ""Already logging. Ignoring ErrorLog directive""); return 0; } size = MAXINT; stamp = 0; level = 0; backup = 0; path = 0; flags = 0; for (option = maGetNextArg(sclone(value), &tok); option; option = maGetNextArg(tok, &tok)) { if (!path) { path = mprJoinPath(httpGetRouteVar(state->route, ""LOG_DIR""), httpExpandRouteVars(state->route, option)); } else { option = ssplit(option, "" =\t,"", &ovalue); ovalue = strim(ovalue, ""\""'"", MPR_TRIM_BOTH); if (smatch(option, ""size"")) { size = (ssize) getnum(ovalue); } else if (smatch(option, ""level"")) { level = atoi(ovalue); } else if (smatch(option, ""backup"")) { backup = atoi(ovalue); } else if (smatch(option, ""anew"")) { flags |= MPR_LOG_ANEW; } else if (smatch(option, ""stamp"")) { stamp = httpGetTicks(ovalue); } else { mprLog(""error appweb config"", 0, ""Unknown ErrorLog option %s"", option); } } } if (size < (10 * 1000)) { mprLog(""error appweb config"", 0, ""Size is too small. Must be larger than 10K""); return MPR_ERR_BAD_SYNTAX; } if (path == 0) { mprLog(""error appweb config"", 0, ""Missing filename""); return MPR_ERR_BAD_SYNTAX; } mprSetLogBackup(size, backup, flags); if (!smatch(path, ""stdout"") && !smatch(path, ""stderr"")) { path = httpMakePath(state->route, state->configDir, path); } if (mprStartLogging(path, MPR_LOG_DETAILED) < 0) { mprLog(""error appweb config"", 0, ""Cannot write to ErrorLog: %s"", path); return MPR_ERR_BAD_SYNTAX; } mprSetLogLevel(level); mprLogHeader(); if (stamp) { httpSetTimestamp(stamp); } return 0; }"
697,3536----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pkcs15-oberthur.c----sc_oberthur_read_file,"sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path, unsigned char **out, size_t *out_len, int verify_pin) { struct sc_context *ctx = p15card->card->ctx; struct sc_card *card = p15card->card; struct sc_file *file = NULL; struct sc_path path; size_t sz; int rv; LOG_FUNC_CALLED(ctx); if (!in_path || !out || !out_len) LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file""); sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin); *out = NULL; *out_len = 0; sc_format_path(in_path, &path); rv = sc_select_file(card, &path, &file); if (rv != SC_SUCCESS) { sc_file_free(file); LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read""); } if (file->ef_structure == SC_FILE_EF_TRANSPARENT) sz = file->size; else sz = (file->record_length + 2) * file->record_count; *out = calloc(sz, 1); if (*out == NULL) { sc_file_free(file); LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file""); } if (file->ef_structure == SC_FILE_EF_TRANSPARENT) { rv = sc_read_binary(card, 0, *out, sz, 0); } else { <S2SV_StartVul> int rec; <S2SV_EndVul> <S2SV_StartVul> int offs = 0; <S2SV_EndVul> <S2SV_StartVul> int rec_len = file->record_length; <S2SV_EndVul> for (rec = 1; ; rec++) { rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR); if (rv == SC_ERROR_RECORD_NOT_FOUND) { rv = 0; break; } else if (rv < 0) { break; } rec_len = rv; *(*out + offs) = 'R'; *(*out + offs + 1) = rv; offs += rv + 2; } sz = offs; } sc_log(ctx, ""read oberthur file result %i"", rv); if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED) { struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL; const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ); int ii; rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10); if (rv != SC_SUCCESS) { sc_file_free(file); LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error""); } for (ii=0; ii<rv; ii++) { struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data; sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"", auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method); if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method) { pin_obj = objs[ii]; break; } } if (!pin_obj || !pin_obj->content.value) { rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED; } else { rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len); if (!rv) rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0); } }; sc_file_free(file); if (rv < 0) { free(*out); *out = NULL; *out_len = 0; } *out_len = sz; LOG_FUNC_RETURN(ctx, rv); }","- int rec;
- int offs = 0;
- int rec_len = file->record_length;
+ size_t rec;
+ size_t offs = 0;
+ size_t rec_len = file->record_length;
+ if (rec > file->record_count) {
+ rv = 0;
+ break;
+ }","sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path, unsigned char **out, size_t *out_len, int verify_pin) { struct sc_context *ctx = p15card->card->ctx; struct sc_card *card = p15card->card; struct sc_file *file = NULL; struct sc_path path; size_t sz; int rv; LOG_FUNC_CALLED(ctx); if (!in_path || !out || !out_len) LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file""); sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin); *out = NULL; *out_len = 0; sc_format_path(in_path, &path); rv = sc_select_file(card, &path, &file); if (rv != SC_SUCCESS) { sc_file_free(file); LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read""); } if (file->ef_structure == SC_FILE_EF_TRANSPARENT) sz = file->size; else sz = (file->record_length + 2) * file->record_count; *out = calloc(sz, 1); if (*out == NULL) { sc_file_free(file); LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file""); } if (file->ef_structure == SC_FILE_EF_TRANSPARENT) { rv = sc_read_binary(card, 0, *out, sz, 0); } else { size_t rec; size_t offs = 0; size_t rec_len = file->record_length; for (rec = 1; ; rec++) { if (rec > file->record_count) { rv = 0; break; } rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR); if (rv == SC_ERROR_RECORD_NOT_FOUND) { rv = 0; break; } else if (rv < 0) { break; } rec_len = rv; *(*out + offs) = 'R'; *(*out + offs + 1) = rv; offs += rv + 2; } sz = offs; } sc_log(ctx, ""read oberthur file result %i"", rv); if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED) { struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL; const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ); int ii; rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10); if (rv != SC_SUCCESS) { sc_file_free(file); LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error""); } for (ii=0; ii<rv; ii++) { struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data; sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"", auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method); if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method) { pin_obj = objs[ii]; break; } } if (!pin_obj || !pin_obj->content.value) { rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED; } else { rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len); if (!rv) rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0); } }; sc_file_free(file); if (rv < 0) { free(*out); *out = NULL; *out_len = 0; } *out_len = sz; LOG_FUNC_RETURN(ctx, rv); }"
698,5673----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event.c----perf_event_interrupt,"static void perf_event_interrupt(struct pt_regs *regs) { int i; struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events); struct perf_event *event; unsigned long val; int found = 0; int nmi; if (cpuhw->n_limited) freeze_limited_counters(cpuhw, mfspr(SPRN_PMC5), mfspr(SPRN_PMC6)); perf_read_regs(regs); nmi = perf_intr_is_nmi(regs); if (nmi) nmi_enter(); else irq_enter(); for (i = 0; i < cpuhw->n_events; ++i) { event = cpuhw->event[i]; if (!event->hw.idx || is_limited_pmc(event->hw.idx)) continue; val = read_pmc(event->hw.idx); if ((int)val < 0) { found = 1; record_and_restart(event, val, regs, nmi); } } if (!found) { for (i = 0; i < ppmu->n_counter; ++i) { if (is_limited_pmc(i + 1)) continue; val = read_pmc(i + 1); <S2SV_StartVul> if ((int)val < 0) <S2SV_EndVul> write_pmc(i + 1, 0); } } write_mmcr0(cpuhw, cpuhw->mmcr[0]); if (nmi) nmi_exit(); else irq_exit(); }","- if ((int)val < 0)
+ if (pmc_overflow(val))","static void perf_event_interrupt(struct pt_regs *regs) { int i; struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events); struct perf_event *event; unsigned long val; int found = 0; int nmi; if (cpuhw->n_limited) freeze_limited_counters(cpuhw, mfspr(SPRN_PMC5), mfspr(SPRN_PMC6)); perf_read_regs(regs); nmi = perf_intr_is_nmi(regs); if (nmi) nmi_enter(); else irq_enter(); for (i = 0; i < cpuhw->n_events; ++i) { event = cpuhw->event[i]; if (!event->hw.idx || is_limited_pmc(event->hw.idx)) continue; val = read_pmc(event->hw.idx); if ((int)val < 0) { found = 1; record_and_restart(event, val, regs, nmi); } } if (!found) { for (i = 0; i < ppmu->n_counter; ++i) { if (is_limited_pmc(i + 1)) continue; val = read_pmc(i + 1); if (pmc_overflow(val)) write_pmc(i + 1, 0); } } write_mmcr0(cpuhw, cpuhw->mmcr[0]); if (nmi) nmi_exit(); else irq_exit(); }"
699,3244----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cjson.c----cJSON_DeleteItemFromArray,"<S2SV_StartVul> void cJSON_DeleteItemFromArray( cJSON *array, int which ) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> cJSON_Delete( cJSON_DetachItemFromArray( array, which ) ); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- void cJSON_DeleteItemFromArray( cJSON *array, int which )
- {
- cJSON_Delete( cJSON_DetachItemFromArray( array, which ) );
- }
+ void cJSON_DeleteItemFromArray(cJSON *array,int which) {cJSON_Delete(cJSON_DetachItemFromArray(array,which));}","void cJSON_DeleteItemFromArray(cJSON *array,int which) {cJSON_Delete(cJSON_DetachItemFromArray(array,which));}"
700,2300----CWE-665----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-12730--aadec.c----aa_read_header,"static int aa_read_header(AVFormatContext *s) { int i, j, idx, largest_idx = -1; uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start; char key[128], val[128], codec_name[64] = {0}; uint8_t output[24], dst[8], src[8]; int64_t largest_size = -1, current_size = -1, chapter_pos; struct toc_entry { uint32_t offset; uint32_t size; } TOC[MAX_TOC_ENTRIES]; uint32_t header_key_part[4]; uint8_t header_key[16] = {0}; AADemuxContext *c = s->priv_data; AVIOContext *pb = s->pb; AVStream *st; avio_skip(pb, 4); avio_skip(pb, 4); toc_size = avio_rb32(pb); avio_skip(pb, 4); if (toc_size > MAX_TOC_ENTRIES) return AVERROR_INVALIDDATA; for (i = 0; i < toc_size; i++) { avio_skip(pb, 4); TOC[i].offset = avio_rb32(pb); TOC[i].size = avio_rb32(pb); } avio_skip(pb, 24); npairs = avio_rb32(pb); if (npairs > MAX_DICTIONARY_ENTRIES) return AVERROR_INVALIDDATA; for (i = 0; i < npairs; i++) { memset(val, 0, sizeof(val)); memset(key, 0, sizeof(key)); avio_skip(pb, 1); nkey = avio_rb32(pb); nval = avio_rb32(pb); avio_get_str(pb, nkey, key, sizeof(key)); avio_get_str(pb, nval, val, sizeof(val)); if (!strcmp(key, ""codec"")) { av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val); strncpy(codec_name, val, sizeof(codec_name) - 1); } else if (!strcmp(key, ""HeaderSeed"")) { av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val); header_seed = atoi(val); } else if (!strcmp(key, ""HeaderKey"")) { av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val); <S2SV_StartVul> sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32, <S2SV_EndVul> &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]); for (idx = 0; idx < 4; idx++) { AV_WB32(&header_key[idx * 4], header_key_part[idx]); } av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is ""); for (i = 0; i < 16; i++) av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]); av_log(s, AV_LOG_DEBUG, ""\n""); } else { av_dict_set(&s->metadata, key, val, 0); } } if (c->aa_fixed_key_len != 16) { av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n""); return AVERROR(EINVAL); } if ((c->codec_second_size = get_second_size(codec_name)) == -1) { av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name); return AVERROR(EINVAL); } c->tea_ctx = av_tea_alloc(); if (!c->tea_ctx) return AVERROR(ENOMEM); av_tea_init(c->tea_ctx, c->aa_fixed_key, 16); output[0] = output[1] = 0; memcpy(output + 2, header_key, 16); idx = 0; for (i = 0; i < 3; i++) { AV_WB32(src, header_seed); AV_WB32(src + 4, header_seed + 1); header_seed += 2; av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) { output[idx] = output[idx] ^ dst[j]; } } memcpy(c->file_key, output + 2, 16); av_log(s, AV_LOG_DEBUG, ""File key is ""); for (i = 0; i < 16; i++) av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]); av_log(s, AV_LOG_DEBUG, ""\n""); st = avformat_new_stream(s, NULL); if (!st) { av_freep(&c->tea_ctx); return AVERROR(ENOMEM); } st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; if (!strcmp(codec_name, ""mp332"")) { st->codecpar->codec_id = AV_CODEC_ID_MP3; st->codecpar->sample_rate = 22050; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC); } else if (!strcmp(codec_name, ""acelp85"")) { st->codecpar->codec_id = AV_CODEC_ID_SIPR; st->codecpar->block_align = 19; st->codecpar->channels = 1; st->codecpar->sample_rate = 8500; st->codecpar->bit_rate = 8500; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC); } else if (!strcmp(codec_name, ""acelp16"")) { st->codecpar->codec_id = AV_CODEC_ID_SIPR; st->codecpar->block_align = 20; st->codecpar->channels = 1; st->codecpar->sample_rate = 16000; st->codecpar->bit_rate = 16000; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC); } for (i = 1; i < toc_size; i++) { current_size = TOC[i].size; if (current_size > largest_size) { largest_idx = i; largest_size = current_size; } } start = TOC[largest_idx].offset; avio_seek(pb, start, SEEK_SET); st->start_time = 0; c->content_start = start; c->content_end = start + largest_size; while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) { int chapter_idx = s->nb_chapters; uint32_t chapter_size = avio_rb32(pb); if (chapter_size == 0) break; chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx; avio_skip(pb, 4 + chapter_size); if (!avpriv_new_chapter(s, chapter_idx, st->time_base, chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL)) return AVERROR(ENOMEM); } st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC; ff_update_cur_dts(s, st, 0); avio_seek(pb, start, SEEK_SET); c->current_chapter_size = 0; c->seek_offset = 0; return 0; }","- sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
+ int ret;
+ ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
+ if (ret != 4)
+ return AVERROR_INVALIDDATA;","static int aa_read_header(AVFormatContext *s) { int i, j, idx, largest_idx = -1; uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start; char key[128], val[128], codec_name[64] = {0}; uint8_t output[24], dst[8], src[8]; int64_t largest_size = -1, current_size = -1, chapter_pos; struct toc_entry { uint32_t offset; uint32_t size; } TOC[MAX_TOC_ENTRIES]; uint32_t header_key_part[4]; uint8_t header_key[16] = {0}; AADemuxContext *c = s->priv_data; AVIOContext *pb = s->pb; AVStream *st; int ret; avio_skip(pb, 4); avio_skip(pb, 4); toc_size = avio_rb32(pb); avio_skip(pb, 4); if (toc_size > MAX_TOC_ENTRIES) return AVERROR_INVALIDDATA; for (i = 0; i < toc_size; i++) { avio_skip(pb, 4); TOC[i].offset = avio_rb32(pb); TOC[i].size = avio_rb32(pb); } avio_skip(pb, 24); npairs = avio_rb32(pb); if (npairs > MAX_DICTIONARY_ENTRIES) return AVERROR_INVALIDDATA; for (i = 0; i < npairs; i++) { memset(val, 0, sizeof(val)); memset(key, 0, sizeof(key)); avio_skip(pb, 1); nkey = avio_rb32(pb); nval = avio_rb32(pb); avio_get_str(pb, nkey, key, sizeof(key)); avio_get_str(pb, nval, val, sizeof(val)); if (!strcmp(key, ""codec"")) { av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val); strncpy(codec_name, val, sizeof(codec_name) - 1); } else if (!strcmp(key, ""HeaderSeed"")) { av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val); header_seed = atoi(val); } else if (!strcmp(key, ""HeaderKey"")) { av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val); ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32, &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]); if (ret != 4) return AVERROR_INVALIDDATA; for (idx = 0; idx < 4; idx++) { AV_WB32(&header_key[idx * 4], header_key_part[idx]); } av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is ""); for (i = 0; i < 16; i++) av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]); av_log(s, AV_LOG_DEBUG, ""\n""); } else { av_dict_set(&s->metadata, key, val, 0); } } if (c->aa_fixed_key_len != 16) { av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n""); return AVERROR(EINVAL); } if ((c->codec_second_size = get_second_size(codec_name)) == -1) { av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name); return AVERROR(EINVAL); } c->tea_ctx = av_tea_alloc(); if (!c->tea_ctx) return AVERROR(ENOMEM); av_tea_init(c->tea_ctx, c->aa_fixed_key, 16); output[0] = output[1] = 0; memcpy(output + 2, header_key, 16); idx = 0; for (i = 0; i < 3; i++) { AV_WB32(src, header_seed); AV_WB32(src + 4, header_seed + 1); header_seed += 2; av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) { output[idx] = output[idx] ^ dst[j]; } } memcpy(c->file_key, output + 2, 16); av_log(s, AV_LOG_DEBUG, ""File key is ""); for (i = 0; i < 16; i++) av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]); av_log(s, AV_LOG_DEBUG, ""\n""); st = avformat_new_stream(s, NULL); if (!st) { av_freep(&c->tea_ctx); return AVERROR(ENOMEM); } st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; if (!strcmp(codec_name, ""mp332"")) { st->codecpar->codec_id = AV_CODEC_ID_MP3; st->codecpar->sample_rate = 22050; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC); } else if (!strcmp(codec_name, ""acelp85"")) { st->codecpar->codec_id = AV_CODEC_ID_SIPR; st->codecpar->block_align = 19; st->codecpar->channels = 1; st->codecpar->sample_rate = 8500; st->codecpar->bit_rate = 8500; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC); } else if (!strcmp(codec_name, ""acelp16"")) { st->codecpar->codec_id = AV_CODEC_ID_SIPR; st->codecpar->block_align = 20; st->codecpar->channels = 1; st->codecpar->sample_rate = 16000; st->codecpar->bit_rate = 16000; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC); } for (i = 1; i < toc_size; i++) { current_size = TOC[i].size; if (current_size > largest_size) { largest_idx = i; largest_size = current_size; } } start = TOC[largest_idx].offset; avio_seek(pb, start, SEEK_SET); st->start_time = 0; c->content_start = start; c->content_end = start + largest_size; while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) { int chapter_idx = s->nb_chapters; uint32_t chapter_size = avio_rb32(pb); if (chapter_size == 0) break; chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx; avio_skip(pb, 4 + chapter_size); if (!avpriv_new_chapter(s, chapter_idx, st->time_base, chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL)) return AVERROR(ENOMEM); } st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC; ff_update_cur_dts(s, st, 0); avio_seek(pb, start, SEEK_SET); c->current_chapter_size = 0; c->seek_offset = 0; return 0; }"
701,6265----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ec_gtk_mitm.c----gtkui_icmp_redir,"void gtkui_icmp_redir(void) { GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame; gint response = 0; DEBUG_MSG(""gtk_icmp_redir""); dialog = gtk_dialog_new_with_buttons(""MITM Attack: ICMP Redirect"", GTK_WINDOW (window), GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL); gtk_container_set_border_width(GTK_CONTAINER (dialog), 5); gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE); hbox = gtk_hbox_new (FALSE, 5); gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0); gtk_widget_show(hbox); image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG); gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1); gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5); gtk_widget_show(image); frame = gtk_frame_new(""Gateway Information""); gtk_container_set_border_width(GTK_CONTAINER (frame), 5); gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0); gtk_widget_show(frame); table = gtk_table_new(2, 2, FALSE); gtk_table_set_row_spacings(GTK_TABLE (table), 5); gtk_table_set_col_spacings(GTK_TABLE (table), 5); gtk_container_set_border_width(GTK_CONTAINER (table), 8); gtk_container_add(GTK_CONTAINER (frame), table); gtk_widget_show(table); label = gtk_label_new(""MAC Address""); gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5); gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0); gtk_widget_show(label); entry1 = gtk_entry_new(); gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN); gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1); gtk_widget_show(entry1); label = gtk_label_new(""IP Address""); gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5); gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0); gtk_widget_show(label); entry2 = gtk_entry_new(); gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN); gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2); gtk_widget_show(entry2); response = gtk_dialog_run(GTK_DIALOG(dialog)); if(response == GTK_RESPONSE_OK) { gtk_widget_hide(dialog); snprintf(params, 6, ""icmp:""); <S2SV_StartVul> strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN); <S2SV_EndVul> <S2SV_StartVul> strncat(params, ""/"", PARAMS_LEN); <S2SV_EndVul> <S2SV_StartVul> strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN); <S2SV_EndVul> gtkui_start_mitm(); } gtk_widget_destroy(dialog); }","- strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN);
- strncat(params, ""/"", PARAMS_LEN);
- strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN);
+ strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), ETH_ASCII_ADDR_LEN);
+ strncat(params, ""/"", 1);
+ strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), IP6_ASCII_ADDR_LEN);","void gtkui_icmp_redir(void) { GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame; gint response = 0; DEBUG_MSG(""gtk_icmp_redir""); dialog = gtk_dialog_new_with_buttons(""MITM Attack: ICMP Redirect"", GTK_WINDOW (window), GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL); gtk_container_set_border_width(GTK_CONTAINER (dialog), 5); gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE); hbox = gtk_hbox_new (FALSE, 5); gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0); gtk_widget_show(hbox); image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG); gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1); gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5); gtk_widget_show(image); frame = gtk_frame_new(""Gateway Information""); gtk_container_set_border_width(GTK_CONTAINER (frame), 5); gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0); gtk_widget_show(frame); table = gtk_table_new(2, 2, FALSE); gtk_table_set_row_spacings(GTK_TABLE (table), 5); gtk_table_set_col_spacings(GTK_TABLE (table), 5); gtk_container_set_border_width(GTK_CONTAINER (table), 8); gtk_container_add(GTK_CONTAINER (frame), table); gtk_widget_show(table); label = gtk_label_new(""MAC Address""); gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5); gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0); gtk_widget_show(label); entry1 = gtk_entry_new(); gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN); gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1); gtk_widget_show(entry1); label = gtk_label_new(""IP Address""); gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5); gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0); gtk_widget_show(label); entry2 = gtk_entry_new(); gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN); gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2); gtk_widget_show(entry2); response = gtk_dialog_run(GTK_DIALOG(dialog)); if(response == GTK_RESPONSE_OK) { gtk_widget_hide(dialog); snprintf(params, 6, ""icmp:""); strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), ETH_ASCII_ADDR_LEN); strncat(params, ""/"", 1); strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), IP6_ASCII_ADDR_LEN); gtkui_start_mitm(); } gtk_widget_destroy(dialog); }"
702,6347----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/index.c----mobi_trie_insert_infl,"MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) { MOBIIndexEntry e = indx->entries[i]; char *inflected = e.label; for (size_t j = 0; j < e.tags_count; j++) { MOBIIndexTag t = e.tags[j]; if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) { <S2SV_StartVul> for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) { <S2SV_EndVul> uint32_t len = t.tagvalues[k]; uint32_t offset = t.tagvalues[k + 1]; char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len); if (base == NULL) { return MOBI_MALLOC_FAILED; } MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected); free(base); if (ret != MOBI_SUCCESS) { return ret; } } } } return MOBI_SUCCESS; }","- for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {
+ for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) {","MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) { MOBIIndexEntry e = indx->entries[i]; char *inflected = e.label; for (size_t j = 0; j < e.tags_count; j++) { MOBIIndexTag t = e.tags[j]; if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) { for (size_t k = 0; k + 1 < t.tagvalues_count; k += 2) { uint32_t len = t.tagvalues[k]; uint32_t offset = t.tagvalues[k + 1]; char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len); if (base == NULL) { return MOBI_MALLOC_FAILED; } MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected); free(base); if (ret != MOBI_SUCCESS) { return ret; } } } } return MOBI_SUCCESS; }"
703,1687----CWE-532----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-0380--rendservice.c----rend_service_intro_established,"rend_service_intro_established(origin_circuit_t *circuit, const uint8_t *request, size_t request_len) { rend_service_t *service; rend_intro_point_t *intro; char serviceid[REND_SERVICE_ID_LEN_BASE32+1]; (void) request; (void) request_len; tor_assert(circuit->rend_data); const char *rend_pk_digest = (char *) rend_data_get_pk_digest(circuit->rend_data, NULL); if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) { log_warn(LD_PROTOCOL, ""received INTRO_ESTABLISHED cell on non-intro circuit.""); goto err; } service = rend_service_get_by_pk_digest(rend_pk_digest); if (!service) { log_warn(LD_REND, ""Unknown service on introduction circuit %u."", (unsigned)circuit->base_.n_circ_id); goto err; } intro = find_intro_point(circuit); if (intro == NULL) { log_warn(LD_REND, ""Introduction circuit established without a rend_intro_point_t "" ""object for service %s on circuit %u"", safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id); goto err; } intro->circuit_established = 1; service->desc_is_dirty = time(NULL); circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO); <S2SV_StartVul> base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1, <S2SV_EndVul> <S2SV_StartVul> rend_pk_digest, REND_SERVICE_ID_LEN); <S2SV_EndVul> log_info(LD_REND, ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"", (unsigned)circuit->base_.n_circ_id, serviceid); pathbias_mark_use_success(circuit); return 0; err: circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL); return -1; }","- base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
- rend_pk_digest, REND_SERVICE_ID_LEN);
+ base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,
+ rend_pk_digest, REND_SERVICE_ID_LEN);","rend_service_intro_established(origin_circuit_t *circuit, const uint8_t *request, size_t request_len) { rend_service_t *service; rend_intro_point_t *intro; char serviceid[REND_SERVICE_ID_LEN_BASE32+1]; (void) request; (void) request_len; tor_assert(circuit->rend_data); const char *rend_pk_digest = (char *) rend_data_get_pk_digest(circuit->rend_data, NULL); if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) { log_warn(LD_PROTOCOL, ""received INTRO_ESTABLISHED cell on non-intro circuit.""); goto err; } service = rend_service_get_by_pk_digest(rend_pk_digest); if (!service) { log_warn(LD_REND, ""Unknown service on introduction circuit %u."", (unsigned)circuit->base_.n_circ_id); goto err; } base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1, rend_pk_digest, REND_SERVICE_ID_LEN); intro = find_intro_point(circuit); if (intro == NULL) { log_warn(LD_REND, ""Introduction circuit established without a rend_intro_point_t "" ""object for service %s on circuit %u"", safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id); goto err; } intro->circuit_established = 1; service->desc_is_dirty = time(NULL); circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO); log_info(LD_REND, ""Received INTRO_ESTABLISHED cell on circuit %u for service %s"", (unsigned)circuit->base_.n_circ_id, serviceid); pathbias_mark_use_success(circuit); return 0; err: circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL); return -1; }"
704,5242----CWE-611----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/apache2_config.c----cmd_hash_engine,"static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1) { directory_config *dcfg = (directory_config *)_dcfg; if (dcfg == NULL) return NULL; if (strcasecmp(p1, ""on"") == 0) { dcfg->hash_is_enabled = HASH_ENABLED; dcfg->hash_enforcement = HASH_ENABLED; } else if (strcasecmp(p1, ""off"") == 0) { dcfg->hash_is_enabled = HASH_DISABLED; dcfg->hash_enforcement = HASH_DISABLED; } <S2SV_StartVul> else return apr_psprintf(cmd->pool, ""ModSecurity: Invalid value for SecRuleEngine: %s"", p1); <S2SV_EndVul> return NULL; }","- else return apr_psprintf(cmd->pool, ""ModSecurity: Invalid value for SecRuleEngine: %s"", p1);
+ else return apr_psprintf(cmd->pool, ""ModSecurity: Invalid value for SexHashEngine: %s"", p1);","static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1) { directory_config *dcfg = (directory_config *)_dcfg; if (dcfg == NULL) return NULL; if (strcasecmp(p1, ""on"") == 0) { dcfg->hash_is_enabled = HASH_ENABLED; dcfg->hash_enforcement = HASH_ENABLED; } else if (strcasecmp(p1, ""off"") == 0) { dcfg->hash_is_enabled = HASH_DISABLED; dcfg->hash_enforcement = HASH_DISABLED; } else return apr_psprintf(cmd->pool, ""ModSecurity: Invalid value for SexHashEngine: %s"", p1); return NULL; }"
705,2024----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-12232--socket.c----sockfs_setattr,"static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr) { int err = simple_setattr(dentry, iattr); if (!err && (iattr->ia_valid & ATTR_UID)) { struct socket *sock = SOCKET_I(d_inode(dentry)); <S2SV_StartVul> sock->sk->sk_uid = iattr->ia_uid; <S2SV_EndVul> } return err; }","- sock->sk->sk_uid = iattr->ia_uid;
+ if (sock->sk)
+ sock->sk->sk_uid = iattr->ia_uid;
+ else
+ err = -ENOENT;","static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr) { int err = simple_setattr(dentry, iattr); if (!err && (iattr->ia_valid & ATTR_UID)) { struct socket *sock = SOCKET_I(d_inode(dentry)); if (sock->sk) sock->sk->sk_uid = iattr->ia_uid; else err = -ENOENT; } return err; }"
706,4633----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inode.c----ext4_write_begin,"static int ext4_write_begin(struct file *file, struct address_space *mapping, loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata) { struct inode *inode = mapping->host; int ret, needed_blocks; handle_t *handle; int retries = 0; struct page *page; pgoff_t index; unsigned from, to; trace_ext4_write_begin(inode, pos, len, flags); needed_blocks = ext4_writepage_trans_blocks(inode) + 1; index = pos >> PAGE_CACHE_SHIFT; from = pos & (PAGE_CACHE_SIZE - 1); to = from + len; retry: handle = ext4_journal_start(inode, needed_blocks); if (IS_ERR(handle)) { ret = PTR_ERR(handle); goto out; } flags |= AOP_FLAG_NOFS; page = grab_cache_page_write_begin(mapping, index, flags); if (!page) { ext4_journal_stop(handle); ret = -ENOMEM; goto out; } *pagep = page; <S2SV_StartVul> ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata, <S2SV_EndVul> <S2SV_StartVul> ext4_get_block); <S2SV_EndVul> if (!ret && ext4_should_journal_data(inode)) { ret = walk_page_buffers(handle, page_buffers(page), from, to, NULL, do_journal_get_write_access); } if (ret) { unlock_page(page); page_cache_release(page); if (pos + len > inode->i_size && ext4_can_truncate(inode)) ext4_orphan_add(handle, inode); ext4_journal_stop(handle); if (pos + len > inode->i_size) { ext4_truncate_failed_write(inode); if (inode->i_nlink) ext4_orphan_del(NULL, inode); } } if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries)) goto retry; out: return ret; }","- ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,
- ext4_get_block);
+ if (ext4_should_dioread_nolock(inode))
+ ret = block_write_begin(file, mapping, pos, len, flags, pagep,
+ fsdata, ext4_get_block_write);
+ else
+ ret = block_write_begin(file, mapping, pos, len, flags, pagep,
+ fsdata, ext4_get_block);","static int ext4_write_begin(struct file *file, struct address_space *mapping, loff_t pos, unsigned len, unsigned flags, struct page **pagep, void **fsdata) { struct inode *inode = mapping->host; int ret, needed_blocks; handle_t *handle; int retries = 0; struct page *page; pgoff_t index; unsigned from, to; trace_ext4_write_begin(inode, pos, len, flags); needed_blocks = ext4_writepage_trans_blocks(inode) + 1; index = pos >> PAGE_CACHE_SHIFT; from = pos & (PAGE_CACHE_SIZE - 1); to = from + len; retry: handle = ext4_journal_start(inode, needed_blocks); if (IS_ERR(handle)) { ret = PTR_ERR(handle); goto out; } flags |= AOP_FLAG_NOFS; page = grab_cache_page_write_begin(mapping, index, flags); if (!page) { ext4_journal_stop(handle); ret = -ENOMEM; goto out; } *pagep = page; if (ext4_should_dioread_nolock(inode)) ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata, ext4_get_block_write); else ret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata, ext4_get_block); if (!ret && ext4_should_journal_data(inode)) { ret = walk_page_buffers(handle, page_buffers(page), from, to, NULL, do_journal_get_write_access); } if (ret) { unlock_page(page); page_cache_release(page); if (pos + len > inode->i_size && ext4_can_truncate(inode)) ext4_orphan_add(handle, inode); ext4_journal_stop(handle); if (pos + len > inode->i_size) { ext4_truncate_failed_write(inode); if (inode->i_nlink) ext4_orphan_del(NULL, inode); } } if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries)) goto retry; out: return ret; }"
707,4503----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/archive_string.c----archive_string_append_from_wcs,"archive_string_append_from_wcs(struct archive_string *as, const wchar_t *w, size_t len) { int n, ret_val = 0; char *p; char *end; #if HAVE_WCRTOMB mbstate_t shift_state; memset(&shift_state, 0, sizeof(shift_state)); #else wctomb(NULL, L'\0'); #endif if (archive_string_ensure(as, as->length + len + 1) == NULL) return (-1); p = as->s + as->length; end = as->s + as->buffer_length - MB_CUR_MAX -1; while (*w != L'\0' && len > 0) { if (p >= end) { as->length = p - as->s; as->s[as->length] = '\0'; if (archive_string_ensure(as, <S2SV_StartVul> as->length + len * 2 + 1) == NULL) <S2SV_EndVul> return (-1); p = as->s + as->length; end = as->s + as->buffer_length - MB_CUR_MAX -1; } #if HAVE_WCRTOMB n = wcrtomb(p, *w++, &shift_state); #else n = wctomb(p, *w++); #endif if (n == -1) { if (errno == EILSEQ) { *p++ = '?'; ret_val = -1; } else { ret_val = -1; break; } } else p += n; len--; } as->length = p - as->s; as->s[as->length] = '\0'; return (ret_val); }","- as->length + len * 2 + 1) == NULL)
+ as->length + max(len * 2,
+ (size_t)MB_CUR_MAX) + 1) == NULL)","archive_string_append_from_wcs(struct archive_string *as, const wchar_t *w, size_t len) { int n, ret_val = 0; char *p; char *end; #if HAVE_WCRTOMB mbstate_t shift_state; memset(&shift_state, 0, sizeof(shift_state)); #else wctomb(NULL, L'\0'); #endif if (archive_string_ensure(as, as->length + len + 1) == NULL) return (-1); p = as->s + as->length; end = as->s + as->buffer_length - MB_CUR_MAX -1; while (*w != L'\0' && len > 0) { if (p >= end) { as->length = p - as->s; as->s[as->length] = '\0'; if (archive_string_ensure(as, as->length + max(len * 2, (size_t)MB_CUR_MAX) + 1) == NULL) return (-1); p = as->s + as->length; end = as->s + as->buffer_length - MB_CUR_MAX -1; } #if HAVE_WCRTOMB n = wcrtomb(p, *w++, &shift_state); #else n = wctomb(p, *w++); #endif if (n == -1) { if (errno == EILSEQ) { *p++ = '?'; ret_val = -1; } else { ret_val = -1; break; } } else p += n; len--; } as->length = p - as->s; as->s[as->length] = '\0'; return (ret_val); }"
708,7047----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/verifier.c----sanitize_ptr_alu,"static int sanitize_ptr_alu(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, struct bpf_reg_state *dst_reg, bool off_is_neg) { struct bpf_verifier_state *vstate = env->cur_state; struct bpf_insn_aux_data *aux = cur_aux(env); bool ptr_is_dst_reg = ptr_reg == dst_reg; u8 opcode = BPF_OP(insn->code); u32 alu_state, alu_limit; struct bpf_reg_state tmp; bool ret; <S2SV_StartVul> if (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K) <S2SV_EndVul> return 0; if (vstate->speculative) goto do_sim; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST; if (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg)) return 0; <S2SV_EndVul> <S2SV_StartVul> if (aux->alu_state && <S2SV_EndVul> <S2SV_StartVul> (aux->alu_state != alu_state || <S2SV_EndVul> <S2SV_StartVul> aux->alu_limit != alu_limit)) <S2SV_EndVul> return -EACCES; <S2SV_StartVul> aux->alu_state = alu_state; <S2SV_EndVul> <S2SV_StartVul> aux->alu_limit = alu_limit; <S2SV_EndVul> do_sim: if (!ptr_is_dst_reg) { tmp = *dst_reg; *dst_reg = *ptr_reg; } ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true); if (!ptr_is_dst_reg) *dst_reg = tmp; return !ret ? -EFAULT : 0; }","- if (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)
- if (aux->alu_state &&
- (aux->alu_state != alu_state ||
- aux->alu_limit != alu_limit))
- aux->alu_state = alu_state;
- aux->alu_limit = alu_limit;
+ if (can_skip_alu_sanitation(env, insn))
+ if (update_alu_sanitation_state(aux, alu_state, alu_limit))","static int sanitize_ptr_alu(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, struct bpf_reg_state *dst_reg, bool off_is_neg) { struct bpf_verifier_state *vstate = env->cur_state; struct bpf_insn_aux_data *aux = cur_aux(env); bool ptr_is_dst_reg = ptr_reg == dst_reg; u8 opcode = BPF_OP(insn->code); u32 alu_state, alu_limit; struct bpf_reg_state tmp; bool ret; if (can_skip_alu_sanitation(env, insn)) return 0; if (vstate->speculative) goto do_sim; alu_state = off_is_neg ? BPF_ALU_NEG_VALUE : 0; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST; if (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg)) return 0; if (update_alu_sanitation_state(aux, alu_state, alu_limit)) return -EACCES; do_sim: if (!ptr_is_dst_reg) { tmp = *dst_reg; *dst_reg = *ptr_reg; } ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true); if (!ptr_is_dst_reg) *dst_reg = tmp; return !ret ? -EFAULT : 0; }"
709,2573----CWE-415----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18174--pinctrl-amd.c----amd_gpio_probe,"static int amd_gpio_probe(struct platform_device *pdev) { int ret = 0; int irq_base; struct resource *res; struct amd_gpio *gpio_dev; gpio_dev = devm_kzalloc(&pdev->dev, sizeof(struct amd_gpio), GFP_KERNEL); if (!gpio_dev) return -ENOMEM; spin_lock_init(&gpio_dev->lock); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&pdev->dev, ""Failed to get gpio io resource.\n""); return -EINVAL; } gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start, resource_size(res)); if (!gpio_dev->base) return -ENOMEM; irq_base = platform_get_irq(pdev, 0); if (irq_base < 0) { dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n""); return -EINVAL; } gpio_dev->pdev = pdev; gpio_dev->gc.direction_input = amd_gpio_direction_input; gpio_dev->gc.direction_output = amd_gpio_direction_output; gpio_dev->gc.get = amd_gpio_get_value; gpio_dev->gc.set = amd_gpio_set_value; gpio_dev->gc.set_debounce = amd_gpio_set_debounce; gpio_dev->gc.dbg_show = amd_gpio_dbg_show; gpio_dev->gc.base = 0; gpio_dev->gc.label = pdev->name; gpio_dev->gc.owner = THIS_MODULE; gpio_dev->gc.parent = &pdev->dev; gpio_dev->gc.ngpio = TOTAL_NUMBER_OF_PINS; #if defined(CONFIG_OF_GPIO) gpio_dev->gc.of_node = pdev->dev.of_node; #endif gpio_dev->groups = kerncz_groups; gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups); <S2SV_StartVul> amd_pinctrl_desc.name = dev_name(&pdev->dev); <S2SV_EndVul> <S2SV_StartVul> gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc, <S2SV_EndVul> &pdev->dev, gpio_dev); if (IS_ERR(gpio_dev->pctrl)) { dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n""); return PTR_ERR(gpio_dev->pctrl); } ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev); <S2SV_StartVul> if (ret) <S2SV_EndVul> goto out1; ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev), 0, 0, TOTAL_NUMBER_OF_PINS); if (ret) { dev_err(&pdev->dev, ""Failed to add pin range\n""); goto out2; } ret = gpiochip_irqchip_add(&gpio_dev->gc, &amd_gpio_irqchip, 0, handle_simple_irq, IRQ_TYPE_NONE); if (ret) { dev_err(&pdev->dev, ""could not add irqchip\n""); ret = -ENODEV; goto out2; } gpiochip_set_chained_irqchip(&gpio_dev->gc, &amd_gpio_irqchip, irq_base, amd_gpio_irq_handler); platform_set_drvdata(pdev, gpio_dev); dev_dbg(&pdev->dev, ""amd gpio driver loaded\n""); return ret; out2: gpiochip_remove(&gpio_dev->gc); <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> out1: <S2SV_EndVul> pinctrl_unregister(gpio_dev->pctrl); return ret; }","- amd_pinctrl_desc.name = dev_name(&pdev->dev);
- gpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,
- if (ret)
- 
- out1:
+ amd_pinctrl_desc.name = dev_name(&pdev->dev);
+ gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,
+ if (ret)","static int amd_gpio_probe(struct platform_device *pdev) { int ret = 0; int irq_base; struct resource *res; struct amd_gpio *gpio_dev; gpio_dev = devm_kzalloc(&pdev->dev, sizeof(struct amd_gpio), GFP_KERNEL); if (!gpio_dev) return -ENOMEM; spin_lock_init(&gpio_dev->lock); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&pdev->dev, ""Failed to get gpio io resource.\n""); return -EINVAL; } gpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start, resource_size(res)); if (!gpio_dev->base) return -ENOMEM; irq_base = platform_get_irq(pdev, 0); if (irq_base < 0) { dev_err(&pdev->dev, ""Failed to get gpio IRQ.\n""); return -EINVAL; } gpio_dev->pdev = pdev; gpio_dev->gc.direction_input = amd_gpio_direction_input; gpio_dev->gc.direction_output = amd_gpio_direction_output; gpio_dev->gc.get = amd_gpio_get_value; gpio_dev->gc.set = amd_gpio_set_value; gpio_dev->gc.set_debounce = amd_gpio_set_debounce; gpio_dev->gc.dbg_show = amd_gpio_dbg_show; gpio_dev->gc.base = 0; gpio_dev->gc.label = pdev->name; gpio_dev->gc.owner = THIS_MODULE; gpio_dev->gc.parent = &pdev->dev; gpio_dev->gc.ngpio = TOTAL_NUMBER_OF_PINS; #if defined(CONFIG_OF_GPIO) gpio_dev->gc.of_node = pdev->dev.of_node; #endif gpio_dev->groups = kerncz_groups; gpio_dev->ngroups = ARRAY_SIZE(kerncz_groups); amd_pinctrl_desc.name = dev_name(&pdev->dev); gpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc, gpio_dev); if (IS_ERR(gpio_dev->pctrl)) { dev_err(&pdev->dev, ""Couldn't register pinctrl driver\n""); return PTR_ERR(gpio_dev->pctrl); } ret = gpiochip_add_data(&gpio_dev->gc, gpio_dev); if (ret) return ret; ret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev), 0, 0, TOTAL_NUMBER_OF_PINS); if (ret) { dev_err(&pdev->dev, ""Failed to add pin range\n""); goto out2; } ret = gpiochip_irqchip_add(&gpio_dev->gc, &amd_gpio_irqchip, 0, handle_simple_irq, IRQ_TYPE_NONE); if (ret) { dev_err(&pdev->dev, ""could not add irqchip\n""); ret = -ENODEV; goto out2; } gpiochip_set_chained_irqchip(&gpio_dev->gc, &amd_gpio_irqchip, irq_base, amd_gpio_irq_handler); platform_set_drvdata(pdev, gpio_dev); dev_dbg(&pdev->dev, ""amd gpio driver loaded\n""); return ret; out2: gpiochip_remove(&gpio_dev->gc); return ret; }"
710,2761----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----perf_swevent_hrtimer,"static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer) { enum hrtimer_restart ret = HRTIMER_RESTART; struct perf_sample_data data; struct pt_regs *regs; struct perf_event *event; u64 period; event = container_of(hrtimer, struct perf_event, hw.hrtimer); if (event->state != PERF_EVENT_STATE_ACTIVE) return HRTIMER_NORESTART; event->pmu->read(event); perf_sample_data_init(&data, 0); data.period = event->hw.last_period; regs = get_irq_regs(); if (regs && !perf_exclude_event(event, regs)) { if (!(event->attr.exclude_idle && current->pid == 0)) <S2SV_StartVul> if (perf_event_overflow(event, 0, &data, regs)) <S2SV_EndVul> ret = HRTIMER_NORESTART; } period = max_t(u64, 10000, event->hw.sample_period); hrtimer_forward_now(hrtimer, ns_to_ktime(period)); return ret; }","- if (perf_event_overflow(event, 0, &data, regs))
+ if (perf_event_overflow(event, &data, regs))","static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer) { enum hrtimer_restart ret = HRTIMER_RESTART; struct perf_sample_data data; struct pt_regs *regs; struct perf_event *event; u64 period; event = container_of(hrtimer, struct perf_event, hw.hrtimer); if (event->state != PERF_EVENT_STATE_ACTIVE) return HRTIMER_NORESTART; event->pmu->read(event); perf_sample_data_init(&data, 0); data.period = event->hw.last_period; regs = get_irq_regs(); if (regs && !perf_exclude_event(event, regs)) { if (!(event->attr.exclude_idle && current->pid == 0)) if (perf_event_overflow(event, &data, regs)) ret = HRTIMER_NORESTART; } period = max_t(u64, 10000, event->hw.sample_period); hrtimer_forward_now(hrtimer, ns_to_ktime(period)); return ret; }"
711,2870----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/class.c----r_bin_java_code_attr_new,"R_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) { RBinJavaAttrInfo *attr = NULL, *_attr = NULL; ut32 k = 0, curpos; ut64 offset = 0; attr = r_bin_java_default_attr_new (buffer, sz, buf_offset); if (!attr) { return NULL; } if (sz < 16 || sz > buf_offset) { free (attr); return NULL; } offset += 6; attr->type = R_BIN_JAVA_ATTR_TYPE_CODE_ATTR; attr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, offset); offset += 4; attr->info.code_attr.code_offset = buf_offset + offset; attr->info.code_attr.code = (ut8 *) malloc (attr->info.code_attr.code_length); <S2SV_StartVul> if (attr->info.code_attr.code == NULL) { <S2SV_EndVul> eprintf (""Handling Code Attributes: Unable to allocate memory "" ""(%u bytes) for a code.\n"", attr->info.code_attr.code_length); return attr; } R_BIN_JAVA_GLOBAL_BIN->current_code_attr = attr; { int len = attr->info.code_attr.code_length; memset (attr->info.code_attr.code, 0, len); if (offset + len >= sz) { len = sz; return attr; } memcpy (attr->info.code_attr.code, buffer + offset, len); offset += len; } attr->info.code_attr.exception_table_length = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.exception_table = r_list_newf (free); for (k = 0; k < attr->info.code_attr.exception_table_length; k++) { curpos = buf_offset + offset; if (curpos + 8 > sz) { return attr; } RBinJavaExceptionEntry *e = R_NEW0 (RBinJavaExceptionEntry); if (!e) { free (attr); return NULL; } e->file_offset = curpos; e->start_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->end_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->handler_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->catch_type = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; r_list_append (attr->info.code_attr.exception_table, e); e->size = 8; } attr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.attributes = r_list_newf (r_bin_java_attribute_free); if (attr->info.code_attr.attributes_count > 0) { for (k = 0; k < attr->info.code_attr.attributes_count; k++) { int size = (offset < sz) ? sz - offset : 0; if (size > sz || size <= 0) { break; } _attr = r_bin_java_read_next_attr_from_buffer (buffer + offset, size, buf_offset + offset); if (!_attr) { eprintf (""[X] r_bin_java_code_attr_new: Error unable to parse remainder of classfile after Method's Code Attribute: %d.\n"", k); break; } IFDBG eprintf(""Parsing @ 0x%""PFMT64x "" (%s) = 0x%""PFMT64x "" bytes, %p\n"", _attr->file_offset, _attr->name, _attr->size, _attr); offset += _attr->size; r_list_append (attr->info.code_attr.attributes, _attr); if (_attr->type == R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) { IFDBG eprintf(""Parsed the LocalVariableTable, preparing the implicit mthod frame.\n""); attr->info.code_attr.implicit_frame = r_bin_java_build_stack_frame_from_local_variable_table (R_BIN_JAVA_GLOBAL_BIN, _attr); attr->info.code_attr.implicit_frame->file_offset = buf_offset; IFDBG r_bin_java_print_stack_map_frame_summary(attr->info.code_attr.implicit_frame); } } } if (attr->info.code_attr.implicit_frame == NULL) { attr->info.code_attr.implicit_frame = r_bin_java_default_stack_frame (); } attr->size = offset; return attr; }","- if (attr->info.code_attr.code == NULL) {
+ if (!attr->info.code_attr.code) {","R_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) { RBinJavaAttrInfo *attr = NULL, *_attr = NULL; ut32 k = 0, curpos; ut64 offset = 0; attr = r_bin_java_default_attr_new (buffer, sz, buf_offset); if (!attr) { return NULL; } if (sz < 16 || sz > buf_offset) { free (attr); return NULL; } offset += 6; attr->type = R_BIN_JAVA_ATTR_TYPE_CODE_ATTR; attr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, offset); offset += 4; attr->info.code_attr.code_offset = buf_offset + offset; attr->info.code_attr.code = (ut8 *) malloc (attr->info.code_attr.code_length); if (!attr->info.code_attr.code) { eprintf (""Handling Code Attributes: Unable to allocate memory "" ""(%u bytes) for a code.\n"", attr->info.code_attr.code_length); return attr; } R_BIN_JAVA_GLOBAL_BIN->current_code_attr = attr; { int len = attr->info.code_attr.code_length; memset (attr->info.code_attr.code, 0, len); if (offset + len >= sz) { len = sz; return attr; } memcpy (attr->info.code_attr.code, buffer + offset, len); offset += len; } attr->info.code_attr.exception_table_length = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.exception_table = r_list_newf (free); for (k = 0; k < attr->info.code_attr.exception_table_length; k++) { curpos = buf_offset + offset; if (curpos + 8 > sz) { return attr; } RBinJavaExceptionEntry *e = R_NEW0 (RBinJavaExceptionEntry); if (!e) { free (attr); return NULL; } e->file_offset = curpos; e->start_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->end_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->handler_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->catch_type = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; r_list_append (attr->info.code_attr.exception_table, e); e->size = 8; } attr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.attributes = r_list_newf (r_bin_java_attribute_free); if (attr->info.code_attr.attributes_count > 0) { for (k = 0; k < attr->info.code_attr.attributes_count; k++) { int size = (offset < sz) ? sz - offset : 0; if (size > sz || size <= 0) { break; } _attr = r_bin_java_read_next_attr_from_buffer (buffer + offset, size, buf_offset + offset); if (!_attr) { eprintf (""[X] r_bin_java_code_attr_new: Error unable to parse remainder of classfile after Method's Code Attribute: %d.\n"", k); break; } IFDBG eprintf(""Parsing @ 0x%""PFMT64x "" (%s) = 0x%""PFMT64x "" bytes, %p\n"", _attr->file_offset, _attr->name, _attr->size, _attr); offset += _attr->size; r_list_append (attr->info.code_attr.attributes, _attr); if (_attr->type == R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) { IFDBG eprintf(""Parsed the LocalVariableTable, preparing the implicit mthod frame.\n""); attr->info.code_attr.implicit_frame = r_bin_java_build_stack_frame_from_local_variable_table (R_BIN_JAVA_GLOBAL_BIN, _attr); attr->info.code_attr.implicit_frame->file_offset = buf_offset; IFDBG r_bin_java_print_stack_map_frame_summary(attr->info.code_attr.implicit_frame); } } } if (attr->info.code_attr.implicit_frame == NULL) { attr->info.code_attr.implicit_frame = r_bin_java_default_stack_frame (); } attr->size = offset; return attr; }"
712,4944----CWE-203----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/eap_pwd.c----compute_password_element,"int compute_password_element (pwd_session_t *session, uint16_t grp_num, char const *password, int password_len, char const *id_server, int id_server_len, char const *id_peer, int id_peer_len, uint32_t *token) { BIGNUM *x_candidate = NULL, *rnd = NULL, *cofactor = NULL; HMAC_CTX *ctx = NULL; uint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, ctr; int nid, is_odd, primebitlen, primebytelen, ret = 0; ctx = HMAC_CTX_new(); if (ctx == NULL) { DEBUG(""failed allocating HMAC context""); goto fail; } switch (grp_num) { case 19: nid = NID_X9_62_prime256v1; break; case 20: nid = NID_secp384r1; break; case 21: nid = NID_secp521r1; break; case 25: nid = NID_X9_62_prime192v1; break; case 26: nid = NID_secp224r1; break; default: DEBUG(""unknown group %d"", grp_num); goto fail; } session->pwe = NULL; session->order = NULL; session->prime = NULL; if ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) { DEBUG(""unable to create EC_GROUP""); goto fail; } if (((rnd = BN_new()) == NULL) || ((cofactor = BN_new()) == NULL) || ((session->pwe = EC_POINT_new(session->group)) == NULL) || ((session->order = BN_new()) == NULL) || ((session->prime = BN_new()) == NULL) || ((x_candidate = BN_new()) == NULL)) { DEBUG(""unable to create bignums""); goto fail; } if (!EC_GROUP_get_curve_GFp(session->group, session->prime, NULL, NULL, NULL)) { DEBUG(""unable to get prime for GFp curve""); goto fail; } if (!EC_GROUP_get_order(session->group, session->order, NULL)) { DEBUG(""unable to get order for curve""); goto fail; } if (!EC_GROUP_get_cofactor(session->group, cofactor, NULL)) { DEBUG(""unable to get cofactor for curve""); goto fail; } primebitlen = BN_num_bits(session->prime); primebytelen = BN_num_bytes(session->prime); if ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) { DEBUG(""unable to alloc space for prf buffer""); goto fail; } ctr = 0; while (1) { <S2SV_StartVul> if (ctr > 10) { <S2SV_EndVul> DEBUG(""unable to find random point on curve for group %d, something's fishy"", grp_num); goto fail; } ctr++; H_Init(ctx); H_Update(ctx, (uint8_t *)token, sizeof(*token)); H_Update(ctx, (uint8_t const *)id_peer, id_peer_len); H_Update(ctx, (uint8_t const *)id_server, id_server_len); H_Update(ctx, (uint8_t const *)password, password_len); H_Update(ctx, (uint8_t *)&ctr, sizeof(ctr)); H_Final(ctx, pwe_digest); BN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd); if (eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, ""EAP-pwd Hunting And Pecking"", strlen(""EAP-pwd Hunting And Pecking""), prfbuf, primebitlen) != 0) { DEBUG(""key derivation function failed""); goto fail; } BN_bin2bn(prfbuf, primebytelen, x_candidate); if (primebitlen % 8) BN_rshift(x_candidate, x_candidate, (8 - (primebitlen % 8))); if (BN_ucmp(x_candidate, session->prime) >= 0) continue; is_odd = BN_is_odd(rnd) ? 1 : 0; if (!EC_POINT_set_compressed_coordinates_GFp(session->group, session->pwe, x_candidate, is_odd, NULL)) { continue; } if (!EC_POINT_is_on_curve(session->group, session->pwe, NULL)) { DEBUG(""EAP-pwd: point is not on curve""); continue; } if (BN_cmp(cofactor, BN_value_one())) { if (!EC_POINT_mul(session->group, session->pwe, NULL, session->pwe, cofactor, NULL)) { DEBUG(""EAP-pwd: cannot multiply generator by order""); continue; } if (EC_POINT_is_at_infinity(session->group, session->pwe)) { DEBUG(""EAP-pwd: point is at infinity""); continue; } } break; } session->group_num = grp_num; if (0) { fail: ret = -1; } BN_clear_free(cofactor); BN_clear_free(x_candidate); BN_clear_free(rnd); talloc_free(prfbuf); HMAC_CTX_free(ctx); return ret; }","- if (ctr > 10) {
+ if (ctr > 100) {","int compute_password_element (pwd_session_t *session, uint16_t grp_num, char const *password, int password_len, char const *id_server, int id_server_len, char const *id_peer, int id_peer_len, uint32_t *token) { BIGNUM *x_candidate = NULL, *rnd = NULL, *cofactor = NULL; HMAC_CTX *ctx = NULL; uint8_t pwe_digest[SHA256_DIGEST_LENGTH], *prfbuf = NULL, ctr; int nid, is_odd, primebitlen, primebytelen, ret = 0; ctx = HMAC_CTX_new(); if (ctx == NULL) { DEBUG(""failed allocating HMAC context""); goto fail; } switch (grp_num) { case 19: nid = NID_X9_62_prime256v1; break; case 20: nid = NID_secp384r1; break; case 21: nid = NID_secp521r1; break; case 25: nid = NID_X9_62_prime192v1; break; case 26: nid = NID_secp224r1; break; default: DEBUG(""unknown group %d"", grp_num); goto fail; } session->pwe = NULL; session->order = NULL; session->prime = NULL; if ((session->group = EC_GROUP_new_by_curve_name(nid)) == NULL) { DEBUG(""unable to create EC_GROUP""); goto fail; } if (((rnd = BN_new()) == NULL) || ((cofactor = BN_new()) == NULL) || ((session->pwe = EC_POINT_new(session->group)) == NULL) || ((session->order = BN_new()) == NULL) || ((session->prime = BN_new()) == NULL) || ((x_candidate = BN_new()) == NULL)) { DEBUG(""unable to create bignums""); goto fail; } if (!EC_GROUP_get_curve_GFp(session->group, session->prime, NULL, NULL, NULL)) { DEBUG(""unable to get prime for GFp curve""); goto fail; } if (!EC_GROUP_get_order(session->group, session->order, NULL)) { DEBUG(""unable to get order for curve""); goto fail; } if (!EC_GROUP_get_cofactor(session->group, cofactor, NULL)) { DEBUG(""unable to get cofactor for curve""); goto fail; } primebitlen = BN_num_bits(session->prime); primebytelen = BN_num_bytes(session->prime); if ((prfbuf = talloc_zero_array(session, uint8_t, primebytelen)) == NULL) { DEBUG(""unable to alloc space for prf buffer""); goto fail; } ctr = 0; while (1) { if (ctr > 100) { DEBUG(""unable to find random point on curve for group %d, something's fishy"", grp_num); goto fail; } ctr++; H_Init(ctx); H_Update(ctx, (uint8_t *)token, sizeof(*token)); H_Update(ctx, (uint8_t const *)id_peer, id_peer_len); H_Update(ctx, (uint8_t const *)id_server, id_server_len); H_Update(ctx, (uint8_t const *)password, password_len); H_Update(ctx, (uint8_t *)&ctr, sizeof(ctr)); H_Final(ctx, pwe_digest); BN_bin2bn(pwe_digest, SHA256_DIGEST_LENGTH, rnd); if (eap_pwd_kdf(pwe_digest, SHA256_DIGEST_LENGTH, ""EAP-pwd Hunting And Pecking"", strlen(""EAP-pwd Hunting And Pecking""), prfbuf, primebitlen) != 0) { DEBUG(""key derivation function failed""); goto fail; } BN_bin2bn(prfbuf, primebytelen, x_candidate); if (primebitlen % 8) BN_rshift(x_candidate, x_candidate, (8 - (primebitlen % 8))); if (BN_ucmp(x_candidate, session->prime) >= 0) continue; is_odd = BN_is_odd(rnd) ? 1 : 0; if (!EC_POINT_set_compressed_coordinates_GFp(session->group, session->pwe, x_candidate, is_odd, NULL)) { continue; } if (!EC_POINT_is_on_curve(session->group, session->pwe, NULL)) { DEBUG(""EAP-pwd: point is not on curve""); continue; } if (BN_cmp(cofactor, BN_value_one())) { if (!EC_POINT_mul(session->group, session->pwe, NULL, session->pwe, cofactor, NULL)) { DEBUG(""EAP-pwd: cannot multiply generator by order""); continue; } if (EC_POINT_is_at_infinity(session->group, session->pwe)) { DEBUG(""EAP-pwd: point is at infinity""); continue; } } break; } session->group_num = grp_num; if (0) { fail: ret = -1; } BN_clear_free(cofactor); BN_clear_free(x_candidate); BN_clear_free(rnd); talloc_free(prfbuf); HMAC_CTX_free(ctx); return ret; }"
713,1981----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-14358--message.c----msg_parse_fetch,"static int msg_parse_fetch(struct ImapHeader *h, char *s) { char tmp[SHORT_STRING]; char *ptmp = NULL; if (!s) return -1; while (*s) { SKIPWS(s); if (mutt_str_strncasecmp(""FLAGS"", s, 5) == 0) { s = msg_parse_flags(h, s); if (!s) return -1; } else if (mutt_str_strncasecmp(""UID"", s, 3) == 0) { s += 3; SKIPWS(s); if (mutt_str_atoui(s, &h->data->uid) < 0) return -1; s = imap_next_word(s); } else if (mutt_str_strncasecmp(""INTERNALDATE"", s, 12) == 0) { s += 12; SKIPWS(s); if (*s != '\""') { mutt_debug(1, ""bogus INTERNALDATE entry: %s\n"", s); return -1; } s++; ptmp = tmp; <S2SV_StartVul> while (*s && *s != '\""') <S2SV_EndVul> *ptmp++ = *s++; if (*s != '\""') return -1; s++; *ptmp = '\0'; h->received = mutt_date_parse_imap(tmp); } else if (mutt_str_strncasecmp(""RFC822.SIZE"", s, 11) == 0) { s += 11; SKIPWS(s); ptmp = tmp; <S2SV_StartVul> while (isdigit((unsigned char) *s)) <S2SV_EndVul> *ptmp++ = *s++; *ptmp = '\0'; if (mutt_str_atol(tmp, &h->content_length) < 0) return -1; } else if ((mutt_str_strncasecmp(""BODY"", s, 4) == 0) || (mutt_str_strncasecmp(""RFC822.HEADER"", s, 13) == 0)) { return -2; } else if (*s == ')') s++; else if (*s) { imap_error(""msg_parse_fetch"", s); return -1; } } return 0; }","- while (*s && *s != '\""')
- while (isdigit((unsigned char) *s))
+ while (*s && (*s != '\""') && (ptmp != (tmp + sizeof(tmp) - 1)))
+ while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1)))","static int msg_parse_fetch(struct ImapHeader *h, char *s) { char tmp[SHORT_STRING]; char *ptmp = NULL; if (!s) return -1; while (*s) { SKIPWS(s); if (mutt_str_strncasecmp(""FLAGS"", s, 5) == 0) { s = msg_parse_flags(h, s); if (!s) return -1; } else if (mutt_str_strncasecmp(""UID"", s, 3) == 0) { s += 3; SKIPWS(s); if (mutt_str_atoui(s, &h->data->uid) < 0) return -1; s = imap_next_word(s); } else if (mutt_str_strncasecmp(""INTERNALDATE"", s, 12) == 0) { s += 12; SKIPWS(s); if (*s != '\""') { mutt_debug(1, ""bogus INTERNALDATE entry: %s\n"", s); return -1; } s++; ptmp = tmp; while (*s && (*s != '\""') && (ptmp != (tmp + sizeof(tmp) - 1))) *ptmp++ = *s++; if (*s != '\""') return -1; s++; *ptmp = '\0'; h->received = mutt_date_parse_imap(tmp); } else if (mutt_str_strncasecmp(""RFC822.SIZE"", s, 11) == 0) { s += 11; SKIPWS(s); ptmp = tmp; while (isdigit((unsigned char) *s) && (ptmp != (tmp + sizeof(tmp) - 1))) *ptmp++ = *s++; *ptmp = '\0'; if (mutt_str_atol(tmp, &h->content_length) < 0) return -1; } else if ((mutt_str_strncasecmp(""BODY"", s, 4) == 0) || (mutt_str_strncasecmp(""RFC822.HEADER"", s, 13) == 0)) { return -2; } else if (*s == ')') s++; else if (*s) { imap_error(""msg_parse_fetch"", s); return -1; } } return 0; }"
714,1328----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-13055--print-isoclns.c----isis_print_is_reach_subtlv,"isis_print_is_reach_subtlv(netdissect_options *ndo, const uint8_t *tptr, u_int subt, u_int subl, const char *ident) { u_int te_class,priority_level,gmpls_switch_cap; union { float f; uint32_t i; } bw; ND_PRINT((ndo, ""%s%s subTLV #%u, length: %u"", ident, tok2str(isis_ext_is_reach_subtlv_values, ""unknown"", subt), subt, subl)); ND_TCHECK2(*tptr, subl); switch(subt) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP: case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID: case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID: if (subl >= 4) { ND_PRINT((ndo, "", 0x%08x"", EXTRACT_32BITS(tptr))); if (subl == 8) ND_PRINT((ndo, "", 0x%08x"", EXTRACT_32BITS(tptr+4))); } break; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR: case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR: if (subl >= sizeof(struct in_addr)) ND_PRINT((ndo, "", %s"", ipaddr_string(ndo, tptr))); break; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW: if (subl >= 4) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, "", %.3f Mbps"", bw.f * 8 / 1000000)); } break; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if (subl >= 32) { for (te_class = 0; te_class < 8; te_class++) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s TE-Class %u: %.3f Mbps"", ident, te_class, bw.f * 8 / 1000000)); tptr+=4; } } break; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD: ND_PRINT((ndo, ""%sBandwidth Constraints Model ID: %s (%u)"", ident, tok2str(diffserv_te_bc_values, ""unknown"", *tptr), *tptr)); tptr++; for (te_class = 0; te_class < (subl-1)/4; te_class++) { <S2SV_StartVul> ND_TCHECK2(*tptr, 4); <S2SV_EndVul> bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s Bandwidth constraint CT%u: %.3f Mbps"", ident, te_class, bw.f * 8 / 1000000)); tptr+=4; } break; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC: if (subl >= 3) ND_PRINT((ndo, "", %u"", EXTRACT_24BITS(tptr))); break; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE: if (subl == 2) { ND_PRINT((ndo, "", [ %s ] (0x%04x)"", bittok2str(isis_subtlv_link_attribute_values, ""Unknown"", EXTRACT_16BITS(tptr)), EXTRACT_16BITS(tptr))); } break; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE: if (subl >= 2) { ND_PRINT((ndo, "", %s, Priority %u"", bittok2str(gmpls_link_prot_values, ""none"", *tptr), *(tptr+1))); } break; case ISIS_SUBTLV_SPB_METRIC: if (subl >= 6) { ND_PRINT((ndo, "", LM: %u"", EXTRACT_24BITS(tptr))); tptr=tptr+3; ND_PRINT((ndo, "", P: %u"", *(tptr))); tptr++; ND_PRINT((ndo, "", P-ID: %u"", EXTRACT_16BITS(tptr))); } break; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR: if (subl >= 36) { gmpls_switch_cap = *tptr; ND_PRINT((ndo, ""%s Interface Switching Capability:%s"", ident, tok2str(gmpls_switch_cap_values, ""Unknown"", gmpls_switch_cap))); ND_PRINT((ndo, "", LSP Encoding: %s"", tok2str(gmpls_encoding_values, ""Unknown"", *(tptr + 1)))); tptr+=4; ND_PRINT((ndo, ""%s Max LSP Bandwidth:"", ident)); for (priority_level = 0; priority_level < 8; priority_level++) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s priority level %d: %.3f Mbps"", ident, priority_level, bw.f * 8 / 1000000)); tptr+=4; } subl-=36; switch (gmpls_switch_cap) { case GMPLS_PSC1: case GMPLS_PSC2: case GMPLS_PSC3: case GMPLS_PSC4: ND_TCHECK2(*tptr, 6); bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s Min LSP Bandwidth: %.3f Mbps"", ident, bw.f * 8 / 1000000)); ND_PRINT((ndo, ""%s Interface MTU: %u"", ident, EXTRACT_16BITS(tptr + 4))); break; case GMPLS_TSC: ND_TCHECK2(*tptr, 8); bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s Min LSP Bandwidth: %.3f Mbps"", ident, bw.f * 8 / 1000000)); ND_PRINT((ndo, ""%s Indication %s"", ident, tok2str(gmpls_switch_cap_tsc_indication_values, ""Unknown (%u)"", *(tptr + 4)))); break; default: if(subl>0){ if (!print_unknown_data(ndo, tptr, ""\n\t\t "", subl)) return(0); } } } break; default: if (!print_unknown_data(ndo, tptr, ""\n\t\t "", subl)) return(0); break; } return(1); trunc: return(0); }","- ND_TCHECK2(*tptr, 4);
+ if (subl == 0)
+ break;","isis_print_is_reach_subtlv(netdissect_options *ndo, const uint8_t *tptr, u_int subt, u_int subl, const char *ident) { u_int te_class,priority_level,gmpls_switch_cap; union { float f; uint32_t i; } bw; ND_PRINT((ndo, ""%s%s subTLV #%u, length: %u"", ident, tok2str(isis_ext_is_reach_subtlv_values, ""unknown"", subt), subt, subl)); ND_TCHECK2(*tptr, subl); switch(subt) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP: case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID: case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID: if (subl >= 4) { ND_PRINT((ndo, "", 0x%08x"", EXTRACT_32BITS(tptr))); if (subl == 8) ND_PRINT((ndo, "", 0x%08x"", EXTRACT_32BITS(tptr+4))); } break; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR: case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR: if (subl >= sizeof(struct in_addr)) ND_PRINT((ndo, "", %s"", ipaddr_string(ndo, tptr))); break; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW: if (subl >= 4) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, "", %.3f Mbps"", bw.f * 8 / 1000000)); } break; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if (subl >= 32) { for (te_class = 0; te_class < 8; te_class++) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s TE-Class %u: %.3f Mbps"", ident, te_class, bw.f * 8 / 1000000)); tptr+=4; } } break; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS: case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD: if (subl == 0) break; ND_PRINT((ndo, ""%sBandwidth Constraints Model ID: %s (%u)"", ident, tok2str(diffserv_te_bc_values, ""unknown"", *tptr), *tptr)); tptr++; for (te_class = 0; te_class < (subl-1)/4; te_class++) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s Bandwidth constraint CT%u: %.3f Mbps"", ident, te_class, bw.f * 8 / 1000000)); tptr+=4; } break; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC: if (subl >= 3) ND_PRINT((ndo, "", %u"", EXTRACT_24BITS(tptr))); break; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE: if (subl == 2) { ND_PRINT((ndo, "", [ %s ] (0x%04x)"", bittok2str(isis_subtlv_link_attribute_values, ""Unknown"", EXTRACT_16BITS(tptr)), EXTRACT_16BITS(tptr))); } break; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE: if (subl >= 2) { ND_PRINT((ndo, "", %s, Priority %u"", bittok2str(gmpls_link_prot_values, ""none"", *tptr), *(tptr+1))); } break; case ISIS_SUBTLV_SPB_METRIC: if (subl >= 6) { ND_PRINT((ndo, "", LM: %u"", EXTRACT_24BITS(tptr))); tptr=tptr+3; ND_PRINT((ndo, "", P: %u"", *(tptr))); tptr++; ND_PRINT((ndo, "", P-ID: %u"", EXTRACT_16BITS(tptr))); } break; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR: if (subl >= 36) { gmpls_switch_cap = *tptr; ND_PRINT((ndo, ""%s Interface Switching Capability:%s"", ident, tok2str(gmpls_switch_cap_values, ""Unknown"", gmpls_switch_cap))); ND_PRINT((ndo, "", LSP Encoding: %s"", tok2str(gmpls_encoding_values, ""Unknown"", *(tptr + 1)))); tptr+=4; ND_PRINT((ndo, ""%s Max LSP Bandwidth:"", ident)); for (priority_level = 0; priority_level < 8; priority_level++) { bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s priority level %d: %.3f Mbps"", ident, priority_level, bw.f * 8 / 1000000)); tptr+=4; } subl-=36; switch (gmpls_switch_cap) { case GMPLS_PSC1: case GMPLS_PSC2: case GMPLS_PSC3: case GMPLS_PSC4: ND_TCHECK2(*tptr, 6); bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s Min LSP Bandwidth: %.3f Mbps"", ident, bw.f * 8 / 1000000)); ND_PRINT((ndo, ""%s Interface MTU: %u"", ident, EXTRACT_16BITS(tptr + 4))); break; case GMPLS_TSC: ND_TCHECK2(*tptr, 8); bw.i = EXTRACT_32BITS(tptr); ND_PRINT((ndo, ""%s Min LSP Bandwidth: %.3f Mbps"", ident, bw.f * 8 / 1000000)); ND_PRINT((ndo, ""%s Indication %s"", ident, tok2str(gmpls_switch_cap_tsc_indication_values, ""Unknown (%u)"", *(tptr + 4)))); break; default: if(subl>0){ if (!print_unknown_data(ndo, tptr, ""\n\t\t "", subl)) return(0); } } } break; default: if (!print_unknown_data(ndo, tptr, ""\n\t\t "", subl)) return(0); break; } return(1); trunc: return(0); }"
715,6614----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/usb.c----__usb_get_extra_descriptor,"int __usb_get_extra_descriptor(char *buffer, unsigned size, <S2SV_StartVul> unsigned char type, void **ptr) <S2SV_EndVul> { struct usb_descriptor_header *header; while (size >= sizeof(struct usb_descriptor_header)) { header = (struct usb_descriptor_header *)buffer; <S2SV_StartVul> if (header->bLength < 2) { <S2SV_EndVul> printk(KERN_ERR ""%s: bogus descriptor, type %d length %d\n"", usbcore_name, header->bDescriptorType, header->bLength); return -1; } <S2SV_StartVul> if (header->bDescriptorType == type) { <S2SV_EndVul> *ptr = header; return 0; } buffer += header->bLength; size -= header->bLength; } return -1; }","- unsigned char type, void **ptr)
- if (header->bLength < 2) {
- if (header->bDescriptorType == type) {
+ unsigned char type, void **ptr, size_t minsize)
+ if (header->bLength < 2 || header->bLength > size) {
+ if (header->bDescriptorType == type && header->bLength >= minsize) {","int __usb_get_extra_descriptor(char *buffer, unsigned size, unsigned char type, void **ptr, size_t minsize) { struct usb_descriptor_header *header; while (size >= sizeof(struct usb_descriptor_header)) { header = (struct usb_descriptor_header *)buffer; if (header->bLength < 2 || header->bLength > size) { printk(KERN_ERR ""%s: bogus descriptor, type %d length %d\n"", usbcore_name, header->bDescriptorType, header->bLength); return -1; } if (header->bDescriptorType == type && header->bLength >= minsize) { *ptr = header; return 0; } buffer += header->bLength; size -= header->bLength; } return -1; }"
716,5073----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/perf_event_xscale.c----xscale1pmu_handle_irq,"xscale1pmu_handle_irq(int irq_num, void *dev) { unsigned long pmnc; struct perf_sample_data data; struct cpu_hw_events *cpuc; struct pt_regs *regs; int idx; pmnc = xscale1pmu_read_pmnc(); xscale1pmu_write_pmnc(pmnc & ~XSCALE_PMU_ENABLE); if (!(pmnc & XSCALE1_OVERFLOWED_MASK)) return IRQ_NONE; regs = get_irq_regs(); perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); for (idx = 0; idx <= armpmu->num_events; ++idx) { struct perf_event *event = cpuc->events[idx]; struct hw_perf_event *hwc; if (!test_bit(idx, cpuc->active_mask)) continue; if (!xscale1_pmnc_counter_has_overflowed(pmnc, idx)) continue; hwc = &event->hw; armpmu_event_update(event, hwc, idx, 1); data.period = event->hw.last_period; if (!armpmu_event_set_period(event, hwc, idx)) continue; <S2SV_StartVul> if (perf_event_overflow(event, 0, &data, regs)) <S2SV_EndVul> armpmu->disable(hwc, idx); } irq_work_run(); pmnc = xscale1pmu_read_pmnc() | XSCALE_PMU_ENABLE; xscale1pmu_write_pmnc(pmnc); return IRQ_HANDLED; }","- if (perf_event_overflow(event, 0, &data, regs))
+ if (perf_event_overflow(event, &data, regs))","xscale1pmu_handle_irq(int irq_num, void *dev) { unsigned long pmnc; struct perf_sample_data data; struct cpu_hw_events *cpuc; struct pt_regs *regs; int idx; pmnc = xscale1pmu_read_pmnc(); xscale1pmu_write_pmnc(pmnc & ~XSCALE_PMU_ENABLE); if (!(pmnc & XSCALE1_OVERFLOWED_MASK)) return IRQ_NONE; regs = get_irq_regs(); perf_sample_data_init(&data, 0); cpuc = &__get_cpu_var(cpu_hw_events); for (idx = 0; idx <= armpmu->num_events; ++idx) { struct perf_event *event = cpuc->events[idx]; struct hw_perf_event *hwc; if (!test_bit(idx, cpuc->active_mask)) continue; if (!xscale1_pmnc_counter_has_overflowed(pmnc, idx)) continue; hwc = &event->hw; armpmu_event_update(event, hwc, idx, 1); data.period = event->hw.last_period; if (!armpmu_event_set_period(event, hwc, idx)) continue; if (perf_event_overflow(event, &data, regs)) armpmu->disable(hwc, idx); } irq_work_run(); pmnc = xscale1pmu_read_pmnc() | XSCALE_PMU_ENABLE; xscale1pmu_write_pmnc(pmnc); return IRQ_HANDLED; }"
717,4325----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dev.c----dev_get_valid_name,"<S2SV_StartVul> static int dev_get_valid_name(struct net *net, <S2SV_EndVul> <S2SV_StartVul> struct net_device *dev, <S2SV_EndVul> <S2SV_StartVul> const char *name) <S2SV_EndVul> { BUG_ON(!net); if (!dev_valid_name(name)) return -EINVAL; if (strchr(name, '%')) return dev_alloc_name_ns(net, dev, name); else if (__dev_get_by_name(net, name)) return -EEXIST; else if (dev->name != name) strlcpy(dev->name, name, IFNAMSIZ); return 0; }","- static int dev_get_valid_name(struct net *net,
- struct net_device *dev,
- const char *name)
+ int dev_get_valid_name(struct net *net, struct net_device *dev,
+ const char *name)","int dev_get_valid_name(struct net *net, struct net_device *dev, const char *name) { BUG_ON(!net); if (!dev_valid_name(name)) return -EINVAL; if (strchr(name, '%')) return dev_alloc_name_ns(net, dev, name); else if (__dev_get_by_name(net, name)) return -EEXIST; else if (dev->name != name) strlcpy(dev->name, name, IFNAMSIZ); return 0; }"
718,710----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-2038--write.c----nfs_can_extend_write,"static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode) { if (file->f_flags & O_DSYNC) return 0; if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE)) return 1; <S2SV_StartVul> if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL || <S2SV_EndVul> <S2SV_StartVul> (inode->i_flock->fl_start == 0 && <S2SV_EndVul> inode->i_flock->fl_end == OFFSET_MAX && <S2SV_StartVul> inode->i_flock->fl_type != F_RDLCK))) <S2SV_EndVul> return 1; return 0; }","- if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||
- (inode->i_flock->fl_start == 0 &&
- inode->i_flock->fl_type != F_RDLCK)))
+ if (!nfs_write_pageuptodate(page, inode))
+ return 0;
+ if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&
+ inode->i_flock->fl_type != F_RDLCK))","static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode) { if (file->f_flags & O_DSYNC) return 0; if (!nfs_write_pageuptodate(page, inode)) return 0; if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE)) return 1; if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 && inode->i_flock->fl_end == OFFSET_MAX && inode->i_flock->fl_type != F_RDLCK)) return 1; return 0; }"
719,1015----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4913--rock.c----get_rock_ridge_filename,"int get_rock_ridge_filename(struct iso_directory_record *de, char *retname, struct inode *inode) { struct rock_state rs; struct rock_ridge *rr; int sig; int retnamlen = 0; int truncate = 0; int ret = 0; if (!ISOFS_SB(inode->i_sb)->s_rock) return 0; *retname = 0; init_rock_state(&rs, inode); setup_rock_ridge(de, inode, &rs); repeat: while (rs.len > 2) { rr = (struct rock_ridge *)rs.chr; if (rr->len < 3) goto out; sig = isonum_721(rs.chr); if (rock_check_overflow(&rs, sig)) goto eio; rs.chr += rr->len; rs.len -= rr->len; if (rs.len < 0) goto out; switch (sig) { case SIG('R', 'R'): if ((rr->u.RR.flags[0] & RR_NM) == 0) goto out; break; case SIG('S', 'P'): if (check_sp(rr, inode)) goto out; break; case SIG('C', 'E'): rs.cont_extent = isonum_733(rr->u.CE.extent); rs.cont_offset = isonum_733(rr->u.CE.offset); rs.cont_size = isonum_733(rr->u.CE.size); break; case SIG('N', 'M'): if (truncate) break; if (rr->len < 5) break; if (rr->u.NM.flags & 6) break; if (rr->u.NM.flags & ~1) { printk(""Unsupported NM flag settings (%d)\n"", rr->u.NM.flags); break; } <S2SV_StartVul> if ((strlen(retname) + rr->len - 5) >= 254) { <S2SV_EndVul> truncate = 1; break; } <S2SV_StartVul> strncat(retname, rr->u.NM.name, rr->len - 5); <S2SV_EndVul> <S2SV_StartVul> retnamlen += rr->len - 5; <S2SV_EndVul> break; case SIG('R', 'E'): kfree(rs.buffer); return -1; default: break; } } ret = rock_continue(&rs); if (ret == 0) goto repeat; if (ret == 1) return retnamlen; out: kfree(rs.buffer); return ret; eio: ret = -EIO; goto out; }","- if ((strlen(retname) + rr->len - 5) >= 254) {
- strncat(retname, rr->u.NM.name, rr->len - 5);
- retnamlen += rr->len - 5;
+ char *p;
+ int len;
+ len = rr->len - 5;
+ if (retnamlen + len >= 254) {
+ p = memchr(rr->u.NM.name, '\0', len);
+ if (unlikely(p))
+ len = p - rr->u.NM.name;
+ memcpy(retname + retnamlen, rr->u.NM.name, len);
+ retnamlen += len;
+ retname[retnamlen] = '\0';","int get_rock_ridge_filename(struct iso_directory_record *de, char *retname, struct inode *inode) { struct rock_state rs; struct rock_ridge *rr; int sig; int retnamlen = 0; int truncate = 0; int ret = 0; char *p; int len; if (!ISOFS_SB(inode->i_sb)->s_rock) return 0; *retname = 0; init_rock_state(&rs, inode); setup_rock_ridge(de, inode, &rs); repeat: while (rs.len > 2) { rr = (struct rock_ridge *)rs.chr; if (rr->len < 3) goto out; sig = isonum_721(rs.chr); if (rock_check_overflow(&rs, sig)) goto eio; rs.chr += rr->len; rs.len -= rr->len; if (rs.len < 0) goto out; switch (sig) { case SIG('R', 'R'): if ((rr->u.RR.flags[0] & RR_NM) == 0) goto out; break; case SIG('S', 'P'): if (check_sp(rr, inode)) goto out; break; case SIG('C', 'E'): rs.cont_extent = isonum_733(rr->u.CE.extent); rs.cont_offset = isonum_733(rr->u.CE.offset); rs.cont_size = isonum_733(rr->u.CE.size); break; case SIG('N', 'M'): if (truncate) break; if (rr->len < 5) break; if (rr->u.NM.flags & 6) break; if (rr->u.NM.flags & ~1) { printk(""Unsupported NM flag settings (%d)\n"", rr->u.NM.flags); break; } len = rr->len - 5; if (retnamlen + len >= 254) { truncate = 1; break; } p = memchr(rr->u.NM.name, '\0', len); if (unlikely(p)) len = p - rr->u.NM.name; memcpy(retname + retnamlen, rr->u.NM.name, len); retnamlen += len; retname[retnamlen] = '\0'; break; case SIG('R', 'E'): kfree(rs.buffer); return -1; default: break; } } ret = rock_continue(&rs); if (ret == 0) goto repeat; if (ret == 1) return retnamlen; out: kfree(rs.buffer); return ret; eio: ret = -EIO; goto out; }"
720,786----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-6526--callchain.c----perf_callchain_user_64,"static void perf_callchain_user_64(struct perf_callchain_entry *entry, struct pt_regs *regs) { unsigned long sp, next_sp; unsigned long next_ip; unsigned long lr; long level = 0; struct signal_frame_64 __user *sigframe; unsigned long __user *fp, *uregs; next_ip = perf_instruction_pointer(regs); lr = regs->link; sp = regs->gpr[1]; perf_callchain_store(entry, next_ip); <S2SV_StartVul> for (;;) { <S2SV_EndVul> fp = (unsigned long __user *) sp; if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp)) return; if (level > 0 && read_user_stack_64(&fp[2], &next_ip)) return; if (next_sp - sp >= sizeof(struct signal_frame_64) && (is_sigreturn_64_address(next_ip, sp) || (level <= 1 && is_sigreturn_64_address(lr, sp))) && sane_signal_64_frame(sp)) { sigframe = (struct signal_frame_64 __user *) sp; uregs = sigframe->uc.uc_mcontext.gp_regs; if (read_user_stack_64(&uregs[PT_NIP], &next_ip) || read_user_stack_64(&uregs[PT_LNK], &lr) || read_user_stack_64(&uregs[PT_R1], &sp)) return; level = 0; perf_callchain_store(entry, PERF_CONTEXT_USER); perf_callchain_store(entry, next_ip); continue; } if (level == 0) next_ip = lr; perf_callchain_store(entry, next_ip); ++level; sp = next_sp; } }","- for (;;) {
+ while (entry->nr < PERF_MAX_STACK_DEPTH) {","static void perf_callchain_user_64(struct perf_callchain_entry *entry, struct pt_regs *regs) { unsigned long sp, next_sp; unsigned long next_ip; unsigned long lr; long level = 0; struct signal_frame_64 __user *sigframe; unsigned long __user *fp, *uregs; next_ip = perf_instruction_pointer(regs); lr = regs->link; sp = regs->gpr[1]; perf_callchain_store(entry, next_ip); while (entry->nr < PERF_MAX_STACK_DEPTH) { fp = (unsigned long __user *) sp; if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp)) return; if (level > 0 && read_user_stack_64(&fp[2], &next_ip)) return; if (next_sp - sp >= sizeof(struct signal_frame_64) && (is_sigreturn_64_address(next_ip, sp) || (level <= 1 && is_sigreturn_64_address(lr, sp))) && sane_signal_64_frame(sp)) { sigframe = (struct signal_frame_64 __user *) sp; uregs = sigframe->uc.uc_mcontext.gp_regs; if (read_user_stack_64(&uregs[PT_NIP], &next_ip) || read_user_stack_64(&uregs[PT_LNK], &lr) || read_user_stack_64(&uregs[PT_R1], &sp)) return; level = 0; perf_callchain_store(entry, PERF_CONTEXT_USER); perf_callchain_store(entry, next_ip); continue; } if (level == 0) next_ip = lr; perf_callchain_store(entry, next_ip); ++level; sp = next_sp; } }"
721,139----CWE-310----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3568--s23_clnt.c----*ssl23_get_client_method,static const SSL_METHOD *ssl23_get_client_method(int ver) { #ifndef OPENSSL_NO_SSL2 if (ver == SSL2_VERSION) return(SSLv2_client_method()); #endif if (ver == SSL3_VERSION) return(SSLv3_client_method()); else if (ver == TLS1_VERSION) return(TLSv1_client_method()); else if (ver == TLS1_1_VERSION) <S2SV_StartVul> return(TLSv1_1_client_method()); <S2SV_EndVul> else return(NULL); },"- return(TLSv1_1_client_method());
+ #endif
+ else if (ver == TLS1_1_VERSION)
+ return(TLSv1_1_client_method());",static const SSL_METHOD *ssl23_get_client_method(int ver) { #ifndef OPENSSL_NO_SSL2 if (ver == SSL2_VERSION) return(SSLv2_client_method()); #endif #ifndef OPENSSL_NO_SSL3 if (ver == SSL3_VERSION) return(SSLv3_client_method()); #endif if (ver == TLS1_VERSION) return(TLSv1_client_method()); else if (ver == TLS1_1_VERSION) return(TLSv1_1_client_method()); else return(NULL); }
722,7292----CWE-824----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/vtable.c----vtable_is_value_in_text_section,"static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) { <S2SV_StartVul> ut64 curAddressValue; <S2SV_EndVul> if (!context->read_addr (context->anal, curAddress, &curAddressValue)) { return false; } bool ret = vtable_addr_in_text_section (context, curAddressValue); if (value) { *value = curAddressValue; } return ret; }","- ut64 curAddressValue;
+ ut64 curAddressValue = UT64_MAX;","static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) { ut64 curAddressValue = UT64_MAX; if (!context->read_addr (context->anal, curAddress, &curAddressValue)) { return false; } bool ret = vtable_addr_in_text_section (context, curAddressValue); if (value) { *value = curAddressValue; } return ret; }"
723,2972----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/espLib.c----espOpenDatabase,"PUBLIC int espOpenDatabase(HttpRoute *route, cchar *spec) { EspRoute *eroute; char *provider, *path, *dir; int flags; eroute = route->eroute; if (eroute->edi) { return 0; } flags = EDI_CREATE | EDI_AUTO_SAVE; if (smatch(spec, ""default"")) { #if ME_COM_SQLITE spec = sfmt(""sdb://%s.sdb"", eroute->appName); #elif ME_COM_MDB spec = sfmt(""mdb://%s.mdb"", eroute->appName); #endif } <S2SV_StartVul> provider = stok(sclone(spec), ""://"", &path); <S2SV_EndVul> <S2SV_StartVul> if (provider == 0 || path == 0) { <S2SV_EndVul> return MPR_ERR_BAD_ARGS; } path = mprJoinPath(httpGetDir(route, ""db""), path); dir = mprGetPathDir(path); if (!mprPathExists(dir, X_OK)) { mprMakeDir(dir, 0755, -1, -1, 1); } if ((eroute->edi = ediOpen(mprGetRelPath(path, NULL), provider, flags)) == 0) { return MPR_ERR_CANT_OPEN; } route->database = sclone(spec); return 0; }","- provider = stok(sclone(spec), ""://"", &path);
- if (provider == 0 || path == 0) {
+ provider = ssplit(sclone(spec), ""://"", &path);
+ if (*provider == '\0' || *path == '\0') {","PUBLIC int espOpenDatabase(HttpRoute *route, cchar *spec) { EspRoute *eroute; char *provider, *path, *dir; int flags; eroute = route->eroute; if (eroute->edi) { return 0; } flags = EDI_CREATE | EDI_AUTO_SAVE; if (smatch(spec, ""default"")) { #if ME_COM_SQLITE spec = sfmt(""sdb://%s.sdb"", eroute->appName); #elif ME_COM_MDB spec = sfmt(""mdb://%s.mdb"", eroute->appName); #endif } provider = ssplit(sclone(spec), ""://"", &path); if (*provider == '\0' || *path == '\0') { return MPR_ERR_BAD_ARGS; } path = mprJoinPath(httpGetDir(route, ""db""), path); dir = mprGetPathDir(path); if (!mprPathExists(dir, X_OK)) { mprMakeDir(dir, 0755, -1, -1, 1); } if ((eroute->edi = ediOpen(mprGetRelPath(path, NULL), provider, flags)) == 0) { return MPR_ERR_CANT_OPEN; } route->database = sclone(spec); return 0; }"
724,877--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-0231--var_unserializer.c----process_nested_data,"static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops) { while (elements-- > 0) { zval *key, *data, **old_data; ALLOC_INIT_ZVAL(key); if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); return 0; } if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) { zval_dtor(key); FREE_ZVAL(key); return 0; } ALLOC_INIT_ZVAL(data); if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); zval_dtor(data); FREE_ZVAL(data); return 0; } if (!objprops) { switch (Z_TYPE_P(key)) { case IS_LONG: if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL); break; case IS_STRING: if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL); break; } } else { convert_to_string(key); <S2SV_StartVul> if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { <S2SV_EndVul> var_push_dtor(var_hash, old_data); } zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof data, NULL); } zval_dtor(key); FREE_ZVAL(key); if (elements && *(*p-1) != ';' && *(*p-1) != '}') { (*p)--; return 0; } }","- if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
+ if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {","static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops) { while (elements-- > 0) { zval *key, *data, **old_data; ALLOC_INIT_ZVAL(key); if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); return 0; } if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) { zval_dtor(key); FREE_ZVAL(key); return 0; } ALLOC_INIT_ZVAL(data); if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); zval_dtor(data); FREE_ZVAL(data); return 0; } if (!objprops) { switch (Z_TYPE_P(key)) { case IS_LONG: if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL); break; case IS_STRING: if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL); break; } } else { convert_to_string(key); if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof data, NULL); } zval_dtor(key); FREE_ZVAL(key); if (elements && *(*p-1) != ';' && *(*p-1) != '}') { (*p)--; return 0; } }"
725,5010----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/stbl_write.c----stbl_AddSize,"<S2SV_StartVul> GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples) <S2SV_EndVul> { u32 i, k; u32 *newSizes; if (!stsz || !sampleNumber) return GF_BAD_PARAM; if (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM; <S2SV_StartVul> if (!nb_pack_samples) nb_pack_samples = 1; <S2SV_EndVul> <S2SV_StartVul> else if (nb_pack_samples>1) <S2SV_EndVul> <S2SV_StartVul> size /= nb_pack_samples; <S2SV_EndVul> if (stsz->sizes == NULL) { if (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) { <S2SV_StartVul> stsz->sampleCount = nb_pack_samples; <S2SV_EndVul> stsz->sampleSize = size; return GF_OK; } if (stsz->sampleSize == size) { <S2SV_StartVul> stsz->sampleCount += nb_pack_samples; <S2SV_EndVul> return GF_OK; } <S2SV_StartVul> if (nb_pack_samples>1) { <S2SV_EndVul> GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Inserting packed samples with different sizes is not yet supported\n"" )); return GF_NOT_SUPPORTED; } stsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1)); if (!stsz->sizes) return GF_OUT_OF_MEM; stsz->alloc_size = stsz->sampleCount + 1; k = 0; for (i = 0 ; i < stsz->sampleCount; i++) { if (i + 1 == sampleNumber) { stsz->sizes[i + k] = size; k = 1; } stsz->sizes[i+k] = stsz->sampleSize; } if (stsz->sampleCount + 1 == sampleNumber) { stsz->sizes[stsz->sampleCount] = size; } stsz->sampleSize = 0; stsz->sampleCount++; return GF_OK; } if (stsz->sampleCount + 1 == sampleNumber) { if (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount; if (stsz->sampleCount == stsz->alloc_size) { ALLOC_INC(stsz->alloc_size); stsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) ); if (!stsz->sizes) return GF_OUT_OF_MEM; memset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) ); } stsz->sizes[stsz->sampleCount] = size; } else { newSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) ); if (!newSizes) return GF_OUT_OF_MEM; k = 0; for (i = 0; i < stsz->sampleCount; i++) { if (i + 1 == sampleNumber) { newSizes[i + k] = size; k = 1; } newSizes[i + k] = stsz->sizes[i]; } gf_free(stsz->sizes); stsz->sizes = newSizes; stsz->alloc_size = 1 + stsz->sampleCount; } stsz->sampleCount++; return GF_OK; }","- GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack_samples)
- if (!nb_pack_samples) nb_pack_samples = 1;
- else if (nb_pack_samples>1)
- size /= nb_pack_samples;
- stsz->sampleCount = nb_pack_samples;
- stsz->sampleCount += nb_pack_samples;
- if (nb_pack_samples>1) {
+ GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack)
+ CHECK_PACK(GF_BAD_PARAM)
+ if (nb_pack>1)
+ size /= nb_pack;
+ stsz->sampleCount = nb_pack;
+ stsz->sampleCount += nb_pack;
+ if (nb_pack>1) {","GF_Err stbl_AddSize(GF_SampleSizeBox *stsz, u32 sampleNumber, u32 size, u32 nb_pack) { u32 i, k; u32 *newSizes; if (!stsz || !sampleNumber) return GF_BAD_PARAM; if (sampleNumber > stsz->sampleCount + 1) return GF_BAD_PARAM; CHECK_PACK(GF_BAD_PARAM) if (nb_pack>1) size /= nb_pack; if (stsz->sizes == NULL) { if (! stsz->sampleCount && (stsz->type != GF_ISOM_BOX_TYPE_STZ2) ) { stsz->sampleCount = nb_pack; stsz->sampleSize = size; return GF_OK; } if (stsz->sampleSize == size) { stsz->sampleCount += nb_pack; return GF_OK; } if (nb_pack>1) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Inserting packed samples with different sizes is not yet supported\n"" )); return GF_NOT_SUPPORTED; } stsz->sizes = (u32*)gf_malloc(sizeof(u32) * (stsz->sampleCount + 1)); if (!stsz->sizes) return GF_OUT_OF_MEM; stsz->alloc_size = stsz->sampleCount + 1; k = 0; for (i = 0 ; i < stsz->sampleCount; i++) { if (i + 1 == sampleNumber) { stsz->sizes[i + k] = size; k = 1; } stsz->sizes[i+k] = stsz->sampleSize; } if (stsz->sampleCount + 1 == sampleNumber) { stsz->sizes[stsz->sampleCount] = size; } stsz->sampleSize = 0; stsz->sampleCount++; return GF_OK; } if (stsz->sampleCount + 1 == sampleNumber) { if (!stsz->alloc_size) stsz->alloc_size = stsz->sampleCount; if (stsz->sampleCount == stsz->alloc_size) { ALLOC_INC(stsz->alloc_size); stsz->sizes = gf_realloc(stsz->sizes, sizeof(u32)*(stsz->alloc_size) ); if (!stsz->sizes) return GF_OUT_OF_MEM; memset(&stsz->sizes[stsz->sampleCount], 0, sizeof(u32)*(stsz->alloc_size - stsz->sampleCount) ); } stsz->sizes[stsz->sampleCount] = size; } else { newSizes = (u32*)gf_malloc(sizeof(u32)*(1 + stsz->sampleCount) ); if (!newSizes) return GF_OUT_OF_MEM; k = 0; for (i = 0; i < stsz->sampleCount; i++) { if (i + 1 == sampleNumber) { newSizes[i + k] = size; k = 1; } newSizes[i + k] = stsz->sizes[i]; } gf_free(stsz->sizes); stsz->sizes = newSizes; stsz->alloc_size = 1 + stsz->sampleCount; } stsz->sampleCount++; return GF_OK; }"
726,3507----CWE-17----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/attach.c----attach_child_main,"static int attach_child_main(void* data) { struct attach_clone_payload* payload = (struct attach_clone_payload*)data; int ipc_socket = payload->ipc_socket; lxc_attach_options_t* options = payload->options; struct lxc_proc_context_info* init_ctx = payload->init_ctx; #if HAVE_SYS_PERSONALITY_H long new_personality; #endif int ret; int status; int expected; long flags; int fd; uid_t new_uid; gid_t new_gid; expected = 0; status = -1; ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected); if (ret <= 0) { ERROR(""error using IPC to receive notification from initial process (0)""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) { ret = lxc_attach_remount_sys_proc(); if (ret < 0) { shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } #if HAVE_SYS_PERSONALITY_H if (options->personality < 0) new_personality = init_ctx->personality; else new_personality = options->personality; if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) { ret = personality(new_personality); if (ret < 0) { SYSERROR(""could not ensure correct architecture""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } #endif if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) { ret = lxc_attach_drop_privs(init_ctx); if (ret < 0) { ERROR(""could not drop privileges""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env); if (ret < 0) { ERROR(""could not set initial environment for attached process""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } new_uid = 0; new_gid = 0; if (options->namespaces & CLONE_NEWUSER) lxc_attach_get_init_uidgid(&new_uid, &new_gid); if (options->uid != (uid_t)-1) new_uid = options->uid; if (options->gid != (gid_t)-1) new_gid = options->gid; if (options->stdin_fd && isatty(options->stdin_fd)) { if (setsid() < 0) { SYSERROR(""unable to setsid""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) { SYSERROR(""unable to TIOCSTTY""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) { if (setgid(new_gid) || setgroups(0, NULL)) { SYSERROR(""switching to container gid""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) { SYSERROR(""switching to container uid""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } status = 1; ret = lxc_write_nointr(ipc_socket, &status, sizeof(status)); if (ret != sizeof(status)) { ERROR(""error using IPC to notify initial process for initialization (1)""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } expected = 2; status = -1; ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected); if (ret <= 0) { ERROR(""error using IPC to receive final notification from initial process (2)""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } shutdown(ipc_socket, SHUT_RDWR); close(ipc_socket); <S2SV_StartVul> if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) { <S2SV_EndVul> int on_exec; <S2SV_StartVul> int proc_mounted; <S2SV_EndVul> on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0; <S2SV_StartVul> proc_mounted = mount_proc_if_needed(""/""); <S2SV_EndVul> <S2SV_StartVul> if (proc_mounted == -1) { <S2SV_EndVul> <S2SV_StartVul> ERROR(""Error mounting a sane /proc""); <S2SV_EndVul> <S2SV_StartVul> rexit(-1); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> ret = lsm_process_label_set(init_ctx->lsm_label, <S2SV_EndVul> <S2SV_StartVul> init_ctx->container->lxc_conf, 0, on_exec); <S2SV_EndVul> <S2SV_StartVul> if (proc_mounted) <S2SV_EndVul> <S2SV_StartVul> umount(""/proc""); <S2SV_EndVul> <S2SV_StartVul> if (ret < 0) { <S2SV_EndVul> rexit(-1); } } if (init_ctx->container && init_ctx->container->lxc_conf && lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) { ERROR(""Loading seccomp policy""); rexit(-1); } lxc_proc_put_context_info(init_ctx); if (options->stdin_fd >= 0 && options->stdin_fd != 0) dup2(options->stdin_fd, 0); if (options->stdout_fd >= 0 && options->stdout_fd != 1) dup2(options->stdout_fd, 1); if (options->stderr_fd >= 0 && options->stderr_fd != 2) dup2(options->stderr_fd, 2); if (options->stdin_fd > 2) close(options->stdin_fd); if (options->stdout_fd > 2) close(options->stdout_fd); if (options->stderr_fd > 2) close(options->stderr_fd); for (fd = 0; fd <= 2; fd++) { flags = fcntl(fd, F_GETFL); if (flags < 0) continue; if (flags & FD_CLOEXEC) { if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) { SYSERROR(""Unable to clear CLOEXEC from fd""); } } } rexit(payload->exec_function(payload->exec_payload)); }","- if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM)) {
- int proc_mounted;
- proc_mounted = mount_proc_if_needed(""/"");
- if (proc_mounted == -1) {
- ERROR(""Error mounting a sane /proc"");
- rexit(-1);
- }
- ret = lsm_process_label_set(init_ctx->lsm_label,
- init_ctx->container->lxc_conf, 0, on_exec);
- if (proc_mounted)
- umount(""/proc"");
- if (ret < 0) {
+ int procfd = payload->procfd;
+ if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
+ if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
+ close(procfd);","static int attach_child_main(void* data) { struct attach_clone_payload* payload = (struct attach_clone_payload*)data; int ipc_socket = payload->ipc_socket; int procfd = payload->procfd; lxc_attach_options_t* options = payload->options; struct lxc_proc_context_info* init_ctx = payload->init_ctx; #if HAVE_SYS_PERSONALITY_H long new_personality; #endif int ret; int status; int expected; long flags; int fd; uid_t new_uid; gid_t new_gid; expected = 0; status = -1; ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected); if (ret <= 0) { ERROR(""error using IPC to receive notification from initial process (0)""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) { ret = lxc_attach_remount_sys_proc(); if (ret < 0) { shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } #if HAVE_SYS_PERSONALITY_H if (options->personality < 0) new_personality = init_ctx->personality; else new_personality = options->personality; if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) { ret = personality(new_personality); if (ret < 0) { SYSERROR(""could not ensure correct architecture""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } #endif if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) { ret = lxc_attach_drop_privs(init_ctx); if (ret < 0) { ERROR(""could not drop privileges""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env); if (ret < 0) { ERROR(""could not set initial environment for attached process""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } new_uid = 0; new_gid = 0; if (options->namespaces & CLONE_NEWUSER) lxc_attach_get_init_uidgid(&new_uid, &new_gid); if (options->uid != (uid_t)-1) new_uid = options->uid; if (options->gid != (gid_t)-1) new_gid = options->gid; if (options->stdin_fd && isatty(options->stdin_fd)) { if (setsid() < 0) { SYSERROR(""unable to setsid""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) { SYSERROR(""unable to TIOCSTTY""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) { if (setgid(new_gid) || setgroups(0, NULL)) { SYSERROR(""switching to container gid""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } } if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) { SYSERROR(""switching to container uid""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } status = 1; ret = lxc_write_nointr(ipc_socket, &status, sizeof(status)); if (ret != sizeof(status)) { ERROR(""error using IPC to notify initial process for initialization (1)""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } expected = 2; status = -1; ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected); if (ret <= 0) { ERROR(""error using IPC to receive final notification from initial process (2)""); shutdown(ipc_socket, SHUT_RDWR); rexit(-1); } shutdown(ipc_socket, SHUT_RDWR); close(ipc_socket); if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) { int on_exec; on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0; if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) { rexit(-1); } } if (init_ctx->container && init_ctx->container->lxc_conf && lxc_seccomp_load(init_ctx->container->lxc_conf) != 0) { ERROR(""Loading seccomp policy""); rexit(-1); } lxc_proc_put_context_info(init_ctx); if (options->stdin_fd >= 0 && options->stdin_fd != 0) dup2(options->stdin_fd, 0); if (options->stdout_fd >= 0 && options->stdout_fd != 1) dup2(options->stdout_fd, 1); if (options->stderr_fd >= 0 && options->stderr_fd != 2) dup2(options->stderr_fd, 2); if (options->stdin_fd > 2) close(options->stdin_fd); if (options->stdout_fd > 2) close(options->stdout_fd); if (options->stderr_fd > 2) close(options->stderr_fd); for (fd = 0; fd <= 2; fd++) { flags = fcntl(fd, F_GETFL); if (flags < 0) continue; if (flags & FD_CLOEXEC) { if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0) { SYSERROR(""Unable to clear CLOEXEC from fd""); } } } close(procfd); rexit(payload->exec_function(payload->exec_payload)); }"
727,948----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-8658--cfg80211.c----brcmf_cfg80211_start_ap,"brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev, struct cfg80211_ap_settings *settings) { s32 ie_offset; struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy); struct brcmf_if *ifp = netdev_priv(ndev); const struct brcmf_tlv *ssid_ie; const struct brcmf_tlv *country_ie; struct brcmf_ssid_le ssid_le; s32 err = -EPERM; const struct brcmf_tlv *rsn_ie; const struct brcmf_vs_tlv *wpa_ie; struct brcmf_join_params join_params; enum nl80211_iftype dev_role; struct brcmf_fil_bss_enable_le bss_enable; u16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef); bool mbss; int is_11d; brcmf_dbg(TRACE, ""ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\n"", settings->chandef.chan->hw_value, settings->chandef.center_freq1, settings->chandef.width, settings->beacon_interval, settings->dtim_period); brcmf_dbg(TRACE, ""ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\n"", settings->ssid, settings->ssid_len, settings->auth_type, settings->inactivity_timeout); dev_role = ifp->vif->wdev.iftype; mbss = ifp->vif->mbss; brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d); country_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_COUNTRY); is_11d = country_ie ? 1 : 0; memset(&ssid_le, 0, sizeof(ssid_le)); if (settings->ssid == NULL || settings->ssid_len == 0) { ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; ssid_ie = brcmf_parse_tlvs( (u8 *)&settings->beacon.head[ie_offset], settings->beacon.head_len - ie_offset, WLAN_EID_SSID); <S2SV_StartVul> if (!ssid_ie) <S2SV_EndVul> return -EINVAL; memcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len); ssid_le.SSID_len = cpu_to_le32(ssid_ie->len); brcmf_dbg(TRACE, ""SSID is (%s) in Head\n"", ssid_le.SSID); } else { memcpy(ssid_le.SSID, settings->ssid, settings->ssid_len); ssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len); } if (!mbss) { brcmf_set_mpc(ifp, 0); brcmf_configure_arp_nd_offload(ifp, false); } rsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_RSN); wpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail, settings->beacon.tail_len); if ((wpa_ie != NULL || rsn_ie != NULL)) { brcmf_dbg(TRACE, ""WPA(2) IE is found\n""); if (wpa_ie != NULL) { err = brcmf_configure_wpaie(ifp, wpa_ie, false); if (err < 0) goto exit; } else { struct brcmf_vs_tlv *tmp_ie; tmp_ie = (struct brcmf_vs_tlv *)rsn_ie; err = brcmf_configure_wpaie(ifp, tmp_ie, true); if (err < 0) goto exit; } } else { brcmf_dbg(TRACE, ""No WPA(2) IEs found\n""); brcmf_configure_opensecurity(ifp); } brcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon); if (!mbss) { if (is_11d != ifp->vif->is_11d) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY, is_11d); if (err < 0) { brcmf_err(""Regulatory Set Error, %d\n"", err); goto exit; } } if (settings->beacon_interval) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, settings->beacon_interval); if (err < 0) { brcmf_err(""Beacon Interval Set Error, %d\n"", err); goto exit; } } if (settings->dtim_period) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD, settings->dtim_period); if (err < 0) { brcmf_err(""DTIM Interval Set Error, %d\n"", err); goto exit; } } if ((dev_role == NL80211_IFTYPE_AP) && ((ifp->ifidx == 0) || !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1); if (err < 0) { brcmf_err(""BRCMF_C_DOWN error %d\n"", err); goto exit; } brcmf_fil_iovar_int_set(ifp, ""apsta"", 0); } err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1); if (err < 0) { brcmf_err(""SET INFRA error %d\n"", err); goto exit; } } else if (WARN_ON(is_11d != ifp->vif->is_11d)) { err = -EINVAL; goto exit; } if (dev_role == NL80211_IFTYPE_AP) { if ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss)) brcmf_fil_iovar_int_set(ifp, ""mbss"", 1); err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1); if (err < 0) { brcmf_err(""setting AP mode failed %d\n"", err); goto exit; } if (!mbss) { err = brcmf_fil_iovar_int_set(ifp, ""chanspec"", chanspec); if (err < 0) { brcmf_err(""Set Channel failed: chspec=%d, %d\n"", chanspec, err); goto exit; } } err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1); if (err < 0) { brcmf_err(""BRCMF_C_UP error (%d)\n"", err); goto exit; } brcmf_cfg80211_reconfigure_wep(ifp); memset(&join_params, 0, sizeof(join_params)); memcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le)); err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID, &join_params, sizeof(join_params)); if (err < 0) { brcmf_err(""SET SSID error (%d)\n"", err); goto exit; } if (settings->hidden_ssid) { err = brcmf_fil_iovar_int_set(ifp, ""closednet"", 1); if (err) { brcmf_err(""closednet error (%d)\n"", err); goto exit; } } brcmf_dbg(TRACE, ""AP mode configuration complete\n""); } else if (dev_role == NL80211_IFTYPE_P2P_GO) { err = brcmf_fil_iovar_int_set(ifp, ""chanspec"", chanspec); if (err < 0) { brcmf_err(""Set Channel failed: chspec=%d, %d\n"", chanspec, err); goto exit; } err = brcmf_fil_bsscfg_data_set(ifp, ""ssid"", &ssid_le, sizeof(ssid_le)); if (err < 0) { brcmf_err(""setting ssid failed %d\n"", err); goto exit; } bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx); bss_enable.enable = cpu_to_le32(1); err = brcmf_fil_iovar_data_set(ifp, ""bss"", &bss_enable, sizeof(bss_enable)); if (err < 0) { brcmf_err(""bss_enable config failed %d\n"", err); goto exit; } brcmf_dbg(TRACE, ""GO mode configuration complete\n""); } else { WARN_ON(1); } set_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state); brcmf_net_setcarrier(ifp, true); exit: if ((err) && (!mbss)) { brcmf_set_mpc(ifp, 1); brcmf_configure_arp_nd_offload(ifp, true); } return err; }","- if (!ssid_ie)
+ if (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)","brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev, struct cfg80211_ap_settings *settings) { s32 ie_offset; struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy); struct brcmf_if *ifp = netdev_priv(ndev); const struct brcmf_tlv *ssid_ie; const struct brcmf_tlv *country_ie; struct brcmf_ssid_le ssid_le; s32 err = -EPERM; const struct brcmf_tlv *rsn_ie; const struct brcmf_vs_tlv *wpa_ie; struct brcmf_join_params join_params; enum nl80211_iftype dev_role; struct brcmf_fil_bss_enable_le bss_enable; u16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef); bool mbss; int is_11d; brcmf_dbg(TRACE, ""ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\n"", settings->chandef.chan->hw_value, settings->chandef.center_freq1, settings->chandef.width, settings->beacon_interval, settings->dtim_period); brcmf_dbg(TRACE, ""ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\n"", settings->ssid, settings->ssid_len, settings->auth_type, settings->inactivity_timeout); dev_role = ifp->vif->wdev.iftype; mbss = ifp->vif->mbss; brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d); country_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_COUNTRY); is_11d = country_ie ? 1 : 0; memset(&ssid_le, 0, sizeof(ssid_le)); if (settings->ssid == NULL || settings->ssid_len == 0) { ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; ssid_ie = brcmf_parse_tlvs( (u8 *)&settings->beacon.head[ie_offset], settings->beacon.head_len - ie_offset, WLAN_EID_SSID); if (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN) return -EINVAL; memcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len); ssid_le.SSID_len = cpu_to_le32(ssid_ie->len); brcmf_dbg(TRACE, ""SSID is (%s) in Head\n"", ssid_le.SSID); } else { memcpy(ssid_le.SSID, settings->ssid, settings->ssid_len); ssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len); } if (!mbss) { brcmf_set_mpc(ifp, 0); brcmf_configure_arp_nd_offload(ifp, false); } rsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_RSN); wpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail, settings->beacon.tail_len); if ((wpa_ie != NULL || rsn_ie != NULL)) { brcmf_dbg(TRACE, ""WPA(2) IE is found\n""); if (wpa_ie != NULL) { err = brcmf_configure_wpaie(ifp, wpa_ie, false); if (err < 0) goto exit; } else { struct brcmf_vs_tlv *tmp_ie; tmp_ie = (struct brcmf_vs_tlv *)rsn_ie; err = brcmf_configure_wpaie(ifp, tmp_ie, true); if (err < 0) goto exit; } } else { brcmf_dbg(TRACE, ""No WPA(2) IEs found\n""); brcmf_configure_opensecurity(ifp); } brcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon); if (!mbss) { if (is_11d != ifp->vif->is_11d) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY, is_11d); if (err < 0) { brcmf_err(""Regulatory Set Error, %d\n"", err); goto exit; } } if (settings->beacon_interval) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, settings->beacon_interval); if (err < 0) { brcmf_err(""Beacon Interval Set Error, %d\n"", err); goto exit; } } if (settings->dtim_period) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD, settings->dtim_period); if (err < 0) { brcmf_err(""DTIM Interval Set Error, %d\n"", err); goto exit; } } if ((dev_role == NL80211_IFTYPE_AP) && ((ifp->ifidx == 0) || !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1); if (err < 0) { brcmf_err(""BRCMF_C_DOWN error %d\n"", err); goto exit; } brcmf_fil_iovar_int_set(ifp, ""apsta"", 0); } err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1); if (err < 0) { brcmf_err(""SET INFRA error %d\n"", err); goto exit; } } else if (WARN_ON(is_11d != ifp->vif->is_11d)) { err = -EINVAL; goto exit; } if (dev_role == NL80211_IFTYPE_AP) { if ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss)) brcmf_fil_iovar_int_set(ifp, ""mbss"", 1); err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1); if (err < 0) { brcmf_err(""setting AP mode failed %d\n"", err); goto exit; } if (!mbss) { err = brcmf_fil_iovar_int_set(ifp, ""chanspec"", chanspec); if (err < 0) { brcmf_err(""Set Channel failed: chspec=%d, %d\n"", chanspec, err); goto exit; } } err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1); if (err < 0) { brcmf_err(""BRCMF_C_UP error (%d)\n"", err); goto exit; } brcmf_cfg80211_reconfigure_wep(ifp); memset(&join_params, 0, sizeof(join_params)); memcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le)); err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID, &join_params, sizeof(join_params)); if (err < 0) { brcmf_err(""SET SSID error (%d)\n"", err); goto exit; } if (settings->hidden_ssid) { err = brcmf_fil_iovar_int_set(ifp, ""closednet"", 1); if (err) { brcmf_err(""closednet error (%d)\n"", err); goto exit; } } brcmf_dbg(TRACE, ""AP mode configuration complete\n""); } else if (dev_role == NL80211_IFTYPE_P2P_GO) { err = brcmf_fil_iovar_int_set(ifp, ""chanspec"", chanspec); if (err < 0) { brcmf_err(""Set Channel failed: chspec=%d, %d\n"", chanspec, err); goto exit; } err = brcmf_fil_bsscfg_data_set(ifp, ""ssid"", &ssid_le, sizeof(ssid_le)); if (err < 0) { brcmf_err(""setting ssid failed %d\n"", err); goto exit; } bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx); bss_enable.enable = cpu_to_le32(1); err = brcmf_fil_iovar_data_set(ifp, ""bss"", &bss_enable, sizeof(bss_enable)); if (err < 0) { brcmf_err(""bss_enable config failed %d\n"", err); goto exit; } brcmf_dbg(TRACE, ""GO mode configuration complete\n""); } else { WARN_ON(1); } set_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state); brcmf_net_setcarrier(ifp, true); exit: if ((err) && (!mbss)) { brcmf_set_mpc(ifp, 1); brcmf_configure_arp_nd_offload(ifp, true); } return err; }"
728,7383----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mysqlcheck.c----dbConnect,"static int dbConnect(char *host, char *user, char *passwd) { DBUG_ENTER(""dbConnect""); if (verbose) { fprintf(stderr, ""# Connecting to %s...\n"", host ? host : ""localhost""); } mysql_init(&mysql_connection); if (opt_compress) mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS); <S2SV_StartVul> #ifdef HAVE_OPENSSL <S2SV_EndVul> <S2SV_StartVul> if (opt_use_ssl) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca, <S2SV_EndVul> <S2SV_StartVul> opt_ssl_capath, opt_ssl_cipher); <S2SV_EndVul> <S2SV_StartVul> mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl); <S2SV_EndVul> <S2SV_StartVul> mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> #endif <S2SV_EndVul> if (opt_protocol) mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol); if (opt_bind_addr) mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr); #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) if (shared_memory_base_name) mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name); #endif if (opt_plugin_dir && *opt_plugin_dir) mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir); if (opt_default_auth && *opt_default_auth) mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth); mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset); mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0); mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD, ""program_name"", ""mysqlcheck""); if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd, NULL, opt_mysql_port, opt_mysql_unix_port, 0))) { DBerror(&mysql_connection, ""when trying to connect""); DBUG_RETURN(1); } mysql_connection.reconnect= 1; DBUG_RETURN(0); }","- #ifdef HAVE_OPENSSL
- if (opt_use_ssl)
- {
- mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
- opt_ssl_capath, opt_ssl_cipher);
- mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);
- mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);
- }
- #endif
+ SSL_SET_OPTIONS(&mysql_connection);","static int dbConnect(char *host, char *user, char *passwd) { DBUG_ENTER(""dbConnect""); if (verbose) { fprintf(stderr, ""# Connecting to %s...\n"", host ? host : ""localhost""); } mysql_init(&mysql_connection); if (opt_compress) mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS); SSL_SET_OPTIONS(&mysql_connection); if (opt_protocol) mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol); if (opt_bind_addr) mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr); #if defined (_WIN32) && !defined (EMBEDDED_LIBRARY) if (shared_memory_base_name) mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name); #endif if (opt_plugin_dir && *opt_plugin_dir) mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir); if (opt_default_auth && *opt_default_auth) mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth); mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset); mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0); mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD, ""program_name"", ""mysqlcheck""); if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd, NULL, opt_mysql_port, opt_mysql_unix_port, 0))) { DBerror(&mysql_connection, ""when trying to connect""); DBUG_RETURN(1); } mysql_connection.reconnect= 1; DBUG_RETURN(0); }"
729,7490----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/volumes.c----btrfs_find_device,"struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices, <S2SV_StartVul> u64 devid, u8 *uuid, u8 *fsid) <S2SV_EndVul> { struct btrfs_device *device; while (fs_devices) { if (!fsid || !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) { <S2SV_StartVul> device = find_device(fs_devices, devid, uuid); <S2SV_EndVul> <S2SV_StartVul> if (device) <S2SV_EndVul> <S2SV_StartVul> return device; <S2SV_EndVul> } <S2SV_StartVul> fs_devices = fs_devices->seed; <S2SV_EndVul> } return NULL; }","- u64 devid, u8 *uuid, u8 *fsid)
- device = find_device(fs_devices, devid, uuid);
- if (device)
- return device;
- fs_devices = fs_devices->seed;
+ u64 devid, u8 *uuid, u8 *fsid,
+ bool seed)
+ list_for_each_entry(device, &fs_devices->devices,
+ dev_list) {
+ if (device->devid == devid &&
+ (!uuid || memcmp(device->uuid, uuid,
+ BTRFS_UUID_SIZE) == 0))
+ return device;
+ }
+ if (seed)
+ fs_devices = fs_devices->seed;
+ else
+ return NULL;","struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid, u8 *fsid, bool seed) { struct btrfs_device *device; while (fs_devices) { if (!fsid || !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) { list_for_each_entry(device, &fs_devices->devices, dev_list) { if (device->devid == devid && (!uuid || memcmp(device->uuid, uuid, BTRFS_UUID_SIZE) == 0)) return device; } } if (seed) fs_devices = fs_devices->seed; else return NULL; } return NULL; }"
730,1405----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-12902--print-zephyr.c----zephyr_print,"zephyr_print(netdissect_options *ndo, const u_char *cp, int length) { struct z_packet z; const char *parse = (const char *) cp; int parselen = length; const char *s; int lose = 0; z.kind = 0; z.class = 0; z.inst = 0; z.opcode = 0; z.sender = 0; z.recipient = 0; <S2SV_StartVul> #define PARSE_STRING \ <S2SV_EndVul> <S2SV_StartVul> s = parse_field(ndo, &parse, &parselen); \ <S2SV_EndVul> if (!s) lose = 1; #define PARSE_FIELD_INT(field) \ PARSE_STRING \ if (!lose) field = strtol(s, 0, 16); #define PARSE_FIELD_STR(field) \ PARSE_STRING \ if (!lose) field = s; PARSE_FIELD_STR(z.version); if (lose) return; if (strncmp(z.version, ""ZEPH"", 4)) return; PARSE_FIELD_INT(z.numfields); PARSE_FIELD_INT(z.kind); PARSE_FIELD_STR(z.uid); PARSE_FIELD_INT(z.port); PARSE_FIELD_INT(z.auth); PARSE_FIELD_INT(z.authlen); PARSE_FIELD_STR(z.authdata); PARSE_FIELD_STR(z.class); PARSE_FIELD_STR(z.inst); PARSE_FIELD_STR(z.opcode); PARSE_FIELD_STR(z.sender); PARSE_FIELD_STR(z.recipient); PARSE_FIELD_STR(z.format); PARSE_FIELD_INT(z.cksum); PARSE_FIELD_INT(z.multi); PARSE_FIELD_STR(z.multi_uid); <S2SV_StartVul> if (lose) { <S2SV_EndVul> <S2SV_StartVul> ND_PRINT((ndo, "" [|zephyr] (%d)"", length)); <S2SV_EndVul> <S2SV_StartVul> return; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> ND_PRINT((ndo, "" zephyr"")); if (strncmp(z.version+4, ""0.2"", 3)) { ND_PRINT((ndo, "" v%s"", z.version+4)); return; } ND_PRINT((ndo, "" %s"", tok2str(z_types, ""type %d"", z.kind))); if (z.kind == Z_PACKET_SERVACK) { const char *ackdata = NULL; PARSE_FIELD_STR(ackdata); if (!lose && strcmp(ackdata, ""SENT"")) ND_PRINT((ndo, ""/%s"", str_to_lower(ackdata))); } if (*z.sender) ND_PRINT((ndo, "" %s"", z.sender)); if (!strcmp(z.class, ""USER_LOCATE"")) { if (!strcmp(z.opcode, ""USER_HIDE"")) ND_PRINT((ndo, "" hide"")); else if (!strcmp(z.opcode, ""USER_UNHIDE"")) ND_PRINT((ndo, "" unhide"")); else ND_PRINT((ndo, "" locate %s"", z.inst)); return; } if (!strcmp(z.class, ""ZEPHYR_ADMIN"")) { ND_PRINT((ndo, "" zephyr-admin %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.class, ""ZEPHYR_CTL"")) { if (!strcmp(z.inst, ""CLIENT"")) { if (!strcmp(z.opcode, ""SUBSCRIBE"") || !strcmp(z.opcode, ""SUBSCRIBE_NODEFS"") || !strcmp(z.opcode, ""UNSUBSCRIBE"")) { ND_PRINT((ndo, "" %ssub%s"", strcmp(z.opcode, ""SUBSCRIBE"") ? ""un"" : """", strcmp(z.opcode, ""SUBSCRIBE_NODEFS"") ? """" : ""-nodefs"")); if (z.kind != Z_PACKET_SERVACK) { const char *c = NULL, *i = NULL, *r = NULL; PARSE_FIELD_STR(c); PARSE_FIELD_STR(i); PARSE_FIELD_STR(r); if (!lose) ND_PRINT((ndo, "" %s"", z_triple(c, i, r))); } return; } if (!strcmp(z.opcode, ""GIMME"")) { ND_PRINT((ndo, "" ret"")); return; } if (!strcmp(z.opcode, ""GIMMEDEFS"")) { ND_PRINT((ndo, "" gimme-defs"")); return; } if (!strcmp(z.opcode, ""CLEARSUB"")) { ND_PRINT((ndo, "" clear-subs"")); return; } ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.inst, ""HM"")) { ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.inst, ""REALM"")) { if (!strcmp(z.opcode, ""ADD_SUBSCRIBE"")) ND_PRINT((ndo, "" realm add-subs"")); if (!strcmp(z.opcode, ""REQ_SUBSCRIBE"")) ND_PRINT((ndo, "" realm req-subs"")); if (!strcmp(z.opcode, ""RLM_SUBSCRIBE"")) ND_PRINT((ndo, "" realm rlm-sub"")); if (!strcmp(z.opcode, ""RLM_UNSUBSCRIBE"")) ND_PRINT((ndo, "" realm rlm-unsub"")); return; } } if (!strcmp(z.class, ""HM_CTL"")) { ND_PRINT((ndo, "" hm_ctl %s"", str_to_lower(z.inst))); ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.class, ""HM_STAT"")) { if (!strcmp(z.inst, ""HMST_CLIENT"") && !strcmp(z.opcode, ""GIMMESTATS"")) { ND_PRINT((ndo, "" get-client-stats"")); return; } } if (!strcmp(z.class, ""WG_CTL"")) { ND_PRINT((ndo, "" wg_ctl %s"", str_to_lower(z.inst))); ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.class, ""LOGIN"")) { if (!strcmp(z.opcode, ""USER_FLUSH"")) { ND_PRINT((ndo, "" flush_locs"")); return; } if (!strcmp(z.opcode, ""NONE"") || !strcmp(z.opcode, ""OPSTAFF"") || !strcmp(z.opcode, ""REALM-VISIBLE"") || !strcmp(z.opcode, ""REALM-ANNOUNCED"") || !strcmp(z.opcode, ""NET-VISIBLE"") || !strcmp(z.opcode, ""NET-ANNOUNCED"")) { ND_PRINT((ndo, "" set-exposure %s"", str_to_lower(z.opcode))); return; } } if (!*z.recipient) z.recipient = ""*""; ND_PRINT((ndo, "" to %s"", z_triple(z.class, z.inst, z.recipient))); if (*z.opcode) ND_PRINT((ndo, "" op %s"", z.opcode)); }","- #define PARSE_STRING \
- s = parse_field(ndo, &parse, &parselen); \
- if (lose) {
- ND_PRINT((ndo, "" [|zephyr] (%d)"", length));
- return;
- }
+ int truncated = 0;
+ #define PARSE_STRING \
+ s = parse_field(ndo, &parse, &parselen, &truncated); \
+ if (truncated) goto trunc; \
+ if (lose)
+ goto trunc;
+ return;
+ trunc:
+ ND_PRINT((ndo, "" [|zephyr] (%d)"", length));
+ return;","zephyr_print(netdissect_options *ndo, const u_char *cp, int length) { struct z_packet z; const char *parse = (const char *) cp; int parselen = length; const char *s; int lose = 0; int truncated = 0; z.kind = 0; z.class = 0; z.inst = 0; z.opcode = 0; z.sender = 0; z.recipient = 0; #define PARSE_STRING \ s = parse_field(ndo, &parse, &parselen, &truncated); \ if (truncated) goto trunc; \ if (!s) lose = 1; #define PARSE_FIELD_INT(field) \ PARSE_STRING \ if (!lose) field = strtol(s, 0, 16); #define PARSE_FIELD_STR(field) \ PARSE_STRING \ if (!lose) field = s; PARSE_FIELD_STR(z.version); if (lose) return; if (strncmp(z.version, ""ZEPH"", 4)) return; PARSE_FIELD_INT(z.numfields); PARSE_FIELD_INT(z.kind); PARSE_FIELD_STR(z.uid); PARSE_FIELD_INT(z.port); PARSE_FIELD_INT(z.auth); PARSE_FIELD_INT(z.authlen); PARSE_FIELD_STR(z.authdata); PARSE_FIELD_STR(z.class); PARSE_FIELD_STR(z.inst); PARSE_FIELD_STR(z.opcode); PARSE_FIELD_STR(z.sender); PARSE_FIELD_STR(z.recipient); PARSE_FIELD_STR(z.format); PARSE_FIELD_INT(z.cksum); PARSE_FIELD_INT(z.multi); PARSE_FIELD_STR(z.multi_uid); if (lose) goto trunc; ND_PRINT((ndo, "" zephyr"")); if (strncmp(z.version+4, ""0.2"", 3)) { ND_PRINT((ndo, "" v%s"", z.version+4)); return; } ND_PRINT((ndo, "" %s"", tok2str(z_types, ""type %d"", z.kind))); if (z.kind == Z_PACKET_SERVACK) { const char *ackdata = NULL; PARSE_FIELD_STR(ackdata); if (!lose && strcmp(ackdata, ""SENT"")) ND_PRINT((ndo, ""/%s"", str_to_lower(ackdata))); } if (*z.sender) ND_PRINT((ndo, "" %s"", z.sender)); if (!strcmp(z.class, ""USER_LOCATE"")) { if (!strcmp(z.opcode, ""USER_HIDE"")) ND_PRINT((ndo, "" hide"")); else if (!strcmp(z.opcode, ""USER_UNHIDE"")) ND_PRINT((ndo, "" unhide"")); else ND_PRINT((ndo, "" locate %s"", z.inst)); return; } if (!strcmp(z.class, ""ZEPHYR_ADMIN"")) { ND_PRINT((ndo, "" zephyr-admin %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.class, ""ZEPHYR_CTL"")) { if (!strcmp(z.inst, ""CLIENT"")) { if (!strcmp(z.opcode, ""SUBSCRIBE"") || !strcmp(z.opcode, ""SUBSCRIBE_NODEFS"") || !strcmp(z.opcode, ""UNSUBSCRIBE"")) { ND_PRINT((ndo, "" %ssub%s"", strcmp(z.opcode, ""SUBSCRIBE"") ? ""un"" : """", strcmp(z.opcode, ""SUBSCRIBE_NODEFS"") ? """" : ""-nodefs"")); if (z.kind != Z_PACKET_SERVACK) { const char *c = NULL, *i = NULL, *r = NULL; PARSE_FIELD_STR(c); PARSE_FIELD_STR(i); PARSE_FIELD_STR(r); if (!lose) ND_PRINT((ndo, "" %s"", z_triple(c, i, r))); } return; } if (!strcmp(z.opcode, ""GIMME"")) { ND_PRINT((ndo, "" ret"")); return; } if (!strcmp(z.opcode, ""GIMMEDEFS"")) { ND_PRINT((ndo, "" gimme-defs"")); return; } if (!strcmp(z.opcode, ""CLEARSUB"")) { ND_PRINT((ndo, "" clear-subs"")); return; } ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.inst, ""HM"")) { ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.inst, ""REALM"")) { if (!strcmp(z.opcode, ""ADD_SUBSCRIBE"")) ND_PRINT((ndo, "" realm add-subs"")); if (!strcmp(z.opcode, ""REQ_SUBSCRIBE"")) ND_PRINT((ndo, "" realm req-subs"")); if (!strcmp(z.opcode, ""RLM_SUBSCRIBE"")) ND_PRINT((ndo, "" realm rlm-sub"")); if (!strcmp(z.opcode, ""RLM_UNSUBSCRIBE"")) ND_PRINT((ndo, "" realm rlm-unsub"")); return; } } if (!strcmp(z.class, ""HM_CTL"")) { ND_PRINT((ndo, "" hm_ctl %s"", str_to_lower(z.inst))); ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.class, ""HM_STAT"")) { if (!strcmp(z.inst, ""HMST_CLIENT"") && !strcmp(z.opcode, ""GIMMESTATS"")) { ND_PRINT((ndo, "" get-client-stats"")); return; } } if (!strcmp(z.class, ""WG_CTL"")) { ND_PRINT((ndo, "" wg_ctl %s"", str_to_lower(z.inst))); ND_PRINT((ndo, "" %s"", str_to_lower(z.opcode))); return; } if (!strcmp(z.class, ""LOGIN"")) { if (!strcmp(z.opcode, ""USER_FLUSH"")) { ND_PRINT((ndo, "" flush_locs"")); return; } if (!strcmp(z.opcode, ""NONE"") || !strcmp(z.opcode, ""OPSTAFF"") || !strcmp(z.opcode, ""REALM-VISIBLE"") || !strcmp(z.opcode, ""REALM-ANNOUNCED"") || !strcmp(z.opcode, ""NET-VISIBLE"") || !strcmp(z.opcode, ""NET-ANNOUNCED"")) { ND_PRINT((ndo, "" set-exposure %s"", str_to_lower(z.opcode))); return; } } if (!*z.recipient) z.recipient = ""*""; ND_PRINT((ndo, "" to %s"", z_triple(z.class, z.inst, z.recipient))); if (*z.opcode) ND_PRINT((ndo, "" op %s"", z.opcode)); return; trunc: ND_PRINT((ndo, "" [|zephyr] (%d)"", length)); return; }"
731,1417----CWE-415----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-12858--zip_dirent.c----_zip_dirent_read,"_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error) { zip_uint8_t buf[CDENTRYSIZE]; zip_uint16_t dostime, dosdate; zip_uint32_t size, variable_size; zip_uint16_t filename_len, comment_len, ef_len; bool from_buffer = (buffer != NULL); size = local ? LENTRYSIZE : CDENTRYSIZE; if (buffer) { if (_zip_buffer_left(buffer) < size) { zip_error_set(error, ZIP_ER_NOZIP, 0); return -1; } } else { if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) { return -1; } } if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) { zip_error_set(error, ZIP_ER_NOZIP, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } _zip_dirent_init(zde); if (!local) zde->version_madeby = _zip_buffer_get_16(buffer); else zde->version_madeby = 0; zde->version_needed = _zip_buffer_get_16(buffer); zde->bitflags = _zip_buffer_get_16(buffer); zde->comp_method = _zip_buffer_get_16(buffer); dostime = _zip_buffer_get_16(buffer); dosdate = _zip_buffer_get_16(buffer); zde->last_mod = _zip_d2u_time(dostime, dosdate); zde->crc = _zip_buffer_get_32(buffer); zde->comp_size = _zip_buffer_get_32(buffer); zde->uncomp_size = _zip_buffer_get_32(buffer); filename_len = _zip_buffer_get_16(buffer); ef_len = _zip_buffer_get_16(buffer); if (local) { comment_len = 0; zde->disk_number = 0; zde->int_attrib = 0; zde->ext_attrib = 0; zde->offset = 0; } else { comment_len = _zip_buffer_get_16(buffer); zde->disk_number = _zip_buffer_get_16(buffer); zde->int_attrib = _zip_buffer_get_16(buffer); zde->ext_attrib = _zip_buffer_get_32(buffer); zde->offset = _zip_buffer_get_32(buffer); } if (!_zip_buffer_ok(buffer)) { zip_error_set(error, ZIP_ER_INTERNAL, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCRYPTED) { if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) { zde->encryption_method = ZIP_EM_UNKNOWN; } else { zde->encryption_method = ZIP_EM_TRAD_PKWARE; } } else { zde->encryption_method = ZIP_EM_NONE; } zde->filename = NULL; zde->extra_fields = NULL; zde->comment = NULL; variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len; if (from_buffer) { if (_zip_buffer_left(buffer) < variable_size) { zip_error_set(error, ZIP_ER_INCONS, 0); return -1; } } else { _zip_buffer_free(buffer); if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) { return -1; } } if (filename_len) { zde->filename = _zip_read_string(buffer, src, filename_len, 1, error); if (!zde->filename) { if (zip_error_code_zip(error) == ZIP_ER_EOF) { zip_error_set(error, ZIP_ER_INCONS, 0); } if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) { if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) { zip_error_set(error, ZIP_ER_INCONS, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } } } if (ef_len) { zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error); if (ef == NULL) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) { free(ef); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } free(ef); if (local) zde->local_extra_fields_read = 1; } if (comment_len) { zde->comment = _zip_read_string(buffer, src, comment_len, 0, error); if (!zde->comment) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) { if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) { zip_error_set(error, ZIP_ER_INCONS, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } } } zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename); zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment); if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) { zip_uint16_t got_len; zip_buffer_t *ef_buffer; const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error); if (ef == NULL) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) { zip_error_set(error, ZIP_ER_MEMORY, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->uncomp_size == ZIP_UINT32_MAX) zde->uncomp_size = _zip_buffer_get_64(ef_buffer); else if (local) { (void)_zip_buffer_skip(ef_buffer, 8); } if (zde->comp_size == ZIP_UINT32_MAX) zde->comp_size = _zip_buffer_get_64(ef_buffer); if (!local) { if (zde->offset == ZIP_UINT32_MAX) zde->offset = _zip_buffer_get_64(ef_buffer); if (zde->disk_number == ZIP_UINT16_MAX) zde->disk_number = _zip_buffer_get_32(buffer); } if (!_zip_buffer_eof(ef_buffer)) { zip_error_set(error, ZIP_ER_INCONS, 0); _zip_buffer_free(ef_buffer); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } _zip_buffer_free(ef_buffer); } if (!_zip_buffer_ok(buffer)) { zip_error_set(error, ZIP_ER_INTERNAL, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (!from_buffer) { _zip_buffer_free(buffer); } if (zde->offset > ZIP_INT64_MAX) { zip_error_set(error, ZIP_ER_SEEK, EFBIG); return -1; } if (!_zip_dirent_process_winzip_aes(zde, error)) { <S2SV_StartVul> if (!from_buffer) { <S2SV_EndVul> <S2SV_StartVul> _zip_buffer_free(buffer); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> return -1; } zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields); return (zip_int64_t)(size + variable_size); }","- if (!from_buffer) {
- _zip_buffer_free(buffer);
- }","_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error) { zip_uint8_t buf[CDENTRYSIZE]; zip_uint16_t dostime, dosdate; zip_uint32_t size, variable_size; zip_uint16_t filename_len, comment_len, ef_len; bool from_buffer = (buffer != NULL); size = local ? LENTRYSIZE : CDENTRYSIZE; if (buffer) { if (_zip_buffer_left(buffer) < size) { zip_error_set(error, ZIP_ER_NOZIP, 0); return -1; } } else { if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) { return -1; } } if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) { zip_error_set(error, ZIP_ER_NOZIP, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } _zip_dirent_init(zde); if (!local) zde->version_madeby = _zip_buffer_get_16(buffer); else zde->version_madeby = 0; zde->version_needed = _zip_buffer_get_16(buffer); zde->bitflags = _zip_buffer_get_16(buffer); zde->comp_method = _zip_buffer_get_16(buffer); dostime = _zip_buffer_get_16(buffer); dosdate = _zip_buffer_get_16(buffer); zde->last_mod = _zip_d2u_time(dostime, dosdate); zde->crc = _zip_buffer_get_32(buffer); zde->comp_size = _zip_buffer_get_32(buffer); zde->uncomp_size = _zip_buffer_get_32(buffer); filename_len = _zip_buffer_get_16(buffer); ef_len = _zip_buffer_get_16(buffer); if (local) { comment_len = 0; zde->disk_number = 0; zde->int_attrib = 0; zde->ext_attrib = 0; zde->offset = 0; } else { comment_len = _zip_buffer_get_16(buffer); zde->disk_number = _zip_buffer_get_16(buffer); zde->int_attrib = _zip_buffer_get_16(buffer); zde->ext_attrib = _zip_buffer_get_32(buffer); zde->offset = _zip_buffer_get_32(buffer); } if (!_zip_buffer_ok(buffer)) { zip_error_set(error, ZIP_ER_INTERNAL, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCRYPTED) { if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) { zde->encryption_method = ZIP_EM_UNKNOWN; } else { zde->encryption_method = ZIP_EM_TRAD_PKWARE; } } else { zde->encryption_method = ZIP_EM_NONE; } zde->filename = NULL; zde->extra_fields = NULL; zde->comment = NULL; variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len; if (from_buffer) { if (_zip_buffer_left(buffer) < variable_size) { zip_error_set(error, ZIP_ER_INCONS, 0); return -1; } } else { _zip_buffer_free(buffer); if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) { return -1; } } if (filename_len) { zde->filename = _zip_read_string(buffer, src, filename_len, 1, error); if (!zde->filename) { if (zip_error_code_zip(error) == ZIP_ER_EOF) { zip_error_set(error, ZIP_ER_INCONS, 0); } if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) { if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) { zip_error_set(error, ZIP_ER_INCONS, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } } } if (ef_len) { zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error); if (ef == NULL) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) { free(ef); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } free(ef); if (local) zde->local_extra_fields_read = 1; } if (comment_len) { zde->comment = _zip_read_string(buffer, src, comment_len, 0, error); if (!zde->comment) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) { if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) { zip_error_set(error, ZIP_ER_INCONS, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } } } zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename); zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment); if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) { zip_uint16_t got_len; zip_buffer_t *ef_buffer; const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error); if (ef == NULL) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) { zip_error_set(error, ZIP_ER_MEMORY, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->uncomp_size == ZIP_UINT32_MAX) zde->uncomp_size = _zip_buffer_get_64(ef_buffer); else if (local) { (void)_zip_buffer_skip(ef_buffer, 8); } if (zde->comp_size == ZIP_UINT32_MAX) zde->comp_size = _zip_buffer_get_64(ef_buffer); if (!local) { if (zde->offset == ZIP_UINT32_MAX) zde->offset = _zip_buffer_get_64(ef_buffer); if (zde->disk_number == ZIP_UINT16_MAX) zde->disk_number = _zip_buffer_get_32(buffer); } if (!_zip_buffer_eof(ef_buffer)) { zip_error_set(error, ZIP_ER_INCONS, 0); _zip_buffer_free(ef_buffer); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } _zip_buffer_free(ef_buffer); } if (!_zip_buffer_ok(buffer)) { zip_error_set(error, ZIP_ER_INTERNAL, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (!from_buffer) { _zip_buffer_free(buffer); } if (zde->offset > ZIP_INT64_MAX) { zip_error_set(error, ZIP_ER_SEEK, EFBIG); return -1; } if (!_zip_dirent_process_winzip_aes(zde, error)) { return -1; } zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields); return (zip_int64_t)(size + variable_size); }"
732,5095----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/wasm.cc----Envoy::Extensions::Common::Wasm::Context::onRequestMetadata,"Http::FilterMetadataStatus Context::onRequestMetadata() { <S2SV_StartVul> if (!wasm_->onRequestMetadata_) { <S2SV_EndVul> return Http::FilterMetadataStatus::Continue; } if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) { return Http::FilterMetadataStatus::Continue; } return Http::FilterMetadataStatus::Continue; }","- if (!wasm_->onRequestMetadata_) {
+ if (!in_vm_context_created_ || !wasm_->onRequestMetadata_) {","Http::FilterMetadataStatus Context::onRequestMetadata() { if (!in_vm_context_created_ || !wasm_->onRequestMetadata_) { return Http::FilterMetadataStatus::Continue; } if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) { return Http::FilterMetadataStatus::Continue; } return Http::FilterMetadataStatus::Continue; }"
733,1839----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-9004--core.c----SYSCALL_DEFINE5,"SYSCALL_DEFINE5(perf_event_open, struct perf_event_attr __user *, attr_uptr, pid_t, pid, int, cpu, int, group_fd, unsigned long, flags) { struct perf_event *group_leader = NULL, *output_event = NULL; struct perf_event *event, *sibling; struct perf_event_attr attr; struct perf_event_context *ctx; struct file *event_file = NULL; struct fd group = {NULL, 0}; struct task_struct *task = NULL; struct pmu *pmu; int event_fd; int move_group = 0; int err; int f_flags = O_RDWR; if (flags & ~PERF_FLAG_ALL) return -EINVAL; err = perf_copy_attr(attr_uptr, &attr); if (err) return err; if (!attr.exclude_kernel) { if (perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN)) return -EACCES; } if (attr.freq) { if (attr.sample_freq > sysctl_perf_event_sample_rate) return -EINVAL; } else { if (attr.sample_period & (1ULL << 63)) return -EINVAL; } if ((flags & PERF_FLAG_PID_CGROUP) && (pid == -1 || cpu == -1)) return -EINVAL; if (flags & PERF_FLAG_FD_CLOEXEC) f_flags |= O_CLOEXEC; event_fd = get_unused_fd_flags(f_flags); if (event_fd < 0) return event_fd; if (group_fd != -1) { err = perf_fget_light(group_fd, &group); if (err) goto err_fd; group_leader = group.file->private_data; if (flags & PERF_FLAG_FD_OUTPUT) output_event = group_leader; if (flags & PERF_FLAG_FD_NO_GROUP) group_leader = NULL; } if (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) { task = find_lively_task_by_vpid(pid); if (IS_ERR(task)) { err = PTR_ERR(task); goto err_group_fd; } } if (task && group_leader && group_leader->attr.inherit != attr.inherit) { err = -EINVAL; goto err_task; } get_online_cpus(); event = perf_event_alloc(&attr, cpu, task, group_leader, NULL, NULL, NULL); if (IS_ERR(event)) { err = PTR_ERR(event); goto err_cpus; } if (flags & PERF_FLAG_PID_CGROUP) { err = perf_cgroup_connect(pid, event, &attr, group_leader); if (err) { __free_event(event); goto err_cpus; } } if (is_sampling_event(event)) { if (event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT) { err = -ENOTSUPP; goto err_alloc; } } account_event(event); pmu = event->pmu; if (group_leader && (is_software_event(event) != is_software_event(group_leader))) { if (is_software_event(event)) { pmu = group_leader->pmu; } else if (is_software_event(group_leader) && (group_leader->group_flags & PERF_GROUP_SOFTWARE)) { move_group = 1; } } ctx = find_get_context(pmu, task, event->cpu); if (IS_ERR(ctx)) { err = PTR_ERR(ctx); goto err_alloc; } if (task) { put_task_struct(task); task = NULL; } if (group_leader) { err = -EINVAL; if (group_leader->group_leader != group_leader) goto err_context; if (move_group) { <S2SV_StartVul> if (group_leader->ctx->type != ctx->type) <S2SV_EndVul> goto err_context; } else { if (group_leader->ctx != ctx) goto err_context; } if (attr.exclusive || attr.pinned) goto err_context; } if (output_event) { err = perf_event_set_output(event, output_event); if (err) goto err_context; } event_file = anon_inode_getfile(""[perf_event]"", &perf_fops, event, f_flags); if (IS_ERR(event_file)) { err = PTR_ERR(event_file); goto err_context; } if (move_group) { struct perf_event_context *gctx = group_leader->ctx; mutex_lock(&gctx->mutex); perf_remove_from_context(group_leader, false); perf_event__state_init(group_leader); list_for_each_entry(sibling, &group_leader->sibling_list, group_entry) { perf_remove_from_context(sibling, false); perf_event__state_init(sibling); put_ctx(gctx); } mutex_unlock(&gctx->mutex); put_ctx(gctx); } WARN_ON_ONCE(ctx->parent_ctx); mutex_lock(&ctx->mutex); if (move_group) { synchronize_rcu(); perf_install_in_context(ctx, group_leader, group_leader->cpu); get_ctx(ctx); list_for_each_entry(sibling, &group_leader->sibling_list, group_entry) { perf_install_in_context(ctx, sibling, sibling->cpu); get_ctx(ctx); } } perf_install_in_context(ctx, event, event->cpu); perf_unpin_context(ctx); mutex_unlock(&ctx->mutex); put_online_cpus(); event->owner = current; mutex_lock(&current->perf_event_mutex); list_add_tail(&event->owner_entry, &current->perf_event_list); mutex_unlock(&current->perf_event_mutex); perf_event__header_size(event); perf_event__id_header_size(event); fdput(group); fd_install(event_fd, event_file); return event_fd; err_context: perf_unpin_context(ctx); put_ctx(ctx); err_alloc: free_event(event); err_cpus: put_online_cpus(); err_task: if (task) put_task_struct(task); err_group_fd: fdput(group); err_fd: put_unused_fd(event_fd); return err; }","- if (group_leader->ctx->type != ctx->type)
+ if (group_leader->ctx->task != ctx->task)
+ goto err_context;
+ if (group_leader->cpu != event->cpu)","SYSCALL_DEFINE5(perf_event_open, struct perf_event_attr __user *, attr_uptr, pid_t, pid, int, cpu, int, group_fd, unsigned long, flags) { struct perf_event *group_leader = NULL, *output_event = NULL; struct perf_event *event, *sibling; struct perf_event_attr attr; struct perf_event_context *ctx; struct file *event_file = NULL; struct fd group = {NULL, 0}; struct task_struct *task = NULL; struct pmu *pmu; int event_fd; int move_group = 0; int err; int f_flags = O_RDWR; if (flags & ~PERF_FLAG_ALL) return -EINVAL; err = perf_copy_attr(attr_uptr, &attr); if (err) return err; if (!attr.exclude_kernel) { if (perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN)) return -EACCES; } if (attr.freq) { if (attr.sample_freq > sysctl_perf_event_sample_rate) return -EINVAL; } else { if (attr.sample_period & (1ULL << 63)) return -EINVAL; } if ((flags & PERF_FLAG_PID_CGROUP) && (pid == -1 || cpu == -1)) return -EINVAL; if (flags & PERF_FLAG_FD_CLOEXEC) f_flags |= O_CLOEXEC; event_fd = get_unused_fd_flags(f_flags); if (event_fd < 0) return event_fd; if (group_fd != -1) { err = perf_fget_light(group_fd, &group); if (err) goto err_fd; group_leader = group.file->private_data; if (flags & PERF_FLAG_FD_OUTPUT) output_event = group_leader; if (flags & PERF_FLAG_FD_NO_GROUP) group_leader = NULL; } if (pid != -1 && !(flags & PERF_FLAG_PID_CGROUP)) { task = find_lively_task_by_vpid(pid); if (IS_ERR(task)) { err = PTR_ERR(task); goto err_group_fd; } } if (task && group_leader && group_leader->attr.inherit != attr.inherit) { err = -EINVAL; goto err_task; } get_online_cpus(); event = perf_event_alloc(&attr, cpu, task, group_leader, NULL, NULL, NULL); if (IS_ERR(event)) { err = PTR_ERR(event); goto err_cpus; } if (flags & PERF_FLAG_PID_CGROUP) { err = perf_cgroup_connect(pid, event, &attr, group_leader); if (err) { __free_event(event); goto err_cpus; } } if (is_sampling_event(event)) { if (event->pmu->capabilities & PERF_PMU_CAP_NO_INTERRUPT) { err = -ENOTSUPP; goto err_alloc; } } account_event(event); pmu = event->pmu; if (group_leader && (is_software_event(event) != is_software_event(group_leader))) { if (is_software_event(event)) { pmu = group_leader->pmu; } else if (is_software_event(group_leader) && (group_leader->group_flags & PERF_GROUP_SOFTWARE)) { move_group = 1; } } ctx = find_get_context(pmu, task, event->cpu); if (IS_ERR(ctx)) { err = PTR_ERR(ctx); goto err_alloc; } if (task) { put_task_struct(task); task = NULL; } if (group_leader) { err = -EINVAL; if (group_leader->group_leader != group_leader) goto err_context; if (move_group) { if (group_leader->ctx->task != ctx->task) goto err_context; if (group_leader->cpu != event->cpu) goto err_context; } else { if (group_leader->ctx != ctx) goto err_context; } if (attr.exclusive || attr.pinned) goto err_context; } if (output_event) { err = perf_event_set_output(event, output_event); if (err) goto err_context; } event_file = anon_inode_getfile(""[perf_event]"", &perf_fops, event, f_flags); if (IS_ERR(event_file)) { err = PTR_ERR(event_file); goto err_context; } if (move_group) { struct perf_event_context *gctx = group_leader->ctx; mutex_lock(&gctx->mutex); perf_remove_from_context(group_leader, false); perf_event__state_init(group_leader); list_for_each_entry(sibling, &group_leader->sibling_list, group_entry) { perf_remove_from_context(sibling, false); perf_event__state_init(sibling); put_ctx(gctx); } mutex_unlock(&gctx->mutex); put_ctx(gctx); } WARN_ON_ONCE(ctx->parent_ctx); mutex_lock(&ctx->mutex); if (move_group) { synchronize_rcu(); perf_install_in_context(ctx, group_leader, group_leader->cpu); get_ctx(ctx); list_for_each_entry(sibling, &group_leader->sibling_list, group_entry) { perf_install_in_context(ctx, sibling, sibling->cpu); get_ctx(ctx); } } perf_install_in_context(ctx, event, event->cpu); perf_unpin_context(ctx); mutex_unlock(&ctx->mutex); put_online_cpus(); event->owner = current; mutex_lock(&current->perf_event_mutex); list_add_tail(&event->owner_entry, &current->perf_event_list); mutex_unlock(&current->perf_event_mutex); perf_event__header_size(event); perf_event__id_header_size(event); fdput(group); fd_install(event_fd, event_file); return event_fd; err_context: perf_unpin_context(ctx); put_ctx(ctx); err_alloc: free_event(event); err_cpus: put_online_cpus(); err_task: if (task) put_task_struct(task); err_group_fd: fdput(group); err_fd: put_unused_fd(event_fd); return err; }"
734,2754----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----perf_event_mmap_output,"static void perf_event_mmap_output(struct perf_event *event, struct perf_mmap_event *mmap_event) { struct perf_output_handle handle; struct perf_sample_data sample; int size = mmap_event->event_id.header.size; int ret; perf_event_header__init_id(&mmap_event->event_id.header, &sample, event); ret = perf_output_begin(&handle, event, <S2SV_StartVul> mmap_event->event_id.header.size, 0, 0); <S2SV_EndVul> if (ret) goto out; mmap_event->event_id.pid = perf_event_pid(event, current); mmap_event->event_id.tid = perf_event_tid(event, current); perf_output_put(&handle, mmap_event->event_id); __output_copy(&handle, mmap_event->file_name, mmap_event->file_size); perf_event__output_id_sample(event, &handle, &sample); perf_output_end(&handle); out: mmap_event->event_id.header.size = size; }","- mmap_event->event_id.header.size, 0, 0);
+ mmap_event->event_id.header.size, 0);","static void perf_event_mmap_output(struct perf_event *event, struct perf_mmap_event *mmap_event) { struct perf_output_handle handle; struct perf_sample_data sample; int size = mmap_event->event_id.header.size; int ret; perf_event_header__init_id(&mmap_event->event_id.header, &sample, event); ret = perf_output_begin(&handle, event, mmap_event->event_id.header.size, 0); if (ret) goto out; mmap_event->event_id.pid = perf_event_pid(event, current); mmap_event->event_id.tid = perf_event_tid(event, current); perf_output_put(&handle, mmap_event->event_id); __output_copy(&handle, mmap_event->file_name, mmap_event->file_size); perf_event__output_id_sample(event, &handle, &sample); perf_output_end(&handle); out: mmap_event->event_id.header.size = size; }"
735,6766----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/open_utils.c----WavpackVerifySingleBlock,"int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum) { WavpackHeader *wphdr = (WavpackHeader *) buffer; uint32_t checksum_passed = 0, bcount, meta_bc; unsigned char *dp, meta_id, c1, c2; if (strncmp (wphdr->ckID, ""wvpk"", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader)) return FALSE; bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8; dp = (unsigned char *)(wphdr + 1); while (bcount >= 2) { meta_id = *dp++; c1 = *dp++; meta_bc = c1 << 1; bcount -= 2; if (meta_id & ID_LARGE) { if (bcount < 2) return FALSE; c1 = *dp++; c2 = *dp++; meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17); bcount -= 2; } if (bcount < meta_bc) return FALSE; if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) { #ifdef BITSTREAM_SHORTS uint16_t *csptr = (uint16_t*) buffer; #else unsigned char *csptr = buffer; #endif int wcount = (int)(dp - 2 - buffer) >> 1; uint32_t csum = (uint32_t) -1; if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4) return FALSE; #ifdef BITSTREAM_SHORTS while (wcount--) csum = (csum * 3) + *csptr++; #else WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat); while (wcount--) { csum = (csum * 3) + csptr [0] + (csptr [1] << 8); csptr += 2; } WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat); #endif if (meta_bc == 4) { <S2SV_StartVul> if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff)) <S2SV_EndVul> return FALSE; } else { csum ^= csum >> 16; <S2SV_StartVul> if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff)) <S2SV_EndVul> return FALSE; } checksum_passed++; } bcount -= meta_bc; dp += meta_bc; } return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed); }","- if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))
- if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))
+ if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))
+ if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))","int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum) { WavpackHeader *wphdr = (WavpackHeader *) buffer; uint32_t checksum_passed = 0, bcount, meta_bc; unsigned char *dp, meta_id, c1, c2; if (strncmp (wphdr->ckID, ""wvpk"", 4) || wphdr->ckSize + 8 < sizeof (WavpackHeader)) return FALSE; bcount = wphdr->ckSize - sizeof (WavpackHeader) + 8; dp = (unsigned char *)(wphdr + 1); while (bcount >= 2) { meta_id = *dp++; c1 = *dp++; meta_bc = c1 << 1; bcount -= 2; if (meta_id & ID_LARGE) { if (bcount < 2) return FALSE; c1 = *dp++; c2 = *dp++; meta_bc += ((uint32_t) c1 << 9) + ((uint32_t) c2 << 17); bcount -= 2; } if (bcount < meta_bc) return FALSE; if (verify_checksum && (meta_id & ID_UNIQUE) == ID_BLOCK_CHECKSUM) { #ifdef BITSTREAM_SHORTS uint16_t *csptr = (uint16_t*) buffer; #else unsigned char *csptr = buffer; #endif int wcount = (int)(dp - 2 - buffer) >> 1; uint32_t csum = (uint32_t) -1; if ((meta_id & ID_ODD_SIZE) || meta_bc < 2 || meta_bc > 4) return FALSE; #ifdef BITSTREAM_SHORTS while (wcount--) csum = (csum * 3) + *csptr++; #else WavpackNativeToLittleEndian ((WavpackHeader *) buffer, WavpackHeaderFormat); while (wcount--) { csum = (csum * 3) + csptr [0] + (csptr [1] << 8); csptr += 2; } WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat); #endif if (meta_bc == 4) { if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff)) return FALSE; } else { csum ^= csum >> 16; if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff)) return FALSE; } checksum_passed++; } bcount -= meta_bc; dp += meta_bc; } return (bcount == 0) && (!verify_checksum || !(wphdr->flags & HAS_CHECKSUM) || checksum_passed); }"
736,2621--------F:/邵苗苗_data/Big-Vul/bigvul/vul/--harfbuzz-myanmar.c----myanmar_shape_syllable,"static HB_Bool myanmar_shape_syllable(HB_Bool openType, HB_ShaperItem *item, HB_Bool invalid) { #ifndef NO_OPENTYPE const int availableGlyphs = item->num_glyphs; #endif const HB_UChar16 *uc = item->string + item->item.pos; int vowel_e = -1; int kinzi = -1; int medial_ra = -1; int base = -1; int i; int len = 0; unsigned short reordered[32]; unsigned char properties[32]; enum { AboveForm = 0x01, PreForm = 0x02, PostForm = 0x04, BelowForm = 0x08 }; HB_Bool lastWasVirama = FALSE; int basePos = -1; memset(properties, 0, 32*sizeof(unsigned char)); assert(item->item.length < 32); #ifdef MYANMAR_DEBUG printf(""original:""); for (i = 0; i < (int)item->item.length; i++) { printf("" %d: %4x"", i, uc[i]); } #endif for (i = 0; i < (int)item->item.length; ++i) { HB_UChar16 chr = uc[i]; if (chr == Mymr_C_VOWEL_E) { vowel_e = i; continue; } if (i == 0 && chr == Mymr_C_NGA && i + 2 < (int)item->item.length && uc[i+1] == Mymr_C_VIRAMA) { int mc = getMyanmarCharClass(uc[i+2]); if ((mc & Mymr_CF_CONSONANT) == Mymr_CF_CONSONANT) { kinzi = i; continue; } } if (base >= 0 && chr == Mymr_C_VIRAMA && i + 1 < (int)item->item.length && uc[i+1] == Mymr_C_RA) { medial_ra = i; continue; } if (base < 0) base = i; } MMDEBUG(""\n base=%d, vowel_e=%d, kinzi=%d, medial_ra=%d"", base, vowel_e, kinzi, medial_ra); if (vowel_e >= 0) { reordered[0] = Mymr_C_VOWEL_E; len = 1; } if (medial_ra >= 0) { reordered[len] = Mymr_C_VIRAMA; reordered[len+1] = Mymr_C_RA; properties[len] = PreForm; properties[len+1] = PreForm; len += 2; } if (invalid) { reordered[len] = C_DOTTED_CIRCLE; ++len; } for (i = 0; i < (int)item->item.length; ++i) { hb_uint16 chr = uc[i]; MymrCharClass cc; if (i == vowel_e) continue; if (i == medial_ra || i == kinzi) { ++i; continue; } cc = getMyanmarCharClass(uc[i]); if (kinzi >= 0 && i > base && (cc & Mymr_CF_AFTER_KINZI)) { reordered[len] = Mymr_C_NGA; reordered[len+1] = Mymr_C_VIRAMA; properties[len-1] = AboveForm; properties[len] = AboveForm; <S2SV_StartVul> len += 2; <S2SV_EndVul> kinzi = -1; } if (lastWasVirama) { int prop = 0; switch(cc & Mymr_CF_POS_MASK) { case Mymr_CF_POS_BEFORE: prop = PreForm; break; case Mymr_CF_POS_BELOW: prop = BelowForm; break; case Mymr_CF_POS_ABOVE: prop = AboveForm; break; case Mymr_CF_POS_AFTER: prop = PostForm; break; default: break; } properties[len-1] = prop; properties[len] = prop; if(basePos >= 0 && basePos == len-2) properties[len-2] = prop; } lastWasVirama = (chr == Mymr_C_VIRAMA); if(i == base) basePos = len; if ((chr != Mymr_C_SIGN_ZWNJ && chr != Mymr_C_SIGN_ZWJ) || !len) { reordered[len] = chr; ++len; } } if (kinzi >= 0) { reordered[len] = Mymr_C_NGA; reordered[len+1] = Mymr_C_VIRAMA; properties[len] = AboveForm; properties[len+1] = AboveForm; len += 2; } if (!item->font->klass->convertStringToGlyphIndices(item->font, reordered, len, item->glyphs, &item->num_glyphs, item->item.bidiLevel % 2)) return FALSE; MMDEBUG(""after shaping: len=%d"", len); for (i = 0; i < len; i++) { item->attributes[i].mark = FALSE; item->attributes[i].clusterStart = FALSE; item->attributes[i].justification = 0; item->attributes[i].zeroWidth = FALSE; MMDEBUG("" %d: %4x property=%x"", i, reordered[i], properties[i]); } #ifndef NO_OPENTYPE if (openType) { hb_uint32 where[32]; for (i = 0; i < len; ++i) { where[i] = ~(PreSubstProperty | BelowSubstProperty | AboveSubstProperty | PostSubstProperty | CligProperty | PositioningProperties); if (properties[i] & PreForm) where[i] &= ~PreFormProperty; if (properties[i] & BelowForm) where[i] &= ~BelowFormProperty; if (properties[i] & AboveForm) where[i] &= ~AboveFormProperty; if (properties[i] & PostForm) where[i] &= ~PostFormProperty; } HB_OpenTypeShape(item, where); if (!HB_OpenTypePosition(item, availableGlyphs, FALSE)) return FALSE; } else #endif { MMDEBUG(""Not using openType""); HB_HeuristicPosition(item); } item->attributes[0].clusterStart = TRUE; return TRUE; }","- len += 2;
+ properties[len] = AboveForm;
+ len += 2;","static HB_Bool myanmar_shape_syllable(HB_Bool openType, HB_ShaperItem *item, HB_Bool invalid) { #ifndef NO_OPENTYPE const int availableGlyphs = item->num_glyphs; #endif const HB_UChar16 *uc = item->string + item->item.pos; int vowel_e = -1; int kinzi = -1; int medial_ra = -1; int base = -1; int i; int len = 0; unsigned short reordered[32]; unsigned char properties[32]; enum { AboveForm = 0x01, PreForm = 0x02, PostForm = 0x04, BelowForm = 0x08 }; HB_Bool lastWasVirama = FALSE; int basePos = -1; memset(properties, 0, 32*sizeof(unsigned char)); assert(item->item.length < 32); #ifdef MYANMAR_DEBUG printf(""original:""); for (i = 0; i < (int)item->item.length; i++) { printf("" %d: %4x"", i, uc[i]); } #endif for (i = 0; i < (int)item->item.length; ++i) { HB_UChar16 chr = uc[i]; if (chr == Mymr_C_VOWEL_E) { vowel_e = i; continue; } if (i == 0 && chr == Mymr_C_NGA && i + 2 < (int)item->item.length && uc[i+1] == Mymr_C_VIRAMA) { int mc = getMyanmarCharClass(uc[i+2]); if ((mc & Mymr_CF_CONSONANT) == Mymr_CF_CONSONANT) { kinzi = i; continue; } } if (base >= 0 && chr == Mymr_C_VIRAMA && i + 1 < (int)item->item.length && uc[i+1] == Mymr_C_RA) { medial_ra = i; continue; } if (base < 0) base = i; } MMDEBUG(""\n base=%d, vowel_e=%d, kinzi=%d, medial_ra=%d"", base, vowel_e, kinzi, medial_ra); if (vowel_e >= 0) { reordered[0] = Mymr_C_VOWEL_E; len = 1; } if (medial_ra >= 0) { reordered[len] = Mymr_C_VIRAMA; reordered[len+1] = Mymr_C_RA; properties[len] = PreForm; properties[len+1] = PreForm; len += 2; } if (invalid) { reordered[len] = C_DOTTED_CIRCLE; ++len; } for (i = 0; i < (int)item->item.length; ++i) { hb_uint16 chr = uc[i]; MymrCharClass cc; if (i == vowel_e) continue; if (i == medial_ra || i == kinzi) { ++i; continue; } cc = getMyanmarCharClass(uc[i]); if (kinzi >= 0 && i > base && (cc & Mymr_CF_AFTER_KINZI)) { reordered[len] = Mymr_C_NGA; reordered[len+1] = Mymr_C_VIRAMA; if (len > 0) properties[len-1] = AboveForm; properties[len] = AboveForm; len += 2; kinzi = -1; } if (lastWasVirama) { int prop = 0; switch(cc & Mymr_CF_POS_MASK) { case Mymr_CF_POS_BEFORE: prop = PreForm; break; case Mymr_CF_POS_BELOW: prop = BelowForm; break; case Mymr_CF_POS_ABOVE: prop = AboveForm; break; case Mymr_CF_POS_AFTER: prop = PostForm; break; default: break; } properties[len-1] = prop; properties[len] = prop; if(basePos >= 0 && basePos == len-2) properties[len-2] = prop; } lastWasVirama = (chr == Mymr_C_VIRAMA); if(i == base) basePos = len; if ((chr != Mymr_C_SIGN_ZWNJ && chr != Mymr_C_SIGN_ZWJ) || !len) { reordered[len] = chr; ++len; } } if (kinzi >= 0) { reordered[len] = Mymr_C_NGA; reordered[len+1] = Mymr_C_VIRAMA; properties[len] = AboveForm; properties[len+1] = AboveForm; len += 2; } if (!item->font->klass->convertStringToGlyphIndices(item->font, reordered, len, item->glyphs, &item->num_glyphs, item->item.bidiLevel % 2)) return FALSE; MMDEBUG(""after shaping: len=%d"", len); for (i = 0; i < len; i++) { item->attributes[i].mark = FALSE; item->attributes[i].clusterStart = FALSE; item->attributes[i].justification = 0; item->attributes[i].zeroWidth = FALSE; MMDEBUG("" %d: %4x property=%x"", i, reordered[i], properties[i]); } #ifndef NO_OPENTYPE if (openType) { hb_uint32 where[32]; for (i = 0; i < len; ++i) { where[i] = ~(PreSubstProperty | BelowSubstProperty | AboveSubstProperty | PostSubstProperty | CligProperty | PositioningProperties); if (properties[i] & PreForm) where[i] &= ~PreFormProperty; if (properties[i] & BelowForm) where[i] &= ~BelowFormProperty; if (properties[i] & AboveForm) where[i] &= ~AboveFormProperty; if (properties[i] & PostForm) where[i] &= ~PostFormProperty; } HB_OpenTypeShape(item, where); if (!HB_OpenTypePosition(item, availableGlyphs, FALSE)) return FALSE; } else #endif { MMDEBUG(""Not using openType""); HB_HeuristicPosition(item); } item->attributes[0].clusterStart = TRUE; return TRUE; }"
737,1536----CWE-404----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-8071--hid-cp2112.c----cp2112_gpio_direction_output,"static int cp2112_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; <S2SV_StartVul> unsigned long flags; <S2SV_EndVul> int ret; <S2SV_StartVul> spin_lock_irqsave(&dev->lock, flags); <S2SV_EndVul> ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_CONFIG_LENGTH) { hid_err(hdev, ""error requesting GPIO config: %d\n"", ret); goto fail; } buf[1] |= 1 << offset; buf[2] = gpio_push_pull; ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_SET_REPORT); if (ret < 0) { hid_err(hdev, ""error setting GPIO config: %d\n"", ret); goto fail; } <S2SV_StartVul> spin_unlock_irqrestore(&dev->lock, flags); <S2SV_EndVul> cp2112_gpio_set(chip, offset, value); return 0; fail: <S2SV_StartVul> spin_unlock_irqrestore(&dev->lock, flags); <S2SV_EndVul> return ret < 0 ? ret : -EIO; }","- unsigned long flags;
- spin_lock_irqsave(&dev->lock, flags);
- spin_unlock_irqrestore(&dev->lock, flags);
- spin_unlock_irqrestore(&dev->lock, flags);
+ mutex_lock(&dev->lock);
+ mutex_unlock(&dev->lock);
+ mutex_unlock(&dev->lock);","static int cp2112_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; int ret; mutex_lock(&dev->lock); ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_CONFIG_LENGTH) { hid_err(hdev, ""error requesting GPIO config: %d\n"", ret); goto fail; } buf[1] |= 1 << offset; buf[2] = gpio_push_pull; ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_SET_REPORT); if (ret < 0) { hid_err(hdev, ""error setting GPIO config: %d\n"", ret); goto fail; } mutex_unlock(&dev->lock); cp2112_gpio_set(chip, offset, value); return 0; fail: mutex_unlock(&dev->lock); return ret < 0 ? ret : -EIO; }"
738,5957----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mysql_plugin.c----usage,"static void usage(void) { PRINT_VERSION; <S2SV_StartVul> puts(""Copyright (c) 2011, Oracle and/or its affiliates. "" <S2SV_EndVul> ""All rights reserved.\n""); puts(""Enable or disable plugins.""); printf(""\nUsage: %s [options] <plugin> ENABLE|DISABLE\n\nOptions:\n"", my_progname); my_print_help(my_long_options); puts(""\n""); }","- puts(""Copyright (c) 2011, Oracle and/or its affiliates. ""
+ puts(""Copyright (c) 2011, 2015, Oracle and/or its affiliates. ""","static void usage(void) { PRINT_VERSION; puts(""Copyright (c) 2011, 2015, Oracle and/or its affiliates. "" ""All rights reserved.\n""); puts(""Enable or disable plugins.""); printf(""\nUsage: %s [options] <plugin> ENABLE|DISABLE\n\nOptions:\n"", my_progname); my_print_help(my_long_options); puts(""\n""); }"
739,252----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-3552--ipv4.c----dccp_v4_connect,"int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len) { const struct sockaddr_in *usin = (struct sockaddr_in *)uaddr; struct inet_sock *inet = inet_sk(sk); struct dccp_sock *dp = dccp_sk(sk); __be16 orig_sport, orig_dport; __be32 daddr, nexthop; struct flowi4 fl4; struct rtable *rt; int err; dp->dccps_role = DCCP_ROLE_CLIENT; if (addr_len < sizeof(struct sockaddr_in)) return -EINVAL; if (usin->sin_family != AF_INET) return -EAFNOSUPPORT; nexthop = daddr = usin->sin_addr.s_addr; <S2SV_StartVul> if (inet->opt != NULL && inet->opt->srr) { <S2SV_EndVul> if (daddr == 0) return -EINVAL; <S2SV_StartVul> nexthop = inet->opt->faddr; <S2SV_EndVul> } orig_sport = inet->inet_sport; orig_dport = usin->sin_port; rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if, IPPROTO_DCCP, orig_sport, orig_dport, sk, true); if (IS_ERR(rt)) return PTR_ERR(rt); if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) { ip_rt_put(rt); return -ENETUNREACH; } <S2SV_StartVul> if (inet->opt == NULL || !inet->opt->srr) <S2SV_EndVul> daddr = rt->rt_dst; if (inet->inet_saddr == 0) inet->inet_saddr = rt->rt_src; inet->inet_rcv_saddr = inet->inet_saddr; inet->inet_dport = usin->sin_port; inet->inet_daddr = daddr; inet_csk(sk)->icsk_ext_hdr_len = 0; <S2SV_StartVul> if (inet->opt != NULL) <S2SV_EndVul> <S2SV_StartVul> inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen; <S2SV_EndVul> dccp_set_state(sk, DCCP_REQUESTING); err = inet_hash_connect(&dccp_death_row, sk); if (err != 0) goto failure; rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport, inet->inet_sport, inet->inet_dport, sk); if (IS_ERR(rt)) { rt = NULL; goto failure; } sk_setup_caps(sk, &rt->dst); dp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr, inet->inet_daddr, inet->inet_sport, inet->inet_dport); inet->inet_id = dp->dccps_iss ^ jiffies; err = dccp_connect(sk); rt = NULL; if (err != 0) goto failure; out: return err; failure: dccp_set_state(sk, DCCP_CLOSED); ip_rt_put(rt); sk->sk_route_caps = 0; inet->inet_dport = 0; goto out; }","- if (inet->opt != NULL && inet->opt->srr) {
- nexthop = inet->opt->faddr;
- if (inet->opt == NULL || !inet->opt->srr)
- if (inet->opt != NULL)
- inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;
+ struct ip_options_rcu *inet_opt;
+ inet_opt = rcu_dereference_protected(inet->inet_opt,
+ sock_owned_by_user(sk));
+ if (inet_opt != NULL && inet_opt->opt.srr) {
+ nexthop = inet_opt->opt.faddr;
+ if (inet_opt == NULL || !inet_opt->opt.srr)
+ if (inet_opt)
+ inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;","int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len) { const struct sockaddr_in *usin = (struct sockaddr_in *)uaddr; struct inet_sock *inet = inet_sk(sk); struct dccp_sock *dp = dccp_sk(sk); __be16 orig_sport, orig_dport; __be32 daddr, nexthop; struct flowi4 fl4; struct rtable *rt; int err; struct ip_options_rcu *inet_opt; dp->dccps_role = DCCP_ROLE_CLIENT; if (addr_len < sizeof(struct sockaddr_in)) return -EINVAL; if (usin->sin_family != AF_INET) return -EAFNOSUPPORT; nexthop = daddr = usin->sin_addr.s_addr; inet_opt = rcu_dereference_protected(inet->inet_opt, sock_owned_by_user(sk)); if (inet_opt != NULL && inet_opt->opt.srr) { if (daddr == 0) return -EINVAL; nexthop = inet_opt->opt.faddr; } orig_sport = inet->inet_sport; orig_dport = usin->sin_port; rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if, IPPROTO_DCCP, orig_sport, orig_dport, sk, true); if (IS_ERR(rt)) return PTR_ERR(rt); if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) { ip_rt_put(rt); return -ENETUNREACH; } if (inet_opt == NULL || !inet_opt->opt.srr) daddr = rt->rt_dst; if (inet->inet_saddr == 0) inet->inet_saddr = rt->rt_src; inet->inet_rcv_saddr = inet->inet_saddr; inet->inet_dport = usin->sin_port; inet->inet_daddr = daddr; inet_csk(sk)->icsk_ext_hdr_len = 0; if (inet_opt) inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen; dccp_set_state(sk, DCCP_REQUESTING); err = inet_hash_connect(&dccp_death_row, sk); if (err != 0) goto failure; rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport, inet->inet_sport, inet->inet_dport, sk); if (IS_ERR(rt)) { rt = NULL; goto failure; } sk_setup_caps(sk, &rt->dst); dp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr, inet->inet_daddr, inet->inet_sport, inet->inet_dport); inet->inet_id = dp->dccps_iss ^ jiffies; err = dccp_connect(sk); rt = NULL; if (err != 0) goto failure; out: return err; failure: dccp_set_state(sk, DCCP_CLOSED); ip_rt_put(rt); sk->sk_route_caps = 0; inet->inet_dport = 0; goto out; }"
740,608----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-7826--trace_syscalls.c----ftrace_syscall_exit,"static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret) { struct trace_array *tr = data; struct ftrace_event_file *ftrace_file; struct syscall_trace_exit *entry; struct syscall_metadata *sys_data; struct ring_buffer_event *event; struct ring_buffer *buffer; unsigned long irq_flags; int pc; int syscall_nr; syscall_nr = trace_get_syscall_nr(current, regs); <S2SV_StartVul> if (syscall_nr < 0) <S2SV_EndVul> return; ftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]); if (!ftrace_file) return; if (ftrace_trigger_soft_disabled(ftrace_file)) return; sys_data = syscall_nr_to_meta(syscall_nr); if (!sys_data) return; local_save_flags(irq_flags); pc = preempt_count(); buffer = tr->trace_buffer.buffer; event = trace_buffer_lock_reserve(buffer, sys_data->exit_event->event.type, sizeof(*entry), irq_flags, pc); if (!event) return; entry = ring_buffer_event_data(event); entry->nr = syscall_nr; entry->ret = syscall_get_return_value(current, regs); event_trigger_unlock_commit(ftrace_file, buffer, event, entry, irq_flags, pc); }","- if (syscall_nr < 0)
+ if (syscall_nr < 0 || syscall_nr >= NR_syscalls)","static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret) { struct trace_array *tr = data; struct ftrace_event_file *ftrace_file; struct syscall_trace_exit *entry; struct syscall_metadata *sys_data; struct ring_buffer_event *event; struct ring_buffer *buffer; unsigned long irq_flags; int pc; int syscall_nr; syscall_nr = trace_get_syscall_nr(current, regs); if (syscall_nr < 0 || syscall_nr >= NR_syscalls) return; ftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]); if (!ftrace_file) return; if (ftrace_trigger_soft_disabled(ftrace_file)) return; sys_data = syscall_nr_to_meta(syscall_nr); if (!sys_data) return; local_save_flags(irq_flags); pc = preempt_count(); buffer = tr->trace_buffer.buffer; event = trace_buffer_lock_reserve(buffer, sys_data->exit_event->event.type, sizeof(*entry), irq_flags, pc); if (!event) return; entry = ring_buffer_event_data(event); entry->nr = syscall_nr; entry->ret = syscall_get_return_value(current, regs); event_trigger_unlock_commit(ftrace_file, buffer, event, entry, irq_flags, pc); }"
741,523----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-1797--x86.c----kvm_set_guest_paused,"static int kvm_set_guest_paused(struct kvm_vcpu *vcpu) { <S2SV_StartVul> if (!vcpu->arch.time_page) <S2SV_EndVul> return -EINVAL; vcpu->arch.pvclock_set_guest_stopped_request = true; kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu); return 0; }","- if (!vcpu->arch.time_page)
+ if (!vcpu->arch.pv_time_enabled)","static int kvm_set_guest_paused(struct kvm_vcpu *vcpu) { if (!vcpu->arch.pv_time_enabled) return -EINVAL; vcpu->arch.pvclock_set_guest_stopped_request = true; kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu); return 0; }"
742,5641----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/crypto_user_base.c----crypto_report,"static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh, struct nlattr **attrs) { struct net *net = sock_net(in_skb->sk); struct crypto_user_alg *p = nlmsg_data(in_nlh); struct crypto_alg *alg; struct sk_buff *skb; struct crypto_dump_info info; int err; if (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name)) return -EINVAL; alg = crypto_alg_match(p, 0); if (!alg) return -ENOENT; err = -ENOMEM; skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL); if (!skb) goto drop_alg; info.in_skb = in_skb; info.out_skb = skb; info.nlmsg_seq = in_nlh->nlmsg_seq; info.nlmsg_flags = 0; err = crypto_report_alg(alg, &info); drop_alg: crypto_mod_put(alg); <S2SV_StartVul> if (err) <S2SV_EndVul> return err; return nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid); }","- if (err)
+ if (err) {
+ kfree_skb(skb);
+ }","static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh, struct nlattr **attrs) { struct net *net = sock_net(in_skb->sk); struct crypto_user_alg *p = nlmsg_data(in_nlh); struct crypto_alg *alg; struct sk_buff *skb; struct crypto_dump_info info; int err; if (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name)) return -EINVAL; alg = crypto_alg_match(p, 0); if (!alg) return -ENOENT; err = -ENOMEM; skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL); if (!skb) goto drop_alg; info.in_skb = in_skb; info.out_skb = skb; info.nlmsg_seq = in_nlh->nlmsg_seq; info.nlmsg_flags = 0; err = crypto_report_alg(alg, &info); drop_alg: crypto_mod_put(alg); if (err) { kfree_skb(skb); return err; } return nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid); }"
743,5267----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dhcps.c----dhcps_receive_udp_packet_handler,"static void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb, struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port) { int16_t total_length_of_packet_buffer; struct pbuf *merged_packet_buffer = NULL; dhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload; if (udp_packet_buffer == NULL) { printf(""\n\r Error!!!! System doesn't allocate any buffer \n\r""); return; } if (sender_port == DHCP_CLIENT_PORT) { total_length_of_packet_buffer = udp_packet_buffer->tot_len; if (udp_packet_buffer->next != NULL) { merged_packet_buffer = pbuf_coalesce(udp_packet_buffer, PBUF_TRANSPORT); if (merged_packet_buffer->tot_len != total_length_of_packet_buffer) { pbuf_free(udp_packet_buffer); return; } } switch (dhcps_check_msg_and_handle_options(udp_packet_buffer)) { case DHCP_SERVER_STATE_OFFER: #if (debug_dhcps) printf(""%s DHCP_SERVER_STATE_OFFER\n"",__func__); #endif dhcps_send_offer(udp_packet_buffer); break; case DHCP_SERVER_STATE_ACK: #if (debug_dhcps) printf(""%s DHCP_SERVER_STATE_ACK\n"",__func__); #endif dhcps_send_ack(udp_packet_buffer); #if (!IS_USE_FIXED_IP) <S2SV_StartVul> mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); <S2SV_EndVul> #ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO save_client_addr(&dhcps_allocated_client_address, client_addr); memset(&client_request_ip, 0, sizeof(client_request_ip)); memset(&client_addr, 0, sizeof(client_addr)); memset(&dhcps_allocated_client_address, 0, sizeof(dhcps_allocated_client_address)); #if (debug_dhcps) dump_client_table(); #endif #endif #endif dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE; break; case DHCP_SERVER_STATE_NAK: #if (debug_dhcps) printf(""%s DHCP_SERVER_STATE_NAK\n"",__func__); #endif dhcps_send_nak(udp_packet_buffer); dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE; break; case DHCP_OPTION_CODE_END: #if (debug_dhcps) printf(""%s DHCP_OPTION_CODE_END\n"",__func__); #endif break; } } udp_disconnect(udp_pcb); if (merged_packet_buffer != NULL) pbuf_free(merged_packet_buffer); else pbuf_free(udp_packet_buffer); }","- mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address));
+ #if LWIP_VERSION_MAJOR >= 2
+ if(netif_get_idx(ip_current_input_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)
+ #else
+ if(netif_get_idx(ip_current_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)
+ #endif
+ {
+ pbuf_free(udp_packet_buffer);
+ return;
+ }
+ udp_packet_buffer = merged_packet_buffer;
+ #if LWIP_VERSION_MAJOR >= 2
+ mark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));
+ #else
+ mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address));
+ #endif","static void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb, struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port) { int16_t total_length_of_packet_buffer; struct pbuf *merged_packet_buffer = NULL; dhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload; if (udp_packet_buffer == NULL) { printf(""\n\r Error!!!! System doesn't allocate any buffer \n\r""); return; } if (sender_port == DHCP_CLIENT_PORT) { #if LWIP_VERSION_MAJOR >= 2 if(netif_get_idx(ip_current_input_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP) #else if(netif_get_idx(ip_current_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP) #endif { pbuf_free(udp_packet_buffer); return; } total_length_of_packet_buffer = udp_packet_buffer->tot_len; if (udp_packet_buffer->next != NULL) { merged_packet_buffer = pbuf_coalesce(udp_packet_buffer, PBUF_TRANSPORT); if (merged_packet_buffer->tot_len != total_length_of_packet_buffer) { pbuf_free(udp_packet_buffer); return; } udp_packet_buffer = merged_packet_buffer; } switch (dhcps_check_msg_and_handle_options(udp_packet_buffer)) { case DHCP_SERVER_STATE_OFFER: #if (debug_dhcps) printf(""%s DHCP_SERVER_STATE_OFFER\n"",__func__); #endif dhcps_send_offer(udp_packet_buffer); break; case DHCP_SERVER_STATE_ACK: #if (debug_dhcps) printf(""%s DHCP_SERVER_STATE_ACK\n"",__func__); #endif dhcps_send_ack(udp_packet_buffer); #if (!IS_USE_FIXED_IP) #if LWIP_VERSION_MAJOR >= 2 mark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address))); #else mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); #endif #ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO save_client_addr(&dhcps_allocated_client_address, client_addr); memset(&client_request_ip, 0, sizeof(client_request_ip)); memset(&client_addr, 0, sizeof(client_addr)); memset(&dhcps_allocated_client_address, 0, sizeof(dhcps_allocated_client_address)); #if (debug_dhcps) dump_client_table(); #endif #endif #endif dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE; break; case DHCP_SERVER_STATE_NAK: #if (debug_dhcps) printf(""%s DHCP_SERVER_STATE_NAK\n"",__func__); #endif dhcps_send_nak(udp_packet_buffer); dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE; break; case DHCP_OPTION_CODE_END: #if (debug_dhcps) printf(""%s DHCP_OPTION_CODE_END\n"",__func__); #endif break; } } udp_disconnect(udp_pcb); if (merged_packet_buffer != NULL) pbuf_free(merged_packet_buffer); else pbuf_free(udp_packet_buffer); }"
744,2958----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/consolefs.c----_consolefs_write,"static ssize_t _consolefs_write(oe_fd_t* file_, const void* buf, size_t count) { ssize_t ret = -1; file_t* file = _cast_file(file_); <S2SV_StartVul> if (!file) <S2SV_EndVul> OE_RAISE_ERRNO(OE_EINVAL); if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK) OE_RAISE_ERRNO(OE_EINVAL); done: return ret; }","- if (!file)
+ if (!file || count > OE_SSIZE_MAX)
+ if (ret > (ssize_t)count)
+ {
+ ret = -1;
+ OE_RAISE_ERRNO(OE_EINVAL);
+ }","static ssize_t _consolefs_write(oe_fd_t* file_, const void* buf, size_t count) { ssize_t ret = -1; file_t* file = _cast_file(file_); if (!file || count > OE_SSIZE_MAX) OE_RAISE_ERRNO(OE_EINVAL); if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK) OE_RAISE_ERRNO(OE_EINVAL); if (ret > (ssize_t)count) { ret = -1; OE_RAISE_ERRNO(OE_EINVAL); } done: return ret; }"
745,422----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4483--msg.c----do_msgsnd,"long do_msgsnd(int msqid, long mtype, void __user *mtext, size_t msgsz, int msgflg) { struct msg_queue *msq; struct msg_msg *msg; int err; struct ipc_namespace *ns; ns = current->nsproxy->ipc_ns; if (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0) return -EINVAL; if (mtype < 1) return -EINVAL; msg = load_msg(mtext, msgsz); if (IS_ERR(msg)) return PTR_ERR(msg); msg->m_type = mtype; msg->m_ts = msgsz; msq = msg_lock_check(ns, msqid); if (IS_ERR(msq)) { err = PTR_ERR(msq); goto out_free; } for (;;) { struct msg_sender s; err = -EACCES; if (ipcperms(ns, &msq->q_perm, S_IWUGO)) goto out_unlock_free; err = security_msg_queue_msgsnd(msq, msg, msgflg); if (err) goto out_unlock_free; if (msgsz + msq->q_cbytes <= msq->q_qbytes && 1 + msq->q_qnum <= msq->q_qbytes) { break; } if (msgflg & IPC_NOWAIT) { err = -EAGAIN; goto out_unlock_free; } ss_add(msq, &s); <S2SV_StartVul> ipc_rcu_getref(msq); <S2SV_EndVul> msg_unlock(msq); schedule(); ipc_lock_by_ptr(&msq->q_perm); ipc_rcu_putref(msq); if (msq->q_perm.deleted) { err = -EIDRM; goto out_unlock_free; } ss_del(&s); if (signal_pending(current)) { err = -ERESTARTNOHAND; goto out_unlock_free; } } msq->q_lspid = task_tgid_vnr(current); msq->q_stime = get_seconds(); if (!pipelined_send(msq, msg)) { list_add_tail(&msg->m_list, &msq->q_messages); msq->q_cbytes += msgsz; msq->q_qnum++; atomic_add(msgsz, &ns->msg_bytes); atomic_inc(&ns->msg_hdrs); } err = 0; msg = NULL; out_unlock_free: msg_unlock(msq); out_free: if (msg != NULL) free_msg(msg); return err; }","- ipc_rcu_getref(msq);
+ if (!ipc_rcu_getref(msq)) {
+ err = -EIDRM;
+ goto out_unlock_free;
+ }","long do_msgsnd(int msqid, long mtype, void __user *mtext, size_t msgsz, int msgflg) { struct msg_queue *msq; struct msg_msg *msg; int err; struct ipc_namespace *ns; ns = current->nsproxy->ipc_ns; if (msgsz > ns->msg_ctlmax || (long) msgsz < 0 || msqid < 0) return -EINVAL; if (mtype < 1) return -EINVAL; msg = load_msg(mtext, msgsz); if (IS_ERR(msg)) return PTR_ERR(msg); msg->m_type = mtype; msg->m_ts = msgsz; msq = msg_lock_check(ns, msqid); if (IS_ERR(msq)) { err = PTR_ERR(msq); goto out_free; } for (;;) { struct msg_sender s; err = -EACCES; if (ipcperms(ns, &msq->q_perm, S_IWUGO)) goto out_unlock_free; err = security_msg_queue_msgsnd(msq, msg, msgflg); if (err) goto out_unlock_free; if (msgsz + msq->q_cbytes <= msq->q_qbytes && 1 + msq->q_qnum <= msq->q_qbytes) { break; } if (msgflg & IPC_NOWAIT) { err = -EAGAIN; goto out_unlock_free; } ss_add(msq, &s); if (!ipc_rcu_getref(msq)) { err = -EIDRM; goto out_unlock_free; } msg_unlock(msq); schedule(); ipc_lock_by_ptr(&msq->q_perm); ipc_rcu_putref(msq); if (msq->q_perm.deleted) { err = -EIDRM; goto out_unlock_free; } ss_del(&s); if (signal_pending(current)) { err = -ERESTARTNOHAND; goto out_unlock_free; } } msq->q_lspid = task_tgid_vnr(current); msq->q_stime = get_seconds(); if (!pipelined_send(msq, msg)) { list_add_tail(&msg->m_list, &msq->q_messages); msq->q_cbytes += msgsz; msq->q_qnum++; atomic_add(msgsz, &ns->msg_bytes); atomic_inc(&ns->msg_hdrs); } err = 0; msg = NULL; out_unlock_free: msg_unlock(msq); out_free: if (msg != NULL) free_msg(msg); return err; }"
746,3218----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jscompile.c----cstm,"static void cstm(JF, js_Ast *stm) { js_Ast *target; int loop, cont, then, end; emitline(J, F, stm); switch (stm->type) { case AST_FUNDEC: break; case STM_BLOCK: cstmlist(J, F, stm->a); break; case STM_EMPTY: if (F->script) { emitline(J, F, stm); emit(J, F, OP_POP); emit(J, F, OP_UNDEF); } break; case STM_VAR: cvarinit(J, F, stm->a); break; case STM_IF: if (stm->c) { cexp(J, F, stm->a); emitline(J, F, stm); then = emitjump(J, F, OP_JTRUE); cstm(J, F, stm->c); emitline(J, F, stm); end = emitjump(J, F, OP_JUMP); label(J, F, then); cstm(J, F, stm->b); label(J, F, end); } else { cexp(J, F, stm->a); emitline(J, F, stm); end = emitjump(J, F, OP_JFALSE); cstm(J, F, stm->b); label(J, F, end); } break; case STM_DO: loop = here(J, F); cstm(J, F, stm->a); cont = here(J, F); cexp(J, F, stm->b); emitline(J, F, stm); emitjumpto(J, F, OP_JTRUE, loop); <S2SV_StartVul> labeljumps(J, F, stm->jumps, here(J,F), cont); <S2SV_EndVul> break; case STM_WHILE: loop = here(J, F); cexp(J, F, stm->a); emitline(J, F, stm); end = emitjump(J, F, OP_JFALSE); cstm(J, F, stm->b); emitline(J, F, stm); emitjumpto(J, F, OP_JUMP, loop); label(J, F, end); <S2SV_StartVul> labeljumps(J, F, stm->jumps, here(J,F), loop); <S2SV_EndVul> break; case STM_FOR: case STM_FOR_VAR: if (stm->type == STM_FOR_VAR) { cvarinit(J, F, stm->a); } else { if (stm->a) { cexp(J, F, stm->a); emit(J, F, OP_POP); } } loop = here(J, F); if (stm->b) { cexp(J, F, stm->b); emitline(J, F, stm); end = emitjump(J, F, OP_JFALSE); } else { end = 0; } cstm(J, F, stm->d); cont = here(J, F); if (stm->c) { cexp(J, F, stm->c); emit(J, F, OP_POP); } emitline(J, F, stm); emitjumpto(J, F, OP_JUMP, loop); if (end) label(J, F, end); <S2SV_StartVul> labeljumps(J, F, stm->jumps, here(J,F), cont); <S2SV_EndVul> break; case STM_FOR_IN: case STM_FOR_IN_VAR: cexp(J, F, stm->b); emitline(J, F, stm); emit(J, F, OP_ITERATOR); loop = here(J, F); { emitline(J, F, stm); emit(J, F, OP_NEXTITER); end = emitjump(J, F, OP_JFALSE); cassignforin(J, F, stm); if (F->script) { emit(J, F, OP_ROT2); cstm(J, F, stm->c); emit(J, F, OP_ROT2); } else { cstm(J, F, stm->c); } emitline(J, F, stm); emitjumpto(J, F, OP_JUMP, loop); } label(J, F, end); <S2SV_StartVul> labeljumps(J, F, stm->jumps, here(J,F), loop); <S2SV_EndVul> break; case STM_SWITCH: cswitch(J, F, stm->a, stm->b); <S2SV_StartVul> labeljumps(J, F, stm->jumps, here(J,F), 0); <S2SV_EndVul> break; case STM_LABEL: cstm(J, F, stm->b); while (stm->type == STM_LABEL) stm = stm->b; if (!isloop(stm->type) && stm->type != STM_SWITCH) <S2SV_StartVul> labeljumps(J, F, stm->jumps, here(J,F), 0); <S2SV_EndVul> break; case STM_BREAK: if (stm->a) { checkfutureword(J, F, stm->a); target = breaktarget(J, F, stm->parent, stm->a->string); if (!target) jsC_error(J, stm, ""break label '%s' not found"", stm->a->string); } else { target = breaktarget(J, F, stm->parent, NULL); if (!target) jsC_error(J, stm, ""unlabelled break must be inside loop or switch""); } cexit(J, F, STM_BREAK, stm, target); emitline(J, F, stm); addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP)); break; case STM_CONTINUE: if (stm->a) { checkfutureword(J, F, stm->a); target = continuetarget(J, F, stm->parent, stm->a->string); if (!target) jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string); } else { target = continuetarget(J, F, stm->parent, NULL); if (!target) jsC_error(J, stm, ""continue must be inside loop""); } cexit(J, F, STM_CONTINUE, stm, target); emitline(J, F, stm); addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP)); break; case STM_RETURN: if (stm->a) cexp(J, F, stm->a); else emit(J, F, OP_UNDEF); target = returntarget(J, F, stm->parent); if (!target) jsC_error(J, stm, ""return not in function""); cexit(J, F, STM_RETURN, stm, target); emitline(J, F, stm); emit(J, F, OP_RETURN); break; case STM_THROW: cexp(J, F, stm->a); emitline(J, F, stm); emit(J, F, OP_THROW); break; case STM_WITH: F->lightweight = 0; if (F->strict) jsC_error(J, stm->a, ""'with' statements are not allowed in strict mode""); cexp(J, F, stm->a); emitline(J, F, stm); emit(J, F, OP_WITH); cstm(J, F, stm->b); emitline(J, F, stm); emit(J, F, OP_ENDWITH); break; case STM_TRY: emitline(J, F, stm); if (stm->b && stm->c) { F->lightweight = 0; if (stm->d) ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d); else ctrycatch(J, F, stm->a, stm->b, stm->c); } else { ctryfinally(J, F, stm->a, stm->d); } break; case STM_DEBUGGER: emitline(J, F, stm); emit(J, F, OP_DEBUGGER); break; default: if (F->script) { emitline(J, F, stm); emit(J, F, OP_POP); cexp(J, F, stm); } else { cexp(J, F, stm); emitline(J, F, stm); emit(J, F, OP_POP); } break; } }","- labeljumps(J, F, stm->jumps, here(J,F), cont);
- labeljumps(J, F, stm->jumps, here(J,F), loop);
- labeljumps(J, F, stm->jumps, here(J,F), cont);
- labeljumps(J, F, stm->jumps, here(J,F), loop);
- labeljumps(J, F, stm->jumps, here(J,F), 0);
- labeljumps(J, F, stm->jumps, here(J,F), 0);
+ labeljumps(J, F, stm, here(J,F), cont);
+ labeljumps(J, F, stm, here(J,F), loop);
+ labeljumps(J, F, stm, here(J,F), cont);
+ labeljumps(J, F, stm, here(J,F), loop);
+ labeljumps(J, F, stm, here(J,F), 0);
+ labeljumps(J, F, stm, here(J,F), 0);","static void cstm(JF, js_Ast *stm) { js_Ast *target; int loop, cont, then, end; emitline(J, F, stm); switch (stm->type) { case AST_FUNDEC: break; case STM_BLOCK: cstmlist(J, F, stm->a); break; case STM_EMPTY: if (F->script) { emitline(J, F, stm); emit(J, F, OP_POP); emit(J, F, OP_UNDEF); } break; case STM_VAR: cvarinit(J, F, stm->a); break; case STM_IF: if (stm->c) { cexp(J, F, stm->a); emitline(J, F, stm); then = emitjump(J, F, OP_JTRUE); cstm(J, F, stm->c); emitline(J, F, stm); end = emitjump(J, F, OP_JUMP); label(J, F, then); cstm(J, F, stm->b); label(J, F, end); } else { cexp(J, F, stm->a); emitline(J, F, stm); end = emitjump(J, F, OP_JFALSE); cstm(J, F, stm->b); label(J, F, end); } break; case STM_DO: loop = here(J, F); cstm(J, F, stm->a); cont = here(J, F); cexp(J, F, stm->b); emitline(J, F, stm); emitjumpto(J, F, OP_JTRUE, loop); labeljumps(J, F, stm, here(J,F), cont); break; case STM_WHILE: loop = here(J, F); cexp(J, F, stm->a); emitline(J, F, stm); end = emitjump(J, F, OP_JFALSE); cstm(J, F, stm->b); emitline(J, F, stm); emitjumpto(J, F, OP_JUMP, loop); label(J, F, end); labeljumps(J, F, stm, here(J,F), loop); break; case STM_FOR: case STM_FOR_VAR: if (stm->type == STM_FOR_VAR) { cvarinit(J, F, stm->a); } else { if (stm->a) { cexp(J, F, stm->a); emit(J, F, OP_POP); } } loop = here(J, F); if (stm->b) { cexp(J, F, stm->b); emitline(J, F, stm); end = emitjump(J, F, OP_JFALSE); } else { end = 0; } cstm(J, F, stm->d); cont = here(J, F); if (stm->c) { cexp(J, F, stm->c); emit(J, F, OP_POP); } emitline(J, F, stm); emitjumpto(J, F, OP_JUMP, loop); if (end) label(J, F, end); labeljumps(J, F, stm, here(J,F), cont); break; case STM_FOR_IN: case STM_FOR_IN_VAR: cexp(J, F, stm->b); emitline(J, F, stm); emit(J, F, OP_ITERATOR); loop = here(J, F); { emitline(J, F, stm); emit(J, F, OP_NEXTITER); end = emitjump(J, F, OP_JFALSE); cassignforin(J, F, stm); if (F->script) { emit(J, F, OP_ROT2); cstm(J, F, stm->c); emit(J, F, OP_ROT2); } else { cstm(J, F, stm->c); } emitline(J, F, stm); emitjumpto(J, F, OP_JUMP, loop); } label(J, F, end); labeljumps(J, F, stm, here(J,F), loop); break; case STM_SWITCH: cswitch(J, F, stm->a, stm->b); labeljumps(J, F, stm, here(J,F), 0); break; case STM_LABEL: cstm(J, F, stm->b); while (stm->type == STM_LABEL) stm = stm->b; if (!isloop(stm->type) && stm->type != STM_SWITCH) labeljumps(J, F, stm, here(J,F), 0); break; case STM_BREAK: if (stm->a) { checkfutureword(J, F, stm->a); target = breaktarget(J, F, stm->parent, stm->a->string); if (!target) jsC_error(J, stm, ""break label '%s' not found"", stm->a->string); } else { target = breaktarget(J, F, stm->parent, NULL); if (!target) jsC_error(J, stm, ""unlabelled break must be inside loop or switch""); } cexit(J, F, STM_BREAK, stm, target); emitline(J, F, stm); addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP)); break; case STM_CONTINUE: if (stm->a) { checkfutureword(J, F, stm->a); target = continuetarget(J, F, stm->parent, stm->a->string); if (!target) jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string); } else { target = continuetarget(J, F, stm->parent, NULL); if (!target) jsC_error(J, stm, ""continue must be inside loop""); } cexit(J, F, STM_CONTINUE, stm, target); emitline(J, F, stm); addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP)); break; case STM_RETURN: if (stm->a) cexp(J, F, stm->a); else emit(J, F, OP_UNDEF); target = returntarget(J, F, stm->parent); if (!target) jsC_error(J, stm, ""return not in function""); cexit(J, F, STM_RETURN, stm, target); emitline(J, F, stm); emit(J, F, OP_RETURN); break; case STM_THROW: cexp(J, F, stm->a); emitline(J, F, stm); emit(J, F, OP_THROW); break; case STM_WITH: F->lightweight = 0; if (F->strict) jsC_error(J, stm->a, ""'with' statements are not allowed in strict mode""); cexp(J, F, stm->a); emitline(J, F, stm); emit(J, F, OP_WITH); cstm(J, F, stm->b); emitline(J, F, stm); emit(J, F, OP_ENDWITH); break; case STM_TRY: emitline(J, F, stm); if (stm->b && stm->c) { F->lightweight = 0; if (stm->d) ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d); else ctrycatch(J, F, stm->a, stm->b, stm->c); } else { ctryfinally(J, F, stm->a, stm->d); } break; case STM_DEBUGGER: emitline(J, F, stm); emit(J, F, OP_DEBUGGER); break; default: if (F->script) { emitline(J, F, stm); emit(J, F, OP_POP); cexp(J, F, stm); } else { cexp(J, F, stm); emitline(J, F, stm); emit(J, F, OP_POP); } break; } }"
747,4276----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/exec.c----ram_block_add,"static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block) { RAMBlock *block; RAMBlock *last_block = NULL; new_block->offset = find_ram_offset(uc, new_block->max_length); if (!new_block->host) { new_block->host = phys_mem_alloc(uc, new_block->max_length, &new_block->mr->align); if (!new_block->host) { return; } } RAMBLOCK_FOREACH(block) { last_block = block; if (block->max_length < new_block->max_length) { break; } } if (block) { <S2SV_StartVul> QLIST_INSERT_BEFORE(block, new_block, next); <S2SV_EndVul> } else if (last_block) { <S2SV_StartVul> QLIST_INSERT_AFTER(last_block, new_block, next); <S2SV_EndVul> } else { <S2SV_StartVul> QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next); <S2SV_EndVul> } uc->ram_list.mru_block = NULL; cpu_physical_memory_set_dirty_range(new_block->offset, new_block->used_length, DIRTY_CLIENTS_ALL); }","- QLIST_INSERT_BEFORE(block, new_block, next);
- QLIST_INSERT_AFTER(last_block, new_block, next);
- QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);
+ uc->invalid_error = UC_ERR_NOMEM;
+ QLIST_INSERT_BEFORE_RCU(block, new_block, next);
+ QLIST_INSERT_AFTER_RCU(last_block, new_block, next);
+ QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next);","static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block) { RAMBlock *block; RAMBlock *last_block = NULL; new_block->offset = find_ram_offset(uc, new_block->max_length); if (!new_block->host) { new_block->host = phys_mem_alloc(uc, new_block->max_length, &new_block->mr->align); if (!new_block->host) { uc->invalid_error = UC_ERR_NOMEM; return; } } RAMBLOCK_FOREACH(block) { last_block = block; if (block->max_length < new_block->max_length) { break; } } if (block) { QLIST_INSERT_BEFORE_RCU(block, new_block, next); } else if (last_block) { QLIST_INSERT_AFTER_RCU(last_block, new_block, next); } else { QLIST_INSERT_HEAD_RCU(&uc->ram_list.blocks, new_block, next); } uc->ram_list.mru_block = NULL; cpu_physical_memory_set_dirty_range(new_block->offset, new_block->used_length, DIRTY_CLIENTS_ALL); }"
748,6846----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xmlrpclib.c----xmlrpc_char_encode,"void xmlrpc_char_encode(char *outbuffer, const char *s1) { long unsigned int i; unsigned char c; char buf2[15]; mowgli_string_t *s = mowgli_string_create(); *buf2 = '\0'; *outbuffer = '\0'; if ((!(s1) || (*(s1) == '\0'))) { return; } for (i = 0; s1[i] != '\0'; i++) { c = s1[i]; if (c > 127) { snprintf(buf2, sizeof buf2, ""&#%d;"", c); s->append(s, buf2, strlen(buf2)); } else if (c == '&') { s->append(s, ""&amp;"", 5); } else if (c == '<') { s->append(s, ""&lt;"", 4); } else if (c == '>') { s->append(s, ""&gt;"", 4); } else if (c == '""') { s->append(s, ""&quot;"", 6); } else { s->append_char(s, c); } } <S2SV_StartVul> memcpy(outbuffer, s->str, XMLRPC_BUFSIZE); <S2SV_EndVul> }","- memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);
+ s->append_char(s, 0);
+ strncpy(outbuffer, s->str, XMLRPC_BUFSIZE);","void xmlrpc_char_encode(char *outbuffer, const char *s1) { long unsigned int i; unsigned char c; char buf2[15]; mowgli_string_t *s = mowgli_string_create(); *buf2 = '\0'; *outbuffer = '\0'; if ((!(s1) || (*(s1) == '\0'))) { return; } for (i = 0; s1[i] != '\0'; i++) { c = s1[i]; if (c > 127) { snprintf(buf2, sizeof buf2, ""&#%d;"", c); s->append(s, buf2, strlen(buf2)); } else if (c == '&') { s->append(s, ""&amp;"", 5); } else if (c == '<') { s->append(s, ""&lt;"", 4); } else if (c == '>') { s->append(s, ""&gt;"", 4); } else if (c == '""') { s->append(s, ""&quot;"", 6); } else { s->append_char(s, c); } } s->append_char(s, 0); strncpy(outbuffer, s->str, XMLRPC_BUFSIZE); }"
749,4707----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rectanglerequest.hpp----RectangleRequest::RectangleRequest,"RectangleRequest(const struct RectangleRequest &req) : Explicit() { <S2SV_StartVul> memcpy(this,&req,sizeof(struct RectangleRequest)); <S2SV_EndVul> <S2SV_StartVul> rr_pNext = NULL; <S2SV_EndVul> }","- memcpy(this,&req,sizeof(struct RectangleRequest));
- rr_pNext = NULL;
+ rr_pNext = NULL;
+ rr_Request = req.rr_Request;
+ rr_usFirstComponent = req.rr_usFirstComponent;
+ rr_usLastComponent = req.rr_usLastComponent;
+ rr_cPriority = req.rr_cPriority;
+ rr_bIncludeAlpha = req.rr_bIncludeAlpha;
+ rr_bUpsampling = req.rr_bUpsampling;
+ rr_bColorTrafo = req.rr_bColorTrafo;",RectangleRequest(const struct RectangleRequest &req) : Explicit() { rr_pNext = NULL; rr_Request = req.rr_Request; rr_usFirstComponent = req.rr_usFirstComponent; rr_usLastComponent = req.rr_usLastComponent; rr_cPriority = req.rr_cPriority; rr_bIncludeAlpha = req.rr_bIncludeAlpha; rr_bUpsampling = req.rr_bUpsampling; rr_bColorTrafo = req.rr_bColorTrafo; }
750,7489----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rdppm.c----read_pbm_integer,"read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval) { register int ch; register unsigned int val; do { ch = pbm_getc(infile); if (ch == EOF) ERREXIT(cinfo, JERR_INPUT_EOF); } while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'); if (ch < '0' || ch > '9') ERREXIT(cinfo, JERR_PPM_NONNUMERIC); val = ch - '0'; while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') { val *= 10; val += ch - '0'; } if (val > maxval) <S2SV_StartVul> ERREXIT(cinfo, JERR_PPM_TOOLARGE); <S2SV_EndVul> return val; }","- ERREXIT(cinfo, JERR_PPM_TOOLARGE);
+ ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);","read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval) { register int ch; register unsigned int val; do { ch = pbm_getc(infile); if (ch == EOF) ERREXIT(cinfo, JERR_INPUT_EOF); } while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'); if (ch < '0' || ch > '9') ERREXIT(cinfo, JERR_PPM_NONNUMERIC); val = ch - '0'; while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') { val *= 10; val += ch - '0'; } if (val > maxval) ERREXIT(cinfo, JERR_PPM_OUTOFRANGE); return val; }"
751,122----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4356--dn.c----append_utf8_value,"append_utf8_value (const unsigned char *value, size_t length, struct stringbuf *sb) { unsigned char tmp[6]; const unsigned char *s; size_t n; int i, nmore; if (length && (*value == ' ' || *value == '#')) { tmp[0] = '\\'; tmp[1] = *value; put_stringbuf_mem (sb, tmp, 2); value++; length--; } if (length && value[length-1] == ' ') { tmp[0] = '\\'; tmp[1] = ' '; put_stringbuf_mem (sb, tmp, 2); length--; } for (s=value, n=0;;) { for (value = s; n < length && !(*s & 0x80); n++, s++) for (value = s; n < length && !(*s & 0x80); n++, s++) ; append_quoted (sb, value, s-value, 0); if (n==length) return; <S2SV_StartVul> assert ((*s & 0x80)); <S2SV_EndVul> <S2SV_StartVul> if ( (*s & 0xe0) == 0xc0 ) <S2SV_EndVul> nmore = 1; else if ( (*s & 0xf0) == 0xe0 ) nmore = 2; else if ( (*s & 0xf8) == 0xf0 ) nmore = 3; else if ( (*s & 0xfc) == 0xf8 ) nmore = 4; else if ( (*s & 0xfe) == 0xfc ) nmore = 5; <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> nmore = 5; <S2SV_EndVul> if (n+nmore > length) <S2SV_StartVul> nmore = length - n; <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> tmp[0] = *s++; n++; <S2SV_StartVul> for (i=1; i <= nmore; i++) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> if ( (*s & 0xc0) != 0x80) <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> tmp[i] = *s++; <S2SV_EndVul> <S2SV_StartVul> n++; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> put_stringbuf_mem (sb, tmp, i); <S2SV_StartVul> } <S2SV_EndVul> }","- assert ((*s & 0x80));
- 
- for (i=1; i <= nmore; i++)
- {
- tmp[i] = *s++;
- n++;
- }
- }
+ if (!(*s & 0x80))
+ nmore = 0;
+ if (!nmore)
+ snprintf (tmp, sizeof tmp, ""\\%02X"", *s);
+ put_stringbuf_mem (sb, tmp, 3);
+ s++; n++;
+ }
+ else
+ {
+ if (n+nmore > length)
+ tmp[0] = *s++; n++;
+ for (i=1; i <= nmore; i++)
+ {
+ if ( (*s & 0xc0) != 0x80)
+ tmp[i] = *s++;
+ n++;
+ }
+ put_stringbuf_mem (sb, tmp, i);","append_utf8_value (const unsigned char *value, size_t length, struct stringbuf *sb) { unsigned char tmp[6]; const unsigned char *s; size_t n; int i, nmore; if (length && (*value == ' ' || *value == '#')) { tmp[0] = '\\'; tmp[1] = *value; put_stringbuf_mem (sb, tmp, 2); value++; length--; } if (length && value[length-1] == ' ') { tmp[0] = '\\'; tmp[1] = ' '; put_stringbuf_mem (sb, tmp, 2); length--; } for (s=value, n=0;;) { for (value = s; n < length && !(*s & 0x80); n++, s++) for (value = s; n < length && !(*s & 0x80); n++, s++) ; append_quoted (sb, value, s-value, 0); if (n==length) return; if (!(*s & 0x80)) nmore = 0; else if ( (*s & 0xe0) == 0xc0 ) nmore = 1; else if ( (*s & 0xf0) == 0xe0 ) nmore = 2; else if ( (*s & 0xf8) == 0xf0 ) nmore = 3; else if ( (*s & 0xfc) == 0xf8 ) nmore = 4; else if ( (*s & 0xfe) == 0xfc ) nmore = 5; else nmore = 0; if (!nmore) { snprintf (tmp, sizeof tmp, ""\\%02X"", *s); put_stringbuf_mem (sb, tmp, 3); s++; n++; } else { if (n+nmore > length) nmore = length - n; tmp[0] = *s++; n++; for (i=1; i <= nmore; i++) { if ( (*s & 0xc0) != 0x80) break; tmp[i] = *s++; n++; } put_stringbuf_mem (sb, tmp, i); } } }"
752,660----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3673--sm_make_chunk.c----*sctp_process_asconf,"struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc, struct sctp_chunk *asconf) { sctp_addiphdr_t *hdr; union sctp_addr_param *addr_param; sctp_addip_param_t *asconf_param; struct sctp_chunk *asconf_ack; __be16 err_code; int length = 0; int chunk_len; __u32 serial; int all_param_pass = 1; <S2SV_StartVul> <S2SV_EndVul> chunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t); hdr = (sctp_addiphdr_t *)asconf->skb->data; serial = ntohl(hdr->serial); length = sizeof(sctp_addiphdr_t); addr_param = (union sctp_addr_param *)(asconf->skb->data + length); chunk_len -= length; length = ntohs(addr_param->p.length); asconf_param = (void *)addr_param + length; chunk_len -= length; asconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4); if (!asconf_ack) goto done; while (chunk_len > 0) { <S2SV_StartVul> err_code = sctp_process_asconf_param(asoc, asconf, <S2SV_EndVul> asconf_param); <S2SV_StartVul> if (SCTP_ERROR_NO_ERROR != err_code) <S2SV_StartVul> all_param_pass = 0; <S2SV_EndVul> <S2SV_StartVul> if (!all_param_pass) <S2SV_EndVul> sctp_add_asconf_response(asconf_ack, asconf_param->crr_id, err_code, <S2SV_StartVul> asconf_param); <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> <S2SV_StartVul> if (SCTP_ERROR_RSRC_LOW == err_code) goto done; <S2SV_StartVul> <S2SV_EndVul> length = ntohs(asconf_param->param_hdr.length); asconf_param = (void *)asconf_param + length; chunk_len -= length; <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> done: <S2SV_EndVul> <S2SV_StartVul> asoc->peer.addip_serial++; <S2SV_EndVul> if (asconf_ack) { sctp_chunk_hold(asconf_ack); list_add_tail(&asconf_ack->transmitted_list, &asoc->asconf_ack_list); } return asconf_ack; }","- 
- err_code = sctp_process_asconf_param(asoc, asconf,
- /* ADDIP 4.1 A7)
- all_param_pass = 0;
- if (!all_param_pass)
- asconf_param);
- 
- /* ADDIP 4.3 D11) When an endpoint receiving an ASCONF to add
- }
- done:
- asoc->peer.addip_serial++;
+ sctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) asconf->chunk_hdr;
+ bool all_param_pass = true;
+ union sctp_params param;
+ sctp_walk_params(param, addip, addip_hdr.params) {
+ if (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||
+ param.p->type == SCTP_PARAM_IPV6_ADDRESS)
+ continue;
+ param.addip);
+ if (err_code != SCTP_ERROR_NO_ERROR)
+ all_param_pass = false;
+ sctp_add_asconf_response(asconf_ack, param.addip->crr_id,
+ err_code, param.addip);
+ if (err_code == SCTP_ERROR_RSRC_LOW)","struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc, struct sctp_chunk *asconf) { sctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) asconf->chunk_hdr; bool all_param_pass = true; union sctp_params param; sctp_addiphdr_t *hdr; union sctp_addr_param *addr_param; sctp_addip_param_t *asconf_param; struct sctp_chunk *asconf_ack; __be16 err_code; int length = 0; int chunk_len; __u32 serial; chunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t); hdr = (sctp_addiphdr_t *)asconf->skb->data; serial = ntohl(hdr->serial); length = sizeof(sctp_addiphdr_t); addr_param = (union sctp_addr_param *)(asconf->skb->data + length); chunk_len -= length; length = ntohs(addr_param->p.length); asconf_param = (void *)addr_param + length; chunk_len -= length; asconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4); if (!asconf_ack) goto done; sctp_walk_params(param, addip, addip_hdr.params) { if (param.p->type == SCTP_PARAM_IPV4_ADDRESS || param.p->type == SCTP_PARAM_IPV6_ADDRESS) continue; err_code = sctp_process_asconf_param(asoc, asconf, param.addip); if (err_code != SCTP_ERROR_NO_ERROR) all_param_pass = false; if (!all_param_pass) sctp_add_asconf_response(asconf_ack, param.addip->crr_id, err_code, param.addip); if (err_code == SCTP_ERROR_RSRC_LOW) goto done; } done: asoc->peer.addip_serial++; if (asconf_ack) { sctp_chunk_hold(asconf_ack); list_add_tail(&asconf_ack->transmitted_list, &asoc->asconf_ack_list); } return asconf_ack; }"
753,1674----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-3733--t1_lib.c----ssl_scan_clienthello_tlsext,"static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al) { unsigned int type; int renegotiate_seen = 0; PACKET extensions; *al = SSL_AD_DECODE_ERROR; s->servername_done = 0; s->tlsext_status_type = -1; #ifndef OPENSSL_NO_NEXTPROTONEG s->s3->next_proto_neg_seen = 0; #endif OPENSSL_free(s->s3->alpn_selected); s->s3->alpn_selected = NULL; s->s3->alpn_selected_len = 0; OPENSSL_free(s->s3->alpn_proposed); s->s3->alpn_proposed = NULL; s->s3->alpn_proposed_len = 0; #ifndef OPENSSL_NO_HEARTBEATS s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS); #endif #ifndef OPENSSL_NO_EC if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG) ssl_check_for_safari(s, pkt); #endif OPENSSL_free(s->s3->tmp.peer_sigalgs); s->s3->tmp.peer_sigalgs = NULL; <S2SV_StartVul> s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC; <S2SV_EndVul> #ifndef OPENSSL_NO_SRP OPENSSL_free(s->srp_ctx.login); s->srp_ctx.login = NULL; #endif s->srtp_profile = NULL; if (PACKET_remaining(pkt) == 0) goto ri_check; if (!PACKET_as_length_prefixed_2(pkt, &extensions)) return 0; if (!tls1_check_duplicate_extensions(&extensions)) return 0; while (PACKET_get_net_2(&extensions, &type)) { PACKET extension; if (!PACKET_get_length_prefixed_2(&extensions, &extension)) return 0; if (s->tlsext_debug_cb) s->tlsext_debug_cb(s, 0, type, PACKET_data(&extension), PACKET_remaining(&extension), s->tlsext_debug_arg); if (type == TLSEXT_TYPE_renegotiate) { if (!ssl_parse_clienthello_renegotiate_ext(s, &extension, al)) return 0; renegotiate_seen = 1; } else if (s->version == SSL3_VERSION) { } else if (type == TLSEXT_TYPE_server_name) { unsigned int servname_type; PACKET sni, hostname; if (!PACKET_as_length_prefixed_2(&extension, &sni) || PACKET_remaining(&sni) == 0) { return 0; } if (!PACKET_get_1(&sni, &servname_type) || servname_type != TLSEXT_NAMETYPE_host_name || !PACKET_as_length_prefixed_2(&sni, &hostname)) { return 0; } if (!s->hit) { if (PACKET_remaining(&hostname) > TLSEXT_MAXLEN_host_name) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } if (PACKET_contains_zero_byte(&hostname)) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } if (!PACKET_strndup(&hostname, &s->session->tlsext_hostname)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->servername_done = 1; } else { s->servername_done = s->session->tlsext_hostname && PACKET_equal(&hostname, s->session->tlsext_hostname, strlen(s->session->tlsext_hostname)); } } #ifndef OPENSSL_NO_SRP else if (type == TLSEXT_TYPE_srp) { PACKET srp_I; if (!PACKET_as_length_prefixed_1(&extension, &srp_I)) return 0; if (PACKET_contains_zero_byte(&srp_I)) return 0; if (!PACKET_strndup(&srp_I, &s->srp_ctx.login)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } #endif #ifndef OPENSSL_NO_EC else if (type == TLSEXT_TYPE_ec_point_formats) { PACKET ec_point_format_list; if (!PACKET_as_length_prefixed_1(&extension, &ec_point_format_list) || PACKET_remaining(&ec_point_format_list) == 0) { return 0; } if (!s->hit) { if (!PACKET_memdup(&ec_point_format_list, &s->session->tlsext_ecpointformatlist, &s-> session->tlsext_ecpointformatlist_length)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } } else if (type == TLSEXT_TYPE_elliptic_curves) { PACKET elliptic_curve_list; if (!PACKET_as_length_prefixed_2(&extension, &elliptic_curve_list) || PACKET_remaining(&elliptic_curve_list) == 0 || (PACKET_remaining(&elliptic_curve_list) % 2) != 0) { return 0; } if (!s->hit) { if (!PACKET_memdup(&elliptic_curve_list, &s->session->tlsext_ellipticcurvelist, &s-> session->tlsext_ellipticcurvelist_length)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } } #endif else if (type == TLSEXT_TYPE_session_ticket) { if (s->tls_session_ticket_ext_cb && !s->tls_session_ticket_ext_cb(s, PACKET_data(&extension), PACKET_remaining(&extension), s->tls_session_ticket_ext_cb_arg)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } else if (type == TLSEXT_TYPE_signature_algorithms) { PACKET supported_sig_algs; if (!PACKET_as_length_prefixed_2(&extension, &supported_sig_algs) || (PACKET_remaining(&supported_sig_algs) % 2) != 0 || PACKET_remaining(&supported_sig_algs) == 0) { return 0; } if (!s->hit) { if (!tls1_save_sigalgs(s, PACKET_data(&supported_sig_algs), PACKET_remaining(&supported_sig_algs))) { return 0; } } } else if (type == TLSEXT_TYPE_status_request) { if (!PACKET_get_1(&extension, (unsigned int *)&s->tlsext_status_type)) { return 0; } #ifndef OPENSSL_NO_OCSP if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) { const unsigned char *ext_data; PACKET responder_id_list, exts; if (!PACKET_get_length_prefixed_2 (&extension, &responder_id_list)) return 0; sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free); if (PACKET_remaining(&responder_id_list) > 0) { s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null(); if (s->tlsext_ocsp_ids == NULL) { *al = SSL_AD_INTERNAL_ERROR; return 0; } } else { s->tlsext_ocsp_ids = NULL; } while (PACKET_remaining(&responder_id_list) > 0) { OCSP_RESPID *id; PACKET responder_id; const unsigned char *id_data; if (!PACKET_get_length_prefixed_2(&responder_id_list, &responder_id) || PACKET_remaining(&responder_id) == 0) { return 0; } id_data = PACKET_data(&responder_id); id = d2i_OCSP_RESPID(NULL, &id_data, PACKET_remaining(&responder_id)); if (id == NULL) return 0; if (id_data != PACKET_end(&responder_id)) { OCSP_RESPID_free(id); return 0; } if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) { OCSP_RESPID_free(id); *al = SSL_AD_INTERNAL_ERROR; return 0; } } if (!PACKET_as_length_prefixed_2(&extension, &exts)) return 0; if (PACKET_remaining(&exts) > 0) { ext_data = PACKET_data(&exts); sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts, X509_EXTENSION_free); s->tlsext_ocsp_exts = d2i_X509_EXTENSIONS(NULL, &ext_data, PACKET_remaining(&exts)); if (s->tlsext_ocsp_exts == NULL || ext_data != PACKET_end(&exts)) { return 0; } } } else #endif { s->tlsext_status_type = -1; } } #ifndef OPENSSL_NO_HEARTBEATS else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) { unsigned int hbtype; if (!PACKET_get_1(&extension, &hbtype) || PACKET_remaining(&extension)) { *al = SSL_AD_DECODE_ERROR; return 0; } switch (hbtype) { case 0x01: s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED; break; case 0x02: s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED; s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS; break; default: *al = SSL_AD_ILLEGAL_PARAMETER; return 0; } } #endif #ifndef OPENSSL_NO_NEXTPROTONEG else if (type == TLSEXT_TYPE_next_proto_neg && s->s3->tmp.finish_md_len == 0) { s->s3->next_proto_neg_seen = 1; } #endif else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation && s->s3->tmp.finish_md_len == 0) { if (!tls1_alpn_handle_client_hello(s, &extension, al)) return 0; } #ifndef OPENSSL_NO_SRTP else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s) && type == TLSEXT_TYPE_use_srtp) { if (ssl_parse_clienthello_use_srtp_ext(s, &extension, al)) return 0; } #endif else if (type == TLSEXT_TYPE_encrypt_then_mac) <S2SV_StartVul> s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC; <S2SV_EndVul> else if (!s->hit) { if (custom_ext_parse(s, 1, type, PACKET_data(&extension), PACKET_remaining(&extension), al) <= 0) return 0; } } if (PACKET_remaining(pkt) != 0) { *al = SSL_AD_INTERNAL_ERROR; return 0; } ri_check: if (!renegotiate_seen && s->renegotiate && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { *al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); return 0; } return 1; }","- s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;
- s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;
+ s->tlsext_use_etm = 0;
+ s->tlsext_use_etm = 1;","static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al) { unsigned int type; int renegotiate_seen = 0; PACKET extensions; *al = SSL_AD_DECODE_ERROR; s->servername_done = 0; s->tlsext_status_type = -1; #ifndef OPENSSL_NO_NEXTPROTONEG s->s3->next_proto_neg_seen = 0; #endif OPENSSL_free(s->s3->alpn_selected); s->s3->alpn_selected = NULL; s->s3->alpn_selected_len = 0; OPENSSL_free(s->s3->alpn_proposed); s->s3->alpn_proposed = NULL; s->s3->alpn_proposed_len = 0; #ifndef OPENSSL_NO_HEARTBEATS s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS); #endif #ifndef OPENSSL_NO_EC if (s->options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG) ssl_check_for_safari(s, pkt); #endif OPENSSL_free(s->s3->tmp.peer_sigalgs); s->s3->tmp.peer_sigalgs = NULL; s->tlsext_use_etm = 0; #ifndef OPENSSL_NO_SRP OPENSSL_free(s->srp_ctx.login); s->srp_ctx.login = NULL; #endif s->srtp_profile = NULL; if (PACKET_remaining(pkt) == 0) goto ri_check; if (!PACKET_as_length_prefixed_2(pkt, &extensions)) return 0; if (!tls1_check_duplicate_extensions(&extensions)) return 0; while (PACKET_get_net_2(&extensions, &type)) { PACKET extension; if (!PACKET_get_length_prefixed_2(&extensions, &extension)) return 0; if (s->tlsext_debug_cb) s->tlsext_debug_cb(s, 0, type, PACKET_data(&extension), PACKET_remaining(&extension), s->tlsext_debug_arg); if (type == TLSEXT_TYPE_renegotiate) { if (!ssl_parse_clienthello_renegotiate_ext(s, &extension, al)) return 0; renegotiate_seen = 1; } else if (s->version == SSL3_VERSION) { } else if (type == TLSEXT_TYPE_server_name) { unsigned int servname_type; PACKET sni, hostname; if (!PACKET_as_length_prefixed_2(&extension, &sni) || PACKET_remaining(&sni) == 0) { return 0; } if (!PACKET_get_1(&sni, &servname_type) || servname_type != TLSEXT_NAMETYPE_host_name || !PACKET_as_length_prefixed_2(&sni, &hostname)) { return 0; } if (!s->hit) { if (PACKET_remaining(&hostname) > TLSEXT_MAXLEN_host_name) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } if (PACKET_contains_zero_byte(&hostname)) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } if (!PACKET_strndup(&hostname, &s->session->tlsext_hostname)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->servername_done = 1; } else { s->servername_done = s->session->tlsext_hostname && PACKET_equal(&hostname, s->session->tlsext_hostname, strlen(s->session->tlsext_hostname)); } } #ifndef OPENSSL_NO_SRP else if (type == TLSEXT_TYPE_srp) { PACKET srp_I; if (!PACKET_as_length_prefixed_1(&extension, &srp_I)) return 0; if (PACKET_contains_zero_byte(&srp_I)) return 0; if (!PACKET_strndup(&srp_I, &s->srp_ctx.login)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } #endif #ifndef OPENSSL_NO_EC else if (type == TLSEXT_TYPE_ec_point_formats) { PACKET ec_point_format_list; if (!PACKET_as_length_prefixed_1(&extension, &ec_point_format_list) || PACKET_remaining(&ec_point_format_list) == 0) { return 0; } if (!s->hit) { if (!PACKET_memdup(&ec_point_format_list, &s->session->tlsext_ecpointformatlist, &s-> session->tlsext_ecpointformatlist_length)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } } else if (type == TLSEXT_TYPE_elliptic_curves) { PACKET elliptic_curve_list; if (!PACKET_as_length_prefixed_2(&extension, &elliptic_curve_list) || PACKET_remaining(&elliptic_curve_list) == 0 || (PACKET_remaining(&elliptic_curve_list) % 2) != 0) { return 0; } if (!s->hit) { if (!PACKET_memdup(&elliptic_curve_list, &s->session->tlsext_ellipticcurvelist, &s-> session->tlsext_ellipticcurvelist_length)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } } #endif else if (type == TLSEXT_TYPE_session_ticket) { if (s->tls_session_ticket_ext_cb && !s->tls_session_ticket_ext_cb(s, PACKET_data(&extension), PACKET_remaining(&extension), s->tls_session_ticket_ext_cb_arg)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } } else if (type == TLSEXT_TYPE_signature_algorithms) { PACKET supported_sig_algs; if (!PACKET_as_length_prefixed_2(&extension, &supported_sig_algs) || (PACKET_remaining(&supported_sig_algs) % 2) != 0 || PACKET_remaining(&supported_sig_algs) == 0) { return 0; } if (!s->hit) { if (!tls1_save_sigalgs(s, PACKET_data(&supported_sig_algs), PACKET_remaining(&supported_sig_algs))) { return 0; } } } else if (type == TLSEXT_TYPE_status_request) { if (!PACKET_get_1(&extension, (unsigned int *)&s->tlsext_status_type)) { return 0; } #ifndef OPENSSL_NO_OCSP if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) { const unsigned char *ext_data; PACKET responder_id_list, exts; if (!PACKET_get_length_prefixed_2 (&extension, &responder_id_list)) return 0; sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free); if (PACKET_remaining(&responder_id_list) > 0) { s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null(); if (s->tlsext_ocsp_ids == NULL) { *al = SSL_AD_INTERNAL_ERROR; return 0; } } else { s->tlsext_ocsp_ids = NULL; } while (PACKET_remaining(&responder_id_list) > 0) { OCSP_RESPID *id; PACKET responder_id; const unsigned char *id_data; if (!PACKET_get_length_prefixed_2(&responder_id_list, &responder_id) || PACKET_remaining(&responder_id) == 0) { return 0; } id_data = PACKET_data(&responder_id); id = d2i_OCSP_RESPID(NULL, &id_data, PACKET_remaining(&responder_id)); if (id == NULL) return 0; if (id_data != PACKET_end(&responder_id)) { OCSP_RESPID_free(id); return 0; } if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) { OCSP_RESPID_free(id); *al = SSL_AD_INTERNAL_ERROR; return 0; } } if (!PACKET_as_length_prefixed_2(&extension, &exts)) return 0; if (PACKET_remaining(&exts) > 0) { ext_data = PACKET_data(&exts); sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts, X509_EXTENSION_free); s->tlsext_ocsp_exts = d2i_X509_EXTENSIONS(NULL, &ext_data, PACKET_remaining(&exts)); if (s->tlsext_ocsp_exts == NULL || ext_data != PACKET_end(&exts)) { return 0; } } } else #endif { s->tlsext_status_type = -1; } } #ifndef OPENSSL_NO_HEARTBEATS else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) { unsigned int hbtype; if (!PACKET_get_1(&extension, &hbtype) || PACKET_remaining(&extension)) { *al = SSL_AD_DECODE_ERROR; return 0; } switch (hbtype) { case 0x01: s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED; break; case 0x02: s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED; s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS; break; default: *al = SSL_AD_ILLEGAL_PARAMETER; return 0; } } #endif #ifndef OPENSSL_NO_NEXTPROTONEG else if (type == TLSEXT_TYPE_next_proto_neg && s->s3->tmp.finish_md_len == 0) { s->s3->next_proto_neg_seen = 1; } #endif else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation && s->s3->tmp.finish_md_len == 0) { if (!tls1_alpn_handle_client_hello(s, &extension, al)) return 0; } #ifndef OPENSSL_NO_SRTP else if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s) && type == TLSEXT_TYPE_use_srtp) { if (ssl_parse_clienthello_use_srtp_ext(s, &extension, al)) return 0; } #endif else if (type == TLSEXT_TYPE_encrypt_then_mac) s->tlsext_use_etm = 1; else if (!s->hit) { if (custom_ext_parse(s, 1, type, PACKET_data(&extension), PACKET_remaining(&extension), al) <= 0) return 0; } } if (PACKET_remaining(pkt) != 0) { *al = SSL_AD_INTERNAL_ERROR; return 0; } ri_check: if (!renegotiate_seen && s->renegotiate && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { *al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); return 0; } return 1; }"
754,3484----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/SQLCreateDataSource.c----_single_string_alloc_and_expand,SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in ) { SQLWCHAR *chr; int len = 0; if ( !in ) { <S2SV_StartVul> return in; <S2SV_EndVul> } while ( in[ len ] != 0 ) { len ++; } chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 )); len = 0; while ( in[ len ] != 0 ) { chr[ len ] = in[ len ]; len ++; } chr[ len ++ ] = 0; return chr; },"- return in;
+ return NULL;",SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in ) { SQLWCHAR *chr; int len = 0; if ( !in ) { return NULL; } while ( in[ len ] != 0 ) { len ++; } chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 )); len = 0; while ( in[ len ] != 0 ) { chr[ len ] = in[ len ]; len ++; } chr[ len ++ ] = 0; return chr; }
755,7183----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/webauthn.c----check_attestation_fido_u2f,"static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) { json_t * j_error = json_array(), * j_return; cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL; int i, ret; char * message = NULL; gnutls_pubkey_t pubkey = NULL; gnutls_x509_crt_t cert = NULL; gnutls_datum_t cert_dat, data, signature, cert_issued_by; <S2SV_StartVul> unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64]; <S2SV_EndVul> size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0; if (j_error != NULL) { do { if (gnutls_x509_crt_init(&cert)) { json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_x509_crt_init"")); break; } if (gnutls_pubkey_init(&pubkey)) { json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_pubkey_init"")); break; } if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) { json_array_append_new(j_error, json_string(""CBOR map value 'attStmt' invalid format"")); break; } for (i=0; i<2; i++) { key = cbor_map_handle(att_stmt)[i].key; if (cbor_isa_string(key)) { if (0 == o_strncmp((const char *)cbor_string_handle(key), ""x5c"", MIN(o_strlen(""x5c""), cbor_string_length(key)))) { x5c = cbor_map_handle(att_stmt)[i].value; } else if (0 == o_strncmp((const char *)cbor_string_handle(key), ""sig"", MIN(o_strlen(""sig""), cbor_string_length(key)))) { sig = cbor_map_handle(att_stmt)[i].value; } else { message = msprintf(""attStmt map element %d key is not valid: '%.*s'"", i, cbor_string_length(key), cbor_string_handle(key)); json_array_append_new(j_error, json_string(message)); o_free(message); break; } } else { message = msprintf(""attStmt map element %d key is not a string"", i); json_array_append_new(j_error, json_string(message)); o_free(message); break; } } if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) { json_array_append_new(j_error, json_string(""CBOR map value 'x5c' invalid format"")); break; } att_cert = cbor_array_get(x5c, 0); cert_dat.data = cbor_bytestring_handle(att_cert); cert_dat.size = cbor_bytestring_length(att_cert); if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) { json_array_append_new(j_error, json_string(""Error importing x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d"", ret); break; } if (json_object_get(j_params, ""root-ca-list"") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) { json_array_append_new(j_error, json_string(""Unrecognized certificate authority"")); if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) { message = msprintf(""Unrecognized certificate autohority: %.*s"", cert_issued_by.size, cert_issued_by.data); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - %s"", message); o_free(message); gnutls_free(cert_issued_by.data); } else { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)""); } break; } if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) { json_array_append_new(j_error, json_string(""Error importing x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d"", ret); break; } if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) { json_array_append_new(j_error, json_string(""Error exporting x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d"", ret); break; } if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) { json_array_append_new(j_error, json_string(""Internal error"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error o_base64_encode cert_export""); break; } if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) { json_array_append_new(j_error, json_string(""Internal error"")); y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error generate_digest_raw client_data""); break; } if (sig == NULL || !cbor_isa_bytestring(sig)) { json_array_append_new(j_error, json_string(""Error sig is not a bytestring"")); break; } data_signed[0] = 0x0; data_signed_offset = 1; memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len); data_signed_offset += rpid_hash_len; memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len); data_signed_offset+=client_data_hash_len; memcpy(data_signed+data_signed_offset, credential_id, credential_id_len); data_signed_offset+=credential_id_len; data_signed[data_signed_offset] = 0x04; data_signed_offset++; memcpy(data_signed+data_signed_offset, cert_x, cert_x_len); data_signed_offset+=cert_x_len; memcpy(data_signed+data_signed_offset, cert_y, cert_y_len); data_signed_offset+=cert_y_len; data.data = data_signed; data.size = data_signed_offset; signature.data = cbor_bytestring_handle(sig); signature.size = cbor_bytestring_length(sig); if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) { json_array_append_new(j_error, json_string(""Invalid signature"")); } } while (0); if (json_array_size(j_error)) { j_return = json_pack(""{sisO}"", ""result"", G_ERROR_PARAM, ""error"", j_error); } else { j_return = json_pack(""{sis{ss%}}"", ""result"", G_OK, ""data"", ""certificate"", cert_export_b64, cert_export_b64_len); } json_decref(j_error); gnutls_pubkey_deinit(pubkey); gnutls_x509_crt_deinit(cert); if (att_cert != NULL) { cbor_decref(&att_cert); } } else { y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error allocating resources for j_error""); j_return = json_pack(""{si}"", ""result"", G_ERROR); } return j_return; }","- unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];
+ unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];
+ if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {
+ y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error allocating data_signed"");
+ json_array_append_new(j_error, json_string(""Internal error""));
+ break;
+ }
+ o_free(data_signed);","static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) { json_t * j_error = json_array(), * j_return; cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL; int i, ret; char * message = NULL; gnutls_pubkey_t pubkey = NULL; gnutls_x509_crt_t cert = NULL; gnutls_datum_t cert_dat, data, signature, cert_issued_by; unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64]; size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0; if (j_error != NULL) { do { if (gnutls_x509_crt_init(&cert)) { json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_x509_crt_init"")); break; } if (gnutls_pubkey_init(&pubkey)) { json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_pubkey_init"")); break; } if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) { json_array_append_new(j_error, json_string(""CBOR map value 'attStmt' invalid format"")); break; } for (i=0; i<2; i++) { key = cbor_map_handle(att_stmt)[i].key; if (cbor_isa_string(key)) { if (0 == o_strncmp((const char *)cbor_string_handle(key), ""x5c"", MIN(o_strlen(""x5c""), cbor_string_length(key)))) { x5c = cbor_map_handle(att_stmt)[i].value; } else if (0 == o_strncmp((const char *)cbor_string_handle(key), ""sig"", MIN(o_strlen(""sig""), cbor_string_length(key)))) { sig = cbor_map_handle(att_stmt)[i].value; } else { message = msprintf(""attStmt map element %d key is not valid: '%.*s'"", i, cbor_string_length(key), cbor_string_handle(key)); json_array_append_new(j_error, json_string(message)); o_free(message); break; } } else { message = msprintf(""attStmt map element %d key is not a string"", i); json_array_append_new(j_error, json_string(message)); o_free(message); break; } } if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) { json_array_append_new(j_error, json_string(""CBOR map value 'x5c' invalid format"")); break; } att_cert = cbor_array_get(x5c, 0); cert_dat.data = cbor_bytestring_handle(att_cert); cert_dat.size = cbor_bytestring_length(att_cert); if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) { json_array_append_new(j_error, json_string(""Error importing x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d"", ret); break; } if (json_object_get(j_params, ""root-ca-list"") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) { json_array_append_new(j_error, json_string(""Unrecognized certificate authority"")); if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) { message = msprintf(""Unrecognized certificate autohority: %.*s"", cert_issued_by.size, cert_issued_by.data); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - %s"", message); o_free(message); gnutls_free(cert_issued_by.data); } else { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)""); } break; } if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) { json_array_append_new(j_error, json_string(""Error importing x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d"", ret); break; } if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) { json_array_append_new(j_error, json_string(""Error exporting x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d"", ret); break; } if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) { json_array_append_new(j_error, json_string(""Internal error"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error o_base64_encode cert_export""); break; } if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) { json_array_append_new(j_error, json_string(""Internal error"")); y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error generate_digest_raw client_data""); break; } if (sig == NULL || !cbor_isa_bytestring(sig)) { json_array_append_new(j_error, json_string(""Error sig is not a bytestring"")); break; } if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error allocating data_signed""); json_array_append_new(j_error, json_string(""Internal error"")); break; } data_signed[0] = 0x0; data_signed_offset = 1; memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len); data_signed_offset += rpid_hash_len; memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len); data_signed_offset+=client_data_hash_len; memcpy(data_signed+data_signed_offset, credential_id, credential_id_len); data_signed_offset+=credential_id_len; data_signed[data_signed_offset] = 0x04; data_signed_offset++; memcpy(data_signed+data_signed_offset, cert_x, cert_x_len); data_signed_offset+=cert_x_len; memcpy(data_signed+data_signed_offset, cert_y, cert_y_len); data_signed_offset+=cert_y_len; data.data = data_signed; data.size = data_signed_offset; signature.data = cbor_bytestring_handle(sig); signature.size = cbor_bytestring_length(sig); if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) { json_array_append_new(j_error, json_string(""Invalid signature"")); } } while (0); o_free(data_signed); if (json_array_size(j_error)) { j_return = json_pack(""{sisO}"", ""result"", G_ERROR_PARAM, ""error"", j_error); } else { j_return = json_pack(""{sis{ss%}}"", ""result"", G_OK, ""data"", ""certificate"", cert_export_b64, cert_export_b64_len); } json_decref(j_error); gnutls_pubkey_deinit(pubkey); gnutls_x509_crt_deinit(cert); if (att_cert != NULL) { cbor_decref(&att_cert); } } else { y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error allocating resources for j_error""); j_return = json_pack(""{si}"", ""result"", G_ERROR); } return j_return; }"
756,6492----CWE-358----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/defrag.c----DefragTimeoutTest,"DefragTimeoutTest(void) { int i; int ret = 0; if (ConfSet(""defrag.trackers"", ""16"") != 1) { printf(""ConfSet failed: ""); goto end; } DefragInit(); for (i = 0; i < 16; i++) { <S2SV_StartVul> Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16); <S2SV_EndVul> if (p == NULL) goto end; Packet *tp = Defrag(NULL, NULL, p, NULL); SCFree(p); if (tp != NULL) { SCFree(tp); goto end; } } <S2SV_StartVul> Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16); <S2SV_EndVul> if (p == NULL) goto end; p->ts.tv_sec += (defrag_context->timeout + 1); Packet *tp = Defrag(NULL, NULL, p, NULL); if (tp != NULL) { SCFree(tp); goto end; } DefragTracker *tracker = DefragLookupTrackerFromHash(p); if (tracker == NULL) goto end; if (tracker->id != 99) goto end; SCFree(p); ret = 1; end: DefragDestroy(); return ret; }","- Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
- Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
+ Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16);
+ Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16);","DefragTimeoutTest(void) { int i; int ret = 0; if (ConfSet(""defrag.trackers"", ""16"") != 1) { printf(""ConfSet failed: ""); goto end; } DefragInit(); for (i = 0; i < 16; i++) { Packet *p = BuildTestPacket(IPPROTO_ICMP,i, 0, 1, 'A' + i, 16); if (p == NULL) goto end; Packet *tp = Defrag(NULL, NULL, p, NULL); SCFree(p); if (tp != NULL) { SCFree(tp); goto end; } } Packet *p = BuildTestPacket(IPPROTO_ICMP, 99, 0, 1, 'A' + i, 16); if (p == NULL) goto end; p->ts.tv_sec += (defrag_context->timeout + 1); Packet *tp = Defrag(NULL, NULL, p, NULL); if (tp != NULL) { SCFree(tp); goto end; } DefragTracker *tracker = DefragLookupTrackerFromHash(p); if (tracker == NULL) goto end; if (tracker->id != 99) goto end; SCFree(p); ret = 1; end: DefragDestroy(); return ret; }"
757,2360----CWE-400----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-21017--box_code_base.c----dinf_Read,"GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs) { GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox); if (e) { return e; } if (!((GF_DataInformationBox *)s)->dref) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n"")); <S2SV_StartVul> ((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF); <S2SV_EndVul> } return GF_OK; }","- ((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
+ GF_Box* dref;
+ dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);
+ ((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref;
+ gf_isom_box_add_for_dump_mode(s, dref);","GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs) { GF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox); if (e) { return e; } if (!((GF_DataInformationBox *)s)->dref) { GF_Box* dref; GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Missing dref box in dinf\n"")); dref = gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF); ((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)dref; gf_isom_box_add_for_dump_mode(s, dref); } return GF_OK; }"
758,6827----CWE-681----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/verifier.c----scalar32_min_max_or,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg) { bool src_known = tnum_subreg_is_const(src_reg->var_off); bool dst_known = tnum_subreg_is_const(dst_reg->var_off); struct tnum var32_off = tnum_subreg(dst_reg->var_off); <S2SV_StartVul> s32 smin_val = src_reg->smin_value; <S2SV_EndVul> <S2SV_StartVul> u32 umin_val = src_reg->umin_value; <S2SV_EndVul> if (src_known && dst_known) return; dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val); dst_reg->u32_max_value = var32_off.value | var32_off.mask; if (dst_reg->s32_min_value < 0 || smin_val < 0) { dst_reg->s32_min_value = S32_MIN; dst_reg->s32_max_value = S32_MAX; } else { <S2SV_StartVul> dst_reg->s32_min_value = dst_reg->umin_value; <S2SV_EndVul> <S2SV_StartVul> dst_reg->s32_max_value = dst_reg->umax_value; <S2SV_EndVul> } }","- s32 smin_val = src_reg->smin_value;
- u32 umin_val = src_reg->umin_value;
- dst_reg->s32_min_value = dst_reg->umin_value;
- dst_reg->s32_max_value = dst_reg->umax_value;
+ s32 smin_val = src_reg->s32_min_value;
+ u32 umin_val = src_reg->u32_min_value;
+ dst_reg->s32_min_value = dst_reg->u32_min_value;
+ dst_reg->s32_max_value = dst_reg->u32_max_value;","static void scalar32_min_max_or(struct bpf_reg_state *dst_reg, struct bpf_reg_state *src_reg) { bool src_known = tnum_subreg_is_const(src_reg->var_off); bool dst_known = tnum_subreg_is_const(dst_reg->var_off); struct tnum var32_off = tnum_subreg(dst_reg->var_off); s32 smin_val = src_reg->s32_min_value; u32 umin_val = src_reg->u32_min_value; if (src_known && dst_known) return; dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val); dst_reg->u32_max_value = var32_off.value | var32_off.mask; if (dst_reg->s32_min_value < 0 || smin_val < 0) { dst_reg->s32_min_value = S32_MIN; dst_reg->s32_max_value = S32_MAX; } else { dst_reg->s32_min_value = dst_reg->u32_min_value; dst_reg->s32_max_value = dst_reg->u32_max_value; } }"
759,4802----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/i2c.c----do_i2c_md,"static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) { uint chip; uint addr, length; <S2SV_StartVul> int alen; <S2SV_EndVul> <S2SV_StartVul> int j, nbytes, linebytes; <S2SV_EndVul> int ret; #if CONFIG_IS_ENABLED(DM_I2C) struct udevice *dev; #endif chip = i2c_dp_last_chip; addr = i2c_dp_last_addr; alen = i2c_dp_last_alen; length = i2c_dp_last_length; if (argc < 3) return CMD_RET_USAGE; if ((flag & CMD_FLAG_REPEAT) == 0) { chip = hextoul(argv[1], NULL); addr = hextoul(argv[2], NULL); alen = get_alen(argv[2], DEFAULT_ADDR_LEN); if (alen > 3) return CMD_RET_USAGE; if (argc > 3) length = hextoul(argv[3], NULL); } #if CONFIG_IS_ENABLED(DM_I2C) ret = i2c_get_cur_bus_chip(chip, &dev); if (!ret && alen != -1) ret = i2c_set_chip_offset_len(dev, alen); if (ret) return i2c_report_err(ret, I2C_ERR_READ); #endif nbytes = length; do { unsigned char linebuf[DISP_LINE_LEN]; unsigned char *cp; linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes; #if CONFIG_IS_ENABLED(DM_I2C) ret = dm_i2c_read(dev, addr, linebuf, linebytes); #else ret = i2c_read(chip, addr, alen, linebuf, linebytes); #endif if (ret) return i2c_report_err(ret, I2C_ERR_READ); else { printf(""%04x:"", addr); cp = linebuf; for (j=0; j<linebytes; j++) { printf("" %02x"", *cp++); addr++; } puts ("" ""); cp = linebuf; for (j=0; j<linebytes; j++) { if ((*cp < 0x20) || (*cp > 0x7e)) puts ("".""); else printf(""%c"", *cp); cp++; } putc ('\n'); } nbytes -= linebytes; } while (nbytes > 0); i2c_dp_last_chip = chip; i2c_dp_last_addr = addr; i2c_dp_last_alen = alen; i2c_dp_last_length = length; return 0; }","- int alen;
- int j, nbytes, linebytes;
+ uint alen;
+ uint j, nbytes, linebytes;","static int do_i2c_md(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) { uint chip; uint addr, length; uint alen; uint j, nbytes, linebytes; int ret; #if CONFIG_IS_ENABLED(DM_I2C) struct udevice *dev; #endif chip = i2c_dp_last_chip; addr = i2c_dp_last_addr; alen = i2c_dp_last_alen; length = i2c_dp_last_length; if (argc < 3) return CMD_RET_USAGE; if ((flag & CMD_FLAG_REPEAT) == 0) { chip = hextoul(argv[1], NULL); addr = hextoul(argv[2], NULL); alen = get_alen(argv[2], DEFAULT_ADDR_LEN); if (alen > 3) return CMD_RET_USAGE; if (argc > 3) length = hextoul(argv[3], NULL); } #if CONFIG_IS_ENABLED(DM_I2C) ret = i2c_get_cur_bus_chip(chip, &dev); if (!ret && alen != -1) ret = i2c_set_chip_offset_len(dev, alen); if (ret) return i2c_report_err(ret, I2C_ERR_READ); #endif nbytes = length; do { unsigned char linebuf[DISP_LINE_LEN]; unsigned char *cp; linebytes = (nbytes > DISP_LINE_LEN) ? DISP_LINE_LEN : nbytes; #if CONFIG_IS_ENABLED(DM_I2C) ret = dm_i2c_read(dev, addr, linebuf, linebytes); #else ret = i2c_read(chip, addr, alen, linebuf, linebytes); #endif if (ret) return i2c_report_err(ret, I2C_ERR_READ); else { printf(""%04x:"", addr); cp = linebuf; for (j=0; j<linebytes; j++) { printf("" %02x"", *cp++); addr++; } puts ("" ""); cp = linebuf; for (j=0; j<linebytes; j++) { if ((*cp < 0x20) || (*cp > 0x7e)) puts ("".""); else printf(""%c"", *cp); cp++; } putc ('\n'); } nbytes -= linebytes; } while (nbytes > 0); i2c_dp_last_chip = chip; i2c_dp_last_addr = addr; i2c_dp_last_alen = alen; i2c_dp_last_length = length; return 0; }"
760,7322----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xsave.h----xsave_state,"static inline int xsave_state(struct xsave_struct *fx, u64 mask) { u32 lmask = mask; u32 hmask = mask >> 32; int err = 0; alternative_input_2( ""1:""XSAVE, <S2SV_StartVul> ""1:""XSAVEOPT, <S2SV_EndVul> X86_FEATURE_XSAVEOPT, <S2SV_StartVul> ""1:""XSAVES, <S2SV_EndVul> X86_FEATURE_XSAVES, [fx] ""D"" (fx), ""a"" (lmask), ""d"" (hmask) : ""memory""); asm volatile(""2:\n\t"" xstate_fault : ""0"" (0) : ""memory""); return err; }","- ""1:""XSAVEOPT,
- ""1:""XSAVES,
+ XSAVEOPT,
+ XSAVES,","static inline int xsave_state(struct xsave_struct *fx, u64 mask) { u32 lmask = mask; u32 hmask = mask >> 32; int err = 0; alternative_input_2( ""1:""XSAVE, XSAVEOPT, X86_FEATURE_XSAVEOPT, XSAVES, X86_FEATURE_XSAVES, [fx] ""D"" (fx), ""a"" (lmask), ""d"" (hmask) : ""memory""); asm volatile(""2:\n\t"" xstate_fault : ""0"" (0) : ""memory""); return err; }"
761,2956----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/consolefs.c----_consolefs_read,"static ssize_t _consolefs_read(oe_fd_t* file_, void* buf, size_t count) { ssize_t ret = -1; file_t* file = _cast_file(file_); <S2SV_StartVul> if (!file) <S2SV_EndVul> OE_RAISE_ERRNO(OE_EINVAL); if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK) OE_RAISE_ERRNO(OE_EINVAL); done: return ret; }","- if (!file)
+ if (!file || count > OE_SSIZE_MAX)
+ if (ret > (ssize_t)count)
+ {
+ ret = -1;
+ OE_RAISE_ERRNO(OE_EINVAL);
+ }","static ssize_t _consolefs_read(oe_fd_t* file_, void* buf, size_t count) { ssize_t ret = -1; file_t* file = _cast_file(file_); if (!file || count > OE_SSIZE_MAX) OE_RAISE_ERRNO(OE_EINVAL); if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK) OE_RAISE_ERRNO(OE_EINVAL); if (ret > (ssize_t)count) { ret = -1; OE_RAISE_ERRNO(OE_EINVAL); } done: return ret; }"
762,2430----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-3232--af_netrom.c----nr_recvmsg,"static int nr_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t size, int flags) { struct sock *sk = sock->sk; struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name; size_t copied; struct sk_buff *skb; int er; lock_sock(sk); if (sk->sk_state != TCP_ESTABLISHED) { release_sock(sk); return -ENOTCONN; } if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) { release_sock(sk); return er; } skb_reset_transport_header(skb); copied = skb->len; if (copied > size) { copied = size; msg->msg_flags |= MSG_TRUNC; } er = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied); if (er < 0) { skb_free_datagram(sk, skb); release_sock(sk); return er; } if (sax != NULL) { <S2SV_StartVul> memset(sax, 0, sizeof(sax)); <S2SV_EndVul> sax->sax25_family = AF_NETROM; skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call, AX25_ADDR_LEN); } msg->msg_namelen = sizeof(*sax); skb_free_datagram(sk, skb); release_sock(sk); return copied; }","- memset(sax, 0, sizeof(sax));
+ memset(sax, 0, sizeof(*sax));","static int nr_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t size, int flags) { struct sock *sk = sock->sk; struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name; size_t copied; struct sk_buff *skb; int er; lock_sock(sk); if (sk->sk_state != TCP_ESTABLISHED) { release_sock(sk); return -ENOTCONN; } if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) { release_sock(sk); return er; } skb_reset_transport_header(skb); copied = skb->len; if (copied > size) { copied = size; msg->msg_flags |= MSG_TRUNC; } er = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied); if (er < 0) { skb_free_datagram(sk, skb); release_sock(sk); return er; } if (sax != NULL) { memset(sax, 0, sizeof(*sax)); sax->sax25_family = AF_NETROM; skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call, AX25_ADDR_LEN); } msg->msg_namelen = sizeof(*sax); skb_free_datagram(sk, skb); release_sock(sk); return copied; }"
763,6738----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiArray.c----jsi_ArrayIndexSubCmd,"static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { int istart = 0, n, i = 0, dir=1, idx=-1; Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1); Jsi_Obj *obj = _this->d.obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); if (!seq) { goto bail; } <S2SV_StartVul> n = Jsi_ObjGetLength(interp, obj); <S2SV_EndVul> if (n == 0) { goto bail; } Jsi_Number nstart; if (op == 2) { istart = n-1; } if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (op == 2) { istart = n-1; dir = -1; } Jsi_ObjListifyArray(interp, obj); for (i = istart; ; i+=dir) { if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt) break; if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) { idx = i; break; } } bail: if (op == 3) Jsi_ValueMakeBool(interp, ret, (idx!=-1)); else Jsi_ValueMakeNumber(interp, ret, idx); return JSI_OK; }","- n = Jsi_ObjGetLength(interp, obj);
+ n = jsi_SizeOfArray(interp, obj);","static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { int istart = 0, n, i = 0, dir=1, idx=-1; Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1); Jsi_Obj *obj = _this->d.obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); if (!seq) { goto bail; } n = jsi_SizeOfArray(interp, obj); if (n == 0) { goto bail; } Jsi_Number nstart; if (op == 2) { istart = n-1; } if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (op == 2) { istart = n-1; dir = -1; } Jsi_ObjListifyArray(interp, obj); for (i = istart; ; i+=dir) { if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt) break; if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) { idx = i; break; } } bail: if (op == 3) Jsi_ValueMakeBool(interp, ret, (idx!=-1)); else Jsi_ValueMakeNumber(interp, ret, idx); return JSI_OK; }"
764,1718----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10158--exif.c----exif_convert_any_to_int,"static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC) { int s_den; unsigned u_den; switch(format) { case TAG_FMT_SBYTE: return *(signed char *)value; case TAG_FMT_BYTE: return *(uchar *)value; case TAG_FMT_USHORT: return php_ifd_get16u(value, motorola_intel); case TAG_FMT_ULONG: return php_ifd_get32u(value, motorola_intel); case TAG_FMT_URATIONAL: u_den = php_ifd_get32u(4+(char *)value, motorola_intel); if (u_den == 0) { return 0; } else { return php_ifd_get32u(value, motorola_intel) / u_den; } case TAG_FMT_SRATIONAL: s_den = php_ifd_get32s(4+(char *)value, motorola_intel); if (s_den == 0) { return 0; } else { <S2SV_StartVul> return php_ifd_get32s(value, motorola_intel) / s_den; <S2SV_EndVul> } case TAG_FMT_SSHORT: return php_ifd_get16u(value, motorola_intel); case TAG_FMT_SLONG: return php_ifd_get32s(value, motorola_intel); case TAG_FMT_SINGLE: #ifdef EXIF_DEBUG php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found value of type single""); #endif return (size_t)*(float *)value; case TAG_FMT_DOUBLE: #ifdef EXIF_DEBUG php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found value of type double""); #endif return (size_t)*(double *)value; } return 0; }","- return php_ifd_get32s(value, motorola_intel) / s_den;
+ return (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den);","static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC) { int s_den; unsigned u_den; switch(format) { case TAG_FMT_SBYTE: return *(signed char *)value; case TAG_FMT_BYTE: return *(uchar *)value; case TAG_FMT_USHORT: return php_ifd_get16u(value, motorola_intel); case TAG_FMT_ULONG: return php_ifd_get32u(value, motorola_intel); case TAG_FMT_URATIONAL: u_den = php_ifd_get32u(4+(char *)value, motorola_intel); if (u_den == 0) { return 0; } else { return php_ifd_get32u(value, motorola_intel) / u_den; } case TAG_FMT_SRATIONAL: s_den = php_ifd_get32s(4+(char *)value, motorola_intel); if (s_den == 0) { return 0; } else { return (size_t)((double)php_ifd_get32s(value, motorola_intel) / s_den); } case TAG_FMT_SSHORT: return php_ifd_get16u(value, motorola_intel); case TAG_FMT_SLONG: return php_ifd_get32s(value, motorola_intel); case TAG_FMT_SINGLE: #ifdef EXIF_DEBUG php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found value of type single""); #endif return (size_t)*(float *)value; case TAG_FMT_DOUBLE: #ifdef EXIF_DEBUG php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found value of type double""); #endif return (size_t)*(double *)value; } return 0; }"
765,5971----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/HexInStream.cxx----HexInStream::HexInStream,"<S2SV_StartVul> HexInStream::HexInStream(InStream& is, int bufSize_) <S2SV_EndVul> : bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is) { ptr = end = start = new U8[bufSize]; }","- HexInStream::HexInStream(InStream& is, int bufSize_)
+ HexInStream::HexInStream(InStream& is, size_t bufSize_)","HexInStream::HexInStream(InStream& is, size_t bufSize_) : bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is) { ptr = end = start = new U8[bufSize]; }"
766,6745----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/jsiArray.c----jsi_ArraySizeOfCmd,"static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); <S2SV_StartVul> int i = Jsi_ObjGetLength(interp, _this->d.obj); <S2SV_EndVul> Jsi_ValueMakeNumber(interp, ret, i); return JSI_OK; }","- int i = Jsi_ObjGetLength(interp, _this->d.obj);
+ int i = jsi_SizeOfArray(interp, _this->d.obj);","static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); int i = jsi_SizeOfArray(interp, _this->d.obj); Jsi_ValueMakeNumber(interp, ret, i); return JSI_OK; }"
767,5447----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/marshal.c----get_object,"static pyc_object *get_object(RBuffer *buffer) { bool error = false; pyc_object *ret = NULL; ut8 code = get_ut8 (buffer, &error); bool flag = (code & FLAG_REF); RListIter *ref_idx = NULL; ut8 type = (code & ~FLAG_REF); if (error) { return NULL; } if (flag) { pyc_object *noneret = get_none_object (); if (noneret) { ref_idx = r_list_append (refs, noneret); } } switch (type) { case TYPE_NULL: free_object (ret); return NULL; case TYPE_TRUE: return get_true_object (); case TYPE_FALSE: free_object (ret); return get_false_object (); case TYPE_NONE: free_object (ret); return get_none_object (); case TYPE_REF: free_object (ret); return get_ref_object (buffer); case TYPE_SMALL_TUPLE: ret = get_small_tuple_object (buffer); break; case TYPE_TUPLE: ret = get_tuple_object (buffer); break; case TYPE_STRING: ret = get_string_object (buffer); break; case TYPE_CODE_v0: ret = get_code_object (buffer); if (ret) { ret->type = TYPE_CODE_v0; } break; case TYPE_CODE_v1: ret = get_code_object (buffer); if (ret) { ret->type = TYPE_CODE_v1; } break; case TYPE_INT: ret = get_int_object (buffer); break; case TYPE_ASCII_INTERNED: ret = get_ascii_interned_object (buffer); break; case TYPE_SHORT_ASCII: ret = get_short_ascii_object (buffer); break; case TYPE_ASCII: ret = get_ascii_object (buffer); break; case TYPE_SHORT_ASCII_INTERNED: ret = get_short_ascii_interned_object (buffer); break; case TYPE_INT64: ret = get_int64_object (buffer); break; case TYPE_INTERNED: ret = get_interned_object (buffer); break; case TYPE_STRINGREF: ret = get_stringref_object (buffer); break; case TYPE_FLOAT: ret = get_float_object (buffer); break; case TYPE_BINARY_FLOAT: ret = get_binary_float_object (buffer); break; case TYPE_COMPLEX: ret = get_complex_object (buffer); break; case TYPE_BINARY_COMPLEX: ret = get_binary_complex_object (buffer); break; case TYPE_LIST: ret = get_list_object (buffer); break; case TYPE_LONG: ret = get_long_object (buffer); break; case TYPE_UNICODE: ret = get_unicode_object (buffer); break; case TYPE_DICT: ret = get_dict_object (buffer); break; case TYPE_FROZENSET: case TYPE_SET: ret = get_set_object (buffer); break; case TYPE_STOPITER: case TYPE_ELLIPSIS: ret = R_NEW0 (pyc_object); break; case TYPE_UNKNOWN: eprintf (""Get not implemented for type 0x%x\n"", type); <S2SV_StartVul> r_list_pop (refs); <S2SV_EndVul> free_object (ret); return NULL; case 0: break; default: eprintf (""Undefined type in get_object (0x%x)\n"", type); return NULL; } if (ret && flag && ref_idx) { if (ref_idx->data != ret) { free_object (ref_idx->data); } ref_idx->data = copy_object (ret); } if (ret) { return ret; } ret = get_none_object (); if (!ret) { return NULL; } r_list_append (refs, ret); return ret; }",- r_list_pop (refs);,"static pyc_object *get_object(RBuffer *buffer) { bool error = false; pyc_object *ret = NULL; ut8 code = get_ut8 (buffer, &error); bool flag = (code & FLAG_REF); RListIter *ref_idx = NULL; ut8 type = (code & ~FLAG_REF); if (error) { return NULL; } if (flag) { pyc_object *noneret = get_none_object (); if (noneret) { ref_idx = r_list_append (refs, noneret); } } switch (type) { case TYPE_NULL: free_object (ret); return NULL; case TYPE_TRUE: return get_true_object (); case TYPE_FALSE: free_object (ret); return get_false_object (); case TYPE_NONE: free_object (ret); return get_none_object (); case TYPE_REF: free_object (ret); return get_ref_object (buffer); case TYPE_SMALL_TUPLE: ret = get_small_tuple_object (buffer); break; case TYPE_TUPLE: ret = get_tuple_object (buffer); break; case TYPE_STRING: ret = get_string_object (buffer); break; case TYPE_CODE_v0: ret = get_code_object (buffer); if (ret) { ret->type = TYPE_CODE_v0; } break; case TYPE_CODE_v1: ret = get_code_object (buffer); if (ret) { ret->type = TYPE_CODE_v1; } break; case TYPE_INT: ret = get_int_object (buffer); break; case TYPE_ASCII_INTERNED: ret = get_ascii_interned_object (buffer); break; case TYPE_SHORT_ASCII: ret = get_short_ascii_object (buffer); break; case TYPE_ASCII: ret = get_ascii_object (buffer); break; case TYPE_SHORT_ASCII_INTERNED: ret = get_short_ascii_interned_object (buffer); break; case TYPE_INT64: ret = get_int64_object (buffer); break; case TYPE_INTERNED: ret = get_interned_object (buffer); break; case TYPE_STRINGREF: ret = get_stringref_object (buffer); break; case TYPE_FLOAT: ret = get_float_object (buffer); break; case TYPE_BINARY_FLOAT: ret = get_binary_float_object (buffer); break; case TYPE_COMPLEX: ret = get_complex_object (buffer); break; case TYPE_BINARY_COMPLEX: ret = get_binary_complex_object (buffer); break; case TYPE_LIST: ret = get_list_object (buffer); break; case TYPE_LONG: ret = get_long_object (buffer); break; case TYPE_UNICODE: ret = get_unicode_object (buffer); break; case TYPE_DICT: ret = get_dict_object (buffer); break; case TYPE_FROZENSET: case TYPE_SET: ret = get_set_object (buffer); break; case TYPE_STOPITER: case TYPE_ELLIPSIS: ret = R_NEW0 (pyc_object); break; case TYPE_UNKNOWN: eprintf (""Get not implemented for type 0x%x\n"", type); free_object (ret); return NULL; case 0: break; default: eprintf (""Undefined type in get_object (0x%x)\n"", type); return NULL; } if (ret && flag && ref_idx) { if (ref_idx->data != ret) { free_object (ref_idx->data); } ref_idx->data = copy_object (ret); } if (ret) { return ret; } ret = get_none_object (); if (!ret) { return NULL; } r_list_append (refs, ret); return ret; }"
768,5004----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/host_calls.cc----enc_untrusted_read,"ssize_t enc_untrusted_read(int fd, void *buf, size_t count) { <S2SV_StartVul> return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( <S2SV_EndVul> asylo::system_call::kSYS_read, fd, buf, count)); }","- return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(
+ ssize_t ret = static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(
+ if (ret != -1 && ret > count) {
+ ::asylo::primitives::TrustedPrimitives::BestEffortAbort(
+ ""enc_untrusted_read: read result exceeds requested"");
+ }
+ return ret;","ssize_t enc_untrusted_read(int fd, void *buf, size_t count) { ssize_t ret = static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( asylo::system_call::kSYS_read, fd, buf, count)); if (ret != -1 && ret > count) { ::asylo::primitives::TrustedPrimitives::BestEffortAbort( ""enc_untrusted_read: read result exceeds requested""); } return ret; }"
769,6368----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/orders.c----update_write_cache_brush_order,"BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) { int i; BYTE iBitmapFormat; BOOL compressed = FALSE; if (!Stream_EnsureRemainingCapacity(s, update_approximate_cache_brush_order(cache_brush, flags))) return FALSE; <S2SV_StartVul> iBitmapFormat = BPP_BMF[cache_brush->bpp]; <S2SV_EndVul> Stream_Write_UINT8(s, cache_brush->index); Stream_Write_UINT8(s, iBitmapFormat); Stream_Write_UINT8(s, cache_brush->cx); Stream_Write_UINT8(s, cache_brush->cy); Stream_Write_UINT8(s, cache_brush->style); Stream_Write_UINT8(s, cache_brush->length); if ((cache_brush->cx == 8) && (cache_brush->cy == 8)) { if (cache_brush->bpp == 1) { if (cache_brush->length != 8) { WLog_ERR(TAG, ""incompatible 1bpp brush of length:%"" PRIu32 """", cache_brush->length); return FALSE; } for (i = 7; i >= 0; i--) { Stream_Write_UINT8(s, cache_brush->data[i]); } } else { if ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20)) compressed = TRUE; else if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24)) compressed = TRUE; else if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32)) compressed = TRUE; if (compressed != FALSE) { if (!update_compress_brush(s, cache_brush->data, cache_brush->bpp)) return FALSE; } else { int scanline = (cache_brush->bpp / 8) * 8; for (i = 7; i >= 0; i--) { Stream_Write(s, &cache_brush->data[i * scanline], scanline); } } } } return TRUE; }","- iBitmapFormat = BPP_BMF[cache_brush->bpp];
+ BOOL rc;
+ iBitmapFormat = get_bpp_bmf(cache_brush->bpp, &rc);
+ if (!rc)
+ return FALSE;","BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) { int i; BYTE iBitmapFormat; BOOL rc; BOOL compressed = FALSE; if (!Stream_EnsureRemainingCapacity(s, update_approximate_cache_brush_order(cache_brush, flags))) return FALSE; iBitmapFormat = get_bpp_bmf(cache_brush->bpp, &rc); if (!rc) return FALSE; Stream_Write_UINT8(s, cache_brush->index); Stream_Write_UINT8(s, iBitmapFormat); Stream_Write_UINT8(s, cache_brush->cx); Stream_Write_UINT8(s, cache_brush->cy); Stream_Write_UINT8(s, cache_brush->style); Stream_Write_UINT8(s, cache_brush->length); if ((cache_brush->cx == 8) && (cache_brush->cy == 8)) { if (cache_brush->bpp == 1) { if (cache_brush->length != 8) { WLog_ERR(TAG, ""incompatible 1bpp brush of length:%"" PRIu32 """", cache_brush->length); return FALSE; } for (i = 7; i >= 0; i--) { Stream_Write_UINT8(s, cache_brush->data[i]); } } else { if ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20)) compressed = TRUE; else if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24)) compressed = TRUE; else if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32)) compressed = TRUE; if (compressed != FALSE) { if (!update_compress_brush(s, cache_brush->data, cache_brush->bpp)) return FALSE; } else { int scanline = (cache_brush->bpp / 8) * 8; for (i = 7; i >= 0; i--) { Stream_Write(s, &cache_brush->data[i * scanline], scanline); } } } } return TRUE; }"
770,5639----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/class.c----r_bin_java_get_attr_buf,"R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) { <S2SV_StartVul> ut8 *attr_buf = NULL; <S2SV_EndVul> int pending = len - offset; const ut8 *a_buf = offset + buf; <S2SV_StartVul> attr_buf = (ut8 *) calloc (pending + 1, 1); <S2SV_EndVul> if (!attr_buf) { eprintf (""Unable to allocate enough bytes (0x%04""PFMT64x "") to read in the attribute.\n"", sz); return attr_buf; } memcpy (attr_buf, a_buf, pending); return attr_buf; }","- ut8 *attr_buf = NULL;
- attr_buf = (ut8 *) calloc (pending + 1, 1);
+ ut8 *attr_buf = (ut8 *) calloc (pending + 1, 1);","R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) { int pending = len - offset; const ut8 *a_buf = offset + buf; ut8 *attr_buf = (ut8 *) calloc (pending + 1, 1); if (!attr_buf) { eprintf (""Unable to allocate enough bytes (0x%04""PFMT64x "") to read in the attribute.\n"", sz); return attr_buf; } memcpy (attr_buf, a_buf, pending); return attr_buf; }"
771,3963----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tcp_ipv4.c----tcp_v4_connect,"int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len) { struct sockaddr_in *usin = (struct sockaddr_in *)uaddr; struct inet_sock *inet = inet_sk(sk); struct tcp_sock *tp = tcp_sk(sk); __be16 orig_sport, orig_dport; __be32 daddr, nexthop; struct flowi4 fl4; struct rtable *rt; int err; if (addr_len < sizeof(struct sockaddr_in)) return -EINVAL; if (usin->sin_family != AF_INET) return -EAFNOSUPPORT; nexthop = daddr = usin->sin_addr.s_addr; <S2SV_StartVul> if (inet->opt && inet->opt->srr) { <S2SV_EndVul> if (!daddr) return -EINVAL; <S2SV_StartVul> nexthop = inet->opt->faddr; <S2SV_EndVul> } orig_sport = inet->inet_sport; orig_dport = usin->sin_port; rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if, IPPROTO_TCP, orig_sport, orig_dport, sk, true); if (IS_ERR(rt)) { err = PTR_ERR(rt); if (err == -ENETUNREACH) IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES); return err; } if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) { ip_rt_put(rt); return -ENETUNREACH; } <S2SV_StartVul> if (!inet->opt || !inet->opt->srr) <S2SV_EndVul> daddr = rt->rt_dst; if (!inet->inet_saddr) inet->inet_saddr = rt->rt_src; inet->inet_rcv_saddr = inet->inet_saddr; if (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) { tp->rx_opt.ts_recent = 0; tp->rx_opt.ts_recent_stamp = 0; tp->write_seq = 0; } if (tcp_death_row.sysctl_tw_recycle && !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) { struct inet_peer *peer = rt_get_peer(rt); if (peer) { inet_peer_refcheck(peer); if ((u32)get_seconds() - peer->tcp_ts_stamp <= TCP_PAWS_MSL) { tp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp; tp->rx_opt.ts_recent = peer->tcp_ts; } } } inet->inet_dport = usin->sin_port; inet->inet_daddr = daddr; inet_csk(sk)->icsk_ext_hdr_len = 0; <S2SV_StartVul> if (inet->opt) <S2SV_EndVul> <S2SV_StartVul> inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen; <S2SV_EndVul> tp->rx_opt.mss_clamp = TCP_MSS_DEFAULT; tcp_set_state(sk, TCP_SYN_SENT); err = inet_hash_connect(&tcp_death_row, sk); if (err) goto failure; rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport, inet->inet_sport, inet->inet_dport, sk); if (IS_ERR(rt)) { err = PTR_ERR(rt); rt = NULL; goto failure; } sk->sk_gso_type = SKB_GSO_TCPV4; sk_setup_caps(sk, &rt->dst); if (!tp->write_seq) tp->write_seq = secure_tcp_sequence_number(inet->inet_saddr, inet->inet_daddr, inet->inet_sport, usin->sin_port); inet->inet_id = tp->write_seq ^ jiffies; err = tcp_connect(sk); rt = NULL; if (err) goto failure; return 0; failure: tcp_set_state(sk, TCP_CLOSE); ip_rt_put(rt); sk->sk_route_caps = 0; inet->inet_dport = 0; return err; }","- if (inet->opt && inet->opt->srr) {
- nexthop = inet->opt->faddr;
- if (!inet->opt || !inet->opt->srr)
- if (inet->opt)
- inet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;
+ struct ip_options_rcu *inet_opt;
+ inet_opt = rcu_dereference_protected(inet->inet_opt,
+ sock_owned_by_user(sk));
+ if (inet_opt && inet_opt->opt.srr) {
+ nexthop = inet_opt->opt.faddr;
+ if (!inet_opt || !inet_opt->opt.srr)
+ if (inet_opt)
+ inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;","int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len) { struct sockaddr_in *usin = (struct sockaddr_in *)uaddr; struct inet_sock *inet = inet_sk(sk); struct tcp_sock *tp = tcp_sk(sk); __be16 orig_sport, orig_dport; __be32 daddr, nexthop; struct flowi4 fl4; struct rtable *rt; int err; struct ip_options_rcu *inet_opt; if (addr_len < sizeof(struct sockaddr_in)) return -EINVAL; if (usin->sin_family != AF_INET) return -EAFNOSUPPORT; nexthop = daddr = usin->sin_addr.s_addr; inet_opt = rcu_dereference_protected(inet->inet_opt, sock_owned_by_user(sk)); if (inet_opt && inet_opt->opt.srr) { if (!daddr) return -EINVAL; nexthop = inet_opt->opt.faddr; } orig_sport = inet->inet_sport; orig_dport = usin->sin_port; rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if, IPPROTO_TCP, orig_sport, orig_dport, sk, true); if (IS_ERR(rt)) { err = PTR_ERR(rt); if (err == -ENETUNREACH) IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES); return err; } if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) { ip_rt_put(rt); return -ENETUNREACH; } if (!inet_opt || !inet_opt->opt.srr) daddr = rt->rt_dst; if (!inet->inet_saddr) inet->inet_saddr = rt->rt_src; inet->inet_rcv_saddr = inet->inet_saddr; if (tp->rx_opt.ts_recent_stamp && inet->inet_daddr != daddr) { tp->rx_opt.ts_recent = 0; tp->rx_opt.ts_recent_stamp = 0; tp->write_seq = 0; } if (tcp_death_row.sysctl_tw_recycle && !tp->rx_opt.ts_recent_stamp && rt->rt_dst == daddr) { struct inet_peer *peer = rt_get_peer(rt); if (peer) { inet_peer_refcheck(peer); if ((u32)get_seconds() - peer->tcp_ts_stamp <= TCP_PAWS_MSL) { tp->rx_opt.ts_recent_stamp = peer->tcp_ts_stamp; tp->rx_opt.ts_recent = peer->tcp_ts; } } } inet->inet_dport = usin->sin_port; inet->inet_daddr = daddr; inet_csk(sk)->icsk_ext_hdr_len = 0; if (inet_opt) inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen; tp->rx_opt.mss_clamp = TCP_MSS_DEFAULT; tcp_set_state(sk, TCP_SYN_SENT); err = inet_hash_connect(&tcp_death_row, sk); if (err) goto failure; rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport, inet->inet_sport, inet->inet_dport, sk); if (IS_ERR(rt)) { err = PTR_ERR(rt); rt = NULL; goto failure; } sk->sk_gso_type = SKB_GSO_TCPV4; sk_setup_caps(sk, &rt->dst); if (!tp->write_seq) tp->write_seq = secure_tcp_sequence_number(inet->inet_saddr, inet->inet_daddr, inet->inet_sport, usin->sin_port); inet->inet_id = tp->write_seq ^ jiffies; err = tcp_connect(sk); rt = NULL; if (err) goto failure; return 0; failure: tcp_set_state(sk, TCP_CLOSE); ip_rt_put(rt); sk->sk_route_caps = 0; inet->inet_dport = 0; return err; }"
772,5261----CWE-59----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/archive_disk_acl_linux.c----set_acl,"set_acl(struct archive *a, int fd, const char *name, <S2SV_StartVul> struct archive_acl *abstract_acl, <S2SV_EndVul> int ae_requested_type, const char *tname) { int acl_type = 0; int ae_type, ae_permset, ae_tag, ae_id; uid_t ae_uid; gid_t ae_gid; const char *ae_name; int entries; int i; int ret; acl_t acl = NULL; acl_entry_t acl_entry; acl_permset_t acl_permset; ret = ARCHIVE_OK; entries = archive_acl_reset(abstract_acl, ae_requested_type); if (entries == 0) return (ARCHIVE_OK); switch (ae_requested_type) { case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: acl_type = ACL_TYPE_ACCESS; break; case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: acl_type = ACL_TYPE_DEFAULT; break; default: errno = ENOENT; archive_set_error(a, errno, ""Unsupported ACL type""); return (ARCHIVE_FAILED); } acl = acl_init(entries); if (acl == (acl_t)NULL) { archive_set_error(a, errno, ""Failed to initialize ACL working storage""); return (ARCHIVE_FAILED); } while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type, &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) { if (acl_create_entry(&acl, &acl_entry) != 0) { archive_set_error(a, errno, ""Failed to create a new ACL entry""); ret = ARCHIVE_FAILED; goto exit_free; } switch (ae_tag) { case ARCHIVE_ENTRY_ACL_USER: ae_uid = archive_write_disk_uid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_USER); acl_set_qualifier(acl_entry, &ae_uid); break; case ARCHIVE_ENTRY_ACL_GROUP: ae_gid = archive_write_disk_gid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_GROUP); acl_set_qualifier(acl_entry, &ae_gid); break; case ARCHIVE_ENTRY_ACL_USER_OBJ: acl_set_tag_type(acl_entry, ACL_USER_OBJ); break; case ARCHIVE_ENTRY_ACL_GROUP_OBJ: acl_set_tag_type(acl_entry, ACL_GROUP_OBJ); break; case ARCHIVE_ENTRY_ACL_MASK: acl_set_tag_type(acl_entry, ACL_MASK); break; case ARCHIVE_ENTRY_ACL_OTHER: acl_set_tag_type(acl_entry, ACL_OTHER); break; default: archive_set_error(a, ARCHIVE_ERRNO_MISC, ""Unsupported ACL tag""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_get_permset(acl_entry, &acl_permset) != 0) { archive_set_error(a, errno, ""Failed to get ACL permission set""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_clear_perms(acl_permset) != 0) { archive_set_error(a, errno, ""Failed to clear ACL permissions""); ret = ARCHIVE_FAILED; goto exit_free; } for (i = 0; i < acl_posix_perm_map_size; ++i) { if (ae_permset & acl_posix_perm_map[i].a_perm) { if (acl_add_perm(acl_permset, acl_posix_perm_map[i].p_perm) != 0) { archive_set_error(a, errno, ""Failed to add ACL permission""); ret = ARCHIVE_FAILED; goto exit_free; } } } } if (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) { if (acl_set_fd(fd, acl) == 0) ret = ARCHIVE_OK; else { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl on fd: %s"", tname); ret = ARCHIVE_WARN; } } } else if (acl_set_file(name, acl_type, acl) != 0) { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl: %s"", tname); ret = ARCHIVE_WARN; } } exit_free: acl_free(acl); return (ret); }","- struct archive_acl *abstract_acl,
+ struct archive_acl *abstract_acl, __LA_MODE_T mode,
+ if (S_ISLNK(mode)) {
+ return (ARCHIVE_OK);
+ }
+ if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {
+ errno = EINVAL;
+ archive_set_error(a, errno,
+ ""Cannot set default ACL on non-directory"");
+ return (ARCHIVE_WARN);
+ }","set_acl(struct archive *a, int fd, const char *name, struct archive_acl *abstract_acl, __LA_MODE_T mode, int ae_requested_type, const char *tname) { int acl_type = 0; int ae_type, ae_permset, ae_tag, ae_id; uid_t ae_uid; gid_t ae_gid; const char *ae_name; int entries; int i; int ret; acl_t acl = NULL; acl_entry_t acl_entry; acl_permset_t acl_permset; ret = ARCHIVE_OK; entries = archive_acl_reset(abstract_acl, ae_requested_type); if (entries == 0) return (ARCHIVE_OK); switch (ae_requested_type) { case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: acl_type = ACL_TYPE_ACCESS; break; case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: acl_type = ACL_TYPE_DEFAULT; break; default: errno = ENOENT; archive_set_error(a, errno, ""Unsupported ACL type""); return (ARCHIVE_FAILED); } if (S_ISLNK(mode)) { return (ARCHIVE_OK); } if (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) { errno = EINVAL; archive_set_error(a, errno, ""Cannot set default ACL on non-directory""); return (ARCHIVE_WARN); } acl = acl_init(entries); if (acl == (acl_t)NULL) { archive_set_error(a, errno, ""Failed to initialize ACL working storage""); return (ARCHIVE_FAILED); } while (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type, &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) { if (acl_create_entry(&acl, &acl_entry) != 0) { archive_set_error(a, errno, ""Failed to create a new ACL entry""); ret = ARCHIVE_FAILED; goto exit_free; } switch (ae_tag) { case ARCHIVE_ENTRY_ACL_USER: ae_uid = archive_write_disk_uid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_USER); acl_set_qualifier(acl_entry, &ae_uid); break; case ARCHIVE_ENTRY_ACL_GROUP: ae_gid = archive_write_disk_gid(a, ae_name, ae_id); acl_set_tag_type(acl_entry, ACL_GROUP); acl_set_qualifier(acl_entry, &ae_gid); break; case ARCHIVE_ENTRY_ACL_USER_OBJ: acl_set_tag_type(acl_entry, ACL_USER_OBJ); break; case ARCHIVE_ENTRY_ACL_GROUP_OBJ: acl_set_tag_type(acl_entry, ACL_GROUP_OBJ); break; case ARCHIVE_ENTRY_ACL_MASK: acl_set_tag_type(acl_entry, ACL_MASK); break; case ARCHIVE_ENTRY_ACL_OTHER: acl_set_tag_type(acl_entry, ACL_OTHER); break; default: archive_set_error(a, ARCHIVE_ERRNO_MISC, ""Unsupported ACL tag""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_get_permset(acl_entry, &acl_permset) != 0) { archive_set_error(a, errno, ""Failed to get ACL permission set""); ret = ARCHIVE_FAILED; goto exit_free; } if (acl_clear_perms(acl_permset) != 0) { archive_set_error(a, errno, ""Failed to clear ACL permissions""); ret = ARCHIVE_FAILED; goto exit_free; } for (i = 0; i < acl_posix_perm_map_size; ++i) { if (ae_permset & acl_posix_perm_map[i].a_perm) { if (acl_add_perm(acl_permset, acl_posix_perm_map[i].p_perm) != 0) { archive_set_error(a, errno, ""Failed to add ACL permission""); ret = ARCHIVE_FAILED; goto exit_free; } } } } if (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) { if (acl_set_fd(fd, acl) == 0) ret = ARCHIVE_OK; else { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl on fd: %s"", tname); ret = ARCHIVE_WARN; } } } else if (acl_set_file(name, acl_type, acl) != 0) { if (errno == EOPNOTSUPP) { ret = ARCHIVE_OK; } else { archive_set_error(a, errno, ""Failed to set acl: %s"", tname); ret = ARCHIVE_WARN; } } exit_free: acl_free(acl); return (ret); }"
773,830----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-2694--main.c----otp_verify,"otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request, krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *pa, krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock, krb5_kdcpreauth_moddata moddata, krb5_kdcpreauth_verify_respond_fn respond, void *arg) { krb5_keyblock *armor_key = NULL; krb5_pa_otp_req *req = NULL; struct request_state *rs; krb5_error_code retval; krb5_data d, plaintext; char *config; <S2SV_StartVul> enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH; <S2SV_EndVul> armor_key = cb->fast_armor(context, rock); if (armor_key == NULL) { retval = KRB5KDC_ERR_PREAUTH_FAILED; com_err(""otp"", retval, ""No armor key found when verifying padata""); goto error; } d = make_data(pa->contents, pa->length); retval = decode_krb5_pa_otp_req(&d, &req); if (retval != 0) { com_err(""otp"", retval, ""Unable to decode OTP request""); goto error; } retval = decrypt_encdata(context, armor_key, req, &plaintext); if (retval != 0) { com_err(""otp"", retval, ""Unable to decrypt nonce""); goto error; } retval = nonce_verify(context, armor_key, &plaintext); if (retval != 0) retval = timestamp_verify(context, &plaintext); krb5_free_data_contents(context, &plaintext); if (retval != 0) { com_err(""otp"", retval, ""Unable to verify nonce or timestamp""); goto error; } rs = k5alloc(sizeof(struct request_state), &retval); if (rs == NULL) goto error; rs->arg = arg; rs->respond = respond; retval = cb->get_string(context, rock, ""otp"", &config); if (retval == 0 && config == NULL) retval = KRB5_PREAUTH_FAILED; if (retval != 0) { free(rs); goto error; } otp_state_verify((otp_state *)moddata, cb->event_context(context, rock), request->client, config, req, on_response, rs); cb->free_string(context, rock, config); k5_free_pa_otp_req(context, req); return; error: k5_free_pa_otp_req(context, req); (*respond)(arg, retval, NULL, NULL, NULL); }","- enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
+ rs->enc_tkt_reply = enc_tkt_reply;","otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request, krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *pa, krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock, krb5_kdcpreauth_moddata moddata, krb5_kdcpreauth_verify_respond_fn respond, void *arg) { krb5_keyblock *armor_key = NULL; krb5_pa_otp_req *req = NULL; struct request_state *rs; krb5_error_code retval; krb5_data d, plaintext; char *config; armor_key = cb->fast_armor(context, rock); if (armor_key == NULL) { retval = KRB5KDC_ERR_PREAUTH_FAILED; com_err(""otp"", retval, ""No armor key found when verifying padata""); goto error; } d = make_data(pa->contents, pa->length); retval = decode_krb5_pa_otp_req(&d, &req); if (retval != 0) { com_err(""otp"", retval, ""Unable to decode OTP request""); goto error; } retval = decrypt_encdata(context, armor_key, req, &plaintext); if (retval != 0) { com_err(""otp"", retval, ""Unable to decrypt nonce""); goto error; } retval = nonce_verify(context, armor_key, &plaintext); if (retval != 0) retval = timestamp_verify(context, &plaintext); krb5_free_data_contents(context, &plaintext); if (retval != 0) { com_err(""otp"", retval, ""Unable to verify nonce or timestamp""); goto error; } rs = k5alloc(sizeof(struct request_state), &retval); if (rs == NULL) goto error; rs->arg = arg; rs->respond = respond; rs->enc_tkt_reply = enc_tkt_reply; retval = cb->get_string(context, rock, ""otp"", &config); if (retval == 0 && config == NULL) retval = KRB5_PREAUTH_FAILED; if (retval != 0) { free(rs); goto error; } otp_state_verify((otp_state *)moddata, cb->event_context(context, rock), request->client, config, req, on_response, rs); cb->free_string(context, rock, config); k5_free_pa_otp_req(context, req); return; error: k5_free_pa_otp_req(context, req); (*respond)(arg, retval, NULL, NULL, NULL); }"
774,6513----CWE-494----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/pki.c----ValidateSignature,"LONG ValidateSignature(HWND hDlg, const char* path) { LONG r; WINTRUST_DATA trust_data = { 0 }; WINTRUST_FILE_INFO trust_file = { 0 }; GUID guid_generic_verify = { 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } }; char *signature_name; size_t i, len; signature_name = GetSignatureName(path); if (signature_name == NULL) { uprintf(""PKI: Could not get signature name""); MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid); return TRUST_E_NOSIGNATURE; } for (i = 0; i < ARRAYSIZE(cert_name); i++) { len = strlen(cert_name[i]); if (strncmp(signature_name, cert_name[i], len) == 0) { if ((len >= strlen(signature_name)) || isspace(signature_name[len])) break; } } if (i >= ARRAYSIZE(cert_name)) { uprintf(""PKI: Signature '%s' is unexpected..."", signature_name); if (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283), MB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES) return TRUST_E_EXPLICIT_DISTRUST; } trust_file.cbStruct = sizeof(trust_file); trust_file.pcwszFilePath = utf8_to_wchar(path); if (trust_file.pcwszFilePath == NULL) { uprintf(""PKI: Unable to convert '%s' to UTF16"", path); return ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY; } trust_data.cbStruct = sizeof(trust_data); <S2SV_StartVul> trust_data.dwUIChoice = WTD_UI_ALL; <S2SV_EndVul> trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN; trust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400; trust_data.dwUnionChoice = WTD_CHOICE_FILE; trust_data.pFile = &trust_file; r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data); safe_free(trust_file.pcwszFilePath); return r; }","- trust_data.dwUIChoice = WTD_UI_ALL;
+ trust_data.dwUIChoice = WTD_UI_NONE;
+ switch (r) {
+ case ERROR_SUCCESS:
+ break;
+ case TRUST_E_NOSIGNATURE:
+ uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString());
+ MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
+ break;
+ default:
+ uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString());
+ MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);
+ break;
+ }","LONG ValidateSignature(HWND hDlg, const char* path) { LONG r; WINTRUST_DATA trust_data = { 0 }; WINTRUST_FILE_INFO trust_file = { 0 }; GUID guid_generic_verify = { 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } }; char *signature_name; size_t i, len; signature_name = GetSignatureName(path); if (signature_name == NULL) { uprintf(""PKI: Could not get signature name""); MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid); return TRUST_E_NOSIGNATURE; } for (i = 0; i < ARRAYSIZE(cert_name); i++) { len = strlen(cert_name[i]); if (strncmp(signature_name, cert_name[i], len) == 0) { if ((len >= strlen(signature_name)) || isspace(signature_name[len])) break; } } if (i >= ARRAYSIZE(cert_name)) { uprintf(""PKI: Signature '%s' is unexpected..."", signature_name); if (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283), MB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES) return TRUST_E_EXPLICIT_DISTRUST; } trust_file.cbStruct = sizeof(trust_file); trust_file.pcwszFilePath = utf8_to_wchar(path); if (trust_file.pcwszFilePath == NULL) { uprintf(""PKI: Unable to convert '%s' to UTF16"", path); return ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY; } trust_data.cbStruct = sizeof(trust_data); trust_data.dwUIChoice = WTD_UI_NONE; trust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN; trust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400; trust_data.dwUnionChoice = WTD_CHOICE_FILE; trust_data.pFile = &trust_file; r = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data); safe_free(trust_file.pcwszFilePath); switch (r) { case ERROR_SUCCESS: break; case TRUST_E_NOSIGNATURE: uprintf(""PKI: File does not appear to be signed: %s"", WinPKIErrorString()); MessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid); break; default: uprintf(""PKI: Failed to validate signature: %s"", WinPKIErrorString()); MessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid); break; } return r; }"
775,5117----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/wpg.c----InsertRow,"static void InsertRow(Image *image,unsigned char *p,ssize_t y,int bpp, ExceptionInfo *exception) { int bit; Quantum index; register Quantum *q; ssize_t x; switch (bpp) { case 1: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-7); x+=8) { for (bit=0; bit < 8; bit++) { index=((*p) & (0x80 >> bit) ? 0x01 : 0x00); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } p++; } if ((image->columns % 8) != 0) { for (bit=0; bit < (ssize_t) (image->columns % 8); bit++) { index=((*p) & (0x80 >> bit) ? 0x01 : 0x00); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } p++; } if (!SyncAuthenticPixels(image,exception)) break; break; } case 2: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; <S2SV_StartVul> for (x=0; x < ((ssize_t) image->columns-1); x+=2) <S2SV_EndVul> { index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if ((image->columns % 4) != 0) { index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); if ((image->columns % 4) >= 1) { index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); if ((image->columns % 4) >= 2) { index=ConstrainColormapIndex(image,(*p >> 2) & 0x3, exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } } p++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; break; } case 4: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-1); x+=2) { index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p) & 0x0f,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if ((image->columns % 2) != 0) { index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; break; } case 8: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { index=ConstrainColormapIndex(image,*p,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } break; case 24: q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelBlue(image,ScaleCharToQuantum(*p++),q); q+=GetPixelChannels(image); } if (!SyncAuthenticPixels(image,exception)) break; break; } }","- for (x=0; x < ((ssize_t) image->columns-1); x+=2)
+ for (x=0; x < ((ssize_t) image->columns-1); x+=4)","static void InsertRow(Image *image,unsigned char *p,ssize_t y,int bpp, ExceptionInfo *exception) { int bit; Quantum index; register Quantum *q; ssize_t x; switch (bpp) { case 1: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-7); x+=8) { for (bit=0; bit < 8; bit++) { index=((*p) & (0x80 >> bit) ? 0x01 : 0x00); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } p++; } if ((image->columns % 8) != 0) { for (bit=0; bit < (ssize_t) (image->columns % 8); bit++) { index=((*p) & (0x80 >> bit) ? 0x01 : 0x00); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } p++; } if (!SyncAuthenticPixels(image,exception)) break; break; } case 2: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-1); x+=4) { index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p >> 2) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if ((image->columns % 4) != 0) { index=ConstrainColormapIndex(image,(*p >> 6) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); if ((image->columns % 4) >= 1) { index=ConstrainColormapIndex(image,(*p >> 4) & 0x3,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); if ((image->columns % 4) >= 2) { index=ConstrainColormapIndex(image,(*p >> 2) & 0x3, exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); } } p++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; break; } case 4: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-1); x+=2) { index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,(*p) & 0x0f,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if ((image->columns % 2) != 0) { index=ConstrainColormapIndex(image,(*p >> 4) & 0x0f,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; break; } case 8: { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { index=ConstrainColormapIndex(image,*p,exception); SetPixelIndex(image,index,q); SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q); p++; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } break; case 24: q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelBlue(image,ScaleCharToQuantum(*p++),q); q+=GetPixelChannels(image); } if (!SyncAuthenticPixels(image,exception)) break; break; } }"
776,274----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2127--root.c----proc_root_init,"void __init proc_root_init(void) { <S2SV_StartVul> struct vfsmount *mnt; <S2SV_EndVul> int err; proc_init_inodecache(); err = register_filesystem(&proc_fs_type); if (err) return; <S2SV_StartVul> mnt = kern_mount_data(&proc_fs_type, &init_pid_ns); <S2SV_EndVul> <S2SV_StartVul> if (IS_ERR(mnt)) { <S2SV_EndVul> unregister_filesystem(&proc_fs_type); return; } <S2SV_StartVul> init_pid_ns.proc_mnt = mnt; <S2SV_EndVul> proc_symlink(""mounts"", NULL, ""self/mounts""); proc_net_init(); #ifdef CONFIG_SYSVIPC proc_mkdir(""sysvipc"", NULL); #endif proc_mkdir(""fs"", NULL); proc_mkdir(""driver"", NULL); proc_mkdir(""fs/nfsd"", NULL); #if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE) proc_mkdir(""openprom"", NULL); #endif proc_tty_init(); #ifdef CONFIG_PROC_DEVICETREE proc_device_tree_init(); #endif proc_mkdir(""bus"", NULL); proc_sys_init(); }","- struct vfsmount *mnt;
- mnt = kern_mount_data(&proc_fs_type, &init_pid_ns);
- if (IS_ERR(mnt)) {
- init_pid_ns.proc_mnt = mnt;
+ err = pid_ns_prepare_proc(&init_pid_ns);
+ if (err) {","void __init proc_root_init(void) { int err; proc_init_inodecache(); err = register_filesystem(&proc_fs_type); if (err) return; err = pid_ns_prepare_proc(&init_pid_ns); if (err) { unregister_filesystem(&proc_fs_type); return; } proc_symlink(""mounts"", NULL, ""self/mounts""); proc_net_init(); #ifdef CONFIG_SYSVIPC proc_mkdir(""sysvipc"", NULL); #endif proc_mkdir(""fs"", NULL); proc_mkdir(""driver"", NULL); proc_mkdir(""fs/nfsd"", NULL); #if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE) proc_mkdir(""openprom"", NULL); #endif proc_tty_init(); #ifdef CONFIG_PROC_DEVICETREE proc_device_tree_init(); #endif proc_mkdir(""bus"", NULL); proc_sys_init(); }"
777,3031----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/secure_enclave.c----trustedDkgVerifyAES,"void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share, uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) { LOG_INFO(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(public_shares); CHECK_STATE(s_share); CHECK_STATE(encryptedPrivateKey); <S2SV_StartVul> SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN); <S2SV_EndVul> mpz_t s; mpz_init(s); <S2SV_StartVul> int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN); <S2SV_EndVul> CHECK_STATUS2(""AES_decrypt failed (in trustedDkgVerifyAES) with status %d""); <S2SV_StartVul> SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN); <S2SV_EndVul> strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1); <S2SV_StartVul> SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN); <S2SV_EndVul> status = session_key_recover(skey, s_share, common_key); CHECK_STATUS(""session_key_recover failed""); <S2SV_StartVul> SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN); <S2SV_EndVul> status=xor_decrypt(common_key, encr_sshare, decr_sshare); CHECK_STATUS(""xor_decrypt failed"") status = mpz_set_str(s, decr_sshare, 16); CHECK_STATUS(""invalid decr secret share""); *result = Verification(public_shares, s, _t, _ind); SET_SUCCESS clean: mpz_clear(s); LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }","- SAFE_CHAR_BUF(skey, ECDSA_SKEY_LEN);
- int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, ECDSA_SKEY_LEN);
- SAFE_CHAR_BUF(encr_sshare, ECDSA_SKEY_LEN);
- SAFE_CHAR_BUF(common_key, ECDSA_SKEY_LEN);
- SAFE_CHAR_BUF(decr_sshare, ECDSA_SKEY_LEN);
+ SAFE_CHAR_BUF(skey,BUF_LEN);
+ int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN);
+ SAFE_CHAR_BUF(encr_sshare, BUF_LEN);
+ SAFE_CHAR_BUF(common_key, BUF_LEN);
+ SAFE_CHAR_BUF(decr_sshare, BUF_LEN);","void trustedDkgVerifyAES(int *errStatus, char *errString, const char *public_shares, const char *s_share, uint8_t *encryptedPrivateKey, uint64_t enc_len, unsigned _t, int _ind, int *result) { LOG_INFO(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(public_shares); CHECK_STATE(s_share); CHECK_STATE(encryptedPrivateKey); SAFE_CHAR_BUF(skey,BUF_LEN); mpz_t s; mpz_init(s); int status = AES_decrypt(encryptedPrivateKey, enc_len, skey, BUF_LEN); CHECK_STATUS2(""AES_decrypt failed (in trustedDkgVerifyAES) with status %d""); SAFE_CHAR_BUF(encr_sshare, BUF_LEN); strncpy(encr_sshare, s_share, ECDSA_SKEY_LEN - 1); SAFE_CHAR_BUF(common_key, BUF_LEN); status = session_key_recover(skey, s_share, common_key); CHECK_STATUS(""session_key_recover failed""); SAFE_CHAR_BUF(decr_sshare, BUF_LEN); status=xor_decrypt(common_key, encr_sshare, decr_sshare); CHECK_STATUS(""xor_decrypt failed"") status = mpz_set_str(s, decr_sshare, 16); CHECK_STATUS(""invalid decr secret share""); *result = Verification(public_shares, s, _t, _ind); SET_SUCCESS clean: mpz_clear(s); LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }"
778,137----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2008-1950--ext_server_name.c----_gnutls_server_name_recv_params,"_gnutls_server_name_recv_params (gnutls_session_t session, const opaque * data, size_t _data_size) { int i; const unsigned char *p; uint16_t len, type; ssize_t data_size = _data_size; int server_names = 0; if (session->security_parameters.entity == GNUTLS_SERVER) { DECR_LENGTH_RET (data_size, 2, 0); len = _gnutls_read_uint16 (data); if (len != data_size) { gnutls_assert (); return 0; } p = data + 2; while (data_size > 0) { DECR_LENGTH_RET (data_size, 1, 0); p++; DECR_LEN (data_size, 2); len = _gnutls_read_uint16 (p); p += 2; <S2SV_StartVul> DECR_LENGTH_RET (data_size, len, 0); <S2SV_EndVul> <S2SV_StartVul> server_names++; <S2SV_EndVul> <S2SV_StartVul> p += len; <S2SV_EndVul> } session->security_parameters.extensions.server_names_size = if (server_names == 0) return 0; <S2SV_EndVul> <S2SV_StartVul> if (server_names > MAX_SERVER_NAME_EXTENSIONS) <S2SV_EndVul> <S2SV_StartVul> server_names = MAX_SERVER_NAME_EXTENSIONS; <S2SV_EndVul> p = data + 2; for (i = 0; i < server_names; i++) server_names[i].name, p, len); session->security_parameters.extensions. server_names[i].name_length = len; session->security_parameters.extensions. server_names[i].type = GNUTLS_NAME_DNS; break; } }","- DECR_LENGTH_RET (data_size, len, 0);
- server_names++;
- p += len;
- if (server_names > MAX_SERVER_NAME_EXTENSIONS)
- server_names = MAX_SERVER_NAME_EXTENSIONS;
+ if (len > 0)
+ {
+ DECR_LENGTH_RET (data_size, len, 0);
+ server_names++;
+ p += len;
+ }
+ else
+ _gnutls_handshake_log
+ (""HSK[%x]: Received zero size server name (under attack?)\n"",
+ session);
+ }
+ if (server_names > MAX_SERVER_NAME_EXTENSIONS)
+ {
+ _gnutls_handshake_log
+ (""HSK[%x]: Too many server names received (under attack?)\n"",
+ session);
+ server_names = MAX_SERVER_NAME_EXTENSIONS;","_gnutls_server_name_recv_params (gnutls_session_t session, const opaque * data, size_t _data_size) { int i; const unsigned char *p; uint16_t len, type; ssize_t data_size = _data_size; int server_names = 0; if (session->security_parameters.entity == GNUTLS_SERVER) { DECR_LENGTH_RET (data_size, 2, 0); len = _gnutls_read_uint16 (data); if (len != data_size) { gnutls_assert (); return 0; } p = data + 2; while (data_size > 0) { DECR_LENGTH_RET (data_size, 1, 0); p++; DECR_LEN (data_size, 2); len = _gnutls_read_uint16 (p); p += 2; if (len > 0) { DECR_LENGTH_RET (data_size, len, 0); server_names++; p += len; } else _gnutls_handshake_log (""HSK[%x]: Received zero size server name (under attack?)\n"", session); } if (server_names > MAX_SERVER_NAME_EXTENSIONS) { _gnutls_handshake_log (""HSK[%x]: Too many server names received (under attack?)\n"", session); server_names = MAX_SERVER_NAME_EXTENSIONS; } session->security_parameters.extensions.server_names_size = if (server_names == 0) return 0; p = data + 2; for (i = 0; i < server_names; i++) server_names[i].name, p, len); session->security_parameters.extensions. server_names[i].name_length = len; session->security_parameters.extensions. server_names[i].type = GNUTLS_NAME_DNS; break; } }"
779,6988----CWE-434----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nodemanip.cpp----preprocessNodes,"void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext) { std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x) { if(ext.remove_emoji) x.Remark = trim(removeEmoji(x.Remark)); nodeRename(x, ext.rename_array, ext); if(ext.add_emoji) x.Remark = addEmoji(x, ext.emoji_array, ext); }); if(ext.sort_flag) { bool failed = true; <S2SV_StartVul> if(ext.sort_script.size()) <S2SV_EndVul> { std::string script = ext.sort_script; if(startsWith(script, ""path:"")) script = fileGet(script.substr(5), false); script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx) { try { ctx.eval(script); auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(""compare""); auto comparer = [&](const Proxy &a, const Proxy &b) { if(a.Type == ProxyType::Unknow) return 1; if(b.Type == ProxyType::Unknow) return 0; return compare(a, b); }; std::stable_sort(nodes.begin(), nodes.end(), comparer); failed = false; } catch(qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b) { return a.Remark < b.Remark; }); } }","- if(ext.sort_script.size())
+ if(ext.sort_script.size() && ext.authorized)","void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext) { std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x) { if(ext.remove_emoji) x.Remark = trim(removeEmoji(x.Remark)); nodeRename(x, ext.rename_array, ext); if(ext.add_emoji) x.Remark = addEmoji(x, ext.emoji_array, ext); }); if(ext.sort_flag) { bool failed = true; if(ext.sort_script.size() && ext.authorized) { std::string script = ext.sort_script; if(startsWith(script, ""path:"")) script = fileGet(script.substr(5), false); script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx) { try { ctx.eval(script); auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(""compare""); auto comparer = [&](const Proxy &a, const Proxy &b) { if(a.Type == ProxyType::Unknow) return 1; if(b.Type == ProxyType::Unknow) return 0; return compare(a, b); }; std::stable_sort(nodes.begin(), nodes.end(), comparer); failed = false; } catch(qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b) { return a.Remark < b.Remark; }); } }"
780,423----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4470--ip_output.c----ip_ufo_append_data,"static inline int ip_ufo_append_data(struct sock *sk, struct sk_buff_head *queue, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int hh_len, int fragheaderlen, int transhdrlen, int maxfraglen, unsigned int flags) { struct sk_buff *skb; int err; if ((skb = skb_peek_tail(queue)) == NULL) { skb = sock_alloc_send_skb(sk, hh_len + fragheaderlen + transhdrlen + 20, (flags & MSG_DONTWAIT), &err); if (skb == NULL) return err; skb_reserve(skb, hh_len); skb_put(skb, fragheaderlen + transhdrlen); skb_reset_network_header(skb); skb->transport_header = skb->network_header + fragheaderlen; <S2SV_StartVul> skb->ip_summed = CHECKSUM_PARTIAL; <S2SV_EndVul> skb->csum = 0; <S2SV_StartVul> skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen; <S2SV_EndVul> <S2SV_StartVul> skb_shinfo(skb)->gso_type = SKB_GSO_UDP; <S2SV_EndVul> __skb_queue_tail(queue, skb); } return skb_append_datato_frags(sk, skb, getfrag, from, (length - transhdrlen)); }","- skb->ip_summed = CHECKSUM_PARTIAL;
- skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
- skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+ } else if (skb_is_gso(skb)) {
+ goto append;
+ skb->ip_summed = CHECKSUM_PARTIAL;
+ skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
+ skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
+ append:","static inline int ip_ufo_append_data(struct sock *sk, struct sk_buff_head *queue, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int hh_len, int fragheaderlen, int transhdrlen, int maxfraglen, unsigned int flags) { struct sk_buff *skb; int err; if ((skb = skb_peek_tail(queue)) == NULL) { skb = sock_alloc_send_skb(sk, hh_len + fragheaderlen + transhdrlen + 20, (flags & MSG_DONTWAIT), &err); if (skb == NULL) return err; skb_reserve(skb, hh_len); skb_put(skb, fragheaderlen + transhdrlen); skb_reset_network_header(skb); skb->transport_header = skb->network_header + fragheaderlen; skb->csum = 0; __skb_queue_tail(queue, skb); } else if (skb_is_gso(skb)) { goto append; } skb->ip_summed = CHECKSUM_PARTIAL; skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen; skb_shinfo(skb)->gso_type = SKB_GSO_UDP; append: return skb_append_datato_frags(sk, skb, getfrag, from, (length - transhdrlen)); }"
781,5453----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ifb.c----ifb_setup,static void ifb_setup(struct net_device *dev) { dev->destructor = free_netdev; dev->netdev_ops = &ifb_netdev_ops; ether_setup(dev); dev->tx_queue_len = TX_Q_LIMIT; dev->features |= IFB_FEATURES; dev->vlan_features |= IFB_FEATURES; dev->flags |= IFF_NOARP; dev->flags &= ~IFF_MULTICAST; <S2SV_StartVul> dev->priv_flags &= ~IFF_XMIT_DST_RELEASE; <S2SV_EndVul> random_ether_addr(dev->dev_addr); },"- dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
+ dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);",static void ifb_setup(struct net_device *dev) { dev->destructor = free_netdev; dev->netdev_ops = &ifb_netdev_ops; ether_setup(dev); dev->tx_queue_len = TX_Q_LIMIT; dev->features |= IFB_FEATURES; dev->vlan_features |= IFB_FEATURES; dev->flags |= IFF_NOARP; dev->flags &= ~IFF_MULTICAST; dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING); random_ether_addr(dev->dev_addr); }
782,676----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3601--iommu.c----kvm_unpin_pages,"<S2SV_StartVul> static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> unsigned long i; <S2SV_EndVul> for (i = 0; i < npages; ++i) <S2SV_StartVul> kvm_release_pfn_clean(pfn + i); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul>","- static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)
- {
- unsigned long i;
- kvm_release_pfn_clean(pfn + i);
- }
- 
+ static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)
+ ","static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)"
783,5773----CWE-122----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/normal.c----get_visual_text,"get_visual_text( cmdarg_T *cap, char_u **pp, int *lenp) { if (VIsual_mode != 'V') unadjust_for_sel(); if (VIsual.lnum != curwin->w_cursor.lnum) { if (cap != NULL) clearopbeep(cap->oap); return FAIL; } if (VIsual_mode == 'V') { *pp = ml_get_curline(); *lenp = (int)STRLEN(*pp); } else { if (LT_POS(curwin->w_cursor, VIsual)) { *pp = ml_get_pos(&curwin->w_cursor); *lenp = VIsual.col - curwin->w_cursor.col + 1; } else { *pp = ml_get_pos(&VIsual); *lenp = curwin->w_cursor.col - VIsual.col + 1; } <S2SV_StartVul> if (has_mbyte) <S2SV_EndVul> *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1; } reset_VIsual_and_resel(); return OK; }","- if (has_mbyte)
+ if (**pp == NUL)
+ if (has_mbyte && *lenp > 0)","get_visual_text( cmdarg_T *cap, char_u **pp, int *lenp) { if (VIsual_mode != 'V') unadjust_for_sel(); if (VIsual.lnum != curwin->w_cursor.lnum) { if (cap != NULL) clearopbeep(cap->oap); return FAIL; } if (VIsual_mode == 'V') { *pp = ml_get_curline(); *lenp = (int)STRLEN(*pp); } else { if (LT_POS(curwin->w_cursor, VIsual)) { *pp = ml_get_pos(&curwin->w_cursor); *lenp = VIsual.col - curwin->w_cursor.col + 1; } else { *pp = ml_get_pos(&VIsual); *lenp = curwin->w_cursor.col - VIsual.col + 1; } if (**pp == NUL) *lenp = 0; if (has_mbyte && *lenp > 0) *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1; } reset_VIsual_and_resel(); return OK; }"
784,6457----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/verifier.c----check_cond_jmp_op,"static int check_cond_jmp_op(struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx) { struct bpf_verifier_state *this_branch = env->cur_state; struct bpf_verifier_state *other_branch; struct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs; struct bpf_reg_state *dst_reg, *other_branch_regs; u8 opcode = BPF_OP(insn->code); int err; if (opcode > BPF_JSLE) { verbose(env, ""invalid BPF_JMP opcode %x\n"", opcode); return -EINVAL; } if (BPF_SRC(insn->code) == BPF_X) { if (insn->imm != 0) { verbose(env, ""BPF_JMP uses reserved fields\n""); return -EINVAL; } err = check_reg_arg(env, insn->src_reg, SRC_OP); if (err) return err; if (is_pointer_value(env, insn->src_reg)) { verbose(env, ""R%d pointer comparison prohibited\n"", insn->src_reg); return -EACCES; } } else { if (insn->src_reg != BPF_REG_0) { verbose(env, ""BPF_JMP uses reserved fields\n""); return -EINVAL; } } err = check_reg_arg(env, insn->dst_reg, SRC_OP); if (err) return err; dst_reg = &regs[insn->dst_reg]; if (BPF_SRC(insn->code) == BPF_K) { int pred = is_branch_taken(dst_reg, insn->imm, opcode); if (pred == 1) { *insn_idx += insn->off; return 0; } else if (pred == 0) { return 0; } } <S2SV_StartVul> other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx); <S2SV_EndVul> if (!other_branch) return -EFAULT; other_branch_regs = other_branch->frame[other_branch->curframe]->regs; if (BPF_SRC(insn->code) == BPF_X) { if (dst_reg->type == SCALAR_VALUE && regs[insn->src_reg].type == SCALAR_VALUE) { if (tnum_is_const(regs[insn->src_reg].var_off)) reg_set_min_max(&other_branch_regs[insn->dst_reg], dst_reg, regs[insn->src_reg].var_off.value, opcode); else if (tnum_is_const(dst_reg->var_off)) reg_set_min_max_inv(&other_branch_regs[insn->src_reg], &regs[insn->src_reg], dst_reg->var_off.value, opcode); else if (opcode == BPF_JEQ || opcode == BPF_JNE) reg_combine_min_max(&other_branch_regs[insn->src_reg], &other_branch_regs[insn->dst_reg], &regs[insn->src_reg], &regs[insn->dst_reg], opcode); } } else if (dst_reg->type == SCALAR_VALUE) { reg_set_min_max(&other_branch_regs[insn->dst_reg], dst_reg, insn->imm, opcode); } if (BPF_SRC(insn->code) == BPF_K && insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) && reg_type_may_be_null(dst_reg->type)) { mark_ptr_or_null_regs(this_branch, insn->dst_reg, opcode == BPF_JNE); mark_ptr_or_null_regs(other_branch, insn->dst_reg, opcode == BPF_JEQ); } else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg], this_branch, other_branch) && is_pointer_value(env, insn->dst_reg)) { verbose(env, ""R%d pointer comparison prohibited\n"", insn->dst_reg); return -EACCES; } if (env->log.level) print_verifier_state(env, this_branch->frame[this_branch->curframe]); return 0; }","- other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);
+ other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,
+ false);","static int check_cond_jmp_op(struct bpf_verifier_env *env, struct bpf_insn *insn, int *insn_idx) { struct bpf_verifier_state *this_branch = env->cur_state; struct bpf_verifier_state *other_branch; struct bpf_reg_state *regs = this_branch->frame[this_branch->curframe]->regs; struct bpf_reg_state *dst_reg, *other_branch_regs; u8 opcode = BPF_OP(insn->code); int err; if (opcode > BPF_JSLE) { verbose(env, ""invalid BPF_JMP opcode %x\n"", opcode); return -EINVAL; } if (BPF_SRC(insn->code) == BPF_X) { if (insn->imm != 0) { verbose(env, ""BPF_JMP uses reserved fields\n""); return -EINVAL; } err = check_reg_arg(env, insn->src_reg, SRC_OP); if (err) return err; if (is_pointer_value(env, insn->src_reg)) { verbose(env, ""R%d pointer comparison prohibited\n"", insn->src_reg); return -EACCES; } } else { if (insn->src_reg != BPF_REG_0) { verbose(env, ""BPF_JMP uses reserved fields\n""); return -EINVAL; } } err = check_reg_arg(env, insn->dst_reg, SRC_OP); if (err) return err; dst_reg = &regs[insn->dst_reg]; if (BPF_SRC(insn->code) == BPF_K) { int pred = is_branch_taken(dst_reg, insn->imm, opcode); if (pred == 1) { *insn_idx += insn->off; return 0; } else if (pred == 0) { return 0; } } other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx, false); if (!other_branch) return -EFAULT; other_branch_regs = other_branch->frame[other_branch->curframe]->regs; if (BPF_SRC(insn->code) == BPF_X) { if (dst_reg->type == SCALAR_VALUE && regs[insn->src_reg].type == SCALAR_VALUE) { if (tnum_is_const(regs[insn->src_reg].var_off)) reg_set_min_max(&other_branch_regs[insn->dst_reg], dst_reg, regs[insn->src_reg].var_off.value, opcode); else if (tnum_is_const(dst_reg->var_off)) reg_set_min_max_inv(&other_branch_regs[insn->src_reg], &regs[insn->src_reg], dst_reg->var_off.value, opcode); else if (opcode == BPF_JEQ || opcode == BPF_JNE) reg_combine_min_max(&other_branch_regs[insn->src_reg], &other_branch_regs[insn->dst_reg], &regs[insn->src_reg], &regs[insn->dst_reg], opcode); } } else if (dst_reg->type == SCALAR_VALUE) { reg_set_min_max(&other_branch_regs[insn->dst_reg], dst_reg, insn->imm, opcode); } if (BPF_SRC(insn->code) == BPF_K && insn->imm == 0 && (opcode == BPF_JEQ || opcode == BPF_JNE) && reg_type_may_be_null(dst_reg->type)) { mark_ptr_or_null_regs(this_branch, insn->dst_reg, opcode == BPF_JNE); mark_ptr_or_null_regs(other_branch, insn->dst_reg, opcode == BPF_JEQ); } else if (!try_match_pkt_pointers(insn, dst_reg, &regs[insn->src_reg], this_branch, other_branch) && is_pointer_value(env, insn->dst_reg)) { verbose(env, ""R%d pointer comparison prohibited\n"", insn->dst_reg); return -EACCES; } if (env->log.level) print_verifier_state(env, this_branch->frame[this_branch->curframe]); return 0; }"
785,6359----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/scrub.c----btrfs_scrub_dev,"int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start, u64 end, struct btrfs_scrub_progress *progress, int readonly, int is_dev_replace) { struct scrub_ctx *sctx; int ret; struct btrfs_device *dev; unsigned int nofs_flag; if (btrfs_fs_closing(fs_info)) return -EINVAL; if (fs_info->nodesize > BTRFS_STRIPE_LEN) { btrfs_err(fs_info, ""scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails"", fs_info->nodesize, BTRFS_STRIPE_LEN); return -EINVAL; } if (fs_info->sectorsize != PAGE_SIZE) { btrfs_err_rl(fs_info, ""scrub: size assumption sectorsize != PAGE_SIZE (%d != %lu) fails"", fs_info->sectorsize, PAGE_SIZE); return -EINVAL; } if (fs_info->nodesize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK || fs_info->sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) { btrfs_err(fs_info, ""scrub: size assumption nodesize and sectorsize <= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails"", fs_info->nodesize, SCRUB_MAX_PAGES_PER_BLOCK, fs_info->sectorsize, SCRUB_MAX_PAGES_PER_BLOCK); return -EINVAL; } sctx = scrub_setup_ctx(fs_info, is_dev_replace); if (IS_ERR(sctx)) return PTR_ERR(sctx); mutex_lock(&fs_info->fs_devices->device_list_mutex); <S2SV_StartVul> dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL); <S2SV_EndVul> if (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) && !is_dev_replace)) { mutex_unlock(&fs_info->fs_devices->device_list_mutex); ret = -ENODEV; goto out_free_ctx; } if (!is_dev_replace && !readonly && !test_bit(BTRFS_DEV_STATE_WRITEABLE, &dev->dev_state)) { mutex_unlock(&fs_info->fs_devices->device_list_mutex); btrfs_err_in_rcu(fs_info, ""scrub: device %s is not writable"", rcu_str_deref(dev->name)); ret = -EROFS; goto out_free_ctx; } mutex_lock(&fs_info->scrub_lock); if (!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &dev->dev_state) || test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &dev->dev_state)) { mutex_unlock(&fs_info->scrub_lock); mutex_unlock(&fs_info->fs_devices->device_list_mutex); ret = -EIO; goto out_free_ctx; } down_read(&fs_info->dev_replace.rwsem); if (dev->scrub_ctx || (!is_dev_replace && btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) { up_read(&fs_info->dev_replace.rwsem); mutex_unlock(&fs_info->scrub_lock); mutex_unlock(&fs_info->fs_devices->device_list_mutex); ret = -EINPROGRESS; goto out_free_ctx; } up_read(&fs_info->dev_replace.rwsem); ret = scrub_workers_get(fs_info, is_dev_replace); if (ret) { mutex_unlock(&fs_info->scrub_lock); mutex_unlock(&fs_info->fs_devices->device_list_mutex); goto out_free_ctx; } sctx->readonly = readonly; dev->scrub_ctx = sctx; mutex_unlock(&fs_info->fs_devices->device_list_mutex); __scrub_blocked_if_needed(fs_info); atomic_inc(&fs_info->scrubs_running); mutex_unlock(&fs_info->scrub_lock); nofs_flag = memalloc_nofs_save(); if (!is_dev_replace) { mutex_lock(&fs_info->fs_devices->device_list_mutex); ret = scrub_supers(sctx, dev); mutex_unlock(&fs_info->fs_devices->device_list_mutex); } if (!ret) ret = scrub_enumerate_chunks(sctx, dev, start, end); memalloc_nofs_restore(nofs_flag); wait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0); atomic_dec(&fs_info->scrubs_running); wake_up(&fs_info->scrub_pause_wait); wait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0); if (progress) memcpy(progress, &sctx->stat, sizeof(*progress)); mutex_lock(&fs_info->scrub_lock); dev->scrub_ctx = NULL; scrub_workers_put(fs_info); mutex_unlock(&fs_info->scrub_lock); scrub_put_ctx(sctx); return ret; out_free_ctx: scrub_free_ctx(sctx); return ret; }","- dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);
+ dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);","int btrfs_scrub_dev(struct btrfs_fs_info *fs_info, u64 devid, u64 start, u64 end, struct btrfs_scrub_progress *progress, int readonly, int is_dev_replace) { struct scrub_ctx *sctx; int ret; struct btrfs_device *dev; unsigned int nofs_flag; if (btrfs_fs_closing(fs_info)) return -EINVAL; if (fs_info->nodesize > BTRFS_STRIPE_LEN) { btrfs_err(fs_info, ""scrub: size assumption nodesize <= BTRFS_STRIPE_LEN (%d <= %d) fails"", fs_info->nodesize, BTRFS_STRIPE_LEN); return -EINVAL; } if (fs_info->sectorsize != PAGE_SIZE) { btrfs_err_rl(fs_info, ""scrub: size assumption sectorsize != PAGE_SIZE (%d != %lu) fails"", fs_info->sectorsize, PAGE_SIZE); return -EINVAL; } if (fs_info->nodesize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK || fs_info->sectorsize > PAGE_SIZE * SCRUB_MAX_PAGES_PER_BLOCK) { btrfs_err(fs_info, ""scrub: size assumption nodesize and sectorsize <= SCRUB_MAX_PAGES_PER_BLOCK (%d <= %d && %d <= %d) fails"", fs_info->nodesize, SCRUB_MAX_PAGES_PER_BLOCK, fs_info->sectorsize, SCRUB_MAX_PAGES_PER_BLOCK); return -EINVAL; } sctx = scrub_setup_ctx(fs_info, is_dev_replace); if (IS_ERR(sctx)) return PTR_ERR(sctx); mutex_lock(&fs_info->fs_devices->device_list_mutex); dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true); if (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) && !is_dev_replace)) { mutex_unlock(&fs_info->fs_devices->device_list_mutex); ret = -ENODEV; goto out_free_ctx; } if (!is_dev_replace && !readonly && !test_bit(BTRFS_DEV_STATE_WRITEABLE, &dev->dev_state)) { mutex_unlock(&fs_info->fs_devices->device_list_mutex); btrfs_err_in_rcu(fs_info, ""scrub: device %s is not writable"", rcu_str_deref(dev->name)); ret = -EROFS; goto out_free_ctx; } mutex_lock(&fs_info->scrub_lock); if (!test_bit(BTRFS_DEV_STATE_IN_FS_METADATA, &dev->dev_state) || test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &dev->dev_state)) { mutex_unlock(&fs_info->scrub_lock); mutex_unlock(&fs_info->fs_devices->device_list_mutex); ret = -EIO; goto out_free_ctx; } down_read(&fs_info->dev_replace.rwsem); if (dev->scrub_ctx || (!is_dev_replace && btrfs_dev_replace_is_ongoing(&fs_info->dev_replace))) { up_read(&fs_info->dev_replace.rwsem); mutex_unlock(&fs_info->scrub_lock); mutex_unlock(&fs_info->fs_devices->device_list_mutex); ret = -EINPROGRESS; goto out_free_ctx; } up_read(&fs_info->dev_replace.rwsem); ret = scrub_workers_get(fs_info, is_dev_replace); if (ret) { mutex_unlock(&fs_info->scrub_lock); mutex_unlock(&fs_info->fs_devices->device_list_mutex); goto out_free_ctx; } sctx->readonly = readonly; dev->scrub_ctx = sctx; mutex_unlock(&fs_info->fs_devices->device_list_mutex); __scrub_blocked_if_needed(fs_info); atomic_inc(&fs_info->scrubs_running); mutex_unlock(&fs_info->scrub_lock); nofs_flag = memalloc_nofs_save(); if (!is_dev_replace) { mutex_lock(&fs_info->fs_devices->device_list_mutex); ret = scrub_supers(sctx, dev); mutex_unlock(&fs_info->fs_devices->device_list_mutex); } if (!ret) ret = scrub_enumerate_chunks(sctx, dev, start, end); memalloc_nofs_restore(nofs_flag); wait_event(sctx->list_wait, atomic_read(&sctx->bios_in_flight) == 0); atomic_dec(&fs_info->scrubs_running); wake_up(&fs_info->scrub_pause_wait); wait_event(sctx->list_wait, atomic_read(&sctx->workers_pending) == 0); if (progress) memcpy(progress, &sctx->stat, sizeof(*progress)); mutex_lock(&fs_info->scrub_lock); dev->scrub_ctx = NULL; scrub_workers_put(fs_info); mutex_unlock(&fs_info->scrub_lock); scrub_put_ctx(sctx); return ret; out_free_ctx: scrub_free_ctx(sctx); return ret; }"
786,2945----CWE-269----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/virtio.c----virtio_config_writeb,"void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data) { VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev); uint8_t val = data; <S2SV_StartVul> if (addr > (vdev->config_len - sizeof(val))) <S2SV_EndVul> return; stb_p(vdev->config + addr, val); if (k->set_config) { k->set_config(vdev, vdev->config); } }","- if (addr > (vdev->config_len - sizeof(val)))
+ if (addr + sizeof(val) > vdev->config_len) {
+ }","void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data) { VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev); uint8_t val = data; if (addr + sizeof(val) > vdev->config_len) { return; } stb_p(vdev->config + addr, val); if (k->set_config) { k->set_config(vdev, vdev->config); } }"
787,2774----CWE-295----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/default_validator.cc----Envoy::Extensions::TransportSockets::Tls::DefaultCertValidator::initializeSslContexts,"int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts, bool provides_certificates) { int verify_mode = SSL_VERIFY_NONE; int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT; if (config_ != nullptr) { envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext:: TrustChainVerification verification = config_->trustChainVerification(); if (verification == envoy::extensions::transport_sockets::tls::v3:: CertificateValidationContext::ACCEPT_UNTRUSTED) { verify_mode = SSL_VERIFY_PEER; verify_mode_validation_context = SSL_VERIFY_PEER; } } if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) { ca_file_path_ = config_->caCertPath(); bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); bool has_crl = false; for (const X509_INFO* item : list.get()) { if (item->x509) { X509_STORE_add_cert(store, item->x509); if (ca_cert_ == nullptr) { X509_up_ref(item->x509); ca_cert_.reset(item->x509); } } if (item->crl) { X509_STORE_add_crl(store, item->crl); has_crl = true; } } if (ca_cert_ == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } if (has_crl) { X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } verify_mode = SSL_VERIFY_PEER; verify_trusted_ca_ = true; if (config_->allowExpiredCertificate()) { X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback); } } } if (config_ != nullptr && !config_->certificateRevocationList().empty()) { bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()), config_->certificateRevocationList().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load CRL from "", config_->certificateRevocationListPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); for (const X509_INFO* item : list.get()) { if (item->crl) { X509_STORE_add_crl(store, item->crl); } } X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } } const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_; if (cert_validation_config != nullptr) { if (!cert_validation_config->subjectAltNameMatchers().empty()) { <S2SV_StartVul> for (const envoy::type::matcher::v3::StringMatcher& matcher : <S2SV_EndVul> cert_validation_config->subjectAltNameMatchers()) { <S2SV_StartVul> subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher)); <S2SV_EndVul> } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateHashList().empty()) { for (auto hash : cert_validation_config->verifyCertificateHashList()) { if (hash.size() == 95) { hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end()); } const auto& decoded = Hex::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid hex-encoded SHA-256 "", hash)); } verify_certificate_hash_list_.push_back(decoded); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateSpkiList().empty()) { for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) { const auto decoded = Base64::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid base64-encoded SHA-256 "", hash)); } verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end()); } verify_mode = verify_mode_validation_context; } } return verify_mode; }","- for (const envoy::type::matcher::v3::StringMatcher& matcher :
- subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher));
+ for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher :
+ subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher));","int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts, bool provides_certificates) { int verify_mode = SSL_VERIFY_NONE; int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT; if (config_ != nullptr) { envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext:: TrustChainVerification verification = config_->trustChainVerification(); if (verification == envoy::extensions::transport_sockets::tls::v3:: CertificateValidationContext::ACCEPT_UNTRUSTED) { verify_mode = SSL_VERIFY_PEER; verify_mode_validation_context = SSL_VERIFY_PEER; } } if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) { ca_file_path_ = config_->caCertPath(); bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); bool has_crl = false; for (const X509_INFO* item : list.get()) { if (item->x509) { X509_STORE_add_cert(store, item->x509); if (ca_cert_ == nullptr) { X509_up_ref(item->x509); ca_cert_.reset(item->x509); } } if (item->crl) { X509_STORE_add_crl(store, item->crl); has_crl = true; } } if (ca_cert_ == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } if (has_crl) { X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } verify_mode = SSL_VERIFY_PEER; verify_trusted_ca_ = true; if (config_->allowExpiredCertificate()) { X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback); } } } if (config_ != nullptr && !config_->certificateRevocationList().empty()) { bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()), config_->certificateRevocationList().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load CRL from "", config_->certificateRevocationListPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); for (const X509_INFO* item : list.get()) { if (item->crl) { X509_STORE_add_crl(store, item->crl); } } X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } } const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_; if (cert_validation_config != nullptr) { if (!cert_validation_config->subjectAltNameMatchers().empty()) { for (const envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher& matcher : cert_validation_config->subjectAltNameMatchers()) { subject_alt_name_matchers_.emplace_back(createStringSanMatcher(matcher)); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateHashList().empty()) { for (auto hash : cert_validation_config->verifyCertificateHashList()) { if (hash.size() == 95) { hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end()); } const auto& decoded = Hex::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid hex-encoded SHA-256 "", hash)); } verify_certificate_hash_list_.push_back(decoded); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateSpkiList().empty()) { for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) { const auto decoded = Base64::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid base64-encoded SHA-256 "", hash)); } verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end()); } verify_mode = verify_mode_validation_context; } } return verify_mode; }"
788,1335----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-13050--print-rpki-rtr.c----rpki_rtr_print,"rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len) { <S2SV_StartVul> u_int tlen, pdu_type, pdu_len; <S2SV_EndVul> <S2SV_StartVul> const u_char *tptr; <S2SV_EndVul> <S2SV_StartVul> const rpki_rtr_pdu *pdu_header; <S2SV_EndVul> tptr = pptr; <S2SV_StartVul> tlen = len; <S2SV_EndVul> <S2SV_StartVul> if (!ndo->ndo_vflag) { <S2SV_EndVul> ND_PRINT((ndo, "", RPKI-RTR"")); return; } while (tlen >= sizeof(rpki_rtr_pdu)) { ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu)); pdu_header = (const rpki_rtr_pdu *)tptr; <S2SV_StartVul> pdu_type = pdu_header->pdu_type; <S2SV_EndVul> pdu_len = EXTRACT_32BITS(pdu_header->length); <S2SV_StartVul> ND_TCHECK2(*tptr, pdu_len); <S2SV_EndVul> <S2SV_StartVul> if (!pdu_type || !pdu_len) { <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> if (tlen < pdu_len) { <S2SV_EndVul> goto trunc; } <S2SV_StartVul> <S2SV_EndVul> if (rpki_rtr_pdu_print(ndo, tptr, 8)) <S2SV_StartVul> goto trunc; <S2SV_EndVul> <S2SV_StartVul> tlen -= pdu_len; <S2SV_EndVul> <S2SV_StartVul> tptr += pdu_len; <S2SV_EndVul> } return; <S2SV_StartVul> trunc: <S2SV_EndVul> <S2SV_StartVul> ND_PRINT((ndo, ""\n\t%s"", tstr)); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul>","- u_int tlen, pdu_type, pdu_len;
- const u_char *tptr;
- const rpki_rtr_pdu *pdu_header;
- tlen = len;
- if (!ndo->ndo_vflag) {
- pdu_type = pdu_header->pdu_type;
- ND_TCHECK2(*tptr, pdu_len);
- if (!pdu_type || !pdu_len) {
- break;
- }
- if (tlen < pdu_len) {
- /*
- goto trunc;
- tlen -= pdu_len;
- tptr += pdu_len;
- trunc:
- ND_PRINT((ndo, ""\n\t%s"", tstr));
- }
- 
+ while (len) {
+ u_int pdu_len = rpki_rtr_pdu_print(ndo, pptr, len, 1, 8);
+ len -= pdu_len;
+ pptr += pdu_len;","rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len) { if (!ndo->ndo_vflag) { ND_PRINT((ndo, "", RPKI-RTR"")); return; } while (len) { u_int pdu_len = rpki_rtr_pdu_print(ndo, pptr, len, 1, 8); len -= pdu_len; pptr += pdu_len; } }"
789,5897----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tbytevector.cpp----ByteVector::mid,"ByteVector ByteVector::mid(uint index, uint length) const { ByteVector v; if(index > size()) return v; ConstIterator endIt; <S2SV_StartVul> if(length < 0xffffffff && length + index < size()) <S2SV_EndVul> endIt = d->data.begin() + index + length; else endIt = d->data.end(); v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt); v.d->size = v.d->data.size(); return v; }","- if(length < 0xffffffff && length + index < size())
+ if(length < size() - index)","ByteVector ByteVector::mid(uint index, uint length) const { ByteVector v; if(index > size()) return v; ConstIterator endIt; if(length < size() - index) endIt = d->data.begin() + index + length; else endIt = d->data.end(); v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt); v.d->size = v.d->data.size(); return v; }"
790,2756----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----perf_event_overflow,"<S2SV_StartVul> int perf_event_overflow(struct perf_event *event, int nmi, <S2SV_EndVul> struct perf_sample_data *data, struct pt_regs *regs) { <S2SV_StartVul> return __perf_event_overflow(event, nmi, 1, data, regs); <S2SV_EndVul> }","- int perf_event_overflow(struct perf_event *event, int nmi,
- return __perf_event_overflow(event, nmi, 1, data, regs);
+ int perf_event_overflow(struct perf_event *event,
+ return __perf_event_overflow(event, 1, data, regs);","int perf_event_overflow(struct perf_event *event, struct perf_sample_data *data, struct pt_regs *regs) { return __perf_event_overflow(event, 1, data, regs); }"
791,6201----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/av_parsers.c----svc_parse_slice,"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si) { s32 pps_id; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); <S2SV_StartVul> if (pps_id > 255) <S2SV_EndVul> return -1; si->pps = &avc->pps[pps_id]; si->pps->id = pps_id; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT]; if (!si->sps->log2_max_frame_num) return -2; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; if (si->sps->frame_mbs_only_flag) { } else { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } return 0; }","- if (pps_id > 255)
+ if ((pps_id<0) || (pps_id > 255))","static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si) { s32 pps_id; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if ((pps_id<0) || (pps_id > 255)) return -1; si->pps = &avc->pps[pps_id]; si->pps->id = pps_id; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT]; if (!si->sps->log2_max_frame_num) return -2; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; if (si->sps->frame_mbs_only_flag) { } else { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->NalHeader.idr_pic_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } return 0; }"
792,3236----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cjson.c----cJSON_CreateFloatArray,"<S2SV_StartVul> cJSON *cJSON_CreateFloatArray( double *numbers, int count ) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> int i; <S2SV_EndVul> <S2SV_StartVul> cJSON *n = 0, *p = 0, *a = cJSON_CreateArray(); <S2SV_EndVul> <S2SV_StartVul> for ( i = 0; a && i < count; ++i ) { <S2SV_EndVul> <S2SV_StartVul> n = cJSON_CreateFloat( numbers[i] ); <S2SV_EndVul> <S2SV_StartVul> if ( ! i ) <S2SV_EndVul> <S2SV_StartVul> a->child = n; <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> suffix_object( p, n ); <S2SV_EndVul> <S2SV_StartVul> p = n; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return a; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>","- cJSON *cJSON_CreateFloatArray( double *numbers, int count )
- {
- int i;
- cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
- for ( i = 0; a && i < count; ++i ) {
- n = cJSON_CreateFloat( numbers[i] );
- if ( ! i )
- a->child = n;
- else
- suffix_object( p, n );
- p = n;
- }
- return a;
- }
+ cJSON *cJSON_CreateFloatArray(const float *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}","cJSON *cJSON_CreateFloatArray(const float *numbers,int count) {int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}"
793,3357----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip_options.c----ip_options_get_from_user,"<S2SV_StartVul> int ip_options_get_from_user(struct net *net, struct ip_options **optp, <S2SV_EndVul> unsigned char __user *data, int optlen) { <S2SV_StartVul> struct ip_options *opt = ip_options_get_alloc(optlen); <S2SV_EndVul> if (!opt) return -ENOMEM; <S2SV_StartVul> if (optlen && copy_from_user(opt->__data, data, optlen)) { <S2SV_EndVul> kfree(opt); return -EFAULT; } return ip_options_get_finish(net, optp, opt, optlen); }","- int ip_options_get_from_user(struct net *net, struct ip_options **optp,
- struct ip_options *opt = ip_options_get_alloc(optlen);
- if (optlen && copy_from_user(opt->__data, data, optlen)) {
+ int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,
+ struct ip_options_rcu *opt = ip_options_get_alloc(optlen);
+ if (optlen && copy_from_user(opt->opt.__data, data, optlen)) {","int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp, unsigned char __user *data, int optlen) { struct ip_options_rcu *opt = ip_options_get_alloc(optlen); if (!opt) return -ENOMEM; if (optlen && copy_from_user(opt->opt.__data, data, optlen)) { kfree(opt); return -EFAULT; } return ip_options_get_finish(net, optp, opt, optlen); }"
794,3529----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/network-openssl.c----irssi_ssl_verify,"<S2SV_StartVul> static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert) <S2SV_EndVul> { if (SSL_get_verify_result(ssl) != X509_V_OK) { unsigned char md[EVP_MAX_MD_SIZE]; unsigned int n; char *str; g_warning(""Could not verify SSL servers certificate:""); if ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL) g_warning("" Could not get subject-name from peer certificate""); else { g_warning("" Subject : %s"", str); free(str); } if ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL) g_warning("" Could not get issuer-name from peer certificate""); else { g_warning("" Issuer : %s"", str); free(str); } if (! X509_digest(cert, EVP_md5(), md, &n)) g_warning("" Could not get fingerprint from peer certificate""); else { char hex[] = ""0123456789ABCDEF""; char fp[EVP_MAX_MD_SIZE*3]; if (n < sizeof(fp)) { unsigned int i; for (i = 0; i < n; i++) { fp[i*3+0] = hex[(md[i] >> 4) & 0xF]; fp[i*3+1] = hex[(md[i] >> 0) & 0xF]; fp[i*3+2] = i == n - 1 ? '\0' : ':'; } g_warning("" MD5 Fingerprint : %s"", fp); } } return FALSE; } return TRUE; }","- static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)
+ static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, const char* hostname, X509 *cert)
+ } else if (! irssi_ssl_verify_hostname(cert, hostname)){
+ return FALSE;","static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, const char* hostname, X509 *cert) { if (SSL_get_verify_result(ssl) != X509_V_OK) { unsigned char md[EVP_MAX_MD_SIZE]; unsigned int n; char *str; g_warning(""Could not verify SSL servers certificate:""); if ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL) g_warning("" Could not get subject-name from peer certificate""); else { g_warning("" Subject : %s"", str); free(str); } if ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL) g_warning("" Could not get issuer-name from peer certificate""); else { g_warning("" Issuer : %s"", str); free(str); } if (! X509_digest(cert, EVP_md5(), md, &n)) g_warning("" Could not get fingerprint from peer certificate""); else { char hex[] = ""0123456789ABCDEF""; char fp[EVP_MAX_MD_SIZE*3]; if (n < sizeof(fp)) { unsigned int i; for (i = 0; i < n; i++) { fp[i*3+0] = hex[(md[i] >> 4) & 0xF]; fp[i*3+1] = hex[(md[i] >> 0) & 0xF]; fp[i*3+2] = i == n - 1 ? '\0' : ':'; } g_warning("" MD5 Fingerprint : %s"", fp); } } return FALSE; } else if (! irssi_ssl_verify_hostname(cert, hostname)){ return FALSE; } return TRUE; }"
795,1879----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2010-5329--v4l2-ioctl.c----video_ioctl2,"<S2SV_StartVul> long video_ioctl2(struct file *file, <S2SV_EndVul> <S2SV_StartVul> unsigned int cmd, unsigned long arg) <S2SV_EndVul> { char sbuf[128]; void *mbuf = NULL; void *parg = (void *)arg; long err = -EINVAL; bool has_array_args; size_t array_size = 0; void __user *user_ptr = NULL; void **kernel_ptr = NULL; if (_IOC_DIR(cmd) != _IOC_NONE) { if (_IOC_SIZE(cmd) <= sizeof(sbuf)) { parg = sbuf; } else { mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL); if (NULL == mbuf) return -ENOMEM; parg = mbuf; } err = -EFAULT; if (_IOC_DIR(cmd) & _IOC_WRITE) { unsigned long n = cmd_input_size(cmd); if (copy_from_user(parg, (void __user *)arg, n)) goto out; if (n < _IOC_SIZE(cmd)) memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n); } else { memset(parg, 0, _IOC_SIZE(cmd)); } } err = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr); if (err < 0) goto out; has_array_args = err; if (has_array_args) { mbuf = kmalloc(array_size, GFP_KERNEL); err = -ENOMEM; if (NULL == mbuf) goto out_array_args; err = -EFAULT; if (copy_from_user(mbuf, user_ptr, array_size)) goto out_array_args; *kernel_ptr = mbuf; } <S2SV_StartVul> err = __video_do_ioctl(file, cmd, parg); <S2SV_EndVul> if (err == -ENOIOCTLCMD) err = -EINVAL; if (has_array_args) { *kernel_ptr = user_ptr; if (copy_to_user(user_ptr, mbuf, array_size)) err = -EFAULT; goto out_array_args; } if (err < 0) goto out; out_array_args: switch (_IOC_DIR(cmd)) { case _IOC_READ: case (_IOC_WRITE | _IOC_READ): if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd))) err = -EFAULT; break; } out: kfree(mbuf); return err; }","- long video_ioctl2(struct file *file,
- unsigned int cmd, unsigned long arg)
- err = __video_do_ioctl(file, cmd, parg);
+ long video_ioctl2(struct file *file,
+ long
+ video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,
+ v4l2_kioctl func)
+ {","long video_ioctl2(struct file *file, long video_usercopy(struct file *file, unsigned int cmd, unsigned long arg, v4l2_kioctl func) { char sbuf[128]; void *mbuf = NULL; void *parg = (void *)arg; long err = -EINVAL; bool has_array_args; size_t array_size = 0; void __user *user_ptr = NULL; void **kernel_ptr = NULL; if (_IOC_DIR(cmd) != _IOC_NONE) { if (_IOC_SIZE(cmd) <= sizeof(sbuf)) { parg = sbuf; } else { mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL); if (NULL == mbuf) return -ENOMEM; parg = mbuf; } err = -EFAULT; if (_IOC_DIR(cmd) & _IOC_WRITE) { unsigned long n = cmd_input_size(cmd); if (copy_from_user(parg, (void __user *)arg, n)) goto out; if (n < _IOC_SIZE(cmd)) memset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n); } else { memset(parg, 0, _IOC_SIZE(cmd)); } } err = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr); if (err < 0) goto out; has_array_args = err; if (has_array_args) { mbuf = kmalloc(array_size, GFP_KERNEL); err = -ENOMEM; if (NULL == mbuf) goto out_array_args; err = -EFAULT; if (copy_from_user(mbuf, user_ptr, array_size)) goto out_array_args; *kernel_ptr = mbuf; } err = func(file, cmd, parg); if (err == -ENOIOCTLCMD) err = -EINVAL; if (has_array_args) { *kernel_ptr = user_ptr; if (copy_to_user(user_ptr, mbuf, array_size)) err = -EFAULT; goto out_array_args; } if (err < 0) goto out; out_array_args: switch (_IOC_DIR(cmd)) { case _IOC_READ: case (_IOC_WRITE | _IOC_READ): if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd))) err = -EFAULT; break; } out: kfree(mbuf); return err; }"
796,3859----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/config.c----virtualHostDirective,"static int virtualHostDirective(MaState *state, cchar *key, cchar *value) { state = maPushState(state); if (state->enabled) { state->route = httpCreateInheritedRoute(httpGetHostDefaultRoute(state->host)); state->route->ssl = 0; state->auth = state->route->auth; state->host = httpCloneHost(state->host); httpResetRoutes(state->host); httpSetRouteHost(state->route, state->host); httpSetHostDefaultRoute(state->host, state->route); if (value) { <S2SV_StartVul> httpSetHostName(state->host, stok(sclone(value), "" \t,"", NULL)); <S2SV_EndVul> httpSetRouteName(state->route, sfmt(""default-%s"", state->host->name)); state->endpoints = sclone(value); } } return 0; }","- httpSetHostName(state->host, stok(sclone(value), "" \t,"", NULL));
+ httpSetHostName(state->host, ssplit(sclone(value), "" \t,"", NULL));","static int virtualHostDirective(MaState *state, cchar *key, cchar *value) { state = maPushState(state); if (state->enabled) { state->route = httpCreateInheritedRoute(httpGetHostDefaultRoute(state->host)); state->route->ssl = 0; state->auth = state->route->auth; state->host = httpCloneHost(state->host); httpResetRoutes(state->host); httpSetRouteHost(state->route, state->host); httpSetHostDefaultRoute(state->host, state->route); if (value) { httpSetHostName(state->host, ssplit(sclone(value), "" \t,"", NULL)); httpSetRouteName(state->route, sfmt(""default-%s"", state->host->name)); state->endpoints = sclone(value); } } return 0; }"
797,4835----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4proc.c----nfs4_open_prepare,"static void nfs4_open_prepare(struct rpc_task *task, void *calldata) { struct nfs4_opendata *data = calldata; struct nfs4_state_owner *sp = data->owner; if (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0) return; if (data->state != NULL) { struct nfs_delegation *delegation; <S2SV_StartVul> if (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL))) <S2SV_EndVul> goto out_no_action; rcu_read_lock(); delegation = rcu_dereference(NFS_I(data->state->inode)->delegation); if (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) { rcu_read_unlock(); goto out_no_action; } rcu_read_unlock(); } data->o_arg.id = sp->so_owner_id.id; data->o_arg.clientid = sp->so_client->cl_clientid; if (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) { task->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR]; nfs_copy_fh(&data->o_res.fh, data->o_arg.fh); } data->timestamp = jiffies; rpc_call_start(task); return; out_no_action: task->tk_action = NULL; }","- if (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))
+ if (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))","static void nfs4_open_prepare(struct rpc_task *task, void *calldata) { struct nfs4_opendata *data = calldata; struct nfs4_state_owner *sp = data->owner; if (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0) return; if (data->state != NULL) { struct nfs_delegation *delegation; if (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags)) goto out_no_action; rcu_read_lock(); delegation = rcu_dereference(NFS_I(data->state->inode)->delegation); if (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) { rcu_read_unlock(); goto out_no_action; } rcu_read_unlock(); } data->o_arg.id = sp->so_owner_id.id; data->o_arg.clientid = sp->so_client->cl_clientid; if (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) { task->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR]; nfs_copy_fh(&data->o_res.fh, data->o_arg.fh); } data->timestamp = jiffies; rpc_call_start(task); return; out_no_action: task->tk_action = NULL; }"
798,1181----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-9870--ptrace.c----arch_ptrace,"long arch_ptrace(struct task_struct *child, long request, unsigned long addr, unsigned long data) { int ret; unsigned long __user *datap = (unsigned long __user *) data; switch (request) { case PTRACE_PEEKUSR: ret = ptrace_read_user(child, addr, datap); break; case PTRACE_POKEUSR: ret = ptrace_write_user(child, addr, data); break; case PTRACE_GETREGS: ret = copy_regset_to_user(child, &user_arm_view, REGSET_GPR, 0, sizeof(struct pt_regs), datap); break; case PTRACE_SETREGS: ret = copy_regset_from_user(child, &user_arm_view, REGSET_GPR, 0, sizeof(struct pt_regs), datap); break; case PTRACE_GETFPREGS: ret = copy_regset_to_user(child, &user_arm_view, REGSET_FPR, 0, sizeof(union fp_state), datap); break; case PTRACE_SETFPREGS: ret = copy_regset_from_user(child, &user_arm_view, REGSET_FPR, 0, sizeof(union fp_state), datap); break; #ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS: ret = ptrace_getwmmxregs(child, datap); break; case PTRACE_SETWMMXREGS: ret = ptrace_setwmmxregs(child, datap); break; #endif case PTRACE_GET_THREAD_AREA: <S2SV_StartVul> ret = put_user(task_thread_info(child)->tp_value, <S2SV_EndVul> datap); break; case PTRACE_SET_SYSCALL: task_thread_info(child)->syscall = data; ret = 0; break; #ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS: ret = ptrace_getcrunchregs(child, datap); break; case PTRACE_SETCRUNCHREGS: ret = ptrace_setcrunchregs(child, datap); break; #endif #ifdef CONFIG_VFP case PTRACE_GETVFPREGS: ret = copy_regset_to_user(child, &user_arm_view, REGSET_VFP, 0, ARM_VFPREGS_SIZE, datap); break; case PTRACE_SETVFPREGS: ret = copy_regset_from_user(child, &user_arm_view, REGSET_VFP, 0, ARM_VFPREGS_SIZE, datap); break; #endif #ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS: if (ptrace_get_breakpoints(child) < 0) return -ESRCH; ret = ptrace_gethbpregs(child, addr, (unsigned long __user *)data); ptrace_put_breakpoints(child); break; case PTRACE_SETHBPREGS: if (ptrace_get_breakpoints(child) < 0) return -ESRCH; ret = ptrace_sethbpregs(child, addr, (unsigned long __user *)data); ptrace_put_breakpoints(child); break; #endif default: ret = ptrace_request(child, request, addr, data); break; } return ret; }","- ret = put_user(task_thread_info(child)->tp_value,
+ ret = put_user(task_thread_info(child)->tp_value[0],","long arch_ptrace(struct task_struct *child, long request, unsigned long addr, unsigned long data) { int ret; unsigned long __user *datap = (unsigned long __user *) data; switch (request) { case PTRACE_PEEKUSR: ret = ptrace_read_user(child, addr, datap); break; case PTRACE_POKEUSR: ret = ptrace_write_user(child, addr, data); break; case PTRACE_GETREGS: ret = copy_regset_to_user(child, &user_arm_view, REGSET_GPR, 0, sizeof(struct pt_regs), datap); break; case PTRACE_SETREGS: ret = copy_regset_from_user(child, &user_arm_view, REGSET_GPR, 0, sizeof(struct pt_regs), datap); break; case PTRACE_GETFPREGS: ret = copy_regset_to_user(child, &user_arm_view, REGSET_FPR, 0, sizeof(union fp_state), datap); break; case PTRACE_SETFPREGS: ret = copy_regset_from_user(child, &user_arm_view, REGSET_FPR, 0, sizeof(union fp_state), datap); break; #ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS: ret = ptrace_getwmmxregs(child, datap); break; case PTRACE_SETWMMXREGS: ret = ptrace_setwmmxregs(child, datap); break; #endif case PTRACE_GET_THREAD_AREA: ret = put_user(task_thread_info(child)->tp_value[0], datap); break; case PTRACE_SET_SYSCALL: task_thread_info(child)->syscall = data; ret = 0; break; #ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS: ret = ptrace_getcrunchregs(child, datap); break; case PTRACE_SETCRUNCHREGS: ret = ptrace_setcrunchregs(child, datap); break; #endif #ifdef CONFIG_VFP case PTRACE_GETVFPREGS: ret = copy_regset_to_user(child, &user_arm_view, REGSET_VFP, 0, ARM_VFPREGS_SIZE, datap); break; case PTRACE_SETVFPREGS: ret = copy_regset_from_user(child, &user_arm_view, REGSET_VFP, 0, ARM_VFPREGS_SIZE, datap); break; #endif #ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS: if (ptrace_get_breakpoints(child) < 0) return -ESRCH; ret = ptrace_gethbpregs(child, addr, (unsigned long __user *)data); ptrace_put_breakpoints(child); break; case PTRACE_SETHBPREGS: if (ptrace_get_breakpoints(child) < 0) return -ESRCH; ret = ptrace_sethbpregs(child, addr, (unsigned long __user *)data); ptrace_put_breakpoints(child); break; #endif default: ret = ptrace_request(child, request, addr, data); break; } return ret; }"
799,5127----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sspi.c----sspi_SecureHandleGetUpperPointer,void* sspi_SecureHandleGetUpperPointer(SecHandle* handle) { void* pointer; <S2SV_StartVul> if (!handle) <S2SV_EndVul> return NULL; pointer = (void*) ~((size_t) handle->dwUpper); return pointer; },"- if (!handle)
+ if (!handle || !SecIsValidHandle(handle))",void* sspi_SecureHandleGetUpperPointer(SecHandle* handle) { void* pointer; if (!handle || !SecIsValidHandle(handle)) return NULL; pointer = (void*) ~((size_t) handle->dwUpper); return pointer; }
800,7363----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/multi.c----Curl_detach_connnection,"void Curl_detach_connnection(struct Curl_easy *data) { struct connectdata *conn = data->conn; <S2SV_StartVul> if(conn) <S2SV_EndVul> Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL); data->conn = NULL; }","- if(conn)
+ if(conn) {
+ Curl_ssl_detach_conn(data, conn);
+ }","void Curl_detach_connnection(struct Curl_easy *data) { struct connectdata *conn = data->conn; if(conn) { Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL); Curl_ssl_detach_conn(data, conn); } data->conn = NULL; }"
801,2966----CWE-522----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fsck.c----check_submodule_url,"static int check_submodule_url(const char *url) { const char *curl_url; if (looks_like_command_line_option(url)) return -1; if (submodule_url_is_relative(url)) { <S2SV_StartVul> char *decoded = url_decode(url); <S2SV_EndVul> <S2SV_StartVul> int has_nl = !!strchr(decoded, '\n'); <S2SV_EndVul> free(decoded); if (has_nl) return -1; } else if (url_to_curl_url(url, &curl_url)) { struct credential c = CREDENTIAL_INIT; int ret = credential_from_url_gently(&c, curl_url, 1); credential_clear(&c); return ret; } return 0; }","- char *decoded = url_decode(url);
- int has_nl = !!strchr(decoded, '\n');
+ char *decoded;
+ const char *next;
+ int has_nl;
+ decoded = url_decode(url);
+ has_nl = !!strchr(decoded, '\n');
+ if (count_leading_dotdots(url, &next) > 0 &&
+ return -1;","static int check_submodule_url(const char *url) { const char *curl_url; if (looks_like_command_line_option(url)) return -1; if (submodule_url_is_relative(url)) { char *decoded; const char *next; int has_nl; decoded = url_decode(url); has_nl = !!strchr(decoded, '\n'); free(decoded); if (has_nl) return -1; if (count_leading_dotdots(url, &next) > 0 && *next == ':') return -1; } else if (url_to_curl_url(url, &curl_url)) { struct credential c = CREDENTIAL_INIT; int ret = credential_from_url_gently(&c, curl_url, 1); credential_clear(&c); return ret; } return 0; }"
802,4495----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/TLSInStream.cxx----TLSInStream::pos,<S2SV_StartVul> int TLSInStream::pos() <S2SV_EndVul> { return offset + ptr - start; },"- int TLSInStream::pos()
+ size_t TLSInStream::pos()",size_t TLSInStream::pos() { return offset + ptr - start; }
803,2610--------F:/邵苗苗_data/Big-Vul/bigvul/vul/--xpath.c----xmlXPathNextPrecedingInternal,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) { if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL); <S2SV_StartVul> if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) || <S2SV_EndVul> <S2SV_StartVul> (ctxt->context->node->type == XML_NAMESPACE_DECL)) <S2SV_EndVul> <S2SV_StartVul> return(NULL); <S2SV_EndVul> if (cur == NULL) { cur = ctxt->context->node; if (cur == NULL) return (NULL); ctxt->ancestor = cur->parent; } if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE)) cur = cur->prev; while (cur->prev == NULL) { cur = cur->parent; if (cur == NULL) return (NULL); if (cur == ctxt->context->doc->children) return (NULL); if (cur != ctxt->ancestor) return (cur); ctxt->ancestor = cur->parent; } cur = cur->prev; while (cur->last != NULL) cur = cur->last; return (cur); }","- if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
- (ctxt->context->node->type == XML_NAMESPACE_DECL))
- return(NULL);
+ if (cur->type == XML_NAMESPACE_DECL)
+ return (NULL);","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) { if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL); if (cur == NULL) { cur = ctxt->context->node; if (cur == NULL) return (NULL); if (cur->type == XML_NAMESPACE_DECL) return (NULL); ctxt->ancestor = cur->parent; } if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE)) cur = cur->prev; while (cur->prev == NULL) { cur = cur->parent; if (cur == NULL) return (NULL); if (cur == ctxt->context->doc->children) return (NULL); if (cur != ctxt->ancestor) return (cur); ctxt->ancestor = cur->parent; } cur = cur->prev; while (cur->last != NULL) cur = cur->last; return (cur); }"
804,2162--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18204--file.c----ocfs2_setattr,"int ocfs2_setattr(struct dentry *dentry, struct iattr *attr) { int status = 0, size_change; int inode_locked = 0; struct inode *inode = d_inode(dentry); struct super_block *sb = inode->i_sb; struct ocfs2_super *osb = OCFS2_SB(sb); struct buffer_head *bh = NULL; handle_t *handle = NULL; struct dquot *transfer_to[MAXQUOTAS] = { }; int qtype; int had_lock; struct ocfs2_lock_holder oh; trace_ocfs2_setattr(inode, dentry, (unsigned long long)OCFS2_I(inode)->ip_blkno, dentry->d_name.len, dentry->d_name.name, attr->ia_valid, attr->ia_mode, from_kuid(&init_user_ns, attr->ia_uid), from_kgid(&init_user_ns, attr->ia_gid)); if (S_ISLNK(inode->i_mode)) attr->ia_valid &= ~ATTR_SIZE; #define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \ | ATTR_GID | ATTR_UID | ATTR_MODE) if (!(attr->ia_valid & OCFS2_VALID_ATTRS)) return 0; status = setattr_prepare(dentry, attr); if (status) return status; if (is_quota_modification(inode, attr)) { status = dquot_initialize(inode); if (status) return status; } size_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE; if (size_change) { status = ocfs2_rw_lock(inode, 1); if (status < 0) { mlog_errno(status); goto bail; } } had_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh); if (had_lock < 0) { status = had_lock; goto bail_unlock_rw; } else if (had_lock) { mlog(ML_ERROR, ""Another case of recursive locking:\n""); dump_stack(); } inode_locked = 1; if (size_change) { status = inode_newsize_ok(inode, attr->ia_size); if (status) goto bail_unlock; <S2SV_StartVul> inode_dio_wait(inode); <S2SV_EndVul> if (i_size_read(inode) >= attr->ia_size) { if (ocfs2_should_order_data(inode)) { status = ocfs2_begin_ordered_truncate(inode, attr->ia_size); if (status) goto bail_unlock; } status = ocfs2_truncate_file(inode, bh, attr->ia_size); } else status = ocfs2_extend_file(inode, bh, attr->ia_size); if (status < 0) { if (status != -ENOSPC) mlog_errno(status); status = -ENOSPC; goto bail_unlock; } } if ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) || (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) { if (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid) && OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) { transfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid)); if (IS_ERR(transfer_to[USRQUOTA])) { status = PTR_ERR(transfer_to[USRQUOTA]); goto bail_unlock; } } if (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid) && OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) { transfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid)); if (IS_ERR(transfer_to[GRPQUOTA])) { status = PTR_ERR(transfer_to[GRPQUOTA]); goto bail_unlock; } } handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits(sb)); if (IS_ERR(handle)) { status = PTR_ERR(handle); mlog_errno(status); goto bail_unlock; } status = __dquot_transfer(inode, transfer_to); if (status < 0) goto bail_commit; } else { handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS); if (IS_ERR(handle)) { status = PTR_ERR(handle); mlog_errno(status); goto bail_unlock; } } setattr_copy(inode, attr); mark_inode_dirty(inode); status = ocfs2_mark_inode_dirty(handle, inode, bh); if (status < 0) mlog_errno(status); bail_commit: ocfs2_commit_trans(osb, handle); bail_unlock: if (status && inode_locked) { ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock); inode_locked = 0; } bail_unlock_rw: if (size_change) ocfs2_rw_unlock(inode, 1); bail: for (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++) dqput(transfer_to[qtype]); if (!status && attr->ia_valid & ATTR_MODE) { status = ocfs2_acl_chmod(inode, bh); if (status < 0) mlog_errno(status); } if (inode_locked) ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock); brelse(bh); return status; }","- inode_dio_wait(inode);
+ inode_dio_wait(inode);","int ocfs2_setattr(struct dentry *dentry, struct iattr *attr) { int status = 0, size_change; int inode_locked = 0; struct inode *inode = d_inode(dentry); struct super_block *sb = inode->i_sb; struct ocfs2_super *osb = OCFS2_SB(sb); struct buffer_head *bh = NULL; handle_t *handle = NULL; struct dquot *transfer_to[MAXQUOTAS] = { }; int qtype; int had_lock; struct ocfs2_lock_holder oh; trace_ocfs2_setattr(inode, dentry, (unsigned long long)OCFS2_I(inode)->ip_blkno, dentry->d_name.len, dentry->d_name.name, attr->ia_valid, attr->ia_mode, from_kuid(&init_user_ns, attr->ia_uid), from_kgid(&init_user_ns, attr->ia_gid)); if (S_ISLNK(inode->i_mode)) attr->ia_valid &= ~ATTR_SIZE; #define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \ | ATTR_GID | ATTR_UID | ATTR_MODE) if (!(attr->ia_valid & OCFS2_VALID_ATTRS)) return 0; status = setattr_prepare(dentry, attr); if (status) return status; if (is_quota_modification(inode, attr)) { status = dquot_initialize(inode); if (status) return status; } size_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE; if (size_change) { inode_dio_wait(inode); status = ocfs2_rw_lock(inode, 1); if (status < 0) { mlog_errno(status); goto bail; } } had_lock = ocfs2_inode_lock_tracker(inode, &bh, 1, &oh); if (had_lock < 0) { status = had_lock; goto bail_unlock_rw; } else if (had_lock) { mlog(ML_ERROR, ""Another case of recursive locking:\n""); dump_stack(); } inode_locked = 1; if (size_change) { status = inode_newsize_ok(inode, attr->ia_size); if (status) goto bail_unlock; if (i_size_read(inode) >= attr->ia_size) { if (ocfs2_should_order_data(inode)) { status = ocfs2_begin_ordered_truncate(inode, attr->ia_size); if (status) goto bail_unlock; } status = ocfs2_truncate_file(inode, bh, attr->ia_size); } else status = ocfs2_extend_file(inode, bh, attr->ia_size); if (status < 0) { if (status != -ENOSPC) mlog_errno(status); status = -ENOSPC; goto bail_unlock; } } if ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) || (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) { if (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid) && OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) { transfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid)); if (IS_ERR(transfer_to[USRQUOTA])) { status = PTR_ERR(transfer_to[USRQUOTA]); goto bail_unlock; } } if (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid) && OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) { transfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid)); if (IS_ERR(transfer_to[GRPQUOTA])) { status = PTR_ERR(transfer_to[GRPQUOTA]); goto bail_unlock; } } handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits(sb)); if (IS_ERR(handle)) { status = PTR_ERR(handle); mlog_errno(status); goto bail_unlock; } status = __dquot_transfer(inode, transfer_to); if (status < 0) goto bail_commit; } else { handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS); if (IS_ERR(handle)) { status = PTR_ERR(handle); mlog_errno(status); goto bail_unlock; } } setattr_copy(inode, attr); mark_inode_dirty(inode); status = ocfs2_mark_inode_dirty(handle, inode, bh); if (status < 0) mlog_errno(status); bail_commit: ocfs2_commit_trans(osb, handle); bail_unlock: if (status && inode_locked) { ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock); inode_locked = 0; } bail_unlock_rw: if (size_change) ocfs2_rw_unlock(inode, 1); bail: for (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++) dqput(transfer_to[qtype]); if (!status && attr->ia_valid & ATTR_MODE) { status = ocfs2_acl_chmod(inode, bh); if (status < 0) mlog_errno(status); } if (inode_locked) ocfs2_inode_unlock_tracker(inode, 1, &oh, had_lock); brelse(bh); return status; }"
805,271----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2136--sock.c----*sock_alloc_send_pskb,"struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len, unsigned long data_len, int noblock, int *errcode) { struct sk_buff *skb; gfp_t gfp_mask; long timeo; int err; gfp_mask = sk->sk_allocation; if (gfp_mask & __GFP_WAIT) gfp_mask |= __GFP_REPEAT; timeo = sock_sndtimeo(sk, noblock); while (1) { err = sock_error(sk); if (err != 0) goto failure; err = -EPIPE; if (sk->sk_shutdown & SEND_SHUTDOWN) goto failure; if (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) { skb = alloc_skb(header_len, gfp_mask); if (skb) { <S2SV_StartVul> int npages; <S2SV_EndVul> int i; if (!data_len) break; <S2SV_StartVul> npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT; <S2SV_EndVul> skb->truesize += data_len; skb_shinfo(skb)->nr_frags = npages; for (i = 0; i < npages; i++) { struct page *page; page = alloc_pages(sk->sk_allocation, 0); if (!page) { err = -ENOBUFS; skb_shinfo(skb)->nr_frags = i; kfree_skb(skb); goto failure; } __skb_fill_page_desc(skb, i, page, 0, (data_len >= PAGE_SIZE ? PAGE_SIZE : data_len)); data_len -= PAGE_SIZE; } break; } err = -ENOBUFS; goto failure; } set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags); set_bit(SOCK_NOSPACE, &sk->sk_socket->flags); err = -EAGAIN; if (!timeo) goto failure; if (signal_pending(current)) goto interrupted; timeo = sock_wait_for_wmem(sk, timeo); } skb_set_owner_w(skb, sk); return skb; interrupted: err = sock_intr_errno(timeo); failure: *errcode = err; return NULL; }","- int npages;
- npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+ int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+ err = -EMSGSIZE;
+ if (npages > MAX_SKB_FRAGS)
+ goto failure;","struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len, unsigned long data_len, int noblock, int *errcode) { struct sk_buff *skb; gfp_t gfp_mask; long timeo; int err; int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT; err = -EMSGSIZE; if (npages > MAX_SKB_FRAGS) goto failure; gfp_mask = sk->sk_allocation; if (gfp_mask & __GFP_WAIT) gfp_mask |= __GFP_REPEAT; timeo = sock_sndtimeo(sk, noblock); while (1) { err = sock_error(sk); if (err != 0) goto failure; err = -EPIPE; if (sk->sk_shutdown & SEND_SHUTDOWN) goto failure; if (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) { skb = alloc_skb(header_len, gfp_mask); if (skb) { int i; if (!data_len) break; skb->truesize += data_len; skb_shinfo(skb)->nr_frags = npages; for (i = 0; i < npages; i++) { struct page *page; page = alloc_pages(sk->sk_allocation, 0); if (!page) { err = -ENOBUFS; skb_shinfo(skb)->nr_frags = i; kfree_skb(skb); goto failure; } __skb_fill_page_desc(skb, i, page, 0, (data_len >= PAGE_SIZE ? PAGE_SIZE : data_len)); data_len -= PAGE_SIZE; } break; } err = -ENOBUFS; goto failure; } set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags); set_bit(SOCK_NOSPACE, &sk->sk_socket->flags); err = -EAGAIN; if (!timeo) goto failure; if (signal_pending(current)) goto interrupted; timeo = sock_wait_for_wmem(sk, timeo); } skb_set_owner_w(skb, sk); return skb; interrupted: err = sock_intr_errno(timeo); failure: *errcode = err; return NULL; }"
806,35----CWE-354----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-15994--checksum.c----csum_len_for_type,int csum_len_for_type(int cst) { switch (cst) { case CSUM_NONE: return 1; <S2SV_StartVul> case CSUM_ARCHAIC: <S2SV_EndVul> return 2; case CSUM_MD4: case CSUM_MD4_OLD: case CSUM_MD4_BUSTED: return MD4_DIGEST_LEN; case CSUM_MD5: return MD5_DIGEST_LEN; } return 0; },"- case CSUM_ARCHAIC:
+ case CSUM_MD4_ARCHAIC:",int csum_len_for_type(int cst) { switch (cst) { case CSUM_NONE: return 1; case CSUM_MD4_ARCHAIC: return 2; case CSUM_MD4: case CSUM_MD4_OLD: case CSUM_MD4_BUSTED: return MD4_DIGEST_LEN; case CSUM_MD5: return MD5_DIGEST_LEN; } return 0; }
807,5305----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/proc.c----mrb_proc_s_new,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class) { mrb_value blk; mrb_value proc; struct RProc *p; mrb_get_args(mrb, ""&!"", &blk); p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class)); <S2SV_StartVul> mrb_proc_copy(p, mrb_proc_ptr(blk)); <S2SV_EndVul> proc = mrb_obj_value(p); mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc); if (!MRB_PROC_STRICT_P(p) && mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) { p->flags |= MRB_PROC_ORPHAN; } return proc; }","- mrb_proc_copy(p, mrb_proc_ptr(blk));
+ mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));","mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class) { mrb_value blk; mrb_value proc; struct RProc *p; mrb_get_args(mrb, ""&!"", &blk); p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class)); mrb_proc_copy(mrb, p, mrb_proc_ptr(blk)); proc = mrb_obj_value(p); mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc); if (!MRB_PROC_STRICT_P(p) && mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) { p->flags |= MRB_PROC_ORPHAN; } return proc; }"
808,5221----CWE-354----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/recovery_cipher.c----recovery_character,"void recovery_character(const char *character) { <S2SV_StartVul> if (!awaiting_character) { <S2SV_EndVul> recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Not in Recovery mode""); layoutHome(); return; } if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) { recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Too many characters attempted during recovery""); layoutHome(); return; } char *pos = strchr(cipher, character[0]); if (character[0] != ' ' && pos == NULL) { recovery_abort(); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Character must be from a to z""); layoutHome(); return; } static int uncyphered_word_count = 0; static bool definitely_using_cipher = false; static CONFIDENTIAL char coded_word[12]; static CONFIDENTIAL char decoded_word[12]; if (!mnemonic[0]) { uncyphered_word_count = 0; definitely_using_cipher = false; memzero(coded_word, sizeof(coded_word)); memzero(decoded_word, sizeof(decoded_word)); } char decoded_character[2] = "" ""; if (character[0] != ' ') { decoded_character[0] = english_alphabet[(int)(pos - cipher)]; strlcat(coded_word, character, sizeof(coded_word)); strlcat(decoded_word, decoded_character, sizeof(decoded_word)); if (enforce_wordlist && 4 <= strlen(coded_word)) { bool maybe_not_using_cipher = attempt_auto_complete(coded_word); bool maybe_using_cipher = attempt_auto_complete(decoded_word); if (!maybe_not_using_cipher && maybe_using_cipher) { definitely_using_cipher = true; } else if (maybe_not_using_cipher && !definitely_using_cipher && MAX_UNCYPHERED_WORDS < uncyphered_word_count++) { recovery_abort(); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Words were not entered correctly. Make sure you are using the substition cipher.""); layoutHome(); return; } } } else { memzero(coded_word, sizeof(coded_word)); memzero(decoded_word, sizeof(decoded_word)); } strlcat(mnemonic, decoded_character, MNEMONIC_BUF); next_character(); }","- if (!awaiting_character) {
+ if (!awaiting_character || !recovery_started) {","void recovery_character(const char *character) { if (!awaiting_character || !recovery_started) { recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Not in Recovery mode""); layoutHome(); return; } if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) { recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Too many characters attempted during recovery""); layoutHome(); return; } char *pos = strchr(cipher, character[0]); if (character[0] != ' ' && pos == NULL) { recovery_abort(); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Character must be from a to z""); layoutHome(); return; } static int uncyphered_word_count = 0; static bool definitely_using_cipher = false; static CONFIDENTIAL char coded_word[12]; static CONFIDENTIAL char decoded_word[12]; if (!mnemonic[0]) { uncyphered_word_count = 0; definitely_using_cipher = false; memzero(coded_word, sizeof(coded_word)); memzero(decoded_word, sizeof(decoded_word)); } char decoded_character[2] = "" ""; if (character[0] != ' ') { decoded_character[0] = english_alphabet[(int)(pos - cipher)]; strlcat(coded_word, character, sizeof(coded_word)); strlcat(decoded_word, decoded_character, sizeof(decoded_word)); if (enforce_wordlist && 4 <= strlen(coded_word)) { bool maybe_not_using_cipher = attempt_auto_complete(coded_word); bool maybe_using_cipher = attempt_auto_complete(decoded_word); if (!maybe_not_using_cipher && maybe_using_cipher) { definitely_using_cipher = true; } else if (maybe_not_using_cipher && !definitely_using_cipher && MAX_UNCYPHERED_WORDS < uncyphered_word_count++) { recovery_abort(); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Words were not entered correctly. Make sure you are using the substition cipher.""); layoutHome(); return; } } } else { memzero(coded_word, sizeof(coded_word)); memzero(decoded_word, sizeof(decoded_word)); } strlcat(mnemonic, decoded_character, MNEMONIC_BUF); next_character(); }"
809,2286----CWE-20----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-13223--stb_vorbis.c----*get_window,"static float *get_window(vorb *f, int len) { len <<= 1; if (len == f->blocksize_0) return f->window[0]; if (len == f->blocksize_1) return f->window[1]; <S2SV_StartVul> assert(0); <S2SV_EndVul> return NULL; }",- assert(0);,"static float *get_window(vorb *f, int len) { len <<= 1; if (len == f->blocksize_0) return f->window[0]; if (len == f->blocksize_1) return f->window[1]; return NULL; }"
810,4056----CWE-668----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rijndael.c----do_encrypt,"do_encrypt (const RIJNDAEL_context *ctx, unsigned char *bx, const unsigned char *ax) { #ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, <S2SV_StartVul> encT); <S2SV_EndVul> #elif defined(USE_ARM_ASM) <S2SV_StartVul> return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT); <S2SV_EndVul> #else return do_encrypt_fn (ctx, bx, ax); #endif }","- encT);
- return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);
+ enc_tables.T);
+ return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,
+ enc_tables.T);","do_encrypt (const RIJNDAEL_context *ctx, unsigned char *bx, const unsigned char *ax) { #ifdef USE_AMD64_ASM return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, enc_tables.T); #elif defined(USE_ARM_ASM) return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, enc_tables.T); #else return do_encrypt_fn (ctx, bx, ax); #endif }"
811,3542----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/icmp.c----icmp6_send,"static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info, const struct in6_addr *force_saddr) { struct net *net = dev_net(skb->dev); struct inet6_dev *idev = NULL; struct ipv6hdr *hdr = ipv6_hdr(skb); struct sock *sk; struct ipv6_pinfo *np; const struct in6_addr *saddr = NULL; struct dst_entry *dst; struct icmp6hdr tmp_hdr; struct flowi6 fl6; struct icmpv6_msg msg; struct sockcm_cookie sockc_unused = {0}; struct ipcm6_cookie ipc6; int iif = 0; int addr_type = 0; int len; int err = 0; u32 mark = IP6_REPLY_MARK(net, skb->mark); if ((u8 *)hdr < skb->head || (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb)) return; addr_type = ipv6_addr_type(&hdr->daddr); if (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) || ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr)) saddr = &hdr->daddr; if (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) { if (type != ICMPV6_PKT_TOOBIG && !(type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && (opt_unrec(skb, info)))) return; saddr = NULL; } addr_type = ipv6_addr_type(&hdr->saddr); if (__ipv6_addr_needs_scope_id(addr_type)) iif = skb->dev->ifindex; <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> iif = l3mdev_master_ifindex(skb_dst(skb)->dev); <S2SV_EndVul> if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) { net_dbg_ratelimited(""icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } if (is_ineligible(skb)) { net_dbg_ratelimited(""icmp6_send: no reply to icmp error [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } mip6_addr_swap(skb); memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_ICMPV6; fl6.daddr = hdr->saddr; if (force_saddr) saddr = force_saddr; if (saddr) fl6.saddr = *saddr; fl6.flowi6_mark = mark; fl6.flowi6_oif = iif; fl6.fl6_icmp_type = type; fl6.fl6_icmp_code = code; security_skb_classify_flow(skb, flowi6_to_flowi(&fl6)); sk = icmpv6_xmit_lock(net); if (!sk) return; sk->sk_mark = mark; np = inet6_sk(sk); if (!icmpv6_xrlim_allow(sk, type, &fl6)) goto out; tmp_hdr.icmp6_type = type; tmp_hdr.icmp6_code = code; tmp_hdr.icmp6_cksum = 0; tmp_hdr.icmp6_pointer = htonl(info); if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) fl6.flowi6_oif = np->mcast_oif; else if (!fl6.flowi6_oif) fl6.flowi6_oif = np->ucast_oif; ipc6.tclass = np->tclass; fl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel); dst = icmpv6_route_lookup(net, skb, sk, &fl6); if (IS_ERR(dst)) goto out; ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst); ipc6.dontfrag = np->dontfrag; ipc6.opt = NULL; msg.skb = skb; msg.offset = skb_network_offset(skb); msg.type = type; len = skb->len - msg.offset; len = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr)); if (len < 0) { net_dbg_ratelimited(""icmp: len problem [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); goto out_dst_release; } rcu_read_lock(); idev = __in6_dev_get(skb->dev); err = ip6_append_data(sk, icmpv6_getfrag, &msg, len + sizeof(struct icmp6hdr), sizeof(struct icmp6hdr), &ipc6, &fl6, (struct rt6_info *)dst, MSG_DONTWAIT, &sockc_unused); if (err) { ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS); ip6_flush_pending_frames(sk); } else { err = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr, len + sizeof(struct icmp6hdr)); } rcu_read_unlock(); out_dst_release: dst_release(dst); out: icmpv6_xmit_unlock(sk); }","- else
- iif = l3mdev_master_ifindex(skb_dst(skb)->dev);
+ else {
+ dst = skb_dst(skb);
+ iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);
+ }","static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info, const struct in6_addr *force_saddr) { struct net *net = dev_net(skb->dev); struct inet6_dev *idev = NULL; struct ipv6hdr *hdr = ipv6_hdr(skb); struct sock *sk; struct ipv6_pinfo *np; const struct in6_addr *saddr = NULL; struct dst_entry *dst; struct icmp6hdr tmp_hdr; struct flowi6 fl6; struct icmpv6_msg msg; struct sockcm_cookie sockc_unused = {0}; struct ipcm6_cookie ipc6; int iif = 0; int addr_type = 0; int len; int err = 0; u32 mark = IP6_REPLY_MARK(net, skb->mark); if ((u8 *)hdr < skb->head || (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb)) return; addr_type = ipv6_addr_type(&hdr->daddr); if (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) || ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr)) saddr = &hdr->daddr; if (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) { if (type != ICMPV6_PKT_TOOBIG && !(type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && (opt_unrec(skb, info)))) return; saddr = NULL; } addr_type = ipv6_addr_type(&hdr->saddr); if (__ipv6_addr_needs_scope_id(addr_type)) iif = skb->dev->ifindex; else { dst = skb_dst(skb); iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev); } if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) { net_dbg_ratelimited(""icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } if (is_ineligible(skb)) { net_dbg_ratelimited(""icmp6_send: no reply to icmp error [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } mip6_addr_swap(skb); memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_ICMPV6; fl6.daddr = hdr->saddr; if (force_saddr) saddr = force_saddr; if (saddr) fl6.saddr = *saddr; fl6.flowi6_mark = mark; fl6.flowi6_oif = iif; fl6.fl6_icmp_type = type; fl6.fl6_icmp_code = code; security_skb_classify_flow(skb, flowi6_to_flowi(&fl6)); sk = icmpv6_xmit_lock(net); if (!sk) return; sk->sk_mark = mark; np = inet6_sk(sk); if (!icmpv6_xrlim_allow(sk, type, &fl6)) goto out; tmp_hdr.icmp6_type = type; tmp_hdr.icmp6_code = code; tmp_hdr.icmp6_cksum = 0; tmp_hdr.icmp6_pointer = htonl(info); if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) fl6.flowi6_oif = np->mcast_oif; else if (!fl6.flowi6_oif) fl6.flowi6_oif = np->ucast_oif; ipc6.tclass = np->tclass; fl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel); dst = icmpv6_route_lookup(net, skb, sk, &fl6); if (IS_ERR(dst)) goto out; ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst); ipc6.dontfrag = np->dontfrag; ipc6.opt = NULL; msg.skb = skb; msg.offset = skb_network_offset(skb); msg.type = type; len = skb->len - msg.offset; len = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr)); if (len < 0) { net_dbg_ratelimited(""icmp: len problem [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); goto out_dst_release; } rcu_read_lock(); idev = __in6_dev_get(skb->dev); err = ip6_append_data(sk, icmpv6_getfrag, &msg, len + sizeof(struct icmp6hdr), sizeof(struct icmp6hdr), &ipc6, &fl6, (struct rt6_info *)dst, MSG_DONTWAIT, &sockc_unused); if (err) { ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS); ip6_flush_pending_frames(sk); } else { err = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr, len + sizeof(struct icmp6hdr)); } rcu_read_unlock(); out_dst_release: dst_release(dst); out: icmpv6_xmit_unlock(sk); }"
812,5565----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip.c----ipStringToAddr,"error_t ipStringToAddr(const char_t *str, IpAddr *ipAddr) { error_t error; #if (IPV6_SUPPORT == ENABLED) <S2SV_StartVul> if(strchr(str, ':')) <S2SV_EndVul> { ipAddr->length = sizeof(Ipv6Addr); error = ipv6StringToAddr(str, &ipAddr->ipv6Addr); } else #endif #if (IPV4_SUPPORT == ENABLED) <S2SV_StartVul> if(strchr(str, '.')) <S2SV_EndVul> { ipAddr->length = sizeof(Ipv4Addr); error = ipv4StringToAddr(str, &ipAddr->ipv4Addr); } else #endif { error = ERROR_FAILURE; } return error; }","- if(strchr(str, ':'))
- if(strchr(str, '.'))
+ if(osStrchr(str, ':') != NULL)
+ if(osStrchr(str, '.') != NULL)","error_t ipStringToAddr(const char_t *str, IpAddr *ipAddr) { error_t error; #if (IPV6_SUPPORT == ENABLED) if(osStrchr(str, ':') != NULL) { ipAddr->length = sizeof(Ipv6Addr); error = ipv6StringToAddr(str, &ipAddr->ipv6Addr); } else #endif #if (IPV4_SUPPORT == ENABLED) if(osStrchr(str, '.') != NULL) { ipAddr->length = sizeof(Ipv4Addr); error = ipv4StringToAddr(str, &ipAddr->ipv4Addr); } else #endif { error = ERROR_FAILURE; } return error; }"
813,1576----CWE-388----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7616--mempolicy.c----COMPAT_SYSCALL_DEFINE6,"COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len, compat_ulong_t, mode, compat_ulong_t __user *, nmask, compat_ulong_t, maxnode, compat_ulong_t, flags) { <S2SV_StartVul> long err = 0; <S2SV_EndVul> unsigned long __user *nm = NULL; unsigned long nr_bits, alloc_size; nodemask_t bm; nr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES); alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8; if (nmask) { <S2SV_StartVul> err = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits); <S2SV_EndVul> nm = compat_alloc_user_space(alloc_size); <S2SV_StartVul> err |= copy_to_user(nm, nodes_addr(bm), alloc_size); <S2SV_EndVul> } <S2SV_StartVul> if (err) <S2SV_EndVul> <S2SV_StartVul> return -EFAULT; <S2SV_EndVul> return sys_mbind(start, len, mode, nm, nr_bits+1, flags); }","- long err = 0;
- err = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);
- err |= copy_to_user(nm, nodes_addr(bm), alloc_size);
- if (err)
- return -EFAULT;
+ if (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))
+ return -EFAULT;
+ if (copy_to_user(nm, nodes_addr(bm), alloc_size))
+ return -EFAULT;","COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len, compat_ulong_t, mode, compat_ulong_t __user *, nmask, compat_ulong_t, maxnode, compat_ulong_t, flags) { unsigned long __user *nm = NULL; unsigned long nr_bits, alloc_size; nodemask_t bm; nr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES); alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8; if (nmask) { if (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits)) return -EFAULT; nm = compat_alloc_user_space(alloc_size); if (copy_to_user(nm, nodes_addr(bm), alloc_size)) return -EFAULT; } return sys_mbind(start, len, mode, nm, nr_bits+1, flags); }"
814,2151----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-18224--aops.c----ocfs2_direct_IO,"static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter) { struct file *file = iocb->ki_filp; struct inode *inode = file->f_mapping->host; struct ocfs2_super *osb = OCFS2_SB(inode->i_sb); get_block_t *get_block; if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) return 0; if (iocb->ki_pos + iter->count > i_size_read(inode) && !ocfs2_supports_append_dio(osb)) return 0; if (iov_iter_rw(iter) == READ) <S2SV_StartVul> get_block = ocfs2_get_block; <S2SV_EndVul> else <S2SV_StartVul> get_block = ocfs2_dio_get_block; <S2SV_EndVul> return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter, get_block, ocfs2_dio_end_io, NULL, 0); }","- get_block = ocfs2_get_block;
- get_block = ocfs2_dio_get_block;
+ get_block = ocfs2_lock_get_block;
+ get_block = ocfs2_dio_wr_get_block;","static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter) { struct file *file = iocb->ki_filp; struct inode *inode = file->f_mapping->host; struct ocfs2_super *osb = OCFS2_SB(inode->i_sb); get_block_t *get_block; if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) return 0; if (iocb->ki_pos + iter->count > i_size_read(inode) && !ocfs2_supports_append_dio(osb)) return 0; if (iov_iter_rw(iter) == READ) get_block = ocfs2_lock_get_block; else get_block = ocfs2_dio_wr_get_block; return __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev, iter, get_block, ocfs2_dio_end_io, NULL, 0); }"
815,2081----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-8789--ntlm_message.c----ntlm_write_message_fields,"<S2SV_StartVul> void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) <S2SV_EndVul> { if (fields->MaxLen < 1) fields->MaxLen = fields->Len; Stream_Write_UINT16(s, fields->Len); Stream_Write_UINT16(s, fields->MaxLen); Stream_Write_UINT32(s, fields->BufferOffset); }","- void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
+ void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
+ ","void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) static void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields) { if (fields->MaxLen < 1) fields->MaxLen = fields->Len; Stream_Write_UINT16(s, fields->Len); Stream_Write_UINT16(s, fields->MaxLen); Stream_Write_UINT32(s, fields->BufferOffset); }"
816,3052----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4xdr.c----decode_getacl,"static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req, <S2SV_StartVul> size_t *acl_len) <S2SV_EndVul> { <S2SV_StartVul> __be32 *savep; <S2SV_EndVul> uint32_t attrlen, bitmap[3] = {0}; struct kvec *iov = req->rq_rcv_buf.head; int status; <S2SV_StartVul> *acl_len = 0; <S2SV_EndVul> if ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0) goto out; if ((status = decode_attr_bitmap(xdr, bitmap)) != 0) goto out; if ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0) goto out; if (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U))) return -EIO; if (likely(bitmap[0] & FATTR4_WORD0_ACL)) { size_t hdrlen; u32 recvd; hdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base; recvd = req->rq_rcv_buf.len - hdrlen; if (attrlen > recvd) { <S2SV_StartVul> dprintk(""NFS: server cheating in getattr"" <S2SV_EndVul> <S2SV_StartVul> "" acl reply: attrlen %u > recvd %u\n"", <S2SV_EndVul> attrlen, recvd); return -EINVAL; } xdr_read_pages(xdr, attrlen); <S2SV_StartVul> *acl_len = attrlen; <S2SV_EndVul> } else status = -EOPNOTSUPP; out: return status; }","- size_t *acl_len)
- __be32 *savep;
- dprintk(""NFS: server cheating in getattr""
- "" acl reply: attrlen %u > recvd %u\n"",
+ struct nfs_getaclres *res)
+ __be32 *savep, *bm_p;
+ res->acl_len = 0;
+ bm_p = xdr->p;
+ xdr->p = bm_p;
+ res->acl_data_offset = be32_to_cpup(bm_p) + 2;
+ res->acl_data_offset <<= 2;
+ attrlen += res->acl_data_offset;
+ if (res->acl_flags & NFS4_ACL_LEN_REQUEST) {
+ res->acl_len = attrlen;
+ goto out;
+ }
+ dprintk(""NFS: acl reply: attrlen %u > recvd %u\n"",
+ res->acl_len = attrlen;","static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req, struct nfs_getaclres *res) { __be32 *savep, *bm_p; uint32_t attrlen, bitmap[3] = {0}; struct kvec *iov = req->rq_rcv_buf.head; int status; res->acl_len = 0; if ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0) goto out; bm_p = xdr->p; if ((status = decode_attr_bitmap(xdr, bitmap)) != 0) goto out; if ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0) goto out; if (unlikely(bitmap[0] & (FATTR4_WORD0_ACL - 1U))) return -EIO; if (likely(bitmap[0] & FATTR4_WORD0_ACL)) { size_t hdrlen; u32 recvd; xdr->p = bm_p; res->acl_data_offset = be32_to_cpup(bm_p) + 2; res->acl_data_offset <<= 2; hdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base; attrlen += res->acl_data_offset; recvd = req->rq_rcv_buf.len - hdrlen; if (attrlen > recvd) { if (res->acl_flags & NFS4_ACL_LEN_REQUEST) { res->acl_len = attrlen; goto out; } dprintk(""NFS: acl reply: attrlen %u > recvd %u\n"", attrlen, recvd); return -EINVAL; } xdr_read_pages(xdr, attrlen); res->acl_len = attrlen; } else status = -EOPNOTSUPP; out: return status; }"
817,1281----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-14991--sg.c----sg_fill_request_table,"sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo) { Sg_request *srp; int val; unsigned int ms; val = 0; list_for_each_entry(srp, &sfp->rq_list, entry) { if (val > SG_MAX_QUEUE) break; <S2SV_StartVul> memset(&rinfo[val], 0, SZ_SG_REQ_INFO); <S2SV_EndVul> rinfo[val].req_state = srp->done + 1; rinfo[val].problem = srp->header.masked_status & srp->header.host_status & srp->header.driver_status; if (srp->done) rinfo[val].duration = srp->header.duration; else { ms = jiffies_to_msecs(jiffies); rinfo[val].duration = (ms > srp->header.duration) ? (ms - srp->header.duration) : 0; } rinfo[val].orphan = srp->orphan; rinfo[val].sg_io_owned = srp->sg_io_owned; rinfo[val].pack_id = srp->header.pack_id; rinfo[val].usr_ptr = srp->header.usr_ptr; val++; } }","- memset(&rinfo[val], 0, SZ_SG_REQ_INFO);","sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo) { Sg_request *srp; int val; unsigned int ms; val = 0; list_for_each_entry(srp, &sfp->rq_list, entry) { if (val > SG_MAX_QUEUE) break; rinfo[val].req_state = srp->done + 1; rinfo[val].problem = srp->header.masked_status & srp->header.host_status & srp->header.driver_status; if (srp->done) rinfo[val].duration = srp->header.duration; else { ms = jiffies_to_msecs(jiffies); rinfo[val].duration = (ms > srp->header.duration) ? (ms - srp->header.duration) : 0; } rinfo[val].orphan = srp->orphan; rinfo[val].sg_io_owned = srp->sg_io_owned; rinfo[val].pack_id = srp->header.pack_id; rinfo[val].usr_ptr = srp->header.usr_ptr; val++; } }"
818,3754----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mptctl.c----compat_mptfwxfer_ioctl,"compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct mpt_fw_xfer32 kfw32; struct mpt_fw_xfer kfw; MPT_ADAPTER *iocp = NULL; int iocnum, iocnumX; int nonblock = (filp->f_flags & O_NONBLOCK); int ret; if (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32))) return -EFAULT; iocnumX = kfw32.iocnum & 0xFF; if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) || (iocp == NULL)) { printk(KERN_DEBUG MYNAM ""::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n"", __LINE__, iocnumX); return -ENODEV; } if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0) return ret; dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT ""compat_mptfwxfer_ioctl() called\n"", iocp->name)); kfw.iocnum = iocnum; kfw.fwlen = kfw32.fwlen; kfw.bufp = compat_ptr(kfw32.bufp); <S2SV_StartVul> ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen); <S2SV_EndVul> mutex_unlock(&iocp->ioctl_cmds.mutex); return ret; }","- ret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);
+ ret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen);","compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct mpt_fw_xfer32 kfw32; struct mpt_fw_xfer kfw; MPT_ADAPTER *iocp = NULL; int iocnum, iocnumX; int nonblock = (filp->f_flags & O_NONBLOCK); int ret; if (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32))) return -EFAULT; iocnumX = kfw32.iocnum & 0xFF; if (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) || (iocp == NULL)) { printk(KERN_DEBUG MYNAM ""::compat_mptfwxfer_ioctl @%d - ioc%d not found!\n"", __LINE__, iocnumX); return -ENODEV; } if ((ret = mptctl_syscall_down(iocp, nonblock)) != 0) return ret; dctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT ""compat_mptfwxfer_ioctl() called\n"", iocp->name)); kfw.iocnum = iocnum; kfw.fwlen = kfw32.fwlen; kfw.bufp = compat_ptr(kfw32.bufp); ret = mptctl_do_fw_download(iocp, kfw.bufp, kfw.fwlen); mutex_unlock(&iocp->ioctl_cmds.mutex); return ret; }"
819,1655--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5546--slab.c----next_random_slot,static freelist_idx_t next_random_slot(union freelist_init_state *state) { <S2SV_StartVul> return (state->list[state->pos++] + state->rand) % state->count; <S2SV_EndVul> },"- return (state->list[state->pos++] + state->rand) % state->count;
+ if (state->pos >= state->count)
+ state->pos = 0;
+ return state->list[state->pos++];",static freelist_idx_t next_random_slot(union freelist_init_state *state) { if (state->pos >= state->count) state->pos = 0; return state->list[state->pos++]; }
820,888----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-9683--crypto.c----ecryptfs_decode_from_filename,"ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size, const unsigned char *src, size_t src_size) { u8 current_bit_offset = 0; size_t src_byte_offset = 0; size_t dst_byte_offset = 0; if (dst == NULL) { (*dst_size) = ecryptfs_max_decoded_size(src_size); goto out; } while (src_byte_offset < src_size) { unsigned char src_byte = filename_rev_map[(int)src[src_byte_offset]]; switch (current_bit_offset) { case 0: dst[dst_byte_offset] = (src_byte << 2); current_bit_offset = 6; break; case 6: dst[dst_byte_offset++] |= (src_byte >> 4); dst[dst_byte_offset] = ((src_byte & 0xF) << 4); current_bit_offset = 4; break; case 4: dst[dst_byte_offset++] |= (src_byte >> 2); dst[dst_byte_offset] = (src_byte << 6); current_bit_offset = 2; break; case 2: dst[dst_byte_offset++] |= (src_byte); <S2SV_StartVul> dst[dst_byte_offset] = 0; <S2SV_EndVul> current_bit_offset = 0; break; } src_byte_offset++; } (*dst_size) = dst_byte_offset; out: return; }",- dst[dst_byte_offset] = 0;,"ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size, const unsigned char *src, size_t src_size) { u8 current_bit_offset = 0; size_t src_byte_offset = 0; size_t dst_byte_offset = 0; if (dst == NULL) { (*dst_size) = ecryptfs_max_decoded_size(src_size); goto out; } while (src_byte_offset < src_size) { unsigned char src_byte = filename_rev_map[(int)src[src_byte_offset]]; switch (current_bit_offset) { case 0: dst[dst_byte_offset] = (src_byte << 2); current_bit_offset = 6; break; case 6: dst[dst_byte_offset++] |= (src_byte >> 4); dst[dst_byte_offset] = ((src_byte & 0xF) << 4); current_bit_offset = 4; break; case 4: dst[dst_byte_offset++] |= (src_byte >> 2); dst[dst_byte_offset] = (src_byte << 6); current_bit_offset = 2; break; case 2: dst[dst_byte_offset++] |= (src_byte); current_bit_offset = 0; break; } src_byte_offset++; } (*dst_size) = dst_byte_offset; out: return; }"
821,2665----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/qedi_dbg.c----qedi_dbg_notice,"qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line, const char *fmt, ...) { va_list va; struct va_format vaf; <S2SV_StartVul> char nfunc[32]; <S2SV_EndVul> <S2SV_StartVul> memset(nfunc, 0, sizeof(nfunc)); <S2SV_EndVul> <S2SV_StartVul> memcpy(nfunc, func, sizeof(nfunc) - 1); <S2SV_EndVul> va_start(va, fmt); vaf.fmt = fmt; vaf.va = &va; if (!(qedi_dbg_log & QEDI_LOG_NOTICE)) goto ret; if (likely(qedi) && likely(qedi->pdev)) pr_notice(""[%s]:[%s:%d]:%d: %pV"", <S2SV_StartVul> dev_name(&qedi->pdev->dev), nfunc, line, <S2SV_EndVul> qedi->host_no, &vaf); else <S2SV_StartVul> pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf); <S2SV_EndVul> ret: va_end(va); }","- char nfunc[32];
- memset(nfunc, 0, sizeof(nfunc));
- memcpy(nfunc, func, sizeof(nfunc) - 1);
- dev_name(&qedi->pdev->dev), nfunc, line,
- pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
+ dev_name(&qedi->pdev->dev), func, line,
+ pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);","qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line, const char *fmt, ...) { va_list va; struct va_format vaf; va_start(va, fmt); vaf.fmt = fmt; vaf.va = &va; if (!(qedi_dbg_log & QEDI_LOG_NOTICE)) goto ret; if (likely(qedi) && likely(qedi->pdev)) pr_notice(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev), func, line, qedi->host_no, &vaf); else pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf); ret: va_end(va); }"
822,7076----CWE-22----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/WebModules.cpp----CWebSock::GetSkinPath,"CString CWebSock::GetSkinPath(const CString& sSkinName) { <S2SV_StartVul> CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkinName; <S2SV_EndVul> if (!CFile::IsDir(sRet)) { <S2SV_StartVul> sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkinName; <S2SV_EndVul> if (!CFile::IsDir(sRet)) { <S2SV_StartVul> sRet = CString(_SKINDIR_) + ""/"" + sSkinName; <S2SV_EndVul> } } return sRet + ""/""; }","- CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkinName;
- sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkinName;
- sRet = CString(_SKINDIR_) + ""/"" + sSkinName;
+ const CString sSkin = sSkinName.Replace_n(""/"", ""_"").Replace_n(""."", ""_"");
+ CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkin;
+ sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkin;
+ sRet = CString(_SKINDIR_) + ""/"" + sSkin;","CString CWebSock::GetSkinPath(const CString& sSkinName) { const CString sSkin = sSkinName.Replace_n(""/"", ""_"").Replace_n(""."", ""_""); CString sRet = CZNC::Get().GetZNCPath() + ""/webskins/"" + sSkin; if (!CFile::IsDir(sRet)) { sRet = CZNC::Get().GetCurPath() + ""/webskins/"" + sSkin; if (!CFile::IsDir(sRet)) { sRet = CString(_SKINDIR_) + ""/"" + sSkin; } } return sRet + ""/""; }"
823,1907--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-19854--crypto_user_base.c----crypto_report_kpp,"static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_kpp rkpp; <S2SV_StartVul> strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type)); <S2SV_EndVul> if (nla_put(skb, CRYPTOCFGA_REPORT_KPP, sizeof(struct crypto_report_kpp), &rkpp)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }","- strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
+ strncpy(rkpp.type, ""kpp"", sizeof(rkpp.type));","static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_kpp rkpp; strncpy(rkpp.type, ""kpp"", sizeof(rkpp.type)); if (nla_put(skb, CRYPTOCFGA_REPORT_KPP, sizeof(struct crypto_report_kpp), &rkpp)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }"
824,6189----CWE-706----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/path.c----verify_dotgit_ntfs,"GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len) { git_buf *reserved = git_repository__reserved_names_win32; size_t reserved_len = git_repository__reserved_names_win32_len; size_t start = 0, i; if (repo) git_repository__reserved_names(&reserved, &reserved_len, repo, true); for (i = 0; i < reserved_len; i++) { git_buf *r = &reserved[i]; if (len >= r->size && strncasecmp(path, r->ptr, r->size) == 0) { start = r->size; break; } } if (!start) return true; <S2SV_StartVul> if (path[start] == '\\') <S2SV_EndVul> return false; for (i = start; i < len; i++) { if (path[i] != ' ' && path[i] != '.') return true; } return false; }","- if (path[start] == '\\')
+ if (path[start] == '\\' || path[start] == ':')","GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len) { git_buf *reserved = git_repository__reserved_names_win32; size_t reserved_len = git_repository__reserved_names_win32_len; size_t start = 0, i; if (repo) git_repository__reserved_names(&reserved, &reserved_len, repo, true); for (i = 0; i < reserved_len; i++) { git_buf *r = &reserved[i]; if (len >= r->size && strncasecmp(path, r->ptr, r->size) == 0) { start = r->size; break; } } if (!start) return true; if (path[start] == '\\' || path[start] == ':') return false; for (i = start; i < len; i++) { if (path[i] != ' ' && path[i] != '.') return true; } return false; }"
825,6972----CWE-320----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/authfile.c----sshkey_load_file,"sshkey_load_file(int fd, struct sshbuf *blob) { u_char buf[1024]; size_t len; struct stat st; <S2SV_StartVul> int r; <S2SV_EndVul> if (fstat(fd, &st) < 0) return SSH_ERR_SYSTEM_ERROR; if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 && st.st_size > MAX_KEY_FILE_SIZE) return SSH_ERR_INVALID_FORMAT; for (;;) { if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) { if (errno == EPIPE) break; r = SSH_ERR_SYSTEM_ERROR; goto out; } if ((r = sshbuf_put(blob, buf, len)) != 0) goto out; if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) { r = SSH_ERR_INVALID_FORMAT; goto out; } } if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 && st.st_size != (off_t)sshbuf_len(blob)) { r = SSH_ERR_FILE_CHANGED; goto out; } r = 0; out: explicit_bzero(buf, sizeof(buf)); if (r != 0) sshbuf_reset(blob); return r; }","- int r;
+ int r, dontmax = 0;
+ if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
+ dontmax = 1;
+ }
+ if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
+ (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
+ return r;","sshkey_load_file(int fd, struct sshbuf *blob) { u_char buf[1024]; size_t len; struct stat st; int r, dontmax = 0; if (fstat(fd, &st) < 0) return SSH_ERR_SYSTEM_ERROR; if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 && st.st_size > MAX_KEY_FILE_SIZE) return SSH_ERR_INVALID_FORMAT; if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) { st.st_size = 64*1024; dontmax = 1; } if ((r = sshbuf_allocate(blob, st.st_size)) != 0 || (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0)) return r; for (;;) { if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) { if (errno == EPIPE) break; r = SSH_ERR_SYSTEM_ERROR; goto out; } if ((r = sshbuf_put(blob, buf, len)) != 0) goto out; if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) { r = SSH_ERR_INVALID_FORMAT; goto out; } } if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 && st.st_size != (off_t)sshbuf_len(blob)) { r = SSH_ERR_FILE_CHANGED; goto out; } r = 0; out: explicit_bzero(buf, sizeof(buf)); if (r != 0) sshbuf_reset(blob); return r; }"
826,2536----CWE-787----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-5510--psd.c----WritePSDChannel,"static size_t WritePSDChannel(const PSDInfo *psd_info, const ImageInfo *image_info,Image *image,Image *next_image, const QuantumType quantum_type, unsigned char *compact_pixels, MagickOffsetType size_offset,const MagickBooleanType separate) { int y; MagickBooleanType monochrome; QuantumInfo *quantum_info; register const PixelPacket *p; register ssize_t i; size_t count, <S2SV_StartVul> length; <S2SV_EndVul> unsigned char *pixels; #ifdef MAGICKCORE_ZLIB_DELEGATE #define CHUNK 16384 int flush, level; unsigned char *compressed_pixels; z_stream stream; compressed_pixels=(unsigned char *) NULL; flush=Z_NO_FLUSH; #endif count=0; if (separate != MagickFalse) { size_offset=TellBlob(image)+2; count+=WriteCompressionStart(psd_info,image,next_image,1); } if (next_image->depth > 8) next_image->depth=16; monochrome=IsMonochromeImage(image,&image->exception) && (image->depth == 1) ? MagickTrue : MagickFalse; quantum_info=AcquireQuantumInfo(image_info,image); if (quantum_info == (QuantumInfo *) NULL) return(0); pixels=GetQuantumPixels(quantum_info); #ifdef MAGICKCORE_ZLIB_DELEGATE if (next_image->compression == ZipCompression) { compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK, sizeof(*compressed_pixels)); if (compressed_pixels == (unsigned char *) NULL) { quantum_info=DestroyQuantumInfo(quantum_info); return(0); } ResetMagickMemory(&stream,0,sizeof(stream)); stream.data_type=Z_BINARY; level=Z_DEFAULT_COMPRESSION; if ((image_info->quality > 0 && image_info->quality < 10)) level=(int) image_info->quality; if (deflateInit(&stream,level) != Z_OK) { quantum_info=DestroyQuantumInfo(quantum_info); return(0); } } #endif for (y=0; y < (ssize_t) next_image->rows; y++) { p=GetVirtualPixels(next_image,0,y,next_image->columns,1,&image->exception); if (p == (const PixelPacket *) NULL) break; length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info, quantum_type,pixels,&image->exception); if (monochrome != MagickFalse) for (i=0; i < (ssize_t) length; i++) pixels[i]=(~pixels[i]); if (next_image->compression == RLECompression) { length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels); count+=WriteBlob(image,length,compact_pixels); size_offset+=WritePSDOffset(psd_info,image,length,size_offset); } #ifdef MAGICKCORE_ZLIB_DELEGATE else if (next_image->compression == ZipCompression) { stream.avail_in=(uInt) length; stream.next_in=(Bytef *) pixels; if (y == (ssize_t) next_image->rows-1) flush=Z_FINISH; do { stream.avail_out=(uInt) CHUNK; stream.next_out=(Bytef *) compressed_pixels; if (deflate(&stream,flush) == Z_STREAM_ERROR) break; length=(size_t) CHUNK-stream.avail_out; if (length > 0) count+=WriteBlob(image,length,compressed_pixels); } while (stream.avail_out == 0); } #endif else count+=WriteBlob(image,length,pixels); } #ifdef MAGICKCORE_ZLIB_DELEGATE if (next_image->compression == ZipCompression) { (void) deflateEnd(&stream); compressed_pixels=(unsigned char *) RelinquishMagickMemory( compressed_pixels); } #endif quantum_info=DestroyQuantumInfo(quantum_info); return(count); }","- length;
+ ","static size_t WritePSDChannel(const PSDInfo *psd_info, const ImageInfo *image_info,Image *image,Image *next_image, const QuantumType quantum_type, unsigned char *compact_pixels, MagickOffsetType size_offset,const MagickBooleanType separate) { int y; MagickBooleanType monochrome; QuantumInfo *quantum_info; register const PixelPacket *p; register ssize_t i; size_t count, length; unsigned char *pixels; #ifdef MAGICKCORE_ZLIB_DELEGATE #define CHUNK 16384 int flush, level; unsigned char *compressed_pixels; z_stream stream; compressed_pixels=(unsigned char *) NULL; flush=Z_NO_FLUSH; #endif count=0; if (separate != MagickFalse) { size_offset=TellBlob(image)+2; count+=WriteCompressionStart(psd_info,image,next_image,1); } if (next_image->depth > 8) next_image->depth=16; monochrome=IsMonochromeImage(image,&image->exception) && (image->depth == 1) ? MagickTrue : MagickFalse; quantum_info=AcquireQuantumInfo(image_info,next_image); if (quantum_info == (QuantumInfo *) NULL) return(0); pixels=GetQuantumPixels(quantum_info); #ifdef MAGICKCORE_ZLIB_DELEGATE if (next_image->compression == ZipCompression) { compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK, sizeof(*compressed_pixels)); if (compressed_pixels == (unsigned char *) NULL) { quantum_info=DestroyQuantumInfo(quantum_info); return(0); } ResetMagickMemory(&stream,0,sizeof(stream)); stream.data_type=Z_BINARY; level=Z_DEFAULT_COMPRESSION; if ((image_info->quality > 0 && image_info->quality < 10)) level=(int) image_info->quality; if (deflateInit(&stream,level) != Z_OK) { quantum_info=DestroyQuantumInfo(quantum_info); return(0); } } #endif for (y=0; y < (ssize_t) next_image->rows; y++) { p=GetVirtualPixels(next_image,0,y,next_image->columns,1,&image->exception); if (p == (const PixelPacket *) NULL) break; length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info, quantum_type,pixels,&image->exception); if (monochrome != MagickFalse) for (i=0; i < (ssize_t) length; i++) pixels[i]=(~pixels[i]); if (next_image->compression == RLECompression) { length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels); count+=WriteBlob(image,length,compact_pixels); size_offset+=WritePSDOffset(psd_info,image,length,size_offset); } #ifdef MAGICKCORE_ZLIB_DELEGATE else if (next_image->compression == ZipCompression) { stream.avail_in=(uInt) length; stream.next_in=(Bytef *) pixels; if (y == (ssize_t) next_image->rows-1) flush=Z_FINISH; do { stream.avail_out=(uInt) CHUNK; stream.next_out=(Bytef *) compressed_pixels; if (deflate(&stream,flush) == Z_STREAM_ERROR) break; length=(size_t) CHUNK-stream.avail_out; if (length > 0) count+=WriteBlob(image,length,compressed_pixels); } while (stream.avail_out == 0); } #endif else count+=WriteBlob(image,length,pixels); } #ifdef MAGICKCORE_ZLIB_DELEGATE if (next_image->compression == ZipCompression) { (void) deflateEnd(&stream); compressed_pixels=(unsigned char *) RelinquishMagickMemory( compressed_pixels); } #endif quantum_info=DestroyQuantumInfo(quantum_info); return(count); }"
827,1196----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-6704--sock.c----sock_getsockopt,"int sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen) { struct sock *sk = sock->sk; union { int val; struct linger ling; struct timeval tm; } v; int lv = sizeof(int); int len; if (get_user(len, optlen)) return -EFAULT; if (len < 0) return -EINVAL; memset(&v, 0, sizeof(v)); switch (optname) { case SO_DEBUG: v.val = sock_flag(sk, SOCK_DBG); break; case SO_DONTROUTE: v.val = sock_flag(sk, SOCK_LOCALROUTE); break; case SO_BROADCAST: v.val = !!sock_flag(sk, SOCK_BROADCAST); break; case SO_SNDBUF: v.val = sk->sk_sndbuf; break; case SO_RCVBUF: v.val = sk->sk_rcvbuf; break; case SO_REUSEADDR: v.val = sk->sk_reuse; break; case SO_KEEPALIVE: v.val = !!sock_flag(sk, SOCK_KEEPOPEN); break; case SO_TYPE: v.val = sk->sk_type; break; case SO_PROTOCOL: v.val = sk->sk_protocol; break; case SO_DOMAIN: v.val = sk->sk_family; break; case SO_ERROR: v.val = -sock_error(sk); if (v.val == 0) v.val = xchg(&sk->sk_err_soft, 0); break; case SO_OOBINLINE: v.val = !!sock_flag(sk, SOCK_URGINLINE); break; case SO_NO_CHECK: v.val = sk->sk_no_check; break; case SO_PRIORITY: v.val = sk->sk_priority; break; case SO_LINGER: lv = sizeof(v.ling); v.ling.l_onoff = !!sock_flag(sk, SOCK_LINGER); v.ling.l_linger = sk->sk_lingertime / HZ; break; case SO_BSDCOMPAT: sock_warn_obsolete_bsdism(""getsockopt""); break; case SO_TIMESTAMP: v.val = sock_flag(sk, SOCK_RCVTSTAMP) && !sock_flag(sk, SOCK_RCVTSTAMPNS); break; case SO_TIMESTAMPNS: v.val = sock_flag(sk, SOCK_RCVTSTAMPNS); break; case SO_TIMESTAMPING: v.val = 0; if (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE)) v.val |= SOF_TIMESTAMPING_TX_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE)) v.val |= SOF_TIMESTAMPING_TX_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE)) v.val |= SOF_TIMESTAMPING_RX_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE)) v.val |= SOF_TIMESTAMPING_RX_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) v.val |= SOF_TIMESTAMPING_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE)) v.val |= SOF_TIMESTAMPING_SYS_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE)) v.val |= SOF_TIMESTAMPING_RAW_HARDWARE; break; case SO_RCVTIMEO: lv = sizeof(struct timeval); if (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) { v.tm.tv_sec = 0; v.tm.tv_usec = 0; } else { v.tm.tv_sec = sk->sk_rcvtimeo / HZ; v.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ; } break; case SO_SNDTIMEO: lv = sizeof(struct timeval); if (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) { v.tm.tv_sec = 0; v.tm.tv_usec = 0; } else { v.tm.tv_sec = sk->sk_sndtimeo / HZ; v.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ; } break; case SO_RCVLOWAT: v.val = sk->sk_rcvlowat; break; case SO_SNDLOWAT: v.val = 1; break; case SO_PASSCRED: <S2SV_StartVul> v.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0; <S2SV_EndVul> break; case SO_PEERCRED: { struct ucred peercred; if (len > sizeof(peercred)) len = sizeof(peercred); cred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred); if (copy_to_user(optval, &peercred, len)) return -EFAULT; goto lenout; } case SO_PEERNAME: { char address[128]; if (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2)) return -ENOTCONN; if (lv < len) return -EINVAL; if (copy_to_user(optval, address, len)) return -EFAULT; goto lenout; } case SO_ACCEPTCONN: v.val = sk->sk_state == TCP_LISTEN; break; case SO_PASSSEC: <S2SV_StartVul> v.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0; <S2SV_EndVul> break; case SO_PEERSEC: return security_socket_getpeersec_stream(sock, optval, optlen, len); case SO_MARK: v.val = sk->sk_mark; break; case SO_RXQ_OVFL: v.val = !!sock_flag(sk, SOCK_RXQ_OVFL); break; case SO_WIFI_STATUS: v.val = !!sock_flag(sk, SOCK_WIFI_STATUS); break; case SO_PEEK_OFF: if (!sock->ops->set_peek_off) return -EOPNOTSUPP; v.val = sk->sk_peek_off; break; case SO_NOFCS: v.val = !!sock_flag(sk, SOCK_NOFCS); break; default: return -ENOPROTOOPT; } if (len > lv) len = lv; if (copy_to_user(optval, &v, len)) return -EFAULT; lenout: if (put_user(len, optlen)) return -EFAULT; return 0; }","- v.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;
- v.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;
+ v.val = !!test_bit(SOCK_PASSCRED, &sock->flags);
+ v.val = !!test_bit(SOCK_PASSSEC, &sock->flags);","int sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen) { struct sock *sk = sock->sk; union { int val; struct linger ling; struct timeval tm; } v; int lv = sizeof(int); int len; if (get_user(len, optlen)) return -EFAULT; if (len < 0) return -EINVAL; memset(&v, 0, sizeof(v)); switch (optname) { case SO_DEBUG: v.val = sock_flag(sk, SOCK_DBG); break; case SO_DONTROUTE: v.val = sock_flag(sk, SOCK_LOCALROUTE); break; case SO_BROADCAST: v.val = !!sock_flag(sk, SOCK_BROADCAST); break; case SO_SNDBUF: v.val = sk->sk_sndbuf; break; case SO_RCVBUF: v.val = sk->sk_rcvbuf; break; case SO_REUSEADDR: v.val = sk->sk_reuse; break; case SO_KEEPALIVE: v.val = !!sock_flag(sk, SOCK_KEEPOPEN); break; case SO_TYPE: v.val = sk->sk_type; break; case SO_PROTOCOL: v.val = sk->sk_protocol; break; case SO_DOMAIN: v.val = sk->sk_family; break; case SO_ERROR: v.val = -sock_error(sk); if (v.val == 0) v.val = xchg(&sk->sk_err_soft, 0); break; case SO_OOBINLINE: v.val = !!sock_flag(sk, SOCK_URGINLINE); break; case SO_NO_CHECK: v.val = sk->sk_no_check; break; case SO_PRIORITY: v.val = sk->sk_priority; break; case SO_LINGER: lv = sizeof(v.ling); v.ling.l_onoff = !!sock_flag(sk, SOCK_LINGER); v.ling.l_linger = sk->sk_lingertime / HZ; break; case SO_BSDCOMPAT: sock_warn_obsolete_bsdism(""getsockopt""); break; case SO_TIMESTAMP: v.val = sock_flag(sk, SOCK_RCVTSTAMP) && !sock_flag(sk, SOCK_RCVTSTAMPNS); break; case SO_TIMESTAMPNS: v.val = sock_flag(sk, SOCK_RCVTSTAMPNS); break; case SO_TIMESTAMPING: v.val = 0; if (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE)) v.val |= SOF_TIMESTAMPING_TX_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE)) v.val |= SOF_TIMESTAMPING_TX_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE)) v.val |= SOF_TIMESTAMPING_RX_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE)) v.val |= SOF_TIMESTAMPING_RX_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) v.val |= SOF_TIMESTAMPING_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE)) v.val |= SOF_TIMESTAMPING_SYS_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE)) v.val |= SOF_TIMESTAMPING_RAW_HARDWARE; break; case SO_RCVTIMEO: lv = sizeof(struct timeval); if (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) { v.tm.tv_sec = 0; v.tm.tv_usec = 0; } else { v.tm.tv_sec = sk->sk_rcvtimeo / HZ; v.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ; } break; case SO_SNDTIMEO: lv = sizeof(struct timeval); if (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) { v.tm.tv_sec = 0; v.tm.tv_usec = 0; } else { v.tm.tv_sec = sk->sk_sndtimeo / HZ; v.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ; } break; case SO_RCVLOWAT: v.val = sk->sk_rcvlowat; break; case SO_SNDLOWAT: v.val = 1; break; case SO_PASSCRED: v.val = !!test_bit(SOCK_PASSCRED, &sock->flags); break; case SO_PEERCRED: { struct ucred peercred; if (len > sizeof(peercred)) len = sizeof(peercred); cred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred); if (copy_to_user(optval, &peercred, len)) return -EFAULT; goto lenout; } case SO_PEERNAME: { char address[128]; if (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2)) return -ENOTCONN; if (lv < len) return -EINVAL; if (copy_to_user(optval, address, len)) return -EFAULT; goto lenout; } case SO_ACCEPTCONN: v.val = sk->sk_state == TCP_LISTEN; break; case SO_PASSSEC: v.val = !!test_bit(SOCK_PASSSEC, &sock->flags); break; case SO_PEERSEC: return security_socket_getpeersec_stream(sock, optval, optlen, len); case SO_MARK: v.val = sk->sk_mark; break; case SO_RXQ_OVFL: v.val = !!sock_flag(sk, SOCK_RXQ_OVFL); break; case SO_WIFI_STATUS: v.val = !!sock_flag(sk, SOCK_WIFI_STATUS); break; case SO_PEEK_OFF: if (!sock->ops->set_peek_off) return -EOPNOTSUPP; v.val = sk->sk_peek_off; break; case SO_NOFCS: v.val = !!sock_flag(sk, SOCK_NOFCS); break; default: return -ENOPROTOOPT; } if (len > lv) len = lv; if (copy_to_user(optval, &v, len)) return -EFAULT; lenout: if (put_user(len, optlen)) return -EFAULT; return 0; }"
828,6968----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cdc_ncm.c----cdc_ncm_bind,"static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf) { <S2SV_StartVul> int ret; <S2SV_EndVul> if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM) return -ENODEV; <S2SV_StartVul> ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0); <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> usbnet_link_change(dev, 0, 0); <S2SV_EndVul> <S2SV_StartVul> return ret; <S2SV_EndVul> }","- int ret;
- ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);
- usbnet_link_change(dev, 0, 0);
- return ret;
+ return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);","static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf) { if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM) return -ENODEV; return cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0); }"
829,1304----CWE-834----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-14056--rl2.c----rl2_read_header,"static av_cold int rl2_read_header(AVFormatContext *s) { AVIOContext *pb = s->pb; AVStream *st; unsigned int frame_count; unsigned int audio_frame_counter = 0; unsigned int video_frame_counter = 0; unsigned int back_size; unsigned short sound_rate; unsigned short rate; unsigned short channels; unsigned short def_sound_size; unsigned int signature; unsigned int pts_den = 11025; unsigned int pts_num = 1103; unsigned int* chunk_offset = NULL; int* chunk_size = NULL; int* audio_size = NULL; int i; int ret = 0; avio_skip(pb,4); back_size = avio_rl32(pb); signature = avio_rb32(pb); avio_skip(pb, 4); frame_count = avio_rl32(pb); if(back_size > INT_MAX/2 || frame_count > INT_MAX / sizeof(uint32_t)) return AVERROR_INVALIDDATA; avio_skip(pb, 2); sound_rate = avio_rl16(pb); rate = avio_rl16(pb); channels = avio_rl16(pb); def_sound_size = avio_rl16(pb); st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO; st->codecpar->codec_id = AV_CODEC_ID_RL2; st->codecpar->codec_tag = 0; st->codecpar->width = 320; st->codecpar->height = 200; st->codecpar->extradata_size = EXTRADATA1_SIZE; if(signature == RLV3_TAG && back_size > 0) st->codecpar->extradata_size += back_size; if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0) return AVERROR(ENOMEM); if(sound_rate){ if (!channels || channels > 42) { av_log(s, AV_LOG_ERROR, ""Invalid number of channels: %d\n"", channels); return AVERROR_INVALIDDATA; } pts_num = def_sound_size; pts_den = rate; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; st->codecpar->codec_id = AV_CODEC_ID_PCM_U8; st->codecpar->codec_tag = 1; st->codecpar->channels = channels; st->codecpar->bits_per_coded_sample = 8; st->codecpar->sample_rate = rate; st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate * st->codecpar->bits_per_coded_sample; st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample / 8; avpriv_set_pts_info(st,32,1,rate); } avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den); chunk_size = av_malloc(frame_count * sizeof(uint32_t)); audio_size = av_malloc(frame_count * sizeof(uint32_t)); chunk_offset = av_malloc(frame_count * sizeof(uint32_t)); if(!chunk_size || !audio_size || !chunk_offset){ av_free(chunk_size); av_free(audio_size); av_free(chunk_offset); return AVERROR(ENOMEM); } <S2SV_StartVul> for(i=0; i < frame_count;i++) <S2SV_EndVul> chunk_size[i] = avio_rl32(pb); <S2SV_StartVul> for(i=0; i < frame_count;i++) <S2SV_EndVul> chunk_offset[i] = avio_rl32(pb); <S2SV_StartVul> for(i=0; i < frame_count;i++) <S2SV_EndVul> audio_size[i] = avio_rl32(pb) & 0xFFFF; for(i=0;i<frame_count;i++){ if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){ ret = AVERROR_INVALIDDATA; break; } if(sound_rate && audio_size[i]){ av_add_index_entry(s->streams[1], chunk_offset[i], audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME); audio_frame_counter += audio_size[i] / channels; } av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i], video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME); ++video_frame_counter; } av_free(chunk_size); av_free(audio_size); av_free(chunk_offset); return ret; }","- for(i=0; i < frame_count;i++)
- for(i=0; i < frame_count;i++)
- for(i=0; i < frame_count;i++)
+ for(i=0; i < frame_count;i++) {
+ if (avio_feof(pb))
+ return AVERROR_INVALIDDATA;
+ }
+ for(i=0; i < frame_count;i++) {
+ if (avio_feof(pb))
+ return AVERROR_INVALIDDATA;
+ }
+ for(i=0; i < frame_count;i++) {
+ if (avio_feof(pb))
+ return AVERROR_INVALIDDATA;
+ }","static av_cold int rl2_read_header(AVFormatContext *s) { AVIOContext *pb = s->pb; AVStream *st; unsigned int frame_count; unsigned int audio_frame_counter = 0; unsigned int video_frame_counter = 0; unsigned int back_size; unsigned short sound_rate; unsigned short rate; unsigned short channels; unsigned short def_sound_size; unsigned int signature; unsigned int pts_den = 11025; unsigned int pts_num = 1103; unsigned int* chunk_offset = NULL; int* chunk_size = NULL; int* audio_size = NULL; int i; int ret = 0; avio_skip(pb,4); back_size = avio_rl32(pb); signature = avio_rb32(pb); avio_skip(pb, 4); frame_count = avio_rl32(pb); if(back_size > INT_MAX/2 || frame_count > INT_MAX / sizeof(uint32_t)) return AVERROR_INVALIDDATA; avio_skip(pb, 2); sound_rate = avio_rl16(pb); rate = avio_rl16(pb); channels = avio_rl16(pb); def_sound_size = avio_rl16(pb); st = avformat_new_stream(s, NULL); if(!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO; st->codecpar->codec_id = AV_CODEC_ID_RL2; st->codecpar->codec_tag = 0; st->codecpar->width = 320; st->codecpar->height = 200; st->codecpar->extradata_size = EXTRADATA1_SIZE; if(signature == RLV3_TAG && back_size > 0) st->codecpar->extradata_size += back_size; if(ff_get_extradata(s, st->codecpar, pb, st->codecpar->extradata_size) < 0) return AVERROR(ENOMEM); if(sound_rate){ if (!channels || channels > 42) { av_log(s, AV_LOG_ERROR, ""Invalid number of channels: %d\n"", channels); return AVERROR_INVALIDDATA; } pts_num = def_sound_size; pts_den = rate; st = avformat_new_stream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; st->codecpar->codec_id = AV_CODEC_ID_PCM_U8; st->codecpar->codec_tag = 1; st->codecpar->channels = channels; st->codecpar->bits_per_coded_sample = 8; st->codecpar->sample_rate = rate; st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate * st->codecpar->bits_per_coded_sample; st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample / 8; avpriv_set_pts_info(st,32,1,rate); } avpriv_set_pts_info(s->streams[0], 32, pts_num, pts_den); chunk_size = av_malloc(frame_count * sizeof(uint32_t)); audio_size = av_malloc(frame_count * sizeof(uint32_t)); chunk_offset = av_malloc(frame_count * sizeof(uint32_t)); if(!chunk_size || !audio_size || !chunk_offset){ av_free(chunk_size); av_free(audio_size); av_free(chunk_offset); return AVERROR(ENOMEM); } for(i=0; i < frame_count;i++) { if (avio_feof(pb)) return AVERROR_INVALIDDATA; chunk_size[i] = avio_rl32(pb); } for(i=0; i < frame_count;i++) { if (avio_feof(pb)) return AVERROR_INVALIDDATA; chunk_offset[i] = avio_rl32(pb); } for(i=0; i < frame_count;i++) { if (avio_feof(pb)) return AVERROR_INVALIDDATA; audio_size[i] = avio_rl32(pb) & 0xFFFF; } for(i=0;i<frame_count;i++){ if(chunk_size[i] < 0 || audio_size[i] > chunk_size[i]){ ret = AVERROR_INVALIDDATA; break; } if(sound_rate && audio_size[i]){ av_add_index_entry(s->streams[1], chunk_offset[i], audio_frame_counter,audio_size[i], 0, AVINDEX_KEYFRAME); audio_frame_counter += audio_size[i] / channels; } av_add_index_entry(s->streams[0], chunk_offset[i] + audio_size[i], video_frame_counter,chunk_size[i]-audio_size[i],0,AVINDEX_KEYFRAME); ++video_frame_counter; } av_free(chunk_size); av_free(audio_size); av_free(chunk_offset); return ret; }"
830,3328----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/AsyncSSLSocketTest.h----folly::ReadCallback::readDataAvailable,"void readDataAvailable(size_t len) noexcept override { std::cerr << ""readDataAvailable, len "" << len << std::endl; currentBuffer.length = len; <S2SV_StartVul> wcb_->setSocket(socket_); <S2SV_EndVul> socket_->write(wcb_, currentBuffer.buffer, len, writeFlags); buffers.push_back(currentBuffer); currentBuffer.reset(); state = STATE_SUCCEEDED; }","- wcb_->setSocket(socket_);
+ if (wcb_) {
+ wcb_->setSocket(socket_);
+ }","void readDataAvailable(size_t len) noexcept override { std::cerr << ""readDataAvailable, len "" << len << std::endl; currentBuffer.length = len; if (wcb_) { wcb_->setSocket(socket_); } socket_->write(wcb_, currentBuffer.buffer, len, writeFlags); buffers.push_back(currentBuffer); currentBuffer.reset(); state = STATE_SUCCEEDED; }"
831,5870----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/authentication_commands.cpp----mongo::CmdAuthenticate::_authenticateX509,"Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) { if (!getSSLManager()) { return Status(ErrorCodes::ProtocolError, ""SSL support is required for the MONGODB-X509 mechanism.""); } if(user.getDB() != ""$external"") { return Status(ErrorCodes::ProtocolError, ""X.509 authentication must always use the $external database.""); } ClientBasic *client = ClientBasic::getCurrent(); AuthorizationSession* authorizationSession = client->getAuthorizationSession(); std::string subjectName = client->port()->getX509SubjectName(); if (user.getUser() != subjectName) { return Status(ErrorCodes::AuthenticationFailed, ""There is no x.509 client certificate matching the user.""); } else { std::string srvSubjectName = getSSLManager()->getServerSubjectName(); <S2SV_StartVul> std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find("",OU="")); <S2SV_EndVul> <S2SV_StartVul> std::string peerClusterId = subjectName.substr(subjectName.find("",OU="")); <S2SV_EndVul> <S2SV_StartVul> fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName); <S2SV_EndVul> int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); <S2SV_StartVul> if (srvClusterId == peerClusterId) { <S2SV_EndVul> if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined || clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) { return Status(ErrorCodes::AuthenticationFailed, ""The provided certificate "" ""can only be used for cluster authentication, not client "" ""authentication. The current configuration does not allow "" ""x.509 cluster authentication, check the --clusterAuthMode flag""); } authorizationSession->grantInternalAuthorization(); } else { if (_isX509AuthDisabled) { return Status(ErrorCodes::BadValue, _x509AuthenticationDisabledMessage); } Status status = authorizationSession->addAndAuthorizeUser(user); if (!status.isOK()) { return status; } } return Status::OK(); } }","- std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find("",OU=""));
- std::string peerClusterId = subjectName.substr(subjectName.find("",OU=""));
- fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);
- if (srvClusterId == peerClusterId) {
+ size_t srvClusterIdPos = srvSubjectName.find("",OU="");
+ size_t peerClusterIdPos = subjectName.find("",OU="");
+ std::string srvClusterId = srvClusterIdPos != std::string::npos ?
+ srvSubjectName.substr(srvClusterIdPos) : """";
+ std::string peerClusterId = peerClusterIdPos != std::string::npos ?
+ subjectName.substr(peerClusterIdPos) : """";
+ if (srvClusterId == peerClusterId && !srvClusterId.empty()) {","Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) { if (!getSSLManager()) { return Status(ErrorCodes::ProtocolError, ""SSL support is required for the MONGODB-X509 mechanism.""); } if(user.getDB() != ""$external"") { return Status(ErrorCodes::ProtocolError, ""X.509 authentication must always use the $external database.""); } ClientBasic *client = ClientBasic::getCurrent(); AuthorizationSession* authorizationSession = client->getAuthorizationSession(); std::string subjectName = client->port()->getX509SubjectName(); if (user.getUser() != subjectName) { return Status(ErrorCodes::AuthenticationFailed, ""There is no x.509 client certificate matching the user.""); } else { std::string srvSubjectName = getSSLManager()->getServerSubjectName(); size_t srvClusterIdPos = srvSubjectName.find("",OU=""); size_t peerClusterIdPos = subjectName.find("",OU=""); std::string srvClusterId = srvClusterIdPos != std::string::npos ? srvSubjectName.substr(srvClusterIdPos) : """"; std::string peerClusterId = peerClusterIdPos != std::string::npos ? subjectName.substr(peerClusterIdPos) : """"; int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); if (srvClusterId == peerClusterId && !srvClusterId.empty()) { if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined || clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) { return Status(ErrorCodes::AuthenticationFailed, ""The provided certificate "" ""can only be used for cluster authentication, not client "" ""authentication. The current configuration does not allow "" ""x.509 cluster authentication, check the --clusterAuthMode flag""); } authorizationSession->grantInternalAuthorization(); } else { if (_isX509AuthDisabled) { return Status(ErrorCodes::BadValue, _x509AuthenticationDisabledMessage); } Status status = authorizationSession->addAndAuthorizeUser(user); if (!status.isOK()) { return status; } } return Status::OK(); } }"
832,4527----CWE-681----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/segment_reduction_ops.cc----tensorflow::UnsortedSegmentReductionOp::Compute,"void Compute(OpKernelContext* context) override { const Tensor& data = context->input(0); const Tensor& segment_ids = context->input(1); const Tensor& num_segments = context->input(2); if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids, num_segments)) { return; } const auto segment_flat = segment_ids.flat<Index>(); <S2SV_StartVul> const Index output_rows = internal::SubtleMustCopy(static_cast<Index>( <S2SV_EndVul> num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()() : num_segments.scalar<int64>()())); OP_REQUIRES(context, output_rows >= 0, errors::InvalidArgument(""Input num_segments == "", output_rows, "" must not be negative."")); TensorShape output_shape; output_shape.AddDim(output_rows); for (int i = segment_ids.dims(); i < data.dims(); i++) { output_shape.AddDim(data.dim_size(i)); } Tensor* output = nullptr; OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output)); auto output_flat = output->flat_outer_dims<T>(); <S2SV_StartVul> auto data_ptr = data.template flat<T>().data(); <S2SV_EndVul> <S2SV_StartVul> reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat, <S2SV_EndVul> <S2SV_StartVul> data.NumElements(), data_ptr, output_flat); <S2SV_EndVul> }","- const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(
- auto data_ptr = data.template flat<T>().data();
- reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,
- data.NumElements(), data_ptr, output_flat);
+ const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>(
+ auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);
+ reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,
+ output_flat);","void Compute(OpKernelContext* context) override { const Tensor& data = context->input(0); const Tensor& segment_ids = context->input(1); const Tensor& num_segments = context->input(2); if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids, num_segments)) { return; } const auto segment_flat = segment_ids.flat<Index>(); const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>( num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()() : num_segments.scalar<int64>()())); OP_REQUIRES(context, output_rows >= 0, errors::InvalidArgument(""Input num_segments == "", output_rows, "" must not be negative."")); TensorShape output_shape; output_shape.AddDim(output_rows); for (int i = segment_ids.dims(); i < data.dims(); i++) { output_shape.AddDim(data.dim_size(i)); } Tensor* output = nullptr; OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output)); auto output_flat = output->flat_outer_dims<T>(); auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1); reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat, output_flat); }"
833,2110----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-7186--xtractprotos.c----main,"int main(int argc, char **argv) { char *filein, *str, *tempfile, *prestring, *outprotos, *protostr; const char *spacestr = "" ""; <S2SV_StartVul> char buf[L_BUF_SIZE]; <S2SV_EndVul> l_uint8 *allheaders; l_int32 i, maxindex, in_line, nflags, protos_added, firstfile, len, ret; size_t nbytes; L_BYTEA *ba, *ba2; SARRAY *sa, *safirst; static char mainName[] = ""xtractprotos""; if (argc == 1) { fprintf(stderr, ""xtractprotos [-prestring=<string>] [-protos=<where>] "" ""[list of C files]\n"" ""where the prestring is prepended to each prototype, and \n"" ""protos can be either 'inline' or the name of an output "" ""prototype file\n""); return 1; } prestring = outprotos = NULL; in_line = FALSE; nflags = 0; maxindex = L_MIN(3, argc); for (i = 1; i < maxindex; i++) { if (argv[i][0] == '-') { if (!strncmp(argv[i], ""-prestring"", 10)) { nflags++; <S2SV_StartVul> ret = sscanf(argv[i] + 1, ""prestring=%s"", buf); <S2SV_EndVul> if (ret != 1) { fprintf(stderr, ""parse failure for prestring\n""); return 1; } <S2SV_StartVul> if ((len = strlen(buf)) > L_BUF_SIZE - 3) { <S2SV_EndVul> L_WARNING(""prestring too large; omitting!\n"", mainName); } else { buf[len] = ' '; buf[len + 1] = '\0'; prestring = stringNew(buf); } } else if (!strncmp(argv[i], ""-protos"", 7)) { nflags++; <S2SV_StartVul> ret = sscanf(argv[i] + 1, ""protos=%s"", buf); <S2SV_EndVul> if (ret != 1) { fprintf(stderr, ""parse failure for protos\n""); return 1; } outprotos = stringNew(buf); if (!strncmp(outprotos, ""inline"", 7)) in_line = TRUE; } } } if (argc - nflags < 2) { fprintf(stderr, ""no files specified!\n""); return 1; } ba = l_byteaCreate(500); sa = sarrayCreate(0); sarrayAddString(sa, (char *)""/*"", L_COPY); <S2SV_StartVul> snprintf(buf, L_BUF_SIZE, <S2SV_EndVul> "" * These prototypes were autogen'd by xtractprotos, v. %s"", version); sarrayAddString(sa, buf, L_COPY); sarrayAddString(sa, (char *)"" */"", L_COPY); sarrayAddString(sa, (char *)""#ifdef __cplusplus"", L_COPY); sarrayAddString(sa, (char *)""extern \""C\"" {"", L_COPY); sarrayAddString(sa, (char *)""#endif /* __cplusplus */\n"", L_COPY); str = sarrayToString(sa, 1); l_byteaAppendString(ba, str); lept_free(str); sarrayDestroy(&sa); firstfile = 1 + nflags; protos_added = FALSE; if ((tempfile = l_makeTempFilename()) == NULL) { fprintf(stderr, ""failure to make a writeable temp file\n""); return 1; } for (i = firstfile; i < argc; i++) { filein = argv[i]; len = strlen(filein); if (filein[len - 1] == 'h') continue; <S2SV_StartVul> snprintf(buf, L_BUF_SIZE, ""cpp -ansi -DNO_PROTOS %s %s"", <S2SV_EndVul> filein, tempfile); ret = system(buf); if (ret) { fprintf(stderr, ""cpp failure for %s; continuing\n"", filein); continue; } if ((str = parseForProtos(tempfile, prestring)) == NULL) { fprintf(stderr, ""parse failure for %s; continuing\n"", filein); continue; } if (strlen(str) > 1) { l_byteaAppendString(ba, str); protos_added = TRUE; } lept_free(str); } lept_rmfile(tempfile); lept_free(tempfile); sa = sarrayCreate(0); sarrayAddString(sa, (char *)""\n#ifdef __cplusplus"", L_COPY); sarrayAddString(sa, (char *)""}"", L_COPY); sarrayAddString(sa, (char *)""#endif /* __cplusplus */"", L_COPY); str = sarrayToString(sa, 1); l_byteaAppendString(ba, str); lept_free(str); sarrayDestroy(&sa); protostr = (char *)l_byteaCopyData(ba, &nbytes); l_byteaDestroy(&ba); if (!outprotos) { fprintf(stderr, ""%s\n"", protostr); lept_free(protostr); return 0; } if (!protos_added) { fprintf(stderr, ""No protos found\n""); lept_free(protostr); return 1; } ba = l_byteaInitFromFile(""allheaders_top.txt""); if (!in_line) { snprintf(buf, sizeof(buf), ""#include \""%s\""\n"", outprotos); l_byteaAppendString(ba, buf); l_binaryWrite(outprotos, ""w"", protostr, nbytes); } else { l_byteaAppendString(ba, protostr); } ba2 = l_byteaInitFromFile(""allheaders_bot.txt""); l_byteaJoin(ba, &ba2); l_byteaWrite(""allheaders.h"", ba, 0, 0); l_byteaDestroy(&ba); lept_free(protostr); return 0; }","- char buf[L_BUF_SIZE];
- ret = sscanf(argv[i] + 1, ""prestring=%s"", buf);
- if ((len = strlen(buf)) > L_BUF_SIZE - 3) {
- ret = sscanf(argv[i] + 1, ""protos=%s"", buf);
- snprintf(buf, L_BUF_SIZE,
- snprintf(buf, L_BUF_SIZE, ""cpp -ansi -DNO_PROTOS %s %s"",
+ char buf[L_BUFSIZE];
+ ret = sscanf(argv[i] + 1, ""prestring=%490s"", buf);
+ if ((len = strlen(buf)) > L_BUFSIZE - 3) {
+ ret = sscanf(argv[i] + 1, ""protos=%490s"", buf);
+ snprintf(buf, L_BUFSIZE,
+ snprintf(buf, L_BUFSIZE, ""cpp -ansi -DNO_PROTOS %s %s"",","int main(int argc, char **argv) { char *filein, *str, *tempfile, *prestring, *outprotos, *protostr; const char *spacestr = "" ""; char buf[L_BUFSIZE]; l_uint8 *allheaders; l_int32 i, maxindex, in_line, nflags, protos_added, firstfile, len, ret; size_t nbytes; L_BYTEA *ba, *ba2; SARRAY *sa, *safirst; static char mainName[] = ""xtractprotos""; if (argc == 1) { fprintf(stderr, ""xtractprotos [-prestring=<string>] [-protos=<where>] "" ""[list of C files]\n"" ""where the prestring is prepended to each prototype, and \n"" ""protos can be either 'inline' or the name of an output "" ""prototype file\n""); return 1; } prestring = outprotos = NULL; in_line = FALSE; nflags = 0; maxindex = L_MIN(3, argc); for (i = 1; i < maxindex; i++) { if (argv[i][0] == '-') { if (!strncmp(argv[i], ""-prestring"", 10)) { nflags++; ret = sscanf(argv[i] + 1, ""prestring=%490s"", buf); if (ret != 1) { fprintf(stderr, ""parse failure for prestring\n""); return 1; } if ((len = strlen(buf)) > L_BUFSIZE - 3) { L_WARNING(""prestring too large; omitting!\n"", mainName); } else { buf[len] = ' '; buf[len + 1] = '\0'; prestring = stringNew(buf); } } else if (!strncmp(argv[i], ""-protos"", 7)) { nflags++; ret = sscanf(argv[i] + 1, ""protos=%490s"", buf); if (ret != 1) { fprintf(stderr, ""parse failure for protos\n""); return 1; } outprotos = stringNew(buf); if (!strncmp(outprotos, ""inline"", 7)) in_line = TRUE; } } } if (argc - nflags < 2) { fprintf(stderr, ""no files specified!\n""); return 1; } ba = l_byteaCreate(500); sa = sarrayCreate(0); sarrayAddString(sa, (char *)""/*"", L_COPY); snprintf(buf, L_BUFSIZE, "" * These prototypes were autogen'd by xtractprotos, v. %s"", version); sarrayAddString(sa, buf, L_COPY); sarrayAddString(sa, (char *)"" */"", L_COPY); sarrayAddString(sa, (char *)""#ifdef __cplusplus"", L_COPY); sarrayAddString(sa, (char *)""extern \""C\"" {"", L_COPY); sarrayAddString(sa, (char *)""#endif /* __cplusplus */\n"", L_COPY); str = sarrayToString(sa, 1); l_byteaAppendString(ba, str); lept_free(str); sarrayDestroy(&sa); firstfile = 1 + nflags; protos_added = FALSE; if ((tempfile = l_makeTempFilename()) == NULL) { fprintf(stderr, ""failure to make a writeable temp file\n""); return 1; } for (i = firstfile; i < argc; i++) { filein = argv[i]; len = strlen(filein); if (filein[len - 1] == 'h') continue; snprintf(buf, L_BUFSIZE, ""cpp -ansi -DNO_PROTOS %s %s"", filein, tempfile); ret = system(buf); if (ret) { fprintf(stderr, ""cpp failure for %s; continuing\n"", filein); continue; } if ((str = parseForProtos(tempfile, prestring)) == NULL) { fprintf(stderr, ""parse failure for %s; continuing\n"", filein); continue; } if (strlen(str) > 1) { l_byteaAppendString(ba, str); protos_added = TRUE; } lept_free(str); } lept_rmfile(tempfile); lept_free(tempfile); sa = sarrayCreate(0); sarrayAddString(sa, (char *)""\n#ifdef __cplusplus"", L_COPY); sarrayAddString(sa, (char *)""}"", L_COPY); sarrayAddString(sa, (char *)""#endif /* __cplusplus */"", L_COPY); str = sarrayToString(sa, 1); l_byteaAppendString(ba, str); lept_free(str); sarrayDestroy(&sa); protostr = (char *)l_byteaCopyData(ba, &nbytes); l_byteaDestroy(&ba); if (!outprotos) { fprintf(stderr, ""%s\n"", protostr); lept_free(protostr); return 0; } if (!protos_added) { fprintf(stderr, ""No protos found\n""); lept_free(protostr); return 1; } ba = l_byteaInitFromFile(""allheaders_top.txt""); if (!in_line) { snprintf(buf, sizeof(buf), ""#include \""%s\""\n"", outprotos); l_byteaAppendString(ba, buf); l_binaryWrite(outprotos, ""w"", protostr, nbytes); } else { l_byteaAppendString(ba, protostr); } ba2 = l_byteaInitFromFile(""allheaders_bot.txt""); l_byteaJoin(ba, &ba2); l_byteaWrite(""allheaders.h"", ba, 0, 0); l_byteaDestroy(&ba); lept_free(protostr); return 0; }"
834,3670----CWE-120----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/packet.c----decode_avp,"static int decode_avp(struct l2tp_avp_t *avp, const struct l2tp_attr_t *RV, const char *secret, size_t secret_len) { MD5_CTX md5_ctx; uint8_t md5[MD5_DIGEST_LENGTH]; uint8_t p1[MD5_DIGEST_LENGTH]; uint8_t *prev_block = NULL; uint16_t attr_len; uint16_t orig_attr_len; uint16_t bytes_left; uint16_t blocks_left; uint16_t last_block_len; <S2SV_StartVul> if (avp->length < sizeof(struct l2tp_avp_t) + 2) { <S2SV_EndVul> log_warn(""l2tp: incorrect hidden avp received (type %hu):"" "" length too small (%hu bytes)\n"", <S2SV_StartVul> ntohs(avp->type), avp->length); <S2SV_EndVul> return -1; } <S2SV_StartVul> attr_len = avp->length - sizeof(struct l2tp_avp_t); <S2SV_EndVul> MD5_Init(&md5_ctx); MD5_Update(&md5_ctx, &avp->type, sizeof(avp->type)); MD5_Update(&md5_ctx, secret, secret_len); MD5_Update(&md5_ctx, RV->val.octets, RV->length); MD5_Final(p1, &md5_ctx); if (attr_len <= MD5_DIGEST_LENGTH) { memxor(avp->val, p1, attr_len); return 0; } memxor(p1, avp->val, MD5_DIGEST_LENGTH); orig_attr_len = ntohs(*(uint16_t *)p1); if (orig_attr_len <= MD5_DIGEST_LENGTH - 2) { memcpy(avp->val, p1, MD5_DIGEST_LENGTH); return 0; } if (orig_attr_len > attr_len - 2) { log_warn(""l2tp: incorrect hidden avp received (type %hu):"" "" original attribute length too big (ciphered"" "" attribute length: %hu bytes, advertised original"" "" attribute length: %hu bytes)\n"", ntohs(avp->type), attr_len, orig_attr_len); return -1; } bytes_left = orig_attr_len + 2 - MD5_DIGEST_LENGTH; last_block_len = bytes_left % MD5_DIGEST_LENGTH; blocks_left = bytes_left / MD5_DIGEST_LENGTH; if (last_block_len) { prev_block = avp->val + blocks_left * MD5_DIGEST_LENGTH; MD5_Init(&md5_ctx); MD5_Update(&md5_ctx, secret, secret_len); MD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH); MD5_Final(md5, &md5_ctx); memxor(prev_block + MD5_DIGEST_LENGTH, md5, last_block_len); prev_block -= MD5_DIGEST_LENGTH; } else prev_block = avp->val + (blocks_left - 1) * MD5_DIGEST_LENGTH; while (prev_block >= avp->val) { MD5_Init(&md5_ctx); MD5_Update(&md5_ctx, secret, secret_len); MD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH); MD5_Final(md5, &md5_ctx); memxor(prev_block + MD5_DIGEST_LENGTH, md5, MD5_DIGEST_LENGTH); prev_block -= MD5_DIGEST_LENGTH; } memcpy(avp->val, p1, MD5_DIGEST_LENGTH); return 0; }","- if (avp->length < sizeof(struct l2tp_avp_t) + 2) {
- ntohs(avp->type), avp->length);
- attr_len = avp->length - sizeof(struct l2tp_avp_t);
+ uint16_t avp_len;
+ avp_len = avp->flags & L2TP_AVP_LEN_MASK;
+ if (avp_len < sizeof(struct l2tp_avp_t) + 2) {
+ ntohs(avp->type), avp_len);
+ attr_len = avp_len - sizeof(struct l2tp_avp_t);","static int decode_avp(struct l2tp_avp_t *avp, const struct l2tp_attr_t *RV, const char *secret, size_t secret_len) { MD5_CTX md5_ctx; uint8_t md5[MD5_DIGEST_LENGTH]; uint8_t p1[MD5_DIGEST_LENGTH]; uint8_t *prev_block = NULL; uint16_t avp_len; uint16_t attr_len; uint16_t orig_attr_len; uint16_t bytes_left; uint16_t blocks_left; uint16_t last_block_len; avp_len = avp->flags & L2TP_AVP_LEN_MASK; if (avp_len < sizeof(struct l2tp_avp_t) + 2) { log_warn(""l2tp: incorrect hidden avp received (type %hu):"" "" length too small (%hu bytes)\n"", ntohs(avp->type), avp_len); return -1; } attr_len = avp_len - sizeof(struct l2tp_avp_t); MD5_Init(&md5_ctx); MD5_Update(&md5_ctx, &avp->type, sizeof(avp->type)); MD5_Update(&md5_ctx, secret, secret_len); MD5_Update(&md5_ctx, RV->val.octets, RV->length); MD5_Final(p1, &md5_ctx); if (attr_len <= MD5_DIGEST_LENGTH) { memxor(avp->val, p1, attr_len); return 0; } memxor(p1, avp->val, MD5_DIGEST_LENGTH); orig_attr_len = ntohs(*(uint16_t *)p1); if (orig_attr_len <= MD5_DIGEST_LENGTH - 2) { memcpy(avp->val, p1, MD5_DIGEST_LENGTH); return 0; } if (orig_attr_len > attr_len - 2) { log_warn(""l2tp: incorrect hidden avp received (type %hu):"" "" original attribute length too big (ciphered"" "" attribute length: %hu bytes, advertised original"" "" attribute length: %hu bytes)\n"", ntohs(avp->type), attr_len, orig_attr_len); return -1; } bytes_left = orig_attr_len + 2 - MD5_DIGEST_LENGTH; last_block_len = bytes_left % MD5_DIGEST_LENGTH; blocks_left = bytes_left / MD5_DIGEST_LENGTH; if (last_block_len) { prev_block = avp->val + blocks_left * MD5_DIGEST_LENGTH; MD5_Init(&md5_ctx); MD5_Update(&md5_ctx, secret, secret_len); MD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH); MD5_Final(md5, &md5_ctx); memxor(prev_block + MD5_DIGEST_LENGTH, md5, last_block_len); prev_block -= MD5_DIGEST_LENGTH; } else prev_block = avp->val + (blocks_left - 1) * MD5_DIGEST_LENGTH; while (prev_block >= avp->val) { MD5_Init(&md5_ctx); MD5_Update(&md5_ctx, secret, secret_len); MD5_Update(&md5_ctx, prev_block, MD5_DIGEST_LENGTH); MD5_Final(md5, &md5_ctx); memxor(prev_block + MD5_DIGEST_LENGTH, md5, MD5_DIGEST_LENGTH); prev_block -= MD5_DIGEST_LENGTH; } memcpy(avp->val, p1, MD5_DIGEST_LENGTH); return 0; }"
835,2582----CWE-369----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2019-14981--feature.c----*MeanShiftImage,"MagickExport Image *MeanShiftImage(const Image *image,const size_t width, const size_t height,const double color_distance,ExceptionInfo *exception) { #define MaxMeanShiftIterations 100 #define MeanShiftImageTag ""MeanShift/Image"" CacheView *image_view, *mean_view, *pixel_view; Image *mean_image; MagickBooleanType status; MagickOffsetType progress; ssize_t y; assert(image != (const Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); mean_image=CloneImage(image,0,0,MagickTrue,exception); if (mean_image == (Image *) NULL) return((Image *) NULL); if (SetImageStorageClass(mean_image,DirectClass,exception) == MagickFalse) { mean_image=DestroyImage(mean_image); return((Image *) NULL); } status=MagickTrue; progress=0; image_view=AcquireVirtualCacheView(image,exception); pixel_view=AcquireVirtualCacheView(image,exception); mean_view=AcquireAuthenticCacheView(mean_image,exception); #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp parallel for schedule(static) shared(status,progress) \ magick_number_threads(mean_image,mean_image,mean_image->rows,1) #endif for (y=0; y < (ssize_t) mean_image->rows; y++) { register const Quantum *magick_restrict p; register Quantum *magick_restrict q; register ssize_t x; if (status == MagickFalse) continue; p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); q=GetCacheViewAuthenticPixels(mean_view,0,y,mean_image->columns,1, exception); if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) { status=MagickFalse; continue; } for (x=0; x < (ssize_t) mean_image->columns; x++) { PixelInfo mean_pixel, previous_pixel; PointInfo mean_location, previous_location; register ssize_t i; GetPixelInfo(image,&mean_pixel); GetPixelInfoPixel(image,p,&mean_pixel); mean_location.x=(double) x; mean_location.y=(double) y; for (i=0; i < MaxMeanShiftIterations; i++) { double distance, gamma; PixelInfo sum_pixel; PointInfo sum_location; ssize_t count, v; sum_location.x=0.0; sum_location.y=0.0; GetPixelInfo(image,&sum_pixel); previous_location=mean_location; previous_pixel=mean_pixel; count=0; for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++) { ssize_t u; for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++) { if ((v*v+u*u) <= (ssize_t) ((width/2)*(height/2))) { PixelInfo pixel; status=GetOneCacheViewVirtualPixelInfo(pixel_view,(ssize_t) MagickRound(mean_location.x+u),(ssize_t) MagickRound( mean_location.y+v),&pixel,exception); distance=(mean_pixel.red-pixel.red)*(mean_pixel.red-pixel.red)+ (mean_pixel.green-pixel.green)*(mean_pixel.green-pixel.green)+ (mean_pixel.blue-pixel.blue)*(mean_pixel.blue-pixel.blue); if (distance <= (color_distance*color_distance)) { sum_location.x+=mean_location.x+u; <S2SV_StartVul> sum_location.y+=mean_location.y+v; <S2SV_EndVul> sum_pixel.red+=pixel.red; sum_pixel.green+=pixel.green; sum_pixel.blue+=pixel.blue; sum_pixel.alpha+=pixel.alpha; count++; } } } } gamma=1.0/count; mean_location.x=gamma*sum_location.x; mean_location.y=gamma*sum_location.y; mean_pixel.red=gamma*sum_pixel.red; mean_pixel.green=gamma*sum_pixel.green; mean_pixel.blue=gamma*sum_pixel.blue; mean_pixel.alpha=gamma*sum_pixel.alpha; distance=(mean_location.x-previous_location.x)* (mean_location.x-previous_location.x)+ (mean_location.y-previous_location.y)* (mean_location.y-previous_location.y)+ 255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)* 255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)+ 255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)* 255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)+ 255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue)* 255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue); if (distance <= 3.0) break; } SetPixelRed(mean_image,ClampToQuantum(mean_pixel.red),q); SetPixelGreen(mean_image,ClampToQuantum(mean_pixel.green),q); SetPixelBlue(mean_image,ClampToQuantum(mean_pixel.blue),q); SetPixelAlpha(mean_image,ClampToQuantum(mean_pixel.alpha),q); p+=GetPixelChannels(image); q+=GetPixelChannels(mean_image); } if (SyncCacheViewAuthenticPixels(mean_view,exception) == MagickFalse) status=MagickFalse; if (image->progress_monitor != (MagickProgressMonitor) NULL) { MagickBooleanType proceed; #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp atomic #endif progress++; proceed=SetImageProgress(image,MeanShiftImageTag,progress,image->rows); if (proceed == MagickFalse) status=MagickFalse; } } mean_view=DestroyCacheView(mean_view); pixel_view=DestroyCacheView(pixel_view); image_view=DestroyCacheView(image_view); return(mean_image); }","- sum_location.y+=mean_location.y+v;
+ count++;","MagickExport Image *MeanShiftImage(const Image *image,const size_t width, const size_t height,const double color_distance,ExceptionInfo *exception) { #define MaxMeanShiftIterations 100 #define MeanShiftImageTag ""MeanShift/Image"" CacheView *image_view, *mean_view, *pixel_view; Image *mean_image; MagickBooleanType status; MagickOffsetType progress; ssize_t y; assert(image != (const Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); mean_image=CloneImage(image,0,0,MagickTrue,exception); if (mean_image == (Image *) NULL) return((Image *) NULL); if (SetImageStorageClass(mean_image,DirectClass,exception) == MagickFalse) { mean_image=DestroyImage(mean_image); return((Image *) NULL); } status=MagickTrue; progress=0; image_view=AcquireVirtualCacheView(image,exception); pixel_view=AcquireVirtualCacheView(image,exception); mean_view=AcquireAuthenticCacheView(mean_image,exception); #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp parallel for schedule(static) shared(status,progress) \ magick_number_threads(mean_image,mean_image,mean_image->rows,1) #endif for (y=0; y < (ssize_t) mean_image->rows; y++) { register const Quantum *magick_restrict p; register Quantum *magick_restrict q; register ssize_t x; if (status == MagickFalse) continue; p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception); q=GetCacheViewAuthenticPixels(mean_view,0,y,mean_image->columns,1, exception); if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL)) { status=MagickFalse; continue; } for (x=0; x < (ssize_t) mean_image->columns; x++) { PixelInfo mean_pixel, previous_pixel; PointInfo mean_location, previous_location; register ssize_t i; GetPixelInfo(image,&mean_pixel); GetPixelInfoPixel(image,p,&mean_pixel); mean_location.x=(double) x; mean_location.y=(double) y; for (i=0; i < MaxMeanShiftIterations; i++) { double distance, gamma; PixelInfo sum_pixel; PointInfo sum_location; ssize_t count, v; sum_location.x=0.0; sum_location.y=0.0; GetPixelInfo(image,&sum_pixel); previous_location=mean_location; previous_pixel=mean_pixel; count=0; for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++) { ssize_t u; for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++) { if ((v*v+u*u) <= (ssize_t) ((width/2)*(height/2))) { PixelInfo pixel; status=GetOneCacheViewVirtualPixelInfo(pixel_view,(ssize_t) MagickRound(mean_location.x+u),(ssize_t) MagickRound( mean_location.y+v),&pixel,exception); distance=(mean_pixel.red-pixel.red)*(mean_pixel.red-pixel.red)+ (mean_pixel.green-pixel.green)*(mean_pixel.green-pixel.green)+ (mean_pixel.blue-pixel.blue)*(mean_pixel.blue-pixel.blue); if (distance <= (color_distance*color_distance)) { sum_location.x+=mean_location.x+u; sum_location.y+=mean_location.y+v; sum_pixel.red+=pixel.red; sum_pixel.green+=pixel.green; sum_pixel.blue+=pixel.blue; sum_pixel.alpha+=pixel.alpha; count++; } } } } gamma=PerceptibleReciprocal(count); mean_location.x=gamma*sum_location.x; mean_location.y=gamma*sum_location.y; mean_pixel.red=gamma*sum_pixel.red; mean_pixel.green=gamma*sum_pixel.green; mean_pixel.blue=gamma*sum_pixel.blue; mean_pixel.alpha=gamma*sum_pixel.alpha; distance=(mean_location.x-previous_location.x)* (mean_location.x-previous_location.x)+ (mean_location.y-previous_location.y)* (mean_location.y-previous_location.y)+ 255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)* 255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)+ 255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)* 255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)+ 255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue)* 255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue); if (distance <= 3.0) break; } SetPixelRed(mean_image,ClampToQuantum(mean_pixel.red),q); SetPixelGreen(mean_image,ClampToQuantum(mean_pixel.green),q); SetPixelBlue(mean_image,ClampToQuantum(mean_pixel.blue),q); SetPixelAlpha(mean_image,ClampToQuantum(mean_pixel.alpha),q); p+=GetPixelChannels(image); q+=GetPixelChannels(mean_image); } if (SyncCacheViewAuthenticPixels(mean_view,exception) == MagickFalse) status=MagickFalse; if (image->progress_monitor != (MagickProgressMonitor) NULL) { MagickBooleanType proceed; #if defined(MAGICKCORE_OPENMP_SUPPORT) #pragma omp atomic #endif progress++; proceed=SetImageProgress(image,MeanShiftImageTag,progress,image->rows); if (proceed == MagickFalse) status=MagickFalse; } } mean_view=DestroyCacheView(mean_view); pixel_view=DestroyCacheView(pixel_view); image_view=DestroyCacheView(image_view); return(mean_image); }"
836,262--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2744--nf_conntrack_reasm.c----*nf_ct_frag6_gather,"struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user) { struct sk_buff *clone; struct net_device *dev = skb->dev; struct frag_hdr *fhdr; struct nf_ct_frag6_queue *fq; struct ipv6hdr *hdr; int fhoff, nhoff; u8 prevhdr; struct sk_buff *ret_skb = NULL; if (ipv6_hdr(skb)->payload_len == 0) { pr_debug(""payload len = 0\n""); return skb; } if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0) return skb; clone = skb_clone(skb, GFP_ATOMIC); if (clone == NULL) { pr_debug(""Can't clone skb\n""); return skb; } NFCT_FRAG6_CB(clone)->orig = skb; if (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) { pr_debug(""message is too short.\n""); goto ret_orig; } skb_set_transport_header(clone, fhoff); hdr = ipv6_hdr(clone); fhdr = (struct frag_hdr *)skb_transport_header(clone); <S2SV_StartVul> if (!(fhdr->frag_off & htons(0xFFF9))) { <S2SV_EndVul> <S2SV_StartVul> pr_debug(""Invalid fragment offset\n""); <S2SV_EndVul> <S2SV_StartVul> goto ret_orig; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh) nf_ct_frag6_evictor(); fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr); if (fq == NULL) { pr_debug(""Can't find and can't create new queue\n""); goto ret_orig; } spin_lock_bh(&fq->q.lock); if (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) { spin_unlock_bh(&fq->q.lock); pr_debug(""Can't insert skb to queue\n""); fq_put(fq); goto ret_orig; } if (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) && fq->q.meat == fq->q.len) { ret_skb = nf_ct_frag6_reasm(fq, dev); if (ret_skb == NULL) pr_debug(""Can't reassemble fragmented packets\n""); } spin_unlock_bh(&fq->q.lock); fq_put(fq); return ret_skb; ret_orig: kfree_skb(clone); return skb; }","- if (!(fhdr->frag_off & htons(0xFFF9))) {
- pr_debug(""Invalid fragment offset\n"");
- goto ret_orig;
- }","struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user) { struct sk_buff *clone; struct net_device *dev = skb->dev; struct frag_hdr *fhdr; struct nf_ct_frag6_queue *fq; struct ipv6hdr *hdr; int fhoff, nhoff; u8 prevhdr; struct sk_buff *ret_skb = NULL; if (ipv6_hdr(skb)->payload_len == 0) { pr_debug(""payload len = 0\n""); return skb; } if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0) return skb; clone = skb_clone(skb, GFP_ATOMIC); if (clone == NULL) { pr_debug(""Can't clone skb\n""); return skb; } NFCT_FRAG6_CB(clone)->orig = skb; if (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) { pr_debug(""message is too short.\n""); goto ret_orig; } skb_set_transport_header(clone, fhoff); hdr = ipv6_hdr(clone); fhdr = (struct frag_hdr *)skb_transport_header(clone); if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh) nf_ct_frag6_evictor(); fq = fq_find(fhdr->identification, user, &hdr->saddr, &hdr->daddr); if (fq == NULL) { pr_debug(""Can't find and can't create new queue\n""); goto ret_orig; } spin_lock_bh(&fq->q.lock); if (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) { spin_unlock_bh(&fq->q.lock); pr_debug(""Can't insert skb to queue\n""); fq_put(fq); goto ret_orig; } if (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) && fq->q.meat == fq->q.len) { ret_skb = nf_ct_frag6_reasm(fq, dev); if (ret_skb == NULL) pr_debug(""Can't reassemble fragmented packets\n""); } spin_unlock_bh(&fq->q.lock); fq_put(fq); return ret_skb; ret_orig: kfree_skb(clone); return skb; }"
837,896----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-9423--svc_auth_gss.c----svcauth_gss_accept_sec_context,"svcauth_gss_accept_sec_context(struct svc_req *rqst, struct rpc_gss_init_res *gr) { struct svc_rpc_gss_data *gd; struct rpc_gss_cred *gc; gss_buffer_desc recv_tok, seqbuf; gss_OID mech; OM_uint32 maj_stat = 0, min_stat = 0, ret_flags, seq; log_debug(""in svcauth_gss_accept_context()""); gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth); gc = (struct rpc_gss_cred *)rqst->rq_clntcred; memset(gr, 0, sizeof(*gr)); memset(&recv_tok, 0, sizeof(recv_tok)); if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok)) return (FALSE); gr->gr_major = gss_accept_sec_context(&gr->gr_minor, &gd->ctx, svcauth_gss_creds, &recv_tok, GSS_C_NO_CHANNEL_BINDINGS, &gd->client_name, &mech, &gr->gr_token, &ret_flags, NULL, NULL); svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok); log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor); if (gr->gr_major != GSS_S_COMPLETE && gr->gr_major != GSS_S_CONTINUE_NEEDED) { badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt); gd->ctx = GSS_C_NO_CONTEXT; goto errout; } <S2SV_EndVul> <S2SV_StartVul> if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) { <S2SV_EndVul> <S2SV_StartVul> fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n""); <S2SV_EndVul> <S2SV_StartVul> goto errout; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc)); <S2SV_EndVul> <S2SV_StartVul> gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc); <S2SV_EndVul> gr->gr_win = sizeof(gd->seqmask) * 8; gd->sec.mech = mech; gd->sec.qop = GSS_C_QOP_DEFAULT; gd->sec.svc = gc->gc_svc; gd->seq = gc->gc_seq; gd->win = gr->gr_win; if (gr->gr_major == GSS_S_COMPLETE) { #ifdef SPKM if(!g_OID_equal(gss_mech_spkm3, mech)) { #endif maj_stat = gss_display_name(&min_stat, gd->client_name, &gd->cname, &gd->sec.mech); #ifdef SPKM } #endif if (maj_stat != GSS_S_COMPLETE) { log_status(""display_name"", maj_stat, min_stat); goto errout; } #ifdef DEBUG #ifdef HAVE_HEIMDAL log_debug(""accepted context for %.*s with "" ""<mech {}, qop %d, svc %d>"", gd->cname.length, (char *)gd->cname.value, gd->sec.qop, gd->sec.svc); #else { gss_buffer_desc mechname; gss_oid_to_str(&min_stat, mech, &mechname); log_debug(""accepted context for %.*s with "" ""<mech %.*s, qop %d, svc %d>"", gd->cname.length, (char *)gd->cname.value, mechname.length, (char *)mechname.value, gd->sec.qop, gd->sec.svc); gss_release_buffer(&min_stat, &mechname); } #endif #endif seq = htonl(gr->gr_win); seqbuf.value = &seq; seqbuf.length = sizeof(seq); gss_release_buffer(&min_stat, &gd->checksum); maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT, &seqbuf, &gd->checksum); if (maj_stat != GSS_S_COMPLETE) { goto errout; } rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS; rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value; rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length; } return (TRUE); errout: gss_release_buffer(&min_stat, &gr->gr_token); return (FALSE); }","- if ((gr->gr_ctx.value = mem_alloc(sizeof(gss_union_ctx_id_desc))) == NULL) {
- fprintf(stderr, ""svcauth_gss_accept_context: out of memory\n"");
- goto errout;
- }
- memcpy(gr->gr_ctx.value, gd->ctx, sizeof(gss_union_ctx_id_desc));
- gr->gr_ctx.length = sizeof(gss_union_ctx_id_desc);
+ gr->gr_ctx.value = ""xxxx"";
+ gr->gr_ctx.length = 4;","svcauth_gss_accept_sec_context(struct svc_req *rqst, struct rpc_gss_init_res *gr) { struct svc_rpc_gss_data *gd; struct rpc_gss_cred *gc; gss_buffer_desc recv_tok, seqbuf; gss_OID mech; OM_uint32 maj_stat = 0, min_stat = 0, ret_flags, seq; log_debug(""in svcauth_gss_accept_context()""); gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth); gc = (struct rpc_gss_cred *)rqst->rq_clntcred; memset(gr, 0, sizeof(*gr)); memset(&recv_tok, 0, sizeof(recv_tok)); if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok)) return (FALSE); gr->gr_major = gss_accept_sec_context(&gr->gr_minor, &gd->ctx, svcauth_gss_creds, &recv_tok, GSS_C_NO_CHANNEL_BINDINGS, &gd->client_name, &mech, &gr->gr_token, &ret_flags, NULL, NULL); svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok); log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor); if (gr->gr_major != GSS_S_COMPLETE && gr->gr_major != GSS_S_CONTINUE_NEEDED) { badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt); gd->ctx = GSS_C_NO_CONTEXT; goto errout; } gr->gr_ctx.value = ""xxxx""; gr->gr_ctx.length = 4; gr->gr_win = sizeof(gd->seqmask) * 8; gd->sec.mech = mech; gd->sec.qop = GSS_C_QOP_DEFAULT; gd->sec.svc = gc->gc_svc; gd->seq = gc->gc_seq; gd->win = gr->gr_win; if (gr->gr_major == GSS_S_COMPLETE) { #ifdef SPKM if(!g_OID_equal(gss_mech_spkm3, mech)) { #endif maj_stat = gss_display_name(&min_stat, gd->client_name, &gd->cname, &gd->sec.mech); #ifdef SPKM } #endif if (maj_stat != GSS_S_COMPLETE) { log_status(""display_name"", maj_stat, min_stat); goto errout; } #ifdef DEBUG #ifdef HAVE_HEIMDAL log_debug(""accepted context for %.*s with "" ""<mech {}, qop %d, svc %d>"", gd->cname.length, (char *)gd->cname.value, gd->sec.qop, gd->sec.svc); #else { gss_buffer_desc mechname; gss_oid_to_str(&min_stat, mech, &mechname); log_debug(""accepted context for %.*s with "" ""<mech %.*s, qop %d, svc %d>"", gd->cname.length, (char *)gd->cname.value, mechname.length, (char *)mechname.value, gd->sec.qop, gd->sec.svc); gss_release_buffer(&min_stat, &mechname); } #endif #endif seq = htonl(gr->gr_win); seqbuf.value = &seq; seqbuf.length = sizeof(seq); gss_release_buffer(&min_stat, &gd->checksum); maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT, &seqbuf, &gd->checksum); if (maj_stat != GSS_S_COMPLETE) { goto errout; } rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS; rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value; rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length; } return (TRUE); errout: gss_release_buffer(&min_stat, &gr->gr_token); return (FALSE); }"
838,669----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3647--emulate.c----load_state_from_tss16,"static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt, struct tss_segment_16 *tss) { int ret; u8 cpl; ctxt->_eip = tss->ip; ctxt->eflags = tss->flag | 2; *reg_write(ctxt, VCPU_REGS_RAX) = tss->ax; *reg_write(ctxt, VCPU_REGS_RCX) = tss->cx; *reg_write(ctxt, VCPU_REGS_RDX) = tss->dx; *reg_write(ctxt, VCPU_REGS_RBX) = tss->bx; *reg_write(ctxt, VCPU_REGS_RSP) = tss->sp; *reg_write(ctxt, VCPU_REGS_RBP) = tss->bp; *reg_write(ctxt, VCPU_REGS_RSI) = tss->si; *reg_write(ctxt, VCPU_REGS_RDI) = tss->di; set_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR); set_segment_selector(ctxt, tss->es, VCPU_SREG_ES); set_segment_selector(ctxt, tss->cs, VCPU_SREG_CS); set_segment_selector(ctxt, tss->ss, VCPU_SREG_SS); set_segment_selector(ctxt, tss->ds, VCPU_SREG_DS); cpl = tss->cs & 3; <S2SV_StartVul> ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true); <S2SV_EndVul> if (ret != X86EMUL_CONTINUE) return ret; <S2SV_StartVul> ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true); <S2SV_EndVul> if (ret != X86EMUL_CONTINUE) return ret; <S2SV_StartVul> ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true); <S2SV_EndVul> if (ret != X86EMUL_CONTINUE) return ret; <S2SV_StartVul> ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true); <S2SV_EndVul> if (ret != X86EMUL_CONTINUE) return ret; <S2SV_StartVul> ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true); <S2SV_EndVul> if (ret != X86EMUL_CONTINUE) return ret; return X86EMUL_CONTINUE; }","- ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);
- ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);
- ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);
- ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);
- ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);
+ ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,
+ true, NULL);
+ ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,
+ true, NULL);
+ ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,
+ true, NULL);
+ ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,
+ true, NULL);
+ ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,
+ true, NULL);","static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt, struct tss_segment_16 *tss) { int ret; u8 cpl; ctxt->_eip = tss->ip; ctxt->eflags = tss->flag | 2; *reg_write(ctxt, VCPU_REGS_RAX) = tss->ax; *reg_write(ctxt, VCPU_REGS_RCX) = tss->cx; *reg_write(ctxt, VCPU_REGS_RDX) = tss->dx; *reg_write(ctxt, VCPU_REGS_RBX) = tss->bx; *reg_write(ctxt, VCPU_REGS_RSP) = tss->sp; *reg_write(ctxt, VCPU_REGS_RBP) = tss->bp; *reg_write(ctxt, VCPU_REGS_RSI) = tss->si; *reg_write(ctxt, VCPU_REGS_RDI) = tss->di; set_segment_selector(ctxt, tss->ldt, VCPU_SREG_LDTR); set_segment_selector(ctxt, tss->es, VCPU_SREG_ES); set_segment_selector(ctxt, tss->cs, VCPU_SREG_CS); set_segment_selector(ctxt, tss->ss, VCPU_SREG_SS); set_segment_selector(ctxt, tss->ds, VCPU_SREG_DS); cpl = tss->cs & 3; ret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true, NULL); if (ret != X86EMUL_CONTINUE) return ret; ret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true, NULL); if (ret != X86EMUL_CONTINUE) return ret; ret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true, NULL); if (ret != X86EMUL_CONTINUE) return ret; ret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true, NULL); if (ret != X86EMUL_CONTINUE) return ret; ret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true, NULL); if (ret != X86EMUL_CONTINUE) return ret; return X86EMUL_CONTINUE; }"
839,369----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-0716--br_multicast.c----br_multicast_add_group,"static int br_multicast_add_group(struct net_bridge *br, struct net_bridge_port *port, struct br_ip *group) { struct net_bridge_mdb_entry *mp; struct net_bridge_port_group *p; struct net_bridge_port_group __rcu **pp; unsigned long now = jiffies; int err; spin_lock(&br->multicast_lock); if (!netif_running(br->dev) || (port && port->state == BR_STATE_DISABLED)) goto out; mp = br_multicast_new_group(br, port, group); err = PTR_ERR(mp); if (IS_ERR(mp)) goto err; if (!port) { <S2SV_StartVul> hlist_add_head(&mp->mglist, &br->mglist); <S2SV_EndVul> mod_timer(&mp->timer, now + br->multicast_membership_interval); goto out; } for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL; pp = &p->next) { if (p->port == port) goto found; if ((unsigned long)p->port < (unsigned long)port) break; } p = kzalloc(sizeof(*p), GFP_ATOMIC); err = -ENOMEM; if (unlikely(!p)) goto err; p->addr = *group; p->port = port; p->next = *pp; hlist_add_head(&p->mglist, &port->mglist); setup_timer(&p->timer, br_multicast_port_group_expired, (unsigned long)p); setup_timer(&p->query_timer, br_multicast_port_group_query_expired, (unsigned long)p); rcu_assign_pointer(*pp, p); found: mod_timer(&p->timer, now + br->multicast_membership_interval); out: err = 0; err: spin_unlock(&br->multicast_lock); return err; }","- hlist_add_head(&mp->mglist, &br->mglist);
+ if (hlist_unhashed(&mp->mglist))
+ hlist_add_head(&mp->mglist, &br->mglist);","static int br_multicast_add_group(struct net_bridge *br, struct net_bridge_port *port, struct br_ip *group) { struct net_bridge_mdb_entry *mp; struct net_bridge_port_group *p; struct net_bridge_port_group __rcu **pp; unsigned long now = jiffies; int err; spin_lock(&br->multicast_lock); if (!netif_running(br->dev) || (port && port->state == BR_STATE_DISABLED)) goto out; mp = br_multicast_new_group(br, port, group); err = PTR_ERR(mp); if (IS_ERR(mp)) goto err; if (!port) { if (hlist_unhashed(&mp->mglist)) hlist_add_head(&mp->mglist, &br->mglist); mod_timer(&mp->timer, now + br->multicast_membership_interval); goto out; } for (pp = &mp->ports; (p = mlock_dereference(*pp, br)) != NULL; pp = &p->next) { if (p->port == port) goto found; if ((unsigned long)p->port < (unsigned long)port) break; } p = kzalloc(sizeof(*p), GFP_ATOMIC); err = -ENOMEM; if (unlikely(!p)) goto err; p->addr = *group; p->port = port; p->next = *pp; hlist_add_head(&p->mglist, &port->mglist); setup_timer(&p->timer, br_multicast_port_group_expired, (unsigned long)p); setup_timer(&p->query_timer, br_multicast_port_group_query_expired, (unsigned long)p); rcu_assign_pointer(*pp, p); found: mod_timer(&p->timer, now + br->multicast_membership_interval); out: err = 0; err: spin_unlock(&br->multicast_lock); return err; }"
840,5204----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/scene_dump.c----gf_dump_vrml_simple_field,"static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent) { u32 i, sf_type; GF_ChildNodeItem *list; void *slot_ptr; switch (field.fieldType) { case GF_SG_VRML_SFNODE: <S2SV_StartVul> assert ( *(GF_Node **)field.far_ptr); <S2SV_EndVul> <S2SV_StartVul> gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL); <S2SV_EndVul> return; case GF_SG_VRML_MFNODE: list = * ((GF_ChildNodeItem **) field.far_ptr); assert( list ); sdump->indent++; while (list) { gf_dump_vrml_node(sdump, list->node, 1, NULL); list = list->next; } sdump->indent--; return; case GF_SG_VRML_SFCOMMANDBUFFER: return; } if (gf_sg_vrml_is_sf_field(field.fieldType)) { if (sdump->XMLDump) StartAttribute(sdump, ""value""); gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent); if (sdump->XMLDump) EndAttribute(sdump); } else { GenMFField *mffield; mffield = (GenMFField *) field.far_ptr; sf_type = gf_sg_vrml_get_sf_type(field.fieldType); if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""[""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, "" value=\'""); } else { StartAttribute(sdump, ""value""); } for (i=0; i<mffield->count; i++) { if (i) gf_fprintf(sdump->trace, "" ""); gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent); } if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""]""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, ""\'""); } else { EndAttribute(sdump); } } }","- assert ( *(GF_Node **)field.far_ptr);
- gf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);
+ gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);","static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent) { u32 i, sf_type; GF_ChildNodeItem *list; void *slot_ptr; switch (field.fieldType) { case GF_SG_VRML_SFNODE: gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL); return; case GF_SG_VRML_MFNODE: list = * ((GF_ChildNodeItem **) field.far_ptr); assert( list ); sdump->indent++; while (list) { gf_dump_vrml_node(sdump, list->node, 1, NULL); list = list->next; } sdump->indent--; return; case GF_SG_VRML_SFCOMMANDBUFFER: return; } if (gf_sg_vrml_is_sf_field(field.fieldType)) { if (sdump->XMLDump) StartAttribute(sdump, ""value""); gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent); if (sdump->XMLDump) EndAttribute(sdump); } else { GenMFField *mffield; mffield = (GenMFField *) field.far_ptr; sf_type = gf_sg_vrml_get_sf_type(field.fieldType); if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""[""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, "" value=\'""); } else { StartAttribute(sdump, ""value""); } for (i=0; i<mffield->count; i++) { if (i) gf_fprintf(sdump->trace, "" ""); gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i); gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent); } if (!sdump->XMLDump) { gf_fprintf(sdump->trace, ""]""); } else if (sf_type==GF_SG_VRML_SFSTRING) { gf_fprintf(sdump->trace, ""\'""); } else { EndAttribute(sdump); } } }"
841,4642----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/posix-timers.c----posixtimer_rearm,"void posixtimer_rearm(struct siginfo *info) { struct k_itimer *timr; unsigned long flags; timr = lock_timer(info->si_tid, &flags); if (!timr) return; if (timr->it_requeue_pending == info->si_sys_private) { timr->kclock->timer_rearm(timr); timr->it_active = 1; timr->it_overrun_last = timr->it_overrun; <S2SV_StartVul> timr->it_overrun = -1; <S2SV_EndVul> ++timr->it_requeue_pending; <S2SV_StartVul> info->si_overrun += timr->it_overrun_last; <S2SV_EndVul> } unlock_timer(timr, flags); }","- timr->it_overrun = -1;
- info->si_overrun += timr->it_overrun_last;
+ timr->it_overrun = -1LL;
+ info->si_overrun = timer_overrun_to_int(timr, info->si_overrun);","void posixtimer_rearm(struct siginfo *info) { struct k_itimer *timr; unsigned long flags; timr = lock_timer(info->si_tid, &flags); if (!timr) return; if (timr->it_requeue_pending == info->si_sys_private) { timr->kclock->timer_rearm(timr); timr->it_active = 1; timr->it_overrun_last = timr->it_overrun; timr->it_overrun = -1LL; ++timr->it_requeue_pending; info->si_overrun = timer_overrun_to_int(timr, info->si_overrun); } unlock_timer(timr, flags); }"
842,6933----CWE-79----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/propertieswidget.cpp----PropertiesWidget::loadTorrentInfos,"void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent) { clear(); m_torrent = torrent; downloaded_pieces->setTorrent(m_torrent); pieces_availability->setTorrent(m_torrent); if (!m_torrent) return; updateSavePath(m_torrent); hash_lbl->setText(m_torrent->hash()); PropListModel->model()->clear(); if (m_torrent->hasMetadata()) { lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate)); label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize())); <S2SV_StartVul> comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment())); <S2SV_EndVul> loadUrlSeeds(); <S2SV_StartVul> label_created_by_val->setText(m_torrent->creator()); <S2SV_EndVul> PropListModel->model()->setupModelData(m_torrent->info()); filesList->setExpanded(PropListModel->index(0, 0), true); PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities()); } loadDynamicData(); }","- comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));
- label_created_by_val->setText(m_torrent->creator());
+ comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment())));
+ label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator()));","void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent) { clear(); m_torrent = torrent; downloaded_pieces->setTorrent(m_torrent); pieces_availability->setTorrent(m_torrent); if (!m_torrent) return; updateSavePath(m_torrent); hash_lbl->setText(m_torrent->hash()); PropListModel->model()->clear(); if (m_torrent->hasMetadata()) { lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate)); label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize())); comment_text->setText(Utils::Misc::parseHtmlLinks(Utils::String::toHtmlEscaped(m_torrent->comment()))); loadUrlSeeds(); label_created_by_val->setText(Utils::String::toHtmlEscaped(m_torrent->creator())); PropListModel->model()->setupModelData(m_torrent->info()); filesList->setExpanded(PropListModel->index(0, 0), true); PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities()); } loadDynamicData(); }"
843,6363----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/orders.c----update_read_cache_bitmap_v3_order,"static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, UINT16 flags) { BYTE bitsPerPixelId; BITMAP_DATA_EX* bitmapData; UINT32 new_len; BYTE* new_data; CACHE_BITMAP_V3_ORDER* cache_bitmap_v3; if (!update || !s) return NULL; cache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER)); if (!cache_bitmap_v3) goto fail; cache_bitmap_v3->cacheId = flags & 0x00000003; cache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7; bitsPerPixelId = (flags & 0x00000078) >> 3; <S2SV_StartVul> cache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId]; <S2SV_EndVul> if (Stream_GetRemainingLength(s) < 21) goto fail; Stream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); Stream_Read_UINT32(s, cache_bitmap_v3->key1); Stream_Read_UINT32(s, cache_bitmap_v3->key2); bitmapData = &cache_bitmap_v3->bitmapData; Stream_Read_UINT8(s, bitmapData->bpp); if ((bitmapData->bpp < 1) || (bitmapData->bpp > 32)) { WLog_Print(update->log, WLOG_ERROR, ""invalid bpp value %"" PRIu32 """", bitmapData->bpp); goto fail; } Stream_Seek_UINT8(s); Stream_Seek_UINT8(s); Stream_Read_UINT8(s, bitmapData->codecID); Stream_Read_UINT16(s, bitmapData->width); Stream_Read_UINT16(s, bitmapData->height); Stream_Read_UINT32(s, new_len); if ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len)) goto fail; new_data = (BYTE*)realloc(bitmapData->data, new_len); if (!new_data) goto fail; bitmapData->data = new_data; bitmapData->length = new_len; Stream_Read(s, bitmapData->data, bitmapData->length); return cache_bitmap_v3; fail: free_cache_bitmap_v3_order(update->context, cache_bitmap_v3); return NULL; }","- cache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];
+ BOOL rc;
+ cache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);
+ if (!rc)
+ goto fail;","static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s, UINT16 flags) { BOOL rc; BYTE bitsPerPixelId; BITMAP_DATA_EX* bitmapData; UINT32 new_len; BYTE* new_data; CACHE_BITMAP_V3_ORDER* cache_bitmap_v3; if (!update || !s) return NULL; cache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER)); if (!cache_bitmap_v3) goto fail; cache_bitmap_v3->cacheId = flags & 0x00000003; cache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7; bitsPerPixelId = (flags & 0x00000078) >> 3; cache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc); if (!rc) goto fail; if (Stream_GetRemainingLength(s) < 21) goto fail; Stream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); Stream_Read_UINT32(s, cache_bitmap_v3->key1); Stream_Read_UINT32(s, cache_bitmap_v3->key2); bitmapData = &cache_bitmap_v3->bitmapData; Stream_Read_UINT8(s, bitmapData->bpp); if ((bitmapData->bpp < 1) || (bitmapData->bpp > 32)) { WLog_Print(update->log, WLOG_ERROR, ""invalid bpp value %"" PRIu32 """", bitmapData->bpp); goto fail; } Stream_Seek_UINT8(s); Stream_Seek_UINT8(s); Stream_Read_UINT8(s, bitmapData->codecID); Stream_Read_UINT16(s, bitmapData->width); Stream_Read_UINT16(s, bitmapData->height); Stream_Read_UINT32(s, new_len); if ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len)) goto fail; new_data = (BYTE*)realloc(bitmapData->data, new_len); if (!new_data) goto fail; bitmapData->data = new_data; bitmapData->length = new_len; Stream_Read(s, bitmapData->data, bitmapData->length); return cache_bitmap_v3; fail: free_cache_bitmap_v3_order(update->context, cache_bitmap_v3); return NULL; }"
844,6237----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/BLSCrypto.cpp----hex2carray,"bool hex2carray(const char *_hex, uint64_t *_bin_len, uint8_t *_bin, uint64_t _max_length) { CHECK_STATE(_hex); CHECK_STATE(_bin); CHECK_STATE(_bin_len) <S2SV_StartVul> int len = strnlen(_hex, 2 * _max_length + 1); <S2SV_EndVul> CHECK_STATE(len != 2 * _max_length + 1); CHECK_STATE(len <= 2 * _max_length ); if (len == 0 && len % 2 == 1) return false; *_bin_len = len / 2; <S2SV_StartVul> for (int i = 0; i < len / 2; i++) { <S2SV_EndVul> int high = char2int((char) _hex[i * 2]); int low = char2int((char) _hex[i * 2 + 1]); if (high < 0 || low < 0) { return false; } _bin[i] = (unsigned char) (high * 16 + low); } return true; }","- int len = strnlen(_hex, 2 * _max_length + 1);
- for (int i = 0; i < len / 2; i++) {
+ uint64_t len = strnlen(_hex, 2 * _max_length + 1);
+ for (uint64_t i = 0; i < len / 2; i++) {","bool hex2carray(const char *_hex, uint64_t *_bin_len, uint8_t *_bin, uint64_t _max_length) { CHECK_STATE(_hex); CHECK_STATE(_bin); CHECK_STATE(_bin_len) uint64_t len = strnlen(_hex, 2 * _max_length + 1); CHECK_STATE(len != 2 * _max_length + 1); CHECK_STATE(len <= 2 * _max_length ); if (len == 0 && len % 2 == 1) return false; *_bin_len = len / 2; for (uint64_t i = 0; i < len / 2; i++) { int high = char2int((char) _hex[i * 2]); int low = char2int((char) _hex[i * 2 + 1]); if (high < 0 || low < 0) { return false; } _bin[i] = (unsigned char) (high * 16 + low); } return true; }"
845,5152----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----pci_cfgrw,"pci_cfgrw(struct vmctx *ctx, int vcpu, int in, int bus, int slot, int func, int coff, int bytes, uint32_t *eax) { struct businfo *bi; struct slotinfo *si; struct pci_vdev *dev; struct pci_vdev_ops *ops; int idx, needcfg; uint64_t addr, bar, mask; bool decode, ignore_reg_unreg = false; bi = pci_businfo[bus]; if (bi != NULL) { si = &bi->slotinfo[slot]; dev = si->si_funcs[func].fi_devi; } else dev = NULL; if (dev == NULL || (bytes != 1 && bytes != 2 && bytes != 4) || (coff & (bytes - 1)) != 0) { if (in) *eax = 0xffffffff; return; } ops = dev->dev_ops; if (strcmp(""passthru"", ops->class_name)) { if (coff >= PCI_REGMAX + 1) { if (in) { *eax = 0xffffffff; if (coff <= PCI_REGMAX + 4) *eax = 0x00000000; } return; } } if (in) { if (ops->vdev_cfgread != NULL) { needcfg = ops->vdev_cfgread(ctx, vcpu, dev, coff, bytes, eax); } else { needcfg = 1; } if (needcfg) *eax = CFGREAD(dev, coff, bytes); pci_emul_hdrtype_fixup(bus, slot, coff, bytes, eax); } else { if (ops->vdev_cfgwrite != NULL && (*ops->vdev_cfgwrite)(ctx, vcpu, dev, coff, bytes, *eax) == 0) return; if (coff >= PCIR_BAR(0) && coff < PCIR_BAR(PCI_BARMAX + 1)) { if (bytes != 4 || (coff & 0x3) != 0) return; idx = (coff - PCIR_BAR(0)) / 4; mask = ~(dev->bar[idx].size - 1); if (dev->bar[idx].type == PCIBAR_IO) decode = porten(dev); else decode = memen(dev); if (decode) { if (!dev->bar[idx].sizing && (*eax == ~0U)) { dev->bar[idx].sizing = true; ignore_reg_unreg = true; } else if (dev->bar[idx].sizing && (*eax != ~0U)) { dev->bar[idx].sizing = false; ignore_reg_unreg = true; } } switch (dev->bar[idx].type) { case PCIBAR_NONE: dev->bar[idx].addr = bar = 0; break; case PCIBAR_IO: addr = *eax & mask; addr &= 0xffff; bar = addr | PCIM_BAR_IO_SPACE; if (addr != dev->bar[idx].addr) { update_bar_address(ctx, dev, addr, idx, PCIBAR_IO, ignore_reg_unreg); } break; case PCIBAR_MEM32: addr = bar = *eax & mask; bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32; if (addr != dev->bar[idx].addr) { update_bar_address(ctx, dev, addr, idx, PCIBAR_MEM32, ignore_reg_unreg); } break; case PCIBAR_MEM64: addr = bar = *eax & mask; bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH; if (addr != (uint32_t)dev->bar[idx].addr) { update_bar_address(ctx, dev, addr, idx, PCIBAR_MEM64, ignore_reg_unreg); } break; case PCIBAR_MEMHI64: <S2SV_StartVul> assert(idx >= 1); <S2SV_EndVul> mask = ~(dev->bar[idx - 1].size - 1); addr = ((uint64_t)*eax << 32) & mask; bar = addr >> 32; if (bar != dev->bar[idx - 1].addr >> 32) { update_bar_address(ctx, dev, addr, idx - 1, PCIBAR_MEMHI64, ignore_reg_unreg); } break; default: <S2SV_StartVul> assert(0); <S2SV_EndVul> } pci_set_cfgdata32(dev, coff, bar); } else if (coff == PCIR_BIOS) { } else if (pci_emul_iscap(dev, coff)) { pci_emul_capwrite(dev, coff, bytes, *eax); } else if (coff >= PCIR_COMMAND && coff < PCIR_REVID) { pci_emul_cmdsts_write(dev, coff, *eax, bytes); } else { CFGWRITE(dev, coff, *eax, bytes); } } }","- assert(idx >= 1);
- assert(0);
+ pr_err(""%s: invalid bar type %d\n"", __func__, dev->bar[idx].type);
+ return;","pci_cfgrw(struct vmctx *ctx, int vcpu, int in, int bus, int slot, int func, int coff, int bytes, uint32_t *eax) { struct businfo *bi; struct slotinfo *si; struct pci_vdev *dev; struct pci_vdev_ops *ops; int idx, needcfg; uint64_t addr, bar, mask; bool decode, ignore_reg_unreg = false; bi = pci_businfo[bus]; if (bi != NULL) { si = &bi->slotinfo[slot]; dev = si->si_funcs[func].fi_devi; } else dev = NULL; if (dev == NULL || (bytes != 1 && bytes != 2 && bytes != 4) || (coff & (bytes - 1)) != 0) { if (in) *eax = 0xffffffff; return; } ops = dev->dev_ops; if (strcmp(""passthru"", ops->class_name)) { if (coff >= PCI_REGMAX + 1) { if (in) { *eax = 0xffffffff; if (coff <= PCI_REGMAX + 4) *eax = 0x00000000; } return; } } if (in) { if (ops->vdev_cfgread != NULL) { needcfg = ops->vdev_cfgread(ctx, vcpu, dev, coff, bytes, eax); } else { needcfg = 1; } if (needcfg) *eax = CFGREAD(dev, coff, bytes); pci_emul_hdrtype_fixup(bus, slot, coff, bytes, eax); } else { if (ops->vdev_cfgwrite != NULL && (*ops->vdev_cfgwrite)(ctx, vcpu, dev, coff, bytes, *eax) == 0) return; if (coff >= PCIR_BAR(0) && coff < PCIR_BAR(PCI_BARMAX + 1)) { if (bytes != 4 || (coff & 0x3) != 0) return; idx = (coff - PCIR_BAR(0)) / 4; mask = ~(dev->bar[idx].size - 1); if (dev->bar[idx].type == PCIBAR_IO) decode = porten(dev); else decode = memen(dev); if (decode) { if (!dev->bar[idx].sizing && (*eax == ~0U)) { dev->bar[idx].sizing = true; ignore_reg_unreg = true; } else if (dev->bar[idx].sizing && (*eax != ~0U)) { dev->bar[idx].sizing = false; ignore_reg_unreg = true; } } switch (dev->bar[idx].type) { case PCIBAR_NONE: dev->bar[idx].addr = bar = 0; break; case PCIBAR_IO: addr = *eax & mask; addr &= 0xffff; bar = addr | PCIM_BAR_IO_SPACE; if (addr != dev->bar[idx].addr) { update_bar_address(ctx, dev, addr, idx, PCIBAR_IO, ignore_reg_unreg); } break; case PCIBAR_MEM32: addr = bar = *eax & mask; bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_32; if (addr != dev->bar[idx].addr) { update_bar_address(ctx, dev, addr, idx, PCIBAR_MEM32, ignore_reg_unreg); } break; case PCIBAR_MEM64: addr = bar = *eax & mask; bar |= PCIM_BAR_MEM_SPACE | PCIM_BAR_MEM_64 | PCIM_BAR_MEM_PREFETCH; if (addr != (uint32_t)dev->bar[idx].addr) { update_bar_address(ctx, dev, addr, idx, PCIBAR_MEM64, ignore_reg_unreg); } break; case PCIBAR_MEMHI64: mask = ~(dev->bar[idx - 1].size - 1); addr = ((uint64_t)*eax << 32) & mask; bar = addr >> 32; if (bar != dev->bar[idx - 1].addr >> 32) { update_bar_address(ctx, dev, addr, idx - 1, PCIBAR_MEMHI64, ignore_reg_unreg); } break; default: pr_err(""%s: invalid bar type %d\n"", __func__, dev->bar[idx].type); return; } pci_set_cfgdata32(dev, coff, bar); } else if (coff == PCIR_BIOS) { } else if (pci_emul_iscap(dev, coff)) { pci_emul_capwrite(dev, coff, bytes, *eax); } else if (coff >= PCIR_COMMAND && coff < PCIR_REVID) { pci_emul_cmdsts_write(dev, coff, *eax, bytes); } else { CFGWRITE(dev, coff, *eax, bytes); } } }"
846,2451----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3346--scsi-disk.c----scsi_write_complete,"static void scsi_write_complete(void * opaque, int ret) { SCSIDiskReq *r = (SCSIDiskReq *)opaque; <S2SV_StartVul> SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); <S2SV_EndVul> uint32_t len; uint32_t n; if (r->req.aiocb != NULL) { r->req.aiocb = NULL; bdrv_acct_done(s->bs, &r->acct); } if (ret) { if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) { return; } } <S2SV_StartVul> <S2SV_EndVul> n = r->iov.iov_len / 512; r->sector += n; r->sector_count -= n; if (r->sector_count == 0) { scsi_req_complete(&r->req, GOOD); <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> len = r->sector_count * 512; <S2SV_EndVul> <S2SV_StartVul> if (len > SCSI_DMA_BUF_SIZE) { <S2SV_EndVul> <S2SV_StartVul> len = SCSI_DMA_BUF_SIZE; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> r->iov.iov_len = len; <S2SV_EndVul> <S2SV_StartVul> DPRINTF(""Write complete tag=0x%x more=%d\n"", r->req.tag, len); <S2SV_EndVul> scsi_req_data(&r->req, len); } }","- SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
- 
- } else {
- len = r->sector_count * 512;
- if (len > SCSI_DMA_BUF_SIZE) {
- len = SCSI_DMA_BUF_SIZE;
- }
- r->iov.iov_len = len;
- DPRINTF(""Write complete tag=0x%x more=%d\n"", r->req.tag, len);
+ bdrv_acct_done(s->bs, &r->acct);
+ }
+ }
+ ","static void scsi_write_complete(void * opaque, int ret) { SCSIDiskReq *r = (SCSIDiskReq *)opaque; SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; if (r->req.aiocb != NULL) { r->req.aiocb = NULL; bdrv_acct_done(s->bs, &r->acct); } if (ret) { if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) { return; } } n = r->qiov.size / 512; r->sector += n; r->sector_count -= n; if (r->sector_count == 0) { scsi_req_complete(&r->req, GOOD); } else { scsi_init_iovec(r); DPRINTF(""Write complete tag=0x%x more=%d\n"", r->req.tag, r->qiov.size); scsi_req_data(&r->req, r->qiov.size); } }"
847,904----CWE-17----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-8172--open.c----do_dentry_open,"static int do_dentry_open(struct file *f, int (*open)(struct inode *, struct file *), const struct cred *cred) { static const struct file_operations empty_fops = {}; struct inode *inode; int error; f->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; if (unlikely(f->f_flags & O_PATH)) f->f_mode = FMODE_PATH; path_get(&f->f_path); inode = f->f_inode = f->f_path.dentry->d_inode; if (f->f_mode & FMODE_WRITE) { error = __get_file_write_access(inode, f->f_path.mnt); if (error) goto cleanup_file; if (!special_file(inode->i_mode)) file_take_write(f); } f->f_mapping = inode->i_mapping; <S2SV_StartVul> file_sb_list_add(f, inode->i_sb); <S2SV_EndVul> if (unlikely(f->f_mode & FMODE_PATH)) { f->f_op = &empty_fops; return 0; } f->f_op = fops_get(inode->i_fop); if (unlikely(WARN_ON(!f->f_op))) { error = -ENODEV; goto cleanup_all; } error = security_file_open(f, cred); if (error) goto cleanup_all; error = break_lease(inode, f->f_flags); if (error) goto cleanup_all; if (!open) open = f->f_op->open; if (open) { error = open(inode, f); if (error) goto cleanup_all; } if ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) i_readcount_inc(inode); f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); file_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping); return 0; cleanup_all: fops_put(f->f_op); <S2SV_StartVul> file_sb_list_del(f); <S2SV_EndVul> if (f->f_mode & FMODE_WRITE) { put_write_access(inode); if (!special_file(inode->i_mode)) { file_reset_write(f); __mnt_drop_write(f->f_path.mnt); } } cleanup_file: path_put(&f->f_path); f->f_path.mnt = NULL; f->f_path.dentry = NULL; f->f_inode = NULL; return error; }","- file_sb_list_add(f, inode->i_sb);
- file_sb_list_del(f);","static int do_dentry_open(struct file *f, int (*open)(struct inode *, struct file *), const struct cred *cred) { static const struct file_operations empty_fops = {}; struct inode *inode; int error; f->f_mode = OPEN_FMODE(f->f_flags) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; if (unlikely(f->f_flags & O_PATH)) f->f_mode = FMODE_PATH; path_get(&f->f_path); inode = f->f_inode = f->f_path.dentry->d_inode; if (f->f_mode & FMODE_WRITE) { error = __get_file_write_access(inode, f->f_path.mnt); if (error) goto cleanup_file; if (!special_file(inode->i_mode)) file_take_write(f); } f->f_mapping = inode->i_mapping; if (unlikely(f->f_mode & FMODE_PATH)) { f->f_op = &empty_fops; return 0; } f->f_op = fops_get(inode->i_fop); if (unlikely(WARN_ON(!f->f_op))) { error = -ENODEV; goto cleanup_all; } error = security_file_open(f, cred); if (error) goto cleanup_all; error = break_lease(inode, f->f_flags); if (error) goto cleanup_all; if (!open) open = f->f_op->open; if (open) { error = open(inode, f); if (error) goto cleanup_all; } if ((f->f_mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ) i_readcount_inc(inode); f->f_flags &= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); file_ra_state_init(&f->f_ra, f->f_mapping->host->i_mapping); return 0; cleanup_all: fops_put(f->f_op); if (f->f_mode & FMODE_WRITE) { put_write_access(inode); if (!special_file(inode->i_mode)) { file_reset_write(f); __mnt_drop_write(f->f_path.mnt); } } cleanup_file: path_put(&f->f_path); f->f_path.mnt = NULL; f->f_path.dentry = NULL; f->f_inode = NULL; return error; }"
848,2127----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-5344--loop.c----lo_release,"<S2SV_StartVul> static void lo_release(struct gendisk *disk, fmode_t mode) <S2SV_EndVul> { <S2SV_StartVul> struct loop_device *lo = disk->private_data; <S2SV_EndVul> int err; if (atomic_dec_return(&lo->lo_refcnt)) return; mutex_lock(&lo->lo_ctl_mutex); if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) { err = loop_clr_fd(lo); if (!err) return; } else if (lo->lo_state == Lo_bound) { blk_mq_freeze_queue(lo->lo_queue); blk_mq_unfreeze_queue(lo->lo_queue); } mutex_unlock(&lo->lo_ctl_mutex); }","- static void lo_release(struct gendisk *disk, fmode_t mode)
- struct loop_device *lo = disk->private_data;
+ static void lo_release(struct gendisk *disk, fmode_t mode)
+ ","static void lo_release(struct gendisk *disk, fmode_t mode) static void __lo_release(struct loop_device *lo) { int err; if (atomic_dec_return(&lo->lo_refcnt)) return; mutex_lock(&lo->lo_ctl_mutex); if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) { err = loop_clr_fd(lo); if (!err) return; } else if (lo->lo_state == Lo_bound) { blk_mq_freeze_queue(lo->lo_queue); blk_mq_unfreeze_queue(lo->lo_queue); } mutex_unlock(&lo->lo_ctl_mutex); }"
849,3777----CWE-674----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/regexp.c----regexec,"int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags) { Resub scratch; int i; if (!sub) sub = &scratch; sub->nsub = prog->nsub; for (i = 0; i < MAXSUB; ++i) sub->sub[i].sp = sub->sub[i].ep = NULL; <S2SV_StartVul> return !match(prog->start, sp, sp, prog->flags | eflags, sub); <S2SV_EndVul> }","- return !match(prog->start, sp, sp, prog->flags | eflags, sub);
+ return match(prog->start, sp, sp, prog->flags | eflags, sub, 0);","int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags) { Resub scratch; int i; if (!sub) sub = &scratch; sub->nsub = prog->nsub; for (i = 0; i < MAXSUB; ++i) sub->sub[i].sp = sub->sub[i].ep = NULL; return match(prog->start, sp, sp, prog->flags | eflags, sub, 0); }"
850,6034----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ras_enc.c----ras_putdatastd,"static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts) { int rowsize; int pad; unsigned int z; int nz; int c; int x; int y; int v; jas_matrix_t *data[3]; int i; for (i = 0; i < numcmpts; ++i) { <S2SV_StartVul> data[i] = jas_matrix_create(jas_image_height(image), jas_image_width(image)); <S2SV_EndVul> <S2SV_StartVul> assert(data[i]); <S2SV_EndVul> } rowsize = RAS_ROWSIZE(hdr); pad = rowsize - (hdr->width * hdr->depth + 7) / 8; hdr->length = hdr->height * rowsize; for (y = 0; y < hdr->height; y++) { for (i = 0; i < numcmpts; ++i) { if (jas_image_readcmpt(image, cmpts[i], 0, y, jas_image_width(image), 1, data[i])) { <S2SV_StartVul> return -1; <S2SV_EndVul> } } z = 0; nz = 0; for (x = 0; x < hdr->width; x++) { z <<= hdr->depth; if (RAS_ISRGB(hdr)) { v = RAS_RED((jas_matrix_getv(data[0], x))) | RAS_GREEN((jas_matrix_getv(data[1], x))) | RAS_BLUE((jas_matrix_getv(data[2], x))); } else { v = (jas_matrix_getv(data[0], x)); } z |= v & RAS_ONES(hdr->depth); nz += hdr->depth; while (nz >= 8) { c = (z >> (nz - 8)) & 0xff; if (jas_stream_putc(out, c) == EOF) { <S2SV_StartVul> return -1; <S2SV_EndVul> } nz -= 8; z &= RAS_ONES(nz); } } if (nz > 0) { c = (z >> (8 - nz)) & RAS_ONES(nz); if (jas_stream_putc(out, c) == EOF) { <S2SV_StartVul> return -1; <S2SV_EndVul> } } if (pad % 2) { if (jas_stream_putc(out, 0) == EOF) { <S2SV_StartVul> return -1; <S2SV_EndVul> } } } for (i = 0; i < numcmpts; ++i) { jas_matrix_destroy(data[i]); } return 0; }","- data[i] = jas_matrix_create(jas_image_height(image), jas_image_width(image));
- assert(data[i]);
- return -1;
- return -1;
- return -1;
- return -1;
+ assert(numcmpts <= 3);
+ for (i = 0; i < 3; ++i) {
+ data[i] = 0;
+ }
+ if (!(data[i] = jas_matrix_create(jas_image_height(image),
+ jas_image_width(image)))) {
+ goto error;
+ }
+ goto error;
+ goto error;
+ goto error;
+ goto error;
+ data[i] = 0;
+ error:
+ for (i = 0; i < numcmpts; ++i) {
+ if (data[i]) {
+ jas_matrix_destroy(data[i]);
+ }
+ }
+ return -1;","static int ras_putdatastd(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts) { int rowsize; int pad; unsigned int z; int nz; int c; int x; int y; int v; jas_matrix_t *data[3]; int i; assert(numcmpts <= 3); for (i = 0; i < 3; ++i) { data[i] = 0; } for (i = 0; i < numcmpts; ++i) { if (!(data[i] = jas_matrix_create(jas_image_height(image), jas_image_width(image)))) { goto error; } } rowsize = RAS_ROWSIZE(hdr); pad = rowsize - (hdr->width * hdr->depth + 7) / 8; hdr->length = hdr->height * rowsize; for (y = 0; y < hdr->height; y++) { for (i = 0; i < numcmpts; ++i) { if (jas_image_readcmpt(image, cmpts[i], 0, y, jas_image_width(image), 1, data[i])) { goto error; } } z = 0; nz = 0; for (x = 0; x < hdr->width; x++) { z <<= hdr->depth; if (RAS_ISRGB(hdr)) { v = RAS_RED((jas_matrix_getv(data[0], x))) | RAS_GREEN((jas_matrix_getv(data[1], x))) | RAS_BLUE((jas_matrix_getv(data[2], x))); } else { v = (jas_matrix_getv(data[0], x)); } z |= v & RAS_ONES(hdr->depth); nz += hdr->depth; while (nz >= 8) { c = (z >> (nz - 8)) & 0xff; if (jas_stream_putc(out, c) == EOF) { goto error; } nz -= 8; z &= RAS_ONES(nz); } } if (nz > 0) { c = (z >> (8 - nz)) & RAS_ONES(nz); if (jas_stream_putc(out, c) == EOF) { goto error; } } if (pad % 2) { if (jas_stream_putc(out, 0) == EOF) { goto error; } } } for (i = 0; i < numcmpts; ++i) { jas_matrix_destroy(data[i]); data[i] = 0; } return 0; error: for (i = 0; i < numcmpts; ++i) { if (data[i]) { jas_matrix_destroy(data[i]); } } return -1; }"
851,1069----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-3134--arp_tables.c----mark_source_chains,"static int mark_source_chains(const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0) { unsigned int hook; for (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) { unsigned int pos = newinfo->hook_entry[hook]; struct arpt_entry *e = (struct arpt_entry *)(entry0 + pos); if (!(valid_hooks & (1 << hook))) continue; e->counters.pcnt = pos; for (;;) { const struct xt_standard_target *t = (void *)arpt_get_target_c(e); int visited = e->comefrom & (1 << hook); if (e->comefrom & (1 << NF_ARP_NUMHOOKS)) { pr_notice(""arptables: loop hook %u pos %u %08X.\n"", hook, pos, e->comefrom); return 0; } e->comefrom |= ((1 << hook) | (1 << NF_ARP_NUMHOOKS)); <S2SV_StartVul> if ((e->target_offset == sizeof(struct arpt_entry) && <S2SV_EndVul> (strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0) && <S2SV_StartVul> t->verdict < 0 && unconditional(&e->arp)) || <S2SV_EndVul> <S2SV_StartVul> visited) { <S2SV_EndVul> unsigned int oldpos, size; if ((strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0) && t->verdict < -NF_MAX_VERDICT - 1) { duprintf(""mark_source_chains: bad "" ""negative verdict (%i)\n"", t->verdict); return 0; } do { e->comefrom ^= (1<<NF_ARP_NUMHOOKS); oldpos = pos; pos = e->counters.pcnt; e->counters.pcnt = 0; if (pos == oldpos) goto next; e = (struct arpt_entry *) (entry0 + pos); } while (oldpos == pos + e->next_offset); size = e->next_offset; e = (struct arpt_entry *) (entry0 + pos + size); e->counters.pcnt = pos; pos += size; } else { int newpos = t->verdict; if (strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0 && newpos >= 0) { if (newpos > newinfo->size - sizeof(struct arpt_entry)) { duprintf(""mark_source_chains: "" ""bad verdict (%i)\n"", newpos); return 0; } duprintf(""Jump rule %u -> %u\n"", pos, newpos); } else { newpos = pos + e->next_offset; } e = (struct arpt_entry *) (entry0 + newpos); e->counters.pcnt = pos; pos = newpos; } } next: duprintf(""Finished chain %u\n"", hook); } return 1; }","- if ((e->target_offset == sizeof(struct arpt_entry) &&
- t->verdict < 0 && unconditional(&e->arp)) ||
- visited) {
+ if ((unconditional(e) &&
+ t->verdict < 0) || visited) {","static int mark_source_chains(const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0) { unsigned int hook; for (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) { unsigned int pos = newinfo->hook_entry[hook]; struct arpt_entry *e = (struct arpt_entry *)(entry0 + pos); if (!(valid_hooks & (1 << hook))) continue; e->counters.pcnt = pos; for (;;) { const struct xt_standard_target *t = (void *)arpt_get_target_c(e); int visited = e->comefrom & (1 << hook); if (e->comefrom & (1 << NF_ARP_NUMHOOKS)) { pr_notice(""arptables: loop hook %u pos %u %08X.\n"", hook, pos, e->comefrom); return 0; } e->comefrom |= ((1 << hook) | (1 << NF_ARP_NUMHOOKS)); if ((unconditional(e) && (strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0) && t->verdict < 0) || visited) { unsigned int oldpos, size; if ((strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0) && t->verdict < -NF_MAX_VERDICT - 1) { duprintf(""mark_source_chains: bad "" ""negative verdict (%i)\n"", t->verdict); return 0; } do { e->comefrom ^= (1<<NF_ARP_NUMHOOKS); oldpos = pos; pos = e->counters.pcnt; e->counters.pcnt = 0; if (pos == oldpos) goto next; e = (struct arpt_entry *) (entry0 + pos); } while (oldpos == pos + e->next_offset); size = e->next_offset; e = (struct arpt_entry *) (entry0 + pos + size); e->counters.pcnt = pos; pos += size; } else { int newpos = t->verdict; if (strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0 && newpos >= 0) { if (newpos > newinfo->size - sizeof(struct arpt_entry)) { duprintf(""mark_source_chains: "" ""bad verdict (%i)\n"", newpos); return 0; } duprintf(""Jump rule %u -> %u\n"", pos, newpos); } else { newpos = pos + e->next_offset; } e = (struct arpt_entry *) (entry0 + newpos); e->counters.pcnt = pos; pos = newpos; } } next: duprintf(""Finished chain %u\n"", hook); } return 1; }"
852,2904----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/namei.c----may_create_in_sticky,"<S2SV_StartVul> static int may_create_in_sticky(struct dentry * const dir, <S2SV_EndVul> struct inode * const inode) { if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) || (!sysctl_protected_regular && S_ISREG(inode->i_mode)) || <S2SV_StartVul> likely(!(dir->d_inode->i_mode & S_ISVTX)) || <S2SV_EndVul> <S2SV_StartVul> uid_eq(inode->i_uid, dir->d_inode->i_uid) || <S2SV_EndVul> uid_eq(current_fsuid(), inode->i_uid)) return 0; <S2SV_StartVul> if (likely(dir->d_inode->i_mode & 0002) || <S2SV_EndVul> <S2SV_StartVul> (dir->d_inode->i_mode & 0020 && <S2SV_EndVul> ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) || (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) { const char *operation = S_ISFIFO(inode->i_mode) ? ""sticky_create_fifo"" : ""sticky_create_regular""; audit_log_path_denied(AUDIT_ANOM_CREAT, operation); return -EACCES; } return 0; }","- static int may_create_in_sticky(struct dentry * const dir,
- likely(!(dir->d_inode->i_mode & S_ISVTX)) ||
- uid_eq(inode->i_uid, dir->d_inode->i_uid) ||
- if (likely(dir->d_inode->i_mode & 0002) ||
- (dir->d_inode->i_mode & 0020 &&
+ static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,
+ likely(!(dir_mode & S_ISVTX)) ||
+ uid_eq(inode->i_uid, dir_uid) ||
+ if (likely(dir_mode & 0002) ||
+ (dir_mode & 0020 &&","static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid, struct inode * const inode) { if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) || (!sysctl_protected_regular && S_ISREG(inode->i_mode)) || likely(!(dir_mode & S_ISVTX)) || uid_eq(inode->i_uid, dir_uid) || uid_eq(current_fsuid(), inode->i_uid)) return 0; if (likely(dir_mode & 0002) || (dir_mode & 0020 && ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) || (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) { const char *operation = S_ISFIFO(inode->i_mode) ? ""sticky_create_fifo"" : ""sticky_create_regular""; audit_log_path_denied(AUDIT_ANOM_CREAT, operation); return -EACCES; } return 0; }"
853,7232----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bfq-iosched.c----bfq_idle_slice_timer,"*/ static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer) { struct bfq_data *bfqd = container_of(timer, struct bfq_data, idle_slice_timer); struct bfq_queue *bfqq = bfqd->in_service_queue; if (bfqq) <S2SV_StartVul> bfq_idle_slice_timer_body(bfqq); <S2SV_EndVul> return HRTIMER_NORESTART;","- bfq_idle_slice_timer_body(bfqq);
+ bfq_idle_slice_timer_body(bfqd, bfqq);","*/ static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer) { struct bfq_data *bfqd = container_of(timer, struct bfq_data, idle_slice_timer); struct bfq_queue *bfqq = bfqd->in_service_queue; if (bfqq) bfq_idle_slice_timer_body(bfqd, bfqq); return HRTIMER_NORESTART;"
854,5789----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/data.c----f2fs_read_data_page,"static int f2fs_read_data_page(struct file *file, struct page *page) { <S2SV_StartVul> struct inode *inode = page->mapping->host; <S2SV_EndVul> int ret = -EAGAIN; trace_f2fs_readpage(page, DATA); if (f2fs_has_inline_data(inode)) ret = f2fs_read_inline_data(inode, page); if (ret == -EAGAIN) <S2SV_StartVul> ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false); <S2SV_EndVul> return ret; }","- struct inode *inode = page->mapping->host;
- ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);
+ struct inode *inode = page_file_mapping(page)->host;
+ ret = f2fs_mpage_readpages(page_file_mapping(page),
+ NULL, page, 1, false);","static int f2fs_read_data_page(struct file *file, struct page *page) { struct inode *inode = page_file_mapping(page)->host; int ret = -EAGAIN; trace_f2fs_readpage(page, DATA); if (f2fs_has_inline_data(inode)) ret = f2fs_read_inline_data(inode, page); if (ret == -EAGAIN) ret = f2fs_mpage_readpages(page_file_mapping(page), NULL, page, 1, false); return ret; }"
855,4840----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/nfs4proc.c----nfs4_opendata_alloc,"static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path, <S2SV_StartVul> struct nfs4_state_owner *sp, int flags, <S2SV_EndVul> const struct iattr *attrs) { struct dentry *parent = dget_parent(path->dentry); struct inode *dir = parent->d_inode; struct nfs_server *server = NFS_SERVER(dir); struct nfs4_opendata *p; p = kzalloc(sizeof(*p), GFP_KERNEL); if (p == NULL) goto err; p->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid); if (p->o_arg.seqid == NULL) goto err_free; p->path.mnt = mntget(path->mnt); p->path.dentry = dget(path->dentry); p->dir = parent; p->owner = sp; atomic_inc(&sp->so_count); p->o_arg.fh = NFS_FH(dir); <S2SV_StartVul> p->o_arg.open_flags = flags, <S2SV_EndVul> p->o_arg.clientid = server->nfs_client->cl_clientid; p->o_arg.id = sp->so_owner_id.id; p->o_arg.name = &p->path.dentry->d_name; p->o_arg.server = server; p->o_arg.bitmask = server->attr_bitmask; p->o_arg.claim = NFS4_OPEN_CLAIM_NULL; if (flags & O_EXCL) { u32 *s = (u32 *) p->o_arg.u.verifier.data; s[0] = jiffies; s[1] = current->pid; } else if (flags & O_CREAT) { p->o_arg.u.attrs = &p->attrs; memcpy(&p->attrs, attrs, sizeof(p->attrs)); } p->c_arg.fh = &p->o_res.fh; p->c_arg.stateid = &p->o_res.stateid; p->c_arg.seqid = p->o_arg.seqid; nfs4_init_opendata_res(p); kref_init(&p->kref); return p; err_free: kfree(p); err: dput(parent); return NULL; }","- struct nfs4_state_owner *sp, int flags,
- p->o_arg.open_flags = flags,
+ struct nfs4_state_owner *sp, fmode_t fmode, int flags,
+ p->o_arg.open_flags = flags;
+ p->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);","static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path, struct nfs4_state_owner *sp, fmode_t fmode, int flags, const struct iattr *attrs) { struct dentry *parent = dget_parent(path->dentry); struct inode *dir = parent->d_inode; struct nfs_server *server = NFS_SERVER(dir); struct nfs4_opendata *p; p = kzalloc(sizeof(*p), GFP_KERNEL); if (p == NULL) goto err; p->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid); if (p->o_arg.seqid == NULL) goto err_free; p->path.mnt = mntget(path->mnt); p->path.dentry = dget(path->dentry); p->dir = parent; p->owner = sp; atomic_inc(&sp->so_count); p->o_arg.fh = NFS_FH(dir); p->o_arg.open_flags = flags; p->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE); p->o_arg.clientid = server->nfs_client->cl_clientid; p->o_arg.id = sp->so_owner_id.id; p->o_arg.name = &p->path.dentry->d_name; p->o_arg.server = server; p->o_arg.bitmask = server->attr_bitmask; p->o_arg.claim = NFS4_OPEN_CLAIM_NULL; if (flags & O_EXCL) { u32 *s = (u32 *) p->o_arg.u.verifier.data; s[0] = jiffies; s[1] = current->pid; } else if (flags & O_CREAT) { p->o_arg.u.attrs = &p->attrs; memcpy(&p->attrs, attrs, sizeof(p->attrs)); } p->c_arg.fh = &p->o_res.fh; p->c_arg.stateid = &p->o_res.stateid; p->c_arg.seqid = p->o_arg.seqid; nfs4_init_opendata_res(p); kref_init(&p->kref); return p; err_free: kfree(p); err: dput(parent); return NULL; }"
856,7452----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mct_u232.c----mct_u232_port_probe,"static int mct_u232_port_probe(struct usb_serial_port *port) { struct mct_u232_private *priv; priv = kzalloc(sizeof(*priv), GFP_KERNEL); if (!priv) return -ENOMEM; <S2SV_StartVul> priv->read_urb = port->serial->port[1]->interrupt_in_urb; <S2SV_EndVul> priv->read_urb->context = port; spin_lock_init(&priv->lock); usb_set_serial_port_data(port, priv); return 0; }","- priv->read_urb = port->serial->port[1]->interrupt_in_urb;
+ struct usb_serial *serial = port->serial;
+ if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {
+ dev_err(&port->dev, ""expected endpoint missing\n"");
+ return -ENODEV;
+ }
+ priv->read_urb = serial->port[1]->interrupt_in_urb;","static int mct_u232_port_probe(struct usb_serial_port *port) { struct usb_serial *serial = port->serial; struct mct_u232_private *priv; if (!serial->port[1] || !serial->port[1]->interrupt_in_urb) { dev_err(&port->dev, ""expected endpoint missing\n""); return -ENODEV; } priv = kzalloc(sizeof(*priv), GFP_KERNEL); if (!priv) return -ENOMEM; priv->read_urb = serial->port[1]->interrupt_in_urb; priv->read_urb->context = port; spin_lock_init(&priv->lock); usb_set_serial_port_data(port, priv); return 0; }"
857,1236----CWE-415----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-16820--snmp.c----csnmp_read_table,"static int csnmp_read_table(host_definition_t *host, data_definition_t *data) { struct snmp_pdu *req; struct snmp_pdu *res = NULL; struct variable_list *vb; const data_set_t *ds; size_t oid_list_len = data->values_len + 1; oid_t oid_list[oid_list_len]; _Bool oid_list_todo[oid_list_len]; int status; size_t i; csnmp_list_instances_t *instance_list_head; csnmp_list_instances_t *instance_list_tail; csnmp_table_values_t **value_list_head; csnmp_table_values_t **value_list_tail; DEBUG(""snmp plugin: csnmp_read_table (host = %s, data = %s)"", host->name, data->name); if (host->sess_handle == NULL) { DEBUG(""snmp plugin: csnmp_read_table: host->sess_handle == NULL""); return (-1); } ds = plugin_get_ds(data->type); if (!ds) { ERROR(""snmp plugin: DataSet `%s' not defined."", data->type); return (-1); } if (ds->ds_num != data->values_len) { ERROR(""snmp plugin: DataSet `%s' requires %zu values, but config talks "" ""about %zu"", data->type, ds->ds_num, data->values_len); return (-1); } assert(data->values_len > 0); memcpy(oid_list, data->values, data->values_len * sizeof(oid_t)); if (data->instance.oid.oid_len > 0) memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t)); else oid_list_len--; for (i = 0; i < oid_list_len; i++) oid_list_todo[i] = 1; value_list_head = calloc(data->values_len, sizeof(*value_list_head)); value_list_tail = calloc(data->values_len, sizeof(*value_list_tail)); if ((value_list_head == NULL) || (value_list_tail == NULL)) { ERROR(""snmp plugin: csnmp_read_table: calloc failed.""); sfree(value_list_head); sfree(value_list_tail); return (-1); } instance_list_head = NULL; instance_list_tail = NULL; status = 0; while (status == 0) { int oid_list_todo_num; req = snmp_pdu_create(SNMP_MSG_GETNEXT); if (req == NULL) { ERROR(""snmp plugin: snmp_pdu_create failed.""); status = -1; break; } oid_list_todo_num = 0; for (i = 0; i < oid_list_len; i++) { if (!oid_list_todo[i]) continue; oid_list_todo_num++; snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len); } if (oid_list_todo_num == 0) { DEBUG(""snmp plugin: all variables have left their subtree""); status = 0; break; } res = NULL; status = snmp_sess_synch_response(host->sess_handle, req, &res); if ((status != STAT_SUCCESS) || (res == NULL)) { char *errstr = NULL; snmp_sess_error(host->sess_handle, NULL, NULL, &errstr); c_complain(LOG_ERR, &host->complaint, ""snmp plugin: host %s: snmp_sess_synch_response failed: %s"", host->name, (errstr == NULL) ? ""Unknown problem"" : errstr); if (res != NULL) snmp_free_pdu(res); res = NULL; <S2SV_StartVul> req = NULL; <S2SV_EndVul> sfree(errstr); csnmp_host_close_session(host); status = -1; break; } status = 0; assert(res != NULL); c_release(LOG_INFO, &host->complaint, ""snmp plugin: host %s: snmp_sess_synch_response successful."", host->name); vb = res->variables; if (vb == NULL) { status = -1; break; } for (vb = res->variables, i = 0; (vb != NULL); vb = vb->next_variable, i++) { while ((i < oid_list_len) && !oid_list_todo[i]) i++; if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) { if ((vb->type == SNMP_ENDOFMIBVIEW) || (snmp_oid_ncompare( data->instance.oid.oid, data->instance.oid.oid_len, vb->name, vb->name_length, data->instance.oid.oid_len) != 0)) { DEBUG(""snmp plugin: host = %s; data = %s; Instance left its subtree."", host->name, data->name); oid_list_todo[i] = 0; continue; } if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail, res, host, data) != 0) { ERROR(""snmp plugin: host %s: csnmp_instance_list_add failed."", host->name); status = -1; break; } } else { csnmp_table_values_t *vt; oid_t vb_name; oid_t suffix; int ret; csnmp_oid_init(&vb_name, vb->name, vb->name_length); ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i); if (ret != 0) { DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; "" ""Value probably left its subtree."", host->name, data->name, i); oid_list_todo[i] = 0; continue; } if ((value_list_tail[i] != NULL) && (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) { DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; "" ""Suffix is not increasing."", host->name, data->name, i); oid_list_todo[i] = 0; continue; } vt = calloc(1, sizeof(*vt)); if (vt == NULL) { ERROR(""snmp plugin: calloc failed.""); status = -1; break; } vt->value = csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale, data->shift, host->name, data->name); memcpy(&vt->suffix, &suffix, sizeof(vt->suffix)); vt->next = NULL; if (value_list_tail[i] == NULL) value_list_head[i] = vt; else value_list_tail[i]->next = vt; value_list_tail[i] = vt; } memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length); oid_list[i].oid_len = vb->name_length; } if (res != NULL) snmp_free_pdu(res); res = NULL; } if (res != NULL) snmp_free_pdu(res); res = NULL; <S2SV_StartVul> if (req != NULL) <S2SV_EndVul> <S2SV_StartVul> snmp_free_pdu(req); <S2SV_EndVul> <S2SV_StartVul> req = NULL; <S2SV_EndVul> if (status == 0) csnmp_dispatch_table(host, data, instance_list_head, value_list_head); while (instance_list_head != NULL) { csnmp_list_instances_t *next = instance_list_head->next; sfree(instance_list_head); instance_list_head = next; } for (i = 0; i < data->values_len; i++) { while (value_list_head[i] != NULL) { csnmp_table_values_t *next = value_list_head[i]->next; sfree(value_list_head[i]); value_list_head[i] = next; } } sfree(value_list_head); sfree(value_list_tail); return (0); }","- req = NULL;
- if (req != NULL)
- snmp_free_pdu(req);
- req = NULL;
+ snmp_free_pdu(req);","static int csnmp_read_table(host_definition_t *host, data_definition_t *data) { struct snmp_pdu *req; struct snmp_pdu *res = NULL; struct variable_list *vb; const data_set_t *ds; size_t oid_list_len = data->values_len + 1; oid_t oid_list[oid_list_len]; _Bool oid_list_todo[oid_list_len]; int status; size_t i; csnmp_list_instances_t *instance_list_head; csnmp_list_instances_t *instance_list_tail; csnmp_table_values_t **value_list_head; csnmp_table_values_t **value_list_tail; DEBUG(""snmp plugin: csnmp_read_table (host = %s, data = %s)"", host->name, data->name); if (host->sess_handle == NULL) { DEBUG(""snmp plugin: csnmp_read_table: host->sess_handle == NULL""); return (-1); } ds = plugin_get_ds(data->type); if (!ds) { ERROR(""snmp plugin: DataSet `%s' not defined."", data->type); return (-1); } if (ds->ds_num != data->values_len) { ERROR(""snmp plugin: DataSet `%s' requires %zu values, but config talks "" ""about %zu"", data->type, ds->ds_num, data->values_len); return (-1); } assert(data->values_len > 0); memcpy(oid_list, data->values, data->values_len * sizeof(oid_t)); if (data->instance.oid.oid_len > 0) memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t)); else oid_list_len--; for (i = 0; i < oid_list_len; i++) oid_list_todo[i] = 1; value_list_head = calloc(data->values_len, sizeof(*value_list_head)); value_list_tail = calloc(data->values_len, sizeof(*value_list_tail)); if ((value_list_head == NULL) || (value_list_tail == NULL)) { ERROR(""snmp plugin: csnmp_read_table: calloc failed.""); sfree(value_list_head); sfree(value_list_tail); return (-1); } instance_list_head = NULL; instance_list_tail = NULL; status = 0; while (status == 0) { int oid_list_todo_num; req = snmp_pdu_create(SNMP_MSG_GETNEXT); if (req == NULL) { ERROR(""snmp plugin: snmp_pdu_create failed.""); status = -1; break; } oid_list_todo_num = 0; for (i = 0; i < oid_list_len; i++) { if (!oid_list_todo[i]) continue; oid_list_todo_num++; snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len); } if (oid_list_todo_num == 0) { DEBUG(""snmp plugin: all variables have left their subtree""); snmp_free_pdu(req); status = 0; break; } res = NULL; status = snmp_sess_synch_response(host->sess_handle, req, &res); if ((status != STAT_SUCCESS) || (res == NULL)) { char *errstr = NULL; snmp_sess_error(host->sess_handle, NULL, NULL, &errstr); c_complain(LOG_ERR, &host->complaint, ""snmp plugin: host %s: snmp_sess_synch_response failed: %s"", host->name, (errstr == NULL) ? ""Unknown problem"" : errstr); if (res != NULL) snmp_free_pdu(res); res = NULL; sfree(errstr); csnmp_host_close_session(host); status = -1; break; } status = 0; assert(res != NULL); c_release(LOG_INFO, &host->complaint, ""snmp plugin: host %s: snmp_sess_synch_response successful."", host->name); vb = res->variables; if (vb == NULL) { status = -1; break; } for (vb = res->variables, i = 0; (vb != NULL); vb = vb->next_variable, i++) { while ((i < oid_list_len) && !oid_list_todo[i]) i++; if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) { if ((vb->type == SNMP_ENDOFMIBVIEW) || (snmp_oid_ncompare( data->instance.oid.oid, data->instance.oid.oid_len, vb->name, vb->name_length, data->instance.oid.oid_len) != 0)) { DEBUG(""snmp plugin: host = %s; data = %s; Instance left its subtree."", host->name, data->name); oid_list_todo[i] = 0; continue; } if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail, res, host, data) != 0) { ERROR(""snmp plugin: host %s: csnmp_instance_list_add failed."", host->name); status = -1; break; } } else { csnmp_table_values_t *vt; oid_t vb_name; oid_t suffix; int ret; csnmp_oid_init(&vb_name, vb->name, vb->name_length); ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i); if (ret != 0) { DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; "" ""Value probably left its subtree."", host->name, data->name, i); oid_list_todo[i] = 0; continue; } if ((value_list_tail[i] != NULL) && (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) { DEBUG(""snmp plugin: host = %s; data = %s; i = %zu; "" ""Suffix is not increasing."", host->name, data->name, i); oid_list_todo[i] = 0; continue; } vt = calloc(1, sizeof(*vt)); if (vt == NULL) { ERROR(""snmp plugin: calloc failed.""); status = -1; break; } vt->value = csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale, data->shift, host->name, data->name); memcpy(&vt->suffix, &suffix, sizeof(vt->suffix)); vt->next = NULL; if (value_list_tail[i] == NULL) value_list_head[i] = vt; else value_list_tail[i]->next = vt; value_list_tail[i] = vt; } memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length); oid_list[i].oid_len = vb->name_length; } if (res != NULL) snmp_free_pdu(res); res = NULL; } if (res != NULL) snmp_free_pdu(res); res = NULL; if (status == 0) csnmp_dispatch_table(host, data, instance_list_head, value_list_head); while (instance_list_head != NULL) { csnmp_list_instances_t *next = instance_list_head->next; sfree(instance_list_head); instance_list_head = next; } for (i = 0; i < data->values_len; i++) { while (value_list_head[i] != NULL) { csnmp_table_values_t *next = value_list_head[i]->next; sfree(value_list_head[i]); value_list_head[i] = next; } } sfree(value_list_head); sfree(value_list_tail); return (0); }"
858,657----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3980--control.c----_fep_open_control_socket,"_fep_open_control_socket (Fep *fep) { struct sockaddr_un sun; char *path; int fd; ssize_t sun_len; fd = socket (AF_UNIX, SOCK_STREAM, 0); if (fd < 0) { perror (""socket""); return -1; } path = create_socket_name (""fep-XXXXXX/control""); if (strlen (path) + 1 >= sizeof(sun.sun_path)) { fep_log (FEP_LOG_LEVEL_WARNING, ""unix domain socket path too long: %d + 1 >= %d"", strlen (path), sizeof (sun.sun_path)); free (path); return -1; } memset (&sun, 0, sizeof(sun)); sun.sun_family = AF_UNIX; <S2SV_StartVul> #ifdef __linux__ <S2SV_EndVul> <S2SV_StartVul> sun.sun_path[0] = '\0'; <S2SV_EndVul> <S2SV_StartVul> memcpy (sun.sun_path + 1, path, strlen (path)); <S2SV_EndVul> <S2SV_StartVul> sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1; <S2SV_EndVul> <S2SV_StartVul> remove_control_socket (path); <S2SV_EndVul> <S2SV_StartVul> #else <S2SV_EndVul> memcpy (sun.sun_path, path, strlen (path)); sun_len = sizeof (struct sockaddr_un); <S2SV_StartVul> #endif <S2SV_EndVul> if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0) { perror (""bind""); free (path); close (fd); return -1; } if (listen (fd, 5) < 0) { perror (""listen""); free (path); close (fd); return -1; } fep->server = fd; fep->control_socket_path = path; return 0; }","- #ifdef __linux__
- sun.sun_path[0] = '\0';
- memcpy (sun.sun_path + 1, path, strlen (path));
- sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1;
- remove_control_socket (path);
- #else
- #endif","_fep_open_control_socket (Fep *fep) { struct sockaddr_un sun; char *path; int fd; ssize_t sun_len; fd = socket (AF_UNIX, SOCK_STREAM, 0); if (fd < 0) { perror (""socket""); return -1; } path = create_socket_name (""fep-XXXXXX/control""); if (strlen (path) + 1 >= sizeof(sun.sun_path)) { fep_log (FEP_LOG_LEVEL_WARNING, ""unix domain socket path too long: %d + 1 >= %d"", strlen (path), sizeof (sun.sun_path)); free (path); return -1; } memset (&sun, 0, sizeof(sun)); sun.sun_family = AF_UNIX; memcpy (sun.sun_path, path, strlen (path)); sun_len = sizeof (struct sockaddr_un); if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0) { perror (""bind""); free (path); close (fd); return -1; } if (listen (fd, 5) < 0) { perror (""listen""); free (path); close (fd); return -1; } fep->server = fd; fep->control_socket_path = path; return 0; }"
859,1299----CWE-200----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-14140--migrate.c----SYSCALL_DEFINE6,"SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages, const void __user * __user *, pages, const int __user *, nodes, int __user *, status, int, flags) { <S2SV_StartVul> const struct cred *cred = current_cred(), *tcred; <S2SV_EndVul> struct task_struct *task; struct mm_struct *mm; int err; nodemask_t task_nodes; if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL)) return -EINVAL; if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE)) return -EPERM; rcu_read_lock(); task = pid ? find_task_by_vpid(pid) : current; if (!task) { rcu_read_unlock(); return -ESRCH; } get_task_struct(task); <S2SV_StartVul> tcred = __task_cred(task); <S2SV_EndVul> <S2SV_StartVul> if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) && <S2SV_EndVul> <S2SV_StartVul> !uid_eq(cred->uid, tcred->suid) && !uid_eq(cred->uid, tcred->uid) && <S2SV_EndVul> <S2SV_StartVul> !capable(CAP_SYS_NICE)) { <S2SV_EndVul> rcu_read_unlock(); err = -EPERM; goto out; } rcu_read_unlock(); err = security_task_movememory(task); if (err) goto out; task_nodes = cpuset_mems_allowed(task); mm = get_task_mm(task); put_task_struct(task); if (!mm) return -EINVAL; if (nodes) err = do_pages_move(mm, task_nodes, nr_pages, pages, nodes, status, flags); else err = do_pages_stat(mm, nr_pages, pages, status); mmput(mm); return err; out: put_task_struct(task); return err; }","- const struct cred *cred = current_cred(), *tcred;
- tcred = __task_cred(task);
- if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
- !uid_eq(cred->uid, tcred->suid) && !uid_eq(cred->uid, tcred->uid) &&
- !capable(CAP_SYS_NICE)) {
+ if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) {","SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages, const void __user * __user *, pages, const int __user *, nodes, int __user *, status, int, flags) { struct task_struct *task; struct mm_struct *mm; int err; nodemask_t task_nodes; if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL)) return -EINVAL; if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE)) return -EPERM; rcu_read_lock(); task = pid ? find_task_by_vpid(pid) : current; if (!task) { rcu_read_unlock(); return -ESRCH; } get_task_struct(task); if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS)) { rcu_read_unlock(); err = -EPERM; goto out; } rcu_read_unlock(); err = security_task_movememory(task); if (err) goto out; task_nodes = cpuset_mems_allowed(task); mm = get_task_mm(task); put_task_struct(task); if (!mm) return -EINVAL; if (nodes) err = do_pages_move(mm, task_nodes, nr_pages, pages, nodes, status, flags); else err = do_pages_stat(mm, nr_pages, pages, status); mmput(mm); return err; out: put_task_struct(task); return err; }"
860,6545----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip_tables.c----check_entry_size_and_hooks,"check_entry_size_and_hooks(struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks) { unsigned int h; int err; if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 || (unsigned char *)e + sizeof(struct ipt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p\n"", e); return -EINVAL; } if (e->next_offset < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!ip_checkentry(&e->ip)) return -EINVAL; <S2SV_StartVul> err = xt_check_entry_offsets(e, e->target_offset, e->next_offset); <S2SV_EndVul> if (err) return err; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if (!(valid_hooks & (1 << h))) continue; if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) { if (!check_underflow(e)) { pr_debug(""Underflows must be unconditional and "" ""use the STANDARD target with "" ""ACCEPT/DROP\n""); return -EINVAL; } newinfo->underflow[h] = underflows[h]; } } e->counters = ((struct xt_counters) { 0, 0 }); e->comefrom = 0; return 0; }","- err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
+ err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+ e->next_offset);","check_entry_size_and_hooks(struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks) { unsigned int h; int err; if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 || (unsigned char *)e + sizeof(struct ipt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p\n"", e); return -EINVAL; } if (e->next_offset < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!ip_checkentry(&e->ip)) return -EINVAL; err = xt_check_entry_offsets(e, e->elems, e->target_offset, e->next_offset); if (err) return err; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if (!(valid_hooks & (1 << h))) continue; if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) { if (!check_underflow(e)) { pr_debug(""Underflows must be unconditional and "" ""use the STANDARD target with "" ""ACCEPT/DROP\n""); return -EINVAL; } newinfo->underflow[h] = underflows[h]; } } e->counters = ((struct xt_counters) { 0, 0 }); e->comefrom = 0; return 0; }"
861,2519----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7277--skbuff.c----__skb_tstamp_tx,"void __skb_tstamp_tx(struct sk_buff *orig_skb, struct skb_shared_hwtstamps *hwtstamps, struct sock *sk, int tstype) { <S2SV_StartVul> struct sk_buff *skb; <S2SV_EndVul> bool tsonly; if (!sk) return; tsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY; if (!skb_may_tx_timestamp(sk, tsonly)) return; if (tsonly) { <S2SV_StartVul> #ifdef CONFIG_INET <S2SV_EndVul> if ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) && sk->sk_protocol == IPPROTO_TCP && sk->sk_type == SOCK_STREAM) skb = tcp_get_timestamping_opt_stats(sk); else #endif skb = alloc_skb(0, GFP_ATOMIC); } else { skb = skb_clone(orig_skb, GFP_ATOMIC); } if (!skb) return; <S2SV_StartVul> <S2SV_EndVul> if (tsonly) { <S2SV_StartVul> skb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags; <S2SV_EndVul> skb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey; } if (hwtstamps) *skb_hwtstamps(skb) = *hwtstamps; else skb->tstamp = ktime_get_real(); __skb_complete_tx_timestamp(skb, sk, tstype); }","- struct sk_buff *skb;
- #ifdef CONFIG_INET
- 
- skb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;
+ 
+ #endif
+ } else {
+ skb = skb_clone(orig_skb, GFP_ATOMIC);","void __skb_tstamp_tx(struct sk_buff *orig_skb, struct skb_shared_hwtstamps *hwtstamps, struct sock *sk, int tstype) { struct sk_buff *skb; bool tsonly, opt_stats = false; if (!sk) return; tsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY; if (!skb_may_tx_timestamp(sk, tsonly)) return; if (tsonly) { #ifdef CONFIG_INET if ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) && sk->sk_protocol == IPPROTO_TCP && sk->sk_type == SOCK_STREAM) { skb = tcp_get_timestamping_opt_stats(sk); opt_stats = true; } else #endif skb = alloc_skb(0, GFP_ATOMIC); } else { skb = skb_clone(orig_skb, GFP_ATOMIC); } if (!skb) return; if (tsonly) { skb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags; skb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey; } if (hwtstamps) *skb_hwtstamps(skb) = *hwtstamps; else skb->tstamp = ktime_get_real(); __skb_complete_tx_timestamp(skb, sk, tstype, opt_stats); }"
862,6087----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/evm_crypto.c----evm_update_evmxattr,"int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name, const char *xattr_value, size_t xattr_value_len) { struct inode *inode = dentry->d_inode; struct evm_ima_xattr_data xattr_data; int rc = 0; rc = evm_calc_hmac(dentry, xattr_name, xattr_value, xattr_value_len, xattr_data.digest); if (rc == 0) { xattr_data.type = EVM_XATTR_HMAC; rc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM, &xattr_data, sizeof(xattr_data), 0); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> else if (rc == -ENODATA) <S2SV_EndVul> rc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM); return rc; }","- }
- else if (rc == -ENODATA)
+ } else if (rc == -ENODATA && inode->i_op->removexattr) {
+ }","int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name, const char *xattr_value, size_t xattr_value_len) { struct inode *inode = dentry->d_inode; struct evm_ima_xattr_data xattr_data; int rc = 0; rc = evm_calc_hmac(dentry, xattr_name, xattr_value, xattr_value_len, xattr_data.digest); if (rc == 0) { xattr_data.type = EVM_XATTR_HMAC; rc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM, &xattr_data, sizeof(xattr_data), 0); } else if (rc == -ENODATA && inode->i_op->removexattr) { rc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM); } return rc; }"
863,4649----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/input.c----input_default_setkeycode,"static int input_default_setkeycode(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode) { unsigned int index; int error; int i; if (!dev->keycodesize) return -EINVAL; if (ke->flags & INPUT_KEYMAP_BY_INDEX) { index = ke->index; } else { error = input_scancode_to_scalar(ke, &index); if (error) return error; } if (index >= dev->keycodemax) return -EINVAL; if (dev->keycodesize < sizeof(ke->keycode) && (ke->keycode >> (dev->keycodesize * 8))) return -EINVAL; switch (dev->keycodesize) { case 1: { u8 *k = (u8 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } case 2: { u16 *k = (u16 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } default: { u32 *k = (u32 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } } <S2SV_StartVul> __clear_bit(*old_keycode, dev->keybit); <S2SV_EndVul> <S2SV_StartVul> __set_bit(ke->keycode, dev->keybit); <S2SV_EndVul> <S2SV_StartVul> for (i = 0; i < dev->keycodemax; i++) { <S2SV_EndVul> <S2SV_StartVul> if (input_fetch_keycode(dev, i) == *old_keycode) { <S2SV_EndVul> <S2SV_StartVul> __set_bit(*old_keycode, dev->keybit); <S2SV_EndVul> <S2SV_StartVul> break; <S2SV_EndVul> } } return 0; }","- __clear_bit(*old_keycode, dev->keybit);
- __set_bit(ke->keycode, dev->keybit);
- for (i = 0; i < dev->keycodemax; i++) {
- if (input_fetch_keycode(dev, i) == *old_keycode) {
- __set_bit(*old_keycode, dev->keybit);
+ if (*old_keycode <= KEY_MAX) {
+ __clear_bit(*old_keycode, dev->keybit);
+ for (i = 0; i < dev->keycodemax; i++) {
+ if (input_fetch_keycode(dev, i) == *old_keycode) {
+ __set_bit(*old_keycode, dev->keybit);
+ break;
+ }
+ __set_bit(ke->keycode, dev->keybit);","static int input_default_setkeycode(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode) { unsigned int index; int error; int i; if (!dev->keycodesize) return -EINVAL; if (ke->flags & INPUT_KEYMAP_BY_INDEX) { index = ke->index; } else { error = input_scancode_to_scalar(ke, &index); if (error) return error; } if (index >= dev->keycodemax) return -EINVAL; if (dev->keycodesize < sizeof(ke->keycode) && (ke->keycode >> (dev->keycodesize * 8))) return -EINVAL; switch (dev->keycodesize) { case 1: { u8 *k = (u8 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } case 2: { u16 *k = (u16 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } default: { u32 *k = (u32 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } } if (*old_keycode <= KEY_MAX) { __clear_bit(*old_keycode, dev->keybit); for (i = 0; i < dev->keycodemax; i++) { if (input_fetch_keycode(dev, i) == *old_keycode) { __set_bit(*old_keycode, dev->keybit); break; } } } __set_bit(ke->keycode, dev->keybit); return 0; }"
864,6532----CWE-824----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dsdiff.c----ParseDsdiffHeaderConfig,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t infilesize, total_samples; DFFFileHeader dff_file_header; DFFChunkHeader dff_chunk_header; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&dff_file_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) || bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1 WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) { error_line (""%s is not a valid .DFF file (by total size)!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize); #endif while (1) { if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) || bcount != sizeof (DFFChunkHeader)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (debug_logging_mode) error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize); if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) { uint32_t version; if (dff_chunk_header.ckDataSize != sizeof (version) || !DoReadFile (infile, &version, sizeof (version), &bcount) || bcount != sizeof (version)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &version, sizeof (version))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&version, ""L""); if (debug_logging_mode) error_line (""dsdiff file version = 0x%08x"", version); } else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) { char *prop_chunk; if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize); prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize); if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) || bcount != dff_chunk_header.ckDataSize) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (prop_chunk); return WAVPACK_SOFT_ERROR; } if (!strncmp (prop_chunk, ""SND "", 4)) { char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize; uint16_t numChannels = 0, chansSpecified, chanMask = 0; <S2SV_StartVul> uint32_t sampleRate; <S2SV_EndVul> while (eptr - cptr >= sizeof (dff_chunk_header)) { memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header)); cptr += sizeof (dff_chunk_header); WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) { if (!strncmp (dff_chunk_header.ckID, ""FS "", 4) && dff_chunk_header.ckDataSize == 4) { memcpy (&sampleRate, cptr, sizeof (sampleRate)); WavpackBigEndianToNative (&sampleRate, ""L""); cptr += dff_chunk_header.ckDataSize; if (debug_logging_mode) error_line (""got sample rate of %u Hz"", sampleRate); } else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) { memcpy (&numChannels, cptr, sizeof (numChannels)); WavpackBigEndianToNative (&numChannels, ""S""); cptr += sizeof (numChannels); chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4; if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } while (chansSpecified--) { if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4)) chanMask |= 0x1; else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4)) chanMask |= 0x2; else if (!strncmp (cptr, ""LS "", 4)) chanMask |= 0x10; else if (!strncmp (cptr, ""RS "", 4)) chanMask |= 0x20; else if (!strncmp (cptr, ""C "", 4)) chanMask |= 0x4; else if (!strncmp (cptr, ""LFE "", 4)) chanMask |= 0x8; else if (debug_logging_mode) error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]); cptr += 4; } if (debug_logging_mode) error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask); } else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) { if (strncmp (cptr, ""DSD "", 4)) { error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"", cptr [0], cptr [1], cptr [2], cptr [3]); free (prop_chunk); return WAVPACK_SOFT_ERROR; } cptr += dff_chunk_header.ckDataSize; } else { if (debug_logging_mode) error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); cptr += dff_chunk_header.ckDataSize; } } else { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } } if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this DSDIFF file already has channel order information!""); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (chanMask) config->channel_mask = chanMask; config->bits_per_sample = 8; config->bytes_per_sample = 1; config->num_channels = numChannels; config->sample_rate = sampleRate / 8; config->qmode |= QMODE_DSD_MSB_FIRST; } else if (debug_logging_mode) error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"", prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize); free (prop_chunk); } else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) { <S2SV_StartVul> if (!config->num_channels) { <S2SV_EndVul> error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } total_samples = dff_chunk_header.ckDataSize / config->num_channels; break; } else { int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1); char *buff; if (bytes_to_copy < 0 || bytes_to_copy > 4194304) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (debug_logging_mode) error_line (""setting configuration with %lld samples"", total_samples); if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }","- uint32_t sampleRate;
- if (!config->num_channels) {
+ uint32_t sampleRate = 0;
+ if (!config->num_channels || !config->sample_rate) {","int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t infilesize, total_samples; DFFFileHeader dff_file_header; DFFChunkHeader dff_chunk_header; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&dff_file_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) || bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1 WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) { error_line (""%s is not a valid .DFF file (by total size)!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize); #endif while (1) { if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) || bcount != sizeof (DFFChunkHeader)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (debug_logging_mode) error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize); if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) { uint32_t version; if (dff_chunk_header.ckDataSize != sizeof (version) || !DoReadFile (infile, &version, sizeof (version), &bcount) || bcount != sizeof (version)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &version, sizeof (version))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&version, ""L""); if (debug_logging_mode) error_line (""dsdiff file version = 0x%08x"", version); } else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) { char *prop_chunk; if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize); prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize); if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) || bcount != dff_chunk_header.ckDataSize) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (prop_chunk); return WAVPACK_SOFT_ERROR; } if (!strncmp (prop_chunk, ""SND "", 4)) { char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize; uint16_t numChannels = 0, chansSpecified, chanMask = 0; uint32_t sampleRate = 0; while (eptr - cptr >= sizeof (dff_chunk_header)) { memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header)); cptr += sizeof (dff_chunk_header); WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) { if (!strncmp (dff_chunk_header.ckID, ""FS "", 4) && dff_chunk_header.ckDataSize == 4) { memcpy (&sampleRate, cptr, sizeof (sampleRate)); WavpackBigEndianToNative (&sampleRate, ""L""); cptr += dff_chunk_header.ckDataSize; if (debug_logging_mode) error_line (""got sample rate of %u Hz"", sampleRate); } else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) { memcpy (&numChannels, cptr, sizeof (numChannels)); WavpackBigEndianToNative (&numChannels, ""S""); cptr += sizeof (numChannels); chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4; if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } while (chansSpecified--) { if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4)) chanMask |= 0x1; else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4)) chanMask |= 0x2; else if (!strncmp (cptr, ""LS "", 4)) chanMask |= 0x10; else if (!strncmp (cptr, ""RS "", 4)) chanMask |= 0x20; else if (!strncmp (cptr, ""C "", 4)) chanMask |= 0x4; else if (!strncmp (cptr, ""LFE "", 4)) chanMask |= 0x8; else if (debug_logging_mode) error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]); cptr += 4; } if (debug_logging_mode) error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask); } else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) { if (strncmp (cptr, ""DSD "", 4)) { error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"", cptr [0], cptr [1], cptr [2], cptr [3]); free (prop_chunk); return WAVPACK_SOFT_ERROR; } cptr += dff_chunk_header.ckDataSize; } else { if (debug_logging_mode) error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); cptr += dff_chunk_header.ckDataSize; } } else { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } } if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this DSDIFF file already has channel order information!""); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (chanMask) config->channel_mask = chanMask; config->bits_per_sample = 8; config->bytes_per_sample = 1; config->num_channels = numChannels; config->sample_rate = sampleRate / 8; config->qmode |= QMODE_DSD_MSB_FIRST; } else if (debug_logging_mode) error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"", prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize); free (prop_chunk); } else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) { if (!config->num_channels || !config->sample_rate) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } total_samples = dff_chunk_header.ckDataSize / config->num_channels; break; } else { int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1); char *buff; if (bytes_to_copy < 0 || bytes_to_copy > 4194304) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (debug_logging_mode) error_line (""setting configuration with %lld samples"", total_samples); if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }"
865,5638----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/class.c----r_bin_java_constant_value_attr_new,"R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut64 offset = 6; RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR; <S2SV_StartVul> attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset); <S2SV_EndVul> offset += 2; attr->size = offset; } return attr; }","- attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);
+ if (offset + 4 < sz) {
+ attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);
+ }","R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut64 offset = 6; RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR; if (offset + 4 < sz) { attr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset); } offset += 2; attr->size = offset; } return attr; }"
866,5325----CWE-401----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/usb.c----rtl_usb_probe,"int rtl_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, struct rtl_hal_cfg *rtl_hal_cfg) { int err; struct ieee80211_hw *hw = NULL; struct rtl_priv *rtlpriv = NULL; struct usb_device *udev; struct rtl_usb_priv *usb_priv; hw = ieee80211_alloc_hw(sizeof(struct rtl_priv) + sizeof(struct rtl_usb_priv), &rtl_ops); if (!hw) { WARN_ONCE(true, ""rtl_usb: ieee80211 alloc failed\n""); return -ENOMEM; } rtlpriv = hw->priv; rtlpriv->hw = hw; rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32), GFP_KERNEL); <S2SV_StartVul> if (!rtlpriv->usb_data) <S2SV_EndVul> return -ENOMEM; spin_lock_init(&rtlpriv->locks.usb_lock); INIT_WORK(&rtlpriv->works.fill_h2c_cmd, rtl_fill_h2c_cmd_work_callback); INIT_WORK(&rtlpriv->works.lps_change_work, rtl_lps_change_work_callback); rtlpriv->usb_data_index = 0; init_completion(&rtlpriv->firmware_loading_complete); SET_IEEE80211_DEV(hw, &intf->dev); udev = interface_to_usbdev(intf); usb_get_dev(udev); usb_priv = rtl_usbpriv(hw); memset(usb_priv, 0, sizeof(*usb_priv)); usb_priv->dev.intf = intf; usb_priv->dev.udev = udev; usb_set_intfdata(intf, hw); rtlpriv->rtlhal.interface = INTF_USB; rtlpriv->cfg = rtl_hal_cfg; rtlpriv->intf_ops = &rtl_usb_ops; _rtl_usb_io_handler_init(&udev->dev, hw); rtlpriv->cfg->ops->read_chip_version(hw); rtlpriv->cfg->ops->read_eeprom_info(hw); err = _rtl_usb_init(hw); if (err) goto error_out2; rtl_usb_init_sw(hw); err = rtl_init_core(hw); if (err) { pr_err(""Can't allocate sw for mac80211\n""); goto error_out2; } if (rtlpriv->cfg->ops->init_sw_vars(hw)) { pr_err(""Can't init_sw_vars\n""); goto error_out; } rtlpriv->cfg->ops->init_sw_leds(hw); err = ieee80211_register_hw(hw); if (err) { pr_err(""Can't register mac80211 hw.\n""); err = -ENODEV; goto error_out; } rtlpriv->mac80211.mac80211_registered = 1; set_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status); return 0; error_out: rtl_deinit_core(hw); error_out2: _rtl_usb_io_handler_release(hw); usb_put_dev(udev); complete(&rtlpriv->firmware_loading_complete); return -ENODEV; }","- if (!rtlpriv->usb_data)
+ if (!rtlpriv->usb_data) {
+ ieee80211_free_hw(hw);
+ }
+ kfree(rtlpriv->usb_data);","int rtl_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, struct rtl_hal_cfg *rtl_hal_cfg) { int err; struct ieee80211_hw *hw = NULL; struct rtl_priv *rtlpriv = NULL; struct usb_device *udev; struct rtl_usb_priv *usb_priv; hw = ieee80211_alloc_hw(sizeof(struct rtl_priv) + sizeof(struct rtl_usb_priv), &rtl_ops); if (!hw) { WARN_ONCE(true, ""rtl_usb: ieee80211 alloc failed\n""); return -ENOMEM; } rtlpriv = hw->priv; rtlpriv->hw = hw; rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32), GFP_KERNEL); if (!rtlpriv->usb_data) { ieee80211_free_hw(hw); return -ENOMEM; } spin_lock_init(&rtlpriv->locks.usb_lock); INIT_WORK(&rtlpriv->works.fill_h2c_cmd, rtl_fill_h2c_cmd_work_callback); INIT_WORK(&rtlpriv->works.lps_change_work, rtl_lps_change_work_callback); rtlpriv->usb_data_index = 0; init_completion(&rtlpriv->firmware_loading_complete); SET_IEEE80211_DEV(hw, &intf->dev); udev = interface_to_usbdev(intf); usb_get_dev(udev); usb_priv = rtl_usbpriv(hw); memset(usb_priv, 0, sizeof(*usb_priv)); usb_priv->dev.intf = intf; usb_priv->dev.udev = udev; usb_set_intfdata(intf, hw); rtlpriv->rtlhal.interface = INTF_USB; rtlpriv->cfg = rtl_hal_cfg; rtlpriv->intf_ops = &rtl_usb_ops; _rtl_usb_io_handler_init(&udev->dev, hw); rtlpriv->cfg->ops->read_chip_version(hw); rtlpriv->cfg->ops->read_eeprom_info(hw); err = _rtl_usb_init(hw); if (err) goto error_out2; rtl_usb_init_sw(hw); err = rtl_init_core(hw); if (err) { pr_err(""Can't allocate sw for mac80211\n""); goto error_out2; } if (rtlpriv->cfg->ops->init_sw_vars(hw)) { pr_err(""Can't init_sw_vars\n""); goto error_out; } rtlpriv->cfg->ops->init_sw_leds(hw); err = ieee80211_register_hw(hw); if (err) { pr_err(""Can't register mac80211 hw.\n""); err = -ENODEV; goto error_out; } rtlpriv->mac80211.mac80211_registered = 1; set_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status); return 0; error_out: rtl_deinit_core(hw); error_out2: _rtl_usb_io_handler_release(hw); usb_put_dev(udev); complete(&rtlpriv->firmware_loading_complete); kfree(rtlpriv->usb_data); return -ENODEV; }"
867,3061----CWE-770----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ximage.cpp----CxImage::GetSize,<S2SV_StartVul> int32_t CxImage::GetSize() <S2SV_EndVul> { <S2SV_StartVul> return head.biSize + head.biSizeImage + GetPaletteSize(); <S2SV_EndVul> },"- int32_t CxImage::GetSize()
- return head.biSize + head.biSizeImage + GetPaletteSize();
+ uint32_t CxImage::GetSize()
+ uint64_t size64 = head.biSize + head.biSizeImage + GetPaletteSize();
+ if (size64 > 0xFFFFFFFF)
+ return 0xFFFFFFFF;
+ return (uint32_t)size64;",uint32_t CxImage::GetSize() { uint64_t size64 = head.biSize + head.biSizeImage + GetPaletteSize(); if (size64 > 0xFFFFFFFF) return 0xFFFFFFFF; return (uint32_t)size64; }
868,4871----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/lua_struct.c----optsize,"static size_t optsize (lua_State *L, char opt, const char **fmt) { switch (opt) { case 'B': case 'b': return sizeof(char); case 'H': case 'h': return sizeof(short); case 'L': case 'l': return sizeof(long); case 'T': return sizeof(size_t); case 'f': return sizeof(float); case 'd': return sizeof(double); case 'x': return 1; <S2SV_StartVul> case 'c': return getnum(L, fmt, 1); <S2SV_EndVul> case 'i': case 'I': { <S2SV_StartVul> int sz = getnum(L, fmt, sizeof(int)); <S2SV_EndVul> if (sz > MAXINTSIZE) luaL_error(L, ""integral size %d is larger than limit of %d"", sz, MAXINTSIZE); return sz; } default: return 0; } }","- case 'c': return getnum(L, fmt, 1);
- int sz = getnum(L, fmt, sizeof(int));
+ case 'c': return getnum(fmt, 1);
+ int sz = getnum(fmt, sizeof(int));","static size_t optsize (lua_State *L, char opt, const char **fmt) { switch (opt) { case 'B': case 'b': return sizeof(char); case 'H': case 'h': return sizeof(short); case 'L': case 'l': return sizeof(long); case 'T': return sizeof(size_t); case 'f': return sizeof(float); case 'd': return sizeof(double); case 'x': return 1; case 'c': return getnum(fmt, 1); case 'i': case 'I': { int sz = getnum(fmt, sizeof(int)); if (sz > MAXINTSIZE) luaL_error(L, ""integral size %d is larger than limit of %d"", sz, MAXINTSIZE); return sz; } default: return 0; } }"
869,141----CWE-310----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3568--s23_srvr.c----*ssl23_get_server_method,static const SSL_METHOD *ssl23_get_server_method(int ver) { #ifndef OPENSSL_NO_SSL2 if (ver == SSL2_VERSION) return(SSLv2_server_method()); #endif if (ver == SSL3_VERSION) return(SSLv3_server_method()); else if (ver == TLS1_VERSION) return(TLSv1_server_method()); <S2SV_StartVul> else if (ver == TLS1_1_VERSION) <S2SV_EndVul> return(TLSv1_1_server_method()); else return(NULL); },"- else if (ver == TLS1_1_VERSION)
+ return(SSLv3_server_method());
+ return(TLSv1_server_method());
+ else if (ver == TLS1_1_VERSION)",static const SSL_METHOD *ssl23_get_server_method(int ver) { #ifndef OPENSSL_NO_SSL2 if (ver == SSL2_VERSION) return(SSLv2_server_method()); #endif #ifndef OPENSSL_NO_SSL3 if (ver == SSL3_VERSION) return(SSLv3_server_method()); #endif if (ver == TLS1_VERSION) return(TLSv1_server_method()); else if (ver == TLS1_1_VERSION) return(TLSv1_1_server_method()); else return(NULL); }
870,7104----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/CImg.h----cimg_library_suffixed::CImg::_load_bmp,"CImg<T>& _load_bmp(std::FILE *const file, const char *const filename) { if (!file && !filename) throw CImgArgumentException(_cimg_instance ""load_bmp(): Specified filename is (null)."", cimg_instance); std::FILE *const nfile = file?file:cimg::fopen(filename,""rb""); CImg<ucharT> header(54); cimg::fread(header._data,54,nfile); if (*header!='B' || header[1]!='M') { if (!file) cimg::fclose(nfile); throw CImgIOException(_cimg_instance ""load_bmp(): Invalid BMP file '%s'."", cimg_instance, filename?filename:""(FILE*)""); } int file_size = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24), offset = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24), header_size = header[0x0E] + (header[0x0F]<<8) + (header[0x10]<<16) + (header[0x11]<<24), dx = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24), dy = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24), compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24), nb_colors = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24), bpp = header[0x1C] + (header[0x1D]<<8); if (!file_size || file_size==offset) { cimg::fseek(nfile,0,SEEK_END); file_size = (int)cimg::ftell(nfile); cimg::fseek(nfile,54,SEEK_SET); } if (header_size>40) cimg::fseek(nfile,header_size - 40,SEEK_CUR); const int dx_bytes = (bpp==1)?(dx/8 + (dx%8?1:0)):((bpp==4)?(dx/2 + (dx%2)):(int)((longT)dx*bpp/8)), align_bytes = (4 - dx_bytes%4)%4; const ulongT cimg_iobuffer = (ulongT)24*1024*1024, buf_size = std::min((ulongT)cimg::abs(dy)*(dx_bytes + align_bytes),(ulongT)file_size - offset); CImg<intT> colormap; if (bpp<16) { if (!nb_colors) nb_colors = 1<<bpp; } else nb_colors = 0; if (nb_colors) { colormap.assign(nb_colors); cimg::fread(colormap._data,nb_colors,nfile); } const int xoffset = offset - 14 - header_size - 4*nb_colors; if (xoffset>0) cimg::fseek(nfile,xoffset,SEEK_CUR); CImg<ucharT> buffer; if (buf_size<cimg_iobuffer) { <S2SV_StartVul> buffer.assign(cimg::abs(dy)*(dx_bytes + align_bytes),1,1,1,0); <S2SV_EndVul> cimg::fread(buffer._data,buf_size,nfile); } else buffer.assign(dx_bytes + align_bytes); unsigned char *ptrs = buffer; if (compression) { if (file) throw CImgIOException(_cimg_instance ""load_bmp(): Unable to load compressed data from '(*FILE)' inputs."", cimg_instance); else { if (!file) cimg::fclose(nfile); return load_other(filename); } } assign(dx,cimg::abs(dy),1,3,0); switch (bpp) { case 1 : { if (colormap._width>=2) for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } unsigned char mask = 0x80, val = 0; cimg_forX(*this,x) { if (mask==0x80) val = *(ptrs++); const unsigned char *col = (unsigned char*)(colormap._data + (val&mask?1:0)); (*this)(x,y,2) = (T)*(col++); (*this)(x,y,1) = (T)*(col++); (*this)(x,y,0) = (T)*(col++); mask = cimg::ror(mask); } ptrs+=align_bytes; } } break; case 4 : { if (colormap._width>=16) for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } unsigned char mask = 0xF0, val = 0; cimg_forX(*this,x) { if (mask==0xF0) val = *(ptrs++); const unsigned char color = (unsigned char)((mask<16)?(val&mask):((val&mask)>>4)); const unsigned char *col = (unsigned char*)(colormap._data + color); (*this)(x,y,2) = (T)*(col++); (*this)(x,y,1) = (T)*(col++); (*this)(x,y,0) = (T)*(col++); mask = cimg::ror(mask,4); } ptrs+=align_bytes; } } break; case 8 : { if (colormap._width>=256) for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { const unsigned char *col = (unsigned char*)(colormap._data + *(ptrs++)); (*this)(x,y,2) = (T)*(col++); (*this)(x,y,1) = (T)*(col++); (*this)(x,y,0) = (T)*(col++); } ptrs+=align_bytes; } } break; case 16 : { for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { const unsigned char c1 = *(ptrs++), c2 = *(ptrs++); const unsigned short col = (unsigned short)(c1|(c2<<8)); (*this)(x,y,2) = (T)(col&0x1F); (*this)(x,y,1) = (T)((col>>5)&0x1F); (*this)(x,y,0) = (T)((col>>10)&0x1F); } ptrs+=align_bytes; } } break; case 24 : { for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { (*this)(x,y,2) = (T)*(ptrs++); (*this)(x,y,1) = (T)*(ptrs++); (*this)(x,y,0) = (T)*(ptrs++); } ptrs+=align_bytes; } } break; case 32 : { for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { (*this)(x,y,2) = (T)*(ptrs++); (*this)(x,y,1) = (T)*(ptrs++); (*this)(x,y,0) = (T)*(ptrs++); ++ptrs; } ptrs+=align_bytes; } } break; } if (dy<0) mirror('y'); if (!file) cimg::fclose(nfile); return *this;","- buffer.assign(cimg::abs(dy)*(dx_bytes + align_bytes),1,1,1,0);
+ buffer.assign(buf_size,1,1,1,0);","CImg<T>& _load_bmp(std::FILE *const file, const char *const filename) { if (!file && !filename) throw CImgArgumentException(_cimg_instance ""load_bmp(): Specified filename is (null)."", cimg_instance); std::FILE *const nfile = file?file:cimg::fopen(filename,""rb""); CImg<ucharT> header(54); cimg::fread(header._data,54,nfile); if (*header!='B' || header[1]!='M') { if (!file) cimg::fclose(nfile); throw CImgIOException(_cimg_instance ""load_bmp(): Invalid BMP file '%s'."", cimg_instance, filename?filename:""(FILE*)""); } int file_size = header[0x02] + (header[0x03]<<8) + (header[0x04]<<16) + (header[0x05]<<24), offset = header[0x0A] + (header[0x0B]<<8) + (header[0x0C]<<16) + (header[0x0D]<<24), header_size = header[0x0E] + (header[0x0F]<<8) + (header[0x10]<<16) + (header[0x11]<<24), dx = header[0x12] + (header[0x13]<<8) + (header[0x14]<<16) + (header[0x15]<<24), dy = header[0x16] + (header[0x17]<<8) + (header[0x18]<<16) + (header[0x19]<<24), compression = header[0x1E] + (header[0x1F]<<8) + (header[0x20]<<16) + (header[0x21]<<24), nb_colors = header[0x2E] + (header[0x2F]<<8) + (header[0x30]<<16) + (header[0x31]<<24), bpp = header[0x1C] + (header[0x1D]<<8); if (!file_size || file_size==offset) { cimg::fseek(nfile,0,SEEK_END); file_size = (int)cimg::ftell(nfile); cimg::fseek(nfile,54,SEEK_SET); } if (header_size>40) cimg::fseek(nfile,header_size - 40,SEEK_CUR); const int dx_bytes = (bpp==1)?(dx/8 + (dx%8?1:0)):((bpp==4)?(dx/2 + (dx%2)):(int)((longT)dx*bpp/8)), align_bytes = (4 - dx_bytes%4)%4; const ulongT cimg_iobuffer = (ulongT)24*1024*1024, buf_size = std::min((ulongT)cimg::abs(dy)*(dx_bytes + align_bytes),(ulongT)file_size - offset); CImg<intT> colormap; if (bpp<16) { if (!nb_colors) nb_colors = 1<<bpp; } else nb_colors = 0; if (nb_colors) { colormap.assign(nb_colors); cimg::fread(colormap._data,nb_colors,nfile); } const int xoffset = offset - 14 - header_size - 4*nb_colors; if (xoffset>0) cimg::fseek(nfile,xoffset,SEEK_CUR); CImg<ucharT> buffer; if (buf_size<cimg_iobuffer) { buffer.assign(buf_size,1,1,1,0); cimg::fread(buffer._data,buf_size,nfile); } else buffer.assign(dx_bytes + align_bytes); unsigned char *ptrs = buffer; if (compression) { if (file) throw CImgIOException(_cimg_instance ""load_bmp(): Unable to load compressed data from '(*FILE)' inputs."", cimg_instance); else { if (!file) cimg::fclose(nfile); return load_other(filename); } } assign(dx,cimg::abs(dy),1,3,0); switch (bpp) { case 1 : { if (colormap._width>=2) for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } unsigned char mask = 0x80, val = 0; cimg_forX(*this,x) { if (mask==0x80) val = *(ptrs++); const unsigned char *col = (unsigned char*)(colormap._data + (val&mask?1:0)); (*this)(x,y,2) = (T)*(col++); (*this)(x,y,1) = (T)*(col++); (*this)(x,y,0) = (T)*(col++); mask = cimg::ror(mask); } ptrs+=align_bytes; } } break; case 4 : { if (colormap._width>=16) for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } unsigned char mask = 0xF0, val = 0; cimg_forX(*this,x) { if (mask==0xF0) val = *(ptrs++); const unsigned char color = (unsigned char)((mask<16)?(val&mask):((val&mask)>>4)); const unsigned char *col = (unsigned char*)(colormap._data + color); (*this)(x,y,2) = (T)*(col++); (*this)(x,y,1) = (T)*(col++); (*this)(x,y,0) = (T)*(col++); mask = cimg::ror(mask,4); } ptrs+=align_bytes; } } break; case 8 : { if (colormap._width>=256) for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { const unsigned char *col = (unsigned char*)(colormap._data + *(ptrs++)); (*this)(x,y,2) = (T)*(col++); (*this)(x,y,1) = (T)*(col++); (*this)(x,y,0) = (T)*(col++); } ptrs+=align_bytes; } } break; case 16 : { for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { const unsigned char c1 = *(ptrs++), c2 = *(ptrs++); const unsigned short col = (unsigned short)(c1|(c2<<8)); (*this)(x,y,2) = (T)(col&0x1F); (*this)(x,y,1) = (T)((col>>5)&0x1F); (*this)(x,y,0) = (T)((col>>10)&0x1F); } ptrs+=align_bytes; } } break; case 24 : { for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { (*this)(x,y,2) = (T)*(ptrs++); (*this)(x,y,1) = (T)*(ptrs++); (*this)(x,y,0) = (T)*(ptrs++); } ptrs+=align_bytes; } } break; case 32 : { for (int y = height() - 1; y>=0; --y) { if (buf_size>=cimg_iobuffer) { if (!cimg::fread(ptrs=buffer._data,dx_bytes,nfile)) break; cimg::fseek(nfile,align_bytes,SEEK_CUR); } cimg_forX(*this,x) { (*this)(x,y,2) = (T)*(ptrs++); (*this)(x,y,1) = (T)*(ptrs++); (*this)(x,y,0) = (T)*(ptrs++); ++ptrs; } ptrs+=align_bytes; } } break; } if (dy<0) mirror('y'); if (!file) cimg::fclose(nfile); return *this;"
871,1729----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10129--smart_protocol.c----parse_report,"static int parse_report(transport_smart *transport, git_push *push) { git_pkt *pkt = NULL; const char *line_end = NULL; gitno_buffer *buf = &transport->buffer; int error, recvd; git_buf data_pkt_buf = GIT_BUF_INIT; for (;;) { if (buf->offset > 0) error = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset); else error = GIT_EBUFS; if (error < 0 && error != GIT_EBUFS) { error = -1; goto done; } if (error == GIT_EBUFS) { if ((recvd = gitno_recv(buf)) < 0) { error = recvd; goto done; } if (recvd == 0) { giterr_set(GITERR_NET, ""early EOF""); error = GIT_EEOF; goto done; } continue; } gitno_consume(buf, line_end); error = 0; <S2SV_StartVul> if (pkt == NULL) <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> switch (pkt->type) { case GIT_PKT_DATA: error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf); break; case GIT_PKT_ERR: giterr_set(GITERR_NET, ""report-status: Error reported: %s"", ((git_pkt_err *)pkt)->error); error = -1; break; case GIT_PKT_PROGRESS: if (transport->progress_cb) { git_pkt_progress *p = (git_pkt_progress *) pkt; error = transport->progress_cb(p->data, p->len, transport->message_cb_payload); } break; default: error = add_push_report_pkt(push, pkt); break; } git_pkt_free(pkt); if (error == GIT_ITEROVER) { error = 0; if (data_pkt_buf.size > 0) { giterr_set(GITERR_NET, ""Incomplete pack data pkt-line""); error = GIT_ERROR; } goto done; } if (error < 0) { goto done; } } done: git_buf_free(&data_pkt_buf); return error; }","- if (pkt == NULL)
- continue;","static int parse_report(transport_smart *transport, git_push *push) { git_pkt *pkt = NULL; const char *line_end = NULL; gitno_buffer *buf = &transport->buffer; int error, recvd; git_buf data_pkt_buf = GIT_BUF_INIT; for (;;) { if (buf->offset > 0) error = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset); else error = GIT_EBUFS; if (error < 0 && error != GIT_EBUFS) { error = -1; goto done; } if (error == GIT_EBUFS) { if ((recvd = gitno_recv(buf)) < 0) { error = recvd; goto done; } if (recvd == 0) { giterr_set(GITERR_NET, ""early EOF""); error = GIT_EEOF; goto done; } continue; } gitno_consume(buf, line_end); error = 0; switch (pkt->type) { case GIT_PKT_DATA: error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf); break; case GIT_PKT_ERR: giterr_set(GITERR_NET, ""report-status: Error reported: %s"", ((git_pkt_err *)pkt)->error); error = -1; break; case GIT_PKT_PROGRESS: if (transport->progress_cb) { git_pkt_progress *p = (git_pkt_progress *) pkt; error = transport->progress_cb(p->data, p->len, transport->message_cb_payload); } break; default: error = add_push_report_pkt(push, pkt); break; } git_pkt_free(pkt); if (error == GIT_ITEROVER) { error = 0; if (data_pkt_buf.size > 0) { giterr_set(GITERR_NET, ""Incomplete pack data pkt-line""); error = GIT_ERROR; } goto done; } if (error < 0) { goto done; } } done: git_buf_free(&data_pkt_buf); return error; }"
872,3689----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-mpls.c----mpls_print,"mpls_print(netdissect_options *ndo, const u_char *bp, u_int length) { const u_char *p; uint32_t label_entry; uint16_t label_stack_depth = 0; enum mpls_packet_type pt = PT_UNKNOWN; p = bp; ND_PRINT((ndo, ""MPLS"")); do { ND_TCHECK2(*p, sizeof(label_entry)); if (length < sizeof(label_entry)) { ND_PRINT((ndo, ""[|MPLS], length %u"", length)); return; } label_entry = EXTRACT_32BITS(p); ND_PRINT((ndo, ""%s(label %u"", (label_stack_depth && ndo->ndo_vflag) ? ""\n\t"" : "" "", MPLS_LABEL(label_entry))); label_stack_depth++; if (ndo->ndo_vflag && MPLS_LABEL(label_entry) < sizeof(mpls_labelname) / sizeof(mpls_labelname[0])) ND_PRINT((ndo, "" (%s)"", mpls_labelname[MPLS_LABEL(label_entry)])); ND_PRINT((ndo, "", exp %u"", MPLS_EXP(label_entry))); if (MPLS_STACK(label_entry)) ND_PRINT((ndo, "", [S]"")); ND_PRINT((ndo, "", ttl %u)"", MPLS_TTL(label_entry))); p += sizeof(label_entry); length -= sizeof(label_entry); } while (!MPLS_STACK(label_entry)); switch (MPLS_LABEL(label_entry)) { case 0: case 3: pt = PT_IPV4; break; case 2: pt = PT_IPV6; break; default: ND_TCHECK(*p); if (length < 1) { return; } switch(*p) { case 0x45: case 0x46: case 0x47: case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4c: case 0x4d: case 0x4e: case 0x4f: pt = PT_IPV4; break; case 0x60: case 0x61: case 0x62: case 0x63: case 0x64: case 0x65: case 0x66: case 0x67: case 0x68: case 0x69: case 0x6a: case 0x6b: case 0x6c: case 0x6d: case 0x6e: case 0x6f: pt = PT_IPV6; break; case 0x81: case 0x82: case 0x83: pt = PT_OSI; break; default: break; } } if (pt == PT_UNKNOWN) { if (!ndo->ndo_suppress_default_print) ND_DEFAULTPRINT(p, length); return; } ND_PRINT((ndo, ndo->ndo_vflag ? ""\n\t"" : "" "")); switch (pt) { case PT_IPV4: ip_print(ndo, p, length); break; case PT_IPV6: ip6_print(ndo, p, length); break; case PT_OSI: <S2SV_StartVul> isoclns_print(ndo, p, length, length); <S2SV_EndVul> break; default: break; } return; trunc: ND_PRINT((ndo, ""[|MPLS]"")); }","- isoclns_print(ndo, p, length, length);
+ isoclns_print(ndo, p, length);","mpls_print(netdissect_options *ndo, const u_char *bp, u_int length) { const u_char *p; uint32_t label_entry; uint16_t label_stack_depth = 0; enum mpls_packet_type pt = PT_UNKNOWN; p = bp; ND_PRINT((ndo, ""MPLS"")); do { ND_TCHECK2(*p, sizeof(label_entry)); if (length < sizeof(label_entry)) { ND_PRINT((ndo, ""[|MPLS], length %u"", length)); return; } label_entry = EXTRACT_32BITS(p); ND_PRINT((ndo, ""%s(label %u"", (label_stack_depth && ndo->ndo_vflag) ? ""\n\t"" : "" "", MPLS_LABEL(label_entry))); label_stack_depth++; if (ndo->ndo_vflag && MPLS_LABEL(label_entry) < sizeof(mpls_labelname) / sizeof(mpls_labelname[0])) ND_PRINT((ndo, "" (%s)"", mpls_labelname[MPLS_LABEL(label_entry)])); ND_PRINT((ndo, "", exp %u"", MPLS_EXP(label_entry))); if (MPLS_STACK(label_entry)) ND_PRINT((ndo, "", [S]"")); ND_PRINT((ndo, "", ttl %u)"", MPLS_TTL(label_entry))); p += sizeof(label_entry); length -= sizeof(label_entry); } while (!MPLS_STACK(label_entry)); switch (MPLS_LABEL(label_entry)) { case 0: case 3: pt = PT_IPV4; break; case 2: pt = PT_IPV6; break; default: ND_TCHECK(*p); if (length < 1) { return; } switch(*p) { case 0x45: case 0x46: case 0x47: case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4c: case 0x4d: case 0x4e: case 0x4f: pt = PT_IPV4; break; case 0x60: case 0x61: case 0x62: case 0x63: case 0x64: case 0x65: case 0x66: case 0x67: case 0x68: case 0x69: case 0x6a: case 0x6b: case 0x6c: case 0x6d: case 0x6e: case 0x6f: pt = PT_IPV6; break; case 0x81: case 0x82: case 0x83: pt = PT_OSI; break; default: break; } } if (pt == PT_UNKNOWN) { if (!ndo->ndo_suppress_default_print) ND_DEFAULTPRINT(p, length); return; } ND_PRINT((ndo, ndo->ndo_vflag ? ""\n\t"" : "" "")); switch (pt) { case PT_IPV4: ip_print(ndo, p, length); break; case PT_IPV6: ip6_print(ndo, p, length); break; case PT_OSI: isoclns_print(ndo, p, length); break; default: break; } return; trunc: ND_PRINT((ndo, ""[|MPLS]"")); }"
873,1097--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-2543--seq_clientmgr.c----snd_seq_ioctl_remove_events,"static int snd_seq_ioctl_remove_events(struct snd_seq_client *client, void __user *arg) { struct snd_seq_remove_events info; if (copy_from_user(&info, arg, sizeof(info))) return -EFAULT; if (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) { <S2SV_StartVul> if (client->type == USER_CLIENT) <S2SV_EndVul> snd_seq_fifo_clear(client->data.user.fifo); } if (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT) snd_seq_queue_remove_cells(client->number, &info); return 0; }","- if (client->type == USER_CLIENT)
+ if (client->type == USER_CLIENT && client->data.user.fifo)","static int snd_seq_ioctl_remove_events(struct snd_seq_client *client, void __user *arg) { struct snd_seq_remove_events info; if (copy_from_user(&info, arg, sizeof(info))) return -EFAULT; if (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) { if (client->type == USER_CLIENT && client->data.user.fifo) snd_seq_fifo_clear(client->data.user.fifo); } if (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT) snd_seq_queue_remove_cells(client->number, &info); return 0; }"
874,4585----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ext_simplexml.cpp----HPHP::f_libxml_disable_entity_loader,bool f_libxml_disable_entity_loader(bool disable ) { <S2SV_StartVul> xmlParserInputBufferCreateFilenameFunc old; <S2SV_EndVul> <S2SV_StartVul> if (disable) { <S2SV_EndVul> <S2SV_StartVul> old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload); <S2SV_EndVul> <S2SV_StartVul> } else { <S2SV_EndVul> <S2SV_StartVul> old = xmlParserInputBufferCreateFilenameDefault(nullptr); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return (old == hphp_libxml_input_buffer_noload); <S2SV_EndVul> },"- xmlParserInputBufferCreateFilenameFunc old;
- if (disable) {
- old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload);
- } else {
- old = xmlParserInputBufferCreateFilenameDefault(nullptr);
- }
- return (old == hphp_libxml_input_buffer_noload);
+ bool old = s_libxml_errors->m_entity_loader_disabled;
+ s_libxml_errors->m_entity_loader_disabled = disable;
+ return old;",bool f_libxml_disable_entity_loader(bool disable ) { bool old = s_libxml_errors->m_entity_loader_disabled; s_libxml_errors->m_entity_loader_disabled = disable; return old; }
875,4651----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/main.c----nfcmrvl_nci_unregister_dev,void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv) { struct nci_dev *ndev = priv->ndev; if (priv->ndev->nfc_dev->fw_download_in_progress) nfcmrvl_fw_dnld_abort(priv); nfcmrvl_fw_dnld_deinit(priv); if (gpio_is_valid(priv->config.reset_n_io)) gpio_free(priv->config.reset_n_io); <S2SV_StartVul> nci_unregister_device(ndev); <S2SV_EndVul> nci_free_device(ndev); kfree(priv); },"- nci_unregister_device(ndev);
+ nci_unregister_device(ndev);",void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv) { struct nci_dev *ndev = priv->ndev; nci_unregister_device(ndev); if (priv->ndev->nfc_dev->fw_download_in_progress) nfcmrvl_fw_dnld_abort(priv); nfcmrvl_fw_dnld_deinit(priv); if (gpio_is_valid(priv->config.reset_n_io)) gpio_free(priv->config.reset_n_io); nci_free_device(ndev); kfree(priv); }
876,7354----CWE-285----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/acl.c----__f2fs_set_acl,"static int __f2fs_set_acl(struct inode *inode, int type, struct posix_acl *acl, struct page *ipage) { int name_index; void *value = NULL; size_t size = 0; int error; switch (type) { case ACL_TYPE_ACCESS: name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS; if (acl) { <S2SV_StartVul> error = posix_acl_equiv_mode(acl, &inode->i_mode); <S2SV_EndVul> <S2SV_StartVul> if (error < 0) <S2SV_EndVul> return error; set_acl_inode(inode, inode->i_mode); <S2SV_StartVul> if (error == 0) <S2SV_EndVul> <S2SV_StartVul> acl = NULL; <S2SV_EndVul> } break; case ACL_TYPE_DEFAULT: name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT; if (!S_ISDIR(inode->i_mode)) return acl ? -EACCES : 0; break; default: return -EINVAL; } if (acl) { value = f2fs_acl_to_disk(acl, &size); if (IS_ERR(value)) { clear_inode_flag(inode, FI_ACL_MODE); return (int)PTR_ERR(value); } } error = f2fs_setxattr(inode, name_index, """", value, size, ipage, 0); kfree(value); if (!error) set_cached_acl(inode, type, acl); clear_inode_flag(inode, FI_ACL_MODE); return error; }","- error = posix_acl_equiv_mode(acl, &inode->i_mode);
- if (error < 0)
- if (error == 0)
- acl = NULL;
+ error = posix_acl_update_mode(inode, &inode->i_mode, &acl);
+ if (error)","static int __f2fs_set_acl(struct inode *inode, int type, struct posix_acl *acl, struct page *ipage) { int name_index; void *value = NULL; size_t size = 0; int error; switch (type) { case ACL_TYPE_ACCESS: name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS; if (acl) { error = posix_acl_update_mode(inode, &inode->i_mode, &acl); if (error) return error; set_acl_inode(inode, inode->i_mode); } break; case ACL_TYPE_DEFAULT: name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT; if (!S_ISDIR(inode->i_mode)) return acl ? -EACCES : 0; break; default: return -EINVAL; } if (acl) { value = f2fs_acl_to_disk(acl, &size); if (IS_ERR(value)) { clear_inode_flag(inode, FI_ACL_MODE); return (int)PTR_ERR(value); } } error = f2fs_setxattr(inode, name_index, """", value, size, ipage, 0); kfree(value); if (!error) set_cached_acl(inode, type, acl); clear_inode_flag(inode, FI_ACL_MODE); return error; }"
877,1226----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-16996--verifier.c----adjust_scalar_min_max_vals,"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *dst_reg, struct bpf_reg_state src_reg) { struct bpf_reg_state *regs = cur_regs(env); u8 opcode = BPF_OP(insn->code); bool src_known, dst_known; s64 smin_val, smax_val; u64 umin_val, umax_val; if (BPF_CLASS(insn->code) != BPF_ALU64) { <S2SV_StartVul> coerce_reg_to_32(dst_reg); <S2SV_EndVul> <S2SV_StartVul> coerce_reg_to_32(&src_reg); <S2SV_EndVul> } smin_val = src_reg.smin_value; smax_val = src_reg.smax_value; umin_val = src_reg.umin_value; umax_val = src_reg.umax_value; src_known = tnum_is_const(src_reg.var_off); dst_known = tnum_is_const(dst_reg->var_off); switch (opcode) { case BPF_ADD: if (signed_add_overflows(dst_reg->smin_value, smin_val) || signed_add_overflows(dst_reg->smax_value, smax_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value += smin_val; dst_reg->smax_value += smax_val; } if (dst_reg->umin_value + umin_val < umin_val || dst_reg->umax_value + umax_val < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value += umin_val; dst_reg->umax_value += umax_val; } dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off); break; case BPF_SUB: if (signed_sub_overflows(dst_reg->smin_value, smax_val) || signed_sub_overflows(dst_reg->smax_value, smin_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value -= smax_val; dst_reg->smax_value -= smin_val; } if (dst_reg->umin_value < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value -= umax_val; dst_reg->umax_value -= umin_val; } dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off); break; case BPF_MUL: dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off); if (smin_val < 0 || dst_reg->smin_value < 0) { __mark_reg_unbounded(dst_reg); __update_reg_bounds(dst_reg); break; } if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) { __mark_reg_unbounded(dst_reg); __update_reg_bounds(dst_reg); break; } dst_reg->umin_value *= umin_val; dst_reg->umax_value *= umax_val; if (dst_reg->umax_value > S64_MAX) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } break; case BPF_AND: if (src_known && dst_known) { __mark_reg_known(dst_reg, dst_reg->var_off.value & src_reg.var_off.value); break; } dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off); dst_reg->umin_value = dst_reg->var_off.value; dst_reg->umax_value = min(dst_reg->umax_value, umax_val); if (dst_reg->smin_value < 0 || smin_val < 0) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } __update_reg_bounds(dst_reg); break; case BPF_OR: if (src_known && dst_known) { __mark_reg_known(dst_reg, dst_reg->var_off.value | src_reg.var_off.value); break; } dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off); dst_reg->umin_value = max(dst_reg->umin_value, umin_val); dst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask; if (dst_reg->smin_value < 0 || smin_val < 0) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } __update_reg_bounds(dst_reg); break; case BPF_LSH: if (umax_val > 63) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; if (dst_reg->umax_value > 1ULL << (63 - umax_val)) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value <<= umin_val; dst_reg->umax_value <<= umax_val; } if (src_known) dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val); else dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val); __update_reg_bounds(dst_reg); break; case BPF_RSH: if (umax_val > 63) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; if (src_known) dst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val); else dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val); dst_reg->umin_value >>= umax_val; dst_reg->umax_value >>= umin_val; __update_reg_bounds(dst_reg); break; default: mark_reg_unknown(env, regs, insn->dst_reg); break; } __reg_deduce_bounds(dst_reg); __reg_bound_offset(dst_reg); return 0; }","- coerce_reg_to_32(dst_reg);
- coerce_reg_to_32(&src_reg);
+ coerce_reg_to_size(dst_reg, 4);
+ coerce_reg_to_size(&src_reg, 4);","static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *dst_reg, struct bpf_reg_state src_reg) { struct bpf_reg_state *regs = cur_regs(env); u8 opcode = BPF_OP(insn->code); bool src_known, dst_known; s64 smin_val, smax_val; u64 umin_val, umax_val; if (BPF_CLASS(insn->code) != BPF_ALU64) { coerce_reg_to_size(dst_reg, 4); coerce_reg_to_size(&src_reg, 4); } smin_val = src_reg.smin_value; smax_val = src_reg.smax_value; umin_val = src_reg.umin_value; umax_val = src_reg.umax_value; src_known = tnum_is_const(src_reg.var_off); dst_known = tnum_is_const(dst_reg->var_off); switch (opcode) { case BPF_ADD: if (signed_add_overflows(dst_reg->smin_value, smin_val) || signed_add_overflows(dst_reg->smax_value, smax_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value += smin_val; dst_reg->smax_value += smax_val; } if (dst_reg->umin_value + umin_val < umin_val || dst_reg->umax_value + umax_val < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value += umin_val; dst_reg->umax_value += umax_val; } dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off); break; case BPF_SUB: if (signed_sub_overflows(dst_reg->smin_value, smax_val) || signed_sub_overflows(dst_reg->smax_value, smin_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value -= smax_val; dst_reg->smax_value -= smin_val; } if (dst_reg->umin_value < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value -= umax_val; dst_reg->umax_value -= umin_val; } dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off); break; case BPF_MUL: dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off); if (smin_val < 0 || dst_reg->smin_value < 0) { __mark_reg_unbounded(dst_reg); __update_reg_bounds(dst_reg); break; } if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) { __mark_reg_unbounded(dst_reg); __update_reg_bounds(dst_reg); break; } dst_reg->umin_value *= umin_val; dst_reg->umax_value *= umax_val; if (dst_reg->umax_value > S64_MAX) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } break; case BPF_AND: if (src_known && dst_known) { __mark_reg_known(dst_reg, dst_reg->var_off.value & src_reg.var_off.value); break; } dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off); dst_reg->umin_value = dst_reg->var_off.value; dst_reg->umax_value = min(dst_reg->umax_value, umax_val); if (dst_reg->smin_value < 0 || smin_val < 0) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } __update_reg_bounds(dst_reg); break; case BPF_OR: if (src_known && dst_known) { __mark_reg_known(dst_reg, dst_reg->var_off.value | src_reg.var_off.value); break; } dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off); dst_reg->umin_value = max(dst_reg->umin_value, umin_val); dst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask; if (dst_reg->smin_value < 0 || smin_val < 0) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } __update_reg_bounds(dst_reg); break; case BPF_LSH: if (umax_val > 63) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; if (dst_reg->umax_value > 1ULL << (63 - umax_val)) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value <<= umin_val; dst_reg->umax_value <<= umax_val; } if (src_known) dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val); else dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val); __update_reg_bounds(dst_reg); break; case BPF_RSH: if (umax_val > 63) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; if (src_known) dst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val); else dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val); dst_reg->umin_value >>= umax_val; dst_reg->umax_value >>= umin_val; __update_reg_bounds(dst_reg); break; default: mark_reg_unknown(env, regs, insn->dst_reg); break; } __reg_deduce_bounds(dst_reg); __reg_bound_offset(dst_reg); return 0; }"
878,5163----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core.c----pci_lintr_release,pci_lintr_release(struct pci_vdev *dev) { struct businfo *bi; struct slotinfo *si; int pin; bi = pci_businfo[dev->bus]; <S2SV_StartVul> assert(bi != NULL); <S2SV_EndVul> si = &bi->slotinfo[dev->slot]; for (pin = 1; pin < 4; pin++) { si->si_intpins[pin].ii_count = 0; si->si_intpins[pin].ii_pirq_pin = 0; si->si_intpins[pin].ii_ioapic_irq = 0; } },"- assert(bi != NULL);
+ if (bi == NULL) {
+ pr_err(""%s: pci [%s] has wrong bus %d info!\n"", __func__, dev->name, dev->bus);
+ return;
+ }","pci_lintr_release(struct pci_vdev *dev) { struct businfo *bi; struct slotinfo *si; int pin; bi = pci_businfo[dev->bus]; if (bi == NULL) { pr_err(""%s: pci [%s] has wrong bus %d info!\n"", __func__, dev->name, dev->bus); return; } si = &bi->slotinfo[dev->slot]; for (pin = 1; pin < 4; pin++) { si->si_intpins[pin].ii_count = 0; si->si_intpins[pin].ii_pirq_pin = 0; si->si_intpins[pin].ii_ioapic_irq = 0; } }"
879,1437----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-11721--huffman.c----Huff_offsetTransmit,"<S2SV_StartVul> void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) { <S2SV_EndVul> bloc = *offset; <S2SV_StartVul> send(huff->loc[ch], NULL, fout); <S2SV_EndVul> *offset = bloc; }","- void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
- send(huff->loc[ch], NULL, fout);
+ void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
+ bloc = *offset;","void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) { void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) { bloc = *offset; send(huff->loc[ch], NULL, fout, maxoffset); *offset = bloc; }"
880,837----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-1792--cms_smime.c----do_free_upto,"static void do_free_upto(BIO *f, BIO *upto) { if (upto) { BIO *tbio; do { tbio = BIO_pop(f); BIO_free(f); f = tbio; } <S2SV_StartVul> while (f != upto); <S2SV_EndVul> } else BIO_free_all(f); }","- while (f != upto);
+ while (f && f != upto);","static void do_free_upto(BIO *f, BIO *upto) { if (upto) { BIO *tbio; do { tbio = BIO_pop(f); BIO_free(f); f = tbio; } while (f && f != upto); } else BIO_free_all(f); }"
881,221----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-9601--jbig2_mmr.c----jbig2_decode_mmr_init,"jbig2_decode_mmr_init(Jbig2MmrCtx *mmr, int width, int height, const byte *data, size_t size) { <S2SV_StartVul> int i; <S2SV_EndVul> uint32_t word = 0; mmr->width = width; mmr->size = size; mmr->data_index = 0; mmr->bit_index = 0; for (i = 0; i < size && i < 4; i++) word |= (data[i] << ((3 - i) << 3)); mmr->word = word; }","- int i;
+ size_t i;","jbig2_decode_mmr_init(Jbig2MmrCtx *mmr, int width, int height, const byte *data, size_t size) { size_t i; uint32_t word = 0; mmr->width = width; mmr->size = size; mmr->data_index = 0; mmr->bit_index = 0; for (i = 0; i < size && i < 4; i++) word |= (data[i] << ((3 - i) << 3)); mmr->word = word; }"
882,5036----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ssi.c----ssiProcessIncludeCommand,"error_t ssiProcessIncludeCommand(HttpConnection *connection, const char_t *tag, size_t length, const char_t *uri, uint_t level) { error_t error; char_t *separator; char_t *attribute; char_t *value; char_t *path; char_t *p; if(length < 7 || length >= HTTP_SERVER_BUFFER_SIZE) return ERROR_INVALID_TAG; osMemcpy(connection->buffer, tag + 7, length - 7); connection->buffer[length - 7] = '\0'; <S2SV_StartVul> separator = strchr(connection->buffer, '='); <S2SV_EndVul> if(!separator) return ERROR_INVALID_TAG; *separator = '\0'; attribute = strTrimWhitespace(connection->buffer); value = strTrimWhitespace(separator + 1); if(value[0] == '\'' || value[0] == '\""') value++; length = osStrlen(value); if(length > 0) { if(value[length - 1] == '\'' || value[length - 1] == '\""') value[length - 1] = '\0'; } if(osStrlen(value) > HTTP_SERVER_URI_MAX_LEN) return ERROR_INVALID_TAG; if(!osStrcasecmp(attribute, ""file"")) { path = osAllocMem(osStrlen(uri) + osStrlen(value) + 1); if(path == NULL) return ERROR_OUT_OF_MEMORY; osStrcpy(path, uri); p = strrchr(path, '/'); if(p) osStrcpy(p + 1, value); else osStrcpy(path, value); } else if(!osStrcasecmp(attribute, ""virtual"")) { path = strDuplicate(value); if(path == NULL) return ERROR_OUT_OF_MEMORY; } else { return ERROR_INVALID_TAG; } if(httpCompExtension(value, "".stm"") || httpCompExtension(value, "".shtm"") || httpCompExtension(value, "".shtml"")) { error = ssiExecuteScript(connection, path, level + 1); } else { #if (HTTP_SERVER_FS_SUPPORT == ENABLED) FsFile *file; httpGetAbsolutePath(connection, path, connection->buffer, HTTP_SERVER_BUFFER_SIZE); file = fsOpenFile(connection->buffer, FS_FILE_MODE_READ); if(file) { while(1) { error = fsReadFile(file, connection->buffer, HTTP_SERVER_BUFFER_SIZE, &length); if(error) break; error = httpWriteStream(connection, connection->buffer, length); if(error) break; } fsCloseFile(file); if(error == ERROR_END_OF_FILE) error = NO_ERROR; } else { error = ERROR_NOT_FOUND; } #else const uint8_t *data; httpGetAbsolutePath(connection, path, connection->buffer, HTTP_SERVER_BUFFER_SIZE); error = resGetData(connection->buffer, &data, &length); if(!error) error = httpWriteStream(connection, data, length); #endif } if(error == ERROR_NOT_FOUND) error = ERROR_INVALID_TAG; osFreeMem(path); return error; }","- separator = strchr(connection->buffer, '=');
+ separator = osStrchr(connection->buffer, '=');","error_t ssiProcessIncludeCommand(HttpConnection *connection, const char_t *tag, size_t length, const char_t *uri, uint_t level) { error_t error; char_t *separator; char_t *attribute; char_t *value; char_t *path; char_t *p; if(length < 7 || length >= HTTP_SERVER_BUFFER_SIZE) return ERROR_INVALID_TAG; osMemcpy(connection->buffer, tag + 7, length - 7); connection->buffer[length - 7] = '\0'; separator = osStrchr(connection->buffer, '='); if(!separator) return ERROR_INVALID_TAG; *separator = '\0'; attribute = strTrimWhitespace(connection->buffer); value = strTrimWhitespace(separator + 1); if(value[0] == '\'' || value[0] == '\""') value++; length = osStrlen(value); if(length > 0) { if(value[length - 1] == '\'' || value[length - 1] == '\""') value[length - 1] = '\0'; } if(osStrlen(value) > HTTP_SERVER_URI_MAX_LEN) return ERROR_INVALID_TAG; if(!osStrcasecmp(attribute, ""file"")) { path = osAllocMem(osStrlen(uri) + osStrlen(value) + 1); if(path == NULL) return ERROR_OUT_OF_MEMORY; osStrcpy(path, uri); p = strrchr(path, '/'); if(p) osStrcpy(p + 1, value); else osStrcpy(path, value); } else if(!osStrcasecmp(attribute, ""virtual"")) { path = strDuplicate(value); if(path == NULL) return ERROR_OUT_OF_MEMORY; } else { return ERROR_INVALID_TAG; } if(httpCompExtension(value, "".stm"") || httpCompExtension(value, "".shtm"") || httpCompExtension(value, "".shtml"")) { error = ssiExecuteScript(connection, path, level + 1); } else { #if (HTTP_SERVER_FS_SUPPORT == ENABLED) FsFile *file; httpGetAbsolutePath(connection, path, connection->buffer, HTTP_SERVER_BUFFER_SIZE); file = fsOpenFile(connection->buffer, FS_FILE_MODE_READ); if(file) { while(1) { error = fsReadFile(file, connection->buffer, HTTP_SERVER_BUFFER_SIZE, &length); if(error) break; error = httpWriteStream(connection, connection->buffer, length); if(error) break; } fsCloseFile(file); if(error == ERROR_END_OF_FILE) error = NO_ERROR; } else { error = ERROR_NOT_FOUND; } #else const uint8_t *data; httpGetAbsolutePath(connection, path, connection->buffer, HTTP_SERVER_BUFFER_SIZE); error = resGetData(connection->buffer, &data, &length); if(!error) error = httpWriteStream(connection, data, length); #endif } if(error == ERROR_NOT_FOUND) error = ERROR_INVALID_TAG; osFreeMem(path); return error; }"
883,5864----CWE-273----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/glob.c----glob_vector,"glob_vector (pat, dir, flags) char *pat; char *dir; int flags; { DIR *d; register struct dirent *dp; struct globval *lastlink, *e, *dirlist; register struct globval *nextlink; register char *nextname, *npat, *subdir; unsigned int count; int lose, skip, ndirs, isdir, sdlen, add_current, patlen; register char **name_vector; register unsigned int i; int mflags; int pflags; int nalloca; struct globval *firstmalloc, *tmplink; char *convfn; lastlink = 0; count = lose = skip = add_current = 0; firstmalloc = 0; nalloca = 0; name_vector = NULL; if (pat == 0 || *pat == '\0') { if (glob_testdir (dir, 0) < 0) return ((char **) &glob_error_return); nextlink = (struct globval *)alloca (sizeof (struct globval)); if (nextlink == NULL) return ((char **) NULL); nextlink->next = (struct globval *)0; nextname = (char *) malloc (1); if (nextname == 0) lose = 1; else { lastlink = nextlink; nextlink->name = nextname; nextname[0] = '\0'; count = 1; } skip = 1; } patlen = (pat && *pat) ? strlen (pat) : 0; <S2SV_StartVul> if (skip == 0 && glob_pattern_p (pat) == 0) <S2SV_EndVul> { int dirlen; struct stat finfo; if (glob_testdir (dir, 0) < 0) return ((char **) &glob_error_return); dirlen = strlen (dir); nextname = (char *)malloc (dirlen + patlen + 2); npat = (char *)malloc (patlen + 1); if (nextname == 0 || npat == 0) { FREE (nextname); FREE (npat); lose = 1; } else { strcpy (npat, pat); dequote_pathname (npat); strcpy (nextname, dir); nextname[dirlen++] = '/'; strcpy (nextname + dirlen, npat); if (GLOB_TESTNAME (nextname) >= 0) { free (nextname); nextlink = (struct globval *)alloca (sizeof (struct globval)); if (nextlink) { nextlink->next = (struct globval *)0; lastlink = nextlink; nextlink->name = npat; count = 1; } else { free (npat); lose = 1; } } else { free (nextname); free (npat); } } skip = 1; } if (skip == 0) { #if defined (OPENDIR_NOT_ROBUST) if (glob_testdir (dir, 0) < 0) return ((char **) &glob_error_return); #endif d = opendir (dir); if (d == NULL) return ((char **) &glob_error_return); mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME; #ifdef FNM_CASEFOLD if (glob_ignore_case) mflags |= FNM_CASEFOLD; #endif if (extended_glob) mflags |= FNM_EXTMATCH; add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR)); while (1) { if (interrupt_state || terminating_signal) { lose = 1; break; } else if (signal_is_pending (SIGINT)) { lose = 1; break; } dp = readdir (d); if (dp == NULL) break; if (REAL_DIR_ENTRY (dp) == 0) continue; #if 0 if (dp->d_name == 0 || *dp->d_name == 0) continue; #endif #if HANDLE_MULTIBYTE if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags)) continue; else #endif if (skipname (pat, dp->d_name, flags)) continue; if (flags & (GX_MATCHDIRS|GX_ALLDIRS)) { pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0; if (flags & GX_NULLDIR) pflags |= MP_IGNDOT; subdir = sh_makepath (dir, dp->d_name, pflags); isdir = glob_testdir (subdir, flags); if (isdir < 0 && (flags & GX_MATCHDIRS)) { free (subdir); continue; } } if (flags & GX_ALLDIRS) { if (isdir == 0) { dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs); if (dirlist == &finddirs_error_return) { free (subdir); lose = 1; break; } if (ndirs) { if (firstmalloc == 0) firstmalloc = e; e->next = lastlink; lastlink = dirlist; count += ndirs; } } nextlink = (struct globval *) malloc (sizeof (struct globval)); if (firstmalloc == 0) firstmalloc = nextlink; sdlen = strlen (subdir); nextname = (char *) malloc (sdlen + 1); if (nextlink == 0 || nextname == 0) { FREE (nextlink); FREE (nextname); free (subdir); lose = 1; break; } nextlink->next = lastlink; lastlink = nextlink; nextlink->name = nextname; bcopy (subdir, nextname, sdlen + 1); free (subdir); ++count; continue; } else if (flags & GX_MATCHDIRS) free (subdir); convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp)); if (strmatch (pat, convfn, mflags) != FNM_NOMATCH) { if (nalloca < ALLOCA_MAX) { nextlink = (struct globval *) alloca (sizeof (struct globval)); nalloca += sizeof (struct globval); } else { nextlink = (struct globval *) malloc (sizeof (struct globval)); if (firstmalloc == 0) firstmalloc = nextlink; } nextname = (char *) malloc (D_NAMLEN (dp) + 1); if (nextlink == 0 || nextname == 0) { FREE (nextlink); FREE (nextname); lose = 1; break; } nextlink->next = lastlink; lastlink = nextlink; nextlink->name = nextname; bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1); ++count; } } (void) closedir (d); } if (add_current) { sdlen = strlen (dir); nextname = (char *)malloc (sdlen + 1); nextlink = (struct globval *) malloc (sizeof (struct globval)); if (nextlink == 0 || nextname == 0) { FREE (nextlink); FREE (nextname); lose = 1; } else { nextlink->name = nextname; nextlink->next = lastlink; lastlink = nextlink; if (flags & GX_NULLDIR) nextname[0] = '\0'; else bcopy (dir, nextname, sdlen + 1); ++count; } } if (lose == 0) { name_vector = (char **) malloc ((count + 1) * sizeof (char *)); lose |= name_vector == NULL; } if (lose) { tmplink = 0; while (lastlink) { if (firstmalloc) { if (lastlink == firstmalloc) firstmalloc = 0; tmplink = lastlink; } else tmplink = 0; free (lastlink->name); lastlink = lastlink->next; FREE (tmplink); } return ((char **)NULL); } for (tmplink = lastlink, i = 0; i < count; ++i) { name_vector[i] = tmplink->name; tmplink = tmplink->next; } name_vector[count] = NULL; if (firstmalloc) { tmplink = 0; while (lastlink) { tmplink = lastlink; if (lastlink == firstmalloc) lastlink = firstmalloc = 0; else lastlink = lastlink->next; free (tmplink); } } return (name_vector); }","- if (skip == 0 && glob_pattern_p (pat) == 0)
+ or contains a pattern with only backslash escapes (hasglob == 2),
+ hasglob = 0;
+ if (skip == 0 && (hasglob = glob_pattern_p (pat)) == 0 || hasglob == 2)","glob_vector (pat, dir, flags) char *pat; char *dir; int flags; { DIR *d; register struct dirent *dp; struct globval *lastlink, *e, *dirlist; register struct globval *nextlink; register char *nextname, *npat, *subdir; unsigned int count; int lose, skip, ndirs, isdir, sdlen, add_current, patlen; register char **name_vector; register unsigned int i; int mflags; int pflags; int hasglob; int nalloca; struct globval *firstmalloc, *tmplink; char *convfn; lastlink = 0; count = lose = skip = add_current = 0; firstmalloc = 0; nalloca = 0; name_vector = NULL; if (pat == 0 || *pat == '\0') { if (glob_testdir (dir, 0) < 0) return ((char **) &glob_error_return); nextlink = (struct globval *)alloca (sizeof (struct globval)); if (nextlink == NULL) return ((char **) NULL); nextlink->next = (struct globval *)0; nextname = (char *) malloc (1); if (nextname == 0) lose = 1; else { lastlink = nextlink; nextlink->name = nextname; nextname[0] = '\0'; count = 1; } skip = 1; } patlen = (pat && *pat) ? strlen (pat) : 0; hasglob = 0; if (skip == 0 && (hasglob = glob_pattern_p (pat)) == 0 || hasglob == 2) { int dirlen; struct stat finfo; if (glob_testdir (dir, 0) < 0) return ((char **) &glob_error_return); dirlen = strlen (dir); nextname = (char *)malloc (dirlen + patlen + 2); npat = (char *)malloc (patlen + 1); if (nextname == 0 || npat == 0) { FREE (nextname); FREE (npat); lose = 1; } else { strcpy (npat, pat); dequote_pathname (npat); strcpy (nextname, dir); nextname[dirlen++] = '/'; strcpy (nextname + dirlen, npat); if (GLOB_TESTNAME (nextname) >= 0) { free (nextname); nextlink = (struct globval *)alloca (sizeof (struct globval)); if (nextlink) { nextlink->next = (struct globval *)0; lastlink = nextlink; nextlink->name = npat; count = 1; } else { free (npat); lose = 1; } } else { free (nextname); free (npat); } } skip = 1; } if (skip == 0) { #if defined (OPENDIR_NOT_ROBUST) if (glob_testdir (dir, 0) < 0) return ((char **) &glob_error_return); #endif d = opendir (dir); if (d == NULL) return ((char **) &glob_error_return); mflags = (noglob_dot_filenames ? FNM_PERIOD : 0) | FNM_PATHNAME; #ifdef FNM_CASEFOLD if (glob_ignore_case) mflags |= FNM_CASEFOLD; #endif if (extended_glob) mflags |= FNM_EXTMATCH; add_current = ((flags & (GX_ALLDIRS|GX_ADDCURDIR)) == (GX_ALLDIRS|GX_ADDCURDIR)); while (1) { if (interrupt_state || terminating_signal) { lose = 1; break; } else if (signal_is_pending (SIGINT)) { lose = 1; break; } dp = readdir (d); if (dp == NULL) break; if (REAL_DIR_ENTRY (dp) == 0) continue; #if 0 if (dp->d_name == 0 || *dp->d_name == 0) continue; #endif #if HANDLE_MULTIBYTE if (MB_CUR_MAX > 1 && mbskipname (pat, dp->d_name, flags)) continue; else #endif if (skipname (pat, dp->d_name, flags)) continue; if (flags & (GX_MATCHDIRS|GX_ALLDIRS)) { pflags = (flags & GX_ALLDIRS) ? MP_RMDOT : 0; if (flags & GX_NULLDIR) pflags |= MP_IGNDOT; subdir = sh_makepath (dir, dp->d_name, pflags); isdir = glob_testdir (subdir, flags); if (isdir < 0 && (flags & GX_MATCHDIRS)) { free (subdir); continue; } } if (flags & GX_ALLDIRS) { if (isdir == 0) { dirlist = finddirs (pat, subdir, (flags & ~GX_ADDCURDIR), &e, &ndirs); if (dirlist == &finddirs_error_return) { free (subdir); lose = 1; break; } if (ndirs) { if (firstmalloc == 0) firstmalloc = e; e->next = lastlink; lastlink = dirlist; count += ndirs; } } nextlink = (struct globval *) malloc (sizeof (struct globval)); if (firstmalloc == 0) firstmalloc = nextlink; sdlen = strlen (subdir); nextname = (char *) malloc (sdlen + 1); if (nextlink == 0 || nextname == 0) { FREE (nextlink); FREE (nextname); free (subdir); lose = 1; break; } nextlink->next = lastlink; lastlink = nextlink; nextlink->name = nextname; bcopy (subdir, nextname, sdlen + 1); free (subdir); ++count; continue; } else if (flags & GX_MATCHDIRS) free (subdir); convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp)); if (strmatch (pat, convfn, mflags) != FNM_NOMATCH) { if (nalloca < ALLOCA_MAX) { nextlink = (struct globval *) alloca (sizeof (struct globval)); nalloca += sizeof (struct globval); } else { nextlink = (struct globval *) malloc (sizeof (struct globval)); if (firstmalloc == 0) firstmalloc = nextlink; } nextname = (char *) malloc (D_NAMLEN (dp) + 1); if (nextlink == 0 || nextname == 0) { FREE (nextlink); FREE (nextname); lose = 1; break; } nextlink->next = lastlink; lastlink = nextlink; nextlink->name = nextname; bcopy (dp->d_name, nextname, D_NAMLEN (dp) + 1); ++count; } } (void) closedir (d); } if (add_current) { sdlen = strlen (dir); nextname = (char *)malloc (sdlen + 1); nextlink = (struct globval *) malloc (sizeof (struct globval)); if (nextlink == 0 || nextname == 0) { FREE (nextlink); FREE (nextname); lose = 1; } else { nextlink->name = nextname; nextlink->next = lastlink; lastlink = nextlink; if (flags & GX_NULLDIR) nextname[0] = '\0'; else bcopy (dir, nextname, sdlen + 1); ++count; } } if (lose == 0) { name_vector = (char **) malloc ((count + 1) * sizeof (char *)); lose |= name_vector == NULL; } if (lose) { tmplink = 0; while (lastlink) { if (firstmalloc) { if (lastlink == firstmalloc) firstmalloc = 0; tmplink = lastlink; } else tmplink = 0; free (lastlink->name); lastlink = lastlink->next; FREE (tmplink); } return ((char **)NULL); } for (tmplink = lastlink, i = 0; i < count; ++i) { name_vector[i] = tmplink->name; tmplink = tmplink->next; } name_vector[count] = NULL; if (firstmalloc) { tmplink = 0; while (lastlink) { tmplink = lastlink; if (lastlink == firstmalloc) lastlink = firstmalloc = 0; else lastlink = lastlink->next; free (tmplink); } } return (name_vector); }"
884,5704----CWE-200----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ecdsa.cpp----Botan::ECDSA_Signature_Operation::ECDSA_Signature_Operation,"ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa, <S2SV_StartVul> const std::string& emsa) : <S2SV_EndVul> PK_Ops::Signature_with_EMSA(emsa), m_group(ecdsa.domain()), m_x(ecdsa.private_value()) { #if defined(BOTAN_HAS_RFC6979_GENERATOR) m_rfc6979_hash = hash_for_emsa(emsa); #endif }","- const std::string& emsa) :
+ const std::string& emsa,
+ RandomNumberGenerator& rng) :
+ m_b = m_group.random_scalar(rng);
+ m_b_inv = m_group.inverse_mod_order(m_b);","ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa, const std::string& emsa, RandomNumberGenerator& rng) : PK_Ops::Signature_with_EMSA(emsa), m_group(ecdsa.domain()), m_x(ecdsa.private_value()) { #if defined(BOTAN_HAS_RFC6979_GENERATOR) m_rfc6979_hash = hash_for_emsa(emsa); #endif m_b = m_group.random_scalar(rng); m_b_inv = m_group.inverse_mod_order(m_b); }"
885,3189----CWE-362----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inet_connection_sock.c----inet_csk_route_req,"struct dst_entry *inet_csk_route_req(struct sock *sk, const struct request_sock *req) { struct rtable *rt; const struct inet_request_sock *ireq = inet_rsk(req); <S2SV_StartVul> struct ip_options *opt = inet_rsk(req)->opt; <S2SV_EndVul> struct net *net = sock_net(sk); struct flowi4 fl4; flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark, RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, sk->sk_protocol, inet_sk_flowi_flags(sk), <S2SV_StartVul> (opt && opt->srr) ? opt->faddr : ireq->rmt_addr, <S2SV_EndVul> ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport); security_req_classify_flow(req, flowi4_to_flowi(&fl4)); rt = ip_route_output_flow(net, &fl4, sk); if (IS_ERR(rt)) goto no_route; <S2SV_StartVul> if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway) <S2SV_EndVul> goto route_err; return &rt->dst; route_err: ip_rt_put(rt); no_route: IP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES); return NULL; }","- struct ip_options *opt = inet_rsk(req)->opt;
- (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,
- if (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)
+ struct ip_options_rcu *opt = inet_rsk(req)->opt;
+ (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,
+ if (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)","struct dst_entry *inet_csk_route_req(struct sock *sk, const struct request_sock *req) { struct rtable *rt; const struct inet_request_sock *ireq = inet_rsk(req); struct ip_options_rcu *opt = inet_rsk(req)->opt; struct net *net = sock_net(sk); struct flowi4 fl4; flowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark, RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, sk->sk_protocol, inet_sk_flowi_flags(sk), (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr, ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport); security_req_classify_flow(req, flowi4_to_flowi(&fl4)); rt = ip_route_output_flow(net, &fl4, sk); if (IS_ERR(rt)) goto no_route; if (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway) goto route_err; return &rt->dst; route_err: ip_rt_put(rt); no_route: IP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES); return NULL; }"
886,2574----CWE-59----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7500--fsm.c----fsmVerify,"<S2SV_StartVul> static int fsmVerify(const char *path, rpmfi fi) <S2SV_EndVul> { int rc; int saveerrno = errno; struct stat dsb; mode_t mode = rpmfiFMode(fi); rc = fsmStat(path, 1, &dsb); if (rc) return rc; if (S_ISREG(mode)) { char *rmpath = rstrscat(NULL, path, ""-RPMDELETE"", NULL); rc = fsmRename(path, rmpath); if (!rc) (void) fsmUnlink(rmpath); else rc = RPMERR_UNLINK_FAILED; free(rmpath); return (rc ? rc : RPMERR_ENOENT); } else if (S_ISDIR(mode)) { if (S_ISDIR(dsb.st_mode)) return 0; if (S_ISLNK(dsb.st_mode)) { rc = fsmStat(path, 0, &dsb); if (rc == RPMERR_ENOENT) rc = 0; if (rc) return rc; errno = saveerrno; <S2SV_StartVul> if (S_ISDIR(dsb.st_mode)) return 0; <S2SV_EndVul> } } else if (S_ISLNK(mode)) { if (S_ISLNK(dsb.st_mode)) { char buf[8 * BUFSIZ]; size_t len; rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len); errno = saveerrno; if (rc) return rc; if (rstreq(rpmfiFLink(fi), buf)) return 0; } } else if (S_ISFIFO(mode)) { if (S_ISFIFO(dsb.st_mode)) return 0; } else if (S_ISCHR(mode) || S_ISBLK(mode)) { if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) && (dsb.st_rdev == rpmfiFRdev(fi))) return 0; } else if (S_ISSOCK(mode)) { if (S_ISSOCK(dsb.st_mode)) return 0; } rc = fsmUnlink(path); if (rc == 0) rc = RPMERR_ENOENT; return (rc ? rc : RPMERR_ENOENT); }","- static int fsmVerify(const char *path, rpmfi fi)
- if (S_ISDIR(dsb.st_mode)) return 0;
+ static int fsmVerify(const char *path, rpmfi fi)
+ if (S_ISLNK(dsb.st_mode)) {
+ if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))","static int fsmVerify(const char *path, rpmfi fi) static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb) { int rc; int saveerrno = errno; struct stat dsb; mode_t mode = rpmfiFMode(fi); rc = fsmStat(path, 1, &dsb); if (rc) return rc; if (S_ISREG(mode)) { char *rmpath = rstrscat(NULL, path, ""-RPMDELETE"", NULL); rc = fsmRename(path, rmpath); if (!rc) (void) fsmUnlink(rmpath); else rc = RPMERR_UNLINK_FAILED; free(rmpath); return (rc ? rc : RPMERR_ENOENT); } else if (S_ISDIR(mode)) { if (S_ISDIR(dsb.st_mode)) return 0; if (S_ISLNK(dsb.st_mode)) { uid_t luid = dsb.st_uid; rc = fsmStat(path, 0, &dsb); if (rc == RPMERR_ENOENT) rc = 0; if (rc) return rc; errno = saveerrno; if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid)) return 0; } } else if (S_ISLNK(mode)) { if (S_ISLNK(dsb.st_mode)) { char buf[8 * BUFSIZ]; size_t len; rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len); errno = saveerrno; if (rc) return rc; if (rstreq(rpmfiFLink(fi), buf)) return 0; } } else if (S_ISFIFO(mode)) { if (S_ISFIFO(dsb.st_mode)) return 0; } else if (S_ISCHR(mode) || S_ISBLK(mode)) { if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) && (dsb.st_rdev == rpmfiFRdev(fi))) return 0; } else if (S_ISSOCK(mode)) { if (S_ISSOCK(dsb.st_mode)) return 0; } rc = fsmUnlink(path); if (rc == 0) rc = RPMERR_ENOENT; return (rc ? rc : RPMERR_ENOENT); }"
887,3152----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/snmp-ber.c----snmp_ber_encode_integer,"<S2SV_StartVul> snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> uint32_t original_out_len; <S2SV_EndVul> <S2SV_StartVul> original_out_len = *out_len; <S2SV_EndVul> do { <S2SV_StartVul> (*out_len)++; <S2SV_EndVul> <S2SV_StartVul> *out-- = (uint8_t)(number & 0xFF); <S2SV_EndVul> number >>= 8; } while(number); <S2SV_StartVul> out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF)); <S2SV_EndVul> <S2SV_StartVul> out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER); <S2SV_EndVul> <S2SV_StartVul> return out; <S2SV_EndVul> }","- snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)
- {
- uint32_t original_out_len;
- original_out_len = *out_len;
- (*out_len)++;
- out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));
- out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);
- return out;
+ snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t number)
+ {
+ return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, number);","snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t number) { return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, number); }"
888,6505----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/print-juniper.c----juniper_atm2_print,"juniper_atm2_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { int llc_hdrlen; struct juniper_l2info_t l2info; l2info.pictype = DLT_JUNIPER_ATM2; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC); return l2info.header_len; } if (EXTRACT_24BITS(p) == 0xfefe03 || EXTRACT_24BITS(p) == 0xaaaa03) { llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL); if (llc_hdrlen > 0) return l2info.header_len; } if (l2info.direction != JUNIPER_BPF_PKT_IN && (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) { ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL); return l2info.header_len; } if (p[0] == 0x03) { <S2SV_StartVul> isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1); <S2SV_EndVul> return l2info.header_len; } if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) return l2info.header_len; if (ip_heuristic_guess(ndo, p, l2info.length) != 0) return l2info.header_len; return l2info.header_len; }","- isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);
+ isoclns_print(ndo, p + 1, l2info.length - 1);","juniper_atm2_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { int llc_hdrlen; struct juniper_l2info_t l2info; l2info.pictype = DLT_JUNIPER_ATM2; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC); return l2info.header_len; } if (EXTRACT_24BITS(p) == 0xfefe03 || EXTRACT_24BITS(p) == 0xaaaa03) { llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL); if (llc_hdrlen > 0) return l2info.header_len; } if (l2info.direction != JUNIPER_BPF_PKT_IN && (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) { ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL); return l2info.header_len; } if (p[0] == 0x03) { isoclns_print(ndo, p + 1, l2info.length - 1); return l2info.header_len; } if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) return l2info.header_len; if (ip_heuristic_guess(ndo, p, l2info.length) != 0) return l2info.header_len; return l2info.header_len; }"
889,4595----CWE-310----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/test_memory_funcs.c----my_malloc,static void *my_malloc(size_t size) { <S2SV_StartVul> malloc_called += 1; <S2SV_EndVul> return malloc(size); },"- malloc_called += 1;
+ malloc_called = 1;",static void *my_malloc(size_t size) { malloc_called = 1; return malloc(size); }
890,3392----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/huffman.c----Huff_offsetTransmit,"<S2SV_StartVul> void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) { <S2SV_EndVul> bloc = *offset; <S2SV_StartVul> send(huff->loc[ch], NULL, fout); <S2SV_EndVul> *offset = bloc; }","- void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
- send(huff->loc[ch], NULL, fout);
+ void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) {
+ send(huff->loc[ch], NULL, fout, maxoffset);","void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) { bloc = *offset; send(huff->loc[ch], NULL, fout, maxoffset); *offset = bloc; }"
891,4630----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/inode.c----ext4_free_io_end,<S2SV_StartVul> static void ext4_free_io_end(ext4_io_end_t *io) <S2SV_EndVul> <S2SV_StartVul> { <S2SV_EndVul> <S2SV_StartVul> BUG_ON(!io); <S2SV_EndVul> <S2SV_StartVul> iput(io->inode); <S2SV_EndVul> <S2SV_StartVul> kfree(io); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul>,"- static void ext4_free_io_end(ext4_io_end_t *io)
- {
- BUG_ON(!io);
- iput(io->inode);
- kfree(io);
- }
+ static void ext4_free_io_end(ext4_io_end_t *io)
+ {
+ BUG_ON(!io);
+ if (io->page)
+ put_page(io->page);
+ iput(io->inode);
+ kfree(io);
+ }",static void ext4_free_io_end(ext4_io_end_t *io) { BUG_ON(!io); if (io->page) put_page(io->page); iput(io->inode); kfree(io); }
892,6370----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/env.c----mongo_env_write_socket,"<S2SV_StartVul> int mongo_env_write_socket( mongo *conn, const void *buf, int len ) { <S2SV_EndVul> const char *cbuf = buf; int flags = 0; while ( len ) { <S2SV_StartVul> int sent = send( conn->sock, cbuf, len, flags ); <S2SV_EndVul> if ( sent == -1 ) { __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() ); conn->connected = 0; return MONGO_ERROR; } cbuf += sent; len -= sent; } return MONGO_OK; }","- int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {
- int sent = send( conn->sock, cbuf, len, flags );
+ int mongo_env_write_socket( mongo *conn, const void *buf, size_t len ) {
+ size_t sent = send( conn->sock, cbuf, len, flags );","int mongo_env_write_socket( mongo *conn, const void *buf, size_t len ) { const char *cbuf = buf; int flags = 0; while ( len ) { size_t sent = send( conn->sock, cbuf, len, flags ); if ( sent == -1 ) { __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() ); conn->connected = 0; return MONGO_ERROR; } cbuf += sent; len -= sent; } return MONGO_OK; }"
893,7066----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mmap.c----stack_maxrandom_size,<S2SV_StartVul> static unsigned int stack_maxrandom_size(void) <S2SV_EndVul> { <S2SV_StartVul> unsigned int max = 0; <S2SV_EndVul> if ((current->flags & PF_RANDOMIZE) && !(current->personality & ADDR_NO_RANDOMIZE)) { <S2SV_StartVul> max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT; <S2SV_EndVul> } return max; },"- static unsigned int stack_maxrandom_size(void)
- unsigned int max = 0;
- max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
+ static unsigned long stack_maxrandom_size(void)
+ unsigned long max = 0;
+ max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;",static unsigned long stack_maxrandom_size(void) { unsigned long max = 0; if ((current->flags & PF_RANDOMIZE) && !(current->personality & ADDR_NO_RANDOMIZE)) { max = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT; } return max; }
894,3034----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/secure_enclave.c----trustedEncryptKeyAES,"void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key, <S2SV_StartVul> uint8_t *encryptedPrivateKey, uint32_t *enc_len) { <S2SV_EndVul> LOG_INFO(__FUNCTION__); *errString = 0; *errStatus = UNKNOWN_ERROR; CHECK_STATE(key); CHECK_STATE(encryptedPrivateKey); *errStatus = UNKNOWN_ERROR; <S2SV_StartVul> int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN); <S2SV_EndVul> CHECK_STATUS2(""AES encrypt failed with status %d""); <S2SV_StartVul> *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE; <S2SV_EndVul> SAFE_CHAR_BUF(decryptedKey, BUF_LEN); <S2SV_StartVul> status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN); <S2SV_EndVul> CHECK_STATUS2(""trustedDecryptKey failed with status %d""); uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH); if (decryptedKeyLen == MAX_KEY_LENGTH) { snprintf(errString, BUF_LEN, ""Decrypted key is not null terminated""); LOG_ERROR(errString); goto clean; } *errStatus = -8; if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) { snprintf(errString, BUF_LEN, ""Decrypted key does not match original key""); LOG_ERROR(errString); goto clean; } SET_SUCCESS clean: ; LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }","- uint8_t *encryptedPrivateKey, uint32_t *enc_len) {
- int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);
- status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);
+ uint8_t *encryptedPrivateKey, uint64_t *enc_len) {
+ int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,
+ DKG, DECRYPTABLE, enc_len);
+ status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);
+ LOG_ERROR(key);
+ LOG_ERROR(decryptedKey);","void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key, uint8_t *encryptedPrivateKey, uint64_t *enc_len) { LOG_INFO(__FUNCTION__); *errString = 0; *errStatus = UNKNOWN_ERROR; CHECK_STATE(key); CHECK_STATE(encryptedPrivateKey); *errStatus = UNKNOWN_ERROR; int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN, DKG, DECRYPTABLE, enc_len); CHECK_STATUS2(""AES encrypt failed with status %d""); SAFE_CHAR_BUF(decryptedKey, BUF_LEN); status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN); CHECK_STATUS2(""trustedDecryptKey failed with status %d""); uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH); if (decryptedKeyLen == MAX_KEY_LENGTH) { snprintf(errString, BUF_LEN, ""Decrypted key is not null terminated""); LOG_ERROR(errString); goto clean; } *errStatus = -8; if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) { snprintf(errString, BUF_LEN, ""Decrypted key does not match original key""); LOG_ERROR(key); LOG_ERROR(decryptedKey); LOG_ERROR(errString); goto clean; } SET_SUCCESS clean: ; LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }"
895,4714----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/context_umount.c----is_fuse_usermount,"static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv) { struct libmnt_ns *ns_old; const char *type = mnt_fs_get_fstype(cxt->fs); const char *optstr; <S2SV_StartVul> char *user_id = NULL; <S2SV_EndVul> <S2SV_StartVul> size_t sz; <S2SV_EndVul> <S2SV_StartVul> uid_t uid; <S2SV_EndVul> <S2SV_StartVul> char uidstr[sizeof(stringify_value(ULONG_MAX))]; <S2SV_EndVul> *errsv = 0; if (!type) return 0; if (strcmp(type, ""fuse"") != 0 && strcmp(type, ""fuseblk"") != 0 && strncmp(type, ""fuse."", 5) != 0 && strncmp(type, ""fuseblk."", 8) != 0) return 0; optstr = mnt_fs_get_fs_options(cxt->fs); if (!optstr) return 0; <S2SV_StartVul> if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0) <S2SV_EndVul> <S2SV_StartVul> return 0; <S2SV_EndVul> <S2SV_StartVul> if (sz == 0 || user_id == NULL) <S2SV_EndVul> return 0; ns_old = mnt_context_switch_origin_ns(cxt); if (!ns_old) { *errsv = -MNT_ERR_NAMESPACE; return 0; } uid = getuid(); if (!mnt_context_switch_ns(cxt, ns_old)) { *errsv = -MNT_ERR_NAMESPACE; return 0; } <S2SV_StartVul> snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid); <S2SV_EndVul> <S2SV_StartVul> return strncmp(user_id, uidstr, sz) == 0; <S2SV_EndVul> }","- char *user_id = NULL;
- size_t sz;
- uid_t uid;
- char uidstr[sizeof(stringify_value(ULONG_MAX))];
- if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
- return 0;
- if (sz == 0 || user_id == NULL)
- snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
- return strncmp(user_id, uidstr, sz) == 0;
+ uid_t uid, entry_uid;
+ if (mnt_optstr_get_uid(optstr, ""user_id"", &entry_uid) != 0)
+ return uid == entry_uid;","static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv) { struct libmnt_ns *ns_old; const char *type = mnt_fs_get_fstype(cxt->fs); const char *optstr; uid_t uid, entry_uid; *errsv = 0; if (!type) return 0; if (strcmp(type, ""fuse"") != 0 && strcmp(type, ""fuseblk"") != 0 && strncmp(type, ""fuse."", 5) != 0 && strncmp(type, ""fuseblk."", 8) != 0) return 0; optstr = mnt_fs_get_fs_options(cxt->fs); if (!optstr) return 0; if (mnt_optstr_get_uid(optstr, ""user_id"", &entry_uid) != 0) return 0; ns_old = mnt_context_switch_origin_ns(cxt); if (!ns_old) { *errsv = -MNT_ERR_NAMESPACE; return 0; } uid = getuid(); if (!mnt_context_switch_ns(cxt, ns_old)) { *errsv = -MNT_ERR_NAMESPACE; return 0; } return uid == entry_uid; }"
896,595----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-9140--print-ppp.c----ppp_hdlc,"ppp_hdlc(netdissect_options *ndo, const u_char *p, int length) { <S2SV_StartVul> u_char *b, *s, *t, c; <S2SV_EndVul> int i, proto; const void *se; if (length <= 0) return; <S2SV_StartVul> b = (uint8_t *)malloc(length); <S2SV_EndVul> if (b == NULL) return; <S2SV_StartVul> for (s = (u_char *)p, t = b, i = length; i > 0; i--) { <S2SV_EndVul> c = *s++; if (c == 0x7d) { <S2SV_StartVul> if (i > 1) { <S2SV_EndVul> <S2SV_StartVul> i--; <S2SV_EndVul> <S2SV_StartVul> c = *s++ ^ 0x20; <S2SV_EndVul> <S2SV_StartVul> } else <S2SV_EndVul> <S2SV_StartVul> continue; <S2SV_EndVul> } *t++ = c; } se = ndo->ndo_snapend; ndo->ndo_snapend = t; length = t - b; if (length < 1) goto trunc; proto = *b; switch (proto) { case PPP_IP: ip_print(ndo, b + 1, length - 1); goto cleanup; case PPP_IPV6: ip6_print(ndo, b + 1, length - 1); goto cleanup; default: break; } if (length < 2) goto trunc; proto = EXTRACT_16BITS(b); switch (proto) { case (PPP_ADDRESS << 8 | PPP_CONTROL): if (length < 4) goto trunc; proto = EXTRACT_16BITS(b+2); handle_ppp(ndo, proto, b + 4, length - 4); break; default: handle_ppp(ndo, proto, b + 2, length - 2); break; } cleanup: ndo->ndo_snapend = se; free(b); return; trunc: ndo->ndo_snapend = se; free(b); ND_PRINT((ndo, ""[|ppp]"")); }","- u_char *b, *s, *t, c;
- b = (uint8_t *)malloc(length);
- for (s = (u_char *)p, t = b, i = length; i > 0; i--) {
- if (i > 1) {
- i--;
- c = *s++ ^ 0x20;
- } else
- continue;
+ u_char *b, *t, c;
+ const u_char *s;
+ b = (u_char *)malloc(length);
+ for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {
+ if (i <= 1 || !ND_TTEST(*s))
+ break;
+ i--;
+ c = *s++ ^ 0x20;","ppp_hdlc(netdissect_options *ndo, const u_char *p, int length) { u_char *b, *t, c; const u_char *s; int i, proto; const void *se; if (length <= 0) return; b = (u_char *)malloc(length); if (b == NULL) return; for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) { c = *s++; if (c == 0x7d) { if (i <= 1 || !ND_TTEST(*s)) break; i--; c = *s++ ^ 0x20; } *t++ = c; } se = ndo->ndo_snapend; ndo->ndo_snapend = t; length = t - b; if (length < 1) goto trunc; proto = *b; switch (proto) { case PPP_IP: ip_print(ndo, b + 1, length - 1); goto cleanup; case PPP_IPV6: ip6_print(ndo, b + 1, length - 1); goto cleanup; default: break; } if (length < 2) goto trunc; proto = EXTRACT_16BITS(b); switch (proto) { case (PPP_ADDRESS << 8 | PPP_CONTROL): if (length < 4) goto trunc; proto = EXTRACT_16BITS(b+2); handle_ppp(ndo, proto, b + 4, length - 4); break; default: handle_ppp(ndo, proto, b + 2, length - 2); break; } cleanup: ndo->ndo_snapend = se; free(b); return; trunc: ndo->ndo_snapend = se; free(b); ND_PRINT((ndo, ""[|ppp]"")); }"
897,809----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-4001--ozhcd.c----oz_hcd_get_desc_cnf,"<S2SV_StartVul> void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc, <S2SV_EndVul> <S2SV_StartVul> int length, int offset, int total_size) <S2SV_EndVul> { struct oz_port *port = hport; struct urb *urb; int err = 0; oz_dbg(ON, ""oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\n"", length, offset, total_size); urb = oz_find_urb_by_id(port, 0, req_id); if (!urb) return; if (status == 0) { <S2SV_StartVul> int copy_len; <S2SV_EndVul> <S2SV_StartVul> int required_size = urb->transfer_buffer_length; <S2SV_EndVul> if (required_size > total_size) required_size = total_size; copy_len = required_size-offset; if (length <= copy_len) copy_len = length; memcpy(urb->transfer_buffer+offset, desc, copy_len); offset += copy_len; if (offset < required_size) { struct usb_ctrlrequest *setup = (struct usb_ctrlrequest *)urb->setup_packet; unsigned wvalue = le16_to_cpu(setup->wValue); if (oz_enqueue_ep_urb(port, 0, 0, urb, req_id)) err = -ENOMEM; else if (oz_usb_get_desc_req(port->hpd, req_id, setup->bRequestType, (u8)(wvalue>>8), (u8)wvalue, setup->wIndex, offset, required_size-offset)) { oz_dequeue_ep_urb(port, 0, 0, urb); err = -ENOMEM; } if (err == 0) return; } } urb->actual_length = total_size; oz_complete_urb(port->ozhcd->hcd, urb, 0); }","- void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,
- int length, int offset, int total_size)
- int copy_len;
- int required_size = urb->transfer_buffer_length;
+ void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,
+ void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,
+ if (status == 0) {
+ unsigned int copy_len;","void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc, void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc, u8 length, u16 offset, u16 total_size) { struct oz_port *port = hport; struct urb *urb; int err = 0; oz_dbg(ON, ""oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\n"", length, offset, total_size); urb = oz_find_urb_by_id(port, 0, req_id); if (!urb) return; if (status == 0) { unsigned int copy_len; unsigned int required_size = urb->transfer_buffer_length; if (required_size > total_size) required_size = total_size; copy_len = required_size-offset; if (length <= copy_len) copy_len = length; memcpy(urb->transfer_buffer+offset, desc, copy_len); offset += copy_len; if (offset < required_size) { struct usb_ctrlrequest *setup = (struct usb_ctrlrequest *)urb->setup_packet; unsigned wvalue = le16_to_cpu(setup->wValue); if (oz_enqueue_ep_urb(port, 0, 0, urb, req_id)) err = -ENOMEM; else if (oz_usb_get_desc_req(port->hpd, req_id, setup->bRequestType, (u8)(wvalue>>8), (u8)wvalue, setup->wIndex, offset, required_size-offset)) { oz_dequeue_ep_urb(port, 0, 0, urb); err = -ENOMEM; } if (err == 0) return; } } urb->actual_length = total_size; oz_complete_urb(port->ozhcd->hcd, urb, 0); }"
898,3914----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/quantum-export.c----ExportRGBQuantum,"static void ExportRGBQuantum(QuantumInfo *quantum_info, const MagickSizeType number_pixels,const PixelPacket *magick_restrict p, unsigned char *magick_restrict q) { QuantumAny range; ssize_t x; ssize_t bit; switch (quantum_info->depth) { case 8: { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(p)),q); q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(p)),q); q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(p)),q); p++; q+=quantum_info->pad; } break; } case 10: { unsigned int pixel; range=GetQuantumRange(quantum_info->depth); if (quantum_info->pack == MagickFalse) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ( ScaleQuantumToAny(GetPixelRed(p),range) << 22 | ScaleQuantumToAny(GetPixelGreen(p),range) << 12 | ScaleQuantumToAny(GetPixelBlue(p),range) << 2); q=PopLongPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } if (quantum_info->quantum == 32UL) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } case 12: { unsigned int pixel; range=GetQuantumRange(quantum_info->depth); if (quantum_info->pack == MagickFalse) { for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2) { switch (x % 3) { default: case 0: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); break; } case 1: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); break; } case 2: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); p++; break; } } <S2SV_StartVul> q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q); <S2SV_EndVul> switch ((x+1) % 3) { default: case 0: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); break; } case 1: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); break; } case 2: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); p++; break; } } <S2SV_StartVul> q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q); <S2SV_EndVul> q+=quantum_info->pad; } for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++) { switch ((x+bit) % 3) { default: case 0: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); break; } case 1: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); break; } case 2: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); p++; break; } } <S2SV_StartVul> q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q); <S2SV_EndVul> q+=quantum_info->pad; } if (bit != 0) p++; break; } if (quantum_info->quantum == 32UL) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } case 16: { unsigned short pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToShort(GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToShort(GetPixelGreen(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToShort(GetPixelBlue(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 32: { unsigned int pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q); q=PopFloatPixel(quantum_info,(float) GetPixelGreen(p),q); q=PopFloatPixel(quantum_info,(float) GetPixelBlue(p),q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToLong(GetPixelRed(p)); q=PopLongPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToLong(GetPixelGreen(p)); q=PopLongPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToLong(GetPixelBlue(p)); q=PopLongPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 64: { if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q); q=PopDoublePixel(quantum_info,(double) GetPixelGreen(p),q); q=PopDoublePixel(quantum_info,(double) GetPixelBlue(p),q); p++; q+=quantum_info->pad; } break; } } default: { range=GetQuantumRange(quantum_info->depth); for (x=0; x < (ssize_t) number_pixels; x++) { q=PopQuantumPixel(quantum_info, ScaleQuantumToAny(GetPixelRed(p),range),q); q=PopQuantumPixel(quantum_info, ScaleQuantumToAny(GetPixelGreen(p),range),q); q=PopQuantumPixel(quantum_info, ScaleQuantumToAny(GetPixelBlue(p),range),q); p++; q+=quantum_info->pad; } break; } } }","- q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
- q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
- q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),q);
+ q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
+ q);
+ q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
+ q);
+ q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4),
+ q);","static void ExportRGBQuantum(QuantumInfo *quantum_info, const MagickSizeType number_pixels,const PixelPacket *magick_restrict p, unsigned char *magick_restrict q) { QuantumAny range; ssize_t x; ssize_t bit; switch (quantum_info->depth) { case 8: { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopCharPixel(ScaleQuantumToChar(GetPixelRed(p)),q); q=PopCharPixel(ScaleQuantumToChar(GetPixelGreen(p)),q); q=PopCharPixel(ScaleQuantumToChar(GetPixelBlue(p)),q); p++; q+=quantum_info->pad; } break; } case 10: { unsigned int pixel; range=GetQuantumRange(quantum_info->depth); if (quantum_info->pack == MagickFalse) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ( ScaleQuantumToAny(GetPixelRed(p),range) << 22 | ScaleQuantumToAny(GetPixelGreen(p),range) << 12 | ScaleQuantumToAny(GetPixelBlue(p),range) << 2); q=PopLongPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } if (quantum_info->quantum == 32UL) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } case 12: { unsigned int pixel; range=GetQuantumRange(quantum_info->depth); if (quantum_info->pack == MagickFalse) { for (x=0; x < (ssize_t) (3*number_pixels-1); x+=2) { switch (x % 3) { default: case 0: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); break; } case 1: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); break; } case 2: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); p++; break; } } q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4), q); switch ((x+1) % 3) { default: case 0: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); break; } case 1: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); break; } case 2: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); p++; break; } } q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4), q); q+=quantum_info->pad; } for (bit=0; bit < (ssize_t) (3*number_pixels % 2); bit++) { switch ((x+bit) % 3) { default: case 0: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); break; } case 1: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); break; } case 2: { pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); p++; break; } } q=PopShortPixel(quantum_info->endian,(unsigned short) (pixel << 4), q); q+=quantum_info->pad; } if (bit != 0) p++; break; } if (quantum_info->quantum == 32UL) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumLongPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=(unsigned int) ScaleQuantumToAny(GetPixelRed(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelGreen(p),range); q=PopQuantumPixel(quantum_info,pixel,q); pixel=(unsigned int) ScaleQuantumToAny(GetPixelBlue(p),range); q=PopQuantumPixel(quantum_info,pixel,q); p++; q+=quantum_info->pad; } break; } case 16: { unsigned short pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=SinglePrecisionToHalf(QuantumScale*GetPixelGreen(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=SinglePrecisionToHalf(QuantumScale*GetPixelBlue(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToShort(GetPixelRed(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToShort(GetPixelGreen(p)); q=PopShortPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToShort(GetPixelBlue(p)); q=PopShortPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 32: { unsigned int pixel; if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q); q=PopFloatPixel(quantum_info,(float) GetPixelGreen(p),q); q=PopFloatPixel(quantum_info,(float) GetPixelBlue(p),q); p++; q+=quantum_info->pad; } break; } for (x=0; x < (ssize_t) number_pixels; x++) { pixel=ScaleQuantumToLong(GetPixelRed(p)); q=PopLongPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToLong(GetPixelGreen(p)); q=PopLongPixel(quantum_info->endian,pixel,q); pixel=ScaleQuantumToLong(GetPixelBlue(p)); q=PopLongPixel(quantum_info->endian,pixel,q); p++; q+=quantum_info->pad; } break; } case 64: { if (quantum_info->format == FloatingPointQuantumFormat) { for (x=0; x < (ssize_t) number_pixels; x++) { q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q); q=PopDoublePixel(quantum_info,(double) GetPixelGreen(p),q); q=PopDoublePixel(quantum_info,(double) GetPixelBlue(p),q); p++; q+=quantum_info->pad; } break; } } default: { range=GetQuantumRange(quantum_info->depth); for (x=0; x < (ssize_t) number_pixels; x++) { q=PopQuantumPixel(quantum_info, ScaleQuantumToAny(GetPixelRed(p),range),q); q=PopQuantumPixel(quantum_info, ScaleQuantumToAny(GetPixelGreen(p),range),q); q=PopQuantumPixel(quantum_info, ScaleQuantumToAny(GetPixelBlue(p),range),q); p++; q+=quantum_info->pad; } break; } } }"
899,5499----CWE-22----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server.cc----webcc::Server::ServeStatic,"ResponsePtr Server::ServeStatic(RequestPtr request) { assert(request->method() == methods::kGet); if (doc_root_.empty()) { LOG_INFO(""The doc root was not specified""); return {}; } <S2SV_StartVul> fs::path path = doc_root_ / request->url().path(); <S2SV_EndVul> try { auto body = std::make_shared<FileBody>(path, file_chunk_size_); auto response = std::make_shared<Response>(Status::kOK); std::string extension = path.extension().string(); response->SetContentType(media_types::FromExtension(extension), """"); response->SetBody(body, true); return response; } catch (const Error& error) { LOG_ERRO(""File error: %s"", error.message().c_str()); return {}; } }","- fs::path path = doc_root_ / request->url().path();
+ std::string url_path = Url::DecodeUnsafe(request->url().path());
+ fs::path sub_path = utility::TranslatePath(url_path);
+ fs::path path = doc_root_ / sub_path;","ResponsePtr Server::ServeStatic(RequestPtr request) { assert(request->method() == methods::kGet); if (doc_root_.empty()) { LOG_INFO(""The doc root was not specified""); return {}; } std::string url_path = Url::DecodeUnsafe(request->url().path()); fs::path sub_path = utility::TranslatePath(url_path); fs::path path = doc_root_ / sub_path; try { auto body = std::make_shared<FileBody>(path, file_chunk_size_); auto response = std::make_shared<Response>(Status::kOK); std::string extension = path.extension().string(); response->SetContentType(media_types::FromExtension(extension), """"); response->SetBody(body, true); return response; } catch (const Error& error) { LOG_ERRO(""File error: %s"", error.message().c_str()); return {}; } }"
900,4055----CWE-668----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rijndael.c----do_decrypt,"do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx, const unsigned char *ax) { #ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds, <S2SV_StartVul> &dec_tables); <S2SV_EndVul> #elif defined(USE_ARM_ASM) return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds, <S2SV_StartVul> &dec_tables); <S2SV_EndVul> #else return do_decrypt_fn (ctx, bx, ax); #endif }","- &dec_tables);
- &dec_tables);
+ dec_tables.T);
+ dec_tables.T);","do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx, const unsigned char *ax) { #ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds, dec_tables.T); #elif defined(USE_ARM_ASM) return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds, dec_tables.T); #else return do_decrypt_fn (ctx, bx, ax); #endif }"
901,7218----CWE-399----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/softmagic.c----mprint,"mprint(struct magic_set *ms, struct magic *m) { uint64_t v; float vf; double vd; int64_t t = 0; char buf[128], tbuf[26]; union VALUETYPE *p = &ms->ms_value; switch (m->type) { case FILE_BYTE: v = file_signextend(ms, m, (uint64_t)p->b); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%d"", (unsigned char)v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%d""), (unsigned char) v) == -1) return -1; break; } t = ms->offset + sizeof(char); break; case FILE_SHORT: case FILE_BESHORT: case FILE_LESHORT: v = file_signextend(ms, m, (uint64_t)p->h); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%u"", (unsigned short)v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%u""), (unsigned short) v) == -1) return -1; break; } t = ms->offset + sizeof(short); break; case FILE_LONG: case FILE_BELONG: case FILE_LELONG: case FILE_MELONG: v = file_signextend(ms, m, (uint64_t)p->l); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%u"", (uint32_t) v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%u""), (uint32_t) v) == -1) return -1; break; } t = ms->offset + sizeof(int32_t); break; case FILE_QUAD: case FILE_BEQUAD: case FILE_LEQUAD: v = file_signextend(ms, m, p->q); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%"" INT64_T_FORMAT ""u"", (unsigned long long)v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%"" INT64_T_FORMAT ""u""), (unsigned long long) v) == -1) return -1; break; } t = ms->offset + sizeof(int64_t); break; case FILE_STRING: case FILE_PSTRING: case FILE_BESTRING16: case FILE_LESTRING16: if (m->reln == '=' || m->reln == '!') { if (file_printf(ms, F(ms, m, ""%s""), m->value.s) == -1) return -1; t = ms->offset + m->vallen; } else { char *str = p->s; t = ms->offset + strlen(str); if (*m->value.s == '\0') str[strcspn(str, ""\n"")] = '\0'; if (m->str_flags & STRING_TRIM) { char *last; while (isspace((unsigned char)*str)) str++; last = str; while (*last) last++; --last; while (isspace((unsigned char)*last)) last--; *++last = '\0'; } if (file_printf(ms, F(ms, m, ""%s""), str) == -1) return -1; if (m->type == FILE_PSTRING) t += file_pstring_length_size(m); } break; case FILE_DATE: case FILE_BEDATE: case FILE_LEDATE: case FILE_MEDATE: if (file_printf(ms, F(ms, m, ""%s""), <S2SV_StartVul> file_fmttime(p->l, FILE_T_LOCAL, tbuf)) == -1) <S2SV_EndVul> return -1; t = ms->offset + sizeof(uint32_t); break; case FILE_LDATE: case FILE_BELDATE: case FILE_LELDATE: case FILE_MELDATE: if (file_printf(ms, F(ms, m, ""%s""), <S2SV_StartVul> file_fmttime(p->l, 0, tbuf)) == -1) <S2SV_EndVul> return -1; t = ms->offset + sizeof(uint32_t); break; case FILE_QDATE: case FILE_BEQDATE: case FILE_LEQDATE: if (file_printf(ms, F(ms, m, ""%s""), <S2SV_StartVul> file_fmttime(p->q, FILE_T_LOCAL, tbuf)) == -1) <S2SV_EndVul> return -1; t = ms->offset + sizeof(uint64_t); break; case FILE_QLDATE: case FILE_BEQLDATE: case FILE_LEQLDATE: if (file_printf(ms, F(ms, m, ""%s""), <S2SV_StartVul> file_fmttime(p->q, 0, tbuf)) == -1) <S2SV_EndVul> return -1; t = ms->offset + sizeof(uint64_t); break; case FILE_QWDATE: case FILE_BEQWDATE: case FILE_LEQWDATE: if (file_printf(ms, F(ms, m, ""%s""), <S2SV_StartVul> file_fmttime(p->q, FILE_T_WINDOWS, tbuf)) == -1) <S2SV_EndVul> return -1; t = ms->offset + sizeof(uint64_t); break; case FILE_FLOAT: case FILE_BEFLOAT: case FILE_LEFLOAT: vf = p->f; switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%g"", vf); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%g""), vf) == -1) return -1; break; } t = ms->offset + sizeof(float); break; case FILE_DOUBLE: case FILE_BEDOUBLE: case FILE_LEDOUBLE: vd = p->d; switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%g"", vd); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%g""), vd) == -1) return -1; break; } t = ms->offset + sizeof(double); break; case FILE_REGEX: { char *cp; int rval; cp = strndup((const char *)ms->search.s, ms->search.rm_len); if (cp == NULL) { file_oomem(ms, ms->search.rm_len); return -1; } rval = file_printf(ms, F(ms, m, ""%s""), cp); free(cp); if (rval == -1) return -1; if ((m->str_flags & REGEX_OFFSET_START)) t = ms->search.offset; else t = ms->search.offset + ms->search.rm_len; break; } case FILE_SEARCH: if (file_printf(ms, F(ms, m, ""%s""), m->value.s) == -1) return -1; if ((m->str_flags & REGEX_OFFSET_START)) t = ms->search.offset; else t = ms->search.offset + m->vallen; break; case FILE_DEFAULT: case FILE_CLEAR: if (file_printf(ms, ""%s"", m->desc) == -1) return -1; t = ms->offset; break; case FILE_INDIRECT: case FILE_USE: case FILE_NAME: t = ms->offset; break; default: file_magerror(ms, ""invalid m->type (%d) in mprint()"", m->type); return -1; } return (int32_t)t; }","- file_fmttime(p->l, FILE_T_LOCAL, tbuf)) == -1)
- file_fmttime(p->l, 0, tbuf)) == -1)
- file_fmttime(p->q, FILE_T_LOCAL, tbuf)) == -1)
- file_fmttime(p->q, 0, tbuf)) == -1)
- file_fmttime(p->q, FILE_T_WINDOWS, tbuf)) == -1)
+ file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)
+ file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)
+ file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)
+ file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)
+ file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)","mprint(struct magic_set *ms, struct magic *m) { uint64_t v; float vf; double vd; int64_t t = 0; char buf[128], tbuf[26]; union VALUETYPE *p = &ms->ms_value; switch (m->type) { case FILE_BYTE: v = file_signextend(ms, m, (uint64_t)p->b); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%d"", (unsigned char)v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%d""), (unsigned char) v) == -1) return -1; break; } t = ms->offset + sizeof(char); break; case FILE_SHORT: case FILE_BESHORT: case FILE_LESHORT: v = file_signextend(ms, m, (uint64_t)p->h); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%u"", (unsigned short)v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%u""), (unsigned short) v) == -1) return -1; break; } t = ms->offset + sizeof(short); break; case FILE_LONG: case FILE_BELONG: case FILE_LELONG: case FILE_MELONG: v = file_signextend(ms, m, (uint64_t)p->l); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%u"", (uint32_t) v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%u""), (uint32_t) v) == -1) return -1; break; } t = ms->offset + sizeof(int32_t); break; case FILE_QUAD: case FILE_BEQUAD: case FILE_LEQUAD: v = file_signextend(ms, m, p->q); switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%"" INT64_T_FORMAT ""u"", (unsigned long long)v); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%"" INT64_T_FORMAT ""u""), (unsigned long long) v) == -1) return -1; break; } t = ms->offset + sizeof(int64_t); break; case FILE_STRING: case FILE_PSTRING: case FILE_BESTRING16: case FILE_LESTRING16: if (m->reln == '=' || m->reln == '!') { if (file_printf(ms, F(ms, m, ""%s""), m->value.s) == -1) return -1; t = ms->offset + m->vallen; } else { char *str = p->s; t = ms->offset + strlen(str); if (*m->value.s == '\0') str[strcspn(str, ""\n"")] = '\0'; if (m->str_flags & STRING_TRIM) { char *last; while (isspace((unsigned char)*str)) str++; last = str; while (*last) last++; --last; while (isspace((unsigned char)*last)) last--; *++last = '\0'; } if (file_printf(ms, F(ms, m, ""%s""), str) == -1) return -1; if (m->type == FILE_PSTRING) t += file_pstring_length_size(m); } break; case FILE_DATE: case FILE_BEDATE: case FILE_LEDATE: case FILE_MEDATE: if (file_printf(ms, F(ms, m, ""%s""), file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1) return -1; t = ms->offset + sizeof(uint32_t); break; case FILE_LDATE: case FILE_BELDATE: case FILE_LELDATE: case FILE_MELDATE: if (file_printf(ms, F(ms, m, ""%s""), file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1) return -1; t = ms->offset + sizeof(uint32_t); break; case FILE_QDATE: case FILE_BEQDATE: case FILE_LEQDATE: if (file_printf(ms, F(ms, m, ""%s""), file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1) return -1; t = ms->offset + sizeof(uint64_t); break; case FILE_QLDATE: case FILE_BEQLDATE: case FILE_LEQLDATE: if (file_printf(ms, F(ms, m, ""%s""), file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1) return -1; t = ms->offset + sizeof(uint64_t); break; case FILE_QWDATE: case FILE_BEQWDATE: case FILE_LEQWDATE: if (file_printf(ms, F(ms, m, ""%s""), file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1) return -1; t = ms->offset + sizeof(uint64_t); break; case FILE_FLOAT: case FILE_BEFLOAT: case FILE_LEFLOAT: vf = p->f; switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%g"", vf); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%g""), vf) == -1) return -1; break; } t = ms->offset + sizeof(float); break; case FILE_DOUBLE: case FILE_BEDOUBLE: case FILE_LEDOUBLE: vd = p->d; switch (check_fmt(ms, m)) { case -1: return -1; case 1: (void)snprintf(buf, sizeof(buf), ""%g"", vd); if (file_printf(ms, F(ms, m, ""%s""), buf) == -1) return -1; break; default: if (file_printf(ms, F(ms, m, ""%g""), vd) == -1) return -1; break; } t = ms->offset + sizeof(double); break; case FILE_REGEX: { char *cp; int rval; cp = strndup((const char *)ms->search.s, ms->search.rm_len); if (cp == NULL) { file_oomem(ms, ms->search.rm_len); return -1; } rval = file_printf(ms, F(ms, m, ""%s""), cp); free(cp); if (rval == -1) return -1; if ((m->str_flags & REGEX_OFFSET_START)) t = ms->search.offset; else t = ms->search.offset + ms->search.rm_len; break; } case FILE_SEARCH: if (file_printf(ms, F(ms, m, ""%s""), m->value.s) == -1) return -1; if ((m->str_flags & REGEX_OFFSET_START)) t = ms->search.offset; else t = ms->search.offset + m->vallen; break; case FILE_DEFAULT: case FILE_CLEAR: if (file_printf(ms, ""%s"", m->desc) == -1) return -1; t = ms->offset; break; case FILE_INDIRECT: case FILE_USE: case FILE_NAME: t = ms->offset; break; default: file_magerror(ms, ""invalid m->type (%d) in mprint()"", m->type); return -1; } return (int32_t)t; }"
902,1823----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-5873--php_http_url.c----*parse_scheme,"static const char *parse_scheme(struct parse_state *state) { size_t mb; const char *tmp = state->ptr; do { switch (*state->ptr) { case ':': state->url.scheme = &state->buffer[0]; state->buffer[state->offset++] = 0; return ++state->ptr; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '+': case '-': case '.': if (state->ptr == tmp) { <S2SV_StartVul> return tmp; <S2SV_EndVul> } case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u': case 'v': case 'w': case 'x': case 'y': case 'z': state->buffer[state->offset++] = *state->ptr; break; default: if (!(mb = parse_mb(state, PARSE_SCHEME, state->ptr, state->end, tmp, 1))) { <S2SV_StartVul> return tmp; <S2SV_EndVul> } state->ptr += mb - 1; } } while (++state->ptr != state->end); return state->ptr = tmp; }","- return tmp;
- return tmp;
+ goto softfail;
+ goto softfail;
+ softfail:
+ state->offset = 0;","static const char *parse_scheme(struct parse_state *state) { size_t mb; const char *tmp = state->ptr; do { switch (*state->ptr) { case ':': state->url.scheme = &state->buffer[0]; state->buffer[state->offset++] = 0; return ++state->ptr; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '+': case '-': case '.': if (state->ptr == tmp) { goto softfail; } case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g': case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n': case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u': case 'v': case 'w': case 'x': case 'y': case 'z': state->buffer[state->offset++] = *state->ptr; break; default: if (!(mb = parse_mb(state, PARSE_SCHEME, state->ptr, state->end, tmp, 1))) { goto softfail; } state->ptr += mb - 1; } } while (++state->ptr != state->end); softfail: state->offset = 0; return state->ptr = tmp; }"
903,1273----CWE-476----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-15274--keyctl.c----keyctl_update_key,"long keyctl_update_key(key_serial_t id, const void __user *_payload, size_t plen) { key_ref_t key_ref; void *payload; long ret; ret = -EINVAL; if (plen > PAGE_SIZE) goto error; payload = NULL; <S2SV_StartVul> if (_payload) { <S2SV_EndVul> ret = -ENOMEM; payload = kmalloc(plen, GFP_KERNEL); if (!payload) goto error; ret = -EFAULT; if (copy_from_user(payload, _payload, plen) != 0) goto error2; } key_ref = lookup_user_key(id, 0, KEY_NEED_WRITE); if (IS_ERR(key_ref)) { ret = PTR_ERR(key_ref); goto error2; } ret = key_update(key_ref, payload, plen); key_ref_put(key_ref); error2: kfree(payload); error: return ret; }","- if (_payload) {
+ if (plen) {","long keyctl_update_key(key_serial_t id, const void __user *_payload, size_t plen) { key_ref_t key_ref; void *payload; long ret; ret = -EINVAL; if (plen > PAGE_SIZE) goto error; payload = NULL; if (plen) { ret = -ENOMEM; payload = kmalloc(plen, GFP_KERNEL); if (!payload) goto error; ret = -EFAULT; if (copy_from_user(payload, _payload, plen) != 0) goto error2; } key_ref = lookup_user_key(id, 0, KEY_NEED_WRITE); if (IS_ERR(key_ref)) { ret = PTR_ERR(key_ref); goto error2; } ret = key_update(key_ref, payload, plen); key_ref_put(key_ref); error2: kfree(payload); error: return ret; }"
904,7186----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/socket.c----getHostByName,"error_t getHostByName(NetInterface *interface, const char_t *name, IpAddr *ipAddr, uint_t flags) { error_t error; HostType type; HostnameResolver protocol; #if (IPV4_SUPPORT == ENABLED) type = HOST_TYPE_IPV4; #elif (IPV6_SUPPORT == ENABLED) type = HOST_TYPE_IPV6; #else type = HOST_TYPE_ANY; #endif #if (DNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_DNS; #elif (MDNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_MDNS; #elif (NBNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_NBNS; #elif (LLMNR_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_LLMNR; #else protocol = HOST_NAME_RESOLVER_ANY; #endif if(name == NULL || ipAddr == NULL) return ERROR_INVALID_PARAMETER; if(interface == NULL) interface = netGetDefaultInterface(); error = ipStringToAddr(name, ipAddr); if(error) { if(flags & HOST_TYPE_IPV4) type = HOST_TYPE_IPV4; else if(flags & HOST_TYPE_IPV6) type = HOST_TYPE_IPV6; if(flags & HOST_NAME_RESOLVER_DNS) { protocol = HOST_NAME_RESOLVER_DNS; } else if(flags & HOST_NAME_RESOLVER_MDNS) { protocol = HOST_NAME_RESOLVER_MDNS; } else if(flags & HOST_NAME_RESOLVER_NBNS) { protocol = HOST_NAME_RESOLVER_NBNS; } else if(flags & HOST_NAME_RESOLVER_LLMNR) { protocol = HOST_NAME_RESOLVER_LLMNR; } else { size_t n = osStrlen(name); if(n >= 6 && !osStrcasecmp(name + n - 6, "".local"")) { #if (MDNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_MDNS; #endif } <S2SV_StartVul> else if(n <= 15 && !strchr(name, '.') && type == HOST_TYPE_IPV4) <S2SV_EndVul> { #if (NBNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_NBNS; #endif } <S2SV_StartVul> else if(!strchr(name, '.')) <S2SV_EndVul> { #if (LLMNR_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_LLMNR; #endif } } #if (DNS_CLIENT_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_DNS) { error = dnsResolve(interface, name, type, ipAddr); } else #endif #if (MDNS_CLIENT_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_MDNS) { error = mdnsClientResolve(interface, name, type, ipAddr); } else #endif #if (NBNS_CLIENT_SUPPORT == ENABLED && IPV4_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_NBNS) { error = nbnsResolve(interface, name, ipAddr); } else #endif #if (LLMNR_CLIENT_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_LLMNR) { error = llmnrResolve(interface, name, type, ipAddr); } else #endif { error = ERROR_INVALID_PARAMETER; } } return error; }","- else if(n <= 15 && !strchr(name, '.') && type == HOST_TYPE_IPV4)
- else if(!strchr(name, '.'))
+ else if(n <= 15 && !osStrchr(name, '.') && type == HOST_TYPE_IPV4)
+ else if(!osStrchr(name, '.'))","error_t getHostByName(NetInterface *interface, const char_t *name, IpAddr *ipAddr, uint_t flags) { error_t error; HostType type; HostnameResolver protocol; #if (IPV4_SUPPORT == ENABLED) type = HOST_TYPE_IPV4; #elif (IPV6_SUPPORT == ENABLED) type = HOST_TYPE_IPV6; #else type = HOST_TYPE_ANY; #endif #if (DNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_DNS; #elif (MDNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_MDNS; #elif (NBNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_NBNS; #elif (LLMNR_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_LLMNR; #else protocol = HOST_NAME_RESOLVER_ANY; #endif if(name == NULL || ipAddr == NULL) return ERROR_INVALID_PARAMETER; if(interface == NULL) interface = netGetDefaultInterface(); error = ipStringToAddr(name, ipAddr); if(error) { if(flags & HOST_TYPE_IPV4) type = HOST_TYPE_IPV4; else if(flags & HOST_TYPE_IPV6) type = HOST_TYPE_IPV6; if(flags & HOST_NAME_RESOLVER_DNS) { protocol = HOST_NAME_RESOLVER_DNS; } else if(flags & HOST_NAME_RESOLVER_MDNS) { protocol = HOST_NAME_RESOLVER_MDNS; } else if(flags & HOST_NAME_RESOLVER_NBNS) { protocol = HOST_NAME_RESOLVER_NBNS; } else if(flags & HOST_NAME_RESOLVER_LLMNR) { protocol = HOST_NAME_RESOLVER_LLMNR; } else { size_t n = osStrlen(name); if(n >= 6 && !osStrcasecmp(name + n - 6, "".local"")) { #if (MDNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_MDNS; #endif } else if(n <= 15 && !osStrchr(name, '.') && type == HOST_TYPE_IPV4) { #if (NBNS_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_NBNS; #endif } else if(!osStrchr(name, '.')) { #if (LLMNR_CLIENT_SUPPORT == ENABLED) protocol = HOST_NAME_RESOLVER_LLMNR; #endif } } #if (DNS_CLIENT_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_DNS) { error = dnsResolve(interface, name, type, ipAddr); } else #endif #if (MDNS_CLIENT_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_MDNS) { error = mdnsClientResolve(interface, name, type, ipAddr); } else #endif #if (NBNS_CLIENT_SUPPORT == ENABLED && IPV4_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_NBNS) { error = nbnsResolve(interface, name, ipAddr); } else #endif #if (LLMNR_CLIENT_SUPPORT == ENABLED) if(protocol == HOST_NAME_RESOLVER_LLMNR) { error = llmnrResolve(interface, name, type, ipAddr); } else #endif { error = ERROR_INVALID_PARAMETER; } } return error; }"
905,7072----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/rx63n_eth_driver.c----rx63nEthInitGpio,void rx63nEthInitGpio(NetInterface *interface) { MPC.PWPR.BIT.B0WI = 0; MPC.PWPR.BIT.PFSWE = 1; #if defined(USE_RDK_RX63N) MPC.PFENET.BIT.PHYMODE = 0; PORTA.PMR.BIT.B3 = 1; MPC.PA3PFS.BYTE = 0x11; PORTA.PMR.BIT.B4 = 1; MPC.PA4PFS.BYTE = 0x11; PORTA.PMR.BIT.B5 = 1; MPC.PA5PFS.BYTE = 0x11; PORTB.PMR.BIT.B0 = 1; MPC.PB0PFS.BYTE = 0x12; PORTB.PMR.BIT.B1 = 1; MPC.PB1PFS.BYTE = 0x12; PORTB.PMR.BIT.B2 = 1; MPC.PB2PFS.BYTE = 0x12; PORTB.PMR.BIT.B3 = 1; MPC.PB3PFS.BYTE = 0x12; PORTB.PMR.BIT.B4 = 1; MPC.PB4PFS.BYTE = 0x12; PORTB.PMR.BIT.B5 = 1; MPC.PB5PFS.BYTE = 0x12; PORTB.PMR.BIT.B6 = 1; MPC.PB6PFS.BYTE = 0x12; PORTB.PMR.BIT.B7 = 1; MPC.PB7PFS.BYTE = 0x12; <S2SV_StartVul> #elif defined(USE_RSK_RX63N) <S2SV_EndVul> MPC.PFENET.BIT.PHYMODE = 1; PORT7.PMR.BIT.B1 = 1; MPC.P71PFS.BYTE = 0x11; PORT7.PMR.BIT.B2 = 1; MPC.P72PFS.BYTE = 0x11; PORT7.PMR.BIT.B4 = 1; MPC.P74PFS.BYTE = 0x11; PORT7.PMR.BIT.B5 = 1; MPC.P75PFS.BYTE = 0x11; PORT7.PMR.BIT.B6 = 1; MPC.P76PFS.BYTE = 0x11; PORT7.PMR.BIT.B7 = 1; MPC.P77PFS.BYTE = 0x11; PORT8.PMR.BIT.B0 = 1; MPC.P80PFS.BYTE = 0x11; PORT8.PMR.BIT.B1 = 1; MPC.P81PFS.BYTE = 0x11; PORT8.PMR.BIT.B2 = 1; MPC.P82PFS.BYTE = 0x11; PORT8.PMR.BIT.B3 = 1; MPC.P83PFS.BYTE = 0x11; PORTC.PMR.BIT.B0 = 1; MPC.PC0PFS.BYTE = 0x11; PORTC.PMR.BIT.B1 = 1; MPC.PC1PFS.BYTE = 0x11; PORTC.PMR.BIT.B2 = 1; MPC.PC2PFS.BYTE = 0x11; PORTC.PMR.BIT.B3 = 1; MPC.PC3PFS.BYTE = 0x11; PORTC.PMR.BIT.B4 = 1; MPC.PC4PFS.BYTE = 0x11; PORTC.PMR.BIT.B5 = 1; MPC.PC5PFS.BYTE = 0x11; PORTC.PMR.BIT.B6 = 1; MPC.PC6PFS.BYTE = 0x11; PORTC.PMR.BIT.B7 = 1; MPC.PC7PFS.BYTE = 0x11; #endif MPC.PWPR.BIT.PFSWE = 0; MPC.PWPR.BIT.B0WI = 0; },"- #elif defined(USE_RSK_RX63N)
+ #elif defined(USE_RSK_RX63N) || defined(USE_RSK_RX63N_256K)",void rx63nEthInitGpio(NetInterface *interface) { MPC.PWPR.BIT.B0WI = 0; MPC.PWPR.BIT.PFSWE = 1; #if defined(USE_RDK_RX63N) MPC.PFENET.BIT.PHYMODE = 0; PORTA.PMR.BIT.B3 = 1; MPC.PA3PFS.BYTE = 0x11; PORTA.PMR.BIT.B4 = 1; MPC.PA4PFS.BYTE = 0x11; PORTA.PMR.BIT.B5 = 1; MPC.PA5PFS.BYTE = 0x11; PORTB.PMR.BIT.B0 = 1; MPC.PB0PFS.BYTE = 0x12; PORTB.PMR.BIT.B1 = 1; MPC.PB1PFS.BYTE = 0x12; PORTB.PMR.BIT.B2 = 1; MPC.PB2PFS.BYTE = 0x12; PORTB.PMR.BIT.B3 = 1; MPC.PB3PFS.BYTE = 0x12; PORTB.PMR.BIT.B4 = 1; MPC.PB4PFS.BYTE = 0x12; PORTB.PMR.BIT.B5 = 1; MPC.PB5PFS.BYTE = 0x12; PORTB.PMR.BIT.B6 = 1; MPC.PB6PFS.BYTE = 0x12; PORTB.PMR.BIT.B7 = 1; MPC.PB7PFS.BYTE = 0x12; #elif defined(USE_RSK_RX63N) || defined(USE_RSK_RX63N_256K) MPC.PFENET.BIT.PHYMODE = 1; PORT7.PMR.BIT.B1 = 1; MPC.P71PFS.BYTE = 0x11; PORT7.PMR.BIT.B2 = 1; MPC.P72PFS.BYTE = 0x11; PORT7.PMR.BIT.B4 = 1; MPC.P74PFS.BYTE = 0x11; PORT7.PMR.BIT.B5 = 1; MPC.P75PFS.BYTE = 0x11; PORT7.PMR.BIT.B6 = 1; MPC.P76PFS.BYTE = 0x11; PORT7.PMR.BIT.B7 = 1; MPC.P77PFS.BYTE = 0x11; PORT8.PMR.BIT.B0 = 1; MPC.P80PFS.BYTE = 0x11; PORT8.PMR.BIT.B1 = 1; MPC.P81PFS.BYTE = 0x11; PORT8.PMR.BIT.B2 = 1; MPC.P82PFS.BYTE = 0x11; PORT8.PMR.BIT.B3 = 1; MPC.P83PFS.BYTE = 0x11; PORTC.PMR.BIT.B0 = 1; MPC.PC0PFS.BYTE = 0x11; PORTC.PMR.BIT.B1 = 1; MPC.PC1PFS.BYTE = 0x11; PORTC.PMR.BIT.B2 = 1; MPC.PC2PFS.BYTE = 0x11; PORTC.PMR.BIT.B3 = 1; MPC.PC3PFS.BYTE = 0x11; PORTC.PMR.BIT.B4 = 1; MPC.PC4PFS.BYTE = 0x11; PORTC.PMR.BIT.B5 = 1; MPC.PC5PFS.BYTE = 0x11; PORTC.PMR.BIT.B6 = 1; MPC.PC6PFS.BYTE = 0x11; PORTC.PMR.BIT.B7 = 1; MPC.PC7PFS.BYTE = 0x11; #endif MPC.PWPR.BIT.PFSWE = 0; MPC.PWPR.BIT.B0WI = 0; }
906,4225----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/MemoryManager.cpp----MemoryManager::validate_user_write,"bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const { <S2SV_StartVul> auto* region = region_from_vaddr(process, vaddr); <S2SV_EndVul> <S2SV_StartVul> return region && region->is_writable(); <S2SV_EndVul> }","- auto* region = region_from_vaddr(process, vaddr);
- return region && region->is_writable();
+ auto* region = user_region_from_vaddr(const_cast<Process&>(process), vaddr);
+ return region && region->is_user_accessible() && region->is_writable();","bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const { auto* region = user_region_from_vaddr(const_cast<Process&>(process), vaddr); return region && region->is_user_accessible() && region->is_writable(); }"
907,4111----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cls_route.c----route4_change,"static int route4_change(struct net *net, struct sk_buff *in_skb, struct tcf_proto *tp, unsigned long base, u32 handle, struct nlattr **tca, void **arg, bool ovr, bool rtnl_held, struct netlink_ext_ack *extack) { struct route4_head *head = rtnl_dereference(tp->root); struct route4_filter __rcu **fp; struct route4_filter *fold, *f1, *pfp, *f = NULL; struct route4_bucket *b; struct nlattr *opt = tca[TCA_OPTIONS]; struct nlattr *tb[TCA_ROUTE4_MAX + 1]; unsigned int h, th; int err; bool new = true; if (opt == NULL) return handle ? -EINVAL : 0; err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt, route4_policy, NULL); if (err < 0) return err; fold = *arg; if (fold && handle && fold->handle != handle) return -EINVAL; err = -ENOBUFS; f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL); if (!f) goto errout; err = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE); if (err < 0) goto errout; if (fold) { f->id = fold->id; f->iif = fold->iif; f->res = fold->res; f->handle = fold->handle; f->tp = fold->tp; f->bkt = fold->bkt; new = false; } err = route4_set_parms(net, tp, base, f, handle, head, tb, tca[TCA_RATE], new, ovr, extack); if (err < 0) goto errout; h = from_hash(f->handle >> 16); fp = &f->bkt->ht[h]; for (pfp = rtnl_dereference(*fp); (f1 = rtnl_dereference(*fp)) != NULL; fp = &f1->next) if (f->handle < f1->handle) break; tcf_block_netif_keep_dst(tp->chain->block); rcu_assign_pointer(f->next, f1); rcu_assign_pointer(*fp, f); if (fold && fold->handle && f->handle != fold->handle) { th = to_hash(fold->handle); h = from_hash(fold->handle >> 16); b = rtnl_dereference(head->table[th]); if (b) { fp = &b->ht[h]; for (pfp = rtnl_dereference(*fp); pfp; fp = &pfp->next, pfp = rtnl_dereference(*fp)) { <S2SV_StartVul> if (pfp == f) { <S2SV_EndVul> <S2SV_StartVul> *fp = f->next; <S2SV_EndVul> break; } } } } route4_reset_fastmap(head); *arg = f; if (fold) { tcf_unbind_filter(tp, &fold->res); tcf_exts_get_net(&fold->exts); tcf_queue_work(&fold->rwork, route4_delete_filter_work); } return 0; errout: if (f) tcf_exts_destroy(&f->exts); kfree(f); return err; }","- if (pfp == f) {
+ if (pfp == fold) {
+ rcu_assign_pointer(*fp, fold->next);","static int route4_change(struct net *net, struct sk_buff *in_skb, struct tcf_proto *tp, unsigned long base, u32 handle, struct nlattr **tca, void **arg, bool ovr, bool rtnl_held, struct netlink_ext_ack *extack) { struct route4_head *head = rtnl_dereference(tp->root); struct route4_filter __rcu **fp; struct route4_filter *fold, *f1, *pfp, *f = NULL; struct route4_bucket *b; struct nlattr *opt = tca[TCA_OPTIONS]; struct nlattr *tb[TCA_ROUTE4_MAX + 1]; unsigned int h, th; int err; bool new = true; if (opt == NULL) return handle ? -EINVAL : 0; err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt, route4_policy, NULL); if (err < 0) return err; fold = *arg; if (fold && handle && fold->handle != handle) return -EINVAL; err = -ENOBUFS; f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL); if (!f) goto errout; err = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE); if (err < 0) goto errout; if (fold) { f->id = fold->id; f->iif = fold->iif; f->res = fold->res; f->handle = fold->handle; f->tp = fold->tp; f->bkt = fold->bkt; new = false; } err = route4_set_parms(net, tp, base, f, handle, head, tb, tca[TCA_RATE], new, ovr, extack); if (err < 0) goto errout; h = from_hash(f->handle >> 16); fp = &f->bkt->ht[h]; for (pfp = rtnl_dereference(*fp); (f1 = rtnl_dereference(*fp)) != NULL; fp = &f1->next) if (f->handle < f1->handle) break; tcf_block_netif_keep_dst(tp->chain->block); rcu_assign_pointer(f->next, f1); rcu_assign_pointer(*fp, f); if (fold && fold->handle && f->handle != fold->handle) { th = to_hash(fold->handle); h = from_hash(fold->handle >> 16); b = rtnl_dereference(head->table[th]); if (b) { fp = &b->ht[h]; for (pfp = rtnl_dereference(*fp); pfp; fp = &pfp->next, pfp = rtnl_dereference(*fp)) { if (pfp == fold) { rcu_assign_pointer(*fp, fold->next); break; } } } } route4_reset_fastmap(head); *arg = f; if (fold) { tcf_unbind_filter(tp, &fold->res); tcf_exts_get_net(&fold->exts); tcf_queue_work(&fold->rwork, route4_delete_filter_work); } return 0; errout: if (f) tcf_exts_destroy(&f->exts); kfree(f); return err; }"
908,764----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3346--scsi-disk.c----scsi_dma_restart_bh,"static void scsi_dma_restart_bh(void *opaque) { SCSIDiskState *s = opaque; SCSIRequest *req; SCSIDiskReq *r; qemu_bh_delete(s->bh); s->bh = NULL; QTAILQ_FOREACH(req, &s->qdev.requests, next) { r = DO_UPCAST(SCSIDiskReq, req, req); if (r->status & SCSI_REQ_STATUS_RETRY) { int status = r->status; int ret; r->status &= ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK); switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) { case SCSI_REQ_STATUS_RETRY_READ: scsi_read_data(&r->req); break; case SCSI_REQ_STATUS_RETRY_WRITE: scsi_write_data(&r->req); break; case SCSI_REQ_STATUS_RETRY_FLUSH: <S2SV_StartVul> ret = scsi_disk_emulate_command(r, r->iov.iov_base); <S2SV_EndVul> if (ret == 0) { scsi_req_complete(&r->req, GOOD); } } } } }","- ret = scsi_disk_emulate_command(r, r->iov.iov_base);
+ ret = scsi_disk_emulate_command(r);","static void scsi_dma_restart_bh(void *opaque) { SCSIDiskState *s = opaque; SCSIRequest *req; SCSIDiskReq *r; qemu_bh_delete(s->bh); s->bh = NULL; QTAILQ_FOREACH(req, &s->qdev.requests, next) { r = DO_UPCAST(SCSIDiskReq, req, req); if (r->status & SCSI_REQ_STATUS_RETRY) { int status = r->status; int ret; r->status &= ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK); switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) { case SCSI_REQ_STATUS_RETRY_READ: scsi_read_data(&r->req); break; case SCSI_REQ_STATUS_RETRY_WRITE: scsi_write_data(&r->req); break; case SCSI_REQ_STATUS_RETRY_FLUSH: ret = scsi_disk_emulate_command(r); if (ret == 0) { scsi_req_complete(&r->req, GOOD); } } } } }"
909,248----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-4565--tcp_illinois.c----tcp_illinois_info,"static void tcp_illinois_info(struct sock *sk, u32 ext, struct sk_buff *skb) { const struct illinois *ca = inet_csk_ca(sk); if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) { struct tcpvegas_info info = { .tcpv_enabled = 1, .tcpv_rttcnt = ca->cnt_rtt, .tcpv_minrtt = ca->base_rtt, }; <S2SV_StartVul> u64 t = ca->sum_rtt; <S2SV_EndVul> <S2SV_StartVul> do_div(t, ca->cnt_rtt); <S2SV_EndVul> <S2SV_StartVul> info.tcpv_rtt = t; <S2SV_EndVul> nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info); } }","- u64 t = ca->sum_rtt;
- do_div(t, ca->cnt_rtt);
- info.tcpv_rtt = t;
+ if (info.tcpv_rttcnt > 0) {
+ u64 t = ca->sum_rtt;
+ do_div(t, info.tcpv_rttcnt);
+ info.tcpv_rtt = t;
+ }","static void tcp_illinois_info(struct sock *sk, u32 ext, struct sk_buff *skb) { const struct illinois *ca = inet_csk_ca(sk); if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) { struct tcpvegas_info info = { .tcpv_enabled = 1, .tcpv_rttcnt = ca->cnt_rtt, .tcpv_minrtt = ca->base_rtt, }; if (info.tcpv_rttcnt > 0) { u64 t = ca->sum_rtt; do_div(t, info.tcpv_rttcnt); info.tcpv_rtt = t; } nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info); } }"
910,826----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-2831--das_watchdog.c----*get_pid_environ_val,"static char *get_pid_environ_val(pid_t pid,char *val){ <S2SV_StartVul> char temp[500]; <S2SV_EndVul> int i=0; int foundit=0; FILE *fp; sprintf(temp,""/proc/%d/environ"",pid); fp=fopen(temp,""r""); if(fp==NULL) return NULL; for(;;){ temp[i]=fgetc(fp); if(foundit==1 && (temp[i]==0 || temp[i]=='\0' || temp[i]==EOF)){ char *ret; temp[i]=0; ret=malloc(strlen(temp)+10); sprintf(ret,""%s"",temp); fclose(fp); return ret; } switch(temp[i]){ case EOF: fclose(fp); return NULL; case '=': temp[i]=0; if(!strcmp(temp,val)){ foundit=1; } i=0; break; case '\0': i=0; break; default: i++; } } }","- char temp[500];
+ int temp_size = 500;
+ char *temp = malloc(temp_size);
+ if (i >= temp_size) {
+ temp_size *= 2;
+ temp = realloc(temp, temp_size);
+ }","static char *get_pid_environ_val(pid_t pid,char *val){ int temp_size = 500; char *temp = malloc(temp_size); int i=0; int foundit=0; FILE *fp; sprintf(temp,""/proc/%d/environ"",pid); fp=fopen(temp,""r""); if(fp==NULL) return NULL; for(;;){ if (i >= temp_size) { temp_size *= 2; temp = realloc(temp, temp_size); } temp[i]=fgetc(fp); if(foundit==1 && (temp[i]==0 || temp[i]=='\0' || temp[i]==EOF)){ char *ret; temp[i]=0; ret=malloc(strlen(temp)+10); sprintf(ret,""%s"",temp); fclose(fp); return ret; } switch(temp[i]){ case EOF: fclose(fp); return NULL; case '=': temp[i]=0; if(!strcmp(temp,val)){ foundit=1; } i=0; break; case '\0': i=0; break; default: i++; } } }"
911,6650----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/bson.c----bson_append_symbol_n,"<S2SV_StartVul> MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) { <S2SV_EndVul> return bson_append_string_base( b, name, value, len, BSON_SYMBOL ); }","- MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {
+ MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, size_t len ) {","MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, size_t len ) { return bson_append_string_base( b, name, value, len, BSON_SYMBOL ); }"
912,307--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-4621--sched.c----put_prev_task,"static void put_prev_task(struct rq *rq, struct task_struct *prev) { if (prev->se.on_rq) update_rq_clock(rq); <S2SV_StartVul> rq->skip_clock_update = 0; <S2SV_EndVul> prev->sched_class->put_prev_task(rq, prev); }",- rq->skip_clock_update = 0;,"static void put_prev_task(struct rq *rq, struct task_struct *prev) { if (prev->se.on_rq) update_rq_clock(rq); prev->sched_class->put_prev_task(rq, prev); }"
913,5522----CWE-369----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/op_level_cost_estimator.cc----tensorflow::grappler::OpLevelCostEstimator::PredictMaxPool,"Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context, NodeCosts* node_costs) const { bool found_unknown_shapes = false; const auto& op_info = op_context.op_info; <S2SV_StartVul> ConvolutionDimensions dims = OpDimensionsFromInputs( <S2SV_EndVul> <S2SV_StartVul> op_info.inputs(0).shape(), op_info, &found_unknown_shapes); <S2SV_EndVul> int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1; int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops; node_costs->num_compute_ops = ops; int64_t input_size = 0; if (dims.ky >= dims.sy) { input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes); } else { const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype())); input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz; } node_costs->num_input_bytes_accessed = {input_size}; const int64_t output_size = CalculateOutputSize(op_info, &found_unknown_shapes); node_costs->num_output_bytes_accessed = {output_size}; node_costs->max_memory = output_size; if (found_unknown_shapes) { node_costs->inaccurate = true; node_costs->num_nodes_with_unknown_shapes = 1; } return Status::OK(); }","- ConvolutionDimensions dims = OpDimensionsFromInputs(
- op_info.inputs(0).shape(), op_info, &found_unknown_shapes);
+ TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,
+ OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,
+ &found_unknown_shapes));","Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context, NodeCosts* node_costs) const { bool found_unknown_shapes = false; const auto& op_info = op_context.op_info; TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims, OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info, &found_unknown_shapes)); int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1; int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops; node_costs->num_compute_ops = ops; int64_t input_size = 0; if (dims.ky >= dims.sy) { input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes); } else { const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype())); input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz; } node_costs->num_input_bytes_accessed = {input_size}; const int64_t output_size = CalculateOutputSize(op_info, &found_unknown_shapes); node_costs->num_output_bytes_accessed = {output_size}; node_costs->max_memory = output_size; if (found_unknown_shapes) { node_costs->inaccurate = true; node_costs->num_nodes_with_unknown_shapes = 1; } return Status::OK(); }"
914,1164----CWE-362----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-7550--keyctl.c----keyctl_read_key,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen) { struct key *key; key_ref_t key_ref; long ret; key_ref = lookup_user_key(keyid, 0, 0); if (IS_ERR(key_ref)) { ret = -ENOKEY; goto error; } key = key_ref_to_ptr(key_ref); ret = key_permission(key_ref, KEY_NEED_READ); if (ret == 0) goto can_read_key; if (ret != -EACCES) goto error; if (!is_key_possessed(key_ref)) { ret = -EACCES; goto error2; } can_read_key: <S2SV_StartVul> ret = key_validate(key); <S2SV_EndVul> <S2SV_StartVul> if (ret == 0) { <S2SV_EndVul> <S2SV_StartVul> ret = -EOPNOTSUPP; <S2SV_EndVul> <S2SV_StartVul> if (key->type->read) { <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> down_read(&key->sem); <S2SV_EndVul> ret = key->type->read(key, buffer, buflen); <S2SV_StartVul> up_read(&key->sem); <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> } error2: key_put(key); error: return ret; }","- ret = key_validate(key);
- if (ret == 0) {
- ret = -EOPNOTSUPP;
- if (key->type->read) {
- down_read(&key->sem);
- up_read(&key->sem);
- }
+ ret = -EOPNOTSUPP;
+ if (key->type->read) {
+ down_read(&key->sem);
+ ret = key_validate(key);
+ if (ret == 0)
+ up_read(&key->sem);","long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen) { struct key *key; key_ref_t key_ref; long ret; key_ref = lookup_user_key(keyid, 0, 0); if (IS_ERR(key_ref)) { ret = -ENOKEY; goto error; } key = key_ref_to_ptr(key_ref); ret = key_permission(key_ref, KEY_NEED_READ); if (ret == 0) goto can_read_key; if (ret != -EACCES) goto error; if (!is_key_possessed(key_ref)) { ret = -EACCES; goto error2; } can_read_key: ret = -EOPNOTSUPP; if (key->type->read) { down_read(&key->sem); ret = key_validate(key); if (ret == 0) ret = key->type->read(key, buffer, buflen); up_read(&key->sem); } error2: key_put(key); error: return ret; }"
915,6619----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fault.c----do_page_fault,"int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address, unsigned long error_code) { struct vm_area_struct * vma; struct mm_struct *mm = current->mm; siginfo_t info; int code = SEGV_MAPERR; int is_write = 0, ret; int trap = TRAP(regs); int is_exec = trap == 0x400; #if !(defined(CONFIG_4xx) || defined(CONFIG_BOOKE)) if (trap == 0x400) error_code &= 0x48200000; else is_write = error_code & DSISR_ISSTORE; #else is_write = error_code & ESR_DST; #endif if (notify_page_fault(regs)) return 0; if (unlikely(debugger_fault_handler(regs))) return 0; if (!user_mode(regs) && (address >= TASK_SIZE)) return SIGSEGV; #if !(defined(CONFIG_4xx) || defined(CONFIG_BOOKE) || \ defined(CONFIG_PPC_BOOK3S_64)) if (error_code & DSISR_DABRMATCH) { do_dabr(regs, address, error_code); return 0; } #endif if (in_atomic() || mm == NULL) { if (!user_mode(regs)) return SIGSEGV; printk(KERN_EMERG ""Page fault in user mode with "" ""in_atomic() = %d mm = %p\n"", in_atomic(), mm); printk(KERN_EMERG ""NIP = %lx MSR = %lx\n"", regs->nip, regs->msr); die(""Weird page fault"", regs, SIGSEGV); } <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address); <S2SV_EndVul> if (!down_read_trylock(&mm->mmap_sem)) { if (!user_mode(regs) && !search_exception_tables(regs->nip)) goto bad_area_nosemaphore; down_read(&mm->mmap_sem); } vma = find_vma(mm, address); if (!vma) goto bad_area; if (vma->vm_start <= address) goto good_area; if (!(vma->vm_flags & VM_GROWSDOWN)) goto bad_area; if (address + 0x100000 < vma->vm_end) { struct pt_regs *uregs = current->thread.regs; if (uregs == NULL) goto bad_area; if (address + 2048 < uregs->gpr[1] && (!user_mode(regs) || !store_updates_sp(regs))) goto bad_area; } if (expand_stack(vma, address)) goto bad_area; good_area: code = SEGV_ACCERR; #if defined(CONFIG_6xx) if (error_code & 0x95700000) goto bad_area; #endif #if defined(CONFIG_8xx) if (error_code & 0x40000000) _tlbil_va(address, 0, 0, 0); if (error_code & 0x10000000) goto bad_area; #endif if (is_exec) { #ifdef CONFIG_PPC_STD_MMU if (error_code & DSISR_PROTFAULT) goto bad_area; #endif if (!(vma->vm_flags & VM_EXEC) && (cpu_has_feature(CPU_FTR_NOEXECUTE) || !(vma->vm_flags & (VM_READ | VM_WRITE)))) goto bad_area; } else if (is_write) { if (!(vma->vm_flags & VM_WRITE)) goto bad_area; } else { if (error_code & 0x08000000) goto bad_area; if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))) goto bad_area; } ret = handle_mm_fault(mm, vma, address, is_write ? FAULT_FLAG_WRITE : 0); if (unlikely(ret & VM_FAULT_ERROR)) { if (ret & VM_FAULT_OOM) goto out_of_memory; else if (ret & VM_FAULT_SIGBUS) goto do_sigbus; BUG(); } if (ret & VM_FAULT_MAJOR) { current->maj_flt++; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, <S2SV_EndVul> regs, address); #ifdef CONFIG_PPC_SMLPAR if (firmware_has_feature(FW_FEATURE_CMO)) { preempt_disable(); get_lppaca()->page_ins += (1 << PAGE_FACTOR); preempt_enable(); } #endif } else { current->min_flt++; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, <S2SV_EndVul> regs, address); } up_read(&mm->mmap_sem); return 0; bad_area: up_read(&mm->mmap_sem); bad_area_nosemaphore: if (user_mode(regs)) { _exception(SIGSEGV, regs, code, address); return 0; } if (is_exec && (error_code & DSISR_PROTFAULT) && printk_ratelimit()) printk(KERN_CRIT ""kernel tried to execute NX-protected"" "" page (%lx) - exploit attempt? (uid: %d)\n"", address, current_uid()); return SIGSEGV; out_of_memory: up_read(&mm->mmap_sem); if (!user_mode(regs)) return SIGKILL; pagefault_out_of_memory(); return 0; do_sigbus: up_read(&mm->mmap_sem); if (user_mode(regs)) { info.si_signo = SIGBUS; info.si_errno = 0; info.si_code = BUS_ADRERR; info.si_addr = (void __user *)address; force_sig_info(SIGBUS, &info, current); return 0; } return SIGBUS; }","- perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);
- perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,
- perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,
+ perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
+ perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,
+ perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,","int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address, unsigned long error_code) { struct vm_area_struct * vma; struct mm_struct *mm = current->mm; siginfo_t info; int code = SEGV_MAPERR; int is_write = 0, ret; int trap = TRAP(regs); int is_exec = trap == 0x400; #if !(defined(CONFIG_4xx) || defined(CONFIG_BOOKE)) if (trap == 0x400) error_code &= 0x48200000; else is_write = error_code & DSISR_ISSTORE; #else is_write = error_code & ESR_DST; #endif if (notify_page_fault(regs)) return 0; if (unlikely(debugger_fault_handler(regs))) return 0; if (!user_mode(regs) && (address >= TASK_SIZE)) return SIGSEGV; #if !(defined(CONFIG_4xx) || defined(CONFIG_BOOKE) || \ defined(CONFIG_PPC_BOOK3S_64)) if (error_code & DSISR_DABRMATCH) { do_dabr(regs, address, error_code); return 0; } #endif if (in_atomic() || mm == NULL) { if (!user_mode(regs)) return SIGSEGV; printk(KERN_EMERG ""Page fault in user mode with "" ""in_atomic() = %d mm = %p\n"", in_atomic(), mm); printk(KERN_EMERG ""NIP = %lx MSR = %lx\n"", regs->nip, regs->msr); die(""Weird page fault"", regs, SIGSEGV); } perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address); if (!down_read_trylock(&mm->mmap_sem)) { if (!user_mode(regs) && !search_exception_tables(regs->nip)) goto bad_area_nosemaphore; down_read(&mm->mmap_sem); } vma = find_vma(mm, address); if (!vma) goto bad_area; if (vma->vm_start <= address) goto good_area; if (!(vma->vm_flags & VM_GROWSDOWN)) goto bad_area; if (address + 0x100000 < vma->vm_end) { struct pt_regs *uregs = current->thread.regs; if (uregs == NULL) goto bad_area; if (address + 2048 < uregs->gpr[1] && (!user_mode(regs) || !store_updates_sp(regs))) goto bad_area; } if (expand_stack(vma, address)) goto bad_area; good_area: code = SEGV_ACCERR; #if defined(CONFIG_6xx) if (error_code & 0x95700000) goto bad_area; #endif #if defined(CONFIG_8xx) if (error_code & 0x40000000) _tlbil_va(address, 0, 0, 0); if (error_code & 0x10000000) goto bad_area; #endif if (is_exec) { #ifdef CONFIG_PPC_STD_MMU if (error_code & DSISR_PROTFAULT) goto bad_area; #endif if (!(vma->vm_flags & VM_EXEC) && (cpu_has_feature(CPU_FTR_NOEXECUTE) || !(vma->vm_flags & (VM_READ | VM_WRITE)))) goto bad_area; } else if (is_write) { if (!(vma->vm_flags & VM_WRITE)) goto bad_area; } else { if (error_code & 0x08000000) goto bad_area; if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE))) goto bad_area; } ret = handle_mm_fault(mm, vma, address, is_write ? FAULT_FLAG_WRITE : 0); if (unlikely(ret & VM_FAULT_ERROR)) { if (ret & VM_FAULT_OOM) goto out_of_memory; else if (ret & VM_FAULT_SIGBUS) goto do_sigbus; BUG(); } if (ret & VM_FAULT_MAJOR) { current->maj_flt++; perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address); #ifdef CONFIG_PPC_SMLPAR if (firmware_has_feature(FW_FEATURE_CMO)) { preempt_disable(); get_lppaca()->page_ins += (1 << PAGE_FACTOR); preempt_enable(); } #endif } else { current->min_flt++; perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address); } up_read(&mm->mmap_sem); return 0; bad_area: up_read(&mm->mmap_sem); bad_area_nosemaphore: if (user_mode(regs)) { _exception(SIGSEGV, regs, code, address); return 0; } if (is_exec && (error_code & DSISR_PROTFAULT) && printk_ratelimit()) printk(KERN_CRIT ""kernel tried to execute NX-protected"" "" page (%lx) - exploit attempt? (uid: %d)\n"", address, current_uid()); return SIGSEGV; out_of_memory: up_read(&mm->mmap_sem); if (!user_mode(regs)) return SIGKILL; pagefault_out_of_memory(); return 0; do_sigbus: up_read(&mm->mmap_sem); if (user_mode(regs)) { info.si_signo = SIGBUS; info.si_errno = 0; info.si_code = BUS_ADRERR; info.si_addr = (void __user *)address; force_sig_info(SIGBUS, &info, current); return 0; } return SIGBUS; }"
916,6426----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/commissioner.cpp----ot::MeshCoP::Commissioner::AddJoiner,"otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout) { otError error = OT_ERROR_NO_BUFS; VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE); <S2SV_StartVul> VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS); <S2SV_EndVul> RemoveJoiner(aEui64, 0); for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++) { if (joiner->mValid) { continue; } if (aEui64 != NULL) { joiner->mEui64 = *aEui64; joiner->mAny = false; } else { joiner->mAny = true; } (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk)); joiner->mValid = true; joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout); UpdateJoinerExpirationTimer(); SendCommissionerSet(); otLogInfoMeshCoP(""Added Joiner (%s, %s)"", (aEui64 != NULL) ? aEui64->ToString().AsCString() : ""*"", aPskd); ExitNow(error = OT_ERROR_NONE); } exit: return error; }","- VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);
+ VerifyOrExit(strnlen(aPskd, Dtls::kPskMaxLength + 1) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);","otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout) { otError error = OT_ERROR_NO_BUFS; VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE); VerifyOrExit(strnlen(aPskd, Dtls::kPskMaxLength + 1) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS); RemoveJoiner(aEui64, 0); for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++) { if (joiner->mValid) { continue; } if (aEui64 != NULL) { joiner->mEui64 = *aEui64; joiner->mAny = false; } else { joiner->mAny = true; } (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk)); joiner->mValid = true; joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout); UpdateJoinerExpirationTimer(); SendCommissionerSet(); otLogInfoMeshCoP(""Added Joiner (%s, %s)"", (aEui64 != NULL) ? aEui64->ToString().AsCString() : ""*"", aPskd); ExitNow(error = OT_ERROR_NONE); } exit: return error; }"
917,5569----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/FontFileBase.h----NSFontConverter::CFontFileBase::CheckRegion,"<S2SV_StartVul> bool CheckRegion(int nPos, int nSize) <S2SV_EndVul> { <S2SV_StartVul> return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen); <S2SV_EndVul> }","- bool CheckRegion(int nPos, int nSize)
- return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);
+ bool CheckRegion(const unsigned int& nPos, const unsigned int& nSize)
+ return (m_nLen >= nSize && nPos <= (m_nLen - nSize));","bool CheckRegion(const unsigned int& nPos, const unsigned int& nSize) { return (m_nLen >= nSize && nPos <= (m_nLen - nSize)); }"
918,6115----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/process_keys.c----lookup_user_key,"key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags, key_perm_t perm) { struct keyring_search_context ctx = { .match_data.cmp = lookup_user_key_possessed, .match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT, .flags = KEYRING_SEARCH_NO_STATE_CHECK, }; struct request_key_auth *rka; struct key *key; key_ref_t key_ref, skey_ref; int ret; try_again: ctx.cred = get_current_cred(); key_ref = ERR_PTR(-ENOKEY); switch (id) { case KEY_SPEC_THREAD_KEYRING: if (!ctx.cred->thread_keyring) { if (!(lflags & KEY_LOOKUP_CREATE)) goto error; ret = install_thread_keyring(); if (ret < 0) { key_ref = ERR_PTR(ret); goto error; } goto reget_creds; } key = ctx.cred->thread_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_PROCESS_KEYRING: if (!ctx.cred->process_keyring) { if (!(lflags & KEY_LOOKUP_CREATE)) goto error; ret = install_process_keyring(); if (ret < 0) { key_ref = ERR_PTR(ret); goto error; } goto reget_creds; } key = ctx.cred->process_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_SESSION_KEYRING: if (!ctx.cred->session_keyring) { ret = install_user_keyrings(); if (ret < 0) goto error; if (lflags & KEY_LOOKUP_CREATE) ret = join_session_keyring(NULL); else ret = install_session_keyring( ctx.cred->user->session_keyring); if (ret < 0) goto error; goto reget_creds; } else if (ctx.cred->session_keyring == ctx.cred->user->session_keyring && lflags & KEY_LOOKUP_CREATE) { ret = join_session_keyring(NULL); if (ret < 0) goto error; goto reget_creds; } rcu_read_lock(); key = rcu_dereference(ctx.cred->session_keyring); __key_get(key); rcu_read_unlock(); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_USER_KEYRING: if (!ctx.cred->user->uid_keyring) { ret = install_user_keyrings(); if (ret < 0) goto error; } key = ctx.cred->user->uid_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_USER_SESSION_KEYRING: if (!ctx.cred->user->session_keyring) { ret = install_user_keyrings(); if (ret < 0) goto error; } key = ctx.cred->user->session_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_GROUP_KEYRING: key_ref = ERR_PTR(-EINVAL); goto error; case KEY_SPEC_REQKEY_AUTH_KEY: key = ctx.cred->request_key_auth; if (!key) goto error; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_REQUESTOR_KEYRING: if (!ctx.cred->request_key_auth) goto error; down_read(&ctx.cred->request_key_auth->sem); if (test_bit(KEY_FLAG_REVOKED, &ctx.cred->request_key_auth->flags)) { key_ref = ERR_PTR(-EKEYREVOKED); key = NULL; } else { rka = ctx.cred->request_key_auth->payload.data[0]; key = rka->dest_keyring; __key_get(key); } up_read(&ctx.cred->request_key_auth->sem); if (!key) goto error; key_ref = make_key_ref(key, 1); break; default: key_ref = ERR_PTR(-EINVAL); if (id < 1) goto error; key = key_lookup(id); if (IS_ERR(key)) { key_ref = ERR_CAST(key); goto error; } key_ref = make_key_ref(key, 0); ctx.index_key.type = key->type; ctx.index_key.description = key->description; ctx.index_key.desc_len = strlen(key->description); ctx.match_data.raw_data = key; kdebug(""check possessed""); skey_ref = search_process_keyrings(&ctx); kdebug(""possessed=%p"", skey_ref); if (!IS_ERR(skey_ref)) { key_put(key); key_ref = skey_ref; } break; } if (lflags & KEY_LOOKUP_FOR_UNLINK) { ret = 0; goto error; } if (!(lflags & KEY_LOOKUP_PARTIAL)) { ret = wait_for_key_construction(key, true); switch (ret) { case -ERESTARTSYS: goto invalid_key; default: if (perm) goto invalid_key; case 0: break; } } else if (perm) { ret = key_validate(key); if (ret < 0) goto invalid_key; } ret = -EIO; if (!(lflags & KEY_LOOKUP_PARTIAL) && <S2SV_StartVul> !test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) <S2SV_EndVul> goto invalid_key; ret = key_task_permission(key_ref, ctx.cred, perm); if (ret < 0) goto invalid_key; key->last_used_at = current_kernel_time().tv_sec; error: put_cred(ctx.cred); return key_ref; invalid_key: key_ref_put(key_ref); key_ref = ERR_PTR(ret); goto error; reget_creds: put_cred(ctx.cred); goto try_again; }","- !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
+ key_read_state(key) == KEY_IS_UNINSTANTIATED)","key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags, key_perm_t perm) { struct keyring_search_context ctx = { .match_data.cmp = lookup_user_key_possessed, .match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT, .flags = KEYRING_SEARCH_NO_STATE_CHECK, }; struct request_key_auth *rka; struct key *key; key_ref_t key_ref, skey_ref; int ret; try_again: ctx.cred = get_current_cred(); key_ref = ERR_PTR(-ENOKEY); switch (id) { case KEY_SPEC_THREAD_KEYRING: if (!ctx.cred->thread_keyring) { if (!(lflags & KEY_LOOKUP_CREATE)) goto error; ret = install_thread_keyring(); if (ret < 0) { key_ref = ERR_PTR(ret); goto error; } goto reget_creds; } key = ctx.cred->thread_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_PROCESS_KEYRING: if (!ctx.cred->process_keyring) { if (!(lflags & KEY_LOOKUP_CREATE)) goto error; ret = install_process_keyring(); if (ret < 0) { key_ref = ERR_PTR(ret); goto error; } goto reget_creds; } key = ctx.cred->process_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_SESSION_KEYRING: if (!ctx.cred->session_keyring) { ret = install_user_keyrings(); if (ret < 0) goto error; if (lflags & KEY_LOOKUP_CREATE) ret = join_session_keyring(NULL); else ret = install_session_keyring( ctx.cred->user->session_keyring); if (ret < 0) goto error; goto reget_creds; } else if (ctx.cred->session_keyring == ctx.cred->user->session_keyring && lflags & KEY_LOOKUP_CREATE) { ret = join_session_keyring(NULL); if (ret < 0) goto error; goto reget_creds; } rcu_read_lock(); key = rcu_dereference(ctx.cred->session_keyring); __key_get(key); rcu_read_unlock(); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_USER_KEYRING: if (!ctx.cred->user->uid_keyring) { ret = install_user_keyrings(); if (ret < 0) goto error; } key = ctx.cred->user->uid_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_USER_SESSION_KEYRING: if (!ctx.cred->user->session_keyring) { ret = install_user_keyrings(); if (ret < 0) goto error; } key = ctx.cred->user->session_keyring; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_GROUP_KEYRING: key_ref = ERR_PTR(-EINVAL); goto error; case KEY_SPEC_REQKEY_AUTH_KEY: key = ctx.cred->request_key_auth; if (!key) goto error; __key_get(key); key_ref = make_key_ref(key, 1); break; case KEY_SPEC_REQUESTOR_KEYRING: if (!ctx.cred->request_key_auth) goto error; down_read(&ctx.cred->request_key_auth->sem); if (test_bit(KEY_FLAG_REVOKED, &ctx.cred->request_key_auth->flags)) { key_ref = ERR_PTR(-EKEYREVOKED); key = NULL; } else { rka = ctx.cred->request_key_auth->payload.data[0]; key = rka->dest_keyring; __key_get(key); } up_read(&ctx.cred->request_key_auth->sem); if (!key) goto error; key_ref = make_key_ref(key, 1); break; default: key_ref = ERR_PTR(-EINVAL); if (id < 1) goto error; key = key_lookup(id); if (IS_ERR(key)) { key_ref = ERR_CAST(key); goto error; } key_ref = make_key_ref(key, 0); ctx.index_key.type = key->type; ctx.index_key.description = key->description; ctx.index_key.desc_len = strlen(key->description); ctx.match_data.raw_data = key; kdebug(""check possessed""); skey_ref = search_process_keyrings(&ctx); kdebug(""possessed=%p"", skey_ref); if (!IS_ERR(skey_ref)) { key_put(key); key_ref = skey_ref; } break; } if (lflags & KEY_LOOKUP_FOR_UNLINK) { ret = 0; goto error; } if (!(lflags & KEY_LOOKUP_PARTIAL)) { ret = wait_for_key_construction(key, true); switch (ret) { case -ERESTARTSYS: goto invalid_key; default: if (perm) goto invalid_key; case 0: break; } } else if (perm) { ret = key_validate(key); if (ret < 0) goto invalid_key; } ret = -EIO; if (!(lflags & KEY_LOOKUP_PARTIAL) && key_read_state(key) == KEY_IS_UNINSTANTIATED) goto invalid_key; ret = key_task_permission(key_ref, ctx.cred, perm); if (ret < 0) goto invalid_key; key->last_used_at = current_kernel_time().tv_sec; error: put_cred(ctx.cred); return key_ref; invalid_key: key_ref_put(key_ref); key_ref = ERR_PTR(ret); goto error; reget_creds: put_cred(ctx.cred); goto try_again; }"
919,3642----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ptrace.c----ptrace_hbptriggered,"<S2SV_StartVul> static void ptrace_hbptriggered(struct perf_event *bp, int unused, <S2SV_EndVul> struct perf_sample_data *data, struct pt_regs *regs) { struct arch_hw_breakpoint *bkpt = counter_arch_bp(bp); long num; int i; siginfo_t info; for (i = 0; i < ARM_MAX_HBP_SLOTS; ++i) if (current->thread.debug.hbp[i] == bp) break; num = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i); info.si_signo = SIGTRAP; info.si_errno = (int)num; info.si_code = TRAP_HWBKPT; info.si_addr = (void __user *)(bkpt->trigger); force_sig_info(SIGTRAP, &info, current); }","- static void ptrace_hbptriggered(struct perf_event *bp, int unused,
+ static void ptrace_hbptriggered(struct perf_event *bp,","static void ptrace_hbptriggered(struct perf_event *bp, struct perf_sample_data *data, struct pt_regs *regs) { struct arch_hw_breakpoint *bkpt = counter_arch_bp(bp); long num; int i; siginfo_t info; for (i = 0; i < ARM_MAX_HBP_SLOTS; ++i) if (current->thread.debug.hbp[i] == bp) break; num = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i); info.si_signo = SIGTRAP; info.si_errno = (int)num; info.si_code = TRAP_HWBKPT; info.si_addr = (void __user *)(bkpt->trigger); force_sig_info(SIGTRAP, &info, current); }"
920,4174----CWE-763----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spnego_mech.c----spnego_gss_verify_mic_iov,"spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t *qop_state, gss_iov_buffer_desc *iov, int iov_count) { <S2SV_StartVul> return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov, <S2SV_EndVul> iov_count); }","- return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,
+ spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;
+ if (sc->ctx_handle == GSS_C_NO_CONTEXT)
+ return (GSS_S_NO_CONTEXT);
+ return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,","spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t *qop_state, gss_iov_buffer_desc *iov, int iov_count) { spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle; if (sc->ctx_handle == GSS_C_NO_CONTEXT) return (GSS_S_NO_CONTEXT); return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov, iov_count); }"
921,1705----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10190--http.c----http_seek_internal,"static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect) { HTTPContext *s = h->priv_data; URLContext *old_hd = s->hd; int64_t old_off = s->off; uint8_t old_buf[BUFFER_SIZE]; int old_buf_size, ret; AVDictionary *options = NULL; if (whence == AVSEEK_SIZE) return s->filesize; else if (!force_reconnect && ((whence == SEEK_CUR && off == 0) || (whence == SEEK_SET && off == s->off))) return s->off; else if ((s->filesize == -1 && whence == SEEK_END)) return AVERROR(ENOSYS); <S2SV_StartVul> <S2SV_EndVul> if (whence == SEEK_CUR) off += s->off; else if (whence == SEEK_END) off += s->filesize; else if (whence != SEEK_SET) return AVERROR(EINVAL); if (off < 0) return AVERROR(EINVAL); <S2SV_StartVul> s->off = off; <S2SV_EndVul> <S2SV_StartVul> if (s->off && h->is_streamed) <S2SV_EndVul> return AVERROR(ENOSYS); old_buf_size = s->buf_end - s->buf_ptr; memcpy(old_buf, s->buf_ptr, old_buf_size); s->hd = NULL; if ((ret = http_open_cnx(h, &options)) < 0) { av_dict_free(&options); memcpy(s->buffer, old_buf, old_buf_size); s->buf_ptr = s->buffer; s->buf_end = s->buffer + old_buf_size; s->hd = old_hd; <S2SV_StartVul> s->off = old_off; <S2SV_EndVul> return ret; } av_dict_free(&options); ffurl_close(old_hd); <S2SV_StartVul> return off; <S2SV_EndVul> }","- 
- s->off = off;
- if (s->off && h->is_streamed)
- s->off = old_off;
- return off;
+ 
+ s->off = off;
+ if (s->off && h->is_streamed)
+ return AVERROR(ENOSYS);
+ s->hd = NULL;
+ 
+ if ((ret = http_open_cnx(h, &options)) < 0) {
+ av_dict_free(&options);
+ }","static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect) { HTTPContext *s = h->priv_data; URLContext *old_hd = s->hd; uint64_t old_off = s->off; uint8_t old_buf[BUFFER_SIZE]; int old_buf_size, ret; AVDictionary *options = NULL; if (whence == AVSEEK_SIZE) return s->filesize; else if (!force_reconnect && ((whence == SEEK_CUR && off == 0) || (whence == SEEK_SET && off == s->off))) return s->off; else if ((s->filesize == UINT64_MAX && whence == SEEK_END)) return AVERROR(ENOSYS); if (whence == SEEK_CUR) off += s->off; else if (whence == SEEK_END) off += s->filesize; else if (whence != SEEK_SET) return AVERROR(EINVAL); if (off < 0) return AVERROR(EINVAL); s->off = off; if (s->off && h->is_streamed) return AVERROR(ENOSYS); old_buf_size = s->buf_end - s->buf_ptr; memcpy(old_buf, s->buf_ptr, old_buf_size); s->hd = NULL; if ((ret = http_open_cnx(h, &options)) < 0) { av_dict_free(&options); memcpy(s->buffer, old_buf, old_buf_size); s->buf_ptr = s->buffer; s->buf_end = s->buffer + old_buf_size; s->hd = old_hd; s->off = old_off; return ret; } av_dict_free(&options); ffurl_close(old_hd); return off; }"
922,1967----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-15501--smart_pkt.c----ng_pkt,"static int ng_pkt(git_pkt **out, const char *line, size_t len) { git_pkt_ng *pkt; const char *ptr; size_t alloclen; pkt = git__malloc(sizeof(*pkt)); GITERR_CHECK_ALLOC(pkt); pkt->ref = NULL; pkt->type = GIT_PKT_NG; line += 3; <S2SV_StartVul> if (!(ptr = strchr(line, ' '))) <S2SV_EndVul> goto out_err; len = ptr - line; GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1); pkt->ref = git__malloc(alloclen); GITERR_CHECK_ALLOC(pkt->ref); memcpy(pkt->ref, line, len); pkt->ref[len] = '\0'; line = ptr + 1; <S2SV_StartVul> if (!(ptr = strchr(line, '\n'))) <S2SV_EndVul> goto out_err; len = ptr - line; GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1); pkt->msg = git__malloc(alloclen); GITERR_CHECK_ALLOC(pkt->msg); memcpy(pkt->msg, line, len); pkt->msg[len] = '\0'; *out = (git_pkt *)pkt; return 0; out_err: giterr_set(GITERR_NET, ""invalid packet line""); git__free(pkt->ref); git__free(pkt); return -1; }","- if (!(ptr = strchr(line, ' ')))
- if (!(ptr = strchr(line, '\n')))
+ if (len < 3)
+ goto out_err;
+ len -= 3;
+ if (!(ptr = memchr(line, ' ', len)))
+ if (len < 1)
+ goto out_err;
+ len -= 1;
+ if (!(ptr = memchr(line, '\n', len)))","static int ng_pkt(git_pkt **out, const char *line, size_t len) { git_pkt_ng *pkt; const char *ptr; size_t alloclen; pkt = git__malloc(sizeof(*pkt)); GITERR_CHECK_ALLOC(pkt); pkt->ref = NULL; pkt->type = GIT_PKT_NG; if (len < 3) goto out_err; line += 3; len -= 3; if (!(ptr = memchr(line, ' ', len))) goto out_err; len = ptr - line; GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1); pkt->ref = git__malloc(alloclen); GITERR_CHECK_ALLOC(pkt->ref); memcpy(pkt->ref, line, len); pkt->ref[len] = '\0'; if (len < 1) goto out_err; line = ptr + 1; len -= 1; if (!(ptr = memchr(line, '\n', len))) goto out_err; len = ptr - line; GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1); pkt->msg = git__malloc(alloclen); GITERR_CHECK_ALLOC(pkt->msg); memcpy(pkt->msg, line, len); pkt->msg[len] = '\0'; *out = (git_pkt *)pkt; return 0; out_err: giterr_set(GITERR_NET, ""invalid packet line""); git__free(pkt->ref); git__free(pkt); return -1; }"
923,3069----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/k5sealiov.c----kg_seal_iov,"kg_seal_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, int *conf_state, gss_iov_buffer_desc *iov, int iov_count, int toktype) { krb5_gss_ctx_id_rec *ctx; krb5_error_code code; krb5_context context; if (qop_req != 0) { *minor_status = (OM_uint32)G_UNKNOWN_QOP; return GSS_S_FAILURE; } ctx = (krb5_gss_ctx_id_rec *)context_handle; <S2SV_StartVul> if (!ctx->established) { <S2SV_EndVul> *minor_status = KG_CTX_INCOMPLETE; return GSS_S_NO_CONTEXT; } if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) { conf_req_flag = FALSE; } context = ctx->k5_context; switch (ctx->proto) { case 0: code = make_seal_token_v1_iov(context, ctx, conf_req_flag, conf_state, iov, iov_count, toktype); break; case 1: code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag, conf_state, iov, iov_count, toktype); break; default: code = G_UNKNOWN_QOP; break; } if (code != 0) { *minor_status = code; save_error_info(*minor_status, context); return GSS_S_FAILURE; } *minor_status = 0; return GSS_S_COMPLETE; }","- if (!ctx->established) {
+ if (ctx->terminated || !ctx->established) {","kg_seal_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, int conf_req_flag, gss_qop_t qop_req, int *conf_state, gss_iov_buffer_desc *iov, int iov_count, int toktype) { krb5_gss_ctx_id_rec *ctx; krb5_error_code code; krb5_context context; if (qop_req != 0) { *minor_status = (OM_uint32)G_UNKNOWN_QOP; return GSS_S_FAILURE; } ctx = (krb5_gss_ctx_id_rec *)context_handle; if (ctx->terminated || !ctx->established) { *minor_status = KG_CTX_INCOMPLETE; return GSS_S_NO_CONTEXT; } if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) { conf_req_flag = FALSE; } context = ctx->k5_context; switch (ctx->proto) { case 0: code = make_seal_token_v1_iov(context, ctx, conf_req_flag, conf_state, iov, iov_count, toktype); break; case 1: code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag, conf_state, iov, iov_count, toktype); break; default: code = G_UNKNOWN_QOP; break; } if (code != 0) { *minor_status = code; save_error_info(*minor_status, context); return GSS_S_FAILURE; } *minor_status = 0; return GSS_S_COMPLETE; }"
924,3163----CWE-502----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/swoole_serialize.c----swoole_unserialize_object,"static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag) { zval property; uint32_t arr_num = 0; size_t name_len = *((unsigned short*) buffer); if (!name_len) { php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal unserialize data""); return NULL; } buffer += 2; zend_string *class_name; <S2SV_StartVul> if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS) <S2SV_EndVul> { class_name = swoole_string_init(ZEND_STRL(""StdClass"")); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> else <S2SV_EndVul> { class_name = swoole_string_init((char*) buffer, name_len); } buffer += name_len; zend_class_entry *ce = swoole_try_get_ce(class_name); swoole_string_release(class_name); if (!ce) { return NULL; } buffer = get_array_real_len(buffer, bucket_len, &arr_num); buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag); object_init_ex(return_value, ce); <S2SV_StartVul> zval *data,*d; <S2SV_EndVul> zend_string *key; zend_ulong index; ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data) { const char *prop_name, *tmp; size_t prop_len; if (key) { if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL) { if (Z_TYPE_P(d) == IS_INDIRECT) { d = Z_INDIRECT_P(d); } zval_dtor(d); ZVAL_COPY(d, data); } else { zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len); zend_update_property(ce, return_value, prop_name, prop_len, data); } } else { zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data); } } ZEND_HASH_FOREACH_END(); zval_dtor(&property); if (ce->constructor) { } if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(""__wakeup""))) { zval ret, wakeup; zend_string *fname = swoole_string_init(ZEND_STRL(""__wakeup"")); Z_STR(wakeup) = fname; Z_TYPE_INFO(wakeup) = IS_STRING_EX; call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL); swoole_string_release(fname); zval_ptr_dtor(&ret); } return buffer; }","- if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)
- }
- else
- zval *data,*d;
+ CHECK_STEP;
+ if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS)
+ }
+ else
+ CHECK_STEP;
+ zval *data, *d;
+ CHECK_STEP;","static void* swoole_unserialize_object(void *buffer, zval *return_value, zend_uchar bucket_len, zval *args, long flag) { zval property; uint32_t arr_num = 0; size_t name_len = *((unsigned short*) buffer); CHECK_STEP; if (!name_len) { php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""illegal unserialize data""); return NULL; } buffer += 2; zend_string *class_name; if (flag == UNSERIALIZE_OBJECT_TO_STDCLASS) { class_name = swoole_string_init(ZEND_STRL(""StdClass"")); } else { class_name = swoole_string_init((char*) buffer, name_len); } buffer += name_len; zend_class_entry *ce = swoole_try_get_ce(class_name); swoole_string_release(class_name); CHECK_STEP; if (!ce) { return NULL; } buffer = get_array_real_len(buffer, bucket_len, &arr_num); buffer = swoole_unserialize_arr(buffer, &property, arr_num, flag); object_init_ex(return_value, ce); zval *data, *d; zend_string *key; zend_ulong index; ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL(property), index, key, data) { const char *prop_name, *tmp; size_t prop_len; if (key) { if ((d = zend_hash_find(Z_OBJPROP_P(return_value), key)) != NULL) { if (Z_TYPE_P(d) == IS_INDIRECT) { d = Z_INDIRECT_P(d); } zval_dtor(d); ZVAL_COPY(d, data); } else { zend_unmangle_property_name_ex(key, &tmp, &prop_name, &prop_len); zend_update_property(ce, return_value, prop_name, prop_len, data); } } else { zend_hash_next_index_insert(Z_OBJPROP_P(return_value), data); } } ZEND_HASH_FOREACH_END(); zval_dtor(&property); if (ce->constructor) { } if (zend_hash_str_exists(&ce->function_table, ZEND_STRL(""__wakeup""))) { zval ret, wakeup; zend_string *fname = swoole_string_init(ZEND_STRL(""__wakeup"")); Z_STR(wakeup) = fname; Z_TYPE_INFO(wakeup) = IS_STRING_EX; call_user_function_ex(CG(function_table), return_value, &wakeup, &ret, 0, NULL, 1, NULL); swoole_string_release(fname); zval_ptr_dtor(&ret); } CHECK_STEP; return buffer; }"
925,6762----CWE-19----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/socket.c----__sys_recvmmsg,"int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags, struct timespec *timeout) { int fput_needed, err, datagrams; struct socket *sock; struct mmsghdr __user *entry; struct compat_mmsghdr __user *compat_entry; struct msghdr msg_sys; struct timespec end_time; if (timeout && poll_select_set_timeout(&end_time, timeout->tv_sec, timeout->tv_nsec)) return -EINVAL; datagrams = 0; sock = sockfd_lookup_light(fd, &err, &fput_needed); if (!sock) return err; err = sock_error(sock->sk); if (err) goto out_put; entry = mmsg; compat_entry = (struct compat_mmsghdr __user *)mmsg; while (datagrams < vlen) { if (MSG_CMSG_COMPAT & flags) { err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry, &msg_sys, flags & ~MSG_WAITFORONE, datagrams); if (err < 0) break; err = __put_user(err, &compat_entry->msg_len); ++compat_entry; } else { err = ___sys_recvmsg(sock, (struct user_msghdr __user *)entry, &msg_sys, flags & ~MSG_WAITFORONE, datagrams); if (err < 0) break; err = put_user(err, &entry->msg_len); ++entry; } if (err) break; ++datagrams; if (flags & MSG_WAITFORONE) flags |= MSG_DONTWAIT; if (timeout) { ktime_get_ts(timeout); *timeout = timespec_sub(end_time, *timeout); if (timeout->tv_sec < 0) { timeout->tv_sec = timeout->tv_nsec = 0; break; } if (timeout->tv_nsec == 0 && timeout->tv_sec == 0) break; } if (msg_sys.msg_flags & MSG_OOB) break; cond_resched(); } <S2SV_StartVul> out_put: <S2SV_EndVul> <S2SV_StartVul> fput_light(sock->file, fput_needed); <S2SV_EndVul> if (err == 0) <S2SV_StartVul> return datagrams; <S2SV_EndVul> <S2SV_StartVul> if (datagrams != 0) { <S2SV_EndVul> <S2SV_StartVul> if (err != -EAGAIN) { <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> sock->sk->sk_err = -err; <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> return datagrams; <S2SV_EndVul> } <S2SV_StartVul> return err; <S2SV_EndVul> }","- out_put:
- fput_light(sock->file, fput_needed);
- return datagrams;
- if (datagrams != 0) {
- if (err != -EAGAIN) {
- sock->sk->sk_err = -err;
- }
- return datagrams;
- return err;
+ goto out_put;
+ if (datagrams == 0) {
+ datagrams = err;
+ goto out_put;
+ }
+ if (err != -EAGAIN) {
+ sock->sk->sk_err = -err;
+ out_put:
+ fput_light(sock->file, fput_needed);
+ return datagrams;","int __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags, struct timespec *timeout) { int fput_needed, err, datagrams; struct socket *sock; struct mmsghdr __user *entry; struct compat_mmsghdr __user *compat_entry; struct msghdr msg_sys; struct timespec end_time; if (timeout && poll_select_set_timeout(&end_time, timeout->tv_sec, timeout->tv_nsec)) return -EINVAL; datagrams = 0; sock = sockfd_lookup_light(fd, &err, &fput_needed); if (!sock) return err; err = sock_error(sock->sk); if (err) goto out_put; entry = mmsg; compat_entry = (struct compat_mmsghdr __user *)mmsg; while (datagrams < vlen) { if (MSG_CMSG_COMPAT & flags) { err = ___sys_recvmsg(sock, (struct user_msghdr __user *)compat_entry, &msg_sys, flags & ~MSG_WAITFORONE, datagrams); if (err < 0) break; err = __put_user(err, &compat_entry->msg_len); ++compat_entry; } else { err = ___sys_recvmsg(sock, (struct user_msghdr __user *)entry, &msg_sys, flags & ~MSG_WAITFORONE, datagrams); if (err < 0) break; err = put_user(err, &entry->msg_len); ++entry; } if (err) break; ++datagrams; if (flags & MSG_WAITFORONE) flags |= MSG_DONTWAIT; if (timeout) { ktime_get_ts(timeout); *timeout = timespec_sub(end_time, *timeout); if (timeout->tv_sec < 0) { timeout->tv_sec = timeout->tv_nsec = 0; break; } if (timeout->tv_nsec == 0 && timeout->tv_sec == 0) break; } if (msg_sys.msg_flags & MSG_OOB) break; cond_resched(); } if (err == 0) goto out_put; if (datagrams == 0) { datagrams = err; goto out_put; } if (err != -EAGAIN) { sock->sk->sk_err = -err; } out_put: fput_light(sock->file, fput_needed); return datagrams; }"
926,5578----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/FontFileBase.h----NSFontConverter::CFontFileBase::Read,"<S2SV_StartVul> int Read(void* pDestBuffer, int nSize) <S2SV_EndVul> { <S2SV_StartVul> if ( m_nPos + nSize >= m_nLen ) <S2SV_EndVul> <S2SV_StartVul> nSize = m_nLen - m_nPos - 1; <S2SV_EndVul> memcpy( pDestBuffer, (m_sFile + m_nPos), nSize ); m_nPos += nSize; return nSize; }","- int Read(void* pDestBuffer, int nSize)
- if ( m_nPos + nSize >= m_nLen )
- nSize = m_nLen - m_nPos - 1;
+ int Read(void* pDestBuffer, unsigned int nSize)
+ if (m_nPos >= m_nLen)
+ nSize = 0;
+ else if (nSize > (m_nLen - m_nPos))
+ nSize = m_nLen - m_nPos;","int Read(void* pDestBuffer, unsigned int nSize) { if (m_nPos >= m_nLen) nSize = 0; else if (nSize > (m_nLen - m_nPos)) nSize = m_nLen - m_nPos; memcpy( pDestBuffer, (m_sFile + m_nPos), nSize ); m_nPos += nSize; return nSize; }"
927,6274----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/httpLib.c----httpAddDefense,"PUBLIC int httpAddDefense(cchar *name, cchar *remedy, cchar *remedyArgs) { Http *http; MprHash *args; MprList *list; char *arg, *key, *value; int next; assert(name && *name); http = HTTP; args = mprCreateHash(0, MPR_HASH_STABLE); list = stolist(remedyArgs); for (ITERATE_ITEMS(list, arg, next)) { <S2SV_StartVul> key = stok(arg, ""="", &value); <S2SV_EndVul> mprAddKey(args, key, strim(value, ""\""'"", 0)); } if (!remedy) { remedy = mprLookupKey(args, ""REMEDY""); } mprAddKey(http->defenses, name, createDefense(name, remedy, args)); return 0; }","- key = stok(arg, ""="", &value);
+ key = ssplit(arg, ""="", &value);","PUBLIC int httpAddDefense(cchar *name, cchar *remedy, cchar *remedyArgs) { Http *http; MprHash *args; MprList *list; char *arg, *key, *value; int next; assert(name && *name); http = HTTP; args = mprCreateHash(0, MPR_HASH_STABLE); list = stolist(remedyArgs); for (ITERATE_ITEMS(list, arg, next)) { key = ssplit(arg, ""="", &value); mprAddKey(args, key, strim(value, ""\""'"", 0)); } if (!remedy) { remedy = mprLookupKey(args, ""REMEDY""); } mprAddKey(http->defenses, name, createDefense(name, remedy, args)); return 0; }"
928,6593----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/http.c----http_seek_internal,"static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect) { HTTPContext *s = h->priv_data; URLContext *old_hd = s->hd; <S2SV_StartVul> int64_t old_off = s->off; <S2SV_EndVul> uint8_t old_buf[BUFFER_SIZE]; int old_buf_size, ret; AVDictionary *options = NULL; if (whence == AVSEEK_SIZE) return s->filesize; else if (!force_reconnect && ((whence == SEEK_CUR && off == 0) || (whence == SEEK_SET && off == s->off))) return s->off; <S2SV_StartVul> else if ((s->filesize == -1 && whence == SEEK_END)) <S2SV_EndVul> return AVERROR(ENOSYS); if (whence == SEEK_CUR) off += s->off; else if (whence == SEEK_END) off += s->filesize; else if (whence != SEEK_SET) return AVERROR(EINVAL); if (off < 0) return AVERROR(EINVAL); s->off = off; if (s->off && h->is_streamed) return AVERROR(ENOSYS); old_buf_size = s->buf_end - s->buf_ptr; memcpy(old_buf, s->buf_ptr, old_buf_size); s->hd = NULL; if ((ret = http_open_cnx(h, &options)) < 0) { av_dict_free(&options); memcpy(s->buffer, old_buf, old_buf_size); s->buf_ptr = s->buffer; s->buf_end = s->buffer + old_buf_size; s->hd = old_hd; s->off = old_off; return ret; } av_dict_free(&options); ffurl_close(old_hd); return off; }","- int64_t old_off = s->off;
- else if ((s->filesize == -1 && whence == SEEK_END))
+ uint64_t old_off = s->off;
+ else if ((s->filesize == UINT64_MAX && whence == SEEK_END))","static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect) { HTTPContext *s = h->priv_data; URLContext *old_hd = s->hd; uint64_t old_off = s->off; uint8_t old_buf[BUFFER_SIZE]; int old_buf_size, ret; AVDictionary *options = NULL; if (whence == AVSEEK_SIZE) return s->filesize; else if (!force_reconnect && ((whence == SEEK_CUR && off == 0) || (whence == SEEK_SET && off == s->off))) return s->off; else if ((s->filesize == UINT64_MAX && whence == SEEK_END)) return AVERROR(ENOSYS); if (whence == SEEK_CUR) off += s->off; else if (whence == SEEK_END) off += s->filesize; else if (whence != SEEK_SET) return AVERROR(EINVAL); if (off < 0) return AVERROR(EINVAL); s->off = off; if (s->off && h->is_streamed) return AVERROR(ENOSYS); old_buf_size = s->buf_end - s->buf_ptr; memcpy(old_buf, s->buf_ptr, old_buf_size); s->hd = NULL; if ((ret = http_open_cnx(h, &options)) < 0) { av_dict_free(&options); memcpy(s->buffer, old_buf, old_buf_size); s->buf_ptr = s->buffer; s->buf_end = s->buffer + old_buf_size; s->hd = old_hd; s->off = old_off; return ret; } av_dict_free(&options); ffurl_close(old_hd); return off; }"
929,6773----CWE-310----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hashtable.c----hashtable_do_rehash,"static int hashtable_do_rehash(hashtable_t *hashtable) { list_t *list, *next; pair_t *pair; size_t i, index, new_size; jsonp_free(hashtable->buckets); <S2SV_StartVul> hashtable->num_buckets++; <S2SV_EndVul> <S2SV_StartVul> new_size = num_buckets(hashtable); <S2SV_EndVul> hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t)); if(!hashtable->buckets) return -1; <S2SV_StartVul> for(i = 0; i < num_buckets(hashtable); i++) <S2SV_EndVul> { hashtable->buckets[i].first = hashtable->buckets[i].last = &hashtable->list; } list = hashtable->list.next; list_init(&hashtable->list); for(; list != &hashtable->list; list = next) { next = list->next; pair = list_to_pair(list); index = pair->hash % new_size; insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list); } return 0; }","- hashtable->num_buckets++;
- new_size = num_buckets(hashtable);
- for(i = 0; i < num_buckets(hashtable); i++)
+ hashtable->order++;
+ new_size = hashsize(hashtable->order);
+ for(i = 0; i < hashsize(hashtable->order); i++)","static int hashtable_do_rehash(hashtable_t *hashtable) { list_t *list, *next; pair_t *pair; size_t i, index, new_size; jsonp_free(hashtable->buckets); hashtable->order++; new_size = hashsize(hashtable->order); hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t)); if(!hashtable->buckets) return -1; for(i = 0; i < hashsize(hashtable->order); i++) { hashtable->buckets[i].first = hashtable->buckets[i].last = &hashtable->list; } list = hashtable->list.next; list_init(&hashtable->list); for(; list != &hashtable->list; list = next) { next = list->next; pair = list_to_pair(list); index = pair->hash % new_size; insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list); } return 0; }"
930,2539----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-10156--timer.c----timer_enter_running,"static void timer_enter_running(Timer *t) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL; int r; assert(t); if (unit_stop_pending(UNIT(t))) return; r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)), JOB_REPLACE, true, &error, NULL); if (r < 0) goto fail; dual_timestamp_get(&t->last_trigger); if (t->stamp_path) <S2SV_StartVul> touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0); <S2SV_EndVul> timer_set_state(t, TIMER_RUNNING); return; fail: log_unit_warning(UNIT(t), ""Failed to queue unit startup job: %s"", bus_error_message(&error, r)); timer_enter_dead(t, TIMER_FAILURE_RESOURCES); }","- touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);
+ touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, MODE_INVALID);","static void timer_enter_running(Timer *t) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL; int r; assert(t); if (unit_stop_pending(UNIT(t))) return; r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)), JOB_REPLACE, true, &error, NULL); if (r < 0) goto fail; dual_timestamp_get(&t->last_trigger); if (t->stamp_path) touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, MODE_INVALID); timer_set_state(t, TIMER_RUNNING); return; fail: log_unit_warning(UNIT(t), ""Failed to queue unit startup job: %s"", bus_error_message(&error, r)); timer_enter_dead(t, TIMER_FAILURE_RESOURCES); }"
931,429----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-4299--dm-snap-persistent.c----persistent_prepare_exception,"static int persistent_prepare_exception(struct dm_exception_store *store, struct dm_exception *e) { struct pstore *ps = get_info(store); <S2SV_StartVul> uint32_t stride; <S2SV_EndVul> <S2SV_StartVul> chunk_t next_free; <S2SV_EndVul> sector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev); if (size < ((ps->next_free + 1) * store->chunk_size)) return -ENOSPC; e->new_chunk = ps->next_free; <S2SV_StartVul> stride = (ps->exceptions_per_area + 1); <S2SV_EndVul> <S2SV_StartVul> next_free = ++ps->next_free; <S2SV_EndVul> <S2SV_StartVul> if (sector_div(next_free, stride) == 1) <S2SV_EndVul> <S2SV_StartVul> ps->next_free++; <S2SV_EndVul> atomic_inc(&ps->pending_count); return 0; }","- uint32_t stride;
- chunk_t next_free;
- stride = (ps->exceptions_per_area + 1);
- next_free = ++ps->next_free;
- if (sector_div(next_free, stride) == 1)
- ps->next_free++;
+ ps->next_free++;
+ skip_metadata(ps);","static int persistent_prepare_exception(struct dm_exception_store *store, struct dm_exception *e) { struct pstore *ps = get_info(store); sector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev); if (size < ((ps->next_free + 1) * store->chunk_size)) return -ENOSPC; e->new_chunk = ps->next_free; ps->next_free++; skip_metadata(ps); atomic_inc(&ps->pending_count); return 0; }"
932,2460----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-7163--pi.c----*opj_pi_create_decode,"opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image, opj_cp_t *p_cp, OPJ_UINT32 p_tile_no) { OPJ_UINT32 pino; OPJ_UINT32 compno, resno; OPJ_UINT32 * l_tmp_data; OPJ_UINT32 ** l_tmp_ptr; OPJ_UINT32 l_max_res; OPJ_UINT32 l_max_prec; OPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1; OPJ_UINT32 l_dx_min,l_dy_min; OPJ_UINT32 l_bound; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride; opj_pi_iterator_t *l_pi = 00; opj_tcp_t *l_tcp = 00; const opj_tccp_t *l_tccp = 00; opj_pi_comp_t *l_current_comp = 00; opj_image_comp_t * l_img_comp = 00; opj_pi_iterator_t * l_current_pi = 00; OPJ_UINT32 * l_encoding_value_ptr = 00; assert(p_cp != 00); assert(p_image != 00); assert(p_tile_no < p_cp->tw * p_cp->th); l_tcp = &p_cp->tcps[p_tile_no]; l_bound = l_tcp->numpocs+1; l_data_stride = 4 * OPJ_J2K_MAXRLVLS; l_tmp_data = (OPJ_UINT32*)opj_malloc( l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32)); if (! l_tmp_data) { return 00; } l_tmp_ptr = (OPJ_UINT32**)opj_malloc( p_image->numcomps * sizeof(OPJ_UINT32 *)); if (! l_tmp_ptr) { opj_free(l_tmp_data); return 00; } l_pi = opj_pi_create(p_image, p_cp, p_tile_no); if (!l_pi) { opj_free(l_tmp_data); opj_free(l_tmp_ptr); return 00; } l_encoding_value_ptr = l_tmp_data; for (compno = 0; compno < p_image->numcomps; ++compno) { l_tmp_ptr[compno] = l_encoding_value_ptr; l_encoding_value_ptr += l_data_stride; } opj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr); l_step_p = 1; l_step_c = l_max_prec * l_step_p; l_step_r = p_image->numcomps * l_step_c; l_step_l = l_max_res * l_step_r; l_current_pi = l_pi; l_current_pi->include = 00; if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U))) { <S2SV_StartVul> l_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16)); <S2SV_EndVul> } if (!l_current_pi->include) { opj_free(l_tmp_data); opj_free(l_tmp_ptr); opj_pi_destroy(l_pi, l_bound); return 00; } l_current_comp = l_current_pi->comps; l_img_comp = p_image->comps; l_tccp = l_tcp->tccps; l_current_pi->tx0 = l_tx0; l_current_pi->ty0 = l_ty0; l_current_pi->tx1 = l_tx1; l_current_pi->ty1 = l_ty1; l_current_pi->step_p = l_step_p; l_current_pi->step_c = l_step_c; l_current_pi->step_r = l_step_r; l_current_pi->step_l = l_step_l; for (compno = 0; compno < l_current_pi->numcomps; ++compno) { opj_pi_resolution_t *l_res = l_current_comp->resolutions; l_encoding_value_ptr = l_tmp_ptr[compno]; l_current_comp->dx = l_img_comp->dx; l_current_comp->dy = l_img_comp->dy; for (resno = 0; resno < l_current_comp->numresolutions; resno++) { l_res->pdx = *(l_encoding_value_ptr++); l_res->pdy = *(l_encoding_value_ptr++); l_res->pw = *(l_encoding_value_ptr++); l_res->ph = *(l_encoding_value_ptr++); ++l_res; } ++l_current_comp; ++l_img_comp; ++l_tccp; } ++l_current_pi; for (pino = 1 ; pino<l_bound ; ++pino ) { l_current_comp = l_current_pi->comps; l_img_comp = p_image->comps; l_tccp = l_tcp->tccps; l_current_pi->tx0 = l_tx0; l_current_pi->ty0 = l_ty0; l_current_pi->tx1 = l_tx1; l_current_pi->ty1 = l_ty1; l_current_pi->step_p = l_step_p; l_current_pi->step_c = l_step_c; l_current_pi->step_r = l_step_r; l_current_pi->step_l = l_step_l; for (compno = 0; compno < l_current_pi->numcomps; ++compno) { opj_pi_resolution_t *l_res = l_current_comp->resolutions; l_encoding_value_ptr = l_tmp_ptr[compno]; l_current_comp->dx = l_img_comp->dx; l_current_comp->dy = l_img_comp->dy; for (resno = 0; resno < l_current_comp->numresolutions; resno++) { l_res->pdx = *(l_encoding_value_ptr++); l_res->pdy = *(l_encoding_value_ptr++); l_res->pw = *(l_encoding_value_ptr++); l_res->ph = *(l_encoding_value_ptr++); ++l_res; } ++l_current_comp; ++l_img_comp; ++l_tccp; } l_current_pi->include = (l_current_pi-1)->include; ++l_current_pi; } opj_free(l_tmp_data); l_tmp_data = 00; opj_free(l_tmp_ptr); l_tmp_ptr = 00; if (l_tcp->POC) { opj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res); } else { opj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res); } return l_pi; }","- l_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));
+ l_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));","opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image, opj_cp_t *p_cp, OPJ_UINT32 p_tile_no) { OPJ_UINT32 pino; OPJ_UINT32 compno, resno; OPJ_UINT32 * l_tmp_data; OPJ_UINT32 ** l_tmp_ptr; OPJ_UINT32 l_max_res; OPJ_UINT32 l_max_prec; OPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1; OPJ_UINT32 l_dx_min,l_dy_min; OPJ_UINT32 l_bound; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride; opj_pi_iterator_t *l_pi = 00; opj_tcp_t *l_tcp = 00; const opj_tccp_t *l_tccp = 00; opj_pi_comp_t *l_current_comp = 00; opj_image_comp_t * l_img_comp = 00; opj_pi_iterator_t * l_current_pi = 00; OPJ_UINT32 * l_encoding_value_ptr = 00; assert(p_cp != 00); assert(p_image != 00); assert(p_tile_no < p_cp->tw * p_cp->th); l_tcp = &p_cp->tcps[p_tile_no]; l_bound = l_tcp->numpocs+1; l_data_stride = 4 * OPJ_J2K_MAXRLVLS; l_tmp_data = (OPJ_UINT32*)opj_malloc( l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32)); if (! l_tmp_data) { return 00; } l_tmp_ptr = (OPJ_UINT32**)opj_malloc( p_image->numcomps * sizeof(OPJ_UINT32 *)); if (! l_tmp_ptr) { opj_free(l_tmp_data); return 00; } l_pi = opj_pi_create(p_image, p_cp, p_tile_no); if (!l_pi) { opj_free(l_tmp_data); opj_free(l_tmp_ptr); return 00; } l_encoding_value_ptr = l_tmp_data; for (compno = 0; compno < p_image->numcomps; ++compno) { l_tmp_ptr[compno] = l_encoding_value_ptr; l_encoding_value_ptr += l_data_stride; } opj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr); l_step_p = 1; l_step_c = l_max_prec * l_step_p; l_step_r = p_image->numcomps * l_step_c; l_step_l = l_max_res * l_step_r; l_current_pi = l_pi; l_current_pi->include = 00; if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U))) { l_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16)); } if (!l_current_pi->include) { opj_free(l_tmp_data); opj_free(l_tmp_ptr); opj_pi_destroy(l_pi, l_bound); return 00; } l_current_comp = l_current_pi->comps; l_img_comp = p_image->comps; l_tccp = l_tcp->tccps; l_current_pi->tx0 = l_tx0; l_current_pi->ty0 = l_ty0; l_current_pi->tx1 = l_tx1; l_current_pi->ty1 = l_ty1; l_current_pi->step_p = l_step_p; l_current_pi->step_c = l_step_c; l_current_pi->step_r = l_step_r; l_current_pi->step_l = l_step_l; for (compno = 0; compno < l_current_pi->numcomps; ++compno) { opj_pi_resolution_t *l_res = l_current_comp->resolutions; l_encoding_value_ptr = l_tmp_ptr[compno]; l_current_comp->dx = l_img_comp->dx; l_current_comp->dy = l_img_comp->dy; for (resno = 0; resno < l_current_comp->numresolutions; resno++) { l_res->pdx = *(l_encoding_value_ptr++); l_res->pdy = *(l_encoding_value_ptr++); l_res->pw = *(l_encoding_value_ptr++); l_res->ph = *(l_encoding_value_ptr++); ++l_res; } ++l_current_comp; ++l_img_comp; ++l_tccp; } ++l_current_pi; for (pino = 1 ; pino<l_bound ; ++pino ) { l_current_comp = l_current_pi->comps; l_img_comp = p_image->comps; l_tccp = l_tcp->tccps; l_current_pi->tx0 = l_tx0; l_current_pi->ty0 = l_ty0; l_current_pi->tx1 = l_tx1; l_current_pi->ty1 = l_ty1; l_current_pi->step_p = l_step_p; l_current_pi->step_c = l_step_c; l_current_pi->step_r = l_step_r; l_current_pi->step_l = l_step_l; for (compno = 0; compno < l_current_pi->numcomps; ++compno) { opj_pi_resolution_t *l_res = l_current_comp->resolutions; l_encoding_value_ptr = l_tmp_ptr[compno]; l_current_comp->dx = l_img_comp->dx; l_current_comp->dy = l_img_comp->dy; for (resno = 0; resno < l_current_comp->numresolutions; resno++) { l_res->pdx = *(l_encoding_value_ptr++); l_res->pdy = *(l_encoding_value_ptr++); l_res->pw = *(l_encoding_value_ptr++); l_res->ph = *(l_encoding_value_ptr++); ++l_res; } ++l_current_comp; ++l_img_comp; ++l_tccp; } l_current_pi->include = (l_current_pi-1)->include; ++l_current_pi; } opj_free(l_tmp_data); l_tmp_data = 00; opj_free(l_tmp_ptr); l_tmp_ptr = 00; if (l_tcp->POC) { opj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res); } else { opj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res); } return l_pi; }"
933,7418----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/axohelp.c----ReadInput,"char *ReadInput(char *filename) { FILE *finput; long filesize, num; char *buffer; if ( ( finput = fopen(filename,""r"") ) == 0 ) { fprintf(stderr,""%s: Cannot open file %s\n"",axohelp,filename); <S2SV_StartVul> exit(-1); <S2SV_EndVul> } if ( ( fseek(finput,0,SEEK_END) != 0 ) || ( ( filesize = ftell(finput) ) < 0 ) || ( fseek(finput,0,SEEK_SET) != 0 ) ) { fprintf(stderr,""%s: File error in file %s\n"",axohelp,filename); <S2SV_StartVul> exit(-1); <S2SV_EndVul> } if ( ( buffer = malloc((filesize+1)*sizeof(char)) ) == 0 ) { fprintf(stderr,""%s: Error allocating %ld bytes of memory"",axohelp,filesize+1); <S2SV_StartVul> exit(-1); <S2SV_EndVul> } num = fread( buffer, 1, filesize, finput ); if ( ferror(finput) ) { fprintf(stderr,""%s: Error reading file %s\n"",axohelp,filename); <S2SV_StartVul> exit(-1); <S2SV_EndVul> } buffer[num] = 0; fclose(finput); return(buffer); }","- exit(-1);
- exit(-1);
- exit(-1);
- exit(-1);
+ exit(1);
+ exit(1);
+ exit(1);
+ exit(1);","char *ReadInput(char *filename) { FILE *finput; long filesize, num; char *buffer; if ( ( finput = fopen(filename,""r"") ) == 0 ) { fprintf(stderr,""%s: Cannot open file %s\n"",axohelp,filename); exit(1); } if ( ( fseek(finput,0,SEEK_END) != 0 ) || ( ( filesize = ftell(finput) ) < 0 ) || ( fseek(finput,0,SEEK_SET) != 0 ) ) { fprintf(stderr,""%s: File error in file %s\n"",axohelp,filename); exit(1); } if ( ( buffer = malloc((filesize+1)*sizeof(char)) ) == 0 ) { fprintf(stderr,""%s: Error allocating %ld bytes of memory"",axohelp,filesize+1); exit(1); } num = fread( buffer, 1, filesize, finput ); if ( ferror(finput) ) { fprintf(stderr,""%s: Error reading file %s\n"",axohelp,filename); exit(1); } buffer[num] = 0; fclose(finput); return(buffer); }"
934,6169----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/singlecomponentlsscan.cpp----SingleComponentLSScan::ParseMCU,"bool SingleComponentLSScan::ParseMCU(void) { #if ACCUSOFT_CODE int lines = m_ulRemaining[0]; UBYTE preshift = m_ucLowBit + FractionalColorBitsOf(); struct Line *line = CurrentLine(0); if (m_pFrame->HeightOf() == 0) { assert(lines == 0); lines = 8; } assert(m_ucCount == 1); if (lines > 8) { lines = 8; } if (m_pFrame->HeightOf() > 0) m_ulRemaining[0] -= lines; <S2SV_StartVul> assert(lines > 0); <S2SV_EndVul> do { LONG length = m_ulWidth[0]; LONG *lp = line->m_pData; #ifdef DEBUG_LS int xpos = 0; static int linenumber = 0; printf(""\n%4d : "",++linenumber); #endif StartLine(0); if (BeginReadMCU(m_Stream.ByteStreamOf())) { do { LONG a,b,c,d; LONG d1,d2,d3; GetContext(0,a,b,c,d); d1 = d - b; d2 = b - c; d3 = c - a; if (isRunMode(d1,d2,d3)) { LONG run = DecodeRun(length,m_lRunIndex[0]); while(run) { UpdateContext(0,a); *lp++ = a << preshift; #ifdef DEBUG_LS printf(""%4d:<%2x> "",xpos++,a); #endif run--,length--; } if (length) { bool negative; bool rtype; LONG errval; LONG merr; LONG rx; UBYTE k; GetContext(0,a,b,c,d); rtype = InterruptedPredictionMode(negative,a,b); k = GolombParameter(rtype); merr = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1); errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k)); rx = Reconstruct(negative,rtype?a:b,errval); UpdateContext(0,rx); *lp = rx << preshift; #ifdef DEBUG_LS printf(""%4d:<%2x> "",xpos++,*lp); #endif UpdateState(rtype,errval); if (m_lRunIndex[0] > 0) m_lRunIndex[0]--; } else break; } else { UWORD ctxt; bool negative; LONG px; LONG rx; LONG errval; LONG merr; UBYTE k; d1 = QuantizedGradient(d1); d2 = QuantizedGradient(d2); d3 = QuantizedGradient(d3); ctxt = Context(negative,d1,d2,d3); px = Predict(a,b,c); px = CorrectPrediction(ctxt,negative,px); k = GolombParameter(ctxt); merr = GolombDecode(k,m_lLimit); errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k)); UpdateState(ctxt,errval); rx = Reconstruct(negative,px,errval); UpdateContext(0,rx); *lp = rx << preshift; #ifdef DEBUG_LS printf(""%4d:<%2x> "",xpos++,*lp); #endif } } while(++lp,--length); } EndLine(0); line = line->m_pNext; } while(--lines); m_Stream.SkipStuffing(); #endif return false; }","- assert(lines > 0);
+ if (lines == 0)
+ return false;","bool SingleComponentLSScan::ParseMCU(void) { #if ACCUSOFT_CODE int lines = m_ulRemaining[0]; UBYTE preshift = m_ucLowBit + FractionalColorBitsOf(); struct Line *line = CurrentLine(0); if (m_pFrame->HeightOf() == 0) { assert(lines == 0); lines = 8; } assert(m_ucCount == 1); if (lines > 8) { lines = 8; } if (m_pFrame->HeightOf() > 0) m_ulRemaining[0] -= lines; if (lines == 0) return false; do { LONG length = m_ulWidth[0]; LONG *lp = line->m_pData; #ifdef DEBUG_LS int xpos = 0; static int linenumber = 0; printf(""\n%4d : "",++linenumber); #endif StartLine(0); if (BeginReadMCU(m_Stream.ByteStreamOf())) { do { LONG a,b,c,d; LONG d1,d2,d3; GetContext(0,a,b,c,d); d1 = d - b; d2 = b - c; d3 = c - a; if (isRunMode(d1,d2,d3)) { LONG run = DecodeRun(length,m_lRunIndex[0]); while(run) { UpdateContext(0,a); *lp++ = a << preshift; #ifdef DEBUG_LS printf(""%4d:<%2x> "",xpos++,a); #endif run--,length--; } if (length) { bool negative; bool rtype; LONG errval; LONG merr; LONG rx; UBYTE k; GetContext(0,a,b,c,d); rtype = InterruptedPredictionMode(negative,a,b); k = GolombParameter(rtype); merr = GolombDecode(k,m_lLimit - m_lJ[m_lRunIndex[0]] - 1); errval = InverseErrorMapping(merr + rtype,ErrorMappingOffset(rtype,rtype || merr,k)); rx = Reconstruct(negative,rtype?a:b,errval); UpdateContext(0,rx); *lp = rx << preshift; #ifdef DEBUG_LS printf(""%4d:<%2x> "",xpos++,*lp); #endif UpdateState(rtype,errval); if (m_lRunIndex[0] > 0) m_lRunIndex[0]--; } else break; } else { UWORD ctxt; bool negative; LONG px; LONG rx; LONG errval; LONG merr; UBYTE k; d1 = QuantizedGradient(d1); d2 = QuantizedGradient(d2); d3 = QuantizedGradient(d3); ctxt = Context(negative,d1,d2,d3); px = Predict(a,b,c); px = CorrectPrediction(ctxt,negative,px); k = GolombParameter(ctxt); merr = GolombDecode(k,m_lLimit); errval = InverseErrorMapping(merr,ErrorMappingOffset(ctxt,k)); UpdateState(ctxt,errval); rx = Reconstruct(negative,px,errval); UpdateContext(0,rx); *lp = rx << preshift; #ifdef DEBUG_LS printf(""%4d:<%2x> "",xpos++,*lp); #endif } } while(++lp,--length); } EndLine(0); line = line->m_pNext; } while(--lines); m_Stream.SkipStuffing(); #endif return false; }"
935,5296----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/oracle.c----ndpi_search_oracle,"void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) { struct ndpi_packet_struct *packet = &flow->packet; u_int16_t dport = 0, sport = 0; NDPI_LOG_DBG(ndpi_struct, ""search ORACLE\n""); if(packet->tcp != NULL) { sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest); NDPI_LOG_DBG2(ndpi_struct, ""calculating ORACLE over tcp\n""); if ((dport == 1521 || sport == 1521) <S2SV_StartVul> && (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00)) <S2SV_EndVul> || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) && (packet->payload[1] != 0x00) && (packet->payload[2] == 0x00) && (packet->payload[3] == 0x00)))) { NDPI_LOG_INFO(ndpi_struct, ""found oracle\n""); ndpi_int_oracle_add_connection(ndpi_struct, flow); } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 && packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 && packet->payload[3] == 0x00 ) { NDPI_LOG_INFO(ndpi_struct, ""found oracle\n""); ndpi_int_oracle_add_connection(ndpi_struct, flow); } } else { NDPI_EXCLUDE_PROTO(ndpi_struct, flow); } }","- && (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))
+ && (((packet->payload_packet_len >= 3 && packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))","void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) { struct ndpi_packet_struct *packet = &flow->packet; u_int16_t dport = 0, sport = 0; NDPI_LOG_DBG(ndpi_struct, ""search ORACLE\n""); if(packet->tcp != NULL) { sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest); NDPI_LOG_DBG2(ndpi_struct, ""calculating ORACLE over tcp\n""); if ((dport == 1521 || sport == 1521) && (((packet->payload_packet_len >= 3 && packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00)) || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) && (packet->payload[1] != 0x00) && (packet->payload[2] == 0x00) && (packet->payload[3] == 0x00)))) { NDPI_LOG_INFO(ndpi_struct, ""found oracle\n""); ndpi_int_oracle_add_connection(ndpi_struct, flow); } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 && packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 && packet->payload[3] == 0x00 ) { NDPI_LOG_INFO(ndpi_struct, ""found oracle\n""); ndpi_int_oracle_add_connection(ndpi_struct, flow); } } else { NDPI_EXCLUDE_PROTO(ndpi_struct, flow); } }"
936,2939----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tiffio.c----pixReadFromTiffStream,"pixReadFromTiffStream(TIFF *tif) { char *text; l_uint8 *linebuf, *data, *rowptr; l_uint16 spp, bps, photometry, tiffcomp, orientation, sample_fmt; l_uint16 *redmap, *greenmap, *bluemap; l_int32 d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval; l_int32 xres, yres, tiffbpl, packedbpl, halfsize; l_uint32 w, h, tiffword, read_oriented; l_uint32 *line, *ppixel, *tiffdata, *pixdata; PIX *pix, *pix1; PIXCMAP *cmap; PROCNAME(""pixReadFromTiffStream""); if (!tif) return (PIX *)ERROR_PTR(""tif not defined"", procName, NULL); read_oriented = 0; TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt); if (sample_fmt != SAMPLEFORMAT_UINT) { L_ERROR(""sample format = %d is not uint\n"", procName, sample_fmt); return NULL; } if (TIFFIsTiled(tif)) { L_ERROR(""tiled format is not supported\n"", procName); return NULL; } TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp); if (tiffcomp == COMPRESSION_OJPEG) { L_ERROR(""old style jpeg format is not supported\n"", procName); return NULL; } TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp); if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) { L_ERROR(""invalid bps = %d\n"", procName, bps); return NULL; } if (spp == 2 && bps != 8) { L_WARNING(""for 2 spp, only handle 8 bps\n"", procName); return NULL; } if (spp == 1) d = bps; else if (spp == 2) d = 32; else if (spp == 3 || spp == 4) d = 32; else return (PIX *)ERROR_PTR(""spp not in set {1,2,3,4}"", procName, NULL); TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); if (w > MaxTiffWidth) { L_ERROR(""width = %d pixels; too large\n"", procName, w); return NULL; } if (h > MaxTiffHeight) { L_ERROR(""height = %d pixels; too large\n"", procName, h); return NULL; } tiffbpl = TIFFScanlineSize(tif); packedbpl = (bps * spp * w + 7) / 8; halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8; #if 0 if (halfsize) L_INFO(""packedbpl = %d is approx. twice tiffbpl = %d\n"", procName, packedbpl, tiffbpl); #endif if (tiffbpl != packedbpl && !halfsize) { L_ERROR(""invalid tiffbpl: tiffbpl = %d, packedbpl = %d, "" ""bps = %d, spp = %d, w = %d\n"", procName, tiffbpl, packedbpl, bps, spp, w); return NULL; } if ((pix = pixCreate(w, h, d)) == NULL) return (PIX *)ERROR_PTR(""pix not made"", procName, NULL); pixSetInputFormat(pix, IFF_TIFF); data = (l_uint8 *)pixGetData(pix); wpl = pixGetWpl(pix); bpl = 4 * wpl; if (spp == 1) { linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8)); for (i = 0; i < h; i++) { if (TIFFReadScanline(tif, linebuf, i, 0) < 0) { LEPT_FREE(linebuf); pixDestroy(&pix); return (PIX *)ERROR_PTR(""line read fail"", procName, NULL); } memcpy(data, linebuf, tiffbpl); data += bpl; } if (bps <= 8) pixEndianByteSwap(pix); else pixEndianTwoByteSwap(pix); LEPT_FREE(linebuf); } else if (spp == 2 && bps == 8) { L_INFO(""gray+alpha is not supported; converting to RGBA\n"", procName); pixSetSpp(pix, 4); <S2SV_StartVul> linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8)); <S2SV_EndVul> pixdata = pixGetData(pix); for (i = 0; i < h; i++) { if (TIFFReadScanline(tif, linebuf, i, 0) < 0) { LEPT_FREE(linebuf); pixDestroy(&pix); return (PIX *)ERROR_PTR(""line read fail"", procName, NULL); } rowptr = linebuf; ppixel = pixdata + i * wpl; for (j = k = 0; j < w; j++) { SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]); SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]); SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]); SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]); ppixel++; } } LEPT_FREE(linebuf); } else { if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h, sizeof(l_uint32))) == NULL) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""calloc fail for tiffdata"", procName, NULL); } if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata, ORIENTATION_TOPLEFT, 0)) { LEPT_FREE(tiffdata); pixDestroy(&pix); return (PIX *)ERROR_PTR(""failed to read tiffdata"", procName, NULL); } else { read_oriented = 1; } if (spp == 4) pixSetSpp(pix, 4); line = pixGetData(pix); for (i = 0; i < h; i++, line += wpl) { for (j = 0, ppixel = line; j < w; j++) { tiffword = tiffdata[i * w + j]; rval = TIFFGetR(tiffword); gval = TIFFGetG(tiffword); bval = TIFFGetB(tiffword); if (spp == 3) { composeRGBPixel(rval, gval, bval, ppixel); } else { aval = TIFFGetA(tiffword); composeRGBAPixel(rval, gval, bval, aval, ppixel); } ppixel++; } } LEPT_FREE(tiffdata); } if (getTiffStreamResolution(tif, &xres, &yres) == 0) { pixSetXRes(pix, xres); pixSetYRes(pix, yres); } comptype = getTiffCompressedFormat(tiffcomp); pixSetInputFormat(pix, comptype); if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) { if (bps > 8) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""colormap size > 256"", procName, NULL); } if ((cmap = pixcmapCreate(bps)) == NULL) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""colormap not made"", procName, NULL); } ncolors = 1 << bps; for (i = 0; i < ncolors; i++) pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8, bluemap[i] >> 8); if (pixSetColormap(pix, cmap)) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""invalid colormap"", procName, NULL); } if (bps == 1) { pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC); pixDestroy(&pix); pix = pix1; } } else { if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) { if (tiffcomp == COMPRESSION_CCITTFAX3 || tiffcomp == COMPRESSION_CCITTFAX4 || tiffcomp == COMPRESSION_CCITTRLE || tiffcomp == COMPRESSION_CCITTRLEW) { photometry = PHOTOMETRIC_MINISWHITE; } else { photometry = PHOTOMETRIC_MINISBLACK; } } if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) || (d == 8 && photometry == PHOTOMETRIC_MINISWHITE)) pixInvert(pix, pix); } if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) { if (orientation >= 1 && orientation <= 8) { struct tiff_transform *transform = (read_oriented) ? &tiff_partial_orientation_transforms[orientation - 1] : &tiff_orientation_transforms[orientation - 1]; if (transform->vflip) pixFlipTB(pix, pix); if (transform->hflip) pixFlipLR(pix, pix); if (transform->rotate) { PIX *oldpix = pix; pix = pixRotate90(oldpix, transform->rotate); pixDestroy(&oldpix); } } } text = NULL; TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text); if (text) pixSetText(pix, text); return pix; }","- linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8));
+ linebuf = (l_uint8 *)LEPT_CALLOC(2 * tiffbpl + 1, sizeof(l_uint8));","pixReadFromTiffStream(TIFF *tif) { char *text; l_uint8 *linebuf, *data, *rowptr; l_uint16 spp, bps, photometry, tiffcomp, orientation, sample_fmt; l_uint16 *redmap, *greenmap, *bluemap; l_int32 d, wpl, bpl, comptype, i, j, k, ncolors, rval, gval, bval, aval; l_int32 xres, yres, tiffbpl, packedbpl, halfsize; l_uint32 w, h, tiffword, read_oriented; l_uint32 *line, *ppixel, *tiffdata, *pixdata; PIX *pix, *pix1; PIXCMAP *cmap; PROCNAME(""pixReadFromTiffStream""); if (!tif) return (PIX *)ERROR_PTR(""tif not defined"", procName, NULL); read_oriented = 0; TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLEFORMAT, &sample_fmt); if (sample_fmt != SAMPLEFORMAT_UINT) { L_ERROR(""sample format = %d is not uint\n"", procName, sample_fmt); return NULL; } if (TIFFIsTiled(tif)) { L_ERROR(""tiled format is not supported\n"", procName); return NULL; } TIFFGetFieldDefaulted(tif, TIFFTAG_COMPRESSION, &tiffcomp); if (tiffcomp == COMPRESSION_OJPEG) { L_ERROR(""old style jpeg format is not supported\n"", procName); return NULL; } TIFFGetFieldDefaulted(tif, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(tif, TIFFTAG_SAMPLESPERPIXEL, &spp); if (bps != 1 && bps != 2 && bps != 4 && bps != 8 && bps != 16) { L_ERROR(""invalid bps = %d\n"", procName, bps); return NULL; } if (spp == 2 && bps != 8) { L_WARNING(""for 2 spp, only handle 8 bps\n"", procName); return NULL; } if (spp == 1) d = bps; else if (spp == 2) d = 32; else if (spp == 3 || spp == 4) d = 32; else return (PIX *)ERROR_PTR(""spp not in set {1,2,3,4}"", procName, NULL); TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &w); TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &h); if (w > MaxTiffWidth) { L_ERROR(""width = %d pixels; too large\n"", procName, w); return NULL; } if (h > MaxTiffHeight) { L_ERROR(""height = %d pixels; too large\n"", procName, h); return NULL; } tiffbpl = TIFFScanlineSize(tif); packedbpl = (bps * spp * w + 7) / 8; halfsize = L_ABS(2 * tiffbpl - packedbpl) <= 8; #if 0 if (halfsize) L_INFO(""packedbpl = %d is approx. twice tiffbpl = %d\n"", procName, packedbpl, tiffbpl); #endif if (tiffbpl != packedbpl && !halfsize) { L_ERROR(""invalid tiffbpl: tiffbpl = %d, packedbpl = %d, "" ""bps = %d, spp = %d, w = %d\n"", procName, tiffbpl, packedbpl, bps, spp, w); return NULL; } if ((pix = pixCreate(w, h, d)) == NULL) return (PIX *)ERROR_PTR(""pix not made"", procName, NULL); pixSetInputFormat(pix, IFF_TIFF); data = (l_uint8 *)pixGetData(pix); wpl = pixGetWpl(pix); bpl = 4 * wpl; if (spp == 1) { linebuf = (l_uint8 *)LEPT_CALLOC(tiffbpl + 1, sizeof(l_uint8)); for (i = 0; i < h; i++) { if (TIFFReadScanline(tif, linebuf, i, 0) < 0) { LEPT_FREE(linebuf); pixDestroy(&pix); return (PIX *)ERROR_PTR(""line read fail"", procName, NULL); } memcpy(data, linebuf, tiffbpl); data += bpl; } if (bps <= 8) pixEndianByteSwap(pix); else pixEndianTwoByteSwap(pix); LEPT_FREE(linebuf); } else if (spp == 2 && bps == 8) { L_INFO(""gray+alpha is not supported; converting to RGBA\n"", procName); pixSetSpp(pix, 4); linebuf = (l_uint8 *)LEPT_CALLOC(2 * tiffbpl + 1, sizeof(l_uint8)); pixdata = pixGetData(pix); for (i = 0; i < h; i++) { if (TIFFReadScanline(tif, linebuf, i, 0) < 0) { LEPT_FREE(linebuf); pixDestroy(&pix); return (PIX *)ERROR_PTR(""line read fail"", procName, NULL); } rowptr = linebuf; ppixel = pixdata + i * wpl; for (j = k = 0; j < w; j++) { SET_DATA_BYTE(ppixel, COLOR_RED, rowptr[k]); SET_DATA_BYTE(ppixel, COLOR_GREEN, rowptr[k]); SET_DATA_BYTE(ppixel, COLOR_BLUE, rowptr[k++]); SET_DATA_BYTE(ppixel, L_ALPHA_CHANNEL, rowptr[k++]); ppixel++; } } LEPT_FREE(linebuf); } else { if ((tiffdata = (l_uint32 *)LEPT_CALLOC((size_t)w * h, sizeof(l_uint32))) == NULL) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""calloc fail for tiffdata"", procName, NULL); } if (!TIFFReadRGBAImageOriented(tif, w, h, tiffdata, ORIENTATION_TOPLEFT, 0)) { LEPT_FREE(tiffdata); pixDestroy(&pix); return (PIX *)ERROR_PTR(""failed to read tiffdata"", procName, NULL); } else { read_oriented = 1; } if (spp == 4) pixSetSpp(pix, 4); line = pixGetData(pix); for (i = 0; i < h; i++, line += wpl) { for (j = 0, ppixel = line; j < w; j++) { tiffword = tiffdata[i * w + j]; rval = TIFFGetR(tiffword); gval = TIFFGetG(tiffword); bval = TIFFGetB(tiffword); if (spp == 3) { composeRGBPixel(rval, gval, bval, ppixel); } else { aval = TIFFGetA(tiffword); composeRGBAPixel(rval, gval, bval, aval, ppixel); } ppixel++; } } LEPT_FREE(tiffdata); } if (getTiffStreamResolution(tif, &xres, &yres) == 0) { pixSetXRes(pix, xres); pixSetYRes(pix, yres); } comptype = getTiffCompressedFormat(tiffcomp); pixSetInputFormat(pix, comptype); if (TIFFGetField(tif, TIFFTAG_COLORMAP, &redmap, &greenmap, &bluemap)) { if (bps > 8) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""colormap size > 256"", procName, NULL); } if ((cmap = pixcmapCreate(bps)) == NULL) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""colormap not made"", procName, NULL); } ncolors = 1 << bps; for (i = 0; i < ncolors; i++) pixcmapAddColor(cmap, redmap[i] >> 8, greenmap[i] >> 8, bluemap[i] >> 8); if (pixSetColormap(pix, cmap)) { pixDestroy(&pix); return (PIX *)ERROR_PTR(""invalid colormap"", procName, NULL); } if (bps == 1) { pix1 = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC); pixDestroy(&pix); pix = pix1; } } else { if (!TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photometry)) { if (tiffcomp == COMPRESSION_CCITTFAX3 || tiffcomp == COMPRESSION_CCITTFAX4 || tiffcomp == COMPRESSION_CCITTRLE || tiffcomp == COMPRESSION_CCITTRLEW) { photometry = PHOTOMETRIC_MINISWHITE; } else { photometry = PHOTOMETRIC_MINISBLACK; } } if ((d == 1 && photometry == PHOTOMETRIC_MINISBLACK) || (d == 8 && photometry == PHOTOMETRIC_MINISWHITE)) pixInvert(pix, pix); } if (TIFFGetField(tif, TIFFTAG_ORIENTATION, &orientation)) { if (orientation >= 1 && orientation <= 8) { struct tiff_transform *transform = (read_oriented) ? &tiff_partial_orientation_transforms[orientation - 1] : &tiff_orientation_transforms[orientation - 1]; if (transform->vflip) pixFlipTB(pix, pix); if (transform->hflip) pixFlipLR(pix, pix); if (transform->rotate) { PIX *oldpix = pix; pix = pixRotate90(oldpix, transform->rotate); pixDestroy(&oldpix); } } } text = NULL; TIFFGetField(tif, TIFFTAG_IMAGEDESCRIPTION, &text); if (text) pixSetText(pix, text); return pix; }"
937,4557----CWE-200----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dsa.cpp----Botan::DSA_Signature_Operation::DSA_Signature_Operation,"<S2SV_StartVul> DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) : <S2SV_EndVul> PK_Ops::Signature_with_EMSA(emsa), m_group(dsa.get_group()), m_x(dsa.get_x()), m_mod_q(dsa.group_q()) { #if defined(BOTAN_HAS_RFC6979_GENERATOR) m_rfc6979_hash = hash_for_emsa(emsa); #endif }","- DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :
+ DSA_Signature_Operation(const DSA_PrivateKey& dsa,
+ const std::string& emsa,
+ RandomNumberGenerator& rng) :
+ m_b = BigInt::random_integer(rng, 2, dsa.group_q());
+ m_b_inv = inverse_mod(m_b, dsa.group_q());","DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa, RandomNumberGenerator& rng) : PK_Ops::Signature_with_EMSA(emsa), m_group(dsa.get_group()), m_x(dsa.get_x()), m_mod_q(dsa.group_q()) { #if defined(BOTAN_HAS_RFC6979_GENERATOR) m_rfc6979_hash = hash_for_emsa(emsa); #endif m_b = BigInt::random_integer(rng, 2, dsa.group_q()); m_b_inv = inverse_mod(m_b, dsa.group_q()); }"
938,4800----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/i2c.c----do_i2c_crc,"static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) { uint chip; ulong addr; <S2SV_StartVul> int alen; <S2SV_EndVul> <S2SV_StartVul> int count; <S2SV_EndVul> uchar byte; ulong crc; ulong err; int ret = 0; #if CONFIG_IS_ENABLED(DM_I2C) struct udevice *dev; #endif if (argc < 4) return CMD_RET_USAGE; chip = hextoul(argv[1], NULL); addr = hextoul(argv[2], NULL); alen = get_alen(argv[2], DEFAULT_ADDR_LEN); if (alen > 3) return CMD_RET_USAGE; #if CONFIG_IS_ENABLED(DM_I2C) ret = i2c_get_cur_bus_chip(chip, &dev); if (!ret && alen != -1) ret = i2c_set_chip_offset_len(dev, alen); if (ret) return i2c_report_err(ret, I2C_ERR_READ); #endif count = hextoul(argv[3], NULL); printf (""CRC32 for %08lx ... %08lx ==> "", addr, addr + count - 1); crc = 0; err = 0; while (count-- > 0) { #if CONFIG_IS_ENABLED(DM_I2C) ret = dm_i2c_read(dev, addr, &byte, 1); #else ret = i2c_read(chip, addr, alen, &byte, 1); #endif if (ret) err++; crc = crc32(crc, &byte, 1); addr++; } if (err > 0) i2c_report_err(ret, I2C_ERR_READ); else printf (""%08lx\n"", crc); return 0; }","- int alen;
- int count;
+ uint alen;
+ uint count;","static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[]) { uint chip; ulong addr; uint alen; uint count; uchar byte; ulong crc; ulong err; int ret = 0; #if CONFIG_IS_ENABLED(DM_I2C) struct udevice *dev; #endif if (argc < 4) return CMD_RET_USAGE; chip = hextoul(argv[1], NULL); addr = hextoul(argv[2], NULL); alen = get_alen(argv[2], DEFAULT_ADDR_LEN); if (alen > 3) return CMD_RET_USAGE; #if CONFIG_IS_ENABLED(DM_I2C) ret = i2c_get_cur_bus_chip(chip, &dev); if (!ret && alen != -1) ret = i2c_set_chip_offset_len(dev, alen); if (ret) return i2c_report_err(ret, I2C_ERR_READ); #endif count = hextoul(argv[3], NULL); printf (""CRC32 for %08lx ... %08lx ==> "", addr, addr + count - 1); crc = 0; err = 0; while (count-- > 0) { #if CONFIG_IS_ENABLED(DM_I2C) ret = dm_i2c_read(dev, addr, &byte, 1); #else ret = i2c_read(chip, addr, alen, &byte, 1); #endif if (ret) err++; crc = crc32(crc, &byte, 1); addr++; } if (err > 0) i2c_report_err(ret, I2C_ERR_READ); else printf (""%08lx\n"", crc); return 0; }"
939,236--------F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2010-2060--prot.c----dispatch_cmd,"dispatch_cmd(conn c) { int r, i, timeout = -1; size_t z; unsigned int count; job j; unsigned char type; char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name; unsigned int pri, body_size; usec delay, ttr; uint64_t id; tube t = NULL; c->cmd[c->cmd_len - 2] = '\0'; if (strlen(c->cmd) != c->cmd_len - 2) { return reply_msg(c, MSG_BAD_FORMAT); } type = which_cmd(c); dprintf(""got %s command: \""%s\""\n"", op_names[(int) type], c->cmd); switch (type) { case OP_PUT: r = read_pri(&pri, c->cmd + 4, &delay_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_delay(&delay, delay_buf, &ttr_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_ttr(&ttr, ttr_buf, &size_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); errno = 0; body_size = strtoul(size_buf, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); if (body_size > job_data_size_limit) { <S2SV_StartVul> return reply_msg(c, MSG_JOB_TOO_BIG); <S2SV_EndVul> } if (end_buf[0] != '\0') return reply_msg(c, MSG_BAD_FORMAT); conn_set_producer(c); c->in_job = make_job(pri, delay, ttr ? : 1, body_size + 2, c->use); if (!c->in_job) { twarnx(""server error: "" MSG_OUT_OF_MEMORY); return skip(c, body_size + 2, MSG_OUT_OF_MEMORY); } fill_extra_data(c); maybe_enqueue_incoming_job(c); break; case OP_PEEK_READY: if (c->cmd_len != CMD_PEEK_READY_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; j = job_copy(pq_peek(&c->use->ready)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_PEEK_DELAYED: if (c->cmd_len != CMD_PEEK_DELAYED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; j = job_copy(pq_peek(&c->use->delay)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_PEEK_BURIED: if (c->cmd_len != CMD_PEEK_BURIED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_PEEKJOB: errno = 0; id = strtoull(c->cmd + CMD_PEEKJOB_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = job_copy(peek_job(id)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_RESERVE_TIMEOUT: errno = 0; timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); case OP_RESERVE: if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; conn_set_worker(c); if (conn_has_close_deadline(c) && !conn_ready(c)) { return reply_msg(c, MSG_DEADLINE_SOON); } wait_for_job(c, timeout); process_queue(); break; case OP_DELETE: errno = 0; id = strtoull(c->cmd + CMD_DELETE_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = job_find(id); j = remove_reserved_job(c, j) ? : remove_ready_job(j) ? : remove_buried_job(j); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); j->state = JOB_STATE_INVALID; r = binlog_write_job(j); job_free(j); if (!r) return reply_serr(c, MSG_INTERNAL_ERROR); reply(c, MSG_DELETED, MSG_DELETED_LEN, STATE_SENDWORD); break; case OP_RELEASE: errno = 0; id = strtoull(c->cmd + CMD_RELEASE_LEN, &pri_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); r = read_pri(&pri, pri_buf, &delay_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_delay(&delay, delay_buf, NULL); if (r) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = remove_reserved_job(c, job_find(id)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); if (delay) { z = binlog_reserve_space_update(j); if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY); j->reserved_binlog_space += z; } j->pri = pri; j->delay = delay; j->release_ct++; r = enqueue_job(j, delay, !!delay); if (r < 0) return reply_serr(c, MSG_INTERNAL_ERROR); if (r == 1) { return reply(c, MSG_RELEASED, MSG_RELEASED_LEN, STATE_SENDWORD); } bury_job(j, 0); reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD); break; case OP_BURY: errno = 0; id = strtoull(c->cmd + CMD_BURY_LEN, &pri_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); r = read_pri(&pri, pri_buf, NULL); if (r) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = remove_reserved_job(c, job_find(id)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); j->pri = pri; r = bury_job(j, 1); if (!r) return reply_serr(c, MSG_INTERNAL_ERROR); reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD); break; case OP_KICK: errno = 0; count = strtoul(c->cmd + CMD_KICK_LEN, &end_buf, 10); if (end_buf == c->cmd + CMD_KICK_LEN) { return reply_msg(c, MSG_BAD_FORMAT); } if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; i = kick_jobs(c->use, count); return reply_line(c, STATE_SENDWORD, ""KICKED %u\r\n"", i); case OP_TOUCH: errno = 0; id = strtoull(c->cmd + CMD_TOUCH_LEN, &end_buf, 10); if (errno) return twarn(""strtoull""), reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = touch_job(c, job_find(id)); if (j) { reply(c, MSG_TOUCHED, MSG_TOUCHED_LEN, STATE_SENDWORD); } else { return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); } break; case OP_STATS: if (c->cmd_len != CMD_STATS_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; do_stats(c, fmt_stats, NULL); break; case OP_JOBSTATS: errno = 0; id = strtoull(c->cmd + CMD_JOBSTATS_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = peek_job(id); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); if (!j->tube) return reply_serr(c, MSG_INTERNAL_ERROR); do_stats(c, (fmt_fn) fmt_job_stats, j); break; case OP_STATS_TUBE: name = c->cmd + CMD_STATS_TUBE_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; t = tube_find(name); if (!t) return reply_msg(c, MSG_NOTFOUND); do_stats(c, (fmt_fn) fmt_stats_tube, t); t = NULL; break; case OP_LIST_TUBES: if (c->cmd_len != CMD_LIST_TUBES_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; do_list_tubes(c, &tubes); break; case OP_LIST_TUBE_USED: if (c->cmd_len != CMD_LIST_TUBE_USED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; reply_line(c, STATE_SENDWORD, ""USING %s\r\n"", c->use->name); break; case OP_LIST_TUBES_WATCHED: if (c->cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; do_list_tubes(c, &c->watch); break; case OP_USE: name = c->cmd + CMD_USE_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; TUBE_ASSIGN(t, tube_find_or_make(name)); if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY); c->use->using_ct--; TUBE_ASSIGN(c->use, t); TUBE_ASSIGN(t, NULL); c->use->using_ct++; reply_line(c, STATE_SENDWORD, ""USING %s\r\n"", c->use->name); break; case OP_WATCH: name = c->cmd + CMD_WATCH_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; TUBE_ASSIGN(t, tube_find_or_make(name)); if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY); r = 1; if (!ms_contains(&c->watch, t)) r = ms_append(&c->watch, t); TUBE_ASSIGN(t, NULL); if (!r) return reply_serr(c, MSG_OUT_OF_MEMORY); reply_line(c, STATE_SENDWORD, ""WATCHING %d\r\n"", c->watch.used); break; case OP_IGNORE: name = c->cmd + CMD_IGNORE_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; t = NULL; for (i = 0; i < c->watch.used; i++) { t = c->watch.items[i]; if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) break; t = NULL; } if (t && c->watch.used < 2) return reply_msg(c, MSG_NOT_IGNORED); if (t) ms_remove(&c->watch, t); t = NULL; reply_line(c, STATE_SENDWORD, ""WATCHING %d\r\n"", c->watch.used); break; case OP_QUIT: conn_close(c); break; case OP_PAUSE_TUBE: op_ct[type]++; r = read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_delay(&delay, delay_buf, NULL); if (r) return reply_msg(c, MSG_BAD_FORMAT); *delay_buf = '\0'; t = tube_find(name); if (!t) return reply_msg(c, MSG_NOTFOUND); t->deadline_at = now_usec() + delay; t->pause = delay; t->stat.pause_ct++; set_main_delay_timeout(); reply_line(c, STATE_SENDWORD, ""PAUSED\r\n""); break; default: return reply_msg(c, MSG_UNKNOWN_COMMAND); } }","- return reply_msg(c, MSG_JOB_TOO_BIG);
+ return skip(c, body_size + 2, MSG_JOB_TOO_BIG);","dispatch_cmd(conn c) { int r, i, timeout = -1; size_t z; unsigned int count; job j; unsigned char type; char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name; unsigned int pri, body_size; usec delay, ttr; uint64_t id; tube t = NULL; c->cmd[c->cmd_len - 2] = '\0'; if (strlen(c->cmd) != c->cmd_len - 2) { return reply_msg(c, MSG_BAD_FORMAT); } type = which_cmd(c); dprintf(""got %s command: \""%s\""\n"", op_names[(int) type], c->cmd); switch (type) { case OP_PUT: r = read_pri(&pri, c->cmd + 4, &delay_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_delay(&delay, delay_buf, &ttr_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_ttr(&ttr, ttr_buf, &size_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); errno = 0; body_size = strtoul(size_buf, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); if (body_size > job_data_size_limit) { return skip(c, body_size + 2, MSG_JOB_TOO_BIG); } if (end_buf[0] != '\0') return reply_msg(c, MSG_BAD_FORMAT); conn_set_producer(c); c->in_job = make_job(pri, delay, ttr ? : 1, body_size + 2, c->use); if (!c->in_job) { twarnx(""server error: "" MSG_OUT_OF_MEMORY); return skip(c, body_size + 2, MSG_OUT_OF_MEMORY); } fill_extra_data(c); maybe_enqueue_incoming_job(c); break; case OP_PEEK_READY: if (c->cmd_len != CMD_PEEK_READY_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; j = job_copy(pq_peek(&c->use->ready)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_PEEK_DELAYED: if (c->cmd_len != CMD_PEEK_DELAYED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; j = job_copy(pq_peek(&c->use->delay)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_PEEK_BURIED: if (c->cmd_len != CMD_PEEK_BURIED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; j = job_copy(buried_job_p(c->use)? j = c->use->buried.next : NULL); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_PEEKJOB: errno = 0; id = strtoull(c->cmd + CMD_PEEKJOB_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = job_copy(peek_job(id)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); reply_job(c, j, MSG_FOUND); break; case OP_RESERVE_TIMEOUT: errno = 0; timeout = strtol(c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); case OP_RESERVE: if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; conn_set_worker(c); if (conn_has_close_deadline(c) && !conn_ready(c)) { return reply_msg(c, MSG_DEADLINE_SOON); } wait_for_job(c, timeout); process_queue(); break; case OP_DELETE: errno = 0; id = strtoull(c->cmd + CMD_DELETE_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = job_find(id); j = remove_reserved_job(c, j) ? : remove_ready_job(j) ? : remove_buried_job(j); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); j->state = JOB_STATE_INVALID; r = binlog_write_job(j); job_free(j); if (!r) return reply_serr(c, MSG_INTERNAL_ERROR); reply(c, MSG_DELETED, MSG_DELETED_LEN, STATE_SENDWORD); break; case OP_RELEASE: errno = 0; id = strtoull(c->cmd + CMD_RELEASE_LEN, &pri_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); r = read_pri(&pri, pri_buf, &delay_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_delay(&delay, delay_buf, NULL); if (r) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = remove_reserved_job(c, job_find(id)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); if (delay) { z = binlog_reserve_space_update(j); if (!z) return reply_serr(c, MSG_OUT_OF_MEMORY); j->reserved_binlog_space += z; } j->pri = pri; j->delay = delay; j->release_ct++; r = enqueue_job(j, delay, !!delay); if (r < 0) return reply_serr(c, MSG_INTERNAL_ERROR); if (r == 1) { return reply(c, MSG_RELEASED, MSG_RELEASED_LEN, STATE_SENDWORD); } bury_job(j, 0); reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD); break; case OP_BURY: errno = 0; id = strtoull(c->cmd + CMD_BURY_LEN, &pri_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); r = read_pri(&pri, pri_buf, NULL); if (r) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = remove_reserved_job(c, job_find(id)); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); j->pri = pri; r = bury_job(j, 1); if (!r) return reply_serr(c, MSG_INTERNAL_ERROR); reply(c, MSG_BURIED, MSG_BURIED_LEN, STATE_SENDWORD); break; case OP_KICK: errno = 0; count = strtoul(c->cmd + CMD_KICK_LEN, &end_buf, 10); if (end_buf == c->cmd + CMD_KICK_LEN) { return reply_msg(c, MSG_BAD_FORMAT); } if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; i = kick_jobs(c->use, count); return reply_line(c, STATE_SENDWORD, ""KICKED %u\r\n"", i); case OP_TOUCH: errno = 0; id = strtoull(c->cmd + CMD_TOUCH_LEN, &end_buf, 10); if (errno) return twarn(""strtoull""), reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = touch_job(c, job_find(id)); if (j) { reply(c, MSG_TOUCHED, MSG_TOUCHED_LEN, STATE_SENDWORD); } else { return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); } break; case OP_STATS: if (c->cmd_len != CMD_STATS_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; do_stats(c, fmt_stats, NULL); break; case OP_JOBSTATS: errno = 0; id = strtoull(c->cmd + CMD_JOBSTATS_LEN, &end_buf, 10); if (errno) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; j = peek_job(id); if (!j) return reply(c, MSG_NOTFOUND, MSG_NOTFOUND_LEN, STATE_SENDWORD); if (!j->tube) return reply_serr(c, MSG_INTERNAL_ERROR); do_stats(c, (fmt_fn) fmt_job_stats, j); break; case OP_STATS_TUBE: name = c->cmd + CMD_STATS_TUBE_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; t = tube_find(name); if (!t) return reply_msg(c, MSG_NOTFOUND); do_stats(c, (fmt_fn) fmt_stats_tube, t); t = NULL; break; case OP_LIST_TUBES: if (c->cmd_len != CMD_LIST_TUBES_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; do_list_tubes(c, &tubes); break; case OP_LIST_TUBE_USED: if (c->cmd_len != CMD_LIST_TUBE_USED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; reply_line(c, STATE_SENDWORD, ""USING %s\r\n"", c->use->name); break; case OP_LIST_TUBES_WATCHED: if (c->cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2) { return reply_msg(c, MSG_BAD_FORMAT); } op_ct[type]++; do_list_tubes(c, &c->watch); break; case OP_USE: name = c->cmd + CMD_USE_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; TUBE_ASSIGN(t, tube_find_or_make(name)); if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY); c->use->using_ct--; TUBE_ASSIGN(c->use, t); TUBE_ASSIGN(t, NULL); c->use->using_ct++; reply_line(c, STATE_SENDWORD, ""USING %s\r\n"", c->use->name); break; case OP_WATCH: name = c->cmd + CMD_WATCH_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; TUBE_ASSIGN(t, tube_find_or_make(name)); if (!t) return reply_serr(c, MSG_OUT_OF_MEMORY); r = 1; if (!ms_contains(&c->watch, t)) r = ms_append(&c->watch, t); TUBE_ASSIGN(t, NULL); if (!r) return reply_serr(c, MSG_OUT_OF_MEMORY); reply_line(c, STATE_SENDWORD, ""WATCHING %d\r\n"", c->watch.used); break; case OP_IGNORE: name = c->cmd + CMD_IGNORE_LEN; if (!name_is_ok(name, 200)) return reply_msg(c, MSG_BAD_FORMAT); op_ct[type]++; t = NULL; for (i = 0; i < c->watch.used; i++) { t = c->watch.items[i]; if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0) break; t = NULL; } if (t && c->watch.used < 2) return reply_msg(c, MSG_NOT_IGNORED); if (t) ms_remove(&c->watch, t); t = NULL; reply_line(c, STATE_SENDWORD, ""WATCHING %d\r\n"", c->watch.used); break; case OP_QUIT: conn_close(c); break; case OP_PAUSE_TUBE: op_ct[type]++; r = read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf); if (r) return reply_msg(c, MSG_BAD_FORMAT); r = read_delay(&delay, delay_buf, NULL); if (r) return reply_msg(c, MSG_BAD_FORMAT); *delay_buf = '\0'; t = tube_find(name); if (!t) return reply_msg(c, MSG_NOTFOUND); t->deadline_at = now_usec() + delay; t->pause = delay; t->stat.pause_ct++; set_main_delay_timeout(); reply_line(c, STATE_SENDWORD, ""PAUSED\r\n""); break; default: return reply_msg(c, MSG_UNKNOWN_COMMAND); } }"
940,4943----CWE-476----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/core-book3s.c----perf_instruction_pointer,unsigned long perf_instruction_pointer(struct pt_regs *regs) { bool use_siar = regs_use_siar(regs); unsigned long siar = mfspr(SPRN_SIAR); <S2SV_StartVul> if (ppmu->flags & PPMU_P10_DD1) { <S2SV_EndVul> if (siar) return siar; else return regs->nip; } else if (use_siar && siar_valid(regs)) return mfspr(SPRN_SIAR) + perf_ip_adjust(regs); else if (use_siar) return 0; else return regs->nip; },"- if (ppmu->flags & PPMU_P10_DD1) {
+ if (ppmu && (ppmu->flags & PPMU_P10_DD1)) {",unsigned long perf_instruction_pointer(struct pt_regs *regs) { bool use_siar = regs_use_siar(regs); unsigned long siar = mfspr(SPRN_SIAR); if (ppmu && (ppmu->flags & PPMU_P10_DD1)) { if (siar) return siar; else return regs->nip; } else if (use_siar && siar_valid(regs)) return mfspr(SPRN_SIAR) + perf_ip_adjust(regs); else if (use_siar) return 0; else return regs->nip; }
941,2623----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2011-3045--pngrutil.c----png_inflate,"png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size, png_bytep output, png_size_t output_size) { png_size_t count = 0; png_ptr->zstream.next_in = (png_bytep)data; png_ptr->zstream.avail_in = size; while (1) { int ret, avail; png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = png_ptr->zbuf_size; ret = inflate(&png_ptr->zstream, Z_NO_FLUSH); avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out; if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0) { if (output != 0 && output_size > count) { <S2SV_StartVul> int copy = output_size - count; <S2SV_EndVul> <S2SV_StartVul> if (avail < copy) copy = avail; <S2SV_EndVul> png_memcpy(output + count, png_ptr->zbuf, copy); } count += avail; } if (ret == Z_OK) continue; png_ptr->zstream.avail_in = 0; inflateReset(&png_ptr->zstream); if (ret == Z_STREAM_END) return count; { PNG_CONST char *msg; if (png_ptr->zstream.msg != 0) msg = png_ptr->zstream.msg; else { #if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE) char umsg[52]; switch (ret) { case Z_BUF_ERROR: msg = ""Buffer error in compressed datastream in %s chunk""; break; case Z_DATA_ERROR: msg = ""Data error in compressed datastream in %s chunk""; break; default: msg = ""Incomplete compressed datastream in %s chunk""; break; } png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name); msg = umsg; #else msg = ""Damaged compressed datastream in chunk other than IDAT""; #endif } png_warning(png_ptr, msg); } return 0; } }","- int copy = output_size - count;
- if (avail < copy) copy = avail;
+ png_size_t copy = output_size - count;
+ if ((png_size_t) avail < copy) copy = (png_size_t) avail;","png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size, png_bytep output, png_size_t output_size) { png_size_t count = 0; png_ptr->zstream.next_in = (png_bytep)data; png_ptr->zstream.avail_in = size; while (1) { int ret, avail; png_ptr->zstream.next_out = png_ptr->zbuf; png_ptr->zstream.avail_out = png_ptr->zbuf_size; ret = inflate(&png_ptr->zstream, Z_NO_FLUSH); avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out; if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0) { if (output != 0 && output_size > count) { png_size_t copy = output_size - count; if ((png_size_t) avail < copy) copy = (png_size_t) avail; png_memcpy(output + count, png_ptr->zbuf, copy); } count += avail; } if (ret == Z_OK) continue; png_ptr->zstream.avail_in = 0; inflateReset(&png_ptr->zstream); if (ret == Z_STREAM_END) return count; { PNG_CONST char *msg; if (png_ptr->zstream.msg != 0) msg = png_ptr->zstream.msg; else { #if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE) char umsg[52]; switch (ret) { case Z_BUF_ERROR: msg = ""Buffer error in compressed datastream in %s chunk""; break; case Z_DATA_ERROR: msg = ""Data error in compressed datastream in %s chunk""; break; default: msg = ""Incomplete compressed datastream in %s chunk""; break; } png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name); msg = umsg; #else msg = ""Damaged compressed datastream in chunk other than IDAT""; #endif } png_warning(png_ptr, msg); } return 0; } }"
942,3721----CWE-276----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/flatpak-transaction.c----load_deployed_metadata,"load_deployed_metadata (FlatpakTransaction *self, FlatpakDecomposed *ref, char **out_commit, char **out_remote) { FlatpakTransactionPrivate *priv = flatpak_transaction_get_instance_private (self); g_autoptr(GFile) deploy_dir = NULL; g_autoptr(GFile) metadata_file = NULL; g_autofree char *metadata_contents = NULL; gsize metadata_contents_length; deploy_dir = flatpak_dir_get_if_deployed (priv->dir, ref, NULL, NULL); if (deploy_dir == NULL) return NULL; if (out_commit || out_remote) { g_autoptr(GBytes) deploy_data = NULL; deploy_data = flatpak_load_deploy_data (deploy_dir, ref, flatpak_dir_get_repo (priv->dir), FLATPAK_DEPLOY_VERSION_ANY, NULL, NULL); if (deploy_data == NULL) return NULL; if (out_commit) *out_commit = g_strdup (flatpak_deploy_data_get_commit (deploy_data)); if (out_remote) *out_remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data)); } metadata_file = g_file_get_child (deploy_dir, ""metadata""); if (!g_file_load_contents (metadata_file, NULL, &metadata_contents, &metadata_contents_length, NULL, NULL)) { g_debug (""No metadata in local deploy of %s"", flatpak_decomposed_get_ref (ref)); return NULL; } <S2SV_StartVul> return g_bytes_new_take (g_steal_pointer (&metadata_contents), metadata_contents_length + 1); <S2SV_EndVul> }","- return g_bytes_new_take (g_steal_pointer (&metadata_contents), metadata_contents_length + 1);
+ return g_bytes_new_take (g_steal_pointer (&metadata_contents), metadata_contents_length);","load_deployed_metadata (FlatpakTransaction *self, FlatpakDecomposed *ref, char **out_commit, char **out_remote) { FlatpakTransactionPrivate *priv = flatpak_transaction_get_instance_private (self); g_autoptr(GFile) deploy_dir = NULL; g_autoptr(GFile) metadata_file = NULL; g_autofree char *metadata_contents = NULL; gsize metadata_contents_length; deploy_dir = flatpak_dir_get_if_deployed (priv->dir, ref, NULL, NULL); if (deploy_dir == NULL) return NULL; if (out_commit || out_remote) { g_autoptr(GBytes) deploy_data = NULL; deploy_data = flatpak_load_deploy_data (deploy_dir, ref, flatpak_dir_get_repo (priv->dir), FLATPAK_DEPLOY_VERSION_ANY, NULL, NULL); if (deploy_data == NULL) return NULL; if (out_commit) *out_commit = g_strdup (flatpak_deploy_data_get_commit (deploy_data)); if (out_remote) *out_remote = g_strdup (flatpak_deploy_data_get_origin (deploy_data)); } metadata_file = g_file_get_child (deploy_dir, ""metadata""); if (!g_file_load_contents (metadata_file, NULL, &metadata_contents, &metadata_contents_length, NULL, NULL)) { g_debug (""No metadata in local deploy of %s"", flatpak_decomposed_get_ref (ref)); return NULL; } return g_bytes_new_take (g_steal_pointer (&metadata_contents), metadata_contents_length); }"
943,484----CWE-310----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-2548--ablkcipher.c----crypto_givcipher_report,"static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_blkcipher rblkcipher; <S2SV_StartVul> snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher""); <S2SV_EndVul> <S2SV_StartVul> snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"", <S2SV_EndVul> <S2SV_StartVul> alg->cra_ablkcipher.geniv ?: ""<built-in>""); <S2SV_EndVul> rblkcipher.blocksize = alg->cra_blocksize; rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize; rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize; rblkcipher.ivsize = alg->cra_ablkcipher.ivsize; if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER, sizeof(struct crypto_report_blkcipher), &rblkcipher)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }","- snprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""givcipher"");
- snprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, ""%s"",
- alg->cra_ablkcipher.geniv ?: ""<built-in>"");
+ strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
+ strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
+ sizeof(rblkcipher.geniv));","static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_blkcipher rblkcipher; strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type)); strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"", sizeof(rblkcipher.geniv)); rblkcipher.blocksize = alg->cra_blocksize; rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize; rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize; rblkcipher.ivsize = alg->cra_ablkcipher.ivsize; if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER, sizeof(struct crypto_report_blkcipher), &rblkcipher)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }"
944,1925----CWE-704----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-18386--n_tty.c----n_tty_ioctl,"static int n_tty_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg) { struct n_tty_data *ldata = tty->disc_data; int retval; switch (cmd) { case TIOCOUTQ: return put_user(tty_chars_in_buffer(tty), (int __user *) arg); case TIOCINQ: down_write(&tty->termios_rwsem); <S2SV_StartVul> if (L_ICANON(tty)) <S2SV_EndVul> retval = inq_canon(ldata); else retval = read_cnt(ldata); up_write(&tty->termios_rwsem); return put_user(retval, (unsigned int __user *) arg); default: return n_tty_ioctl_helper(tty, file, cmd, arg); } }","- if (L_ICANON(tty))
+ if (L_ICANON(tty) && !L_EXTPROC(tty))","static int n_tty_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg) { struct n_tty_data *ldata = tty->disc_data; int retval; switch (cmd) { case TIOCOUTQ: return put_user(tty_chars_in_buffer(tty), (int __user *) arg); case TIOCINQ: down_write(&tty->termios_rwsem); if (L_ICANON(tty) && !L_EXTPROC(tty)) retval = inq_canon(ldata); else retval = read_cnt(ldata); up_write(&tty->termios_rwsem); return put_user(retval, (unsigned int __user *) arg); default: return n_tty_ioctl_helper(tty, file, cmd, arg); } }"
945,3790----CWE-400----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/fault_64.c----do_sparc64_fault,"asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs) { struct mm_struct *mm = current->mm; struct vm_area_struct *vma; unsigned int insn = 0; int si_code, fault_code, fault; unsigned long address, mm_rss; fault_code = get_thread_fault_code(); if (notify_page_fault(regs)) return; si_code = SEGV_MAPERR; address = current_thread_info()->fault_address; if ((fault_code & FAULT_CODE_ITLB) && (fault_code & FAULT_CODE_DTLB)) BUG(); if (test_thread_flag(TIF_32BIT)) { if (!(regs->tstate & TSTATE_PRIV)) { if (unlikely((regs->tpc >> 32) != 0)) { bogus_32bit_fault_tpc(regs); goto intr_or_no_mm; } } if (unlikely((address >> 32) != 0)) { bogus_32bit_fault_address(regs, address); goto intr_or_no_mm; } } if (regs->tstate & TSTATE_PRIV) { unsigned long tpc = regs->tpc; if ((tpc >= KERNBASE && tpc < (unsigned long) __init_end) || (tpc >= MODULES_VADDR && tpc < MODULES_END)) { } else { bad_kernel_pc(regs, address); return; } } if (in_atomic() || !mm) goto intr_or_no_mm; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address); <S2SV_EndVul> if (!down_read_trylock(&mm->mmap_sem)) { if ((regs->tstate & TSTATE_PRIV) && !search_exception_tables(regs->tpc)) { insn = get_fault_insn(regs, insn); goto handle_kernel_fault; } down_read(&mm->mmap_sem); } vma = find_vma(mm, address); if (!vma) goto bad_area; if (((fault_code & (FAULT_CODE_DTLB | FAULT_CODE_WRITE | FAULT_CODE_WINFIXUP)) == FAULT_CODE_DTLB) && (vma->vm_flags & VM_WRITE) != 0) { insn = get_fault_insn(regs, 0); if (!insn) goto continue_fault; if ((insn & 0xc0200000) == 0xc0200000 && (insn & 0x01780000) != 0x01680000) { fault_code |= FAULT_CODE_WRITE; } } continue_fault: if (vma->vm_start <= address) goto good_area; if (!(vma->vm_flags & VM_GROWSDOWN)) goto bad_area; if (!(fault_code & FAULT_CODE_WRITE)) { insn = get_fault_insn(regs, insn); if ((insn & 0xc0800000) == 0xc0800000) { unsigned char asi; if (insn & 0x2000) asi = (regs->tstate >> 24); else asi = (insn >> 5); if ((asi & 0xf2) == 0x82) goto bad_area; } } if (expand_stack(vma, address)) goto bad_area; good_area: si_code = SEGV_ACCERR; if ((fault_code & FAULT_CODE_ITLB) && !(vma->vm_flags & VM_EXEC)) { BUG_ON(address != regs->tpc); BUG_ON(regs->tstate & TSTATE_PRIV); goto bad_area; } if (fault_code & FAULT_CODE_WRITE) { if (!(vma->vm_flags & VM_WRITE)) goto bad_area; if (tlb_type == spitfire && (vma->vm_flags & VM_EXEC) != 0 && vma->vm_file != NULL) set_thread_fault_code(fault_code | FAULT_CODE_BLKCOMMIT); } else { if (!(vma->vm_flags & (VM_READ | VM_EXEC))) goto bad_area; } fault = handle_mm_fault(mm, vma, address, (fault_code & FAULT_CODE_WRITE) ? FAULT_FLAG_WRITE : 0); if (unlikely(fault & VM_FAULT_ERROR)) { if (fault & VM_FAULT_OOM) goto out_of_memory; else if (fault & VM_FAULT_SIGBUS) goto do_sigbus; BUG(); } if (fault & VM_FAULT_MAJOR) { current->maj_flt++; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, <S2SV_EndVul> <S2SV_StartVul> regs, address); <S2SV_EndVul> } else { current->min_flt++; <S2SV_StartVul> perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, <S2SV_EndVul> <S2SV_StartVul> regs, address); <S2SV_EndVul> } up_read(&mm->mmap_sem); mm_rss = get_mm_rss(mm); #ifdef CONFIG_HUGETLB_PAGE mm_rss -= (mm->context.huge_pte_count * (HPAGE_SIZE / PAGE_SIZE)); #endif if (unlikely(mm_rss > mm->context.tsb_block[MM_TSB_BASE].tsb_rss_limit)) tsb_grow(mm, MM_TSB_BASE, mm_rss); #ifdef CONFIG_HUGETLB_PAGE mm_rss = mm->context.huge_pte_count; if (unlikely(mm_rss > mm->context.tsb_block[MM_TSB_HUGE].tsb_rss_limit)) tsb_grow(mm, MM_TSB_HUGE, mm_rss); #endif return; bad_area: insn = get_fault_insn(regs, insn); up_read(&mm->mmap_sem); handle_kernel_fault: do_kernel_fault(regs, si_code, fault_code, insn, address); return; out_of_memory: insn = get_fault_insn(regs, insn); up_read(&mm->mmap_sem); if (!(regs->tstate & TSTATE_PRIV)) { pagefault_out_of_memory(); return; } goto handle_kernel_fault; intr_or_no_mm: insn = get_fault_insn(regs, 0); goto handle_kernel_fault; do_sigbus: insn = get_fault_insn(regs, insn); up_read(&mm->mmap_sem); do_fault_siginfo(BUS_ADRERR, SIGBUS, regs, insn, fault_code); if (regs->tstate & TSTATE_PRIV) goto handle_kernel_fault; }","- perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);
- perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,
- regs, address);
- perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,
- regs, address);
+ perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
+ perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);
+ perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);","asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs) { struct mm_struct *mm = current->mm; struct vm_area_struct *vma; unsigned int insn = 0; int si_code, fault_code, fault; unsigned long address, mm_rss; fault_code = get_thread_fault_code(); if (notify_page_fault(regs)) return; si_code = SEGV_MAPERR; address = current_thread_info()->fault_address; if ((fault_code & FAULT_CODE_ITLB) && (fault_code & FAULT_CODE_DTLB)) BUG(); if (test_thread_flag(TIF_32BIT)) { if (!(regs->tstate & TSTATE_PRIV)) { if (unlikely((regs->tpc >> 32) != 0)) { bogus_32bit_fault_tpc(regs); goto intr_or_no_mm; } } if (unlikely((address >> 32) != 0)) { bogus_32bit_fault_address(regs, address); goto intr_or_no_mm; } } if (regs->tstate & TSTATE_PRIV) { unsigned long tpc = regs->tpc; if ((tpc >= KERNBASE && tpc < (unsigned long) __init_end) || (tpc >= MODULES_VADDR && tpc < MODULES_END)) { } else { bad_kernel_pc(regs, address); return; } } if (in_atomic() || !mm) goto intr_or_no_mm; perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address); if (!down_read_trylock(&mm->mmap_sem)) { if ((regs->tstate & TSTATE_PRIV) && !search_exception_tables(regs->tpc)) { insn = get_fault_insn(regs, insn); goto handle_kernel_fault; } down_read(&mm->mmap_sem); } vma = find_vma(mm, address); if (!vma) goto bad_area; if (((fault_code & (FAULT_CODE_DTLB | FAULT_CODE_WRITE | FAULT_CODE_WINFIXUP)) == FAULT_CODE_DTLB) && (vma->vm_flags & VM_WRITE) != 0) { insn = get_fault_insn(regs, 0); if (!insn) goto continue_fault; if ((insn & 0xc0200000) == 0xc0200000 && (insn & 0x01780000) != 0x01680000) { fault_code |= FAULT_CODE_WRITE; } } continue_fault: if (vma->vm_start <= address) goto good_area; if (!(vma->vm_flags & VM_GROWSDOWN)) goto bad_area; if (!(fault_code & FAULT_CODE_WRITE)) { insn = get_fault_insn(regs, insn); if ((insn & 0xc0800000) == 0xc0800000) { unsigned char asi; if (insn & 0x2000) asi = (regs->tstate >> 24); else asi = (insn >> 5); if ((asi & 0xf2) == 0x82) goto bad_area; } } if (expand_stack(vma, address)) goto bad_area; good_area: si_code = SEGV_ACCERR; if ((fault_code & FAULT_CODE_ITLB) && !(vma->vm_flags & VM_EXEC)) { BUG_ON(address != regs->tpc); BUG_ON(regs->tstate & TSTATE_PRIV); goto bad_area; } if (fault_code & FAULT_CODE_WRITE) { if (!(vma->vm_flags & VM_WRITE)) goto bad_area; if (tlb_type == spitfire && (vma->vm_flags & VM_EXEC) != 0 && vma->vm_file != NULL) set_thread_fault_code(fault_code | FAULT_CODE_BLKCOMMIT); } else { if (!(vma->vm_flags & (VM_READ | VM_EXEC))) goto bad_area; } fault = handle_mm_fault(mm, vma, address, (fault_code & FAULT_CODE_WRITE) ? FAULT_FLAG_WRITE : 0); if (unlikely(fault & VM_FAULT_ERROR)) { if (fault & VM_FAULT_OOM) goto out_of_memory; else if (fault & VM_FAULT_SIGBUS) goto do_sigbus; BUG(); } if (fault & VM_FAULT_MAJOR) { current->maj_flt++; perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address); } else { current->min_flt++; perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address); } up_read(&mm->mmap_sem); mm_rss = get_mm_rss(mm); #ifdef CONFIG_HUGETLB_PAGE mm_rss -= (mm->context.huge_pte_count * (HPAGE_SIZE / PAGE_SIZE)); #endif if (unlikely(mm_rss > mm->context.tsb_block[MM_TSB_BASE].tsb_rss_limit)) tsb_grow(mm, MM_TSB_BASE, mm_rss); #ifdef CONFIG_HUGETLB_PAGE mm_rss = mm->context.huge_pte_count; if (unlikely(mm_rss > mm->context.tsb_block[MM_TSB_HUGE].tsb_rss_limit)) tsb_grow(mm, MM_TSB_HUGE, mm_rss); #endif return; bad_area: insn = get_fault_insn(regs, insn); up_read(&mm->mmap_sem); handle_kernel_fault: do_kernel_fault(regs, si_code, fault_code, insn, address); return; out_of_memory: insn = get_fault_insn(regs, insn); up_read(&mm->mmap_sem); if (!(regs->tstate & TSTATE_PRIV)) { pagefault_out_of_memory(); return; } goto handle_kernel_fault; intr_or_no_mm: insn = get_fault_insn(regs, 0); goto handle_kernel_fault; do_sigbus: insn = get_fault_insn(regs, insn); up_read(&mm->mmap_sem); do_fault_siginfo(BUS_ADRERR, SIGBUS, regs, insn, fault_code); if (regs->tstate & TSTATE_PRIV) goto handle_kernel_fault; }"
946,5002----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/heap_1.c----pvPortMalloc,"void * pvPortMalloc( size_t xWantedSize ) { void * pvReturn = NULL; static uint8_t * pucAlignedHeap = NULL; #if ( portBYTE_ALIGNMENT != 1 ) { if( xWantedSize & portBYTE_ALIGNMENT_MASK ) { <S2SV_StartVul> xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ); <S2SV_EndVul> } } #endif vTaskSuspendAll(); { if( pucAlignedHeap == NULL ) { pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); } <S2SV_StartVul> if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && <S2SV_EndVul> ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) { pvReturn = pucAlignedHeap + xNextFreeByte; xNextFreeByte += xWantedSize; } traceMALLOC( pvReturn, xWantedSize ); } ( void ) xTaskResumeAll(); #if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if( pvReturn == NULL ) { extern void vApplicationMallocFailedHook( void ); vApplicationMallocFailedHook(); } } #endif return pvReturn; }","- xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
- if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
+ if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize )
+ {
+ xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
+ }
+ else
+ {
+ xWantedSize = 0;
+ }
+ ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&","void * pvPortMalloc( size_t xWantedSize ) { void * pvReturn = NULL; static uint8_t * pucAlignedHeap = NULL; #if ( portBYTE_ALIGNMENT != 1 ) { if( xWantedSize & portBYTE_ALIGNMENT_MASK ) { if ( (xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) )) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ); } else { xWantedSize = 0; } } } #endif vTaskSuspendAll(); { if( pucAlignedHeap == NULL ) { pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); } if( ( xWantedSize > 0 ) && ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) { pvReturn = pucAlignedHeap + xNextFreeByte; xNextFreeByte += xWantedSize; } traceMALLOC( pvReturn, xWantedSize ); } ( void ) xTaskResumeAll(); #if ( configUSE_MALLOC_FAILED_HOOK == 1 ) { if( pvReturn == NULL ) { extern void vApplicationMallocFailedHook( void ); vApplicationMallocFailedHook(); } } #endif return pvReturn; }"
947,2386----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2018-14880--print-ospf6.c----ospf6_print_lshdr,"ospf6_print_lshdr(netdissect_options *ndo, register const struct lsa6_hdr *lshp, const u_char *dataend) { if ((const u_char *)(lshp + 1) > dataend) goto trunc; <S2SV_StartVul> ND_TCHECK(lshp->ls_type); <S2SV_EndVul> <S2SV_StartVul> ND_TCHECK(lshp->ls_seq); <S2SV_EndVul> ND_PRINT((ndo, ""\n\t Advertising Router %s, seq 0x%08x, age %us, length %u"", ipaddr_string(ndo, &lshp->ls_router), EXTRACT_32BITS(&lshp->ls_seq), EXTRACT_16BITS(&lshp->ls_age), EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr))); ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid); return (0); trunc: return (1); }","- ND_TCHECK(lshp->ls_type);
- ND_TCHECK(lshp->ls_seq);","ospf6_print_lshdr(netdissect_options *ndo, register const struct lsa6_hdr *lshp, const u_char *dataend) { if ((const u_char *)(lshp + 1) > dataend) goto trunc; ND_TCHECK(lshp->ls_length); ND_PRINT((ndo, ""\n\t Advertising Router %s, seq 0x%08x, age %us, length %u"", ipaddr_string(ndo, &lshp->ls_router), EXTRACT_32BITS(&lshp->ls_seq), EXTRACT_16BITS(&lshp->ls_age), EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr))); ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid); return (0); trunc: return (1); }"
948,1676----CWE-125----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-3731--e_aes.c----aes_ccm_ctrl,"static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr) { EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,c); switch (type) { case EVP_CTRL_INIT: cctx->key_set = 0; cctx->iv_set = 0; cctx->L = 8; cctx->M = 12; cctx->tag_set = 0; cctx->len_set = 0; cctx->tls_aad_len = -1; return 1; case EVP_CTRL_AEAD_TLS1_AAD: if (arg != EVP_AEAD_TLS1_AAD_LEN) return 0; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); cctx->tls_aad_len = arg; { uint16_t len = EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1]; len -= EVP_CCM_TLS_EXPLICIT_IV_LEN; <S2SV_StartVul> if (!EVP_CIPHER_CTX_encrypting(c)) <S2SV_EndVul> len -= cctx->M; EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8; EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff; } return cctx->M; case EVP_CTRL_CCM_SET_IV_FIXED: if (arg != EVP_CCM_TLS_FIXED_IV_LEN) return 0; memcpy(EVP_CIPHER_CTX_iv_noconst(c), ptr, arg); return 1; case EVP_CTRL_AEAD_SET_IVLEN: arg = 15 - arg; case EVP_CTRL_CCM_SET_L: if (arg < 2 || arg > 8) return 0; cctx->L = arg; return 1; case EVP_CTRL_AEAD_SET_TAG: if ((arg & 1) || arg < 4 || arg > 16) return 0; if (EVP_CIPHER_CTX_encrypting(c) && ptr) return 0; if (ptr) { cctx->tag_set = 1; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); } cctx->M = arg; return 1; case EVP_CTRL_AEAD_GET_TAG: if (!EVP_CIPHER_CTX_encrypting(c) || !cctx->tag_set) return 0; if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg)) return 0; cctx->tag_set = 0; cctx->iv_set = 0; cctx->len_set = 0; return 1; case EVP_CTRL_COPY: { EVP_CIPHER_CTX *out = ptr; EVP_AES_CCM_CTX *cctx_out = EVP_C_DATA(EVP_AES_CCM_CTX,out); if (cctx->ccm.key) { if (cctx->ccm.key != &cctx->ks) return 0; cctx_out->ccm.key = &cctx_out->ks; } return 1; } default: return -1; } }","- if (!EVP_CIPHER_CTX_encrypting(c))
+ if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)
+ return 0;
+ if (!EVP_CIPHER_CTX_encrypting(c)) {
+ if (len < cctx->M)
+ return 0;
+ }","static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr) { EVP_AES_CCM_CTX *cctx = EVP_C_DATA(EVP_AES_CCM_CTX,c); switch (type) { case EVP_CTRL_INIT: cctx->key_set = 0; cctx->iv_set = 0; cctx->L = 8; cctx->M = 12; cctx->tag_set = 0; cctx->len_set = 0; cctx->tls_aad_len = -1; return 1; case EVP_CTRL_AEAD_TLS1_AAD: if (arg != EVP_AEAD_TLS1_AAD_LEN) return 0; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); cctx->tls_aad_len = arg; { uint16_t len = EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1]; if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN) return 0; len -= EVP_CCM_TLS_EXPLICIT_IV_LEN; if (!EVP_CIPHER_CTX_encrypting(c)) { if (len < cctx->M) return 0; len -= cctx->M; } EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8; EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff; } return cctx->M; case EVP_CTRL_CCM_SET_IV_FIXED: if (arg != EVP_CCM_TLS_FIXED_IV_LEN) return 0; memcpy(EVP_CIPHER_CTX_iv_noconst(c), ptr, arg); return 1; case EVP_CTRL_AEAD_SET_IVLEN: arg = 15 - arg; case EVP_CTRL_CCM_SET_L: if (arg < 2 || arg > 8) return 0; cctx->L = arg; return 1; case EVP_CTRL_AEAD_SET_TAG: if ((arg & 1) || arg < 4 || arg > 16) return 0; if (EVP_CIPHER_CTX_encrypting(c) && ptr) return 0; if (ptr) { cctx->tag_set = 1; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); } cctx->M = arg; return 1; case EVP_CTRL_AEAD_GET_TAG: if (!EVP_CIPHER_CTX_encrypting(c) || !cctx->tag_set) return 0; if (!CRYPTO_ccm128_tag(&cctx->ccm, ptr, (size_t)arg)) return 0; cctx->tag_set = 0; cctx->iv_set = 0; cctx->len_set = 0; return 1; case EVP_CTRL_COPY: { EVP_CIPHER_CTX *out = ptr; EVP_AES_CCM_CTX *cctx_out = EVP_C_DATA(EVP_AES_CCM_CTX,out); if (cctx->ccm.key) { if (cctx->ccm.key != &cctx->ks) return 0; cctx_out->ccm.key = &cctx_out->ks; } return 1; } default: return -1; } }"
949,7482----NVD-CWE-noinfo----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cl_main.c----CL_InitRef,"void CL_InitRef( void ) { refimport_t ri; refexport_t *ret; #ifdef USE_RENDERER_DLOPEN GetRefAPI_t GetRefAPI; char dllName[MAX_OSPATH]; #endif Com_Printf( ""----- Initializing Renderer ----\n"" ); #ifdef USE_RENDERER_DLOPEN <S2SV_StartVul> cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH); <S2SV_EndVul> Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string); if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString)) { Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError()); Cvar_ForceReset(""cl_renderer""); Com_sprintf(dllName, sizeof(dllName), ""renderer_opengl2_"" ARCH_STRING DLL_EXT); rendererLib = Sys_LoadDll(dllName, qfalse); } if(!rendererLib) { Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError()); Com_Error(ERR_FATAL, ""Failed to load renderer""); } GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI""); if(!GetRefAPI) { Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"", Sys_LibraryError()); } #endif ri.Cmd_AddCommand = Cmd_AddCommand; ri.Cmd_RemoveCommand = Cmd_RemoveCommand; ri.Cmd_Argc = Cmd_Argc; ri.Cmd_Argv = Cmd_Argv; ri.Cmd_ExecuteText = Cbuf_ExecuteText; ri.Printf = CL_RefPrintf; ri.Error = Com_Error; ri.Milliseconds = CL_ScaledMilliseconds; ri.Malloc = CL_RefMalloc; ri.Free = Z_Free; #ifdef HUNK_DEBUG ri.Hunk_AllocDebug = Hunk_AllocDebug; #else ri.Hunk_Alloc = Hunk_Alloc; #endif ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory; ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory; ri.CM_ClusterPVS = CM_ClusterPVS; ri.CM_DrawDebugSurface = CM_DrawDebugSurface; ri.FS_ReadFile = FS_ReadFile; ri.FS_FreeFile = FS_FreeFile; ri.FS_WriteFile = FS_WriteFile; ri.FS_FreeFileList = FS_FreeFileList; ri.FS_ListFiles = FS_ListFiles; ri.FS_FileIsInPAK = FS_FileIsInPAK; ri.FS_FileExists = FS_FileExists; ri.Cvar_Get = Cvar_Get; ri.Cvar_Set = Cvar_Set; ri.Cvar_SetValue = Cvar_SetValue; ri.Cvar_CheckRange = Cvar_CheckRange; ri.Cvar_SetDescription = Cvar_SetDescription; ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue; ri.CIN_UploadCinematic = CIN_UploadCinematic; ri.CIN_PlayCinematic = CIN_PlayCinematic; ri.CIN_RunCinematic = CIN_RunCinematic; ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame; ri.IN_Init = IN_Init; ri.IN_Shutdown = IN_Shutdown; ri.IN_Restart = IN_Restart; ri.ftol = Q_ftol; ri.Sys_SetEnv = Sys_SetEnv; ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit; ri.Sys_GLimpInit = Sys_GLimpInit; ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory; ret = GetRefAPI( REF_API_VERSION, &ri ); #if defined __USEA3D && defined __A3D_GEOM hA3Dg_ExportRenderGeom (ret); #endif Com_Printf( ""-------------------------------\n""); if ( !ret ) { Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" ); } re = *ret; Cvar_Set( ""cl_paused"", ""0"" ); }","- cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH);
+ cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED);","void CL_InitRef( void ) { refimport_t ri; refexport_t *ret; #ifdef USE_RENDERER_DLOPEN GetRefAPI_t GetRefAPI; char dllName[MAX_OSPATH]; #endif Com_Printf( ""----- Initializing Renderer ----\n"" ); #ifdef USE_RENDERER_DLOPEN cl_renderer = Cvar_Get(""cl_renderer"", ""opengl2"", CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED); Com_sprintf(dllName, sizeof(dllName), ""renderer_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string); if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString)) { Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError()); Cvar_ForceReset(""cl_renderer""); Com_sprintf(dllName, sizeof(dllName), ""renderer_opengl2_"" ARCH_STRING DLL_EXT); rendererLib = Sys_LoadDll(dllName, qfalse); } if(!rendererLib) { Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError()); Com_Error(ERR_FATAL, ""Failed to load renderer""); } GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI""); if(!GetRefAPI) { Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"", Sys_LibraryError()); } #endif ri.Cmd_AddCommand = Cmd_AddCommand; ri.Cmd_RemoveCommand = Cmd_RemoveCommand; ri.Cmd_Argc = Cmd_Argc; ri.Cmd_Argv = Cmd_Argv; ri.Cmd_ExecuteText = Cbuf_ExecuteText; ri.Printf = CL_RefPrintf; ri.Error = Com_Error; ri.Milliseconds = CL_ScaledMilliseconds; ri.Malloc = CL_RefMalloc; ri.Free = Z_Free; #ifdef HUNK_DEBUG ri.Hunk_AllocDebug = Hunk_AllocDebug; #else ri.Hunk_Alloc = Hunk_Alloc; #endif ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory; ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory; ri.CM_ClusterPVS = CM_ClusterPVS; ri.CM_DrawDebugSurface = CM_DrawDebugSurface; ri.FS_ReadFile = FS_ReadFile; ri.FS_FreeFile = FS_FreeFile; ri.FS_WriteFile = FS_WriteFile; ri.FS_FreeFileList = FS_FreeFileList; ri.FS_ListFiles = FS_ListFiles; ri.FS_FileIsInPAK = FS_FileIsInPAK; ri.FS_FileExists = FS_FileExists; ri.Cvar_Get = Cvar_Get; ri.Cvar_Set = Cvar_Set; ri.Cvar_SetValue = Cvar_SetValue; ri.Cvar_CheckRange = Cvar_CheckRange; ri.Cvar_SetDescription = Cvar_SetDescription; ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue; ri.CIN_UploadCinematic = CIN_UploadCinematic; ri.CIN_PlayCinematic = CIN_PlayCinematic; ri.CIN_RunCinematic = CIN_RunCinematic; ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame; ri.IN_Init = IN_Init; ri.IN_Shutdown = IN_Shutdown; ri.IN_Restart = IN_Restart; ri.ftol = Q_ftol; ri.Sys_SetEnv = Sys_SetEnv; ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit; ri.Sys_GLimpInit = Sys_GLimpInit; ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory; ret = GetRefAPI( REF_API_VERSION, &ri ); #if defined __USEA3D && defined __A3D_GEOM hA3Dg_ExportRenderGeom (ret); #endif Com_Printf( ""-------------------------------\n""); if ( !ret ) { Com_Error (ERR_FATAL, ""Couldn't initialize refresh"" ); } re = *ret; Cvar_Set( ""cl_paused"", ""0"" ); }"
950,3043----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/secure_enclave.c----trustedSetSEK_backup,"void trustedSetSEK_backup(int *errStatus, char *errString, <S2SV_StartVul> uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) { <S2SV_EndVul> CALL_ONCE LOG_INFO(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(encrypted_sek); CHECK_STATE(sek_hex); uint64_t len; hex2carray(sek_hex, &len, (uint8_t *) AES_key); derive_DH_Key(); sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex); if (*errStatus != 0) { LOG_ERROR(""sealHexSEK failed""); goto clean; } SET_SUCCESS clean: ; LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }","- uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {
+ uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) {","void trustedSetSEK_backup(int *errStatus, char *errString, uint8_t *encrypted_sek, uint64_t *enc_len, const char *sek_hex) { CALL_ONCE LOG_INFO(__FUNCTION__); INIT_ERROR_STATE CHECK_STATE(encrypted_sek); CHECK_STATE(sek_hex); uint64_t len; hex2carray(sek_hex, &len, (uint8_t *) AES_key); derive_DH_Key(); sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex); if (*errStatus != 0) { LOG_ERROR(""sealHexSEK failed""); goto clean; } SET_SUCCESS clean: ; LOG_INFO(__FUNCTION__ ); LOG_INFO(""SGX call completed""); }"
951,4546----CWE-264----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip6_tables.c----check_compat_entry_size_and_hooks,"check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_match *ematch; struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; unsigned int j; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 || (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_ip6t_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!ip6_checkentry(&e->ipv6)) return -EINVAL; <S2SV_StartVul> ret = xt_compat_check_entry_offsets(e, <S2SV_EndVul> e->target_offset, e->next_offset); if (ret) return ret; off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry); entry_offset = (void *)e - (void *)base; j = 0; xt_ematch_foreach(ematch, e) { ret = compat_find_calc_match(ematch, name, &e->ipv6, &off); if (ret != 0) goto release_matches; ++j; } t = compat_ip6t_get_target(e); target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto release_matches; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(AF_INET6, entry_offset, off); if (ret) goto out; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; out: module_put(t->u.kernel.target->me); release_matches: xt_ematch_foreach(ematch, e) { if (j-- == 0) break; module_put(ematch->u.kernel.match->me); } return ret; }","- ret = xt_compat_check_entry_offsets(e,
+ ret = xt_compat_check_entry_offsets(e, e->elems,","check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_match *ematch; struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; unsigned int j; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 || (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_ip6t_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!ip6_checkentry(&e->ipv6)) return -EINVAL; ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset, e->next_offset); if (ret) return ret; off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry); entry_offset = (void *)e - (void *)base; j = 0; xt_ematch_foreach(ematch, e) { ret = compat_find_calc_match(ematch, name, &e->ipv6, &off); if (ret != 0) goto release_matches; ++j; } t = compat_ip6t_get_target(e); target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto release_matches; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(AF_INET6, entry_offset, off); if (ret) goto out; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; out: module_put(t->u.kernel.target->me); release_matches: xt_ematch_foreach(ematch, e) { if (j-- == 0) break; module_put(ematch->u.kernel.match->me); } return ret; }"
952,1044----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2016-4440--vmx.c----hardware_setup,"static __init int hardware_setup(void) { int r = -ENOMEM, i, msr; rdmsrl_safe(MSR_EFER, &host_efer); for (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) kvm_define_shared_msr(i, vmx_msr_index[i]); vmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_io_bitmap_a) return r; vmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_io_bitmap_b) goto out; vmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_legacy) goto out1; vmx_msr_bitmap_legacy_x2apic = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_legacy_x2apic) goto out2; vmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_longmode) goto out3; vmx_msr_bitmap_longmode_x2apic = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_longmode_x2apic) goto out4; if (nested) { vmx_msr_bitmap_nested = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_nested) goto out5; } vmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_vmread_bitmap) goto out6; vmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_vmwrite_bitmap) goto out7; memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE); memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE); memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE); clear_bit(0x80, vmx_io_bitmap_a); memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE); memset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE); memset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE); if (nested) memset(vmx_msr_bitmap_nested, 0xff, PAGE_SIZE); if (setup_vmcs_config(&vmcs_config) < 0) { r = -EIO; goto out8; } if (boot_cpu_has(X86_FEATURE_NX)) kvm_enable_efer_bits(EFER_NX); if (!cpu_has_vmx_vpid()) enable_vpid = 0; if (!cpu_has_vmx_shadow_vmcs()) enable_shadow_vmcs = 0; if (enable_shadow_vmcs) init_vmcs_shadow_fields(); if (!cpu_has_vmx_ept() || !cpu_has_vmx_ept_4levels()) { enable_ept = 0; enable_unrestricted_guest = 0; enable_ept_ad_bits = 0; } if (!cpu_has_vmx_ept_ad_bits()) enable_ept_ad_bits = 0; if (!cpu_has_vmx_unrestricted_guest()) enable_unrestricted_guest = 0; if (!cpu_has_vmx_flexpriority()) flexpriority_enabled = 0; if (!flexpriority_enabled) kvm_x86_ops->set_apic_access_page_addr = NULL; if (!cpu_has_vmx_tpr_shadow()) kvm_x86_ops->update_cr8_intercept = NULL; if (enable_ept && !cpu_has_vmx_ept_2m_page()) kvm_disable_largepages(); if (!cpu_has_vmx_ple()) ple_gap = 0; if (!cpu_has_vmx_apicv()) enable_apicv = 0; if (cpu_has_vmx_tsc_scaling()) { kvm_has_tsc_control = true; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX; kvm_tsc_scaling_ratio_frac_bits = 48; } vmx_disable_intercept_for_msr(MSR_FS_BASE, false); vmx_disable_intercept_for_msr(MSR_GS_BASE, false); vmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true); vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false); vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false); vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false); vmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true); memcpy(vmx_msr_bitmap_legacy_x2apic, vmx_msr_bitmap_legacy, PAGE_SIZE); memcpy(vmx_msr_bitmap_longmode_x2apic, vmx_msr_bitmap_longmode, PAGE_SIZE); set_bit(0, vmx_vpid_bitmap); <S2SV_StartVul> if (enable_apicv) { <S2SV_EndVul> <S2SV_StartVul> for (msr = 0x800; msr <= 0x8ff; msr++) <S2SV_EndVul> <S2SV_StartVul> vmx_disable_intercept_msr_read_x2apic(msr); <S2SV_EndVul> <S2SV_EndVul> <S2SV_StartVul> vmx_enable_intercept_msr_read_x2apic(0x802); <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> vmx_enable_intercept_msr_read_x2apic(0x839); <S2SV_StartVul> <S2SV_EndVul> vmx_disable_intercept_msr_write_x2apic(0x808); <S2SV_StartVul> <S2SV_EndVul> vmx_disable_intercept_msr_write_x2apic(0x80b); <S2SV_StartVul> <S2SV_EndVul> vmx_disable_intercept_msr_write_x2apic(0x83f); <S2SV_StartVul> } <S2SV_EndVul> <S2SV_StartVul> <S2SV_EndVul> if (enable_ept) { kvm_mmu_set_mask_ptes(0ull, (enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull, (enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull, 0ull, VMX_EPT_EXECUTABLE_MASK); ept_set_mmio_spte_mask(); kvm_enable_tdp(); } else kvm_disable_tdp(); update_ple_window_actual_max(); if (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml()) enable_pml = 0; if (!enable_pml) { kvm_x86_ops->slot_enable_log_dirty = NULL; kvm_x86_ops->slot_disable_log_dirty = NULL; kvm_x86_ops->flush_log_dirty = NULL; kvm_x86_ops->enable_log_dirty_pt_masked = NULL; } kvm_set_posted_intr_wakeup_handler(wakeup_handler); return alloc_kvm_area(); out8: free_page((unsigned long)vmx_vmwrite_bitmap); out7: free_page((unsigned long)vmx_vmread_bitmap); out6: if (nested) free_page((unsigned long)vmx_msr_bitmap_nested); out5: free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic); out4: free_page((unsigned long)vmx_msr_bitmap_longmode); out3: free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic); out2: free_page((unsigned long)vmx_msr_bitmap_legacy); out1: free_page((unsigned long)vmx_io_bitmap_b); out: free_page((unsigned long)vmx_io_bitmap_a); return r; }","- if (enable_apicv) {
- for (msr = 0x800; msr <= 0x8ff; msr++)
- vmx_disable_intercept_msr_read_x2apic(msr);
- vmx_enable_intercept_msr_read_x2apic(0x802);
- }
- 
+ for (msr = 0x800; msr <= 0x8ff; msr++)
+ vmx_disable_intercept_msr_read_x2apic(msr);
+ vmx_enable_intercept_msr_read_x2apic(0x802);
+ vmx_enable_intercept_msr_read_x2apic(0x839);
+ vmx_disable_intercept_msr_write_x2apic(0x808);
+ vmx_disable_intercept_msr_write_x2apic(0x80b);
+ vmx_disable_intercept_msr_write_x2apic(0x83f);","static __init int hardware_setup(void) { int r = -ENOMEM, i, msr; rdmsrl_safe(MSR_EFER, &host_efer); for (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) kvm_define_shared_msr(i, vmx_msr_index[i]); vmx_io_bitmap_a = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_io_bitmap_a) return r; vmx_io_bitmap_b = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_io_bitmap_b) goto out; vmx_msr_bitmap_legacy = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_legacy) goto out1; vmx_msr_bitmap_legacy_x2apic = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_legacy_x2apic) goto out2; vmx_msr_bitmap_longmode = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_longmode) goto out3; vmx_msr_bitmap_longmode_x2apic = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_longmode_x2apic) goto out4; if (nested) { vmx_msr_bitmap_nested = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_msr_bitmap_nested) goto out5; } vmx_vmread_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_vmread_bitmap) goto out6; vmx_vmwrite_bitmap = (unsigned long *)__get_free_page(GFP_KERNEL); if (!vmx_vmwrite_bitmap) goto out7; memset(vmx_vmread_bitmap, 0xff, PAGE_SIZE); memset(vmx_vmwrite_bitmap, 0xff, PAGE_SIZE); memset(vmx_io_bitmap_a, 0xff, PAGE_SIZE); clear_bit(0x80, vmx_io_bitmap_a); memset(vmx_io_bitmap_b, 0xff, PAGE_SIZE); memset(vmx_msr_bitmap_legacy, 0xff, PAGE_SIZE); memset(vmx_msr_bitmap_longmode, 0xff, PAGE_SIZE); if (nested) memset(vmx_msr_bitmap_nested, 0xff, PAGE_SIZE); if (setup_vmcs_config(&vmcs_config) < 0) { r = -EIO; goto out8; } if (boot_cpu_has(X86_FEATURE_NX)) kvm_enable_efer_bits(EFER_NX); if (!cpu_has_vmx_vpid()) enable_vpid = 0; if (!cpu_has_vmx_shadow_vmcs()) enable_shadow_vmcs = 0; if (enable_shadow_vmcs) init_vmcs_shadow_fields(); if (!cpu_has_vmx_ept() || !cpu_has_vmx_ept_4levels()) { enable_ept = 0; enable_unrestricted_guest = 0; enable_ept_ad_bits = 0; } if (!cpu_has_vmx_ept_ad_bits()) enable_ept_ad_bits = 0; if (!cpu_has_vmx_unrestricted_guest()) enable_unrestricted_guest = 0; if (!cpu_has_vmx_flexpriority()) flexpriority_enabled = 0; if (!flexpriority_enabled) kvm_x86_ops->set_apic_access_page_addr = NULL; if (!cpu_has_vmx_tpr_shadow()) kvm_x86_ops->update_cr8_intercept = NULL; if (enable_ept && !cpu_has_vmx_ept_2m_page()) kvm_disable_largepages(); if (!cpu_has_vmx_ple()) ple_gap = 0; if (!cpu_has_vmx_apicv()) enable_apicv = 0; if (cpu_has_vmx_tsc_scaling()) { kvm_has_tsc_control = true; kvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX; kvm_tsc_scaling_ratio_frac_bits = 48; } vmx_disable_intercept_for_msr(MSR_FS_BASE, false); vmx_disable_intercept_for_msr(MSR_GS_BASE, false); vmx_disable_intercept_for_msr(MSR_KERNEL_GS_BASE, true); vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_CS, false); vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_ESP, false); vmx_disable_intercept_for_msr(MSR_IA32_SYSENTER_EIP, false); vmx_disable_intercept_for_msr(MSR_IA32_BNDCFGS, true); memcpy(vmx_msr_bitmap_legacy_x2apic, vmx_msr_bitmap_legacy, PAGE_SIZE); memcpy(vmx_msr_bitmap_longmode_x2apic, vmx_msr_bitmap_longmode, PAGE_SIZE); set_bit(0, vmx_vpid_bitmap); for (msr = 0x800; msr <= 0x8ff; msr++) vmx_disable_intercept_msr_read_x2apic(msr); vmx_enable_intercept_msr_read_x2apic(0x802); vmx_enable_intercept_msr_read_x2apic(0x839); vmx_disable_intercept_msr_write_x2apic(0x808); vmx_disable_intercept_msr_write_x2apic(0x80b); vmx_disable_intercept_msr_write_x2apic(0x83f); if (enable_ept) { kvm_mmu_set_mask_ptes(0ull, (enable_ept_ad_bits) ? VMX_EPT_ACCESS_BIT : 0ull, (enable_ept_ad_bits) ? VMX_EPT_DIRTY_BIT : 0ull, 0ull, VMX_EPT_EXECUTABLE_MASK); ept_set_mmio_spte_mask(); kvm_enable_tdp(); } else kvm_disable_tdp(); update_ple_window_actual_max(); if (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml()) enable_pml = 0; if (!enable_pml) { kvm_x86_ops->slot_enable_log_dirty = NULL; kvm_x86_ops->slot_disable_log_dirty = NULL; kvm_x86_ops->flush_log_dirty = NULL; kvm_x86_ops->enable_log_dirty_pt_masked = NULL; } kvm_set_posted_intr_wakeup_handler(wakeup_handler); return alloc_kvm_area(); out8: free_page((unsigned long)vmx_vmwrite_bitmap); out7: free_page((unsigned long)vmx_vmread_bitmap); out6: if (nested) free_page((unsigned long)vmx_msr_bitmap_nested); out5: free_page((unsigned long)vmx_msr_bitmap_longmode_x2apic); out4: free_page((unsigned long)vmx_msr_bitmap_longmode); out3: free_page((unsigned long)vmx_msr_bitmap_legacy_x2apic); out2: free_page((unsigned long)vmx_msr_bitmap_legacy); out1: free_page((unsigned long)vmx_io_bitmap_b); out: free_page((unsigned long)vmx_io_bitmap_a); return r; }"
953,7204----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/hns_dsaf_xgmac.c----hns_xgmac_get_sset_count,static int hns_xgmac_get_sset_count(int stringset) { <S2SV_StartVul> if (stringset == ETH_SS_STATS) <S2SV_EndVul> return ARRAY_SIZE(g_xgmac_stats_string); return 0; },"- if (stringset == ETH_SS_STATS)
+ if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)",static int hns_xgmac_get_sset_count(int stringset) { if (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS) return ARRAY_SIZE(g_xgmac_stats_string); return 0; }
954,7205----CWE-252----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/tiff.c----ReadGROUP4Image,"static Image *ReadGROUP4Image(const ImageInfo *image_info, ExceptionInfo *exception) { char filename[MagickPathExtent]; FILE *file; Image *image; ImageInfo *read_info; int c, unique_file; MagickBooleanType status; size_t length; ssize_t offset, strip_offset; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } file=(FILE *) NULL; unique_file=AcquireUniqueFileResource(filename); if (unique_file != -1) file=fdopen(unique_file,""wb""); if ((unique_file == -1) || (file == (FILE *) NULL)) ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile""); length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file); length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file); length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,image->columns); length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,image->rows); length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file); length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file); length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file); length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file); strip_offset=10+(12*14)+4+8; length=WriteLSBLong(file,(size_t) strip_offset); length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,(size_t) image_info->orientation); length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file); length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,image->rows); length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file); offset=(ssize_t) ftell(file)-4; length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,(size_t) (strip_offset-8)); length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,(size_t) (strip_offset-8)); length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file); length=fwrite(""\000\000\000\000"",1,4,file); length=WriteLSBLong(file,(long) image->resolution.x); length=WriteLSBLong(file,1); for (length=0; (c=ReadBlobByte(image)) != EOF; length++) <S2SV_StartVul> (void) fputc(c,file); <S2SV_EndVul> offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET); length=WriteLSBLong(file,(unsigned int) length); (void) fclose(file); (void) CloseBlob(image); image=DestroyImage(image); read_info=CloneImageInfo((ImageInfo *) NULL); (void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename); image=ReadTIFFImage(read_info,exception); read_info=DestroyImageInfo(read_info); if (image != (Image *) NULL) { (void) CopyMagickString(image->filename,image_info->filename, MagickPathExtent); (void) CopyMagickString(image->magick_filename,image_info->filename, MagickPathExtent); (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent); } (void) RelinquishUniqueFileResource(filename); return(image); }","- (void) fputc(c,file);
+ status=MagickTrue;
+ if (fputc(c,file) != c)
+ status=MagickFalse;
+ if (status == MagickFalse)
+ image=DestroyImage(image);","static Image *ReadGROUP4Image(const ImageInfo *image_info, ExceptionInfo *exception) { char filename[MagickPathExtent]; FILE *file; Image *image; ImageInfo *read_info; int c, unique_file; MagickBooleanType status; size_t length; ssize_t offset, strip_offset; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } file=(FILE *) NULL; unique_file=AcquireUniqueFileResource(filename); if (unique_file != -1) file=fdopen(unique_file,""wb""); if ((unique_file == -1) || (file == (FILE *) NULL)) ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile""); length=fwrite(""\111\111\052\000\010\000\000\000\016\000"",1,10,file); length=fwrite(""\376\000\003\000\001\000\000\000\000\000\000\000"",1,12,file); length=fwrite(""\000\001\004\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,image->columns); length=fwrite(""\001\001\004\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,image->rows); length=fwrite(""\002\001\003\000\001\000\000\000\001\000\000\000"",1,12,file); length=fwrite(""\003\001\003\000\001\000\000\000\004\000\000\000"",1,12,file); length=fwrite(""\006\001\003\000\001\000\000\000\000\000\000\000"",1,12,file); length=fwrite(""\021\001\003\000\001\000\000\000"",1,8,file); strip_offset=10+(12*14)+4+8; length=WriteLSBLong(file,(size_t) strip_offset); length=fwrite(""\022\001\003\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,(size_t) image_info->orientation); length=fwrite(""\025\001\003\000\001\000\000\000\001\000\000\000"",1,12,file); length=fwrite(""\026\001\004\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,image->rows); length=fwrite(""\027\001\004\000\001\000\000\000\000\000\000\000"",1,12,file); offset=(ssize_t) ftell(file)-4; length=fwrite(""\032\001\005\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,(size_t) (strip_offset-8)); length=fwrite(""\033\001\005\000\001\000\000\000"",1,8,file); length=WriteLSBLong(file,(size_t) (strip_offset-8)); length=fwrite(""\050\001\003\000\001\000\000\000\002\000\000\000"",1,12,file); length=fwrite(""\000\000\000\000"",1,4,file); length=WriteLSBLong(file,(long) image->resolution.x); length=WriteLSBLong(file,1); status=MagickTrue; for (length=0; (c=ReadBlobByte(image)) != EOF; length++) if (fputc(c,file) != c) status=MagickFalse; offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET); length=WriteLSBLong(file,(unsigned int) length); (void) fclose(file); (void) CloseBlob(image); image=DestroyImage(image); read_info=CloneImageInfo((ImageInfo *) NULL); (void) FormatLocaleString(read_info->filename,MagickPathExtent,""%s"",filename); image=ReadTIFFImage(read_info,exception); read_info=DestroyImageInfo(read_info); if (image != (Image *) NULL) { (void) CopyMagickString(image->filename,image_info->filename, MagickPathExtent); (void) CopyMagickString(image->magick_filename,image_info->filename, MagickPathExtent); (void) CopyMagickString(image->magick,""GROUP4"",MagickPathExtent); } (void) RelinquishUniqueFileResource(filename); if (status == MagickFalse) image=DestroyImage(image); return(image); }"
955,4851----CWE-189----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/cdf.c----cdf_read_property_info,"cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount) { const cdf_section_header_t *shp; cdf_section_header_t sh; const uint8_t *p, *q, *e; int16_t s16; int32_t s32; uint32_t u32; int64_t s64; uint64_t u64; cdf_timestamp_t tp; size_t i, o, o4, nelements, j; cdf_property_info_t *inp; if (offs > UINT32_MAX / 4) { errno = EFTYPE; goto out; } shp = CAST(const cdf_section_header_t *, (const void *) ((const char *)sst->sst_tab + offs)); if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1) goto out; sh.sh_len = CDF_TOLE4(shp->sh_len); #define CDF_SHLEN_LIMIT (UINT32_MAX / 8) if (sh.sh_len > CDF_SHLEN_LIMIT) { errno = EFTYPE; goto out; } sh.sh_properties = CDF_TOLE4(shp->sh_properties); #define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp))) if (sh.sh_properties > CDF_PROP_LIMIT) goto out; DPRINTF((""section len: %u properties %u\n"", sh.sh_len, sh.sh_properties)); if (*maxcount) { if (*maxcount > CDF_PROP_LIMIT) goto out; *maxcount += sh.sh_properties; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); } else { *maxcount = sh.sh_properties; inp = CAST(cdf_property_info_t *, malloc(*maxcount * sizeof(*inp))); } if (inp == NULL) goto out; *info = inp; inp += *count; *count += sh.sh_properties; p = CAST(const uint8_t *, (const void *) ((const char *)(const void *)sst->sst_tab + offs + sizeof(sh))); e = CAST(const uint8_t *, (const void *) (((const char *)(const void *)shp) + sh.sh_len)); if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) goto out; for (i = 0; i < sh.sh_properties; i++) { size_t ofs, tail = (i << 1) + 1; if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t), __LINE__) == -1) goto out; ofs = CDF_GETUINT32(p, tail); q = (const uint8_t *)(const void *) ((const char *)(const void *)p + ofs - 2 * sizeof(uint32_t)); <S2SV_StartVul> if (q > e) { <S2SV_EndVul> DPRINTF((""Ran of the end %p > %p\n"", q, e)); goto out; } inp[i].pi_id = CDF_GETUINT32(p, i << 1); inp[i].pi_type = CDF_GETUINT32(q, 0); DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"", i, inp[i].pi_id, inp[i].pi_type, q - p, offs)); if (inp[i].pi_type & CDF_VECTOR) { nelements = CDF_GETUINT32(q, 1); if (nelements == 0) { DPRINTF((""CDF_VECTOR with nelements == 0\n"")); goto out; } o = 2; } else { nelements = 1; o = 1; } o4 = o * sizeof(uint32_t); if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED)) goto unknown; switch (inp[i].pi_type & CDF_TYPEMASK) { case CDF_NULL: case CDF_EMPTY: break; case CDF_SIGNED16: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s16, &q[o4], sizeof(s16)); inp[i].pi_s16 = CDF_TOLE2(s16); break; case CDF_SIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s32, &q[o4], sizeof(s32)); inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32); break; case CDF_BOOL: case CDF_UNSIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); inp[i].pi_u32 = CDF_TOLE4(u32); break; case CDF_SIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s64, &q[o4], sizeof(s64)); inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64); break; case CDF_UNSIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64); break; case CDF_FLOAT: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); u32 = CDF_TOLE4(u32); memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f)); break; case CDF_DOUBLE: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); u64 = CDF_TOLE8((uint64_t)u64); memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d)); break; case CDF_LENGTH32_STRING: case CDF_LENGTH32_WSTRING: if (nelements > 1) { size_t nelem = inp - *info; if (*maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT) goto out; *maxcount += nelements; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); if (inp == NULL) goto out; *info = inp; inp = *info + nelem; } DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"", nelements)); for (j = 0; j < nelements && i < sh.sh_properties; j++, i++) { uint32_t l = CDF_GETUINT32(q, o); inp[i].pi_str.s_len = l; inp[i].pi_str.s_buf = (const char *) (const void *)(&q[o4 + sizeof(l)]); DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT ""u, s = %s\n"", l, CDF_ROUND(l, sizeof(l)), inp[i].pi_str.s_buf)); if (l & 1) l++; o += l >> 1; if (q + o >= e) goto out; o4 = o * sizeof(uint32_t); } i--; break; case CDF_FILETIME: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&tp, &q[o4], sizeof(tp)); inp[i].pi_tp = CDF_TOLE8((uint64_t)tp); break; case CDF_CLIPBOARD: if (inp[i].pi_type & CDF_VECTOR) goto unknown; break; default: unknown: DPRINTF((""Don't know how to deal with %x\n"", inp[i].pi_type)); break; } } return 0; out: free(*info); return -1; }","- if (q > e) {
+ if (q < p || q > e) {","cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h, uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount) { const cdf_section_header_t *shp; cdf_section_header_t sh; const uint8_t *p, *q, *e; int16_t s16; int32_t s32; uint32_t u32; int64_t s64; uint64_t u64; cdf_timestamp_t tp; size_t i, o, o4, nelements, j; cdf_property_info_t *inp; if (offs > UINT32_MAX / 4) { errno = EFTYPE; goto out; } shp = CAST(const cdf_section_header_t *, (const void *) ((const char *)sst->sst_tab + offs)); if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1) goto out; sh.sh_len = CDF_TOLE4(shp->sh_len); #define CDF_SHLEN_LIMIT (UINT32_MAX / 8) if (sh.sh_len > CDF_SHLEN_LIMIT) { errno = EFTYPE; goto out; } sh.sh_properties = CDF_TOLE4(shp->sh_properties); #define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp))) if (sh.sh_properties > CDF_PROP_LIMIT) goto out; DPRINTF((""section len: %u properties %u\n"", sh.sh_len, sh.sh_properties)); if (*maxcount) { if (*maxcount > CDF_PROP_LIMIT) goto out; *maxcount += sh.sh_properties; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); } else { *maxcount = sh.sh_properties; inp = CAST(cdf_property_info_t *, malloc(*maxcount * sizeof(*inp))); } if (inp == NULL) goto out; *info = inp; inp += *count; *count += sh.sh_properties; p = CAST(const uint8_t *, (const void *) ((const char *)(const void *)sst->sst_tab + offs + sizeof(sh))); e = CAST(const uint8_t *, (const void *) (((const char *)(const void *)shp) + sh.sh_len)); if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1) goto out; for (i = 0; i < sh.sh_properties; i++) { size_t ofs, tail = (i << 1) + 1; if (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t), __LINE__) == -1) goto out; ofs = CDF_GETUINT32(p, tail); q = (const uint8_t *)(const void *) ((const char *)(const void *)p + ofs - 2 * sizeof(uint32_t)); if (q < p || q > e) { DPRINTF((""Ran of the end %p > %p\n"", q, e)); goto out; } inp[i].pi_id = CDF_GETUINT32(p, i << 1); inp[i].pi_type = CDF_GETUINT32(q, 0); DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"", i, inp[i].pi_id, inp[i].pi_type, q - p, offs)); if (inp[i].pi_type & CDF_VECTOR) { nelements = CDF_GETUINT32(q, 1); if (nelements == 0) { DPRINTF((""CDF_VECTOR with nelements == 0\n"")); goto out; } o = 2; } else { nelements = 1; o = 1; } o4 = o * sizeof(uint32_t); if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED)) goto unknown; switch (inp[i].pi_type & CDF_TYPEMASK) { case CDF_NULL: case CDF_EMPTY: break; case CDF_SIGNED16: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s16, &q[o4], sizeof(s16)); inp[i].pi_s16 = CDF_TOLE2(s16); break; case CDF_SIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s32, &q[o4], sizeof(s32)); inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32); break; case CDF_BOOL: case CDF_UNSIGNED32: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); inp[i].pi_u32 = CDF_TOLE4(u32); break; case CDF_SIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&s64, &q[o4], sizeof(s64)); inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64); break; case CDF_UNSIGNED64: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64); break; case CDF_FLOAT: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u32, &q[o4], sizeof(u32)); u32 = CDF_TOLE4(u32); memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f)); break; case CDF_DOUBLE: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&u64, &q[o4], sizeof(u64)); u64 = CDF_TOLE8((uint64_t)u64); memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d)); break; case CDF_LENGTH32_STRING: case CDF_LENGTH32_WSTRING: if (nelements > 1) { size_t nelem = inp - *info; if (*maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT) goto out; *maxcount += nelements; inp = CAST(cdf_property_info_t *, realloc(*info, *maxcount * sizeof(*inp))); if (inp == NULL) goto out; *info = inp; inp = *info + nelem; } DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"", nelements)); for (j = 0; j < nelements && i < sh.sh_properties; j++, i++) { uint32_t l = CDF_GETUINT32(q, o); inp[i].pi_str.s_len = l; inp[i].pi_str.s_buf = (const char *) (const void *)(&q[o4 + sizeof(l)]); DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT ""u, s = %s\n"", l, CDF_ROUND(l, sizeof(l)), inp[i].pi_str.s_buf)); if (l & 1) l++; o += l >> 1; if (q + o >= e) goto out; o4 = o * sizeof(uint32_t); } i--; break; case CDF_FILETIME: if (inp[i].pi_type & CDF_VECTOR) goto unknown; (void)memcpy(&tp, &q[o4], sizeof(tp)); inp[i].pi_tp = CDF_TOLE8((uint64_t)tp); break; case CDF_CLIPBOARD: if (inp[i].pi_type & CDF_VECTOR) goto unknown; break; default: unknown: DPRINTF((""Don't know how to deal with %x\n"", inp[i].pi_type)); break; } } return 0; out: free(*info); return -1; }"
956,1563----CWE-787----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-7866--pngdec.c----decode_zbuf,"static int decode_zbuf(AVBPrint *bp, const uint8_t *data, const uint8_t *data_end) { z_stream zstream; unsigned char *buf; unsigned buf_size; int ret; zstream.zalloc = ff_png_zalloc; zstream.zfree = ff_png_zfree; zstream.opaque = NULL; if (inflateInit(&zstream) != Z_OK) return AVERROR_EXTERNAL; zstream.next_in = (unsigned char *)data; zstream.avail_in = data_end - data; av_bprint_init(bp, 0, -1); while (zstream.avail_in > 0) { <S2SV_StartVul> av_bprint_get_buffer(bp, 1, &buf, &buf_size); <S2SV_EndVul> <S2SV_StartVul> if (!buf_size) { <S2SV_EndVul> ret = AVERROR(ENOMEM); goto fail; } zstream.next_out = buf; <S2SV_StartVul> zstream.avail_out = buf_size; <S2SV_EndVul> ret = inflate(&zstream, Z_PARTIAL_FLUSH); if (ret != Z_OK && ret != Z_STREAM_END) { ret = AVERROR_EXTERNAL; goto fail; } bp->len += zstream.next_out - buf; if (ret == Z_STREAM_END) break; } inflateEnd(&zstream); bp->str[bp->len] = 0; return 0; fail: inflateEnd(&zstream); av_bprint_finalize(bp, NULL); return ret; }","- av_bprint_get_buffer(bp, 1, &buf, &buf_size);
- if (!buf_size) {
- zstream.avail_out = buf_size;
+ av_bprint_get_buffer(bp, 2, &buf, &buf_size);
+ if (buf_size < 2) {
+ zstream.avail_out = buf_size - 1;","static int decode_zbuf(AVBPrint *bp, const uint8_t *data, const uint8_t *data_end) { z_stream zstream; unsigned char *buf; unsigned buf_size; int ret; zstream.zalloc = ff_png_zalloc; zstream.zfree = ff_png_zfree; zstream.opaque = NULL; if (inflateInit(&zstream) != Z_OK) return AVERROR_EXTERNAL; zstream.next_in = (unsigned char *)data; zstream.avail_in = data_end - data; av_bprint_init(bp, 0, -1); while (zstream.avail_in > 0) { av_bprint_get_buffer(bp, 2, &buf, &buf_size); if (buf_size < 2) { ret = AVERROR(ENOMEM); goto fail; } zstream.next_out = buf; zstream.avail_out = buf_size - 1; ret = inflate(&zstream, Z_PARTIAL_FLUSH); if (ret != Z_OK && ret != Z_STREAM_END) { ret = AVERROR_EXTERNAL; goto fail; } bp->len += zstream.next_out - buf; if (ret == Z_STREAM_END) break; } inflateEnd(&zstream); bp->str[bp->len] = 0; return 0; fail: inflateEnd(&zstream); av_bprint_finalize(bp, NULL); return ret; }"
957,3861----CWE-415----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/php_mbregex.c----_php_mb_regex_get_option_string,"static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax) { size_t len_left = len; size_t len_req = 0; char *p = str; char c; if ((option & ONIG_OPTION_IGNORECASE) != 0) { if (len_left > 0) { --len_left; *(p++) = 'i'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } if ((option & ONIG_OPTION_EXTEND) != 0) { if (len_left > 0) { --len_left; *(p++) = 'x'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) == (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) { if (len_left > 0) { --len_left; *(p++) = 'p'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } else { if ((option & ONIG_OPTION_MULTILINE) != 0) { if (len_left > 0) { --len_left; *(p++) = 'm'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } if ((option & ONIG_OPTION_SINGLELINE) != 0) { if (len_left > 0) { --len_left; *(p++) = 's'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } <S2SV_StartVul> } <S2SV_EndVul> if ((option & ONIG_OPTION_FIND_LONGEST) != 0) { if (len_left > 0) { --len_left; *(p++) = 'l'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) { if (len_left > 0) { --len_left; *(p++) = 'n'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> } c = 0; if (syntax == ONIG_SYNTAX_JAVA) { c = 'j'; } else if (syntax == ONIG_SYNTAX_GNU_REGEX) { c = 'u'; } else if (syntax == ONIG_SYNTAX_GREP) { c = 'g'; } else if (syntax == ONIG_SYNTAX_EMACS) { c = 'c'; } else if (syntax == ONIG_SYNTAX_RUBY) { c = 'r'; } else if (syntax == ONIG_SYNTAX_PERL) { c = 'z'; } else if (syntax == ONIG_SYNTAX_POSIX_BASIC) { c = 'b'; } else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) { c = 'd'; } if (c != 0) { if (len_left > 0) { --len_left; *(p++) = c; } ++len_req; } if (len_left > 0) { --len_left; *(p++) = '\0'; } <S2SV_StartVul> ++len_req; <S2SV_EndVul> if (len < len_req) { return len_req; } return 0; }","- ++len_req;
- ++len_req;
- ++len_req;
- ++len_req;
- ++len_req;
- }
- ++len_req;
- ++len_req;
- ++len_req;
+ ++len_req;
+ ++len_req;
+ ++len_req;
+ ++len_req;
+ ++len_req;
+ }
+ ++len_req;
+ ++len_req;
+ ++len_req;","static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax) { size_t len_left = len; size_t len_req = 0; char *p = str; char c; if ((option & ONIG_OPTION_IGNORECASE) != 0) { if (len_left > 0) { --len_left; *(p++) = 'i'; } ++len_req; } if ((option & ONIG_OPTION_EXTEND) != 0) { if (len_left > 0) { --len_left; *(p++) = 'x'; } ++len_req; } if ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) == (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) { if (len_left > 0) { --len_left; *(p++) = 'p'; } ++len_req; } else { if ((option & ONIG_OPTION_MULTILINE) != 0) { if (len_left > 0) { --len_left; *(p++) = 'm'; } ++len_req; } if ((option & ONIG_OPTION_SINGLELINE) != 0) { if (len_left > 0) { --len_left; *(p++) = 's'; } ++len_req; } } if ((option & ONIG_OPTION_FIND_LONGEST) != 0) { if (len_left > 0) { --len_left; *(p++) = 'l'; } ++len_req; } if ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) { if (len_left > 0) { --len_left; *(p++) = 'n'; } ++len_req; } c = 0; if (syntax == ONIG_SYNTAX_JAVA) { c = 'j'; } else if (syntax == ONIG_SYNTAX_GNU_REGEX) { c = 'u'; } else if (syntax == ONIG_SYNTAX_GREP) { c = 'g'; } else if (syntax == ONIG_SYNTAX_EMACS) { c = 'c'; } else if (syntax == ONIG_SYNTAX_RUBY) { c = 'r'; } else if (syntax == ONIG_SYNTAX_PERL) { c = 'z'; } else if (syntax == ONIG_SYNTAX_POSIX_BASIC) { c = 'b'; } else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) { c = 'd'; } if (c != 0) { if (len_left > 0) { --len_left; *(p++) = c; } ++len_req; } if (len_left > 0) { --len_left; *(p++) = '\0'; } ++len_req; if (len < len_req) { return len_req; } return 0; }"
958,2964----CWE-284----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/req.c----_prolog_error,"_prolog_error(batch_job_launch_msg_t *req, int rc) { char *err_name_ptr, err_name[256], path_name[MAXPATHLEN]; char *fmt_char; int fd; if (req->std_err || req->std_out) { if (req->std_err) strncpy(err_name, req->std_err, sizeof(err_name)); else strncpy(err_name, req->std_out, sizeof(err_name)); if ((fmt_char = strchr(err_name, (int) '%')) && (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) { char tmp_name[256]; fmt_char[1] = 'u'; snprintf(tmp_name, sizeof(tmp_name), err_name, req->job_id); strncpy(err_name, tmp_name, sizeof(err_name)); } } else { snprintf(err_name, sizeof(err_name), ""slurm-%u.out"", req->job_id); } err_name_ptr = err_name; if (err_name_ptr[0] == '/') snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr); else if (req->work_dir) snprintf(path_name, MAXPATHLEN, ""%s/%s"", req->work_dir, err_name_ptr); else snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr); <S2SV_StartVul> if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) { <S2SV_EndVul> <S2SV_StartVul> error(""Unable to open %s: %s"", path_name, <S2SV_EndVul> <S2SV_StartVul> slurm_strerror(errno)); <S2SV_EndVul> return; } snprintf(err_name, sizeof(err_name), ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc)); safe_write(fd, err_name, strlen(err_name)); if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) { snprintf(err_name, sizeof(err_name), ""Couldn't change fd owner to %u:%u: %m\n"", req->uid, req->gid); } rwfail: close(fd); }","- if ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {
- error(""Unable to open %s: %s"", path_name,
- slurm_strerror(errno));
+ if ((fd = _open_as_other(path_name, req)) == -1) {
+ error(""Unable to open %s: Permission denied"", path_name);","_prolog_error(batch_job_launch_msg_t *req, int rc) { char *err_name_ptr, err_name[256], path_name[MAXPATHLEN]; char *fmt_char; int fd; if (req->std_err || req->std_out) { if (req->std_err) strncpy(err_name, req->std_err, sizeof(err_name)); else strncpy(err_name, req->std_out, sizeof(err_name)); if ((fmt_char = strchr(err_name, (int) '%')) && (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) { char tmp_name[256]; fmt_char[1] = 'u'; snprintf(tmp_name, sizeof(tmp_name), err_name, req->job_id); strncpy(err_name, tmp_name, sizeof(err_name)); } } else { snprintf(err_name, sizeof(err_name), ""slurm-%u.out"", req->job_id); } err_name_ptr = err_name; if (err_name_ptr[0] == '/') snprintf(path_name, MAXPATHLEN, ""%s"", err_name_ptr); else if (req->work_dir) snprintf(path_name, MAXPATHLEN, ""%s/%s"", req->work_dir, err_name_ptr); else snprintf(path_name, MAXPATHLEN, ""/%s"", err_name_ptr); if ((fd = _open_as_other(path_name, req)) == -1) { error(""Unable to open %s: Permission denied"", path_name); return; } snprintf(err_name, sizeof(err_name), ""Error running slurm prolog: %d\n"", WEXITSTATUS(rc)); safe_write(fd, err_name, strlen(err_name)); if (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) { snprintf(err_name, sizeof(err_name), ""Couldn't change fd owner to %u:%u: %m\n"", req->uid, req->gid); } rwfail: close(fd); }"
959,6624----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/snmp-engine.c----snmp_engine_get_next,"<S2SV_StartVul> snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length) <S2SV_EndVul> { snmp_mib_resource_t *resource; <S2SV_StartVul> uint32_t i; <S2SV_EndVul> <S2SV_StartVul> for(i = 0; i < varbinds_length; i++) { <S2SV_EndVul> <S2SV_StartVul> resource = snmp_mib_find_next(varbinds[i].oid); <S2SV_EndVul> if(!resource) { switch(header->version) { case SNMP_VERSION_1: <S2SV_StartVul> header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME; <S2SV_EndVul> <S2SV_StartVul> header->error_index_max_repetitions.error_index = i + 1; <S2SV_EndVul> break; case SNMP_VERSION_2C: <S2SV_StartVul> (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW; <S2SV_EndVul> break; default: <S2SV_StartVul> header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME; <S2SV_EndVul> <S2SV_StartVul> header->error_index_max_repetitions.error_index = 0; <S2SV_EndVul> } } else { <S2SV_StartVul> resource->handler(&varbinds[i], resource->oid); <S2SV_EndVul> } } return 0; }","- snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)
- uint32_t i;
- for(i = 0; i < varbinds_length; i++) {
- resource = snmp_mib_find_next(varbinds[i].oid);
- header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
- header->error_index_max_repetitions.error_index = i + 1;
- (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;
- header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;
- header->error_index_max_repetitions.error_index = 0;
- resource->handler(&varbinds[i], resource->oid);
+ snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds)
+ uint8_t i;
+ i = 0;
+ while(varbinds[i].value_type != BER_DATA_TYPE_EOC && i < SNMP_MAX_NR_VALUES) {
+ resource = snmp_mib_find_next(&varbinds[i].oid);
+ header->error_status = SNMP_STATUS_NO_SUCH_NAME;
+ header->error_index = i + 1;
+ (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;
+ header->error_status = SNMP_STATUS_NO_SUCH_NAME;
+ header->error_index = 0;
+ resource->handler(&varbinds[i], &resource->oid);
+ i++;","snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds) { snmp_mib_resource_t *resource; uint8_t i; i = 0; while(varbinds[i].value_type != BER_DATA_TYPE_EOC && i < SNMP_MAX_NR_VALUES) { resource = snmp_mib_find_next(&varbinds[i].oid); if(!resource) { switch(header->version) { case SNMP_VERSION_1: header->error_status = SNMP_STATUS_NO_SUCH_NAME; header->error_index = i + 1; break; case SNMP_VERSION_2C: (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW; break; default: header->error_status = SNMP_STATUS_NO_SUCH_NAME; header->error_index = 0; } } else { resource->handler(&varbinds[i], &resource->oid); } i++; } return 0; }"
960,6923----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/yaffs.cpp----yaffsfs_istat,"yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum, TSK_DADDR_T numblock, int32_t sec_skew) { TSK_FS_META *fs_meta; TSK_FS_FILE *fs_file; YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs; char ls[12]; YAFFSFS_PRINT_ADDR print; <S2SV_StartVul> char timeBuf[32]; <S2SV_EndVul> YaffsCacheObject * obj = NULL; YaffsCacheVersion * version = NULL; YaffsHeader * header = NULL; yaffscache_version_find_by_inode(yfs, inum, &version, &obj); if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) { return 1; } fs_meta = fs_file->meta; tsk_fprintf(hFile, ""inode: %"" PRIuINUM ""\n"", inum); tsk_fprintf(hFile, ""%sAllocated\n"", (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? """" : ""Not ""); if (fs_meta->link) tsk_fprintf(hFile, ""symbolic link to: %s\n"", fs_meta->link); tsk_fprintf(hFile, ""uid / gid: %"" PRIuUID "" / %"" PRIuGID ""\n"", fs_meta->uid, fs_meta->gid); tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls)); tsk_fprintf(hFile, ""mode: %s\n"", ls); tsk_fprintf(hFile, ""size: %"" PRIdOFF ""\n"", fs_meta->size); tsk_fprintf(hFile, ""num of links: %d\n"", fs_meta->nlink); if(version != NULL){ yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset); if(header != NULL){ tsk_fprintf(hFile, ""Name: %s\n"", header->name); } } if (sec_skew != 0) { tsk_fprintf(hFile, ""\nAdjusted Inode Times:\n""); fs_meta->mtime -= sec_skew; fs_meta->atime -= sec_skew; fs_meta->ctime -= sec_skew; tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); fs_meta->mtime += sec_skew; fs_meta->atime += sec_skew; fs_meta->ctime += sec_skew; tsk_fprintf(hFile, ""\nOriginal Inode Times:\n""); } else { tsk_fprintf(hFile, ""\nInode Times:\n""); } tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); if(version != NULL){ tsk_fprintf(hFile, ""\nHeader Chunk:\n""); tsk_fprintf(hFile, ""%"" PRIuDADDR ""\n"", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size))); } if (numblock > 0) { TSK_OFF_T lower_size = numblock * fs->block_size; fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size); } tsk_fprintf(hFile, ""\nData Chunks:\n""); if (flags & TSK_FS_ISTAT_RUNLIST){ const TSK_FS_ATTR *fs_attr_default = tsk_fs_file_attr_get_type(fs_file, TSK_FS_ATTR_TYPE_DEFAULT, 0, 0); if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) { if (tsk_fs_attr_print(fs_attr_default, hFile)) { tsk_fprintf(hFile, ""\nError creating run lists ""); tsk_error_print(hFile); tsk_error_reset(); } } } else { print.idx = 0; print.hFile = hFile; if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY, (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) { tsk_fprintf(hFile, ""\nError reading file: ""); tsk_error_print(hFile); tsk_error_reset(); } else if (print.idx != 0) { tsk_fprintf(hFile, ""\n""); } } tsk_fs_file_close(fs_file); return 0; }","- char timeBuf[32];
+ char timeBuf[128];","yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum, TSK_DADDR_T numblock, int32_t sec_skew) { TSK_FS_META *fs_meta; TSK_FS_FILE *fs_file; YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs; char ls[12]; YAFFSFS_PRINT_ADDR print; char timeBuf[128]; YaffsCacheObject * obj = NULL; YaffsCacheVersion * version = NULL; YaffsHeader * header = NULL; yaffscache_version_find_by_inode(yfs, inum, &version, &obj); if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) { return 1; } fs_meta = fs_file->meta; tsk_fprintf(hFile, ""inode: %"" PRIuINUM ""\n"", inum); tsk_fprintf(hFile, ""%sAllocated\n"", (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? """" : ""Not ""); if (fs_meta->link) tsk_fprintf(hFile, ""symbolic link to: %s\n"", fs_meta->link); tsk_fprintf(hFile, ""uid / gid: %"" PRIuUID "" / %"" PRIuGID ""\n"", fs_meta->uid, fs_meta->gid); tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls)); tsk_fprintf(hFile, ""mode: %s\n"", ls); tsk_fprintf(hFile, ""size: %"" PRIdOFF ""\n"", fs_meta->size); tsk_fprintf(hFile, ""num of links: %d\n"", fs_meta->nlink); if(version != NULL){ yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset); if(header != NULL){ tsk_fprintf(hFile, ""Name: %s\n"", header->name); } } if (sec_skew != 0) { tsk_fprintf(hFile, ""\nAdjusted Inode Times:\n""); fs_meta->mtime -= sec_skew; fs_meta->atime -= sec_skew; fs_meta->ctime -= sec_skew; tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); fs_meta->mtime += sec_skew; fs_meta->atime += sec_skew; fs_meta->ctime += sec_skew; tsk_fprintf(hFile, ""\nOriginal Inode Times:\n""); } else { tsk_fprintf(hFile, ""\nInode Times:\n""); } tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); if(version != NULL){ tsk_fprintf(hFile, ""\nHeader Chunk:\n""); tsk_fprintf(hFile, ""%"" PRIuDADDR ""\n"", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size))); } if (numblock > 0) { TSK_OFF_T lower_size = numblock * fs->block_size; fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size); } tsk_fprintf(hFile, ""\nData Chunks:\n""); if (flags & TSK_FS_ISTAT_RUNLIST){ const TSK_FS_ATTR *fs_attr_default = tsk_fs_file_attr_get_type(fs_file, TSK_FS_ATTR_TYPE_DEFAULT, 0, 0); if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) { if (tsk_fs_attr_print(fs_attr_default, hFile)) { tsk_fprintf(hFile, ""\nError creating run lists ""); tsk_error_print(hFile); tsk_error_reset(); } } } else { print.idx = 0; print.hFile = hFile; if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY, (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) { tsk_fprintf(hFile, ""\nError reading file: ""); tsk_error_print(hFile); tsk_error_reset(); } else if (print.idx != 0) { tsk_fprintf(hFile, ""\n""); } } tsk_fs_file_close(fs_file); return 0; }"
961,6141----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/sndfile.c----sf_open_virtual,"sf_open_virtual (SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data) { SF_PRIVATE *psf ; if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ; return NULL ; } ; if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ; return NULL ; } ; if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ; return NULL ; } ; <S2SV_StartVul> if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL) <S2SV_EndVul> { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files (psf) ; psf->virtual_io = SF_TRUE ; psf->vio = *sfvirtual ; psf->vio_user_data = user_data ; psf->file.mode = mode ; return psf_open_file (psf, sfinfo) ; }","- if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
+ if ((psf = psf_allocate ()) == NULL)","sf_open_virtual (SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data) { SF_PRIVATE *psf ; if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ; return NULL ; } ; if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ; return NULL ; } ; if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ; return NULL ; } ; if ((psf = psf_allocate ()) == NULL) { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files (psf) ; psf->virtual_io = SF_TRUE ; psf->vio = *sfvirtual ; psf->vio_user_data = user_data ; psf->file.mode = mode ; return psf_open_file (psf, sfinfo) ; }"
962,5561----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/wpg.c----ReadWPGImage,"static Image *ReadWPGImage(const ImageInfo *image_info, ExceptionInfo *exception) { typedef struct { size_t FileId; MagickOffsetType DataOffset; unsigned int ProductType; unsigned int FileType; unsigned char MajorVersion; unsigned char MinorVersion; unsigned int EncryptKey; unsigned int Reserved; } WPGHeader; typedef struct { unsigned char RecType; size_t RecordLength; } WPGRecord; typedef struct { unsigned char Class; unsigned char RecType; size_t Extension; size_t RecordLength; } WPG2Record; typedef struct { unsigned HorizontalUnits; unsigned VerticalUnits; unsigned char PosSizePrecision; } WPG2Start; typedef struct { unsigned int Width; unsigned int Height; unsigned int Depth; unsigned int HorzRes; unsigned int VertRes; } WPGBitmapType1; typedef struct { unsigned int Width; unsigned int Height; unsigned char Depth; unsigned char Compression; } WPG2BitmapType1; typedef struct { unsigned int RotAngle; unsigned int LowLeftX; unsigned int LowLeftY; unsigned int UpRightX; unsigned int UpRightY; unsigned int Width; unsigned int Height; unsigned int Depth; unsigned int HorzRes; unsigned int VertRes; } WPGBitmapType2; typedef struct { unsigned int StartIndex; unsigned int NumOfEntries; } WPGColorMapRec; Image *image; unsigned int status; WPGHeader Header; WPGRecord Rec; WPG2Record Rec2; WPG2Start StartWPG; WPGBitmapType1 BitmapHeader1; WPG2BitmapType1 Bitmap2Header1; WPGBitmapType2 BitmapHeader2; WPGColorMapRec WPG_Palette; int i, bpp, WPG2Flags; ssize_t ldblk; size_t one; unsigned char *BImgBuff; tCTM CTM; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); one=1; image=AcquireImage(image_info,exception); image->depth=8; status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } Header.FileId=ReadBlobLSBLong(image); Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image); Header.ProductType=ReadBlobLSBShort(image); Header.FileType=ReadBlobLSBShort(image); Header.MajorVersion=ReadBlobByte(image); Header.MinorVersion=ReadBlobByte(image); Header.EncryptKey=ReadBlobLSBShort(image); Header.Reserved=ReadBlobLSBShort(image); if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (Header.EncryptKey!=0) ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported""); image->columns = 1; image->rows = 1; image->colors = 0; bpp=0; BitmapHeader2.RotAngle=0; switch(Header.FileType) { case 1: while(!EOFBlob(image)) { (void) SeekBlob(image,Header.DataOffset,SEEK_SET); if(EOFBlob(image)) break; Rec.RecType=(i=ReadBlobByte(image)); if(i==EOF) break; Rd_WP_DWORD(image,&Rec.RecordLength); if(EOFBlob(image)) break; Header.DataOffset=TellBlob(image)+Rec.RecordLength; switch(Rec.RecType) { case 0x0B: BitmapHeader1.Width=ReadBlobLSBShort(image); BitmapHeader1.Height=ReadBlobLSBShort(image); if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); BitmapHeader1.Depth=ReadBlobLSBShort(image); BitmapHeader1.HorzRes=ReadBlobLSBShort(image); BitmapHeader1.VertRes=ReadBlobLSBShort(image); if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes) { image->units=PixelsPerCentimeterResolution; image->resolution.x=BitmapHeader1.HorzRes/470.0; image->resolution.y=BitmapHeader1.VertRes/470.0; } image->columns=BitmapHeader1.Width; image->rows=BitmapHeader1.Height; bpp=BitmapHeader1.Depth; goto UnpackRaster; case 0x0E: WPG_Palette.StartIndex=ReadBlobLSBShort(image); WPG_Palette.NumOfEntries=ReadBlobLSBShort(image); image->colors=WPG_Palette.NumOfEntries; if (!AcquireImageColormap(image,image->colors,exception)) goto NoMemory; for (i=WPG_Palette.StartIndex; i < (int)WPG_Palette.NumOfEntries; i++) { image->colormap[i].red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->colormap[i].green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->colormap[i].blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); } break; case 0x11: if(Rec.RecordLength > 8) image=ExtractPostscript(image,image_info, TellBlob(image)+8, (ssize_t) Rec.RecordLength-8,exception); break; case 0x14: BitmapHeader2.RotAngle=ReadBlobLSBShort(image); BitmapHeader2.LowLeftX=ReadBlobLSBShort(image); BitmapHeader2.LowLeftY=ReadBlobLSBShort(image); BitmapHeader2.UpRightX=ReadBlobLSBShort(image); BitmapHeader2.UpRightY=ReadBlobLSBShort(image); BitmapHeader2.Width=ReadBlobLSBShort(image); BitmapHeader2.Height=ReadBlobLSBShort(image); if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); BitmapHeader2.Depth=ReadBlobLSBShort(image); BitmapHeader2.HorzRes=ReadBlobLSBShort(image); BitmapHeader2.VertRes=ReadBlobLSBShort(image); image->units=PixelsPerCentimeterResolution; image->page.width=(unsigned int) ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0); image->page.height=(unsigned int) ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0); image->page.x=(int) (BitmapHeader2.LowLeftX/470.0); image->page.y=(int) (BitmapHeader2.LowLeftX/470.0); if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes) { image->resolution.x=BitmapHeader2.HorzRes/470.0; image->resolution.y=BitmapHeader2.VertRes/470.0; } image->columns=BitmapHeader2.Width; image->rows=BitmapHeader2.Height; bpp=BitmapHeader2.Depth; UnpackRaster: if ((image->colors == 0) && (bpp != 24)) { image->colors=one << bpp; if (!AcquireImageColormap(image,image->colors,exception)) { NoMemory: ThrowReaderException(ResourceLimitError, ""MemoryAllocationFailed""); } for (i=0; (i < (int) image->colors) && (i < 256); i++) { image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red); image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green); image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue); } } else { if (bpp < 24) if ( (image->colors < (one << bpp)) && (bpp != 24) ) image->colormap=(PixelInfo *) ResizeQuantumMemory( image->colormap,(size_t) (one << bpp), sizeof(*image->colormap)); } if (bpp == 1) { if(image->colormap[0].red==0 && image->colormap[0].green==0 && image->colormap[0].blue==0 && image->colormap[1].red==0 && image->colormap[1].green==0 && image->colormap[1].blue==0) { image->colormap[1].red = image->colormap[1].green = image->colormap[1].blue = QuantumRange; } } if(UnpackWPGRaster(image,bpp,exception) < 0) { DecompressionFailed: ThrowReaderException(CoderError,""UnableToDecompressImage""); } if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping) { if(BitmapHeader2.RotAngle & 0x8000) { Image *flop_image; flop_image = FlopImage(image, exception); if (flop_image != (Image *) NULL) { DuplicateBlob(flop_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flop_image); } } if(BitmapHeader2.RotAngle & 0x2000) { Image *flip_image; flip_image = FlipImage(image, exception); if (flip_image != (Image *) NULL) { DuplicateBlob(flip_image,image); (void) RemoveLastImageFromList(&image); <S2SV_StartVul> AppendImageToList(&image,flip_image); <S2SV_EndVul> } } if(BitmapHeader2.RotAngle & 0x0FFF) { Image *rotate_image; rotate_image=RotateImage(image,(BitmapHeader2.RotAngle & 0x0FFF), exception); if (rotate_image != (Image *) NULL) { DuplicateBlob(rotate_image,image); (void) RemoveLastImageFromList(&image); <S2SV_StartVul> AppendImageToList(&image,rotate_image); <S2SV_EndVul> } <S2SV_StartVul> } <S2SV_EndVul> } AcquireNextImage(image_info,image,exception); image->depth=8; if (image->next == (Image *) NULL) goto Finish; image=SyncNextImageInList(image); <S2SV_StartVul> image->columns=image->rows=0; <S2SV_EndVul> image->colors=0; break; case 0x1B: if(Rec.RecordLength>0x3C) image=ExtractPostscript(image,image_info, TellBlob(image)+0x3C, (ssize_t) Rec.RecordLength-0x3C,exception); break; } } break; case 2: (void) memset(CTM,0,sizeof(CTM)); StartWPG.PosSizePrecision = 0; while(!EOFBlob(image)) { (void) SeekBlob(image,Header.DataOffset,SEEK_SET); if(EOFBlob(image)) break; Rec2.Class=(i=ReadBlobByte(image)); if(i==EOF) break; Rec2.RecType=(i=ReadBlobByte(image)); if(i==EOF) break; Rd_WP_DWORD(image,&Rec2.Extension); Rd_WP_DWORD(image,&Rec2.RecordLength); if(EOFBlob(image)) break; Header.DataOffset=TellBlob(image)+Rec2.RecordLength; switch(Rec2.RecType) { case 1: StartWPG.HorizontalUnits=ReadBlobLSBShort(image); StartWPG.VerticalUnits=ReadBlobLSBShort(image); StartWPG.PosSizePrecision=ReadBlobByte(image); break; case 0x0C: WPG_Palette.StartIndex=ReadBlobLSBShort(image); WPG_Palette.NumOfEntries=ReadBlobLSBShort(image); image->colors=WPG_Palette.NumOfEntries; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError, ""MemoryAllocationFailed""); for (i=WPG_Palette.StartIndex; i < (int)WPG_Palette.NumOfEntries; i++) { image->colormap[i].red=ScaleCharToQuantum((char) ReadBlobByte(image)); image->colormap[i].green=ScaleCharToQuantum((char) ReadBlobByte(image)); image->colormap[i].blue=ScaleCharToQuantum((char) ReadBlobByte(image)); (void) ReadBlobByte(image); } break; case 0x0E: Bitmap2Header1.Width=ReadBlobLSBShort(image); Bitmap2Header1.Height=ReadBlobLSBShort(image); if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); Bitmap2Header1.Depth=ReadBlobByte(image); Bitmap2Header1.Compression=ReadBlobByte(image); if(Bitmap2Header1.Compression > 1) continue; switch(Bitmap2Header1.Depth) { case 1: bpp=1; break; case 2: bpp=2; break; case 3: bpp=4; break; case 4: bpp=8; break; case 8: bpp=24; break; default: continue; } image->columns=Bitmap2Header1.Width; <S2SV_StartVul> image->rows=Bitmap2Header1.Height; <S2SV_EndVul> if ((image->colors == 0) && (bpp != 24)) { size_t one; one=1; image->colors=one << bpp; if (!AcquireImageColormap(image,image->colors,exception)) goto NoMemory; } else { if(bpp < 24) if( image->colors<(one << bpp) && bpp!=24 ) image->colormap=(PixelInfo *) ResizeQuantumMemory( image->colormap,(size_t) (one << bpp), sizeof(*image->colormap)); } switch(Bitmap2Header1.Compression) { case 0: { ldblk=(ssize_t) ((bpp*image->columns+7)/8); BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk+1,sizeof(*BImgBuff)); if (BImgBuff == (unsigned char *) NULL) goto NoMemory; for(i=0; i< (ssize_t) image->rows; i++) { (void) ReadBlob(image,ldblk,BImgBuff); InsertRow(image,BImgBuff,i,bpp,exception); } if(BImgBuff) <S2SV_StartVul> BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);; <S2SV_EndVul> break; } case 1: { if( UnpackWPG2Raster(image,bpp,exception) < 0) goto DecompressionFailed; break; } } if(CTM[0][0]<0 && !image_info->ping) { Image *flop_image; flop_image = FlopImage(image, exception); if (flop_image != (Image *) NULL) { DuplicateBlob(flop_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flop_image); } <S2SV_EndVul> } if(CTM[1][1]<0 && !image_info->ping) { Image *flip_image; flip_image = FlipImage(image, exception); if (flip_image != (Image *) NULL) { DuplicateBlob(flip_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flip_image); } <S2SV_EndVul> <S2SV_StartVul> } <S2SV_EndVul> AcquireNextImage(image_info,image,exception); image->depth=8; if (image->next == (Image *) NULL) goto Finish; image=SyncNextImageInList(image); image->columns=image->rows=1; image->colors=0; break; case 0x12: i=ReadBlobLSBShort(image); if(Rec2.RecordLength > (unsigned int) i) image=ExtractPostscript(image,image_info, TellBlob(image)+i, (ssize_t) (Rec2.RecordLength-i-2),exception); break; case 0x1B: WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM); (void) WPG2Flags; break; } } break; default: { ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported""); } } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); Finish: (void) CloseBlob(image); { Image *p; ssize_t scene=0; p=image; image=NULL; while (p != (Image *) NULL) { Image *tmp=p; if ((p->rows == 0) || (p->columns == 0)) { p=p->previous; DeleteImageFromList(&tmp); } else { image=p; p=p->previous; } } for (p=image; p != (Image *) NULL; p=p->next) p->scene=(size_t) scene++; } if (image == (Image *) NULL) ThrowReaderException(CorruptImageError, ""ImageFileDoesNotContainAnyImageData""); return(image); }","- AppendImageToList(&image,flip_image);
- AppendImageToList(&image,rotate_image);
- }
- image->columns=image->rows=0;
- image->rows=Bitmap2Header1.Height;
- BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);;
- }
+ AppendImageToList(&image,flip_image);
+ AppendImageToList(&image,rotate_image);
+ }
+ image->columns=image->rows=1;
+ image->rows=Bitmap2Header1.Height;
+ BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff);
+ }","static Image *ReadWPGImage(const ImageInfo *image_info, ExceptionInfo *exception) { typedef struct { size_t FileId; MagickOffsetType DataOffset; unsigned int ProductType; unsigned int FileType; unsigned char MajorVersion; unsigned char MinorVersion; unsigned int EncryptKey; unsigned int Reserved; } WPGHeader; typedef struct { unsigned char RecType; size_t RecordLength; } WPGRecord; typedef struct { unsigned char Class; unsigned char RecType; size_t Extension; size_t RecordLength; } WPG2Record; typedef struct { unsigned HorizontalUnits; unsigned VerticalUnits; unsigned char PosSizePrecision; } WPG2Start; typedef struct { unsigned int Width; unsigned int Height; unsigned int Depth; unsigned int HorzRes; unsigned int VertRes; } WPGBitmapType1; typedef struct { unsigned int Width; unsigned int Height; unsigned char Depth; unsigned char Compression; } WPG2BitmapType1; typedef struct { unsigned int RotAngle; unsigned int LowLeftX; unsigned int LowLeftY; unsigned int UpRightX; unsigned int UpRightY; unsigned int Width; unsigned int Height; unsigned int Depth; unsigned int HorzRes; unsigned int VertRes; } WPGBitmapType2; typedef struct { unsigned int StartIndex; unsigned int NumOfEntries; } WPGColorMapRec; Image *image; unsigned int status; WPGHeader Header; WPGRecord Rec; WPG2Record Rec2; WPG2Start StartWPG; WPGBitmapType1 BitmapHeader1; WPG2BitmapType1 Bitmap2Header1; WPGBitmapType2 BitmapHeader2; WPGColorMapRec WPG_Palette; int i, bpp, WPG2Flags; ssize_t ldblk; size_t one; unsigned char *BImgBuff; tCTM CTM; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); one=1; image=AcquireImage(image_info,exception); image->depth=8; status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } Header.FileId=ReadBlobLSBLong(image); Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image); Header.ProductType=ReadBlobLSBShort(image); Header.FileType=ReadBlobLSBShort(image); Header.MajorVersion=ReadBlobByte(image); Header.MinorVersion=ReadBlobByte(image); Header.EncryptKey=ReadBlobLSBShort(image); Header.Reserved=ReadBlobLSBShort(image); if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (Header.EncryptKey!=0) ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported""); image->columns = 1; image->rows = 1; image->colors = 0; bpp=0; BitmapHeader2.RotAngle=0; switch(Header.FileType) { case 1: while(!EOFBlob(image)) { (void) SeekBlob(image,Header.DataOffset,SEEK_SET); if(EOFBlob(image)) break; Rec.RecType=(i=ReadBlobByte(image)); if(i==EOF) break; Rd_WP_DWORD(image,&Rec.RecordLength); if(EOFBlob(image)) break; Header.DataOffset=TellBlob(image)+Rec.RecordLength; switch(Rec.RecType) { case 0x0B: BitmapHeader1.Width=ReadBlobLSBShort(image); BitmapHeader1.Height=ReadBlobLSBShort(image); if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); BitmapHeader1.Depth=ReadBlobLSBShort(image); BitmapHeader1.HorzRes=ReadBlobLSBShort(image); BitmapHeader1.VertRes=ReadBlobLSBShort(image); if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes) { image->units=PixelsPerCentimeterResolution; image->resolution.x=BitmapHeader1.HorzRes/470.0; image->resolution.y=BitmapHeader1.VertRes/470.0; } image->columns=BitmapHeader1.Width; image->rows=BitmapHeader1.Height; bpp=BitmapHeader1.Depth; goto UnpackRaster; case 0x0E: WPG_Palette.StartIndex=ReadBlobLSBShort(image); WPG_Palette.NumOfEntries=ReadBlobLSBShort(image); image->colors=WPG_Palette.NumOfEntries; if (!AcquireImageColormap(image,image->colors,exception)) goto NoMemory; for (i=WPG_Palette.StartIndex; i < (int)WPG_Palette.NumOfEntries; i++) { image->colormap[i].red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->colormap[i].green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->colormap[i].blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); } break; case 0x11: if(Rec.RecordLength > 8) image=ExtractPostscript(image,image_info, TellBlob(image)+8, (ssize_t) Rec.RecordLength-8,exception); break; case 0x14: BitmapHeader2.RotAngle=ReadBlobLSBShort(image); BitmapHeader2.LowLeftX=ReadBlobLSBShort(image); BitmapHeader2.LowLeftY=ReadBlobLSBShort(image); BitmapHeader2.UpRightX=ReadBlobLSBShort(image); BitmapHeader2.UpRightY=ReadBlobLSBShort(image); BitmapHeader2.Width=ReadBlobLSBShort(image); BitmapHeader2.Height=ReadBlobLSBShort(image); if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); BitmapHeader2.Depth=ReadBlobLSBShort(image); BitmapHeader2.HorzRes=ReadBlobLSBShort(image); BitmapHeader2.VertRes=ReadBlobLSBShort(image); image->units=PixelsPerCentimeterResolution; image->page.width=(unsigned int) ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0); image->page.height=(unsigned int) ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0); image->page.x=(int) (BitmapHeader2.LowLeftX/470.0); image->page.y=(int) (BitmapHeader2.LowLeftX/470.0); if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes) { image->resolution.x=BitmapHeader2.HorzRes/470.0; image->resolution.y=BitmapHeader2.VertRes/470.0; } image->columns=BitmapHeader2.Width; image->rows=BitmapHeader2.Height; bpp=BitmapHeader2.Depth; UnpackRaster: if ((image->colors == 0) && (bpp != 24)) { image->colors=one << bpp; if (!AcquireImageColormap(image,image->colors,exception)) { NoMemory: ThrowReaderException(ResourceLimitError, ""MemoryAllocationFailed""); } for (i=0; (i < (int) image->colors) && (i < 256); i++) { image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red); image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green); image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue); } } else { if (bpp < 24) if ( (image->colors < (one << bpp)) && (bpp != 24) ) image->colormap=(PixelInfo *) ResizeQuantumMemory( image->colormap,(size_t) (one << bpp), sizeof(*image->colormap)); } if (bpp == 1) { if(image->colormap[0].red==0 && image->colormap[0].green==0 && image->colormap[0].blue==0 && image->colormap[1].red==0 && image->colormap[1].green==0 && image->colormap[1].blue==0) { image->colormap[1].red = image->colormap[1].green = image->colormap[1].blue = QuantumRange; } } if(UnpackWPGRaster(image,bpp,exception) < 0) { DecompressionFailed: ThrowReaderException(CoderError,""UnableToDecompressImage""); } if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping) { if(BitmapHeader2.RotAngle & 0x8000) { Image *flop_image; flop_image = FlopImage(image, exception); if (flop_image != (Image *) NULL) { DuplicateBlob(flop_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flop_image); } } if(BitmapHeader2.RotAngle & 0x2000) { Image *flip_image; flip_image = FlipImage(image, exception); if (flip_image != (Image *) NULL) { DuplicateBlob(flip_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flip_image); } } if(BitmapHeader2.RotAngle & 0x0FFF) { Image *rotate_image; rotate_image=RotateImage(image,(BitmapHeader2.RotAngle & 0x0FFF), exception); if (rotate_image != (Image *) NULL) { DuplicateBlob(rotate_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,rotate_image); } } } AcquireNextImage(image_info,image,exception); image->depth=8; if (image->next == (Image *) NULL) goto Finish; image=SyncNextImageInList(image); image->columns=image->rows=1; image->colors=0; break; case 0x1B: if(Rec.RecordLength>0x3C) image=ExtractPostscript(image,image_info, TellBlob(image)+0x3C, (ssize_t) Rec.RecordLength-0x3C,exception); break; } } break; case 2: (void) memset(CTM,0,sizeof(CTM)); StartWPG.PosSizePrecision = 0; while(!EOFBlob(image)) { (void) SeekBlob(image,Header.DataOffset,SEEK_SET); if(EOFBlob(image)) break; Rec2.Class=(i=ReadBlobByte(image)); if(i==EOF) break; Rec2.RecType=(i=ReadBlobByte(image)); if(i==EOF) break; Rd_WP_DWORD(image,&Rec2.Extension); Rd_WP_DWORD(image,&Rec2.RecordLength); if(EOFBlob(image)) break; Header.DataOffset=TellBlob(image)+Rec2.RecordLength; switch(Rec2.RecType) { case 1: StartWPG.HorizontalUnits=ReadBlobLSBShort(image); StartWPG.VerticalUnits=ReadBlobLSBShort(image); StartWPG.PosSizePrecision=ReadBlobByte(image); break; case 0x0C: WPG_Palette.StartIndex=ReadBlobLSBShort(image); WPG_Palette.NumOfEntries=ReadBlobLSBShort(image); image->colors=WPG_Palette.NumOfEntries; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError, ""MemoryAllocationFailed""); for (i=WPG_Palette.StartIndex; i < (int)WPG_Palette.NumOfEntries; i++) { image->colormap[i].red=ScaleCharToQuantum((char) ReadBlobByte(image)); image->colormap[i].green=ScaleCharToQuantum((char) ReadBlobByte(image)); image->colormap[i].blue=ScaleCharToQuantum((char) ReadBlobByte(image)); (void) ReadBlobByte(image); } break; case 0x0E: Bitmap2Header1.Width=ReadBlobLSBShort(image); Bitmap2Header1.Height=ReadBlobLSBShort(image); if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); Bitmap2Header1.Depth=ReadBlobByte(image); Bitmap2Header1.Compression=ReadBlobByte(image); if(Bitmap2Header1.Compression > 1) continue; switch(Bitmap2Header1.Depth) { case 1: bpp=1; break; case 2: bpp=2; break; case 3: bpp=4; break; case 4: bpp=8; break; case 8: bpp=24; break; default: continue; } image->columns=Bitmap2Header1.Width; image->rows=Bitmap2Header1.Height; if ((image->colors == 0) && (bpp != 24)) { size_t one; one=1; image->colors=one << bpp; if (!AcquireImageColormap(image,image->colors,exception)) goto NoMemory; } else { if(bpp < 24) if( image->colors<(one << bpp) && bpp!=24 ) image->colormap=(PixelInfo *) ResizeQuantumMemory( image->colormap,(size_t) (one << bpp), sizeof(*image->colormap)); } switch(Bitmap2Header1.Compression) { case 0: { ldblk=(ssize_t) ((bpp*image->columns+7)/8); BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk+1,sizeof(*BImgBuff)); if (BImgBuff == (unsigned char *) NULL) goto NoMemory; for(i=0; i< (ssize_t) image->rows; i++) { (void) ReadBlob(image,ldblk,BImgBuff); InsertRow(image,BImgBuff,i,bpp,exception); } if(BImgBuff) BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff); break; } case 1: { if( UnpackWPG2Raster(image,bpp,exception) < 0) goto DecompressionFailed; break; } } if(CTM[0][0]<0 && !image_info->ping) { Image *flop_image; flop_image = FlopImage(image, exception); if (flop_image != (Image *) NULL) { DuplicateBlob(flop_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flop_image); } } if(CTM[1][1]<0 && !image_info->ping) { Image *flip_image; flip_image = FlipImage(image, exception); if (flip_image != (Image *) NULL) { DuplicateBlob(flip_image,image); (void) RemoveLastImageFromList(&image); AppendImageToList(&image,flip_image); } } AcquireNextImage(image_info,image,exception); image->depth=8; if (image->next == (Image *) NULL) goto Finish; image=SyncNextImageInList(image); image->columns=image->rows=1; image->colors=0; break; case 0x12: i=ReadBlobLSBShort(image); if(Rec2.RecordLength > (unsigned int) i) image=ExtractPostscript(image,image_info, TellBlob(image)+i, (ssize_t) (Rec2.RecordLength-i-2),exception); break; case 0x1B: WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM); (void) WPG2Flags; break; } } break; default: { ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported""); } } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); Finish: (void) CloseBlob(image); { Image *p; ssize_t scene=0; p=image; image=NULL; while (p != (Image *) NULL) { Image *tmp=p; if ((p->rows == 0) || (p->columns == 0)) { p=p->previous; DeleteImageFromList(&tmp); } else { image=p; p=p->previous; } } for (p=image; p != (Image *) NULL; p=p->next) p->scene=(size_t) scene++; } if (image == (Image *) NULL) ThrowReaderException(CorruptImageError, ""ImageFileDoesNotContainAnyImageData""); return(image); }"
963,5045----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/xsDataView.c----fx_TypedArray,"void fx_TypedArray(txMachine* the) { txSlot* instance = fxConstructTypedArray(the); txSlot* dispatch = instance->next; txSlot* view = dispatch->next; txSlot* buffer = view->next; txSlot* data = C_NULL; txU2 shift = dispatch->value.typedArray.dispatch->shift; txSlot* slot; if ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) { slot = mxArgv(0)->value.reference->next; if (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) { txInteger offset = fxArgToByteLength(the, 1, 0); txInteger size; txSlot* info; if (offset & ((1 << shift) - 1)) mxRangeError(""invalid byteOffset %ld"", offset); size = fxArgToByteLength(the, 2, -1); info = fxGetBufferInfo(the, mxArgv(0)); if (size >= 0) { <S2SV_StartVul> size <<= shift; <S2SV_EndVul> <S2SV_StartVul> if (info->value.bufferInfo.length < (offset + size)) <S2SV_EndVul> <S2SV_StartVul> mxRangeError(""out of range byteLength %ld"", size); <S2SV_EndVul> } else { if (info->value.bufferInfo.length & ((1 << shift) - 1)) mxRangeError(""invalid byteLength %ld"", info->value.bufferInfo.length); size = info->value.bufferInfo.length - offset; if (size < 0) mxRangeError(""out of range byteLength %ld"", size); if (info->value.bufferInfo.maxLength >= 0) size = -1; } view->value.dataView.offset = offset; view->value.dataView.size = size; buffer->kind = XS_REFERENCE_KIND; buffer->value.reference = mxArgv(0)->value.reference; } else if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) { txSlot* sourceDispatch = slot; txSlot* sourceView = sourceDispatch->next; txSlot* sourceBuffer = sourceView->next; txU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift; txInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift; txSlot* sourceData = sourceBuffer->value.reference->next; txInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size; txInteger sourceOffset = sourceView->value.dataView.offset; txInteger offset = 0; txInteger size = sourceLength << shift; mxPushUninitialized(); mxPush(mxArrayBufferConstructor); if (sourceData->kind == XS_ARRAY_BUFFER_KIND) { mxPushSlot(sourceBuffer); mxGetID(mxID(_constructor)); fxToSpeciesConstructor(the, &mxArrayBufferConstructor); } else mxPush(mxArrayBufferConstructor); mxPushUndefined(); mxPushUninitialized(); mxPushUninitialized(); sourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift; size = sourceLength << shift; mxPushInteger(size); mxRunCount(1); mxPullSlot(buffer); sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift; size = sourceLength << shift; data = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE); view->value.dataView.offset = offset; view->value.dataView.size = size; if (dispatch == sourceDispatch) c_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size); else { txBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array) || (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array); txBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array) || (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array); if (contentType != sourceContentType) mxTypeError(""incompatible content type""); mxPushUndefined(); while (offset < size) { (*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative); (*dispatch->value.typedArray.dispatch->coerce)(the, the->stack); (*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative); sourceOffset += sourceDelta; offset += 1 << shift; } mxPop(); } } else { fx_TypedArray_from_object(the, instance, C_NULL, C_NULL); } } else { txInteger length = fxArgToByteLength(the, 0, 0); if (length & (((1 << shift) - 1) << (32 - shift))) mxRangeError(""out of range byteLength""); length <<= shift; mxPush(mxArrayBufferConstructor); mxNew(); mxPushInteger(length); mxRunCount(1); mxPullSlot(buffer); view->value.dataView.offset = 0; view->value.dataView.size = length; } }","- size <<= shift;
- if (info->value.bufferInfo.length < (offset + size))
- mxRangeError(""out of range byteLength %ld"", size);
+ txInteger delta = size << shift;
+ txInteger end = offset + delta;
+ if ((info->value.bufferInfo.length < end) || (end < offset))
+ mxRangeError(""out of range length %ld"", size);
+ size = delta;","void fx_TypedArray(txMachine* the) { txSlot* instance = fxConstructTypedArray(the); txSlot* dispatch = instance->next; txSlot* view = dispatch->next; txSlot* buffer = view->next; txSlot* data = C_NULL; txU2 shift = dispatch->value.typedArray.dispatch->shift; txSlot* slot; if ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) { slot = mxArgv(0)->value.reference->next; if (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) { txInteger offset = fxArgToByteLength(the, 1, 0); txInteger size; txSlot* info; if (offset & ((1 << shift) - 1)) mxRangeError(""invalid byteOffset %ld"", offset); size = fxArgToByteLength(the, 2, -1); info = fxGetBufferInfo(the, mxArgv(0)); if (size >= 0) { txInteger delta = size << shift; txInteger end = offset + delta; if ((info->value.bufferInfo.length < end) || (end < offset)) mxRangeError(""out of range length %ld"", size); size = delta; } else { if (info->value.bufferInfo.length & ((1 << shift) - 1)) mxRangeError(""invalid byteLength %ld"", info->value.bufferInfo.length); size = info->value.bufferInfo.length - offset; if (size < 0) mxRangeError(""out of range byteLength %ld"", size); if (info->value.bufferInfo.maxLength >= 0) size = -1; } view->value.dataView.offset = offset; view->value.dataView.size = size; buffer->kind = XS_REFERENCE_KIND; buffer->value.reference = mxArgv(0)->value.reference; } else if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) { txSlot* sourceDispatch = slot; txSlot* sourceView = sourceDispatch->next; txSlot* sourceBuffer = sourceView->next; txU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift; txInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift; txSlot* sourceData = sourceBuffer->value.reference->next; txInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size; txInteger sourceOffset = sourceView->value.dataView.offset; txInteger offset = 0; txInteger size = sourceLength << shift; mxPushUninitialized(); mxPush(mxArrayBufferConstructor); if (sourceData->kind == XS_ARRAY_BUFFER_KIND) { mxPushSlot(sourceBuffer); mxGetID(mxID(_constructor)); fxToSpeciesConstructor(the, &mxArrayBufferConstructor); } else mxPush(mxArrayBufferConstructor); mxPushUndefined(); mxPushUninitialized(); mxPushUninitialized(); sourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift; size = sourceLength << shift; mxPushInteger(size); mxRunCount(1); mxPullSlot(buffer); sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift; size = sourceLength << shift; data = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE); view->value.dataView.offset = offset; view->value.dataView.size = size; if (dispatch == sourceDispatch) c_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size); else { txBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array) || (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array); txBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array) || (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array); if (contentType != sourceContentType) mxTypeError(""incompatible content type""); mxPushUndefined(); while (offset < size) { (*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative); (*dispatch->value.typedArray.dispatch->coerce)(the, the->stack); (*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative); sourceOffset += sourceDelta; offset += 1 << shift; } mxPop(); } } else { fx_TypedArray_from_object(the, instance, C_NULL, C_NULL); } } else { txInteger length = fxArgToByteLength(the, 0, 0); if (length & (((1 << shift) - 1) << (32 - shift))) mxRangeError(""out of range byteLength""); length <<= shift; mxPush(mxArrayBufferConstructor); mxNew(); mxPushInteger(length); mxRunCount(1); mxPullSlot(buffer); view->value.dataView.offset = 0; view->value.dataView.size = length; } }"
964,2856----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/common.c----header_put_be_int,"header_put_be_int (SF_PRIVATE *psf, int x) <S2SV_StartVul> { if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4) <S2SV_EndVul> <S2SV_StartVul> { psf->header [psf->headindex++] = (x >> 24) ; <S2SV_EndVul> <S2SV_StartVul> psf->header [psf->headindex++] = (x >> 16) ; <S2SV_EndVul> <S2SV_StartVul> psf->header [psf->headindex++] = (x >> 8) ; <S2SV_EndVul> <S2SV_StartVul> psf->header [psf->headindex++] = x ; <S2SV_EndVul> <S2SV_StartVul> } ; <S2SV_EndVul> }","- { if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
- { psf->header [psf->headindex++] = (x >> 24) ;
- psf->header [psf->headindex++] = (x >> 16) ;
- psf->header [psf->headindex++] = (x >> 8) ;
- psf->header [psf->headindex++] = x ;
- } ;
+ { psf->header.ptr [psf->header.indx++] = (x >> 24) ;
+ psf->header.ptr [psf->header.indx++] = (x >> 16) ;
+ psf->header.ptr [psf->header.indx++] = (x >> 8) ;
+ psf->header.ptr [psf->header.indx++] = x ;","header_put_be_int (SF_PRIVATE *psf, int x) { psf->header.ptr [psf->header.indx++] = (x >> 24) ; psf->header.ptr [psf->header.indx++] = (x >> 16) ; psf->header.ptr [psf->header.indx++] = (x >> 8) ; psf->header.ptr [psf->header.indx++] = x ; }"
965,1685----CWE-416----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-2584--emulate.c----emulate_store_desc_ptr,"static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt, void (*get)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr)) { struct desc_ptr desc_ptr; if (ctxt->mode == X86EMUL_MODE_PROT64) ctxt->op_bytes = 8; get(ctxt, &desc_ptr); if (ctxt->op_bytes == 2) { ctxt->op_bytes = 4; desc_ptr.address &= 0x00ffffff; } ctxt->dst.type = OP_NONE; <S2SV_StartVul> return segmented_write(ctxt, ctxt->dst.addr.mem, <S2SV_EndVul> <S2SV_StartVul> &desc_ptr, 2 + ctxt->op_bytes); <S2SV_EndVul> }","- return segmented_write(ctxt, ctxt->dst.addr.mem,
- &desc_ptr, 2 + ctxt->op_bytes);
+ return segmented_write_std(ctxt, ctxt->dst.addr.mem,
+ &desc_ptr, 2 + ctxt->op_bytes);","static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt, void (*get)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr)) { struct desc_ptr desc_ptr; if (ctxt->mode == X86EMUL_MODE_PROT64) ctxt->op_bytes = 8; get(ctxt, &desc_ptr); if (ctxt->op_bytes == 2) { ctxt->op_bytes = 4; desc_ptr.address &= 0x00ffffff; } ctxt->dst.type = OP_NONE; return segmented_write_std(ctxt, ctxt->dst.addr.mem, &desc_ptr, 2 + ctxt->op_bytes); }"
966,3411----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/locale_methods.c----get_icu_value_internal,"static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale) { char* tag_value = NULL; int32_t tag_value_len = 512; int singletonPos = 0; char* mod_loc_name = NULL; int grOffset = 0; int32_t buflen = 512; UErrorCode status = U_ZERO_ERROR; if( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){ grOffset = findOffset( LOC_GRANDFATHERED , loc_name ); if( grOffset >= 0 ){ if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ return estrdup(loc_name); } else { return NULL; } } if( fromParseLocale==1 ){ if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ if( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){ return estrdup(loc_name); } } <S2SV_StartVul> singletonPos = getSingletonPos( loc_name ); <S2SV_EndVul> if( singletonPos == 0){ return NULL; } else if( singletonPos > 0 ){ mod_loc_name = estrndup ( loc_name , singletonPos-1); } } } if( mod_loc_name == NULL){ <S2SV_StartVul> mod_loc_name = estrdup(loc_name ); <S2SV_EndVul> } do{ tag_value = erealloc( tag_value , buflen ); tag_value_len = buflen; if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){ buflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_LANG_TAG )==0 ){ buflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_REGION_TAG)==0 ){ buflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){ buflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){ buflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status); } if( U_FAILURE( status ) ) { if( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR; continue; } *result = 0; if( tag_value ){ efree( tag_value ); } if( mod_loc_name ){ efree( mod_loc_name); } return NULL; } } while( buflen > tag_value_len ); if( buflen ==0 ){ *result = -1; if( tag_value ){ efree( tag_value ); } if( mod_loc_name ){ efree( mod_loc_name); } return NULL; } else { *result = 1; } if( mod_loc_name ){ efree( mod_loc_name); } return tag_value; }","- singletonPos = getSingletonPos( loc_name );
- mod_loc_name = estrdup(loc_name );
+ singletonPos = getSingletonPos( loc_name );
+ mod_loc_name = estrdup(loc_name );","static char* get_icu_value_internal( const char* loc_name , char* tag_name, int* result , int fromParseLocale) { char* tag_value = NULL; int32_t tag_value_len = 512; int singletonPos = 0; char* mod_loc_name = NULL; int grOffset = 0; int32_t buflen = 512; UErrorCode status = U_ZERO_ERROR; if( strcmp(tag_name, LOC_CANONICALIZE_TAG) != 0 ){ grOffset = findOffset( LOC_GRANDFATHERED , loc_name ); if( grOffset >= 0 ){ if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ return estrdup(loc_name); } else { return NULL; } } if( fromParseLocale==1 ){ if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ if( strlen(loc_name)>1 && (isIDPrefix(loc_name) == 1) ){ return estrdup(loc_name); } } singletonPos = getSingletonPos( loc_name ); if( singletonPos == 0){ return NULL; } else if( singletonPos > 0 ){ mod_loc_name = estrndup ( loc_name , singletonPos-1); } } } if( mod_loc_name == NULL){ mod_loc_name = estrdup(loc_name ); } do{ tag_value = erealloc( tag_value , buflen ); tag_value_len = buflen; if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){ buflen = uloc_getScript ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_LANG_TAG )==0 ){ buflen = uloc_getLanguage ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_REGION_TAG)==0 ){ buflen = uloc_getCountry ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){ buflen = uloc_getVariant ( mod_loc_name ,tag_value , tag_value_len , &status); } if( strcmp(tag_name , LOC_CANONICALIZE_TAG)==0 ){ buflen = uloc_canonicalize ( mod_loc_name ,tag_value , tag_value_len , &status); } if( U_FAILURE( status ) ) { if( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR; buflen++; continue; } *result = 0; if( tag_value ){ efree( tag_value ); } if( mod_loc_name ){ efree( mod_loc_name); } return NULL; } } while( buflen > tag_value_len ); if( buflen ==0 ){ *result = -1; if( tag_value ){ efree( tag_value ); } if( mod_loc_name ){ efree( mod_loc_name); } return NULL; } else { *result = 1; } if( mod_loc_name ){ efree( mod_loc_name); } return tag_value; }"
967,2675----CWE-617----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/resource_handle.cc----tensorflow::ResourceHandle::ResourceHandle,ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) { <S2SV_StartVul> FromProto(proto); <S2SV_EndVul> },"- FromProto(proto);
+ TF_CHECK_OK(FromProto(proto));
+ }",ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) { TF_CHECK_OK(FromProto(proto)); }
968,5645----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/class.c----mrb_remove_method,"mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid) { mt_tbl *h; MRB_CLASS_ORIGIN(c); h = c->mt; <S2SV_StartVul> if (h && mt_del(mrb, h, mid)) return; <S2SV_EndVul> mrb_name_error(mrb, mid, ""method '%n' not defined in %C"", mid, c); }","- if (h && mt_del(mrb, h, mid)) return;
+ if (h && mt_del(mrb, h, mid)) {
+ mrb_mc_clear_by_class(mrb, c);
+ return;
+ }","mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid) { mt_tbl *h; MRB_CLASS_ORIGIN(c); h = c->mt; if (h && mt_del(mrb, h, mid)) { mrb_mc_clear_by_class(mrb, c); return; } mrb_name_error(mrb, mid, ""method '%n' not defined in %C"", mid, c); }"
969,5323----CWE-787----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/qpaintengineex.cpp----QPaintEngineEx::stroke,"void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) { #ifdef QT_DEBUG_DRAW qDebug() << ""QPaintEngineEx::stroke()"" << pen; #endif Q_D(QPaintEngineEx); if (path.isEmpty()) return; if (!d->strokeHandler) { d->strokeHandler = new StrokeHandler(path.elementCount()+4); d->stroker.setMoveToHook(qpaintengineex_moveTo); d->stroker.setLineToHook(qpaintengineex_lineTo); d->stroker.setCubicToHook(qpaintengineex_cubicTo); } QRectF clipRect; QPen pen = inPen; if (pen.style() > Qt::SolidLine) { QRectF cpRect = path.controlPointRect(); const QTransform &xf = state()->matrix; if (pen.isCosmetic()) { clipRect = d->exDeviceRect; cpRect.translate(xf.dx(), xf.dy()); } else { clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect)); } QRectF extentRect = cpRect & clipRect; qreal extent = qMax(extentRect.width(), extentRect.height()); qreal patternLength = 0; const QList<qreal> pattern = pen.dashPattern(); const int patternSize = qMin(pattern.size(), 32); for (int i = 0; i < patternSize; i++) patternLength += qMax(pattern.at(i), qreal(0)); if (pen.widthF()) patternLength *= pen.widthF(); if (qFuzzyIsNull(patternLength)) { pen.setStyle(Qt::NoPen); <S2SV_StartVul> } else if (extent / patternLength > 10000) { <S2SV_EndVul> pen.setStyle(Qt::SolidLine); QColor color(pen.color()); color.setAlpha(color.alpha() / 2); pen.setColor(color); } } if (!qpen_fast_equals(pen, d->strokerPen)) { d->strokerPen = pen; d->stroker.setJoinStyle(pen.joinStyle()); d->stroker.setCapStyle(pen.capStyle()); d->stroker.setMiterLimit(pen.miterLimit()); qreal penWidth = pen.widthF(); if (penWidth == 0) d->stroker.setStrokeWidth(1); else d->stroker.setStrokeWidth(penWidth); Qt::PenStyle style = pen.style(); if (style == Qt::SolidLine) { d->activeStroker = &d->stroker; } else if (style == Qt::NoPen) { d->activeStroker = nullptr; } else { d->dasher.setDashPattern(pen.dashPattern()); d->dasher.setDashOffset(pen.dashOffset()); d->activeStroker = &d->dasher; } } if (!d->activeStroker) { return; } if (!clipRect.isNull()) d->activeStroker->setClipRect(clipRect); if (d->activeStroker == &d->stroker) d->stroker.setForceOpen(path.hasExplicitOpen()); const QPainterPath::ElementType *types = path.elements(); const qreal *points = path.points(); int pointCount = path.elementCount(); const qreal *lastPoint = points + (pointCount<<1); d->strokeHandler->types.reset(); d->strokeHandler->pts.reset(); uint flags = QVectorPath::WindingFill; if (path.elementCount() > 2) flags |= QVectorPath::NonConvexShapeMask; if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin) flags |= QVectorPath::CurvedShapeMask; if (!pen.isCosmetic()) { d->activeStroker->setCurveThresholdFromTransform(state()->matrix); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: d->activeStroker->moveTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::LineToElement: d->activeStroker->lineTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::CurveToElement: d->activeStroker->cubicTo(points[0], points[1], points[2], points[3], points[4], points[5]); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; default: break; } } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } else { d->activeStroker->moveTo(points[0], points[1]); points += 2; while (points < lastPoint) { d->activeStroker->lineTo(points[0], points[1]); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } d->activeStroker->end(); if (!d->strokeHandler->types.size()) return; QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); fill(strokePath, pen.brush()); } else { if (state()->matrix.type() >= QTransform::TxProject) { QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath()); d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform()); } else { d->activeStroker->setCurveThresholdFromTransform(QTransform()); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->moveTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::LineToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::CurveToElement: { QPointF c1 = ((const QPointF *) points)[0] * state()->matrix; QPointF c2 = ((const QPointF *) points)[1] * state()->matrix; QPointF e = ((const QPointF *) points)[2] * state()->matrix; d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y()); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; } default: break; } } if (path.hasImplicitClose()) { QPointF pt = * ((const QPointF *) path.points()) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); } } else { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->moveTo(p.x(), p.y()); points += 2; while (points < lastPoint) { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->lineTo(p.x(), p.y()); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(p.x(), p.y()); } d->activeStroker->end(); } QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); QTransform xform = state()->matrix; state()->matrix = QTransform(); transformChanged(); QBrush brush = pen.brush(); if (qbrush_style(brush) != Qt::SolidPattern) brush.setTransform(brush.transform() * xform); fill(strokePath, brush); state()->matrix = xform; transformChanged(); } }","- } else if (extent / patternLength > 10000) {
+ } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) {","void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) { #ifdef QT_DEBUG_DRAW qDebug() << ""QPaintEngineEx::stroke()"" << pen; #endif Q_D(QPaintEngineEx); if (path.isEmpty()) return; if (!d->strokeHandler) { d->strokeHandler = new StrokeHandler(path.elementCount()+4); d->stroker.setMoveToHook(qpaintengineex_moveTo); d->stroker.setLineToHook(qpaintengineex_lineTo); d->stroker.setCubicToHook(qpaintengineex_cubicTo); } QRectF clipRect; QPen pen = inPen; if (pen.style() > Qt::SolidLine) { QRectF cpRect = path.controlPointRect(); const QTransform &xf = state()->matrix; if (pen.isCosmetic()) { clipRect = d->exDeviceRect; cpRect.translate(xf.dx(), xf.dy()); } else { clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect)); } QRectF extentRect = cpRect & clipRect; qreal extent = qMax(extentRect.width(), extentRect.height()); qreal patternLength = 0; const QList<qreal> pattern = pen.dashPattern(); const int patternSize = qMin(pattern.size(), 32); for (int i = 0; i < patternSize; i++) patternLength += qMax(pattern.at(i), qreal(0)); if (pen.widthF()) patternLength *= pen.widthF(); if (qFuzzyIsNull(patternLength)) { pen.setStyle(Qt::NoPen); } else if (qFuzzyIsNull(extent) || extent / patternLength > 10000) { pen.setStyle(Qt::SolidLine); QColor color(pen.color()); color.setAlpha(color.alpha() / 2); pen.setColor(color); } } if (!qpen_fast_equals(pen, d->strokerPen)) { d->strokerPen = pen; d->stroker.setJoinStyle(pen.joinStyle()); d->stroker.setCapStyle(pen.capStyle()); d->stroker.setMiterLimit(pen.miterLimit()); qreal penWidth = pen.widthF(); if (penWidth == 0) d->stroker.setStrokeWidth(1); else d->stroker.setStrokeWidth(penWidth); Qt::PenStyle style = pen.style(); if (style == Qt::SolidLine) { d->activeStroker = &d->stroker; } else if (style == Qt::NoPen) { d->activeStroker = nullptr; } else { d->dasher.setDashPattern(pen.dashPattern()); d->dasher.setDashOffset(pen.dashOffset()); d->activeStroker = &d->dasher; } } if (!d->activeStroker) { return; } if (!clipRect.isNull()) d->activeStroker->setClipRect(clipRect); if (d->activeStroker == &d->stroker) d->stroker.setForceOpen(path.hasExplicitOpen()); const QPainterPath::ElementType *types = path.elements(); const qreal *points = path.points(); int pointCount = path.elementCount(); const qreal *lastPoint = points + (pointCount<<1); d->strokeHandler->types.reset(); d->strokeHandler->pts.reset(); uint flags = QVectorPath::WindingFill; if (path.elementCount() > 2) flags |= QVectorPath::NonConvexShapeMask; if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin) flags |= QVectorPath::CurvedShapeMask; if (!pen.isCosmetic()) { d->activeStroker->setCurveThresholdFromTransform(state()->matrix); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: d->activeStroker->moveTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::LineToElement: d->activeStroker->lineTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::CurveToElement: d->activeStroker->cubicTo(points[0], points[1], points[2], points[3], points[4], points[5]); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; default: break; } } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } else { d->activeStroker->moveTo(points[0], points[1]); points += 2; while (points < lastPoint) { d->activeStroker->lineTo(points[0], points[1]); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } d->activeStroker->end(); if (!d->strokeHandler->types.size()) return; QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); fill(strokePath, pen.brush()); } else { if (state()->matrix.type() >= QTransform::TxProject) { QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath()); d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform()); } else { d->activeStroker->setCurveThresholdFromTransform(QTransform()); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->moveTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::LineToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::CurveToElement: { QPointF c1 = ((const QPointF *) points)[0] * state()->matrix; QPointF c2 = ((const QPointF *) points)[1] * state()->matrix; QPointF e = ((const QPointF *) points)[2] * state()->matrix; d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y()); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; } default: break; } } if (path.hasImplicitClose()) { QPointF pt = * ((const QPointF *) path.points()) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); } } else { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->moveTo(p.x(), p.y()); points += 2; while (points < lastPoint) { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->lineTo(p.x(), p.y()); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(p.x(), p.y()); } d->activeStroker->end(); } QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); QTransform xform = state()->matrix; state()->matrix = QTransform(); transformChanged(); QBrush brush = pen.brush(); if (qbrush_style(brush) != Qt::SolidPattern) brush.setTransform(brush.transform() * xform); fill(strokePath, brush); state()->matrix = xform; transformChanged(); } }"
970,5950----CWE-369----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/dsdiff.c----ParseDsdiffHeaderConfig,"int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t infilesize, total_samples; DFFFileHeader dff_file_header; DFFChunkHeader dff_chunk_header; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&dff_file_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) || bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1 WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) { error_line (""%s is not a valid .DFF file (by total size)!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize); #endif while (1) { if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) || bcount != sizeof (DFFChunkHeader)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (debug_logging_mode) error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize); if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) { uint32_t version; if (dff_chunk_header.ckDataSize != sizeof (version) || !DoReadFile (infile, &version, sizeof (version), &bcount) || bcount != sizeof (version)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &version, sizeof (version))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&version, ""L""); if (debug_logging_mode) error_line (""dsdiff file version = 0x%08x"", version); } else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) { char *prop_chunk; if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize); prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize); if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) || bcount != dff_chunk_header.ckDataSize) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (prop_chunk); return WAVPACK_SOFT_ERROR; } if (!strncmp (prop_chunk, ""SND "", 4)) { char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize; <S2SV_StartVul> uint16_t numChannels, chansSpecified, chanMask = 0; <S2SV_EndVul> uint32_t sampleRate; while (eptr - cptr >= sizeof (dff_chunk_header)) { memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header)); cptr += sizeof (dff_chunk_header); WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) { if (!strncmp (dff_chunk_header.ckID, ""FS "", 4) && dff_chunk_header.ckDataSize == 4) { memcpy (&sampleRate, cptr, sizeof (sampleRate)); WavpackBigEndianToNative (&sampleRate, ""L""); cptr += dff_chunk_header.ckDataSize; if (debug_logging_mode) error_line (""got sample rate of %u Hz"", sampleRate); } else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) { memcpy (&numChannels, cptr, sizeof (numChannels)); WavpackBigEndianToNative (&numChannels, ""S""); cptr += sizeof (numChannels); chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4; <S2SV_StartVul> if (numChannels < chansSpecified || numChannels < 1) { <S2SV_EndVul> error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } while (chansSpecified--) { if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4)) chanMask |= 0x1; else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4)) chanMask |= 0x2; else if (!strncmp (cptr, ""LS "", 4)) chanMask |= 0x10; else if (!strncmp (cptr, ""RS "", 4)) chanMask |= 0x20; else if (!strncmp (cptr, ""C "", 4)) chanMask |= 0x4; else if (!strncmp (cptr, ""LFE "", 4)) chanMask |= 0x8; else if (debug_logging_mode) error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]); cptr += 4; } if (debug_logging_mode) error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask); } else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) { if (strncmp (cptr, ""DSD "", 4)) { error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"", cptr [0], cptr [1], cptr [2], cptr [3]); free (prop_chunk); return WAVPACK_SOFT_ERROR; } cptr += dff_chunk_header.ckDataSize; } else { if (debug_logging_mode) error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); cptr += dff_chunk_header.ckDataSize; } } else { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } } if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this DSDIFF file already has channel order information!""); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (chanMask) config->channel_mask = chanMask; config->bits_per_sample = 8; config->bytes_per_sample = 1; config->num_channels = numChannels; config->sample_rate = sampleRate / 8; config->qmode |= QMODE_DSD_MSB_FIRST; } else if (debug_logging_mode) error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"", prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize); free (prop_chunk); } else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) { total_samples = dff_chunk_header.ckDataSize / config->num_channels; break; } else { int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1); char *buff; if (bytes_to_copy < 0 || bytes_to_copy > 4194304) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (debug_logging_mode) error_line (""setting configuration with %lld samples"", total_samples); if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }","- uint16_t numChannels, chansSpecified, chanMask = 0;
- if (numChannels < chansSpecified || numChannels < 1) {
+ uint16_t numChannels = 0, chansSpecified, chanMask = 0;
+ if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) {
+ if (!config->num_channels) {
+ error_line (""%s is not a valid .DFF file!"", infilename);
+ return WAVPACK_SOFT_ERROR;
+ }","int ParseDsdiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t infilesize, total_samples; DFFFileHeader dff_file_header; DFFChunkHeader dff_chunk_header; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&dff_file_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &dff_file_header) + 4, sizeof (DFFFileHeader) - 4, &bcount) || bcount != sizeof (DFFFileHeader) - 4) || strncmp (dff_file_header.formType, ""DSD "", 4)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_file_header, sizeof (DFFFileHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1 WavpackBigEndianToNative (&dff_file_header, DFFFileHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && dff_file_header.ckDataSize && dff_file_header.ckDataSize + 1 && dff_file_header.ckDataSize + 12 != infilesize) { error_line (""%s is not a valid .DFF file (by total size)!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""file header indicated length = %lld"", dff_file_header.ckDataSize); #endif while (1) { if (!DoReadFile (infile, &dff_chunk_header, sizeof (DFFChunkHeader), &bcount) || bcount != sizeof (DFFChunkHeader)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &dff_chunk_header, sizeof (DFFChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (debug_logging_mode) error_line (""chunk header indicated length = %lld"", dff_chunk_header.ckDataSize); if (!strncmp (dff_chunk_header.ckID, ""FVER"", 4)) { uint32_t version; if (dff_chunk_header.ckDataSize != sizeof (version) || !DoReadFile (infile, &version, sizeof (version), &bcount) || bcount != sizeof (version)) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &version, sizeof (version))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackBigEndianToNative (&version, ""L""); if (debug_logging_mode) error_line (""dsdiff file version = 0x%08x"", version); } else if (!strncmp (dff_chunk_header.ckID, ""PROP"", 4)) { char *prop_chunk; if (dff_chunk_header.ckDataSize < 4 || dff_chunk_header.ckDataSize > 1024) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } if (debug_logging_mode) error_line (""got PROP chunk of %d bytes total"", (int) dff_chunk_header.ckDataSize); prop_chunk = malloc ((size_t) dff_chunk_header.ckDataSize); if (!DoReadFile (infile, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize, &bcount) || bcount != dff_chunk_header.ckDataSize) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, prop_chunk, (uint32_t) dff_chunk_header.ckDataSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (prop_chunk); return WAVPACK_SOFT_ERROR; } if (!strncmp (prop_chunk, ""SND "", 4)) { char *cptr = prop_chunk + 4, *eptr = prop_chunk + dff_chunk_header.ckDataSize; uint16_t numChannels = 0, chansSpecified, chanMask = 0; uint32_t sampleRate; while (eptr - cptr >= sizeof (dff_chunk_header)) { memcpy (&dff_chunk_header, cptr, sizeof (dff_chunk_header)); cptr += sizeof (dff_chunk_header); WavpackBigEndianToNative (&dff_chunk_header, DFFChunkHeaderFormat); if (dff_chunk_header.ckDataSize > 0 && dff_chunk_header.ckDataSize <= eptr - cptr) { if (!strncmp (dff_chunk_header.ckID, ""FS "", 4) && dff_chunk_header.ckDataSize == 4) { memcpy (&sampleRate, cptr, sizeof (sampleRate)); WavpackBigEndianToNative (&sampleRate, ""L""); cptr += dff_chunk_header.ckDataSize; if (debug_logging_mode) error_line (""got sample rate of %u Hz"", sampleRate); } else if (!strncmp (dff_chunk_header.ckID, ""CHNL"", 4) && dff_chunk_header.ckDataSize >= 2) { memcpy (&numChannels, cptr, sizeof (numChannels)); WavpackBigEndianToNative (&numChannels, ""S""); cptr += sizeof (numChannels); chansSpecified = (int)(dff_chunk_header.ckDataSize - sizeof (numChannels)) / 4; if (numChannels < chansSpecified || numChannels < 1 || numChannels > 256) { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } while (chansSpecified--) { if (!strncmp (cptr, ""SLFT"", 4) || !strncmp (cptr, ""MLFT"", 4)) chanMask |= 0x1; else if (!strncmp (cptr, ""SRGT"", 4) || !strncmp (cptr, ""MRGT"", 4)) chanMask |= 0x2; else if (!strncmp (cptr, ""LS "", 4)) chanMask |= 0x10; else if (!strncmp (cptr, ""RS "", 4)) chanMask |= 0x20; else if (!strncmp (cptr, ""C "", 4)) chanMask |= 0x4; else if (!strncmp (cptr, ""LFE "", 4)) chanMask |= 0x8; else if (debug_logging_mode) error_line (""undefined channel ID %c%c%c%c"", cptr [0], cptr [1], cptr [2], cptr [3]); cptr += 4; } if (debug_logging_mode) error_line (""%d channels, mask = 0x%08x"", numChannels, chanMask); } else if (!strncmp (dff_chunk_header.ckID, ""CMPR"", 4) && dff_chunk_header.ckDataSize >= 4) { if (strncmp (cptr, ""DSD "", 4)) { error_line (""DSDIFF files must be uncompressed, not \""%c%c%c%c\""!"", cptr [0], cptr [1], cptr [2], cptr [3]); free (prop_chunk); return WAVPACK_SOFT_ERROR; } cptr += dff_chunk_header.ckDataSize; } else { if (debug_logging_mode) error_line (""got PROP/SND chunk type \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); cptr += dff_chunk_header.ckDataSize; } } else { error_line (""%s is not a valid .DFF file!"", infilename); free (prop_chunk); return WAVPACK_SOFT_ERROR; } } if (chanMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this DSDIFF file already has channel order information!""); free (prop_chunk); return WAVPACK_SOFT_ERROR; } else if (chanMask) config->channel_mask = chanMask; config->bits_per_sample = 8; config->bytes_per_sample = 1; config->num_channels = numChannels; config->sample_rate = sampleRate / 8; config->qmode |= QMODE_DSD_MSB_FIRST; } else if (debug_logging_mode) error_line (""got unknown PROP chunk type \""%c%c%c%c\"" of %d bytes"", prop_chunk [0], prop_chunk [1], prop_chunk [2], prop_chunk [3], dff_chunk_header.ckDataSize); free (prop_chunk); } else if (!strncmp (dff_chunk_header.ckID, ""DSD "", 4)) { if (!config->num_channels) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } total_samples = dff_chunk_header.ckDataSize / config->num_channels; break; } else { int bytes_to_copy = (int)(((dff_chunk_header.ckDataSize) + 1) & ~(int64_t)1); char *buff; if (bytes_to_copy < 0 || bytes_to_copy > 4194304) { error_line (""%s is not a valid .DFF file!"", infilename); return WAVPACK_SOFT_ERROR; } buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", dff_chunk_header.ckID [0], dff_chunk_header.ckID [1], dff_chunk_header.ckID [2], dff_chunk_header.ckID [3], dff_chunk_header.ckDataSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (debug_logging_mode) error_line (""setting configuration with %lld samples"", total_samples); if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }"
971,1206----CWE-119----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2017-1000249--readelf.c----do_bid_note,"do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type, int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz, size_t noff, size_t doff, int *flags) { if (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 && <S2SV_StartVul> type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) { <S2SV_EndVul> uint8_t desc[20]; const char *btype; uint32_t i; *flags |= FLAGS_DID_BUILD_ID; switch (descsz) { case 8: btype = ""xxHash""; break; case 16: btype = ""md5/uuid""; break; case 20: btype = ""sha1""; break; default: btype = ""unknown""; break; } if (file_printf(ms, "", BuildID[%s]="", btype) == -1) return 1; (void)memcpy(desc, &nbuf[doff], descsz); for (i = 0; i < descsz; i++) if (file_printf(ms, ""%02x"", desc[i]) == -1) return 1; return 1; } return 0; }","- type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {
+ type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {","do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type, int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz, size_t noff, size_t doff, int *flags) { if (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 && type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) { uint8_t desc[20]; const char *btype; uint32_t i; *flags |= FLAGS_DID_BUILD_ID; switch (descsz) { case 8: btype = ""xxHash""; break; case 16: btype = ""md5/uuid""; break; case 20: btype = ""sha1""; break; default: btype = ""unknown""; break; } if (file_printf(ms, "", BuildID[%s]="", btype) == -1) return 1; (void)memcpy(desc, &nbuf[doff], descsz); for (i = 0; i < descsz; i++) if (file_printf(ms, ""%02x"", desc[i]) == -1) return 1; return 1; } return 0; }"
972,2698----CWE-416----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/collective_ops.cc----tensorflow::CollectiveAllToAllV3OpKernel::ComputeAsync,"void ComputeAsync(OpKernelContext* c, DoneCallback done) override { auto col_params = new CollectiveParams(); auto done_with_cleanup = [col_params, done = std::move(done)]() { done(); col_params->Unref(); }; core::RefCountPtr<CollectiveGroupResource> resource; OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource), <S2SV_StartVul> done); <S2SV_EndVul> Tensor group_assignment = c->input(2); OP_REQUIRES_OK_ASYNC( c, FillCollectiveParams(col_params, group_assignment, ALL_TO_ALL_COLLECTIVE, resource.get()), done); col_params->instance.shape = c->input(0).shape(); VLOG(1) << ""CollectiveAllToAll group_size "" << col_params->group.group_size << "" group_key "" << col_params->group.group_key << "" instance_key "" << col_params->instance.instance_key; Tensor* output = nullptr; OP_REQUIRES_OK_ASYNC(c, c->forward_input_or_allocate_output( {0}, 0, col_params->instance.shape, &output), done_with_cleanup); Run(c, col_params, std::move(done_with_cleanup)); }","- done);
+ done_with_cleanup);","void ComputeAsync(OpKernelContext* c, DoneCallback done) override { auto col_params = new CollectiveParams(); auto done_with_cleanup = [col_params, done = std::move(done)]() { done(); col_params->Unref(); }; core::RefCountPtr<CollectiveGroupResource> resource; OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource), done_with_cleanup); Tensor group_assignment = c->input(2); OP_REQUIRES_OK_ASYNC( c, FillCollectiveParams(col_params, group_assignment, ALL_TO_ALL_COLLECTIVE, resource.get()), done); col_params->instance.shape = c->input(0).shape(); VLOG(1) << ""CollectiveAllToAll group_size "" << col_params->group.group_size << "" group_key "" << col_params->group.group_key << "" instance_key "" << col_params->instance.instance_key; Tensor* output = nullptr; OP_REQUIRES_OK_ASYNC(c, c->forward_input_or_allocate_output( {0}, 0, col_params->instance.shape, &output), done_with_cleanup); Run(c, col_params, std::move(done_with_cleanup)); }"
973,205----CWE-310----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2013-6450--t1_enc.c----tls1_change_cipher_state,"int tls1_change_cipher_state(SSL *s, int which) { static const unsigned char empty[]=""""; unsigned char *p,*mac_secret; unsigned char *exp_label; unsigned char tmp1[EVP_MAX_KEY_LENGTH]; unsigned char tmp2[EVP_MAX_KEY_LENGTH]; unsigned char iv1[EVP_MAX_IV_LENGTH*2]; unsigned char iv2[EVP_MAX_IV_LENGTH*2]; unsigned char *ms,*key,*iv; int client_write; EVP_CIPHER_CTX *dd; const EVP_CIPHER *c; #ifndef OPENSSL_NO_COMP const SSL_COMP *comp; #endif const EVP_MD *m; int mac_type; int *mac_secret_size; EVP_MD_CTX *mac_ctx; EVP_PKEY *mac_key; int is_export,n,i,j,k,exp_label_len,cl; int reuse_dd = 0; is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher); c=s->s3->tmp.new_sym_enc; m=s->s3->tmp.new_hash; mac_type = s->s3->tmp.new_mac_pkey_type; #ifndef OPENSSL_NO_COMP comp=s->s3->tmp.new_compression; #endif #ifdef KSSL_DEBUG printf(""tls1_change_cipher_state(which= %d) w/\n"", which); printf(""\talg= %ld/%ld, comp= %p\n"", s->s3->tmp.new_cipher->algorithm_mkey, s->s3->tmp.new_cipher->algorithm_auth, comp); printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c); printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"", c->nid,c->block_size,c->key_len,c->iv_len); printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length); { int i; for (i=0; i<s->s3->tmp.key_block_length; i++) printf(""%02x"", s->s3->tmp.key_block[i]); printf(""\n""); } #endif if (which & SSL3_CC_READ) { if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC) s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM; else s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM; if (s->enc_read_ctx != NULL) reuse_dd = 1; else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL) goto err; else EVP_CIPHER_CTX_init(s->enc_read_ctx); dd= s->enc_read_ctx; mac_ctx=ssl_replace_hash(&s->read_hash,NULL); #ifndef OPENSSL_NO_COMP if (s->expand != NULL) { COMP_CTX_free(s->expand); s->expand=NULL; } if (comp != NULL) { s->expand=COMP_CTX_new(comp->method); if (s->expand == NULL) { SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR); goto err2; } if (s->s3->rrec.comp == NULL) s->s3->rrec.comp=(unsigned char *) OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH); if (s->s3->rrec.comp == NULL) goto err; } #endif if (s->version != DTLS1_VERSION) memset(&(s->s3->read_sequence[0]),0,8); mac_secret= &(s->s3->read_mac_secret[0]); mac_secret_size=&(s->s3->read_mac_secret_size); } else { if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC) s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM; else s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM; <S2SV_StartVul> if (s->enc_write_ctx != NULL) <S2SV_EndVul> reuse_dd = 1; <S2SV_StartVul> else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL) <S2SV_EndVul> goto err; <S2SV_StartVul> else <S2SV_EndVul> <S2SV_StartVul> EVP_CIPHER_CTX_init(s->enc_write_ctx); <S2SV_EndVul> dd= s->enc_write_ctx; <S2SV_StartVul> mac_ctx = ssl_replace_hash(&s->write_hash,NULL); <S2SV_EndVul> #ifndef OPENSSL_NO_COMP if (s->compress != NULL) { s->compress=COMP_CTX_new(comp->method); if (s->compress == NULL) { SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR); goto err2; } } #endif if (s->version != DTLS1_VERSION) memset(&(s->s3->write_sequence[0]),0,8); mac_secret= &(s->s3->write_mac_secret[0]); mac_secret_size = &(s->s3->write_mac_secret_size); } if (reuse_dd) EVP_CIPHER_CTX_cleanup(dd); p=s->s3->tmp.key_block; i=*mac_secret_size=s->s3->tmp.new_mac_secret_size; cl=EVP_CIPHER_key_length(c); j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ? cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl; if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) k = EVP_GCM_TLS_FIXED_IV_LEN; else k=EVP_CIPHER_iv_length(c); if ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) || (which == SSL3_CHANGE_CIPHER_SERVER_READ)) { ms= &(p[ 0]); n=i+i; key= &(p[ n]); n+=j+j; iv= &(p[ n]); n+=k+k; exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST; exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE; client_write=1; } else { n=i; ms= &(p[ n]); n+=i+j; key= &(p[ n]); n+=j+k; iv= &(p[ n]); n+=k; exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST; exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE; client_write=0; } if (n > s->s3->tmp.key_block_length) { SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR); goto err2; } memcpy(mac_secret,ms,i); if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER)) { mac_key = EVP_PKEY_new_mac_key(mac_type, NULL, mac_secret,*mac_secret_size); EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key); EVP_PKEY_free(mac_key); } #ifdef TLS_DEBUG printf(""which = %04X\nmac key="",which); { int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); } #endif if (is_export) { if (!tls1_PRF(ssl_get_algorithm2(s), exp_label,exp_label_len, s->s3->client_random,SSL3_RANDOM_SIZE, s->s3->server_random,SSL3_RANDOM_SIZE, NULL,0,NULL,0, key,j,tmp1,tmp2,EVP_CIPHER_key_length(c))) goto err2; key=tmp1; if (k > 0) { if (!tls1_PRF(ssl_get_algorithm2(s), TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE, s->s3->client_random,SSL3_RANDOM_SIZE, s->s3->server_random,SSL3_RANDOM_SIZE, NULL,0,NULL,0, empty,0,iv1,iv2,k*2)) goto err2; if (client_write) iv=iv1; else iv= &(iv1[k]); } } s->session->key_arg_length=0; #ifdef KSSL_DEBUG { int i; printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n""); printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]); printf(""\n""); printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]); printf(""\n""); } #endif if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) { EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE)); EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv); } else EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE)); if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size) EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY, *mac_secret_size,mac_secret); #ifdef TLS_DEBUG printf(""which = %04X\nkey="",which); { int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); } printf(""\niv=""); { int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); } printf(""\n""); #endif OPENSSL_cleanse(tmp1,sizeof(tmp1)); OPENSSL_cleanse(tmp2,sizeof(tmp1)); OPENSSL_cleanse(iv1,sizeof(iv1)); OPENSSL_cleanse(iv2,sizeof(iv2)); return(1); err: SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE); err2: return(0); }","- if (s->enc_write_ctx != NULL)
- else if ((s->enc_write_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
- else
- EVP_CIPHER_CTX_init(s->enc_write_ctx);
- mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
+ if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
+ else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
+ if (SSL_IS_DTLS(s))
+ {
+ mac_ctx = EVP_MD_CTX_create();
+ if (!mac_ctx)
+ goto err;
+ s->write_hash = mac_ctx;
+ }
+ else
+ mac_ctx = ssl_replace_hash(&s->write_hash,NULL);","int tls1_change_cipher_state(SSL *s, int which) { static const unsigned char empty[]=""""; unsigned char *p,*mac_secret; unsigned char *exp_label; unsigned char tmp1[EVP_MAX_KEY_LENGTH]; unsigned char tmp2[EVP_MAX_KEY_LENGTH]; unsigned char iv1[EVP_MAX_IV_LENGTH*2]; unsigned char iv2[EVP_MAX_IV_LENGTH*2]; unsigned char *ms,*key,*iv; int client_write; EVP_CIPHER_CTX *dd; const EVP_CIPHER *c; #ifndef OPENSSL_NO_COMP const SSL_COMP *comp; #endif const EVP_MD *m; int mac_type; int *mac_secret_size; EVP_MD_CTX *mac_ctx; EVP_PKEY *mac_key; int is_export,n,i,j,k,exp_label_len,cl; int reuse_dd = 0; is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher); c=s->s3->tmp.new_sym_enc; m=s->s3->tmp.new_hash; mac_type = s->s3->tmp.new_mac_pkey_type; #ifndef OPENSSL_NO_COMP comp=s->s3->tmp.new_compression; #endif #ifdef KSSL_DEBUG printf(""tls1_change_cipher_state(which= %d) w/\n"", which); printf(""\talg= %ld/%ld, comp= %p\n"", s->s3->tmp.new_cipher->algorithm_mkey, s->s3->tmp.new_cipher->algorithm_auth, comp); printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c); printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"", c->nid,c->block_size,c->key_len,c->iv_len); printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length); { int i; for (i=0; i<s->s3->tmp.key_block_length; i++) printf(""%02x"", s->s3->tmp.key_block[i]); printf(""\n""); } #endif if (which & SSL3_CC_READ) { if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC) s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM; else s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM; if (s->enc_read_ctx != NULL) reuse_dd = 1; else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL) goto err; else EVP_CIPHER_CTX_init(s->enc_read_ctx); dd= s->enc_read_ctx; mac_ctx=ssl_replace_hash(&s->read_hash,NULL); #ifndef OPENSSL_NO_COMP if (s->expand != NULL) { COMP_CTX_free(s->expand); s->expand=NULL; } if (comp != NULL) { s->expand=COMP_CTX_new(comp->method); if (s->expand == NULL) { SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR); goto err2; } if (s->s3->rrec.comp == NULL) s->s3->rrec.comp=(unsigned char *) OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH); if (s->s3->rrec.comp == NULL) goto err; } #endif if (s->version != DTLS1_VERSION) memset(&(s->s3->read_sequence[0]),0,8); mac_secret= &(s->s3->read_mac_secret[0]); mac_secret_size=&(s->s3->read_mac_secret_size); } else { if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC) s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM; else s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM; if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s)) reuse_dd = 1; else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL) goto err; dd= s->enc_write_ctx; if (SSL_IS_DTLS(s)) { mac_ctx = EVP_MD_CTX_create(); if (!mac_ctx) goto err; s->write_hash = mac_ctx; } else mac_ctx = ssl_replace_hash(&s->write_hash,NULL); #ifndef OPENSSL_NO_COMP if (s->compress != NULL) { s->compress=COMP_CTX_new(comp->method); if (s->compress == NULL) { SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR); goto err2; } } #endif if (s->version != DTLS1_VERSION) memset(&(s->s3->write_sequence[0]),0,8); mac_secret= &(s->s3->write_mac_secret[0]); mac_secret_size = &(s->s3->write_mac_secret_size); } if (reuse_dd) EVP_CIPHER_CTX_cleanup(dd); p=s->s3->tmp.key_block; i=*mac_secret_size=s->s3->tmp.new_mac_secret_size; cl=EVP_CIPHER_key_length(c); j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ? cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl; if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) k = EVP_GCM_TLS_FIXED_IV_LEN; else k=EVP_CIPHER_iv_length(c); if ( (which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) || (which == SSL3_CHANGE_CIPHER_SERVER_READ)) { ms= &(p[ 0]); n=i+i; key= &(p[ n]); n+=j+j; iv= &(p[ n]); n+=k+k; exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST; exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE; client_write=1; } else { n=i; ms= &(p[ n]); n+=i+j; key= &(p[ n]); n+=j+k; iv= &(p[ n]); n+=k; exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST; exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE; client_write=0; } if (n > s->s3->tmp.key_block_length) { SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR); goto err2; } memcpy(mac_secret,ms,i); if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER)) { mac_key = EVP_PKEY_new_mac_key(mac_type, NULL, mac_secret,*mac_secret_size); EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key); EVP_PKEY_free(mac_key); } #ifdef TLS_DEBUG printf(""which = %04X\nmac key="",which); { int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); } #endif if (is_export) { if (!tls1_PRF(ssl_get_algorithm2(s), exp_label,exp_label_len, s->s3->client_random,SSL3_RANDOM_SIZE, s->s3->server_random,SSL3_RANDOM_SIZE, NULL,0,NULL,0, key,j,tmp1,tmp2,EVP_CIPHER_key_length(c))) goto err2; key=tmp1; if (k > 0) { if (!tls1_PRF(ssl_get_algorithm2(s), TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE, s->s3->client_random,SSL3_RANDOM_SIZE, s->s3->server_random,SSL3_RANDOM_SIZE, NULL,0,NULL,0, empty,0,iv1,iv2,k*2)) goto err2; if (client_write) iv=iv1; else iv= &(iv1[k]); } } s->session->key_arg_length=0; #ifdef KSSL_DEBUG { int i; printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n""); printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]); printf(""\n""); printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]); printf(""\n""); } #endif if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE) { EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE)); EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv); } else EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE)); if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size) EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY, *mac_secret_size,mac_secret); #ifdef TLS_DEBUG printf(""which = %04X\nkey="",which); { int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); } printf(""\niv=""); { int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); } printf(""\n""); #endif OPENSSL_cleanse(tmp1,sizeof(tmp1)); OPENSSL_cleanse(tmp2,sizeof(tmp1)); OPENSSL_cleanse(iv1,sizeof(iv1)); OPENSSL_cleanse(iv2,sizeof(iv2)); return(1); err: SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE); err2: return(0); }"
974,269----CWE-189----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2012-2375--nfs4proc.c----__nfs4_get_acl_uncached,"static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) { struct page *pages[NFS4ACL_MAXPAGES] = {NULL, }; struct nfs_getaclargs args = { .fh = NFS_FH(inode), .acl_pages = pages, .acl_len = buflen, }; struct nfs_getaclres res = { .acl_len = buflen, }; void *resp_buf; struct rpc_message msg = { .rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL], .rpc_argp = &args, .rpc_resp = &res, }; int ret = -ENOMEM, npages, i, acl_len = 0; npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT; if (npages == 0) npages = 1; for (i = 0; i < npages; i++) { pages[i] = alloc_page(GFP_KERNEL); if (!pages[i]) goto out_free; } if (npages > 1) { res.acl_scratch = alloc_page(GFP_KERNEL); if (!res.acl_scratch) goto out_free; } args.acl_len = npages * PAGE_SIZE; args.acl_pgbase = 0; if (buf == NULL) res.acl_flags |= NFS4_ACL_LEN_REQUEST; resp_buf = page_address(pages[0]); dprintk(""%s buf %p buflen %zu npages %d args.acl_len %zu\n"", __func__, buf, buflen, npages, args.acl_len); ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0); if (ret) goto out_free; acl_len = res.acl_len - res.acl_data_offset; if (acl_len > args.acl_len) nfs4_write_cached_acl(inode, NULL, acl_len); else nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset, acl_len); if (buf) { ret = -ERANGE; if (acl_len > buflen) goto out_free; _copy_from_pages(buf, pages, res.acl_data_offset, <S2SV_StartVul> res.acl_len); <S2SV_EndVul> } ret = acl_len; out_free: for (i = 0; i < npages; i++) if (pages[i]) __free_page(pages[i]); if (res.acl_scratch) __free_page(res.acl_scratch); return ret; }","- res.acl_len);
+ acl_len);","static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen) { struct page *pages[NFS4ACL_MAXPAGES] = {NULL, }; struct nfs_getaclargs args = { .fh = NFS_FH(inode), .acl_pages = pages, .acl_len = buflen, }; struct nfs_getaclres res = { .acl_len = buflen, }; void *resp_buf; struct rpc_message msg = { .rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL], .rpc_argp = &args, .rpc_resp = &res, }; int ret = -ENOMEM, npages, i, acl_len = 0; npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT; if (npages == 0) npages = 1; for (i = 0; i < npages; i++) { pages[i] = alloc_page(GFP_KERNEL); if (!pages[i]) goto out_free; } if (npages > 1) { res.acl_scratch = alloc_page(GFP_KERNEL); if (!res.acl_scratch) goto out_free; } args.acl_len = npages * PAGE_SIZE; args.acl_pgbase = 0; if (buf == NULL) res.acl_flags |= NFS4_ACL_LEN_REQUEST; resp_buf = page_address(pages[0]); dprintk(""%s buf %p buflen %zu npages %d args.acl_len %zu\n"", __func__, buf, buflen, npages, args.acl_len); ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0); if (ret) goto out_free; acl_len = res.acl_len - res.acl_data_offset; if (acl_len > args.acl_len) nfs4_write_cached_acl(inode, NULL, acl_len); else nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset, acl_len); if (buf) { ret = -ERANGE; if (acl_len > buflen) goto out_free; _copy_from_pages(buf, pages, res.acl_data_offset, acl_len); } ret = acl_len; out_free: for (i = 0; i < npages; i++) if (pages[i]) __free_page(pages[i]); if (res.acl_scratch) __free_page(res.acl_scratch); return ret; }"
975,3410----CWE-125----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/locale_methods.c----get_icu_disp_value_src_php,"<S2SV_StartVul> static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) <S2SV_EndVul> { const char* loc_name = NULL; int loc_name_len = 0; const char* disp_loc_name = NULL; int disp_loc_name_len = 0; int free_loc_name = 0; UChar* disp_name = NULL; int32_t disp_name_len = 0; char* mod_loc_name = NULL; int32_t buflen = 512; UErrorCode status = U_ZERO_ERROR; char* utf8value = NULL; int utf8value_len = 0; char* msg = NULL; int grOffset = 0; intl_error_reset( NULL TSRMLS_CC ); if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"", <S2SV_StartVul> &loc_name, &loc_name_len , <S2SV_EndVul> &disp_loc_name ,&disp_loc_name_len ) == FAILURE) { spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name ); intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, msg , 1 TSRMLS_CC ); efree(msg); RETURN_FALSE; } if(loc_name_len > ULOC_FULLNAME_CAPACITY) { spprintf(&msg , 0, ""locale_get_display_%s : name too long"", tag_name ); intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, msg , 1 TSRMLS_CC ); efree(msg); RETURN_FALSE; } if(loc_name_len == 0) { loc_name = intl_locale_get_default(TSRMLS_C); } if( strcmp(tag_name, DISP_NAME) != 0 ){ grOffset = findOffset( LOC_GRANDFATHERED , loc_name ); if( grOffset >= 0 ){ if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ mod_loc_name = getPreferredTag( loc_name ); } else { RETURN_FALSE; } } } if( mod_loc_name==NULL ){ mod_loc_name = estrdup( loc_name ); } if( !disp_loc_name){ disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C)); free_loc_name = 1; } do{ disp_name = erealloc( disp_name , buflen * sizeof(UChar) ); disp_name_len = buflen; if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ buflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){ buflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){ buflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){ buflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , DISP_NAME)==0 ){ buflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } if( U_FAILURE( status ) ) { if( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR; continue; } spprintf(&msg, 0, ""locale_get_display_%s : unable to get locale %s"", tag_name , tag_name ); intl_error_set( NULL, status, msg , 1 TSRMLS_CC ); efree(msg); if( disp_name){ efree( disp_name ); } if( mod_loc_name){ efree( mod_loc_name ); } if (free_loc_name) { efree((void *)disp_loc_name); disp_loc_name = NULL; } RETURN_FALSE; } } while( buflen > disp_name_len ); if( mod_loc_name){ efree( mod_loc_name ); } if (free_loc_name) { efree((void *)disp_loc_name); disp_loc_name = NULL; } intl_convert_utf16_to_utf8( &utf8value, &utf8value_len, disp_name, buflen, &status ); efree( disp_name ); if( U_FAILURE( status ) ) { spprintf(&msg, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", tag_name , tag_name ); intl_error_set( NULL, status, msg , 1 TSRMLS_CC ); efree(msg); RETURN_FALSE; } RETVAL_STRINGL( utf8value, utf8value_len , FALSE); }","- static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
- &loc_name, &loc_name_len ,
+ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)
+ &loc_name, &loc_name_len ,","static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) { const char* loc_name = NULL; int loc_name_len = 0; const char* disp_loc_name = NULL; int disp_loc_name_len = 0; int free_loc_name = 0; UChar* disp_name = NULL; int32_t disp_name_len = 0; char* mod_loc_name = NULL; int32_t buflen = 512; UErrorCode status = U_ZERO_ERROR; char* utf8value = NULL; int utf8value_len = 0; char* msg = NULL; int grOffset = 0; intl_error_reset( NULL TSRMLS_CC ); if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s|s"", &loc_name, &loc_name_len , &disp_loc_name ,&disp_loc_name_len ) == FAILURE) { spprintf(&msg , 0, ""locale_get_display_%s : unable to parse input params"", tag_name ); intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, msg , 1 TSRMLS_CC ); efree(msg); RETURN_FALSE; } if(loc_name_len > ULOC_FULLNAME_CAPACITY) { spprintf(&msg , 0, ""locale_get_display_%s : name too long"", tag_name ); intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, msg , 1 TSRMLS_CC ); efree(msg); RETURN_FALSE; } if(loc_name_len == 0) { loc_name = intl_locale_get_default(TSRMLS_C); } if( strcmp(tag_name, DISP_NAME) != 0 ){ grOffset = findOffset( LOC_GRANDFATHERED , loc_name ); if( grOffset >= 0 ){ if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ mod_loc_name = getPreferredTag( loc_name ); } else { RETURN_FALSE; } } } if( mod_loc_name==NULL ){ mod_loc_name = estrdup( loc_name ); } if( !disp_loc_name){ disp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C)); free_loc_name = 1; } do{ disp_name = erealloc( disp_name , buflen * sizeof(UChar) ); disp_name_len = buflen; if( strcmp(tag_name , LOC_LANG_TAG)==0 ){ buflen = uloc_getDisplayLanguage ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , LOC_SCRIPT_TAG)==0 ){ buflen = uloc_getDisplayScript ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , LOC_REGION_TAG)==0 ){ buflen = uloc_getDisplayCountry ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , LOC_VARIANT_TAG)==0 ){ buflen = uloc_getDisplayVariant ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } else if( strcmp(tag_name , DISP_NAME)==0 ){ buflen = uloc_getDisplayName ( mod_loc_name , disp_loc_name , disp_name , disp_name_len , &status); } if( U_FAILURE( status ) ) { if( status == U_BUFFER_OVERFLOW_ERROR ) { status = U_ZERO_ERROR; continue; } spprintf(&msg, 0, ""locale_get_display_%s : unable to get locale %s"", tag_name , tag_name ); intl_error_set( NULL, status, msg , 1 TSRMLS_CC ); efree(msg); if( disp_name){ efree( disp_name ); } if( mod_loc_name){ efree( mod_loc_name ); } if (free_loc_name) { efree((void *)disp_loc_name); disp_loc_name = NULL; } RETURN_FALSE; } } while( buflen > disp_name_len ); if( mod_loc_name){ efree( mod_loc_name ); } if (free_loc_name) { efree((void *)disp_loc_name); disp_loc_name = NULL; } intl_convert_utf16_to_utf8( &utf8value, &utf8value_len, disp_name, buflen, &status ); efree( disp_name ); if( U_FAILURE( status ) ) { spprintf(&msg, 0, ""locale_get_display_%s :error converting display name for %s to UTF-8"", tag_name , tag_name ); intl_error_set( NULL, status, msg , 1 TSRMLS_CC ); efree(msg); RETURN_FALSE; } RETVAL_STRINGL( utf8value, utf8value_len , FALSE); }"
976,19----CWE-399----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2015-7540--asn1.c----asn1_write_OctetString,"bool asn1_write_OctetString(struct asn1_data *data, const void *p, size_t length) { <S2SV_StartVul> asn1_push_tag(data, ASN1_OCTET_STRING); <S2SV_EndVul> <S2SV_StartVul> asn1_write(data, p, length); <S2SV_EndVul> <S2SV_StartVul> asn1_pop_tag(data); <S2SV_EndVul> <S2SV_StartVul> return !data->has_error; <S2SV_EndVul> }","- asn1_push_tag(data, ASN1_OCTET_STRING);
- asn1_write(data, p, length);
- asn1_pop_tag(data);
- return !data->has_error;
+ if (!asn1_push_tag(data, ASN1_OCTET_STRING)) return false;
+ if (!asn1_write(data, p, length)) return false;
+ return asn1_pop_tag(data);","bool asn1_write_OctetString(struct asn1_data *data, const void *p, size_t length) { if (!asn1_push_tag(data, ASN1_OCTET_STRING)) return false; if (!asn1_write(data, p, length)) return false; return asn1_pop_tag(data); }"
977,4201----CWE-126----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/scriptfile.c----get_one_sourceline,"get_one_sourceline(source_cookie_T *sp) { garray_T ga; int len; int c; char_u *buf; #ifdef USE_CRNL int has_cr; #endif int have_read = FALSE; ga_init2(&ga, 1, 250); ++sp->sourcing_lnum; for (;;) { if (ga_grow(&ga, 120) == FAIL) break; if (sp->source_from_buf) { if (sp->buf_lnum >= sp->buflines.ga_len) break; ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]); sp->buf_lnum++; if (ga_grow(&ga, 1) == FAIL) break; buf = (char_u *)ga.ga_data; buf[ga.ga_len++] = NUL; } else { buf = (char_u *)ga.ga_data; if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len, sp->fp) == NULL) break; } <S2SV_StartVul> len = ga.ga_len + (int)STRLEN(buf + ga.ga_len); <S2SV_EndVul> #ifdef USE_CRNL if ( (len == 1 || (len >= 2 && buf[len - 2] == '\n')) && sp->fileformat == EOL_DOS && buf[len - 1] == Ctrl_Z) { buf[len - 1] = NUL; break; } #endif have_read = TRUE; ga.ga_len = len; if (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\n') continue; if (len >= 1 && buf[len - 1] == '\n') { #ifdef USE_CRNL has_cr = (len >= 2 && buf[len - 2] == '\r'); if (sp->fileformat == EOL_UNKNOWN) { if (has_cr) sp->fileformat = EOL_DOS; else sp->fileformat = EOL_UNIX; } if (sp->fileformat == EOL_DOS) { if (has_cr) { buf[len - 2] = '\n'; --len; --ga.ga_len; } else { if (!sp->error) { msg_source(HL_ATTR(HLF_W)); emsg(_(""W15: Warning: Wrong line separator, ^M may be missing"")); } sp->error = TRUE; sp->fileformat = EOL_UNIX; } } #endif for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--) ; if ((len & 1) != (c & 1)) { ++sp->sourcing_lnum; continue; } buf[len - 1] = NUL; } line_breakcheck(); break; } if (have_read) return (char_u *)ga.ga_data; vim_free(ga.ga_data); return NULL; }","- len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);
+ len = ga.ga_len;
+ len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);","get_one_sourceline(source_cookie_T *sp) { garray_T ga; int len; int c; char_u *buf; #ifdef USE_CRNL int has_cr; #endif int have_read = FALSE; ga_init2(&ga, 1, 250); ++sp->sourcing_lnum; for (;;) { if (ga_grow(&ga, 120) == FAIL) break; if (sp->source_from_buf) { if (sp->buf_lnum >= sp->buflines.ga_len) break; ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]); sp->buf_lnum++; if (ga_grow(&ga, 1) == FAIL) break; buf = (char_u *)ga.ga_data; buf[ga.ga_len++] = NUL; len = ga.ga_len; } else { buf = (char_u *)ga.ga_data; if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len, sp->fp) == NULL) break; len = ga.ga_len + (int)STRLEN(buf + ga.ga_len); } #ifdef USE_CRNL if ( (len == 1 || (len >= 2 && buf[len - 2] == '\n')) && sp->fileformat == EOL_DOS && buf[len - 1] == Ctrl_Z) { buf[len - 1] = NUL; break; } #endif have_read = TRUE; ga.ga_len = len; if (ga.ga_maxlen - ga.ga_len == 1 && buf[len - 1] != '\n') continue; if (len >= 1 && buf[len - 1] == '\n') { #ifdef USE_CRNL has_cr = (len >= 2 && buf[len - 2] == '\r'); if (sp->fileformat == EOL_UNKNOWN) { if (has_cr) sp->fileformat = EOL_DOS; else sp->fileformat = EOL_UNIX; } if (sp->fileformat == EOL_DOS) { if (has_cr) { buf[len - 2] = '\n'; --len; --ga.ga_len; } else { if (!sp->error) { msg_source(HL_ATTR(HLF_W)); emsg(_(""W15: Warning: Wrong line separator, ^M may be missing"")); } sp->error = TRUE; sp->fileformat = EOL_UNIX; } } #endif for (c = len - 2; c >= 0 && buf[c] == Ctrl_V; c--) ; if ((len & 1) != (c & 1)) { ++sp->sourcing_lnum; continue; } buf[len - 1] = NUL; } line_breakcheck(); break; } if (have_read) return (char_u *)ga.ga_data; vim_free(ga.ga_data); return NULL; }"
978,694----CWE-264----F:/邵苗苗_data/Big-Vul/bigvul/vul/CVE-2014-3122--rmap.c----try_to_unmap_cluster,"static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount, struct vm_area_struct *vma, struct page *check_page) { struct mm_struct *mm = vma->vm_mm; pmd_t *pmd; pte_t *pte; pte_t pteval; spinlock_t *ptl; struct page *page; unsigned long address; unsigned long mmun_start; unsigned long mmun_end; unsigned long end; int ret = SWAP_AGAIN; int locked_vma = 0; address = (vma->vm_start + cursor) & CLUSTER_MASK; end = address + CLUSTER_SIZE; if (address < vma->vm_start) address = vma->vm_start; if (end > vma->vm_end) end = vma->vm_end; pmd = mm_find_pmd(mm, address); if (!pmd) return ret; mmun_start = address; mmun_end = end; mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end); if (down_read_trylock(&vma->vm_mm->mmap_sem)) { locked_vma = (vma->vm_flags & VM_LOCKED); if (!locked_vma) up_read(&vma->vm_mm->mmap_sem); } pte = pte_offset_map_lock(mm, pmd, address, &ptl); update_hiwater_rss(mm); for (; address < end; pte++, address += PAGE_SIZE) { if (!pte_present(*pte)) continue; page = vm_normal_page(vma, address, *pte); BUG_ON(!page || PageAnon(page)); if (locked_vma) { <S2SV_StartVul> mlock_vma_page(page); <S2SV_EndVul> <S2SV_StartVul> if (page == check_page) <S2SV_EndVul> ret = SWAP_MLOCK; continue; } if (ptep_clear_flush_young_notify(vma, address, pte)) continue; flush_cache_page(vma, address, pte_pfn(*pte)); pteval = ptep_clear_flush(vma, address, pte); if (page->index != linear_page_index(vma, address)) { pte_t ptfile = pgoff_to_pte(page->index); if (pte_soft_dirty(pteval)) pte_file_mksoft_dirty(ptfile); set_pte_at(mm, address, pte, ptfile); } if (pte_dirty(pteval)) set_page_dirty(page); page_remove_rmap(page); page_cache_release(page); dec_mm_counter(mm, MM_FILEPAGES); (*mapcount)--; } pte_unmap_unlock(pte - 1, ptl); mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end); if (locked_vma) up_read(&vma->vm_mm->mmap_sem); return ret; }","- if (page == check_page)
+ if (page == check_page) {
+ mlock_vma_page(page);
+ } else if (trylock_page(page)) {
+ mlock_vma_page(page);
+ unlock_page(page);
+ }","static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount, struct vm_area_struct *vma, struct page *check_page) { struct mm_struct *mm = vma->vm_mm; pmd_t *pmd; pte_t *pte; pte_t pteval; spinlock_t *ptl; struct page *page; unsigned long address; unsigned long mmun_start; unsigned long mmun_end; unsigned long end; int ret = SWAP_AGAIN; int locked_vma = 0; address = (vma->vm_start + cursor) & CLUSTER_MASK; end = address + CLUSTER_SIZE; if (address < vma->vm_start) address = vma->vm_start; if (end > vma->vm_end) end = vma->vm_end; pmd = mm_find_pmd(mm, address); if (!pmd) return ret; mmun_start = address; mmun_end = end; mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end); if (down_read_trylock(&vma->vm_mm->mmap_sem)) { locked_vma = (vma->vm_flags & VM_LOCKED); if (!locked_vma) up_read(&vma->vm_mm->mmap_sem); } pte = pte_offset_map_lock(mm, pmd, address, &ptl); update_hiwater_rss(mm); for (; address < end; pte++, address += PAGE_SIZE) { if (!pte_present(*pte)) continue; page = vm_normal_page(vma, address, *pte); BUG_ON(!page || PageAnon(page)); if (locked_vma) { if (page == check_page) { mlock_vma_page(page); ret = SWAP_MLOCK; } else if (trylock_page(page)) { mlock_vma_page(page); unlock_page(page); } continue; } if (ptep_clear_flush_young_notify(vma, address, pte)) continue; flush_cache_page(vma, address, pte_pfn(*pte)); pteval = ptep_clear_flush(vma, address, pte); if (page->index != linear_page_index(vma, address)) { pte_t ptfile = pgoff_to_pte(page->index); if (pte_soft_dirty(pteval)) pte_file_mksoft_dirty(ptfile); set_pte_at(mm, address, pte, ptfile); } if (pte_dirty(pteval)) set_page_dirty(page); page_remove_rmap(page); page_cache_release(page); dec_mm_counter(mm, MM_FILEPAGES); (*mapcount)--; } pte_unmap_unlock(pte - 1, ptl); mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end); if (locked_vma) up_read(&vma->vm_mm->mmap_sem); return ret; }"
979,2731----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/mongo.c----mongo_message_create,"<S2SV_StartVul> static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) { <S2SV_EndVul> mongo_message *mm = ( mongo_message * )bson_malloc( len ); if ( !id ) id = rand(); <S2SV_StartVul> mm->head.len = len; <S2SV_EndVul> mm->head.id = id; mm->head.responseTo = responseTo; mm->head.op = op; return mm; }","- static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {
- mm->head.len = len;
+ static mongo_message *mongo_message_create( size_t len , int id , int responseTo , int op ) {
+ mm->head.len = ( int )len;","static mongo_message *mongo_message_create( size_t len , int id , int responseTo , int op ) { mongo_message *mm = ( mongo_message * )bson_malloc( len ); if ( !id ) id = rand(); mm->head.len = ( int )len; mm->head.id = id; mm->head.responseTo = responseTo; mm->head.op = op; return mm; }"
980,3855----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/config.c----requireDirective,"static int requireDirective(MaState *state, cchar *key, cchar *value) { char *age, *type, *rest, *option, *ovalue, *tok; int domains; if (!maTokenize(state, value, ""%S ?*"", &type, &rest)) { return MPR_ERR_BAD_SYNTAX; } if (scaselesscmp(type, ""ability"") == 0) { httpSetAuthRequiredAbilities(state->auth, rest); } else if (scaselesscmp(type, ""group"") == 0 || scaselesscmp(type, ""role"") == 0) { httpSetAuthRequiredAbilities(state->auth, rest); } else if (scaselesscmp(type, ""secure"") == 0) { domains = 0; age = 0; for (option = stok(sclone(rest), "" \t"", &tok); option; option = stok(0, "" \t"", &tok)) { <S2SV_StartVul> option = stok(option, "" =\t,"", &ovalue); <S2SV_EndVul> ovalue = strim(ovalue, ""\""'"", MPR_TRIM_BOTH); if (smatch(option, ""age"")) { age = sfmt(""%lld"", (int64) httpGetTicks(ovalue)); } else if (smatch(option, ""domains"")) { domains = 1; } } if (age) { if (domains) { age = sjoin(""-1"", age, NULL); } } addCondition(state, ""secure"", age, HTTP_ROUTE_STRICT_TLS); } else if (scaselesscmp(type, ""user"") == 0) { httpSetAuthPermittedUsers(state->auth, rest); } else if (scaselesscmp(type, ""valid-user"") == 0) { httpSetAuthAnyValidUser(state->auth); } else { return configError(state, key); } return 0; }","- option = stok(option, "" =\t,"", &ovalue);
+ option = ssplit(option, "" =\t,"", &ovalue);","static int requireDirective(MaState *state, cchar *key, cchar *value) { char *age, *type, *rest, *option, *ovalue, *tok; int domains; if (!maTokenize(state, value, ""%S ?*"", &type, &rest)) { return MPR_ERR_BAD_SYNTAX; } if (scaselesscmp(type, ""ability"") == 0) { httpSetAuthRequiredAbilities(state->auth, rest); } else if (scaselesscmp(type, ""group"") == 0 || scaselesscmp(type, ""role"") == 0) { httpSetAuthRequiredAbilities(state->auth, rest); } else if (scaselesscmp(type, ""secure"") == 0) { domains = 0; age = 0; for (option = stok(sclone(rest), "" \t"", &tok); option; option = stok(0, "" \t"", &tok)) { option = ssplit(option, "" =\t,"", &ovalue); ovalue = strim(ovalue, ""\""'"", MPR_TRIM_BOTH); if (smatch(option, ""age"")) { age = sfmt(""%lld"", (int64) httpGetTicks(ovalue)); } else if (smatch(option, ""domains"")) { domains = 1; } } if (age) { if (domains) { age = sjoin(""-1"", age, NULL); } } addCondition(state, ""secure"", age, HTTP_ROUTE_STRICT_TLS); } else if (scaselesscmp(type, ""user"") == 0) { httpSetAuthPermittedUsers(state->auth, rest); } else if (scaselesscmp(type, ""valid-user"") == 0) { httpSetAuthAnyValidUser(state->auth); } else { return configError(state, key); } return 0; }"
981,6562----NVD-CWE-Other----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/ip6_output.c----ip6_append_data,"int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6, struct rt6_info *rt, unsigned int flags, int dontfrag) { struct inet_sock *inet = inet_sk(sk); struct ipv6_pinfo *np = inet6_sk(sk); struct inet_cork *cork; struct sk_buff *skb; unsigned int maxfraglen, fragheaderlen; int exthdrlen; int hh_len; int mtu; int copy; int err; int offset = 0; int csummode = CHECKSUM_NONE; __u8 tx_flags = 0; if (flags&MSG_PROBE) return 0; cork = &inet->cork.base; if (skb_queue_empty(&sk->sk_write_queue)) { if (opt) { if (WARN_ON(np->cork.opt)) return -EINVAL; np->cork.opt = kmalloc(opt->tot_len, sk->sk_allocation); if (unlikely(np->cork.opt == NULL)) return -ENOBUFS; np->cork.opt->tot_len = opt->tot_len; np->cork.opt->opt_flen = opt->opt_flen; np->cork.opt->opt_nflen = opt->opt_nflen; np->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt, sk->sk_allocation); if (opt->dst0opt && !np->cork.opt->dst0opt) return -ENOBUFS; np->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt, sk->sk_allocation); if (opt->dst1opt && !np->cork.opt->dst1opt) return -ENOBUFS; np->cork.opt->hopopt = ip6_opt_dup(opt->hopopt, sk->sk_allocation); if (opt->hopopt && !np->cork.opt->hopopt) return -ENOBUFS; np->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt, sk->sk_allocation); if (opt->srcrt && !np->cork.opt->srcrt) return -ENOBUFS; } dst_hold(&rt->dst); cork->dst = &rt->dst; inet->cork.fl.u.ip6 = *fl6; np->cork.hop_limit = hlimit; np->cork.tclass = tclass; mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ? rt->dst.dev->mtu : dst_mtu(rt->dst.path); if (np->frag_size < mtu) { if (np->frag_size) mtu = np->frag_size; } cork->fragsize = mtu; if (dst_allfrag(rt->dst.path)) cork->flags |= IPCORK_ALLFRAG; cork->length = 0; sk->sk_sndmsg_page = NULL; sk->sk_sndmsg_off = 0; exthdrlen = rt->dst.header_len + (opt ? opt->opt_flen : 0) - rt->rt6i_nfheader_len; length += exthdrlen; transhdrlen += exthdrlen; } else { rt = (struct rt6_info *)cork->dst; fl6 = &inet->cork.fl.u.ip6; opt = np->cork.opt; transhdrlen = 0; exthdrlen = 0; mtu = cork->fragsize; } hh_len = LL_RESERVED_SPACE(rt->dst.dev); fragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len + (opt ? opt->opt_nflen : 0); maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr); if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) { if (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) { ipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen); return -EMSGSIZE; } } if (sk->sk_type == SOCK_DGRAM) { err = sock_tx_timestamp(sk, &tx_flags); if (err) goto error; } cork->length += length; if (length > mtu) { int proto = sk->sk_protocol; if (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){ ipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen); return -EMSGSIZE; } if (proto == IPPROTO_UDP && (rt->dst.dev->features & NETIF_F_UFO)) { err = ip6_ufo_append_data(sk, getfrag, from, length, hh_len, fragheaderlen, <S2SV_StartVul> transhdrlen, mtu, flags); <S2SV_EndVul> if (err) goto error; return 0; } } if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) goto alloc_new_skb; while (length > 0) { copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len; if (copy < length) copy = maxfraglen - skb->len; if (copy <= 0) { char *data; unsigned int datalen; unsigned int fraglen; unsigned int fraggap; unsigned int alloclen; struct sk_buff *skb_prev; alloc_new_skb: skb_prev = skb; if (skb_prev) fraggap = skb_prev->len - maxfraglen; else fraggap = 0; datalen = length + fraggap; if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen) datalen = maxfraglen - fragheaderlen; fraglen = datalen + fragheaderlen; if ((flags & MSG_MORE) && !(rt->dst.dev->features&NETIF_F_SG)) alloclen = mtu; else alloclen = datalen + fragheaderlen; if (datalen == length + fraggap) alloclen += rt->dst.trailer_len; alloclen += sizeof(struct frag_hdr); if (transhdrlen) { skb = sock_alloc_send_skb(sk, alloclen + hh_len, (flags & MSG_DONTWAIT), &err); } else { skb = NULL; if (atomic_read(&sk->sk_wmem_alloc) <= 2 * sk->sk_sndbuf) skb = sock_wmalloc(sk, alloclen + hh_len, 1, sk->sk_allocation); if (unlikely(skb == NULL)) err = -ENOBUFS; else { tx_flags = 0; } } if (skb == NULL) goto error; skb->ip_summed = csummode; skb->csum = 0; skb_reserve(skb, hh_len+sizeof(struct frag_hdr)); if (sk->sk_type == SOCK_DGRAM) skb_shinfo(skb)->tx_flags = tx_flags; data = skb_put(skb, fraglen); skb_set_network_header(skb, exthdrlen); data += fragheaderlen; skb->transport_header = (skb->network_header + fragheaderlen); if (fraggap) { skb->csum = skb_copy_and_csum_bits( skb_prev, maxfraglen, data + transhdrlen, fraggap, 0); skb_prev->csum = csum_sub(skb_prev->csum, skb->csum); data += fraggap; pskb_trim_unique(skb_prev, maxfraglen); } copy = datalen - transhdrlen - fraggap; if (copy < 0) { err = -EINVAL; kfree_skb(skb); goto error; } else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) { err = -EFAULT; kfree_skb(skb); goto error; } offset += copy; length -= datalen - fraggap; transhdrlen = 0; exthdrlen = 0; csummode = CHECKSUM_NONE; __skb_queue_tail(&sk->sk_write_queue, skb); continue; } if (copy > length) copy = length; if (!(rt->dst.dev->features&NETIF_F_SG)) { unsigned int off; off = skb->len; if (getfrag(from, skb_put(skb, copy), offset, copy, off, skb) < 0) { __skb_trim(skb, off); err = -EFAULT; goto error; } } else { int i = skb_shinfo(skb)->nr_frags; skb_frag_t *frag = &skb_shinfo(skb)->frags[i-1]; struct page *page = sk->sk_sndmsg_page; int off = sk->sk_sndmsg_off; unsigned int left; if (page && (left = PAGE_SIZE - off) > 0) { if (copy >= left) copy = left; if (page != frag->page) { if (i == MAX_SKB_FRAGS) { err = -EMSGSIZE; goto error; } get_page(page); skb_fill_page_desc(skb, i, page, sk->sk_sndmsg_off, 0); frag = &skb_shinfo(skb)->frags[i]; } } else if(i < MAX_SKB_FRAGS) { if (copy > PAGE_SIZE) copy = PAGE_SIZE; page = alloc_pages(sk->sk_allocation, 0); if (page == NULL) { err = -ENOMEM; goto error; } sk->sk_sndmsg_page = page; sk->sk_sndmsg_off = 0; skb_fill_page_desc(skb, i, page, 0, 0); frag = &skb_shinfo(skb)->frags[i]; } else { err = -EMSGSIZE; goto error; } if (getfrag(from, page_address(frag->page)+frag->page_offset+frag->size, offset, copy, skb->len, skb) < 0) { err = -EFAULT; goto error; } sk->sk_sndmsg_off += copy; frag->size += copy; skb->len += copy; skb->data_len += copy; skb->truesize += copy; atomic_add(copy, &sk->sk_wmem_alloc); } offset += copy; length -= copy; } return 0; error: cork->length -= length; IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS); return err; }","- transhdrlen, mtu, flags);
+ transhdrlen, mtu, flags, rt);","int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb), void *from, int length, int transhdrlen, int hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6, struct rt6_info *rt, unsigned int flags, int dontfrag) { struct inet_sock *inet = inet_sk(sk); struct ipv6_pinfo *np = inet6_sk(sk); struct inet_cork *cork; struct sk_buff *skb; unsigned int maxfraglen, fragheaderlen; int exthdrlen; int hh_len; int mtu; int copy; int err; int offset = 0; int csummode = CHECKSUM_NONE; __u8 tx_flags = 0; if (flags&MSG_PROBE) return 0; cork = &inet->cork.base; if (skb_queue_empty(&sk->sk_write_queue)) { if (opt) { if (WARN_ON(np->cork.opt)) return -EINVAL; np->cork.opt = kmalloc(opt->tot_len, sk->sk_allocation); if (unlikely(np->cork.opt == NULL)) return -ENOBUFS; np->cork.opt->tot_len = opt->tot_len; np->cork.opt->opt_flen = opt->opt_flen; np->cork.opt->opt_nflen = opt->opt_nflen; np->cork.opt->dst0opt = ip6_opt_dup(opt->dst0opt, sk->sk_allocation); if (opt->dst0opt && !np->cork.opt->dst0opt) return -ENOBUFS; np->cork.opt->dst1opt = ip6_opt_dup(opt->dst1opt, sk->sk_allocation); if (opt->dst1opt && !np->cork.opt->dst1opt) return -ENOBUFS; np->cork.opt->hopopt = ip6_opt_dup(opt->hopopt, sk->sk_allocation); if (opt->hopopt && !np->cork.opt->hopopt) return -ENOBUFS; np->cork.opt->srcrt = ip6_rthdr_dup(opt->srcrt, sk->sk_allocation); if (opt->srcrt && !np->cork.opt->srcrt) return -ENOBUFS; } dst_hold(&rt->dst); cork->dst = &rt->dst; inet->cork.fl.u.ip6 = *fl6; np->cork.hop_limit = hlimit; np->cork.tclass = tclass; mtu = np->pmtudisc == IPV6_PMTUDISC_PROBE ? rt->dst.dev->mtu : dst_mtu(rt->dst.path); if (np->frag_size < mtu) { if (np->frag_size) mtu = np->frag_size; } cork->fragsize = mtu; if (dst_allfrag(rt->dst.path)) cork->flags |= IPCORK_ALLFRAG; cork->length = 0; sk->sk_sndmsg_page = NULL; sk->sk_sndmsg_off = 0; exthdrlen = rt->dst.header_len + (opt ? opt->opt_flen : 0) - rt->rt6i_nfheader_len; length += exthdrlen; transhdrlen += exthdrlen; } else { rt = (struct rt6_info *)cork->dst; fl6 = &inet->cork.fl.u.ip6; opt = np->cork.opt; transhdrlen = 0; exthdrlen = 0; mtu = cork->fragsize; } hh_len = LL_RESERVED_SPACE(rt->dst.dev); fragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len + (opt ? opt->opt_nflen : 0); maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen - sizeof(struct frag_hdr); if (mtu <= sizeof(struct ipv6hdr) + IPV6_MAXPLEN) { if (cork->length + length > sizeof(struct ipv6hdr) + IPV6_MAXPLEN - fragheaderlen) { ipv6_local_error(sk, EMSGSIZE, fl6, mtu-exthdrlen); return -EMSGSIZE; } } if (sk->sk_type == SOCK_DGRAM) { err = sock_tx_timestamp(sk, &tx_flags); if (err) goto error; } cork->length += length; if (length > mtu) { int proto = sk->sk_protocol; if (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){ ipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen); return -EMSGSIZE; } if (proto == IPPROTO_UDP && (rt->dst.dev->features & NETIF_F_UFO)) { err = ip6_ufo_append_data(sk, getfrag, from, length, hh_len, fragheaderlen, transhdrlen, mtu, flags, rt); if (err) goto error; return 0; } } if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) goto alloc_new_skb; while (length > 0) { copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len; if (copy < length) copy = maxfraglen - skb->len; if (copy <= 0) { char *data; unsigned int datalen; unsigned int fraglen; unsigned int fraggap; unsigned int alloclen; struct sk_buff *skb_prev; alloc_new_skb: skb_prev = skb; if (skb_prev) fraggap = skb_prev->len - maxfraglen; else fraggap = 0; datalen = length + fraggap; if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen) datalen = maxfraglen - fragheaderlen; fraglen = datalen + fragheaderlen; if ((flags & MSG_MORE) && !(rt->dst.dev->features&NETIF_F_SG)) alloclen = mtu; else alloclen = datalen + fragheaderlen; if (datalen == length + fraggap) alloclen += rt->dst.trailer_len; alloclen += sizeof(struct frag_hdr); if (transhdrlen) { skb = sock_alloc_send_skb(sk, alloclen + hh_len, (flags & MSG_DONTWAIT), &err); } else { skb = NULL; if (atomic_read(&sk->sk_wmem_alloc) <= 2 * sk->sk_sndbuf) skb = sock_wmalloc(sk, alloclen + hh_len, 1, sk->sk_allocation); if (unlikely(skb == NULL)) err = -ENOBUFS; else { tx_flags = 0; } } if (skb == NULL) goto error; skb->ip_summed = csummode; skb->csum = 0; skb_reserve(skb, hh_len+sizeof(struct frag_hdr)); if (sk->sk_type == SOCK_DGRAM) skb_shinfo(skb)->tx_flags = tx_flags; data = skb_put(skb, fraglen); skb_set_network_header(skb, exthdrlen); data += fragheaderlen; skb->transport_header = (skb->network_header + fragheaderlen); if (fraggap) { skb->csum = skb_copy_and_csum_bits( skb_prev, maxfraglen, data + transhdrlen, fraggap, 0); skb_prev->csum = csum_sub(skb_prev->csum, skb->csum); data += fraggap; pskb_trim_unique(skb_prev, maxfraglen); } copy = datalen - transhdrlen - fraggap; if (copy < 0) { err = -EINVAL; kfree_skb(skb); goto error; } else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) { err = -EFAULT; kfree_skb(skb); goto error; } offset += copy; length -= datalen - fraggap; transhdrlen = 0; exthdrlen = 0; csummode = CHECKSUM_NONE; __skb_queue_tail(&sk->sk_write_queue, skb); continue; } if (copy > length) copy = length; if (!(rt->dst.dev->features&NETIF_F_SG)) { unsigned int off; off = skb->len; if (getfrag(from, skb_put(skb, copy), offset, copy, off, skb) < 0) { __skb_trim(skb, off); err = -EFAULT; goto error; } } else { int i = skb_shinfo(skb)->nr_frags; skb_frag_t *frag = &skb_shinfo(skb)->frags[i-1]; struct page *page = sk->sk_sndmsg_page; int off = sk->sk_sndmsg_off; unsigned int left; if (page && (left = PAGE_SIZE - off) > 0) { if (copy >= left) copy = left; if (page != frag->page) { if (i == MAX_SKB_FRAGS) { err = -EMSGSIZE; goto error; } get_page(page); skb_fill_page_desc(skb, i, page, sk->sk_sndmsg_off, 0); frag = &skb_shinfo(skb)->frags[i]; } } else if(i < MAX_SKB_FRAGS) { if (copy > PAGE_SIZE) copy = PAGE_SIZE; page = alloc_pages(sk->sk_allocation, 0); if (page == NULL) { err = -ENOMEM; goto error; } sk->sk_sndmsg_page = page; sk->sk_sndmsg_off = 0; skb_fill_page_desc(skb, i, page, 0, 0); frag = &skb_shinfo(skb)->frags[i]; } else { err = -EMSGSIZE; goto error; } if (getfrag(from, page_address(frag->page)+frag->page_offset+frag->size, offset, copy, skb->len, skb) < 0) { err = -EFAULT; goto error; } sk->sk_sndmsg_off += copy; frag->size += copy; skb->len += copy; skb->data_len += copy; skb->truesize += copy; atomic_add(copy, &sk->sk_wmem_alloc); } offset += copy; length -= copy; } return 0; error: cork->length -= length; IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS); return err; }"
982,2897----CWE-190----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/spl_directory.c----spl_filesystem_object_create_type,"static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_filesystem_object *source, int type, zend_class_entry *ce, zval *return_value TSRMLS_DC) { spl_filesystem_object *intern; zend_bool use_include_path = 0; zval *arg1, *arg2; zend_error_handling error_handling; zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC); switch (source->type) { case SPL_FS_INFO: case SPL_FS_FILE: break; case SPL_FS_DIR: if (!source->u.dir.entry.d_name[0]) { zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Could not open file""); zend_restore_error_handling(&error_handling TSRMLS_CC); return NULL; } } switch (type) { case SPL_FS_INFO: ce = ce ? ce : source->info_class; zend_update_class_constants(ce TSRMLS_CC); return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC); Z_TYPE_P(return_value) = IS_OBJECT; spl_filesystem_object_get_file_name(source TSRMLS_CC); if (ce->constructor->common.scope != spl_ce_SplFileInfo) { MAKE_STD_ZVAL(arg1); ZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1); zend_call_method_with_1_params(&return_value, ce, &ce->constructor, ""__construct"", NULL, arg1); zval_ptr_dtor(&arg1); } else { intern->file_name = estrndup(source->file_name, source->file_name_len); intern->file_name_len = source->file_name_len; intern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC); intern->_path = estrndup(intern->_path, intern->_path_len); } break; case SPL_FS_FILE: ce = ce ? ce : source->file_class; zend_update_class_constants(ce TSRMLS_CC); return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC); Z_TYPE_P(return_value) = IS_OBJECT; spl_filesystem_object_get_file_name(source TSRMLS_CC); if (ce->constructor->common.scope != spl_ce_SplFileObject) { MAKE_STD_ZVAL(arg1); MAKE_STD_ZVAL(arg2); ZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1); ZVAL_STRINGL(arg2, ""r"", 1, 1); zend_call_method_with_2_params(&return_value, ce, &ce->constructor, ""__construct"", NULL, arg1, arg2); zval_ptr_dtor(&arg1); zval_ptr_dtor(&arg2); } else { intern->file_name = source->file_name; intern->file_name_len = source->file_name_len; intern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC); intern->_path = estrndup(intern->_path, intern->_path_len); intern->u.file.open_mode = ""r""; intern->u.file.open_mode_len = 1; <S2SV_StartVul> if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"", <S2SV_EndVul> <S2SV_StartVul> &intern->u.file.open_mode, &intern->u.file.open_mode_len, <S2SV_EndVul> &use_include_path, &intern->u.file.zcontext) == FAILURE) { zend_restore_error_handling(&error_handling TSRMLS_CC); intern->u.file.open_mode = NULL; intern->file_name = NULL; zval_dtor(return_value); Z_TYPE_P(return_value) = IS_NULL; return NULL; } if (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) { zend_restore_error_handling(&error_handling TSRMLS_CC); zval_dtor(return_value); Z_TYPE_P(return_value) = IS_NULL; return NULL; } } break; <S2SV_StartVul> case SPL_FS_DIR: <S2SV_EndVul> zend_restore_error_handling(&error_handling TSRMLS_CC); zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Operation not supported""); return NULL; } zend_restore_error_handling(&error_handling TSRMLS_CC); return NULL; }","- if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"",
- &intern->u.file.open_mode, &intern->u.file.open_mode_len,
- case SPL_FS_DIR:
+ if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"",
+ &intern->u.file.open_mode, &intern->u.file.open_mode_len,
+ case SPL_FS_DIR:","static spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_filesystem_object *source, int type, zend_class_entry *ce, zval *return_value TSRMLS_DC) { spl_filesystem_object *intern; zend_bool use_include_path = 0; zval *arg1, *arg2; zend_error_handling error_handling; zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC); switch (source->type) { case SPL_FS_INFO: case SPL_FS_FILE: break; case SPL_FS_DIR: if (!source->u.dir.entry.d_name[0]) { zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Could not open file""); zend_restore_error_handling(&error_handling TSRMLS_CC); return NULL; } } switch (type) { case SPL_FS_INFO: ce = ce ? ce : source->info_class; zend_update_class_constants(ce TSRMLS_CC); return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC); Z_TYPE_P(return_value) = IS_OBJECT; spl_filesystem_object_get_file_name(source TSRMLS_CC); if (ce->constructor->common.scope != spl_ce_SplFileInfo) { MAKE_STD_ZVAL(arg1); ZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1); zend_call_method_with_1_params(&return_value, ce, &ce->constructor, ""__construct"", NULL, arg1); zval_ptr_dtor(&arg1); } else { intern->file_name = estrndup(source->file_name, source->file_name_len); intern->file_name_len = source->file_name_len; intern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC); intern->_path = estrndup(intern->_path, intern->_path_len); } break; case SPL_FS_FILE: ce = ce ? ce : source->file_class; zend_update_class_constants(ce TSRMLS_CC); return_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC); Z_TYPE_P(return_value) = IS_OBJECT; spl_filesystem_object_get_file_name(source TSRMLS_CC); if (ce->constructor->common.scope != spl_ce_SplFileObject) { MAKE_STD_ZVAL(arg1); MAKE_STD_ZVAL(arg2); ZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1); ZVAL_STRINGL(arg2, ""r"", 1, 1); zend_call_method_with_2_params(&return_value, ce, &ce->constructor, ""__construct"", NULL, arg1, arg2); zval_ptr_dtor(&arg1); zval_ptr_dtor(&arg2); } else { intern->file_name = source->file_name; intern->file_name_len = source->file_name_len; intern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC); intern->_path = estrndup(intern->_path, intern->_path_len); intern->u.file.open_mode = ""r""; intern->u.file.open_mode_len = 1; if (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|sbr"", &intern->u.file.open_mode, &intern->u.file.open_mode_len, &use_include_path, &intern->u.file.zcontext) == FAILURE) { zend_restore_error_handling(&error_handling TSRMLS_CC); intern->u.file.open_mode = NULL; intern->file_name = NULL; zval_dtor(return_value); Z_TYPE_P(return_value) = IS_NULL; return NULL; } if (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) { zend_restore_error_handling(&error_handling TSRMLS_CC); zval_dtor(return_value); Z_TYPE_P(return_value) = IS_NULL; return NULL; } } break; case SPL_FS_DIR: zend_restore_error_handling(&error_handling TSRMLS_CC); zend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, ""Operation not supported""); return NULL; } zend_restore_error_handling(&error_handling TSRMLS_CC); return NULL; }"
983,7242----CWE-131----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/count_ops.cc----tensorflow::SparseCount::Compute,"void Compute(OpKernelContext* context) override { const Tensor& indices = context->input(0); const Tensor& values = context->input(1); const Tensor& shape = context->input(2); const Tensor& weights = context->input(3); bool use_weights = weights.NumElements() > 0; OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()), errors::InvalidArgument( ""Input indices must be a 2-dimensional tensor. Got: "", indices.shape().DebugString())); if (use_weights) { OP_REQUIRES( context, weights.shape() == values.shape(), errors::InvalidArgument( ""Weights and values must have the same shape. Weight shape: "", weights.shape().DebugString(), ""; values shape: "", values.shape().DebugString())); } OP_REQUIRES(context, shape.NumElements() != 0, errors::InvalidArgument( ""The shape argument requires at least one element."")); bool is_1d = shape.NumElements() == 1; <S2SV_StartVul> int num_batches = is_1d ? 1 : shape.flat<int64>()(0); <S2SV_EndVul> int num_values = values.NumElements(); OP_REQUIRES(context, num_values == indices.shape().dim_size(0), errors::InvalidArgument( ""Number of values must match first dimension of indices."", ""Got "", num_values, "" values, indices shape: "", indices.shape().DebugString())); const auto indices_values = indices.matrix<int64>(); const auto values_values = values.flat<T>(); const auto weight_values = weights.flat<W>(); auto per_batch_counts = BatchedMap<W>(num_batches); T max_value = 0; for (int idx = 0; idx < num_values; ++idx) { int batch = is_1d ? 0 : indices_values(idx, 0); if (batch >= num_batches) { OP_REQUIRES(context, batch < num_batches, errors::InvalidArgument( ""Indices value along the first dimension must be "", ""lower than the first index of the shape."", ""Got "", batch, "" as batch and "", num_batches, "" as the first dimension of the shape."")); } const auto& value = values_values(idx); if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) { if (binary_output_) { per_batch_counts[batch][value] = 1; } else if (use_weights) { per_batch_counts[batch][value] += weight_values(idx); } else { per_batch_counts[batch][value]++; } if (value > max_value) { max_value = value; } } } int num_output_values = GetOutputSize(max_value, maxlength_, minlength_); OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values, is_1d, context)); }","- int num_batches = is_1d ? 1 : shape.flat<int64>()(0);
+ auto shape_vector = shape.flat<int64>();
+ int num_batches = is_1d ? 1 : shape_vector(0);
+ for (int b = 0; b < shape_vector.size(); b++) {
+ OP_REQUIRES(context, shape_vector(b) >= 0,
+ errors::InvalidArgument(
+ ""Elements in dense_shape must be >= 0. Instead got:"",
+ shape.DebugString()));
+ }","void Compute(OpKernelContext* context) override { const Tensor& indices = context->input(0); const Tensor& values = context->input(1); const Tensor& shape = context->input(2); const Tensor& weights = context->input(3); bool use_weights = weights.NumElements() > 0; OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()), errors::InvalidArgument( ""Input indices must be a 2-dimensional tensor. Got: "", indices.shape().DebugString())); if (use_weights) { OP_REQUIRES( context, weights.shape() == values.shape(), errors::InvalidArgument( ""Weights and values must have the same shape. Weight shape: "", weights.shape().DebugString(), ""; values shape: "", values.shape().DebugString())); } OP_REQUIRES(context, shape.NumElements() != 0, errors::InvalidArgument( ""The shape argument requires at least one element."")); bool is_1d = shape.NumElements() == 1; auto shape_vector = shape.flat<int64>(); int num_batches = is_1d ? 1 : shape_vector(0); int num_values = values.NumElements(); for (int b = 0; b < shape_vector.size(); b++) { OP_REQUIRES(context, shape_vector(b) >= 0, errors::InvalidArgument( ""Elements in dense_shape must be >= 0. Instead got:"", shape.DebugString())); } OP_REQUIRES(context, num_values == indices.shape().dim_size(0), errors::InvalidArgument( ""Number of values must match first dimension of indices."", ""Got "", num_values, "" values, indices shape: "", indices.shape().DebugString())); const auto indices_values = indices.matrix<int64>(); const auto values_values = values.flat<T>(); const auto weight_values = weights.flat<W>(); auto per_batch_counts = BatchedMap<W>(num_batches); T max_value = 0; for (int idx = 0; idx < num_values; ++idx) { int batch = is_1d ? 0 : indices_values(idx, 0); if (batch >= num_batches) { OP_REQUIRES(context, batch < num_batches, errors::InvalidArgument( ""Indices value along the first dimension must be "", ""lower than the first index of the shape."", ""Got "", batch, "" as batch and "", num_batches, "" as the first dimension of the shape."")); } const auto& value = values_values(idx); if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) { if (binary_output_) { per_batch_counts[batch][value] = 1; } else if (use_weights) { per_batch_counts[batch][value] += weight_values(idx); } else { per_batch_counts[batch][value]++; } if (value > max_value) { max_value = value; } } } int num_output_values = GetOutputSize(max_value, maxlength_, minlength_); OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values, is_1d, context)); }"
984,6384----CWE-119----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/libraw_cxx.cpp----LibRaw::dcraw_process,"int LibRaw::dcraw_process(void) { int quality,i; int iterations=-1, dcb_enhance=1, noiserd=0; int eeci_refine_fl=0, es_med_passes_fl=0; float cared=0,cablue=0; float linenoise=0; float lclean=0,cclean=0; float thresh=0; float preser=0; float expos=1.0; CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW); try { int no_crop = 1; if (~O.cropbox[2] && ~O.cropbox[3]) no_crop=0; libraw_decoder_info_t di; get_decoder_info(&di); int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad; raw2image_ex(subtract_inline); <S2SV_StartVul> int save_4color = O.four_color_rgb; <S2SV_EndVul> if (IO.zero_is_bad) { remove_zeroes(); SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES); } if(O.half_size) O.four_color_rgb = 1; if(O.bad_pixels && no_crop) { bad_pixels(O.bad_pixels); SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS); } if (O.dark_frame && no_crop) { subtract (O.dark_frame); SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME); } if (O.wf_debanding) { wf_remove_banding(); } quality = 2 + !IO.fuji_width; if (O.user_qual >= 0) quality = O.user_qual; if(!subtract_inline || !C.data_maximum) { adjust_bl(); subtract_black(); } adjust_maximum(); if (O.user_sat > 0) C.maximum = O.user_sat; if (P1.is_foveon) { if(load_raw == &LibRaw::foveon_dp_load_raw) { for (int i=0; i < S.height*S.width*4; i++) if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0; } else foveon_interpolate(); SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE); } if (O.green_matching && !O.half_size) { green_matching(); } if (!P1.is_foveon) { scale_colors(); SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS); } pre_interpolate(); SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE); if (O.dcb_iterations >= 0) iterations = O.dcb_iterations; if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl; if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd; if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine; if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes; if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);} if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);} if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);} if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);} if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);} if (P1.filters) { if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd); if (quality == 0) lin_interpolate(); else if (quality == 1 || P1.colors > 3 || P1.filters < 1000) vng_interpolate(); else if (quality == 2) ppg_interpolate(); else if (quality == 3) ahd_interpolate(); else if (quality == 4) dcb(iterations, dcb_enhance); else if (quality == 5) ahd_interpolate_mod(); else if (quality == 6) afd_interpolate_pl(2,1); else if (quality == 7) vcd_interpolate(0); else if (quality == 8) vcd_interpolate(12); else if (quality == 9) lmmse_interpolate(1); else if (quality == 10) amaze_demosaic_RT(); else if (quality == 11) dht_interpolate(); else if (quality == 12) aahd_interpolate(); else ahd_interpolate(); SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE); } if (IO.mix_green) { for (P1.colors=3, i=0; i < S.height * S.width; i++) imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1; SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN); } if(!P1.is_foveon) { if (P1.colors == 3) { if (quality == 8) { if (eeci_refine_fl == 1) refinement(); if (O.med_passes > 0) median_filter_new(); if (es_med_passes_fl > 0) es_median_filter(); } else { median_filter(); } SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER); } } if (O.highlight == 2) { blend_highlights(); SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS); } if (O.highlight > 2) { recover_highlights(); SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS); } if (O.use_fuji_rotate) { fuji_rotate(); SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE); } if(!libraw_internal_data.output_data.histogram) { libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4); merror(libraw_internal_data.output_data.histogram,""LibRaw::dcraw_process()""); } #ifndef NO_LCMS if(O.camera_profile) { apply_profile(O.camera_profile,O.output_profile); SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE); } #endif convert_to_rgb(); SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB); if (O.use_fuji_rotate) { stretch(); SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH); } O.four_color_rgb = save_4color; return 0; } catch ( LibRaw_exceptions err) { EXCEPTION_HANDLER(err); } }","- int save_4color = O.four_color_rgb;
+ int save_4color = O.four_color_rgb;","int LibRaw::dcraw_process(void) { int quality,i; int iterations=-1, dcb_enhance=1, noiserd=0; int eeci_refine_fl=0, es_med_passes_fl=0; float cared=0,cablue=0; float linenoise=0; float lclean=0,cclean=0; float thresh=0; float preser=0; float expos=1.0; CHECK_ORDER_LOW(LIBRAW_PROGRESS_LOAD_RAW); try { int no_crop = 1; if (~O.cropbox[2] && ~O.cropbox[3]) no_crop=0; libraw_decoder_info_t di; get_decoder_info(&di); int subtract_inline = !O.bad_pixels && !O.dark_frame && !O.wf_debanding && !(di.decoder_flags & LIBRAW_DECODER_LEGACY) && !IO.zero_is_bad; raw2image_ex(subtract_inline); int save_4color = O.four_color_rgb; if (IO.zero_is_bad) { remove_zeroes(); SET_PROC_FLAG(LIBRAW_PROGRESS_REMOVE_ZEROES); } if(O.half_size) O.four_color_rgb = 1; if(O.bad_pixels && no_crop) { bad_pixels(O.bad_pixels); SET_PROC_FLAG(LIBRAW_PROGRESS_BAD_PIXELS); } if (O.dark_frame && no_crop) { subtract (O.dark_frame); SET_PROC_FLAG(LIBRAW_PROGRESS_DARK_FRAME); } if (O.wf_debanding) { wf_remove_banding(); } quality = 2 + !IO.fuji_width; if (O.user_qual >= 0) quality = O.user_qual; if(!subtract_inline || !C.data_maximum) { adjust_bl(); subtract_black(); } adjust_maximum(); if (O.user_sat > 0) C.maximum = O.user_sat; if (P1.is_foveon) { if(load_raw == &LibRaw::foveon_dp_load_raw) { for (int i=0; i < S.height*S.width*4; i++) if ((short) imgdata.image[0][i] < 0) imgdata.image[0][i] = 0; } else foveon_interpolate(); SET_PROC_FLAG(LIBRAW_PROGRESS_FOVEON_INTERPOLATE); } if (O.green_matching && !O.half_size) { green_matching(); } if (!P1.is_foveon) { scale_colors(); SET_PROC_FLAG(LIBRAW_PROGRESS_SCALE_COLORS); } pre_interpolate(); SET_PROC_FLAG(LIBRAW_PROGRESS_PRE_INTERPOLATE); if (O.dcb_iterations >= 0) iterations = O.dcb_iterations; if (O.dcb_enhance_fl >=0 ) dcb_enhance = O.dcb_enhance_fl; if (O.fbdd_noiserd >=0 ) noiserd = O.fbdd_noiserd; if (O.eeci_refine >=0 ) eeci_refine_fl = O.eeci_refine; if (O.es_med_passes >0 ) es_med_passes_fl = O.es_med_passes; if (!O.half_size && O.cfa_green >0) {thresh=O.green_thresh ;green_equilibrate(thresh);} if (O.exp_correc >0) {expos=O.exp_shift ; preser=O.exp_preser; exp_bef(expos,preser);} if (O.ca_correc >0 ) {cablue=O.cablue; cared=O.cared; CA_correct_RT(cablue, cared);} if (O.cfaline >0 ) {linenoise=O.linenoise; cfa_linedn(linenoise);} if (O.cfa_clean >0 ) {lclean=O.lclean; cclean=O.cclean; cfa_impulse_gauss(lclean,cclean);} if (P1.filters) { if (noiserd>0 && P1.colors==3 && P1.filters) fbdd(noiserd); if (quality == 0) lin_interpolate(); else if (quality == 1 || P1.colors > 3 || P1.filters < 1000) vng_interpolate(); else if (quality == 2) ppg_interpolate(); else if (quality == 3) ahd_interpolate(); else if (quality == 4) dcb(iterations, dcb_enhance); else if (quality == 5) ahd_interpolate_mod(); else if (quality == 6) afd_interpolate_pl(2,1); else if (quality == 7) vcd_interpolate(0); else if (quality == 8) vcd_interpolate(12); else if (quality == 9) lmmse_interpolate(1); else if (quality == 10) amaze_demosaic_RT(); else if (quality == 11) dht_interpolate(); else if (quality == 12) aahd_interpolate(); else ahd_interpolate(); SET_PROC_FLAG(LIBRAW_PROGRESS_INTERPOLATE); } if (IO.mix_green) { for (P1.colors=3, i=0; i < S.height * S.width; i++) imgdata.image[i][1] = (imgdata.image[i][1] + imgdata.image[i][3]) >> 1; SET_PROC_FLAG(LIBRAW_PROGRESS_MIX_GREEN); } if(!P1.is_foveon) { if (P1.colors == 3) { if (quality == 8) { if (eeci_refine_fl == 1) refinement(); if (O.med_passes > 0) median_filter_new(); if (es_med_passes_fl > 0) es_median_filter(); } else { median_filter(); } SET_PROC_FLAG(LIBRAW_PROGRESS_MEDIAN_FILTER); } } if (O.highlight == 2) { blend_highlights(); SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS); } if (O.highlight > 2) { recover_highlights(); SET_PROC_FLAG(LIBRAW_PROGRESS_HIGHLIGHTS); } if (O.use_fuji_rotate) { fuji_rotate(); SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE); } if(!libraw_internal_data.output_data.histogram) { libraw_internal_data.output_data.histogram = (int (*)[LIBRAW_HISTOGRAM_SIZE]) malloc(sizeof(*libraw_internal_data.output_data.histogram)*4); merror(libraw_internal_data.output_data.histogram,""LibRaw::dcraw_process()""); } #ifndef NO_LCMS if(O.camera_profile) { apply_profile(O.camera_profile,O.output_profile); SET_PROC_FLAG(LIBRAW_PROGRESS_APPLY_PROFILE); } #endif convert_to_rgb(); SET_PROC_FLAG(LIBRAW_PROGRESS_CONVERT_RGB); if (O.use_fuji_rotate) { stretch(); SET_PROC_FLAG(LIBRAW_PROGRESS_STRETCH); } O.four_color_rgb = save_4color; return 0; } catch ( LibRaw_exceptions err) { EXCEPTION_HANDLER(err); } }"
985,4142----CWE-20----/home/smm/defect-repair/DPR-main/dpr/data/downloads/my_data/cvefixes/vul/server.cpp----CServer::SendMsg,"int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID) { CNetChunk Packet; if(!pMsg) return -1; <S2SV_StartVul> if(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID)) <S2SV_EndVul> return 0; mem_zero(&Packet, sizeof(CNetChunk)); Packet.m_ClientID = ClientID; Packet.m_pData = pMsg->Data(); Packet.m_DataSize = pMsg->Size(); if(Flags&MSGFLAG_VITAL) Packet.m_Flags |= NETSENDFLAG_VITAL; if(Flags&MSGFLAG_FLUSH) Packet.m_Flags |= NETSENDFLAG_FLUSH; if(!(Flags&MSGFLAG_NORECORD)) m_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size()); if(!(Flags&MSGFLAG_NOSEND)) { if(ClientID == -1) { int i; for(i = 0; i < MAX_CLIENTS; i++) if(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting) { Packet.m_ClientID = i; m_NetServer.Send(&Packet); } } else m_NetServer.Send(&Packet); } return 0; }","- if(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))
+ if(ClientID != -1 && (ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CClient::STATE_EMPTY || m_aClients[ClientID].m_Quitting))","int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID) { CNetChunk Packet; if(!pMsg) return -1; if(ClientID != -1 && (ClientID < 0 || ClientID >= MAX_CLIENTS || m_aClients[ClientID].m_State == CClient::STATE_EMPTY || m_aClients[ClientID].m_Quitting)) return 0; mem_zero(&Packet, sizeof(CNetChunk)); Packet.m_ClientID = ClientID; Packet.m_pData = pMsg->Data(); Packet.m_DataSize = pMsg->Size(); if(Flags&MSGFLAG_VITAL) Packet.m_Flags |= NETSENDFLAG_VITAL; if(Flags&MSGFLAG_FLUSH) Packet.m_Flags |= NETSENDFLAG_FLUSH; if(!(Flags&MSGFLAG_NORECORD)) m_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size()); if(!(Flags&MSGFLAG_NOSEND)) { if(ClientID == -1) { int i; for(i = 0; i < MAX_CLIENTS; i++) if(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting) { Packet.m_ClientID = i; m_NetServer.Send(&Packet); } } else m_NetServer.Send(&Packet); } return 0; }"
